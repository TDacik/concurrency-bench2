// tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_15;

// tag-#anon#ST[U16'encoding'||U16'parity'|]
// file /usr/include/linux/hdlc/ioctl.h line 52
struct anonymous_2;

// tag-#anon#ST[U16'source'||U16'dest'||U16'len'||U16'check'|]
// file /usr/include/netinet/udp.h line 67
struct anonymous_18;

// tag-#anon#ST[U16'uh_sport'||U16'uh_dport'||U16'uh_ulen'||U16'uh_sum'|]
// file /usr/include/netinet/udp.h line 60
struct anonymous_17;

// tag-#anon#ST[U32'clock_rate'||U32'clock_type'||U16'loopback'||U16'_pad0'|]
// file /usr/include/linux/hdlc/ioctl.h line 39
struct anonymous_7;

// tag-#anon#ST[U32'clock_rate'||U32'clock_type'||U16'loopback'||U16'_pad0'||U32'slot_map'|]
// file /usr/include/linux/hdlc/ioctl.h line 45
struct anonymous_8;

// tag-#anon#ST[U32'dlci'|]
// file /usr/include/linux/hdlc/ioctl.h line 67
struct anonymous_5;

// tag-#anon#ST[U32'dlci'||ARR16{S8}_S8_'master'|]
// file /usr/include/linux/hdlc/ioctl.h line 71
struct anonymous_6;

// tag-#anon#ST[U32'interval'||U32'timeout'|]
// file /usr/include/linux/hdlc/ioctl.h line 76
struct anonymous_3;

// tag-#anon#ST[U32't391'||U32't392'||U32'n391'||U32'n392'||U32'n393'||U16'lmi'||U16'dce'|]
// file /usr/include/linux/hdlc/ioctl.h line 57
struct anonymous_4;

// tag-#anon#UN[*{S8}_S8_'ifcu_buf'||*{SYM#tag-ifreq#}_SYM#tag-ifreq#_'ifcu_req'|]
// file /usr/include/linux/if.h line 254
union anonymous_0;

// tag-#anon#UN[*{SYM#tag-#anon#ST[U16'encoding'||U16'parity'|]#}_SYM#tag-#anon#ST[U16'encoding'||U16'parity'|]#_'raw_hdlc'||*{SYM#tag-#anon#ST[U32'interval'||U32'timeout'|]#}_SYM#tag-#anon#ST[U32'interval'||U32'timeout'|]#_'cisco'||*{SYM#tag-#anon#ST[U32't391'||U32't392'||U32'n391'||U32'n392'||U32'n393'||U16'lmi'||U16'dce'|]#}_SYM#tag-#anon#ST[U32't391'||U32't392'||U32'n391'||U32'n392'||U32'n393'||U16'lmi'||U16'dce'|]#_'fr'||*{SYM#tag-#anon#ST[U32'dlci'|]#}_SYM#tag-#anon#ST[U32'dlci'|]#_'fr_pvc'||*{SYM#tag-#anon#ST[U32'dlci'||ARR16{S8}_S8_'master'|]#}_SYM#tag-#anon#ST[U32'dlci'||ARR16{S8}_S8_'master'|]#_'fr_pvc_info'||*{SYM#tag-#anon#ST[U32'clock_rate'||U32'clock_type'||U16'loopback'||U16'_pad0'|]#}_SYM#tag-#anon#ST[U32'clock_rate'||U32'clock_type'||U16'loopback'||U16'_pad0'|]#_'sync'||*{SYM#tag-#anon#ST[U32'clock_rate'||U32'clock_type'||U16'loopback'||U16'_pad0'||U32'slot_map'|]#}_SYM#tag-#anon#ST[U32'clock_rate'||U32'clock_type'||U16'loopback'||U16'_pad0'||U32'slot_map'|]#_'te1'|]
// file /usr/include/linux/if.h line 182
union anonymous_9;

// tag-#anon#UN[ARR16{S8}_S8_'ifrn_name'|]
// file /usr/include/linux/if.h line 205
union anonymous_10;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_1;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous;

// tag-#anon#UN[SYM#tag-#anon#ST[U16'uh_sport'||U16'uh_dport'||U16'uh_ulen'||U16'uh_sum'|]#'_anon0'||SYM#tag-#anon#ST[U16'source'||U16'dest'||U16'len'||U16'check'|]#'_anon1'|]
// file /usr/include/netinet/udp.h line 58
union anonymous_19;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_16;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'||SYM#tag-sockaddr#'ifru_dstaddr'||SYM#tag-sockaddr#'ifru_broadaddr'||SYM#tag-sockaddr#'ifru_netmask'||SYM#tag-sockaddr#'ifru_hwaddr'||S16'ifru_flags'||S32'ifru_ivalue'||S32'ifru_mtu'||SYM#tag-ifmap#'ifru_map'||ARR16{S8}_S8_'ifru_slave'||ARR16{S8}_S8_'ifru_newname'||*{S8}_S8_'ifru_data'|]
// file /usr/include/net/if.h line 135
union anonymous_13;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'||SYM#tag-sockaddr#'ifru_dstaddr'||SYM#tag-sockaddr#'ifru_broadaddr'||SYM#tag-sockaddr#'ifru_netmask'||SYM#tag-sockaddr#'ifru_hwaddr'||S16'ifru_flags'||S32'ifru_ivalue'||S32'ifru_mtu'||SYM#tag-ifmap#'ifru_map'||ARR16{S8}_S8_'ifru_slave'||ARR16{S8}_S8_'ifru_newname'||*{V}_V_'ifru_data'||SYM#tag-if_settings#'ifru_settings'|]
// file /usr/include/linux/if.h line 210
union anonymous_11;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_14;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_20;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-bat_packet
// file batman.h line 202
struct bat_packet;

// tag-batgat_ioc_args
// file posix/../batman.h line 342
struct batgat_ioc_args;

// tag-batman_if
// file batman.h line 220
struct batman_if;

// tag-chunkHeader
// file allocate.c line 38
struct chunkHeader;

// tag-chunkTrailer
// file allocate.c line 48
struct chunkTrailer;

// tag-curr_gw_data
// file posix/../batman.h line 336
struct curr_gw_data;

// tag-debug_clients
// file batman.h line 188
struct debug_clients;

// tag-debug_level_info
// file posix/../batman.h line 331
struct debug_level_info;

// tag-element_t
// file hash.h line 30
struct element_t;

// tag-forw_node
// file batman.h line 249
struct forw_node;

// tag-free_ip
// file posix/../batman.h line 301
struct free_ip;

// tag-gw_client
// file posix/../batman.h line 292
struct gw_client;

// tag-gw_node
// file batman.h line 170
struct gw_node;

// tag-hash_it_t
// file hash.h line 35
struct hash_it_t;

// tag-hashtable_t
// file hash.h line 42
struct hashtable_t;

// tag-hna_element
// file hna.h line 36
struct hna_element;

// tag-hna_global_entry
// file hna.h line 57
struct hna_global_entry;

// tag-hna_local_entry
// file hna.h line 50
struct hna_local_entry;

// tag-hna_orig_ptr
// file hna.h line 65
struct hna_orig_ptr;

// tag-hna_task
// file hna.h line 42
struct hna_task;

// tag-if_settings
// file /usr/include/linux/if.h line 179
struct if_settings;

// tag-ifconf
// file /usr/include/linux/if.h line 252
struct ifconf;

// tag-ifmap
// file /usr/include/linux/if.h line 169
struct ifmap;

// tag-ifreq
// file /usr/include/linux/if.h line 203
struct ifreq;

// tag-ifreq_link1
// file /usr/include/net/if.h line 126
struct ifreq_0;

// tag-ifreq_link2
// file /usr/include/net/if.h line 126
struct ifreq_1;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-iphdr
// file /usr/include/netinet/ip.h line 44
struct iphdr;

// tag-list_head
// file list-batman.h line 45
struct list_head;

// tag-list_head_first
// file list-batman.h line 49
struct list_head_first;

// tag-memoryUsage
// file allocate.c line 57
struct memoryUsage;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-neigh_node
// file batman.h line 219
struct neigh_node;

// tag-nlmsgerr
// file /usr/include/linux/netlink.h line 99
struct nlmsgerr;

// tag-nlmsghdr
// file /usr/include/linux/netlink.h line 42
struct nlmsghdr;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-orig_node
// file batman.h line 216
struct orig_node;

// tag-prof_container
// file profile.h line 40
struct prof_container;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rtattr
// file /usr/include/linux/rtnetlink.h line 156
struct rtattr;

// tag-rtmsg
// file /usr/include/linux/rtnetlink.h line 182
struct rtmsg;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_nl
// file /usr/include/linux/netlink.h line 35
struct sockaddr_nl;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tms
// file /usr/include/x86_64-linux-gnu/sys/times.h line 34
struct tms;

// tag-udphdr
// file /usr/include/netinet/udp.h line 56
struct udphdr;

// tag-unix_client
// file posix/../batman.h line 319
struct unix_client;

// tag-unix_if
// file batman.h line 187
struct unix_if;

// tag-vis_data
// file vis-types.h line 42
struct vis_data;

// tag-vis_if
// file batman.h line 186
struct vis_if;

// tag-vis_packet
// file vis-types.h line 35
struct vis_packet;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __list_add
// file list-batman.c line 34
static void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);
// __list_del
// file list-batman.c line 90
static void __list_del(struct list_head *prev, struct list_head *next);
// _hna_global_add
// file hna.c line 314
static void _hna_global_add(struct orig_node *orig_node, struct hna_element *hna_element);
// _hna_global_del
// file hna.c line 406
static void _hna_global_del(struct orig_node *orig_node, struct hna_element *hna_element);
// _hna_global_hash_del
// file hna.c line 732
static void _hna_global_hash_del(void *data);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// activate_interface
// file posix/init.c line 859
static void activate_interface(struct batman_if *batman_if);
// addMemory
// file allocate.c line 124
static void addMemory(unsigned int length, signed int tag);
// add_default_route
// file os.h line 85
void add_default_route(void);
// add_del_interface_rules
// file linux/route.c line 506
signed int add_del_interface_rules(signed char rule_action);
// add_del_route
// file os.h line 47
void add_del_route(unsigned int dest, unsigned char netmask, unsigned int router, unsigned int src_ip, signed int ifi, char *dev, unsigned char rt_table, signed char route_type, signed char route_action);
// add_del_rule
// file linux/route.c line 357
void add_del_rule(unsigned int network, unsigned char netmask, signed char rt_table, unsigned int prio, char *iif, signed char rule_type, signed char rule_action);
// add_dev_tun
// file linux/tun.c line 171
signed char add_dev_tun(struct batman_if *batman_if, unsigned int tun_addr, char *tun_dev, unsigned long int tun_dev_size, signed int *fd, signed int *ifi);
// add_nat_rule
// file linux/tun.c line 103
void add_nat_rule(char *dev);
// addr_to_string
// file os.h line 36
void addr_to_string(unsigned int addr, char *str, signed int len);
// apply_init_args
// file posix/init.c line 142
void apply_init_args(signed int argc, char **argv);
// bat_wait
// file posix/posix.c line 168
static void bat_wait(signed int T, signed int t);
// batman
// file batman.c line 765
signed char batman(void);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bind_to_iface
// file linux/kernel.c line 149
signed char bind_to_iface(signed int sock, char *dev);
// bit_count
// file bitarray.c line 190
unsigned char bit_count(signed int to_count);
// bit_get_packet
// file bitarray.h line 33
char bit_get_packet(unsigned long int *seq_bits, signed short int seq_num_diff, signed char set_mark);
// bit_init
// file bitarray.c line 32
void bit_init(unsigned long int *seq_bits);
// bit_mark
// file bitarray.h line 31
void bit_mark(unsigned long int *seq_bits, signed int n);
// bit_packet_count
// file bitarray.h line 34
signed int bit_packet_count(unsigned long int *seq_bits);
// bit_shift
// file bitarray.c line 82
void bit_shift(unsigned long int *seq_bits, signed int n);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// checkIntegrity
// file allocate.h line 29
void checkIntegrity(void);
// checkLeak
// file allocate.c line 246
void checkLeak(void);
// checkPadding
// file allocate.c line 112
static signed int checkPadding(unsigned char *padding, unsigned long int length);
// check_active_interfaces
// file posix/init.c line 1040
void check_active_interfaces(void);
// check_inactive_interfaces
// file os.h line 66
void check_inactive_interfaces(void);
// choose_gw
// file batman.c line 217
void choose_gw(void);
// choose_hna
// file hna.c line 47
signed int choose_hna(void *data, signed int size);
// choose_orig
// file originator.h line 30
signed int choose_orig(void *data, signed int size);
// choose_vip
// file posix/tunnel.c line 540
static signed int choose_vip(void *data, signed int size);
// choose_wip
// file posix/tunnel.c line 520
static signed int choose_wip(void *data, signed int size);
// cleanup
// file posix/posix.c line 570
void cleanup(void);
// client_to_gw_tun
// file posix/../os.h line 95
void * client_to_gw_tun(void *arg);
// clock
// file /usr/include/time.h line 189
extern signed long int clock(void);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// compare_hna
// file hna.c line 42
signed int compare_hna(void *data1, void *data2);
// compare_orig
// file originator.h line 29
signed int compare_orig(void *data1, void *data2);
// compare_vip
// file posix/tunnel.c line 513
static signed int compare_vip(void *data1, void *data2);
// compare_wip
// file posix/tunnel.c line 508
static signed int compare_wip(void *data1, void *data2);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// count_real_packets
// file batman.c line 715
static unsigned char count_real_packets(struct bat_packet *in, unsigned int neigh, struct batman_if *if_incoming);
// create_neighbor
// file originator.h line 28
struct neigh_node * create_neighbor(struct orig_node *orig_node, struct orig_node *orig_neigh_node, unsigned int neigh, struct batman_if *if_incoming);
// create_routing_pipe
// file posix/init.c line 92
static void create_routing_pipe(void);
// deactivate_interface
// file os.h line 65
void deactivate_interface(struct batman_if *batman_if);
// debugFree
// file allocate.h line 33
void debugFree(void *memoryParameter, signed int tag);
// debugMalloc
// file allocate.h line 31
void * debugMalloc(unsigned int length, signed int tag);
// debugRealloc
// file allocate.h line 32
void * debugRealloc(void *memoryParameter, unsigned int length, signed int tag);
// debug_orig
// file originator.h line 34
void debug_orig(void);
// debug_output
// file os.h line 100
void debug_output(signed char debug_prio, char *format, ...);
// del_default_route
// file os.h line 84
void del_default_route(void);
// del_dev_tun
// file linux/tun.c line 154
signed char del_dev_tun(signed int fd);
// del_gw_interface
// file posix/posix.c line 428
void del_gw_interface(void);
// del_nat_rule
// file linux/tun.c line 110
void del_nat_rule(char *dev);
// dprintf
// file /usr/include/stdio.h line 415
extern signed int dprintf(signed int, const char *, ...);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// exec_iptables_rule
// file linux/tun.c line 90
void exec_iptables_rule(char *cmd, signed char route_action);
// execl
// file /usr/include/unistd.h line 573
extern signed int execl(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fillPadding
// file allocate.c line 102
static void fillPadding(unsigned char *padding, unsigned long int length);
// flush_routes_rules
// file linux/route.c line 620
signed int flush_routes_rules(signed char is_rule);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fscanf
// file /usr/include/stdio.h line 425
extern signed int fscanf(struct _IO_FILE *, const char *, ...);
// generate_vis_packet
// file batman.c line 629
static void generate_vis_packet(void);
// getHeaderPad
// file allocate.c line 70
static unsigned long int getHeaderPad();
// getTrailerPad
// file allocate.c line 86
static unsigned long int getTrailerPad(unsigned long int length);
// get_bit_status
// file bitarray.h line 29
unsigned char get_bit_status(unsigned long int *seq_bits, unsigned short int last_seqno, unsigned short int curr_seqno);
// get_forwarding
// file os.h line 77
signed int get_forwarding(void);
// get_gw_class
// file batman.c line 496
unsigned char get_gw_class(signed int down, signed int up);
// get_gw_speeds
// file batman.c line 483
void get_gw_speeds(unsigned char gw_class, signed int *down, signed int *up);
// get_integer_file
// file linux/kernel.c line 44
static signed int get_integer_file(const char *filename);
// get_ip_addr
// file posix/tunnel.c line 436
static struct gw_client * get_ip_addr(struct sockaddr_in *client_addr, struct hashtable_t **wip_hash, struct hashtable_t **vip_hash, struct list_head_first *free_ip_list, unsigned char *next_free_ip);
// get_orig_node
// file originator.h line 31
struct orig_node * get_orig_node(unsigned int addr);
// get_rp_filter
// file os.h line 73
signed int get_rp_filter(char *dev);
// get_send_redirects
// file os.h line 75
signed int get_send_redirects(char *dev);
// get_time_msec
// file os.h line 33
unsigned int get_time_msec(void);
// get_time_msec64
// file os.h line 34
unsigned long int get_time_msec64(void);
// get_tun_ip
// file posix/tunnel.c line 99
static signed char get_tun_ip(struct sockaddr_in *gw_addr, signed int udp_sock, unsigned int *tun_addr);
// get_tunneled_protocol
// file posix/tunnel.c line 72
static unsigned char get_tunneled_protocol(const unsigned char *buff);
// get_tunneled_sender_ip
// file posix/tunnel.c line 81
static unsigned int get_tunneled_sender_ip(const unsigned char *buff);
// get_tunneled_udpdest
// file posix/tunnel.c line 90
static unsigned short int get_tunneled_udpdest(const unsigned char *buff);
// getgid
// file /usr/include/unistd.h line 681
extern unsigned int getgid(void);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gw_listen
// file posix/../os.h line 94
void * gw_listen(void *arg);
// handler
// file posix/../os.h line 42
void handler(signed int sig);
// hash_add
// file hash.h line 74
signed int hash_add(struct hashtable_t *hash, void *data);
// hash_add_bucket
// file hash.c line 67
static signed int hash_add_bucket(struct hashtable_t *hash, void *data, struct element_t *bucket, signed int check_duplicate);
// hash_delete
// file hash.c line 41
void hash_delete(struct hashtable_t *hash, void (*free_cb)(void *));

//

// hash_destroy
// file hash.h line 71
void hash_destroy(struct hashtable_t *hash);
// hash_find
// file hash.h line 83
void * hash_find(struct hashtable_t *hash, void *keydata);
// hash_init
// file hash.c line 29
void hash_init(struct hashtable_t *hash);
// hash_iterate
// file hash.h line 93
struct hash_it_t * hash_iterate(struct hashtable_t *hash, struct hash_it_t *iter_in);
// hash_new
// file hash.h line 58
struct hashtable_t * hash_new(signed int size, signed int (*compare)(void *, void *), signed int (*choose)(void *, signed int));
// hash_new::choose_object
//
signed int choose_object(void *, signed int);

//

// hash_remove
// file hash.c line 262
void * hash_remove(struct hashtable_t *hash, void *data);
// hash_remove_bucket
// file hash.h line 63
void * hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t);
// hash_resize
// file hash.h line 86
struct hashtable_t * hash_resize(struct hashtable_t *hash, signed int size);
// hna_buff_delete
// file hna.c line 472
static signed int hna_buff_delete(struct hna_element *buf, signed int *buf_len, struct hna_element *e);
// hna_free
// file hna.c line 749
void hna_free(void);
// hna_global_add
// file hna.h line 80
void hna_global_add(struct orig_node *orig_node, unsigned char *new_hna, signed short int new_hna_len);
// hna_global_check_tq
// file hna.h line 83
void hna_global_check_tq(struct orig_node *orig_node);
// hna_global_del
// file hna.h line 84
void hna_global_del(struct orig_node *orig_node);
// hna_global_update
// file hna.h line 81
void hna_global_update(struct orig_node *orig_node, unsigned char *new_hna, signed short int new_hna_len, struct neigh_node *old_router);
// hna_init
// file hna.c line 66
void hna_init(void);
// hna_local_buffer_fill
// file hna.c line 171
static void hna_local_buffer_fill(void);
// hna_local_task_add_ip
// file hna.c line 84
void hna_local_task_add_ip(unsigned int ip_addr, unsigned short int netmask, unsigned char route_action);
// hna_local_task_add_str
// file hna.c line 106
void hna_local_task_add_str(char *hna_string, unsigned char route_action, unsigned char runtime);
// hna_local_task_exec
// file hna.h line 75
void hna_local_task_exec(void);
// hna_local_update_nat
// file os.h line 56
void hna_local_update_nat(unsigned int hna_ip, unsigned char netmask, signed char route_action);
// hna_local_update_routes
// file hna.c line 302
void hna_local_update_routes(struct hna_local_entry *hna_local_entry, signed char route_action);
// hna_local_update_vis_packet
// file hna.h line 77
unsigned char * hna_local_update_vis_packet(unsigned char *vis_packet, unsigned short int *vis_packet_size);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init_bh_ports
// file posix/../os.h line 93
void init_bh_ports(void);
// init_interface
// file posix/init.c line 1011
void init_interface(struct batman_if *batman_if);
// init_interface_gw
// file posix/init.c line 1060
void init_interface_gw(void);
// interface_listen_sockets
// file posix/init.c line 777
void interface_listen_sockets(void);
// internal_output
// file posix/../os.h line 99
void internal_output(unsigned int sock);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// isBidirectionalNeigh
// file batman.c line 542
static signed int isBidirectionalNeigh(struct orig_node *orig_node, struct orig_node *orig_neigh_node, struct bat_packet *in, unsigned int recv_time, struct batman_if *if_incoming);
// is_aborted
// file os.h line 41
signed char is_aborted(void);
// is_batman_if
// file batman.c line 200
signed int is_batman_if(char *dev, struct batman_if **batman_if);
// is_interface_up
// file posix/init.c line 797
static signed int is_interface_up(char *dev);
// is_wifi_interface
// file linux/kernel.c line 185
signed int is_wifi_interface(char *dev, signed int fd);
// list_add
// file list-batman.c line 49
void list_add(struct list_head *new, struct list_head_first *head);
// list_add_before
// file list-batman.h line 56
void list_add_before(struct list_head *prev_node, struct list_head *next_node, struct list_head *new_node);
// list_add_tail
// file list-batman.h line 55
void list_add_tail(struct list_head *new, struct list_head_first *head);
// list_del
// file list-batman.h line 57
void list_del(struct list_head *prev_entry, struct list_head *entry, struct list_head_first *head);
// list_empty
// file list-batman.h line 58
signed int list_empty(struct list_head_first *head);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// my_daemon
// file posix/init.c line 51
static signed int my_daemon(void);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// print_animation
// file posix/../os.h line 83
void print_animation(void);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// probe_nat_tool
// file linux/tun.c line 86
signed int probe_nat_tool(void);
// probe_tun
// file linux/tun.c line 131
signed char probe_tun(unsigned char print_to_stderr);
// prof_init
// file profile.h line 50
void prof_init(signed int index, char *name);
// prof_print
// file profile.h line 53
void prof_print(void);
// prof_start
// file profile.h line 51
void prof_start(signed int index);
// prof_stop
// file profile.h line 52
void prof_stop(signed int index);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_16 *, const union anonymous *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_16 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous_16 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_16 *);
// purge_orig
// file originator.h line 33
void purge_orig(unsigned int curr_time);
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// rand_num
// file os.h line 35
signed int rand_num(signed int limit);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// receive_packet
// file os.h line 86
signed char receive_packet(unsigned char *packet_buff, signed int packet_buff_len, signed short int *packet_len, unsigned int *neigh, unsigned int timeout, struct batman_if **if_incoming);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int,  struct sockaddr *, unsigned int *);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// removeMemory
// file allocate.c line 157
static void removeMemory(signed int tag, signed int freetag);
// restore_and_exit
// file os.h line 44
void restore_and_exit(unsigned char is_sigsegv);
// restore_defaults
// file posix/../os.h line 89
void restore_defaults(void);
// ring_buffer_avg
// file ring_buffer.h line 30
unsigned char ring_buffer_avg(unsigned char *tq_recv);
// ring_buffer_set
// file ring_buffer.h line 29
void ring_buffer_set(unsigned char *tq_recv, unsigned char *tq_index, unsigned char value);
// run_cmd
// file linux/tun.c line 47
signed int run_cmd(char *cmd);
// schedule_forward_packet
// file schedule.h line 24
void schedule_forward_packet(struct orig_node *orig_node, struct bat_packet *in, unsigned int neigh, unsigned char directlink, signed short int hna_buff_len, struct batman_if *if_incoming, unsigned int curr_time);
// schedule_own_packet
// file schedule.h line 23
void schedule_own_packet(struct batman_if *batman_if);
// segmentation_fault
// file posix/../os.h line 43
void segmentation_fault(signed int sig);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_15 *, struct anonymous_15 *, struct anonymous_15 *, struct timeval *);
// send_outstanding_packets
// file schedule.h line 25
void send_outstanding_packets(unsigned int curr_time);
// send_udp_packet
// file os.h line 87
signed char send_udp_packet(unsigned char *packet_buff, signed int packet_buff_len, struct sockaddr_in *broad, signed int send_sock, struct batman_if *batman_if);
// send_vis_packet
// file batman.c line 707
static void send_vis_packet(void);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int,  struct sockaddr *, unsigned int);
// set_forwarding
// file os.h line 76
void set_forwarding(signed int state);
// set_integer_file
// file linux/kernel.c line 62
static void set_integer_file(const char *filename, signed int integer);
// set_rp_filter
// file os.h line 72
void set_rp_filter(signed int state, char *dev);
// set_send_redirects
// file os.h line 74
void set_send_redirects(signed int state, char *dev);
// set_tun_addr
// file linux/tun.c line 312
signed char set_tun_addr(signed int fd, unsigned int tun_addr, char *tun_dev);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// sym_print
// file posix/posix.c line 129
static void sym_print(char x, char y, char *z);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// times
// file /usr/include/x86_64-linux-gnu/sys/times.h line 48
extern signed long int times(struct tms *);
// times_wrapper
// file posix/posix.c line 57
static signed long int times_wrapper(void);
// unix_listen
// file posix/../os.h line 98
void * unix_listen(void *arg);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_gw_list
// file batman.c line 422
void update_gw_list(struct orig_node *orig_node, unsigned char new_gwflags, unsigned short int gw_port);
// update_internal_clock
// file posix/posix.c line 96
static void update_internal_clock(void);
// update_orig
// file originator.h line 32
void update_orig(struct orig_node *orig_node, struct bat_packet *in, unsigned int neigh, struct batman_if *if_incoming, unsigned char *hna_recv_buff, signed short int hna_buff_len, unsigned char is_duplicate, unsigned int curr_time);
// update_routes
// file batman.c line 344
void update_routes(struct orig_node *orig_node, struct neigh_node *neigh_node, unsigned char *hna_recv_buff, signed short int hna_buff_len);
// usage
// file batman.c line 125
void usage(void);
// use_gateway_module
// file linux/kernel.c line 172
signed int use_gateway_module(void);
// vdprintf
// file /usr/include/stdio.h line 412
extern signed int vdprintf(signed int, const char *, void **);
// verbose_usage
// file batman.c line 148
void verbose_usage(void);
// vprintf
// file /usr/include/stdio.h line 377
extern signed int vprintf(const char *, void **);
// vsyslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 200
extern void vsyslog(signed int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_15
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_2
{
  // encoding
  unsigned short int encoding;
  // parity
  unsigned short int parity;
};

struct anonymous_18
{
  // source
  unsigned short int source;
  // dest
  unsigned short int dest;
  // len
  unsigned short int len;
  // check
  unsigned short int check;
};

struct anonymous_17
{
  // uh_sport
  unsigned short int uh_sport;
  // uh_dport
  unsigned short int uh_dport;
  // uh_ulen
  unsigned short int uh_ulen;
  // uh_sum
  unsigned short int uh_sum;
};

struct anonymous_7
{
  // clock_rate
  unsigned int clock_rate;
  // clock_type
  unsigned int clock_type;
  // loopback
  unsigned short int loopback;
};

struct anonymous_8
{
  // clock_rate
  unsigned int clock_rate;
  // clock_type
  unsigned int clock_type;
  // loopback
  unsigned short int loopback;
  // slot_map
  unsigned int slot_map;
};

struct anonymous_5
{
  // dlci
  unsigned int dlci;
};

struct anonymous_6
{
  // dlci
  unsigned int dlci;
  // master
  char master[16l];
};

struct anonymous_3
{
  // interval
  unsigned int interval;
  // timeout
  unsigned int timeout;
};

struct anonymous_4
{
  // t391
  unsigned int t391;
  // t392
  unsigned int t392;
  // n391
  unsigned int n391;
  // n392
  unsigned int n392;
  // n393
  unsigned int n393;
  // lmi
  unsigned short int lmi;
  // dce
  unsigned short int dce;
};

union anonymous_0
{
  // ifcu_buf
  char *ifcu_buf;
  // ifcu_req
  struct ifreq *ifcu_req;
};

union anonymous_9
{
  // raw_hdlc
  struct anonymous_2 *raw_hdlc;
  // cisco
  struct anonymous_3 *cisco;
  // fr
  struct anonymous_4 *fr;
  // fr_pvc
  struct anonymous_5 *fr_pvc;
  // fr_pvc_info
  struct anonymous_6 *fr_pvc_info;
  // sync
  struct anonymous_7 *sync;
  // te1
  struct anonymous_8 *te1;
};

union anonymous_10
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous_1
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_19
{
  // _anon0
  struct anonymous_17 _anon0;
  // _anon1
  struct anonymous_18 _anon1;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_16
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous_13
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

struct if_settings
{
  // type
  unsigned int type;
  // size
  unsigned int size;
  // ifs_ifsu
  union anonymous_9 ifs_ifsu;
};

union anonymous_11
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  void *ifru_data;
  // ifru_settings
  struct if_settings ifru_settings;
};

union anonymous_14
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_20
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct bat_packet
{
  // version
  unsigned char version;
  // flags
  unsigned char flags;
  // ttl
  unsigned char ttl;
  // gwflags
  unsigned char gwflags;
  // seqno
  unsigned short int seqno;
  // gwport
  unsigned short int gwport;
  // orig
  unsigned int orig;
  // prev_sender
  unsigned int prev_sender;
  // tq
  unsigned char tq;
  // hna_len
  unsigned char hna_len;
} __attribute__ ((__packed__));

struct batgat_ioc_args
{
  // dev_name
  char dev_name[16l];
  // exists
  unsigned char exists;
  // universal
  unsigned int universal;
  // ifindex
  unsigned int ifindex;
};

struct list_head
{
  // next
  struct list_head *next;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct batman_if
{
  // list
  struct list_head list;
  // dev
  char *dev;
  // udp_send_sock
  signed int udp_send_sock;
  // udp_recv_sock
  signed int udp_recv_sock;
  // udp_tunnel_sock
  signed int udp_tunnel_sock;
  // if_num
  unsigned char if_num;
  // if_active
  unsigned char if_active;
  // if_index
  signed int if_index;
  // if_rp_filter_old
  signed char if_rp_filter_old;
  // if_send_redirects_old
  signed char if_send_redirects_old;
  // listen_thread_id
  unsigned long int listen_thread_id;
  // addr
  struct sockaddr_in addr;
  // broad
  struct sockaddr_in broad;
  // netaddr
  unsigned int netaddr;
  // netmask
  unsigned char netmask;
  // wifi_if
  unsigned char wifi_if;
  // out
  struct bat_packet out;
};

struct chunkHeader
{
  // next
  struct chunkHeader *next;
  // length
  unsigned int length;
  // tag
  signed int tag;
  // magicNumber
  unsigned int magicNumber;
};

struct chunkTrailer
{
  // magicNumber
  unsigned int magicNumber;
};

struct curr_gw_data
{
  // orig
  unsigned int orig;
  // gw_node
  struct gw_node *gw_node;
  // batman_if
  struct batman_if *batman_if;
};

struct debug_clients
{
  // fd_list
  void **fd_list;
  // clients_num
  signed short int *clients_num;
  // mutex
  union anonymous_16 **mutex;
};

struct debug_level_info
{
  // list
  struct list_head list;
  // fd
  signed int fd;
};

struct element_t
{
  // data
  void *data;
  // next
  struct element_t *next;
};

struct forw_node
{
  // list
  struct list_head list;
  // send_time
  unsigned int send_time;
  // own
  unsigned char own;
  // pack_buff
  unsigned char *pack_buff;
  // pack_buff_len
  unsigned short int pack_buff_len;
  // direct_link_flags
  unsigned int direct_link_flags;
  // num_packets
  unsigned char num_packets;
  // if_incoming
  struct batman_if *if_incoming;
};

struct free_ip
{
  // list
  struct list_head list;
  // addr
  unsigned int addr;
};

struct gw_client
{
  // wip_addr
  unsigned int wip_addr;
  // vip_addr
  unsigned int vip_addr;
  // client_port
  unsigned short int client_port;
  // last_keep_alive
  unsigned int last_keep_alive;
  // nat_warn
  unsigned char nat_warn;
};

struct gw_node
{
  // list
  struct list_head list;
  // orig_node
  struct orig_node *orig_node;
  // gw_port
  unsigned short int gw_port;
  // gw_failure
  unsigned short int gw_failure;
  // last_failure
  unsigned int last_failure;
  // deleted
  unsigned int deleted;
};

struct hash_it_t
{
  // index
  signed int index;
  // bucket
  struct element_t *bucket;
  // prev_bucket
  struct element_t *prev_bucket;
  // first_bucket
  struct element_t **first_bucket;
};

struct hashtable_t
{
  // table
  struct element_t **table;
  // elements
  signed int elements;
  // size
  signed int size;
  // compare
  signed int (*compare)(void *, void *);
  // choose
  signed int (*choose)(void *, signed int);
};

struct hna_element
{
  // addr
  unsigned int addr;
  // netmask
  unsigned char netmask;
} __attribute__ ((__packed__));

struct list_head_first
{
  // next
  struct list_head *next;
  // prev
  struct list_head *prev;
};

struct hna_global_entry
{
  // addr
  unsigned int addr;
  // netmask
  unsigned char netmask;
  // curr_orig_node
  struct orig_node *curr_orig_node;
  // orig_list
  struct list_head_first orig_list;
} __attribute__ ((__packed__));

struct hna_local_entry
{
  // list
  struct list_head list;
  // addr
  unsigned int addr;
  // netmask
  unsigned char netmask;
};

struct hna_orig_ptr
{
  // list
  struct list_head list;
  // orig_node
  struct orig_node *orig_node;
};

struct hna_task
{
  // list
  struct list_head list;
  // addr
  unsigned int addr;
  // netmask
  unsigned char netmask;
  // route_action
  unsigned char route_action;
};

struct ifconf
{
  // ifc_len
  signed int ifc_len;
  // ifc_ifcu
  union anonymous_0 ifc_ifcu;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous_10 ifr_ifrn;
  // ifr_ifru
  union anonymous_11 ifr_ifru;
};

struct ifreq_0
{
  // ifr_ifrn
  union anonymous_10 ifr_ifrn;
  // ifr_ifru
  union anonymous_13 ifr_ifru;
};

struct ifreq_1
{
  // ifr_ifrn
  union anonymous_10 ifr_ifrn;
  // ifr_ifru
  union anonymous_13 ifr_ifru;
};

struct in6_addr
{
  // __in6_u
  union anonymous_1 __in6_u;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct iphdr
{
  // ihl
  unsigned int ihl : 4;
  // version
  unsigned int version : 4;
  // tos
  unsigned char tos;
  // tot_len
  unsigned short int tot_len;
  // id
  unsigned short int id;
  // frag_off
  unsigned short int frag_off;
  // ttl
  unsigned char ttl;
  // protocol
  unsigned char protocol;
  // check
  unsigned short int check;
  // saddr
  unsigned int saddr;
  // daddr
  unsigned int daddr;
};

struct memoryUsage
{
  // next
  struct memoryUsage *next;
  // length
  unsigned int length;
  // counter
  unsigned int counter;
  // tag
  signed int tag;
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct neigh_node
{
  // list
  struct list_head list;
  // addr
  unsigned int addr;
  // real_packet_count
  unsigned char real_packet_count;
  // tq_recv
  unsigned char *tq_recv;
  // tq_index
  unsigned char tq_index;
  // tq_avg
  unsigned char tq_avg;
  // last_ttl
  unsigned char last_ttl;
  // last_valid
  unsigned int last_valid;
  // real_bits
  unsigned long int *real_bits;
  // orig_node
  struct orig_node *orig_node;
  // if_incoming
  struct batman_if *if_incoming;
};

struct nlmsghdr
{
  // nlmsg_len
  unsigned int nlmsg_len;
  // nlmsg_type
  unsigned short int nlmsg_type;
  // nlmsg_flags
  unsigned short int nlmsg_flags;
  // nlmsg_seq
  unsigned int nlmsg_seq;
  // nlmsg_pid
  unsigned int nlmsg_pid;
};

struct nlmsgerr
{
  // error
  signed int error;
  // msg
  struct nlmsghdr msg;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct orig_node
{
  // orig
  unsigned int orig;
  // router
  struct neigh_node *router;
  // batman_if
  struct batman_if *batman_if;
  // bcast_own
  unsigned long int *bcast_own;
  // bcast_own_sum
  unsigned char *bcast_own_sum;
  // tq_own
  unsigned char tq_own;
  // tq_asym_penalty
  signed int tq_asym_penalty;
  // last_valid
  unsigned int last_valid;
  // gwflags
  unsigned char gwflags;
  // hna_buff
  unsigned char *hna_buff;
  // hna_buff_len
  signed short int hna_buff_len;
  // last_real_seqno
  unsigned short int last_real_seqno;
  // last_ttl
  unsigned char last_ttl;
  // neigh_list
  struct list_head_first neigh_list;
};

struct prof_container
{
  // start_time
  signed long int start_time;
  // total_time
  signed long int total_time;
  // name
  char *name;
  // calls
  unsigned long int calls;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rtattr
{
  // rta_len
  unsigned short int rta_len;
  // rta_type
  unsigned short int rta_type;
};

struct rtmsg
{
  // rtm_family
  unsigned char rtm_family;
  // rtm_dst_len
  unsigned char rtm_dst_len;
  // rtm_src_len
  unsigned char rtm_src_len;
  // rtm_tos
  unsigned char rtm_tos;
  // rtm_table
  unsigned char rtm_table;
  // rtm_protocol
  unsigned char rtm_protocol;
  // rtm_scope
  unsigned char rtm_scope;
  // rtm_type
  unsigned char rtm_type;
  // rtm_flags
  unsigned int rtm_flags;
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_nl
{
  // nl_family
  unsigned short int nl_family;
  // nl_pad
  unsigned short int nl_pad;
  // nl_pid
  unsigned int nl_pid;
  // nl_groups
  unsigned int nl_groups;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct tms
{
  // tms_utime
  signed long int tms_utime;
  // tms_stime
  signed long int tms_stime;
  // tms_cutime
  signed long int tms_cutime;
  // tms_cstime
  signed long int tms_cstime;
};

struct udphdr
{
  // _anon0
  union anonymous_19 _anon0;
};

struct unix_client
{
  // list
  struct list_head list;
  // sock
  signed int sock;
  // debug_level
  unsigned char debug_level;
};

struct unix_if
{
  // unix_sock
  signed int unix_sock;
  // listen_thread_id
  unsigned long int listen_thread_id;
  // addr
  struct sockaddr_un addr;
  // client_list
  struct list_head_first client_list;
};

struct vis_data
{
  // type
  unsigned char type;
  // data
  unsigned char data;
  // ip
  unsigned int ip;
} __attribute__ ((__packed__));

struct vis_if
{
  // sock
  signed int sock;
  // addr
  struct sockaddr_in addr;
};

struct vis_packet
{
  // sender_ip
  unsigned int sender_ip;
  // version
  unsigned char version;
  // gw_class
  unsigned char gw_class;
  // tq_max
  unsigned char tq_max;
} __attribute__ ((__packed__));


// active_ifs
// file batman.c line 89
unsigned char active_ifs = (unsigned char)0;
// aggregation_enabled
// file batman.c line 118
unsigned char aggregation_enabled = (unsigned char)1;
// batman_clock_mutex
// file posix/posix.c line 52
static union anonymous_16 batman_clock_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// batman_clock_ticks
// file batman.c line 109
unsigned long int batman_clock_ticks = (unsigned long int)0;
// bh_udp_ports
// file posix/tunnel.c line 62
unsigned short int bh_udp_ports[6l] = { (unsigned short int)4307, (unsigned short int)162, (unsigned short int)137, (unsigned short int)138, (unsigned short int)139, (unsigned short int)5353 };
// chunkList
// file allocate.c line 38
struct chunkHeader *chunkList = (struct chunkHeader *)(void *)0;
// chunk_mutex
// file allocate.c line 36
static union anonymous_16 chunk_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// curr_gateway
// file batman.c line 79
struct gw_node *curr_gateway = (struct gw_node *)(void *)0;
// curr_gateway_thread_id
// file batman.c line 80
unsigned long int curr_gateway_thread_id = (unsigned long int)0;
// debug_clients
// file batman.c line 104
struct debug_clients debug_clients;
// debug_level
// file batman.c line 39
unsigned char debug_level = (unsigned char)0;
// debug_level_max
// file batman.c line 44
unsigned char debug_level_max = (unsigned char)5;
// disable_client_nat
// file batman.c line 121
signed char disable_client_nat = (signed char)0;
// dummy_tms_struct
// file posix/posix.c line 53
static struct tms dummy_tms_struct;
// forw_list
// file batman.c line 98
struct list_head_first forw_list;
// found_ifs
// file batman.c line 88
unsigned char found_ifs = (unsigned char)0;
// gateway_class
// file batman.c line 64
unsigned char gateway_class = (unsigned char)0;
// global_win_size
// file batman.c line 115
unsigned char global_win_size = (unsigned char)10;
// gw_list
// file batman.c line 99
struct list_head_first gw_list;
// hna_buff_local
// file hna.c line 33
unsigned char *hna_buff_local = (unsigned char *)(void *)0;
// hna_chg_list
// file hna.c line 37
struct list_head_first hna_chg_list;
// hna_chg_list_mutex
// file hna.c line 39
static union anonymous_16 hna_chg_list_mutex;
// hna_global_hash
// file hna.c line 40
static struct hashtable_t *hna_global_hash = (struct hashtable_t *)(void *)0;
// hna_list
// file hna.c line 36
struct list_head_first hna_list;
// hop_penalty
// file batman.c line 111
unsigned char hop_penalty = (unsigned char)5;
// if_list
// file batman.c line 100
struct list_head_first if_list;
// last_clock_tick
// file posix/posix.c line 47
static signed long int last_clock_tick;
// local_win_size
// file batman.c line 116
unsigned char local_win_size = (unsigned char)64;
// log_facility_active
// file batman.c line 94
unsigned char log_facility_active = (unsigned char)0;
// memoryList
// file allocate.c line 57
struct memoryUsage *memoryList = (struct memoryUsage *)(void *)0;
// memory_mutex
// file allocate.c line 58
static union anonymous_16 memory_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// minimum_recv
// file batman.c line 114
unsigned char minimum_recv = (unsigned char)1;
// minimum_send
// file batman.c line 113
unsigned char minimum_send = (unsigned char)1;
// nat_tool_avail
// file batman.c line 120
signed int nat_tool_avail = -1;
// no_detach
// file posix/init.c line 47
signed int no_detach = 0;
// num_hna_local
// file hna.c line 34
unsigned char num_hna_local = (unsigned char)0;
// num_words
// file batman.c line 117
unsigned char num_words = (unsigned char)((unsigned long int)64 / (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8));
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// orig_hash
// file batman.c line 96
struct hashtable_t *orig_hash;
// originator_interval
// file batman.c line 77
signed short int originator_interval = (signed short int)1000;
// policy_routing_pipe
// file batman.c line 85
signed int policy_routing_pipe = 0;
// policy_routing_script
// file batman.c line 84
char *policy_routing_script = (char *)(void *)0;
// policy_routing_script_pid
// file batman.c line 86
signed int policy_routing_script_pid;
// pref_gateway
// file batman.c line 82
unsigned int pref_gateway = (unsigned int)0;
// prof_container
// file profile.c line 32
static struct prof_container prof_container[9l];
// prog_name
// file batman.c line 57
char *prog_name;
// purge_timeout
// file batman.c line 112
unsigned int purge_timeout = 200000u;
// receive_max_sock
// file batman.c line 90
signed int receive_max_sock = 0;
// receive_wait_set
// file batman.c line 91
struct anonymous_15 receive_wait_set;
// route_type_to_string
// file linux/route.c line 37
static const char *route_type_to_string[4l] = { "route", "throw route", "unreachable route", "unknown route type" };
// route_type_to_string_script
// file linux/route.c line 44
static const char *route_type_to_string_script[4l] = { "UNICAST", "THROW", "UNREACH", "UNKNOWN" };
// routing_class
// file batman.c line 74
unsigned char routing_class = (unsigned char)0;
// rule_type_to_string
// file linux/route.c line 52
static const char *rule_type_to_string[3l] = { "from", "to", "iif" };
// rule_type_to_string_script
// file linux/route.c line 58
static const char *rule_type_to_string_script[3l] = { "SRC", "DST", "IIF" };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stop
// file posix/init.c line 46
signed char stop;
// system_tick
// file posix/posix.c line 48
static float system_tick;
// tunnel_running
// file posix/posix.c line 50
unsigned char tunnel_running = (unsigned char)0;
// unix_client
// file batman.c line 93
unsigned char unix_client = (unsigned char)0;
// unix_if
// file batman.c line 103
struct unix_if unix_if;
// vis_if
// file batman.c line 102
struct vis_if vis_if;
// vis_packet
// file batman.c line 106
unsigned char *vis_packet = (unsigned char *)(void *)0;
// vis_packet_size
// file batman.c line 107
unsigned short int vis_packet_size = (unsigned short int)0;

// __list_add
// file list-batman.c line 34
static void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  new->next = next;
  prev->next = new;
}

// __list_del
// file list-batman.c line 90
static void __list_del(struct list_head *prev, struct list_head *next)
{
  prev->next = next;
}

// _hna_global_add
// file hna.c line 314
static void _hna_global_add(struct orig_node *orig_node, struct hna_element *hna_element)
{
  struct list_head *list_pos;
  struct hna_global_entry *hna_global_entry;
  struct hna_orig_ptr *hna_orig_ptr = (struct hna_orig_ptr *)(void *)0;
  struct orig_node *old_orig_node = (struct orig_node *)(void *)0;
  struct hashtable_t *swaphash;
  void *return_value_hash_find_1;
  return_value_hash_find_1=hash_find(hna_global_hash, (void *)hna_element);
  hna_global_entry = (struct hna_global_entry *)return_value_hash_find_1;
  if(hna_global_entry == ((struct hna_global_entry *)NULL))
  {
    void *return_value_debugMalloc_2;
    return_value_debugMalloc_2=debugMalloc((unsigned int)sizeof(struct hna_global_entry) /*29ul*/ , 703);
    hna_global_entry = (struct hna_global_entry *)return_value_debugMalloc_2;
    if(hna_global_entry == ((struct hna_global_entry *)NULL))
      goto __CPROVER_DUMP_L16;

    hna_global_entry->addr = hna_element->addr;
    hna_global_entry->netmask = hna_element->netmask;
    hna_global_entry->curr_orig_node = (struct orig_node *)(void *)0;
    hna_global_entry->orig_list.next = (struct list_head *)&hna_global_entry->orig_list;
    hna_global_entry->orig_list.prev = (struct list_head *)&hna_global_entry->orig_list;
    hash_add(hna_global_hash, (void *)hna_global_entry);
    if(!(hna_global_hash->size >= 4 * hna_global_hash->elements))
    {
      swaphash=hash_resize(hna_global_hash, hna_global_hash->size * 2);
      if(swaphash == ((struct hashtable_t *)NULL))
        debug_output((signed char)0, "Couldn't resize global hna hash table \n");

      else
        hna_global_hash = swaphash;
    }

  }

  _Bool tmp_if_expr_4;
  if(!(hna_global_entry->curr_orig_node == orig_node))
  {
    list_pos = (&hna_global_entry->orig_list)->next;
    for( ; !(list_pos == (struct list_head *)&hna_global_entry->orig_list); list_pos = list_pos->next)
    {
      hna_orig_ptr = (struct hna_orig_ptr *)((char *)list_pos - (signed long int)(unsigned long int)&((struct hna_orig_ptr *)0)->list);
      if(hna_orig_ptr->orig_node == orig_node)
        break;

      hna_orig_ptr = (struct hna_orig_ptr *)(void *)0;
    }
    if(hna_orig_ptr == ((struct hna_orig_ptr *)NULL))
    {
      void *return_value_debugMalloc_3;
      return_value_debugMalloc_3=debugMalloc((unsigned int)sizeof(struct hna_orig_ptr) /*16ul*/ , 704);
      hna_orig_ptr = (struct hna_orig_ptr *)return_value_debugMalloc_3;
      if(hna_orig_ptr == ((struct hna_orig_ptr *)NULL))
        goto __CPROVER_DUMP_L16;

      hna_orig_ptr->orig_node = orig_node;
      do
        (&hna_orig_ptr->list)->next = &hna_orig_ptr->list;
      while((_Bool)0);
      list_add_tail(&hna_orig_ptr->list, &hna_global_entry->orig_list);
    }

    if(hna_global_entry->curr_orig_node == ((struct orig_node *)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)orig_node->router->tq_avg > (signed int)hna_global_entry->curr_orig_node->router->tq_avg ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      old_orig_node = hna_global_entry->curr_orig_node;
      hna_global_entry->curr_orig_node = orig_node;
      if(!(old_orig_node == ((struct orig_node *)NULL)))
      {
        if(hna_global_entry->curr_orig_node->router->addr == old_orig_node->router->addr)
          goto __CPROVER_DUMP_L16;

      }

      add_del_route(hna_element->addr, hna_element->netmask, orig_node->router->addr, orig_node->router->if_incoming->addr.sin_addr.s_addr, orig_node->router->if_incoming->if_index, orig_node->router->if_incoming->dev, (unsigned char)65, (signed char)0, (signed char)0);
    }

    if(!(old_orig_node == ((struct orig_node *)NULL)))
      add_del_route(hna_element->addr, hna_element->netmask, old_orig_node->router->addr, old_orig_node->router->if_incoming->addr.sin_addr.s_addr, old_orig_node->router->if_incoming->if_index, old_orig_node->router->if_incoming->dev, (unsigned char)65, (signed char)0, (signed char)1);

  }


__CPROVER_DUMP_L16:
  ;
}

// _hna_global_del
// file hna.c line 406
static void _hna_global_del(struct orig_node *orig_node, struct hna_element *hna_element)
{
  struct list_head *list_pos;
  struct list_head *list_pos_tmp;
  struct list_head *prev_list_head;
  struct hna_global_entry *hna_global_entry;
  struct hna_orig_ptr *hna_orig_ptr = (struct hna_orig_ptr *)(void *)0;
  void *return_value_hash_find_1;
  return_value_hash_find_1=hash_find(hna_global_hash, (void *)hna_element);
  hna_global_entry = (struct hna_global_entry *)return_value_hash_find_1;
  _Bool tmp_if_expr_2;
  if(!(hna_global_entry == ((struct hna_global_entry *)NULL)))
  {
    hna_global_entry->curr_orig_node = (struct orig_node *)(void *)0;
    prev_list_head = (struct list_head *)&hna_global_entry->orig_list;
    list_pos = (&hna_global_entry->orig_list)->next;
    list_pos_tmp = list_pos->next;
    for( ; !(list_pos == (struct list_head *)&hna_global_entry->orig_list); list_pos_tmp = list_pos->next)
    {
      hna_orig_ptr = (struct hna_orig_ptr *)((char *)list_pos - (signed long int)(unsigned long int)&((struct hna_orig_ptr *)0)->list);
      if(hna_orig_ptr->orig_node == orig_node)
      {
        list_del(prev_list_head, list_pos, &hna_global_entry->orig_list);
        debugFree((void *)hna_orig_ptr, 1707);
      }

      else
      {
        if(hna_global_entry->curr_orig_node == ((struct orig_node *)NULL))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (signed int)hna_orig_ptr->orig_node->router->tq_avg > (signed int)hna_global_entry->curr_orig_node->router->tq_avg ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          hna_global_entry->curr_orig_node = hna_orig_ptr->orig_node;

        prev_list_head = &hna_orig_ptr->list;
      }
      list_pos = list_pos_tmp;
    }
    if(!(hna_global_entry->curr_orig_node == ((struct orig_node *)NULL)))
    {
      if(hna_global_entry->curr_orig_node->router->addr == orig_node->router->addr)
        goto __CPROVER_DUMP_L12;

      add_del_route(hna_element->addr, hna_element->netmask, hna_global_entry->curr_orig_node->router->addr, hna_global_entry->curr_orig_node->router->if_incoming->addr.sin_addr.s_addr, hna_global_entry->curr_orig_node->router->if_incoming->if_index, hna_global_entry->curr_orig_node->router->if_incoming->dev, (unsigned char)65, (signed char)0, (signed char)0);
    }

    add_del_route(hna_element->addr, hna_element->netmask, orig_node->router->addr, orig_node->router->if_incoming->addr.sin_addr.s_addr, orig_node->router->if_incoming->if_index, orig_node->router->if_incoming->dev, (unsigned char)65, (signed char)0, (signed char)1);
    if(hna_global_entry->curr_orig_node == ((struct orig_node *)NULL))
    {
      hash_remove(hna_global_hash, (void *)hna_element);
      debugFree((void *)hna_global_entry, 1708);
    }

  }


__CPROVER_DUMP_L12:
  ;
}

// _hna_global_hash_del
// file hna.c line 732
static void _hna_global_hash_del(void *data)
{
  struct hna_global_entry *hna_global_entry = (struct hna_global_entry *)data;
  struct hna_orig_ptr *hna_orig_ptr = (struct hna_orig_ptr *)(void *)0;
  struct list_head *list_pos;
  struct list_head *list_pos_tmp;
  list_pos = (&hna_global_entry->orig_list)->next;
  list_pos_tmp = list_pos->next;
  for( ; !(list_pos == (struct list_head *)&hna_global_entry->orig_list); list_pos_tmp = list_pos->next)
  {
    hna_orig_ptr = (struct hna_orig_ptr *)((char *)list_pos - (signed long int)(unsigned long int)&((struct hna_orig_ptr *)0)->list);
    list_del((struct list_head *)&hna_global_entry->orig_list, list_pos, &hna_global_entry->orig_list);
    debugFree((void *)hna_orig_ptr, 1710);
    list_pos = list_pos_tmp;
  }
  debugFree((void *)hna_global_entry, 1711);
}

// activate_interface
// file posix/init.c line 859
static void activate_interface(struct batman_if *batman_if)
{
  struct ifreq_1 int_req;
  signed int on = 1;
  signed int sock_opts;
  batman_if->udp_recv_sock=socket(2, 2, 0);
  if(!(batman_if->udp_recv_sock >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    debug_output((signed char)3, "Error - can't create receive socket: %s\n", return_value_strerror_2);
    goto error;
  }

  memset((void *)&int_req, 0, sizeof(struct ifreq_1) /*40ul*/ );
  strncpy(int_req.ifr_ifrn.ifrn_name, batman_if->dev, (unsigned long int)(16 - 1));
  signed int return_value_ioctl_5;
  return_value_ioctl_5=ioctl(batman_if->udp_recv_sock, (unsigned long int)0x8915, &int_req);
  if(!(return_value_ioctl_5 >= 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    debug_output((signed char)3, "Error - can't get IP address of interface %s: %s\n", batman_if->dev, return_value_strerror_4);
    goto error;
  }

  batman_if->addr.sin_family = (unsigned short int)2;
  batman_if->addr.sin_port=htons((unsigned short int)4305);
  batman_if->addr.sin_addr.s_addr = ((struct sockaddr_in *)&int_req.ifr_ifru.ifru_addr)->sin_addr.s_addr;
  signed int return_value_ioctl_8;
  signed int return_value_ioctl_11;
  signed int return_value_is_wifi_interface_12;
  signed int return_value_ioctl_15;
  signed int return_value_setsockopt_20;
  signed char return_value_bind_to_iface_23;
  signed int return_value_bind_26;
  signed char return_value_bind_to_iface_29;
  signed int return_value_bind_32;
  signed int return_value_get_rp_filter_33;
  signed int return_value_get_send_redirects_34;
  if(batman_if->addr.sin_addr.s_addr == 0u)
    debug_output((signed char)3, "Error - invalid ip address detected (0.0.0.0): %s\n", batman_if->dev);

  else
  {
    return_value_ioctl_8=ioctl(batman_if->udp_recv_sock, (unsigned long int)0x8919, &int_req);
    if(!(return_value_ioctl_8 >= 0))
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      char *return_value_strerror_7;
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      debug_output((signed char)3, "Error - can't get broadcast IP address of interface %s: %s\n", batman_if->dev, return_value_strerror_7);
      goto error;
    }

    batman_if->broad.sin_family = (unsigned short int)2;
    batman_if->broad.sin_port=htons((unsigned short int)4305);
    batman_if->broad.sin_addr.s_addr = ((struct sockaddr_in *)&int_req.ifr_ifru.ifru_broadaddr)->sin_addr.s_addr;
    if(batman_if->broad.sin_addr.s_addr == 0u)
      debug_output((signed char)3, "Error - invalid broadcast address detected (0.0.0.0): %s\n", batman_if->dev);

    else
    {
      return_value_ioctl_11=ioctl(batman_if->udp_recv_sock, (unsigned long int)0x8933, &int_req);
      if(!(return_value_ioctl_11 >= 0))
      {
        signed int *return_value___errno_location_9;
        return_value___errno_location_9=__errno_location();
        char *return_value_strerror_10;
        return_value_strerror_10=strerror(*return_value___errno_location_9);
        debug_output((signed char)3, "Error - can't get index of interface %s: %s\n", batman_if->dev, return_value_strerror_10);
        goto error;
      }

      batman_if->if_index = int_req.ifr_ifru.ifru_ivalue;
      return_value_is_wifi_interface_12=is_wifi_interface(batman_if->dev, batman_if->udp_recv_sock);
      batman_if->wifi_if = (unsigned char)return_value_is_wifi_interface_12;
      return_value_ioctl_15=ioctl(batman_if->udp_recv_sock, (unsigned long int)0x891b, &int_req);
      if(!(return_value_ioctl_15 >= 0))
      {
        signed int *return_value___errno_location_13;
        return_value___errno_location_13=__errno_location();
        char *return_value_strerror_14;
        return_value_strerror_14=strerror(*return_value___errno_location_13);
        debug_output((signed char)3, "Error - can't get netmask address of interface %s: %s\n", batman_if->dev, return_value_strerror_14);
        goto error;
      }

      batman_if->netaddr = ((struct sockaddr_in *)&int_req.ifr_ifru.ifru_addr)->sin_addr.s_addr & batman_if->addr.sin_addr.s_addr;
      batman_if->netmask=bit_count((signed int)((struct sockaddr_in *)&int_req.ifr_ifru.ifru_addr)->sin_addr.s_addr);
      add_del_rule(batman_if->netaddr, batman_if->netmask, (signed char)66, (unsigned int)(6600 + (signed int)batman_if->if_num), ((char *)NULL), (signed char)1, (signed char)0);
      add_del_rule(batman_if->netaddr, batman_if->netmask, (signed char)67, (unsigned int)(6600 + 100 + (signed int)batman_if->if_num), ((char *)NULL), (signed char)1, (signed char)0);
      batman_if->udp_send_sock=socket(2, 2, 0);
      if(!(batman_if->udp_send_sock >= 0))
      {
        signed int *return_value___errno_location_16;
        return_value___errno_location_16=__errno_location();
        char *return_value_strerror_17;
        return_value_strerror_17=strerror(*return_value___errno_location_16);
        debug_output((signed char)3, "Error - can't create send socket: %s\n", return_value_strerror_17);
        goto error;
      }

      return_value_setsockopt_20=setsockopt(batman_if->udp_send_sock, 1, 6, (const void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_20 >= 0))
      {
        signed int *return_value___errno_location_18;
        return_value___errno_location_18=__errno_location();
        char *return_value_strerror_19;
        return_value_strerror_19=strerror(*return_value___errno_location_18);
        debug_output((signed char)3, "Error - can't enable broadcasts: %s\n", return_value_strerror_19);
        goto error;
      }

      return_value_bind_to_iface_23=bind_to_iface(batman_if->udp_send_sock, batman_if->dev);
      if(!((signed int)return_value_bind_to_iface_23 >= 0))
      {
        signed int *return_value___errno_location_21;
        return_value___errno_location_21=__errno_location();
        char *return_value_strerror_22;
        return_value_strerror_22=strerror(*return_value___errno_location_21);
        debug_output((signed char)3, "Cannot bind socket to device %s : %s \n", batman_if->dev, return_value_strerror_22);
        goto error;
      }

      return_value_bind_26=bind(batman_if->udp_send_sock, (struct sockaddr *)&batman_if->addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(!(return_value_bind_26 >= 0))
      {
        signed int *return_value___errno_location_24;
        return_value___errno_location_24=__errno_location();
        char *return_value_strerror_25;
        return_value_strerror_25=strerror(*return_value___errno_location_24);
        debug_output((signed char)3, "Error - can't bind send socket: %s\n", return_value_strerror_25);
        goto error;
      }

      sock_opts=fcntl(batman_if->udp_send_sock, 3, 0);
      fcntl(batman_if->udp_send_sock, 4, sock_opts | 04000);
      return_value_bind_to_iface_29=bind_to_iface(batman_if->udp_recv_sock, batman_if->dev);
      if(!((signed int)return_value_bind_to_iface_29 >= 0))
      {
        signed int *return_value___errno_location_27;
        return_value___errno_location_27=__errno_location();
        char *return_value_strerror_28;
        return_value_strerror_28=strerror(*return_value___errno_location_27);
        debug_output((signed char)3, "Cannot bind socket to device %s : %s \n", batman_if->dev, return_value_strerror_28);
        goto error;
      }

      return_value_bind_32=bind(batman_if->udp_recv_sock, (struct sockaddr *)&batman_if->broad, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(!(return_value_bind_32 >= 0))
      {
        signed int *return_value___errno_location_30;
        return_value___errno_location_30=__errno_location();
        char *return_value_strerror_31;
        return_value_strerror_31=strerror(*return_value___errno_location_30);
        debug_output((signed char)3, "Error - can't bind receive socket: %s\n", return_value_strerror_31);
        goto error;
      }

      batman_if->out.orig = batman_if->addr.sin_addr.s_addr;
      batman_if->out.prev_sender = batman_if->addr.sin_addr.s_addr;
      batman_if->if_active = (unsigned char)1;
      active_ifs = active_ifs + 1;
      interface_listen_sockets();
      debug_output((signed char)3, "Interface activated: %s\n", batman_if->dev);
      return_value_get_rp_filter_33=get_rp_filter(batman_if->dev);
      batman_if->if_rp_filter_old = (signed char)return_value_get_rp_filter_33;
      set_rp_filter(0, batman_if->dev);
      return_value_get_send_redirects_34=get_send_redirects(batman_if->dev);
      batman_if->if_send_redirects_old = (signed char)return_value_get_send_redirects_34;
      set_send_redirects(0, batman_if->dev);
      goto __CPROVER_DUMP_L15;
    }
  }

error:
  ;
  deactivate_interface(batman_if);

__CPROVER_DUMP_L15:
  ;
}

// addMemory
// file allocate.c line 124
static void addMemory(unsigned int length, signed int tag)
{
  struct memoryUsage *walker;
  pthread_mutex_lock(&memory_mutex);
  walker = memoryList;
  for( ; !(walker == ((struct memoryUsage *)NULL)); walker = walker->next)
    if(walker->tag == tag)
    {
      walker->counter = walker->counter + 1u;
      break;
    }

  if(walker == ((struct memoryUsage *)NULL))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct memoryUsage) /*24ul*/ );
    walker = (struct memoryUsage *)return_value_malloc_1;
    walker->length = length;
    walker->tag = tag;
    walker->counter = (unsigned int)1;
    walker->next = memoryList;
    memoryList = walker;
  }

  pthread_mutex_unlock(&memory_mutex);
}

// add_default_route
// file os.h line 85
void add_default_route(void)
{
  struct curr_gw_data *curr_gw_data;
  if(!(tunnel_running == 0))
    debug_output((signed char)3, "Error - couldn't create tunnel: old tunnel is still active\n");

  else
  {
    void *return_value_debugMalloc_1;
    return_value_debugMalloc_1=debugMalloc((unsigned int)sizeof(struct curr_gw_data) /*24ul*/ , 207);
    curr_gw_data = (struct curr_gw_data *)return_value_debugMalloc_1;
    curr_gw_data->orig = curr_gateway->orig_node->orig;
    curr_gw_data->gw_node = curr_gateway;
    curr_gw_data->batman_if = curr_gateway->orig_node->batman_if;
    tunnel_running = (unsigned char)1;
    signed int return_value_pthread_create_4;
    return_value_pthread_create_4=pthread_create(&curr_gateway_thread_id, (const union pthread_attr_t *)(void *)0, client_to_gw_tun, (void *)curr_gw_data);
    if(!(return_value_pthread_create_4 == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      debug_output((signed char)0, "Error - couldn't spawn thread: %s\n", return_value_strerror_3);
      debugFree((void *)curr_gw_data, 1213);
      curr_gateway = (struct gw_node *)(void *)0;
      tunnel_running = (unsigned char)0;
    }

    else
      pthread_detach(curr_gateway_thread_id);
  }
}

// add_del_interface_rules
// file linux/route.c line 506
signed int add_del_interface_rules(signed char rule_action)
{
  signed int tmp_fd;
  unsigned int addr;
  unsigned int netaddr;
  signed int len;
  unsigned char netmask;
  unsigned char if_count = (unsigned char)1;
  char *buf;
  char *buf_ptr;
  struct ifconf ifc;
  struct ifreq *ifr;
  struct ifreq ifr_tmp;
  struct batman_if *batman_if;
  tmp_fd=socket(2, 2, 0);
  if(!(tmp_fd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    debug_output((signed char)0, "Error - can't %s interface rules (udp socket): %s\n", (signed int)rule_action == 1 ? "delete" : "add", return_value_strerror_2);
    return -1;
  }

  len = (signed int)((unsigned long int)10 * sizeof(struct ifreq) /*40ul*/ );
  while((_Bool)1)
  {
    void *return_value_debugMalloc_3;
    return_value_debugMalloc_3=debugMalloc((unsigned int)len, 601);
    buf = (char *)return_value_debugMalloc_3;
    ifc.ifc_len = len;
    ifc.ifc_ifcu.ifcu_buf = buf;
    signed int return_value_ioctl_6;
    return_value_ioctl_6=ioctl(tmp_fd, (unsigned long int)0x8912, &ifc);
    if(!(return_value_ioctl_6 >= 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      debug_output((signed char)0, "Error - can't %s interface rules (SIOCGIFCONF): %s\n", (signed int)rule_action == 1 ? "delete" : "add", return_value_strerror_5);
      close(tmp_fd);
      debugFree((void *)buf, 1606);
      return -1;
    }

    else
      if(!(ifc.ifc_len >= len))
        break;

    len = len + (signed int)((unsigned long int)10 * sizeof(struct ifreq) /*40ul*/ );
    debugFree((void *)buf, 1601);
  }
  buf_ptr = buf;
  while(!(buf_ptr >= buf + (signed long int)ifc.ifc_len))
  {
    ifr = (struct ifreq *)buf_ptr;
    buf_ptr = buf_ptr + (signed long int)(((signed int)ifr->ifr_ifru.ifru_addr.sa_family == 10 ? sizeof(struct sockaddr_in6) /*28ul*/  : sizeof(struct sockaddr) /*16ul*/ ) + sizeof(char [16l]) /*16ul*/ );
    if((signed int)ifr->ifr_ifru.ifru_addr.sa_family == 2)
    {
      signed int return_value_strncmp_7;
      return_value_strncmp_7=strncmp(ifr->ifr_ifrn.ifrn_name, "gate", (unsigned long int)4);
      if(!(return_value_strncmp_7 == 0))
      {
        memset((void *)&ifr_tmp, 0, sizeof(struct ifreq) /*40ul*/ );
        strncpy(ifr_tmp.ifr_ifrn.ifrn_name, ifr->ifr_ifrn.ifrn_name, (unsigned long int)(16 - 1));
        signed int return_value_ioctl_10;
        return_value_ioctl_10=ioctl(tmp_fd, (unsigned long int)0x8913, &ifr_tmp);
        if(!(return_value_ioctl_10 >= 0))
        {
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          char *return_value_strerror_9;
          return_value_strerror_9=strerror(*return_value___errno_location_8);
          debug_output((signed char)0, "Error - can't get flags of interface %s (interface rules): %s\n", (const void *)ifr->ifr_ifrn.ifrn_name, return_value_strerror_9);
          continue;
        }

        if(!((1 & (signed int)ifr_tmp.ifr_ifru.ifru_flags) == 0) && !((64 & (signed int)ifr_tmp.ifr_ifru.ifru_flags) == 0))
        {
          signed int return_value_ioctl_13;
          return_value_ioctl_13=ioctl(tmp_fd, (unsigned long int)0x8915, &ifr_tmp);
          if(!(return_value_ioctl_13 >= 0))
          {
            signed int *return_value___errno_location_11;
            return_value___errno_location_11=__errno_location();
            char *return_value_strerror_12;
            return_value_strerror_12=strerror(*return_value___errno_location_11);
            debug_output((signed char)0, "Error - can't get IP address of interface %s (interface rules): %s\n", (const void *)ifr->ifr_ifrn.ifrn_name, return_value_strerror_12);
            continue;
          }

          addr = ((struct sockaddr_in *)&ifr_tmp.ifr_ifru.ifru_addr)->sin_addr.s_addr;
          signed int return_value_ioctl_16;
          return_value_ioctl_16=ioctl(tmp_fd, (unsigned long int)0x891b, &ifr_tmp);
          if(!(return_value_ioctl_16 >= 0))
          {
            signed int *return_value___errno_location_14;
            return_value___errno_location_14=__errno_location();
            char *return_value_strerror_15;
            return_value_strerror_15=strerror(*return_value___errno_location_14);
            debug_output((signed char)0, "Error - can't get netmask address of interface %s (interface rules): %s\n", (const void *)ifr->ifr_ifrn.ifrn_name, return_value_strerror_15);
            continue;
          }

          netaddr = ((struct sockaddr_in *)&ifr_tmp.ifr_ifru.ifru_addr)->sin_addr.s_addr & addr;
          netmask=bit_count((signed int)((struct sockaddr_in *)&ifr_tmp.ifr_ifru.ifru_addr)->sin_addr.s_addr);
          add_del_route(netaddr, netmask, (unsigned int)0, (unsigned int)0, 0, ifr->ifr_ifrn.ifrn_name, (unsigned char)68, (signed char)1, rule_action);
          signed int return_value_is_batman_if_17;
          return_value_is_batman_if_17=is_batman_if(ifr->ifr_ifrn.ifrn_name, &batman_if);
          if(return_value_is_batman_if_17 == 0)
          {
            add_del_rule(netaddr, netmask, (signed char)68, (unsigned int)((signed int)rule_action == 1 ? 0 : 6600 + 100 + 100 + (signed int)if_count), ((char *)NULL), (signed char)0, rule_action);
            signed int return_value_strncmp_18;
            return_value_strncmp_18=strncmp(ifr->ifr_ifrn.ifrn_name, "lo", (unsigned long int)(16 - 1));
            if(return_value_strncmp_18 == 0)
              add_del_rule((unsigned int)0, (unsigned char)0, (signed char)68, (unsigned int)(6600 + 100 + 100), "lo\0 ", (signed char)2, rule_action);

            if_count = if_count + 1;
          }

        }

      }

    }

  }
  close(tmp_fd);
  debugFree((void *)buf, 1605);
  return 1;
}

// add_del_route
// file os.h line 47
void add_del_route(unsigned int dest, unsigned char netmask, unsigned int router, unsigned int src_ip, signed int ifi, char *dev, unsigned char rt_table, signed char route_type, signed char route_action)
{
  signed int netlink_sock;
  unsigned long int len;
  unsigned int my_router;
  char buf[4096l];
  char str1[16l];
  char str2[16l];
  char str3[16l];
  struct rtattr *rta;
  struct sockaddr_nl nladdr;
  struct iovec iov;
  struct msghdr msg;
  struct nlmsghdr *nh;
  /* add_del_route::1::tag-req_s */
struct req_s
{
  // rtm
  struct rtmsg rtm;
  // buff
  char buff[(signed long int)(sizeof(struct rtattr) * 8) /*32l*/ ];
};

/* */
  ;
  struct req_s *req;
  char req_buf[60l];
  iov.iov_base = (void *)buf;
  iov.iov_len = sizeof(char [4096l]) /*4096ul*/ ;
  inet_ntop(2, (const void *)&dest, str1, (unsigned int)sizeof(char [16l]) /*16ul*/ );
  inet_ntop(2, (const void *)&router, str2, (unsigned int)sizeof(char [16l]) /*16ul*/ );
  inet_ntop(2, (const void *)&src_ip, str3, (unsigned int)sizeof(char [16l]) /*16ul*/ );
  char *return_value_strerror_8;
  if(!(policy_routing_script == ((char *)NULL)))
    dprintf(policy_routing_pipe, "ROUTE %s %s %s %i %s %s %i %s %i\n", (signed int)route_action == 1 ? "del" : "add", route_type_to_string_script[(signed long int)route_type], (const void *)str1, netmask, (const void *)str2, (const void *)str3, ifi, dev, rt_table);

  else
  {
    if(dest == 0u && router == dest)
    {
      if(!((signed int)route_type == 2))
      {
        debug_output((signed char)3, "%s default route via %s (table %i)\n", (signed int)route_action == 1 ? "Deleting" : "Adding", dev, rt_table);
        debug_output((signed char)4, "%s default route via %s (table %i)\n", (signed int)route_action == 1 ? "Deleting" : "Adding", dev, rt_table);
      }

      my_router = router;
    }

    else
      if(router == dest && !(dest == 0u))
      {
        debug_output((signed char)3, "%s route to %s via 0.0.0.0 (table %i - %s)\n", (signed int)route_action == 1 ? "Deleting" : "Adding", (const void *)str1, rt_table, dev);
        debug_output((signed char)4, "%s route to %s via 0.0.0.0 (table %i - %s)\n", (signed int)route_action == 1 ? "Deleting" : "Adding", (const void *)str1, rt_table, dev);
        my_router = (unsigned int)0;
      }

      else
      {
        debug_output((signed char)3, "%s %s to %s/%i via %s (table %i - %s)\n", (signed int)route_action == 1 ? "Deleting" : "Adding", route_type_to_string[(signed long int)route_type], (const void *)str1, netmask, (const void *)str2, rt_table, dev);
        debug_output((signed char)4, "%s %s to %s/%i via %s (table %i - %s)\n", (signed int)route_action == 1 ? "Deleting" : "Adding", route_type_to_string[(signed long int)route_type], (const void *)str1, netmask, (const void *)str2, rt_table, dev);
        my_router = router;
      }
    nh = (struct nlmsghdr *)req_buf;
    req = (struct req_s *)(void *)((char *)req_buf + (signed long int)(0 + (signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1))));
    memset((void *)&nladdr, 0, sizeof(struct sockaddr_nl) /*12ul*/ );
    memset((void *)req_buf, 0, sizeof(struct req_s) /*44ul*/  + (unsigned long int)(signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)));
    memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
    nladdr.nl_family = (unsigned short int)16;
    len = sizeof(struct rtmsg) /*12ul*/  + sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4;
    if((signed int)route_type == 0)
      len = len + (unsigned long int)2 * (sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4);

    if(!(src_ip == 0u))
      len = len + sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4;

    nh->nlmsg_len = (unsigned int)(len + (unsigned long int)(signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)));
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    nh->nlmsg_pid = (unsigned int)return_value_getpid_1;
    req->rtm.rtm_family = (unsigned char)2;
    req->rtm.rtm_table = rt_table;
    req->rtm.rtm_dst_len = netmask;
    if((signed int)route_action == 1)
    {
      nh->nlmsg_flags = (unsigned short int)(1 | 4);
      nh->nlmsg_type = (unsigned short int)25;
      req->rtm.rtm_scope = (unsigned char)255;
    }

    else
    {
      nh->nlmsg_flags = (unsigned short int)(1 | 4 | 0x400 | 0x800);
      nh->nlmsg_type = (unsigned short int)24;
      if(my_router == 0u && (signed int)route_type == 0 && !(src_ip == 0u))
        req->rtm.rtm_scope = (unsigned char)253;

      else
        req->rtm.rtm_scope = (unsigned char)0;
      req->rtm.rtm_protocol = (unsigned char)4;
      switch((signed int)route_type)
      {
        case 0:
        {
          req->rtm.rtm_type = (unsigned char)1;
          break;
        }
        case 1:
        {
          req->rtm.rtm_type = (unsigned char)9;
          break;
        }
        case 2:
        {
          req->rtm.rtm_type = (unsigned char)7;
          break;
        }
        default:
        {
          debug_output((signed char)0, "Error - unknown route type (add_del_route): %i\n", route_type);
          goto __CPROVER_DUMP_L22;
        }
      }
    }
    rta = (struct rtattr *)req->buff;
    rta->rta_type = (unsigned short int)1;
    rta->rta_len = (unsigned short int)(sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4);
    memcpy((void *)((char *)req->buff + (signed long int)sizeof(struct rtattr) /*4ul*/ ), (const void *)(char *)&dest, (unsigned long int)4);
    if((signed int)route_type == 0)
    {
      rta = (struct rtattr *)(req->buff + (signed long int)sizeof(struct rtattr) /*4ul*/  + (signed long int)4);
      rta->rta_type = (unsigned short int)5;
      rta->rta_len = (unsigned short int)(sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4);
      memcpy((void *)((char *)req->buff + (signed long int)((unsigned long int)2 * sizeof(struct rtattr) /*4ul*/ ) + (signed long int)4), (const void *)(char *)&my_router, (unsigned long int)4);
      rta = (struct rtattr *)(req->buff + (signed long int)((unsigned long int)2 * sizeof(struct rtattr) /*4ul*/ ) + (signed long int)8);
      rta->rta_type = (unsigned short int)4;
      rta->rta_len = (unsigned short int)(sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4);
      memcpy((void *)((char *)req->buff + (signed long int)((unsigned long int)3 * sizeof(struct rtattr) /*4ul*/ ) + (signed long int)8), (const void *)(char *)&ifi, (unsigned long int)4);
      if(!(src_ip == 0u))
      {
        rta = (struct rtattr *)(req->buff + (signed long int)((unsigned long int)3 * sizeof(struct rtattr) /*4ul*/ ) + (signed long int)12);
        rta->rta_type = (unsigned short int)7;
        rta->rta_len = (unsigned short int)(sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4);
        memcpy((void *)((char *)req->buff + (signed long int)((unsigned long int)4 * sizeof(struct rtattr) /*4ul*/ ) + (signed long int)12), (const void *)(char *)&src_ip, (unsigned long int)4);
      }

    }

    netlink_sock=socket(16, 2, 0);
    if(!(netlink_sock >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      debug_output((signed char)0, "Error - can't create netlink socket for routing table manipulation: %s\n", return_value_strerror_3);
      goto __CPROVER_DUMP_L22;
    }

    signed long int return_value_sendto_6;
    return_value_sendto_6=sendto(netlink_sock, (const void *)req_buf, (unsigned long int)nh->nlmsg_len, 0, (struct sockaddr *)&nladdr, (unsigned int)sizeof(struct sockaddr_nl) /*12ul*/ );
    if(!(return_value_sendto_6 >= 0l))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      debug_output((signed char)0, "Error - can't send message to kernel via netlink socket for routing table manipulation: %s\n", return_value_strerror_5);
      close(netlink_sock);
      goto __CPROVER_DUMP_L22;
    }

    msg.msg_name = (void *)&nladdr;
    msg.msg_namelen = (unsigned int)sizeof(struct sockaddr_nl) /*12ul*/ ;
    msg.msg_iov = &iov;
    msg.msg_iovlen = (unsigned long int)1;
    msg.msg_control = (void *)0;
    signed long int return_value_recvmsg_7;
    return_value_recvmsg_7=recvmsg(netlink_sock, &msg, 0);
    len = (unsigned long int)return_value_recvmsg_7;
    nh = (struct nlmsghdr *)buf;
    while(len >= sizeof(struct nlmsghdr) /*16ul*/ )
    {
      if(!((unsigned long int)nh->nlmsg_len >= sizeof(struct nlmsghdr) /*16ul*/ ))
        break;

      if(!(len >= (unsigned long int)nh->nlmsg_len))
        break;

      if((signed int)nh->nlmsg_type == 0x3)
        break;

      if((signed int)nh->nlmsg_type == 0x2)
      {
        if(!(((struct nlmsgerr *)((char *)nh + 16l))->error == 0))
        {
          return_value_strerror_8=strerror(-((struct nlmsgerr *)(void *)((char *)nh + (signed long int)(0 + (signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)))))->error);
          debug_output((signed char)0, "Error - can't %s %s to %s/%i via %s (table %i): %s\n", (signed int)route_action == 1 ? "delete" : "add", route_type_to_string[(signed long int)route_type], (const void *)str1, netmask, (const void *)str2, rt_table, return_value_strerror_8);
        }

      }

      len = len - (unsigned long int)((nh->nlmsg_len + 4U) - (unsigned int)1 & ~(4U - (unsigned int)1));
      nh = (struct nlmsghdr *)((char *)nh + (signed long int)((nh->nlmsg_len + 4U) - (unsigned int)1 & ~(4U - (unsigned int)1)));
    }
    close(netlink_sock);
  }

__CPROVER_DUMP_L22:
  ;
}

// add_del_rule
// file linux/route.c line 357
void add_del_rule(unsigned int network, unsigned char netmask, signed char rt_table, unsigned int prio, char *iif, signed char rule_type, signed char rule_action)
{
  signed int netlink_sock;
  unsigned long int len;
  char buf[4096l];
  char str1[16l];
  struct rtattr *rta;
  struct sockaddr_nl nladdr;
  struct iovec iov;
  struct msghdr msg;
  struct nlmsghdr *nh;
  /* add_del_rule::1::tag-req_s */
struct req_s_0
{
  // rtm
  struct rtmsg rtm;
  // buff
  char buff[(signed long int)(sizeof(struct rtattr) * 4) /*16l*/ ];
};

/* */
  ;
  struct req_s_0 *req;
  char req_buf[44l];
  iov.iov_base = (void *)buf;
  iov.iov_len = sizeof(char [4096l]) /*4096ul*/ ;
  inet_ntop(2, (const void *)&network, str1, (unsigned int)sizeof(char [16l]) /*16ul*/ );
  if(!(policy_routing_script == ((char *)NULL)))
    dprintf(policy_routing_pipe, "RULE %s %s %s %i %s %s %u %s %i\n", (signed int)rule_action == 1 ? "del" : "add", rule_type_to_string[(signed long int)rule_type], (const void *)str1, netmask, (const void *)"unused", (const void *)"unused", prio, iif, rt_table);

  else
  {
    nh = (struct nlmsghdr *)req_buf;
    req = (struct req_s_0 *)(void *)((char *)req_buf + (signed long int)(0 + (signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1))));
    memset((void *)&nladdr, 0, sizeof(struct sockaddr_nl) /*12ul*/ );
    memset((void *)req_buf, 0, sizeof(struct req_s_0) /*28ul*/  + (unsigned long int)(signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)));
    memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
    nladdr.nl_family = (unsigned short int)16;
    len = sizeof(struct rtmsg) /*12ul*/  + sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4;
    if(!(prio == 0u))
      len = len + sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4;

    nh->nlmsg_len = (unsigned int)(len + (unsigned long int)(signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)));
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    nh->nlmsg_pid = (unsigned int)return_value_getpid_1;
    req->rtm.rtm_family = (unsigned char)2;
    req->rtm.rtm_table = (unsigned char)rt_table;
    if((signed int)rule_action == 1)
    {
      nh->nlmsg_flags = (unsigned short int)(1 | 4);
      nh->nlmsg_type = (unsigned short int)33;
      req->rtm.rtm_scope = (unsigned char)255;
    }

    else
    {
      nh->nlmsg_flags = (unsigned short int)(1 | 4 | 0x400 | 0x200);
      nh->nlmsg_type = (unsigned short int)32;
      req->rtm.rtm_scope = (unsigned char)0;
      req->rtm.rtm_protocol = (unsigned char)4;
      req->rtm.rtm_type = (unsigned char)1;
    }
    switch((signed int)rule_type)
    {
      case 0:
      {
        rta = (struct rtattr *)req->buff;
        rta->rta_type = (unsigned short int)2;
        req->rtm.rtm_src_len = netmask;
        rta->rta_len = (unsigned short int)(sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4);
        memcpy((void *)((char *)req->buff + (signed long int)sizeof(struct rtattr) /*4ul*/ ), (const void *)(char *)&network, (unsigned long int)4);
        break;
      }
      case 1:
      {
        rta = (struct rtattr *)req->buff;
        rta->rta_type = (unsigned short int)1;
        req->rtm.rtm_dst_len = netmask;
        rta->rta_len = (unsigned short int)(sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4);
        memcpy((void *)((char *)req->buff + (signed long int)sizeof(struct rtattr) /*4ul*/ ), (const void *)(char *)&network, (unsigned long int)4);
        break;
      }
      case 2:
      {
        rta = (struct rtattr *)req->buff;
        rta->rta_len = (unsigned short int)(sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4);
        if((signed int)rule_action == 1)
        {
          rta->rta_type = (unsigned short int)2;
          memcpy((void *)((char *)req->buff + (signed long int)sizeof(struct rtattr) /*4ul*/ ), (const void *)(char *)&network, (unsigned long int)4);
        }

        else
        {
          rta->rta_type = (unsigned short int)3;
          memcpy((void *)((char *)req->buff + (signed long int)sizeof(struct rtattr) /*4ul*/ ), (const void *)iif, (unsigned long int)4);
        }
        break;
      }
      default:
      {
        debug_output((signed char)0, "Error - unknown rule type (add_del_rule): %i\n", rule_type);
        goto __CPROVER_DUMP_L18;
      }
    }
    if(!(prio == 0u))
    {
      rta = (struct rtattr *)(req->buff + (signed long int)sizeof(struct rtattr) /*4ul*/  + (signed long int)4);
      rta->rta_type = (unsigned short int)6;
      rta->rta_len = (unsigned short int)(sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4);
      memcpy((void *)((char *)req->buff + (signed long int)((unsigned long int)2 * sizeof(struct rtattr) /*4ul*/ ) + (signed long int)4), (const void *)(char *)&prio, (unsigned long int)4);
    }

    netlink_sock=socket(16, 2, 0);
    if(!(netlink_sock >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      debug_output((signed char)0, "Error - can't create netlink socket for routing rule manipulation: %s\n", return_value_strerror_3);
      goto __CPROVER_DUMP_L18;
    }

    signed long int return_value_sendto_6;
    return_value_sendto_6=sendto(netlink_sock, (const void *)req_buf, (unsigned long int)nh->nlmsg_len, 0, (struct sockaddr *)&nladdr, (unsigned int)sizeof(struct sockaddr_nl) /*12ul*/ );
    if(!(return_value_sendto_6 >= 0l))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      debug_output((signed char)0, "Error - can't send message to kernel via netlink socket for routing rule manipulation: %s\n", return_value_strerror_5);
      close(netlink_sock);
      goto __CPROVER_DUMP_L18;
    }

    msg.msg_name = (void *)&nladdr;
    msg.msg_namelen = (unsigned int)sizeof(struct sockaddr_nl) /*12ul*/ ;
    msg.msg_iov = &iov;
    msg.msg_iovlen = (unsigned long int)1;
    msg.msg_control = (void *)0;
    signed long int return_value_recvmsg_7;
    return_value_recvmsg_7=recvmsg(netlink_sock, &msg, 0);
    len = (unsigned long int)return_value_recvmsg_7;
    nh = (struct nlmsghdr *)buf;
    for( ; len >= sizeof(struct nlmsghdr) /*16ul*/ ; nh = (struct nlmsghdr *)((char *)nh + (signed long int)((nh->nlmsg_len + 4U) - (unsigned int)1 & ~(4U - (unsigned int)1))))
    {
      if(!((unsigned long int)nh->nlmsg_len >= sizeof(struct nlmsghdr) /*16ul*/ ))
        break;

      if(!(len >= (unsigned long int)nh->nlmsg_len))
        break;

      if((signed int)nh->nlmsg_type == 0x3)
        break;

      if((signed int)nh->nlmsg_type == 0x2)
      {
        if(!(((struct nlmsgerr *)((char *)nh + 16l))->error == 0))
        {
          inet_ntop(2, (const void *)&network, str1, (unsigned int)sizeof(char [16l]) /*16ul*/ );
          char *return_value_strerror_8;
          return_value_strerror_8=strerror(-((struct nlmsgerr *)(void *)((char *)nh + (signed long int)(0 + (signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)))))->error);
          debug_output((signed char)0, "Error - can't %s rule %s %s/%i: %s\n", (signed int)rule_action == 1 ? "delete" : "add", rule_type_to_string_script[(signed long int)rule_type], (const void *)str1, netmask, return_value_strerror_8);
        }

      }

      len = len - (unsigned long int)((nh->nlmsg_len + 4U) - (unsigned int)1 & ~(4U - (unsigned int)1));
    }
    close(netlink_sock);
  }

__CPROVER_DUMP_L18:
  ;
}

// add_dev_tun
// file linux/tun.c line 171
signed char add_dev_tun(struct batman_if *batman_if, unsigned int tun_addr, char *tun_dev, unsigned long int tun_dev_size, signed int *fd, signed int *ifi)
{
  signed int tmp_fd;
  signed int sock_opts;
  struct ifreq ifr_tun;
  struct ifreq ifr_if;
  struct sockaddr_in addr;
  memset((void *)&ifr_tun, 0, sizeof(struct ifreq) /*40ul*/ );
  memset((void *)&ifr_if, 0, sizeof(struct ifreq) /*40ul*/ );
  ifr_tun.ifr_ifru.ifru_flags = (signed short int)(0x0001 | 0x1000);
  strncpy(ifr_tun.ifr_ifrn.ifrn_name, "gate%d", (unsigned long int)16);
  *fd=open("/dev/net/tun", 02);
  if(!(*fd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    debug_output((signed char)0, "Error - can't create tun device (/dev/net/tun): %s\n", return_value_strerror_2);
    return (signed char)-1;
  }

  signed int return_value_ioctl_5;
  return_value_ioctl_5=ioctl(*fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(84 << 0 + 8) | (unsigned int)(202 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, (void *)&ifr_tun);
  if(!(return_value_ioctl_5 >= 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    debug_output((signed char)0, "Error - can't create tun device (TUNSETIFF): %s\n", return_value_strerror_4);
    close(*fd);
    return (signed char)-1;
  }

  signed int return_value_ioctl_8;
  return_value_ioctl_8=ioctl(*fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(84 << 0 + 8) | (unsigned int)(203 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, 1);
  if(!(return_value_ioctl_8 >= 0))
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    debug_output((signed char)0, "Error - can't create tun device (TUNSETPERSIST): %s\n", return_value_strerror_7);
    close(*fd);
    return (signed char)-1;
  }

  tmp_fd=socket(2, 2, 0);
  if(!(tmp_fd >= 0))
  {
    signed int *return_value___errno_location_9;
    return_value___errno_location_9=__errno_location();
    char *return_value_strerror_10;
    return_value_strerror_10=strerror(*return_value___errno_location_9);
    debug_output((signed char)0, "Error - can't create tun device (udp socket): %s\n", return_value_strerror_10);
    del_dev_tun(*fd);
    return (signed char)-1;
  }

  memset((void *)&addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr.sin_addr.s_addr = tun_addr;
  addr.sin_family = (unsigned short int)2;
  memcpy((void *)&ifr_tun.ifr_ifru.ifru_addr, (const void *)&addr, sizeof(struct sockaddr) /*16ul*/ );
  signed int return_value_ioctl_13;
  return_value_ioctl_13=ioctl(tmp_fd, (unsigned long int)0x8916, &ifr_tun);
  if(!(return_value_ioctl_13 >= 0))
  {
    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    char *return_value_strerror_12;
    return_value_strerror_12=strerror(*return_value___errno_location_11);
    debug_output((signed char)0, "Error - can't create tun device (SIOCSIFADDR): %s\n", return_value_strerror_12);
    del_dev_tun(*fd);
    close(tmp_fd);
    return (signed char)-1;
  }

  signed int return_value_ioctl_16;
  return_value_ioctl_16=ioctl(tmp_fd, (unsigned long int)0x8933, &ifr_tun);
  if(!(return_value_ioctl_16 >= 0))
  {
    signed int *return_value___errno_location_14;
    return_value___errno_location_14=__errno_location();
    char *return_value_strerror_15;
    return_value_strerror_15=strerror(*return_value___errno_location_14);
    debug_output((signed char)0, "Error - can't create tun device (SIOCGIFINDEX): %s\n", return_value_strerror_15);
    del_dev_tun(*fd);
    close(tmp_fd);
    return (signed char)-1;
  }

  *ifi = ifr_tun.ifr_ifru.ifru_ivalue;
  signed int return_value_ioctl_19;
  return_value_ioctl_19=ioctl(tmp_fd, (unsigned long int)0x8913, &ifr_tun);
  if(!(return_value_ioctl_19 >= 0))
  {
    signed int *return_value___errno_location_17;
    return_value___errno_location_17=__errno_location();
    char *return_value_strerror_18;
    return_value_strerror_18=strerror(*return_value___errno_location_17);
    debug_output((signed char)0, "Error - can't create tun device (SIOCGIFFLAGS): %s\n", return_value_strerror_18);
    del_dev_tun(*fd);
    close(tmp_fd);
    return (signed char)-1;
  }

  ifr_tun.ifr_ifru.ifru_flags = ifr_tun.ifr_ifru.ifru_flags | (signed short int)1;
  ifr_tun.ifr_ifru.ifru_flags = ifr_tun.ifr_ifru.ifru_flags | (signed short int)64;
  signed int return_value_ioctl_22;
  return_value_ioctl_22=ioctl(tmp_fd, (unsigned long int)0x8914, &ifr_tun);
  if(!(return_value_ioctl_22 >= 0))
  {
    signed int *return_value___errno_location_20;
    return_value___errno_location_20=__errno_location();
    char *return_value_strerror_21;
    return_value_strerror_21=strerror(*return_value___errno_location_20);
    debug_output((signed char)0, "Error - can't create tun device (SIOCSIFFLAGS): %s\n", return_value_strerror_21);
    del_dev_tun(*fd);
    close(tmp_fd);
    return (signed char)-1;
  }

  strncpy(ifr_if.ifr_ifrn.ifrn_name, batman_if->dev, (unsigned long int)(16 - 1));
  signed int return_value_ioctl_25;
  return_value_ioctl_25=ioctl(tmp_fd, (unsigned long int)0x8921, &ifr_if);
  if(!(return_value_ioctl_25 >= 0))
  {
    signed int *return_value___errno_location_23;
    return_value___errno_location_23=__errno_location();
    char *return_value_strerror_24;
    return_value_strerror_24=strerror(*return_value___errno_location_23);
    debug_output((signed char)0, "Error - can't create tun device (SIOCGIFMTU): %s\n", return_value_strerror_24);
    del_dev_tun(*fd);
    close(tmp_fd);
    return (signed char)-1;
  }

  if(!(ifr_if.ifr_ifru.ifru_mtu >= 100))
    debug_output((signed char)0, "Warning - MTU smaller than 100 -> can't reduce MTU anymore\n");

  else
  {
    ifr_tun.ifr_ifru.ifru_mtu = ifr_if.ifr_ifru.ifru_mtu - 29;
    signed int return_value_ioctl_28;
    return_value_ioctl_28=ioctl(tmp_fd, (unsigned long int)0x8922, &ifr_tun);
    if(!(return_value_ioctl_28 >= 0))
    {
      signed int *return_value___errno_location_26;
      return_value___errno_location_26=__errno_location();
      char *return_value_strerror_27;
      return_value_strerror_27=strerror(*return_value___errno_location_26);
      debug_output((signed char)0, "Error - can't create tun device (SIOCSIFMTU): %s\n", return_value_strerror_27);
      del_dev_tun(*fd);
      close(tmp_fd);
      return (signed char)-1;
    }

  }
  sock_opts=fcntl(*fd, 3, 0);
  fcntl(*fd, 4, sock_opts | 04000);
  strncpy(tun_dev, ifr_tun.ifr_ifrn.ifrn_name, tun_dev_size - (unsigned long int)1);
  close(tmp_fd);
  return (signed char)1;
}

// add_nat_rule
// file linux/tun.c line 103
void add_nat_rule(char *dev)
{
  char cmd[100l];
  sprintf(cmd, "iptables -t nat -A POSTROUTING -o %s -j MASQUERADE", dev);
  exec_iptables_rule(cmd, (signed char)0);
}

// addr_to_string
// file os.h line 36
void addr_to_string(unsigned int addr, char *str, signed int len)
{
  inet_ntop(2, (const void *)&addr, str, (unsigned int)len);
}

// apply_init_args
// file posix/init.c line 142
void apply_init_args(signed int argc, char **argv)
{
  struct in_addr tmp_ip_holder;
  struct batman_if *batman_if;
  struct hna_task *hna_task;
  struct debug_level_info *debug_level_info;
  unsigned char found_args = (unsigned char)1;
  unsigned char batch_mode = (unsigned char)0;
  unsigned char info_output = (unsigned char)0;
  unsigned char was_hna = (unsigned char)0;
  signed char res;
  signed int optchar;
  signed int option_index;
  signed int recv_buff_len;
  signed int bytes_written;
  signed int download_speed = 0;
  signed int upload_speed = 0;
  char str1[16l];
  char str2[16l];
  char *slash_ptr;
  char *unix_buff;
  char *buff_ptr;
  char *cr_ptr;
  char routing_class_opt = (char)0;
  char gateway_class_opt = (char)0;
  char pref_gw_opt = (char)0;
  char hop_penalty_opt = (char)0;
  char purge_timeout_opt = (char)0;
  unsigned int vis_server = (unsigned int)0;
  struct option long_options[7l] = { { .name="policy-routing-script", .has_arg=1, .flag=((signed int *)NULL),
    .val=110 },
    { .name="hop-penalty", .has_arg=1, .flag=((signed int *)NULL), .val=109 },
    { .name="purge-timeout", .has_arg=1, .flag=((signed int *)NULL), .val=113 },
    { .name="disable-aggregation", .has_arg=0, .flag=((signed int *)NULL),
    .val=120 },
    { .name="disable-client-nat", .has_arg=0, .flag=((signed int *)NULL),
    .val=122 },
    { .name="no-detach", .has_arg=0, .flag=((signed int *)NULL), .val=68 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
  memset((void *)&tmp_ip_holder, 0, sizeof(struct in_addr) /*4ul*/ );
  stop = (signed char)0;
  prog_name = argv[(signed long int)0];
  signed int *return_value___errno_location_1;
  signed long int return_value_strtol_2;
  signed int *return_value___errno_location_3;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  signed int *return_value___errno_location_6;
  signed long int return_value_strtol_7;
  signed int *return_value___errno_location_8;
  _Bool tmp_if_expr_10;
  signed int *return_value___errno_location_9;
  unsigned long int return_value_strlen_19;
  unsigned long int return_value_strlen_11;
  signed int return_value_strncmp_12;
  _Bool tmp_if_expr_15;
  unsigned long int return_value_strlen_13;
  signed int return_value_strncmp_14;
  _Bool tmp_if_expr_18;
  unsigned long int return_value_strlen_16;
  signed int return_value_strncmp_17;
  _Bool tmp_if_expr_24;
  signed int *return_value___errno_location_23;
  unsigned long int return_value_strlen_25;
  signed int return_value_strncmp_26;
  _Bool tmp_if_expr_29;
  unsigned long int return_value_strlen_27;
  signed int return_value_strncmp_28;
  _Bool tmp_if_expr_32;
  unsigned long int return_value_strlen_30;
  signed int return_value_strncmp_31;
  signed int *return_value___errno_location_34;
  signed long int return_value_strtol_35;
  signed int *return_value___errno_location_36;
  signed long int return_value_strtol_37;
  signed int *return_value___errno_location_38;
  signed long int return_value_strtol_39;
  signed int *return_value___errno_location_40;
  signed int return_value_inet_pton_41;
  signed int *return_value___errno_location_42;
  signed long int return_value_strtol_43;
  signed int *return_value___errno_location_44;
  signed int return_value_inet_pton_45;
  do
  {
    optchar=getopt_long(argc, argv, "a:A:bcd:hHio:g:p:r:s:vVD", long_options, &option_index);
    if(optchar == -1)
      break;

    switch(optchar)
    {
      case 97:
      {
        hna_local_task_add_str(optarg, (unsigned char)0, (unsigned char)0);
        found_args = found_args + (unsigned char)((signed int)*((char *)(optarg - (signed long int)1)) == optchar ? 1 : 2);
        break;
      }
      case 65:
      {
        hna_local_task_add_str(optarg, (unsigned char)1, (unsigned char)0);
        found_args = found_args + (unsigned char)((signed int)*((char *)(optarg - (signed long int)1)) == optchar ? 1 : 2);
        break;
      }
      case 98:
      {
        batch_mode = batch_mode + 1;
        found_args = found_args + 1;
        break;
      }
      case 99:
      {
        unix_client = unix_client + 1;
        found_args = found_args + 1;
        break;
      }
      case 100:
      {
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 0;
        return_value_strtol_2=strtol(optarg, (char ** restrict )(void *)0, 10);
        debug_level = (unsigned char)return_value_strtol_2;
        return_value___errno_location_3=__errno_location();
        if(*return_value___errno_location_3 == 34)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value___errno_location_4=__errno_location();
          tmp_if_expr_5 = (*return_value___errno_location_4 != 0 ? ((signed int)debug_level == 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
        {
          perror("strtol");
          exit(1);
        }

        if(!((signed int)debug_level_max >= (signed int)debug_level))
        {
          printf("Invalid debug level: %i\nDebug level has to be between 0 and %i.\n", debug_level, debug_level_max);
          exit(1);
        }

        found_args = found_args + (unsigned char)((signed int)*((char *)(optarg - (signed long int)1)) == optchar ? 1 : 2);
        break;
      }
      case 103:
      {
        slash_ptr=strchr(optarg, 47);
        if(!(slash_ptr == ((char *)NULL)))
          *slash_ptr = (char)0;

        return_value___errno_location_6=__errno_location();
        *return_value___errno_location_6 = 0;
        return_value_strtol_7=strtol(optarg, (char ** restrict )(void *)0, 10);
        download_speed = (signed int)return_value_strtol_7;
        return_value___errno_location_8=__errno_location();
        if(*return_value___errno_location_8 == 34)
          tmp_if_expr_10 = (_Bool)1;

        else
        {
          return_value___errno_location_9=__errno_location();
          tmp_if_expr_10 = (*return_value___errno_location_9 != 0 ? (download_speed == 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_10)
        {
          perror("strtol");
          exit(1);
        }

        return_value_strlen_19=strlen(optarg);
        if(return_value_strlen_19 >= 5ul)
        {
          return_value_strlen_11=strlen(optarg);
          return_value_strncmp_12=strncmp((optarg + (signed long int)return_value_strlen_11) - (signed long int)4, "MBit", (unsigned long int)4);
          if(return_value_strncmp_12 == 0)
            tmp_if_expr_15 = (_Bool)1;

          else
          {
            return_value_strlen_13=strlen(optarg);
            return_value_strncmp_14=strncmp((optarg + (signed long int)return_value_strlen_13) - (signed long int)4, "mbit", (unsigned long int)4);
            tmp_if_expr_15 = return_value_strncmp_14 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_15)
            tmp_if_expr_18 = (_Bool)1;

          else
          {
            return_value_strlen_16=strlen(optarg);
            return_value_strncmp_17=strncmp((optarg + (signed long int)return_value_strlen_16) - (signed long int)4, "Mbit", (unsigned long int)4);
            tmp_if_expr_18 = return_value_strncmp_17 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_18)
            download_speed = download_speed * 1024;

        }

        if(!(slash_ptr == ((char *)NULL)))
        {
          signed int *return_value___errno_location_20;
          return_value___errno_location_20=__errno_location();
          *return_value___errno_location_20 = 0;
          signed long int return_value_strtol_21;
          return_value_strtol_21=strtol(slash_ptr + (signed long int)1, (char ** restrict )(void *)0, 10);
          upload_speed = (signed int)return_value_strtol_21;
          signed int *return_value___errno_location_22;
          return_value___errno_location_22=__errno_location();
          if(*return_value___errno_location_22 == 34)
            tmp_if_expr_24 = (_Bool)1;

          else
          {
            return_value___errno_location_23=__errno_location();
            tmp_if_expr_24 = (*return_value___errno_location_23 != 0 ? (upload_speed == 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_24)
          {
            perror("strtol");
            exit(1);
          }

          unsigned long int return_value_strlen_33;
          return_value_strlen_33=strlen(slash_ptr + (signed long int)1);
          if(return_value_strlen_33 >= 5ul)
          {
            return_value_strlen_25=strlen(slash_ptr + (signed long int)1);
            return_value_strncmp_26=strncmp((slash_ptr + (signed long int)1 + (signed long int)return_value_strlen_25) - (signed long int)4, "MBit", (unsigned long int)4);
            if(return_value_strncmp_26 == 0)
              tmp_if_expr_29 = (_Bool)1;

            else
            {
              return_value_strlen_27=strlen(slash_ptr + (signed long int)1);
              return_value_strncmp_28=strncmp((slash_ptr + (signed long int)1 + (signed long int)return_value_strlen_27) - (signed long int)4, "mbit", (unsigned long int)4);
              tmp_if_expr_29 = return_value_strncmp_28 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_29)
              tmp_if_expr_32 = (_Bool)1;

            else
            {
              return_value_strlen_30=strlen(slash_ptr + (signed long int)1);
              return_value_strncmp_31=strncmp((slash_ptr + (signed long int)1 + (signed long int)return_value_strlen_30) - (signed long int)4, "Mbit", (unsigned long int)4);
              tmp_if_expr_32 = return_value_strncmp_31 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_32)
              upload_speed = upload_speed * 1024;

          }

          *slash_ptr = (char)47;
        }

        gateway_class_opt = (char)1;
        found_args = found_args + (unsigned char)((signed int)*((char *)(optarg - (signed long int)1)) == optchar ? 1 : 2);
        break;
      }
      case 72:
      {
        verbose_usage();
        exit(0);
      }
      case 105:
      {
        info_output = info_output + 1;
        found_args = found_args + 1;
        break;
      }
      case 110:
      {
        policy_routing_script = optarg;
        found_args = found_args + (unsigned char)((signed int)*((char *)(optarg - (signed long int)1)) == optchar ? 1 : 2);
        break;
      }
      case 109:
      {
        return_value___errno_location_34=__errno_location();
        *return_value___errno_location_34 = 0;
        return_value_strtol_35=strtol(optarg, (char ** restrict )(void *)0, 10);
        hop_penalty = (unsigned char)return_value_strtol_35;
        hop_penalty_opt = (char)1;
        found_args = found_args + (unsigned char)((signed int)*((char *)(optarg - (signed long int)1)) == optchar ? 1 : 2);
        break;
      }
      case 113:
      {
        return_value___errno_location_36=__errno_location();
        *return_value___errno_location_36 = 0;
        return_value_strtol_37=strtol(optarg, (char ** restrict )(void *)0, 10);
        purge_timeout = (unsigned int)return_value_strtol_37;
        purge_timeout_opt = (char)1;
        found_args = found_args + (unsigned char)((signed int)*((char *)(optarg - (signed long int)1)) == optchar ? 1 : 2);
        break;
      }
      case 111:
      {
        return_value___errno_location_38=__errno_location();
        *return_value___errno_location_38 = 0;
        return_value_strtol_39=strtol(optarg, (char ** restrict )(void *)0, 10);
        originator_interval = (signed short int)return_value_strtol_39;
        if(!((signed int)originator_interval >= 1))
        {
          printf("Invalid originator interval specified: %i.\nThe Interval has to be greater than 0.\n", originator_interval);
          exit(1);
        }

        found_args = found_args + (unsigned char)((signed int)*((char *)(optarg - (signed long int)1)) == optchar ? 1 : 2);
        break;
      }
      case 112:
      {
        return_value___errno_location_40=__errno_location();
        *return_value___errno_location_40 = 0;
        return_value_inet_pton_41=inet_pton(2, optarg, (void *)&tmp_ip_holder);
        if(!(return_value_inet_pton_41 >= 1))
        {
          printf("Invalid preferred gateway IP specified: %s\n", optarg);
          exit(1);
        }

        pref_gateway = tmp_ip_holder.s_addr;
        pref_gw_opt = (char)1;
        found_args = found_args + (unsigned char)((signed int)*((char *)(optarg - (signed long int)1)) == optchar ? 1 : 2);
        break;
      }
      case 114:
      {
        return_value___errno_location_42=__errno_location();
        *return_value___errno_location_42 = 0;
        return_value_strtol_43=strtol(optarg, (char ** restrict )(void *)0, 10);
        routing_class = (unsigned char)return_value_strtol_43;
        routing_class_opt = (char)1;
        found_args = found_args + (unsigned char)((signed int)*((char *)(optarg - (signed long int)1)) == optchar ? 1 : 2);
        break;
      }
      case 115:
      {
        return_value___errno_location_44=__errno_location();
        *return_value___errno_location_44 = 0;
        return_value_inet_pton_45=inet_pton(2, optarg, (void *)&tmp_ip_holder);
        if(!(return_value_inet_pton_45 >= 1))
        {
          printf("Invalid preferred visualation server IP specified: %s\n", optarg);
          exit(1);
        }

        vis_server = tmp_ip_holder.s_addr;
        found_args = found_args + (unsigned char)((signed int)*((char *)(optarg - (signed long int)1)) == optchar ? 1 : 2);
        break;
      }
      case 118:
      {
        printf("B.A.T.M.A.N. %s (compatibility version %i)\n", (const void *)"debian-0.3.2-17", 5);
        exit(0);
      }
      case 86:
      {
        print_animation();
        printf("\033[0;0HB.A.T.M.A.N. %s (compatibility version %i)\n", (const void *)"debian-0.3.2-17", 5);
        printf("\033[9;0H \t May the bat guide your path ...\n\n\n");
        exit(0);
      }
      case 120:
      {
        aggregation_enabled = (unsigned char)0;
        found_args = found_args + 1;
        break;
      }
      case 122:
      {
        disable_client_nat = (signed char)1;
        found_args = found_args + 1;
        break;
      }
      case 68:
      {
        no_detach = 1;
        found_args = found_args + 1;
        break;
      }
      case 104:

      default:
      {
        usage();
        exit(0);
      }
    }
  }
  while((_Bool)1);
  if(unix_client == 0 && !(info_output == 0))
  {
    internal_output((unsigned int)1);
    exit(0);
  }

  if(upload_speed == 0 && download_speed >= 1)
    upload_speed = download_speed / 5;

  if(download_speed >= 1)
  {
    gateway_class=get_gw_class(download_speed, upload_speed);
    get_gw_speeds(gateway_class, &download_speed, &upload_speed);
  }

  if(!((signed int)gateway_class == 0) && !((signed int)routing_class == 0))
  {
    fprintf(stderr, "Error - routing class can't be set while gateway class is in use !\n");
    usage();
    exit(1);
  }

  if(!(pref_gateway == 0u) && !((signed int)gateway_class == 0))
  {
    fprintf(stderr, "Error - preferred gateway can't be set while gateway class is in use !\n");
    usage();
    exit(1);
  }

  if((signed int)routing_class == 0 && !(pref_gateway == 0u))
    routing_class = (unsigned char)30;

  signed char return_value_probe_tun_46;
  if(!((signed int)gateway_class == 0) || !((signed int)routing_class == 0))
  {
    return_value_probe_tun_46=probe_tun((unsigned char)1);
    if(return_value_probe_tun_46 == 0)
      exit(1);

  }

  signed int return_value_connect_67;
  void *return_value_debugMalloc_68;
  signed int return_value_list_empty_69;
  signed long int return_value_write_72;
  signed long int return_value_read_73;
  signed int return_value_strncmp_74;
  signed int return_value_list_empty_79;
  if(unix_client == 0)
  {
    if((signed int)found_args >= argc)
    {
      fprintf(stderr, "Error - no interface specified\n");
      usage();
      exit(1);
    }

    if((signed int)routing_class == 0 && !(disable_client_nat == 0))
      fprintf(stderr, "Warning - the activated option '--disable-client-nat' has no effect without setting a routing class.\n");

    nat_tool_avail=probe_nat_tool();
    if(!(policy_routing_script == ((char *)NULL)))
      create_routing_pipe();

    signal(2, handler);
    signal(15, handler);
    signal(13, (void (*)(signed int))1);
    signal(11, segmentation_fault);
    void *return_value_debugMalloc_47;
    return_value_debugMalloc_47=debugMalloc((unsigned int)(sizeof(struct list_head_first *) /*8ul*/  * (unsigned long int)debug_level_max), 203);
    debug_clients.fd_list = (void **)return_value_debugMalloc_47;
    void *return_value_debugMalloc_48;
    return_value_debugMalloc_48=debugMalloc((unsigned int)(sizeof(union anonymous_16 *) /*8ul*/  * (unsigned long int)debug_level_max), 209);
    debug_clients.mutex = (union anonymous_16 **)return_value_debugMalloc_48;
    void *return_value_debugMalloc_49;
    return_value_debugMalloc_49=debugMalloc((unsigned int)(sizeof(signed short int) /*2ul*/  * (unsigned long int)debug_level_max), 209);
    debug_clients.clients_num = (signed short int *)return_value_debugMalloc_49;
    res = (signed char)0;
    for( ; !((signed int)res >= (signed int)debug_level_max); res = res + 1)
    {
      debug_clients.fd_list[(signed long int)res]=debugMalloc((unsigned int)sizeof(struct list_head_first) /*16ul*/ , 204);
      ((struct list_head_first *)debug_clients.fd_list[(signed long int)res])->next = (struct list_head *)debug_clients.fd_list[(signed long int)res];
      ((struct list_head_first *)debug_clients.fd_list[(signed long int)res])->prev = (struct list_head *)debug_clients.fd_list[(signed long int)res];
      void *return_value_debugMalloc_50;
      return_value_debugMalloc_50=debugMalloc((unsigned int)sizeof(union anonymous_16) /*40ul*/ , 209);
      debug_clients.mutex[(signed long int)res] = (union anonymous_16 *)return_value_debugMalloc_50;
      pthread_mutex_init((union anonymous_16 *)debug_clients.mutex[(signed long int)res], (const union anonymous *)(void *)0);
      debug_clients.clients_num[(signed long int)res] = (signed short int)0;
    }
    signed int return_value_flush_routes_rules_51;
    return_value_flush_routes_rules_51=flush_routes_rules((signed char)0);
    if(!(return_value_flush_routes_rules_51 >= 0))
      exit(1);

    signed int return_value_flush_routes_rules_52;
    return_value_flush_routes_rules_52=flush_routes_rules((signed char)1);
    if(!(return_value_flush_routes_rules_52 >= 0))
      exit(1);

    while(!((signed int)found_args >= argc))
    {
      if((signed int)*argv[(signed long int)found_args] == 45)
      {
        fprintf(stderr, "%s: invalid option -- %s\n", argv[(signed long int)0], argv[(signed long int)found_args]);
        usage();
        exit(1);
      }

      void *return_value_debugMalloc_53;
      return_value_debugMalloc_53=debugMalloc((unsigned int)sizeof(struct batman_if) /*104ul*/ , 206);
      batman_if = (struct batman_if *)return_value_debugMalloc_53;
      memset((void *)batman_if, 0, sizeof(struct batman_if) /*104ul*/ );
      do
        (&batman_if->list)->next = &batman_if->list;
      while((_Bool)0);
      batman_if->dev = argv[(signed long int)found_args];
      batman_if->if_num = found_ifs;
      batman_if->if_rp_filter_old = (signed char)-1;
      batman_if->if_send_redirects_old = (signed char)-1;
      list_add_tail(&batman_if->list, &if_list);
      init_interface(batman_if);
      if((signed int)batman_if->if_num >= 1)
        hna_local_task_add_ip(batman_if->addr.sin_addr.s_addr, (unsigned short int)32, (unsigned char)0);

      if(!(batman_if->if_active == 0))
      {
        addr_to_string(batman_if->addr.sin_addr.s_addr, str1, (signed int)sizeof(char [16l]) /*16ul*/ );
        addr_to_string(batman_if->broad.sin_addr.s_addr, str2, (signed int)sizeof(char [16l]) /*16ul*/ );
        printf("Using interface %s with address %s and broadcast address %s\n", batman_if->dev, (const void *)str1, (const void *)str2);
      }

      else
        printf("Not using interface %s (retrying later): interface not active\n", batman_if->dev);
      found_ifs = found_ifs + 1;
      found_args = found_args + 1;
    }
    unlink("/var/run/batmand.socket");
    unix_if.unix_sock=socket(1, 1, 0);
    memset((void *)&unix_if.addr, 0, sizeof(struct sockaddr_un) /*110ul*/ );
    unix_if.addr.sun_family = (unsigned short int)1;
    strcpy(unix_if.addr.sun_path, "/var/run/batmand.socket");
    signed int return_value_bind_56;
    return_value_bind_56=bind(unix_if.unix_sock, (struct sockaddr *)&unix_if.addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
    if(!(return_value_bind_56 >= 0))
    {
      signed int *return_value___errno_location_54;
      return_value___errno_location_54=__errno_location();
      char *return_value_strerror_55;
      return_value_strerror_55=strerror(*return_value___errno_location_54);
      printf("Error - can't bind unix socket '%s': %s\n", (const void *)"/var/run/batmand.socket", return_value_strerror_55);
      restore_defaults();
      exit(1);
    }

    signed int return_value_listen_59;
    return_value_listen_59=listen(unix_if.unix_sock, 10);
    if(!(return_value_listen_59 >= 0))
    {
      signed int *return_value___errno_location_57;
      return_value___errno_location_57=__errno_location();
      char *return_value_strerror_58;
      return_value_strerror_58=strerror(*return_value___errno_location_57);
      printf("Error - can't listen unix socket '%s': %s\n", (const void *)"/var/run/batmand.socket", return_value_strerror_58);
      restore_defaults();
      exit(1);
    }

    if((signed int)debug_level == 0)
    {
      if(no_detach == 0)
      {
        signed int return_value_my_daemon_62;
        return_value_my_daemon_62=my_daemon();
        if(!(return_value_my_daemon_62 >= 0))
        {
          signed int *return_value___errno_location_60;
          return_value___errno_location_60=__errno_location();
          char *return_value_strerror_61;
          return_value_strerror_61=strerror(*return_value___errno_location_60);
          printf("Error - can't fork to background: %s\n", return_value_strerror_61);
          restore_defaults();
          exit(1);
        }

      }

      openlog("batmand", 0x01, 3 << 3);
    }

    else
    {
      printf("B.A.T.M.A.N. %s (compatibility version %i)\n", (const void *)"debian-0.3.2-17", 5);
      debug_clients.clients_num[(signed long int)((signed int)debug_level - 1)] = debug_clients.clients_num[(signed long int)((signed int)debug_level - 1)] + 1;
      void *return_value_debugMalloc_63;
      return_value_debugMalloc_63=debugMalloc((unsigned int)sizeof(struct debug_level_info) /*16ul*/ , 205);
      debug_level_info = (struct debug_level_info *)return_value_debugMalloc_63;
      do
        (&debug_level_info->list)->next = &debug_level_info->list;
      while((_Bool)0);
      debug_level_info->fd = 2;
      list_add(&debug_level_info->list, (struct list_head_first *)debug_clients.fd_list[(signed long int)((signed int)debug_level - 1)]);
    }
    log_facility_active = (unsigned char)1;
    pthread_create(&unix_if.listen_thread_id, (const union pthread_attr_t *)(void *)0, unix_listen, (void *)0);
    add_del_rule((unsigned int)0, (unsigned char)0, (signed char)65, (unsigned int)((6600 + 100) - 1), ((char *)NULL), (signed char)1, (signed char)0);
    add_del_route((unsigned int)0, (unsigned char)0, (unsigned int)0, (unsigned int)0, 0, "unknown", (unsigned char)67, (signed char)2, (signed char)0);
    if((signed int)routing_class >= 1)
    {
      signed int return_value_add_del_interface_rules_64;
      return_value_add_del_interface_rules_64=add_del_interface_rules((signed char)0);
      if(!(return_value_add_del_interface_rules_64 >= 0))
      {
        restore_defaults();
        exit(1);
      }

    }

    memset((void *)&vis_if, 0, sizeof(struct vis_if) /*20ul*/ );
    if(!(vis_server == 0u))
    {
      vis_if.addr.sin_family = (unsigned short int)2;
      vis_if.addr.sin_port=htons((unsigned short int)(4305 + 2));
      vis_if.addr.sin_addr.s_addr = vis_server;
      vis_if.sock=socket(2, 2, 0);
    }

    if(!((signed int)gateway_class == 0))
      init_interface_gw();

    if((signed int)debug_level >= 1)
    {
      printf("debug level: %i\n", debug_level);
      if(!((signed int)originator_interval == 1000))
        printf("originator interval: %i\n", originator_interval);

      if((signed int)gateway_class >= 1)
        printf("gateway class: %i -> propagating: %i%s/%i%s\n", gateway_class, download_speed > 2048 ? download_speed / 1024 : download_speed, download_speed > 2048 ? "MBit" : "KBit", upload_speed > 2048 ? upload_speed / 1024 : upload_speed, upload_speed > 2048 ? "MBit" : "KBit");

      if((signed int)routing_class >= 1)
        printf("routing class: %i\n", routing_class);

      if(pref_gateway >= 1u)
      {
        addr_to_string(pref_gateway, str1, (signed int)sizeof(char [16l]) /*16ul*/ );
        printf("preferred gateway: %s\n", (const void *)str1);
      }

      if(vis_server >= 1u)
      {
        addr_to_string(vis_server, str1, (signed int)sizeof(char [16l]) /*16ul*/ );
        printf("visualisation server: %s\n", (const void *)str1);
      }

    }

  }

  else
  {
    do
    {

    more_hna:
      ;
      unix_if.unix_sock=socket(1, 1, 0);
      memset((void *)&unix_if.addr, 0, sizeof(struct sockaddr_un) /*110ul*/ );
      unix_if.addr.sun_family = (unsigned short int)1;
      strcpy(unix_if.addr.sun_path, "/var/run/batmand.socket");
      return_value_connect_67=connect(unix_if.unix_sock, (struct sockaddr *)&unix_if.addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
      if(!(return_value_connect_67 >= 0))
      {
        signed int *return_value___errno_location_65;
        return_value___errno_location_65=__errno_location();
        char *return_value_strerror_66;
        return_value_strerror_66=strerror(*return_value___errno_location_65);
        printf("Error - can't connect to unix socket '%s': %s ! Is batmand running on this host ?\n", (const void *)"/var/run/batmand.socket", return_value_strerror_66);
        close(unix_if.unix_sock);
        exit(1);
      }

      return_value_debugMalloc_68=debugMalloc((unsigned int)1501, 5001);
      unix_buff = (char *)return_value_debugMalloc_68;
      if((signed int)debug_level >= 1)
      {
        if((signed int)debug_level_max >= (signed int)debug_level)
        {
          snprintf(unix_buff, (unsigned long int)10, "d:%c", debug_level);
          if((signed int)debug_level >= 3 && !(batch_mode == 0))
            printf("WARNING: Your chosen debug level (%i) does not support batch mode !\n", debug_level);

        }

      }

      else
        if(!(routing_class_opt == 0))
        {
          batch_mode = (unsigned char)1;
          snprintf(unix_buff, (unsigned long int)10, "r:%c", routing_class);
        }

        else
          if(!(pref_gw_opt == 0))
          {
            batch_mode = (unsigned char)1;
            addr_to_string(pref_gateway, str1, (signed int)sizeof(char [16l]) /*16ul*/ );
            snprintf(unix_buff, (unsigned long int)20, "p:%s", (const void *)str1);
          }

          else
            if(!(gateway_class_opt == 0))
            {
              batch_mode = (unsigned char)1;
              snprintf(unix_buff, (unsigned long int)10, "g:%c", gateway_class);
            }

            else
              if(!(hop_penalty_opt == 0))
              {
                batch_mode = (unsigned char)1;
                snprintf(unix_buff, (unsigned long int)10, "m:%c", hop_penalty);
              }

              else
                if(!(purge_timeout_opt == 0))
                {
                  batch_mode = (unsigned char)1;
                  snprintf(unix_buff, (unsigned long int)20, "q:%u", purge_timeout);
                }

                else
                  if(!(info_output == 0))
                  {
                    batch_mode = (unsigned char)1;
                    snprintf(unix_buff, (unsigned long int)10, "i");
                  }

                  else
                  {
                    return_value_list_empty_69=list_empty(&hna_chg_list);
                    if(return_value_list_empty_69 == 0)
                    {
                      was_hna = (unsigned char)1;
                      batch_mode = was_hna;
                      hna_task = (struct hna_task *)hna_chg_list.next;
                      addr_to_string(hna_task->addr, str1, (signed int)sizeof(char [16l]) /*16ul*/ );
                      snprintf(unix_buff, (unsigned long int)30, "%c:%s/%i", (signed int)hna_task->route_action == 0 ? 97 : 65, (const void *)str1, hna_task->netmask);
                      list_del((struct list_head *)&hna_chg_list, &hna_task->list, &hna_chg_list);
                      debugFree((void *)hna_task, 1298);
                    }

                    else
                    {
                      batch_mode = (unsigned char)1;
                      snprintf(unix_buff, (unsigned long int)10, "y");
                    }
                  }
      return_value_write_72=write(unix_if.unix_sock, (const void *)unix_buff, (unsigned long int)30);
      if(!(return_value_write_72 >= 0l))
      {
        signed int *return_value___errno_location_70;
        return_value___errno_location_70=__errno_location();
        char *return_value_strerror_71;
        return_value_strerror_71=strerror(*return_value___errno_location_70);
        printf("Error - can't write to unix socket: %s\n", return_value_strerror_71);
        close(unix_if.unix_sock);
        debugFree((void *)unix_buff, 5101);
        exit(1);
      }

      do
      {
        return_value_read_73=read(unix_if.unix_sock, (void *)unix_buff, (unsigned long int)1500);
        recv_buff_len = (signed int)return_value_read_73;
        if(!(recv_buff_len >= 1))
          break;

        unix_buff[(signed long int)recv_buff_len] = (char)0;
        buff_ptr = unix_buff;
        bytes_written = 0;
        do
        {
          cr_ptr=strchr(buff_ptr, 10);
          if(cr_ptr == ((char *)NULL))
            break;

          *cr_ptr = (char)0;
          signed int return_value_strncmp_75;
          return_value_strncmp_75=strncmp(buff_ptr, "EOD", (unsigned long int)3);
          if(return_value_strncmp_75 == 0)
          {
            if(!(batch_mode == 0))
              goto close_con;

          }

          else
          {
            return_value_strncmp_74=strncmp(buff_ptr, "BOD", (unsigned long int)3);
            if(return_value_strncmp_74 == 0)
            {
              if(batch_mode == 0)
                printf("\033[2J\033[0;0f");

            }

            else
              printf("%s\n", buff_ptr);
          }
          unsigned long int return_value_strlen_76;
          return_value_strlen_76=strlen(buff_ptr);
          bytes_written = bytes_written + (signed int)(return_value_strlen_76 + (unsigned long int)1);
          buff_ptr = cr_ptr + (signed long int)1;
        }
        while((_Bool)1);
        if(!(bytes_written == recv_buff_len))
          printf("%s", buff_ptr);

      }
      while((_Bool)1);

    close_con:
      ;
      close(unix_if.unix_sock);
      debugFree((void *)unix_buff, 5102);
      if(!(recv_buff_len >= 0))
      {
        signed int *return_value___errno_location_77;
        return_value___errno_location_77=__errno_location();
        char *return_value_strerror_78;
        return_value_strerror_78=strerror(*return_value___errno_location_77);
        printf("Error - can't read from unix socket: %s\n", return_value_strerror_78);
        exit(1);
      }

      else
        if(batch_mode == 0)
          printf("Connection terminated by remote host\n");

      if(was_hna == 0)
        break;

      return_value_list_empty_79=list_empty(&hna_chg_list);
    }
    while(return_value_list_empty_79 == 0);
    exit(0);
  }
}

// bat_wait
// file posix/posix.c line 168
static void bat_wait(signed int T, signed int t)
{
  struct timeval time;
  time.tv_sec = (signed long int)T;
  time.tv_usec = (signed long int)(t * 10000);
  select(0, (struct anonymous_15 *)(void *)0, (struct anonymous_15 *)(void *)0, (struct anonymous_15 *)(void *)0, &time);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// batman
// file batman.c line 765
signed char batman(void)
{
  struct list_head *list_pos;
  struct list_head *forw_pos_tmp;
  struct orig_node *orig_neigh_node;
  struct orig_node *orig_node;
  struct batman_if *batman_if;
  struct batman_if *if_incoming;
  struct forw_node *forw_node;
  struct bat_packet *bat_packet;
  unsigned int neigh;
  unsigned int debug_timeout;
  unsigned int vis_timeout;
  unsigned int select_timeout;
  unsigned int curr_time;
  unsigned char in[2001l];
  unsigned char *hna_recv_buff;
  char orig_str[16l];
  char neigh_str[16l];
  char ifaddr_str[16l];
  char prev_sender_str[16l];
  signed short int hna_buff_len;
  signed short int packet_len;
  signed short int curr_packet_len;
  unsigned char forward_old;
  unsigned char if_rp_filter_all_old;
  unsigned char if_rp_filter_default_old;
  unsigned char if_send_redirects_all_old;
  unsigned char if_send_redirects_default_old;
  unsigned char is_my_addr;
  unsigned char is_my_orig;
  unsigned char is_my_oldorig;
  unsigned char is_broadcast;
  unsigned char is_duplicate;
  unsigned char is_bidirectional;
  unsigned char has_directlink_flag;
  signed char res;
  vis_timeout=get_time_msec();
  debug_timeout = vis_timeout;
  orig_hash=hash_new(128, compare_orig, choose_orig);
  signed char return_value_is_aborted_6;
  unsigned int tmp_if_expr_7;
  struct orig_node *tmp_if_expr_10;
  struct orig_node *return_value_get_orig_node_9;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_12;
  if(orig_hash == ((struct hashtable_t *)NULL))
    return (signed char)-1;

  else
  {
    prof_init(0, "choose_gw");
    prof_init(1, "update_routes");
    prof_init(2, "update_gw_list");
    prof_init(3, "isDuplicate");
    prof_init(4, "get_orig_node");
    prof_init(5, "update_orig");
    prof_init(6, "purge_orig");
    prof_init(7, "schedule_forward_packet");
    prof_init(8, "send_outstanding_packets");
    list_pos = (&if_list)->next;
    for( ; !(list_pos == (struct list_head *)&if_list); list_pos = list_pos->next)
    {
      batman_if = (struct batman_if *)((char *)list_pos - (signed long int)(unsigned long int)&((struct batman_if *)0)->list);
      batman_if->out.version = (unsigned char)5;
      batman_if->out.flags = (unsigned char)0x00;
      batman_if->out.ttl = (unsigned char)((signed int)batman_if->if_num > 0 ? 2 : 50);
      batman_if->out.gwflags = (unsigned char)((signed int)batman_if->if_num > 0 ? 0 : (signed int)gateway_class);
      batman_if->out.seqno = (unsigned short int)1;
      batman_if->out.gwport=htons((unsigned short int)4306);
      batman_if->out.tq = (unsigned char)255;
      schedule_own_packet(batman_if);
    }
    signed int return_value_get_rp_filter_1;
    return_value_get_rp_filter_1=get_rp_filter("all");
    if_rp_filter_all_old = (unsigned char)return_value_get_rp_filter_1;
    signed int return_value_get_rp_filter_2;
    return_value_get_rp_filter_2=get_rp_filter("default");
    if_rp_filter_default_old = (unsigned char)return_value_get_rp_filter_2;
    signed int return_value_get_send_redirects_3;
    return_value_get_send_redirects_3=get_send_redirects("all");
    if_send_redirects_all_old = (unsigned char)return_value_get_send_redirects_3;
    signed int return_value_get_send_redirects_4;
    return_value_get_send_redirects_4=get_send_redirects("default");
    if_send_redirects_default_old = (unsigned char)return_value_get_send_redirects_4;
    set_rp_filter(0, "all");
    set_rp_filter(0, "default");
    set_send_redirects(0, "all");
    set_send_redirects(0, "default");
    signed int return_value_get_forwarding_5;
    return_value_get_forwarding_5=get_forwarding();
    forward_old = (unsigned char)return_value_get_forwarding_5;
    set_forwarding(1);
    do
    {
      return_value_is_aborted_6=is_aborted();
      if(!(return_value_is_aborted_6 == 0))
        break;

      debug_output((signed char)4, " \n");
      curr_time=get_time_msec();
      if((signed int)((struct forw_node *)forw_list.next)->send_time + -((signed int)curr_time) >= 1)
        tmp_if_expr_7 = ((struct forw_node *)forw_list.next)->send_time - curr_time;

      else
        tmp_if_expr_7 = (unsigned int)10;
      select_timeout = tmp_if_expr_7;
      res=receive_packet(in, (signed int)sizeof(unsigned char [2001l]) /*2001ul*/ , &packet_len, &neigh, select_timeout, &if_incoming);
      if((signed int)res >= 1)
      {
        curr_time=get_time_msec();
        curr_packet_len = (signed short int)0;
        bat_packet = (struct bat_packet *)in;
        addr_to_string(neigh, neigh_str, (signed int)sizeof(char [16l]) /*16ul*/ );
        addr_to_string(if_incoming->addr.sin_addr.s_addr, ifaddr_str, (signed int)sizeof(char [16l]) /*16ul*/ );
        while((signed int)packet_len >= (signed int)sizeof(struct bat_packet) /*18*/  + (signed int)curr_packet_len)
        {
          if(!((signed int)packet_len >= 5 * (signed int)bat_packet->hna_len + (signed int)sizeof(struct bat_packet) /*18*/  + (signed int)curr_packet_len))
            break;

          if(5 * (signed int)bat_packet->hna_len + (signed int)sizeof(struct bat_packet) /*18*/  + (signed int)curr_packet_len >= 513)
            break;

          bat_packet = (struct bat_packet *)(in + (signed long int)curr_packet_len);
          curr_packet_len = curr_packet_len + (signed short int)(sizeof(struct bat_packet) /*18ul*/  + (unsigned long int)((signed int)bat_packet->hna_len * 5));
          bat_packet->seqno=ntohs(bat_packet->seqno);
          addr_to_string(bat_packet->orig, orig_str, (signed int)sizeof(char [16l]) /*16ul*/ );
          addr_to_string(bat_packet->prev_sender, prev_sender_str, (signed int)sizeof(char [16l]) /*16ul*/ );
          is_broadcast = (unsigned char)0;
          is_my_oldorig = is_broadcast;
          is_my_orig = is_my_oldorig;
          is_my_addr = is_my_orig;
          has_directlink_flag = (unsigned char)(((signed int)bat_packet->flags & 0x40) != 0 ? 1 : 0);
          debug_output((signed char)4, "Received BATMAN packet via NB: %s, IF: %s %s (from OG: %s, via old OG: %s, seqno %d, tq %d, TTL %d, V %d, IDF %d) \n", (const void *)neigh_str, if_incoming->dev, (const void *)ifaddr_str, (const void *)orig_str, (const void *)prev_sender_str, bat_packet->seqno, bat_packet->tq, bat_packet->ttl, bat_packet->version, has_directlink_flag);
          hna_buff_len = (signed short int)((signed int)bat_packet->hna_len * 5);
          hna_recv_buff = (signed int)hna_buff_len > 4 ? (unsigned char *)(bat_packet + (signed long int)1) : (unsigned char *)(void *)0;
          list_pos = (&if_list)->next;
          for( ; !(list_pos == (struct list_head *)&if_list); list_pos = list_pos->next)
          {
            batman_if = (struct batman_if *)((char *)list_pos - (signed long int)(unsigned long int)&((struct batman_if *)0)->list);
            if(neigh == batman_if->addr.sin_addr.s_addr)
              is_my_addr = (unsigned char)1;

            if(bat_packet->orig == batman_if->addr.sin_addr.s_addr)
              is_my_orig = (unsigned char)1;

            if(neigh == batman_if->broad.sin_addr.s_addr)
              is_broadcast = (unsigned char)1;

            if(bat_packet->prev_sender == batman_if->addr.sin_addr.s_addr)
              is_my_oldorig = (unsigned char)1;

          }
          if(!((signed int)bat_packet->gwflags == 0))
            debug_output((signed char)4, "Is an internet gateway (class %i) \n", bat_packet->gwflags);

          if(!((signed int)bat_packet->version == 5))
          {
            debug_output((signed char)4, "Drop packet: incompatible batman version (%i) \n", bat_packet->version);
            break;
          }

          if(!(is_my_addr == 0))
          {
            debug_output((signed char)4, "Drop packet: received my own broadcast (sender: %s) \n", (const void *)neigh_str);
            break;
          }

          if(!(is_broadcast == 0))
          {
            debug_output((signed char)4, "Drop packet: ignoring all packets with broadcast source IP (sender: %s) \n", (const void *)neigh_str);
            break;
          }

          if(!(is_my_orig == 0))
          {
            orig_neigh_node=get_orig_node(neigh);
            if(!(has_directlink_flag == 0))
            {
              if(if_incoming->addr.sin_addr.s_addr == bat_packet->orig)
              {
                if((signed int)bat_packet->seqno + -((signed int)if_incoming->out.seqno) == -2)
                {
                  debug_output((signed char)4, "count own bcast (is_my_orig): old = %i, ", orig_neigh_node->bcast_own_sum[(signed long int)if_incoming->if_num]);
                  bit_mark((unsigned long int *)&orig_neigh_node->bcast_own[(signed long int)((signed int)if_incoming->if_num * (signed int)num_words)], 0);
                  signed int return_value_bit_packet_count_8;
                  return_value_bit_packet_count_8=bit_packet_count((unsigned long int *)&orig_neigh_node->bcast_own[(signed long int)((signed int)if_incoming->if_num * (signed int)num_words)]);
                  orig_neigh_node->bcast_own_sum[(signed long int)if_incoming->if_num] = (unsigned char)return_value_bit_packet_count_8;
                  debug_output((signed char)4, "new = %i \n", orig_neigh_node->bcast_own_sum[(signed long int)if_incoming->if_num]);
                }

              }

            }

            debug_output((signed char)4, "Drop packet: originator packet from myself (via neighbour) \n");
            break;
          }

          if((signed int)bat_packet->tq == 0)
          {
            count_real_packets(bat_packet, neigh, if_incoming);
            debug_output((signed char)4, "Drop packet: originator packet with tq is 0 \n");
            break;
          }

          if(!(is_my_oldorig == 0))
          {
            debug_output((signed char)4, "Drop packet: ignoring all rebroadcast echos (sender: %s) \n", (const void *)neigh_str);
            break;
          }

          is_duplicate=count_real_packets(bat_packet, neigh, if_incoming);
          orig_node=get_orig_node(bat_packet->orig);
          if(bat_packet->orig == neigh)
            tmp_if_expr_10 = orig_node;

          else
          {
            return_value_get_orig_node_9=get_orig_node(neigh);
            tmp_if_expr_10 = return_value_get_orig_node_9;
          }
          orig_neigh_node = tmp_if_expr_10;
          if(!(bat_packet->orig == neigh))
          {
            if(orig_neigh_node->router == ((struct neigh_node *)NULL))
            {
              debug_output((signed char)4, "Drop packet: OGM via unknown neighbor! \n");
              break;
            }

          }

          signed int return_value_isBidirectionalNeigh_11;
          return_value_isBidirectionalNeigh_11=isBidirectionalNeigh(orig_node, orig_neigh_node, bat_packet, curr_time, if_incoming);
          is_bidirectional = (unsigned char)return_value_isBidirectionalNeigh_11;
          if(!(is_bidirectional == 0))
          {
            if(is_duplicate == 0)
              tmp_if_expr_13 = (_Bool)1;

            else
            {
              if(orig_node->last_real_seqno == bat_packet->seqno)
                tmp_if_expr_12 = (signed int)orig_node->last_ttl - 3 <= (signed int)bat_packet->ttl ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_12 = (_Bool)0;
              tmp_if_expr_13 = tmp_if_expr_12 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_13)
              update_orig(orig_node, bat_packet, neigh, if_incoming, hna_recv_buff, hna_buff_len, is_duplicate, curr_time);

          }

          if(bat_packet->orig == neigh)
          {
            schedule_forward_packet(orig_node, bat_packet, neigh, (unsigned char)1, hna_buff_len, if_incoming, curr_time);
            debug_output((signed char)4, "Forward packet: rebroadcast neighbour packet with direct link flag \n");
            break;
          }

          if(is_bidirectional == 0)
          {
            debug_output((signed char)4, "Drop packet: not received via bidirectional link\n");
            break;
          }

          if(!(is_duplicate == 0))
          {
            debug_output((signed char)4, "Drop packet: duplicate packet received\n");
            break;
          }

          debug_output((signed char)4, "Forward packet: rebroadcast originator packet \n");
          schedule_forward_packet(orig_node, bat_packet, neigh, (unsigned char)0, hna_buff_len, if_incoming, curr_time);
        }
      }


    send_packets:
      ;
      send_outstanding_packets(curr_time);
      if((signed int)curr_time + -(1000 + (signed int)debug_timeout) >= 1)
      {
        debug_timeout = curr_time;
        purge_orig(curr_time);
        debug_orig();
        check_inactive_interfaces();
        if((signed int)debug_clients.clients_num[4l] >= 1)
        {
          checkIntegrity();
          prof_print();
        }

        if(curr_gateway == ((struct gw_node *)NULL) && !((signed int)routing_class == 0))
          choose_gw();

        if((signed int)curr_time + -(10000 + (signed int)vis_timeout) >= 1 && !(vis_if.sock == 0))
        {
          vis_timeout = curr_time;
          send_vis_packet();
        }

        hna_local_task_exec();
      }

    }
    while((_Bool)1);
    if((signed int)debug_level >= 1)
      printf("Deleting all BATMAN routes\n");

    unsigned int return_value_get_time_msec_14;
    return_value_get_time_msec_14=get_time_msec();
    purge_orig(return_value_get_time_msec_14 + (unsigned int)5 * purge_timeout + (unsigned int)originator_interval);
    hash_destroy(orig_hash);
    list_pos = (&forw_list)->next;
    forw_pos_tmp = list_pos->next;
    for( ; !(list_pos == (struct list_head *)&forw_list); forw_pos_tmp = list_pos->next)
    {
      forw_node = (struct forw_node *)((char *)list_pos - (signed long int)(unsigned long int)&((struct forw_node *)0)->list);
      list_del((struct list_head *)&forw_list, list_pos, &forw_list);
      debugFree((void *)forw_node->pack_buff, 1105);
      debugFree((void *)forw_node, 1106);
      list_pos = forw_pos_tmp;
    }
    if(!(vis_packet == ((unsigned char *)NULL)))
      debugFree((void *)vis_packet, 1108);

    set_forwarding((signed int)forward_old);
    set_rp_filter((signed int)if_rp_filter_all_old, "all");
    set_rp_filter((signed int)if_rp_filter_default_old, "default");
    set_send_redirects((signed int)if_send_redirects_all_old, "all");
    set_send_redirects((signed int)if_send_redirects_default_old, "default");
    return (signed char)0;
  }
}

// bind_to_iface
// file linux/kernel.c line 149
signed char bind_to_iface(signed int sock, char *dev)
{
  char *colon_ptr;
  colon_ptr=strchr(dev, 58);
  if(!(colon_ptr == ((char *)NULL)))
    *colon_ptr = (char)0;

  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(dev);
  signed int return_value_setsockopt_2;
  return_value_setsockopt_2=setsockopt(sock, 1, 25, (const void *)dev, (unsigned int)(return_value_strlen_1 + (unsigned long int)1));
  if(!(return_value_setsockopt_2 >= 0))
  {
    if(!(colon_ptr == ((char *)NULL)))
      *colon_ptr = (char)58;

    return (signed char)-1;
  }

  else
  {
    if(!(colon_ptr == ((char *)NULL)))
      *colon_ptr = (char)58;

    return (signed char)1;
  }
}

// bit_count
// file bitarray.c line 190
unsigned char bit_count(signed int to_count)
{
  unsigned char hamming = (unsigned char)0;
  for( ; !(to_count == 0); hamming = hamming + 1)
    to_count = to_count & to_count - 1;
  return hamming;
}

// bit_get_packet
// file bitarray.h line 33
char bit_get_packet(unsigned long int *seq_bits, signed short int seq_num_diff, signed char set_mark)
{
  signed int i;
  if((signed int)seq_num_diff >= -((signed int)local_win_size) && !((signed int)seq_num_diff >= 0))
  {
    if(!(set_mark == 0))
      bit_mark(seq_bits, -((signed int)seq_num_diff));

    return (char)0;
  }

  else
  {
    if(!((signed int)seq_num_diff >= -((signed int)local_win_size)) || !((signed int)local_win_size >= (signed int)seq_num_diff))
    {
      if(!((signed int)local_win_size >= (signed int)seq_num_diff))
        debug_output((signed char)4, "It seems we missed a lot of packets (%i) !\n", (signed int)seq_num_diff - 1);

      if(!((signed int)local_win_size >= -((signed int)seq_num_diff)))
        debug_output((signed char)4, "Other host probably restarted !\n");

      i = 0;
      for( ; !(i >= (signed int)num_words); i = i + 1)
        seq_bits[(signed long int)i] = (unsigned long int)0;
      if(!(set_mark == 0))
        seq_bits[(signed long int)0] = (unsigned long int)1;

    }

    else
    {
      bit_shift(seq_bits, (signed int)seq_num_diff);
      if(!(set_mark == 0))
        bit_mark(seq_bits, 0);

    }
    return (char)1;
  }
}

// bit_init
// file bitarray.c line 32
void bit_init(unsigned long int *seq_bits)
{
  signed int i = 0;
  for( ; !(i >= (signed int)num_words); i = i + 1)
    seq_bits[(signed long int)i] = (unsigned long int)0;
}

// bit_mark
// file bitarray.h line 31
void bit_mark(unsigned long int *seq_bits, signed int n)
{
  signed int word_offset;
  signed int word_num;
  if(!(n >= (signed int)local_win_size) && n >= 0)
  {
    word_offset = (signed int)((unsigned long int)n % (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8));
    word_num = (signed int)((unsigned long int)n / (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8));
    seq_bits[(signed long int)word_num] = seq_bits[(signed long int)word_num] | 1ULL << word_offset;
  }

}

// bit_packet_count
// file bitarray.h line 34
signed int bit_packet_count(unsigned long int *seq_bits)
{
  signed int i;
  signed int hamming = 0;
  unsigned long int word;
  i = 0;
  for( ; !(i >= (signed int)num_words); i = i + 1)
  {
    word = seq_bits[(signed long int)i];
    for( ; !(word == 0ul); hamming = hamming + 1)
      word = word & word - (unsigned long int)1;
  }
  return hamming;
}

// bit_shift
// file bitarray.c line 82
void bit_shift(unsigned long int *seq_bits, signed int n)
{
  signed int word_offset;
  signed int word_num;
  signed int i;
  if(n >= 1)
  {
    word_offset = (signed int)((unsigned long int)n % (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8));
    word_num = (signed int)((unsigned long int)n / (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8));
    i = (signed int)num_words - 1;
    for( ; !(word_num >= i); i = i - 1)
      seq_bits[(signed long int)i] = (seq_bits[(signed long int)(i - word_num)] << word_offset) + (seq_bits[(signed long int)((i - word_num) - 1)] >> sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8 - (unsigned long int)word_offset);
    seq_bits[(signed long int)i] = seq_bits[(signed long int)(i - word_num)] << word_offset;
    i = i - 1;
    for( ; i >= 0; i = i - 1)
      seq_bits[(signed long int)i] = (unsigned long int)0;
  }

}

// checkIntegrity
// file allocate.h line 29
void checkIntegrity(void)
{
  struct chunkHeader *walker;
  struct chunkTrailer *chunkTrailer;
  unsigned char *memory;
  struct memoryUsage *memoryWalker;
  debug_output((signed char)5, " \nMemory usage information:\n");
  pthread_mutex_lock(&memory_mutex);
  memoryWalker = memoryList;
  for( ; !(memoryWalker == ((struct memoryUsage *)NULL)); memoryWalker = memoryWalker->next)
    if(!(memoryWalker->counter == 0u))
      debug_output((signed char)5, "   tag: %''4i, num malloc: %4i, bytes per malloc: %''4i, total: %6i\n", memoryWalker->tag, memoryWalker->counter, memoryWalker->length, memoryWalker->counter * memoryWalker->length);

  pthread_mutex_unlock(&memory_mutex);
  pthread_mutex_lock(&chunk_mutex);
  walker = chunkList;
  for( ; !(walker == ((struct chunkHeader *)NULL)); walker = walker->next)
  {
    if(!(walker->magicNumber == 305419896u))
    {
      debug_output((signed char)0, "checkIntegrity - invalid magic number in header: %08x, malloc tag = %d\n", walker->magicNumber, walker->tag);
      pthread_mutex_unlock(&chunk_mutex);
      restore_and_exit((unsigned char)0);
    }

    memory = (unsigned char *)walker;
    unsigned long int return_value_getHeaderPad_1;
    return_value_getHeaderPad_1=getHeaderPad();
    unsigned long int return_value_getTrailerPad_2;
    return_value_getTrailerPad_2=getTrailerPad((unsigned long int)walker->length);
    chunkTrailer = (struct chunkTrailer *)(memory + (signed long int)sizeof(struct chunkHeader) /*24ul*/  + (signed long int)return_value_getHeaderPad_1 + (signed long int)walker->length + (signed long int)return_value_getTrailerPad_2);
    if(!(chunkTrailer->magicNumber == 305419896u))
    {
      debug_output((signed char)0, "checkIntegrity - invalid magic number in trailer: %08x, malloc tag = %d\n", chunkTrailer->magicNumber, walker->tag);
      pthread_mutex_unlock(&chunk_mutex);
      restore_and_exit((unsigned char)0);
    }

  }
  pthread_mutex_unlock(&chunk_mutex);
}

// checkLeak
// file allocate.c line 246
void checkLeak(void)
{
  struct chunkHeader *walker;
  pthread_mutex_lock(&chunk_mutex);
  walker = chunkList;
  for( ; !(walker == ((struct chunkHeader *)NULL)); walker = walker->next)
    debug_output((signed char)0, "Memory leak detected, malloc tag = %d\n", walker->tag);
  pthread_mutex_unlock(&chunk_mutex);
}

// checkPadding
// file allocate.c line 112
static signed int checkPadding(unsigned char *padding, unsigned long int length)
{
  unsigned char c = (unsigned char)0x00;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= length); i = i + 1ul)
  {
    c = c + (unsigned char)0xA7;
    if(!(padding[(signed long int)i] == c))
      return 0;

  }
  return 1;
}

// check_active_interfaces
// file posix/init.c line 1040
void check_active_interfaces(void)
{
  struct list_head *list_pos;
  struct batman_if *batman_if;
  signed int return_value_is_interface_up_1;
  if(!((signed int)active_ifs == 0))
  {
    list_pos = (&if_list)->next;
    for( ; !(list_pos == (struct list_head *)&if_list); list_pos = list_pos->next)
    {
      batman_if = (struct batman_if *)((char *)list_pos - (signed long int)(unsigned long int)&((struct batman_if *)0)->list);
      if(!(batman_if->if_active == 0))
      {
        return_value_is_interface_up_1=is_interface_up(batman_if->dev);
        if(return_value_is_interface_up_1 == 0)
          deactivate_interface(batman_if);

      }

    }
  }

}

// check_inactive_interfaces
// file os.h line 66
void check_inactive_interfaces(void)
{
  struct list_head *list_pos;
  struct batman_if *batman_if;
  signed int return_value_is_interface_up_1;
  if(!(found_ifs == active_ifs))
  {
    list_pos = (&if_list)->next;
    for( ; !(list_pos == (struct list_head *)&if_list); list_pos = list_pos->next)
    {
      batman_if = (struct batman_if *)((char *)list_pos - (signed long int)(unsigned long int)&((struct batman_if *)0)->list);
      if(batman_if->if_active == 0)
      {
        return_value_is_interface_up_1=is_interface_up(batman_if->dev);
        if(!(return_value_is_interface_up_1 == 0))
          activate_interface(batman_if);

      }

    }
  }

}

// choose_gw
// file batman.c line 217
void choose_gw(void)
{
  struct list_head *pos;
  struct gw_node *gw_node;
  struct gw_node *tmp_curr_gw = (struct gw_node *)(void *)0;
  unsigned char max_gw_class = (unsigned char)0;
  unsigned char max_tq = (unsigned char)0;
  unsigned int current_time;
  unsigned int max_gw_factor = (unsigned int)0;
  unsigned int tmp_gw_factor = (unsigned int)0;
  signed int download_speed;
  signed int upload_speed;
  char orig_str[16l];
  prof_start(0);
  current_time=get_time_msec();
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_get_time_msec64_1;
  if((signed int)routing_class == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    if(!((signed int)routing_class >= 4))
    {
      return_value_get_time_msec64_1=get_time_msec64();
      tmp_if_expr_2 = (signed long int)(return_value_get_time_msec64_1 - (unsigned long int)((signed int)originator_interval * (signed int)local_win_size)) < (signed long int)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  signed char return_value_is_aborted_8;
  if(tmp_if_expr_3)
    prof_stop(0);

  else
  {
    signed int return_value_list_empty_4;
    return_value_list_empty_4=list_empty(&gw_list);
    if(!(return_value_list_empty_4 == 0))
    {
      if(!(curr_gateway == ((struct gw_node *)NULL)))
      {
        debug_output((signed char)3, "Removing default route - no gateway in range\n");
        del_default_route();
      }

      prof_stop(0);
    }

    else
    {
      pos = (&gw_list)->next;
      for( ; !(pos == (struct list_head *)&gw_list); pos = pos->next)
      {
        gw_node = (struct gw_node *)((char *)pos - (signed long int)(unsigned long int)&((struct gw_node *)0)->list);
        if(!(gw_node == (struct gw_node *)gw_list.next))
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = gw_node->list.next != (struct list_head *)&gw_list ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_5)
        {
          if(!((signed int)current_time + -(30000 + (signed int)gw_node->last_failure) >= 0))
            goto __CPROVER_DUMP_L23;

        }

        if(!(gw_node->orig_node->router == ((struct neigh_node *)NULL)))
        {
          if(gw_node->deleted == 0u)
          {
            if((signed int)routing_class == 1)
            {
              get_gw_speeds(gw_node->orig_node->gwflags, &download_speed, &upload_speed);
              tmp_gw_factor = (unsigned int)((((signed int)gw_node->orig_node->router->tq_avg * 100) / (signed int)local_win_size) * (((signed int)gw_node->orig_node->router->tq_avg * 100) / (signed int)local_win_size) * (download_speed / 64));
              if(!(max_gw_factor >= tmp_gw_factor))
                tmp_if_expr_7 = (_Bool)1;

              else
              {
                if(tmp_gw_factor == max_gw_factor)
                  tmp_if_expr_6 = (signed int)gw_node->orig_node->router->tq_avg > (signed int)max_tq ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_6 = (_Bool)0;
                tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_7)
                tmp_curr_gw = gw_node;

              goto __CPROVER_DUMP_L19;
            }

            if(!((signed int)max_tq >= (signed int)gw_node->orig_node->router->tq_avg))
              tmp_curr_gw = gw_node;


          __CPROVER_DUMP_L19:
            ;
            if(!((signed int)max_gw_class >= (signed int)gw_node->orig_node->gwflags))
              max_gw_class = gw_node->orig_node->gwflags;

            if(!((signed int)max_tq >= (signed int)gw_node->orig_node->router->tq_avg))
              max_tq = gw_node->orig_node->router->tq_avg;

            if(!(max_gw_factor >= tmp_gw_factor))
              max_gw_factor = tmp_gw_factor;

            if(!(pref_gateway == 0u))
            {
              if(pref_gateway == gw_node->orig_node->orig)
              {
                tmp_curr_gw = gw_node;
                addr_to_string(tmp_curr_gw->orig_node->orig, orig_str, 16);
                debug_output((signed char)3, "Preferred gateway found: %s (gw_flags: %i, tq: %i, gw_product: %i)\n", (const void *)orig_str, gw_node->orig_node->gwflags, gw_node->orig_node->router->tq_avg, tmp_gw_factor);
                break;
              }

            }

          }

        }


      __CPROVER_DUMP_L23:
        ;
      }
      if(!(curr_gateway == tmp_curr_gw))
      {
        if(!(curr_gateway == ((struct gw_node *)NULL)))
        {
          if(!(tmp_curr_gw == ((struct gw_node *)NULL)))
            debug_output((signed char)3, "Removing default route - better gateway found\n");

          else
            debug_output((signed char)3, "Removing default route - no gateway in range\n");
          del_default_route();
        }

        curr_gateway = tmp_curr_gw;
        if(!(curr_gateway == ((struct gw_node *)NULL)))
        {
          return_value_is_aborted_8=is_aborted();
          if(return_value_is_aborted_8 == 0)
          {
            addr_to_string(curr_gateway->orig_node->orig, orig_str, 16);
            debug_output((signed char)3, "Adding default route to %s (gw_flags: %i, tq: %i, gw_product: %i)\n", (const void *)orig_str, max_gw_class, max_tq, max_gw_factor);
            add_default_route();
          }

        }

      }

      prof_stop(0);
    }
  }
}

// choose_hna
// file hna.c line 47
signed int choose_hna(void *data, signed int size)
{
  unsigned char *key = (unsigned char *)data;
  unsigned int hash = (unsigned int)0;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 5ul); i = i + 1ul)
  {
    hash = hash + (unsigned int)key[(signed long int)i];
    hash = hash + (hash << 10);
    hash = hash ^ hash >> 6;
  }
  hash = hash + (hash << 3);
  hash = hash ^ hash >> 11;
  hash = hash + (hash << 15);
  return (signed int)(hash % (unsigned int)size);
}

// choose_orig
// file originator.h line 30
signed int choose_orig(void *data, signed int size)
{
  unsigned char *key = (unsigned char *)data;
  unsigned int hash = (unsigned int)0;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 4ul); i = i + 1ul)
  {
    hash = hash + (unsigned int)key[(signed long int)i];
    hash = hash + (hash << 10);
    hash = hash ^ hash >> 6;
  }
  hash = hash + (hash << 3);
  hash = hash ^ hash >> 11;
  hash = hash + (hash << 15);
  return (signed int)(hash % (unsigned int)size);
}

// choose_vip
// file posix/tunnel.c line 540
static signed int choose_vip(void *data, signed int size)
{
  unsigned char *key = (unsigned char *)data;
  unsigned int hash = (unsigned int)0;
  unsigned long int i = (unsigned long int)4;
  for( ; !(i >= 8ul); i = i + 1ul)
  {
    hash = hash + (unsigned int)key[(signed long int)i];
    hash = hash + (hash << 10);
    hash = hash ^ hash >> 6;
  }
  hash = hash + (hash << 3);
  hash = hash ^ hash >> 11;
  hash = hash + (hash << 15);
  return (signed int)(hash % (unsigned int)size);
}

// choose_wip
// file posix/tunnel.c line 520
static signed int choose_wip(void *data, signed int size)
{
  unsigned char *key = (unsigned char *)data;
  unsigned int hash = (unsigned int)0;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 4ul); i = i + 1ul)
  {
    hash = hash + (unsigned int)key[(signed long int)i];
    hash = hash + (hash << 10);
    hash = hash ^ hash >> 6;
  }
  hash = hash + (hash << 3);
  hash = hash ^ hash >> 11;
  hash = hash + (hash << 15);
  return (signed int)(hash % (unsigned int)size);
}

// cleanup
// file posix/posix.c line 570
void cleanup(void)
{
  signed char i;
  struct list_head *debug_pos;
  struct list_head *debug_pos_tmp;
  i = (signed char)0;
  for( ; !((signed int)i >= (signed int)debug_level_max); i = i + 1)
  {
    if((signed int)debug_clients.clients_num[(signed long int)i] >= 1)
    {
      debug_pos = ((struct list_head *)debug_clients.fd_list[(signed long int)i])->next;
      debug_pos_tmp = debug_pos->next;
      for( ; !(debug_pos == (struct list_head *)debug_clients.fd_list[(signed long int)i]); debug_pos_tmp = debug_pos->next)
      {
        list_del((struct list_head *)debug_clients.fd_list[(signed long int)i], debug_pos, (struct list_head_first *)debug_clients.fd_list[(signed long int)i]);
        debugFree((void *)debug_pos, 1218);
        debug_pos = debug_pos_tmp;
      }
    }

    debugFree(debug_clients.fd_list[(signed long int)i], 1219);
    debugFree((void *)debug_clients.mutex[(signed long int)i], 1220);
  }
  debugFree((void *)debug_clients.fd_list, 1221);
  debugFree((void *)debug_clients.mutex, 1222);
  debugFree((void *)debug_clients.clients_num, 1223);
}

// client_to_gw_tun
// file posix/../os.h line 95
void * client_to_gw_tun(void *arg)
{
  struct curr_gw_data *curr_gw_data = (struct curr_gw_data *)arg;
  struct sockaddr_in gw_addr;
  struct sockaddr_in my_addr;
  struct sockaddr_in sender_addr;
  struct timeval tv;
  struct list_head_first packet_list;
  signed int res;
  signed int max_sock;
  signed int buff_len;
  signed int udp_sock;
  signed int tun_fd;
  signed int tun_ifi;
  signed int sock_opts;
  signed int i;
  signed int num_refresh_lease = 0;
  signed int last_refresh_attempt = 0;
  unsigned int addr_len;
  unsigned int current_time;
  unsigned int ip_lease_time = (unsigned int)0;
  unsigned int gw_state_time = (unsigned int)0;
  unsigned int my_tun_addr = (unsigned int)0;
  unsigned int ignore_packet;
  char tun_if[16l];
  char my_str[16l];
  char gw_str[16l];
  char gw_state = (char)0x01;
  unsigned char buff[1501l];
  struct anonymous_15 wait_sockets;
  struct anonymous_15 tmp_wait_sockets;
  addr_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  packet_list.next = (struct list_head *)&packet_list;
  packet_list.prev = (struct list_head *)&packet_list;
  memset((void *)&gw_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  memset((void *)&my_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  gw_addr.sin_family = (unsigned short int)2;
  gw_addr.sin_port = curr_gw_data->gw_node->gw_port;
  gw_addr.sin_addr.s_addr = curr_gw_data->orig;
  my_addr.sin_family = (unsigned short int)2;
  my_addr.sin_port = curr_gw_data->gw_node->gw_port;
  my_addr.sin_addr.s_addr = curr_gw_data->batman_if->addr.sin_addr.s_addr;
  udp_sock=socket(2, 2, 0);
  if(!(udp_sock >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    debug_output((signed char)0, "Error - can't create udp socket: %s\n", return_value_strerror_2);
    goto out;
  }

  sock_opts = 1;
  signed int return_value_setsockopt_5;
  return_value_setsockopt_5=setsockopt(udp_sock, 1, 2, (const void *)&sock_opts, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_setsockopt_5 >= 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    debug_output((signed char)0, "Error - can't set options on udp socket: %s\n", return_value_strerror_4);
    goto udp_out;
  }

  signed int return_value_bind_8;
  return_value_bind_8=bind(udp_sock, (struct sockaddr *)&my_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(return_value_bind_8 >= 0))
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    debug_output((signed char)0, "Error - can't bind tunnel socket: %s\n", return_value_strerror_7);
    goto udp_out;
  }

  sock_opts=fcntl(udp_sock, 3, 0);
  fcntl(udp_sock, 4, sock_opts | 04000);
  signed char return_value_get_tun_ip_9;
  return_value_get_tun_ip_9=get_tun_ip(&gw_addr, udp_sock, &my_tun_addr);
  signed char return_value_add_dev_tun_10;
  signed char return_value_is_aborted_11;
  signed int *return_value___errno_location_14;
  signed long int return_value_recvfrom_15;
  signed long int return_value_write_18;
  signed int *return_value___errno_location_16;
  char *return_value_strerror_17;
  unsigned char return_value_get_tunneled_protocol_19;
  signed long int return_value_read_23;
  signed int *return_value___errno_location_24;
  char *return_value_strerror_25;
  signed int *return_value___errno_location_34;
  char *return_value_strerror_35;
  if(!((signed int)return_value_get_tun_ip_9 >= 0))
  {
    curr_gw_data->gw_node->last_failure=get_time_msec();
    curr_gw_data->gw_node->gw_failure = curr_gw_data->gw_node->gw_failure + 1;
  }

  else
  {
    ip_lease_time=get_time_msec();
    addr_to_string(my_tun_addr, my_str, (signed int)sizeof(char [16l]) /*16ul*/ );
    addr_to_string(curr_gw_data->orig, gw_str, (signed int)sizeof(char [16l]) /*16ul*/ );
    debug_output((signed char)3, "Gateway client - got IP (%s) from gateway: %s \n", (const void *)my_str, (const void *)gw_str);
    return_value_add_dev_tun_10=add_dev_tun(curr_gw_data->batman_if, my_tun_addr, tun_if, sizeof(char [16l]) /*16ul*/ , &tun_fd, &tun_ifi);
    if((signed int)return_value_add_dev_tun_10 >= 1)
    {
      add_nat_rule(tun_if);
      add_del_route((unsigned int)0, (unsigned char)0, (unsigned int)0, my_tun_addr, tun_ifi, tun_if, (unsigned char)68, (signed char)0, (signed char)0);
      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_15) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wait_sockets)->fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&wait_sockets)->fds_bits[(signed long int)(udp_sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wait_sockets)->fds_bits[(signed long int)(udp_sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << udp_sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      (&wait_sockets)->fds_bits[(signed long int)(tun_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wait_sockets)->fds_bits[(signed long int)(tun_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << tun_fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      max_sock = udp_sock > tun_fd ? udp_sock : tun_fd;
      do
      {
        return_value_is_aborted_11=is_aborted();
        if(!(return_value_is_aborted_11 == 0))
          break;

        if(curr_gateway == ((struct gw_node *)NULL))
          break;

        if(!(curr_gw_data->gw_node->deleted == 0u))
          break;

        tv.tv_sec = (signed long int)0;
        tv.tv_usec = (signed long int)250;
        memcpy((void *)&tmp_wait_sockets, (const void *)&wait_sockets, sizeof(struct anonymous_15) /*128ul*/ );
        res=select(max_sock + 1, &tmp_wait_sockets, (struct anonymous_15 *)(void *)0, (struct anonymous_15 *)(void *)0, &tv);
        current_time=get_time_msec();
        if(!(res >= 0))
        {
          return_value___errno_location_14=__errno_location();
          if(!(*return_value___errno_location_14 == 4))
          {
            signed int *return_value___errno_location_12;
            return_value___errno_location_12=__errno_location();
            char *return_value_strerror_13;
            return_value_strerror_13=strerror(*return_value___errno_location_12);
            debug_output((signed char)0, "Error - can't select (client_to_gw_tun): %s \n", return_value_strerror_13);
            break;
          }

        }

        if(res >= 1)
        {
          if(!((tmp_wait_sockets.fds_bits[(signed long int)(udp_sock / 8)] & (signed long int)(1UL << udp_sock % 8)) == 0l))
          {
            do
            {
              return_value_recvfrom_15=recvfrom(udp_sock, (void *)buff, sizeof(unsigned char [1501l]) /*1501ul*/  - (unsigned long int)1, 0, (struct sockaddr *)&sender_addr, &addr_len);
              buff_len = (signed int)return_value_recvfrom_15;
              if(!(buff_len >= 1))
                break;

              if(!(buff_len >= 2))
                debug_output((signed char)0, "Error - ignoring gateway packet from %s: packet too small (%i)\n", (const void *)my_str, buff_len);

              else
                switch((signed int)buff[(signed long int)0])
                {
                  case 0x01:
                  {
                    return_value_write_18=write(tun_fd, (const void *)(buff + (signed long int)1), (unsigned long int)(buff_len - 1));
                    if(!(return_value_write_18 >= 0l))
                    {
                      return_value___errno_location_16=__errno_location();
                      return_value_strerror_17=strerror(*return_value___errno_location_16);
                      debug_output((signed char)0, "Error - can't write packet: %s\n", return_value_strerror_17);
                    }

                    return_value_get_tunneled_protocol_19=get_tunneled_protocol(buff);
                    if(!((signed int)return_value_get_tunneled_protocol_19 == 1))
                    {
                      gw_state = (char)0x02;
                      gw_state_time = current_time;
                    }

                    break;
                  }
                  case 0x03:
                  {
                    addr_to_string(my_tun_addr, my_str, (signed int)sizeof(char [16l]) /*16ul*/ );
                    debug_output((signed char)3, "Gateway client - gateway (%s) says: IP (%s) is invalid (maybe expired) \n", (const void *)gw_str, (const void *)my_str);
                    curr_gateway = (struct gw_node *)(void *)0;
                    goto cleanup;
                  }
                  case 0x05:
                  {
                    debug_output((signed char)3, "Gateway client - successfully refreshed IP lease: %s \n", (const void *)gw_str);
                    ip_lease_time = current_time;
                    num_refresh_lease = 0;
                  }
                  default:
                    ;
                }
            }
            while((_Bool)1);
            signed int *return_value___errno_location_22;
            return_value___errno_location_22=__errno_location();
            if(!(*return_value___errno_location_22 == 11))
            {
              signed int *return_value___errno_location_20;
              return_value___errno_location_20=__errno_location();
              char *return_value_strerror_21;
              return_value_strerror_21=strerror(*return_value___errno_location_20);
              debug_output((signed char)0, "Error - gateway client can't receive packet: %s\n", return_value_strerror_21);
              break;
            }

          }

          else
            if(!((tmp_wait_sockets.fds_bits[(signed long int)(tun_fd / 8)] & (signed long int)(1UL << tun_fd % 8)) == 0l))
            {
              do
              {
                return_value_read_23=read(tun_fd, (void *)(buff + (signed long int)1), sizeof(unsigned char [1501l]) /*1501ul*/  - (unsigned long int)2);
                buff_len = (signed int)return_value_read_23;
                if(!(buff_len >= 1))
                  break;

                buff[(signed long int)0] = (unsigned char)0x01;
                signed long int return_value_sendto_26;
                return_value_sendto_26=sendto(udp_sock, (const void *)buff, (unsigned long int)(buff_len + 1), 0, (struct sockaddr *)&gw_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
                if(!(return_value_sendto_26 >= 0l))
                {
                  return_value___errno_location_24=__errno_location();
                  return_value_strerror_25=strerror(*return_value___errno_location_24);
                  debug_output((signed char)0, "Error - can't send data to gateway: %s\n", return_value_strerror_25);
                }

                if(gw_state_time == 0u && (signed int)gw_state == 0x01)
                {
                  ignore_packet = (unsigned int)0;
                  unsigned char return_value_get_tunneled_protocol_27;
                  return_value_get_tunneled_protocol_27=get_tunneled_protocol(buff);
                  if((signed int)return_value_get_tunneled_protocol_27 == 1)
                    ignore_packet = (unsigned int)1;

                  unsigned char return_value_get_tunneled_protocol_29;
                  return_value_get_tunneled_protocol_29=get_tunneled_protocol(buff);
                  if((signed int)return_value_get_tunneled_protocol_29 == 17)
                  {
                    i = 0;
                    for( ; !(i >= 6); i = i + 1)
                    {
                      unsigned short int return_value_get_tunneled_udpdest_28;
                      return_value_get_tunneled_udpdest_28=get_tunneled_udpdest(buff);
                      if(return_value_get_tunneled_udpdest_28 == bh_udp_ports[(signed long int)i])
                      {
                        ignore_packet = (unsigned int)1;
                        break;
                      }

                    }
                  }

                  unsigned int return_value_get_tunneled_sender_ip_30;
                  return_value_get_tunneled_sender_ip_30=get_tunneled_sender_ip(buff);
                  if(!(return_value_get_tunneled_sender_ip_30 == my_tun_addr))
                    ignore_packet = (unsigned int)1;

                  if(ignore_packet == 0u)
                    gw_state_time = current_time;

                }

              }
              while((_Bool)1);
              signed int *return_value___errno_location_33;
              return_value___errno_location_33=__errno_location();
              if(!(*return_value___errno_location_33 == 11))
              {
                signed int *return_value___errno_location_31;
                return_value___errno_location_31=__errno_location();
                char *return_value_strerror_32;
                return_value_strerror_32=strerror(*return_value___errno_location_31);
                debug_output((signed char)0, "Error - gateway client can't read tun data: %s\n", return_value_strerror_32);
                break;
              }

            }

        }


      after_incoming_packet:
        ;
        if((signed int)current_time + -(1000 + (signed int)(unsigned int)last_refresh_attempt) >= 1 && (signed int)current_time + -(1200000 + (signed int)ip_lease_time) >= 1)
        {
          if(!(num_refresh_lease >= 12))
          {
            buff[(signed long int)0] = (unsigned char)0x04;
            signed long int return_value_sendto_36;
            return_value_sendto_36=sendto(udp_sock, (const void *)buff, (unsigned long int)100, 0, (struct sockaddr *)&gw_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
            if(!(return_value_sendto_36 >= 0l))
            {
              return_value___errno_location_34=__errno_location();
              return_value_strerror_35=strerror(*return_value___errno_location_34);
              debug_output((signed char)0, "Error - can't send keep alive request to gateway: %s \n", return_value_strerror_35);
            }

            num_refresh_lease = num_refresh_lease + 1;
            last_refresh_attempt = (signed int)current_time;
          }

          else
          {
            addr_to_string(my_tun_addr, my_str, (signed int)sizeof(char [16l]) /*16ul*/ );
            debug_output((signed char)3, "Gateway client - disconnecting from unresponsive gateway (%s): could not refresh IP lease \n", (const void *)gw_str);
            curr_gw_data->gw_node->last_failure = current_time;
            curr_gw_data->gw_node->gw_failure = curr_gw_data->gw_node->gw_failure + 1;
            break;
          }
        }

        if((signed int)gw_state == 0x01 && (signed int)current_time + -(60000 + (signed int)gw_state_time) >= 1 && !(gw_state_time == 0u))
        {
          debug_output((signed char)3, "Gateway client - disconnecting from unresponsive gateway (%s): gateway seems to be a blackhole \n", (const void *)gw_str);
          curr_gw_data->gw_node->last_failure = current_time;
          curr_gw_data->gw_node->gw_failure = curr_gw_data->gw_node->gw_failure + 1;
          break;
        }

        if((signed int)gw_state == 0x02 && (signed int)current_time + -(300000 + (signed int)gw_state_time) >= 1)
        {
          gw_state = (char)0x01;
          gw_state_time = (unsigned int)0;
        }

      }
      while((_Bool)1);

    cleanup:
      ;
      add_del_route((unsigned int)0, (unsigned char)0, (unsigned int)0, my_tun_addr, tun_ifi, tun_if, (unsigned char)68, (signed char)0, (signed char)1);
      del_nat_rule(tun_if);
      del_dev_tun(tun_fd);
    }

  }

udp_out:
  ;
  close(udp_sock);

out:
  ;
  curr_gateway = (struct gw_node *)(void *)0;
  tunnel_running = (unsigned char)0;
  debugFree(arg, 1212);
  return (void *)0;
}

// compare_hna
// file hna.c line 42
signed int compare_hna(void *data1, void *data2)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp(data1, data2, (unsigned long int)5);
  return return_value_memcmp_1 == 0 ? 1 : 0;
}

// compare_orig
// file originator.h line 29
signed int compare_orig(void *data1, void *data2)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp(data1, data2, (unsigned long int)4);
  return return_value_memcmp_1 == 0 ? 1 : 0;
}

// compare_vip
// file posix/tunnel.c line 513
static signed int compare_vip(void *data1, void *data2)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)((char *)data1 + (signed long int)4), (const void *)((char *)data2 + (signed long int)4), (unsigned long int)4);
  return return_value_memcmp_1 == 0 ? 1 : 0;
}

// compare_wip
// file posix/tunnel.c line 508
static signed int compare_wip(void *data1, void *data2)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp(data1, data2, (unsigned long int)4);
  return return_value_memcmp_1 == 0 ? 1 : 0;
}

// count_real_packets
// file batman.c line 715
static unsigned char count_real_packets(struct bat_packet *in, unsigned int neigh, struct batman_if *if_incoming)
{
  struct list_head *list_pos;
  struct orig_node *orig_node;
  struct neigh_node *tmp_neigh_node;
  unsigned char is_duplicate = (unsigned char)0;
  orig_node=get_orig_node(in->orig);
  list_pos = (&orig_node->neigh_list)->next;
  _Bool tmp_if_expr_1;
  for( ; !(list_pos == (struct list_head *)&orig_node->neigh_list); list_pos = list_pos->next)
  {
    tmp_neigh_node = (struct neigh_node *)((char *)list_pos - (signed long int)(unsigned long int)&((struct neigh_node *)0)->list);
    if(is_duplicate == 0)
      is_duplicate=get_bit_status(tmp_neigh_node->real_bits, orig_node->last_real_seqno, in->seqno);

    if(tmp_neigh_node->addr == neigh)
      tmp_if_expr_1 = tmp_neigh_node->if_incoming == if_incoming ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      bit_get_packet(tmp_neigh_node->real_bits, (signed short int)((signed int)in->seqno - (signed int)orig_node->last_real_seqno), (signed char)1);

    else
      bit_get_packet(tmp_neigh_node->real_bits, (signed short int)((signed int)in->seqno - (signed int)orig_node->last_real_seqno), (signed char)0);
    signed int return_value_bit_packet_count_2;
    return_value_bit_packet_count_2=bit_packet_count(tmp_neigh_node->real_bits);
    tmp_neigh_node->real_packet_count = (unsigned char)return_value_bit_packet_count_2;
  }
  if(is_duplicate == 0)
  {
    debug_output((signed char)4, "updating last_seqno: old %d, new %d \n", orig_node->last_real_seqno, in->seqno);
    orig_node->last_real_seqno = in->seqno;
  }

  return is_duplicate;
}

// create_neighbor
// file originator.h line 28
struct neigh_node * create_neighbor(struct orig_node *orig_node, struct orig_node *orig_neigh_node, unsigned int neigh, struct batman_if *if_incoming)
{
  struct neigh_node *neigh_node;
  debug_output((signed char)4, "Creating new last-hop neighbour of originator\n");
  void *return_value_debugMalloc_1;
  return_value_debugMalloc_1=debugMalloc((unsigned int)sizeof(struct neigh_node) /*56ul*/ , 403);
  neigh_node = (struct neigh_node *)return_value_debugMalloc_1;
  memset((void *)neigh_node, 0, sizeof(struct neigh_node) /*56ul*/ );
  do
    (&neigh_node->list)->next = &neigh_node->list;
  while((_Bool)0);
  neigh_node->addr = neigh;
  neigh_node->orig_node = orig_neigh_node;
  neigh_node->if_incoming = if_incoming;
  void *return_value_debugMalloc_2;
  return_value_debugMalloc_2=debugMalloc((unsigned int)(sizeof(unsigned short int) /*2ul*/  * (unsigned long int)global_win_size), 406);
  neigh_node->tq_recv = (unsigned char *)return_value_debugMalloc_2;
  memset((void *)neigh_node->tq_recv, 0, sizeof(unsigned short int) /*2ul*/  * (unsigned long int)global_win_size);
  void *return_value_debugMalloc_3;
  return_value_debugMalloc_3=debugMalloc((unsigned int)(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)num_words), 407);
  neigh_node->real_bits = (unsigned long int *)return_value_debugMalloc_3;
  memset((void *)neigh_node->real_bits, 0, sizeof(unsigned long int) /*8ul*/  * (unsigned long int)num_words);
  list_add_tail(&neigh_node->list, &orig_node->neigh_list);
  return neigh_node;
}

// create_routing_pipe
// file posix/init.c line 92
static void create_routing_pipe(void)
{
  signed int fd[2l];
  signed int pipe_opts;
  signed int return_value_pipe_3;
  return_value_pipe_3=pipe(fd);
  if(!(return_value_pipe_3 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    printf("Could not create a pipe to '%s': %s\n", policy_routing_script, return_value_strerror_2);
    exit(1);
  }

  policy_routing_script_pid=fork();
  signed int *return_value___errno_location_7;
  char *return_value_strerror_8;
  if(!(policy_routing_script_pid >= 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    printf("Could not fork to execute '%s': %s\n", policy_routing_script, return_value_strerror_5);
    exit(1);
  }

  else
    if(policy_routing_script_pid >= 1)
    {
      close(fd[(signed long int)0]);
      policy_routing_pipe = fd[(signed long int)1];
      pipe_opts=fcntl(policy_routing_pipe, 3, 0);
      fcntl(policy_routing_pipe, 4, pipe_opts | 04000);
    }

    else
    {
      close(fd[(signed long int)1]);
      if(!(fd[0l] == 0))
      {
        signed int return_value_dup2_6;
        return_value_dup2_6=dup2(fd[(signed long int)0], 0);
        if(!(return_value_dup2_6 == 0))
        {
          printf("Could not dup2 to redirect stdin to '%s'\n", policy_routing_script);
          exit(1);
        }

        close(fd[(signed long int)0]);
      }

      signal(2, (void (*)(signed int))1);
      signal(15, (void (*)(signed int))1);
      signal(13, (void (*)(signed int))1);
      signed int return_value_execl_9;
      return_value_execl_9=execl("/bin/sh", "/bin/sh", (const void *)"-c", policy_routing_script, (void *)0);
      if(!(return_value_execl_9 >= 0))
      {
        return_value___errno_location_7=__errno_location();
        return_value_strerror_8=strerror(*return_value___errno_location_7);
        printf("Could not execute '%s': %s\n", policy_routing_script, return_value_strerror_8);
      }

    }
}

// deactivate_interface
// file os.h line 65
void deactivate_interface(struct batman_if *batman_if)
{
  if(!(batman_if->udp_recv_sock == 0))
    close(batman_if->udp_recv_sock);

  if(!(batman_if->udp_send_sock == 0))
    close(batman_if->udp_send_sock);

  batman_if->udp_recv_sock = 0;
  batman_if->udp_send_sock = 0;
  if(batman_if->netaddr >= 1u)
  {
    if((signed int)batman_if->netmask >= 1)
    {
      add_del_rule(batman_if->netaddr, batman_if->netmask, (signed char)66, (unsigned int)(6600 + (signed int)batman_if->if_num), ((char *)NULL), (signed char)1, (signed char)1);
      add_del_rule(batman_if->netaddr, batman_if->netmask, (signed char)67, (unsigned int)(6600 + 100 + (signed int)batman_if->if_num), ((char *)NULL), (signed char)1, (signed char)1);
    }

  }

  batman_if->if_active = (unsigned char)0;
  active_ifs = active_ifs - 1;
  if((signed int)batman_if->if_rp_filter_old >= 0)
    set_rp_filter((signed int)batman_if->if_rp_filter_old, batman_if->dev);

  if((signed int)batman_if->if_send_redirects_old >= 0)
    set_send_redirects((signed int)batman_if->if_send_redirects_old, batman_if->dev);

  batman_if->if_rp_filter_old = (signed char)-1;
  batman_if->if_send_redirects_old = (signed char)-1;
  interface_listen_sockets();
  debug_output((signed char)3, "Interface deactivated: %s\n", batman_if->dev);
}

// debugFree
// file allocate.h line 33
void debugFree(void *memoryParameter, signed int tag)
{
  unsigned char *memory;
  struct chunkHeader *chunkHeader;
  struct chunkTrailer *chunkTrailer;
  struct chunkHeader *walker;
  struct chunkHeader *previous;
  memory = (unsigned char *)memoryParameter;
  unsigned long int return_value_getHeaderPad_1;
  return_value_getHeaderPad_1=getHeaderPad();
  chunkHeader = (struct chunkHeader *)((memory - (signed long int)sizeof(struct chunkHeader) /*24ul*/ ) - (signed long int)return_value_getHeaderPad_1);
  if(!(chunkHeader->magicNumber == 305419896u))
  {
    debug_output((signed char)0, "debugFree - invalid magic number in header: %08x, malloc tag = %d, free tag = %d\n", chunkHeader->magicNumber, chunkHeader->tag, tag);
    restore_and_exit((unsigned char)0);
  }

  unsigned long int return_value_getHeaderPad_2;
  return_value_getHeaderPad_2=getHeaderPad();
  unsigned long int return_value_getHeaderPad_3;
  return_value_getHeaderPad_3=getHeaderPad();
  signed int return_value_checkPadding_4;
  return_value_checkPadding_4=checkPadding(memory - (signed long int)return_value_getHeaderPad_2, return_value_getHeaderPad_3);
  if(return_value_checkPadding_4 == 0)
  {
    debug_output((signed char)0, "debugFree - invalid magic padding in header, malloc tag = %d\n", chunkHeader->tag);
    restore_and_exit((unsigned char)0);
  }

  previous = (struct chunkHeader *)(void *)0;
  pthread_mutex_lock(&chunk_mutex);
  walker = chunkList;
  for( ; !(walker == ((struct chunkHeader *)NULL)); walker = walker->next)
  {
    if(walker == chunkHeader)
      break;

    previous = walker;
  }
  if(walker == ((struct chunkHeader *)NULL))
  {
    debug_output((signed char)0, "Double free detected, malloc tag = %d, free tag = %d\n", chunkHeader->tag, tag);
    pthread_mutex_unlock(&chunk_mutex);
    restore_and_exit((unsigned char)0);
  }

  if(previous == ((struct chunkHeader *)NULL))
    chunkList = walker->next;

  else
    previous->next = walker->next;
  pthread_mutex_unlock(&chunk_mutex);
  unsigned long int return_value_getTrailerPad_5;
  return_value_getTrailerPad_5=getTrailerPad((unsigned long int)chunkHeader->length);
  chunkTrailer = (struct chunkTrailer *)(memory + (signed long int)chunkHeader->length + (signed long int)return_value_getTrailerPad_5);
  if(!(chunkTrailer->magicNumber == 305419896u))
  {
    debug_output((signed char)0, "debugFree - invalid magic number in trailer: %08x, malloc tag = %d, free tag = %d\n", chunkTrailer->magicNumber, chunkHeader->tag, tag);
    restore_and_exit((unsigned char)0);
  }

  unsigned long int return_value_getTrailerPad_6;
  return_value_getTrailerPad_6=getTrailerPad((unsigned long int)chunkHeader->length);
  signed int return_value_checkPadding_7;
  return_value_checkPadding_7=checkPadding(memory + (signed long int)chunkHeader->length, return_value_getTrailerPad_6);
  if(return_value_checkPadding_7 == 0)
  {
    debug_output((signed char)0, "debugFree - invalid magic padding in trailer, malloc tag = %d\n", chunkHeader->tag);
    restore_and_exit((unsigned char)0);
  }

  removeMemory(chunkHeader->tag, tag);
  free((void *)chunkHeader);
}

// debugMalloc
// file allocate.h line 31
void * debugMalloc(unsigned int length, signed int tag)
{
  unsigned char *memory;
  struct chunkHeader *chunkHeader;
  struct chunkTrailer *chunkTrailer;
  unsigned char *chunk;
  unsigned long int return_value_getHeaderPad_1;
  return_value_getHeaderPad_1=getHeaderPad();
  unsigned long int return_value_getTrailerPad_2;
  return_value_getTrailerPad_2=getTrailerPad((unsigned long int)length);
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)length + sizeof(struct chunkHeader) /*24ul*/  + sizeof(struct chunkTrailer) /*4ul*/  + return_value_getHeaderPad_1 + return_value_getTrailerPad_2);
  memory = (unsigned char *)return_value_malloc_3;
  if(memory == ((unsigned char *)NULL))
  {
    debug_output((signed char)0, "Cannot allocate %u bytes, malloc tag = %d\n", (unsigned int)((unsigned long int)length + sizeof(struct chunkHeader) /*24ul*/  + sizeof(struct chunkTrailer) /*4ul*/ ), tag);
    restore_and_exit((unsigned char)0);
  }

  chunkHeader = (struct chunkHeader *)memory;
  unsigned long int return_value_getHeaderPad_4;
  return_value_getHeaderPad_4=getHeaderPad();
  chunk = memory + (signed long int)sizeof(struct chunkHeader) /*24ul*/  + (signed long int)return_value_getHeaderPad_4;
  unsigned long int return_value_getHeaderPad_5;
  return_value_getHeaderPad_5=getHeaderPad();
  unsigned long int return_value_getTrailerPad_6;
  return_value_getTrailerPad_6=getTrailerPad((unsigned long int)length);
  chunkTrailer = (struct chunkTrailer *)(memory + (signed long int)sizeof(struct chunkHeader) /*24ul*/  + (signed long int)length + (signed long int)return_value_getHeaderPad_5 + (signed long int)return_value_getTrailerPad_6);
  unsigned long int return_value_getHeaderPad_7;
  return_value_getHeaderPad_7=getHeaderPad();
  fillPadding((unsigned char *)chunkHeader + (signed long int)sizeof(struct chunkHeader) /*24ul*/ , return_value_getHeaderPad_7);
  unsigned long int return_value_getTrailerPad_8;
  return_value_getTrailerPad_8=getTrailerPad((unsigned long int)length);
  fillPadding(chunk + (signed long int)length, return_value_getTrailerPad_8);
  chunkHeader->length = length;
  chunkHeader->tag = tag;
  chunkHeader->magicNumber = (unsigned int)0x12345678;
  chunkTrailer->magicNumber = (unsigned int)0x12345678;
  pthread_mutex_lock(&chunk_mutex);
  chunkHeader->next = chunkList;
  chunkList = chunkHeader;
  pthread_mutex_unlock(&chunk_mutex);
  addMemory(length, tag);
  return (void *)chunk;
}

// debugRealloc
// file allocate.h line 32
void * debugRealloc(void *memoryParameter, unsigned int length, signed int tag)
{
  unsigned char *memory;
  struct chunkHeader *chunkHeader = (struct chunkHeader *)(void *)0;
  struct chunkTrailer *chunkTrailer;
  unsigned char *result;
  unsigned int copyLength;
  if(!(memoryParameter == NULL))
  {
    memory = (unsigned char *)memoryParameter;
    unsigned long int return_value_getHeaderPad_1;
    return_value_getHeaderPad_1=getHeaderPad();
    chunkHeader = (struct chunkHeader *)((memory - (signed long int)sizeof(struct chunkHeader) /*24ul*/ ) - (signed long int)return_value_getHeaderPad_1);
    if(!(chunkHeader->magicNumber == 305419896u))
    {
      debug_output((signed char)0, "debugRealloc - invalid magic number in header: %08x, malloc tag = %d\n", chunkHeader->magicNumber, chunkHeader->tag);
      restore_and_exit((unsigned char)0);
    }

    unsigned long int return_value_getHeaderPad_2;
    return_value_getHeaderPad_2=getHeaderPad();
    unsigned long int return_value_getHeaderPad_3;
    return_value_getHeaderPad_3=getHeaderPad();
    signed int return_value_checkPadding_4;
    return_value_checkPadding_4=checkPadding(memory - (signed long int)return_value_getHeaderPad_2, return_value_getHeaderPad_3);
    if(return_value_checkPadding_4 == 0)
    {
      debug_output((signed char)0, "debugRealloc - invalid magic padding in header, malloc tag = %d\n", chunkHeader->tag);
      restore_and_exit((unsigned char)0);
    }

    unsigned long int return_value_getTrailerPad_5;
    return_value_getTrailerPad_5=getTrailerPad((unsigned long int)chunkHeader->length);
    chunkTrailer = (struct chunkTrailer *)(memory + (signed long int)chunkHeader->length + (signed long int)return_value_getTrailerPad_5);
    if(!(chunkTrailer->magicNumber == 305419896u))
    {
      debug_output((signed char)0, "debugRealloc - invalid magic number in trailer: %08x, malloc tag = %d\n", chunkTrailer->magicNumber, chunkHeader->tag);
      restore_and_exit((unsigned char)0);
    }

    unsigned long int return_value_getTrailerPad_6;
    return_value_getTrailerPad_6=getTrailerPad((unsigned long int)chunkHeader->length);
    signed int return_value_checkPadding_7;
    return_value_checkPadding_7=checkPadding(memory + (signed long int)chunkHeader->length, return_value_getTrailerPad_6);
    if(return_value_checkPadding_7 == 0)
    {
      debug_output((signed char)0, "debugRealloc - invalid magic padding in trailer, malloc tag = %d\n", chunkHeader->tag);
      restore_and_exit((unsigned char)0);
    }

  }

  void *return_value_debugMalloc_8;
  return_value_debugMalloc_8=debugMalloc(length, tag);
  result = (unsigned char *)return_value_debugMalloc_8;
  if(!(memoryParameter == NULL))
  {
    copyLength = length;
    if(!(chunkHeader->length >= copyLength))
      copyLength = chunkHeader->length;

    memcpy((void *)result, memoryParameter, (unsigned long int)copyLength);
    debugFree(memoryParameter, 9999);
  }

  return (void *)result;
}

// debug_orig
// file originator.h line 34
void debug_orig(void)
{
  struct hash_it_t *hashit = (struct hash_it_t *)(void *)0;
  struct list_head *forw_pos;
  struct list_head *orig_pos;
  struct list_head *neigh_pos;
  struct forw_node *forw_node;
  struct orig_node *orig_node;
  struct neigh_node *neigh_node;
  struct gw_node *gw_node;
  unsigned short int batman_count = (unsigned short int)0;
  unsigned long int uptime_sec;
  signed int download_speed;
  signed int upload_speed;
  signed int debug_out_size;
  char str[16l];
  char str2[16l];
  char orig_str[16l];
  char debug_out_str[1001l];
  if((signed int)debug_clients.clients_num[1l] >= 1)
  {
    addr_to_string(((struct batman_if *)if_list.next)->addr.sin_addr.s_addr, orig_str, (signed int)sizeof(char [16l]) /*16ul*/ );
    unsigned long int return_value_get_time_msec64_1;
    return_value_get_time_msec64_1=get_time_msec64();
    uptime_sec = (unsigned long int)(return_value_get_time_msec64_1 / (unsigned long int)1000);
    debug_output((signed char)2, "BOD\n");
    debug_output((signed char)2, "%''12s     (%s/%i) %''15s [%10s], gw_class ... [B.A.T.M.A.N. %s, MainIF/IP: %s/%s, UT: %id%2ih%2im] \n", (const void *)"Gateway", (const void *)"#", 255, (const void *)"Nexthop", (const void *)"outgoingIF", (const void *)"debian-0.3.2-17", ((struct batman_if *)if_list.next)->dev, (const void *)orig_str, (unsigned int)(uptime_sec / (unsigned long int)86400), (unsigned int)((uptime_sec % (unsigned long int)86400) / (unsigned long int)3600), (unsigned int)((uptime_sec % (unsigned long int)3600) / (unsigned long int)60));
    signed int return_value_list_empty_2;
    return_value_list_empty_2=list_empty(&gw_list);
    if(!(return_value_list_empty_2 == 0))
      debug_output((signed char)2, "No gateways in range ... \n");

    else
    {
      orig_pos = (&gw_list)->next;
      for( ; !(orig_pos == (struct list_head *)&gw_list); orig_pos = orig_pos->next)
      {
        gw_node = (struct gw_node *)((char *)orig_pos - (signed long int)(unsigned long int)&((struct gw_node *)0)->list);
        if(gw_node->deleted == 0u)
        {
          if(!(gw_node->orig_node->router == ((struct neigh_node *)NULL)))
          {
            addr_to_string(gw_node->orig_node->orig, str, (signed int)sizeof(char [16l]) /*16ul*/ );
            addr_to_string(gw_node->orig_node->router->addr, str2, (signed int)sizeof(char [16l]) /*16ul*/ );
            get_gw_speeds(gw_node->orig_node->gwflags, &download_speed, &upload_speed);
            debug_output((signed char)2, "%s %-15s (%3i) %''15s [%10s], gw_class %3i - %i%s/%i%s, gateway failures: %i \n", curr_gateway == gw_node ? "=>" : "  ", (const void *)str, gw_node->orig_node->router->tq_avg, (const void *)str2, gw_node->orig_node->router->if_incoming->dev, gw_node->orig_node->gwflags, download_speed > 2048 ? download_speed / 1024 : download_speed, download_speed > 2048 ? "MBit" : "KBit", upload_speed > 2048 ? upload_speed / 1024 : upload_speed, upload_speed > 2048 ? "MBit" : "KBit", gw_node->gw_failure);
            batman_count = batman_count + 1;
          }

        }

      }
      if((signed int)batman_count == 0)
        debug_output((signed char)2, "No gateways in range ... \n");

    }
    debug_output((signed char)2, "EOD\n");
  }

  _Bool tmp_if_expr_5;
  if((signed int)*debug_clients.clients_num >= 1)
    tmp_if_expr_5 = (_Bool)1;

  else
    tmp_if_expr_5 = (signed int)debug_clients.clients_num[(signed long int)3] > 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_5)
  {
    addr_to_string(((struct batman_if *)if_list.next)->addr.sin_addr.s_addr, orig_str, (signed int)sizeof(char [16l]) /*16ul*/ );
    unsigned long int return_value_get_time_msec64_3;
    return_value_get_time_msec64_3=get_time_msec64();
    uptime_sec = (unsigned long int)(return_value_get_time_msec64_3 / (unsigned long int)1000);
    debug_output((signed char)1, "BOD \n");
    debug_output((signed char)1, "  %-11s (%s/%i) %''15s [%10s]: %''20s ... [B.A.T.M.A.N. %s, MainIF/IP: %s/%s, UT: %id%2ih%2im] \n", (const void *)"Originator", (const void *)"#", 255, (const void *)"Nexthop", (const void *)"outgoingIF", (const void *)"Potential nexthops", (const void *)"debian-0.3.2-17", ((struct batman_if *)if_list.next)->dev, (const void *)orig_str, (unsigned int)(uptime_sec / (unsigned long int)86400), (unsigned int)((uptime_sec % (unsigned long int)86400) / (unsigned long int)3600), (unsigned int)((uptime_sec % (unsigned long int)3600) / (unsigned long int)60));
    if((signed int)debug_clients.clients_num[3l] >= 1)
    {
      debug_output((signed char)4, "------------------ DEBUG ------------------ \n");
      debug_output((signed char)4, "Forward list \n");
      forw_pos = (&forw_list)->next;
      for( ; !(forw_pos == (struct list_head *)&forw_list); forw_pos = forw_pos->next)
      {
        forw_node = (struct forw_node *)((char *)forw_pos - (signed long int)(unsigned long int)&((struct forw_node *)0)->list);
        addr_to_string(((struct bat_packet *)forw_node->pack_buff)->orig, str, (signed int)sizeof(char [16l]) /*16ul*/ );
        debug_output((signed char)4, "    %s at %u \n", (const void *)str, forw_node->send_time);
      }
      debug_output((signed char)4, "Originator list \n");
      debug_output((signed char)4, "  %-11s (%s/%i) %''15s [%10s]: %''20s\n", (const void *)"Originator", (const void *)"#", 255, (const void *)"Nexthop", (const void *)"outgoingIF", (const void *)"Potential nexthops");
    }

    do
    {
      hashit=hash_iterate(orig_hash, hashit);
      if(hashit == ((struct hash_it_t *)NULL))
        break;

      orig_node = (struct orig_node *)hashit->bucket->data;
      if(!(orig_node->router == ((struct neigh_node *)NULL)))
      {
        batman_count = batman_count + 1;
        addr_to_string(orig_node->orig, str, (signed int)sizeof(char [16l]) /*16ul*/ );
        addr_to_string(orig_node->router->addr, str2, (signed int)sizeof(char [16l]) /*16ul*/ );
        debug_output((signed char)1, "%-15s (%3i) %''15s [%10s]:", (const void *)str, orig_node->router->tq_avg, (const void *)str2, orig_node->router->if_incoming->dev);
        debug_output((signed char)4, "%''15s (%3i) %''15s [%10s], last_valid: %u: \n", (const void *)str, orig_node->router->tq_avg, (const void *)str2, orig_node->router->if_incoming->dev, orig_node->last_valid);
        debug_out_size = 0;
        neigh_pos = (&orig_node->neigh_list)->next;
        for( ; !(neigh_pos == (struct list_head *)&orig_node->neigh_list); neigh_pos = neigh_pos->next)
        {
          neigh_node = (struct neigh_node *)((char *)neigh_pos - (signed long int)(unsigned long int)&((struct neigh_node *)0)->list);
          addr_to_string(neigh_node->addr, str, (signed int)sizeof(char [16l]) /*16ul*/ );
          signed int return_value_snprintf_4;
          return_value_snprintf_4=snprintf(debug_out_str + (signed long int)debug_out_size, (sizeof(char [1001l]) /*1001ul*/  - (unsigned long int)1) - (unsigned long int)debug_out_size, " %15s (%3i)", (const void *)str, neigh_node->tq_avg);
          debug_out_size = debug_out_size + return_value_snprintf_4;
          if((unsigned long int)(30u + (unsigned int)debug_out_size) >= 1001ul)
          {
            debug_output((signed char)1, "%s \n", (const void *)debug_out_str);
            debug_output((signed char)4, "%s \n", (const void *)debug_out_str);
            debug_out_size = 0;
          }

        }
        if(debug_out_size >= 1)
        {
          debug_output((signed char)1, "%s \n", (const void *)debug_out_str);
          debug_output((signed char)4, "%s \n", (const void *)debug_out_str);
        }

      }

    }
    while((_Bool)1);
    if((signed int)batman_count == 0)
    {
      debug_output((signed char)1, "No batman nodes in range ... \n");
      debug_output((signed char)4, "No batman nodes in range ... \n");
    }

    debug_output((signed char)1, "EOD\n");
    debug_output((signed char)4, "---------------------------------------------- END DEBUG \n");
  }

}

// debug_output
// file os.h line 100
void debug_output(signed char debug_prio, char *format, ...)
{
  struct list_head *debug_pos;
  struct debug_level_info *debug_level_info;
  signed char debug_prio_intern;
  void **args;
  unsigned int return_value_get_time_msec_1;
  unsigned int return_value_get_time_msec_4;
  signed int return_value_strncmp_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_8;
  signed int return_value_strncmp_7;
  signed int *return_value___errno_location_9;
  char *return_value_strerror_10;
  if(log_facility_active == 0)
  {
    args = (void **)&format;
    vprintf(format, args);
    args = ((void **)NULL);
  }

  else
  {
    if((signed int)debug_prio == 0)
    {
      if((signed int)debug_level == 0)
      {
        args = (void **)&format;
        vsyslog(3, format, args);
        args = ((void **)NULL);
      }

      else
        if((signed int)debug_level == 3 || (signed int)debug_level == 4)
        {
          if((signed int)debug_level == 4)
          {
            return_value_get_time_msec_1=get_time_msec();
            printf("[%10u] ", return_value_get_time_msec_1);
          }

          args = (void **)&format;
          vprintf(format, args);
          args = ((void **)NULL);
        }

      debug_prio_intern = (signed char)3;
    }

    else
      debug_prio_intern = (signed char)((signed int)debug_prio - 1);
    if((signed int)debug_clients.clients_num[(signed long int)debug_prio_intern] >= 1)
    {
      signed int return_value_pthread_mutex_trylock_3;
      return_value_pthread_mutex_trylock_3=pthread_mutex_trylock((union anonymous_16 *)debug_clients.mutex[(signed long int)debug_prio_intern]);
      if(!(return_value_pthread_mutex_trylock_3 == 0))
      {
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(16);
        debug_output((signed char)0, "Warning - could not trylock mutex (debug_output): %s \n", return_value_strerror_2);
        goto __CPROVER_DUMP_L19;
      }

      args = (void **)&format;
      debug_pos = ((struct list_head *)debug_clients.fd_list[(signed long int)debug_prio_intern])->next;
      for( ; !(debug_pos == (struct list_head *)debug_clients.fd_list[(signed long int)debug_prio_intern]); debug_pos = debug_pos->next)
      {
        debug_level_info = (struct debug_level_info *)((char *)debug_pos - (signed long int)(unsigned long int)&((struct debug_level_info *)0)->list);
        if((signed int)debug_prio_intern == 3)
        {
          return_value_get_time_msec_4=get_time_msec();
          dprintf(debug_level_info->fd, "[%10u] ", return_value_get_time_msec_4);
        }

        if((signed int)debug_level == 1 || (signed int)debug_level == 2)
        {
          if(debug_level_info->fd == 1)
          {
            return_value_strncmp_5=strncmp(format, "BOD", (unsigned long int)3);
            if(return_value_strncmp_5 == 0)
              printf("\033[2J\033[0;0f");

          }

        }

        if(!((signed int)debug_level == 1) && !((signed int)debug_level == 2))
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = debug_level_info->fd != 1 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_strncmp_7=strncmp(format, "EOD", (unsigned long int)3);
          tmp_if_expr_8 = return_value_strncmp_7 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          vdprintf(debug_level_info->fd, format, args);

      }
      args = ((void **)NULL);
      signed int return_value_pthread_mutex_unlock_11;
      return_value_pthread_mutex_unlock_11=pthread_mutex_unlock((union anonymous_16 *)debug_clients.mutex[(signed long int)debug_prio_intern]);
      if(!(return_value_pthread_mutex_unlock_11 >= 0))
      {
        return_value___errno_location_9=__errno_location();
        return_value_strerror_10=strerror(*return_value___errno_location_9);
        debug_output((signed char)0, "Error - could not unlock mutex (debug_output): %s \n", return_value_strerror_10);
      }

    }

  }

__CPROVER_DUMP_L19:
  ;
}

// del_default_route
// file os.h line 84
void del_default_route(void)
{
  curr_gateway = (struct gw_node *)(void *)0;
}

// del_dev_tun
// file linux/tun.c line 154
signed char del_dev_tun(signed int fd)
{
  signed int return_value_ioctl_3;
  return_value_ioctl_3=ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(84 << 0 + 8) | (unsigned int)(203 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, 0);
  if(!(return_value_ioctl_3 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    debug_output((signed char)0, "Error - can't delete tun device: %s\n", return_value_strerror_2);
    return (signed char)-1;
  }

  close(fd);
  return (signed char)1;
}

// del_gw_interface
// file posix/posix.c line 428
void del_gw_interface(void)
{
  struct batman_if *batman_if = (struct batman_if *)if_list.next;
  struct batgat_ioc_args args;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  if(batman_if->udp_tunnel_sock >= 1)
  {
    if(!(batman_if->listen_thread_id == 0ul))
      pthread_join(batman_if->listen_thread_id, (void **)(void *)0);

    else
      if(!(batman_if->dev == ((char *)NULL)))
      {
        strncpy(args.dev_name, batman_if->dev, (unsigned long int)(16 - 1));
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(batman_if->dev);
        args.universal = (unsigned int)return_value_strlen_1;
        signed int return_value_ioctl_4;
        return_value_ioctl_4=ioctl(batman_if->udp_tunnel_sock, (unsigned long int)2, &args);
        if(!(return_value_ioctl_4 >= 0))
        {
          return_value___errno_location_2=__errno_location();
          return_value_strerror_3=strerror(*return_value___errno_location_2);
          debug_output((signed char)0, "Error - can't remove device %s from kernel module : %s\n", batman_if->dev, return_value_strerror_3);
        }

      }

    close(batman_if->udp_tunnel_sock);
    batman_if->listen_thread_id = (unsigned long int)0;
    batman_if->udp_tunnel_sock = 0;
  }

}

// del_nat_rule
// file linux/tun.c line 110
void del_nat_rule(char *dev)
{
  char cmd[100l];
  sprintf(cmd, "iptables -t nat -D POSTROUTING -o %s -j MASQUERADE", dev);
  exec_iptables_rule(cmd, (signed char)1);
}

// exec_iptables_rule
// file linux/tun.c line 90
void exec_iptables_rule(char *cmd, signed char route_action)
{
  if(disable_client_nat == 0)
  {
    if(nat_tool_avail == -1)
    {
      debug_output((signed char)3, "Warning - could not %sactivate NAT: iptables binary not found!\n", (signed int)route_action == 0 ? "" : "de");
      debug_output((signed char)3, "          You may need to run this command: %s\n", cmd);
    }

    else
      run_cmd(cmd);
  }

}

// fillPadding
// file allocate.c line 102
static void fillPadding(unsigned char *padding, unsigned long int length)
{
  unsigned char c = (unsigned char)0x00;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= length); i = i + 1ul)
  {
    c = c + (unsigned char)0xA7;
    padding[(signed long int)i] = c;
  }
}

// flush_routes_rules
// file linux/route.c line 620
signed int flush_routes_rules(signed char is_rule)
{
  signed int netlink_sock;
  signed int rtl;
  unsigned long int len;
  signed int dest = 0;
  signed int router = 0;
  signed int ifi = 0;
  unsigned int prio = (unsigned int)0;
  signed char rule_type = (signed char)0;
  char buf[8192l];
  char *dev = (char *)(void *)0;
  struct sockaddr_nl nladdr;
  struct iovec iov;
  struct msghdr msg;
  struct nlmsghdr *nh;
  struct rtmsg *rtm;
  /* flush_routes_rules::1::tag-req_s */
struct req_s_1
{
  // rtm
  struct rtmsg rtm;
};

/* */
  ;
  struct req_s_1 *req;
  char req_buf[(signed long int)(sizeof(struct req_s_1) * 2 + 4) /*28l*/ ];
  struct rtattr *rtap;
  iov.iov_base = (void *)buf;
  iov.iov_len = sizeof(char [8192l]) /*8192ul*/ ;
  nh = (struct nlmsghdr *)req_buf;
  req = (struct req_s_1 *)(void *)((char *)req_buf + (signed long int)(0 + (signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1))));
  memset((void *)&nladdr, 0, sizeof(struct sockaddr_nl) /*12ul*/ );
  memset((void *)req_buf, 0, sizeof(struct req_s_1) /*12ul*/  + (unsigned long int)(signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)));
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  nladdr.nl_family = (unsigned short int)16;
  nh->nlmsg_len = (unsigned int)(sizeof(struct req_s_1) /*12ul*/  + (unsigned long int)(signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)));
  signed int return_value_getpid_1;
  return_value_getpid_1=getpid();
  nh->nlmsg_pid = (unsigned int)return_value_getpid_1;
  req->rtm.rtm_family = (unsigned char)2;
  nh->nlmsg_flags = (unsigned short int)(1 | 0x100 | 0x200);
  nh->nlmsg_type = (unsigned short int)(is_rule != 0 ? 34 : 26);
  req->rtm.rtm_scope = (unsigned char)1;
  netlink_sock=socket(16, 2, 0);
  if(!(netlink_sock >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    debug_output((signed char)0, "Error - can't create netlink socket for flushing the routing table: %s\n", return_value_strerror_3);
    return -1;
  }

  signed long int return_value_sendto_6;
  return_value_sendto_6=sendto(netlink_sock, (const void *)req_buf, (unsigned long int)nh->nlmsg_len, 0, (struct sockaddr *)&nladdr, (unsigned int)sizeof(struct sockaddr_nl) /*12ul*/ );
  if(!(return_value_sendto_6 >= 0l))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    debug_output((signed char)0, "Error - can't send message to kernel via netlink socket for flushing the routing table: %s\n", return_value_strerror_5);
    close(netlink_sock);
    return -1;
  }

  msg.msg_name = (void *)&nladdr;
  msg.msg_namelen = (unsigned int)sizeof(struct sockaddr_nl) /*12ul*/ ;
  msg.msg_iov = &iov;
  msg.msg_iovlen = (unsigned long int)1;
  msg.msg_control = (void *)0;
  signed long int return_value_recvmsg_7;
  return_value_recvmsg_7=recvmsg(netlink_sock, &msg, 0);
  len = (unsigned long int)return_value_recvmsg_7;
  nh = (struct nlmsghdr *)buf;
  while(len >= sizeof(struct nlmsghdr) /*16ul*/ )
  {
    if(!((unsigned long int)nh->nlmsg_len >= sizeof(struct nlmsghdr) /*16ul*/ ))
      break;

    if(!(len >= (unsigned long int)nh->nlmsg_len))
      break;

    if((signed int)nh->nlmsg_type == 0x3)
      break;

    if((signed int)nh->nlmsg_type == 0x2)
    {
      if(!(((struct nlmsgerr *)((char *)nh + 16l))->error == 0))
      {
        char *return_value_strerror_8;
        return_value_strerror_8=strerror(-((struct nlmsgerr *)(void *)((char *)nh + (signed long int)(0 + (signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)))))->error);
        debug_output((signed char)0, "Error - can't flush %s: %s \n", is_rule != 0 ? "routing rules" : "routing table", return_value_strerror_8);
        close(netlink_sock);
        return -1;
      }

    }

    rtm = (struct rtmsg *)(void *)((char *)nh + (signed long int)(0 + (signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1))));
    rtap = (struct rtattr *)((char *)rtm + (signed long int)((sizeof(struct rtmsg) /*12ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)));
    rtl = (signed int)((unsigned long int)nh->nlmsg_len - ((sizeof(struct rtmsg) /*12ul*/  + (unsigned long int)(signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)) + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)));
    len = len - (unsigned long int)((nh->nlmsg_len + 4U) - (unsigned int)1 & ~(4U - (unsigned int)1));
    nh = (struct nlmsghdr *)((char *)nh + (signed long int)((nh->nlmsg_len + 4U) - (unsigned int)1 & ~(4U - (unsigned int)1)));
    if(!((signed int)rtm->rtm_table == 67))
    {
      if(!((signed int)rtm->rtm_table == 65))
      {
        if(!((signed int)rtm->rtm_table == 66))
        {
          if(!((signed int)rtm->rtm_table == 68))
            continue;

        }

      }

    }

    for( ; rtl >= (signed int)sizeof(struct rtattr) /*4*/ ; rtap = (struct rtattr *)((char *)rtap + (signed long int)(((unsigned int)rtap->rta_len + 4U) - (unsigned int)1 & ~(4U - (unsigned int)1))))
    {
      if(!((unsigned long int)rtap->rta_len >= sizeof(struct rtattr) /*4ul*/ ))
        break;

      if(!(rtl >= (signed int)rtap->rta_len))
        break;

      switch((signed int)rtap->rta_type)
      {
        case 1:
        {
          dest = *((signed int *)(void *)((char *)rtap + (signed long int)(((sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)) + (unsigned long int)0)));
          rule_type = (signed char)2;
          break;
        }
        case 2:
        {
          dest = *((signed int *)(void *)((char *)rtap + (signed long int)(((sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)) + (unsigned long int)0)));
          rule_type = (signed char)0;
          break;
        }
        case 5:
        {
          router = *((signed int *)(void *)((char *)rtap + (signed long int)(((sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)) + (unsigned long int)0)));
          break;
        }
        case 4:
        {
          ifi = *((signed int *)(void *)((char *)rtap + (signed long int)(((sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)) + (unsigned long int)0)));
          break;
        }
        case 6:
        {
          prio = *((unsigned int *)(void *)((char *)rtap + (signed long int)(((sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)) + (unsigned long int)0)));
          break;
        }
        case 3:
        {
          dev = (char *)(void *)((char *)rtap + (signed long int)(((sizeof(struct rtattr) /*4ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)) + (unsigned long int)0));
          rule_type = (signed char)1;
          break;
        }
        case 15:
          break;
        case 7:
          break;
        default:
          debug_output((signed char)0, "Error - unknown rta type: %i \n", rtap->rta_type);
      }
      rtl = rtl - (signed int)(((unsigned int)rtap->rta_len + 4U) - (unsigned int)1 & ~(4U - (unsigned int)1));
    }
    if(!(is_rule == 0))
      switch((signed int)rule_type)
      {
        case 0:
        {
          add_del_rule((unsigned int)dest, rtm->rtm_src_len, (signed char)rtm->rtm_table, prio, ((char *)NULL), rule_type, (signed char)1);
          break;
        }
        case 1:
        {
          add_del_rule((unsigned int)dest, rtm->rtm_dst_len, (signed char)rtm->rtm_table, prio, ((char *)NULL), rule_type, (signed char)1);
          break;
        }
        case 2:
          add_del_rule((unsigned int)0, (unsigned char)0, (signed char)rtm->rtm_table, prio, dev, rule_type, (signed char)1);
      }

    else
    {
      switch((signed int)rtm->rtm_type)
      {
        case 1:
        {
          rule_type = (signed char)0;
          break;
        }
        case 9:
        {
          rule_type = (signed char)1;
          break;
        }
        case 7:
        {
          rule_type = (signed char)2;
          break;
        }
        default:
          rule_type = (signed char)3;
      }
      if((signed int)rule_type == 2)
      {
        router = 0;
        dest = router;
      }

      add_del_route((unsigned int)dest, rtm->rtm_dst_len, (unsigned int)router, (unsigned int)0, ifi, "unknown", rtm->rtm_table, rule_type, (signed char)1);
    }
  }
  close(netlink_sock);
  return 1;
}

// generate_vis_packet
// file batman.c line 629
static void generate_vis_packet(void)
{
  struct hash_it_t *hashit = (struct hash_it_t *)(void *)0;
  struct orig_node *orig_node;
  struct vis_data *vis_data;
  struct list_head *list_pos;
  struct batman_if *batman_if;
  if(!(vis_packet == ((unsigned char *)NULL)))
  {
    debugFree((void *)vis_packet, 1102);
    vis_packet = (unsigned char *)(void *)0;
    vis_packet_size = (unsigned short int)0;
  }

  vis_packet_size = (unsigned short int)sizeof(struct vis_packet) /*7ul*/ ;
  void *return_value_debugMalloc_1;
  return_value_debugMalloc_1=debugMalloc((unsigned int)vis_packet_size, 104);
  vis_packet = (unsigned char *)return_value_debugMalloc_1;
  memcpy((void *)&((struct vis_packet *)vis_packet)->sender_ip, (const void *)(unsigned char *)&((struct batman_if *)if_list.next)->addr.sin_addr.s_addr, (unsigned long int)4);
  ((struct vis_packet *)vis_packet)->version = (unsigned char)23;
  ((struct vis_packet *)vis_packet)->gw_class = gateway_class;
  ((struct vis_packet *)vis_packet)->tq_max = (unsigned char)255;
  do
  {
    hashit=hash_iterate(orig_hash, hashit);
    if(hashit == ((struct hash_it_t *)NULL))
      break;

    orig_node = (struct orig_node *)hashit->bucket->data;
    if(!(orig_node->router == ((struct neigh_node *)NULL)))
    {
      if(orig_node->orig == orig_node->router->addr)
      {
        if((signed int)orig_node->router->tq_avg >= 1)
        {
          vis_packet_size = vis_packet_size + (unsigned short int)sizeof(struct vis_data) /*6ul*/ ;
          void *return_value_debugRealloc_2;
          return_value_debugRealloc_2=debugRealloc((void *)vis_packet, (unsigned int)vis_packet_size, 105);
          vis_packet = (unsigned char *)return_value_debugRealloc_2;
          vis_data = (struct vis_data *)((vis_packet + (signed long int)vis_packet_size) - (signed long int)sizeof(struct vis_data) /*6ul*/ );
          memcpy((void *)&vis_data->ip, (const void *)(unsigned char *)&orig_node->orig, (unsigned long int)4);
          vis_data->data = orig_node->router->tq_avg;
          vis_data->type = (unsigned char)1;
        }

      }

    }

  }
  while((_Bool)1);
  if((signed int)found_ifs >= 2)
  {
    list_pos = (&if_list)->next;
    for( ; !(list_pos == (struct list_head *)&if_list); list_pos = list_pos->next)
    {
      batman_if = (struct batman_if *)((char *)list_pos - (signed long int)(unsigned long int)&((struct batman_if *)0)->list);
      if(!(((struct vis_packet *)vis_packet)->sender_ip == batman_if->addr.sin_addr.s_addr))
      {
        vis_packet_size = vis_packet_size + (unsigned short int)sizeof(struct vis_data) /*6ul*/ ;
        void *return_value_debugRealloc_3;
        return_value_debugRealloc_3=debugRealloc((void *)vis_packet, (unsigned int)vis_packet_size, 106);
        vis_packet = (unsigned char *)return_value_debugRealloc_3;
        vis_data = (struct vis_data *)((vis_packet + (signed long int)vis_packet_size) - (signed long int)sizeof(struct vis_data) /*6ul*/ );
        memcpy((void *)&vis_data->ip, (const void *)(unsigned char *)&batman_if->addr.sin_addr.s_addr, (unsigned long int)4);
        vis_data->data = (unsigned char)0;
        vis_data->type = (unsigned char)2;
      }

    }
  }

  vis_packet=hna_local_update_vis_packet(vis_packet, &vis_packet_size);
  if((unsigned long int)vis_packet_size == sizeof(struct vis_packet) /*7ul*/ )
  {
    debugFree((void *)vis_packet, 1107);
    vis_packet = (unsigned char *)(void *)0;
    vis_packet_size = (unsigned short int)0;
  }

}

// getHeaderPad
// file allocate.c line 70
static unsigned long int getHeaderPad()
{
  unsigned long int alignwith;
  unsigned long int pad;
  alignwith = sizeof(void *) /*8ul*/ ;
  pad = alignwith - sizeof(struct chunkHeader) /*24ul*/  % alignwith;
  if(pad == alignwith)
    return (unsigned long int)0;

  else
    return pad;
}

// getTrailerPad
// file allocate.c line 86
static unsigned long int getTrailerPad(unsigned long int length)
{
  unsigned long int alignwith;
  unsigned long int pad;
  alignwith = sizeof(void *) /*8ul*/ ;
  pad = alignwith - length % alignwith;
  if(pad == alignwith)
    return (unsigned long int)0;

  else
    return pad;
}

// get_bit_status
// file bitarray.h line 29
unsigned char get_bit_status(unsigned long int *seq_bits, unsigned short int last_seqno, unsigned short int curr_seqno)
{
  signed short int diff;
  signed short int word_offset;
  signed short int word_num;
  diff = (signed short int)((signed int)last_seqno - (signed int)curr_seqno);
  if((signed int)diff >= (signed int)local_win_size || !((signed int)diff >= 0))
    return (unsigned char)0;

  else
  {
    word_offset = (signed short int)((unsigned long int)((signed int)last_seqno - (signed int)curr_seqno) % (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8));
    word_num = (signed short int)((unsigned long int)((signed int)last_seqno - (signed int)curr_seqno) / (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8));
    if(!((seq_bits[(signed long int)word_num] & 1ULL << (signed int)word_offset) == 0ul))
      return (unsigned char)1;

    else
      return (unsigned char)0;
  }
}

// get_forwarding
// file os.h line 77
signed int get_forwarding(void)
{
  signed int return_value_get_integer_file_1;
  return_value_get_integer_file_1=get_integer_file("/proc/sys/net/ipv4/ip_forward");
  return return_value_get_integer_file_1;
}

// get_gw_class
// file batman.c line 496
unsigned char get_gw_class(signed int down, signed int up)
{
  signed int mdown = 0;
  signed int tdown;
  signed int tup;
  signed int difference = 0x0FFFFFFF;
  unsigned char gw_class = (unsigned char)0;
  unsigned char sbit;
  unsigned char part;
  sbit = (unsigned char)0;
  for( ; !((signed int)sbit >= 2); sbit = sbit + 1)
  {
    part = (unsigned char)0;
    for( ; !((signed int)part >= 16); part = part + 1)
    {
      tdown = 32 * ((signed int)sbit + 2) * (1 << (signed int)part);
      signed int return_value_abs_1;
      return_value_abs_1=abs(tdown - down);
      if(!(return_value_abs_1 >= difference))
      {
        gw_class = (unsigned char)(((signed int)sbit << 7) + ((signed int)part << 3));
        difference=abs(tdown - down);
        mdown = tdown;
      }

    }
  }
  difference = 0x0FFFFFFF;
  part = (unsigned char)0;
  for( ; !((signed int)part >= 8); part = part + 1)
  {
    tup = (((signed int)part + 1) * mdown) / 8;
    signed int return_value_abs_2;
    return_value_abs_2=abs(tup - up);
    if(!(return_value_abs_2 >= difference))
    {
      gw_class = (unsigned char)((signed int)gw_class & 0xF8 | (signed int)part);
      difference=abs(tup - up);
    }

  }
  return gw_class;
}

// get_gw_speeds
// file batman.c line 483
void get_gw_speeds(unsigned char gw_class, signed int *down, signed int *up)
{
  char sbit = (char)(((signed int)gw_class & 0x80) >> 7);
  char dpart = (char)(((signed int)gw_class & 0x7C) >> 3);
  char upart = (char)((signed int)gw_class & 0x07);
  *down = 32 * ((signed int)sbit + 2) * (1 << (signed int)dpart);
  *up = (((signed int)upart + 1) * *down) / 8;
}

// get_integer_file
// file linux/kernel.c line 44
static signed int get_integer_file(const char *filename)
{
  struct _IO_FILE *f;
  signed int integer = 0;
  signed int n;
  f=fopen(filename, "r");
  if(f == ((struct _IO_FILE *)NULL))
    return 0;

  else
  {
    n=fscanf(f, "%d", &integer);
    fclose(f);
    if(n == 0 || n == -1)
      integer = 0;

    return integer;
  }
}

// get_ip_addr
// file posix/tunnel.c line 436
static struct gw_client * get_ip_addr(struct sockaddr_in *client_addr, struct hashtable_t **wip_hash, struct hashtable_t **vip_hash, struct list_head_first *free_ip_list, unsigned char *next_free_ip)
{
  struct gw_client *gw_client;
  struct free_ip *free_ip;
  struct list_head *list_pos;
  struct list_head *list_pos_tmp;
  struct hashtable_t *swaphash;
  void *return_value_hash_find_1;
  return_value_hash_find_1=hash_find(*wip_hash, (void *)&client_addr->sin_addr.s_addr);
  gw_client = (struct gw_client *)return_value_hash_find_1;
  if(!(gw_client == ((struct gw_client *)NULL)))
    return gw_client;

  else
  {
    void *return_value_debugMalloc_2;
    return_value_debugMalloc_2=debugMalloc((unsigned int)sizeof(struct gw_client) /*20ul*/ , 208);
    gw_client = (struct gw_client *)return_value_debugMalloc_2;
    gw_client->wip_addr = client_addr->sin_addr.s_addr;
    gw_client->client_port = client_addr->sin_port;
    gw_client->last_keep_alive=get_time_msec();
    gw_client->vip_addr = (unsigned int)0;
    gw_client->nat_warn = (unsigned char)0;
    list_pos = free_ip_list->next;
    list_pos_tmp = list_pos->next;
    if(!(list_pos == (struct list_head *)free_ip_list))
    {
      free_ip = (struct free_ip *)((char *)list_pos - (signed long int)(unsigned long int)&((struct free_ip *)0)->list);
      gw_client->vip_addr = free_ip->addr;
      list_del((struct list_head *)free_ip_list, list_pos, free_ip_list);
      debugFree((void *)free_ip, 1216);
      goto __CPROVER_DUMP_L3;
      list_pos = list_pos_tmp;
      list_pos_tmp = list_pos->next;
    }


  __CPROVER_DUMP_L3:
    ;
    if(gw_client->vip_addr == 0u)
    {
      gw_client->vip_addr = *((unsigned int *)next_free_ip);
      next_free_ip[(signed long int)3] = next_free_ip[(signed long int)3] + 1;
      if((signed int)next_free_ip[3l] == 0)
        next_free_ip[(signed long int)2] = next_free_ip[(signed long int)2] + 1;

    }

    hash_add(*wip_hash, (void *)gw_client);
    hash_add(*vip_hash, (void *)gw_client);
    if(!((*wip_hash)->size >= 4 * (*wip_hash)->elements))
    {
      swaphash=hash_resize(*wip_hash, (*wip_hash)->size * 2);
      if(swaphash == ((struct hashtable_t *)NULL))
      {
        debug_output((signed char)0, "Couldn't resize hash table \n");
        restore_and_exit((unsigned char)0);
      }

      *wip_hash = swaphash;
      swaphash=hash_resize(*vip_hash, (*vip_hash)->size * 2);
      if(swaphash == ((struct hashtable_t *)NULL))
      {
        debug_output((signed char)0, "Couldn't resize hash table \n");
        restore_and_exit((unsigned char)0);
      }

      *vip_hash = swaphash;
    }

    return gw_client;
  }
}

// get_orig_node
// file originator.h line 31
struct orig_node * get_orig_node(unsigned int addr)
{
  struct orig_node *orig_node;
  struct hashtable_t *swaphash;
  char orig_str[16l];
  prof_start(4);
  void *return_value_hash_find_1;
  return_value_hash_find_1=hash_find(orig_hash, (void *)&addr);
  orig_node = (struct orig_node *)return_value_hash_find_1;
  if(!(orig_node == ((struct orig_node *)NULL)))
  {
    prof_stop(4);
    return orig_node;
  }

  else
  {
    addr_to_string(addr, orig_str, 16);
    debug_output((signed char)4, "Creating new originator: %s \n", (const void *)orig_str);
    void *return_value_debugMalloc_2;
    return_value_debugMalloc_2=debugMalloc((unsigned int)sizeof(struct orig_node) /*88ul*/ , 401);
    orig_node = (struct orig_node *)return_value_debugMalloc_2;
    memset((void *)orig_node, 0, sizeof(struct orig_node) /*88ul*/ );
    orig_node->neigh_list.next = (struct list_head *)&orig_node->neigh_list;
    orig_node->neigh_list.prev = (struct list_head *)&orig_node->neigh_list;
    orig_node->orig = addr;
    orig_node->router = (struct neigh_node *)(void *)0;
    orig_node->batman_if = (struct batman_if *)(void *)0;
    void *return_value_debugMalloc_3;
    return_value_debugMalloc_3=debugMalloc((unsigned int)((unsigned long int)found_ifs * sizeof(unsigned long int) /*8ul*/  * (unsigned long int)num_words), 404);
    orig_node->bcast_own = (unsigned long int *)return_value_debugMalloc_3;
    memset((void *)orig_node->bcast_own, 0, (unsigned long int)found_ifs * sizeof(unsigned long int) /*8ul*/  * (unsigned long int)num_words);
    void *return_value_debugMalloc_4;
    return_value_debugMalloc_4=debugMalloc((unsigned int)((unsigned long int)found_ifs * sizeof(unsigned char) /*1ul*/ ), 405);
    orig_node->bcast_own_sum = (unsigned char *)return_value_debugMalloc_4;
    memset((void *)orig_node->bcast_own_sum, 0, (unsigned long int)found_ifs * sizeof(unsigned char) /*1ul*/ );
    hash_add(orig_hash, (void *)orig_node);
    if(!(orig_hash->size >= 4 * orig_hash->elements))
    {
      swaphash=hash_resize(orig_hash, orig_hash->size * 2);
      if(swaphash == ((struct hashtable_t *)NULL))
      {
        debug_output((signed char)0, "Couldn't resize hash table \n");
        restore_and_exit((unsigned char)0);
      }

      orig_hash = swaphash;
    }

    prof_stop(4);
    return orig_node;
  }
}

// get_rp_filter
// file os.h line 73
signed int get_rp_filter(char *dev)
{
  signed int state = 0;
  char filename[100l];
  char *colon_ptr;
  colon_ptr=strchr(dev, 58);
  if(!(colon_ptr == ((char *)NULL)))
    *colon_ptr = (char)0;

  sprintf(filename, "/proc/sys/net/ipv4/conf/%s/rp_filter", dev);
  state=get_integer_file(filename);
  if(!(colon_ptr == ((char *)NULL)))
    *colon_ptr = (char)58;

  return state;
}

// get_send_redirects
// file os.h line 75
signed int get_send_redirects(char *dev)
{
  signed int state = 0;
  char filename[100l];
  char *colon_ptr;
  colon_ptr=strchr(dev, 58);
  if(!(colon_ptr == ((char *)NULL)))
    *colon_ptr = (char)0;

  sprintf(filename, "/proc/sys/net/ipv4/conf/%s/send_redirects", dev);
  state=get_integer_file(filename);
  if(!(colon_ptr == ((char *)NULL)))
    *colon_ptr = (char)58;

  return state;
}

// get_time_msec
// file os.h line 33
unsigned int get_time_msec(void)
{
  unsigned int time;
  pthread_mutex_lock(&batman_clock_mutex);
  update_internal_clock();
  time = (unsigned int)(((float)batman_clock_ticks * (float)1000) / system_tick);
  pthread_mutex_unlock(&batman_clock_mutex);
  return time;
}

// get_time_msec64
// file os.h line 34
unsigned long int get_time_msec64(void)
{
  unsigned long int time;
  pthread_mutex_lock(&batman_clock_mutex);
  update_internal_clock();
  time = (unsigned long int)(((float)batman_clock_ticks * (float)1000) / system_tick);
  pthread_mutex_unlock(&batman_clock_mutex);
  return time;
}

// get_tun_ip
// file posix/tunnel.c line 99
static signed char get_tun_ip(struct sockaddr_in *gw_addr, signed int udp_sock, unsigned int *tun_addr)
{
  struct sockaddr_in sender_addr;
  struct timeval tv;
  unsigned char buff[100l];
  signed int res;
  signed int buff_len;
  unsigned int addr_len;
  signed char i = (signed char)12;
  struct anonymous_15 wait_sockets;
  addr_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  memset((void *)&buff, 0, sizeof(unsigned char [100l]) /*100ul*/ );
  signed char return_value_is_aborted_1;
  signed int *return_value___errno_location_7;
  signed long int return_value_recvfrom_10;
  do
  {
    return_value_is_aborted_1=is_aborted();
    if(!(return_value_is_aborted_1 == 0))
      break;

    if(curr_gateway == ((struct gw_node *)NULL))
      break;

    if(!((signed int)i >= 1))
      break;

    buff[(signed long int)0] = (unsigned char)0x02;
    signed long int return_value_sendto_4;
    return_value_sendto_4=sendto(udp_sock, (const void *)buff, sizeof(unsigned char [100l]) /*100ul*/ , 0, (struct sockaddr *)gw_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_sendto_4 >= 0l))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      debug_output((signed char)0, "Error - can't send ip request to gateway: %s \n", return_value_strerror_3);
      goto next_try;
    }

    tv.tv_sec = (signed long int)0;
    tv.tv_usec = (signed long int)250000;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_15) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wait_sockets)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&wait_sockets)->fds_bits[(signed long int)(udp_sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wait_sockets)->fds_bits[(signed long int)(udp_sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << udp_sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    res=select(udp_sock + 1, &wait_sockets, (struct anonymous_15 *)(void *)0, (struct anonymous_15 *)(void *)0, &tv);
    if(!(res >= 0))
    {
      return_value___errno_location_7=__errno_location();
      if(!(*return_value___errno_location_7 == 4))
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        char *return_value_strerror_6;
        return_value_strerror_6=strerror(*return_value___errno_location_5);
        debug_output((signed char)0, "Error - can't select (get_tun_ip): %s \n", return_value_strerror_6);
        break;
      }

    }

    if(res >= 1)
    {
      if(!((wait_sockets.fds_bits[(signed long int)(udp_sock / 8)] & (signed long int)(1UL << udp_sock % 8)) == 0l))
      {
        return_value_recvfrom_10=recvfrom(udp_sock, (void *)buff, sizeof(unsigned char [100l]) /*100ul*/  - (unsigned long int)1, 0, (struct sockaddr *)&sender_addr, &addr_len);
        buff_len = (signed int)return_value_recvfrom_10;
        if(!(buff_len >= 0))
        {
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          char *return_value_strerror_9;
          return_value_strerror_9=strerror(*return_value___errno_location_8);
          debug_output((signed char)0, "Error - can't receive ip request: %s \n", return_value_strerror_9);
          goto next_try;
        }

        if(!(buff_len >= 4))
          debug_output((signed char)0, "Error - can't receive ip request: packet size is %i < 4 \n", buff_len);

        else
        {
          memcpy((void *)tun_addr, (const void *)(buff + (signed long int)1), (unsigned long int)4);
          return (signed char)1;
        }
      }

    }


  next_try:
    ;
    i = i - 1;
  }
  while((_Bool)1);
  if((signed int)i == 0)
    debug_output((signed char)0, "Error - can't receive ip from gateway: number of maximum retries reached \n");

  return (signed char)-1;
}

// get_tunneled_protocol
// file posix/tunnel.c line 72
static unsigned char get_tunneled_protocol(const unsigned char *buff)
{
  return ((struct iphdr *)(buff + (signed long int)1))->protocol;
}

// get_tunneled_sender_ip
// file posix/tunnel.c line 81
static unsigned int get_tunneled_sender_ip(const unsigned char *buff)
{
  return ((struct iphdr *)(buff + (signed long int)1))->saddr;
}

// get_tunneled_udpdest
// file posix/tunnel.c line 90
static unsigned short int get_tunneled_udpdest(const unsigned char *buff)
{
  return ((struct udphdr *)(buff + (signed long int)1 + (signed long int)((signed int)((struct iphdr *)(buff + (signed long int)1))->ihl * 4)))->_anon0._anon1.dest;
}

// gw_listen
// file posix/../os.h line 94
void * gw_listen(void *arg)
{
  struct batman_if *batman_if = (struct batman_if *)if_list.next;
  struct timeval tv;
  struct sockaddr_in addr;
  struct sockaddr_in client_addr;
  struct gw_client *gw_client;
  char gw_addr[16l];
  char str[16l];
  char tun_dev[16l];
  unsigned char buff[1501l];
  signed int res;
  signed int max_sock;
  signed int buff_len;
  signed int tun_fd;
  signed int tun_ifi;
  unsigned int addr_len;
  unsigned int client_timeout;
  unsigned int current_time;
  unsigned char my_tun_ip[4l];
  unsigned char next_free_ip[4l];
  struct hashtable_t *wip_hash;
  struct hashtable_t *vip_hash;
  struct list_head_first free_ip_list;
  struct anonymous_15 wait_sockets;
  struct anonymous_15 tmp_wait_sockets;
  struct hash_it_t *hashit;
  struct free_ip *free_ip;
  struct list_head *list_pos;
  struct list_head *list_pos_tmp;
  next_free_ip[(signed long int)0] = (unsigned char)169;
  my_tun_ip[(signed long int)0] = next_free_ip[(signed long int)0];
  next_free_ip[(signed long int)1] = (unsigned char)254;
  my_tun_ip[(signed long int)1] = next_free_ip[(signed long int)1];
  next_free_ip[(signed long int)2] = (unsigned char)0;
  my_tun_ip[(signed long int)2] = next_free_ip[(signed long int)2];
  my_tun_ip[(signed long int)3] = (unsigned char)0;
  next_free_ip[(signed long int)3] = (unsigned char)1;
  addr_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  client_timeout=get_time_msec();
  client_addr.sin_family = (unsigned short int)2;
  client_addr.sin_port=htons((unsigned short int)(4305 + 1));
  free_ip_list.next = (struct list_head *)&free_ip_list;
  free_ip_list.prev = (struct list_head *)&free_ip_list;
  signed char return_value_add_dev_tun_1;
  return_value_add_dev_tun_1=add_dev_tun(batman_if, *((unsigned int *)my_tun_ip), tun_dev, sizeof(char [16l]) /*16ul*/ , &tun_fd, &tun_ifi);
  signed int tmp_if_expr_2;
  signed char return_value_is_aborted_3;
  signed int *return_value___errno_location_6;
  signed long int return_value_recvfrom_7;
  void *return_value_hash_find_8;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  signed long int return_value_write_13;
  signed int *return_value___errno_location_11;
  char *return_value_strerror_12;
  void *return_value_hash_find_14;
  signed long int return_value_sendto_17;
  signed long int return_value_sendto_20;
  signed long int return_value_read_24;
  signed int *return_value___errno_location_26;
  char *return_value_strerror_27;
  if(!((signed int)return_value_add_dev_tun_1 >= 0))
    return (void *)0;

  else
  {
    wip_hash=hash_new(128, compare_wip, choose_wip);
    if(wip_hash == ((struct hashtable_t *)NULL))
      return (void *)0;

    else
    {
      vip_hash=hash_new(128, compare_vip, choose_vip);
      if(vip_hash == ((struct hashtable_t *)NULL))
      {
        hash_destroy(wip_hash);
        return (void *)0;
      }

      else
      {
        add_del_route(*((unsigned int *)my_tun_ip), (unsigned char)16, (unsigned int)0, (unsigned int)0, tun_ifi, tun_dev, (unsigned char)254, (signed char)0, (signed char)0);
        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_15) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wait_sockets)->fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&wait_sockets)->fds_bits[(signed long int)(batman_if->udp_tunnel_sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wait_sockets)->fds_bits[(signed long int)(batman_if->udp_tunnel_sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << batman_if->udp_tunnel_sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        (&wait_sockets)->fds_bits[(signed long int)(tun_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wait_sockets)->fds_bits[(signed long int)(tun_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << tun_fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        if(!(tun_fd >= batman_if->udp_tunnel_sock))
          tmp_if_expr_2 = batman_if->udp_tunnel_sock;

        else
          tmp_if_expr_2 = tun_fd;
        max_sock = tmp_if_expr_2;
        do
        {
          return_value_is_aborted_3=is_aborted();
          if(!(return_value_is_aborted_3 == 0))
            break;

          if(!((signed int)gateway_class >= 1))
            break;

          tv.tv_sec = (signed long int)0;
          tv.tv_usec = (signed long int)250;
          memcpy((void *)&tmp_wait_sockets, (const void *)&wait_sockets, sizeof(struct anonymous_15) /*128ul*/ );
          res=select(max_sock + 1, &tmp_wait_sockets, (struct anonymous_15 *)(void *)0, (struct anonymous_15 *)(void *)0, &tv);
          current_time=get_time_msec();
          if(!(res >= 0))
          {
            return_value___errno_location_6=__errno_location();
            if(!(*return_value___errno_location_6 == 4))
            {
              signed int *return_value___errno_location_4;
              return_value___errno_location_4=__errno_location();
              char *return_value_strerror_5;
              return_value_strerror_5=strerror(*return_value___errno_location_4);
              debug_output((signed char)0, "Error - can't select (gw_listen): %s \n", return_value_strerror_5);
              break;
            }

          }

          if(res >= 1)
          {
            if(!((tmp_wait_sockets.fds_bits[(signed long int)(batman_if->udp_tunnel_sock / 8)] & (signed long int)(1UL << batman_if->udp_tunnel_sock % 8)) == 0l))
            {
              do
              {
                return_value_recvfrom_7=recvfrom(batman_if->udp_tunnel_sock, (void *)buff, sizeof(unsigned char [1501l]) /*1501ul*/  - (unsigned long int)1, 0, (struct sockaddr *)&addr, &addr_len);
                buff_len = (signed int)return_value_recvfrom_7;
                if(!(buff_len >= 1))
                  break;

                if(!(buff_len >= 2))
                {
                  addr_to_string(addr.sin_addr.s_addr, str, (signed int)sizeof(char [16l]) /*16ul*/ );
                  debug_output((signed char)0, "Error - ignoring client packet from %s: packet too small (%i)\n", (const void *)str, buff_len);
                }

                else
                  switch((signed int)buff[(signed long int)0])
                  {
                    case 0x01:
                    {
                      return_value_hash_find_8=hash_find(vip_hash, (void *)(buff + (signed long int)9));
                      gw_client = (struct gw_client *)return_value_hash_find_8;
                      if(gw_client == ((struct gw_client *)NULL))
                        tmp_if_expr_10 = (_Bool)1;

                      else
                      {
                        if(!(gw_client->wip_addr == addr.sin_addr.s_addr))
                          tmp_if_expr_9 = (signed int)gw_client->nat_warn == 0 ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr_9 = (_Bool)0;
                        tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr_10)
                      {
                        buff[(signed long int)0] = (unsigned char)0x03;
                        addr_to_string(addr.sin_addr.s_addr, str, (signed int)sizeof(char [16l]) /*16ul*/ );
                        debug_output((signed char)0, "Error - got packet from unknown client: %s (tunnelled sender ip %i.%i.%i.%i) \n", (const void *)str, (unsigned char)buff[(signed long int)13], (unsigned char)buff[(signed long int)14], (unsigned char)buff[(signed long int)15], (unsigned char)buff[(signed long int)16]);
                        if(gw_client == ((struct gw_client *)NULL))
                        {
                          gw_client=get_ip_addr(&addr, &wip_hash, &vip_hash, &free_ip_list, next_free_ip);
                          addr_to_string(gw_client->vip_addr, str, (signed int)sizeof(char [16l]) /*16ul*/ );
                          addr_to_string(addr.sin_addr.s_addr, gw_addr, (signed int)sizeof(char [16l]) /*16ul*/ );
                          debug_output((signed char)3, "Gateway - assigned %s to unregistered client: %s \n", (const void *)str, (const void *)gw_addr);
                        }

                        debug_output((signed char)0, "Either enable NAT on the client or make sure this host has a route back to the sender address.\n");
                        gw_client->nat_warn = gw_client->nat_warn + 1;
                      }

                      return_value_write_13=write(tun_fd, (const void *)(buff + (signed long int)1), (unsigned long int)(buff_len - 1));
                      if(!(return_value_write_13 >= 0l))
                      {
                        return_value___errno_location_11=__errno_location();
                        return_value_strerror_12=strerror(*return_value___errno_location_11);
                        debug_output((signed char)0, "Error - can't write packet into tun: %s\n", return_value_strerror_12);
                      }

                      break;
                    }
                    case 0x04:
                    {
                      return_value_hash_find_14=hash_find(wip_hash, (void *)&addr.sin_addr.s_addr);
                      gw_client = (struct gw_client *)return_value_hash_find_14;
                      buff[(signed long int)0] = (unsigned char)0x03;
                      if(!(gw_client == ((struct gw_client *)NULL)))
                      {
                        gw_client->last_keep_alive = current_time;
                        buff[(signed long int)0] = (unsigned char)0x05;
                      }

                      addr_to_string(addr.sin_addr.s_addr, str, (signed int)sizeof(char [16l]) /*16ul*/ );
                      return_value_sendto_17=sendto(batman_if->udp_tunnel_sock, (const void *)buff, (unsigned long int)100, 0, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
                      if(!(return_value_sendto_17 >= 0l))
                      {
                        signed int *return_value___errno_location_15;
                        return_value___errno_location_15=__errno_location();
                        char *return_value_strerror_16;
                        return_value_strerror_16=strerror(*return_value___errno_location_15);
                        debug_output((signed char)0, "Error - can't send %s to client (%s): %s \n", (signed int)buff[(signed long int)0] == 0x05 ? "keep alive reply" : "invalid ip information", (const void *)str, return_value_strerror_16);
                        break;
                      }

                      debug_output((signed char)3, "Gateway - send %s to client: %s \n", (signed int)buff[(signed long int)0] == 0x05 ? "keep alive reply" : "invalid ip information", (const void *)str);
                      break;
                    }
                    case 0x02:
                    {
                      gw_client=get_ip_addr(&addr, &wip_hash, &vip_hash, &free_ip_list, next_free_ip);
                      memcpy((void *)(buff + (signed long int)1), (const void *)(char *)&gw_client->vip_addr, (unsigned long int)4);
                      return_value_sendto_20=sendto(batman_if->udp_tunnel_sock, (const void *)buff, (unsigned long int)100, 0, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
                      if(!(return_value_sendto_20 >= 0l))
                      {
                        addr_to_string(addr.sin_addr.s_addr, str, (signed int)sizeof(char [16l]) /*16ul*/ );
                        signed int *return_value___errno_location_18;
                        return_value___errno_location_18=__errno_location();
                        char *return_value_strerror_19;
                        return_value_strerror_19=strerror(*return_value___errno_location_18);
                        debug_output((signed char)0, "Error - can't send requested ip to client (%s): %s \n", (const void *)str, return_value_strerror_19);
                        break;
                      }

                      addr_to_string(gw_client->vip_addr, str, (signed int)sizeof(char [16l]) /*16ul*/ );
                      addr_to_string(addr.sin_addr.s_addr, gw_addr, (signed int)sizeof(char [16l]) /*16ul*/ );
                      debug_output((signed char)3, "Gateway - assigned %s to client: %s \n", (const void *)str, (const void *)gw_addr);
                    }
                  }
              }
              while((_Bool)1);
              signed int *return_value___errno_location_23;
              return_value___errno_location_23=__errno_location();
              if(!(*return_value___errno_location_23 == 11))
              {
                signed int *return_value___errno_location_21;
                return_value___errno_location_21=__errno_location();
                char *return_value_strerror_22;
                return_value_strerror_22=strerror(*return_value___errno_location_21);
                debug_output((signed char)0, "Error - gateway can't receive packet: %s\n", return_value_strerror_22);
                break;
              }

            }

            else
              if(!((tmp_wait_sockets.fds_bits[(signed long int)(tun_fd / 8)] & (signed long int)(1UL << tun_fd % 8)) == 0l))
              {
                do
                {
                  return_value_read_24=read(tun_fd, (void *)(buff + (signed long int)1), sizeof(unsigned char [1501l]) /*1501ul*/  - (unsigned long int)2);
                  buff_len = (signed int)return_value_read_24;
                  if(!(buff_len >= 1))
                    break;

                  void *return_value_hash_find_25;
                  return_value_hash_find_25=hash_find(vip_hash, (void *)(buff + (signed long int)13));
                  gw_client = (struct gw_client *)return_value_hash_find_25;
                  if(!(gw_client == ((struct gw_client *)NULL)))
                  {
                    client_addr.sin_addr.s_addr = gw_client->wip_addr;
                    client_addr.sin_port = gw_client->client_port;
                    buff[(signed long int)0] = (unsigned char)0x01;
                    signed long int return_value_sendto_28;
                    return_value_sendto_28=sendto(batman_if->udp_tunnel_sock, (const void *)buff, (unsigned long int)(buff_len + 1), 0, (struct sockaddr *)&client_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
                    if(!(return_value_sendto_28 >= 0l))
                    {
                      return_value___errno_location_26=__errno_location();
                      return_value_strerror_27=strerror(*return_value___errno_location_26);
                      debug_output((signed char)0, "Error - can't send data to client (%s): %s \n", (const void *)str, return_value_strerror_27);
                    }

                  }

                  else
                  {
                    addr_to_string(*((unsigned int *)(buff + (signed long int)17)), gw_addr, (signed int)sizeof(char [16l]) /*16ul*/ );
                    debug_output((signed char)3, "Gateway - could not resolve packet: %s \n", (const void *)gw_addr);
                  }
                }
                while((_Bool)1);
                signed int *return_value___errno_location_31;
                return_value___errno_location_31=__errno_location();
                if(!(*return_value___errno_location_31 == 11))
                {
                  signed int *return_value___errno_location_29;
                  return_value___errno_location_29=__errno_location();
                  char *return_value_strerror_30;
                  return_value_strerror_30=strerror(*return_value___errno_location_29);
                  debug_output((signed char)0, "Error - gateway can't read tun data: %s\n", return_value_strerror_30);
                  break;
                }

              }

          }


        after_incoming_packet:
          ;
          if((signed int)current_time + -(60000 + (signed int)client_timeout) >= 1)
          {
            client_timeout = current_time;
            hashit = (struct hash_it_t *)(void *)0;
            do
            {
              hashit=hash_iterate(wip_hash, hashit);
              if(hashit == ((struct hash_it_t *)NULL))
                break;

              gw_client = (struct gw_client *)hashit->bucket->data;
              if((signed int)current_time + -(1260000 + (signed int)gw_client->last_keep_alive) >= 1)
              {
                hash_remove_bucket(wip_hash, hashit);
                hash_remove(vip_hash, (void *)gw_client);
                void *return_value_debugMalloc_32;
                return_value_debugMalloc_32=debugMalloc((unsigned int)sizeof(struct neigh_node) /*56ul*/ , 210);
                free_ip = (struct free_ip *)return_value_debugMalloc_32;
                do
                  (&free_ip->list)->next = &free_ip->list;
                while((_Bool)0);
                free_ip->addr = gw_client->vip_addr;
                list_add_tail(&free_ip->list, &free_ip_list);
                debugFree((void *)gw_client, 1216);
              }

            }
            while((_Bool)1);
          }

        }
        while((_Bool)1);
        my_tun_ip[(signed long int)3] = (unsigned char)0;
        add_del_route(*((unsigned int *)my_tun_ip), (unsigned char)16, (unsigned int)0, (unsigned int)0, tun_ifi, tun_dev, (unsigned char)254, (signed char)0, (signed char)1);
        del_dev_tun(tun_fd);
        hashit = (struct hash_it_t *)(void *)0;
        do
        {
          hashit=hash_iterate(wip_hash, hashit);
          if(hashit == ((struct hash_it_t *)NULL))
            break;

          gw_client = (struct gw_client *)hashit->bucket->data;
          hash_remove_bucket(wip_hash, hashit);
          hash_remove(vip_hash, (void *)gw_client);
          debugFree((void *)gw_client, 1217);
        }
        while((_Bool)1);
        hash_destroy(wip_hash);
        hash_destroy(vip_hash);
        list_pos = (&free_ip_list)->next;
        list_pos_tmp = list_pos->next;
        for( ; !(list_pos == (struct list_head *)&free_ip_list); list_pos_tmp = list_pos->next)
        {
          free_ip = (struct free_ip *)((char *)list_pos - (signed long int)(unsigned long int)&((struct free_ip *)0)->list);
          list_del((struct list_head *)&free_ip_list, list_pos, &free_ip_list);
          debugFree((void *)free_ip, 1218);
          list_pos = list_pos_tmp;
        }
        return (void *)0;
      }
    }
  }
}

// handler
// file posix/../os.h line 42
void handler(signed int sig)
{
  stop = (signed char)1;
}

// hash_add
// file hash.h line 74
signed int hash_add(struct hashtable_t *hash, void *data)
{
  signed int ret;
  struct element_t *bucket;
  void *return_value_debugMalloc_1;
  return_value_debugMalloc_1=debugMalloc((unsigned int)sizeof(struct element_t) /*16ul*/ , 304);
  bucket = (struct element_t *)return_value_debugMalloc_1;
  if(bucket == ((struct element_t *)NULL))
    return -1;

  else
  {
    ret=hash_add_bucket(hash, data, bucket, 1);
    if(!(ret >= 0))
      debugFree((void *)bucket, 1307);

    return ret;
  }
}

// hash_add_bucket
// file hash.c line 67
static signed int hash_add_bucket(struct hashtable_t *hash, void *data, struct element_t *bucket, signed int check_duplicate)
{
  signed int index;
  struct element_t *bucket_it;
  struct element_t *prev_bucket = (struct element_t *)(void *)0;
  index=hash->choose(data, hash->size);
  bucket_it = hash->table[(signed long int)index];
  signed int return_value;
  if(!(bucket_it == ((struct element_t *)NULL)))
  {
    if(!(check_duplicate == 0))
    {
      return_value=hash->compare(bucket_it->data, data);
      if(!(return_value == 0))
        return -1;

    }

    prev_bucket = bucket_it;
    bucket_it = bucket_it->next;
  }

  bucket->data = data;
  bucket->next = (struct element_t *)(void *)0;
  if(prev_bucket == ((struct element_t *)NULL))
    hash->table[(signed long int)index] = bucket;

  else
    prev_bucket->next = bucket;
  hash->elements = hash->elements + 1;
  return 0;
}

// hash_delete
// file hash.c line 41
void hash_delete(struct hashtable_t *hash, void (*free_cb)(void *))
{
  struct element_t *bucket;
  struct element_t *last_bucket;
  signed int i = 0;
  for( ; !(i >= hash->size); i = i + 1)
  {
    bucket = hash->table[(signed long int)i];
    while(!(bucket == ((struct element_t *)NULL)))
    {
      if(!(free_cb == ((void (*)(void *))NULL)))
        free_cb(bucket->data);

      last_bucket = bucket;
      bucket = bucket->next;
      debugFree((void *)last_bucket, 1301);
    }
  }
  hash_destroy(hash);
}

// hash_destroy
// file hash.h line 71
void hash_destroy(struct hashtable_t *hash)
{
  debugFree((void *)hash->table, 1302);
  debugFree((void *)hash, 1303);
}

// hash_find
// file hash.h line 83
void * hash_find(struct hashtable_t *hash, void *keydata)
{
  signed int index;
  struct element_t *bucket;
  index=hash->choose(keydata, hash->size);
  bucket = hash->table[(signed long int)index];
  if(!(bucket == ((struct element_t *)NULL)))
  {
    signed int return_value;
    return_value=hash->compare(bucket->data, keydata);
    if(!(return_value == 0))
      return bucket->data;

    bucket = bucket->next;
  }

  return (void *)0;
}

// hash_init
// file hash.c line 29
void hash_init(struct hashtable_t *hash)
{
  signed int i;
  hash->elements = 0;
  i = 0;
  for( ; !(i >= hash->size); i = i + 1)
    hash->table[(signed long int)i] = (struct element_t *)(void *)0;
}

// hash_iterate
// file hash.h line 93
struct hash_it_t * hash_iterate(struct hashtable_t *hash, struct hash_it_t *iter_in)
{
  struct hash_it_t *iter;
  if(iter_in == ((struct hash_it_t *)NULL))
  {
    void *return_value_debugMalloc_1;
    return_value_debugMalloc_1=debugMalloc((unsigned int)sizeof(struct hash_it_t) /*32ul*/ , 301);
    iter = (struct hash_it_t *)return_value_debugMalloc_1;
    iter->index = -1;
    iter->bucket = (struct element_t *)(void *)0;
    iter->prev_bucket = (struct element_t *)(void *)0;
  }

  else
    iter = iter_in;
  if(!(iter->bucket == ((struct element_t *)NULL)))
  {
    if(!(iter->first_bucket == ((struct element_t **)NULL)))
    {
      if(!(*iter->first_bucket == iter->bucket))
      {
        if(!(*iter->first_bucket == ((struct element_t *)NULL)))
        {
          iter->prev_bucket = (struct element_t *)(void *)0;
          iter->bucket = *iter->first_bucket;
          iter->first_bucket = &hash->table[(signed long int)iter->index];
          return iter;
        }

        else
          iter->bucket = (struct element_t *)(void *)0;
      }

    }

    else
      if(!(iter->prev_bucket == ((struct element_t *)NULL)))
      {
        if(!(iter->prev_bucket->next == iter->bucket))
          iter->bucket = iter->prev_bucket;

      }

  }

  if(!(iter->bucket == ((struct element_t *)NULL)))
  {
    if(iter->bucket->next == ((struct element_t *)NULL))
      goto __CPROVER_DUMP_L7;

    iter->prev_bucket = iter->bucket;
    iter->bucket = iter->bucket->next;
    iter->first_bucket = (struct element_t **)(void *)0;
    return iter;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    iter->index = iter->index + 1;
    while(!(iter->index >= hash->size))
      if(!(hash->table[(signed long int)iter->index] == ((struct element_t *)NULL)))
      {
        iter->prev_bucket = (struct element_t *)(void *)0;
        iter->bucket = hash->table[(signed long int)iter->index];
        iter->first_bucket = &hash->table[(signed long int)iter->index];
        return iter;
      }

      else
        iter->index = iter->index + 1;
    debugFree((void *)iter, 1304);
    return (struct hash_it_t *)(void *)0;
  }
}

// hash_new
// file hash.h line 58
struct hashtable_t * hash_new(signed int size, signed int (*compare)(void *, void *), signed int (*choose)(void *, signed int))
{
  struct hashtable_t *hash;
  void *return_value_debugMalloc_1;
  return_value_debugMalloc_1=debugMalloc((unsigned int)sizeof(struct hashtable_t) /*32ul*/ , 302);
  hash = (struct hashtable_t *)return_value_debugMalloc_1;
  if(hash == ((struct hashtable_t *)NULL))
    return (struct hashtable_t *)(void *)0;

  else
  {
    hash->size = size;
    void *return_value_debugMalloc_2;
    return_value_debugMalloc_2=debugMalloc((unsigned int)(sizeof(struct element_t *) /*8ul*/  * (unsigned long int)size), 303);
    hash->table = (struct element_t **)return_value_debugMalloc_2;
    if(hash->table == ((struct element_t **)NULL))
    {
      debugFree((void *)hash, 1305);
      return (struct hashtable_t *)(void *)0;
    }

    else
    {
      hash_init(hash);
      hash->compare = compare;
      hash->choose = choose;
      return hash;
    }
  }
}

// hash_remove
// file hash.c line 262
void * hash_remove(struct hashtable_t *hash, void *data)
{
  struct hash_it_t hash_it_t;
  hash_it_t.index=hash->choose(data, hash->size);
  hash_it_t.bucket = hash->table[(signed long int)hash_it_t.index];
  hash_it_t.prev_bucket = (struct element_t *)(void *)0;
  struct element_t **tmp_if_expr_1;
  if(!(hash_it_t.bucket == ((struct element_t *)NULL)))
  {
    signed int return_value;
    return_value=hash->compare(hash_it_t.bucket->data, data);
    if(!(return_value == 0))
    {
      if(hash_it_t.bucket == hash->table[(signed long int)hash_it_t.index])
        tmp_if_expr_1 = &hash->table[(signed long int)hash_it_t.index];

      else
        tmp_if_expr_1 = (struct element_t **)(void *)0;
      hash_it_t.first_bucket = tmp_if_expr_1;
      void *return_value_hash_remove_bucket_2;
      return_value_hash_remove_bucket_2=hash_remove_bucket(hash, &hash_it_t);
      return return_value_hash_remove_bucket_2;
    }

    hash_it_t.prev_bucket = hash_it_t.bucket;
    hash_it_t.bucket = hash_it_t.bucket->next;
  }

  return (void *)0;
}

// hash_remove_bucket
// file hash.h line 63
void * hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t)
{
  void *data_save = hash_it_t->bucket->data;
  if(!(hash_it_t->prev_bucket == ((struct element_t *)NULL)))
    hash_it_t->prev_bucket->next = hash_it_t->bucket->next;

  else
    if(!(hash_it_t->first_bucket == ((struct element_t **)NULL)))
      *hash_it_t->first_bucket = hash_it_t->bucket->next;

  debugFree((void *)hash_it_t->bucket, 1306);
  hash->elements = hash->elements - 1;
  return data_save;
}

// hash_resize
// file hash.h line 86
struct hashtable_t * hash_resize(struct hashtable_t *hash, signed int size)
{
  struct hashtable_t *new_hash;
  struct element_t *bucket;
  signed int i;
  new_hash=hash_new(size, hash->compare, hash->choose);
  if(new_hash == ((struct hashtable_t *)NULL))
    return (struct hashtable_t *)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= hash->size); i = i + 1)
      while(!(hash->table[(signed long int)i] == ((struct element_t *)NULL)))
      {
        bucket = hash->table[(signed long int)i];
        hash->table[(signed long int)i] = bucket->next;
        hash_add_bucket(new_hash, bucket->data, bucket, 0);
      }
    hash_delete(hash, (void (*)(void *))(void *)0);
    return new_hash;
  }
}

// hna_buff_delete
// file hna.c line 472
static signed int hna_buff_delete(struct hna_element *buf, signed int *buf_len, struct hna_element *e)
{
  signed int i;
  signed int num_elements;
  if(buf == ((struct hna_element *)NULL))
    return 0;

  else
  {
    num_elements = (signed int)((unsigned long int)*buf_len / sizeof(struct hna_element) /*5ul*/ );
    i = 0;
    for( ; !(i >= num_elements); i = i + 1)
    {
      signed int return_value_memcmp_1;
      return_value_memcmp_1=memcmp((const void *)&buf[(signed long int)i], (const void *)e, sizeof(struct hna_element) /*5ul*/ );
      if(return_value_memcmp_1 == 0)
      {
        memmove((void *)&buf[(signed long int)i], (const void *)&buf[(signed long int)(num_elements - 1)], sizeof(struct hna_element) /*5ul*/ );
        *buf_len = *buf_len - (signed int)sizeof(struct hna_element) /*5ul*/ ;
        return 1;
      }

    }
    return 0;
  }
}

// hna_free
// file hna.c line 749
void hna_free(void)
{
  struct list_head *list_pos;
  struct list_head *list_pos_tmp;
  struct hna_local_entry *hna_local_entry;
  list_pos = (&hna_list)->next;
  list_pos_tmp = list_pos->next;
  for( ; !(list_pos == (struct list_head *)&hna_list); list_pos_tmp = list_pos->next)
  {
    hna_local_entry = (struct hna_local_entry *)((char *)list_pos - (signed long int)(unsigned long int)&((struct hna_local_entry *)0)->list);
    hna_local_update_routes(hna_local_entry, (signed char)1);
    debugFree((void *)hna_local_entry, 1705);
    list_pos = list_pos_tmp;
  }
  if(!(hna_buff_local == ((unsigned char *)NULL)))
    debugFree((void *)hna_buff_local, 1706);

  num_hna_local = (unsigned char)0;
  hna_buff_local = (unsigned char *)(void *)0;
  if(!(hna_global_hash == ((struct hashtable_t *)NULL)))
    hash_delete(hna_global_hash, _hna_global_hash_del);

}

// hna_global_add
// file hna.h line 80
void hna_global_add(struct orig_node *orig_node, unsigned char *new_hna, signed short int new_hna_len)
{
  struct hna_element *e;
  struct hna_element *buff;
  signed int i;
  signed int num_elements;
  char hna_str[16l];
  _Bool tmp_if_expr_2;
  if(new_hna == ((unsigned char *)NULL) || (signed int)new_hna_len == 0)
  {
    orig_node->hna_buff = (unsigned char *)(void *)0;
    orig_node->hna_buff_len = (signed short int)0;
  }

  else
  {
    void *return_value_debugMalloc_1;
    return_value_debugMalloc_1=debugMalloc((unsigned int)new_hna_len, 705);
    orig_node->hna_buff = (unsigned char *)return_value_debugMalloc_1;
    orig_node->hna_buff_len = new_hna_len;
    memcpy((void *)orig_node->hna_buff, (const void *)new_hna, (unsigned long int)new_hna_len);
    num_elements = (signed int)((unsigned long int)orig_node->hna_buff_len / sizeof(struct hna_element) /*5ul*/ );
    buff = (struct hna_element *)orig_node->hna_buff;
    debug_output((signed char)4, "HNA information received (%i HNA network%s): \n", num_elements, num_elements > 1 ? "s" : "");
    i = 0;
    for( ; !(i >= num_elements); i = i + 1)
    {
      e = &buff[(signed long int)i];
      addr_to_string(e->addr, hna_str, (signed int)sizeof(char [16l]) /*16ul*/ );
      if((signed int)e->netmask >= 1)
        tmp_if_expr_2 = (signed int)e->netmask < 33 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        debug_output((signed char)4, "hna: %s/%i\n", (const void *)hna_str, e->netmask);

      else
        debug_output((signed char)4, "hna: %s/%i -> ignoring (invalid netmask) \n", (const void *)hna_str, e->netmask);
      if((signed int)e->netmask >= 1)
      {
        if(!((signed int)e->netmask >= 33))
          _hna_global_add(orig_node, e);

      }

    }
  }
}

// hna_global_check_tq
// file hna.h line 83
void hna_global_check_tq(struct orig_node *orig_node)
{
  struct hna_element *e;
  struct hna_element *buff;
  struct hna_global_entry *hna_global_entry;
  signed int i;
  signed int num_elements;
  _Bool tmp_if_expr_1;
  if(orig_node->hna_buff == ((unsigned char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)orig_node->hna_buff_len == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
  {
    num_elements = (signed int)((unsigned long int)orig_node->hna_buff_len / sizeof(struct hna_element) /*5ul*/ );
    buff = (struct hna_element *)orig_node->hna_buff;
    i = 0;
    for( ; !(i >= num_elements); i = i + 1)
    {
      e = &buff[(signed long int)i];
      if(!((signed int)e->netmask >= 1))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)e->netmask > 32 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_2)
      {
        void *return_value_hash_find_3;
        return_value_hash_find_3=hash_find(hna_global_hash, (void *)e);
        hna_global_entry = (struct hna_global_entry *)return_value_hash_find_3;
        if(!(hna_global_entry == ((struct hna_global_entry *)NULL)))
        {
          if(!(hna_global_entry->curr_orig_node == orig_node))
          {
            if((signed int)orig_node->router->tq_avg >= (signed int)hna_global_entry->curr_orig_node->router->tq_avg)
            {
              if(!(hna_global_entry->curr_orig_node->router->addr == orig_node->router->addr))
              {
                add_del_route(e->addr, e->netmask, orig_node->router->addr, orig_node->router->if_incoming->addr.sin_addr.s_addr, orig_node->router->if_incoming->if_index, orig_node->router->if_incoming->dev, (unsigned char)65, (signed char)0, (signed char)0);
                add_del_route(e->addr, e->netmask, hna_global_entry->curr_orig_node->router->addr, hna_global_entry->curr_orig_node->router->if_incoming->addr.sin_addr.s_addr, hna_global_entry->curr_orig_node->router->if_incoming->if_index, hna_global_entry->curr_orig_node->router->if_incoming->dev, (unsigned char)65, (signed char)0, (signed char)1);
              }


            set_orig_node:
              ;
              hna_global_entry->curr_orig_node = orig_node;
            }

          }

        }

      }

    }
  }

}

// hna_global_del
// file hna.h line 84
void hna_global_del(struct orig_node *orig_node)
{
  struct hna_element *e;
  struct hna_element *buff;
  signed int i;
  signed int num_elements;
  _Bool tmp_if_expr_1;
  if(orig_node->hna_buff == ((unsigned char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)orig_node->hna_buff_len == 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    num_elements = (signed int)((unsigned long int)orig_node->hna_buff_len / sizeof(struct hna_element) /*5ul*/ );
    buff = (struct hna_element *)orig_node->hna_buff;
    i = 0;
    for( ; !(i >= num_elements); i = i + 1)
    {
      e = &buff[(signed long int)i];
      if((signed int)e->netmask >= 1)
      {
        if(!((signed int)e->netmask >= 33))
          _hna_global_del(orig_node, e);

      }

    }
    debugFree((void *)orig_node->hna_buff, 1709);
    orig_node->hna_buff = (unsigned char *)(void *)0;
    orig_node->hna_buff_len = (signed short int)0;
  }

}

// hna_global_update
// file hna.h line 81
void hna_global_update(struct orig_node *orig_node, unsigned char *new_hna, signed short int new_hna_len, struct neigh_node *old_router)
{
  struct hna_element *e;
  struct hna_element *buff;
  struct hna_global_entry *hna_global_entry;
  signed int i;
  signed int num_elements;
  signed int old_hna_len;
  unsigned char *old_hna;
  _Bool tmp_if_expr_1;
  signed int return_value_memcmp_3;
  if(!(orig_node->hna_buff == ((unsigned char *)NULL)))
  {
    if(!(new_hna == ((unsigned char *)NULL)) && !((signed int)new_hna_len == 0))
      goto __CPROVER_DUMP_L1;

    hna_global_del(orig_node);
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(orig_node->hna_buff == ((unsigned char *)NULL))
    {
      if(new_hna == ((unsigned char *)NULL) && (signed int)new_hna_len == 0)
        goto __CPROVER_DUMP_L2;

      hna_global_add(orig_node, new_hna, new_hna_len);
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!(old_router == orig_node->router))
      {
        num_elements = (signed int)((unsigned long int)orig_node->hna_buff_len / sizeof(struct hna_element) /*5ul*/ );
        buff = (struct hna_element *)orig_node->hna_buff;
        i = 0;
        for( ; !(i >= num_elements); i = i + 1)
        {
          e = &buff[(signed long int)i];
          if(!((signed int)e->netmask >= 1))
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = (signed int)e->netmask > 32 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr_1)
          {
            void *return_value_hash_find_2;
            return_value_hash_find_2=hash_find(hna_global_hash, (void *)e);
            hna_global_entry = (struct hna_global_entry *)return_value_hash_find_2;
            if(!(hna_global_entry == ((struct hna_global_entry *)NULL)))
            {
              if(hna_global_entry->curr_orig_node == orig_node)
              {
                add_del_route(e->addr, e->netmask, orig_node->router->addr, orig_node->router->if_incoming->addr.sin_addr.s_addr, orig_node->router->if_incoming->if_index, orig_node->router->if_incoming->dev, (unsigned char)65, (signed char)0, (signed char)0);
                add_del_route(e->addr, e->netmask, old_router->addr, old_router->if_incoming->addr.sin_addr.s_addr, old_router->if_incoming->if_index, old_router->if_incoming->dev, (unsigned char)65, (signed char)0, (signed char)1);
              }

            }

          }

        }
      }

      else
        if(orig_node->hna_buff_len == new_hna_len)
        {
          return_value_memcmp_3=memcmp((const void *)orig_node->hna_buff, (const void *)new_hna, (unsigned long int)new_hna_len);
          if(!(return_value_memcmp_3 == 0))
            goto __CPROVER_DUMP_L11;

        }

        else
        {

        __CPROVER_DUMP_L11:
          ;
          old_hna = orig_node->hna_buff;
          old_hna_len = (signed int)orig_node->hna_buff_len;
          void *return_value_debugMalloc_4;
          return_value_debugMalloc_4=debugMalloc((unsigned int)new_hna_len, 706);
          orig_node->hna_buff = (unsigned char *)return_value_debugMalloc_4;
          orig_node->hna_buff_len = new_hna_len;
          memcpy((void *)orig_node->hna_buff, (const void *)new_hna, (unsigned long int)new_hna_len);
          num_elements = (signed int)((unsigned long int)orig_node->hna_buff_len / sizeof(struct hna_element) /*5ul*/ );
          buff = (struct hna_element *)orig_node->hna_buff;
          i = 0;
          for( ; !(i >= num_elements); i = i + 1)
          {
            e = &buff[(signed long int)i];
            signed int return_value_hna_buff_delete_5;
            return_value_hna_buff_delete_5=hna_buff_delete((struct hna_element *)old_hna, &old_hna_len, e);
            if(return_value_hna_buff_delete_5 == 0)
            {
              if((signed int)e->netmask >= 1)
              {
                if(!((signed int)e->netmask >= 33))
                  _hna_global_add(orig_node, e);

              }

            }

          }
          num_elements = (signed int)((unsigned long int)old_hna_len / sizeof(struct hna_element) /*5ul*/ );
          buff = (struct hna_element *)old_hna;
          i = 0;
          for( ; !(i >= num_elements); i = i + 1)
          {
            e = &buff[(signed long int)i];
            if((signed int)e->netmask >= 1)
            {
              if(!((signed int)e->netmask >= 33))
                _hna_global_del(orig_node, e);

            }

          }
          if(!(old_hna == ((unsigned char *)NULL)))
            debugFree((void *)old_hna, 1704);

        }
    }
  }
}

// hna_init
// file hna.c line 66
void hna_init(void)
{
  hna_list.next = (struct list_head *)&hna_list;
  hna_list.prev = (struct list_head *)&hna_list;
  hna_chg_list.next = (struct list_head *)&hna_chg_list;
  hna_chg_list.prev = (struct list_head *)&hna_chg_list;
  pthread_mutex_init(&hna_chg_list_mutex, (const union anonymous *)(void *)0);
  hna_global_hash=hash_new(128, compare_hna, choose_hna);
  if(hna_global_hash == ((struct hashtable_t *)NULL))
  {
    printf("Error - Could not create hna_global_hash (out of memory?)\n");
    exit(1);
  }

}

// hna_local_buffer_fill
// file hna.c line 171
static void hna_local_buffer_fill(void)
{
  struct list_head *list_pos;
  struct hna_local_entry *hna_local_entry;
  if(!(hna_buff_local == ((unsigned char *)NULL)))
    debugFree((void *)hna_buff_local, 1701);

  num_hna_local = (unsigned char)0;
  hna_buff_local = (unsigned char *)(void *)0;
  signed int return_value_list_empty_1;
  return_value_list_empty_1=list_empty(&hna_list);
  if(return_value_list_empty_1 == 0)
  {
    list_pos = (&hna_list)->next;
    for( ; !(list_pos == (struct list_head *)&hna_list); list_pos = list_pos->next)
    {
      hna_local_entry = (struct hna_local_entry *)((char *)list_pos - (signed long int)(unsigned long int)&((struct hna_local_entry *)0)->list);
      void *return_value_debugRealloc_2;
      return_value_debugRealloc_2=debugRealloc((void *)hna_buff_local, (unsigned int)((unsigned long int)(((signed int)num_hna_local + 1) * 5) * sizeof(unsigned char) /*1ul*/ ), 15);
      hna_buff_local = (unsigned char *)return_value_debugRealloc_2;
      memmove((void *)&hna_buff_local[(signed long int)((signed int)num_hna_local * 5)], (const void *)(unsigned char *)&hna_local_entry->addr, (unsigned long int)4);
      hna_buff_local[(signed long int)((signed int)num_hna_local * 5 + 4)] = (unsigned char)hna_local_entry->netmask;
      num_hna_local = num_hna_local + 1;
    }
  }

}

// hna_local_task_add_ip
// file hna.c line 84
void hna_local_task_add_ip(unsigned int ip_addr, unsigned short int netmask, unsigned char route_action)
{
  struct hna_task *hna_task;
  void *return_value_debugMalloc_1;
  return_value_debugMalloc_1=debugMalloc((unsigned int)sizeof(struct hna_task) /*16ul*/ , 701);
  hna_task = (struct hna_task *)return_value_debugMalloc_1;
  memset((void *)hna_task, 0, sizeof(struct hna_task) /*16ul*/ );
  do
    (&hna_task->list)->next = &hna_task->list;
  while((_Bool)0);
  hna_task->addr = ip_addr;
  hna_task->netmask = (unsigned char)netmask;
  hna_task->route_action = route_action;
  signed int return_value_pthread_mutex_lock_4;
  return_value_pthread_mutex_lock_4=pthread_mutex_lock(&hna_chg_list_mutex);
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  if(!(return_value_pthread_mutex_lock_4 == 0))
  {
    return_value___errno_location_2=__errno_location();
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    debug_output((signed char)0, "Error - could not lock hna_chg_list mutex in %s(): %s \n", (const void *)"hna_local_task_add_ip", return_value_strerror_3);
  }

  list_add_tail(&hna_task->list, &hna_chg_list);
  signed int return_value_pthread_mutex_unlock_7;
  return_value_pthread_mutex_unlock_7=pthread_mutex_unlock(&hna_chg_list_mutex);
  signed int *return_value___errno_location_5;
  char *return_value_strerror_6;
  if(!(return_value_pthread_mutex_unlock_7 == 0))
  {
    return_value___errno_location_5=__errno_location();
    return_value_strerror_6=strerror(*return_value___errno_location_5);
    debug_output((signed char)0, "Error - could not unlock hna_chg_list mutex in %s(): %s \n", (const void *)"hna_local_task_add_ip", return_value_strerror_6);
  }

}

// hna_local_task_add_str
// file hna.c line 106
void hna_local_task_add_str(char *hna_string, unsigned char route_action, unsigned char runtime)
{
  struct in_addr tmp_ip_holder;
  unsigned short int netmask;
  char *slash_ptr;
  slash_ptr=strchr(hna_string, 47);
  if(slash_ptr == ((char *)NULL))
  {
    if(!(runtime == 0))
    {
      debug_output((signed char)3, "Invalid announced network (netmask is missing): %s\n", hna_string);
      goto __CPROVER_DUMP_L11;
    }

    printf("Invalid announced network (netmask is missing): %s\n", hna_string);
    exit(1);
  }

  *slash_ptr = (char)0;
  signed int return_value_inet_pton_1;
  return_value_inet_pton_1=inet_pton(2, hna_string, (void *)&tmp_ip_holder);
  if(!(return_value_inet_pton_1 >= 1))
  {
    *slash_ptr = (char)47;
    if(!(runtime == 0))
    {
      debug_output((signed char)3, "Invalid announced network (IP is invalid): %s\n", hna_string);
      goto __CPROVER_DUMP_L11;
    }

    printf("Invalid announced network (IP is invalid): %s\n", hna_string);
    exit(1);
  }

  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  *return_value___errno_location_2 = 0;
  signed long int return_value_strtol_3;
  return_value_strtol_3=strtol(slash_ptr + (signed long int)1, (char ** restrict )(void *)0, 10);
  netmask = (unsigned short int)return_value_strtol_3;
  signed int *return_value___errno_location_4;
  return_value___errno_location_4=__errno_location();
  _Bool tmp_if_expr_6;
  signed int *return_value___errno_location_5;
  if(*return_value___errno_location_4 == 34)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value___errno_location_5=__errno_location();
    tmp_if_expr_6 = (*return_value___errno_location_5 != 0 ? ((signed int)netmask == 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_6)
  {
    *slash_ptr = (char)47;
    if(!(runtime == 0))
      goto __CPROVER_DUMP_L11;

    perror("strtol");
    exit(1);
  }

  if((signed int)netmask >= 33 || !((signed int)netmask >= 1))
  {
    *slash_ptr = (char)47;
    if(!(runtime == 0))
    {
      debug_output((signed char)3, "Invalid announced network (netmask is invalid): %s\n", hna_string);
      goto __CPROVER_DUMP_L11;
    }

    printf("Invalid announced network (netmask is invalid): %s\n", hna_string);
    exit(1);
  }

  *slash_ptr = (char)47;
  unsigned int return_value_htonl_7;
  return_value_htonl_7=htonl(0xFFFFFFFF << 32 - (signed int)netmask);
  tmp_ip_holder.s_addr = tmp_ip_holder.s_addr & return_value_htonl_7;
  hna_local_task_add_ip(tmp_ip_holder.s_addr, netmask, route_action);

__CPROVER_DUMP_L11:
  ;
}

// hna_local_task_exec
// file hna.h line 75
void hna_local_task_exec(void)
{
  struct list_head *list_pos;
  struct list_head *list_pos_tmp;
  struct list_head *prev_list_head;
  struct list_head *hna_pos;
  struct list_head *hna_pos_tmp;
  struct hna_task *hna_task;
  struct hna_local_entry *hna_local_entry;
  char hna_addr_str[16l];
  signed int return_value_pthread_mutex_trylock_1;
  return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&hna_chg_list_mutex);
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  if(return_value_pthread_mutex_trylock_1 == 0)
  {
    signed int return_value_list_empty_2;
    return_value_list_empty_2=list_empty(&hna_chg_list);
    if(return_value_list_empty_2 == 0)
    {
      list_pos = (&hna_chg_list)->next;
      list_pos_tmp = list_pos->next;
      for( ; !(list_pos == (struct list_head *)&hna_chg_list); list_pos_tmp = list_pos->next)
      {
        hna_task = (struct hna_task *)((char *)list_pos - (signed long int)(unsigned long int)&((struct hna_task *)0)->list);
        addr_to_string(hna_task->addr, hna_addr_str, (signed int)sizeof(char [16l]) /*16ul*/ );
        hna_local_entry = (struct hna_local_entry *)(void *)0;
        prev_list_head = (struct list_head *)&hna_list;
        hna_pos = (&hna_list)->next;
        hna_pos_tmp = hna_pos->next;
        for( ; !(hna_pos == (struct list_head *)&hna_list); hna_pos_tmp = hna_pos->next)
        {
          hna_local_entry = (struct hna_local_entry *)((char *)hna_pos - (signed long int)(unsigned long int)&((struct hna_local_entry *)0)->list);
          if(hna_task->addr == hna_local_entry->addr)
          {
            if(hna_task->netmask == hna_local_entry->netmask)
            {
              if((signed int)hna_task->route_action == 1)
              {
                debug_output((signed char)3, "Deleting HNA from announce network list: %s/%i\n", (const void *)hna_addr_str, hna_task->netmask);
                hna_local_update_routes(hna_local_entry, (signed char)1);
                list_del(prev_list_head, hna_pos, &hna_list);
                debugFree((void *)hna_local_entry, 1702);
              }

              else
                debug_output((signed char)3, "Can't add HNA - already announcing network: %s/%i\n", (const void *)hna_addr_str, hna_task->netmask);
              break;
            }

          }

          prev_list_head = &hna_local_entry->list;
          hna_local_entry = (struct hna_local_entry *)(void *)0;
          hna_pos = hna_pos_tmp;
        }
        if(hna_local_entry == ((struct hna_local_entry *)NULL))
        {
          if((signed int)hna_task->route_action == 0)
          {
            debug_output((signed char)3, "Adding HNA to announce network list: %s/%i\n", (const void *)hna_addr_str, hna_task->netmask);
            void *return_value_debugMalloc_3;
            return_value_debugMalloc_3=debugMalloc((unsigned int)sizeof(struct hna_local_entry) /*16ul*/ , 702);
            hna_local_entry = (struct hna_local_entry *)return_value_debugMalloc_3;
            memset((void *)hna_local_entry, 0, sizeof(struct hna_local_entry) /*16ul*/ );
            do
              (&hna_local_entry->list)->next = &hna_local_entry->list;
            while((_Bool)0);
            hna_local_entry->addr = hna_task->addr;
            hna_local_entry->netmask = hna_task->netmask;
            hna_local_update_routes(hna_local_entry, (signed char)0);
            list_add_tail(&hna_local_entry->list, &hna_list);
          }

          else
            debug_output((signed char)3, "Can't delete HNA - network is not announced: %s/%i\n", (const void *)hna_addr_str, hna_task->netmask);
        }

        list_del((struct list_head *)&hna_chg_list, list_pos, &hna_chg_list);
        debugFree((void *)hna_task, 1703);
        list_pos = list_pos_tmp;
      }
      hna_local_buffer_fill();
    }


  unlock_chg_list:
    ;
    signed int return_value_pthread_mutex_unlock_6;
    return_value_pthread_mutex_unlock_6=pthread_mutex_unlock(&hna_chg_list_mutex);
    if(!(return_value_pthread_mutex_unlock_6 == 0))
    {
      return_value___errno_location_4=__errno_location();
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      debug_output((signed char)0, "Error - could not unlock hna_chg_list mutex in %s(): %s \n", (const void *)"hna_local_task_exec", return_value_strerror_5);
    }

  }

}

// hna_local_update_nat
// file os.h line 56
void hna_local_update_nat(unsigned int hna_ip, unsigned char netmask, signed char route_action)
{
  char cmd[100l];
  char ip_addr[16l];
  inet_ntop(2, (const void *)&hna_ip, ip_addr, (unsigned int)sizeof(char [16l]) /*16ul*/ );
  if((signed int)route_action == 1)
    sprintf(cmd, "iptables -t nat -D POSTROUTING -s %s/%i -j ACCEPT", (const void *)ip_addr, netmask);

  else
    sprintf(cmd, "iptables -t nat -I POSTROUTING -s %s/%i -j ACCEPT", (const void *)ip_addr, netmask);
  exec_iptables_rule(cmd, route_action);
}

// hna_local_update_routes
// file hna.c line 302
void hna_local_update_routes(struct hna_local_entry *hna_local_entry, signed char route_action)
{
  add_del_route(hna_local_entry->addr, hna_local_entry->netmask, (unsigned int)0, (unsigned int)0, 0, "unknown", (unsigned char)65, (signed char)1, route_action);
  add_del_route(hna_local_entry->addr, hna_local_entry->netmask, (unsigned int)0, (unsigned int)0, 0, "unknown", (unsigned char)66, (signed char)1, route_action);
  add_del_route(hna_local_entry->addr, hna_local_entry->netmask, (unsigned int)0, (unsigned int)0, 0, "unknown", (unsigned char)67, (signed char)1, route_action);
  add_del_route(hna_local_entry->addr, hna_local_entry->netmask, (unsigned int)0, (unsigned int)0, 0, "unknown", (unsigned char)68, (signed char)1, route_action);
  hna_local_update_nat(hna_local_entry->addr, hna_local_entry->netmask, route_action);
}

// hna_local_update_vis_packet
// file hna.h line 77
unsigned char * hna_local_update_vis_packet(unsigned char *vis_packet, unsigned short int *vis_packet_size)
{
  struct list_head *list_pos;
  struct hna_local_entry *hna_local_entry;
  struct vis_data *vis_data;
  if(!((signed int)num_hna_local >= 1))
    return vis_packet;

  else
  {
    list_pos = (&hna_list)->next;
    for( ; !(list_pos == (struct list_head *)&hna_list); list_pos = list_pos->next)
    {
      hna_local_entry = (struct hna_local_entry *)((char *)list_pos - (signed long int)(unsigned long int)&((struct hna_local_entry *)0)->list);
      *vis_packet_size = *vis_packet_size + (unsigned short int)sizeof(struct vis_data) /*6ul*/ ;
      void *return_value_debugRealloc_1;
      return_value_debugRealloc_1=debugRealloc((void *)vis_packet, (unsigned int)*vis_packet_size, 107);
      vis_packet = (unsigned char *)return_value_debugRealloc_1;
      vis_data = (struct vis_data *)((vis_packet + (signed long int)*vis_packet_size) - (signed long int)sizeof(struct vis_data) /*6ul*/ );
      memcpy((void *)&vis_data->ip, (const void *)(unsigned char *)&hna_local_entry->addr, (unsigned long int)4);
      vis_data->data = hna_local_entry->netmask;
      vis_data->type = (unsigned char)3;
    }
    return vis_packet;
  }
}

// init_bh_ports
// file posix/../os.h line 93
void init_bh_ports(void)
{
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
    bh_udp_ports[(signed long int)i]=htons(bh_udp_ports[(signed long int)i]);
}

// init_interface
// file posix/init.c line 1011
void init_interface(struct batman_if *batman_if)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(batman_if->dev);
  if(return_value_strlen_1 >= 16ul)
  {
    printf("Error - interface name too long: %s\n", batman_if->dev);
    restore_defaults();
    exit(1);
  }

  signed int return_value_is_interface_up_2;
  return_value_is_interface_up_2=is_interface_up(batman_if->dev);
  if(!(return_value_is_interface_up_2 == 0))
    activate_interface(batman_if);

}

// init_interface_gw
// file posix/init.c line 1060
void init_interface_gw(void)
{
  signed int sock_opts;
  signed int err;
  signed int skfd;
  struct ifreq_1 ifr;
  struct sockaddr_in sin;
  struct batgat_ioc_args ioc;
  struct batman_if *batman_if = (struct batman_if *)if_list.next;
  batman_if->udp_tunnel_sock=use_gateway_module();
  if(!(batman_if->udp_tunnel_sock >= 0))
  {
    batman_if->addr.sin_port=htons((unsigned short int)4306);
    batman_if->udp_tunnel_sock=socket(2, 2, 0);
    if(!(batman_if->udp_tunnel_sock >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      debug_output((signed char)0, "Error - can't create tunnel socket: %s\n", return_value_strerror_2);
      restore_defaults();
      exit(1);
    }

    signed int return_value_bind_5;
    return_value_bind_5=bind(batman_if->udp_tunnel_sock, (struct sockaddr *)&batman_if->addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_bind_5 >= 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      debug_output((signed char)0, "Error - can't bind tunnel socket: %s\n", return_value_strerror_4);
      restore_defaults();
      exit(1);
    }

    sock_opts=fcntl(batman_if->udp_tunnel_sock, 3, 0);
    fcntl(batman_if->udp_tunnel_sock, 4, sock_opts | 04000);
    batman_if->addr.sin_port=htons((unsigned short int)4305);
    pthread_create(&batman_if->listen_thread_id, (const union pthread_attr_t *)(void *)0, gw_listen, (void *)batman_if);
  }

  else
  {
    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(batman_if->dev);
    ioc.universal = (unsigned int)return_value_strlen_6;
    ioc.exists = (unsigned char)0;
    strncpy(ioc.dev_name, batman_if->dev, (unsigned long int)(16 - 1));
    signed int return_value_ioctl_9;
    return_value_ioctl_9=ioctl(batman_if->udp_tunnel_sock, (unsigned long int)1, &ioc);
    if(!(return_value_ioctl_9 >= 0))
    {
      signed int *return_value___errno_location_7;
      return_value___errno_location_7=__errno_location();
      char *return_value_strerror_8;
      return_value_strerror_8=strerror(*return_value___errno_location_7);
      debug_output((signed char)0, "Error - can't add device %s: %s\n", batman_if->dev, return_value_strerror_8);
      batman_if->dev = (char *)(void *)0;
      restore_defaults();
      exit(1);
    }

    skfd=socket(2, 2, 0);
    if(!(skfd >= 0))
    {
      debug_output((signed char)0, "Error - can't create socket to gate\n");
      restore_defaults();
      exit(1);
    }

    memset((void *)&ifr, 0, sizeof(struct ifreq_1) /*40ul*/ );
    memset((void *)&sin, 0, sizeof(struct sockaddr) /*16ul*/ );
    strncpy(ifr.ifr_ifrn.ifrn_name, ioc.dev_name, (unsigned long int)(16 - 1));
    sin.sin_family = (unsigned short int)2;
    sin.sin_addr.s_addr = ioc.universal;
    memcpy((void *)&ifr.ifr_ifru.ifru_addr, (const void *)&sin, sizeof(struct sockaddr) /*16ul*/ );
    err=ioctl(skfd, (unsigned long int)0x8916, &ifr);
    if(!(err >= 0))
    {
      char *return_value_strerror_10;
      return_value_strerror_10=strerror(err);
      debug_output((signed char)0, "Error - can't set IFADDR %s: %s\n", (const void *)ioc.dev_name, return_value_strerror_10);
      close(skfd);
      restore_defaults();
      exit(1);
    }

    memset((void *)&ifr, 0, sizeof(struct ifreq_1) /*40ul*/ );
    strncpy(ifr.ifr_ifrn.ifrn_name, ioc.dev_name, (unsigned long int)(16 - 1));
    signed int return_value_ioctl_13;
    return_value_ioctl_13=ioctl(skfd, (unsigned long int)0x8913, &ifr);
    if(!(return_value_ioctl_13 >= 0))
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      char *return_value_strerror_12;
      return_value_strerror_12=strerror(*return_value___errno_location_11);
      debug_output((signed char)0, "Error - can't get IFFLAGS for %s: %s\n", (const void *)ioc.dev_name, return_value_strerror_12);
      close(skfd);
      restore_defaults();
      exit(1);
    }

    strncpy(ifr.ifr_ifrn.ifrn_name, ioc.dev_name, (unsigned long int)(16 - 1));
    ifr.ifr_ifru.ifru_flags = ifr.ifr_ifru.ifru_flags | (signed short int)(1 | 64);
    signed int return_value_ioctl_16;
    return_value_ioctl_16=ioctl(skfd, (unsigned long int)0x8914, &ifr);
    if(!(return_value_ioctl_16 >= 0))
    {
      signed int *return_value___errno_location_14;
      return_value___errno_location_14=__errno_location();
      char *return_value_strerror_15;
      return_value_strerror_15=strerror(*return_value___errno_location_14);
      debug_output((signed char)0, "Error - can't set IFFLAGS for %s: %s\n", (const void *)ioc.dev_name, return_value_strerror_15);
      close(skfd);
      restore_defaults();
      exit(1);
    }

    close(skfd);
    if(ioc.exists == 0)
      add_del_route(ioc.universal, (unsigned char)16, (unsigned int)0, (unsigned int)0, (signed int)ioc.ifindex, ioc.dev_name, (unsigned char)254, (signed char)0, (signed char)0);

  }
}

// interface_listen_sockets
// file posix/init.c line 777
void interface_listen_sockets(void)
{
  struct list_head *list_pos;
  struct batman_if *batman_if;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_15) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&receive_wait_set)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  receive_max_sock = 0;
  list_pos = (&if_list)->next;
  for( ; !(list_pos == (struct list_head *)&if_list); list_pos = list_pos->next)
  {
    batman_if = (struct batman_if *)((char *)list_pos - (signed long int)(unsigned long int)&((struct batman_if *)0)->list);
    if(!(batman_if->if_active == 0))
    {
      if(!(receive_max_sock >= batman_if->udp_recv_sock))
        receive_max_sock = batman_if->udp_recv_sock;

      (&receive_wait_set)->fds_bits[(signed long int)(batman_if->udp_recv_sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&receive_wait_set)->fds_bits[(signed long int)(batman_if->udp_recv_sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << batman_if->udp_recv_sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    }

  }
}

// internal_output
// file posix/../os.h line 99
void internal_output(unsigned int sock)
{
  dprintf((signed int)sock, "source_version=%s\n", (const void *)"debian-0.3.2-17");
  dprintf((signed int)sock, "compat_version=%i\n", 5);
  dprintf((signed int)sock, "vis_compat_version=%i\n", 23);
  dprintf((signed int)sock, "ogm_port=%i\n", 4305);
  dprintf((signed int)sock, "gw_port=%i\n", 4306);
  dprintf((signed int)sock, "vis_port=%i\n", 4305 + 2);
  dprintf((signed int)sock, "unix_socket_path=%s\n", (const void *)"/var/run/batmand.socket");
  dprintf((signed int)sock, "own_ogm_jitter=%i\n", 100);
  dprintf((signed int)sock, "default_ttl=%i\n", 50);
  dprintf((signed int)sock, "originator_timeout=%u (default: %u)\n", purge_timeout, 200000u);
  dprintf((signed int)sock, "tq_local_window_size=%i\n", 64);
  dprintf((signed int)sock, "tq_global_window_size=%i\n", 10);
  dprintf((signed int)sock, "tq_local_bidirect_send_minimum=%i\n", 1);
  dprintf((signed int)sock, "tq_local_bidirect_recv_minimum=%i\n", 1);
  dprintf((signed int)sock, "tq_hop_penalty=%i (default: %i)\n", hop_penalty, 5);
  dprintf((signed int)sock, "tq_total_limit=%i\n", 1);
  dprintf((signed int)sock, "tq_max_value=%i\n", 255);
  dprintf((signed int)sock, "rt_table_networks=%i\n", 65);
  dprintf((signed int)sock, "rt_table_hosts=%i\n", 66);
  dprintf((signed int)sock, "rt_table_unreach=%i\n", 67);
  dprintf((signed int)sock, "rt_table_tunnel=%i\n", 68);
  dprintf((signed int)sock, "rt_prio_default=%i\n", 6600);
  dprintf((signed int)sock, "rt_prio_unreach=%i\n", 6600 + 100);
  dprintf((signed int)sock, "rt_prio_tunnel=%i\n", 6600 + 100 + 100);
}

// isBidirectionalNeigh
// file batman.c line 542
static signed int isBidirectionalNeigh(struct orig_node *orig_node, struct orig_node *orig_neigh_node, struct bat_packet *in, unsigned int recv_time, struct batman_if *if_incoming)
{
  struct list_head *list_pos;
  struct neigh_node *neigh_node = (struct neigh_node *)(void *)0;
  struct neigh_node *tmp_neigh_node = (struct neigh_node *)(void *)0;
  unsigned char total_count;
  char orig_str[16l];
  char neigh_str[16l];
  if(orig_node == orig_neigh_node)
  {
    list_pos = (&orig_node->neigh_list)->next;
    for( ; !(list_pos == (struct list_head *)&orig_node->neigh_list); list_pos = list_pos->next)
    {
      tmp_neigh_node = (struct neigh_node *)((char *)list_pos - (signed long int)(unsigned long int)&((struct neigh_node *)0)->list);
      if(tmp_neigh_node->addr == orig_neigh_node->orig)
      {
        if(tmp_neigh_node->if_incoming == if_incoming)
          neigh_node = tmp_neigh_node;

      }

    }
    if(neigh_node == ((struct neigh_node *)NULL))
      neigh_node=create_neighbor(orig_node, orig_neigh_node, orig_neigh_node->orig, if_incoming);

    neigh_node->last_valid = recv_time;
  }

  else
  {
    list_pos = (&orig_neigh_node->neigh_list)->next;
    for( ; !(list_pos == (struct list_head *)&orig_neigh_node->neigh_list); list_pos = list_pos->next)
    {
      tmp_neigh_node = (struct neigh_node *)((char *)list_pos - (signed long int)(unsigned long int)&((struct neigh_node *)0)->list);
      if(tmp_neigh_node->addr == orig_neigh_node->orig)
      {
        if(tmp_neigh_node->if_incoming == if_incoming)
          neigh_node = tmp_neigh_node;

      }

    }
    if(neigh_node == ((struct neigh_node *)NULL))
      neigh_node=create_neighbor(orig_neigh_node, orig_neigh_node, orig_neigh_node->orig, if_incoming);

  }
  orig_node->last_valid = recv_time;
  signed int tmp_if_expr_1;
  if(!((signed int)neigh_node->real_packet_count >= (signed int)orig_neigh_node->bcast_own_sum[(signed long int)if_incoming->if_num]))
    tmp_if_expr_1 = (signed int)neigh_node->real_packet_count;

  else
    tmp_if_expr_1 = (signed int)orig_neigh_node->bcast_own_sum[(signed long int)if_incoming->if_num];
  total_count = (unsigned char)tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!((signed int)total_count >= (signed int)minimum_send))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)neigh_node->real_packet_count < (signed int)minimum_recv ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    orig_neigh_node->tq_own = (unsigned char)0;

  else
    orig_neigh_node->tq_own = (unsigned char)((255 * (signed int)total_count) / (signed int)neigh_node->real_packet_count);
  orig_neigh_node->tq_asym_penalty = 255 - (255 * ((signed int)local_win_size - (signed int)neigh_node->real_packet_count) * ((signed int)local_win_size - (signed int)neigh_node->real_packet_count) * ((signed int)local_win_size - (signed int)neigh_node->real_packet_count)) / ((signed int)local_win_size * (signed int)local_win_size * (signed int)local_win_size);
  in->tq = (unsigned char)(((signed int)in->tq * (signed int)orig_neigh_node->tq_own * orig_neigh_node->tq_asym_penalty) / (255 * 255));
  addr_to_string(orig_node->orig, orig_str, 16);
  addr_to_string(orig_neigh_node->orig, neigh_str, 16);
  debug_output((signed char)4, "bidirectional: orig = %-15s neigh = %-15s => own_bcast = %2i, real recv = %2i, local tq: %3i, asym_penalty: %3i, total tq: %3i \n", (const void *)orig_str, (const void *)neigh_str, total_count, neigh_node->real_packet_count, orig_neigh_node->tq_own, orig_neigh_node->tq_asym_penalty, in->tq);
  if((signed int)in->tq >= 1)
    return 1;

  else
    return 0;
}

// is_aborted
// file os.h line 41
signed char is_aborted(void)
{
  return (signed char)((signed int)stop != 0);
}

// is_batman_if
// file batman.c line 200
signed int is_batman_if(char *dev, struct batman_if **batman_if)
{
  struct list_head *if_pos = (&if_list)->next;
  for( ; !(if_pos == (struct list_head *)&if_list); if_pos = if_pos->next)
  {
    *batman_if = (struct batman_if *)((char *)if_pos - (signed long int)(unsigned long int)&((struct batman_if *)0)->list);
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp((*batman_if)->dev, dev);
    if(return_value_strcmp_1 == 0)
      return 1;

  }
  return 0;
}

// is_interface_up
// file posix/init.c line 797
static signed int is_interface_up(char *dev)
{
  struct ifreq_1 int_req;
  signed int sock;
  sock=socket(2, 2, 0);
  signed int return_value_ioctl_2;
  if(!(sock >= 0))
    return 0;

  else
  {
    memset((void *)&int_req, 0, sizeof(struct ifreq_1) /*40ul*/ );
    strncpy(int_req.ifr_ifrn.ifrn_name, dev, (unsigned long int)(16 - 1));
    signed int return_value_ioctl_1;
    return_value_ioctl_1=ioctl(sock, (unsigned long int)0x8913, &int_req);
    if(return_value_ioctl_1 >= 0)
    {
      if((1 & (signed int)int_req.ifr_ifru.ifru_flags) == 0)
        goto failure;

      return_value_ioctl_2=ioctl(sock, (unsigned long int)0x8915, &int_req);
      if(!(return_value_ioctl_2 >= 0))
        goto failure;

      close(sock);
      return 1;
    }

    else
    {

    failure:
      ;
      close(sock);
      return 0;
    }
  }
}

// is_wifi_interface
// file linux/kernel.c line 185
signed int is_wifi_interface(char *dev, signed int fd)
{
  struct ifreq_0 int_req;
  char *colon_ptr;
  memset((void *)&int_req, 0, sizeof(struct ifreq_0) /*40ul*/ );
  strncpy(int_req.ifr_ifrn.ifrn_name, dev, (unsigned long int)(16 - 1));
  colon_ptr=strchr(int_req.ifr_ifrn.ifrn_name, 58);
  if(!(colon_ptr == ((char *)NULL)))
    *colon_ptr = (char)0;

  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(fd, (unsigned long int)0x8B01, &int_req);
  if(return_value_ioctl_1 >= 0)
    return 1;

  else
    return 0;
}

// list_add
// file list-batman.c line 49
void list_add(struct list_head *new, struct list_head_first *head)
{
  __list_add(new, (struct list_head *)head, head->next);
  if(head->prev == (struct list_head *)head)
    head->prev = new;

}

// list_add_before
// file list-batman.h line 56
void list_add_before(struct list_head *prev_node, struct list_head *next_node, struct list_head *new_node)
{
  prev_node->next = new_node;
  new_node->next = next_node;
}

// list_add_tail
// file list-batman.h line 55
void list_add_tail(struct list_head *new, struct list_head_first *head)
{
  __list_add(new, head->prev, (struct list_head *)head);
  head->prev = new;
}

// list_del
// file list-batman.h line 57
void list_del(struct list_head *prev_entry, struct list_head *entry, struct list_head_first *head)
{
  if(head->prev == entry)
    head->prev = prev_entry;

  __list_del(prev_entry, entry->next);
  entry->next = (struct list_head *)(void *)0;
}

// list_empty
// file list-batman.h line 58
signed int list_empty(struct list_head_first *head)
{
  return (signed int)(head->next == (struct list_head *)head);
}

// main
// file posix/posix.c line 602
signed int main(signed int argc, char **argv)
{
  signed char res;
  unsigned int return_value_getuid_1;
  return_value_getuid_1=getuid();
  _Bool tmp_if_expr_3;
  unsigned int return_value_getgid_2;
  if(!(return_value_getuid_1 == 0u))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_getgid_2=getgid();
    tmp_if_expr_3 = return_value_getgid_2 != 0u ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    fprintf(stderr, "Error - you must be root to run %s !\n", argv[(signed long int)0]);
    exit(1);
  }

  forw_list.next = (struct list_head *)&forw_list;
  forw_list.prev = (struct list_head *)&forw_list;
  gw_list.next = (struct list_head *)&gw_list;
  gw_list.prev = (struct list_head *)&gw_list;
  if_list.next = (struct list_head *)&if_list;
  if_list.prev = (struct list_head *)&if_list;
  hna_init();
  signed long int return_value_sysconf_4;
  return_value_sysconf_4=sysconf(2);
  system_tick = (float)return_value_sysconf_4;
  last_clock_tick=times_wrapper();
  update_internal_clock();
  apply_init_args(argc, argv);
  init_bh_ports();
  signed int return_value_getpid_5;
  return_value_getpid_5=getpid();
  srand((unsigned int)return_value_getpid_5);
  res=batman();
  hna_free();
  restore_defaults();
  cleanup();
  checkLeak();
  return (signed int)res;
}

// my_daemon
// file posix/init.c line 51
static signed int my_daemon(void)
{
  signed int fd;
  signed int return_value_fork_1;
  return_value_fork_1=fork();
  if(!(return_value_fork_1 == -1))
  {
    if(return_value_fork_1 == 0)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    return -1;

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L4;
  }
  exit(0);

__CPROVER_DUMP_L4:
  ;
  signed int return_value_setsid_2;
  return_value_setsid_2=setsid();
  if(return_value_setsid_2 == -1)
    return -1;

  else
  {
    signed int return_value_fork_3;
    return_value_fork_3=fork();
    if(!(return_value_fork_3 == 0))
      exit(0);

    chdir("/");
    fd=open("/dev/null", 02, 0);
    if(!(fd == -1))
    {
      dup2(fd, 0);
      dup2(fd, 1);
      dup2(fd, 2);
      if(fd >= 3)
        close(fd);

    }

    return 0;
  }
}

// print_animation
// file posix/../os.h line 83
void print_animation(void)
{
  printf("\033[2J\033[0;0f");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(0, 50);
  sym_print((char)0, (char)3, ".");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(1, 0);
  sym_print((char)0, (char)4, "v");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(0, 20);
  sym_print((char)1, (char)3, "^");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(0, 20);
  sym_print((char)1, (char)4, "/");
  sym_print((char)0, (char)5, "/");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(0, 10);
  sym_print((char)2, (char)3, "\\");
  sym_print((char)2, (char)5, "/");
  sym_print((char)0, (char)6, ")/");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(0, 10);
  sym_print((char)2, (char)3, "_\\");
  sym_print((char)4, (char)4, ")");
  sym_print((char)2, (char)5, " /");
  sym_print((char)0, (char)6, " )/");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(0, 10);
  sym_print((char)4, (char)2, "'\\");
  sym_print((char)2, (char)3, "__/ \\");
  sym_print((char)4, (char)4, "   )");
  sym_print((char)1, (char)5, "   ");
  sym_print((char)2, (char)6, "   /");
  sym_print((char)3, (char)7, "\\");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(0, 15);
  sym_print((char)6, (char)3, " \\");
  sym_print((char)3, (char)4, "_ \\   \\");
  sym_print((char)10, (char)5, "\\");
  sym_print((char)1, (char)6, "          \\");
  sym_print((char)3, (char)7, " ");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(0, 20);
  sym_print((char)7, (char)1, "____________");
  sym_print((char)7, (char)3, " _   \\");
  sym_print((char)3, (char)4, "_      ");
  sym_print((char)10, (char)5, " ");
  sym_print((char)11, (char)6, " ");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(0, 25);
  sym_print((char)3, (char)1, "____________    ");
  sym_print((char)1, (char)2, "'|\\   \\");
  sym_print((char)2, (char)3, " /         ");
  sym_print((char)3, (char)4, " ");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(0, 25);
  sym_print((char)3, (char)1, "    ____________");
  sym_print((char)1, (char)2, "    '\\   ");
  sym_print((char)2, (char)3, "__/  _   \\");
  sym_print((char)3, (char)4, "_");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(0, 35);
  sym_print((char)7, (char)1, "            ");
  sym_print((char)7, (char)3, " \\   ");
  sym_print((char)5, (char)4, "\\    \\");
  sym_print((char)11, (char)5, "\\");
  sym_print((char)12, (char)6, "\\");
  printf("\033[8;0H");
  fflush((struct _IO_FILE *)(void *)0);
  bat_wait(0, 35);
}

// probe_nat_tool
// file linux/tun.c line 86
signed int probe_nat_tool(void)
{
  signed int return_value_run_cmd_1;
  return_value_run_cmd_1=run_cmd("which iptables > /dev/null");
  return return_value_run_cmd_1;
}

// probe_tun
// file linux/tun.c line 131
signed char probe_tun(unsigned char print_to_stderr)
{
  signed int fd;
  fd=open("/dev/net/tun", 02);
  if(!(fd >= 0))
  {
    if(!(print_to_stderr == 0))
      fprintf(stderr, "Error - could not open '/dev/net/tun' ! Is the tun kernel module loaded ?\n");

    else
      debug_output((signed char)0, "Error - could not open '/dev/net/tun' ! Is the tun kernel module loaded ?\n");
    return (signed char)0;
  }

  else
  {
    close(fd);
    return (signed char)1;
  }
}

// prof_init
// file profile.h line 50
void prof_init(signed int index, char *name)
{
  prof_container[(signed long int)index].total_time = (signed long int)0;
  prof_container[(signed long int)index].calls = (unsigned long int)0;
  prof_container[(signed long int)index].name = name;
}

// prof_print
// file profile.h line 53
void prof_print(void)
{
  signed int index;
  debug_output((signed char)5, " \nProfile data:\n");
  index = 0;
  double tmp_if_expr_1;
  for( ; !(index >= 9); index = index + 1)
  {
    if(prof_container[(signed long int)index].calls == 0ul)
      tmp_if_expr_1 = 0.0;

    else
      tmp_if_expr_1 = (double)(((float)prof_container[(signed long int)index].total_time / (float)(signed long int)1000000) / (float)prof_container[(signed long int)index].calls);
    debug_output((signed char)5, "   %''30s: cpu time = %10.3f, calls = %''10i, avg time per call = %4.10f \n", prof_container[(signed long int)index].name, (float)prof_container[(signed long int)index].total_time / (float)(signed long int)1000000, prof_container[(signed long int)index].calls, tmp_if_expr_1);
  }
}

// prof_start
// file profile.h line 51
void prof_start(signed int index)
{
  prof_container[(signed long int)index].start_time=clock();
}

// prof_stop
// file profile.h line 52
void prof_stop(signed int index)
{
  prof_container[(signed long int)index].calls = prof_container[(signed long int)index].calls + 1ul;
  signed long int return_value_clock_1;
  return_value_clock_1=clock();
  prof_container[(signed long int)index].total_time = prof_container[(signed long int)index].total_time + (return_value_clock_1 - prof_container[(signed long int)index].start_time);
}

// purge_orig
// file originator.h line 33
void purge_orig(unsigned int curr_time)
{
  struct hash_it_t *hashit = (struct hash_it_t *)(void *)0;
  struct list_head *neigh_pos;
  struct list_head *neigh_temp;
  struct list_head *prev_list_head;
  struct list_head *gw_pos;
  struct list_head *gw_pos_tmp;
  struct orig_node *orig_node;
  struct neigh_node *neigh_node;
  struct neigh_node *best_neigh_node;
  struct gw_node *gw_node;
  unsigned char gw_purged = (unsigned char)0;
  unsigned char neigh_purged;
  unsigned char max_tq;
  char orig_str[16l];
  char neigh_str[16l];
  prof_start(6);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  do
  {
    hashit=hash_iterate(orig_hash, hashit);
    if(hashit == ((struct hash_it_t *)NULL))
      break;

    orig_node = (struct orig_node *)hashit->bucket->data;
    if((signed int)curr_time + -(2 * (signed int)purge_timeout + (signed int)orig_node->last_valid) >= 1)
    {
      addr_to_string(orig_node->orig, orig_str, 16);
      debug_output((signed char)4, "Originator timeout: originator %s, last_valid %u \n", (const void *)orig_str, orig_node->last_valid);
      hash_remove_bucket(orig_hash, hashit);
      neigh_pos = (&orig_node->neigh_list)->next;
      neigh_temp = neigh_pos->next;
      for( ; !(neigh_pos == (struct list_head *)&orig_node->neigh_list); neigh_temp = neigh_pos->next)
      {
        neigh_node = (struct neigh_node *)((char *)neigh_pos - (signed long int)(unsigned long int)&((struct neigh_node *)0)->list);
        list_del((struct list_head *)&orig_node->neigh_list, neigh_pos, &orig_node->neigh_list);
        debugFree((void *)neigh_node->tq_recv, 1407);
        debugFree((void *)neigh_node->real_bits, 1409);
        debugFree((void *)neigh_node, 1401);
        neigh_pos = neigh_temp;
      }
      gw_pos = (&gw_list)->next;
      for( ; !(gw_pos == (struct list_head *)&gw_list); gw_pos = gw_pos->next)
      {
        gw_node = (struct gw_node *)((char *)gw_pos - (signed long int)(unsigned long int)&((struct gw_node *)0)->list);
        if(gw_node->deleted == 0u)
        {
          if(gw_node->orig_node == orig_node)
          {
            addr_to_string(gw_node->orig_node->orig, orig_str, 16);
            debug_output((signed char)3, "Removing gateway %s from gateway list \n", (const void *)orig_str);
            gw_node->deleted=get_time_msec();
            gw_purged = (unsigned char)1;
            break;
          }

        }

      }
      update_routes(orig_node, (struct neigh_node *)(void *)0, (unsigned char *)(void *)0, (signed short int)0);
      debugFree((void *)orig_node->bcast_own, 1403);
      debugFree((void *)orig_node->bcast_own_sum, 1404);
      debugFree((void *)orig_node, 1405);
    }

    else
    {
      best_neigh_node = (struct neigh_node *)(void *)0;
      neigh_purged = (unsigned char)0;
      max_tq = neigh_purged;
      prev_list_head = (struct list_head *)&orig_node->neigh_list;
      neigh_pos = (&orig_node->neigh_list)->next;
      neigh_temp = neigh_pos->next;
      for( ; !(neigh_pos == (struct list_head *)&orig_node->neigh_list); neigh_temp = neigh_pos->next)
      {
        neigh_node = (struct neigh_node *)((char *)neigh_pos - (signed long int)(unsigned long int)&((struct neigh_node *)0)->list);
        if((signed int)curr_time + -((signed int)neigh_node->last_valid + (signed int)purge_timeout) >= 1)
        {
          addr_to_string(orig_node->orig, orig_str, 16);
          addr_to_string(neigh_node->addr, neigh_str, 16);
          debug_output((signed char)4, "Neighbour timeout: originator %s, neighbour: %s, last_valid %u \n", (const void *)orig_str, (const void *)neigh_str, neigh_node->last_valid);
          if(orig_node->router == neigh_node)
          {
            debug_output((signed char)4, "Deleting previous route \n");
            hna_global_del(orig_node);
            add_del_route(orig_node->orig, (unsigned char)32, orig_node->router->addr, (unsigned int)0, orig_node->batman_if->if_index, orig_node->batman_if->dev, (unsigned char)66, (signed char)0, (signed char)1);
            if(!(curr_gateway == ((struct gw_node *)NULL)))
            {
              if(curr_gateway->orig_node == orig_node)
                del_default_route();

            }

            orig_node->router = (struct neigh_node *)(void *)0;
          }

          neigh_purged = (unsigned char)1;
          list_del(prev_list_head, neigh_pos, &orig_node->neigh_list);
          debugFree((void *)neigh_node->tq_recv, 1408);
          debugFree((void *)neigh_node->real_bits, 1410);
          debugFree((void *)neigh_node, 1406);
        }

        else
        {
          if(best_neigh_node == ((struct neigh_node *)NULL))
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = (signed int)neigh_node->tq_avg > (signed int)max_tq ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_1)
          {
            best_neigh_node = neigh_node;
            max_tq = neigh_node->tq_avg;
          }

          prev_list_head = &neigh_node->list;
        }
        neigh_pos = neigh_temp;
      }
      if(!(neigh_purged == 0))
      {
        if(best_neigh_node == ((struct neigh_node *)NULL))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = orig_node->router == (struct neigh_node *)(void *)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)max_tq > (signed int)orig_node->router->tq_avg ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
          update_routes(orig_node, best_neigh_node, orig_node->hna_buff, orig_node->hna_buff_len);

      }

    }
  }
  while((_Bool)1);
  prev_list_head = (struct list_head *)&gw_list;
  gw_pos = (&gw_list)->next;
  gw_pos_tmp = gw_pos->next;
  _Bool tmp_if_expr_4;
  for( ; !(gw_pos == (struct list_head *)&gw_list); gw_pos_tmp = gw_pos->next)
  {
    gw_node = (struct gw_node *)((char *)gw_pos - (signed long int)(unsigned long int)&((struct gw_node *)0)->list);
    if(!(gw_node->deleted == 0u))
      tmp_if_expr_4 = (signed int)(curr_time - (gw_node->deleted + (unsigned int)2 * purge_timeout)) > 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      list_del(prev_list_head, gw_pos, &gw_list);
      debugFree((void *)gw_pos, 1406);
    }

    else
      prev_list_head = &gw_node->list;
    gw_pos = gw_pos_tmp;
  }
  prof_stop(6);
  if(!(gw_purged == 0))
    choose_gw();

}

// rand_num
// file os.h line 35
signed int rand_num(signed int limit)
{
  signed int tmp_if_expr_2;
  signed int return_value_rand_1;
  if(limit == 0)
    tmp_if_expr_2 = 0;

  else
  {
    return_value_rand_1=rand();
    tmp_if_expr_2 = return_value_rand_1 % limit;
  }
  return tmp_if_expr_2;
}

// receive_packet
// file os.h line 86
signed char receive_packet(unsigned char *packet_buff, signed int packet_buff_len, signed short int *packet_len, unsigned int *neigh, unsigned int timeout, struct batman_if **if_incoming)
{
  struct sockaddr_in addr;
  struct timeval tv;
  struct list_head *if_pos;
  struct batman_if *batman_if;
  unsigned int addr_len;
  signed char res;
  struct anonymous_15 tmp_wait_set;
  addr_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  memcpy((void *)&tmp_wait_set, (const void *)&receive_wait_set, sizeof(struct anonymous_15) /*128ul*/ );
  while((_Bool)1)
  {
    tv.tv_sec = (signed long int)(timeout / (unsigned int)1000);
    tv.tv_usec = (signed long int)((timeout % (unsigned int)1000) * (unsigned int)1000);
    signed int return_value_select_1;
    return_value_select_1=select(receive_max_sock + 1, &tmp_wait_set, (struct anonymous_15 *)(void *)0, (struct anonymous_15 *)(void *)0, &tv);
    res = (signed char)return_value_select_1;
    if((signed int)res >= 0)
      break;

    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    if(!(*return_value___errno_location_4 == 4))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      debug_output((signed char)0, "Error - can't select (receive_packet): %s\n", return_value_strerror_3);
      check_active_interfaces();
      interface_listen_sockets();
      return (signed char)-1;
    }

  }
  if((signed int)res == 0)
    return (signed char)0;

  else
  {
    if_pos = (&if_list)->next;
    for( ; !(if_pos == (struct list_head *)&if_list); if_pos = if_pos->next)
    {
      batman_if = (struct batman_if *)((char *)if_pos - (signed long int)(unsigned long int)&((struct batman_if *)0)->list);
      if(!((tmp_wait_set.fds_bits[(signed long int)(batman_if->udp_recv_sock / 8)] & (signed long int)(1UL << batman_if->udp_recv_sock % 8)) == 0l))
      {
        signed long int return_value_recvfrom_7;
        return_value_recvfrom_7=recvfrom(batman_if->udp_recv_sock, (void *)packet_buff, (unsigned long int)(packet_buff_len - 1), 0, (struct sockaddr *)&addr, &addr_len);
        *packet_len = (signed short int)return_value_recvfrom_7;
        if(!((signed int)*packet_len >= 0))
        {
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          char *return_value_strerror_6;
          return_value_strerror_6=strerror(*return_value___errno_location_5);
          debug_output((signed char)0, "Error - can't receive packet: %s\n", return_value_strerror_6);
          deactivate_interface(batman_if);
          return (signed char)-1;
        }

        if(!((unsigned long int)(unsigned int)*packet_len >= sizeof(struct bat_packet) /*18ul*/ ))
          return (signed char)0;

        *if_incoming = batman_if;
        break;
      }

    }
    *neigh = addr.sin_addr.s_addr;
    return (signed char)1;
  }
}

// removeMemory
// file allocate.c line 157
static void removeMemory(signed int tag, signed int freetag)
{
  struct memoryUsage *walker;
  pthread_mutex_lock(&memory_mutex);
  walker = memoryList;
  for( ; !(walker == ((struct memoryUsage *)NULL)); walker = walker->next)
    if(walker->tag == tag)
    {
      if(walker->counter == 0u)
      {
        debug_output((signed char)0, "Freeing more memory than was allocated: malloc tag = %d, free tag = %d\n", tag, freetag);
        pthread_mutex_unlock(&memory_mutex);
        restore_and_exit((unsigned char)0);
      }

      walker->counter = walker->counter - 1u;
      break;
    }

  if(walker == ((struct memoryUsage *)NULL))
  {
    debug_output((signed char)0, "Freeing memory that was never allocated: malloc tag = %d, free tag = %d\n", tag, freetag);
    pthread_mutex_unlock(&memory_mutex);
    restore_and_exit((unsigned char)0);
  }

  pthread_mutex_unlock(&memory_mutex);
}

// restore_and_exit
// file os.h line 44
void restore_and_exit(unsigned char is_sigsegv)
{
  struct orig_node *orig_node;
  struct hash_it_t *hashit = (struct hash_it_t *)(void *)0;
  if(unix_client == 0)
  {
    stop = (signed char)1;
    del_gw_interface();
    if(!(curr_gateway == ((struct gw_node *)NULL)) && !((signed int)routing_class == 0))
      del_default_route();

    if(is_sigsegv == 0)
      do
      {
        hashit=hash_iterate(orig_hash, hashit);
        if(hashit == ((struct hash_it_t *)NULL))
          break;

        orig_node = (struct orig_node *)hashit->bucket->data;
        update_routes(orig_node, (struct neigh_node *)(void *)0, (unsigned char *)(void *)0, (signed short int)0);
      }
      while((_Bool)1);

    restore_defaults();
  }

  if(!(is_sigsegv == 0))
    raise(11);

  exit(1);
}

// restore_defaults
// file posix/../os.h line 89
void restore_defaults(void)
{
  struct list_head *if_pos;
  struct list_head *if_pos_tmp;
  struct batman_if *batman_if;
  stop = (signed char)1;
  if((signed int)routing_class >= 1)
    add_del_interface_rules((signed char)1);

  del_gw_interface();
  if_pos = (&if_list)->next;
  if_pos_tmp = if_pos->next;
  for( ; !(if_pos == (struct list_head *)&if_list); if_pos_tmp = if_pos->next)
  {
    batman_if = (struct batman_if *)((char *)if_pos - (signed long int)(unsigned long int)&((struct batman_if *)0)->list);
    deactivate_interface(batman_if);
    list_del((struct list_head *)&if_list, if_pos, &if_list);
    debugFree((void *)if_pos, 1214);
    if_pos = if_pos_tmp;
  }
  add_del_rule((unsigned int)0, (unsigned char)0, (signed char)65, (unsigned int)((6600 + 100) - 1), ((char *)NULL), (signed char)1, (signed char)1);
  add_del_route((unsigned int)0, (unsigned char)0, (unsigned int)0, (unsigned int)0, 0, "unknown", (unsigned char)67, (signed char)2, (signed char)1);
  if(!(curr_gateway == ((struct gw_node *)NULL)) && !((signed int)routing_class == 0))
    del_default_route();

  if(!(vis_if.sock == 0))
    close(vis_if.sock);

  if(!(unix_if.unix_sock == 0))
    close(unix_if.unix_sock);

  if(!(unix_if.listen_thread_id == 0ul))
  {
    pthread_join(unix_if.listen_thread_id, (void **)(void *)0);
    unix_if.listen_thread_id = (unsigned long int)0;
  }

  if((signed int)debug_level == 0)
    closelog();

  if(!(policy_routing_script == ((char *)NULL)))
  {
    close(policy_routing_pipe);
    waitpid(policy_routing_script_pid, (signed int *)(void *)0, 0);
  }

}

// ring_buffer_avg
// file ring_buffer.h line 30
unsigned char ring_buffer_avg(unsigned char *tq_recv)
{
  unsigned char *ptr;
  unsigned short int count = (unsigned short int)0;
  unsigned short int i = (unsigned short int)0;
  unsigned int sum = (unsigned int)0;
  ptr = tq_recv;
  for( ; !((signed int)i >= (signed int)global_win_size); ptr = ptr + 1l)
  {
    if(!((signed int)*ptr == 0))
    {
      count = count + 1;
      sum = sum + (unsigned int)*ptr;
    }

    i = i + 1;
  }
  if((signed int)count == 0)
    return (unsigned char)0;

  else
    return (unsigned char)(sum / (unsigned int)count);
}

// ring_buffer_set
// file ring_buffer.h line 29
void ring_buffer_set(unsigned char *tq_recv, unsigned char *tq_index, unsigned char value)
{
  tq_recv[(signed long int)*tq_index] = value;
  *tq_index = (unsigned char)(((signed int)*tq_index + 1) % (signed int)global_win_size);
}

// run_cmd
// file linux/tun.c line 47
signed int run_cmd(char *cmd)
{
  signed int error;
  signed int pipes[2l];
  signed int run_cmd__1__stderr = -1;
  signed int ret = 0;
  char error_log[256l];
  signed int return_value_pipe_3;
  return_value_pipe_3=pipe(pipes);
  if(!(return_value_pipe_3 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    debug_output((signed char)3, "Warning - could not create a pipe to '%s': %s\n", cmd, return_value_strerror_2);
    return -1;
  }

  memset((void *)error_log, 0, (unsigned long int)256);
  run_cmd__1__stderr=dup(2);
  dup2(pipes[(signed long int)1], 2);
  close(pipes[(signed long int)1]);
  error=system(cmd);
  dup2(run_cmd__1__stderr, 2);
  close(run_cmd__1__stderr);
  _Bool tmp_if_expr_5;
  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_12
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  if(!(error >= 0))
    tmp_if_expr_5 = (_Bool)1;

  else
    tmp_if_expr_5 = (((union anonymous_12){ .__in=error }).__i & 0xff00) >> 8 != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_5)
  {
    signed long int return_value_read_4;
    return_value_read_4=read(pipes[(signed long int)0], (void *)error_log, sizeof(char [256l]) /*256ul*/ );
    ret = (signed int)return_value_read_4;
    debug_output((signed char)3, "Warning - command '%s' returned an error\n", cmd);
    if(ret >= 1)
      debug_output((signed char)3, "          %s\n", (const void *)error_log);

    ret = -1;
  }

  close(pipes[(signed long int)0]);
  return ret;
}

// schedule_forward_packet
// file schedule.h line 24
void schedule_forward_packet(struct orig_node *orig_node, struct bat_packet *in, unsigned int neigh, unsigned char directlink, signed short int hna_buff_len, struct batman_if *if_incoming, unsigned int curr_time)
{
  struct forw_node *forw_node_new = (struct forw_node *)(void *)0;
  struct forw_node *forw_node_aggregate = (struct forw_node *)(void *)0;
  struct forw_node *forw_node_pos = (struct forw_node *)(void *)0;
  struct list_head *list_pos = forw_list.next;
  struct list_head *prev_list_head = (struct list_head *)&forw_list;
  struct bat_packet *bat_packet;
  unsigned char tq_avg = (unsigned char)0;
  unsigned int send_time;
  prof_start(7);
  debug_output((signed char)4, "schedule_forward_packet():  \n");
  signed int return_value_rand_num_1;
  signed int return_value_rand_num_2;
  _Bool tmp_if_expr_3;
  if(!((signed int)in->ttl >= 2))
  {
    debug_output((signed char)4, "ttl exceeded \n");
    prof_stop(7);
  }

  else
  {
    if(!(aggregation_enabled == 0))
    {
      return_value_rand_num_1=rand_num(100);
      send_time = ((curr_time + (unsigned int)100) - (unsigned int)(100 / 2)) + (unsigned int)return_value_rand_num_1;
    }

    else
    {
      return_value_rand_num_2=rand_num(100 / 2);
      send_time = curr_time + (unsigned int)return_value_rand_num_2;
    }
    list_pos = (&forw_list)->next;
    for( ; !(list_pos == (struct list_head *)&forw_list); list_pos = list_pos->next)
    {
      forw_node_pos = (struct forw_node *)((char *)list_pos - (signed long int)(unsigned long int)&((struct forw_node *)0)->list);
      if(!(aggregation_enabled == 0))
      {
        forw_node_aggregate = forw_node_pos;
        if(!((signed int)forw_node_pos->send_time + -((signed int)send_time) >= 0))
        {
          if(!(sizeof(struct bat_packet) /*18ul*/  + (unsigned long int)forw_node_pos->pack_buff_len + (unsigned long int)hna_buff_len >= 513ul))
          {
            bat_packet = (struct bat_packet *)forw_node_pos->pack_buff;
            if(directlink == 0)
            {
              if((0x40 & (signed int)bat_packet->flags) == 0)
              {
                if(!((signed int)bat_packet->ttl == 1))
                {
                  if(forw_node_pos->own == 0)
                    tmp_if_expr_3 = (_Bool)1;

                  else
                    tmp_if_expr_3 = (signed int)forw_node_pos->if_incoming->if_num == 0 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_3)
                    break;

                }

              }

            }

            if(!(directlink == 0))
            {
              if((signed int)in->ttl == 2)
              {
                if(forw_node_pos->if_incoming == if_incoming)
                  break;

              }

            }

          }

        }

        forw_node_aggregate = (struct forw_node *)(void *)0;
      }

      if((signed int)forw_node_pos->send_time + -((signed int)send_time) >= 1)
        break;

      prev_list_head = &forw_node_pos->list;
      forw_node_pos = (struct forw_node *)(void *)0;
    }
    if(forw_node_aggregate == ((struct forw_node *)NULL))
    {
      void *return_value_debugMalloc_4;
      return_value_debugMalloc_4=debugMalloc((unsigned int)sizeof(struct forw_node) /*48ul*/ , 504);
      forw_node_new = (struct forw_node *)return_value_debugMalloc_4;
      void *return_value_debugMalloc_5;
      return_value_debugMalloc_5=debugMalloc((unsigned int)512, 505);
      forw_node_new->pack_buff = (unsigned char *)return_value_debugMalloc_5;
      do
        (&forw_node_new->list)->next = &forw_node_new->list;
      while((_Bool)0);
      forw_node_new->pack_buff_len = (unsigned short int)(sizeof(struct bat_packet) /*18ul*/  + (unsigned long int)hna_buff_len);
      memcpy((void *)forw_node_new->pack_buff, (const void *)in, (unsigned long int)forw_node_new->pack_buff_len);
      bat_packet = (struct bat_packet *)forw_node_new->pack_buff;
      forw_node_new->own = (unsigned char)0;
      forw_node_new->if_incoming = if_incoming;
      forw_node_new->num_packets = (unsigned char)0;
      forw_node_new->direct_link_flags = (unsigned int)0;
      forw_node_new->send_time = send_time;
    }

    else
    {
      memcpy((void *)(forw_node_aggregate->pack_buff + (signed long int)forw_node_aggregate->pack_buff_len), (const void *)in, sizeof(struct bat_packet) /*18ul*/  + (unsigned long int)hna_buff_len);
      bat_packet = (struct bat_packet *)(forw_node_aggregate->pack_buff + (signed long int)forw_node_aggregate->pack_buff_len);
      forw_node_aggregate->pack_buff_len = forw_node_aggregate->pack_buff_len + (unsigned short int)(sizeof(struct bat_packet) /*18ul*/  + (unsigned long int)hna_buff_len);
      forw_node_aggregate->num_packets = forw_node_aggregate->num_packets + 1;
      forw_node_new = forw_node_aggregate;
    }
    if(!(directlink == 0))
      forw_node_new->direct_link_flags = forw_node_new->direct_link_flags | (unsigned int)(1 << (signed int)forw_node_new->num_packets);

    bat_packet->ttl = bat_packet->ttl - 1;
    bat_packet->prev_sender = neigh;
    if(!(orig_node->router == ((struct neigh_node *)NULL)))
    {
      if(!((signed int)orig_node->router->tq_avg == 0))
      {
        if(!(orig_node->router->addr == neigh))
        {
          bat_packet->tq = orig_node->router->tq_avg;
          bat_packet->ttl = (unsigned char)((signed int)orig_node->router->last_ttl - 1);
        }

        tq_avg = orig_node->router->tq_avg;
      }

    }

    bat_packet->tq = (unsigned char)(((signed int)bat_packet->tq * (255 - (signed int)hop_penalty)) / 255);
    debug_output((signed char)4, "forwarding: tq_orig: %i, tq_avg: %i, tq_forw: %i, ttl_orig: %i, ttl_forw: %i \n", in->tq, tq_avg, bat_packet->tq, (signed int)in->ttl - 1, bat_packet->ttl);
    bat_packet->seqno=htons(bat_packet->seqno);
    if(!(directlink == 0))
      bat_packet->flags = bat_packet->flags | (unsigned char)0x40;

    else
      bat_packet->flags = bat_packet->flags & (unsigned char)~0x40;
    if(forw_node_aggregate == ((struct forw_node *)NULL))
    {
      if(!(forw_node_pos == ((struct forw_node *)NULL)))
        list_add_before(prev_list_head, list_pos, &forw_node_new->list);

      else
        list_add_tail(&forw_node_new->list, &forw_list);
    }

    prof_stop(7);
  }
}

// schedule_own_packet
// file schedule.h line 23
void schedule_own_packet(struct batman_if *batman_if)
{
  struct forw_node *forw_node_new;
  struct forw_node *forw_packet_tmp = (struct forw_node *)(void *)0;
  struct list_head *list_pos;
  struct list_head *prev_list_head;
  struct hash_it_t *hashit = (struct hash_it_t *)(void *)0;
  struct orig_node *orig_node;
  debug_output((signed char)4, "schedule_own_packet(): %s \n", batman_if->dev);
  void *return_value_debugMalloc_1;
  return_value_debugMalloc_1=debugMalloc((unsigned int)sizeof(struct forw_node) /*48ul*/ , 501);
  forw_node_new = (struct forw_node *)return_value_debugMalloc_1;
  do
    (&forw_node_new->list)->next = &forw_node_new->list;
  while((_Bool)0);
  unsigned int return_value_get_time_msec_2;
  return_value_get_time_msec_2=get_time_msec();
  signed int return_value_rand_num_3;
  return_value_rand_num_3=rand_num(2 * 100);
  forw_node_new->send_time = ((return_value_get_time_msec_2 + (unsigned int)originator_interval) - (unsigned int)100) + (unsigned int)return_value_rand_num_3;
  forw_node_new->if_incoming = batman_if;
  forw_node_new->own = (unsigned char)1;
  forw_node_new->num_packets = (unsigned char)0;
  forw_node_new->direct_link_flags = (unsigned int)0;
  _Bool tmp_if_expr_6;
  if((signed int)num_hna_local >= 1)
    tmp_if_expr_6 = (signed int)batman_if->if_num == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_6 = (_Bool)0;
  if(tmp_if_expr_6)
  {
    void *return_value_debugMalloc_4;
    return_value_debugMalloc_4=debugMalloc((unsigned int)512, 502);
    forw_node_new->pack_buff = (unsigned char *)return_value_debugMalloc_4;
    memcpy((void *)forw_node_new->pack_buff, (const void *)(unsigned char *)&batman_if->out, sizeof(struct bat_packet) /*18ul*/ );
    memcpy((void *)(forw_node_new->pack_buff + (signed long int)sizeof(struct bat_packet) /*18ul*/ ), (const void *)hna_buff_local, (unsigned long int)((signed int)num_hna_local * 5));
    forw_node_new->pack_buff_len = (unsigned short int)(sizeof(struct bat_packet) /*18ul*/  + (unsigned long int)((signed int)num_hna_local * 5));
    ((struct bat_packet *)forw_node_new->pack_buff)->hna_len = num_hna_local;
  }

  else
  {
    void *return_value_debugMalloc_5;
    return_value_debugMalloc_5=debugMalloc((unsigned int)512, 503);
    forw_node_new->pack_buff = (unsigned char *)return_value_debugMalloc_5;
    memcpy((void *)forw_node_new->pack_buff, (const void *)&batman_if->out, sizeof(struct bat_packet) /*18ul*/ );
    forw_node_new->pack_buff_len = (unsigned short int)sizeof(struct bat_packet) /*18ul*/ ;
    ((struct bat_packet *)forw_node_new->pack_buff)->hna_len = (unsigned char)0;
  }
  ((struct bat_packet *)forw_node_new->pack_buff)->seqno=htons(((struct bat_packet *)forw_node_new->pack_buff)->seqno);
  prev_list_head = (struct list_head *)&forw_list;
  list_pos = (&forw_list)->next;
  for( ; !(list_pos == (struct list_head *)&forw_list); list_pos = list_pos->next)
  {
    forw_packet_tmp = (struct forw_node *)((char *)list_pos - (signed long int)(unsigned long int)&((struct forw_node *)0)->list);
    if((signed int)forw_packet_tmp->send_time + -((signed int)forw_node_new->send_time) >= 0)
    {
      list_add_before(prev_list_head, list_pos, &forw_node_new->list);
      break;
    }

    prev_list_head = &forw_packet_tmp->list;
    forw_packet_tmp = (struct forw_node *)(void *)0;
  }
  if(forw_packet_tmp == ((struct forw_node *)NULL))
    list_add_tail(&forw_node_new->list, &forw_list);

  batman_if->out.seqno = batman_if->out.seqno + 1;
  do
  {
    hashit=hash_iterate(orig_hash, hashit);
    if(hashit == ((struct hash_it_t *)NULL))
      break;

    orig_node = (struct orig_node *)hashit->bucket->data;
    debug_output((signed char)4, "count own bcast (schedule_own_packet): old = %i, ", orig_node->bcast_own_sum[(signed long int)batman_if->if_num]);
    bit_get_packet((unsigned long int *)&orig_node->bcast_own[(signed long int)((signed int)batman_if->if_num * (signed int)num_words)], (signed short int)1, (signed char)0);
    signed int return_value_bit_packet_count_7;
    return_value_bit_packet_count_7=bit_packet_count((unsigned long int *)&orig_node->bcast_own[(signed long int)((signed int)batman_if->if_num * (signed int)num_words)]);
    orig_node->bcast_own_sum[(signed long int)batman_if->if_num] = (unsigned char)return_value_bit_packet_count_7;
    debug_output((signed char)4, "new = %i \n", orig_node->bcast_own_sum[(signed long int)batman_if->if_num]);
  }
  while((_Bool)1);
}

// segmentation_fault
// file posix/../os.h line 43
void segmentation_fault(signed int sig)
{
  signal(11, (void (*)(signed int))0);
  debug_output((signed char)0, "Error - SIGSEGV received, trying to clean up ... \n");
  flush_routes_rules((signed char)0);
  flush_routes_rules((signed char)1);
  restore_and_exit((unsigned char)1);
}

// send_outstanding_packets
// file schedule.h line 25
void send_outstanding_packets(unsigned int curr_time)
{
  struct forw_node *forw_node;
  struct list_head *forw_pos;
  struct list_head *if_pos;
  struct list_head *temp;
  struct batman_if *batman_if;
  struct bat_packet *bat_packet;
  char orig_str[16l];
  unsigned char directlink;
  unsigned char curr_packet_num;
  signed short int curr_packet_len;
  prof_start(8);
  forw_pos = (&forw_list)->next;
  temp = forw_pos->next;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_6;
  char *tmp_if_expr_7;
  for( ; !(forw_pos == (struct list_head *)&forw_list); temp = forw_pos->next)
  {
    forw_node = (struct forw_node *)((char *)forw_pos - (signed long int)(unsigned long int)&((struct forw_node *)0)->list);
    if(!((signed int)curr_time + -((signed int)forw_node->send_time) >= 0))
      break;

    bat_packet = (struct bat_packet *)forw_node->pack_buff;
    addr_to_string(bat_packet->orig, orig_str, 16);
    directlink = (unsigned char)(((signed int)bat_packet->flags & 0x40) != 0 ? 1 : 0);
    if(forw_node->if_incoming == ((struct batman_if *)NULL))
      debug_output((signed char)0, "Error - can't forward packet: incoming iface not specified \n");

    else
    {
      if(!(directlink == 0))
        tmp_if_expr_3 = (signed int)bat_packet->ttl == 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        if(!(forw_node->own == 0))
          tmp_if_expr_4 = (signed int)forw_node->if_incoming->if_num > 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
      {
        unsigned short int return_value_ntohs_1;
        return_value_ntohs_1=ntohs(bat_packet->seqno);
        debug_output((signed char)4, "%s packet (originator %s, seqno %d, TTL %d) on interface %s\n", forw_node->own != 0 ? "Sending own" : "Forwarding", (const void *)orig_str, return_value_ntohs_1, bat_packet->ttl, forw_node->if_incoming->dev);
        signed char return_value_send_udp_packet_2;
        return_value_send_udp_packet_2=send_udp_packet(forw_node->pack_buff, (signed int)forw_node->pack_buff_len, &forw_node->if_incoming->broad, forw_node->if_incoming->udp_send_sock, forw_node->if_incoming);
        if(!((signed int)return_value_send_udp_packet_2 >= 0))
          deactivate_interface(forw_node->if_incoming);

        goto packet_free;
      }

      if_pos = (&if_list)->next;
      for( ; !(if_pos == (struct list_head *)&if_list); if_pos = if_pos->next)
      {
        batman_if = (struct batman_if *)((char *)if_pos - (signed long int)(unsigned long int)&((struct batman_if *)0)->list);
        curr_packet_len = (signed short int)0;
        curr_packet_num = (unsigned char)curr_packet_len;
        bat_packet = (struct bat_packet *)forw_node->pack_buff;
        while((unsigned long int)forw_node->pack_buff_len >= sizeof(struct bat_packet) /*18ul*/  + (unsigned long int)curr_packet_len)
        {
          if(!((unsigned long int)forw_node->pack_buff_len >= sizeof(struct bat_packet) /*18ul*/  + (unsigned long int)(5 * (signed int)bat_packet->hna_len) + (unsigned long int)curr_packet_len))
            break;

          if(sizeof(struct bat_packet) /*18ul*/  + (unsigned long int)(5 * (signed int)bat_packet->hna_len) + (unsigned long int)curr_packet_len >= 513ul)
            break;

          if(!((forw_node->direct_link_flags & (unsigned int)(1 << (signed int)curr_packet_num)) == 0u))
            tmp_if_expr_6 = forw_node->if_incoming == batman_if ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6 = (_Bool)0;
          if(tmp_if_expr_6)
            bat_packet->flags = bat_packet->flags | (unsigned char)0x40;

          else
            bat_packet->flags = bat_packet->flags & (unsigned char)~0x40;
          if((signed int)curr_packet_num >= 1)
            addr_to_string(bat_packet->orig, orig_str, 16);

          if(!(batman_if->wifi_if == 0))
          {
            if(forw_node->own == 0)
            {
              if(forw_node->if_incoming == batman_if)
                bat_packet->tq = (unsigned char)(((signed int)bat_packet->tq * (255 - 2 * (signed int)hop_penalty)) / 255);

            }

          }

          if((signed int)curr_packet_num >= 1)
            tmp_if_expr_7 = "Forwarding";

          else
            tmp_if_expr_7 = forw_node->own != 0 ? "Sending own" : "Forwarding";
          unsigned short int return_value_ntohs_8;
          return_value_ntohs_8=ntohs(bat_packet->seqno);
          debug_output((signed char)4, "%s %spacket (originator %s, seqno %d, TQ %d, TTL %d, IDF %s) on interface %s\n", tmp_if_expr_7, (signed int)curr_packet_num > 0 ? "aggregated " : "", (const void *)orig_str, return_value_ntohs_8, bat_packet->tq, bat_packet->ttl, ((signed int)bat_packet->flags & 0x40) != 0 ? "on" : "off", batman_if->dev);
          curr_packet_len = curr_packet_len + (signed short int)(sizeof(struct bat_packet) /*18ul*/  + (unsigned long int)((signed int)bat_packet->hna_len * 5));
          curr_packet_num = curr_packet_num + 1;
          bat_packet = (struct bat_packet *)(forw_node->pack_buff + (signed long int)curr_packet_len);
        }
        signed char return_value_send_udp_packet_9;
        return_value_send_udp_packet_9=send_udp_packet(forw_node->pack_buff, (signed int)forw_node->pack_buff_len, &batman_if->broad, batman_if->udp_send_sock, batman_if);
        if(!((signed int)return_value_send_udp_packet_9 >= 0))
          deactivate_interface(batman_if);

      }
    }

  packet_free:
    ;
    list_del((struct list_head *)&forw_list, forw_pos, &forw_list);
    if(!(forw_node->own == 0))
    {
      if(!(forw_node->if_incoming == ((struct batman_if *)NULL)))
        schedule_own_packet(forw_node->if_incoming);

    }

    debugFree((void *)forw_node->pack_buff, 1501);
    debugFree((void *)forw_node, 1502);
    forw_pos = temp;
  }
  prof_stop(8);
}

// send_udp_packet
// file os.h line 87
signed char send_udp_packet(unsigned char *packet_buff, signed int packet_buff_len, struct sockaddr_in *broad, signed int send_sock, struct batman_if *batman_if)
{
  if(!(batman_if == ((struct batman_if *)NULL)))
  {
    if(!(batman_if->if_active == 0))
      goto __CPROVER_DUMP_L1;

    return (signed char)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    signed long int return_value_sendto_7;
    return_value_sendto_7=sendto(send_sock, (const void *)packet_buff, (unsigned long int)packet_buff_len, 0, (struct sockaddr *)broad, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_sendto_7 >= 0l))
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      if(*return_value___errno_location_6 == 1)
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        unsigned short int return_value_ntohs_3;
        return_value_ntohs_3=ntohs(broad->sin_port);
        debug_output((signed char)0, "Error - can't send udp packet: %s.\nDoes your firewall allow outgoing packets on port %i ?\n", return_value_strerror_2, return_value_ntohs_3);
      }

      else
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        debug_output((signed char)0, "Error - can't send udp packet: %s\n", return_value_strerror_5);
      }
      return (signed char)-1;
    }

    return (signed char)0;
  }
}

// send_vis_packet
// file batman.c line 707
static void send_vis_packet(void)
{
  generate_vis_packet();
  if(!(vis_packet == ((unsigned char *)NULL)))
    send_udp_packet(vis_packet, (signed int)vis_packet_size, &vis_if.addr, vis_if.sock, (struct batman_if *)(void *)0);

}

// set_forwarding
// file os.h line 76
void set_forwarding(signed int state)
{
  set_integer_file("/proc/sys/net/ipv4/ip_forward", state);
}

// set_integer_file
// file linux/kernel.c line 62
static void set_integer_file(const char *filename, signed int integer)
{
  struct _IO_FILE *f;
  f=fopen(filename, "w");
  if(!(f == ((struct _IO_FILE *)NULL)))
  {
    fprintf(f, "%d", integer);
    fclose(f);
  }

}

// set_rp_filter
// file os.h line 72
void set_rp_filter(signed int state, char *dev)
{
  char filename[100l];
  char *colon_ptr;
  colon_ptr=strchr(dev, 58);
  if(!(colon_ptr == ((char *)NULL)))
    *colon_ptr = (char)0;

  sprintf(filename, "/proc/sys/net/ipv4/conf/%s/rp_filter", dev);
  set_integer_file(filename, state);
  if(!(colon_ptr == ((char *)NULL)))
    *colon_ptr = (char)58;

}

// set_send_redirects
// file os.h line 74
void set_send_redirects(signed int state, char *dev)
{
  char filename[100l];
  char *colon_ptr;
  colon_ptr=strchr(dev, 58);
  if(!(colon_ptr == ((char *)NULL)))
    *colon_ptr = (char)0;

  sprintf(filename, "/proc/sys/net/ipv4/conf/%s/send_redirects", dev);
  set_integer_file(filename, state);
  if(!(colon_ptr == ((char *)NULL)))
    *colon_ptr = (char)58;

}

// set_tun_addr
// file linux/tun.c line 312
signed char set_tun_addr(signed int fd, unsigned int tun_addr, char *tun_dev)
{
  struct sockaddr_in addr;
  struct ifreq ifr_tun;
  memset((void *)&ifr_tun, 0, sizeof(struct ifreq) /*40ul*/ );
  memset((void *)&addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr.sin_addr.s_addr = tun_addr;
  addr.sin_family = (unsigned short int)2;
  memcpy((void *)&ifr_tun.ifr_ifru.ifru_addr, (const void *)&addr, sizeof(struct sockaddr) /*16ul*/ );
  strncpy(ifr_tun.ifr_ifrn.ifrn_name, tun_dev, (unsigned long int)(16 - 1));
  signed int return_value_ioctl_3;
  return_value_ioctl_3=ioctl(fd, (unsigned long int)0x8916, &ifr_tun);
  if(!(return_value_ioctl_3 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    debug_output((signed char)0, "Error - can't set tun address (SIOCSIFADDR): %s\n", return_value_strerror_2);
    return (signed char)-1;
  }

  return (signed char)1;
}

// sym_print
// file posix/posix.c line 129
static void sym_print(char x, char y, char *z)
{
  char i = (char)0;
  char Z;
  do
  {
    printf("\033[%i;%iH%c", (signed int)y + 1, 25 + (signed int)x + (signed int)i, z[(signed long int)(signed int)i]);
    switch((signed int)z[(signed long int)(signed int)i])
    {
      case 92:
      {
        Z = (char)47;
        break;
      }
      case 47:
      {
        Z = (char)92;
        break;
      }
      case 41:
      {
        Z = (char)40;
        break;
      }
      default:
        Z = z[(signed long int)(signed int)i];
    }
    printf("\033[%i;%iH%c", (signed int)y + 1, (24 - (signed int)x) - (signed int)i, Z);
    i = i + 1;
  }
  while(!(z[(signed long int)((signed int)i + -1)] == 0));
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// times_wrapper
// file posix/posix.c line 57
static signed long int times_wrapper(void)
{
  signed int save_errno;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  save_errno = *return_value___errno_location_1;
  signed long int ret;
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  *return_value___errno_location_2 = 0;
  ret=times(&dummy_tms_struct);
  signed int *return_value___errno_location_4;
  return_value___errno_location_4=__errno_location();
  if(!(*return_value___errno_location_4 == 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    ret = (signed long int)-(*return_value___errno_location_3);
  }

  signed int *return_value___errno_location_5;
  return_value___errno_location_5=__errno_location();
  *return_value___errno_location_5 = save_errno;
  return ret;
}

// unix_listen
// file posix/../os.h line 98
void * unix_listen(void *arg)
{
  struct unix_client *unix_listen__1__unix_client;
  struct debug_level_info *debug_level_info;
  struct list_head *list_pos;
  struct list_head *unix_pos_tmp;
  struct list_head *debug_pos;
  struct list_head *debug_pos_tmp;
  struct list_head *prev_list_head;
  struct list_head *prev_list_head_unix;
  struct hna_local_entry *hna_local_entry;
  struct batman_if *batman_if;
  struct timeval tv;
  struct sockaddr_un sun_addr;
  struct in_addr tmp_ip_holder;
  signed int status;
  signed int max_sock;
  signed int unix_opts;
  signed int download_speed;
  signed int upload_speed;
  signed char res;
  char buff[100l];
  char str[16l];
  char was_gateway;
  char tmp_unix_value;
  struct anonymous_15 wait_sockets;
  struct anonymous_15 tmp_wait_sockets;
  unsigned int sun_size = (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ ;
  unix_if.client_list.next = (struct list_head *)&unix_if.client_list;
  unix_if.client_list.prev = (struct list_head *)&unix_if.client_list;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_15) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wait_sockets)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&wait_sockets)->fds_bits[(signed long int)(unix_if.unix_sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wait_sockets)->fds_bits[(signed long int)(unix_if.unix_sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << unix_if.unix_sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  max_sock = unix_if.unix_sock;
  signed char return_value_is_aborted_1;
  signed int *return_value___errno_location_7;
  char *return_value_strerror_8;
  signed int *return_value___errno_location_10;
  char *return_value_strerror_11;
  signed int *return_value___errno_location_13;
  char *return_value_strerror_14;
  signed int *return_value___errno_location_17;
  char *return_value_strerror_18;
  _Bool tmp_if_expr_21;
  signed char return_value_probe_tun_20;
  _Bool tmp_if_expr_25;
  signed char return_value_probe_tun_24;
  signed int *return_value___errno_location_27;
  char *return_value_strerror_28;
  signed int *return_value___errno_location_29;
  char *return_value_strerror_30;
  signed int *return_value___errno_location_32;
  char *return_value_strerror_33;
  signed int *return_value___errno_location_37;
  do
  {
    return_value_is_aborted_1=is_aborted();
    if(!(return_value_is_aborted_1 == 0))
      break;

    tv.tv_sec = (signed long int)1;
    tv.tv_usec = (signed long int)0;
    memcpy((void *)&tmp_wait_sockets, (const void *)&wait_sockets, sizeof(struct anonymous_15) /*128ul*/ );
    signed int return_value_select_2;
    return_value_select_2=select(max_sock + 1, &tmp_wait_sockets, (struct anonymous_15 *)(void *)0, (struct anonymous_15 *)(void *)0, &tv);
    res = (signed char)return_value_select_2;
    if((signed int)res >= 1)
    {
      if(!((tmp_wait_sockets.fds_bits[(signed long int)(unix_if.unix_sock / 8)] & (signed long int)(1UL << unix_if.unix_sock % 8)) == 0l))
      {
        void *return_value_debugMalloc_3;
        return_value_debugMalloc_3=debugMalloc((unsigned int)sizeof(struct unix_client) /*16ul*/ , 201);
        unix_listen__1__unix_client = (struct unix_client *)return_value_debugMalloc_3;
        memset((void *)unix_listen__1__unix_client, 0, sizeof(struct unix_client) /*16ul*/ );
        unix_listen__1__unix_client->sock=accept(unix_if.unix_sock, (struct sockaddr *)&sun_addr, &sun_size);
        if(unix_listen__1__unix_client->sock == -1)
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          char *return_value_strerror_5;
          return_value_strerror_5=strerror(*return_value___errno_location_4);
          debug_output((signed char)0, "Error - can't accept unix client: %s\n", return_value_strerror_5);
          continue;
        }

        do
          (&unix_listen__1__unix_client->list)->next = &unix_listen__1__unix_client->list;
        while((_Bool)0);
        (&wait_sockets)->fds_bits[(signed long int)(unix_listen__1__unix_client->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wait_sockets)->fds_bits[(signed long int)(unix_listen__1__unix_client->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << unix_listen__1__unix_client->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        if(!(max_sock >= unix_listen__1__unix_client->sock))
          max_sock = unix_listen__1__unix_client->sock;

        unix_opts=fcntl(unix_listen__1__unix_client->sock, 3, 0);
        fcntl(unix_listen__1__unix_client->sock, 4, unix_opts | 04000);
        list_add_tail(&unix_listen__1__unix_client->list, &unix_if.client_list);
        debug_output((signed char)3, "Unix socket: got connection\n");
      }

      else
      {
        max_sock = unix_if.unix_sock;
        prev_list_head_unix = (struct list_head *)&unix_if.client_list;
        list_pos = (&unix_if.client_list)->next;
        unix_pos_tmp = list_pos->next;
        for( ; !(list_pos == (struct list_head *)&unix_if.client_list); unix_pos_tmp = list_pos->next)
        {
          unix_listen__1__unix_client = (struct unix_client *)((char *)list_pos - (signed long int)(unsigned long int)&((struct unix_client *)0)->list);
          if(!((tmp_wait_sockets.fds_bits[(signed long int)(unix_listen__1__unix_client->sock / 8)] & (signed long int)(1UL << unix_listen__1__unix_client->sock % 8)) == 0l))
          {
            signed long int return_value_read_6;
            return_value_read_6=read(unix_listen__1__unix_client->sock, (void *)buff, sizeof(char [100l]) /*100ul*/ );
            status = (signed int)return_value_read_6;
            if(status >= 1)
            {
              if(!(max_sock >= unix_listen__1__unix_client->sock))
                max_sock = unix_listen__1__unix_client->sock;

              if((signed int)buff[0l] == 97)
              {
                if(status >= 3)
                {
                  hna_local_task_add_str(buff + (signed long int)2, (unsigned char)0, (unsigned char)1);
                  dprintf(unix_listen__1__unix_client->sock, "EOD\n");
                }

              }

              else
                if((signed int)buff[0l] == 65)
                {
                  if(status >= 3)
                  {
                    hna_local_task_add_str(buff + (signed long int)2, (unsigned char)1, (unsigned char)1);
                    dprintf(unix_listen__1__unix_client->sock, "EOD\n");
                  }

                }

                else
                  if((signed int)buff[0l] == 100)
                  {
                    if(status >= 3)
                    {
                      if((signed int)buff[2l] >= 1)
                      {
                        if((signed int)debug_level_max >= (signed int)buff[2l])
                        {
                          if(!((signed int)unix_listen__1__unix_client->debug_level == 0))
                          {
                            prev_list_head = (struct list_head *)debug_clients.fd_list[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)];
                            signed int return_value_pthread_mutex_lock_9;
                            return_value_pthread_mutex_lock_9=pthread_mutex_lock((union anonymous_16 *)debug_clients.mutex[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)]);
                            if(!(return_value_pthread_mutex_lock_9 == 0))
                            {
                              return_value___errno_location_7=__errno_location();
                              return_value_strerror_8=strerror(*return_value___errno_location_7);
                              debug_output((signed char)0, "Error - could not lock mutex (unix_listen => 1): %s \n", return_value_strerror_8);
                            }

                            debug_pos = ((struct list_head *)debug_clients.fd_list[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)])->next;
                            debug_pos_tmp = debug_pos->next;
                            for( ; !(debug_pos == (struct list_head *)debug_clients.fd_list[(signed long int)((signed int)unix_listen__1__unix_client->debug_level + -1)]); debug_pos_tmp = debug_pos->next)
                            {
                              debug_level_info = (struct debug_level_info *)((char *)debug_pos - (signed long int)(unsigned long int)&((struct debug_level_info *)0)->list);
                              if(debug_level_info->fd == unix_listen__1__unix_client->sock)
                              {
                                list_del(prev_list_head, debug_pos, (struct list_head_first *)debug_clients.fd_list[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)]);
                                debug_clients.clients_num[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)] = debug_clients.clients_num[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)] - 1;
                                debugFree((void *)debug_pos, 1201);
                                break;
                              }

                              prev_list_head = &debug_level_info->list;
                              debug_pos = debug_pos_tmp;
                            }
                            signed int return_value_pthread_mutex_unlock_12;
                            return_value_pthread_mutex_unlock_12=pthread_mutex_unlock((union anonymous_16 *)debug_clients.mutex[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)]);
                            if(!(return_value_pthread_mutex_unlock_12 == 0))
                            {
                              return_value___errno_location_10=__errno_location();
                              return_value_strerror_11=strerror(*return_value___errno_location_10);
                              debug_output((signed char)0, "Error - could not unlock mutex (unix_listen => 1): %s \n", return_value_strerror_11);
                            }

                          }

                          if(!((signed int)unix_listen__1__unix_client->debug_level == (signed int)buff[2l]))
                          {
                            signed int return_value_pthread_mutex_lock_15;
                            return_value_pthread_mutex_lock_15=pthread_mutex_lock((union anonymous_16 *)debug_clients.mutex[(signed long int)((signed int)buff[(signed long int)2] - 1)]);
                            if(!(return_value_pthread_mutex_lock_15 == 0))
                            {
                              return_value___errno_location_13=__errno_location();
                              return_value_strerror_14=strerror(*return_value___errno_location_13);
                              debug_output((signed char)0, "Error - could not lock mutex (unix_listen => 2): %s \n", return_value_strerror_14);
                            }

                            void *return_value_debugMalloc_16;
                            return_value_debugMalloc_16=debugMalloc((unsigned int)sizeof(struct debug_level_info) /*16ul*/ , 202);
                            debug_level_info = (struct debug_level_info *)return_value_debugMalloc_16;
                            do
                              (&debug_level_info->list)->next = &debug_level_info->list;
                            while((_Bool)0);
                            debug_level_info->fd = unix_listen__1__unix_client->sock;
                            list_add(&debug_level_info->list, (struct list_head_first *)debug_clients.fd_list[(signed long int)((signed int)buff[(signed long int)2] - 1)]);
                            debug_clients.clients_num[(signed long int)((signed int)buff[(signed long int)2] - 1)] = debug_clients.clients_num[(signed long int)((signed int)buff[(signed long int)2] - 1)] + 1;
                            unix_listen__1__unix_client->debug_level = (unsigned char)buff[(signed long int)2];
                            signed int return_value_pthread_mutex_unlock_19;
                            return_value_pthread_mutex_unlock_19=pthread_mutex_unlock((union anonymous_16 *)debug_clients.mutex[(signed long int)((signed int)buff[(signed long int)2] - 1)]);
                            if(!(return_value_pthread_mutex_unlock_19 == 0))
                            {
                              return_value___errno_location_17=__errno_location();
                              return_value_strerror_18=strerror(*return_value___errno_location_17);
                              debug_output((signed char)0, "Error - could not unlock mutex (unix_listen => 2): %s \n", return_value_strerror_18);
                            }

                          }

                          else
                            unix_listen__1__unix_client->debug_level = (unsigned char)0;
                        }

                      }

                    }

                  }

                  else
                    if((signed int)buff[0l] == 105)
                    {
                      internal_output((unsigned int)unix_listen__1__unix_client->sock);
                      dprintf(unix_listen__1__unix_client->sock, "EOD\n");
                    }

                    else
                      if((signed int)buff[0l] == 103)
                      {
                        if(status >= 3)
                        {
                          if((signed int)buff[2l] == 0)
                            tmp_if_expr_21 = (_Bool)1;

                          else
                          {
                            return_value_probe_tun_20=probe_tun((unsigned char)0);
                            tmp_if_expr_21 = return_value_probe_tun_20 != 0 ? (_Bool)1 : (_Bool)0;
                          }
                          if(tmp_if_expr_21)
                          {
                            was_gateway = (char)((signed int)gateway_class > 0 ? 1 : 0);
                            gateway_class = (unsigned char)buff[(signed long int)2];
                            ((struct batman_if *)if_list.next)->out.gwflags = gateway_class;
                            if((signed int)gateway_class >= 1 && (signed int)routing_class >= 1)
                            {
                              if(!(curr_gateway == ((struct gw_node *)NULL)) && !((signed int)routing_class == 0))
                                del_default_route();

                              add_del_interface_rules((signed char)1);
                              routing_class = (unsigned char)0;
                            }

                            if(was_gateway == 0 && (signed int)gateway_class >= 1)
                              init_interface_gw();

                            else
                              if((signed int)gateway_class == 0 && !(was_gateway == 0))
                                del_gw_interface();

                          }

                        }

                        dprintf(unix_listen__1__unix_client->sock, "EOD\n");
                      }

                      else
                        if((signed int)buff[0l] == 109)
                        {
                          if(status >= 3)
                          {
                            debug_output((signed char)3, "Unix socket: changing hop penalty points from: %i to: %i\n", hop_penalty, buff[(signed long int)2]);
                            hop_penalty = (unsigned char)buff[(signed long int)2];
                          }

                          dprintf(unix_listen__1__unix_client->sock, "EOD\n");
                        }

                        else
                          if((signed int)buff[0l] == 113)
                          {
                            if(status >= 3)
                            {
                              signed long int return_value_strtol_22;
                              return_value_strtol_22=strtol(buff + (signed long int)2, (char ** restrict )(void *)0, 10);
                              debug_output((signed char)3, "Unix socket: changing purge timeout from: %i to: %i\n", purge_timeout, return_value_strtol_22);
                              signed long int return_value_strtol_23;
                              return_value_strtol_23=strtol(buff + (signed long int)2, (char ** restrict )(void *)0, 10);
                              purge_timeout = (unsigned int)return_value_strtol_23;
                            }

                            dprintf(unix_listen__1__unix_client->sock, "EOD\n");
                          }

                          else
                            if((signed int)buff[0l] == 114)
                            {
                              if(status >= 3)
                              {
                                if((signed int)buff[2l] == 0)
                                  tmp_if_expr_25 = (_Bool)1;

                                else
                                {
                                  return_value_probe_tun_24=probe_tun((unsigned char)0);
                                  tmp_if_expr_25 = return_value_probe_tun_24 != 0 ? (_Bool)1 : (_Bool)0;
                                }
                                if(tmp_if_expr_25)
                                {
                                  tmp_unix_value = buff[(signed long int)2];
                                  if((signed int)tmp_unix_value >= 0 && !((signed int)tmp_unix_value == (signed int)routing_class) && !((signed int)tmp_unix_value >= 4))
                                  {
                                    if(!(curr_gateway == ((struct gw_node *)NULL)) && !((signed int)routing_class == 0))
                                      del_default_route();

                                    if((signed int)tmp_unix_value >= 1 && (signed int)gateway_class >= 1)
                                    {
                                      gateway_class = (unsigned char)0;
                                      ((struct batman_if *)if_list.next)->out.gwflags = gateway_class;
                                      del_gw_interface();
                                    }

                                    if((signed int)routing_class == 0 && (signed int)tmp_unix_value >= 1)
                                      add_del_interface_rules((signed char)0);

                                    else
                                      if((signed int)tmp_unix_value == 0 && (signed int)routing_class >= 1)
                                        add_del_interface_rules((signed char)1);

                                    routing_class = (unsigned char)tmp_unix_value;
                                  }

                                }

                              }

                              dprintf(unix_listen__1__unix_client->sock, "EOD\n");
                            }

                            else
                              if((signed int)buff[0l] == 112)
                              {
                                if(status >= 3)
                                {
                                  signed int return_value_inet_pton_26;
                                  return_value_inet_pton_26=inet_pton(2, buff + (signed long int)2, (void *)&tmp_ip_holder);
                                  if(return_value_inet_pton_26 >= 1)
                                  {
                                    pref_gateway = tmp_ip_holder.s_addr;
                                    if(!(curr_gateway == ((struct gw_node *)NULL)))
                                      del_default_route();

                                  }

                                  else
                                    debug_output((signed char)3, "Unix socket: rejected new preferred gw (%s) - invalid IP specified\n", buff + (signed long int)2);
                                }

                                dprintf(unix_listen__1__unix_client->sock, "EOD\n");
                              }

                              else
                                if((signed int)buff[0l] == 121)
                                {
                                  dprintf(unix_listen__1__unix_client->sock, "%s", prog_name);
                                  if((signed int)routing_class >= 1)
                                    dprintf(unix_listen__1__unix_client->sock, " -r %i", routing_class);

                                  if(pref_gateway >= 1u)
                                  {
                                    addr_to_string(pref_gateway, str, (signed int)sizeof(char [16l]) /*16ul*/ );
                                    dprintf(unix_listen__1__unix_client->sock, " -p %s", (const void *)str);
                                  }

                                  if((signed int)gateway_class >= 1)
                                  {
                                    get_gw_speeds(gateway_class, &download_speed, &upload_speed);
                                    dprintf(unix_listen__1__unix_client->sock, " -g %i%s/%i%s", download_speed > 2048 ? download_speed / 1024 : download_speed, download_speed > 2048 ? "MBit" : "KBit", upload_speed > 2048 ? upload_speed / 1024 : upload_speed, upload_speed > 2048 ? "MBit" : "KBit");
                                  }

                                  debug_pos = (&hna_list)->next;
                                  for( ; !(debug_pos == (struct list_head *)&hna_list); debug_pos = debug_pos->next)
                                  {
                                    hna_local_entry = (struct hna_local_entry *)((char *)debug_pos - (signed long int)(unsigned long int)&((struct hna_local_entry *)0)->list);
                                    addr_to_string(hna_local_entry->addr, str, (signed int)sizeof(char [16l]) /*16ul*/ );
                                    dprintf(unix_listen__1__unix_client->sock, " -a %s/%i", (const void *)str, hna_local_entry->netmask);
                                  }
                                  if(!((signed int)debug_level == 0))
                                    dprintf(unix_listen__1__unix_client->sock, " -d %i", debug_level);

                                  if(!((signed int)originator_interval == 1000))
                                    dprintf(unix_listen__1__unix_client->sock, " -o %i", originator_interval);

                                  if(!(vis_if.sock == 0))
                                  {
                                    addr_to_string(vis_if.addr.sin_addr.s_addr, str, (signed int)sizeof(char [16l]) /*16ul*/ );
                                    dprintf(unix_listen__1__unix_client->sock, " -s %s", (const void *)str);
                                  }

                                  if(!(policy_routing_script == ((char *)NULL)))
                                    dprintf(unix_listen__1__unix_client->sock, " --policy-routing-script %s", policy_routing_script);

                                  if(!((signed int)hop_penalty == 5))
                                    dprintf(unix_listen__1__unix_client->sock, " --hop-penalty %i", hop_penalty);

                                  if(aggregation_enabled == 0)
                                    dprintf(unix_listen__1__unix_client->sock, " --disable-aggregation");

                                  if(!(purge_timeout == 200000u))
                                    dprintf(unix_listen__1__unix_client->sock, " --purge-timeout %u", purge_timeout);

                                  debug_pos = (&if_list)->next;
                                  for( ; !(debug_pos == (struct list_head *)&if_list); debug_pos = debug_pos->next)
                                  {
                                    batman_if = (struct batman_if *)((char *)debug_pos - (signed long int)(unsigned long int)&((struct batman_if *)0)->list);
                                    dprintf(unix_listen__1__unix_client->sock, " %s", batman_if->dev);
                                  }
                                  dprintf(unix_listen__1__unix_client->sock, "\nEOD\n");
                                }

              prev_list_head_unix = &unix_listen__1__unix_client->list;
            }

            else
            {
              if(!(status >= 0))
              {
                return_value___errno_location_27=__errno_location();
                return_value_strerror_28=strerror(*return_value___errno_location_27);
                debug_output((signed char)0, "Error - can't read unix message: %s\n", return_value_strerror_28);
              }

              if(!((signed int)unix_listen__1__unix_client->debug_level == 0))
              {
                prev_list_head = (struct list_head *)debug_clients.fd_list[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)];
                signed int return_value_pthread_mutex_lock_31;
                return_value_pthread_mutex_lock_31=pthread_mutex_lock((union anonymous_16 *)debug_clients.mutex[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)]);
                if(!(return_value_pthread_mutex_lock_31 == 0))
                {
                  return_value___errno_location_29=__errno_location();
                  return_value_strerror_30=strerror(*return_value___errno_location_29);
                  debug_output((signed char)0, "Error - could not lock mutex (unix_listen => 3): %s \n", return_value_strerror_30);
                }

                debug_pos = ((struct list_head *)debug_clients.fd_list[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)])->next;
                debug_pos_tmp = debug_pos->next;
                for( ; !(debug_pos == (struct list_head *)debug_clients.fd_list[(signed long int)((signed int)unix_listen__1__unix_client->debug_level + -1)]); debug_pos_tmp = debug_pos->next)
                {
                  debug_level_info = (struct debug_level_info *)((char *)debug_pos - (signed long int)(unsigned long int)&((struct debug_level_info *)0)->list);
                  if(debug_level_info->fd == unix_listen__1__unix_client->sock)
                  {
                    list_del(prev_list_head, debug_pos, (struct list_head_first *)debug_clients.fd_list[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)]);
                    debug_clients.clients_num[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)] = debug_clients.clients_num[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)] - 1;
                    debugFree((void *)debug_pos, 1202);
                    break;
                  }

                  prev_list_head = &debug_level_info->list;
                  debug_pos = debug_pos_tmp;
                }
                signed int return_value_pthread_mutex_unlock_34;
                return_value_pthread_mutex_unlock_34=pthread_mutex_unlock((union anonymous_16 *)debug_clients.mutex[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)]);
                if(!(return_value_pthread_mutex_unlock_34 == 0))
                {
                  return_value___errno_location_32=__errno_location();
                  return_value_strerror_33=strerror(*return_value___errno_location_32);
                  debug_output((signed char)0, "Error - could not unlock mutex (unix_listen => 3): %s \n", return_value_strerror_33);
                }

              }

              debug_output((signed char)3, "Unix client closed connection ...\n");
              (&wait_sockets)->fds_bits[(signed long int)(unix_listen__1__unix_client->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wait_sockets)->fds_bits[(signed long int)(unix_listen__1__unix_client->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << unix_listen__1__unix_client->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
              close(unix_listen__1__unix_client->sock);
              list_del(prev_list_head_unix, list_pos, &unix_if.client_list);
              debugFree((void *)list_pos, 1203);
            }
          }

          else
            if(!(max_sock >= unix_listen__1__unix_client->sock))
              max_sock = unix_listen__1__unix_client->sock;

          list_pos = unix_pos_tmp;
        }
      }
    }

    else
      if(!((signed int)res >= 0))
      {
        return_value___errno_location_37=__errno_location();
        if(!(*return_value___errno_location_37 == 4))
        {
          signed int *return_value___errno_location_35;
          return_value___errno_location_35=__errno_location();
          char *return_value_strerror_36;
          return_value_strerror_36=strerror(*return_value___errno_location_35);
          debug_output((signed char)0, "Error - can't select (unix_listen): %s\n", return_value_strerror_36);
          break;
        }

      }

  }
  while((_Bool)1);
  list_pos = (&unix_if.client_list)->next;
  unix_pos_tmp = list_pos->next;
  signed int *return_value___errno_location_38;
  char *return_value_strerror_39;
  signed int *return_value___errno_location_41;
  char *return_value_strerror_42;
  for( ; !(list_pos == (struct list_head *)&unix_if.client_list); unix_pos_tmp = list_pos->next)
  {
    unix_listen__1__unix_client = (struct unix_client *)((char *)list_pos - (signed long int)(unsigned long int)&((struct unix_client *)0)->list);
    if(!((signed int)unix_listen__1__unix_client->debug_level == 0))
    {
      prev_list_head = (struct list_head *)debug_clients.fd_list[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)];
      signed int return_value_pthread_mutex_lock_40;
      return_value_pthread_mutex_lock_40=pthread_mutex_lock((union anonymous_16 *)debug_clients.mutex[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)]);
      if(!(return_value_pthread_mutex_lock_40 == 0))
      {
        return_value___errno_location_38=__errno_location();
        return_value_strerror_39=strerror(*return_value___errno_location_38);
        debug_output((signed char)0, "Error - could not lock mutex (unix_listen => 4): %s \n", return_value_strerror_39);
      }

      debug_pos = ((struct list_head *)debug_clients.fd_list[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)])->next;
      debug_pos_tmp = debug_pos->next;
      for( ; !(debug_pos == (struct list_head *)debug_clients.fd_list[(signed long int)((signed int)unix_listen__1__unix_client->debug_level + -1)]); debug_pos_tmp = debug_pos->next)
      {
        debug_level_info = (struct debug_level_info *)((char *)debug_pos - (signed long int)(unsigned long int)&((struct debug_level_info *)0)->list);
        if(debug_level_info->fd == unix_listen__1__unix_client->sock)
        {
          list_del(prev_list_head, debug_pos, (struct list_head_first *)debug_clients.fd_list[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)]);
          debug_clients.clients_num[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)] = debug_clients.clients_num[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)] - 1;
          debugFree((void *)debug_pos, 1204);
          break;
        }

        prev_list_head = &debug_level_info->list;
        debug_pos = debug_pos_tmp;
      }
      signed int return_value_pthread_mutex_unlock_43;
      return_value_pthread_mutex_unlock_43=pthread_mutex_unlock((union anonymous_16 *)debug_clients.mutex[(signed long int)((signed int)unix_listen__1__unix_client->debug_level - 1)]);
      if(!(return_value_pthread_mutex_unlock_43 == 0))
      {
        return_value___errno_location_41=__errno_location();
        return_value_strerror_42=strerror(*return_value___errno_location_41);
        debug_output((signed char)0, "Error - could not unlock mutex (unix_listen => 4): %s \n", return_value_strerror_42);
      }

    }

    list_del((struct list_head *)&unix_if.client_list, list_pos, &unix_if.client_list);
    debugFree((void *)list_pos, 1205);
    list_pos = unix_pos_tmp;
  }
  return (void *)0;
}

// update_gw_list
// file batman.c line 422
void update_gw_list(struct orig_node *orig_node, unsigned char new_gwflags, unsigned short int gw_port)
{
  struct list_head *gw_pos;
  struct list_head *gw_pos_tmp;
  struct gw_node *gw_node;
  char orig_str[16l];
  signed int download_speed;
  signed int upload_speed;
  prof_start(2);
  gw_pos = (&gw_list)->next;
  gw_pos_tmp = gw_pos->next;
  for( ; !(gw_pos == (struct list_head *)&gw_list); gw_pos_tmp = gw_pos->next)
  {
    gw_node = (struct gw_node *)((char *)gw_pos - (signed long int)(unsigned long int)&((struct gw_node *)0)->list);
    if(gw_node->orig_node == orig_node)
    {
      addr_to_string(gw_node->orig_node->orig, orig_str, 16);
      debug_output((signed char)3, "Gateway class of originator %s changed from %i to %i\n", (const void *)orig_str, gw_node->orig_node->gwflags, new_gwflags);
      if((signed int)new_gwflags == 0)
      {
        gw_node->deleted=get_time_msec();
        gw_node->orig_node->gwflags = new_gwflags;
        debug_output((signed char)3, "Gateway %s removed from gateway list\n", (const void *)orig_str);
        if(gw_node == curr_gateway)
          choose_gw();

      }

      else
      {
        gw_node->deleted = (unsigned int)0;
        gw_node->orig_node->gwflags = new_gwflags;
      }
      prof_stop(2);
      goto __CPROVER_DUMP_L8;
    }

    gw_pos = gw_pos_tmp;
  }
  addr_to_string(orig_node->orig, orig_str, 16);
  get_gw_speeds(new_gwflags, &download_speed, &upload_speed);
  debug_output((signed char)3, "Found new gateway %s -> class: %i - %i%s/%i%s\n", (const void *)orig_str, new_gwflags, download_speed > 2048 ? download_speed / 1024 : download_speed, download_speed > 2048 ? "MBit" : "KBit", upload_speed > 2048 ? upload_speed / 1024 : upload_speed, upload_speed > 2048 ? "MBit" : "KBit");
  void *return_value_debugMalloc_1;
  return_value_debugMalloc_1=debugMalloc((unsigned int)sizeof(struct gw_node) /*32ul*/ , 103);
  gw_node = (struct gw_node *)return_value_debugMalloc_1;
  memset((void *)gw_node, 0, sizeof(struct gw_node) /*32ul*/ );
  do
    (&gw_node->list)->next = &gw_node->list;
  while((_Bool)0);
  gw_node->orig_node = orig_node;
  gw_node->gw_port = gw_port;
  gw_node->last_failure=get_time_msec();
  list_add_tail(&gw_node->list, &gw_list);
  prof_stop(2);

__CPROVER_DUMP_L8:
  ;
}

// update_internal_clock
// file posix/posix.c line 96
static void update_internal_clock(void)
{
  signed long int current_clock_tick;
  current_clock_tick=times_wrapper();
  batman_clock_ticks = batman_clock_ticks + (unsigned long int)(current_clock_tick - last_clock_tick);
  last_clock_tick = current_clock_tick;
}

// update_orig
// file originator.h line 32
void update_orig(struct orig_node *orig_node, struct bat_packet *in, unsigned int neigh, struct batman_if *if_incoming, unsigned char *hna_recv_buff, signed short int hna_buff_len, unsigned char is_duplicate, unsigned int curr_time)
{
  struct list_head *list_pos;
  struct gw_node *gw_node;
  struct neigh_node *neigh_node = (struct neigh_node *)(void *)0;
  struct neigh_node *tmp_neigh_node = (struct neigh_node *)(void *)0;
  struct neigh_node *best_neigh_node = (struct neigh_node *)(void *)0;
  unsigned char max_bcast_own = (unsigned char)0;
  unsigned char max_tq = (unsigned char)0;
  prof_start(5);
  debug_output((signed char)4, "update_originator(): Searching and updating originator entry of received packet,  \n");
  list_pos = (&orig_node->neigh_list)->next;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  for( ; !(list_pos == (struct list_head *)&orig_node->neigh_list); list_pos = list_pos->next)
  {
    tmp_neigh_node = (struct neigh_node *)((char *)list_pos - (signed long int)(unsigned long int)&((struct neigh_node *)0)->list);
    if(tmp_neigh_node->addr == neigh)
      tmp_if_expr_5 = tmp_neigh_node->if_incoming == if_incoming ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
      neigh_node = tmp_neigh_node;

    else
    {
      if(is_duplicate == 0)
      {
        ring_buffer_set(tmp_neigh_node->tq_recv, &tmp_neigh_node->tq_index, (unsigned char)0);
        tmp_neigh_node->tq_avg=ring_buffer_avg(tmp_neigh_node->tq_recv);
      }

      if(!((signed int)max_tq >= (signed int)tmp_neigh_node->tq_avg))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        if(tmp_neigh_node->tq_avg == max_tq)
          tmp_if_expr_1 = (signed int)tmp_neigh_node->orig_node->bcast_own_sum[(signed long int)if_incoming->if_num] > (signed int)max_bcast_own ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        if(orig_node->router == tmp_neigh_node)
          tmp_if_expr_3 = tmp_neigh_node->tq_avg == max_tq ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
      {
        max_tq = tmp_neigh_node->tq_avg;
        max_bcast_own = tmp_neigh_node->orig_node->bcast_own_sum[(signed long int)if_incoming->if_num];
        best_neigh_node = tmp_neigh_node;
      }

    }
  }
  if(neigh_node == ((struct neigh_node *)NULL))
  {
    struct orig_node *return_value_get_orig_node_6;
    return_value_get_orig_node_6=get_orig_node(neigh);
    neigh_node=create_neighbor(orig_node, return_value_get_orig_node_6, neigh, if_incoming);
  }

  else
    debug_output((signed char)4, "Updating existing last-hop neighbour of originator\n");
  neigh_node->last_valid = curr_time;
  ring_buffer_set(neigh_node->tq_recv, &neigh_node->tq_index, in->tq);
  neigh_node->tq_avg=ring_buffer_avg(neigh_node->tq_recv);
  if(is_duplicate == 0)
  {
    orig_node->last_ttl = in->ttl;
    neigh_node->last_ttl = in->ttl;
  }

  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  if(!((signed int)max_tq >= (signed int)neigh_node->tq_avg))
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    if(neigh_node->tq_avg == max_tq)
      tmp_if_expr_7 = (signed int)neigh_node->orig_node->bcast_own_sum[(signed long int)if_incoming->if_num] > (signed int)max_bcast_own ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_7 = (_Bool)0;
    tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  if(tmp_if_expr_8)
    tmp_if_expr_10 = (_Bool)1;

  else
  {
    if(orig_node->router == neigh_node)
      tmp_if_expr_9 = neigh_node->tq_avg == max_tq ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_9 = (_Bool)0;
    tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_10)
    best_neigh_node = neigh_node;

  update_routes(orig_node, best_neigh_node, hna_recv_buff, hna_buff_len);
  if(!(orig_node->gwflags == in->gwflags))
    update_gw_list(orig_node, in->gwflags, in->gwport);

  orig_node->gwflags = in->gwflags;
  hna_global_check_tq(orig_node);
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_11;
  if((signed int)routing_class >= 3)
  {
    if(!((signed int)orig_node->gwflags == 0))
    {
      if(!(curr_gateway == ((struct gw_node *)NULL)))
      {
        if(!(curr_gateway->orig_node == orig_node))
        {
          if(pref_gateway == 0u)
            tmp_if_expr_12 = (signed int)orig_node->router->tq_avg > (signed int)curr_gateway->orig_node->router->tq_avg ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_12 = (_Bool)0;
          if(tmp_if_expr_12)
            tmp_if_expr_13 = (_Bool)1;

          else
            tmp_if_expr_13 = pref_gateway == orig_node->orig ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_13)
          {
            if(pref_gateway == orig_node->orig || (signed int)routing_class == 3)
              tmp_if_expr_11 = (_Bool)1;

            else
              tmp_if_expr_11 = (signed int)orig_node->router->tq_avg - (signed int)curr_gateway->orig_node->router->tq_avg >= (signed int)routing_class ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_11)
            {
              gw_node = (struct gw_node *)(void *)0;
              list_pos = (&gw_list)->next;
              for( ; !(list_pos == (struct list_head *)&gw_list); list_pos = list_pos->next)
              {
                gw_node = (struct gw_node *)((char *)list_pos - (signed long int)(unsigned long int)&((struct gw_node *)0)->list);
                if(gw_node->orig_node == orig_node)
                  break;

                gw_node = (struct gw_node *)(void *)0;
              }
              if(!(gw_node == ((struct gw_node *)NULL)))
              {
                if((signed int)curr_time + -(30000 + (signed int)gw_node->last_failure) >= 1)
                {
                  debug_output((signed char)3, "Gateway client - restart gateway selection: better gateway found (tq curr: %i, tq new: %i) \n", curr_gateway->orig_node->router->tq_avg, orig_node->router->tq_avg);
                  del_default_route();
                }

              }

            }

          }

        }

      }

    }

  }

  prof_stop(5);
}

// update_routes
// file batman.c line 344
void update_routes(struct orig_node *orig_node, struct neigh_node *neigh_node, unsigned char *hna_recv_buff, signed short int hna_buff_len)
{
  char orig_str[16l];
  char next_str[16l];
  struct neigh_node *old_router;
  prof_start(1);
  debug_output((signed char)4, "update_routes() \n");
  _Bool tmp_if_expr_1;
  if(!(orig_node == ((struct orig_node *)NULL)))
    tmp_if_expr_1 = orig_node->router != neigh_node ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    old_router = orig_node->router;
    if(!(neigh_node == ((struct neigh_node *)NULL)) && !(orig_node == ((struct orig_node *)NULL)))
    {
      addr_to_string(orig_node->orig, orig_str, 16);
      addr_to_string(neigh_node->addr, next_str, 16);
      debug_output((signed char)4, "Route to %s via %s\n", (const void *)orig_str, (const void *)next_str);
    }

    if(orig_node->router == ((struct neigh_node *)NULL) && !(neigh_node == ((struct neigh_node *)NULL)))
    {
      debug_output((signed char)4, "Adding new route\n");
      add_del_route(orig_node->orig, (unsigned char)32, neigh_node->addr, neigh_node->if_incoming->addr.sin_addr.s_addr, neigh_node->if_incoming->if_index, neigh_node->if_incoming->dev, (unsigned char)66, (signed char)0, (signed char)0);
      orig_node->batman_if = neigh_node->if_incoming;
      orig_node->router = neigh_node;
      hna_global_add(orig_node, hna_recv_buff, hna_buff_len);
    }

    else
      if(neigh_node == ((struct neigh_node *)NULL) && !(orig_node->router == ((struct neigh_node *)NULL)))
      {
        debug_output((signed char)4, "Deleting previous route\n");
        hna_global_del(orig_node);
        add_del_route(orig_node->orig, (unsigned char)32, orig_node->router->addr, (unsigned int)0, orig_node->batman_if->if_index, orig_node->batman_if->dev, (unsigned char)66, (signed char)0, (signed char)1);
      }

      else
      {
        debug_output((signed char)4, "Route changed\n");
        add_del_route(orig_node->orig, (unsigned char)32, neigh_node->addr, neigh_node->if_incoming->addr.sin_addr.s_addr, neigh_node->if_incoming->if_index, neigh_node->if_incoming->dev, (unsigned char)66, (signed char)0, (signed char)0);
        add_del_route(orig_node->orig, (unsigned char)32, orig_node->router->addr, (unsigned int)0, orig_node->batman_if->if_index, orig_node->batman_if->dev, (unsigned char)66, (signed char)0, (signed char)1);
        orig_node->batman_if = neigh_node->if_incoming;
        orig_node->router = neigh_node;
        hna_global_update(orig_node, hna_recv_buff, hna_buff_len, old_router);
      }
    orig_node->router = neigh_node;
  }

  else
    if(!(orig_node == ((struct orig_node *)NULL)))
      hna_global_update(orig_node, hna_recv_buff, hna_buff_len, orig_node->router);

  prof_stop(1);
}

// usage
// file batman.c line 125
void usage(void)
{
  fprintf(stderr, "Usage: batman [options] interface [interface interface]\n");
  fprintf(stderr, "       -a add announced network(s)\n");
  fprintf(stderr, "       -A delete announced network(s)\n");
  fprintf(stderr, "       -b run connection in batch mode\n");
  fprintf(stderr, "       -c connect via unix socket\n");
  fprintf(stderr, "       -d debug level\n");
  fprintf(stderr, "       -g gateway class\n");
  fprintf(stderr, "       -h this help\n");
  fprintf(stderr, "       -H verbose help\n");
  fprintf(stderr, "       -i internal options output\n");
  fprintf(stderr, "       -o originator interval in ms\n");
  fprintf(stderr, "       -p preferred gateway\n");
  fprintf(stderr, "       -r routing class\n");
  fprintf(stderr, "       -s visualization server\n");
  fprintf(stderr, "       -v print version\n");
  fprintf(stderr, "       --policy-routing-script\n");
  fprintf(stderr, "       --disable-client-nat\n");
}

// use_gateway_module
// file linux/kernel.c line 172
signed int use_gateway_module(void)
{
  signed int fd;
  fd=open("/dev/batgat", 01);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    debug_output((signed char)0, "Warning - batgat kernel modul interface (/dev/batgat) not usable: %s\nThis may decrease the performance of batman!\n", return_value_strerror_2);
    return -1;
  }

  return fd;
}

// verbose_usage
// file batman.c line 148
void verbose_usage(void)
{
  fprintf(stderr, "Usage: batman [options] interface [interface interface]\n\n");
  fprintf(stderr, "       -a add announced network(s)\n");
  fprintf(stderr, "          network/netmask is expected\n");
  fprintf(stderr, "       -A delete announced network(s)\n");
  fprintf(stderr, "          network/netmask is expected\n");
  fprintf(stderr, "       -b run connection in batch mode\n");
  fprintf(stderr, "       -c connect to running batmand via unix socket\n");
  fprintf(stderr, "       -d debug level\n");
  fprintf(stderr, "          default:         0 -> debug disabled\n");
  fprintf(stderr, "          allowed values:  1 -> list neighbours\n");
  fprintf(stderr, "                           2 -> list gateways\n");
  fprintf(stderr, "                           3 -> observe batman\n");
  fprintf(stderr, "                           4 -> observe batman (very verbose)\n\n");
  if((signed int)debug_level_max == 5)
    fprintf(stderr, "                           5 -> memory debug / cpu usage\n\n");

  fprintf(stderr, "       -g gateway class\n");
  fprintf(stderr, "          default:         0 -> gateway disabled\n");
  fprintf(stderr, "          allowed values:  download/upload in kbit/s (default) or mbit/s\n");
  fprintf(stderr, "          note:            batmand will choose the nearest gateway class representing your speeds\n");
  fprintf(stderr, "                           and therefore accepts all given values\n");
  fprintf(stderr, "                           e.g. 5000\n");
  fprintf(stderr, "                                5000kbit\n");
  fprintf(stderr, "                                5mbit\n");
  fprintf(stderr, "                                5mbit/1024\n");
  fprintf(stderr, "                                5mbit/1024kbit\n");
  fprintf(stderr, "                                5mbit/1mbit\n");
  fprintf(stderr, "       -h shorter help\n");
  fprintf(stderr, "       -H this help\n");
  fprintf(stderr, "       -i gives information about all internal options\n");
  fprintf(stderr, "       -o originator interval in ms\n");
  fprintf(stderr, "          default: 1000, allowed values: >0\n\n");
  fprintf(stderr, "       -p preferred gateway\n");
  fprintf(stderr, "          default: none, allowed values: IP\n\n");
  fprintf(stderr, "       -r routing class (only needed if gateway class = 0)\n");
  fprintf(stderr, "          default:         0  -> set no default route\n");
  fprintf(stderr, "          allowed values:  1  -> use fast internet connection (gw_flags * TQ)\n");
  fprintf(stderr, "                           2  -> use stable internet connection (TQ)\n");
  fprintf(stderr, "                           3  -> use fast-switch internet connection (TQ but switch as soon as a better gateway appears)\n\n");
  fprintf(stderr, "                           XX -> use late-switch internet connection (TQ but switch as soon as a gateway appears which is XX TQ better)\n\n");
  fprintf(stderr, "       -s visualization server\n");
  fprintf(stderr, "          default: none, allowed values: IP\n\n");
  fprintf(stderr, "       -v print version\n");
  fprintf(stderr, "       --policy-routing-script send all routing table changes to the script\n");
  fprintf(stderr, "       --disable-client-nat deactivates the 'set tunnel NAT rules' feature (useful for half tunneling)\n");
}

