// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_0;

// tag-#anon#ST[ARR32{U8}_U8_'Key'||ARR32{U8}_U8_'V'||U32'reseed_counter'|]
// file ../libcperciva/crypto/crypto_entropy.c line 20
struct anonymous_1;

// tag-#anon#ST[ARR8{U32}_U32_'state'||U64'count'||ARR64{U8}_U8_'buf'|]
// file ../libcperciva/alg/sha256.h line 23
struct anonymous_5;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_7;

// tag-#anon#ST[SYM#tag-#anon#ST[ARR8{U32}_U32_'state'||U64'count'||ARR64{U8}_U8_'buf'|]#'ictx'||SYM#tag-#anon#ST[ARR8{U32}_U32_'state'||U64'count'||ARR64{U8}_U8_'buf'|]#'octx'|]
// file ../libcperciva/alg/sha256.h line 55
struct anonymous_2;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'|]
// file /usr/include/netinet/in.h line 211
union anonymous;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_6;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_4;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_3;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-accept_cookie
// file ../libcperciva/network/network_accept.c line 11
struct accept_cookie;

// tag-accept_state
// file dispatch.c line 16
struct accept_state;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-aes_key_st
// file /usr/include/openssl/aes.h line 78
struct aes_key_st;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-conn_state
// file ../proto/proto_conn.c line 17
struct conn_state;

// tag-connect_cookie
// file ../libcperciva/network/network_connect.c line 15
struct connect_cookie;

// tag-crypto_aes_key
// file ../libcperciva/crypto/crypto_aes.h line 8
struct crypto_aes_key;

// tag-crypto_aes_key_aesni
// file ../libcperciva/crypto/crypto_aes_aesni.c line 15
struct crypto_aes_key_aesni;

// tag-crypto_aesctr
// file ../libcperciva/crypto/crypto_aesctr.h line 16
struct crypto_aesctr;

// tag-dnsthread_internal
// file ../lib/dnsthread/dnsthread.h line 8
struct dnsthread_internal;

// tag-elasticarray
// file ../libcperciva/datastruct/elasticarray.h line 20
struct elasticarray;

// tag-eventq
// file ../libcperciva/events/events_immediate.c line 10
struct eventq;

// tag-eventrec
// file ../libcperciva/events/events_internal.h line 7
struct eventrec;

// tag-handshake_cookie
// file ../proto/proto_handshake.c line 13
struct handshake_cookie;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-mpool_eventq_struct
// file ../libcperciva/events/events_immediate.c line 17
struct mpool_eventq_struct;

// tag-mpool_eventrec_struct
// file ../libcperciva/events/events.c line 17
struct mpool_eventrec_struct;

// tag-network_read_cookie
// file ../libcperciva/network/network_read.c line 15
struct network_read_cookie;

// tag-network_write_cookie
// file ../libcperciva/network/network_write.c line 33
struct network_write_cookie;

// tag-pipe_cookie
// file ../proto/proto_pipe.c line 15
struct pipe_cookie;

// tag-proto_keys
// file ../proto/proto_crypt.h line 9
struct proto_keys;

// tag-proto_secret
// file ../proto/proto_crypt.h line 10
struct proto_secret;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-ptrheap
// file ../libcperciva/datastruct/ptrheap.h line 19
struct ptrheap;

// tag-ptrlist_struct
// file ../libcperciva/datastruct/ptrheap.c line 7
struct ptrlist_struct;

// tag-resolve_cookie
// file ../lib/dnsthread/dnsthread.c line 39
struct resolve_cookie;

// tag-sock_addr
// file ../libcperciva/util/sock.h line 13
struct sock_addr;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/un.h line 29
struct sockaddr_un;

// tag-socketlist_struct
// file ../libcperciva/events/events_network.c line 19
struct socketlist_struct;

// tag-socketrec
// file ../libcperciva/events/events_network.c line 13
struct socketrec;

// tag-timerqueue
// file ../libcperciva/datastruct/timerqueue.h line 9
struct timerqueue;

// tag-timerrec
// file ../libcperciva/datastruct/timerqueue.c line 14
struct timerrec_0;

// tag-timerrec_link1
// file ../libcperciva/events/events_timer.c line 12
struct timerrec;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// AES_encrypt
// file /usr/include/openssl/aes.h line 100
void AES_encrypt(const unsigned char *, unsigned char *, const struct aes_key_st *);
// AES_set_encrypt_key
// file /usr/include/openssl/aes.h line 90
signed int AES_set_encrypt_key(const unsigned char *, const signed int, struct aes_key_st *);
// BN_CTX_free
// file /usr/include/openssl/bn.h line 426
void BN_CTX_free(struct bignum_ctx *);
// BN_CTX_new
// file /usr/include/openssl/bn.h line 422
struct bignum_ctx * BN_CTX_new(void);
// BN_add
// file /usr/include/openssl/bn.h line 448
signed int BN_add(struct bignum_st *, const struct bignum_st *, const struct bignum_st *);
// BN_bin2bn
// file /usr/include/openssl/bn.h line 441
struct bignum_st * BN_bin2bn(const unsigned char *, signed int, struct bignum_st *);
// BN_bn2bin
// file /usr/include/openssl/bn.h line 442
signed int BN_bn2bin(const struct bignum_st *, unsigned char *);
// BN_clear_free
// file /usr/include/openssl/bn.h line 438
void BN_clear_free(struct bignum_st *);
// BN_free
// file /usr/include/openssl/bn.h line 492
void BN_free(struct bignum_st *);
// BN_mod_exp
// file /usr/include/openssl/bn.h line 498
signed int BN_mod_exp(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *);
// BN_mod_mul
// file /usr/include/openssl/bn.h line 474
signed int BN_mod_mul(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *);
// BN_new
// file /usr/include/openssl/bn.h line 436
struct bignum_st * BN_new(void);
// BN_num_bits
// file /usr/include/openssl/bn.h line 434
signed int BN_num_bits(const struct bignum_st *);
// BN_set_word
// file /usr/include/openssl/bn.h line 488
signed int BN_set_word(struct bignum_st *, unsigned long int);
// BN_sub
// file /usr/include/openssl/bn.h line 445
signed int BN_sub(struct bignum_st *, const struct bignum_st *, const struct bignum_st *);
// ERR_error_string
// file /usr/include/openssl/err.h line 334
char * ERR_error_string(unsigned long int, char *);
// ERR_get_error
// file /usr/include/openssl/err.h line 321
unsigned long int ERR_get_error(void);
// PBKDF2_SHA256
// file ../libcperciva/alg/sha256.h line 92
void PBKDF2_SHA256(const unsigned char *passwd, unsigned long int passwdlen, const unsigned char *salt, unsigned long int saltlen, unsigned long int c, unsigned char *buf, unsigned long int dkLen);
// SHA256_Pad
// file ../libcperciva/alg/sha256.c line 175
static void SHA256_Pad(struct anonymous_5 *ctx);
// SHA256_Transform
// file ../libcperciva/alg/sha256.c line 74
static void SHA256_Transform(unsigned int *state, const unsigned char *block);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __get_cpuid
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/cpuid.h line 233
static inline signed int __get_cpuid(unsigned int __level, unsigned int *__eax, unsigned int *__ebx, unsigned int *__ecx, unsigned int *__edx);
// __get_cpuid_max
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/cpuid.h line 178
static inline unsigned int __get_cpuid_max(unsigned int __ext, unsigned int *__sig);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// _mm_aesenc_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/wmmintrin.h line 61
static inline __gcc_v2di _mm_aesenc_si128(__gcc_v2di __X, __gcc_v2di __Y);
// _mm_aesenclast_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/wmmintrin.h line 69
static inline __gcc_v2di _mm_aesenclast_si128(__gcc_v2di __X, __gcc_v2di __Y);
// _mm_loadu_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 696
static inline __gcc_v2di _mm_loadu_si128(const __gcc_v2di *__P);
// _mm_storeu_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 714
static inline void _mm_storeu_si128(__gcc_v2di *__P, __gcc_v2di __B);
// _mm_xor_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1286
static inline __gcc_v2di _mm_xor_si128(__gcc_v2di __A, __gcc_v2di __B);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// aesnitest
// file ../libcperciva/crypto/crypto_aes.c line 26
static signed int aesnitest(unsigned char *ptext, unsigned char *key, unsigned long int keylen);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// be32dec_vect
// file ../libcperciva/alg/sha256.c line 32
static void be32dec_vect(unsigned int *dst, const unsigned char *src, unsigned long int len);
// be32enc_vect
// file ../libcperciva/alg/sha256.c line 15
static void be32enc_vect(unsigned char *dst, const unsigned int *src, unsigned long int len);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// blinded_modexp
// file ../libcperciva/crypto/crypto_dh.c line 36
static signed int blinded_modexp(unsigned char *r, struct bignum_st *a, const unsigned char *priv);
// callback_accept
// file ../libcperciva/network/network_accept.c line 19
static signed int callback_accept(void *cookie);
// callback_buf
// file ../libcperciva/network/network_read.c line 43
static signed int callback_buf(void *cookie);
// callback_buf_link1
// file ../libcperciva/network/network_write.c line 61
static signed int callback_buf_link1(void *cookie_link1);
// callback_conndied
// file dispatch.c line 93
static signed int callback_conndied(void *cookie);
// callback_connect
// file ../libcperciva/network/network_connect.c line 65
static signed int callback_connect(void *cookie);
// callback_connect_done
// file ../proto/proto_conn.c line 231
static signed int callback_connect_done(void *cookie, signed int t);
// callback_connect_timeout
// file ../proto/proto_conn.c line 274
static signed int callback_connect_timeout(void *cookie);
// callback_dh_read
// file ../proto/proto_handshake.c line 206
static signed int callback_dh_read(void *cookie, signed long int len);
// callback_dh_write
// file ../proto/proto_handshake.c line 259
static signed int callback_dh_write(void *cookie, signed long int len);
// callback_gotconn
// file dispatch.c line 106
static signed int callback_gotconn(void *cookie, signed int s);
// callback_handshake_done
// file ../proto/proto_conn.c line 293
static signed int callback_handshake_done(void *cookie, struct proto_keys *f, struct proto_keys *r);
// callback_handshake_timeout
// file ../proto/proto_conn.c line 335
static signed int callback_handshake_timeout(void *cookie);
// callback_nonce_read
// file ../proto/proto_handshake.c line 145
static signed int callback_nonce_read(void *cookie, signed long int len);
// callback_nonce_write
// file ../proto/proto_handshake.c line 124
static signed int callback_nonce_write(void *cookie, signed long int len);
// callback_pipe_read
// file ../proto/proto_pipe.c line 83
static signed int callback_pipe_read(void *cookie, signed long int len);
// callback_pipe_write
// file ../proto/proto_pipe.c line 148
static signed int callback_pipe_write(void *cookie, signed long int len);
// callback_pipestatus
// file ../proto/proto_conn.c line 348
static signed int callback_pipestatus(void *cookie);
// callback_resolve
// file dispatch.c line 38
static signed int callback_resolve(void *cookie, struct sock_addr **sas);
// callback_resolve_link1
// file ../lib/dnsthread/dnsthread.c line 447
static signed int callback_resolve_link1(void *cookie_link1, struct sock_addr **sas_link1);
// callback_resolveagain
// file dispatch.c line 66
static signed int callback_resolveagain(void *cookie);
// callback_resolveone
// file ../lib/dnsthread/dnsthread.c line 303
static signed int callback_resolveone(void *cookie);
// callback_resolveone::1::callback_object
//
signed int callback_object(void *, struct sock_addr **);
// callback_timeo
// file ../libcperciva/network/network_connect.c line 100
static signed int callback_timeo(void *cookie);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// compar
// file ../libcperciva/datastruct/timerqueue.c line 43
static signed int compar(void *cookie, const void *x, const void *y);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// cpusupport_x86_aesni
// file ../libcperciva/cpusupport/cpusupport.h line 61
static inline signed int cpusupport_x86_aesni(void);
// cpusupport_x86_aesni_detect
// file ../libcperciva/cpusupport/cpusupport_x86_aesni.c line 9
signed int cpusupport_x86_aesni_detect(void);
// crypto_aes_encrypt_block
// file ../libcperciva/crypto/crypto_aes.c line 131
void crypto_aes_encrypt_block(const unsigned char *in, unsigned char *out, struct crypto_aes_key *key);
// crypto_aes_encrypt_block_aesni
// file ../libcperciva/crypto/crypto_aes_aesni.h line 23
void crypto_aes_encrypt_block_aesni(const unsigned char *in, unsigned char *out, const void *key);
// crypto_aes_key_expand
// file ../libcperciva/crypto/crypto_aes.h line 15
struct crypto_aes_key * crypto_aes_key_expand(const unsigned char *key, unsigned long int len);
// crypto_aes_key_expand_128_aesni
// file ../libcperciva/crypto/crypto_aes_aesni.c line 38
static void crypto_aes_key_expand_128_aesni(const unsigned char *key, __gcc_v2di *rkeys);
// crypto_aes_key_expand_256_aesni
// file ../libcperciva/crypto/crypto_aes_aesni.c line 92
static void crypto_aes_key_expand_256_aesni(const unsigned char *key, __gcc_v2di *rkeys);
// crypto_aes_key_expand_aesni
// file ../libcperciva/crypto/crypto_aes_aesni.h line 14
void * crypto_aes_key_expand_aesni(const unsigned char *key, unsigned long int len);
// crypto_aes_key_free
// file ../libcperciva/crypto/crypto_aes.h line 29
void crypto_aes_key_free(struct crypto_aes_key *key);
// crypto_aes_key_free_aesni
// file ../libcperciva/crypto/crypto_aes_aesni.h line 29
void crypto_aes_key_free_aesni(void *key);
// crypto_aesctr_buf
// file ../libcperciva/crypto/crypto_aesctr.h line 38
void crypto_aesctr_buf(struct crypto_aes_key *key, unsigned long int nonce, const unsigned char *inbuf, unsigned char *outbuf, unsigned long int buflen);
// crypto_aesctr_free
// file ../libcperciva/crypto/crypto_aesctr.c line 83
void crypto_aesctr_free(struct crypto_aesctr *stream);
// crypto_aesctr_init
// file ../libcperciva/crypto/crypto_aesctr.c line 23
struct crypto_aesctr * crypto_aesctr_init(struct crypto_aes_key *key, unsigned long int nonce);
// crypto_aesctr_stream
// file ../libcperciva/crypto/crypto_aesctr.c line 51
void crypto_aesctr_stream(struct crypto_aesctr *stream, const unsigned char *inbuf, unsigned char *outbuf, unsigned long int buflen);
// crypto_dh_compute
// file ../libcperciva/crypto/crypto_dh.h line 33
signed int crypto_dh_compute(const unsigned char *pub, const unsigned char *priv, unsigned char *key);
// crypto_dh_generate
// file ../libcperciva/crypto/crypto_dh.h line 24
signed int crypto_dh_generate(unsigned char *pub, unsigned char *priv);
// crypto_dh_generate_pub
// file ../libcperciva/crypto/crypto_dh.c line 184
signed int crypto_dh_generate_pub(unsigned char *pub, const unsigned char *priv);
// crypto_dh_sanitycheck
// file ../libcperciva/crypto/crypto_dh.h line 41
signed int crypto_dh_sanitycheck(const unsigned char *pub);
// crypto_entropy_read
// file ../libcperciva/crypto/crypto_entropy.h line 12
signed int crypto_entropy_read(unsigned char *buf, unsigned long int buflen);
// crypto_verify_bytes
// file ../libcperciva/crypto/crypto_verify_bytes.h line 12
unsigned char crypto_verify_bytes(const unsigned char *buf0, const unsigned char *buf1, unsigned long int len);
// daemonize
// file ../libcperciva/util/daemonize.h line 8
signed int daemonize(const char *spid);
// dhread
// file ../proto/proto_handshake.c line 188
static signed int dhread(struct handshake_cookie *H);
// dhwrite
// file ../proto/proto_handshake.c line 236
static signed int dhwrite(struct handshake_cookie *H);
// dispatch_accept
// file dispatch.h line 24
signed int dispatch_accept(signed int s, const char *tgt, double rtime, struct sock_addr **sas, signed int decr, signed int nofps, signed int requirefps, signed int nokeepalive, struct proto_secret *K, unsigned long int nconn_max, double timeo);
// dnsthread_kill
// file ../lib/dnsthread/dnsthread.h line 35
signed int dnsthread_kill(struct dnsthread_internal *T);
// dnsthread_resolve
// file ../lib/dnsthread/dnsthread.c line 414
signed int dnsthread_resolve(const char *addr, signed int (*callback)(void *, struct sock_addr **), void *cookie);
// dnsthread_resolve::callback_object
//
signed int callback_object(void *, struct sock_addr **);
// dnsthread_resolveone
// file ../lib/dnsthread/dnsthread.h line 26
signed int dnsthread_resolveone(struct dnsthread_internal *T, const char *addr, signed int (*callback)(void *, struct sock_addr **), void *cookie);
// dnsthread_resolveone::callback_object
//
signed int callback_object(void *, struct sock_addr **);
// dnsthread_spawn
// file ../lib/dnsthread/dnsthread.h line 15
struct dnsthread_internal * dnsthread_spawn(void);
// doaccept
// file dispatch.c line 76
static signed int doaccept(struct accept_state *A);
// docallback
// file ../libcperciva/network/network_connect.c line 30
static signed int docallback(void *cookie);
// docallback_link1
// file ../libcperciva/network/network_read.c line 27
static signed int docallback_link1(struct network_read_cookie *C, signed long int nbytes);
// docallback_link2
// file ../libcperciva/network/network_write.c line 45
static signed int docallback_link2(struct network_write_cookie *C_link1, signed long int nbytes_link1);
// doevent
// file ../libcperciva/events/events.c line 60
static inline signed int doevent(struct eventrec *r);
// dofailed
// file ../libcperciva/network/network_connect.c line 47
static signed int dofailed(struct connect_cookie *C);
// done
// file ../libcperciva/util/warnp.c line 14
static void done(void);
// dropconn
// file ../proto/proto_conn.c line 108
static signed int dropconn(struct conn_state *C);
// elasticarray_append
// file ../libcperciva/datastruct/elasticarray.c line 139
signed int elasticarray_append(struct elasticarray *EA, const void *buf, unsigned long int nrec, unsigned long int reclen);
// elasticarray_export
// file ../libcperciva/datastruct/elasticarray.c line 258
signed int elasticarray_export(struct elasticarray *EA, void **buf, unsigned long int *nrec, unsigned long int reclen);
// elasticarray_free
// file ../libcperciva/datastruct/elasticarray.c line 241
void elasticarray_free(struct elasticarray *EA);
// elasticarray_get
// file ../libcperciva/datastruct/elasticarray.c line 230
void * elasticarray_get(struct elasticarray *EA, unsigned long int pos, unsigned long int reclen);
// elasticarray_getsize
// file ../libcperciva/datastruct/elasticarray.c line 127
unsigned long int elasticarray_getsize(struct elasticarray *EA, unsigned long int reclen);
// elasticarray_init
// file ../libcperciva/datastruct/elasticarray.c line 65
struct elasticarray * elasticarray_init(unsigned long int nrec, unsigned long int reclen);
// elasticarray_resize
// file ../libcperciva/datastruct/elasticarray.c line 99
signed int elasticarray_resize(struct elasticarray *EA, unsigned long int nrec, unsigned long int reclen);
// elasticarray_shrink
// file ../libcperciva/datastruct/elasticarray.c line 177
void elasticarray_shrink(struct elasticarray *EA, unsigned long int nrec, unsigned long int reclen);
// elasticarray_truncate
// file ../libcperciva/datastruct/elasticarray.c line 203
signed int elasticarray_truncate(struct elasticarray *EA);
// entropy_read
// file ../libcperciva/util/entropy.c line 23
signed int entropy_read(unsigned char *buf, unsigned long int buflen);
// events_freerec
// file ../libcperciva/events/events_internal.h line 19
void events_freerec(struct eventrec *r);
// events_immediate_cancel
// file ../libcperciva/events/events_immediate.c line 88
void events_immediate_cancel(void *cookie);
// events_immediate_get
// file ../libcperciva/events/events_immediate.c line 119
struct eventrec * events_immediate_get(void);
// events_immediate_register
// file ../libcperciva/events/events_immediate.c line 41
void * events_immediate_register(signed int (*func)(void *), void *cookie, signed int prio);
// events_immediate_register::func_object
//
signed int func_object(void *);
// events_mkrec
// file ../libcperciva/events/events_internal.h line 13
struct eventrec * events_mkrec(signed int (*func)(void *), void *cookie);
// events_mkrec::func_object
//
signed int func_object(void *);
// events_network_cancel
// file ../libcperciva/events/events_network.c line 160
signed int events_network_cancel(signed int s, signed int op);
// events_network_get
// file ../libcperciva/events/events_network.c line 292
struct eventrec * events_network_get(void);
// events_network_register
// file ../libcperciva/events/events.h line 34
signed int events_network_register(signed int (*func)(void *), void *cookie, signed int s, signed int op);
// events_network_register::func_object
//
signed int func_object(void *);
// events_network_select
// file ../libcperciva/events/events_network.c line 234
signed int events_network_select(struct timeval *tv);
// events_network_selectstats
// file ../libcperciva/events/events_network_selectstats.c line 91
void events_network_selectstats(double *_N, double *_mu, double *_va, double *_max);
// events_network_selectstats_select
// file ../libcperciva/events/events_internal.h line 54
void events_network_selectstats_select(void);
// events_network_selectstats_startclock
// file ../libcperciva/events/events_internal.h line 41
void events_network_selectstats_startclock(void);
// events_network_selectstats_stopclock
// file ../libcperciva/events/events_internal.h line 47
void events_network_selectstats_stopclock(void);
// events_network_shutdown
// file ../libcperciva/events/events_network.c line 333
void events_network_shutdown(void);
// events_run
// file ../libcperciva/events/events.h line 89
signed int events_run(void);
// events_shutdown
// file ../libcperciva/events/events.c line 198
void events_shutdown(void);
// events_spin
// file ../libcperciva/events/events.c line 178
signed int events_spin(signed int *done);
// events_timer_cancel
// file ../libcperciva/events/events.h line 70
void events_timer_cancel(void *cookie);
// events_timer_get
// file ../libcperciva/events/events_timer.c line 222
signed int events_timer_get(struct eventrec **r);
// events_timer_min
// file ../libcperciva/events/events_timer.c line 160
signed int events_timer_min(struct timeval **timeo);
// events_timer_register
// file ../libcperciva/events/events_timer.c line 47
void * events_timer_register(signed int (*func)(void *), void *cookie, struct timeval *timeo);
// events_timer_register::func_object
//
signed int func_object(void *);
// events_timer_register_double
// file ../libcperciva/events/events.h line 63
void * events_timer_register_double(signed int (*func)(void *), void *cookie, double timeo);
// events_timer_register_double::func_object
//
signed int func_object(void *);
// events_timer_reset
// file ../libcperciva/events/events_timer.c line 133
signed int events_timer_reset(void *cookie);
// events_timer_shutdown
// file ../libcperciva/events/events_timer.c line 265
void events_timer_shutdown(void);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// generate
// file ../libcperciva/crypto/crypto_entropy.c line 149
static void generate(unsigned char *buf, unsigned long int buflen);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeout
// file ../libcperciva/events/events_timer.c line 22
static signed int gettimeout(struct timeval *tv, struct timeval *tdelta);
// gotnonces
// file ../proto/proto_handshake.c line 166
static signed int gotnonces(struct handshake_cookie *H);
// growsocketlist
// file ../libcperciva/events/events_network.c line 62
static signed int growsocketlist(unsigned long int nrec);
// handshakedone
// file ../proto/proto_handshake.c line 284
static signed int handshakedone(struct handshake_cookie *H);
// handshakefail
// file ../proto/proto_handshake.c line 43
static signed int handshakefail(struct handshake_cookie *H);
// heapify
// file ../libcperciva/datastruct/ptrheap.c line 81
static void heapify(struct ptrlist_struct *elems, unsigned long int i, unsigned long int N, signed int (*compar)(void *, const void *, const void *), void (*setreccookie)(void *, void *, unsigned long int), void *cookie);
// heapify::compar_object
//
signed int compar_object(void *, const void *, const void *);
// heapify::setreccookie_object
//
void setreccookie_object(void *, void *, unsigned long int);
// heapifyup
// file ../libcperciva/datastruct/ptrheap.c line 49
static void heapifyup(struct ptrlist_struct *elems, unsigned long int i, signed int (*compar)(void *, const void *, const void *), void (*setreccookie)(void *, void *, unsigned long int), void *cookie);
// heapifyup::compar_object
//
signed int compar_object(void *, const void *, const void *);
// heapifyup::setreccookie_object
//
void setreccookie_object(void *, void *, unsigned long int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// imalloc
// file ../libcperciva/util/imalloc.h line 13
static inline void * imalloc(unsigned long int nrec, unsigned long int reclen);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// initsocketlist
// file ../libcperciva/events/events_network.c line 34
static signed int initsocketlist(void);
// insecure_memzero
// file ../libcperciva/util/insecure_memzero.h line 27
static inline void insecure_memzero(volatile void *buf, unsigned long int len);
// insecure_memzero_link1
// file ../libcperciva/util/insecure_memzero.h line 27
static inline void insecure_memzero_link1(volatile void *buf_link1, unsigned long int len_link1);
// insecure_memzero_link2
// file ../libcperciva/util/insecure_memzero.h line 27
static inline void insecure_memzero_link2(volatile void *buf_link2, unsigned long int len_link2);
// insecure_memzero_link3
// file ../libcperciva/util/insecure_memzero.h line 27
static inline void insecure_memzero_link3(volatile void *buf_link3, unsigned long int len_link3);
// insecure_memzero_func
// file ../libcperciva/util/insecure_memzero.c line 8
static void insecure_memzero_func(volatile void *buf, unsigned long int len);
// insecure_memzero_ptr_object
//
void insecure_memzero_ptr_object(volatile void *, unsigned long int);
// instantiate
// file ../libcperciva/crypto/crypto_entropy.c line 45
static signed int instantiate(void);
// is_not_one
// file ../proto/proto_crypt.c line 157
static signed int is_not_one(const unsigned char *x, unsigned long int len);
// launchpipes
// file ../proto/proto_conn.c line 76
static signed int launchpipes(struct conn_state *C);
// libcperciva_HMAC_SHA256_Buf
// file ../libcperciva/alg/sha256.h line 85
void libcperciva_HMAC_SHA256_Buf(const void *K, unsigned long int Klen, const void *in, unsigned long int len, unsigned char *digest);
// libcperciva_HMAC_SHA256_Final
// file ../libcperciva/alg/sha256.h line 78
void libcperciva_HMAC_SHA256_Final(unsigned char *digest, struct anonymous_2 *ctx);
// libcperciva_HMAC_SHA256_Init
// file ../libcperciva/alg/sha256.h line 65
void libcperciva_HMAC_SHA256_Init(struct anonymous_2 *ctx, const void *_K, unsigned long int Klen);
// libcperciva_HMAC_SHA256_Update
// file ../libcperciva/alg/sha256.h line 71
void libcperciva_HMAC_SHA256_Update(struct anonymous_2 *ctx, const void *in, unsigned long int len);
// libcperciva_SHA256_Buf
// file ../libcperciva/alg/sha256.c line 283
void libcperciva_SHA256_Buf(const void *in, unsigned long int len, unsigned char *digest);
// libcperciva_SHA256_Final
// file ../libcperciva/alg/sha256.h line 46
void libcperciva_SHA256_Final(unsigned char *digest, struct anonymous_5 *ctx);
// libcperciva_SHA256_Init
// file ../libcperciva/alg/sha256.h line 33
void libcperciva_SHA256_Init(struct anonymous_5 *ctx);
// libcperciva_SHA256_Update
// file ../libcperciva/alg/sha256.h line 39
void libcperciva_SHA256_Update(struct anonymous_5 *ctx, const void *in, unsigned long int len);
// libcperciva_asprintf
// file ../libcperciva/util/asprintf.h line 14
signed int libcperciva_asprintf(char **ret, const char *format, ...);
// libcperciva_be32dec
// file ../libcperciva/util/sysendian.h line 38
static inline unsigned int libcperciva_be32dec(const void *pp);
// libcperciva_be32dec_link1
// file ../libcperciva/util/sysendian.h line 38
static inline unsigned int libcperciva_be32dec_link1(const void *pp_link1);
// libcperciva_be32enc
// file ../libcperciva/util/sysendian.h line 47
static inline void libcperciva_be32enc(void *pp, unsigned int x);
// libcperciva_be32enc_link1
// file ../libcperciva/util/sysendian.h line 47
static inline void libcperciva_be32enc_link1(void *pp_link1, unsigned int x_link1);
// libcperciva_be64enc
// file ../libcperciva/util/sysendian.h line 69
static inline void libcperciva_be64enc(void *pp, unsigned long int x);
// libcperciva_be64enc_link1
// file ../libcperciva/util/sysendian.h line 69
static inline void libcperciva_be64enc_link1(void *pp_link1, unsigned long int x_link1);
// libcperciva_be64enc_link2
// file ../libcperciva/util/sysendian.h line 69
static inline void libcperciva_be64enc_link2(void *pp_link2, unsigned long int x_link2);
// libcperciva_warn
// file ../libcperciva/util/warnp.h line 21
void libcperciva_warn(const char *fmt, ...);
// libcperciva_warnx
// file ../libcperciva/util/warnp.h line 22
void libcperciva_warnx(const char *fmt, ...);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkkeypair
// file ../proto/proto_crypt.c line 31
static struct proto_keys * mkkeypair(unsigned char *kbuf);
// monoclock_get
// file ../libcperciva/util/monoclock.c line 16
signed int monoclock_get(struct timeval *tv);
// mpool_eventq_atexit
// file ../libcperciva/events/events_immediate.c line 17
static void mpool_eventq_atexit(void);
// mpool_eventq_free
// file ../libcperciva/events/events_immediate.c line 17
static inline void mpool_eventq_free(struct eventq *p);
// mpool_eventq_malloc
// file ../libcperciva/events/events_immediate.c line 17
static inline struct eventq * mpool_eventq_malloc(void);
// mpool_eventrec_atexit
// file ../libcperciva/events/events.c line 17
static void mpool_eventrec_atexit(void);
// mpool_eventrec_free
// file ../libcperciva/events/events.c line 17
static inline void mpool_eventrec_free(struct eventrec *p);
// mpool_eventrec_malloc
// file ../libcperciva/events/events.c line 17
static inline struct eventrec * mpool_eventrec_malloc(void);
// network_accept
// file ../libcperciva/network/network.h line 21
void * network_accept(signed int fd, signed int (*callback)(void *, signed int), void *cookie);
// network_accept::callback_object
//
signed int callback_object(void *, signed int);
// network_accept_cancel
// file ../libcperciva/network/network_accept.c line 94
void network_accept_cancel(void *cookie);
// network_connect
// file ../libcperciva/network/network.h line 39
void * network_connect(struct sock_addr * const *sas, signed int (*callback)(void *, signed int), void *cookie);
// network_connect::callback_object
//
signed int callback_object(void *, signed int);
// network_connect_cancel
// file ../libcperciva/network/network.h line 55
void network_connect_cancel(void *cookie);
// network_connect_timeo
// file ../libcperciva/network/network_connect.c line 192
void * network_connect_timeo(struct sock_addr * const *sas, struct timeval *timeo, signed int (*callback)(void *, signed int), void *cookie);
// network_connect_timeo::callback_object
//
signed int callback_object(void *, signed int);
// network_read
// file ../libcperciva/network/network.h line 66
void * network_read(signed int fd, unsigned char *buf, unsigned long int buflen, unsigned long int minread, signed int (*callback)(void *, signed long int), void *cookie);
// network_read::callback_object
//
signed int callback_object(void *, signed long int);
// network_read_cancel
// file ../libcperciva/network/network.h line 74
void network_read_cancel(void *cookie);
// network_write
// file ../libcperciva/network/network.h line 85
void * network_write(signed int fd, const unsigned char *buf, unsigned long int buflen, unsigned long int minwrite, signed int (*callback)(void *, signed long int), void *cookie);
// network_write::callback_object
//
signed int callback_object(void *, signed long int);
// network_write_cancel
// file ../libcperciva/network/network.h line 93
void network_write_cancel(void *cookie);
// noeintr_write
// file ../libcperciva/util/noeintr.h line 12
signed long int noeintr_write(signed int d, const void *buf, unsigned long int nbyte);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// prettyprint_ipv4
// file ../libcperciva/util/sock_util.c line 187
static char * prettyprint_ipv4(struct sockaddr *name, unsigned long int namelen);
// prettyprint_ipv6
// file ../libcperciva/util/sock_util.c line 214
static char * prettyprint_ipv6(struct sockaddr *name, unsigned long int namelen);
// prettyprint_unix
// file ../libcperciva/util/sock_util.c line 241
static char * prettyprint_unix(struct sockaddr_un *name);
// proto_conn_create
// file ../proto/proto_conn.h line 22
signed int proto_conn_create(signed int s, struct sock_addr **sas, signed int decr, signed int nofps, signed int requirefps, signed int nokeepalive, struct proto_secret *K, double timeo, signed int (*callback_dead)(void *), void *cookie);
// proto_conn_create::callback_dead_object
//
signed int callback_dead_object(void *);
// proto_crypt_dec
// file ../proto/proto_crypt.c line 342
signed long int proto_crypt_dec(unsigned char *ibuf, unsigned char *obuf, struct proto_keys *k);
// proto_crypt_dh_generate
// file ../proto/proto_crypt.c line 211
signed int proto_crypt_dh_generate(unsigned char *yh_l, unsigned char *x, const unsigned char *dhmac_l, signed int nofps);
// proto_crypt_dh_validate
// file ../proto/proto_crypt.c line 177
signed int proto_crypt_dh_validate(const unsigned char *yh_r, const unsigned char *dhmac_r, signed int requirefps);
// proto_crypt_dhmac
// file ../proto/proto_crypt.c line 121
void proto_crypt_dhmac(struct proto_secret *K, const unsigned char *nonce_l, const unsigned char *nonce_r, unsigned char *dhmac_l, unsigned char *dhmac_r, signed int decr);
// proto_crypt_enc
// file ../proto/proto_crypt.c line 304
void proto_crypt_enc(unsigned char *ibuf, unsigned long int len, unsigned char *obuf, struct proto_keys *k);
// proto_crypt_free
// file ../proto/proto_crypt.h line 100
void proto_crypt_free(struct proto_keys *k);
// proto_crypt_mkkeys
// file ../proto/proto_crypt.c line 248
signed int proto_crypt_mkkeys(struct proto_secret *K, const unsigned char *nonce_l, const unsigned char *nonce_r, const unsigned char *yh_r, const unsigned char *x, signed int nofps, signed int decr, struct proto_keys **eh_c, struct proto_keys **eh_s);
// proto_crypt_secret
// file ../proto/proto_crypt.h line 28
struct proto_secret * proto_crypt_secret(const char *filename);
// proto_handshake
// file ../proto/proto_handshake.h line 21
void * proto_handshake(signed int s, signed int decr, signed int nofps, signed int requirefps, struct proto_secret *K, signed int (*callback)(void *, struct proto_keys *, struct proto_keys *), void *cookie);
// proto_handshake::callback_object
//
signed int callback_object(void *, struct proto_keys *, struct proto_keys *);
// proto_handshake_cancel
// file ../proto/proto_handshake.h line 28
void proto_handshake_cancel(void *cookie);
// proto_pipe
// file ../proto/proto_pipe.h line 14
void * proto_pipe(signed int s_in, signed int s_out, signed int decr, struct proto_keys *k, signed int *status, signed int (*callback)(void *), void *cookie);
// proto_pipe::callback_object
//
signed int callback_object(void *);
// proto_pipe_cancel
// file ../proto/proto_pipe.h line 21
void proto_pipe_cancel(void *cookie);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_4 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_4 *, const union anonymous_6 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_4 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_4 *, union anonymous_3 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_3 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_3 *, const union anonymous_6 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_3 *);
// ptrheap_add
// file ../libcperciva/datastruct/ptrheap.c line 193
signed int ptrheap_add(struct ptrheap *H, void *ptr);
// ptrheap_create
// file ../libcperciva/datastruct/ptrheap.c line 141
struct ptrheap * ptrheap_create(signed int (*compar)(void *, const void *, const void *), void (*setreccookie)(void *, void *, unsigned long int), void *cookie, unsigned long int N, void **ptrs);
// ptrheap_create::compar_object
//
signed int compar_object(void *, const void *, const void *);
// ptrheap_create::setreccookie_object
//
void setreccookie_object(void *, void *, unsigned long int);
// ptrheap_delete
// file ../libcperciva/datastruct/ptrheap.c line 239
void ptrheap_delete(struct ptrheap *H, unsigned long int rc);
// ptrheap_deletemin
// file ../libcperciva/datastruct/ptrheap.c line 284
void ptrheap_deletemin(struct ptrheap *H);
// ptrheap_free
// file ../libcperciva/datastruct/ptrheap.c line 325
void ptrheap_free(struct ptrheap *H);
// ptrheap_getmin
// file ../libcperciva/datastruct/ptrheap.c line 223
void * ptrheap_getmin(struct ptrheap *H);
// ptrheap_increase
// file ../libcperciva/datastruct/ptrheap.c line 298
void ptrheap_increase(struct ptrheap *H, unsigned long int rc);
// ptrheap_increasemin
// file ../libcperciva/datastruct/ptrheap.c line 312
void ptrheap_increasemin(struct ptrheap *H);
// ptrheap_init
// file ../libcperciva/datastruct/ptrheap.c line 126
struct ptrheap * ptrheap_init(signed int (*compar)(void *, const void *, const void *), void (*setreccookie)(void *, void *, unsigned long int), void *cookie);
// ptrheap_init::compar_object
//
signed int compar_object(void *, const void *, const void *);
// ptrheap_init::setreccookie_object
//
void setreccookie_object(void *, void *, unsigned long int);
// ptrlist_append
// file ../libcperciva/datastruct/ptrheap.c line 7
static inline signed int ptrlist_append(struct ptrlist_struct *EA, void * const *buf, unsigned long int nrec);
// ptrlist_free
// file ../libcperciva/datastruct/ptrheap.c line 7
static inline void ptrlist_free(struct ptrlist_struct *EA);
// ptrlist_get
// file ../libcperciva/datastruct/ptrheap.c line 7
static inline void ** ptrlist_get(struct ptrlist_struct *EA, unsigned long int pos);
// ptrlist_init
// file ../libcperciva/datastruct/ptrheap.c line 7
static inline struct ptrlist_struct * ptrlist_init(unsigned long int nrec);
// ptrlist_shrink
// file ../libcperciva/datastruct/ptrheap.c line 7
static inline void ptrlist_shrink(struct ptrlist_struct *EA, unsigned long int nrec);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// reseed
// file ../libcperciva/crypto/crypto_entropy.c line 120
static signed int reseed(void);
// resize
// file ../libcperciva/datastruct/elasticarray.c line 21
static signed int resize(struct elasticarray *EA, unsigned long int nsize);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_0 *, struct anonymous_0 *, struct anonymous_0 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// setreccookie
// file ../libcperciva/datastruct/timerqueue.c line 55
static void setreccookie(void *cookie, void *ptr, unsigned long int rc);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// sock_addr_cmp
// file ../libcperciva/util/sock_util.c line 22
signed int sock_addr_cmp(struct sock_addr *sa1, struct sock_addr *sa2);
// sock_addr_deserialize
// file ../libcperciva/util/sock_util.c line 150
struct sock_addr * sock_addr_deserialize(const unsigned char *buf, unsigned long int buflen);
// sock_addr_dup
// file ../libcperciva/util/sock_util.c line 44
struct sock_addr * sock_addr_dup(struct sock_addr *sa);
// sock_addr_duplist
// file ../libcperciva/util/sock_util.h line 25
struct sock_addr ** sock_addr_duplist(struct sock_addr * const *sas);
// sock_addr_free
// file ../libcperciva/util/sock.c line 441
void sock_addr_free(struct sock_addr *sa);
// sock_addr_freelist
// file ../libcperciva/util/sock.h line 54
void sock_addr_freelist(struct sock_addr **sas);
// sock_addr_prettyprint
// file ../libcperciva/util/sock_util.c line 257
char * sock_addr_prettyprint(struct sock_addr *sa);
// sock_addr_serialize
// file ../libcperciva/util/sock_util.c line 118
signed int sock_addr_serialize(struct sock_addr *sa, unsigned char **buf, unsigned long int *buflen);
// sock_connect
// file ../libcperciva/util/sock.c line 358
signed int sock_connect(struct sock_addr * const *sas);
// sock_connect_nb
// file ../libcperciva/util/sock.c line 406
signed int sock_connect_nb(struct sock_addr *sa);
// sock_listener
// file ../libcperciva/util/sock.h line 26
signed int sock_listener(struct sock_addr *sa);
// sock_resolve
// file ../libcperciva/util/sock.h line 19
struct sock_addr ** sock_resolve(const char *addr);
// sock_resolve_host
// file ../libcperciva/util/sock.c line 68
static struct sock_addr ** sock_resolve_host(const char *addr, const char *ports);
// sock_resolve_ipv4
// file ../libcperciva/util/sock.c line 182
static struct sock_addr ** sock_resolve_ipv4(const char *addr, unsigned short int p);
// sock_resolve_ipv6
// file ../libcperciva/util/sock.c line 138
static struct sock_addr ** sock_resolve_ipv6(const char *addr, unsigned short int p);
// sock_resolve_unix
// file ../libcperciva/util/sock.c line 24
static struct sock_addr ** sock_resolve_unix(const char *addr);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketlist_free
// file ../libcperciva/events/events_network.c line 19
static inline void socketlist_free(struct socketlist_struct *EA);
// socketlist_get
// file ../libcperciva/events/events_network.c line 19
static inline struct socketrec * socketlist_get(struct socketlist_struct *EA, unsigned long int pos);
// socketlist_getsize
// file ../libcperciva/events/events_network.c line 19
static inline unsigned long int socketlist_getsize(struct socketlist_struct *EA);
// socketlist_init
// file ../libcperciva/events/events_network.c line 19
static inline struct socketlist_struct * socketlist_init(unsigned long int nrec);
// socketlist_resize
// file ../libcperciva/events/events_network.c line 19
static inline signed int socketlist_resize(struct socketlist_struct *EA, unsigned long int nrec);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// starthandshake
// file ../proto/proto_conn.c line 50
static signed int starthandshake(struct conn_state *C, signed int s, signed int decr);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtoimax
// file /usr/include/inttypes.h line 297
extern signed long int strtoimax(const char *, char ** restrict , signed int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// swap
// file ../libcperciva/datastruct/ptrheap.c line 24
static void swap(struct ptrlist_struct *elems, unsigned long int i, unsigned long int j, void (*setreccookie)(void *, void *, unsigned long int), void *cookie);
// swap::setreccookie_object
//
void setreccookie_object(void *, void *, unsigned long int);
// timerqueue_add
// file ../libcperciva/datastruct/timerqueue.c line 97
void * timerqueue_add(struct timerqueue *Q, struct timeval *tv, void *ptr);
// timerqueue_delete
// file ../libcperciva/datastruct/timerqueue.c line 132
void timerqueue_delete(struct timerqueue *Q, void *cookie);
// timerqueue_free
// file ../libcperciva/datastruct/timerqueue.c line 226
void timerqueue_free(struct timerqueue *Q);
// timerqueue_getmin
// file ../libcperciva/datastruct/timerqueue.c line 168
struct timeval * timerqueue_getmin(struct timerqueue *Q);
// timerqueue_getptr
// file ../libcperciva/datastruct/timerqueue.c line 189
void * timerqueue_getptr(struct timerqueue *Q, struct timeval *tv);
// timerqueue_increase
// file ../libcperciva/datastruct/timerqueue.c line 149
void timerqueue_increase(struct timerqueue *Q, void *cookie, struct timeval *tv);
// timerqueue_init
// file ../libcperciva/datastruct/timerqueue.c line 69
struct timerqueue * timerqueue_init(void);
// tryconnect
// file ../libcperciva/network/network_connect.c line 116
static signed int tryconnect(struct connect_cookie *C);
// tvcmp
// file ../libcperciva/datastruct/timerqueue.c line 22
static signed int tvcmp(struct timeval *x, struct timeval *y);
// update
// file ../libcperciva/crypto/crypto_entropy.c line 73
static void update(unsigned char *data, unsigned long int datalen);
// usage
// file main.c line 17
static void usage(void);
// useaesni
// file ../libcperciva/crypto/crypto_aes.c line 55
static signed int useaesni(void);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// warnp_setprogname
// file ../libcperciva/util/warnp.h line 14
void warnp_setprogname(const char *progname);
// workthread
// file ../lib/dnsthread/dnsthread.c line 60
static void * workthread(void *cookie);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_0
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_1
{
  // Key
  unsigned char Key[32l];
  // V
  unsigned char V[32l];
  // reseed_counter
  unsigned int reseed_counter;
};

struct anonymous_5
{
  // state
  unsigned int state[8l];
  // count
  unsigned long int count;
  // buf
  unsigned char buf[64l];
};

struct anonymous_7
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_2
{
  // ictx
  struct anonymous_5 ictx;
  // octx
  struct anonymous_5 octx;
};

union anonymous
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
};

union anonymous_6
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_4
{
  // __data
  struct anonymous_7 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct accept_cookie
{
  // callback
  signed int (*callback)(void *, signed int);
  // cookie
  void *cookie;
  // fd
  signed int fd;
};

struct accept_state
{
  // s
  signed int s;
  // tgt
  const char *tgt;
  // sas
  struct sock_addr **sas;
  // rtime
  double rtime;
  // decr
  signed int decr;
  // nofps
  signed int nofps;
  // requirefps
  signed int requirefps;
  // nokeepalive
  signed int nokeepalive;
  // K
  struct proto_secret *K;
  // nconn
  unsigned long int nconn;
  // nconn_max
  unsigned long int nconn_max;
  // timeo
  double timeo;
  // accept_cookie
  void *accept_cookie;
  // T
  struct dnsthread_internal *T;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct aes_key_st
{
  // rd_key
  unsigned int rd_key[60l];
  // rounds
  signed int rounds;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct conn_state
{
  // callback_dead
  signed int (*callback_dead)(void *);
  // cookie
  void *cookie;
  // sas
  struct sock_addr **sas;
  // decr
  signed int decr;
  // nofps
  signed int nofps;
  // requirefps
  signed int requirefps;
  // nokeepalive
  signed int nokeepalive;
  // K
  struct proto_secret *K;
  // timeo
  double timeo;
  // s
  signed int s;
  // t
  signed int t;
  // connect_cookie
  void *connect_cookie;
  // connect_timeout_cookie
  void *connect_timeout_cookie;
  // handshake_cookie
  void *handshake_cookie;
  // handshake_timeout_cookie
  void *handshake_timeout_cookie;
  // k_f
  struct proto_keys *k_f;
  // k_r
  struct proto_keys *k_r;
  // pipe_f
  void *pipe_f;
  // pipe_r
  void *pipe_r;
  // stat_f
  signed int stat_f;
  // stat_r
  signed int stat_r;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct connect_cookie
{
  // callback
  signed int (*callback)(void *, signed int);
  // cookie
  void *cookie;
  // sas
  struct sock_addr * const *sas;
  // timeo
  struct timeval timeo;
  // cookie_immediate
  void *cookie_immediate;
  // s
  signed int s;
  // timeo_enabled
  signed int timeo_enabled;
  // cookie_timeo
  void *cookie_timeo;
};

struct crypto_aes_key_aesni
{
  // rkeys
  __gcc_v2di rkeys[15l];
  // nr
  unsigned long int nr;
};

struct crypto_aesctr
{
  // key
  struct crypto_aes_key *key;
  // nonce
  unsigned long int nonce;
  // bytectr
  unsigned long int bytectr;
  // buf
  unsigned char buf[16l];
};

struct dnsthread_internal
{
  // thr
  unsigned long int thr;
  // mtx
  union anonymous_3 mtx;
  // cv
  union anonymous_4 cv;
  // state
  signed int state;
  // wakeupsock
  signed int wakeupsock[2l];
  // addr
  char *addr;
  // sas
  struct sock_addr **sas;
  // res_errno
  signed int res_errno;
  // callback
  signed int (*callback)(void *, struct sock_addr **);
  // cookie
  void *cookie;
};

struct elasticarray
{
  // size
  unsigned long int size;
  // alloc
  unsigned long int alloc;
  // buf
  void *buf;
};

struct eventq
{
  // r
  struct eventrec *r;
  // next
  struct eventq *next;
  // prev
  struct eventq *prev;
  // prio
  signed int prio;
};

struct eventrec
{
  // func
  signed int (*func)(void *);
  // cookie
  void *cookie;
};

struct handshake_cookie
{
  // callback
  signed int (*callback)(void *, struct proto_keys *, struct proto_keys *);
  // cookie
  void *cookie;
  // s
  signed int s;
  // decr
  signed int decr;
  // nofps
  signed int nofps;
  // requirefps
  signed int requirefps;
  // K
  struct proto_secret *K;
  // nonce_local
  unsigned char nonce_local[32l];
  // nonce_remote
  unsigned char nonce_remote[32l];
  // dhmac_local
  unsigned char dhmac_local[32l];
  // dhmac_remote
  unsigned char dhmac_remote[32l];
  // x
  unsigned char x[32l];
  // yh_local
  unsigned char yh_local[288l];
  // yh_remote
  unsigned char yh_remote[288l];
  // read_cookie
  void *read_cookie;
  // write_cookie
  void *write_cookie;
};

struct in6_addr
{
  // __in6_u
  union anonymous __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct mpool_eventq_struct
{
  // stacklen
  unsigned long int stacklen;
  // top
  void *top;
  // atexit_set
  signed int atexit_set;
};

struct mpool_eventrec_struct
{
  // stacklen
  unsigned long int stacklen;
  // top
  void *top;
  // atexit_set
  signed int atexit_set;
};

struct network_read_cookie
{
  // callback
  signed int (*callback)(void *, signed long int);
  // cookie
  void *cookie;
  // fd
  signed int fd;
  // buf
  unsigned char *buf;
  // buflen
  unsigned long int buflen;
  // minlen
  unsigned long int minlen;
  // bufpos
  unsigned long int bufpos;
};

struct network_write_cookie
{
  // callback
  signed int (*callback)(void *, signed long int);
  // cookie
  void *cookie;
  // fd
  signed int fd;
  // buf
  const unsigned char *buf;
  // buflen
  unsigned long int buflen;
  // minlen
  unsigned long int minlen;
  // bufpos
  unsigned long int bufpos;
};

struct pipe_cookie
{
  // callback
  signed int (*callback)(void *);
  // cookie
  void *cookie;
  // status
  signed int *status;
  // s_in
  signed int s_in;
  // s_out
  signed int s_out;
  // decr
  signed int decr;
  // k
  struct proto_keys *k;
  // dbuf
  unsigned char dbuf[1024l];
  // ebuf
  unsigned char ebuf[1060l];
  // read_cookie
  void *read_cookie;
  // write_cookie
  void *write_cookie;
  // wlen
  signed long int wlen;
};

struct proto_keys
{
  // k_aes
  struct crypto_aes_key *k_aes;
  // k_hmac
  unsigned char k_hmac[32l];
  // pnum
  unsigned long int pnum;
};

struct proto_secret
{
  // K
  unsigned char K[32l];
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct ptrheap
{
  // compar
  signed int (*compar)(void *, const void *, const void *);
  // setreccookie
  void (*setreccookie)(void *, void *, unsigned long int);
  // cookie
  void *cookie;
  // elems
  struct ptrlist_struct *elems;
  // nelems
  unsigned long int nelems;
};

struct resolve_cookie
{
  // callback
  signed int (*callback)(void *, struct sock_addr **);
  // cookie
  void *cookie;
  // T
  struct dnsthread_internal *T;
};

struct sock_addr
{
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // name
  struct sockaddr *name;
  // namelen
  unsigned int namelen;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct socketrec
{
  // reader
  struct eventrec *reader;
  // writer
  struct eventrec *writer;
};

struct timerqueue
{
  // H
  struct ptrheap *H;
};

struct timerrec_0
{
  // tv
  struct timeval tv;
  // rc
  unsigned long int rc;
  // ptr
  void *ptr;
};

struct timerrec
{
  // r
  struct eventrec *r;
  // cookie
  void *cookie;
  // tv_orig
  struct timeval tv_orig;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};


// M2
// file ../libcperciva/events/events_network_selectstats.c line 15
static double M2 = 0.0;
// N
// file ../libcperciva/events/events_network_selectstats.c line 13
static double N = 0.0;
// PAD
// file ../libcperciva/alg/sha256.c line 166
static unsigned char PAD[64l] = { (unsigned char)0x80, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// Q
// file ../libcperciva/events/events_timer.c line 18
static struct timerqueue *Q = (struct timerqueue *)(void *)0;
// S
// file ../libcperciva/events/events_network.c line 20
static struct socketlist_struct *S = (struct socketlist_struct *)(void *)0;
// cpusupport_x86_aesni_init
// file ../libcperciva/cpusupport/cpusupport_x86_aesni.c line 9
signed int cpusupport_x86_aesni_init = 0;
// cpusupport_x86_aesni_present
// file ../libcperciva/cpusupport/cpusupport_x86_aesni.c line 9
signed int cpusupport_x86_aesni_present = 0;
// crypto_dh_group14
// file ../libcperciva/crypto/crypto_dh_group14.c line 13
unsigned char crypto_dh_group14[256l] = { (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xc9, (unsigned char)0x0f, (unsigned char)0xda, (unsigned char)0xa2, (unsigned char)0x21, (unsigned char)0x68, (unsigned char)0xc2, (unsigned char)0x34, (unsigned char)0xc4, (unsigned char)0xc6, (unsigned char)0x62, (unsigned char)0x8b, (unsigned char)0x80, (unsigned char)0xdc, (unsigned char)0x1c, (unsigned char)0xd1, (unsigned char)0x29, (unsigned char)0x02, (unsigned char)0x4e, (unsigned char)0x08, (unsigned char)0x8a, (unsigned char)0x67, (unsigned char)0xcc, (unsigned char)0x74, (unsigned char)0x02, (unsigned char)0x0b, (unsigned char)0xbe, (unsigned char)0xa6, (unsigned char)0x3b, (unsigned char)0x13, (unsigned char)0x9b, (unsigned char)0x22, (unsigned char)0x51, (unsigned char)0x4a, (unsigned char)0x08, (unsigned char)0x79, (unsigned char)0x8e, (unsigned char)0x34, (unsigned char)0x04, (unsigned char)0xdd, (unsigned char)0xef, (unsigned char)0x95, (unsigned char)0x19, (unsigned char)0xb3, (unsigned char)0xcd, (unsigned char)0x3a, (unsigned char)0x43, (unsigned char)0x1b, (unsigned char)0x30, (unsigned char)0x2b, (unsigned char)0x0a, (unsigned char)0x6d, (unsigned char)0xf2, (unsigned char)0x5f, (unsigned char)0x14, (unsigned char)0x37, (unsigned char)0x4f, (unsigned char)0xe1, (unsigned char)0x35, (unsigned char)0x6d, (unsigned char)0x6d, (unsigned char)0x51, (unsigned char)0xc2, (unsigned char)0x45, (unsigned char)0xe4, (unsigned char)0x85, (unsigned char)0xb5, (unsigned char)0x76, (unsigned char)0x62, (unsigned char)0x5e, (unsigned char)0x7e, (unsigned char)0xc6, (unsigned char)0xf4, (unsigned char)0x4c, (unsigned char)0x42, (unsigned char)0xe9, (unsigned char)0xa6, (unsigned char)0x37, (unsigned char)0xed, (unsigned char)0x6b, (unsigned char)0x0b, (unsigned char)0xff, (unsigned char)0x5c, (unsigned char)0xb6, (unsigned char)0xf4, (unsigned char)0x06, (unsigned char)0xb7, (unsigned char)0xed, (unsigned char)0xee, (unsigned char)0x38, (unsigned char)0x6b, (unsigned char)0xfb, (unsigned char)0x5a, (unsigned char)0x89, (unsigned char)0x9f, (unsigned char)0xa5, (unsigned char)0xae, (unsigned char)0x9f, (unsigned char)0x24, (unsigned char)0x11, (unsigned char)0x7c, (unsigned char)0x4b, (unsigned char)0x1f, (unsigned char)0xe6, (unsigned char)0x49, (unsigned char)0x28, (unsigned char)0x66, (unsigned char)0x51, (unsigned char)0xec, (unsigned char)0xe4, (unsigned char)0x5b, (unsigned char)0x3d, (unsigned char)0xc2, (unsigned char)0x00, (unsigned char)0x7c, (unsigned char)0xb8, (unsigned char)0xa1, (unsigned char)0x63, (unsigned char)0xbf, (unsigned char)0x05, (unsigned char)0x98, (unsigned char)0xda, (unsigned char)0x48, (unsigned char)0x36, (unsigned char)0x1c, (unsigned char)0x55, (unsigned char)0xd3, (unsigned char)0x9a, (unsigned char)0x69, (unsigned char)0x16, (unsigned char)0x3f, (unsigned char)0xa8, (unsigned char)0xfd, (unsigned char)0x24, (unsigned char)0xcf, (unsigned char)0x5f, (unsigned char)0x83, (unsigned char)0x65, (unsigned char)0x5d, (unsigned char)0x23, (unsigned char)0xdc, (unsigned char)0xa3, (unsigned char)0xad, (unsigned char)0x96, (unsigned char)0x1c, (unsigned char)0x62, (unsigned char)0xf3, (unsigned char)0x56, (unsigned char)0x20, (unsigned char)0x85, (unsigned char)0x52, (unsigned char)0xbb, (unsigned char)0x9e, (unsigned char)0xd5, (unsigned char)0x29, (unsigned char)0x07, (unsigned char)0x70, (unsigned char)0x96, (unsigned char)0x96, (unsigned char)0x6d, (unsigned char)0x67, (unsigned char)0x0c, (unsigned char)0x35, (unsigned char)0x4e, (unsigned char)0x4a, (unsigned char)0xbc, (unsigned char)0x98, (unsigned char)0x04, (unsigned char)0xf1, (unsigned char)0x74, (unsigned char)0x6c, (unsigned char)0x08, (unsigned char)0xca, (unsigned char)0x18, (unsigned char)0x21, (unsigned char)0x7c, (unsigned char)0x32, (unsigned char)0x90, (unsigned char)0x5e, (unsigned char)0x46, (unsigned char)0x2e, (unsigned char)0x36, (unsigned char)0xce, (unsigned char)0x3b, (unsigned char)0xe3, (unsigned char)0x9e, (unsigned char)0x77, (unsigned char)0x2c, (unsigned char)0x18, (unsigned char)0x0e, (unsigned char)0x86, (unsigned char)0x03, (unsigned char)0x9b, (unsigned char)0x27, (unsigned char)0x83, (unsigned char)0xa2, (unsigned char)0xec, (unsigned char)0x07, (unsigned char)0xa2, (unsigned char)0x8f, (unsigned char)0xb5, (unsigned char)0xc5, (unsigned char)0x5d, (unsigned char)0xf0, (unsigned char)0x6f, (unsigned char)0x4c, (unsigned char)0x52, (unsigned char)0xc9, (unsigned char)0xde, (unsigned char)0x2b, (unsigned char)0xcb, (unsigned char)0xf6, (unsigned char)0x95, (unsigned char)0x58, (unsigned char)0x17, (unsigned char)0x18, (unsigned char)0x39, (unsigned char)0x95, (unsigned char)0x49, (unsigned char)0x7c, (unsigned char)0xea, (unsigned char)0x95, (unsigned char)0x6a, (unsigned char)0xe5, (unsigned char)0x15, (unsigned char)0xd2, (unsigned char)0x26, (unsigned char)0x18, (unsigned char)0x98, (unsigned char)0xfa, (unsigned char)0x05, (unsigned char)0x10, (unsigned char)0x15, (unsigned char)0x72, (unsigned char)0x8e, (unsigned char)0x5a, (unsigned char)0x8a, (unsigned char)0xac, (unsigned char)0xaa, (unsigned char)0x68, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff };
// drbg
// file ../libcperciva/crypto/crypto_entropy.c line 24
static struct anonymous_1 drbg;
// fdscanpos
// file ../libcperciva/events/events_network.c line 27
static unsigned long int fdscanpos;
// heads
// file ../libcperciva/events/events_immediate.c line 20
static struct eventq *heads[32l] = { (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0, (struct eventq *)(void *)0 };
// initialized
// file ../libcperciva/util/warnp.c line 9
static signed int initialized = 0;
// initstate
// file ../libcperciva/alg/sha256.c line 196
static const unsigned int initstate[8l] = { (const unsigned int)0x6A09E667, 0xBB67AE85, (const unsigned int)0x3C6EF372, 0xA54FF53A, (const unsigned int)0x510E527F, 0x9B05688C, (const unsigned int)0x1F83D9AB, (const unsigned int)0x5BE0CD19 };
// insecure_memzero_ptr
// file ../libcperciva/util/insecure_memzero.c line 18
void (* volatile insecure_memzero_ptr)(volatile void *, unsigned long int);
// insecure_memzero_ptr
// file ../libcperciva/util/insecure_memzero.c line 18
void (* volatile insecure_memzero_ptr)(volatile void *, unsigned long int) = insecure_memzero_func;
// instantiated
// file ../libcperciva/crypto/crypto_entropy.c line 27
static signed int instantiated = 0;
// max
// file ../libcperciva/events/events_network_selectstats.c line 16
static double max = 0.0;
// minq
// file ../libcperciva/events/events_immediate.c line 31
static signed int minq = 32;
// mpool_eventq_rec
// file ../libcperciva/events/events_immediate.c line 17
static struct mpool_eventq_struct mpool_eventq_rec = { .stacklen=(unsigned long int)0, .top=(void *)0, .atexit_set=0 };
// mpool_eventrec_rec
// file ../libcperciva/events/events.c line 17
static struct mpool_eventrec_struct mpool_eventrec_rec = { .stacklen=(unsigned long int)0, .top=(void *)0, .atexit_set=0 };
// mu
// file ../libcperciva/events/events_network_selectstats.c line 14
static double mu = 0.0;
// name
// file ../libcperciva/util/warnp.c line 10
static char *name = (char *)(void *)0;
// nev
// file ../libcperciva/events/events_network.c line 30
static unsigned long int nev;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// readfds
// file ../libcperciva/events/events_network.c line 23
static struct anonymous_0 readfds;
// running
// file ../libcperciva/events/events_network_selectstats.c line 10
static signed int running = 0;
// st
// file ../libcperciva/events/events_network_selectstats.c line 9
static struct timeval st;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// tails
// file ../libcperciva/events/events_immediate.c line 28
static struct eventq *tails[32l];
// tv_zero
// file ../libcperciva/events/events.c line 20
static struct timeval tv_zero = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
// two_exp_256
// file ../libcperciva/crypto/crypto_dh.c line 18
static unsigned char two_exp_256[33l] = { (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00 };
// writefds
// file ../libcperciva/events/events_network.c line 24
static struct anonymous_0 writefds;

// PBKDF2_SHA256
// file ../libcperciva/alg/sha256.h line 92
void PBKDF2_SHA256(const unsigned char *passwd, unsigned long int passwdlen, const unsigned char *salt, unsigned long int saltlen, unsigned long int c, unsigned char *buf, unsigned long int dkLen)
{
  struct anonymous_2 PShctx;
  struct anonymous_2 hctx;
  unsigned long int i;
  unsigned char ivec[4l];
  unsigned char U[32l];
  unsigned char T[32l];
  unsigned long int j;
  signed int k;
  unsigned long int clen;
  /* assertion dkLen <= 32 * (size_t)((4294967295U)) */
  assert(dkLen <= (unsigned long int)32 * (unsigned long int)4294967295U);
  libcperciva_HMAC_SHA256_Init(&PShctx, (const void *)passwd, passwdlen);
  libcperciva_HMAC_SHA256_Update(&PShctx, (const void *)salt, saltlen);
  i = (unsigned long int)0;
  for( ; !(32ul * i >= dkLen); i = i + 1ul)
  {
    libcperciva_be32enc_link1((void *)ivec, (unsigned int)(i + (unsigned long int)1));
    memcpy((void *)&hctx, (const void *)&PShctx, sizeof(struct anonymous_2) /*208ul*/ );
    libcperciva_HMAC_SHA256_Update(&hctx, (const void *)ivec, (unsigned long int)4);
    libcperciva_HMAC_SHA256_Final(U, &hctx);
    memcpy((void *)T, (const void *)U, (unsigned long int)32);
    j = (unsigned long int)2;
    for( ; c >= j; j = j + 1ul)
    {
      libcperciva_HMAC_SHA256_Init(&hctx, (const void *)passwd, passwdlen);
      libcperciva_HMAC_SHA256_Update(&hctx, (const void *)U, (unsigned long int)32);
      libcperciva_HMAC_SHA256_Final(U, &hctx);
      k = 0;
      for( ; !(k >= 32); k = k + 1)
        T[(signed long int)k] = T[(signed long int)k] ^ U[(signed long int)k];
    }
    clen = dkLen - i * (unsigned long int)32;
    if(clen >= 33ul)
      clen = (unsigned long int)32;

    memcpy((void *)&buf[(signed long int)(i * (unsigned long int)32)], (const void *)T, clen);
  }
  insecure_memzero((volatile void *)&PShctx, sizeof(struct anonymous_2) /*208ul*/ );
}

// SHA256_Pad
// file ../libcperciva/alg/sha256.c line 175
static void SHA256_Pad(struct anonymous_5 *ctx)
{
  unsigned char len[8l];
  unsigned int r;
  unsigned int plen;
  libcperciva_be64enc_link1((void *)len, ctx->count);
  r = (unsigned int)(ctx->count >> 3 & (unsigned long int)0x3f);
  plen = r < (unsigned int)56 ? (unsigned int)56 - r : (unsigned int)120 - r;
  libcperciva_SHA256_Update(ctx, (const void *)PAD, (unsigned long int)plen);
  libcperciva_SHA256_Update(ctx, (const void *)len, (unsigned long int)8);
}

// SHA256_Transform
// file ../libcperciva/alg/sha256.c line 74
static void SHA256_Transform(unsigned int *state, const unsigned char *block)
{
  unsigned int W[64l];
  unsigned int SHA256_Transform__1__S[8l];
  unsigned int t0;
  unsigned int t1;
  signed int i;
  be32dec_vect(W, block, (unsigned long int)64);
  i = 16;
  for( ; !(i >= 64); i = i + 1)
    W[(signed long int)i] = ((W[(signed long int)(i - 2)] >> 17 | W[(signed long int)(i - 2)] << 32 - 17) ^ (W[(signed long int)(i - 2)] >> 19 | W[(signed long int)(i - 2)] << 32 - 19) ^ W[(signed long int)(i - 2)] >> 10) + W[(signed long int)(i - 7)] + ((W[(signed long int)(i - 15)] >> 7 | W[(signed long int)(i - 15)] << 32 - 7) ^ (W[(signed long int)(i - 15)] >> 18 | W[(signed long int)(i - 15)] << 32 - 18) ^ W[(signed long int)(i - 15)] >> 3) + W[(signed long int)(i - 16)];
  memcpy((void *)SHA256_Transform__1__S, (const void *)state, (unsigned long int)32);
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 0) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 0) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 0) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 0) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 0) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 0) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 0) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 0) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 0) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 0) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 0) % 8)]) + W[(signed long int)0] + (unsigned int)0x428a2f98;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 0) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 0) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 0) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 0) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 0) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 0) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 0) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 0) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 0) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 0) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 0) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 0) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 0) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 0) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 1) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 1) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 1) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 1) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 1) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 1) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 1) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 1) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 1) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 1) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 1) % 8)]) + W[(signed long int)1] + (unsigned int)0x71374491;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 1) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 1) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 1) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 1) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 1) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 1) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 1) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 1) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 1) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 1) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 1) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 1) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 1) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 1) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 2) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 2) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 2) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 2) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 2) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 2) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 2) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 2) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 2) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 2) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 2) % 8)]) + W[(signed long int)2] + 0xb5c0fbcf;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 2) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 2) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 2) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 2) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 2) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 2) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 2) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 2) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 2) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 2) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 2) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 2) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 2) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 2) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 3) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 3) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 3) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 3) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 3) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 3) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 3) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 3) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 3) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 3) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 3) % 8)]) + W[(signed long int)3] + 0xe9b5dba5;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 3) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 3) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 3) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 3) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 3) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 3) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 3) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 3) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 3) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 3) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 3) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 3) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 3) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 3) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 4) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 4) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 4) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 4) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 4) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 4) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 4) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 4) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 4) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 4) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 4) % 8)]) + W[(signed long int)4] + (unsigned int)0x3956c25b;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 4) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 4) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 4) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 4) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 4) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 4) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 4) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 4) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 4) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 4) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 4) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 4) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 4) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 4) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 5) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 5) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 5) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 5) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 5) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 5) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 5) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 5) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 5) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 5) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 5) % 8)]) + W[(signed long int)5] + (unsigned int)0x59f111f1;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 5) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 5) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 5) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 5) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 5) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 5) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 5) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 5) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 5) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 5) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 5) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 5) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 5) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 5) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 6) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 6) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 6) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 6) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 6) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 6) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 6) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 6) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 6) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 6) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 6) % 8)]) + W[(signed long int)6] + 0x923f82a4;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 6) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 6) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 6) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 6) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 6) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 6) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 6) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 6) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 6) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 6) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 6) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 6) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 6) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 6) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 7) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 7) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 7) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 7) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 7) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 7) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 7) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 7) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 7) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 7) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 7) % 8)]) + W[(signed long int)7] + 0xab1c5ed5;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 7) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 7) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 7) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 7) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 7) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 7) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 7) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 7) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 7) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 7) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 7) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 7) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 7) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 7) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 8) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 8) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 8) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 8) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 8) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 8) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 8) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 8) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 8) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 8) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 8) % 8)]) + W[(signed long int)8] + 0xd807aa98;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 8) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 8) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 8) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 8) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 8) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 8) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 8) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 8) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 8) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 8) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 8) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 8) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 8) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 8) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 9) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 9) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 9) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 9) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 9) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 9) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 9) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 9) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 9) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 9) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 9) % 8)]) + W[(signed long int)9] + (unsigned int)0x12835b01;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 9) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 9) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 9) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 9) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 9) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 9) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 9) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 9) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 9) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 9) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 9) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 9) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 9) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 9) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 10) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 10) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 10) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 10) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 10) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 10) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 10) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 10) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 10) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 10) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 10) % 8)]) + W[(signed long int)10] + (unsigned int)0x243185be;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 10) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 10) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 10) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 10) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 10) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 10) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 10) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 10) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 10) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 10) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 10) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 10) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 10) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 10) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 11) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 11) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 11) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 11) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 11) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 11) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 11) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 11) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 11) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 11) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 11) % 8)]) + W[(signed long int)11] + (unsigned int)0x550c7dc3;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 11) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 11) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 11) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 11) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 11) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 11) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 11) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 11) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 11) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 11) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 11) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 11) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 11) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 11) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 12) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 12) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 12) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 12) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 12) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 12) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 12) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 12) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 12) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 12) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 12) % 8)]) + W[(signed long int)12] + (unsigned int)0x72be5d74;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 12) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 12) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 12) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 12) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 12) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 12) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 12) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 12) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 12) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 12) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 12) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 12) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 12) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 12) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 13) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 13) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 13) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 13) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 13) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 13) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 13) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 13) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 13) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 13) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 13) % 8)]) + W[(signed long int)13] + 0x80deb1fe;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 13) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 13) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 13) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 13) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 13) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 13) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 13) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 13) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 13) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 13) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 13) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 13) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 13) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 13) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 14) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 14) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 14) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 14) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 14) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 14) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 14) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 14) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 14) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 14) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 14) % 8)]) + W[(signed long int)14] + 0x9bdc06a7;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 14) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 14) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 14) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 14) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 14) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 14) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 14) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 14) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 14) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 14) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 14) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 14) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 14) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 14) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 15) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 15) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 15) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 15) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 15) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 15) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 15) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 15) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 15) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 15) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 15) % 8)]) + W[(signed long int)15] + 0xc19bf174;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 15) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 15) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 15) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 15) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 15) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 15) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 15) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 15) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 15) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 15) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 15) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 15) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 15) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 15) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 16) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 16) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 16) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 16) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 16) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 16) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 16) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 16) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 16) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 16) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 16) % 8)]) + W[(signed long int)16] + 0xe49b69c1;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 16) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 16) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 16) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 16) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 16) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 16) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 16) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 16) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 16) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 16) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 16) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 16) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 16) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 16) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 17) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 17) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 17) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 17) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 17) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 17) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 17) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 17) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 17) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 17) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 17) % 8)]) + W[(signed long int)17] + 0xefbe4786;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 17) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 17) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 17) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 17) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 17) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 17) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 17) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 17) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 17) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 17) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 17) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 17) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 17) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 17) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 18) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 18) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 18) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 18) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 18) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 18) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 18) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 18) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 18) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 18) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 18) % 8)]) + W[(signed long int)18] + (unsigned int)0x0fc19dc6;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 18) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 18) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 18) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 18) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 18) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 18) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 18) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 18) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 18) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 18) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 18) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 18) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 18) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 18) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 19) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 19) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 19) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 19) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 19) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 19) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 19) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 19) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 19) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 19) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 19) % 8)]) + W[(signed long int)19] + (unsigned int)0x240ca1cc;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 19) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 19) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 19) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 19) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 19) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 19) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 19) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 19) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 19) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 19) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 19) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 19) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 19) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 19) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 20) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 20) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 20) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 20) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 20) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 20) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 20) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 20) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 20) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 20) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 20) % 8)]) + W[(signed long int)20] + (unsigned int)0x2de92c6f;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 20) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 20) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 20) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 20) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 20) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 20) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 20) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 20) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 20) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 20) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 20) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 20) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 20) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 20) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 21) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 21) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 21) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 21) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 21) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 21) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 21) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 21) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 21) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 21) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 21) % 8)]) + W[(signed long int)21] + (unsigned int)0x4a7484aa;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 21) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 21) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 21) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 21) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 21) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 21) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 21) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 21) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 21) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 21) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 21) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 21) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 21) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 21) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 22) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 22) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 22) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 22) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 22) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 22) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 22) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 22) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 22) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 22) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 22) % 8)]) + W[(signed long int)22] + (unsigned int)0x5cb0a9dc;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 22) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 22) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 22) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 22) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 22) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 22) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 22) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 22) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 22) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 22) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 22) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 22) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 22) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 22) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 23) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 23) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 23) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 23) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 23) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 23) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 23) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 23) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 23) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 23) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 23) % 8)]) + W[(signed long int)23] + (unsigned int)0x76f988da;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 23) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 23) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 23) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 23) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 23) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 23) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 23) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 23) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 23) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 23) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 23) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 23) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 23) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 23) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 24) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 24) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 24) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 24) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 24) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 24) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 24) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 24) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 24) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 24) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 24) % 8)]) + W[(signed long int)24] + 0x983e5152;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 24) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 24) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 24) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 24) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 24) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 24) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 24) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 24) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 24) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 24) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 24) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 24) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 24) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 24) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 25) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 25) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 25) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 25) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 25) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 25) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 25) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 25) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 25) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 25) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 25) % 8)]) + W[(signed long int)25] + 0xa831c66d;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 25) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 25) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 25) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 25) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 25) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 25) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 25) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 25) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 25) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 25) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 25) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 25) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 25) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 25) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 26) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 26) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 26) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 26) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 26) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 26) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 26) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 26) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 26) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 26) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 26) % 8)]) + W[(signed long int)26] + 0xb00327c8;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 26) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 26) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 26) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 26) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 26) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 26) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 26) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 26) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 26) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 26) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 26) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 26) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 26) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 26) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 27) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 27) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 27) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 27) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 27) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 27) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 27) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 27) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 27) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 27) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 27) % 8)]) + W[(signed long int)27] + 0xbf597fc7;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 27) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 27) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 27) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 27) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 27) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 27) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 27) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 27) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 27) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 27) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 27) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 27) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 27) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 27) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 28) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 28) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 28) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 28) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 28) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 28) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 28) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 28) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 28) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 28) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 28) % 8)]) + W[(signed long int)28] + 0xc6e00bf3;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 28) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 28) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 28) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 28) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 28) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 28) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 28) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 28) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 28) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 28) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 28) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 28) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 28) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 28) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 29) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 29) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 29) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 29) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 29) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 29) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 29) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 29) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 29) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 29) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 29) % 8)]) + W[(signed long int)29] + 0xd5a79147;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 29) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 29) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 29) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 29) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 29) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 29) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 29) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 29) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 29) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 29) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 29) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 29) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 29) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 29) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 30) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 30) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 30) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 30) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 30) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 30) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 30) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 30) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 30) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 30) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 30) % 8)]) + W[(signed long int)30] + (unsigned int)0x06ca6351;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 30) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 30) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 30) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 30) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 30) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 30) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 30) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 30) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 30) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 30) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 30) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 30) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 30) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 30) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 31) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 31) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 31) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 31) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 31) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 31) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 31) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 31) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 31) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 31) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 31) % 8)]) + W[(signed long int)31] + (unsigned int)0x14292967;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 31) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 31) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 31) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 31) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 31) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 31) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 31) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 31) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 31) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 31) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 31) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 31) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 31) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 31) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 32) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 32) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 32) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 32) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 32) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 32) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 32) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 32) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 32) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 32) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 32) % 8)]) + W[(signed long int)32] + (unsigned int)0x27b70a85;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 32) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 32) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 32) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 32) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 32) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 32) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 32) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 32) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 32) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 32) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 32) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 32) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 32) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 32) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 33) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 33) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 33) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 33) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 33) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 33) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 33) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 33) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 33) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 33) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 33) % 8)]) + W[(signed long int)33] + (unsigned int)0x2e1b2138;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 33) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 33) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 33) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 33) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 33) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 33) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 33) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 33) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 33) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 33) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 33) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 33) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 33) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 33) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 34) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 34) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 34) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 34) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 34) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 34) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 34) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 34) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 34) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 34) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 34) % 8)]) + W[(signed long int)34] + (unsigned int)0x4d2c6dfc;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 34) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 34) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 34) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 34) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 34) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 34) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 34) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 34) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 34) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 34) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 34) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 34) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 34) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 34) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 35) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 35) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 35) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 35) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 35) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 35) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 35) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 35) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 35) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 35) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 35) % 8)]) + W[(signed long int)35] + (unsigned int)0x53380d13;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 35) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 35) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 35) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 35) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 35) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 35) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 35) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 35) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 35) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 35) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 35) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 35) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 35) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 35) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 36) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 36) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 36) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 36) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 36) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 36) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 36) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 36) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 36) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 36) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 36) % 8)]) + W[(signed long int)36] + (unsigned int)0x650a7354;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 36) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 36) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 36) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 36) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 36) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 36) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 36) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 36) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 36) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 36) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 36) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 36) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 36) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 36) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 37) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 37) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 37) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 37) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 37) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 37) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 37) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 37) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 37) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 37) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 37) % 8)]) + W[(signed long int)37] + (unsigned int)0x766a0abb;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 37) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 37) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 37) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 37) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 37) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 37) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 37) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 37) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 37) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 37) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 37) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 37) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 37) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 37) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 38) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 38) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 38) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 38) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 38) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 38) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 38) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 38) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 38) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 38) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 38) % 8)]) + W[(signed long int)38] + 0x81c2c92e;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 38) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 38) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 38) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 38) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 38) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 38) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 38) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 38) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 38) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 38) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 38) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 38) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 38) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 38) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 39) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 39) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 39) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 39) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 39) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 39) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 39) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 39) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 39) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 39) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 39) % 8)]) + W[(signed long int)39] + 0x92722c85;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 39) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 39) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 39) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 39) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 39) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 39) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 39) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 39) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 39) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 39) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 39) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 39) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 39) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 39) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 40) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 40) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 40) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 40) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 40) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 40) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 40) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 40) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 40) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 40) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 40) % 8)]) + W[(signed long int)40] + 0xa2bfe8a1;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 40) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 40) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 40) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 40) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 40) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 40) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 40) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 40) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 40) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 40) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 40) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 40) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 40) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 40) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 41) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 41) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 41) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 41) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 41) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 41) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 41) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 41) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 41) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 41) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 41) % 8)]) + W[(signed long int)41] + 0xa81a664b;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 41) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 41) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 41) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 41) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 41) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 41) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 41) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 41) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 41) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 41) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 41) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 41) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 41) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 41) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 42) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 42) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 42) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 42) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 42) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 42) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 42) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 42) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 42) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 42) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 42) % 8)]) + W[(signed long int)42] + 0xc24b8b70;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 42) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 42) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 42) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 42) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 42) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 42) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 42) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 42) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 42) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 42) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 42) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 42) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 42) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 42) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 43) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 43) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 43) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 43) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 43) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 43) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 43) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 43) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 43) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 43) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 43) % 8)]) + W[(signed long int)43] + 0xc76c51a3;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 43) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 43) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 43) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 43) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 43) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 43) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 43) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 43) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 43) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 43) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 43) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 43) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 43) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 43) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 44) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 44) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 44) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 44) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 44) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 44) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 44) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 44) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 44) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 44) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 44) % 8)]) + W[(signed long int)44] + 0xd192e819;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 44) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 44) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 44) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 44) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 44) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 44) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 44) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 44) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 44) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 44) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 44) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 44) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 44) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 44) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 45) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 45) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 45) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 45) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 45) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 45) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 45) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 45) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 45) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 45) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 45) % 8)]) + W[(signed long int)45] + 0xd6990624;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 45) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 45) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 45) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 45) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 45) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 45) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 45) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 45) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 45) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 45) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 45) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 45) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 45) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 45) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 46) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 46) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 46) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 46) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 46) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 46) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 46) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 46) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 46) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 46) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 46) % 8)]) + W[(signed long int)46] + 0xf40e3585;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 46) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 46) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 46) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 46) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 46) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 46) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 46) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 46) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 46) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 46) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 46) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 46) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 46) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 46) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 47) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 47) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 47) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 47) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 47) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 47) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 47) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 47) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 47) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 47) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 47) % 8)]) + W[(signed long int)47] + (unsigned int)0x106aa070;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 47) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 47) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 47) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 47) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 47) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 47) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 47) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 47) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 47) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 47) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 47) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 47) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 47) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 47) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 48) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 48) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 48) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 48) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 48) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 48) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 48) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 48) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 48) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 48) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 48) % 8)]) + W[(signed long int)48] + (unsigned int)0x19a4c116;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 48) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 48) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 48) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 48) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 48) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 48) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 48) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 48) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 48) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 48) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 48) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 48) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 48) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 48) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 49) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 49) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 49) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 49) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 49) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 49) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 49) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 49) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 49) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 49) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 49) % 8)]) + W[(signed long int)49] + (unsigned int)0x1e376c08;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 49) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 49) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 49) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 49) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 49) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 49) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 49) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 49) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 49) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 49) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 49) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 49) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 49) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 49) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 50) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 50) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 50) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 50) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 50) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 50) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 50) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 50) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 50) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 50) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 50) % 8)]) + W[(signed long int)50] + (unsigned int)0x2748774c;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 50) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 50) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 50) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 50) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 50) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 50) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 50) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 50) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 50) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 50) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 50) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 50) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 50) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 50) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 51) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 51) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 51) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 51) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 51) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 51) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 51) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 51) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 51) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 51) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 51) % 8)]) + W[(signed long int)51] + (unsigned int)0x34b0bcb5;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 51) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 51) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 51) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 51) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 51) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 51) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 51) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 51) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 51) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 51) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 51) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 51) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 51) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 51) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 52) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 52) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 52) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 52) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 52) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 52) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 52) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 52) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 52) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 52) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 52) % 8)]) + W[(signed long int)52] + (unsigned int)0x391c0cb3;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 52) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 52) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 52) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 52) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 52) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 52) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 52) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 52) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 52) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 52) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 52) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 52) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 52) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 52) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 53) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 53) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 53) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 53) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 53) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 53) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 53) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 53) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 53) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 53) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 53) % 8)]) + W[(signed long int)53] + (unsigned int)0x4ed8aa4a;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 53) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 53) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 53) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 53) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 53) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 53) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 53) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 53) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 53) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 53) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 53) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 53) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 53) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 53) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 54) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 54) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 54) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 54) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 54) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 54) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 54) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 54) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 54) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 54) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 54) % 8)]) + W[(signed long int)54] + (unsigned int)0x5b9cca4f;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 54) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 54) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 54) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 54) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 54) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 54) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 54) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 54) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 54) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 54) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 54) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 54) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 54) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 54) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 55) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 55) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 55) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 55) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 55) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 55) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 55) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 55) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 55) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 55) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 55) % 8)]) + W[(signed long int)55] + (unsigned int)0x682e6ff3;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 55) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 55) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 55) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 55) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 55) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 55) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 55) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 55) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 55) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 55) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 55) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 55) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 55) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 55) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 56) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 56) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 56) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 56) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 56) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 56) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 56) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 56) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 56) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 56) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 56) % 8)]) + W[(signed long int)56] + (unsigned int)0x748f82ee;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 56) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 56) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 56) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 56) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 56) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 56) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 56) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 56) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 56) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 56) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 56) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 56) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 56) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 56) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 57) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 57) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 57) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 57) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 57) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 57) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 57) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 57) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 57) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 57) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 57) % 8)]) + W[(signed long int)57] + (unsigned int)0x78a5636f;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 57) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 57) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 57) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 57) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 57) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 57) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 57) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 57) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 57) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 57) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 57) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 57) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 57) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 57) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 58) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 58) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 58) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 58) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 58) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 58) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 58) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 58) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 58) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 58) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 58) % 8)]) + W[(signed long int)58] + 0x84c87814;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 58) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 58) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 58) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 58) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 58) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 58) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 58) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 58) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 58) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 58) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 58) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 58) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 58) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 58) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 59) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 59) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 59) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 59) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 59) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 59) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 59) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 59) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 59) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 59) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 59) % 8)]) + W[(signed long int)59] + 0x8cc70208;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 59) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 59) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 59) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 59) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 59) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 59) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 59) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 59) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 59) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 59) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 59) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 59) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 59) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 59) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 60) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 60) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 60) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 60) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 60) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 60) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 60) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 60) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 60) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 60) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 60) % 8)]) + W[(signed long int)60] + 0x90befffa;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 60) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 60) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 60) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 60) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 60) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 60) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 60) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 60) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 60) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 60) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 60) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 60) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 60) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 60) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 61) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 61) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 61) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 61) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 61) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 61) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 61) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 61) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 61) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 61) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 61) % 8)]) + W[(signed long int)61] + 0xa4506ceb;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 61) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 61) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 61) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 61) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 61) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 61) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 61) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 61) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 61) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 61) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 61) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 61) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 61) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 61) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 62) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 62) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 62) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 62) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 62) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 62) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 62) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 62) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 62) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 62) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 62) % 8)]) + W[(signed long int)62] + 0xbef9a3f7;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 62) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 62) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 62) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 62) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 62) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 62) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 62) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 62) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 62) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 62) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 62) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 62) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 62) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 62) % 8)] = t0 + t1;
  t0 = SHA256_Transform__1__S[(signed long int)((71 - 63) % 8)] + ((SHA256_Transform__1__S[(signed long int)((68 - 63) % 8)] >> 6 | SHA256_Transform__1__S[(signed long int)((68 - 63) % 8)] << 32 - 6) ^ (SHA256_Transform__1__S[(signed long int)((68 - 63) % 8)] >> 11 | SHA256_Transform__1__S[(signed long int)((68 - 63) % 8)] << 32 - 11) ^ (SHA256_Transform__1__S[(signed long int)((68 - 63) % 8)] >> 25 | SHA256_Transform__1__S[(signed long int)((68 - 63) % 8)] << 32 - 25)) + (SHA256_Transform__1__S[(signed long int)((68 - 63) % 8)] & (SHA256_Transform__1__S[(signed long int)((69 - 63) % 8)] ^ SHA256_Transform__1__S[(signed long int)((70 - 63) % 8)]) ^ SHA256_Transform__1__S[(signed long int)((70 - 63) % 8)]) + W[(signed long int)63] + 0xc67178f2;
  t1 = ((SHA256_Transform__1__S[(signed long int)((64 - 63) % 8)] >> 2 | SHA256_Transform__1__S[(signed long int)((64 - 63) % 8)] << 32 - 2) ^ (SHA256_Transform__1__S[(signed long int)((64 - 63) % 8)] >> 13 | SHA256_Transform__1__S[(signed long int)((64 - 63) % 8)] << 32 - 13) ^ (SHA256_Transform__1__S[(signed long int)((64 - 63) % 8)] >> 22 | SHA256_Transform__1__S[(signed long int)((64 - 63) % 8)] << 32 - 22)) + (SHA256_Transform__1__S[(signed long int)((64 - 63) % 8)] & (SHA256_Transform__1__S[(signed long int)((65 - 63) % 8)] | SHA256_Transform__1__S[(signed long int)((66 - 63) % 8)]) | SHA256_Transform__1__S[(signed long int)((65 - 63) % 8)] & SHA256_Transform__1__S[(signed long int)((66 - 63) % 8)]);
  SHA256_Transform__1__S[(signed long int)((67 - 63) % 8)] = SHA256_Transform__1__S[(signed long int)((67 - 63) % 8)] + t0;
  SHA256_Transform__1__S[(signed long int)((71 - 63) % 8)] = t0 + t1;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    state[(signed long int)i] = state[(signed long int)i] + SHA256_Transform__1__S[(signed long int)i];
  insecure_memzero((volatile void *)W, (unsigned long int)256);
  insecure_memzero((volatile void *)SHA256_Transform__1__S, (unsigned long int)32);
  insecure_memzero((volatile void *)&t0, sizeof(unsigned int) /*4ul*/ );
  insecure_memzero((volatile void *)&t1, sizeof(unsigned int) /*4ul*/ );
}

// __get_cpuid
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/cpuid.h line 233
static inline signed int __get_cpuid(unsigned int __level, unsigned int *__eax, unsigned int *__ebx, unsigned int *__ecx, unsigned int *__edx)
{
  unsigned int __ext = __level & 0x80000000;
  unsigned int return_value___get_cpuid_max_1;
  return_value___get_cpuid_max_1=__get_cpuid_max(__ext, ((unsigned int *)NULL));
  if(!(return_value___get_cpuid_max_1 >= __level))
    return 0;

  else
  {
    asm("cpuid\n\t" : "=a"(*__eax), "=b"(*__ebx), "=c"(*__ecx), "=d"(*__edx) : "0"(__level) : );
    return 1;
  }
}

// __get_cpuid_max
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/cpuid.h line 178
static inline unsigned int __get_cpuid_max(unsigned int __ext, unsigned int *__sig)
{
  unsigned int __eax;
  unsigned int __ebx;
  unsigned int __ecx;
  unsigned int __edx;
  asm("cpuid\n\t" : "=a"(__eax), "=b"(__ebx), "=c"(__ecx), "=d"(__edx) : "0"(__ext) : );
  if(!(__sig == ((unsigned int *)NULL)))
    *__sig = __ebx;

  return __eax;
}

// _mm_aesenc_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/wmmintrin.h line 61
static inline __gcc_v2di _mm_aesenc_si128(__gcc_v2di __X, __gcc_v2di __Y)
{
  __gcc_v2di return_value___builtin_ia32_aesenc128_1;
  return_value___builtin_ia32_aesenc128_1=__builtin_ia32_aesenc128((__gcc_v2di)__X, (__gcc_v2di)__Y);
  return (__gcc_v2di)return_value___builtin_ia32_aesenc128_1;
}

// _mm_aesenclast_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/wmmintrin.h line 69
static inline __gcc_v2di _mm_aesenclast_si128(__gcc_v2di __X, __gcc_v2di __Y)
{
  __gcc_v2di return_value___builtin_ia32_aesenclast128_1;
  return_value___builtin_ia32_aesenclast128_1=__builtin_ia32_aesenclast128((__gcc_v2di)__X, (__gcc_v2di)__Y);
  return (__gcc_v2di)return_value___builtin_ia32_aesenclast128_1;
}

// _mm_loadu_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 696
static inline __gcc_v2di _mm_loadu_si128(const __gcc_v2di *__P)
{
  __gcc_v16qi return_value___builtin_ia32_loaddqu_1;
  return_value___builtin_ia32_loaddqu_1=__builtin_ia32_loaddqu((const char *)__P);
  return (__gcc_v2di)return_value___builtin_ia32_loaddqu_1;
}

// _mm_storeu_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 714
static inline void _mm_storeu_si128(__gcc_v2di *__P, __gcc_v2di __B)
{
  __builtin_ia32_storedqu((char *)__P, (__gcc_v16qi)__B);
}

// _mm_xor_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1286
static inline __gcc_v2di _mm_xor_si128(__gcc_v2di __A, __gcc_v2di __B)
{
  return (__gcc_v2di)((unsigned long long int __attribute__((vector_size (2l*sizeof(unsigned long long int)))))__A ^ (unsigned long long int __attribute__((vector_size (2l*sizeof(unsigned long long int)))))__B);
}

// aesnitest
// file ../libcperciva/crypto/crypto_aes.c line 26
static signed int aesnitest(unsigned char *ptext, unsigned char *key, unsigned long int keylen)
{
  struct aes_key_st kexp_openssl;
  void *kexp_aesni;
  unsigned char ctext_openssl[16l];
  unsigned char ctext_aesni[16l];
  AES_set_encrypt_key(key, (const signed int)(keylen * (unsigned long int)8), &kexp_openssl);
  kexp_aesni=crypto_aes_key_expand_aesni(key, keylen);
  signed int return_value_memcmp_1;
  if(!(kexp_aesni == NULL))
  {
    AES_encrypt(ptext, ctext_openssl, &kexp_openssl);
    crypto_aes_encrypt_block_aesni(ptext, ctext_aesni, kexp_aesni);
    crypto_aes_key_free_aesni(kexp_aesni);
    return_value_memcmp_1=memcmp((const void *)ctext_openssl, (const void *)ctext_aesni, (unsigned long int)16);
    return return_value_memcmp_1;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// be32dec_vect
// file ../libcperciva/alg/sha256.c line 32
static void be32dec_vect(unsigned int *dst, const unsigned char *src, unsigned long int len)
{
  unsigned long int i;
  /* assertion len % 4 == 0 */
  assert(len % (unsigned long int)4 == (unsigned long int)0);
  i = (unsigned long int)0;
  for( ; !(i >= len / 4ul); i = i + 1ul)
    dst[(signed long int)i]=libcperciva_be32dec_link1((const void *)(src + (signed long int)(i * (unsigned long int)4)));
}

// be32enc_vect
// file ../libcperciva/alg/sha256.c line 15
static void be32enc_vect(unsigned char *dst, const unsigned int *src, unsigned long int len)
{
  unsigned long int i;
  /* assertion len % 4 == 0 */
  assert(len % (unsigned long int)4 == (unsigned long int)0);
  i = (unsigned long int)0;
  for( ; !(i >= len / 4ul); i = i + 1ul)
    libcperciva_be32enc_link1((void *)(dst + (signed long int)(i * (unsigned long int)4)), src[(signed long int)i]);
}

// blinded_modexp
// file ../libcperciva/crypto/crypto_dh.c line 36
static signed int blinded_modexp(unsigned char *r, struct bignum_st *a, const unsigned char *priv)
{
  struct bignum_st *two_exp_256_bn;
  struct bignum_st *priv_bn;
  unsigned char blinding[32l];
  struct bignum_st *blinding_bn;
  struct bignum_st *priv_blinded;
  struct bignum_st *m_bn;
  struct bignum_ctx *ctx;
  struct bignum_st *r1;
  struct bignum_st *r2;
  unsigned long int rlen;
  two_exp_256_bn=BN_bin2bn(two_exp_256, 33, (struct bignum_st *)(void *)0);
  signed int return_value_BN_add_10;
  _Bool tmp_if_expr_12;
  signed int return_value_BN_add_11;
  _Bool tmp_if_expr_14;
  signed int return_value_BN_add_13;
  _Bool tmp_if_expr_16;
  signed int return_value_BN_add_15;
  signed int return_value_crypto_entropy_read_17;
  signed int return_value_BN_add_24;
  signed int return_value_BN_sub_31;
  signed int return_value_BN_mod_exp_47;
  signed int return_value_BN_mod_exp_51;
  signed int return_value_BN_mod_mul_55;
  signed int return_value_BN_num_bits_56;
  if(two_exp_256_bn == ((struct bignum_st *)NULL))
    do
    {
      unsigned long int return_value_ERR_get_error_1;
      return_value_ERR_get_error_1=ERR_get_error();
      char *return_value_ERR_error_string_2;
      return_value_ERR_error_string_2=ERR_error_string(return_value_ERR_get_error_1, (char *)(void *)0);
      libcperciva_warnx("%s", return_value_ERR_error_string_2);
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 0;
    }
    while((_Bool)0);

  else
  {
    priv_bn=BN_bin2bn(priv, 32, (struct bignum_st *)(void *)0);
    if(priv_bn == ((struct bignum_st *)NULL))
      do
      {
        unsigned long int return_value_ERR_get_error_4;
        return_value_ERR_get_error_4=ERR_get_error();
        char *return_value_ERR_error_string_5;
        return_value_ERR_error_string_5=ERR_error_string(return_value_ERR_get_error_4, (char *)(void *)0);
        libcperciva_warnx("%s", return_value_ERR_error_string_5);
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        *return_value___errno_location_6 = 0;
      }
      while((_Bool)0);

    else
    {
      return_value_BN_add_10=BN_add(priv_bn, priv_bn, two_exp_256_bn);
      if(return_value_BN_add_10 == 0)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_BN_add_11=BN_add(priv_bn, priv_bn, two_exp_256_bn);
        tmp_if_expr_12 = !(return_value_BN_add_11 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
        tmp_if_expr_14 = (_Bool)1;

      else
      {
        return_value_BN_add_13=BN_add(priv_bn, priv_bn, two_exp_256_bn);
        tmp_if_expr_14 = !(return_value_BN_add_13 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_14)
        tmp_if_expr_16 = (_Bool)1;

      else
      {
        return_value_BN_add_15=BN_add(priv_bn, priv_bn, two_exp_256_bn);
        tmp_if_expr_16 = !(return_value_BN_add_15 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_16)
        do
        {
          unsigned long int return_value_ERR_get_error_7;
          return_value_ERR_get_error_7=ERR_get_error();
          char *return_value_ERR_error_string_8;
          return_value_ERR_error_string_8=ERR_error_string(return_value_ERR_get_error_7, (char *)(void *)0);
          libcperciva_warnx("%s", return_value_ERR_error_string_8);
          signed int *return_value___errno_location_9;
          return_value___errno_location_9=__errno_location();
          *return_value___errno_location_9 = 0;
        }
        while((_Bool)0);

      else
      {
        return_value_crypto_entropy_read_17=crypto_entropy_read(blinding, (unsigned long int)32);
        if(return_value_crypto_entropy_read_17 == 0)
        {
          blinding_bn=BN_bin2bn(blinding, 32, (struct bignum_st *)(void *)0);
          if(blinding_bn == ((struct bignum_st *)NULL))
            do
            {
              unsigned long int return_value_ERR_get_error_18;
              return_value_ERR_get_error_18=ERR_get_error();
              char *return_value_ERR_error_string_19;
              return_value_ERR_error_string_19=ERR_error_string(return_value_ERR_get_error_18, (char *)(void *)0);
              libcperciva_warnx("%s", return_value_ERR_error_string_19);
              signed int *return_value___errno_location_20;
              return_value___errno_location_20=__errno_location();
              *return_value___errno_location_20 = 0;
            }
            while((_Bool)0);

          else
          {
            return_value_BN_add_24=BN_add(blinding_bn, blinding_bn, two_exp_256_bn);
            if(return_value_BN_add_24 == 0)
              do
              {
                unsigned long int return_value_ERR_get_error_21;
                return_value_ERR_get_error_21=ERR_get_error();
                char *return_value_ERR_error_string_22;
                return_value_ERR_error_string_22=ERR_error_string(return_value_ERR_get_error_21, (char *)(void *)0);
                libcperciva_warnx("%s", return_value_ERR_error_string_22);
                signed int *return_value___errno_location_23;
                return_value___errno_location_23=__errno_location();
                *return_value___errno_location_23 = 0;
              }
              while((_Bool)0);

            else
            {
              priv_blinded=BN_new();
              if(priv_blinded == ((struct bignum_st *)NULL))
                do
                {
                  unsigned long int return_value_ERR_get_error_25;
                  return_value_ERR_get_error_25=ERR_get_error();
                  char *return_value_ERR_error_string_26;
                  return_value_ERR_error_string_26=ERR_error_string(return_value_ERR_get_error_25, (char *)(void *)0);
                  libcperciva_warnx("%s", return_value_ERR_error_string_26);
                  signed int *return_value___errno_location_27;
                  return_value___errno_location_27=__errno_location();
                  *return_value___errno_location_27 = 0;
                }
                while((_Bool)0);

              else
              {
                return_value_BN_sub_31=BN_sub(priv_blinded, priv_bn, blinding_bn);
                if(return_value_BN_sub_31 == 0)
                  do
                  {
                    unsigned long int return_value_ERR_get_error_28;
                    return_value_ERR_get_error_28=ERR_get_error();
                    char *return_value_ERR_error_string_29;
                    return_value_ERR_error_string_29=ERR_error_string(return_value_ERR_get_error_28, (char *)(void *)0);
                    libcperciva_warnx("%s", return_value_ERR_error_string_29);
                    signed int *return_value___errno_location_30;
                    return_value___errno_location_30=__errno_location();
                    *return_value___errno_location_30 = 0;
                  }
                  while((_Bool)0);

                else
                {
                  m_bn=BN_bin2bn(crypto_dh_group14, 256, (struct bignum_st *)(void *)0);
                  if(m_bn == ((struct bignum_st *)NULL))
                    do
                    {
                      unsigned long int return_value_ERR_get_error_32;
                      return_value_ERR_get_error_32=ERR_get_error();
                      char *return_value_ERR_error_string_33;
                      return_value_ERR_error_string_33=ERR_error_string(return_value_ERR_get_error_32, (char *)(void *)0);
                      libcperciva_warnx("%s", return_value_ERR_error_string_33);
                      signed int *return_value___errno_location_34;
                      return_value___errno_location_34=__errno_location();
                      *return_value___errno_location_34 = 0;
                    }
                    while((_Bool)0);

                  else
                  {
                    ctx=BN_CTX_new();
                    if(ctx == ((struct bignum_ctx *)NULL))
                      do
                      {
                        unsigned long int return_value_ERR_get_error_35;
                        return_value_ERR_get_error_35=ERR_get_error();
                        char *return_value_ERR_error_string_36;
                        return_value_ERR_error_string_36=ERR_error_string(return_value_ERR_get_error_35, (char *)(void *)0);
                        libcperciva_warnx("%s", return_value_ERR_error_string_36);
                        signed int *return_value___errno_location_37;
                        return_value___errno_location_37=__errno_location();
                        *return_value___errno_location_37 = 0;
                      }
                      while((_Bool)0);

                    else
                    {
                      r1=BN_new();
                      if(r1 == ((struct bignum_st *)NULL))
                        do
                        {
                          unsigned long int return_value_ERR_get_error_38;
                          return_value_ERR_get_error_38=ERR_get_error();
                          char *return_value_ERR_error_string_39;
                          return_value_ERR_error_string_39=ERR_error_string(return_value_ERR_get_error_38, (char *)(void *)0);
                          libcperciva_warnx("%s", return_value_ERR_error_string_39);
                          signed int *return_value___errno_location_40;
                          return_value___errno_location_40=__errno_location();
                          *return_value___errno_location_40 = 0;
                        }
                        while((_Bool)0);

                      else
                      {
                        r2=BN_new();
                        if(r2 == ((struct bignum_st *)NULL))
                          do
                          {
                            unsigned long int return_value_ERR_get_error_41;
                            return_value_ERR_get_error_41=ERR_get_error();
                            char *return_value_ERR_error_string_42;
                            return_value_ERR_error_string_42=ERR_error_string(return_value_ERR_get_error_41, (char *)(void *)0);
                            libcperciva_warnx("%s", return_value_ERR_error_string_42);
                            signed int *return_value___errno_location_43;
                            return_value___errno_location_43=__errno_location();
                            *return_value___errno_location_43 = 0;
                          }
                          while((_Bool)0);

                        else
                        {
                          return_value_BN_mod_exp_47=BN_mod_exp(r1, a, blinding_bn, m_bn, ctx);
                          if(return_value_BN_mod_exp_47 == 0)
                            do
                            {
                              unsigned long int return_value_ERR_get_error_44;
                              return_value_ERR_get_error_44=ERR_get_error();
                              char *return_value_ERR_error_string_45;
                              return_value_ERR_error_string_45=ERR_error_string(return_value_ERR_get_error_44, (char *)(void *)0);
                              libcperciva_warnx("%s", return_value_ERR_error_string_45);
                              signed int *return_value___errno_location_46;
                              return_value___errno_location_46=__errno_location();
                              *return_value___errno_location_46 = 0;
                            }
                            while((_Bool)0);

                          else
                          {
                            return_value_BN_mod_exp_51=BN_mod_exp(r2, a, priv_blinded, m_bn, ctx);
                            if(return_value_BN_mod_exp_51 == 0)
                              do
                              {
                                unsigned long int return_value_ERR_get_error_48;
                                return_value_ERR_get_error_48=ERR_get_error();
                                char *return_value_ERR_error_string_49;
                                return_value_ERR_error_string_49=ERR_error_string(return_value_ERR_get_error_48, (char *)(void *)0);
                                libcperciva_warnx("%s", return_value_ERR_error_string_49);
                                signed int *return_value___errno_location_50;
                                return_value___errno_location_50=__errno_location();
                                *return_value___errno_location_50 = 0;
                              }
                              while((_Bool)0);

                            else
                            {
                              return_value_BN_mod_mul_55=BN_mod_mul(r1, r1, r2, m_bn, ctx);
                              if(return_value_BN_mod_mul_55 == 0)
                                do
                                {
                                  unsigned long int return_value_ERR_get_error_52;
                                  return_value_ERR_get_error_52=ERR_get_error();
                                  char *return_value_ERR_error_string_53;
                                  return_value_ERR_error_string_53=ERR_error_string(return_value_ERR_get_error_52, (char *)(void *)0);
                                  libcperciva_warnx("%s", return_value_ERR_error_string_53);
                                  signed int *return_value___errno_location_54;
                                  return_value___errno_location_54=__errno_location();
                                  *return_value___errno_location_54 = 0;
                                }
                                while((_Bool)0);

                              else
                              {
                                return_value_BN_num_bits_56=BN_num_bits(r1);
                                rlen = (unsigned long int)((return_value_BN_num_bits_56 + 7) / 8);
                                if(rlen >= 257ul)
                                  do
                                  {
                                    libcperciva_warnx("Exponent result too large!");
                                    signed int *return_value___errno_location_57;
                                    return_value___errno_location_57=__errno_location();
                                    *return_value___errno_location_57 = 0;
                                  }
                                  while((_Bool)0);

                                else
                                {
                                  memset((void *)r, 0, (unsigned long int)256 - rlen);
                                  BN_bn2bin(r1, (r + (signed long int)256) - (signed long int)rlen);
                                  BN_clear_free(r2);
                                  BN_clear_free(r1);
                                  BN_CTX_free(ctx);
                                  BN_free(m_bn);
                                  BN_clear_free(priv_blinded);
                                  BN_clear_free(blinding_bn);
                                  BN_clear_free(priv_bn);
                                  BN_free(two_exp_256_bn);
                                  return 0;
                                }
                              }
                            }
                          }

                        err8:
                          ;
                          BN_clear_free(r2);
                        }

                      err7:
                        ;
                        BN_clear_free(r1);
                      }

                    err6:
                      ;
                      BN_CTX_free(ctx);
                    }

                  err5:
                    ;
                    BN_free(m_bn);
                  }
                }

              err4:
                ;
                BN_clear_free(priv_blinded);
              }
            }

          err3:
            ;
            BN_clear_free(blinding_bn);
          }
        }

      }

    err2:
      ;
      BN_clear_free(priv_bn);
    }

  err1:
    ;
    BN_free(two_exp_256_bn);
  }

err0:
  ;
  return -1;
}

// callback_accept
// file ../libcperciva/network/network_accept.c line 19
static signed int callback_accept(void *cookie)
{
  struct accept_cookie *C = (struct accept_cookie *)cookie;
  signed int s;
  signed int rc;
  s=accept(C->fd, (struct sockaddr *)(void *)0, (unsigned int *)(void *)0);
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  _Bool tmp_if_expr_7;
  signed int *return_value___errno_location_6;
  if(s == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 11)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value___errno_location_2=__errno_location();
      tmp_if_expr_3 = *return_value___errno_location_2 == 11 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value___errno_location_4=__errno_location();
      tmp_if_expr_5 = *return_value___errno_location_4 == 103 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value___errno_location_6=__errno_location();
      tmp_if_expr_7 = *return_value___errno_location_6 == 4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      goto tryagain;

  }

  rc=C->callback(C->cookie, s);
  free((void *)C);
  return rc;

tryagain:
  ;
  signed int return_value_events_network_register_8;
  return_value_events_network_register_8=events_network_register(callback_accept, (void *)C, C->fd, 0);
  return return_value_events_network_register_8;
}

// callback_buf
// file ../libcperciva/network/network_read.c line 43
static signed int callback_buf(void *cookie)
{
  struct network_read_cookie *C = (struct network_read_cookie *)cookie;
  unsigned long int oplen;
  signed long int len;
  oplen = C->buflen - C->bufpos;
  len=recv(C->fd, (void *)(C->buf + (signed long int)C->bufpos), oplen, 0);
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  if(len == -1l)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 11)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value___errno_location_2=__errno_location();
      tmp_if_expr_3 = *return_value___errno_location_2 == 11 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value___errno_location_4=__errno_location();
      tmp_if_expr_5 = *return_value___errno_location_4 == 4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      goto tryagain;

    goto failed;
  }

  else
    if(len == 0l)
      goto eof;

  C->bufpos = C->bufpos + (unsigned long int)len;
  signed int return_value_docallback_6;
  signed int return_value_docallback_8;
  if(C->bufpos >= C->minlen)
  {
    return_value_docallback_6=docallback_link1(C, (signed long int)C->bufpos);
    return return_value_docallback_6;
  }

  else
  {

  tryagain:
    ;
    signed int return_value_events_network_register_7;
    return_value_events_network_register_7=events_network_register(callback_buf, (void *)C, C->fd, 0);
    if(return_value_events_network_register_7 == 0)
    {
      return 0;

    eof:
      ;
      return_value_docallback_8=docallback_link1(C, (signed long int)0);
      return return_value_docallback_8;
    }

    else
    {

    failed:
      ;
      signed int return_value_docallback_9;
      return_value_docallback_9=docallback_link1(C, (signed long int)-1);
      return return_value_docallback_9;
    }
  }
}

// callback_buf_link1
// file ../libcperciva/network/network_write.c line 61
static signed int callback_buf_link1(void *cookie_link1)
{
  struct network_write_cookie *C_link1 = (struct network_write_cookie *)cookie_link1;
  unsigned long int oplen_link1;
  signed long int len_link1;
  oplen_link1 = C_link1->buflen - C_link1->bufpos;
  len_link1=send(C_link1->fd, (const void *)(C_link1->buf + (signed long int)C_link1->bufpos), oplen_link1, 16384);
  /* assertion len != 0 */
  assert(len_link1 != (signed long int)0);
  _Bool tmp_if_expr_3_link1;
  signed int *return_value___errno_location_2_link1;
  _Bool tmp_if_expr_5_link1;
  signed int *return_value___errno_location_4_link1;
  if(len_link1 == -1l)
  {
    signed int *return_value___errno_location_1_link1;
    return_value___errno_location_1_link1=__errno_location();
    if(*return_value___errno_location_1_link1 == 11)
      tmp_if_expr_3_link1 = (_Bool)1;

    else
    {
      return_value___errno_location_2_link1=__errno_location();
      tmp_if_expr_3_link1 = *return_value___errno_location_2_link1 == 11 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3_link1)
      tmp_if_expr_5_link1 = (_Bool)1;

    else
    {
      return_value___errno_location_4_link1=__errno_location();
      tmp_if_expr_5_link1 = *return_value___errno_location_4_link1 == 4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5_link1)
      goto tryagain;

    goto failed;
  }

  C_link1->bufpos = C_link1->bufpos + (unsigned long int)len_link1;
  signed int return_value_docallback_6_link1;
  if(C_link1->bufpos >= C_link1->minlen)
  {
    return_value_docallback_6_link1=docallback_link2(C_link1, (signed long int)C_link1->bufpos);
    return return_value_docallback_6_link1;
  }

  else
  {

  tryagain:
    ;
    signed int return_value_events_network_register_7_link1;
    return_value_events_network_register_7_link1=events_network_register(callback_buf_link1, (void *)C_link1, C_link1->fd, 1);
    if(return_value_events_network_register_7_link1 == 0)
      return 0;

    else
    {

    failed:
      ;
      signed int return_value_docallback_8_link1;
      return_value_docallback_8_link1=docallback_link2(C_link1, (signed long int)-1);
      return return_value_docallback_8_link1;
    }
  }
}

// callback_conndied
// file dispatch.c line 93
static signed int callback_conndied(void *cookie)
{
  struct accept_state *A = (struct accept_state *)cookie;
  A->nconn = A->nconn - (unsigned long int)1;
  signed int return_value_doaccept_1;
  return_value_doaccept_1=doaccept(A);
  return return_value_doaccept_1;
}

// callback_connect
// file ../libcperciva/network/network_connect.c line 65
static signed int callback_connect(void *cookie)
{
  struct connect_cookie *C = (struct connect_cookie *)cookie;
  signed int sockerr;
  unsigned int sockerrlen = (unsigned int)sizeof(signed int) /*4ul*/ ;
  if(!(C->cookie_timeo == NULL))
  {
    events_timer_cancel(C->cookie_timeo);
    C->cookie_timeo = (void *)0;
  }

  signed int return_value_getsockopt_1;
  return_value_getsockopt_1=getsockopt(C->s, 1, 4, (void *)&sockerr, &sockerrlen);
  signed int return_value_dofailed_2;
  signed int return_value_docallback_3;
  if(return_value_getsockopt_1 == 0)
  {
    if(!(sockerr == 0))
    {
      return_value_dofailed_2=dofailed(C);
      return return_value_dofailed_2;
    }

    return_value_docallback_3=docallback((void *)C);
    return return_value_docallback_3;
  }

  else
  {

  err1:
    ;
    close(C->s);
    free((void *)C);
    return -1;
  }
}

// callback_connect_done
// file ../proto/proto_conn.c line 231
static signed int callback_connect_done(void *cookie, signed int t)
{
  struct conn_state *C = (struct conn_state *)cookie;
  C->connect_cookie = (void *)0;
  sock_addr_freelist(C->sas);
  C->sas = (struct sock_addr **)(void *)0;
  events_timer_cancel(C->connect_timeout_cookie);
  C->connect_timeout_cookie = (void *)0;
  C->t = t;
  signed int return_value_dropconn_1;
  if(C->t == -1)
  {
    return_value_dropconn_1=dropconn(C);
    return return_value_dropconn_1;
  }

  else
  {
    if(C->decr == 0)
    {
      signed int return_value_starthandshake_2;
      return_value_starthandshake_2=starthandshake(C, C->t, C->decr);
      if(!(return_value_starthandshake_2 == 0))
        goto err1;

    }

    if(!(C->t == -1))
    {
      if(!(C->k_f == ((struct proto_keys *)NULL)))
      {
        if(!(C->k_r == ((struct proto_keys *)NULL)))
        {
          signed int return_value_launchpipes_3;
          return_value_launchpipes_3=launchpipes(C);
          if(!(return_value_launchpipes_3 == 0))
            goto err1;

        }

      }

    }

    return 0;

  err1:
    ;
    dropconn(C);
    return -1;
  }
}

// callback_connect_timeout
// file ../proto/proto_conn.c line 274
static signed int callback_connect_timeout(void *cookie)
{
  struct conn_state *C = (struct conn_state *)cookie;
  C->connect_timeout_cookie = (void *)0;
  signed int return_value_dropconn_1;
  return_value_dropconn_1=dropconn(C);
  return return_value_dropconn_1;
}

// callback_dh_read
// file ../proto/proto_handshake.c line 206
static signed int callback_dh_read(void *cookie, signed long int len)
{
  struct handshake_cookie *H = (struct handshake_cookie *)cookie;
  H->read_cookie = (void *)0;
  signed int return_value_handshakefail_1;
  signed int return_value_handshakefail_2;
  signed int return_value_dhwrite_4;
  signed int return_value_handshakedone_5;
  if(!(len >= 288l))
  {
    return_value_handshakefail_1=handshakefail(H);
    return return_value_handshakefail_1;
  }

  else
  {
    signed int return_value_proto_crypt_dh_validate_3;
    return_value_proto_crypt_dh_validate_3=proto_crypt_dh_validate(H->yh_remote, H->dhmac_remote, H->requirefps);
    if(!(return_value_proto_crypt_dh_validate_3 == 0))
    {
      return_value_handshakefail_2=handshakefail(H);
      return return_value_handshakefail_2;
    }

    else
      if(!(H->decr == 0))
      {
        return_value_dhwrite_4=dhwrite(H);
        return return_value_dhwrite_4;
      }

      else
      {
        return_value_handshakedone_5=handshakedone(H);
        return return_value_handshakedone_5;
      }
  }
}

// callback_dh_write
// file ../proto/proto_handshake.c line 259
static signed int callback_dh_write(void *cookie, signed long int len)
{
  struct handshake_cookie *H = (struct handshake_cookie *)cookie;
  H->write_cookie = (void *)0;
  signed int return_value_handshakefail_1;
  signed int return_value_handshakedone_2;
  signed int return_value_dhread_3;
  if(!(len >= 288l))
  {
    return_value_handshakefail_1=handshakefail(H);
    return return_value_handshakefail_1;
  }

  else
    if(!(H->decr == 0))
    {
      return_value_handshakedone_2=handshakedone(H);
      return return_value_handshakedone_2;
    }

    else
    {
      return_value_dhread_3=dhread(H);
      return return_value_dhread_3;
    }
}

// callback_gotconn
// file dispatch.c line 106
static signed int callback_gotconn(void *cookie, signed int s)
{
  struct accept_state *A = (struct accept_state *)cookie;
  struct sock_addr **sas;
  A->accept_cookie = (void *)0;
  signed int return_value_proto_conn_create_5;
  signed int return_value_doaccept_6;
  if(s == -1)
    do
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 0))
      {
        libcperciva_warn("network_accept failed");
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 0;
      }

      else
        libcperciva_warnx("network_accept failed");
    }
    while((_Bool)0);

  else
  {
    A->nconn = A->nconn + (unsigned long int)1;
    sas=sock_addr_duplist(A->sas);
    if(!(sas == ((struct sock_addr **)NULL)))
    {
      return_value_proto_conn_create_5=proto_conn_create(s, sas, A->decr, A->nofps, A->requirefps, A->nokeepalive, A->K, A->timeo, callback_conndied, (void *)A);
      if(!(return_value_proto_conn_create_5 == 0))
        do
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          if(!(*return_value___errno_location_4 == 0))
          {
            libcperciva_warn("Failure setting up new connection");
            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            *return_value___errno_location_3 = 0;
          }

          else
            libcperciva_warnx("Failure setting up new connection");
        }
        while((_Bool)0);

      else
      {
        return_value_doaccept_6=doaccept(A);
        if(!(return_value_doaccept_6 == 0))
          goto err0;

        return 0;
      }

    err2:
      ;
      sock_addr_freelist(sas);
    }


  err1:
    ;
    A->nconn = A->nconn - (unsigned long int)1;
    close(s);
  }

err0:
  ;
  return -1;
}

// callback_handshake_done
// file ../proto/proto_conn.c line 293
static signed int callback_handshake_done(void *cookie, struct proto_keys *f, struct proto_keys *r)
{
  struct conn_state *C = (struct conn_state *)cookie;
  C->handshake_cookie = (void *)0;
  events_timer_cancel(C->handshake_timeout_cookie);
  C->handshake_timeout_cookie = (void *)0;
  signed int return_value_dropconn_1;
  if(f == ((struct proto_keys *)NULL) && r == ((struct proto_keys *)NULL))
  {
    return_value_dropconn_1=dropconn(C);
    return return_value_dropconn_1;
  }

  else
  {
    /* assertion f != ((void *)0) */
    assert(f != (struct proto_keys *)(void *)0);
    /* assertion r != ((void *)0) */
    assert(r != (struct proto_keys *)(void *)0);
    C->k_f = f;
    C->k_r = r;
    if(!(C->t == -1))
    {
      if(!(C->k_f == ((struct proto_keys *)NULL)))
      {
        if(!(C->k_r == ((struct proto_keys *)NULL)))
        {
          signed int return_value_launchpipes_2;
          return_value_launchpipes_2=launchpipes(C);
          if(!(return_value_launchpipes_2 == 0))
            goto err1;

        }

      }

    }

    return 0;

  err1:
    ;
    dropconn(C);
    return -1;
  }
}

// callback_handshake_timeout
// file ../proto/proto_conn.c line 335
static signed int callback_handshake_timeout(void *cookie)
{
  struct conn_state *C = (struct conn_state *)cookie;
  C->handshake_timeout_cookie = (void *)0;
  signed int return_value_dropconn_1;
  return_value_dropconn_1=dropconn(C);
  return return_value_dropconn_1;
}

// callback_nonce_read
// file ../proto/proto_handshake.c line 145
static signed int callback_nonce_read(void *cookie, signed long int len)
{
  struct handshake_cookie *H = (struct handshake_cookie *)cookie;
  H->read_cookie = (void *)0;
  signed int return_value_handshakefail_1;
  signed int return_value_gotnonces_2;
  if(!(len >= 32l))
  {
    return_value_handshakefail_1=handshakefail(H);
    return return_value_handshakefail_1;
  }

  else
    if(H->write_cookie == NULL)
    {
      return_value_gotnonces_2=gotnonces(H);
      return return_value_gotnonces_2;
    }

    else
      return 0;
}

// callback_nonce_write
// file ../proto/proto_handshake.c line 124
static signed int callback_nonce_write(void *cookie, signed long int len)
{
  struct handshake_cookie *H = (struct handshake_cookie *)cookie;
  H->write_cookie = (void *)0;
  signed int return_value_handshakefail_1;
  signed int return_value_gotnonces_2;
  if(!(len >= 32l))
  {
    return_value_handshakefail_1=handshakefail(H);
    return return_value_handshakefail_1;
  }

  else
    if(H->read_cookie == NULL)
    {
      return_value_gotnonces_2=gotnonces(H);
      return return_value_gotnonces_2;
    }

    else
      return 0;
}

// callback_pipe_read
// file ../proto/proto_pipe.c line 83
static signed int callback_pipe_read(void *cookie, signed long int len)
{
  struct pipe_cookie *P = (struct pipe_cookie *)cookie;
  P->read_cookie = (void *)0;
  signed int return_value;
  if(!(len == 0l))
  {
    if(!(len == -1l))
    {
      if(!(P->decr == 0))
      {
        if(!(len >= 1060l))
          goto fail;

      }

      if(!(P->decr == 0))
      {
        P->wlen=proto_crypt_dec(P->ebuf, P->dbuf, P->k);
        if(P->wlen == -1l)
          goto fail;

      }

      else
      {
        proto_crypt_enc(P->dbuf, (unsigned long int)len, P->ebuf, P->k);
        P->wlen = (signed long int)(1024 + 4 + 32);
      }
      if(!(P->decr == 0))
      {
        P->write_cookie=network_write(P->s_out, P->dbuf, (unsigned long int)P->wlen, (unsigned long int)P->wlen, callback_pipe_write, (void *)P);
        if(P->write_cookie == NULL)
          goto err0;

      }

      else
      {
        P->write_cookie=network_write(P->s_out, P->ebuf, (unsigned long int)P->wlen, (unsigned long int)P->wlen, callback_pipe_write, (void *)P);
        if(P->write_cookie == NULL)
          goto err0;

      }
      return 0;
    }


  fail:
    ;
    *P->status = -1;
    return_value=P->callback(P->cookie);
    return return_value;
  }

  else
  {

  eof:
    ;
    shutdown(P->s_out, 1);
    *P->status = 0;
    signed int return_value_1;
    return_value_1=P->callback(P->cookie);
    return return_value_1;

  err0:
    ;
    return -1;
  }
}

// callback_pipe_write
// file ../proto/proto_pipe.c line 148
static signed int callback_pipe_write(void *cookie, signed long int len)
{
  struct pipe_cookie *P = (struct pipe_cookie *)cookie;
  P->write_cookie = (void *)0;
  if(len >= P->wlen)
  {
    if(!(P->decr == 0))
    {
      P->read_cookie=network_read(P->s_in, P->ebuf, (unsigned long int)(1024 + 4 + 32), (unsigned long int)(1024 + 4 + 32), callback_pipe_read, (void *)P);
      if(P->read_cookie == NULL)
        goto err0;

    }

    else
    {
      P->read_cookie=network_read(P->s_in, P->dbuf, (unsigned long int)1024, (unsigned long int)1, callback_pipe_read, (void *)P);
      if(P->read_cookie == NULL)
        goto err0;

    }
    return 0;
  }

  else
  {

  fail:
    ;
    *P->status = -1;
    signed int return_value;
    return_value=P->callback(P->cookie);
    return return_value;

  err0:
    ;
    return -1;
  }
}

// callback_pipestatus
// file ../proto/proto_conn.c line 348
static signed int callback_pipestatus(void *cookie)
{
  struct conn_state *C = (struct conn_state *)cookie;
  _Bool tmp_if_expr_2;
  if(C->stat_f == -1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = C->stat_r == -1 ? (_Bool)1 : (_Bool)0;
  signed int return_value_dropconn_1;
  signed int return_value_dropconn_3;
  if(tmp_if_expr_2)
  {
    return_value_dropconn_1=dropconn(C);
    return return_value_dropconn_1;
  }

  else
    if(C->stat_f == 0)
    {
      if(!(C->stat_r == 0))
        goto __CPROVER_DUMP_L4;

      return_value_dropconn_3=dropconn(C);
      return return_value_dropconn_3;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      return 0;
    }
}

// callback_resolve
// file dispatch.c line 38
static signed int callback_resolve(void *cookie, struct sock_addr **sas)
{
  struct accept_state *A = (struct accept_state *)cookie;
  if(!(sas == ((struct sock_addr **)NULL)))
  {
    sock_addr_freelist(A->sas);
    A->sas = sas;
  }

  void *return_value_events_timer_register_double_1;
  return_value_events_timer_register_double_1=events_timer_register_double(callback_resolveagain, (void *)A, A->rtime);
  if(!(return_value_events_timer_register_double_1 == NULL))
    return 0;

  else
  {

  err0:
    ;
    return -1;
  }
}

// callback_resolve_link1
// file ../lib/dnsthread/dnsthread.c line 447
static signed int callback_resolve_link1(void *cookie_link1, struct sock_addr **sas_link1)
{
  struct resolve_cookie *R = (struct resolve_cookie *)cookie_link1;
  signed int rc;
  rc=R->callback(R->cookie, sas_link1);
  signed int return_value_dnsthread_kill_1;
  return_value_dnsthread_kill_1=dnsthread_kill(R->T);
  if(!(return_value_dnsthread_kill_1 == 0))
    rc = -1;

  free((void *)R);
  return rc;
}

// callback_resolveagain
// file dispatch.c line 66
static signed int callback_resolveagain(void *cookie)
{
  struct accept_state *A = (struct accept_state *)cookie;
  signed int return_value_dnsthread_resolveone_1;
  return_value_dnsthread_resolveone_1=dnsthread_resolveone(A->T, A->tgt, callback_resolve, (void *)A);
  return return_value_dnsthread_resolveone_1;
}

// callback_resolveone
// file ../lib/dnsthread/dnsthread.c line 303
static signed int callback_resolveone(void *cookie)
{
  struct dnsthread_internal *T = (struct dnsthread_internal *)cookie;
  struct sock_addr **sas;
  unsigned char zero;
  signed int res_errno = 0;
  signed int (*callback)(void *, struct sock_addr **);
  void *cb_cookie;
  signed int rc;
  signed long int return_value_read_2;
  return_value_read_2=read(T->wakeupsock[(signed long int)1], (void *)&zero, (unsigned long int)1);
  signed int *return_value___errno_location_7;
  signed int return_value;
  if(!(return_value_read_2 == 1l))
    do
    {
      libcperciva_warnx("Error reading from wakeup socket");
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 0;
    }
    while((_Bool)0);

  else
  {
    rc=pthread_mutex_lock(&T->mtx);
    if(!(rc == 0))
      do
      {
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(rc);
        libcperciva_warnx("pthread_mutex_lock: %s", return_value_strerror_3);
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = 0;
      }
      while((_Bool)0);

    else
    {
      free((void *)T->addr);
      sas = T->sas;
      res_errno = T->res_errno;
      callback = T->callback;
      cb_cookie = T->cookie;
      rc=pthread_mutex_unlock(&T->mtx);
      if(!(rc == 0))
        do
        {
          char *return_value_strerror_5;
          return_value_strerror_5=strerror(rc);
          libcperciva_warnx("pthread_mutex_unlock: %s", return_value_strerror_5);
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          *return_value___errno_location_6 = 0;
        }
        while((_Bool)0);

      else
      {
        if(sas == ((struct sock_addr **)NULL))
        {
          return_value___errno_location_7=__errno_location();
          *return_value___errno_location_7 = res_errno;
        }

        return_value=callback(cb_cookie, sas);
        return return_value;
      }
    }
  }

err0:
  ;
  return -1;
}

// callback_timeo
// file ../libcperciva/network/network_connect.c line 100
static signed int callback_timeo(void *cookie)
{
  struct connect_cookie *C = (struct connect_cookie *)cookie;
  C->cookie_timeo = (void *)0;
  events_network_cancel(C->s, 1);
  signed int return_value_dofailed_1;
  return_value_dofailed_1=dofailed(C);
  return return_value_dofailed_1;
}

// compar
// file ../libcperciva/datastruct/timerqueue.c line 43
static signed int compar(void *cookie, const void *x, const void *y)
{
  struct timerrec_0 *_x = (struct timerrec_0 *)x;
  struct timerrec_0 *_y = (struct timerrec_0 *)y;
  (void)cookie;
  signed int return_value_tvcmp_1;
  return_value_tvcmp_1=tvcmp(&_x->tv, &_y->tv);
  return return_value_tvcmp_1;
}

// cpusupport_x86_aesni
// file ../libcperciva/cpusupport/cpusupport.h line 61
static inline signed int cpusupport_x86_aesni(void)
{
  if(!(cpusupport_x86_aesni_present == 0))
    return 1;

  else
    if(!(cpusupport_x86_aesni_init == 0))
      return 0;

  cpusupport_x86_aesni_present=cpusupport_x86_aesni_detect();
  cpusupport_x86_aesni_init = 1;
  return cpusupport_x86_aesni_present;
}

// cpusupport_x86_aesni_detect
// file ../libcperciva/cpusupport/cpusupport_x86_aesni.c line 9
signed int cpusupport_x86_aesni_detect(void)
{
  unsigned int eax;
  unsigned int ebx;
  unsigned int ecx;
  unsigned int edx;
  signed int return_value___get_cpuid_1;
  return_value___get_cpuid_1=__get_cpuid((unsigned int)0, &eax, &ebx, &ecx, &edx);
  signed int return_value___get_cpuid_2;
  if(!(return_value___get_cpuid_1 == 0))
  {
    if(!(eax >= 1u))
      goto unsupported;

    return_value___get_cpuid_2=__get_cpuid((unsigned int)1, &eax, &ebx, &ecx, &edx);
    if(return_value___get_cpuid_2 == 0)
      goto unsupported;

    return (signed int)(ecx & (unsigned int)(1 << 25));
  }

  else
  {

  unsupported:
    ;
    return 0;
  }
}

// crypto_aes_encrypt_block
// file ../libcperciva/crypto/crypto_aes.c line 131
void crypto_aes_encrypt_block(const unsigned char *in, unsigned char *out, struct crypto_aes_key *key)
{
  signed int return_value_useaesni_1;
  return_value_useaesni_1=useaesni();
  if(!(return_value_useaesni_1 == 0))
    crypto_aes_encrypt_block_aesni(in, out, (const void *)key);

  else
    AES_encrypt(in, out, (const struct aes_key_st *)(const void *)key);
}

// crypto_aes_encrypt_block_aesni
// file ../libcperciva/crypto/crypto_aes_aesni.h line 23
void crypto_aes_encrypt_block_aesni(const unsigned char *in, unsigned char *out, const void *key)
{
  struct crypto_aes_key_aesni *_key = (struct crypto_aes_key_aesni *)key;
  const __gcc_v2di *aes_key = _key->rkeys;
  __gcc_v2di aes_state;
  unsigned long int nr = _key->nr;
  aes_state=_mm_loadu_si128((const __gcc_v2di *)in);
  aes_state=_mm_xor_si128(aes_state, aes_key[(signed long int)0]);
  aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)1]);
  aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)2]);
  aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)3]);
  aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)4]);
  aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)5]);
  aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)6]);
  aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)7]);
  aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)8]);
  aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)9]);
  if(nr >= 11ul)
  {
    aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)10]);
    aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)11]);
    if(nr >= 13ul)
    {
      aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)12]);
      aes_state=_mm_aesenc_si128(aes_state, aes_key[(signed long int)13]);
    }

  }

  aes_state=_mm_aesenclast_si128(aes_state, aes_key[(signed long int)nr]);
  _mm_storeu_si128((__gcc_v2di *)out, aes_state);
}

// crypto_aes_key_expand
// file ../libcperciva/crypto/crypto_aes.h line 15
struct crypto_aes_key * crypto_aes_key_expand(const unsigned char *key, unsigned long int len)
{
  struct aes_key_st *kexp;
  /* assertion (len == 16) || (len == 32) */
  assert(len == (unsigned long int)16 || len == (unsigned long int)32);
  signed int return_value_useaesni_2;
  return_value_useaesni_2=useaesni();
  void *return_value_crypto_aes_key_expand_aesni_1;
  if(!(return_value_useaesni_2 == 0))
  {
    return_value_crypto_aes_key_expand_aesni_1=crypto_aes_key_expand_aesni(key, len);
    return (struct crypto_aes_key *)return_value_crypto_aes_key_expand_aesni_1;
  }

  else
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sizeof(struct aes_key_st) /*244ul*/ );
    kexp = (struct aes_key_st *)return_value_malloc_3;
    if(!(kexp == ((struct aes_key_st *)NULL)))
    {
      AES_set_encrypt_key(key, (const signed int)(len * (unsigned long int)8), kexp);
      return (struct crypto_aes_key *)(void *)kexp;
    }

    else
    {

    err0:
      ;
      return (struct crypto_aes_key *)(void *)0;
    }
  }
}

// crypto_aes_key_expand_128_aesni
// file ../libcperciva/crypto/crypto_aes_aesni.c line 38
static void crypto_aes_key_expand_128_aesni(const unsigned char *key, __gcc_v2di *rkeys)
{
  rkeys[(signed long int)0]=_mm_loadu_si128((const __gcc_v2di *)&key[(signed long int)0]);
  do
  {
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__1___s = rkeys[(signed long int)(1 - 1)];
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__1___t = rkeys[(signed long int)(1 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_1;
    return_value___builtin_ia32_pslldqi128_1=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__1___s, (signed int)4 * 8);
    crypto_aes_key_expand_128_aesni__1__1___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__1___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_1);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_2;
    return_value___builtin_ia32_pslldqi128_2=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__1___s, (signed int)8 * 8);
    crypto_aes_key_expand_128_aesni__1__1___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__1___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_2);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_3;
    return_value___builtin_ia32_aeskeygenassist128_3=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__1___t, (signed int)0x01);
    crypto_aes_key_expand_128_aesni__1__1___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_3;
    __gcc_v4si return_value___builtin_ia32_pshufd_4;
    return_value___builtin_ia32_pshufd_4=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_128_aesni__1__1___t, (signed int)0xff);
    crypto_aes_key_expand_128_aesni__1__1___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_4;
    rkeys[(signed long int)1]=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__1___s, crypto_aes_key_expand_128_aesni__1__1___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__2___s = rkeys[(signed long int)(2 - 1)];
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__2___t = rkeys[(signed long int)(2 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_5;
    return_value___builtin_ia32_pslldqi128_5=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__2___s, (signed int)4 * 8);
    crypto_aes_key_expand_128_aesni__1__2___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__2___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_5);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_6;
    return_value___builtin_ia32_pslldqi128_6=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__2___s, (signed int)8 * 8);
    crypto_aes_key_expand_128_aesni__1__2___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__2___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_6);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_7;
    return_value___builtin_ia32_aeskeygenassist128_7=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__2___t, (signed int)0x02);
    crypto_aes_key_expand_128_aesni__1__2___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_7;
    __gcc_v4si return_value___builtin_ia32_pshufd_8;
    return_value___builtin_ia32_pshufd_8=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_128_aesni__1__2___t, (signed int)0xff);
    crypto_aes_key_expand_128_aesni__1__2___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_8;
    rkeys[(signed long int)2]=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__2___s, crypto_aes_key_expand_128_aesni__1__2___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di _s = rkeys[(signed long int)(3 - 1)];
    __gcc_v2di _t = rkeys[(signed long int)(3 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_9;
    return_value___builtin_ia32_pslldqi128_9=__builtin_ia32_pslldqi128((__gcc_v2di)_s, (signed int)4 * 8);
    _s=_mm_xor_si128(_s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_9);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_10;
    return_value___builtin_ia32_pslldqi128_10=__builtin_ia32_pslldqi128((__gcc_v2di)_s, (signed int)8 * 8);
    _s=_mm_xor_si128(_s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_10);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_11;
    return_value___builtin_ia32_aeskeygenassist128_11=__builtin_ia32_aeskeygenassist128((__gcc_v2di)_t, (signed int)0x04);
    _t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_11;
    __gcc_v4si return_value___builtin_ia32_pshufd_12;
    return_value___builtin_ia32_pshufd_12=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)_t, (signed int)0xff);
    _t = (__gcc_v2di)return_value___builtin_ia32_pshufd_12;
    rkeys[(signed long int)3]=_mm_xor_si128(_s, _t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__4___s = rkeys[(signed long int)(4 - 1)];
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__4___t = rkeys[(signed long int)(4 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_13;
    return_value___builtin_ia32_pslldqi128_13=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__4___s, (signed int)4 * 8);
    crypto_aes_key_expand_128_aesni__1__4___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__4___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_13);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_14;
    return_value___builtin_ia32_pslldqi128_14=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__4___s, (signed int)8 * 8);
    crypto_aes_key_expand_128_aesni__1__4___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__4___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_14);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_15;
    return_value___builtin_ia32_aeskeygenassist128_15=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__4___t, (signed int)0x08);
    crypto_aes_key_expand_128_aesni__1__4___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_15;
    __gcc_v4si return_value___builtin_ia32_pshufd_16;
    return_value___builtin_ia32_pshufd_16=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_128_aesni__1__4___t, (signed int)0xff);
    crypto_aes_key_expand_128_aesni__1__4___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_16;
    rkeys[(signed long int)4]=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__4___s, crypto_aes_key_expand_128_aesni__1__4___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__5___s = rkeys[(signed long int)(5 - 1)];
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__5___t = rkeys[(signed long int)(5 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_17;
    return_value___builtin_ia32_pslldqi128_17=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__5___s, (signed int)4 * 8);
    crypto_aes_key_expand_128_aesni__1__5___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__5___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_17);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_18;
    return_value___builtin_ia32_pslldqi128_18=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__5___s, (signed int)8 * 8);
    crypto_aes_key_expand_128_aesni__1__5___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__5___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_18);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_19;
    return_value___builtin_ia32_aeskeygenassist128_19=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__5___t, (signed int)0x10);
    crypto_aes_key_expand_128_aesni__1__5___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_19;
    __gcc_v4si return_value___builtin_ia32_pshufd_20;
    return_value___builtin_ia32_pshufd_20=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_128_aesni__1__5___t, (signed int)0xff);
    crypto_aes_key_expand_128_aesni__1__5___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_20;
    rkeys[(signed long int)5]=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__5___s, crypto_aes_key_expand_128_aesni__1__5___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__6___s = rkeys[(signed long int)(6 - 1)];
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__6___t = rkeys[(signed long int)(6 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_21;
    return_value___builtin_ia32_pslldqi128_21=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__6___s, (signed int)4 * 8);
    crypto_aes_key_expand_128_aesni__1__6___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__6___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_21);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_22;
    return_value___builtin_ia32_pslldqi128_22=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__6___s, (signed int)8 * 8);
    crypto_aes_key_expand_128_aesni__1__6___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__6___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_22);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_23;
    return_value___builtin_ia32_aeskeygenassist128_23=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__6___t, (signed int)0x20);
    crypto_aes_key_expand_128_aesni__1__6___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_23;
    __gcc_v4si return_value___builtin_ia32_pshufd_24;
    return_value___builtin_ia32_pshufd_24=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_128_aesni__1__6___t, (signed int)0xff);
    crypto_aes_key_expand_128_aesni__1__6___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_24;
    rkeys[(signed long int)6]=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__6___s, crypto_aes_key_expand_128_aesni__1__6___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__7___s = rkeys[(signed long int)(7 - 1)];
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__7___t = rkeys[(signed long int)(7 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_25;
    return_value___builtin_ia32_pslldqi128_25=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__7___s, (signed int)4 * 8);
    crypto_aes_key_expand_128_aesni__1__7___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__7___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_25);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_26;
    return_value___builtin_ia32_pslldqi128_26=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__7___s, (signed int)8 * 8);
    crypto_aes_key_expand_128_aesni__1__7___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__7___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_26);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_27;
    return_value___builtin_ia32_aeskeygenassist128_27=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__7___t, (signed int)0x40);
    crypto_aes_key_expand_128_aesni__1__7___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_27;
    __gcc_v4si return_value___builtin_ia32_pshufd_28;
    return_value___builtin_ia32_pshufd_28=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_128_aesni__1__7___t, (signed int)0xff);
    crypto_aes_key_expand_128_aesni__1__7___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_28;
    rkeys[(signed long int)7]=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__7___s, crypto_aes_key_expand_128_aesni__1__7___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__8___s = rkeys[(signed long int)(8 - 1)];
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__8___t = rkeys[(signed long int)(8 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_29;
    return_value___builtin_ia32_pslldqi128_29=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__8___s, (signed int)4 * 8);
    crypto_aes_key_expand_128_aesni__1__8___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__8___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_29);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_30;
    return_value___builtin_ia32_pslldqi128_30=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__8___s, (signed int)8 * 8);
    crypto_aes_key_expand_128_aesni__1__8___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__8___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_30);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_31;
    return_value___builtin_ia32_aeskeygenassist128_31=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__8___t, (signed int)0x80);
    crypto_aes_key_expand_128_aesni__1__8___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_31;
    __gcc_v4si return_value___builtin_ia32_pshufd_32;
    return_value___builtin_ia32_pshufd_32=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_128_aesni__1__8___t, (signed int)0xff);
    crypto_aes_key_expand_128_aesni__1__8___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_32;
    rkeys[(signed long int)8]=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__8___s, crypto_aes_key_expand_128_aesni__1__8___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__9___s = rkeys[(signed long int)(9 - 1)];
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__9___t = rkeys[(signed long int)(9 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_33;
    return_value___builtin_ia32_pslldqi128_33=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__9___s, (signed int)4 * 8);
    crypto_aes_key_expand_128_aesni__1__9___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__9___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_33);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_34;
    return_value___builtin_ia32_pslldqi128_34=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__9___s, (signed int)8 * 8);
    crypto_aes_key_expand_128_aesni__1__9___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__9___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_34);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_35;
    return_value___builtin_ia32_aeskeygenassist128_35=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__9___t, (signed int)0x1b);
    crypto_aes_key_expand_128_aesni__1__9___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_35;
    __gcc_v4si return_value___builtin_ia32_pshufd_36;
    return_value___builtin_ia32_pshufd_36=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_128_aesni__1__9___t, (signed int)0xff);
    crypto_aes_key_expand_128_aesni__1__9___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_36;
    rkeys[(signed long int)9]=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__9___s, crypto_aes_key_expand_128_aesni__1__9___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__10___s = rkeys[(signed long int)(10 - 1)];
    __gcc_v2di crypto_aes_key_expand_128_aesni__1__10___t = rkeys[(signed long int)(10 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_37;
    return_value___builtin_ia32_pslldqi128_37=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__10___s, (signed int)4 * 8);
    crypto_aes_key_expand_128_aesni__1__10___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__10___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_37);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_38;
    return_value___builtin_ia32_pslldqi128_38=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__10___s, (signed int)8 * 8);
    crypto_aes_key_expand_128_aesni__1__10___s=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__10___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_38);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_39;
    return_value___builtin_ia32_aeskeygenassist128_39=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_128_aesni__1__10___t, (signed int)0x36);
    crypto_aes_key_expand_128_aesni__1__10___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_39;
    __gcc_v4si return_value___builtin_ia32_pshufd_40;
    return_value___builtin_ia32_pshufd_40=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_128_aesni__1__10___t, (signed int)0xff);
    crypto_aes_key_expand_128_aesni__1__10___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_40;
    rkeys[(signed long int)10]=_mm_xor_si128(crypto_aes_key_expand_128_aesni__1__10___s, crypto_aes_key_expand_128_aesni__1__10___t);
  }
  while((_Bool)0);
}

// crypto_aes_key_expand_256_aesni
// file ../libcperciva/crypto/crypto_aes_aesni.c line 92
static void crypto_aes_key_expand_256_aesni(const unsigned char *key, __gcc_v2di *rkeys)
{
  rkeys[(signed long int)0]=_mm_loadu_si128((const __gcc_v2di *)&key[(signed long int)0]);
  rkeys[(signed long int)1]=_mm_loadu_si128((const __gcc_v2di *)&key[(signed long int)16]);
  do
  {
    __gcc_v2di _s = rkeys[(signed long int)(2 - 2)];
    __gcc_v2di _t = rkeys[(signed long int)(2 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_1;
    return_value___builtin_ia32_pslldqi128_1=__builtin_ia32_pslldqi128((__gcc_v2di)_s, (signed int)4 * 8);
    _s=_mm_xor_si128(_s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_1);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_2;
    return_value___builtin_ia32_pslldqi128_2=__builtin_ia32_pslldqi128((__gcc_v2di)_s, (signed int)8 * 8);
    _s=_mm_xor_si128(_s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_2);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_3;
    return_value___builtin_ia32_aeskeygenassist128_3=__builtin_ia32_aeskeygenassist128((__gcc_v2di)_t, (signed int)0x01);
    _t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_3;
    __gcc_v4si return_value___builtin_ia32_pshufd_4;
    return_value___builtin_ia32_pshufd_4=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)_t, (signed int)0xff);
    _t = (__gcc_v2di)return_value___builtin_ia32_pshufd_4;
    rkeys[(signed long int)2]=_mm_xor_si128(_s, _t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__2___s = rkeys[(signed long int)(3 - 2)];
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__2___t = rkeys[(signed long int)(3 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_5;
    return_value___builtin_ia32_pslldqi128_5=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__2___s, (signed int)4 * 8);
    crypto_aes_key_expand_256_aesni__1__2___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__2___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_5);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_6;
    return_value___builtin_ia32_pslldqi128_6=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__2___s, (signed int)8 * 8);
    crypto_aes_key_expand_256_aesni__1__2___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__2___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_6);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_7;
    return_value___builtin_ia32_aeskeygenassist128_7=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__2___t, (signed int)0x00);
    crypto_aes_key_expand_256_aesni__1__2___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_7;
    __gcc_v4si return_value___builtin_ia32_pshufd_8;
    return_value___builtin_ia32_pshufd_8=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_256_aesni__1__2___t, (signed int)0xaa);
    crypto_aes_key_expand_256_aesni__1__2___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_8;
    rkeys[(signed long int)3]=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__2___s, crypto_aes_key_expand_256_aesni__1__2___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__3___s = rkeys[(signed long int)(4 - 2)];
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__3___t = rkeys[(signed long int)(4 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_9;
    return_value___builtin_ia32_pslldqi128_9=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__3___s, (signed int)4 * 8);
    crypto_aes_key_expand_256_aesni__1__3___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__3___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_9);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_10;
    return_value___builtin_ia32_pslldqi128_10=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__3___s, (signed int)8 * 8);
    crypto_aes_key_expand_256_aesni__1__3___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__3___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_10);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_11;
    return_value___builtin_ia32_aeskeygenassist128_11=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__3___t, (signed int)0x02);
    crypto_aes_key_expand_256_aesni__1__3___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_11;
    __gcc_v4si return_value___builtin_ia32_pshufd_12;
    return_value___builtin_ia32_pshufd_12=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_256_aesni__1__3___t, (signed int)0xff);
    crypto_aes_key_expand_256_aesni__1__3___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_12;
    rkeys[(signed long int)4]=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__3___s, crypto_aes_key_expand_256_aesni__1__3___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__4___s = rkeys[(signed long int)(5 - 2)];
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__4___t = rkeys[(signed long int)(5 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_13;
    return_value___builtin_ia32_pslldqi128_13=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__4___s, (signed int)4 * 8);
    crypto_aes_key_expand_256_aesni__1__4___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__4___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_13);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_14;
    return_value___builtin_ia32_pslldqi128_14=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__4___s, (signed int)8 * 8);
    crypto_aes_key_expand_256_aesni__1__4___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__4___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_14);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_15;
    return_value___builtin_ia32_aeskeygenassist128_15=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__4___t, (signed int)0x00);
    crypto_aes_key_expand_256_aesni__1__4___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_15;
    __gcc_v4si return_value___builtin_ia32_pshufd_16;
    return_value___builtin_ia32_pshufd_16=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_256_aesni__1__4___t, (signed int)0xaa);
    crypto_aes_key_expand_256_aesni__1__4___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_16;
    rkeys[(signed long int)5]=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__4___s, crypto_aes_key_expand_256_aesni__1__4___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__5___s = rkeys[(signed long int)(6 - 2)];
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__5___t = rkeys[(signed long int)(6 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_17;
    return_value___builtin_ia32_pslldqi128_17=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__5___s, (signed int)4 * 8);
    crypto_aes_key_expand_256_aesni__1__5___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__5___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_17);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_18;
    return_value___builtin_ia32_pslldqi128_18=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__5___s, (signed int)8 * 8);
    crypto_aes_key_expand_256_aesni__1__5___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__5___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_18);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_19;
    return_value___builtin_ia32_aeskeygenassist128_19=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__5___t, (signed int)0x04);
    crypto_aes_key_expand_256_aesni__1__5___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_19;
    __gcc_v4si return_value___builtin_ia32_pshufd_20;
    return_value___builtin_ia32_pshufd_20=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_256_aesni__1__5___t, (signed int)0xff);
    crypto_aes_key_expand_256_aesni__1__5___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_20;
    rkeys[(signed long int)6]=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__5___s, crypto_aes_key_expand_256_aesni__1__5___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__6___s = rkeys[(signed long int)(7 - 2)];
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__6___t = rkeys[(signed long int)(7 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_21;
    return_value___builtin_ia32_pslldqi128_21=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__6___s, (signed int)4 * 8);
    crypto_aes_key_expand_256_aesni__1__6___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__6___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_21);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_22;
    return_value___builtin_ia32_pslldqi128_22=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__6___s, (signed int)8 * 8);
    crypto_aes_key_expand_256_aesni__1__6___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__6___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_22);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_23;
    return_value___builtin_ia32_aeskeygenassist128_23=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__6___t, (signed int)0x00);
    crypto_aes_key_expand_256_aesni__1__6___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_23;
    __gcc_v4si return_value___builtin_ia32_pshufd_24;
    return_value___builtin_ia32_pshufd_24=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_256_aesni__1__6___t, (signed int)0xaa);
    crypto_aes_key_expand_256_aesni__1__6___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_24;
    rkeys[(signed long int)7]=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__6___s, crypto_aes_key_expand_256_aesni__1__6___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__7___s = rkeys[(signed long int)(8 - 2)];
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__7___t = rkeys[(signed long int)(8 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_25;
    return_value___builtin_ia32_pslldqi128_25=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__7___s, (signed int)4 * 8);
    crypto_aes_key_expand_256_aesni__1__7___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__7___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_25);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_26;
    return_value___builtin_ia32_pslldqi128_26=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__7___s, (signed int)8 * 8);
    crypto_aes_key_expand_256_aesni__1__7___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__7___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_26);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_27;
    return_value___builtin_ia32_aeskeygenassist128_27=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__7___t, (signed int)0x08);
    crypto_aes_key_expand_256_aesni__1__7___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_27;
    __gcc_v4si return_value___builtin_ia32_pshufd_28;
    return_value___builtin_ia32_pshufd_28=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_256_aesni__1__7___t, (signed int)0xff);
    crypto_aes_key_expand_256_aesni__1__7___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_28;
    rkeys[(signed long int)8]=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__7___s, crypto_aes_key_expand_256_aesni__1__7___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__8___s = rkeys[(signed long int)(9 - 2)];
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__8___t = rkeys[(signed long int)(9 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_29;
    return_value___builtin_ia32_pslldqi128_29=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__8___s, (signed int)4 * 8);
    crypto_aes_key_expand_256_aesni__1__8___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__8___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_29);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_30;
    return_value___builtin_ia32_pslldqi128_30=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__8___s, (signed int)8 * 8);
    crypto_aes_key_expand_256_aesni__1__8___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__8___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_30);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_31;
    return_value___builtin_ia32_aeskeygenassist128_31=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__8___t, (signed int)0x00);
    crypto_aes_key_expand_256_aesni__1__8___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_31;
    __gcc_v4si return_value___builtin_ia32_pshufd_32;
    return_value___builtin_ia32_pshufd_32=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_256_aesni__1__8___t, (signed int)0xaa);
    crypto_aes_key_expand_256_aesni__1__8___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_32;
    rkeys[(signed long int)9]=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__8___s, crypto_aes_key_expand_256_aesni__1__8___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__9___s = rkeys[(signed long int)(10 - 2)];
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__9___t = rkeys[(signed long int)(10 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_33;
    return_value___builtin_ia32_pslldqi128_33=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__9___s, (signed int)4 * 8);
    crypto_aes_key_expand_256_aesni__1__9___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__9___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_33);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_34;
    return_value___builtin_ia32_pslldqi128_34=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__9___s, (signed int)8 * 8);
    crypto_aes_key_expand_256_aesni__1__9___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__9___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_34);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_35;
    return_value___builtin_ia32_aeskeygenassist128_35=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__9___t, (signed int)0x10);
    crypto_aes_key_expand_256_aesni__1__9___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_35;
    __gcc_v4si return_value___builtin_ia32_pshufd_36;
    return_value___builtin_ia32_pshufd_36=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_256_aesni__1__9___t, (signed int)0xff);
    crypto_aes_key_expand_256_aesni__1__9___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_36;
    rkeys[(signed long int)10]=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__9___s, crypto_aes_key_expand_256_aesni__1__9___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__10___s = rkeys[(signed long int)(11 - 2)];
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__10___t = rkeys[(signed long int)(11 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_37;
    return_value___builtin_ia32_pslldqi128_37=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__10___s, (signed int)4 * 8);
    crypto_aes_key_expand_256_aesni__1__10___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__10___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_37);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_38;
    return_value___builtin_ia32_pslldqi128_38=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__10___s, (signed int)8 * 8);
    crypto_aes_key_expand_256_aesni__1__10___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__10___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_38);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_39;
    return_value___builtin_ia32_aeskeygenassist128_39=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__10___t, (signed int)0x00);
    crypto_aes_key_expand_256_aesni__1__10___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_39;
    __gcc_v4si return_value___builtin_ia32_pshufd_40;
    return_value___builtin_ia32_pshufd_40=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_256_aesni__1__10___t, (signed int)0xaa);
    crypto_aes_key_expand_256_aesni__1__10___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_40;
    rkeys[(signed long int)11]=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__10___s, crypto_aes_key_expand_256_aesni__1__10___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__11___s = rkeys[(signed long int)(12 - 2)];
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__11___t = rkeys[(signed long int)(12 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_41;
    return_value___builtin_ia32_pslldqi128_41=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__11___s, (signed int)4 * 8);
    crypto_aes_key_expand_256_aesni__1__11___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__11___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_41);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_42;
    return_value___builtin_ia32_pslldqi128_42=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__11___s, (signed int)8 * 8);
    crypto_aes_key_expand_256_aesni__1__11___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__11___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_42);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_43;
    return_value___builtin_ia32_aeskeygenassist128_43=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__11___t, (signed int)0x20);
    crypto_aes_key_expand_256_aesni__1__11___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_43;
    __gcc_v4si return_value___builtin_ia32_pshufd_44;
    return_value___builtin_ia32_pshufd_44=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_256_aesni__1__11___t, (signed int)0xff);
    crypto_aes_key_expand_256_aesni__1__11___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_44;
    rkeys[(signed long int)12]=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__11___s, crypto_aes_key_expand_256_aesni__1__11___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__12___s = rkeys[(signed long int)(13 - 2)];
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__12___t = rkeys[(signed long int)(13 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_45;
    return_value___builtin_ia32_pslldqi128_45=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__12___s, (signed int)4 * 8);
    crypto_aes_key_expand_256_aesni__1__12___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__12___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_45);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_46;
    return_value___builtin_ia32_pslldqi128_46=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__12___s, (signed int)8 * 8);
    crypto_aes_key_expand_256_aesni__1__12___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__12___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_46);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_47;
    return_value___builtin_ia32_aeskeygenassist128_47=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__12___t, (signed int)0x00);
    crypto_aes_key_expand_256_aesni__1__12___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_47;
    __gcc_v4si return_value___builtin_ia32_pshufd_48;
    return_value___builtin_ia32_pshufd_48=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_256_aesni__1__12___t, (signed int)0xaa);
    crypto_aes_key_expand_256_aesni__1__12___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_48;
    rkeys[(signed long int)13]=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__12___s, crypto_aes_key_expand_256_aesni__1__12___t);
  }
  while((_Bool)0);
  do
  {
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__13___s = rkeys[(signed long int)(14 - 2)];
    __gcc_v2di crypto_aes_key_expand_256_aesni__1__13___t = rkeys[(signed long int)(14 - 1)];
    __gcc_v2di return_value___builtin_ia32_pslldqi128_49;
    return_value___builtin_ia32_pslldqi128_49=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__13___s, (signed int)4 * 8);
    crypto_aes_key_expand_256_aesni__1__13___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__13___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_49);
    __gcc_v2di return_value___builtin_ia32_pslldqi128_50;
    return_value___builtin_ia32_pslldqi128_50=__builtin_ia32_pslldqi128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__13___s, (signed int)8 * 8);
    crypto_aes_key_expand_256_aesni__1__13___s=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__13___s, (__gcc_v2di)return_value___builtin_ia32_pslldqi128_50);
    __gcc_v2di return_value___builtin_ia32_aeskeygenassist128_51;
    return_value___builtin_ia32_aeskeygenassist128_51=__builtin_ia32_aeskeygenassist128((__gcc_v2di)crypto_aes_key_expand_256_aesni__1__13___t, (signed int)0x40);
    crypto_aes_key_expand_256_aesni__1__13___t = (__gcc_v2di)return_value___builtin_ia32_aeskeygenassist128_51;
    __gcc_v4si return_value___builtin_ia32_pshufd_52;
    return_value___builtin_ia32_pshufd_52=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)crypto_aes_key_expand_256_aesni__1__13___t, (signed int)0xff);
    crypto_aes_key_expand_256_aesni__1__13___t = (__gcc_v2di)return_value___builtin_ia32_pshufd_52;
    rkeys[(signed long int)14]=_mm_xor_si128(crypto_aes_key_expand_256_aesni__1__13___s, crypto_aes_key_expand_256_aesni__1__13___t);
  }
  while((_Bool)0);
}

// crypto_aes_key_expand_aesni
// file ../libcperciva/crypto/crypto_aes_aesni.h line 14
void * crypto_aes_key_expand_aesni(const unsigned char *key, unsigned long int len)
{
  struct crypto_aes_key_aesni *kexp;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct crypto_aes_key_aesni) /*248ul*/ );
  kexp = (struct crypto_aes_key_aesni *)return_value_malloc_1;
  if(!(kexp == ((struct crypto_aes_key_aesni *)NULL)))
  {
    if(len == 16ul)
    {
      kexp->nr = (unsigned long int)10;
      crypto_aes_key_expand_128_aesni(key, kexp->rkeys);
    }

    else
      if(len == 32ul)
      {
        kexp->nr = (unsigned long int)14;
        crypto_aes_key_expand_256_aesni(key, kexp->rkeys);
      }

      else
      {
        do
        {
          libcperciva_warnx("Unsupported AES key length: %zu bytes", len);
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          *return_value___errno_location_2 = 0;
        }
        while((_Bool)0);
        goto err1;
      }
    return (void *)kexp;

  err1:
    ;
    free((void *)kexp);
  }


err0:
  ;
  return (void *)0;
}

// crypto_aes_key_free
// file ../libcperciva/crypto/crypto_aes.h line 29
void crypto_aes_key_free(struct crypto_aes_key *key)
{
  signed int return_value_useaesni_1;
  return_value_useaesni_1=useaesni();
  if(!(return_value_useaesni_1 == 0))
    crypto_aes_key_free_aesni((void *)key);

  else
  {
    insecure_memzero_link1((volatile void *)key, sizeof(struct aes_key_st) /*244ul*/ );
    free((void *)key);
  }
}

// crypto_aes_key_free_aesni
// file ../libcperciva/crypto/crypto_aes_aesni.h line 29
void crypto_aes_key_free_aesni(void *key)
{
  insecure_memzero_link2(key, sizeof(struct crypto_aes_key_aesni) /*248ul*/ );
  free(key);
}

// crypto_aesctr_buf
// file ../libcperciva/crypto/crypto_aesctr.h line 38
void crypto_aesctr_buf(struct crypto_aes_key *key, unsigned long int nonce, const unsigned char *inbuf, unsigned char *outbuf, unsigned long int buflen)
{
  struct crypto_aesctr stream_rec;
  struct crypto_aesctr *stream = &stream_rec;
  signed int i;
  stream->key = key;
  stream->nonce = nonce;
  stream->bytectr = (unsigned long int)0;
  crypto_aesctr_stream(stream, inbuf, outbuf, buflen);
  i = 0;
  for( ; !(i >= 16); i = i + 1)
    stream->buf[(signed long int)i] = (unsigned char)0;
  stream->nonce = (unsigned long int)0;
  stream->bytectr = stream->nonce;
}

// crypto_aesctr_free
// file ../libcperciva/crypto/crypto_aesctr.c line 83
void crypto_aesctr_free(struct crypto_aesctr *stream)
{
  signed int i;
  if(!(stream == ((struct crypto_aesctr *)NULL)))
  {
    i = 0;
    for( ; !(i >= 16); i = i + 1)
      stream->buf[(signed long int)i] = (unsigned char)0;
    stream->nonce = (unsigned long int)0;
    stream->bytectr = stream->nonce;
    free((void *)stream);
  }

}

// crypto_aesctr_init
// file ../libcperciva/crypto/crypto_aesctr.c line 23
struct crypto_aesctr * crypto_aesctr_init(struct crypto_aes_key *key, unsigned long int nonce)
{
  struct crypto_aesctr *stream;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct crypto_aesctr) /*40ul*/ );
  stream = (struct crypto_aesctr *)return_value_malloc_1;
  if(!(stream == ((struct crypto_aesctr *)NULL)))
  {
    stream->key = key;
    stream->nonce = nonce;
    stream->bytectr = (unsigned long int)0;
    return stream;
  }

  else
  {

  err0:
    ;
    return (struct crypto_aesctr *)(void *)0;
  }
}

// crypto_aesctr_stream
// file ../libcperciva/crypto/crypto_aesctr.c line 51
void crypto_aesctr_stream(struct crypto_aesctr *stream, const unsigned char *inbuf, unsigned char *outbuf, unsigned long int buflen)
{
  unsigned char pblk[16l];
  unsigned long int pos;
  signed int bytemod;
  pos = (unsigned long int)0;
  for( ; !(pos >= buflen); pos = pos + 1ul)
  {
    bytemod = (signed int)(stream->bytectr % (unsigned long int)16);
    if(bytemod == 0)
    {
      libcperciva_be64enc_link2((void *)pblk, stream->nonce);
      libcperciva_be64enc_link2((void *)(pblk + (signed long int)8), stream->bytectr / (unsigned long int)16);
      crypto_aes_encrypt_block(pblk, stream->buf, stream->key);
    }

    outbuf[(signed long int)pos] = (unsigned char)((signed int)inbuf[(signed long int)pos] ^ (signed int)stream->buf[(signed long int)bytemod]);
    stream->bytectr = stream->bytectr + (unsigned long int)1;
  }
}

// crypto_dh_compute
// file ../libcperciva/crypto/crypto_dh.h line 33
signed int crypto_dh_compute(const unsigned char *pub, const unsigned char *priv, unsigned char *key)
{
  struct bignum_st *a;
  a=BN_bin2bn(pub, 256, (struct bignum_st *)(void *)0);
  signed int return_value_blinded_modexp_4;
  if(a == ((struct bignum_st *)NULL))
    do
    {
      unsigned long int return_value_ERR_get_error_1;
      return_value_ERR_get_error_1=ERR_get_error();
      char *return_value_ERR_error_string_2;
      return_value_ERR_error_string_2=ERR_error_string(return_value_ERR_get_error_1, (char *)(void *)0);
      libcperciva_warnx("%s", return_value_ERR_error_string_2);
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 0;
    }
    while((_Bool)0);

  else
  {
    return_value_blinded_modexp_4=blinded_modexp(key, a, priv);
    if(return_value_blinded_modexp_4 == 0)
    {
      BN_free(a);
      return 0;
    }


  err1:
    ;
    BN_free(a);
  }

err0:
  ;
  return -1;
}

// crypto_dh_generate
// file ../libcperciva/crypto/crypto_dh.h line 24
signed int crypto_dh_generate(unsigned char *pub, unsigned char *priv)
{
  signed int return_value_crypto_entropy_read_1;
  return_value_crypto_entropy_read_1=crypto_entropy_read(priv, (unsigned long int)32);
  signed int return_value_crypto_dh_generate_pub_2;
  if(return_value_crypto_entropy_read_1 == 0)
  {
    return_value_crypto_dh_generate_pub_2=crypto_dh_generate_pub(pub, priv);
    if(!(return_value_crypto_dh_generate_pub_2 == 0))
      goto err0;

    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// crypto_dh_generate_pub
// file ../libcperciva/crypto/crypto_dh.c line 184
signed int crypto_dh_generate_pub(unsigned char *pub, const unsigned char *priv)
{
  struct bignum_st *two;
  two=BN_new();
  signed int return_value_BN_set_word_7;
  signed int return_value_blinded_modexp_8;
  if(two == ((struct bignum_st *)NULL))
    do
    {
      unsigned long int return_value_ERR_get_error_1;
      return_value_ERR_get_error_1=ERR_get_error();
      char *return_value_ERR_error_string_2;
      return_value_ERR_error_string_2=ERR_error_string(return_value_ERR_get_error_1, (char *)(void *)0);
      libcperciva_warnx("%s", return_value_ERR_error_string_2);
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 0;
    }
    while((_Bool)0);

  else
  {
    return_value_BN_set_word_7=BN_set_word(two, (unsigned long int)2);
    if(return_value_BN_set_word_7 == 0)
      do
      {
        unsigned long int return_value_ERR_get_error_4;
        return_value_ERR_get_error_4=ERR_get_error();
        char *return_value_ERR_error_string_5;
        return_value_ERR_error_string_5=ERR_error_string(return_value_ERR_get_error_4, (char *)(void *)0);
        libcperciva_warnx("%s", return_value_ERR_error_string_5);
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        *return_value___errno_location_6 = 0;
      }
      while((_Bool)0);

    else
    {
      return_value_blinded_modexp_8=blinded_modexp(pub, two, priv);
      if(return_value_blinded_modexp_8 == 0)
      {
        BN_free(two);
        return 0;
      }

    }

  err1:
    ;
    BN_free(two);
  }

err0:
  ;
  return -1;
}

// crypto_dh_sanitycheck
// file ../libcperciva/crypto/crypto_dh.h line 41
signed int crypto_dh_sanitycheck(const unsigned char *pub)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)pub, (const void *)crypto_dh_group14, (unsigned long int)256);
  if(return_value_memcmp_1 >= 0)
    return -1;

  else
    return 0;
}

// crypto_entropy_read
// file ../libcperciva/crypto/crypto_entropy.h line 12
signed int crypto_entropy_read(unsigned char *buf, unsigned long int buflen)
{
  unsigned long int bytes_to_provide;
  if(instantiated == 0)
  {
    signed int return_value_instantiate_1;
    return_value_instantiate_1=instantiate();
    if(!(return_value_instantiate_1 == 0))
      return -1;

    instantiated = 1;
  }

  for( ; buflen >= 1ul; buflen = buflen - bytes_to_provide)
  {
    if(drbg.reseed_counter >= 257u)
    {
      signed int return_value_reseed_2;
      return_value_reseed_2=reseed();
      if(!(return_value_reseed_2 == 0))
        return -1;

    }

    if(buflen >= 65537ul)
      bytes_to_provide = (unsigned long int)65536;

    else
      bytes_to_provide = buflen;
    generate(buf, bytes_to_provide);
    buf = buf + (signed long int)bytes_to_provide;
  }
  return 0;
}

// crypto_verify_bytes
// file ../libcperciva/crypto/crypto_verify_bytes.h line 12
unsigned char crypto_verify_bytes(const unsigned char *buf0, const unsigned char *buf1, unsigned long int len)
{
  unsigned char rc = (unsigned char)0;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= len); i = i + 1ul)
    rc = (unsigned char)((signed int)rc | (signed int)buf0[(signed long int)i] ^ (signed int)buf1[(signed long int)i]);
  return rc;
}

// daemonize
// file ../libcperciva/util/daemonize.h line 8
signed int daemonize(const char *spid)
{
  struct _IO_FILE *f;
  signed int fd[2l];
  char dummy = (char)0;
  signed int return_value_pipe_3;
  return_value_pipe_3=pipe(fd);
  signed int return_value_fork_4;
  signed int return_value_close_7;
  signed int return_value_setsid_17;
  signed int return_value_getpid_22;
  signed int return_value_fprintf_23;
  signed int return_value_fclose_26;
  signed long int return_value_noeintr_write_29;
  signed int return_value_close_30;
  signed int return_value_close_34;
  if(!(return_value_pipe_3 == 0))
    do
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 0))
      {
        libcperciva_warn("pipe");
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 0;
      }

      else
        libcperciva_warnx("pipe");
    }
    while((_Bool)0);

  else
  {
    return_value_fork_4=fork();
    if(!(return_value_fork_4 == -1))
    {
      if(return_value_fork_4 == 0)
        goto __CPROVER_DUMP_L8;

    }

    else
    {
      do
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        if(!(*return_value___errno_location_6 == 0))
        {
          libcperciva_warn("fork");
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          *return_value___errno_location_5 = 0;
        }

        else
          libcperciva_warnx("fork");
      }
      while((_Bool)0);
      goto err2;

    __CPROVER_DUMP_L8:
      ;
      goto __CPROVER_DUMP_L23;
    }
    do
    {
      return_value_close_7=close(fd[(signed long int)1]);
      if(return_value_close_7 == 0)
        break;

      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      if(!(*return_value___errno_location_8 == 4))
      {
        do
        {
          signed int *return_value___errno_location_10;
          return_value___errno_location_10=__errno_location();
          if(!(*return_value___errno_location_10 == 0))
          {
            libcperciva_warn("close");
            signed int *return_value___errno_location_9;
            return_value___errno_location_9=__errno_location();
            *return_value___errno_location_9 = 0;
          }

          else
            libcperciva_warnx("close");
        }
        while((_Bool)0);
        goto err1;
      }

    }
    while((_Bool)1);
    do
    {
      signed long int return_value_read_11;
      return_value_read_11=read(fd[(signed long int)0], (void *)&dummy, (unsigned long int)1);
      if(!(return_value_read_11 == -1l))
      {
        if(return_value_read_11 == 0l)
          goto __CPROVER_DUMP_L16;

        if(return_value_read_11 == 1l)
          goto __CPROVER_DUMP_L17;

      }

      else
      {
        goto __CPROVER_DUMP_L18;

      __CPROVER_DUMP_L16:
        ;
        goto err1;

      __CPROVER_DUMP_L17:
        ;
        _exit(0);
      }

    __CPROVER_DUMP_L18:
      ;
      signed int *return_value___errno_location_14;
      return_value___errno_location_14=__errno_location();
      if(!(*return_value___errno_location_14 == 4))
      {
        do
        {
          signed int *return_value___errno_location_13;
          return_value___errno_location_13=__errno_location();
          if(!(*return_value___errno_location_13 == 0))
          {
            libcperciva_warn("read");
            signed int *return_value___errno_location_12;
            return_value___errno_location_12=__errno_location();
            *return_value___errno_location_12 = 0;
          }

          else
            libcperciva_warnx("read");
        }
        while((_Bool)0);
        goto err1;
      }

    }
    while((_Bool)1);

  __CPROVER_DUMP_L23:
    ;
    return_value_setsid_17=setsid();
    if(return_value_setsid_17 == -1)
    {
      do
      {
        signed int *return_value___errno_location_16;
        return_value___errno_location_16=__errno_location();
        if(!(*return_value___errno_location_16 == 0))
        {
          libcperciva_warn("setsid");
          signed int *return_value___errno_location_15;
          return_value___errno_location_15=__errno_location();
          *return_value___errno_location_15 = 0;
        }

        else
          libcperciva_warnx("setsid");
      }
      while((_Bool)0);
      goto die;
    }

    f=fopen(spid, "w");
    if(f == ((struct _IO_FILE *)NULL))
    {
      do
      {
        signed int *return_value___errno_location_19;
        return_value___errno_location_19=__errno_location();
        if(!(*return_value___errno_location_19 == 0))
        {
          libcperciva_warn("fopen(%s)", spid);
          signed int *return_value___errno_location_18;
          return_value___errno_location_18=__errno_location();
          *return_value___errno_location_18 = 0;
        }

        else
          libcperciva_warnx("fopen(%s)", spid);
      }
      while((_Bool)0);
      goto die;
    }

    return_value_getpid_22=getpid();
    return_value_fprintf_23=fprintf(f, "%d", return_value_getpid_22);
    if(!(return_value_fprintf_23 >= 0))
    {
      do
      {
        signed int *return_value___errno_location_21;
        return_value___errno_location_21=__errno_location();
        if(!(*return_value___errno_location_21 == 0))
        {
          libcperciva_warn("fprintf");
          signed int *return_value___errno_location_20;
          return_value___errno_location_20=__errno_location();
          *return_value___errno_location_20 = 0;
        }

        else
          libcperciva_warnx("fprintf");
      }
      while((_Bool)0);
      goto die;
    }

    return_value_fclose_26=fclose(f);
    if(!(return_value_fclose_26 == 0))
    {
      do
      {
        signed int *return_value___errno_location_25;
        return_value___errno_location_25=__errno_location();
        if(!(*return_value___errno_location_25 == 0))
        {
          libcperciva_warn("fclose");
          signed int *return_value___errno_location_24;
          return_value___errno_location_24=__errno_location();
          *return_value___errno_location_24 = 0;
        }

        else
          libcperciva_warnx("fclose");
      }
      while((_Bool)0);
      goto die;
    }

    return_value_noeintr_write_29=noeintr_write(fd[(signed long int)1], (const void *)&dummy, (unsigned long int)1);
    if(return_value_noeintr_write_29 == -1l)
    {
      do
      {
        signed int *return_value___errno_location_28;
        return_value___errno_location_28=__errno_location();
        if(!(*return_value___errno_location_28 == 0))
        {
          libcperciva_warn("write");
          signed int *return_value___errno_location_27;
          return_value___errno_location_27=__errno_location();
          *return_value___errno_location_27 = 0;
        }

        else
          libcperciva_warnx("write");
      }
      while((_Bool)0);
      goto die;
    }

    do
    {
      return_value_close_30=close(fd[(signed long int)0]);
      if(return_value_close_30 == 0)
        break;

      signed int *return_value___errno_location_31;
      return_value___errno_location_31=__errno_location();
      if(!(*return_value___errno_location_31 == 4))
      {
        do
        {
          signed int *return_value___errno_location_33;
          return_value___errno_location_33=__errno_location();
          if(!(*return_value___errno_location_33 == 0))
          {
            libcperciva_warn("close");
            signed int *return_value___errno_location_32;
            return_value___errno_location_32=__errno_location();
            *return_value___errno_location_32 = 0;
          }

          else
            libcperciva_warnx("close");
        }
        while((_Bool)0);
        goto die;
      }

    }
    while((_Bool)1);
    do
    {
      return_value_close_34=close(fd[(signed long int)1]);
      if(return_value_close_34 == 0)
        break;

      signed int *return_value___errno_location_35;
      return_value___errno_location_35=__errno_location();
      if(!(*return_value___errno_location_35 == 4))
      {
        do
        {
          signed int *return_value___errno_location_37;
          return_value___errno_location_37=__errno_location();
          if(!(*return_value___errno_location_37 == 0))
          {
            libcperciva_warn("close");
            signed int *return_value___errno_location_36;
            return_value___errno_location_36=__errno_location();
            *return_value___errno_location_36 = 0;
          }

          else
            libcperciva_warnx("close");
        }
        while((_Bool)0);
        goto die;
      }

    }
    while((_Bool)1);
    return 0;

  err2:
    ;
    close(fd[(signed long int)1]);

  err1:
    ;
    close(fd[(signed long int)0]);
  }

err0:
  ;
  return -1;

die:
  ;
  _exit(0);
}

// dhread
// file ../proto/proto_handshake.c line 188
static signed int dhread(struct handshake_cookie *H)
{
  H->read_cookie=network_read(H->s, H->yh_remote, (unsigned long int)(256 + 32), (unsigned long int)(256 + 32), callback_dh_read, (void *)H);
  if(!(H->read_cookie == NULL))
    return 0;

  else
  {

  err0:
    ;
    return -1;
  }
}

// dhwrite
// file ../proto/proto_handshake.c line 236
static signed int dhwrite(struct handshake_cookie *H)
{
  signed int return_value_proto_crypt_dh_generate_1;
  return_value_proto_crypt_dh_generate_1=proto_crypt_dh_generate(H->yh_local, H->x, H->dhmac_local, H->nofps);
  if(return_value_proto_crypt_dh_generate_1 == 0)
  {
    H->write_cookie=network_write(H->s, H->yh_local, (unsigned long int)(256 + 32), (unsigned long int)(256 + 32), callback_dh_write, (void *)H);
    if(H->write_cookie == NULL)
      goto err0;

    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// dispatch_accept
// file dispatch.h line 24
signed int dispatch_accept(signed int s, const char *tgt, double rtime, struct sock_addr **sas, signed int decr, signed int nofps, signed int requirefps, signed int nokeepalive, struct proto_secret *K, unsigned long int nconn_max, double timeo)
{
  struct accept_state *A;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct accept_state) /*96ul*/ );
  A = (struct accept_state *)return_value_malloc_1;
  signed int return_value_doaccept_3;
  if(!(A == ((struct accept_state *)NULL)))
  {
    A->s = s;
    A->tgt = tgt;
    A->sas = sas;
    A->rtime = rtime;
    A->decr = decr;
    A->nofps = nofps;
    A->requirefps = requirefps;
    A->nokeepalive = nokeepalive;
    A->K = K;
    A->nconn = (unsigned long int)0;
    A->nconn_max = nconn_max;
    A->timeo = timeo;
    A->accept_cookie = (void *)0;
    if(rtime > 0.0)
    {
      A->T=dnsthread_spawn();
      void *return_value_events_timer_register_double_2;
      return_value_events_timer_register_double_2=events_timer_register_double(callback_resolveagain, (void *)A, A->rtime);
      if(return_value_events_timer_register_double_2 == NULL)
        goto err1;

    }

    return_value_doaccept_3=doaccept(A);
    if(return_value_doaccept_3 == 0)
      return 0;


  err1:
    ;
    if(rtime > 0.0)
      dnsthread_kill(A->T);

    free((void *)A);
  }


err0:
  ;
  return -1;
}

// dnsthread_kill
// file ../lib/dnsthread/dnsthread.h line 35
signed int dnsthread_kill(struct dnsthread_internal *T)
{
  signed int rc;
  signed int ostate;
  unsigned long int thr;
  rc=pthread_mutex_lock(&T->mtx);
  if(!(rc == 0))
    do
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(rc);
      libcperciva_warnx("pthread_mutex_lock: %s", return_value_strerror_1);
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
    }
    while((_Bool)0);

  else
  {
    ostate = T->state;
    thr = T->thr;
    T->state = 2;
    rc=pthread_cond_signal(&T->cv);
    if(!(rc == 0))
      do
      {
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(rc);
        libcperciva_warnx("pthread_cond_signal: %s", return_value_strerror_3);
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = 0;
      }
      while((_Bool)0);

    else
    {
      rc=pthread_mutex_unlock(&T->mtx);
      if(!(rc == 0))
      {
        do
        {
          char *return_value_strerror_5;
          return_value_strerror_5=strerror(rc);
          libcperciva_warnx("pthread_mutex_unlock: %s", return_value_strerror_5);
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          *return_value___errno_location_6 = 0;
        }
        while((_Bool)0);
        goto err0;
      }

      if(ostate == 0)
      {
        rc=pthread_join(thr, (void **)(void *)0);
        if(!(rc == 0))
        {
          do
          {
            char *return_value_strerror_7;
            return_value_strerror_7=strerror(rc);
            libcperciva_warnx("pthread_join: %s", return_value_strerror_7);
            signed int *return_value___errno_location_8;
            return_value___errno_location_8=__errno_location();
            *return_value___errno_location_8 = 0;
          }
          while((_Bool)0);
          goto err0;
        }

      }

      return 0;
    }

  err1:
    ;
    pthread_mutex_unlock(&T->mtx);
  }

err0:
  ;
  return -1;
}

// dnsthread_resolve
// file ../lib/dnsthread/dnsthread.c line 414
signed int dnsthread_resolve(const char *addr, signed int (*callback)(void *, struct sock_addr **), void *cookie)
{
  struct resolve_cookie *R;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct resolve_cookie) /*24ul*/ );
  R = (struct resolve_cookie *)return_value_malloc_1;
  signed int return_value_dnsthread_resolveone_2;
  if(!(R == ((struct resolve_cookie *)NULL)))
  {
    R->callback = callback;
    R->cookie = cookie;
    R->T=dnsthread_spawn();
    if(!(R->T == ((struct dnsthread_internal *)NULL)))
    {
      return_value_dnsthread_resolveone_2=dnsthread_resolveone(R->T, addr, callback_resolve_link1, (void *)R);
      if(return_value_dnsthread_resolveone_2 == 0)
        return 0;


    err2:
      ;
      dnsthread_kill(R->T);
    }


  err1:
    ;
    free((void *)R);
  }


err0:
  ;
  return -1;
}

// dnsthread_resolveone
// file ../lib/dnsthread/dnsthread.h line 26
signed int dnsthread_resolveone(struct dnsthread_internal *T, const char *addr, signed int (*callback)(void *, struct sock_addr **), void *cookie)
{
  signed int err = 0;
  signed int rc;
  rc=pthread_mutex_lock(&T->mtx);
  signed int return_value_events_network_register_7;
  signed int *return_value___errno_location_10;
  if(!(rc == 0))
    do
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(rc);
      libcperciva_warnx("pthread_mutex_lock: %s", return_value_strerror_1);
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
    }
    while((_Bool)0);

  else
  {
    if(T->state == 1)
      err = 114;

    else
    {
      T->addr=strdup(addr);
      if(T->addr == ((char *)NULL))
        goto err1;

      T->callback = callback;
      T->cookie = cookie;
      T->state = 1;
      rc=pthread_cond_signal(&T->cv);
      if(!(rc == 0))
      {
        do
        {
          char *return_value_strerror_3;
          return_value_strerror_3=strerror(rc);
          libcperciva_warnx("pthread_cond_signal: %s", return_value_strerror_3);
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          *return_value___errno_location_4 = 0;
        }
        while((_Bool)0);
        goto err1;
      }

      return_value_events_network_register_7=events_network_register(callback_resolveone, (void *)T, T->wakeupsock[(signed long int)1], 0);
      if(!(return_value_events_network_register_7 == 0))
      {
        do
        {
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          if(!(*return_value___errno_location_6 == 0))
          {
            libcperciva_warn("Error registering wakeup listener");
            signed int *return_value___errno_location_5;
            return_value___errno_location_5=__errno_location();
            *return_value___errno_location_5 = 0;
          }

          else
            libcperciva_warnx("Error registering wakeup listener");
        }
        while((_Bool)0);
        goto err1;
      }

    }

  ealready:
    ;
    rc=pthread_mutex_unlock(&T->mtx);
    if(!(rc == 0))
      do
      {
        char *return_value_strerror_8;
        return_value_strerror_8=strerror(rc);
        libcperciva_warnx("pthread_mutex_unlock: %s", return_value_strerror_8);
        signed int *return_value___errno_location_9;
        return_value___errno_location_9=__errno_location();
        *return_value___errno_location_9 = 0;
      }
      while((_Bool)0);

    else
    {
      if(!(err == 0))
      {
        return_value___errno_location_10=__errno_location();
        *return_value___errno_location_10 = err;
      }

      return 0;

    err1:
      ;
      pthread_mutex_unlock(&T->mtx);
    }
  }

err0:
  ;
  return -1;
}

// dnsthread_spawn
// file ../lib/dnsthread/dnsthread.h line 15
struct dnsthread_internal * dnsthread_spawn(void)
{
  struct dnsthread_internal *T;
  signed int rc;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct dnsthread_internal) /*152ul*/ );
  T = (struct dnsthread_internal *)return_value_malloc_1;
  signed int return_value_socketpair_10;
  if(!(T == ((struct dnsthread_internal *)NULL)))
  {
    rc=pthread_mutex_init(&T->mtx, (const union anonymous_6 *)(void *)0);
    if(!(rc == 0))
      do
      {
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(rc);
        libcperciva_warnx("pthread_mutex_init: %s", return_value_strerror_2);
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = 0;
      }
      while((_Bool)0);

    else
    {
      rc=pthread_mutex_lock(&T->mtx);
      if(!(rc == 0))
        do
        {
          char *return_value_strerror_4;
          return_value_strerror_4=strerror(rc);
          libcperciva_warnx("pthread_mutex_lock: %s", return_value_strerror_4);
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          *return_value___errno_location_5 = 0;
        }
        while((_Bool)0);

      else
      {
        rc=pthread_cond_init(&T->cv, (const union anonymous_6 *)(void *)0);
        if(!(rc == 0))
          do
          {
            char *return_value_strerror_6;
            return_value_strerror_6=strerror(rc);
            libcperciva_warnx("pthread_cond_init: %s", return_value_strerror_6);
            signed int *return_value___errno_location_7;
            return_value___errno_location_7=__errno_location();
            *return_value___errno_location_7 = 0;
          }
          while((_Bool)0);

        else
        {
          return_value_socketpair_10=socketpair(1, 1, 0, T->wakeupsock);
          if(!(return_value_socketpair_10 == 0))
            do
            {
              signed int *return_value___errno_location_9;
              return_value___errno_location_9=__errno_location();
              if(!(*return_value___errno_location_9 == 0))
              {
                libcperciva_warn("socketpair");
                signed int *return_value___errno_location_8;
                return_value___errno_location_8=__errno_location();
                *return_value___errno_location_8 = 0;
              }

              else
                libcperciva_warnx("socketpair");
            }
            while((_Bool)0);

          else
          {
            T->state = 0;
            rc=pthread_create(&T->thr, (const union pthread_attr_t *)(void *)0, workthread, (void *)T);
            if(!(rc == 0))
              do
              {
                char *return_value_strerror_11;
                return_value_strerror_11=strerror(rc);
                libcperciva_warnx("pthread_create: %s", return_value_strerror_11);
                signed int *return_value___errno_location_12;
                return_value___errno_location_12=__errno_location();
                *return_value___errno_location_12 = 0;
              }
              while((_Bool)0);

            else
            {
              rc=pthread_mutex_unlock(&T->mtx);
              if(!(rc == 0))
              {
                do
                {
                  char *return_value_strerror_13;
                  return_value_strerror_13=strerror(rc);
                  libcperciva_warnx("pthread_mutex_unlock: %s", return_value_strerror_13);
                  signed int *return_value___errno_location_14;
                  return_value___errno_location_14=__errno_location();
                  *return_value___errno_location_14 = 0;
                }
                while((_Bool)0);
                goto err0;
              }

              return T;
            }

          err5:
            ;
            close(T->wakeupsock[(signed long int)1]);
            close(T->wakeupsock[(signed long int)0]);
          }

        err4:
          ;
          pthread_cond_destroy(&T->cv);
        }

      err3:
        ;
        pthread_mutex_unlock(&T->mtx);
      }

    err2:
      ;
      pthread_mutex_destroy(&T->mtx);
    }

  err1:
    ;
    free((void *)T);
  }


err0:
  ;
  return (struct dnsthread_internal *)(void *)0;
}

// doaccept
// file dispatch.c line 76
static signed int doaccept(struct accept_state *A)
{
  signed int rc = 0;
  if(!(A->nconn >= A->nconn_max))
  {
    if(A->accept_cookie == NULL)
    {
      A->accept_cookie=network_accept(A->s, callback_gotconn, (void *)A);
      if(A->accept_cookie == NULL)
        rc = -1;

    }

  }

  return rc;
}

// docallback
// file ../libcperciva/network/network_connect.c line 30
static signed int docallback(void *cookie)
{
  struct connect_cookie *C = (struct connect_cookie *)cookie;
  signed int rc;
  rc=C->callback(C->cookie, C->s);
  free((void *)C);
  return rc;
}

// docallback_link1
// file ../libcperciva/network/network_read.c line 27
static signed int docallback_link1(struct network_read_cookie *C, signed long int nbytes)
{
  signed int rc_link1;
  rc_link1=C->callback(C->cookie, nbytes);
  free((void *)C);
  return rc_link1;
}

// docallback_link2
// file ../libcperciva/network/network_write.c line 45
static signed int docallback_link2(struct network_write_cookie *C_link1, signed long int nbytes_link1)
{
  signed int rc_link2;
  rc_link2=C_link1->callback(C_link1->cookie, nbytes_link1);
  free((void *)C_link1);
  return rc_link2;
}

// doevent
// file ../libcperciva/events/events.c line 60
static inline signed int doevent(struct eventrec *r)
{
  signed int rc;
  rc=r->func(r->cookie);
  mpool_eventrec_free(r);
  return rc;
}

// dofailed
// file ../libcperciva/network/network_connect.c line 47
static signed int dofailed(struct connect_cookie *C)
{
  close(C->s);
  C->s = -1;
  C->sas = C->sas + 1l;
  signed int return_value_tryconnect_1;
  return_value_tryconnect_1=tryconnect(C);
  return return_value_tryconnect_1;
}

// done
// file ../libcperciva/util/warnp.c line 14
static void done(void)
{
  free((void *)name);
  name = (char *)(void *)0;
}

// dropconn
// file ../proto/proto_conn.c line 108
static signed int dropconn(struct conn_state *C)
{
  signed int rc;
  close(C->s);
  if(!(C->t == -1))
    close(C->t);

  if(!(C->connect_cookie == NULL))
    network_connect_cancel(C->connect_cookie);

  sock_addr_freelist(C->sas);
  if(!(C->handshake_cookie == NULL))
    proto_handshake_cancel(C->handshake_cookie);

  if(!(C->connect_timeout_cookie == NULL))
    events_timer_cancel(C->connect_timeout_cookie);

  if(!(C->handshake_timeout_cookie == NULL))
    events_timer_cancel(C->handshake_timeout_cookie);

  proto_crypt_free(C->k_f);
  proto_crypt_free(C->k_r);
  if(!(C->pipe_f == NULL))
    proto_pipe_cancel(C->pipe_f);

  if(!(C->pipe_r == NULL))
    proto_pipe_cancel(C->pipe_r);

  rc=C->callback_dead(C->cookie);
  free((void *)C);
  return rc;
}

// elasticarray_append
// file ../libcperciva/datastruct/elasticarray.c line 139
signed int elasticarray_append(struct elasticarray *EA, const void *buf, unsigned long int nrec, unsigned long int reclen)
{
  unsigned long int bufpos = EA->size;
  _Bool tmp_if_expr_2;
  if(!(18446744073709551615UL / reclen >= nrec))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = nrec * reclen > 18446744073709551615UL - EA->size ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 12;
    goto err0;
  }

  signed int return_value_resize_3;
  return_value_resize_3=resize(EA, EA->size + nrec * reclen);
  if(return_value_resize_3 == 0)
  {
    memcpy((void *)((unsigned char *)EA->buf + (signed long int)bufpos), buf, nrec * reclen);
    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// elasticarray_export
// file ../libcperciva/datastruct/elasticarray.c line 258
signed int elasticarray_export(struct elasticarray *EA, void **buf, unsigned long int *nrec, unsigned long int reclen)
{
  signed int return_value_elasticarray_truncate_1;
  return_value_elasticarray_truncate_1=elasticarray_truncate(EA);
  if(return_value_elasticarray_truncate_1 == 0)
  {
    *buf = EA->buf;
    *nrec=elasticarray_getsize(EA, reclen);
    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// elasticarray_free
// file ../libcperciva/datastruct/elasticarray.c line 241
void elasticarray_free(struct elasticarray *EA)
{
  if(!(EA == ((struct elasticarray *)NULL)))
  {
    free(EA->buf);
    free((void *)EA);
  }

}

// elasticarray_get
// file ../libcperciva/datastruct/elasticarray.c line 230
void * elasticarray_get(struct elasticarray *EA, unsigned long int pos, unsigned long int reclen)
{
  return (void *)((unsigned char *)EA->buf + (signed long int)(pos * reclen));
}

// elasticarray_getsize
// file ../libcperciva/datastruct/elasticarray.c line 127
unsigned long int elasticarray_getsize(struct elasticarray *EA, unsigned long int reclen)
{
  return EA->size / reclen;
}

// elasticarray_init
// file ../libcperciva/datastruct/elasticarray.c line 65
struct elasticarray * elasticarray_init(unsigned long int nrec, unsigned long int reclen)
{
  struct elasticarray *EA;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct elasticarray) /*24ul*/ );
  EA = (struct elasticarray *)return_value_malloc_1;
  signed int return_value_elasticarray_resize_2;
  if(!(EA == ((struct elasticarray *)NULL)))
  {
    EA->alloc = (unsigned long int)0;
    EA->size = EA->alloc;
    EA->buf = (void *)0;
    return_value_elasticarray_resize_2=elasticarray_resize(EA, nrec, reclen);
    if(return_value_elasticarray_resize_2 == 0)
      return EA;


  err1:
    ;
    elasticarray_free(EA);
  }


err0:
  ;
  return (struct elasticarray *)(void *)0;
}

// elasticarray_resize
// file ../libcperciva/datastruct/elasticarray.c line 99
signed int elasticarray_resize(struct elasticarray *EA, unsigned long int nrec, unsigned long int reclen)
{
  if(!(18446744073709551615UL / reclen >= nrec))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 12;
    goto err0;
  }

  signed int return_value_resize_2;
  return_value_resize_2=resize(EA, nrec * reclen);
  if(return_value_resize_2 == 0)
    return 0;

  else
  {

  err0:
    ;
    return -1;
  }
}

// elasticarray_shrink
// file ../libcperciva/datastruct/elasticarray.c line 177
void elasticarray_shrink(struct elasticarray *EA, unsigned long int nrec, unsigned long int reclen)
{
  unsigned long int nsize;
  _Bool tmp_if_expr_1;
  if(!(18446744073709551615UL / reclen >= nrec))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = nrec * reclen > EA->size ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    nsize = (unsigned long int)0;

  else
    nsize = EA->size - nrec * reclen;
  signed int return_value_resize_2;
  return_value_resize_2=resize(EA, nsize);
  if(!(return_value_resize_2 == 0))
    EA->size = nsize;

}

// elasticarray_truncate
// file ../libcperciva/datastruct/elasticarray.c line 203
signed int elasticarray_truncate(struct elasticarray *EA)
{
  void *nbuf;
  if(!(EA->size >= EA->alloc))
  {
    nbuf=realloc(EA->buf, EA->size);
    if(nbuf == NULL)
    {
      if(EA->size >= 1ul)
        goto err0;

    }

    EA->buf = nbuf;
    EA->alloc = EA->size;
  }

  return 0;

err0:
  ;
  return -1;
}

// entropy_read
// file ../libcperciva/util/entropy.c line 23
signed int entropy_read(unsigned char *buf, unsigned long int buflen)
{
  signed int fd;
  signed long int lenread;
  signed int return_value_close_7;
  if(buflen >= 9223372036854775808ul)
    do
    {
      libcperciva_warnx("Programmer error: Trying to read insane amount of random data: %zu", buflen);
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 0;
    }
    while((_Bool)0);

  else
  {
    fd=open("/dev/urandom", 00);
    if(fd == -1)
      do
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        if(!(*return_value___errno_location_3 == 0))
        {
          libcperciva_warn("open(/dev/urandom)");
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          *return_value___errno_location_2 = 0;
        }

        else
          libcperciva_warnx("open(/dev/urandom)");
      }
      while((_Bool)0);

    else
    {
      for( ; buflen >= 1ul; buflen = buflen - (unsigned long int)lenread)
      {
        lenread=read(fd, (void *)buf, buflen);
        if(lenread == -1l)
        {
          do
          {
            signed int *return_value___errno_location_5;
            return_value___errno_location_5=__errno_location();
            if(!(*return_value___errno_location_5 == 0))
            {
              libcperciva_warn("read(/dev/urandom)");
              signed int *return_value___errno_location_4;
              return_value___errno_location_4=__errno_location();
              *return_value___errno_location_4 = 0;
            }

            else
              libcperciva_warnx("read(/dev/urandom)");
          }
          while((_Bool)0);
          goto err1;
        }

        if(lenread == 0l)
        {
          do
          {
            libcperciva_warnx("EOF on /dev/urandom?");
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            *return_value___errno_location_6 = 0;
          }
          while((_Bool)0);
          goto err1;
        }

        buf = buf + lenread;
      }
      do
      {
        return_value_close_7=close(fd);
        if(!(return_value_close_7 == -1))
          break;

        signed int *return_value___errno_location_10;
        return_value___errno_location_10=__errno_location();
        if(!(*return_value___errno_location_10 == 4))
        {
          do
          {
            signed int *return_value___errno_location_9;
            return_value___errno_location_9=__errno_location();
            if(!(*return_value___errno_location_9 == 0))
            {
              libcperciva_warn("close(/dev/urandom)");
              signed int *return_value___errno_location_8;
              return_value___errno_location_8=__errno_location();
              *return_value___errno_location_8 = 0;
            }

            else
              libcperciva_warnx("close(/dev/urandom)");
          }
          while((_Bool)0);
          goto err0;
        }

      }
      while((_Bool)1);
      return 0;

    err1:
      ;
      close(fd);
    }
  }

err0:
  ;
  return -1;
}

// events_freerec
// file ../libcperciva/events/events_internal.h line 19
void events_freerec(struct eventrec *r)
{
  mpool_eventrec_free(r);
}

// events_immediate_cancel
// file ../libcperciva/events/events_immediate.c line 88
void events_immediate_cancel(void *cookie)
{
  struct eventq *q = (struct eventq *)cookie;
  signed int prio = q->prio;
  if(!(q->prev == ((struct eventq *)NULL)))
    q->prev->next = q->next;

  else
    heads[(signed long int)prio] = q->next;
  if(!(q->next == ((struct eventq *)NULL)))
    q->next->prev = q->prev;

  else
    tails[(signed long int)prio] = q->prev;
  events_freerec(q->r);
  mpool_eventq_free(q);
}

// events_immediate_get
// file ../libcperciva/events/events_immediate.c line 119
struct eventrec * events_immediate_get(void)
{
  struct eventq *q;
  struct eventrec *r;
  for( ; !(minq >= 32); minq = minq + 1)
    if(!(heads[(signed long int)minq] == ((struct eventq *)NULL)))
      break;

  if(minq == 32)
    return (struct eventrec *)(void *)0;

  else
  {
    q = heads[(signed long int)minq];
    heads[(signed long int)minq] = q->next;
    if(!(heads[(signed long int)minq] == ((struct eventq *)NULL)))
      heads[(signed long int)minq]->prev = (struct eventq *)(void *)0;

    r = q->r;
    mpool_eventq_free(q);
    return r;
  }
}

// events_immediate_register
// file ../libcperciva/events/events_immediate.c line 41
void * events_immediate_register(signed int (*func)(void *), void *cookie, signed int prio)
{
  struct eventrec *r;
  struct eventq *q;
  /* assertion (prio >= 0) && (prio < 32) */
  assert(prio >= 0 && prio < 32);
  r=events_mkrec(func, cookie);
  if(!(r == ((struct eventrec *)NULL)))
  {
    q=mpool_eventq_malloc();
    if(!(q == ((struct eventq *)NULL)))
    {
      q->r = r;
      q->next = (struct eventq *)(void *)0;
      q->prev = (struct eventq *)(void *)0;
      q->prio = prio;
      if(heads[(signed long int)prio] == ((struct eventq *)NULL))
      {
        heads[(signed long int)prio] = q;
        if(!(prio >= minq))
          minq = prio;

      }

      else
      {
        tails[(signed long int)prio]->next = q;
        q->prev = tails[(signed long int)prio];
      }
      tails[(signed long int)prio] = q;
      return (void *)q;
    }


  err1:
    ;
    events_freerec(r);
  }


err0:
  ;
  return (void *)0;
}

// events_mkrec
// file ../libcperciva/events/events_internal.h line 13
struct eventrec * events_mkrec(signed int (*func)(void *), void *cookie)
{
  struct eventrec *r;
  r=mpool_eventrec_malloc();
  if(!(r == ((struct eventrec *)NULL)))
  {
    r->func = func;
    r->cookie = cookie;
    return r;
  }

  else
  {

  err0:
    ;
    return (struct eventrec *)(void *)0;
  }
}

// events_network_cancel
// file ../libcperciva/events/events_network.c line 160
signed int events_network_cancel(signed int s, signed int op)
{
  struct eventrec **r;
  signed int return_value_initsocketlist_1;
  return_value_initsocketlist_1=initsocketlist();
  unsigned long int return_value_socketlist_getsize_5;
  struct socketrec *return_value_socketlist_get_6;
  struct socketrec *return_value_socketlist_get_7;
  if(return_value_initsocketlist_1 == 0)
  {
    if(s >= 1024 || !(s >= 0))
    {
      do
      {
        libcperciva_warnx("Invalid file descriptor for network event: %d", s);
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 0;
      }
      while((_Bool)0);
      goto err0;
    }

    if(!(op == 0) && !(op == 1))
    {
      do
      {
        libcperciva_warnx("Invalid operation for network event: %d", op);
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = 0;
      }
      while((_Bool)0);
      goto err0;
    }

    return_value_socketlist_getsize_5=socketlist_getsize(S);
    if((unsigned long int)s >= return_value_socketlist_getsize_5)
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = 2;
      goto err0;
    }

    if(op == 0)
    {
      return_value_socketlist_get_6=socketlist_get(S, (unsigned long int)s);
      r = &return_value_socketlist_get_6->reader;
    }

    else
    {
      return_value_socketlist_get_7=socketlist_get(S, (unsigned long int)s);
      r = &return_value_socketlist_get_7->writer;
    }
    if(*r == ((struct eventrec *)NULL))
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      *return_value___errno_location_8 = 2;
      goto err0;
    }

    events_freerec(*r);
    *r = (struct eventrec *)(void *)0;
    if(op == 0)
      (&readfds)->__fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->__fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << s % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));

    else
      (&writefds)->__fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writefds)->__fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << s % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
    nev = nev - 1ul;
    if(nev == 0ul)
      events_network_selectstats_stopclock();

    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// events_network_get
// file ../libcperciva/events/events_network.c line 292
struct eventrec * events_network_get(void)
{
  struct eventrec *r;
  unsigned long int nfds;
  nfds=socketlist_getsize(S);
  r = (struct eventrec *)(void *)0;
  for( ; !(fdscanpos >= nfds); fdscanpos = fdscanpos + 1ul)
  {
    if(!((readfds.__fds_bits[(signed long int)(fdscanpos / sizeof(signed long int) * 8 /*64ul*/ )] & (signed long int)(1UL << fdscanpos % sizeof(signed long int) * 8 /*64ul*/ )) == 0l))
    {
      struct socketrec *return_value_socketlist_get_1;
      return_value_socketlist_get_1=socketlist_get(S, fdscanpos);
      r = return_value_socketlist_get_1->reader;
      struct socketrec *return_value_socketlist_get_2;
      return_value_socketlist_get_2=socketlist_get(S, fdscanpos);
      return_value_socketlist_get_2->reader = (struct eventrec *)(void *)0;
      nev = nev - 1ul;
      if(nev == 0ul)
        events_network_selectstats_stopclock();

      (&readfds)->__fds_bits[(signed long int)(fdscanpos / (unsigned long int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->__fds_bits[(signed long int)(fdscanpos / (unsigned long int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fdscanpos % (unsigned long int)(8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      break;
    }

    if(!((writefds.__fds_bits[(signed long int)(fdscanpos / sizeof(signed long int) * 8 /*64ul*/ )] & (signed long int)(1UL << fdscanpos % sizeof(signed long int) * 8 /*64ul*/ )) == 0l))
    {
      struct socketrec *return_value_socketlist_get_3;
      return_value_socketlist_get_3=socketlist_get(S, fdscanpos);
      r = return_value_socketlist_get_3->writer;
      struct socketrec *return_value_socketlist_get_4;
      return_value_socketlist_get_4=socketlist_get(S, fdscanpos);
      return_value_socketlist_get_4->writer = (struct eventrec *)(void *)0;
      nev = nev - 1ul;
      if(nev == 0ul)
        events_network_selectstats_stopclock();

      (&writefds)->__fds_bits[(signed long int)(fdscanpos / (unsigned long int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writefds)->__fds_bits[(signed long int)(fdscanpos / (unsigned long int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fdscanpos % (unsigned long int)(8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      break;
    }

  }
  return r;
}

// events_network_register
// file ../libcperciva/events/events.h line 34
signed int events_network_register(signed int (*func)(void *), void *cookie, signed int s, signed int op)
{
  struct eventrec **r;
  signed int return_value_initsocketlist_1;
  return_value_initsocketlist_1=initsocketlist();
  unsigned long int return_value_socketlist_getsize_5;
  signed int return_value_growsocketlist_4;
  struct socketrec *return_value_socketlist_get_6;
  struct socketrec *return_value_socketlist_get_7;
  unsigned long int tmp_post_9;
  if(return_value_initsocketlist_1 == 0)
  {
    if(s >= 1024 || !(s >= 0))
    {
      do
      {
        libcperciva_warnx("Invalid file descriptor for network event: %d", s);
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 0;
      }
      while((_Bool)0);
      goto err0;
    }

    if(!(op == 0) && !(op == 1))
    {
      do
      {
        libcperciva_warnx("Invalid operation for network event: %d", op);
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = 0;
      }
      while((_Bool)0);
      goto err0;
    }

    return_value_socketlist_getsize_5=socketlist_getsize(S);
    if((unsigned long int)s >= return_value_socketlist_getsize_5)
    {
      return_value_growsocketlist_4=growsocketlist((unsigned long int)(s + 1));
      if(!(return_value_growsocketlist_4 == 0))
        goto err0;

    }

    if(op == 0)
    {
      return_value_socketlist_get_6=socketlist_get(S, (unsigned long int)s);
      r = &return_value_socketlist_get_6->reader;
    }

    else
    {
      return_value_socketlist_get_7=socketlist_get(S, (unsigned long int)s);
      r = &return_value_socketlist_get_7->writer;
    }
    if(!(*r == ((struct eventrec *)NULL)))
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      *return_value___errno_location_8 = 17;
      goto err0;
    }

    *r=events_mkrec(func, cookie);
    if(*r == ((struct eventrec *)NULL))
      goto err0;

    tmp_post_9 = nev;
    nev = nev + 1ul;
    if(tmp_post_9 == 0ul)
      events_network_selectstats_startclock();

    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// events_network_select
// file ../libcperciva/events/events_network.c line 234
signed int events_network_select(struct timeval *tv)
{
  unsigned long int i;
  signed int return_value_initsocketlist_1;
  return_value_initsocketlist_1=initsocketlist();
  unsigned long int return_value_socketlist_getsize_2;
  unsigned long int return_value_socketlist_getsize_5;
  signed int return_value_select_6;
  if(return_value_initsocketlist_1 == 0)
  {
    do
    {
      signed int __d0;
      signed int events_network_select__1__1____d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(events_network_select__1__1____d1) : "a"(0), "0"(sizeof(struct anonymous_0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readfds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    do
    {
      signed int events_network_select__1__2____d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(events_network_select__1__2____d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&writefds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    i = (unsigned long int)0;
    do
    {
      return_value_socketlist_getsize_2=socketlist_getsize(S);
      if(i >= return_value_socketlist_getsize_2)
        break;

      struct socketrec *return_value_socketlist_get_3;
      return_value_socketlist_get_3=socketlist_get(S, i);
      if(!(return_value_socketlist_get_3->reader == ((struct eventrec *)NULL)))
        (&readfds)->__fds_bits[(signed long int)(i / (unsigned long int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->__fds_bits[(signed long int)(i / (unsigned long int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << i % (unsigned long int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ));

      struct socketrec *return_value_socketlist_get_4;
      return_value_socketlist_get_4=socketlist_get(S, i);
      if(!(return_value_socketlist_get_4->writer == ((struct eventrec *)NULL)))
        (&writefds)->__fds_bits[(signed long int)(i / (unsigned long int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writefds)->__fds_bits[(signed long int)(i / (unsigned long int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << i % (unsigned long int)(8 * (signed int)sizeof(signed long int) /*8ul*/ ));

      i = i + 1ul;
    }
    while((_Bool)1);
    events_network_selectstats_select();
    do
    {
      return_value_socketlist_getsize_5=socketlist_getsize(S);
      return_value_select_6=select((signed int)return_value_socketlist_getsize_5, &readfds, &writefds, (struct anonymous_0 *)(void *)0, tv);
      if(!(return_value_select_6 == -1))
        break;

      signed int *return_value___errno_location_7;
      return_value___errno_location_7=__errno_location();
      if(!(*return_value___errno_location_7 == 4))
      {
        do
        {
          signed int *return_value___errno_location_9;
          return_value___errno_location_9=__errno_location();
          if(!(*return_value___errno_location_9 == 0))
          {
            libcperciva_warn("select()");
            signed int *return_value___errno_location_8;
            return_value___errno_location_8=__errno_location();
            *return_value___errno_location_8 = 0;
          }

          else
            libcperciva_warnx("select()");
        }
        while((_Bool)0);
        goto err0;
      }

    }
    while((_Bool)1);
    if(nev >= 1ul)
      events_network_selectstats_startclock();

    fdscanpos = (unsigned long int)0;
    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// events_network_selectstats
// file ../libcperciva/events/events_network_selectstats.c line 91
void events_network_selectstats(double *_N, double *_mu, double *_va, double *_max)
{
  *_N = N;
  *_mu = mu;
  if(N > 1.0)
    *_va = M2 / (N - 1.0);

  else
    *_va = 0.0;
  *_max = max;
  max = 0.0;
  M2 = max;
  mu = M2;
  N = mu;
}

// events_network_selectstats_select
// file ../libcperciva/events/events_internal.h line 54
void events_network_selectstats_select(void)
{
  struct timeval tnow;
  double t;
  double d;
  if(!(running == 0))
  {
    signed int return_value_monoclock_get_1;
    return_value_monoclock_get_1=monoclock_get(&tnow);
    if(return_value_monoclock_get_1 == 0)
    {
      t = (double)(tnow.tv_sec - st.tv_sec) + (double)(tnow.tv_usec - st.tv_usec) * 0.000001;
      N = N + 1.0;
      d = t - mu;
      mu = mu + d / N;
      M2 = M2 + d * (t - mu);
      if(max < t)
        max = t;

    }


  done:
    ;
    running = 0;
  }

}

// events_network_selectstats_startclock
// file ../libcperciva/events/events_internal.h line 41
void events_network_selectstats_startclock(void)
{
  if(running == 0)
  {
    signed int return_value_monoclock_get_1;
    return_value_monoclock_get_1=monoclock_get(&st);
    if(return_value_monoclock_get_1 == 0)
      running = 1;

  }

}

// events_network_selectstats_stopclock
// file ../libcperciva/events/events_internal.h line 47
void events_network_selectstats_stopclock(void)
{
  running = 0;
}

// events_network_shutdown
// file ../libcperciva/events/events_network.c line 333
void events_network_shutdown(void)
{
  if(!(S == ((struct socketlist_struct *)NULL)))
  {
    if(!(nev >= 1ul))
    {
      socketlist_free(S);
      S = (struct socketlist_struct *)(void *)0;
    }

  }

}

// events_run
// file ../libcperciva/events/events.h line 89
signed int events_run(void)
{
  struct eventrec *r;
  struct timeval *tv;
  struct timeval tv2;
  signed int rc = 0;
  r=events_immediate_get();
  signed int return_value_events_timer_min_1;
  signed int return_value_events_network_select_2;
  if(!(r == ((struct eventrec *)NULL)))
    while(!(r == ((struct eventrec *)NULL)))
    {
      rc=doevent(r);
      if(!(rc == 0))
        goto done;

      r=events_immediate_get();
    }

  else
  {
    return_value_events_timer_min_1=events_timer_min(&tv);
    if(!(return_value_events_timer_min_1 == 0))
      goto err0;

    return_value_events_network_select_2=events_network_select(tv);
    if(!(return_value_events_network_select_2 == 0))
      goto err1;

    free((void *)tv);
    do
    {
      r=events_immediate_get();
      if(!(r == ((struct eventrec *)NULL)))
      {
        rc=doevent(r);
        if(!(rc == 0))
          break;

      }

      else
      {
        r=events_network_get();
        if(!(r == ((struct eventrec *)NULL)))
        {
          rc=doevent(r);
          if(!(rc == 0))
            break;

        }

        else
        {
          memcpy((void *)&tv2, (const void *)&tv_zero, sizeof(struct timeval) /*16ul*/ );
          signed int return_value_events_network_select_3;
          return_value_events_network_select_3=events_network_select(&tv2);
          if(!(return_value_events_network_select_3 == 0))
            goto err0;

          r=events_network_get();
          if(!(r == ((struct eventrec *)NULL)))
          {
            rc=doevent(r);
            if(!(rc == 0))
              break;

          }

          else
          {
            signed int return_value_events_timer_get_4;
            return_value_events_timer_get_4=events_timer_get(&r);
            if(!(return_value_events_timer_get_4 == 0))
              goto err0;

            if(!(r == ((struct eventrec *)NULL)))
            {
              rc=doevent(r);
              if(!(rc == 0))
                break;

            }

            else
              break;
          }
        }
      }
    }
    while((_Bool)1);
  }

done:
  ;
  return rc;

err1:
  ;
  free((void *)tv);

err0:
  ;
  return -1;
}

// events_shutdown
// file ../libcperciva/events/events.c line 198
void events_shutdown(void)
{
  events_network_shutdown();
  events_timer_shutdown();
}

// events_spin
// file ../libcperciva/events/events.c line 178
signed int events_spin(signed int *done)
{
  signed int rc = 0;
  while(*done == 0)
  {
    if(!(rc == 0))
      break;

    rc=events_run();
  }
  return rc;
}

// events_timer_cancel
// file ../libcperciva/events/events.h line 70
void events_timer_cancel(void *cookie)
{
  struct timerrec *t = (struct timerrec *)cookie;
  timerqueue_delete(Q, t->cookie);
  events_freerec(t->r);
  free((void *)t);
}

// events_timer_get
// file ../libcperciva/events/events_timer.c line 222
signed int events_timer_get(struct eventrec **r)
{
  struct timeval tnow;
  struct timerrec *t;
  signed int return_value_monoclock_get_1;
  void *return_value_timerqueue_getptr_2;
  if(Q == ((struct timerqueue *)NULL))
    *r = (struct eventrec *)(void *)0;

  else
  {
    return_value_monoclock_get_1=monoclock_get(&tnow);
    if(!(return_value_monoclock_get_1 == 0))
      goto err0;

    return_value_timerqueue_getptr_2=timerqueue_getptr(Q, &tnow);
    t = (struct timerrec *)return_value_timerqueue_getptr_2;
    if(!(t == ((struct timerrec *)NULL)))
    {
      *r = t->r;
      free((void *)t);
    }

    else
      *r = (struct eventrec *)(void *)0;
  }

done:
  ;
  return 0;

err0:
  ;
  return -1;
}

// events_timer_min
// file ../libcperciva/events/events_timer.c line 160
signed int events_timer_min(struct timeval **timeo)
{
  struct timeval tnow;
  struct timeval *tv;
  void *return_value_malloc_1;
  signed int return_value_monoclock_get_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  if(Q == ((struct timerqueue *)NULL))
    *timeo = (struct timeval *)(void *)0;

  else
  {
    tv=timerqueue_getmin(Q);
    if(tv == ((struct timeval *)NULL))
      *timeo = (struct timeval *)(void *)0;

    else
    {
      return_value_malloc_1=malloc(sizeof(struct timeval) /*16ul*/ );
      *timeo = (struct timeval *)return_value_malloc_1;
      if(*timeo == ((struct timeval *)NULL))
        goto err0;

      return_value_monoclock_get_2=monoclock_get(&tnow);
      if(!(return_value_monoclock_get_2 == 0))
        goto err1;

      if(!(tv->tv_sec >= tnow.tv_sec))
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        if(tnow.tv_sec == tv->tv_sec)
          tmp_if_expr_3 = tnow.tv_usec > tv->tv_usec ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
      {
        (*timeo)->tv_sec = (signed long int)0;
        (*timeo)->tv_usec = (signed long int)0;
      }

      else
      {
        (*timeo)->tv_sec = tv->tv_sec - tnow.tv_sec;
        (*timeo)->tv_usec = tv->tv_usec - tnow.tv_usec;
        if(!(tv->tv_usec >= tnow.tv_usec))
        {
          (*timeo)->tv_usec = (*timeo)->tv_usec + (signed long int)1000000;
          (*timeo)->tv_sec = (*timeo)->tv_sec - (signed long int)1;
        }

      }
    }
  }

done:
  ;
  return 0;

err1:
  ;
  free((void *)*timeo);

err0:
  ;
  return -1;
}

// events_timer_register
// file ../libcperciva/events/events_timer.c line 47
void * events_timer_register(signed int (*func)(void *), void *cookie, struct timeval *timeo)
{
  struct eventrec *r;
  struct timerrec *t;
  struct timeval tv;
  if(Q == ((struct timerqueue *)NULL))
  {
    Q=timerqueue_init();
    if(Q == ((struct timerqueue *)NULL))
      goto err0;

  }

  r=events_mkrec(func, cookie);
  void *return_value_malloc_1;
  signed int return_value_gettimeout_2;
  if(!(r == ((struct eventrec *)NULL)))
  {
    return_value_malloc_1=malloc(sizeof(struct timerrec) /*32ul*/ );
    t = (struct timerrec *)return_value_malloc_1;
    if(!(t == ((struct timerrec *)NULL)))
    {
      t->r = r;
      memcpy((void *)&t->tv_orig, (const void *)timeo, sizeof(struct timeval) /*16ul*/ );
      return_value_gettimeout_2=gettimeout(&tv, &t->tv_orig);
      if(return_value_gettimeout_2 == 0)
      {
        t->cookie=timerqueue_add(Q, &tv, (void *)t);
        if(!(t->cookie == NULL))
          return (void *)t;

      }


    err2:
      ;
      free((void *)t);
    }


  err1:
    ;
    events_freerec(r);
  }


err0:
  ;
  return (void *)0;
}

// events_timer_register_double
// file ../libcperciva/events/events.h line 63
void * events_timer_register_double(signed int (*func)(void *), void *cookie, double timeo)
{
  struct timeval tv;
  tv.tv_sec = (signed long int)timeo;
  tv.tv_usec = (signed long int)((timeo - (double)tv.tv_sec) * 1000000.0);
  void *return_value_events_timer_register_1;
  return_value_events_timer_register_1=events_timer_register(func, cookie, &tv);
  return return_value_events_timer_register_1;
}

// events_timer_reset
// file ../libcperciva/events/events_timer.c line 133
signed int events_timer_reset(void *cookie)
{
  struct timerrec *t = (struct timerrec *)cookie;
  struct timeval tv;
  signed int return_value_gettimeout_1;
  return_value_gettimeout_1=gettimeout(&tv, &t->tv_orig);
  if(return_value_gettimeout_1 == 0)
  {
    timerqueue_increase(Q, t->cookie, &tv);
    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// events_timer_shutdown
// file ../libcperciva/events/events_timer.c line 265
void events_timer_shutdown(void)
{
  struct timeval *return_value_timerqueue_getmin_1;
  if(!(Q == ((struct timerqueue *)NULL)))
  {
    return_value_timerqueue_getmin_1=timerqueue_getmin(Q);
    if(return_value_timerqueue_getmin_1 == ((struct timeval *)NULL))
    {
      timerqueue_free(Q);
      Q = (struct timerqueue *)(void *)0;
    }

  }

}

// generate
// file ../libcperciva/crypto/crypto_entropy.c line 149
static void generate(unsigned char *buf, unsigned long int buflen)
{
  unsigned long int bufpos;
  /* assertion buflen <= 65536 */
  assert(buflen <= (unsigned long int)65536);
  /* assertion drbg.reseed_counter <= 256 */
  assert(drbg.reseed_counter <= (unsigned int)256);
  bufpos = (unsigned long int)0;
  for( ; !(bufpos >= buflen); bufpos = bufpos + (unsigned long int)32)
  {
    libcperciva_HMAC_SHA256_Buf((const void *)drbg.Key, (unsigned long int)32, (const void *)drbg.V, (unsigned long int)32, drbg.V);
    if(buflen + -bufpos >= 32ul)
      memcpy((void *)&buf[(signed long int)bufpos], (const void *)drbg.V, (unsigned long int)32);

    else
      memcpy((void *)&buf[(signed long int)bufpos], (const void *)drbg.V, buflen - bufpos);
  }
  update((unsigned char *)(void *)0, (unsigned long int)0);
  drbg.reseed_counter = drbg.reseed_counter + (unsigned int)1;
}

// gettimeout
// file ../libcperciva/events/events_timer.c line 22
static signed int gettimeout(struct timeval *tv, struct timeval *tdelta)
{
  signed int return_value_monoclock_get_1;
  return_value_monoclock_get_1=monoclock_get(tv);
  if(return_value_monoclock_get_1 == 0)
  {
    tv->tv_sec = tv->tv_sec + tdelta->tv_sec;
    tv->tv_usec = tv->tv_usec + tdelta->tv_usec;
    if(tv->tv_usec >= 1000000l)
    {
      tv->tv_usec = tv->tv_usec - (signed long int)1000000;
      tv->tv_sec = tv->tv_sec + (signed long int)1;
    }

    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// gotnonces
// file ../proto/proto_handshake.c line 166
static signed int gotnonces(struct handshake_cookie *H)
{
  proto_crypt_dhmac(H->K, H->nonce_local, H->nonce_remote, H->dhmac_local, H->dhmac_remote, H->decr);
  signed int return_value_dhread_1;
  signed int return_value_dhwrite_2;
  if(!(H->decr == 0))
  {
    return_value_dhread_1=dhread(H);
    return return_value_dhread_1;
  }

  else
  {
    return_value_dhwrite_2=dhwrite(H);
    return return_value_dhwrite_2;
  }
}

// growsocketlist
// file ../libcperciva/events/events_network.c line 62
static signed int growsocketlist(unsigned long int nrec)
{
  unsigned long int i;
  i=socketlist_getsize(S);
  signed int return_value_socketlist_resize_1;
  return_value_socketlist_resize_1=socketlist_resize(S, nrec);
  if(return_value_socketlist_resize_1 == 0)
  {
    for( ; !(i >= nrec); i = i + 1ul)
    {
      struct socketrec *return_value_socketlist_get_2;
      return_value_socketlist_get_2=socketlist_get(S, i);
      return_value_socketlist_get_2->reader = (struct eventrec *)(void *)0;
      struct socketrec *return_value_socketlist_get_3;
      return_value_socketlist_get_3=socketlist_get(S, i);
      return_value_socketlist_get_3->writer = (struct eventrec *)(void *)0;
    }
    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// handshakedone
// file ../proto/proto_handshake.c line 284
static signed int handshakedone(struct handshake_cookie *H)
{
  struct proto_keys *c;
  struct proto_keys *s;
  signed int rc;
  /* assertion H->read_cookie == ((void *)0) */
  assert(H->read_cookie == (void *)0);
  /* assertion H->write_cookie == ((void *)0) */
  assert(H->write_cookie == (void *)0);
  signed int return_value_proto_crypt_mkkeys_1;
  return_value_proto_crypt_mkkeys_1=proto_crypt_mkkeys(H->K, H->nonce_local, H->nonce_remote, H->yh_remote, H->x, H->nofps, H->decr, &c, &s);
  if(return_value_proto_crypt_mkkeys_1 == 0)
  {
    rc=H->callback(H->cookie, c, s);
    free((void *)H);
    return rc;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// handshakefail
// file ../proto/proto_handshake.c line 43
static signed int handshakefail(struct handshake_cookie *H)
{
  signed int rc;
  if(!(H->read_cookie == NULL))
    network_read_cancel(H->read_cookie);

  if(!(H->write_cookie == NULL))
    network_write_cancel(H->write_cookie);

  rc=H->callback(H->cookie, (struct proto_keys *)(void *)0, (struct proto_keys *)(void *)0);
  free((void *)H);
  return rc;
}

// heapify
// file ../libcperciva/datastruct/ptrheap.c line 81
static void heapify(struct ptrlist_struct *elems, unsigned long int i, unsigned long int N, signed int (*compar)(void *, const void *, const void *), void (*setreccookie)(void *, void *, unsigned long int), void *cookie)
{
  unsigned long int min;
  void **return_value_ptrlist_get_1;
  void **return_value_ptrlist_get_2;
  signed int return_value;
  void **return_value_ptrlist_get_3;
  void **return_value_ptrlist_get_4;
  signed int return_value_1;
  do
  {
    min = i;
    if(!(2ul * i + 1ul >= N))
    {
      return_value_ptrlist_get_1=ptrlist_get(elems, min);
      return_value_ptrlist_get_2=ptrlist_get(elems, (unsigned long int)2 * i + (unsigned long int)1);
      return_value=compar(cookie, *return_value_ptrlist_get_1, *return_value_ptrlist_get_2);
      if(return_value >= 1)
        min = (unsigned long int)2 * i + (unsigned long int)1;

    }

    if(!(2ul * i + 2ul >= N))
    {
      return_value_ptrlist_get_3=ptrlist_get(elems, min);
      return_value_ptrlist_get_4=ptrlist_get(elems, (unsigned long int)2 * i + (unsigned long int)2);
      return_value_1=compar(cookie, *return_value_ptrlist_get_3, *return_value_ptrlist_get_4);
      if(return_value_1 >= 1)
        min = (unsigned long int)2 * i + (unsigned long int)2;

    }

    if(min == i)
      break;

    swap(elems, min, i, setreccookie, cookie);
    i = min;
  }
  while((_Bool)1);
}

// heapifyup
// file ../libcperciva/datastruct/ptrheap.c line 49
static void heapifyup(struct ptrlist_struct *elems, unsigned long int i, signed int (*compar)(void *, const void *, const void *), void (*setreccookie)(void *, void *, unsigned long int), void *cookie)
{
  if(!(i == 0ul))
  {
    void **return_value_ptrlist_get_1;
    return_value_ptrlist_get_1=ptrlist_get(elems, i);
    void **return_value_ptrlist_get_2;
    return_value_ptrlist_get_2=ptrlist_get(elems, (i - (unsigned long int)1) / (unsigned long int)2);
    signed int return_value;
    return_value=compar(cookie, *return_value_ptrlist_get_1, *return_value_ptrlist_get_2);
    if(!(return_value >= 0))
    {
      swap(elems, i, (i - (unsigned long int)1) / (unsigned long int)2, setreccookie, cookie);
      i = (i - (unsigned long int)1) / (unsigned long int)2;
    }

  }

}

// imalloc
// file ../libcperciva/util/imalloc.h line 13
static inline void * imalloc(unsigned long int nrec, unsigned long int reclen)
{
  if(!(18446744073709551615UL / reclen >= nrec))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 12;
    return (void *)0;
  }

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(nrec * reclen);
    return return_value_malloc_2;
  }
}

// initsocketlist
// file ../libcperciva/events/events_network.c line 34
static signed int initsocketlist(void)
{
  if(S == ((struct socketlist_struct *)NULL))
  {
    S=socketlist_init((unsigned long int)0);
    if(S == ((struct socketlist_struct *)NULL))
      goto err0;

    nev = (unsigned long int)0;
    fdscanpos = (unsigned long int)1024;
  }


done:
  ;
  return 0;

err0:
  ;
  return -1;
}

// insecure_memzero
// file ../libcperciva/util/insecure_memzero.h line 27
static inline void insecure_memzero(volatile void *buf, unsigned long int len)
{
  insecure_memzero_ptr(buf, len);
}

// insecure_memzero_link1
// file ../libcperciva/util/insecure_memzero.h line 27
static inline void insecure_memzero_link1(volatile void *buf_link1, unsigned long int len_link1)
{
  insecure_memzero_ptr(buf_link1, len_link1);
}

// insecure_memzero_link2
// file ../libcperciva/util/insecure_memzero.h line 27
static inline void insecure_memzero_link2(volatile void *buf_link2, unsigned long int len_link2)
{
  insecure_memzero_ptr(buf_link2, len_link2);
}

// insecure_memzero_link3
// file ../libcperciva/util/insecure_memzero.h line 27
static inline void insecure_memzero_link3(volatile void *buf_link3, unsigned long int len_link3)
{
  insecure_memzero_ptr(buf_link3, len_link3);
}

// insecure_memzero_func
// file ../libcperciva/util/insecure_memzero.c line 8
static void insecure_memzero_func(volatile void *buf, unsigned long int len)
{
  volatile unsigned char *_buf = (volatile unsigned char *)buf;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= len); i = i + 1ul)
    _buf[(signed long int)i] = (volatile unsigned char)0;
}

// instantiate
// file ../libcperciva/crypto/crypto_entropy.c line 45
static signed int instantiate(void)
{
  unsigned char seed_material[48l];
  signed int return_value_entropy_read_1;
  return_value_entropy_read_1=entropy_read(seed_material, (unsigned long int)48);
  if(!(return_value_entropy_read_1 == 0))
    return -1;

  else
  {
    memset((void *)drbg.Key, 0x00, (unsigned long int)32);
    memset((void *)drbg.V, 0x01, (unsigned long int)32);
    drbg.reseed_counter = (unsigned int)1;
    update(seed_material, (unsigned long int)48);
    insecure_memzero_link3((volatile void *)seed_material, (unsigned long int)48);
    return 0;
  }
}

// is_not_one
// file ../proto/proto_crypt.c line 157
static signed int is_not_one(const unsigned char *x, unsigned long int len)
{
  unsigned long int i;
  char y;
  i = (unsigned long int)0;
  y = (char)0;
  for( ; !(i >= len + 18446744073709551615ul); i = i + 1ul)
    y = y | (char)x[(signed long int)i];
  return (signed int)y | (signed int)x[(signed long int)(len - (unsigned long int)1)] - 1;
}

// launchpipes
// file ../proto/proto_conn.c line 76
static signed int launchpipes(struct conn_state *C)
{
  signed int on = C->nokeepalive != 0 ? 0 : 1;
  setsockopt(C->s, 1, 9, (const void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
  setsockopt(C->t, 1, 9, (const void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
  C->pipe_f=proto_pipe(C->s, C->t, C->decr, C->k_f, &C->stat_f, callback_pipestatus, (void *)C);
  if(!(C->pipe_f == NULL))
  {
    C->pipe_r=proto_pipe(C->t, C->s, (signed int)!(C->decr != 0), C->k_r, &C->stat_r, callback_pipestatus, (void *)C);
    if(C->pipe_r == NULL)
      goto err0;

    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// libcperciva_HMAC_SHA256_Buf
// file ../libcperciva/alg/sha256.h line 85
void libcperciva_HMAC_SHA256_Buf(const void *K, unsigned long int Klen, const void *in, unsigned long int len, unsigned char *digest)
{
  struct anonymous_2 ctx;
  libcperciva_HMAC_SHA256_Init(&ctx, K, Klen);
  libcperciva_HMAC_SHA256_Update(&ctx, in, len);
  libcperciva_HMAC_SHA256_Final(digest, &ctx);
}

// libcperciva_HMAC_SHA256_Final
// file ../libcperciva/alg/sha256.h line 78
void libcperciva_HMAC_SHA256_Final(unsigned char *digest, struct anonymous_2 *ctx)
{
  unsigned char ihash[32l];
  libcperciva_SHA256_Final(ihash, &ctx->ictx);
  libcperciva_SHA256_Update(&ctx->octx, (const void *)ihash, (unsigned long int)32);
  libcperciva_SHA256_Final(digest, &ctx->octx);
  insecure_memzero((volatile void *)ihash, (unsigned long int)32);
}

// libcperciva_HMAC_SHA256_Init
// file ../libcperciva/alg/sha256.h line 65
void libcperciva_HMAC_SHA256_Init(struct anonymous_2 *ctx, const void *_K, unsigned long int Klen)
{
  unsigned char pad[64l];
  unsigned char khash[32l];
  const unsigned char *K = (const unsigned char *)_K;
  unsigned long int i;
  if(Klen >= 65ul)
  {
    libcperciva_SHA256_Init(&ctx->ictx);
    libcperciva_SHA256_Update(&ctx->ictx, (const void *)K, Klen);
    libcperciva_SHA256_Final(khash, &ctx->ictx);
    K = khash;
    Klen = (unsigned long int)32;
  }

  libcperciva_SHA256_Init(&ctx->ictx);
  memset((void *)pad, 0x36, (unsigned long int)64);
  i = (unsigned long int)0;
  for( ; !(i >= Klen); i = i + 1ul)
    pad[(signed long int)i] = pad[(signed long int)i] ^ K[(signed long int)i];
  libcperciva_SHA256_Update(&ctx->ictx, (const void *)pad, (unsigned long int)64);
  libcperciva_SHA256_Init(&ctx->octx);
  memset((void *)pad, 0x5c, (unsigned long int)64);
  i = (unsigned long int)0;
  for( ; !(i >= Klen); i = i + 1ul)
    pad[(signed long int)i] = pad[(signed long int)i] ^ K[(signed long int)i];
  libcperciva_SHA256_Update(&ctx->octx, (const void *)pad, (unsigned long int)64);
  insecure_memzero((volatile void *)khash, (unsigned long int)32);
  insecure_memzero((volatile void *)pad, (unsigned long int)64);
}

// libcperciva_HMAC_SHA256_Update
// file ../libcperciva/alg/sha256.h line 71
void libcperciva_HMAC_SHA256_Update(struct anonymous_2 *ctx, const void *in, unsigned long int len)
{
  libcperciva_SHA256_Update(&ctx->ictx, in, len);
}

// libcperciva_SHA256_Buf
// file ../libcperciva/alg/sha256.c line 283
void libcperciva_SHA256_Buf(const void *in, unsigned long int len, unsigned char *digest)
{
  struct anonymous_5 ctx;
  libcperciva_SHA256_Init(&ctx);
  libcperciva_SHA256_Update(&ctx, in, len);
  libcperciva_SHA256_Final(digest, &ctx);
}

// libcperciva_SHA256_Final
// file ../libcperciva/alg/sha256.h line 46
void libcperciva_SHA256_Final(unsigned char *digest, struct anonymous_5 *ctx)
{
  SHA256_Pad(ctx);
  be32enc_vect(digest, ctx->state, (unsigned long int)32);
  insecure_memzero((volatile void *)ctx, sizeof(struct anonymous_5) /*104ul*/ );
}

// libcperciva_SHA256_Init
// file ../libcperciva/alg/sha256.h line 33
void libcperciva_SHA256_Init(struct anonymous_5 *ctx)
{
  ctx->count = (unsigned long int)0;
  memcpy((void *)ctx->state, (const void *)initstate, sizeof(const unsigned int [8l]) /*32ul*/ );
}

// libcperciva_SHA256_Update
// file ../libcperciva/alg/sha256.h line 39
void libcperciva_SHA256_Update(struct anonymous_5 *ctx, const void *in, unsigned long int len)
{
  unsigned int r;
  const unsigned char *src = (const unsigned char *)in;
  if(!(len == 0ul))
  {
    r = (unsigned int)(ctx->count >> 3 & (unsigned long int)0x3f);
    ctx->count = ctx->count + ((unsigned long int)len << 3);
    if(!(len >= (unsigned long int)(64u + -r)))
      memcpy((void *)&ctx->buf[(signed long int)r], (const void *)src, len);

    else
    {
      memcpy((void *)&ctx->buf[(signed long int)r], (const void *)src, (unsigned long int)((unsigned int)64 - r));
      SHA256_Transform(ctx->state, ctx->buf);
      src = src + (signed long int)((unsigned int)64 - r);
      len = len - (unsigned long int)((unsigned int)64 - r);
      for( ; len >= 64ul; len = len - (unsigned long int)64)
      {
        SHA256_Transform(ctx->state, src);
        src = src + (signed long int)64;
      }
      memcpy((void *)ctx->buf, (const void *)src, len);
    }
  }

}

// libcperciva_asprintf
// file ../libcperciva/util/asprintf.h line 14
signed int libcperciva_asprintf(char **ret, const char *format, ...)
{
  void **ap;
  signed int len;
  unsigned long int buflen;
  ap = (void **)&format;
  len=vsnprintf((char *)(void *)0, (unsigned long int)0, format, ap);
  ap = ((void **)NULL);
  void *return_value_malloc_1;
  if(len >= 0)
  {
    buflen = (unsigned long int)len + (unsigned long int)1;
    return_value_malloc_1=malloc(buflen);
    *ret = (char *)return_value_malloc_1;
    if(!(*ret == ((char *)NULL)))
    {
      ap = (void **)&format;
      len=vsnprintf(*ret, buflen, format, ap);
      ap = ((void **)NULL);
      if(len >= 0)
        return len;


    err1:
      ;
      free((void *)*ret);
    }

  }


err0:
  ;
  return -1;
}

// libcperciva_be32dec
// file ../libcperciva/util/sysendian.h line 38
static inline unsigned int libcperciva_be32dec(const void *pp)
{
  const unsigned char *p = (const unsigned char *)pp;
  return (unsigned int)p[(signed long int)3] + ((unsigned int)p[(signed long int)2] << 8) + ((unsigned int)p[(signed long int)1] << 16) + ((unsigned int)p[(signed long int)0] << 24);
}

// libcperciva_be32dec_link1
// file ../libcperciva/util/sysendian.h line 38
static inline unsigned int libcperciva_be32dec_link1(const void *pp_link1)
{
  const unsigned char *p_link1 = (const unsigned char *)pp_link1;
  return (unsigned int)p_link1[(signed long int)3] + ((unsigned int)p_link1[(signed long int)2] << 8) + ((unsigned int)p_link1[(signed long int)1] << 16) + ((unsigned int)p_link1[(signed long int)0] << 24);
}

// libcperciva_be32enc
// file ../libcperciva/util/sysendian.h line 47
static inline void libcperciva_be32enc(void *pp, unsigned int x)
{
  unsigned char *p = (unsigned char *)pp;
  p[(signed long int)3] = (unsigned char)(x & (unsigned int)0xff);
  p[(signed long int)2] = (unsigned char)(x >> 8 & (unsigned int)0xff);
  p[(signed long int)1] = (unsigned char)(x >> 16 & (unsigned int)0xff);
  p[(signed long int)0] = (unsigned char)(x >> 24 & (unsigned int)0xff);
}

// libcperciva_be32enc_link1
// file ../libcperciva/util/sysendian.h line 47
static inline void libcperciva_be32enc_link1(void *pp_link1, unsigned int x_link1)
{
  unsigned char *p_link1 = (unsigned char *)pp_link1;
  p_link1[(signed long int)3] = (unsigned char)(x_link1 & (unsigned int)0xff);
  p_link1[(signed long int)2] = (unsigned char)(x_link1 >> 8 & (unsigned int)0xff);
  p_link1[(signed long int)1] = (unsigned char)(x_link1 >> 16 & (unsigned int)0xff);
  p_link1[(signed long int)0] = (unsigned char)(x_link1 >> 24 & (unsigned int)0xff);
}

// libcperciva_be64enc
// file ../libcperciva/util/sysendian.h line 69
static inline void libcperciva_be64enc(void *pp, unsigned long int x)
{
  unsigned char *p = (unsigned char *)pp;
  p[(signed long int)7] = (unsigned char)(x & (unsigned long int)0xff);
  p[(signed long int)6] = (unsigned char)(x >> 8 & (unsigned long int)0xff);
  p[(signed long int)5] = (unsigned char)(x >> 16 & (unsigned long int)0xff);
  p[(signed long int)4] = (unsigned char)(x >> 24 & (unsigned long int)0xff);
  p[(signed long int)3] = (unsigned char)(x >> 32 & (unsigned long int)0xff);
  p[(signed long int)2] = (unsigned char)(x >> 40 & (unsigned long int)0xff);
  p[(signed long int)1] = (unsigned char)(x >> 48 & (unsigned long int)0xff);
  p[(signed long int)0] = (unsigned char)(x >> 56 & (unsigned long int)0xff);
}

// libcperciva_be64enc_link1
// file ../libcperciva/util/sysendian.h line 69
static inline void libcperciva_be64enc_link1(void *pp_link1, unsigned long int x_link1)
{
  unsigned char *p_link1 = (unsigned char *)pp_link1;
  p_link1[(signed long int)7] = (unsigned char)(x_link1 & (unsigned long int)0xff);
  p_link1[(signed long int)6] = (unsigned char)(x_link1 >> 8 & (unsigned long int)0xff);
  p_link1[(signed long int)5] = (unsigned char)(x_link1 >> 16 & (unsigned long int)0xff);
  p_link1[(signed long int)4] = (unsigned char)(x_link1 >> 24 & (unsigned long int)0xff);
  p_link1[(signed long int)3] = (unsigned char)(x_link1 >> 32 & (unsigned long int)0xff);
  p_link1[(signed long int)2] = (unsigned char)(x_link1 >> 40 & (unsigned long int)0xff);
  p_link1[(signed long int)1] = (unsigned char)(x_link1 >> 48 & (unsigned long int)0xff);
  p_link1[(signed long int)0] = (unsigned char)(x_link1 >> 56 & (unsigned long int)0xff);
}

// libcperciva_be64enc_link2
// file ../libcperciva/util/sysendian.h line 69
static inline void libcperciva_be64enc_link2(void *pp_link2, unsigned long int x_link2)
{
  unsigned char *p_link2 = (unsigned char *)pp_link2;
  p_link2[(signed long int)7] = (unsigned char)(x_link2 & (unsigned long int)0xff);
  p_link2[(signed long int)6] = (unsigned char)(x_link2 >> 8 & (unsigned long int)0xff);
  p_link2[(signed long int)5] = (unsigned char)(x_link2 >> 16 & (unsigned long int)0xff);
  p_link2[(signed long int)4] = (unsigned char)(x_link2 >> 24 & (unsigned long int)0xff);
  p_link2[(signed long int)3] = (unsigned char)(x_link2 >> 32 & (unsigned long int)0xff);
  p_link2[(signed long int)2] = (unsigned char)(x_link2 >> 40 & (unsigned long int)0xff);
  p_link2[(signed long int)1] = (unsigned char)(x_link2 >> 48 & (unsigned long int)0xff);
  p_link2[(signed long int)0] = (unsigned char)(x_link2 >> 56 & (unsigned long int)0xff);
}

// libcperciva_warn
// file ../libcperciva/util/warnp.h line 21
void libcperciva_warn(const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  fprintf(stderr, "%s", name != (char *)(void *)0 ? name : "(unknown)");
  if(!(fmt == ((const char *)NULL)))
  {
    fprintf(stderr, ": ");
    vfprintf(stderr, fmt, ap);
  }

  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  char *return_value_strerror_2;
  return_value_strerror_2=strerror(*return_value___errno_location_1);
  fprintf(stderr, ": %s\n", return_value_strerror_2);
  ap = ((void **)NULL);
}

// libcperciva_warnx
// file ../libcperciva/util/warnp.h line 22
void libcperciva_warnx(const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  fprintf(stderr, "%s", name != (char *)(void *)0 ? name : "(unknown)");
  if(!(fmt == ((const char *)NULL)))
  {
    fprintf(stderr, ": ");
    vfprintf(stderr, fmt, ap);
  }

  fprintf(stderr, "\n");
  ap = ((void **)NULL);
}

// main
// file main.c line 35
signed int main(signed int argc, char **argv)
{
  signed int opt_d = 0;
  signed int opt_D = 0;
  signed int opt_e = 0;
  signed int opt_f = 0;
  signed int opt_g = 0;
  signed int opt_F = 0;
  signed int opt_j = 0;
  const char *opt_k = (const char *)(void *)0;
  signed long int opt_n = (signed long int)0;
  double opt_o = 0.0;
  char *opt_p = (char *)(void *)0;
  double opt_r = 0.0;
  signed int opt_R = 0;
  const char *opt_s = (const char *)(void *)0;
  const char *opt_t = (const char *)(void *)0;
  struct sock_addr **sas_s;
  struct sock_addr **sas_t;
  struct proto_secret *K;
  signed int ch;
  signed int s;
  do
    if(!(*argv == ((char *)NULL)))
      warnp_setprogname(argv[(signed long int)0]);

  while((_Bool)0);
  do
  {
    ch=getopt(argc, argv, "dDefFgjk:n:o:r:Rp:s:t:");
    if(ch == -1)
      break;

    switch(ch)
    {
      case 100:
      {
        if(!(opt_d == 0) || !(opt_e == 0))
          usage();

        opt_d = 1;
        break;
      }
      case 68:
      {
        if(!(opt_D == 0))
          usage();

        opt_D = 1;
        break;
      }
      case 101:
      {
        if(!(opt_d == 0) || !(opt_e == 0))
          usage();

        opt_e = 1;
        break;
      }
      case 102:
      {
        if(!(opt_f == 0))
          usage();

        opt_f = 1;
        break;
      }
      case 70:
      {
        if(!(opt_F == 0))
          usage();

        opt_F = 1;
        break;
      }
      case 103:
      {
        if(!(opt_g == 0))
          usage();

        opt_g = 1;
        break;
      }
      case 106:
      {
        if(!(opt_j == 0))
          usage();

        opt_j = 1;
        break;
      }
      case 107:
      {
        if(!(opt_k == ((const char *)NULL)))
          usage();

        opt_k = optarg;
        break;
      }
      case 110:
      {
        if(!(opt_n == 0l))
          usage();

        opt_n=strtoimax(optarg, (char ** restrict )(void *)0, 0);
        if(opt_n == 0l)
        {
          do
          {
            libcperciva_warnx("Invalid option: -n %s", optarg);
            signed int *return_value___errno_location_1;
            return_value___errno_location_1=__errno_location();
            *return_value___errno_location_1 = 0;
          }
          while((_Bool)0);
          exit(1);
        }

        if(opt_n >= 501l || !(opt_n >= 1l))
        {
          do
          {
            libcperciva_warnx("The parameter to -n must be between 1 and 500\n");
            signed int *return_value___errno_location_2;
            return_value___errno_location_2=__errno_location();
            *return_value___errno_location_2 = 0;
          }
          while((_Bool)0);
          exit(1);
        }

        break;
      }
      case 111:
      {
        if(IEEE_FLOAT_NOTEQUAL(opt_o, 0.0))
          usage();

        opt_o=strtod(optarg, (char ** restrict )(void *)0);
        if(IEEE_FLOAT_EQUAL(opt_o, 0.0))
        {
          do
          {
            libcperciva_warnx("Invalid option: -o %s", optarg);
            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            *return_value___errno_location_3 = 0;
          }
          while((_Bool)0);
          exit(1);
        }

        break;
      }
      case 112:
      {
        if(!(opt_p == ((char *)NULL)))
          usage();

        opt_p=strdup(optarg);
        if(opt_p == ((char *)NULL))
          do
          {

          __CPROVER_DUMP_L32:
            ;
            signed int *return_value___errno_location_5;
            return_value___errno_location_5=__errno_location();
            if(!(*return_value___errno_location_5 == 0))
            {
              libcperciva_warn("Error parsing argument: -%c %s", ch, optarg);
              signed int *return_value___errno_location_4;
              return_value___errno_location_4=__errno_location();
              *return_value___errno_location_4 = 0;
            }

            else
              libcperciva_warnx("Error parsing argument: -%c %s", ch, optarg);
            exit(1);
          }
          while((_Bool)0);

        break;
      }
      case 114:
      {
        if(IEEE_FLOAT_NOTEQUAL(opt_r, 0.0))
          usage();

        opt_r=strtod(optarg, (char ** restrict )(void *)0);
        if(IEEE_FLOAT_EQUAL(opt_r, 0.0))
        {
          do
          {
            libcperciva_warnx("Invalid option: -r %s", optarg);
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            *return_value___errno_location_6 = 0;
          }
          while((_Bool)0);
          exit(1);
        }

        break;
      }
      case 82:
      {
        if(!(opt_R == 0))
          usage();

        opt_R = 1;
        break;
      }
      case 115:
      {
        if(!(opt_s == ((const char *)NULL)))
          usage();

        opt_s = optarg;
        break;
      }
      case 116:
      {
        if(!(opt_t == ((const char *)NULL)))
          usage();

        opt_t = optarg;
        break;
      }
      default:
        usage();
    }
  }
  while((_Bool)1);
  if(!(argc == optind))
    usage();

  if(opt_n == 0l)
    opt_n = (signed long int)100;

  if(IEEE_FLOAT_EQUAL(opt_o, 0.0))
    opt_o = 5.0;

  if(IEEE_FLOAT_EQUAL(opt_r, 0.0))
    opt_r = 60.0;

  if(opt_d == 0 && opt_e == 0)
    usage();

  if(!(opt_f == 0) && !(opt_g == 0))
    usage();

  if(opt_k == ((const char *)NULL))
    usage();

  if(!(opt_o > 0.0))
    usage();

  if(IEEE_FLOAT_NOTEQUAL(opt_r, 60.0) && !(opt_R == 0))
    usage();

  if(opt_s == ((const char *)NULL))
    usage();

  if(opt_t == ((const char *)NULL))
    usage();

  if(opt_p == ((char *)NULL))
  {
    signed int return_value_libcperciva_asprintf_9;
    return_value_libcperciva_asprintf_9=libcperciva_asprintf(&opt_p, "%s.pid", opt_s);
    if(return_value_libcperciva_asprintf_9 == -1)
    {
      do
      {
        signed int *return_value___errno_location_8;
        return_value___errno_location_8=__errno_location();
        if(!(*return_value___errno_location_8 == 0))
        {
          libcperciva_warn("asprintf");
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          *return_value___errno_location_7 = 0;
        }

        else
          libcperciva_warnx("asprintf");
      }
      while((_Bool)0);
      exit(1);
    }

  }

  signed int return_value_daemonize_12;
  if(opt_F == 0 && !(opt_D == 0))
  {
    return_value_daemonize_12=daemonize(opt_p);
    if(!(return_value_daemonize_12 == 0))
    {
      do
      {
        signed int *return_value___errno_location_11;
        return_value___errno_location_11=__errno_location();
        if(!(*return_value___errno_location_11 == 0))
        {
          libcperciva_warn("Failed to daemonize");
          signed int *return_value___errno_location_10;
          return_value___errno_location_10=__errno_location();
          *return_value___errno_location_10 = 0;
        }

        else
          libcperciva_warnx("Failed to daemonize");
      }
      while((_Bool)0);
      exit(1);
    }

  }

  do
  {
    sas_s=sock_resolve(opt_s);
    if(!(sas_s == ((struct sock_addr **)NULL)))
      break;

    if(opt_D == 0)
    {
      do
      {
        signed int *return_value___errno_location_14;
        return_value___errno_location_14=__errno_location();
        if(!(*return_value___errno_location_14 == 0))
        {
          libcperciva_warn("Error resolving socket address: %s", opt_s);
          signed int *return_value___errno_location_13;
          return_value___errno_location_13=__errno_location();
          *return_value___errno_location_13 = 0;
        }

        else
          libcperciva_warnx("Error resolving socket address: %s", opt_s);
      }
      while((_Bool)0);
      exit(1);
    }

    sleep((unsigned int)1);
  }
  while((_Bool)1);
  if(*sas_s == ((struct sock_addr *)NULL))
  {
    do
    {
      libcperciva_warnx("No addresses found for %s", opt_s);
      signed int *return_value___errno_location_15;
      return_value___errno_location_15=__errno_location();
      *return_value___errno_location_15 = 0;
    }
    while((_Bool)0);
    exit(1);
  }

  do
  {
    sas_t=sock_resolve(opt_t);
    if(!(sas_t == ((struct sock_addr **)NULL)))
      break;

    if(opt_D == 0)
    {
      do
      {
        signed int *return_value___errno_location_17;
        return_value___errno_location_17=__errno_location();
        if(!(*return_value___errno_location_17 == 0))
        {
          libcperciva_warn("Error resolving socket address: %s", opt_t);
          signed int *return_value___errno_location_16;
          return_value___errno_location_16=__errno_location();
          *return_value___errno_location_16 = 0;
        }

        else
          libcperciva_warnx("Error resolving socket address: %s", opt_t);
      }
      while((_Bool)0);
      exit(1);
    }

    sleep((unsigned int)1);
  }
  while((_Bool)1);
  if(*sas_t == ((struct sock_addr *)NULL))
  {
    do
    {
      libcperciva_warnx("No addresses found for %s", opt_t);
      signed int *return_value___errno_location_18;
      return_value___errno_location_18=__errno_location();
      *return_value___errno_location_18 = 0;
    }
    while((_Bool)0);
    exit(1);
  }

  K=proto_crypt_secret(opt_k);
  if(K == ((struct proto_secret *)NULL))
  {
    do
    {
      signed int *return_value___errno_location_20;
      return_value___errno_location_20=__errno_location();
      if(!(*return_value___errno_location_20 == 0))
      {
        libcperciva_warn("Error reading shared secret");
        signed int *return_value___errno_location_19;
        return_value___errno_location_19=__errno_location();
        *return_value___errno_location_19 = 0;
      }

      else
        libcperciva_warnx("Error reading shared secret");
    }
    while((_Bool)0);
    exit(1);
  }

  if(!(sas_s[1l] == ((struct sock_addr *)NULL)))
    do
    {
      libcperciva_warnx("Listening on first of multiple addresses found for %s", opt_s);
      signed int *return_value___errno_location_21;
      return_value___errno_location_21=__errno_location();
      *return_value___errno_location_21 = 0;
    }
    while((_Bool)0);

  s=sock_listener(sas_s[(signed long int)0]);
  if(s == -1)
    exit(1);

  signed int return_value_daemonize_24;
  if(opt_F == 0)
  {
    return_value_daemonize_24=daemonize(opt_p);
    if(!(return_value_daemonize_24 == 0))
    {
      do
      {
        signed int *return_value___errno_location_23;
        return_value___errno_location_23=__errno_location();
        if(!(*return_value___errno_location_23 == 0))
        {
          libcperciva_warn("Failed to daemonize");
          signed int *return_value___errno_location_22;
          return_value___errno_location_22=__errno_location();
          *return_value___errno_location_22 = 0;
        }

        else
          libcperciva_warnx("Failed to daemonize");
      }
      while((_Bool)0);
      exit(1);
    }

  }

  signed int return_value_dispatch_accept_27;
  return_value_dispatch_accept_27=dispatch_accept(s, opt_t, opt_R != 0 ? 0.0 : opt_r, sas_t, opt_d, opt_f, opt_g, opt_j, K, (unsigned long int)opt_n, opt_o);
  if(!(return_value_dispatch_accept_27 == 0))
  {
    do
    {
      signed int *return_value___errno_location_26;
      return_value___errno_location_26=__errno_location();
      if(!(*return_value___errno_location_26 == 0))
      {
        libcperciva_warn("Failed to initialize connection acceptor");
        signed int *return_value___errno_location_25;
        return_value___errno_location_25=__errno_location();
        *return_value___errno_location_25 = 0;
      }

      else
        libcperciva_warnx("Failed to initialize connection acceptor");
    }
    while((_Bool)0);
    exit(1);
  }

  do
  {
    signed int return_value_events_run_30;
    return_value_events_run_30=events_run();
    if(!(return_value_events_run_30 == 0))
    {
      do
      {
        signed int *return_value___errno_location_29;
        return_value___errno_location_29=__errno_location();
        if(!(*return_value___errno_location_29 == 0))
        {
          libcperciva_warn("Error running event loop");
          signed int *return_value___errno_location_28;
          return_value___errno_location_28=__errno_location();
          *return_value___errno_location_28 = 0;
        }

        else
          libcperciva_warnx("Error running event loop");
      }
      while((_Bool)0);
      exit(1);
    }

  }
  while((_Bool)1);
}

// mkkeypair
// file ../proto/proto_crypt.c line 31
static struct proto_keys * mkkeypair(unsigned char *kbuf)
{
  struct proto_keys *k;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct proto_keys) /*48ul*/ );
  k = (struct proto_keys *)return_value_malloc_1;
  if(!(k == ((struct proto_keys *)NULL)))
  {
    k->k_aes=crypto_aes_key_expand(&kbuf[(signed long int)0], (unsigned long int)32);
    if(!(k->k_aes == ((struct crypto_aes_key *)NULL)))
    {
      memcpy((void *)k->k_hmac, (const void *)&kbuf[(signed long int)32], (unsigned long int)32);
      k->pnum = (unsigned long int)0;
      return k;
    }


  err1:
    ;
    free((void *)k);
  }


err0:
  ;
  return (struct proto_keys *)(void *)0;
}

// monoclock_get
// file ../libcperciva/util/monoclock.c line 16
signed int monoclock_get(struct timeval *tv)
{
  struct timespec tp;
  signed int return_value_clock_gettime_9;
  return_value_clock_gettime_9=clock_gettime(1, &tp);
  signed int *return_value___errno_location_6;
  _Bool tmp_if_expr_8;
  signed int *return_value___errno_location_7;
  signed int return_value_clock_gettime_5;
  if(return_value_clock_gettime_9 == 0)
  {
    tv->tv_sec = tp.tv_sec;
    tv->tv_usec = tp.tv_nsec / (signed long int)1000;
  }

  else
  {
    return_value___errno_location_6=__errno_location();
    if(!(*return_value___errno_location_6 == 38))
    {
      return_value___errno_location_7=__errno_location();
      tmp_if_expr_8 = *return_value___errno_location_7 != 22 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    if(tmp_if_expr_8)
    {
      do
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        if(!(*return_value___errno_location_2 == 0))
        {
          libcperciva_warn("clock_gettime(CLOCK_MONOTONIC)");
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          *return_value___errno_location_1 = 0;
        }

        else
          libcperciva_warnx("clock_gettime(CLOCK_MONOTONIC)");
      }
      while((_Bool)0);
      goto err0;
    }

    else
    {
      return_value_clock_gettime_5=clock_gettime(0, &tp);
      if(return_value_clock_gettime_5 == 0)
      {
        tv->tv_sec = tp.tv_sec;
        tv->tv_usec = tp.tv_nsec / (signed long int)1000;
      }

      else
      {
        do
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          if(!(*return_value___errno_location_4 == 0))
          {
            libcperciva_warn("clock_gettime(CLOCK_REALTIME)");
            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            *return_value___errno_location_3 = 0;
          }

          else
            libcperciva_warnx("clock_gettime(CLOCK_REALTIME)");
        }
        while((_Bool)0);
        goto err0;
      }
    }
  }
  return 0;

err0:
  ;
  return -1;
}

// mpool_eventq_atexit
// file ../libcperciva/events/events_immediate.c line 17
static void mpool_eventq_atexit(void)
{
  void *top;
  do
  {
    top = mpool_eventq_rec.top;
    if(top == NULL)
      break;

    mpool_eventq_rec.top = *((void **)top);
    free(top);
  }
  while((_Bool)1);
}

// mpool_eventq_free
// file ../libcperciva/events/events_immediate.c line 17
static inline void mpool_eventq_free(struct eventq *p)
{
  if(!(p == ((struct eventq *)NULL)))
  {
    if(!(mpool_eventq_rec.stacklen >= 4096ul))
    {
      *((void **)p) = mpool_eventq_rec.top;
      mpool_eventq_rec.top = (void *)p;
      mpool_eventq_rec.stacklen = mpool_eventq_rec.stacklen + (unsigned long int)1;
    }

    else
      free((void *)p);
  }

}

// mpool_eventq_malloc
// file ../libcperciva/events/events_immediate.c line 17
static inline struct eventq * mpool_eventq_malloc(void)
{
  struct eventq *p;
  if(!(mpool_eventq_rec.stacklen == 0ul))
  {
    p = (struct eventq *)mpool_eventq_rec.top;
    mpool_eventq_rec.top = *((void **)p);
    mpool_eventq_rec.stacklen = mpool_eventq_rec.stacklen - (unsigned long int)1;
  }

  else
  {
    if(mpool_eventq_rec.atexit_set == 0)
    {
      atexit(mpool_eventq_atexit);
      mpool_eventq_rec.atexit_set = 1;
    }

    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct eventq) /*32ul*/  > sizeof(void *) /*8ul*/  ? sizeof(struct eventq) /*32ul*/  : sizeof(void *) /*8ul*/ );
    p = (struct eventq *)return_value_malloc_1;
  }
  return p;
}

// mpool_eventrec_atexit
// file ../libcperciva/events/events.c line 17
static void mpool_eventrec_atexit(void)
{
  void *top;
  do
  {
    top = mpool_eventrec_rec.top;
    if(top == NULL)
      break;

    mpool_eventrec_rec.top = *((void **)top);
    free(top);
  }
  while((_Bool)1);
}

// mpool_eventrec_free
// file ../libcperciva/events/events.c line 17
static inline void mpool_eventrec_free(struct eventrec *p)
{
  if(!(p == ((struct eventrec *)NULL)))
  {
    if(!(mpool_eventrec_rec.stacklen >= 4096ul))
    {
      *((void **)p) = mpool_eventrec_rec.top;
      mpool_eventrec_rec.top = (void *)p;
      mpool_eventrec_rec.stacklen = mpool_eventrec_rec.stacklen + (unsigned long int)1;
    }

    else
      free((void *)p);
  }

}

// mpool_eventrec_malloc
// file ../libcperciva/events/events.c line 17
static inline struct eventrec * mpool_eventrec_malloc(void)
{
  struct eventrec *p;
  if(!(mpool_eventrec_rec.stacklen == 0ul))
  {
    p = (struct eventrec *)mpool_eventrec_rec.top;
    mpool_eventrec_rec.top = *((void **)p);
    mpool_eventrec_rec.stacklen = mpool_eventrec_rec.stacklen - (unsigned long int)1;
  }

  else
  {
    if(mpool_eventrec_rec.atexit_set == 0)
    {
      atexit(mpool_eventrec_atexit);
      mpool_eventrec_rec.atexit_set = 1;
    }

    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct eventrec) /*16ul*/  > sizeof(void *) /*8ul*/  ? sizeof(struct eventrec) /*16ul*/  : sizeof(void *) /*8ul*/ );
    p = (struct eventrec *)return_value_malloc_1;
  }
  return p;
}

// network_accept
// file ../libcperciva/network/network.h line 21
void * network_accept(signed int fd, signed int (*callback)(void *, signed int), void *cookie)
{
  struct accept_cookie *C;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct accept_cookie) /*24ul*/ );
  C = (struct accept_cookie *)return_value_malloc_1;
  signed int return_value_events_network_register_2;
  if(!(C == ((struct accept_cookie *)NULL)))
  {
    C->callback = callback;
    C->cookie = cookie;
    C->fd = fd;
    return_value_events_network_register_2=events_network_register(callback_accept, (void *)C, C->fd, 0);
    if(return_value_events_network_register_2 == 0)
      return (void *)C;


  err1:
    ;
    free((void *)C);
  }


err0:
  ;
  return (void *)0;
}

// network_accept_cancel
// file ../libcperciva/network/network_accept.c line 94
void network_accept_cancel(void *cookie)
{
  struct accept_cookie *C = (struct accept_cookie *)cookie;
  events_network_cancel(C->fd, 0);
  free((void *)C);
}

// network_connect
// file ../libcperciva/network/network.h line 39
void * network_connect(struct sock_addr * const *sas, signed int (*callback)(void *, signed int), void *cookie)
{
  void *return_value_network_connect_timeo_1;
  return_value_network_connect_timeo_1=network_connect_timeo(sas, (struct timeval *)(void *)0, callback, cookie);
  return return_value_network_connect_timeo_1;
}

// network_connect_cancel
// file ../libcperciva/network/network.h line 55
void network_connect_cancel(void *cookie)
{
  struct connect_cookie *C = (struct connect_cookie *)cookie;
  _Bool tmp_if_expr_1;
  if(!(C->cookie_immediate == NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = C->s != -1 ? (_Bool)1 : (_Bool)0;
  /* assertion (C->cookie_immediate != ((void *)0)) || (C->s != -1) */
  assert(tmp_if_expr_1);
  _Bool tmp_if_expr_2;
  if(C->cookie_immediate == NULL)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = C->s == -1 ? (_Bool)1 : (_Bool)0;
  /* assertion (C->cookie_immediate == ((void *)0)) || (C->s == -1) */
  assert(tmp_if_expr_2);
  if(!(C->cookie_timeo == NULL))
    events_timer_cancel(C->cookie_timeo);

  if(!(C->cookie_immediate == NULL))
    events_immediate_cancel(C->cookie_immediate);

  if(!(C->s == -1))
  {
    events_network_cancel(C->s, 1);
    close(C->s);
  }

  free((void *)C);
}

// network_connect_timeo
// file ../libcperciva/network/network_connect.c line 192
void * network_connect_timeo(struct sock_addr * const *sas, struct timeval *timeo, signed int (*callback)(void *, signed int), void *cookie)
{
  struct connect_cookie *C;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct connect_cookie) /*64ul*/ );
  C = (struct connect_cookie *)return_value_malloc_1;
  signed int return_value_tryconnect_2;
  if(!(C == ((struct connect_cookie *)NULL)))
  {
    C->callback = callback;
    C->cookie = cookie;
    C->sas = sas;
    C->cookie_immediate = (void *)0;
    C->cookie_timeo = (void *)0;
    C->s = -1;
    if(!(timeo == ((struct timeval *)NULL)))
    {
      memcpy((void *)&C->timeo, (const void *)timeo, sizeof(struct timeval) /*16ul*/ );
      C->timeo_enabled = 1;
    }

    else
      C->timeo_enabled = 0;
    return_value_tryconnect_2=tryconnect(C);
    if(!(return_value_tryconnect_2 == 0))
      goto err0;

    return (void *)C;
  }

  else
  {

  err0:
    ;
    return (void *)0;
  }
}

// network_read
// file ../libcperciva/network/network.h line 66
void * network_read(signed int fd, unsigned char *buf, unsigned long int buflen, unsigned long int minread, signed int (*callback)(void *, signed long int), void *cookie)
{
  struct network_read_cookie *C;
  /* assertion buflen != 0 */
  assert(buflen != (unsigned long int)0);
  /* assertion buflen <= 0x7fffffffffffffffL */
  assert(buflen <= (unsigned long int)0x7fffffffffffffffL);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct network_read_cookie) /*56ul*/ );
  C = (struct network_read_cookie *)return_value_malloc_1;
  signed int return_value_events_network_register_2;
  if(!(C == ((struct network_read_cookie *)NULL)))
  {
    C->callback = callback;
    C->cookie = cookie;
    C->fd = fd;
    C->buf = buf;
    C->buflen = buflen;
    C->minlen = minread;
    C->bufpos = (unsigned long int)0;
    return_value_events_network_register_2=events_network_register(callback_buf, (void *)C, C->fd, 0);
    if(return_value_events_network_register_2 == 0)
      return (void *)C;


  err1:
    ;
    free((void *)C);
  }


err0:
  ;
  return (void *)0;
}

// network_read_cancel
// file ../libcperciva/network/network.h line 74
void network_read_cancel(void *cookie)
{
  struct network_read_cookie *C = (struct network_read_cookie *)cookie;
  events_network_cancel(C->fd, 0);
  free((void *)C);
}

// network_write
// file ../libcperciva/network/network.h line 85
void * network_write(signed int fd, const unsigned char *buf, unsigned long int buflen, unsigned long int minwrite, signed int (*callback)(void *, signed long int), void *cookie)
{
  struct network_write_cookie *C;
  /* assertion buflen != 0 */
  assert(buflen != (unsigned long int)0);
  /* assertion buflen <= 0x7fffffffffffffffL */
  assert(buflen <= (unsigned long int)0x7fffffffffffffffL);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct network_write_cookie) /*56ul*/ );
  C = (struct network_write_cookie *)return_value_malloc_1;
  signed int return_value_events_network_register_2;
  if(!(C == ((struct network_write_cookie *)NULL)))
  {
    C->callback = callback;
    C->cookie = cookie;
    C->fd = fd;
    C->buf = buf;
    C->buflen = buflen;
    C->minlen = minwrite;
    C->bufpos = (unsigned long int)0;
    return_value_events_network_register_2=events_network_register(callback_buf_link1, (void *)C, C->fd, 1);
    if(return_value_events_network_register_2 == 0)
      return (void *)C;


  err1:
    ;
    free((void *)C);
  }


err0:
  ;
  return (void *)0;
}

// network_write_cancel
// file ../libcperciva/network/network.h line 93
void network_write_cancel(void *cookie)
{
  struct network_write_cookie *C = (struct network_write_cookie *)cookie;
  events_network_cancel(C->fd, 1);
  free((void *)C);
}

// noeintr_write
// file ../libcperciva/util/noeintr.h line 12
signed long int noeintr_write(signed int d, const void *buf, unsigned long int nbyte)
{
  const unsigned char *p = (const unsigned char *)buf;
  unsigned long int len = nbyte;
  signed long int lenwrit;
  /* assertion nbyte <= 0x7fffffffffffffffL */
  assert(nbyte <= (unsigned long int)0x7fffffffffffffffL);
  while(len >= 1ul)
  {
    lenwrit=write(d, (const void *)p, len);
    if(lenwrit == -1l)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        continue;

      goto err0;
    }

    /* assertion lenwrit >= 0 */
    assert(lenwrit >= (signed long int)0);
    /* assertion lenwrit <= (ssize_t)len */
    assert(lenwrit <= (signed long int)len);
    p = p + lenwrit;
    len = len - (unsigned long int)lenwrit;
  }
  return (signed long int)nbyte;

err0:
  ;
  return (signed long int)-1;
}

// prettyprint_ipv4
// file ../libcperciva/util/sock_util.c line 187
static char * prettyprint_ipv4(struct sockaddr *name, unsigned long int namelen)
{
  struct sockaddr_in sa_in;
  char addr[16l];
  char *s;
  if(!(namelen == sizeof(struct sockaddr_in) /*16ul*/ ))
    return (char *)(void *)0;

  else
  {
    memcpy((void *)&sa_in, (const void *)name, namelen);
    const char *return_value_inet_ntop_1;
    return_value_inet_ntop_1=inet_ntop(2, (const void *)&sa_in.sin_addr, addr, (unsigned int)sizeof(char [16l]) /*16ul*/ );
    if(return_value_inet_ntop_1 == ((const char *)NULL))
      return (char *)(void *)0;

    else
    {
      unsigned short int return_value_ntohs_2;
      return_value_ntohs_2=ntohs(sa_in.sin_port);
      signed int return_value_libcperciva_asprintf_3;
      return_value_libcperciva_asprintf_3=libcperciva_asprintf(&s, "[%s]:%d", (const void *)addr, return_value_ntohs_2);
      if(return_value_libcperciva_asprintf_3 == -1)
        return (char *)(void *)0;

      else
        return s;
    }
  }
}

// prettyprint_ipv6
// file ../libcperciva/util/sock_util.c line 214
static char * prettyprint_ipv6(struct sockaddr *name, unsigned long int namelen)
{
  struct sockaddr_in6 sa_in6;
  char addr[46l];
  char *s;
  if(!(namelen == sizeof(struct sockaddr_in6) /*28ul*/ ))
    return (char *)(void *)0;

  else
  {
    memcpy((void *)&sa_in6, (const void *)name, namelen);
    const char *return_value_inet_ntop_1;
    return_value_inet_ntop_1=inet_ntop(10, (const void *)&sa_in6.sin6_addr, addr, (unsigned int)sizeof(char [46l]) /*46ul*/ );
    if(return_value_inet_ntop_1 == ((const char *)NULL))
      return (char *)(void *)0;

    else
    {
      unsigned short int return_value_ntohs_2;
      return_value_ntohs_2=ntohs(sa_in6.sin6_port);
      signed int return_value_libcperciva_asprintf_3;
      return_value_libcperciva_asprintf_3=libcperciva_asprintf(&s, "[%s]:%d", (const void *)addr, return_value_ntohs_2);
      if(return_value_libcperciva_asprintf_3 == -1)
        return (char *)(void *)0;

      else
        return s;
    }
  }
}

// prettyprint_unix
// file ../libcperciva/util/sock_util.c line 241
static char * prettyprint_unix(struct sockaddr_un *name)
{
  char *return_value_strdup_1;
  return_value_strdup_1=strdup(name->sun_path);
  return return_value_strdup_1;
}

// proto_conn_create
// file ../proto/proto_conn.h line 22
signed int proto_conn_create(signed int s, struct sock_addr **sas, signed int decr, signed int nofps, signed int requirefps, signed int nokeepalive, struct proto_secret *K, double timeo, signed int (*callback_dead)(void *), void *cookie)
{
  struct conn_state *C;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct conn_state) /*136ul*/ );
  C = (struct conn_state *)return_value_malloc_1;
  if(!(C == ((struct conn_state *)NULL)))
  {
    C->callback_dead = callback_dead;
    C->cookie = cookie;
    C->sas = sas;
    C->decr = decr;
    C->nofps = nofps;
    C->requirefps = requirefps;
    C->nokeepalive = nokeepalive;
    C->K = K;
    C->timeo = timeo;
    C->s = s;
    C->t = -1;
    C->connect_cookie = (void *)0;
    C->connect_timeout_cookie = (void *)0;
    C->handshake_cookie = (void *)0;
    C->handshake_timeout_cookie = (void *)0;
    C->k_r = (struct proto_keys *)(void *)0;
    C->k_f = C->k_r;
    C->pipe_r = (void *)0;
    C->pipe_f = C->pipe_r;
    C->stat_r = 1;
    C->stat_f = C->stat_r;
    C->connect_timeout_cookie=events_timer_register_double(callback_connect_timeout, (void *)C, C->timeo);
    if(!(C->connect_timeout_cookie == NULL))
    {
      C->connect_cookie=network_connect(C->sas, callback_connect_done, (void *)C);
      if(!(C->connect_cookie == NULL))
      {
        if(!(C->decr == 0))
        {
          signed int return_value_starthandshake_2;
          return_value_starthandshake_2=starthandshake(C, C->s, C->decr);
          if(!(return_value_starthandshake_2 == 0))
            goto err3;

        }

        return 0;

      err3:
        ;
        network_connect_cancel(C->connect_cookie);
      }


    err2:
      ;
      events_timer_cancel(C->connect_timeout_cookie);
    }


  err1:
    ;
    free((void *)C);
  }


err0:
  ;
  return -1;
}

// proto_crypt_dec
// file ../proto/proto_crypt.c line 342
signed long int proto_crypt_dec(unsigned char *ibuf, unsigned char *obuf, struct proto_keys *k)
{
  struct anonymous_2 ctx;
  unsigned char hbuf[32l];
  unsigned char pnum_exp[8l];
  unsigned long int len;
  libcperciva_be64enc((void *)pnum_exp, k->pnum);
  libcperciva_HMAC_SHA256_Init(&ctx, (const void *)k->k_hmac, (unsigned long int)32);
  libcperciva_HMAC_SHA256_Update(&ctx, (const void *)ibuf, (unsigned long int)(1024 + 4));
  libcperciva_HMAC_SHA256_Update(&ctx, (const void *)pnum_exp, (unsigned long int)8);
  libcperciva_HMAC_SHA256_Final(hbuf, &ctx);
  unsigned char return_value_crypto_verify_bytes_1;
  return_value_crypto_verify_bytes_1=crypto_verify_bytes(hbuf, &ibuf[(signed long int)(1024 + 4)], (unsigned long int)32);
  if(!(return_value_crypto_verify_bytes_1 == 0))
    return (signed long int)-1;

  else
  {
    crypto_aesctr_buf(k->k_aes, k->pnum, ibuf, ibuf, (unsigned long int)(1024 + 4));
    k->pnum = k->pnum + (unsigned long int)1;
    unsigned int return_value_libcperciva_be32dec_2;
    return_value_libcperciva_be32dec_2=libcperciva_be32dec((const void *)&ibuf[(signed long int)1024]);
    len = (unsigned long int)return_value_libcperciva_be32dec_2;
    if(len == 0ul || len >= 1025ul)
      return (signed long int)-1;

    else
    {
      memcpy((void *)obuf, (const void *)ibuf, len);
      return (signed long int)len;
    }
  }
}

// proto_crypt_dh_generate
// file ../proto/proto_crypt.c line 211
signed int proto_crypt_dh_generate(unsigned char *yh_l, unsigned char *x, const unsigned char *dhmac_l, signed int nofps)
{
  if(!(nofps == 0))
  {
    memset((void *)yh_l, 0, (unsigned long int)(256 - 1));
    yh_l[(signed long int)(256 - 1)] = (unsigned char)1;
  }

  else
  {
    signed int return_value_crypto_dh_generate_1;
    return_value_crypto_dh_generate_1=crypto_dh_generate(yh_l, x);
    if(!(return_value_crypto_dh_generate_1 == 0))
      goto err0;

  }
  libcperciva_HMAC_SHA256_Buf((const void *)dhmac_l, (unsigned long int)32, (const void *)yh_l, (unsigned long int)256, &yh_l[(signed long int)256]);
  return 0;

err0:
  ;
  return -1;
}

// proto_crypt_dh_validate
// file ../proto/proto_crypt.c line 177
signed int proto_crypt_dh_validate(const unsigned char *yh_r, const unsigned char *dhmac_r, signed int requirefps)
{
  unsigned char hbuf[32l];
  libcperciva_HMAC_SHA256_Buf((const void *)dhmac_r, (unsigned long int)32, (const void *)yh_r, (unsigned long int)256, hbuf);
  unsigned char return_value_crypto_verify_bytes_1;
  return_value_crypto_verify_bytes_1=crypto_verify_bytes(&yh_r[(signed long int)256], hbuf, (unsigned long int)32);
  if(!(return_value_crypto_verify_bytes_1 == 0))
    return 1;

  else
  {
    signed int return_value_crypto_dh_sanitycheck_2;
    return_value_crypto_dh_sanitycheck_2=crypto_dh_sanitycheck(&yh_r[(signed long int)0]);
    if(!(return_value_crypto_dh_sanitycheck_2 == 0))
      return 1;

    else
    {
      if(!(requirefps == 0))
      {
        signed int return_value_is_not_one_3;
        return_value_is_not_one_3=is_not_one(&yh_r[(signed long int)0], (unsigned long int)256);
        if(return_value_is_not_one_3 == 0)
          return 1;

      }

      return 0;
    }
  }
}

// proto_crypt_dhmac
// file ../proto/proto_crypt.c line 121
void proto_crypt_dhmac(struct proto_secret *K, const unsigned char *nonce_l, const unsigned char *nonce_r, unsigned char *dhmac_l, unsigned char *dhmac_r, signed int decr)
{
  unsigned char nonce_CS[64l];
  unsigned char dk_1[64l];
  const unsigned char *nonce_c;
  const unsigned char *nonce_s;
  unsigned char *dhmac_c;
  unsigned char *dhmac_s;
  nonce_c = decr != 0 ? nonce_r : nonce_l;
  dhmac_c = decr != 0 ? dhmac_r : dhmac_l;
  nonce_s = decr != 0 ? nonce_l : nonce_r;
  dhmac_s = decr != 0 ? dhmac_l : dhmac_r;
  memcpy((void *)&nonce_CS[(signed long int)0], (const void *)nonce_c, (unsigned long int)32);
  memcpy((void *)&nonce_CS[(signed long int)32], (const void *)nonce_s, (unsigned long int)32);
  PBKDF2_SHA256(K->K, (unsigned long int)32, nonce_CS, (unsigned long int)(32 * 2), (unsigned long int)1, dk_1, (unsigned long int)(32 * 2));
  memcpy((void *)dhmac_c, (const void *)&dk_1[(signed long int)0], (unsigned long int)32);
  memcpy((void *)dhmac_s, (const void *)&dk_1[(signed long int)32], (unsigned long int)32);
}

// proto_crypt_enc
// file ../proto/proto_crypt.c line 304
void proto_crypt_enc(unsigned char *ibuf, unsigned long int len, unsigned char *obuf, struct proto_keys *k)
{
  struct anonymous_2 ctx;
  unsigned char pnum_exp[8l];
  /* assertion len <= 1024 */
  assert(len <= (unsigned long int)1024);
  memcpy((void *)obuf, (const void *)ibuf, len);
  memset((void *)&obuf[(signed long int)len], 0, (unsigned long int)1024 - len);
  libcperciva_be32enc((void *)&obuf[(signed long int)1024], (unsigned int)len);
  crypto_aesctr_buf(k->k_aes, k->pnum, obuf, obuf, (unsigned long int)(1024 + 4));
  libcperciva_be64enc((void *)pnum_exp, k->pnum);
  libcperciva_HMAC_SHA256_Init(&ctx, (const void *)k->k_hmac, (unsigned long int)32);
  libcperciva_HMAC_SHA256_Update(&ctx, (const void *)obuf, (unsigned long int)(1024 + 4));
  libcperciva_HMAC_SHA256_Update(&ctx, (const void *)pnum_exp, (unsigned long int)8);
  libcperciva_HMAC_SHA256_Final(&obuf[(signed long int)(1024 + 4)], &ctx);
  k->pnum = k->pnum + (unsigned long int)1;
}

// proto_crypt_free
// file ../proto/proto_crypt.h line 100
void proto_crypt_free(struct proto_keys *k)
{
  if(!(k == ((struct proto_keys *)NULL)))
  {
    crypto_aes_key_free(k->k_aes);
    free((void *)k);
  }

}

// proto_crypt_mkkeys
// file ../proto/proto_crypt.c line 248
signed int proto_crypt_mkkeys(struct proto_secret *K, const unsigned char *nonce_l, const unsigned char *nonce_r, const unsigned char *yh_r, const unsigned char *x, signed int nofps, signed int decr, struct proto_keys **eh_c, struct proto_keys **eh_s)
{
  unsigned char nonce_y[320l];
  unsigned char dk_2[128l];
  const unsigned char *nonce_c;
  const unsigned char *nonce_s;
  nonce_c = decr != 0 ? nonce_r : nonce_l;
  nonce_s = decr != 0 ? nonce_l : nonce_r;
  memcpy((void *)&nonce_y[(signed long int)0], (const void *)nonce_c, (unsigned long int)32);
  memcpy((void *)&nonce_y[(signed long int)32], (const void *)nonce_s, (unsigned long int)32);
  if(!(nofps == 0))
  {
    memset((void *)&nonce_y[(signed long int)(32 * 2)], 0, (unsigned long int)(256 - 1));
    nonce_y[(signed long int)((32 * 2 + 256) - 1)] = (unsigned char)1;
  }

  else
  {
    signed int return_value_crypto_dh_compute_1;
    return_value_crypto_dh_compute_1=crypto_dh_compute(yh_r, x, &nonce_y[(signed long int)(32 * 2)]);
    if(!(return_value_crypto_dh_compute_1 == 0))
      goto err0;

  }
  PBKDF2_SHA256(K->K, (unsigned long int)32, nonce_y, (unsigned long int)(32 * 2 + 256), (unsigned long int)1, dk_2, (unsigned long int)128);
  *eh_c=mkkeypair(&dk_2[(signed long int)0]);
  if(!(*eh_c == ((struct proto_keys *)NULL)))
  {
    *eh_s=mkkeypair(&dk_2[(signed long int)64]);
    if(!(*eh_s == ((struct proto_keys *)NULL)))
      return 0;


  err1:
    ;
    proto_crypt_free(*eh_c);
  }


err0:
  ;
  return -1;
}

// proto_crypt_secret
// file ../proto/proto_crypt.h line 28
struct proto_secret * proto_crypt_secret(const char *filename)
{
  struct anonymous_5 ctx;
  struct _IO_FILE *f;
  struct proto_secret *K;
  unsigned char buf[8192l];
  unsigned long int lenread;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct proto_secret) /*32ul*/ );
  K = (struct proto_secret *)return_value_malloc_1;
  signed int return_value_feof_6;
  if(!(K == ((struct proto_secret *)NULL)))
  {
    f=fopen(filename, "r");
    if(f == ((struct _IO_FILE *)NULL))
      do
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        if(!(*return_value___errno_location_3 == 0))
        {
          libcperciva_warn("Cannot open file: %s", filename);
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          *return_value___errno_location_2 = 0;
        }

        else
          libcperciva_warnx("Cannot open file: %s", filename);
      }
      while((_Bool)0);

    else
    {
      libcperciva_SHA256_Init(&ctx);
      do
      {
        lenread=fread((void *)buf, (unsigned long int)1, (unsigned long int)8192, f);
        if(!(lenread >= 1ul))
          break;

        libcperciva_SHA256_Update(&ctx, (const void *)buf, lenread);
      }
      while((_Bool)1);
      return_value_feof_6=feof(f);
      if(return_value_feof_6 == 0)
        do
        {
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          if(!(*return_value___errno_location_5 == 0))
          {
            libcperciva_warn("Error reading file: %s", filename);
            signed int *return_value___errno_location_4;
            return_value___errno_location_4=__errno_location();
            *return_value___errno_location_4 = 0;
          }

          else
            libcperciva_warnx("Error reading file: %s", filename);
        }
        while((_Bool)0);

      else
      {
        fclose(f);
        libcperciva_SHA256_Final(K->K, &ctx);
        return K;
      }

    err2:
      ;
      fclose(f);
    }

  err1:
    ;
    free((void *)K);
  }


err0:
  ;
  return (struct proto_secret *)(void *)0;
}

// proto_handshake
// file ../proto/proto_handshake.h line 21
void * proto_handshake(signed int s, signed int decr, signed int nofps, signed int requirefps, struct proto_secret *K, signed int (*callback)(void *, struct proto_keys *, struct proto_keys *), void *cookie)
{
  struct handshake_cookie *H;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct handshake_cookie) /*792ul*/ );
  H = (struct handshake_cookie *)return_value_malloc_1;
  signed int return_value_crypto_entropy_read_2;
  if(!(H == ((struct handshake_cookie *)NULL)))
  {
    H->callback = callback;
    H->cookie = cookie;
    H->s = s;
    H->decr = decr;
    H->nofps = nofps;
    H->requirefps = requirefps;
    H->K = K;
    return_value_crypto_entropy_read_2=crypto_entropy_read(H->nonce_local, (unsigned long int)32);
    if(return_value_crypto_entropy_read_2 == 0)
    {
      H->write_cookie=network_write(s, H->nonce_local, (unsigned long int)32, (unsigned long int)32, callback_nonce_write, (void *)H);
      if(!(H->write_cookie == NULL))
      {
        H->read_cookie=network_read(s, H->nonce_remote, (unsigned long int)32, (unsigned long int)32, callback_nonce_read, (void *)H);
        if(!(H->read_cookie == NULL))
          return (void *)H;


      err2:
        ;
        network_write_cancel(H->write_cookie);
      }

    }


  err1:
    ;
    free((void *)H);
  }


err0:
  ;
  return (void *)0;
}

// proto_handshake_cancel
// file ../proto/proto_handshake.h line 28
void proto_handshake_cancel(void *cookie)
{
  struct handshake_cookie *H = (struct handshake_cookie *)cookie;
  if(!(H->read_cookie == NULL))
    network_read_cancel(H->read_cookie);

  if(!(H->write_cookie == NULL))
    network_write_cancel(H->write_cookie);

  free((void *)H);
}

// proto_pipe
// file ../proto/proto_pipe.h line 14
void * proto_pipe(signed int s_in, signed int s_out, signed int decr, struct proto_keys *k, signed int *status, signed int (*callback)(void *), void *cookie)
{
  struct pipe_cookie *P;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct pipe_cookie) /*2160ul*/ );
  P = (struct pipe_cookie *)return_value_malloc_1;
  if(!(P == ((struct pipe_cookie *)NULL)))
  {
    P->callback = callback;
    P->cookie = cookie;
    P->status = status;
    P->s_in = s_in;
    P->s_out = s_out;
    P->decr = decr;
    P->k = k;
    P->read_cookie = (void *)0;
    P->write_cookie = (void *)0;
    if(!(P->decr == 0))
    {
      P->read_cookie=network_read(P->s_in, P->ebuf, (unsigned long int)(1024 + 4 + 32), (unsigned long int)(1024 + 4 + 32), callback_pipe_read, (void *)P);
      if(P->read_cookie == NULL)
        goto err1;

    }

    else
    {
      P->read_cookie=network_read(P->s_in, P->dbuf, (unsigned long int)1024, (unsigned long int)1, callback_pipe_read, (void *)P);
      if(P->read_cookie == NULL)
        goto err1;

    }
    return (void *)P;

  err1:
    ;
    free((void *)P);
  }


err0:
  ;
  return (void *)0;
}

// proto_pipe_cancel
// file ../proto/proto_pipe.h line 21
void proto_pipe_cancel(void *cookie)
{
  struct pipe_cookie *P = (struct pipe_cookie *)cookie;
  if(!(P->read_cookie == NULL))
    network_read_cancel(P->read_cookie);

  if(!(P->write_cookie == NULL))
    network_write_cancel(P->write_cookie);

  free((void *)P);
}

// ptrheap_add
// file ../libcperciva/datastruct/ptrheap.c line 193
signed int ptrheap_add(struct ptrheap *H, void *ptr)
{
  signed int return_value_ptrlist_append_1;
  return_value_ptrlist_append_1=ptrlist_append(H->elems, &ptr, (unsigned long int)1);
  if(return_value_ptrlist_append_1 == 0)
  {
    H->nelems = H->nelems + (unsigned long int)1;
    if(!(H->setreccookie == ((void (*)(void *, void *, unsigned long int))NULL)))
      H->setreccookie(H->cookie, ptr, H->nelems - (unsigned long int)1);

    heapifyup(H->elems, H->nelems - (unsigned long int)1, H->compar, H->setreccookie, H->cookie);
    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// ptrheap_create
// file ../libcperciva/datastruct/ptrheap.c line 141
struct ptrheap * ptrheap_create(signed int (*compar)(void *, const void *, const void *), void (*setreccookie)(void *, void *, unsigned long int), void *cookie, unsigned long int N, void **ptrs)
{
  struct ptrheap *H;
  unsigned long int i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ptrheap) /*40ul*/ );
  H = (struct ptrheap *)return_value_malloc_1;
  void **return_value_ptrlist_get_2;
  void **return_value_ptrlist_get_3;
  if(!(H == ((struct ptrheap *)NULL)))
  {
    H->compar = compar;
    H->setreccookie = setreccookie;
    H->cookie = cookie;
    H->nelems = N;
    H->elems=ptrlist_init(N);
    if(!(H->elems == ((struct ptrlist_struct *)NULL)))
    {
      i = (unsigned long int)0;
      for( ; !(i >= N); i = i + 1ul)
      {
        return_value_ptrlist_get_2=ptrlist_get(H->elems, i);
        *return_value_ptrlist_get_2 = ptrs[(signed long int)i];
      }
      i = N - (unsigned long int)1;
      for( ; !(i >= N); i = i - 1ul)
        heapify(H->elems, i, N, H->compar, (void (*)(void *, void *, unsigned long int))(void *)0, H->cookie);
      if(!(H->setreccookie == ((void (*)(void *, void *, unsigned long int))NULL)))
      {
        i = (unsigned long int)0;
        if(!(i >= N))
        {
          return_value_ptrlist_get_3=ptrlist_get(H->elems, i);
          H->setreccookie(H->cookie, *return_value_ptrlist_get_3, i);
          i = i + 1ul;
        }

      }

      return H;
    }


  err1:
    ;
    free((void *)H);
  }


err0:
  ;
  return (struct ptrheap *)(void *)0;
}

// ptrheap_delete
// file ../libcperciva/datastruct/ptrheap.c line 239
void ptrheap_delete(struct ptrheap *H, unsigned long int rc)
{
  void **return_value_ptrlist_get_3;
  _Bool tmp_if_expr_6;
  void **return_value_ptrlist_get_4;
  void **return_value_ptrlist_get_5;
  signed int return_value;
  if(!(rc == H->nelems + 18446744073709551615ul))
  {
    void **return_value_ptrlist_get_1;
    return_value_ptrlist_get_1=ptrlist_get(H->elems, rc);
    void **return_value_ptrlist_get_2;
    return_value_ptrlist_get_2=ptrlist_get(H->elems, H->nelems - (unsigned long int)1);
    *return_value_ptrlist_get_1 = *return_value_ptrlist_get_2;
    if(!(H->setreccookie == ((void (*)(void *, void *, unsigned long int))NULL)))
    {
      return_value_ptrlist_get_3=ptrlist_get(H->elems, rc);
      H->setreccookie(H->cookie, *return_value_ptrlist_get_3, rc);
    }

    if(rc >= 1ul)
    {
      return_value_ptrlist_get_4=ptrlist_get(H->elems, rc);
      return_value_ptrlist_get_5=ptrlist_get(H->elems, (rc - (unsigned long int)1) / (unsigned long int)2);
      return_value=H->compar(H->cookie, *return_value_ptrlist_get_4, *return_value_ptrlist_get_5);
      tmp_if_expr_6 = return_value < 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
    {
      swap(H->elems, rc, (rc - (unsigned long int)1) / (unsigned long int)2, H->setreccookie, H->cookie);
      heapifyup(H->elems, (rc - (unsigned long int)1) / (unsigned long int)2, H->compar, H->setreccookie, H->cookie);
    }

    else
      heapify(H->elems, rc, H->nelems, H->compar, H->setreccookie, H->cookie);
  }

  ptrlist_shrink(H->elems, (unsigned long int)1);
  H->nelems = H->nelems - 1ul;
}

// ptrheap_deletemin
// file ../libcperciva/datastruct/ptrheap.c line 284
void ptrheap_deletemin(struct ptrheap *H)
{
  ptrheap_delete(H, (unsigned long int)0);
}

// ptrheap_free
// file ../libcperciva/datastruct/ptrheap.c line 325
void ptrheap_free(struct ptrheap *H)
{
  if(!(H == ((struct ptrheap *)NULL)))
  {
    ptrlist_free(H->elems);
    free((void *)H);
  }

}

// ptrheap_getmin
// file ../libcperciva/datastruct/ptrheap.c line 223
void * ptrheap_getmin(struct ptrheap *H)
{
  void **return_value_ptrlist_get_1;
  if(!(H->nelems == 0ul))
  {
    return_value_ptrlist_get_1=ptrlist_get(H->elems, (unsigned long int)0);
    return *return_value_ptrlist_get_1;
  }

  else
    return (void *)0;
}

// ptrheap_increase
// file ../libcperciva/datastruct/ptrheap.c line 298
void ptrheap_increase(struct ptrheap *H, unsigned long int rc)
{
  heapify(H->elems, rc, H->nelems, H->compar, H->setreccookie, H->cookie);
}

// ptrheap_increasemin
// file ../libcperciva/datastruct/ptrheap.c line 312
void ptrheap_increasemin(struct ptrheap *H)
{
  heapify(H->elems, (unsigned long int)0, H->nelems, H->compar, H->setreccookie, H->cookie);
}

// ptrheap_init
// file ../libcperciva/datastruct/ptrheap.c line 126
struct ptrheap * ptrheap_init(signed int (*compar)(void *, const void *, const void *), void (*setreccookie)(void *, void *, unsigned long int), void *cookie)
{
  struct ptrheap *return_value_ptrheap_create_1;
  return_value_ptrheap_create_1=ptrheap_create(compar, setreccookie, cookie, (unsigned long int)0, (void **)(void *)0);
  return return_value_ptrheap_create_1;
}

// ptrlist_append
// file ../libcperciva/datastruct/ptrheap.c line 7
static inline signed int ptrlist_append(struct ptrlist_struct *EA, void * const *buf, unsigned long int nrec)
{
  signed int return_value_elasticarray_append_1;
  return_value_elasticarray_append_1=elasticarray_append((struct elasticarray *)EA, (const void *)buf, nrec, sizeof(void *) /*8ul*/ );
  return return_value_elasticarray_append_1;
}

// ptrlist_free
// file ../libcperciva/datastruct/ptrheap.c line 7
static inline void ptrlist_free(struct ptrlist_struct *EA)
{
  elasticarray_free((struct elasticarray *)EA);
}

// ptrlist_get
// file ../libcperciva/datastruct/ptrheap.c line 7
static inline void ** ptrlist_get(struct ptrlist_struct *EA, unsigned long int pos)
{
  void **rec;
  void *return_value_elasticarray_get_1;
  return_value_elasticarray_get_1=elasticarray_get((struct elasticarray *)EA, pos, sizeof(void *) /*8ul*/ );
  rec = (void **)return_value_elasticarray_get_1;
  return rec;
}

// ptrlist_init
// file ../libcperciva/datastruct/ptrheap.c line 7
static inline struct ptrlist_struct * ptrlist_init(unsigned long int nrec)
{
  struct elasticarray *EA;
  EA=elasticarray_init(nrec, sizeof(void *) /*8ul*/ );
  return (struct ptrlist_struct *)EA;
}

// ptrlist_shrink
// file ../libcperciva/datastruct/ptrheap.c line 7
static inline void ptrlist_shrink(struct ptrlist_struct *EA, unsigned long int nrec)
{
  elasticarray_shrink((struct elasticarray *)EA, nrec, sizeof(void *) /*8ul*/ );
}

// reseed
// file ../libcperciva/crypto/crypto_entropy.c line 120
static signed int reseed(void)
{
  unsigned char seed_material[32l];
  signed int return_value_entropy_read_1;
  return_value_entropy_read_1=entropy_read(seed_material, (unsigned long int)32);
  if(!(return_value_entropy_read_1 == 0))
    return -1;

  else
  {
    update(seed_material, (unsigned long int)32);
    drbg.reseed_counter = (unsigned int)1;
    insecure_memzero_link3((volatile void *)seed_material, (unsigned long int)32);
    return 0;
  }
}

// resize
// file ../libcperciva/datastruct/elasticarray.c line 21
static signed int resize(struct elasticarray *EA, unsigned long int nsize)
{
  unsigned long int nalloc;
  void *nbuf;
  if(!(EA->alloc >= nsize))
  {
    nalloc = EA->alloc * (unsigned long int)2;
    if(!(nalloc >= nsize))
      nalloc = nsize;

  }

  else
    if(!(4ul * nsize >= EA->alloc))
      nalloc = nsize * (unsigned long int)2;

    else
      nalloc = EA->alloc;
  if(!(nalloc == EA->alloc))
  {
    nbuf=realloc(EA->buf, nalloc);
    if(nbuf == NULL && nalloc >= 1ul)
      goto err0;

    EA->buf = nbuf;
    EA->alloc = nalloc;
  }

  EA->size = nsize;
  return 0;

err0:
  ;
  return -1;
}

// setreccookie
// file ../libcperciva/datastruct/timerqueue.c line 55
static void setreccookie(void *cookie, void *ptr, unsigned long int rc)
{
  struct timerrec_0 *rec = (struct timerrec_0 *)ptr;
  (void)cookie;
  rec->rc = rc;
}

// sock_addr_cmp
// file ../libcperciva/util/sock_util.c line 22
signed int sock_addr_cmp(struct sock_addr *sa1, struct sock_addr *sa2)
{
  _Bool tmp_if_expr_1;
  if(!(sa1->ai_family == sa2->ai_family))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = sa1->ai_socktype != sa2->ai_socktype ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = sa1->namelen != sa2->namelen ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    return 1;

  else
  {
    signed int return_value_memcmp_3;
    return_value_memcmp_3=memcmp((const void *)sa1->name, (const void *)sa2->name, (unsigned long int)sa1->namelen);
    if(!(return_value_memcmp_3 == 0))
      return 1;

    else
      return 0;
  }
}

// sock_addr_deserialize
// file ../libcperciva/util/sock_util.c line 150
struct sock_addr * sock_addr_deserialize(const unsigned char *buf, unsigned long int buflen)
{
  struct sock_addr *sa;
  void *return_value_malloc_1;
  void *return_value_malloc_2;
  if(buflen >= sizeof(unsigned int) * 3 /*12ul*/ )
  {
    return_value_malloc_1=malloc(sizeof(struct sock_addr) /*24ul*/ );
    sa = (struct sock_addr *)return_value_malloc_1;
    if(!(sa == ((struct sock_addr *)NULL)))
    {
      memcpy((void *)&sa->ai_family, (const void *)buf, sizeof(signed int) /*4ul*/ );
      buf = buf + (signed long int)sizeof(signed int) /*4ul*/ ;
      memcpy((void *)&sa->ai_socktype, (const void *)buf, sizeof(signed int) /*4ul*/ );
      buf = buf + (signed long int)sizeof(signed int) /*4ul*/ ;
      memcpy((void *)&sa->namelen, (const void *)buf, sizeof(unsigned int) /*4ul*/ );
      buf = buf + (signed long int)sizeof(unsigned int) /*4ul*/ ;
      if(buflen == sizeof(unsigned int) * 3 /*12ul*/  + (unsigned long int)sa->namelen)
      {
        return_value_malloc_2=malloc((unsigned long int)sa->namelen);
        sa->name = (struct sockaddr *)return_value_malloc_2;
        if(!(sa->name == ((struct sockaddr *)NULL)))
        {
          memcpy((void *)sa->name, (const void *)buf, (unsigned long int)sa->namelen);
          return sa;
        }

      }


    err1:
      ;
      free((void *)sa);
    }

  }


err0:
  ;
  return (struct sock_addr *)(void *)0;
}

// sock_addr_dup
// file ../libcperciva/util/sock_util.c line 44
struct sock_addr * sock_addr_dup(struct sock_addr *sa)
{
  struct sock_addr *sa2;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct sock_addr) /*24ul*/ );
  sa2 = (struct sock_addr *)return_value_malloc_1;
  void *return_value_malloc_2;
  if(!(sa2 == ((struct sock_addr *)NULL)))
  {
    sa2->ai_family = sa->ai_family;
    sa2->ai_socktype = sa->ai_socktype;
    sa2->namelen = sa->namelen;
    return_value_malloc_2=malloc((unsigned long int)sa2->namelen);
    sa2->name = (struct sockaddr *)return_value_malloc_2;
    if(!(sa2->name == ((struct sockaddr *)NULL)))
    {
      memcpy((void *)sa2->name, (const void *)sa->name, (unsigned long int)sa2->namelen);
      return sa2;
    }


  err1:
    ;
    free((void *)sa2);
  }


err0:
  ;
  return (struct sock_addr *)(void *)0;
}

// sock_addr_duplist
// file ../libcperciva/util/sock_util.h line 25
struct sock_addr ** sock_addr_duplist(struct sock_addr * const *sas)
{
  struct sock_addr **sas2;
  unsigned long int i = (unsigned long int)0;
  for( ; !(sas[(signed long int)i] == ((struct sock_addr *)NULL)); i = i + 1ul)
    ;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((i + (unsigned long int)1) * sizeof(struct sock_addr *) /*8ul*/ );
  sas2 = (struct sock_addr **)return_value_malloc_1;
  if(!(sas2 == ((struct sock_addr **)NULL)))
  {
    i = (unsigned long int)0;
    for( ; !(sas[(signed long int)i] == ((struct sock_addr *)NULL)); i = i + 1ul)
    {
      sas2[(signed long int)i]=sock_addr_dup(sas[(signed long int)i]);
      if(sas2[(signed long int)i] == ((struct sock_addr *)NULL))
        goto err1;

    }
    sas2[(signed long int)i] = (struct sock_addr *)(void *)0;
    return sas2;

  err1:
    ;
    sock_addr_freelist(sas2);
  }


err0:
  ;
  return (struct sock_addr **)(void *)0;
}

// sock_addr_free
// file ../libcperciva/util/sock.c line 441
void sock_addr_free(struct sock_addr *sa)
{
  if(!(sa == ((struct sock_addr *)NULL)))
  {
    free((void *)sa->name);
    free((void *)sa);
  }

}

// sock_addr_freelist
// file ../libcperciva/util/sock.h line 54
void sock_addr_freelist(struct sock_addr **sas)
{
  struct sock_addr **p;
  if(!(sas == ((struct sock_addr **)NULL)))
  {
    p = sas;
    for( ; !(*p == ((struct sock_addr *)NULL)); p = p + 1l)
      sock_addr_free(*p);
    free((void *)sas);
  }

}

// sock_addr_prettyprint
// file ../libcperciva/util/sock_util.c line 257
char * sock_addr_prettyprint(struct sock_addr *sa)
{
  char *return_value_prettyprint_ipv4_1;
  char *return_value_prettyprint_ipv6_2;
  char *return_value_prettyprint_unix_3;
  char *return_value_strdup_4;
  switch(sa->ai_family)
  {
    case 2:
    {
      return_value_prettyprint_ipv4_1=prettyprint_ipv4(sa->name, (unsigned long int)sa->namelen);
      return return_value_prettyprint_ipv4_1;
    }
    case 10:
    {
      return_value_prettyprint_ipv6_2=prettyprint_ipv6(sa->name, (unsigned long int)sa->namelen);
      return return_value_prettyprint_ipv6_2;
    }
    case 1:
    {
      return_value_prettyprint_unix_3=prettyprint_unix((struct sockaddr_un *)sa->name);
      return return_value_prettyprint_unix_3;
    }
    default:
    {
      return_value_strdup_4=strdup("Unknown address");
      return return_value_strdup_4;
    }
  }
}

// sock_addr_serialize
// file ../libcperciva/util/sock_util.c line 118
signed int sock_addr_serialize(struct sock_addr *sa, unsigned char **buf, unsigned long int *buflen)
{
  unsigned char *p;
  *buflen = (unsigned long int)2 * sizeof(signed int) /*4ul*/  + sizeof(unsigned int) /*4ul*/  + (unsigned long int)sa->namelen;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(*buflen);
  *buf = (unsigned char *)return_value_malloc_1;
  p = *buf;
  if(!(p == ((unsigned char *)NULL)))
  {
    memcpy((void *)p, (const void *)&sa->ai_family, sizeof(signed int) /*4ul*/ );
    p = p + (signed long int)sizeof(signed int) /*4ul*/ ;
    memcpy((void *)p, (const void *)&sa->ai_socktype, sizeof(signed int) /*4ul*/ );
    p = p + (signed long int)sizeof(signed int) /*4ul*/ ;
    memcpy((void *)p, (const void *)&sa->namelen, sizeof(unsigned int) /*4ul*/ );
    p = p + (signed long int)sizeof(unsigned int) /*4ul*/ ;
    memcpy((void *)p, (const void *)sa->name, (unsigned long int)sa->namelen);
    return 0;
  }

  else
  {

  err0:
    ;
    return -1;
  }
}

// sock_connect
// file ../libcperciva/util/sock.c line 358
signed int sock_connect(struct sock_addr * const *sas)
{
  signed int s = -1;
  for( ; !(*sas == ((struct sock_addr *)NULL)); sas = sas + 1l)
  {
    s=socket(sas[(signed long int)0]->ai_family, sas[(signed long int)0]->ai_socktype, 0);
    if(!(s == -1))
    {
      signed int return_value_connect_1;
      return_value_connect_1=connect(s, sas[(signed long int)0]->name, sas[(signed long int)0]->namelen);
      if(return_value_connect_1 == 0)
        break;

      close(s);
    }

  }
  signed int return_value_fcntl_5;
  if(*sas == ((struct sock_addr *)NULL))
    do
    {
      libcperciva_warnx("Could not connect");
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
    }
    while((_Bool)0);

  else
  {
    return_value_fcntl_5=fcntl(s, 4, 04000);
    if(return_value_fcntl_5 == -1)
      do
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 0))
        {
          libcperciva_warn("Cannot make connection non-blocking");
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          *return_value___errno_location_3 = 0;
        }

        else
          libcperciva_warnx("Cannot make connection non-blocking");
      }
      while((_Bool)0);

    else
      return s;

  err1:
    ;
    close(s);
  }

err0:
  ;
  return -1;
}

// sock_connect_nb
// file ../libcperciva/util/sock.c line 406
signed int sock_connect_nb(struct sock_addr *sa)
{
  signed int s;
  s=socket(sa->ai_family, sa->ai_socktype, 0);
  signed int return_value_fcntl_3;
  signed int return_value_connect_6;
  signed int *return_value___errno_location_5;
  signed int *return_value___errno_location_4;
  if(!(s == -1))
  {
    return_value_fcntl_3=fcntl(s, 4, 04000);
    if(return_value_fcntl_3 == -1)
      do
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        if(!(*return_value___errno_location_2 == 0))
        {
          libcperciva_warn("Cannot make socket non-blocking");
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          *return_value___errno_location_1 = 0;
        }

        else
          libcperciva_warnx("Cannot make socket non-blocking");
      }
      while((_Bool)0);

    else
    {
      return_value_connect_6=connect(s, sa->name, sa->namelen);
      if(return_value_connect_6 == -1)
      {
        return_value___errno_location_5=__errno_location();
        if(!(*return_value___errno_location_5 == 115))
        {
          return_value___errno_location_4=__errno_location();
          if(!(*return_value___errno_location_4 == 4))
            goto err1;

        }

      }

      return s;
    }

  err1:
    ;
    close(s);
  }


err0:
  ;
  return -1;
}

// sock_listener
// file ../libcperciva/util/sock.h line 26
signed int sock_listener(struct sock_addr *sa)
{
  signed int s;
  signed int val = 1;
  s=socket(sa->ai_family, sa->ai_socktype, 0);
  signed int return_value_setsockopt_5;
  signed int return_value_bind_8;
  signed int return_value_listen_11;
  signed int return_value_fcntl_14;
  if(s == -1)
    do
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 0))
      {
        libcperciva_warn("socket(%d, %d)", sa->ai_family, sa->ai_socktype);
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 0;
      }

      else
        libcperciva_warnx("socket(%d, %d)", sa->ai_family, sa->ai_socktype);
    }
    while((_Bool)0);

  else
  {
    return_value_setsockopt_5=setsockopt(s, 1, 2, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_5 == 0))
      do
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 0))
        {
          libcperciva_warn("setsockopt(SO_REUSEADDR)");
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          *return_value___errno_location_3 = 0;
        }

        else
          libcperciva_warnx("setsockopt(SO_REUSEADDR)");
      }
      while((_Bool)0);

    else
    {
      return_value_bind_8=bind(s, sa->name, sa->namelen);
      if(!(return_value_bind_8 == 0))
        do
        {
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          if(!(*return_value___errno_location_7 == 0))
          {
            libcperciva_warn("Error binding socket");
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            *return_value___errno_location_6 = 0;
          }

          else
            libcperciva_warnx("Error binding socket");
        }
        while((_Bool)0);

      else
      {
        return_value_listen_11=listen(s, 10);
        if(!(return_value_listen_11 == 0))
          do
          {
            signed int *return_value___errno_location_10;
            return_value___errno_location_10=__errno_location();
            if(!(*return_value___errno_location_10 == 0))
            {
              libcperciva_warn("Error marking socket as listening");
              signed int *return_value___errno_location_9;
              return_value___errno_location_9=__errno_location();
              *return_value___errno_location_9 = 0;
            }

            else
              libcperciva_warnx("Error marking socket as listening");
          }
          while((_Bool)0);

        else
        {
          return_value_fcntl_14=fcntl(s, 4, 04000);
          if(return_value_fcntl_14 == -1)
            do
            {
              signed int *return_value___errno_location_13;
              return_value___errno_location_13=__errno_location();
              if(!(*return_value___errno_location_13 == 0))
              {
                libcperciva_warn("Error marking socket as non-blocking");
                signed int *return_value___errno_location_12;
                return_value___errno_location_12=__errno_location();
                *return_value___errno_location_12 = 0;
              }

              else
                libcperciva_warnx("Error marking socket as non-blocking");
            }
            while((_Bool)0);

          else
            return s;
        }
      }
    }

  err1:
    ;
    close(s);
  }

err0:
  ;
  return -1;
}

// sock_resolve
// file ../libcperciva/util/sock.h line 19
struct sock_addr ** sock_resolve(const char *addr)
{
  struct sock_addr **res;
  char *s;
  char *ports;
  char *ips;
  signed long int p;
  char *tmp_post_2;
  unsigned long int return_value_strlen_4;
  unsigned long int return_value_strlen_5;
  char *return_value_strchr_7;
  if((signed int)*addr == 47)
    res=sock_resolve_unix(addr);

  else
  {
    s=strdup(addr);
    if(s == ((char *)NULL))
      goto err0;

    ports=strrchr(s, 58);
    if(ports == ((char *)NULL))
    {
      do
      {
        libcperciva_warnx("Address must contain port number: %s", s);
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 0;
      }
      while((_Bool)0);
      goto err1;
    }

    tmp_post_2 = ports;
    ports = ports + 1l;
    *tmp_post_2 = (char)0;
    if(!((signed int)*s == 91))
      res=sock_resolve_host(s, ports);

    else
    {
      return_value_strlen_4=strlen(s);
      if(!((signed int)s[-1l + (signed long int)return_value_strlen_4] == 93))
      {
        do
        {
          libcperciva_warnx("Invalid [IP address]: %s", s);
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          *return_value___errno_location_3 = 0;
        }
        while((_Bool)0);
        goto err1;
      }

      ips = &s[(signed long int)1];
      return_value_strlen_5=strlen(ips);
      ips[(signed long int)(return_value_strlen_5 - (unsigned long int)1)] = (char)0;
      p=strtol(ports, (char ** restrict )(void *)0, 10);
      if(p >= 65536l || !(p >= 1l))
      {
        do
        {
          libcperciva_warnx("Invalid port number: %s", ports);
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          *return_value___errno_location_6 = 0;
        }
        while((_Bool)0);
        goto err1;
      }

      return_value_strchr_7=strchr(ips, 58);
      if(!(return_value_strchr_7 == ((char *)NULL)))
        res=sock_resolve_ipv6(ips, (unsigned short int)p);

      else
        res=sock_resolve_ipv4(ips, (unsigned short int)p);
    }

  done1:
    ;
    free((void *)s);
  }

done0:
  ;
  return res;

err1:
  ;
  free((void *)s);

err0:
  ;
  return (struct sock_addr **)(void *)0;
}

// sock_resolve_host
// file ../libcperciva/util/sock.c line 68
static struct sock_addr ** sock_resolve_host(const char *addr, const char *ports)
{
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *r;
  struct sock_addr **sas;
  unsigned long int n;
  signed int error;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  hints.ai_protocol = 6;
  error=getaddrinfo(addr, ports, &hints, &res);
  void *return_value_imalloc_3;
  if(!(error == 0))
    do
    {
      const char *return_value_gai_strerror_1;
      return_value_gai_strerror_1=gai_strerror(error);
      libcperciva_warnx("Error looking up %s: %s", addr, return_value_gai_strerror_1);
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
    }
    while((_Bool)0);

  else
  {
    n = (unsigned long int)0;
    r = res;
    for( ; !(r == ((struct addrinfo *)NULL)); r = r->ai_next)
      n = n + 1ul;
    return_value_imalloc_3=imalloc(n + (unsigned long int)1, sizeof(struct sock_addr *) /*8ul*/ );
    sas = (struct sock_addr **)return_value_imalloc_3;
    if(sas == ((struct sock_addr **)NULL))
    {
      if(1ul + n >= 1ul)
        goto err1;

    }

    n = (unsigned long int)0;
    r = res;
    for( ; !(r == ((struct addrinfo *)NULL)); r = r->ai_next)
    {
      void *return_value_malloc_4;
      return_value_malloc_4=malloc(sizeof(struct sock_addr) /*24ul*/ );
      sas[(signed long int)n] = (struct sock_addr *)return_value_malloc_4;
      if(sas[(signed long int)n] == ((struct sock_addr *)NULL))
        goto err2;

      sas[(signed long int)n]->ai_family = r->ai_family;
      sas[(signed long int)n]->ai_socktype = r->ai_socktype;
      sas[(signed long int)n]->namelen = r->ai_addrlen;
      void *return_value_malloc_5;
      return_value_malloc_5=malloc((unsigned long int)sas[(signed long int)n]->namelen);
      sas[(signed long int)n]->name = (struct sockaddr *)return_value_malloc_5;
      if(sas[(signed long int)n]->name == ((struct sockaddr *)NULL))
        goto err3;

      memcpy((void *)sas[(signed long int)n]->name, (const void *)r->ai_addr, (unsigned long int)sas[(signed long int)n]->namelen);
      n = n + 1ul;
    }
    sas[(signed long int)n] = (struct sock_addr *)(void *)0;
    freeaddrinfo(res);
    return sas;

  err3:
    ;
    free((void *)sas[(signed long int)n]);

  err2:
    ;
    for( ; n >= 1ul; n = n - 1ul)
      sock_addr_free(sas[(signed long int)(n - (unsigned long int)1)]);
    free((void *)sas);

  err1:
    ;
    freeaddrinfo(res);
  }

err0:
  ;
  return (struct sock_addr **)(void *)0;
}

// sock_resolve_ipv4
// file ../libcperciva/util/sock.c line 182
static struct sock_addr ** sock_resolve_ipv4(const char *addr, unsigned short int p)
{
  struct sock_addr **sas;
  struct sock_addr *sa;
  struct sockaddr_in *sin;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct sockaddr_in) /*16ul*/ );
  sin = (struct sockaddr_in *)return_value_calloc_1;
  signed int return_value_inet_pton_3;
  void *return_value_malloc_4;
  void *return_value_malloc_5;
  if(!(sin == ((struct sockaddr_in *)NULL)))
  {
    sin->sin_family = (unsigned short int)2;
    sin->sin_port=htons(p);
    return_value_inet_pton_3=inet_pton(2, addr, (void *)&sin->sin_addr);
    if(!(return_value_inet_pton_3 == 1))
      do
      {
        libcperciva_warnx("Error parsing IP address: %s", addr);
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 0;
      }
      while((_Bool)0);

    else
    {
      return_value_malloc_4=malloc(sizeof(struct sock_addr) /*24ul*/ );
      sa = (struct sock_addr *)return_value_malloc_4;
      if(!(sa == ((struct sock_addr *)NULL)))
      {
        sa->ai_family = 2;
        sa->ai_socktype = 1;
        sa->name = (struct sockaddr *)sin;
        sa->namelen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        return_value_malloc_5=malloc((unsigned long int)2 * sizeof(struct sock_addr *) /*8ul*/ );
        sas = (struct sock_addr **)return_value_malloc_5;
        if(!(sas == ((struct sock_addr **)NULL)))
        {
          sas[(signed long int)0] = sa;
          sas[(signed long int)1] = (struct sock_addr *)(void *)0;
          return sas;
        }


      err2:
        ;
        free((void *)sa);
      }

    }

  err1:
    ;
    free((void *)sin);
  }


err0:
  ;
  return (struct sock_addr **)(void *)0;
}

// sock_resolve_ipv6
// file ../libcperciva/util/sock.c line 138
static struct sock_addr ** sock_resolve_ipv6(const char *addr, unsigned short int p)
{
  struct sock_addr **sas;
  struct sock_addr *sa;
  struct sockaddr_in6 *sin6;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct sockaddr_in6) /*28ul*/ );
  sin6 = (struct sockaddr_in6 *)return_value_calloc_1;
  signed int return_value_inet_pton_3;
  void *return_value_malloc_4;
  void *return_value_malloc_5;
  if(!(sin6 == ((struct sockaddr_in6 *)NULL)))
  {
    sin6->sin6_family = (unsigned short int)10;
    sin6->sin6_port=htons(p);
    return_value_inet_pton_3=inet_pton(10, addr, (void *)&sin6->sin6_addr);
    if(!(return_value_inet_pton_3 == 1))
      do
      {
        libcperciva_warnx("Error parsing IP address: %s", addr);
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 0;
      }
      while((_Bool)0);

    else
    {
      return_value_malloc_4=malloc(sizeof(struct sock_addr) /*24ul*/ );
      sa = (struct sock_addr *)return_value_malloc_4;
      if(!(sa == ((struct sock_addr *)NULL)))
      {
        sa->ai_family = 10;
        sa->ai_socktype = 1;
        sa->name = (struct sockaddr *)sin6;
        sa->namelen = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
        return_value_malloc_5=malloc((unsigned long int)2 * sizeof(struct sock_addr *) /*8ul*/ );
        sas = (struct sock_addr **)return_value_malloc_5;
        if(!(sas == ((struct sock_addr **)NULL)))
        {
          sas[(signed long int)0] = sa;
          sas[(signed long int)1] = (struct sock_addr *)(void *)0;
          return sas;
        }


      err2:
        ;
        free((void *)sa);
      }

    }

  err1:
    ;
    free((void *)sin6);
  }


err0:
  ;
  return (struct sock_addr **)(void *)0;
}

// sock_resolve_unix
// file ../libcperciva/util/sock.c line 24
static struct sock_addr ** sock_resolve_unix(const char *addr)
{
  struct sock_addr **sas;
  struct sock_addr *sa;
  struct sockaddr_un *sa_un;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct sockaddr_un) /*110ul*/ );
  sa_un = (struct sockaddr_un *)return_value_calloc_1;
  unsigned long int return_value_strlen_3;
  void *return_value_malloc_4;
  void *return_value_malloc_5;
  if(!(sa_un == ((struct sockaddr_un *)NULL)))
  {
    sa_un->sun_family = (unsigned short int)1;
    return_value_strlen_3=strlen(addr);
    if(return_value_strlen_3 >= sizeof(char [108l]) /*108ul*/ )
      do
      {
        libcperciva_warnx("socket path too long: %s", addr);
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 0;
      }
      while((_Bool)0);

    else
    {
      strcpy(sa_un->sun_path, addr);
      return_value_malloc_4=malloc(sizeof(struct sock_addr) /*24ul*/ );
      sa = (struct sock_addr *)return_value_malloc_4;
      if(!(sa == ((struct sock_addr *)NULL)))
      {
        sa->ai_family = 1;
        sa->ai_socktype = 1;
        sa->name = (struct sockaddr *)sa_un;
        sa->namelen = (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ ;
        return_value_malloc_5=malloc((unsigned long int)2 * sizeof(struct sock_addr *) /*8ul*/ );
        sas = (struct sock_addr **)return_value_malloc_5;
        if(!(sas == ((struct sock_addr **)NULL)))
        {
          sas[(signed long int)0] = sa;
          sas[(signed long int)1] = (struct sock_addr *)(void *)0;
          return sas;
        }


      err2:
        ;
        free((void *)sa);
      }

    }

  err1:
    ;
    free((void *)sa_un);
  }


err0:
  ;
  return (struct sock_addr **)(void *)0;
}

// socketlist_free
// file ../libcperciva/events/events_network.c line 19
static inline void socketlist_free(struct socketlist_struct *EA)
{
  elasticarray_free((struct elasticarray *)EA);
}

// socketlist_get
// file ../libcperciva/events/events_network.c line 19
static inline struct socketrec * socketlist_get(struct socketlist_struct *EA, unsigned long int pos)
{
  struct socketrec *rec;
  void *return_value_elasticarray_get_1;
  return_value_elasticarray_get_1=elasticarray_get((struct elasticarray *)EA, pos, sizeof(struct socketrec) /*16ul*/ );
  rec = (struct socketrec *)return_value_elasticarray_get_1;
  return rec;
}

// socketlist_getsize
// file ../libcperciva/events/events_network.c line 19
static inline unsigned long int socketlist_getsize(struct socketlist_struct *EA)
{
  unsigned long int return_value_elasticarray_getsize_1;
  return_value_elasticarray_getsize_1=elasticarray_getsize((struct elasticarray *)EA, sizeof(struct socketrec) /*16ul*/ );
  return return_value_elasticarray_getsize_1;
}

// socketlist_init
// file ../libcperciva/events/events_network.c line 19
static inline struct socketlist_struct * socketlist_init(unsigned long int nrec)
{
  struct elasticarray *EA;
  EA=elasticarray_init(nrec, sizeof(struct socketrec) /*16ul*/ );
  return (struct socketlist_struct *)EA;
}

// socketlist_resize
// file ../libcperciva/events/events_network.c line 19
static inline signed int socketlist_resize(struct socketlist_struct *EA, unsigned long int nrec)
{
  signed int return_value_elasticarray_resize_1;
  return_value_elasticarray_resize_1=elasticarray_resize((struct elasticarray *)EA, nrec, sizeof(struct socketrec) /*16ul*/ );
  return return_value_elasticarray_resize_1;
}

// starthandshake
// file ../proto/proto_conn.c line 50
static signed int starthandshake(struct conn_state *C, signed int s, signed int decr)
{
  C->handshake_timeout_cookie=events_timer_register_double(callback_handshake_timeout, (void *)C, C->timeo);
  if(!(C->handshake_timeout_cookie == NULL))
  {
    C->handshake_cookie=proto_handshake(s, decr, C->nofps, C->requirefps, C->K, callback_handshake_done, (void *)C);
    if(!(C->handshake_cookie == NULL))
      return 0;


  err1:
    ;
    events_timer_cancel(C->handshake_timeout_cookie);
    C->handshake_timeout_cookie = (void *)0;
  }


err0:
  ;
  return -1;
}

// swap
// file ../libcperciva/datastruct/ptrheap.c line 24
static void swap(struct ptrlist_struct *elems, unsigned long int i, unsigned long int j, void (*setreccookie)(void *, void *, unsigned long int), void *cookie)
{
  void *tmp;
  void **return_value_ptrlist_get_1;
  return_value_ptrlist_get_1=ptrlist_get(elems, i);
  tmp = *return_value_ptrlist_get_1;
  void **return_value_ptrlist_get_2;
  return_value_ptrlist_get_2=ptrlist_get(elems, i);
  void **return_value_ptrlist_get_3;
  return_value_ptrlist_get_3=ptrlist_get(elems, j);
  *return_value_ptrlist_get_2 = *return_value_ptrlist_get_3;
  void **return_value_ptrlist_get_4;
  return_value_ptrlist_get_4=ptrlist_get(elems, j);
  *return_value_ptrlist_get_4 = tmp;
  if(!(setreccookie == ((void (*)(void *, void *, unsigned long int))NULL)))
  {
    void **return_value_ptrlist_get_5;
    return_value_ptrlist_get_5=ptrlist_get(elems, i);
    setreccookie(cookie, *return_value_ptrlist_get_5, i);
    void **return_value_ptrlist_get_6;
    return_value_ptrlist_get_6=ptrlist_get(elems, j);
    setreccookie(cookie, *return_value_ptrlist_get_6, j);
  }

}

// timerqueue_add
// file ../libcperciva/datastruct/timerqueue.c line 97
void * timerqueue_add(struct timerqueue *Q, struct timeval *tv, void *ptr)
{
  struct timerrec_0 *r;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct timerrec_0) /*32ul*/ );
  r = (struct timerrec_0 *)return_value_malloc_1;
  signed int return_value_ptrheap_add_2;
  if(!(r == ((struct timerrec_0 *)NULL)))
  {
    memcpy((void *)&r->tv, (const void *)tv, sizeof(struct timeval) /*16ul*/ );
    r->ptr = ptr;
    return_value_ptrheap_add_2=ptrheap_add(Q->H, (void *)r);
    if(return_value_ptrheap_add_2 == 0)
      return (void *)r;


  err1:
    ;
    free((void *)r);
  }


err0:
  ;
  return (void *)0;
}

// timerqueue_delete
// file ../libcperciva/datastruct/timerqueue.c line 132
void timerqueue_delete(struct timerqueue *Q, void *cookie)
{
  struct timerrec_0 *r = (struct timerrec_0 *)cookie;
  ptrheap_delete(Q->H, r->rc);
  free((void *)r);
}

// timerqueue_free
// file ../libcperciva/datastruct/timerqueue.c line 226
void timerqueue_free(struct timerqueue *Q)
{
  struct timerrec_0 *r;
  void *return_value_ptrheap_getmin_1;
  do
  {
    return_value_ptrheap_getmin_1=ptrheap_getmin(Q->H);
    r = (struct timerrec_0 *)return_value_ptrheap_getmin_1;
    if(r == ((struct timerrec_0 *)NULL))
      break;

    free((void *)r);
    ptrheap_deletemin(Q->H);
  }
  while((_Bool)1);
  ptrheap_free(Q->H);
  free((void *)Q);
}

// timerqueue_getmin
// file ../libcperciva/datastruct/timerqueue.c line 168
struct timeval * timerqueue_getmin(struct timerqueue *Q)
{
  struct timerrec_0 *r;
  void *return_value_ptrheap_getmin_1;
  return_value_ptrheap_getmin_1=ptrheap_getmin(Q->H);
  r = (struct timerrec_0 *)return_value_ptrheap_getmin_1;
  if(!(r == ((struct timerrec_0 *)NULL)))
    return &r->tv;

  else
    return (struct timeval *)(void *)0;
}

// timerqueue_getptr
// file ../libcperciva/datastruct/timerqueue.c line 189
void * timerqueue_getptr(struct timerqueue *Q, struct timeval *tv)
{
  struct timerrec_0 *r;
  void *ptr;
  void *return_value_ptrheap_getmin_1;
  return_value_ptrheap_getmin_1=ptrheap_getmin(Q->H);
  r = (struct timerrec_0 *)return_value_ptrheap_getmin_1;
  if(r == ((struct timerrec_0 *)NULL))
    return (void *)0;

  else
  {
    signed int return_value_tvcmp_2;
    return_value_tvcmp_2=tvcmp(&r->tv, tv);
    if(return_value_tvcmp_2 >= 1)
      return (void *)0;

    else
    {
      ptrheap_deletemin(Q->H);
      ptr = r->ptr;
      free((void *)r);
      return ptr;
    }
  }
}

// timerqueue_increase
// file ../libcperciva/datastruct/timerqueue.c line 149
void timerqueue_increase(struct timerqueue *Q, void *cookie, struct timeval *tv)
{
  struct timerrec_0 *r = (struct timerrec_0 *)cookie;
  memcpy((void *)&r->tv, (const void *)tv, sizeof(struct timeval) /*16ul*/ );
  ptrheap_increase(Q->H, r->rc);
}

// timerqueue_init
// file ../libcperciva/datastruct/timerqueue.c line 69
struct timerqueue * timerqueue_init(void)
{
  struct timerqueue *timerqueue_init__1__Q;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct timerqueue) /*8ul*/ );
  timerqueue_init__1__Q = (struct timerqueue *)return_value_malloc_1;
  if(!(timerqueue_init__1__Q == ((struct timerqueue *)NULL)))
  {
    timerqueue_init__1__Q->H=ptrheap_init(compar, setreccookie, (void *)timerqueue_init__1__Q);
    if(!(timerqueue_init__1__Q->H == ((struct ptrheap *)NULL)))
      return timerqueue_init__1__Q;


  err1:
    ;
    free((void *)timerqueue_init__1__Q);
  }


err0:
  ;
  return (struct timerqueue *)(void *)0;
}

// tryconnect
// file ../libcperciva/network/network_connect.c line 116
static signed int tryconnect(struct connect_cookie *C)
{
  for( ; !(*C->sas == ((struct sock_addr *)NULL)); C->sas = C->sas + 1l)
  {
    C->s=sock_connect_nb(C->sas[(signed long int)0]);
    if(!(C->s == -1))
      break;

  }
  signed int return_value_events_network_register_1;
  if(!(*C->sas == ((struct sock_addr *)NULL)))
  {
    if(!(C->timeo_enabled == 0))
    {
      C->cookie_timeo=events_timer_register(callback_timeo, (void *)C, &C->timeo);
      if(C->cookie_timeo == NULL)
        goto err1;

    }

    else
      C->cookie_timeo = (void *)0;
    return_value_events_network_register_1=events_network_register(callback_connect, (void *)C, C->s, 1);
    if(!(return_value_events_network_register_1 == 0))
      goto err2;

    return 0;
  }

  else
  {

  failed:
    ;
    C->cookie_immediate=events_immediate_register(docallback, (void *)C, 0);
    if(!(C->cookie_immediate == NULL))
    {
      return 0;

    err2:
      ;
      if(!(C->cookie_timeo == NULL))
        events_timer_cancel(C->cookie_timeo);

    }


  err1:
    ;
    if(!(C->s == -1))
      close(C->s);

    free((void *)C);
    return -1;
  }
}

// tvcmp
// file ../libcperciva/datastruct/timerqueue.c line 22
static signed int tvcmp(struct timeval *x, struct timeval *y)
{
  if(!(y->tv_sec >= x->tv_sec))
    return 1;

  else
    if(!(x->tv_sec >= y->tv_sec))
      return -1;

    else
      if(!(y->tv_usec >= x->tv_usec))
        return 1;

      else
        if(!(x->tv_usec >= y->tv_usec))
          return -1;

        else
          return 0;
}

// update
// file ../libcperciva/crypto/crypto_entropy.c line 73
static void update(unsigned char *data, unsigned long int datalen)
{
  struct anonymous_2 ctx;
  unsigned char K[32l];
  unsigned char Vx[33l];
  memcpy((void *)K, (const void *)drbg.Key, (unsigned long int)32);
  memcpy((void *)Vx, (const void *)drbg.V, (unsigned long int)32);
  Vx[(signed long int)32] = (unsigned char)0x00;
  libcperciva_HMAC_SHA256_Init(&ctx, (const void *)K, (unsigned long int)32);
  libcperciva_HMAC_SHA256_Update(&ctx, (const void *)Vx, (unsigned long int)33);
  libcperciva_HMAC_SHA256_Update(&ctx, (const void *)data, datalen);
  libcperciva_HMAC_SHA256_Final(K, &ctx);
  libcperciva_HMAC_SHA256_Buf((const void *)K, (unsigned long int)32, (const void *)Vx, (unsigned long int)32, Vx);
  if(!(datalen == 0ul))
  {
    Vx[(signed long int)32] = (unsigned char)0x01;
    libcperciva_HMAC_SHA256_Init(&ctx, (const void *)K, (unsigned long int)32);
    libcperciva_HMAC_SHA256_Update(&ctx, (const void *)Vx, (unsigned long int)33);
    libcperciva_HMAC_SHA256_Update(&ctx, (const void *)data, datalen);
    libcperciva_HMAC_SHA256_Final(K, &ctx);
    libcperciva_HMAC_SHA256_Buf((const void *)K, (unsigned long int)32, (const void *)Vx, (unsigned long int)32, Vx);
  }

  memcpy((void *)drbg.Key, (const void *)K, (unsigned long int)32);
  memcpy((void *)drbg.V, (const void *)Vx, (unsigned long int)32);
  insecure_memzero_link3((volatile void *)K, (unsigned long int)32);
  insecure_memzero_link3((volatile void *)Vx, (unsigned long int)33);
}

// usage
// file main.c line 17
static void usage(void)
{
  fprintf(stderr, "usage: spiped {-e | -d} -s <source socket> -t <target socket> -k <key file>\n    [-DFj] [-f | -g] [-n <max # connections>] [-o <connection timeout>]\n    [-p <pidfile>] [-r <rtime> | -R]\n");
  exit(1);
}

// useaesni
// file ../libcperciva/crypto/crypto_aes.c line 55
static signed int useaesni(void)
{
  unsigned char key[32l];
  unsigned char ptext[16l];
  unsigned long int i;
  _Bool tmp_if_expr_5;
  signed int return_value_aesnitest_4;
  static signed int aesnigood = -1;
  while(aesnigood == -1)
  {
    aesnigood = 0;
    signed int return_value_cpusupport_x86_aesni_1;
    return_value_cpusupport_x86_aesni_1=cpusupport_x86_aesni();
    if(return_value_cpusupport_x86_aesni_1 == 0)
      break;

    i = (unsigned long int)0;
    for( ; !(i >= 16ul); i = i + 1ul)
      ptext[(signed long int)i] = (unsigned char)((unsigned long int)0x11 * i);
    i = (unsigned long int)0;
    for( ; !(i >= 32ul); i = i + 1ul)
      key[(signed long int)i] = (unsigned char)i;
    signed int return_value_aesnitest_3;
    return_value_aesnitest_3=aesnitest(ptext, key, (unsigned long int)16);
    if(!(return_value_aesnitest_3 == 0))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_aesnitest_4=aesnitest(ptext, key, (unsigned long int)32);
      tmp_if_expr_5 = return_value_aesnitest_4 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
    {
      do
      {
        libcperciva_warnx("Disabling AESNI due to failed self-test");
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 0;
      }
      while((_Bool)0);
      break;
    }

    aesnigood = 1;
  }
  return aesnigood;
}

// warnp_setprogname
// file ../libcperciva/util/warnp.h line 14
void warnp_setprogname(const char *progname)
{
  const char *p;
  free((void *)name);
  p = progname;
  for( ; !((signed int)*progname == 0); progname = progname + 1l)
    if((signed int)*progname == 47)
      p = progname + (signed long int)1;

  name=strdup(p);
  if(initialized == 0)
  {
    atexit(done);
    initialized = 1;
  }

}

// workthread
// file ../lib/dnsthread/dnsthread.c line 60
static void * workthread(void *cookie)
{
  struct dnsthread_internal *T = (struct dnsthread_internal *)cookie;
  char *addr;
  struct sock_addr **sas;
  signed int res_errno = 0;
  signed int rc;
  unsigned char zero = (unsigned char)0;
  rc=pthread_mutex_lock(&T->mtx);
  if(!(rc == 0))
  {
    do
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(rc);
      libcperciva_warnx("pthread_mutex_lock: %s", return_value_strerror_1);
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
    }
    while((_Bool)0);
    exit(1);
  }


__CPROVER_DUMP_L2:
  ;
  signed int *return_value___errno_location_7;
  while((_Bool)1)
  {
    if(T->state == 0)
    {
      rc=pthread_cond_wait(&T->cv, &T->mtx);
      if(!(rc == 0))
      {
        do
        {
          char *return_value_strerror_3;
          return_value_strerror_3=strerror(rc);
          libcperciva_warnx("pthread_cond_wait: %s", return_value_strerror_3);
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          *return_value___errno_location_4 = 0;
        }
        while((_Bool)0);
        exit(1);
      }

      goto __CPROVER_DUMP_L2;
    }

    if(T->state == 2)
      break;

    addr = T->addr;
    rc=pthread_mutex_unlock(&T->mtx);
    if(!(rc == 0))
    {
      do
      {
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(rc);
        libcperciva_warnx("pthread_mutex_unlock: %s", return_value_strerror_5);
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        *return_value___errno_location_6 = 0;
      }
      while((_Bool)0);
      exit(1);
    }

    sas=sock_resolve(addr);
    if(sas == ((struct sock_addr **)NULL))
    {
      return_value___errno_location_7=__errno_location();
      res_errno = *return_value___errno_location_7;
    }

    rc=pthread_mutex_lock(&T->mtx);
    if(!(rc == 0))
    {
      do
      {
        char *return_value_strerror_8;
        return_value_strerror_8=strerror(rc);
        libcperciva_warnx("pthread_mutex_lock: %s", return_value_strerror_8);
        signed int *return_value___errno_location_9;
        return_value___errno_location_9=__errno_location();
        *return_value___errno_location_9 = 0;
      }
      while((_Bool)0);
      exit(1);
    }

    T->sas = sas;
    T->res_errno = res_errno;
    signed long int return_value_noeintr_write_12;
    return_value_noeintr_write_12=noeintr_write(T->wakeupsock[(signed long int)0], (const void *)&zero, (unsigned long int)1);
    if(!(return_value_noeintr_write_12 == 1l))
    {
      do
      {
        signed int *return_value___errno_location_11;
        return_value___errno_location_11=__errno_location();
        if(!(*return_value___errno_location_11 == 0))
        {
          libcperciva_warn("Error writing to wakeup socket");
          signed int *return_value___errno_location_10;
          return_value___errno_location_10=__errno_location();
          *return_value___errno_location_10 = 0;
        }

        else
          libcperciva_warnx("Error writing to wakeup socket");
      }
      while((_Bool)0);
      exit(1);
    }

    if(!(T->state == 2))
      T->state = 0;

  }
  close(T->wakeupsock[(signed long int)1]);
  close(T->wakeupsock[(signed long int)0]);
  rc=pthread_cond_destroy(&T->cv);
  if(!(rc == 0))
  {
    do
    {
      char *return_value_strerror_13;
      return_value_strerror_13=strerror(rc);
      libcperciva_warnx("pthread_cond_destroy: %s", return_value_strerror_13);
      signed int *return_value___errno_location_14;
      return_value___errno_location_14=__errno_location();
      *return_value___errno_location_14 = 0;
    }
    while((_Bool)0);
    exit(1);
  }

  rc=pthread_mutex_unlock(&T->mtx);
  if(!(rc == 0))
  {
    do
    {
      char *return_value_strerror_15;
      return_value_strerror_15=strerror(rc);
      libcperciva_warnx("pthread_mutex_unlock: %s", return_value_strerror_15);
      signed int *return_value___errno_location_16;
      return_value___errno_location_16=__errno_location();
      *return_value___errno_location_16 = 0;
    }
    while((_Bool)0);
    exit(1);
  }

  rc=pthread_mutex_destroy(&T->mtx);
  if(!(rc == 0))
  {
    do
    {
      char *return_value_strerror_17;
      return_value_strerror_17=strerror(rc);
      libcperciva_warnx("pthread_mutex_destroy: %s", return_value_strerror_17);
      signed int *return_value___errno_location_18;
      return_value___errno_location_18=__errno_location();
      *return_value___errno_location_18 = 0;
    }
    while((_Bool)0);
    exit(1);
  }

  free((void *)T);
  return (void *)0;
}

