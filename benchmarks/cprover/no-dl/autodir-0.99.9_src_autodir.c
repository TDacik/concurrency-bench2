// tag-#anon#ST[*{*{SYM#tag-bqueue#}$SYM#tag-bqueue#$}$*{SYM#tag-bqueue#}$SYM#tag-bqueue#$$'hash'||S32'hash_used'||S32'hash_size'||S64'wait'||S32'maxproc'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'lock'||U64'queue_watch'||S32'stop'||U32'$pad1'||*{SYM#tag-bqueue#}$SYM#tag-bqueue#$'start_t'||*{SYM#tag-bqueue#}$SYM#tag-bqueue#$'end_t'||*{SYM#tag-bqueue#}$SYM#tag-bqueue#$'cur_t'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'bchain_wait'||*{SYM#tag-bqueue#}$SYM#tag-bqueue#$'bchain'|]
// file backup_queue.c line 75
struct anonymous$19;

// tag-#anon#ST[*{S8}$S8$'path'||S32'mounted'||S32'k_pipe'||S32'ioctlfd'||S32'time_out'||S32'proto'||U32'$pad0'||U64'dev'|]
// file autodir.c line 64
struct anonymous$12;

// tag-#anon#ST[*{SYM#tag-lentry#}$SYM#tag-lentry#$'list'||S32'count'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'lock'|]
// file lockfile.c line 54
struct anonymous$17;

// tag-#anon#ST[*{SYM#tag-lt__handle#}$SYM#tag-lt__handle#$'handle'||*{S8}$S8$'mod_path'||*{S8}$S8$'mod_subopt'|]
// file module.c line 41
struct anonymous$1;

// tag-#anon#ST[*{SYM#tag-mentry#}$SYM#tag-mentry#$'list'||S32'count'||U32'$pad0'|]
// file multipath.c line 55
struct anonymous$18;

// tag-#anon#ST[*{SYM#tag-packet#}$SYM#tag-packet#$'list'||S32'count'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'lock'|]
// file mpacket.c line 35
struct anonymous$8;

// tag-#anon#ST[*{SYM#tag-wentry#}$SYM#tag-wentry#$'list'||S32'count'||U32'$pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'lock'|]
// file workon.c line 49
struct anonymous$15;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$2;

// tag-#anon#ST[ARR256{S8}$S8$'name'||*{cS8}$cS8$'module_name'||S32'pid'||S32'pgrp'||S32'fg'||U32'$pad0'||*{S8}$S8$'pid_file'||S32'shutdown'||S32'stop'||U64'sig_th'||S32'multi_path'||S8'multi_prefix'||U24'$pad1'||SYM#tag-thread_cache#'expire_tc'||SYM#tag-thread_cache#'missing_tc'|]
// file autodir.c line 74
struct anonymous$16;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$14;

// tag-#anon#ST[S32'count'||ARR41{S8}$S8$'ostr'||U24'$pad0'||ARR20{SYM#tag-opt_cb#}$SYM#tag-opt_cb#$'opt'||SYM#tag-cary#'ca'|]
// file options.c line 72
struct anonymous$13;

// tag-#anon#ST[S32'count'||U32'$pad0'||*{SYM#tag-barg#}$SYM#tag-barg#$'end'||*{SYM#tag-barg#}$SYM#tag-barg#$'start'|]
// file backup_argv.c line 52
struct anonymous$4;

// tag-#anon#ST[S32'count'||U32'$pad0'||*{SYM#tag-bqueue#}$SYM#tag-bqueue#$'list'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'lock'|]
// file backup_queue.c line 111
struct anonymous$20;

// tag-#anon#ST[S32'msg_which'||S32'slog_init'||S32'verbose_log'||U32'$pad0'||*{S8}$S8$'modname_prefix'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'strerror_lock'|]
// file msg.c line 61
struct anonymous$11;

// tag-#anon#ST[S32'priority'||U32'$pad0'||*{cS8}$cS8$'tag'|]
// file msg.c line 45
struct anonymous$10;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'lock'||*{SYM#tag-backup_pid#}$SYM#tag-backup_pid#$'list'||S32'count'||U32'$pad0'|]
// file backup_pid.c line 35
struct anonymous$5;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'lock'||*{SYM#tag-backup_pids#}$SYM#tag-backup_pids#$'pids1'||*{SYM#tag-backup_pids#}$SYM#tag-backup_pids#$'pids2'|]
// file backup_pid.c line 113
struct anonymous$6;

// tag-#anon#ST[U64'main'||ARR10{U64}$U64$'threads'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'lock'||S32'cur'||S32'stop'||S32'ioctlfd'||U32'$pad0'||*{S32}$S32$'shutdown'|]
// file expire.c line 40
struct anonymous$7;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$9;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$0;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_cap_struct
// file /usr/include/sys/capability.h line 41
struct _cap_struct;

// tag-autofs_packet_expire
// file /usr/include/linux/auto_fs.h line 58
struct autofs_packet_expire;

// tag-autofs_packet_expire_multi
// file /usr/include/linux/auto_fs4.h line 115
struct autofs_packet_expire_multi;

// tag-autofs_packet_hdr
// file /usr/include/linux/auto_fs.h line 45
struct autofs_packet_hdr;

// tag-autofs_packet_missing
// file /usr/include/linux/auto_fs.h line 50
struct autofs_packet_missing;

// tag-autofs_packet_union
// file /usr/include/linux/auto_fs4.h line 122
union autofs_packet_union;

// tag-backup_pid
// file backup_pid.h line 9
struct backup_pid;

// tag-backup_pids
// file backup_pid.h line 7
struct backup_pids;

// tag-barg
// file backup_argv.c line 46
struct barg;

// tag-bqueue
// file backup_queue.c line 56
struct bqueue;

// tag-cary
// file miscfuncs.h line 28
struct cary;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-lentry
// file lockfile.c line 45
struct lentry;

// tag-lt__handle
// file /usr/include/ltdl.h line 50
struct lt__handle;

// tag-mentry
// file multipath.c line 47
struct mentry;

// tag-module_info
// file module.h line 26
struct module_info;

// tag-opt_cb
// file options.c line 64
struct opt_cb;

// tag-packet
// file mpacket.h line 26
struct packet;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-thread_cache
// file thread_cache.h line 26
struct thread_cache;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-wentry
// file workon.c line 40
struct wentry;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __fxstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 398
extern signed int __fxstat(signed int, signed int, struct stat *);
// __lxstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 402
extern signed int __lxstat(signed int, const char *, struct stat *);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 400
extern signed int __xstat(signed int, const char *, struct stat *);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// autodir_clean
// file autodir.c line 626
static void autodir_clean(void);
// autodir_name
// file autodir.c line 650
char * autodir_name(void);
// autodir_option_fg
// file autodir.c line 788
void autodir_option_fg(char ch, char *arg, signed int valid);
// autodir_option_multipath
// file autodir.c line 793
void autodir_option_multipath(char ch, char *arg, signed int valid);
// autodir_option_multiprefix
// file autodir.c line 800
void autodir_option_multiprefix(char ch, char *arg, signed int valid);
// autodir_option_path
// file autodir.c line 762
void autodir_option_path(char ch, char *arg, signed int valid);
// autodir_option_pidfile
// file autodir.c line 771
void autodir_option_pidfile(char ch, char *arg, signed int valid);
// autodir_option_timeout
// file autodir.c line 780
void autodir_option_timeout(char ch, char *arg, signed int valid);
// autodir_setname
// file autodir.c line 94
static void autodir_setname(const char *name);
// backarg_add
// file backup_argv.c line 66
static void backarg_add(char *arg);
// backarg_clean
// file backup_argv.c line 203
static void backarg_clean(void);
// backarg_expand
// file backup_argv.c line 92
static signed int backarg_expand(char *buf, const signed int len, const char *fmt, const char *dname, const char *dpath, const char *host, struct tm *tm);
// backup_add
// file backup.h line 5
void backup_add(const char *name, const char *path);
// backup_argv_get
// file backup_argv.h line 27
signed int backup_argv_get(const char *name, const char *path, char ***argv);
// backup_argv_init
// file backup_argv.h line 26
void backup_argv_init(char *bopt);
// backup_child_add
// file backup_child.c line 109
static signed int backup_child_add(const char *name, signed int pid, signed long int started);
// backup_child_count
// file backup_child.h line 8
signed int backup_child_count(void);
// backup_child_init
// file backup_child.h line 4
void backup_child_init(signed int size, signed int blife);
// backup_child_kill
// file backup_child.h line 7
void backup_child_kill(const char *name);
// backup_child_start
// file backup_child.h line 5
void backup_child_start(const char *name, const char *path);
// backup_child_stop
// file backup_child.h line 12
void backup_child_stop(void);
// backup_child_stop_set
// file backup_child.h line 13
void backup_child_stop_set(void);
// backup_child_wait
// file backup_child.h line 6
void backup_child_wait(const char *name);
// backup_exec
// file backup_fork.c line 54
static void backup_exec(const char *name, const char *path);
// backup_fast_kill
// file backup_fork.h line 8
void backup_fast_kill(signed int pid, const char *name);
// backup_fork_new
// file backup_fork.h line 4
signed int backup_fork_new(const char *name, const char *path);
// backup_fork_option_pri
// file backup_fork.h line 10
void backup_fork_option_pri(char ch, char *arg, signed int valid);
// backup_init
// file backup.h line 4
void backup_init(void);
// backup_kill
// file backup_fork.h line 6
void backup_kill(signed int pid, const char *name);
// backup_kill_all
// file backup_child.c line 445
static void backup_kill_all(void);
// backup_monitor_thread
// file backup_child.c line 260
static void * backup_monitor_thread(void *x);
// backup_option_life
// file backup.h line 15
void backup_option_life(char ch, char *arg, signed int valid);
// backup_option_max_proc
// file backup.h line 14
void backup_option_max_proc(char ch, char *arg, signed int valid);
// backup_option_nokill
// file backup.h line 13
void backup_option_nokill(char ch, char *arg, signed int valid);
// backup_option_path
// file backup.h line 10
void backup_option_path(char ch, char *arg, signed int valid);
// backup_option_wait
// file backup.h line 11
void backup_option_wait(char ch, char *arg, signed int valid);
// backup_option_wait2finish
// file backup.h line 12
void backup_option_wait2finish(char ch, char *arg, signed int valid);
// backup_pid_init
// file backup_pid.h line 34
void backup_pid_init(signed int size);
// backup_pidmem_allocate
// file backup_pid.h line 38
struct backup_pid * backup_pidmem_allocate(void);
// backup_pidmem_free
// file backup_pid.h line 39
void backup_pidmem_free(struct backup_pid *bp);
// backup_pids_get
// file backup_pid.h line 35
struct backup_pids * backup_pids_get(void);
// backup_pids_unget
// file backup_pid.h line 36
void backup_pids_unget(struct backup_pids *pids);
// backup_queue_add
// file backup_queue.h line 6
void backup_queue_add(const char *name, const char *path);
// backup_queue_init
// file backup_queue.h line 4
void backup_queue_init(signed int bwait, signed int maxproc);
// backup_queue_remove
// file backup_queue.h line 5
signed int backup_queue_remove(const char *name);
// backup_queue_stop
// file backup_queue.h line 8
void backup_queue_stop(void);
// backup_queue_stop_set
// file backup_queue.h line 7
void backup_queue_stop_set(void);
// backup_remove
// file backup.h line 6
void backup_remove(const char *name, signed int force);
// backup_signal_all
// file backup_child.c line 424
static void backup_signal_all(void);
// backup_soft_signal
// file backup_fork.h line 7
void backup_soft_signal(signed int pid);
// backup_stop
// file backup.h line 7
void backup_stop(void);
// backup_stop_set
// file backup.h line 8
void backup_stop_set(void);
// backup_waitpid
// file backup_fork.h line 5
signed int backup_waitpid(signed int pid, const char *name, signed int block);
// bchain_process
// file backup_queue.c line 338
static void bchain_process(void);
// become_daemon
// file autodir.c line 537
static void become_daemon(void);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cap_free
// file /usr/include/sys/capability.h line 74
extern signed int cap_free(void *);
// cap_from_text
// file /usr/include/sys/capability.h line 106
extern struct _cap_struct * cap_from_text(const char *);
// cap_set_proc
// file /usr/include/sys/capability.h line 93
extern signed int cap_set_proc(struct _cap_struct *);
// cary_add
// file miscfuncs.c line 103
signed int cary_add(struct cary *c, char ch);
// cary_add_str
// file miscfuncs.c line 114
signed int cary_add_str(struct cary *ca, const char *str);
// cary_init
// file miscfuncs.c line 95
void cary_init(struct cary *c, char *buf, signed int max);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// check_abs_path
// file miscfuncs.h line 37
signed int check_abs_path(char *path);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// clock_nanosleep
// file /usr/include/time.h line 353
extern signed int clock_nanosleep(signed int, signed int, struct timespec *, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// condattr_init
// file thread.c line 96
static void condattr_init(void);
// create_dir
// file miscfuncs.h line 42
signed int create_dir(const char *dir, unsigned int mode);
// dropcap_drop
// file dropcap.h line 26
void dropcap_drop(void);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// entry_allocate
// file backup_queue.c line 142
static struct bqueue * entry_allocate(void);
// entry_allocate$link1
// file backup_pid.c line 66
static struct backup_pid * entry_allocate$link1(void);
// entry_free
// file backup_queue.c line 117
static void entry_free(struct bqueue *bq);
// entry_free$link1
// file backup_pid.c line 41
static void entry_free$link1(struct backup_pid *to_free);
// exclusive_lock
// file lockfile.c line 278
static signed int exclusive_lock(signed int fd, const char *path);
// execv
// file /usr/include/unistd.h line 563
extern signed int execv(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expire_start
// file expire.h line 26
void expire_start(signed int time_out, signed int ioctlfd, signed int *shutdown);
// expire_stop
// file expire.h line 27
void expire_stop(void);
// expire_stop_set
// file expire.h line 28
void expire_stop_set(void);
// extra_expire_mounts
// file expire.c line 69
static void * extra_expire_mounts(void *x);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_hash
// file lockfile.c line 471
static void free_hash(void);
// free_slot_get
// file backup_pid.c line 195
static signed int free_slot_get(struct backup_pids *pids);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat(signed int __fd, struct stat *__statbuf);
// fstat$link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat$link1(signed int __fd$link1, struct stat *__statbuf$link1);
// get_cache
// file thread_cache.c line 40
static struct packet * get_cache(struct thread_cache *tc);
// get_pid
// file backup_child.c line 150
static signed int get_pid(const char *name, struct backup_pid **id, signed int mark_kill);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpgrp
// file /usr/include/unistd.h line 634
extern signed int getpgrp(void);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// handle_events
// file autodir.c line 497
static void handle_events(signed int fd);
// handle_expire
// file autodir.c line 430
static void handle_expire(struct packet *pkt);
// handle_missing
// file autodir.c line 301
static void handle_missing(struct packet *pkt);
// hash_resize
// file backup_queue.c line 200
static void hash_resize(void);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// lentry_free
// file lockfile.c line 100
static void lentry_free(struct lentry *le);
// lentry_malloc
// file lockfile.c line 77
static struct lentry * lentry_malloc(void);
// lhash_resize
// file lockfile.c line 129
static void lhash_resize(void);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// lockfile_add2hash
// file lockfile.c line 183
static struct lentry * lockfile_add2hash(const char *name, const char *path, signed int *exist);
// lockfile_clean
// file lockfile.c line 537
static void lockfile_clean(void);
// lockfile_create
// file lockfile.h line 28
signed int lockfile_create(const char *name);
// lockfile_hash_clean
// file lockfile.c line 496
static void lockfile_hash_clean(void);
// lockfile_hash_init
// file lockfile.c line 518
static void lockfile_hash_init(void);
// lockfile_init
// file lockfile.h line 32
void lockfile_init(signed int pid, const char *mod_name);
// lockfile_option_lockdir
// file lockfile.h line 30
void lockfile_option_lockdir(char ch, char *arg, signed int valid);
// lockfile_option_lockfiles
// file lockfile.h line 31
void lockfile_option_lockfiles(char ch, char *arg, signed int valid);
// lockfile_remove
// file lockfile.h line 29
void lockfile_remove(const char *name);
// lockfile_sleep
// file lockfile.c line 303
static signed int lockfile_sleep(signed int n);
// lockfile_stop_set
// file lockfile.h line 33
void lockfile_stop_set(void);
// lockfile_unhash
// file lockfile.c line 239
static struct lentry * lockfile_unhash(const char *name, signed int force);
// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 459
static inline signed int lstat(const char *__path, struct stat *__statbuf);
// lstat$link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 459
static inline signed int lstat$link1(const char *__path$link1, struct stat *__statbuf$link1);
// lt_dlclose
// file /usr/include/ltdl.h line 83
extern signed int lt_dlclose(struct lt__handle *);
// lt_dlerror
// file /usr/include/ltdl.h line 82
extern const char * lt_dlerror(void);
// lt_dlinit
// file /usr/include/ltdl.h line 53
extern signed int lt_dlinit(void);
// lt_dlopenext
// file /usr/include/ltdl.h line 78
extern struct lt__handle * lt_dlopenext(const char *);
// lt_dlsym
// file /usr/include/ltdl.h line 81
extern void * lt_dlsym(struct lt__handle *, const char *);
// main_expire_mounts
// file expire.c line 173
static void * main_expire_mounts(void *x);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mentry_free
// file multipath.c line 88
static void mentry_free(struct mentry *me);
// mentry_malloc
// file multipath.c line 72
static struct mentry * mentry_malloc(void);
// mhash_resize
// file multipath.c line 104
static void mhash_resize(void);
// missing_exit
// file autodir.c line 287
static void missing_exit(char *mname, char *name, unsigned int wqt, signed int result);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mod_clean$object
//
void mod_clean$object(void);
// mod_dir$object
//
void mod_dir$object(char *, signed int, const char *);
// mod_dowork$object
//
signed int mod_dowork$object(const char *, const char *, char *, signed int);
// mod_init$object
//
struct module_info * mod_init$object(char *, const char *);
// module_check
// file module.c line 72
static void module_check(void);
// module_clean
// file module.c line 94
static void module_clean(void);
// module_load
// file module.h line 39
void module_load(char *apath);
// module_name
// file module.h line 42
const char * module_name(void);
// module_option_modopt
// file module.h line 41
void module_option_modopt(char ch, char *arg, signed int valid);
// module_option_modpath
// file module.h line 40
void module_option_modpath(char ch, char *arg, signed int valid);
// module_symbol
// file module.c line 61
static void * module_symbol(const char *sname);
// mono_nanosleep
// file time_mono.h line 19
void mono_nanosleep(signed long int nsec);
// mount
// file /usr/include/x86_64-linux-gnu/sys/mount.h line 135
extern signed int mount(const char *, const char *, const char *, unsigned long int, const void *);
// mount_autodir
// file autodir.c line 192
static void mount_autodir(char *path, signed int pgrp, signed int pid, signed int minp, signed int maxp);
// msg_clean
// file msg.c line 148
static void msg_clean(void);
// msg_console
// file msg.c line 69
static void msg_console(signed int msgprio, const char *txt);
// msg_console_off
// file msg.h line 50
void msg_console_off(void);
// msg_console_on
// file msg.h line 49
void msg_console_on(void);
// msg_init
// file msg.h line 48
void msg_init(void);
// msg_modname_prefix
// file msg.h line 53
void msg_modname_prefix(const char *modname);
// msg_option_verbose
// file msg.c line 202
void msg_option_verbose(char ch, char *arg, signed int valid);
// msg_syslog
// file msg.c line 86
static void msg_syslog(signed int msgprio, const char *txt);
// msg_syslog_off
// file msg.c line 190
void msg_syslog_off(void);
// msg_syslog_on
// file msg.h line 51
void msg_syslog_on(void);
// msglog
// file msg.h line 54
void msglog(signed int mprio, const char *fmt, ...);
// multipath_clean
// file multipath.c line 238
static void multipath_clean(void);
// multipath_dec
// file multipath.h line 7
signed int multipath_dec(const char *name);
// multipath_inc
// file multipath.h line 6
signed int multipath_inc(const char *name);
// multipath_init
// file multipath.h line 4
void multipath_init(void);
// mutexattr_init
// file thread.c line 77
static void mutexattr_init(void);
// octal_string2dec
// file miscfuncs.c line 145
signed int octal_string2dec(const char *str, unsigned int *oct);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// option_call_cbs
// file options.c line 143
static void option_call_cbs(void);
// option_help
// file options.c line 124
static void option_help(char ch, char *arg, signed int valid);
// option_init
// file options.h line 26
void option_init(signed int argc, char **argv);
// option_is_exist
// file options.c line 79
static struct opt_cb * option_is_exist(char opch);
// option_process
// file options.c line 159
static void option_process(char **argv, signed int argc);
// option_register
// file options.c line 191
static void option_register(const char opch, void (* const cb)(char, char *, signed int), const signed int areq);
// option_register::cb$object
//
void cb$object(char, char *, signed int);
// option_usage
// file options.c line 93
static void option_usage(void);
// option_version
// file options.c line 133
static void option_version(char ch, char *arg, signed int valid);
// packet_allocate
// file mpacket.h line 40
struct packet * packet_allocate(void);
// packet_clean
// file mpacket.c line 107
static void packet_clean(void);
// packet_free
// file mpacket.h line 41
void packet_free(struct packet *pk);
// packet_get_free_list
// file mpacket.c line 43
static struct packet * packet_get_free_list(void);
// packet_init
// file mpacket.h line 39
void packet_init(void);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// poll_read
// file autodir.c line 236
static signed int poll_read(signed int fd, char *buf, signed int sz);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_attr_setscope
// file /usr/include/pthread.h line 353
extern signed int pthread_attr_setscope(union pthread_attr_t *, signed int);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 377
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$0 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$0 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$0 *, const union anonymous$9 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$0 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$0 *, union anonymous *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$0 *, union anonymous *);
// pthread_condattr_init
// file /usr/include/pthread.h line 1010
extern signed int pthread_condattr_init(union anonymous$9 *);
// pthread_condattr_setclock
// file /usr/include/pthread.h line 1035
extern signed int pthread_condattr_setclock(union anonymous$9 *, signed int);
// pthread_condattr_setpshared
// file /usr/include/pthread.h line 1024
extern signed int pthread_condattr_setpshared(union anonymous$9 *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous$9 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous$9 *);
// pthread_mutexattr_setpshared
// file /usr/include/pthread.h line 822
extern signed int pthread_mutexattr_setpshared(union anonymous$9 *, signed int);
// pthread_mutexattr_settype
// file /usr/include/pthread.h line 835
extern signed int pthread_mutexattr_settype(union anonymous$9 *, signed int);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setcanceltype
// file /usr/include/pthread.h line 512
extern signed int pthread_setcanceltype(signed int, signed int *);
// queue_entry_add
// file backup_queue.c line 281
static signed int queue_entry_add(struct bqueue *new);
// queue_entry_locate
// file backup_queue.c line 182
static struct bqueue * queue_entry_locate(const char *name, unsigned int hash, signed int key);
// queue_entry_release
// file backup_queue.c line 243
static void queue_entry_release(struct bqueue *bq);
// queue_watch_thread
// file backup_queue.c line 381
static void * queue_watch_thread(void *x);
// queue_watch_wait
// file backup_queue.c line 364
static void queue_watch_wait(signed int dift);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// remove_pid
// file backup_child.c line 207
static void remove_pid(struct backup_pid *bp);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// rename_dir
// file miscfuncs.c line 275
signed int rename_dir(const char *from, const char *to_dir, const char *to_name, const char *tme_format);
// reset_signals
// file backup_fork.c line 43
static void reset_signals(void);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// send_fail
// file autodir.c line 113
static void send_fail(unsigned int wait_queue_token);
// send_ready
// file autodir.c line 107
static void send_ready(unsigned int wait_queue_token);
// setpgid
// file /usr/include/unistd.h line 646
extern signed int setpgid(signed int, signed int);
// setpgrp
// file /usr/include/unistd.h line 660
extern signed int setpgrp(void);
// setpriority
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 97
extern signed int setpriority(signed int, unsigned int, signed int);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// shared_lock
// file lockfile.c line 316
static signed int shared_lock(signed int fd, const char *path);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous$2 *);
// signal_block
// file autodir.c line 617
static void signal_block(void);
// signal_handle
// file autodir.c line 588
static void * signal_handle(void *v);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous$2 *, struct anonymous$2 *);
// sigwait
// file /usr/include/signal.h line 270
extern signed int sigwait(const struct anonymous$2 *, signed int *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// start_extra_expire_thread
// file expire.c line 133
static void start_extra_expire_thread(void);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// string_hash
// file miscfuncs.c line 244
unsigned int string_hash(const char *str);
// string_n_copy
// file miscfuncs.h line 36
char * string_n_copy(char *str1, const char *str2, signed int len);
// string_safe
// file miscfuncs.h line 46
void string_safe(char *str, signed int rep);
// string_to_number
// file miscfuncs.h line 41
signed int string_to_number(const char *str, signed int *num);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// thread_attribute_init
// file thread.c line 54
static void thread_attribute_init(union pthread_attr_t *attr, signed int joinable, unsigned long int stacksz);
// thread_cache_init
// file thread_cache.h line 62
void thread_cache_init(struct thread_cache *tc, void (*cb)(struct packet *), signed int n_slots, signed int max_thread_wait);
// thread_cache_init::cb$object
//
void cb$object(struct packet *);
// thread_cache_new
// file thread_cache.h line 61
void thread_cache_new(struct thread_cache *tc, struct packet *pkt);
// thread_cache_stop
// file thread_cache.h line 64
void thread_cache_stop(struct thread_cache *tc);
// thread_cache_thread
// file thread_cache.c line 81
static void * thread_cache_thread(void *x);
// thread_cond_timespec
// file time_mono.h line 18
struct timespec * thread_cond_timespec(struct timespec *tp, signed long int sec);
// thread_init
// file thread.h line 34
void thread_init(void);
// thread_new
// file thread.h line 35
signed int thread_new(void * (*th_func)(void *), void *data, unsigned long int *pt);
// thread_new::th_func$object
//
void * th_func$object(void *);
// thread_new_joinable
// file thread.h line 37
signed int thread_new_joinable(void * (*th_func)(void *), void *data, unsigned long int *pt);
// thread_new_joinable::th_func$object
//
void * th_func$object(void *);
// thread_new_wait
// file thread.h line 36
unsigned long int thread_new_wait(void * (*th_func)(void *), void *data, signed long int retry);
// thread_new_wait::th_func$object
//
void * th_func$object(void *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// time_mono
// file time_mono.h line 14
signed long int time_mono(void);
// time_mono_init
// file time_mono.h line 7
extern void time_mono_init(void);
// umount
// file /usr/include/x86_64-linux-gnu/sys/mount.h line 140
extern signed int umount(const char *);
// umount_all
// file autodir.c line 159
static signed int umount_all(void);
// umount_dir
// file autodir.c line 124
static signed int umount_dir(char *path);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// wait_extra_expirethread
// file expire.c line 158
static void wait_extra_expirethread(void);
// wait_pid
// file backup_child.c line 235
static signed int wait_pid(signed int pid, struct backup_pid *bp);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// wentry_free
// file workon.c line 88
static void wentry_free(struct wentry *we);
// wentry_malloc
// file workon.c line 65
static struct wentry * wentry_malloc(void);
// whash_resize
// file workon.c line 116
static void whash_resize(void);
// workon_cleanup
// file workon.c line 259
static void workon_cleanup(void);
// workon_init
// file workon.h line 27
void workon_init(void);
// workon_name
// file workon.h line 28
signed int workon_name(const char *name);
// workon_release
// file workon.h line 29
void workon_release(const char *name);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_all
// file miscfuncs.c line 223
signed int write_all(signed int fd, const char *buf, signed int buf_sz);
// write_pidfile
// file autodir.c line 570
static void write_pidfile(signed int pid);

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous$14
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous$0
{
  // __data
  struct anonymous$14 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct anonymous$19
{
  // hash
  struct bqueue **hash;
  // hash_used
  signed int hash_used;
  // hash_size
  signed int hash_size;
  // wait
  signed long int wait;
  // maxproc
  signed int maxproc;
  // lock
  union anonymous lock;
  // queue_watch
  unsigned long int queue_watch;
  // stop
  signed int stop;
  // start_t
  struct bqueue *start_t;
  // end_t
  struct bqueue *end_t;
  // cur_t
  struct bqueue *cur_t;
  // bchain_wait
  union anonymous$0 bchain_wait;
  // bchain
  struct bqueue *bchain;
};

struct anonymous$12
{
  // path
  char *path;
  // mounted
  signed int mounted;
  // k_pipe
  signed int k_pipe;
  // ioctlfd
  signed int ioctlfd;
  // time_out
  signed int time_out;
  // proto
  signed int proto;
  // dev
  unsigned long int dev;
};

struct anonymous$17
{
  // list
  struct lentry *list;
  // count
  signed int count;
  // lock
  union anonymous lock;
};

struct anonymous$1
{
  // handle
  struct lt__handle *handle;
  // mod_path
  char *mod_path;
  // mod_subopt
  char *mod_subopt;
};

struct anonymous$18
{
  // list
  struct mentry *list;
  // count
  signed int count;
};

struct anonymous$8
{
  // list
  struct packet *list;
  // count
  signed int count;
  // lock
  union anonymous lock;
};

struct anonymous$15
{
  // list
  struct wentry *list;
  // count
  signed int count;
  // lock
  union anonymous lock;
};

struct anonymous$2
{
  // __val
  unsigned long int __val[16l];
};

struct thread_cache
{
  // lock
  union anonymous lock;
  // stop
  signed int stop;
  // cb
  void (*cb)(struct packet *);
  // thread_count
  signed int thread_count;
  // pending_count
  signed int pending_count;
  // count_cond
  union anonymous$0 count_cond;
  // thread_waiting
  signed int thread_waiting;
  // max_thread_wait
  signed int max_thread_wait;
  // waiting_cond
  union anonymous$0 waiting_cond;
  // pkt_slots
  struct packet **pkt_slots;
  // n_slots
  signed int n_slots;
  // in
  signed int in;
  // out
  signed int out;
};

struct anonymous$16
{
  // name
  char name[256l];
  // module_name
  const char *module_name;
  // pid
  signed int pid;
  // pgrp
  signed int pgrp;
  // fg
  signed int fg;
  // pid_file
  char *pid_file;
  // shutdown
  signed int shutdown;
  // stop
  signed int stop;
  // sig_th
  unsigned long int sig_th;
  // multi_path
  signed int multi_path;
  // multi_prefix
  char multi_prefix;
  // expire_tc
  struct thread_cache expire_tc;
  // missing_tc
  struct thread_cache missing_tc;
};

struct opt_cb
{
  // opch
  char opch;
  // arg_str
  char *arg_str;
  // valid
  signed int valid;
  // req_arg
  signed int req_arg;
  // cb
  void (*cb)(char, char *, signed int);
};

struct cary
{
  // array
  char *array;
  // max
  signed int max;
  // cur
  signed int cur;
};

struct anonymous$13
{
  // count
  signed int count;
  // ostr
  char ostr[41l];
  // opt
  struct opt_cb opt[20l];
  // ca
  struct cary ca;
};

struct anonymous$4
{
  // count
  signed int count;
  // end
  struct barg *end;
  // start
  struct barg *start;
};

struct anonymous$20
{
  // count
  signed int count;
  // list
  struct bqueue *list;
  // lock
  union anonymous lock;
};

struct anonymous$11
{
  // msg_which
  signed int msg_which;
  // slog_init
  signed int slog_init;
  // verbose_log
  signed int verbose_log;
  // modname_prefix
  char *modname_prefix;
  // strerror_lock
  union anonymous strerror_lock;
};

struct anonymous$10
{
  // priority
  signed int priority;
  // tag
  const char *tag;
};

struct anonymous$5
{
  // lock
  union anonymous lock;
  // list
  struct backup_pid *list;
  // count
  signed int count;
};

struct anonymous$6
{
  // lock
  union anonymous lock;
  // pids1
  struct backup_pids *pids1;
  // pids2
  struct backup_pids *pids2;
};

struct anonymous$7
{
  // main
  unsigned long int main;
  // threads
  unsigned long int threads[10l];
  // lock
  union anonymous lock;
  // cur
  signed int cur;
  // stop
  signed int stop;
  // ioctlfd
  signed int ioctlfd;
  // shutdown
  signed int *shutdown;
};

union anonymous$9
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct autofs_packet_hdr
{
  // proto_version
  signed int proto_version;
  // type
  signed int type;
};

struct autofs_packet_expire
{
  // hdr
  struct autofs_packet_hdr hdr;
  // len
  signed int len;
  // name
  char name[256l];
};

struct autofs_packet_expire_multi
{
  // hdr
  struct autofs_packet_hdr hdr;
  // wait_queue_token
  unsigned int wait_queue_token;
  // len
  signed int len;
  // name
  char name[256l];
};

struct autofs_packet_missing
{
  // hdr
  struct autofs_packet_hdr hdr;
  // wait_queue_token
  unsigned int wait_queue_token;
  // len
  signed int len;
  // name
  char name[256l];
};

union autofs_packet_union
{
  // hdr
  struct autofs_packet_hdr hdr;
  // missing
  struct autofs_packet_missing missing;
  // expire
  struct autofs_packet_expire expire;
  // expire_multi
  struct autofs_packet_expire_multi expire_multi;
};

struct backup_pid
{
  // hash
  unsigned int hash;
  // name
  char name[256l];
  // pid
  signed int pid;
  // started
  signed long int started;
  // lock
  union anonymous lock;
  // waiting
  signed int waiting;
  // wait
  union anonymous$0 wait;
  // next
  struct backup_pid *next;
  // pids
  struct backup_pids *pids;
  // pids_idx
  signed int pids_idx;
  // kill
  signed int kill;
};

struct backup_pids
{
  // size
  signed int size;
  // count
  signed int count;
  // s
  struct backup_pid **s;
  // free_slot
  signed int free_slot;
  // in_use
  signed int in_use;
  // to_free
  struct backup_pid *to_free;
};

struct barg
{
  // arg
  char *arg;
  // type
  signed int type;
  // next
  struct barg *next;
};

struct bqueue
{
  // hash
  unsigned int hash;
  // dname
  char dname[256l];
  // dpath
  char dpath[4097l];
  // estamp
  signed long int estamp;
  // next
  struct bqueue *next;
  // prev
  struct bqueue *prev;
  // next_t
  struct bqueue *next_t;
  // prev_t
  struct bqueue *prev_t;
  // in_bchain
  signed int in_bchain;
  // bchain_next
  struct bqueue *bchain_next;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct lentry
{
  // name
  char name[256l];
  // path
  char path[4097l];
  // fd
  signed int fd;
  // hash
  unsigned int hash;
  // next
  struct lentry *next;
};

struct mentry
{
  // name
  char name[256l];
  // count
  signed int count;
  // hash
  unsigned int hash;
  // next
  struct mentry *next;
};

struct module_info
{
  // name
  const char *name;
  // protocol
  signed int protocol;
};

struct packet
{
  // ap
  union autofs_packet_union ap;
  // next
  struct packet *next;
  // tc
  struct thread_cache *tc;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct wentry
{
  // name
  char name[256l];
  // hash
  unsigned int hash;
  // in_use
  signed int in_use;
  // wait
  union anonymous wait;
  // next
  struct wentry *next;
};


// BQ
// file backup_queue.c line 99
static struct anonymous$19 BQ;
// autodir
// file autodir.c line 72
static struct anonymous$12 autodir;
// backup_life
// file backup.c line 43
static signed int backup_life = 0;
// backup_life$link1
// file backup_child.c line 46
static signed int backup_life$link1;
// backup_limit
// file backup.c line 41
static signed int backup_limit = 0;
// backup_monitor_th
// file backup_child.c line 44
static unsigned long int backup_monitor_th;
// backup_nokill
// file backup.c line 42
static signed int backup_nokill = 0;
// backup_path
// file backup.c line 37
static char *backup_path = ((char *)NULL);
// backup_wait2finish
// file backup.c line 40
static signed int backup_wait2finish = 0;
// backup_wait_before
// file backup.c line 39
static signed int backup_wait_before = 0;
// barg_list
// file backup_argv.c line 56
static struct anonymous$4 barg_list;
// bcache
// file backup_queue.c line 115
static struct anonymous$20 bcache;
// bcache$link1
// file backup_pid.c line 39
static struct anonymous$5 bcache$link1;
// clockid
// file time_mono.c line 34
signed int clockid = 0;
// cmn_attr
// file thread.c line 48
static union pthread_attr_t cmn_attr;
// common_cond_attr
// file thread.c line 52
union anonymous$9 common_cond_attr;
// common_mutex_attr
// file thread.c line 51
union anonymous$9 common_mutex_attr;
// do_backup
// file backup.c line 38
static signed int do_backup = 0;
// expire
// file expire.c line 48
static struct anonymous$7 expire;
// hash
// file backup_child.c line 40
static struct backup_pid **hash;
// hash_lock
// file workon.c line 58
static union anonymous hash_lock;
// hash_lock$link1
// file lockfile.c line 61
static union anonymous hash_lock$link1;
// hash_lock$link2
// file multipath.c line 63
static union anonymous hash_lock$link2;
// hash_lock$link3
// file backup_child.c line 43
static union anonymous hash_lock$link3;
// hash_size
// file backup_child.c line 41
static signed int hash_size;
// hash_used
// file backup_child.c line 42
static signed int hash_used;
// hostname
// file backup_argv.c line 58
static char hostname[65l];
// initialized
// file time_mono.c line 37
static signed int initialized = 0;
// join_attr
// file thread.c line 49
static union pthread_attr_t join_attr;
// lcache
// file lockfile.c line 58
static struct anonymous$17 lcache;
// lhash
// file lockfile.c line 60
static struct lentry **lhash;
// lhash_size
// file lockfile.c line 67
static signed int lhash_size;
// lhash_used
// file lockfile.c line 68
static signed int lhash_used;
// lockdir
// file lockfile.c line 63
static char *lockdir;
// lockfiles
// file lockfile.c line 62
static signed int lockfiles;
// lockstop
// file lockfile.c line 70
static signed int lockstop = 0;
// mcache
// file multipath.c line 58
static struct anonymous$18 mcache;
// mg
// file msg.c line 67
static struct anonymous$11 mg;
// mhash
// file multipath.c line 60
static struct mentry **mhash;
// mhash_size
// file multipath.c line 61
static signed int mhash_size;
// mhash_used
// file multipath.c line 62
static signed int mhash_used;
// mod_clean
// file module.h line 37
void (*mod_clean)(void);
// mod_dir
// file module.h line 35
void (*mod_dir)(char *, signed int, const char *);
// mod_dowork
// file module.h line 36
signed int (*mod_dowork)(const char *, const char *, char *, signed int);
// mod_init
// file module.h line 34
struct module_info * (*mod_init)(char *, const char *);
// modinfo
// file module.c line 49
static struct module_info *modinfo;
// module
// file module.c line 47
static struct anonymous$1 module;
// msgmap
// file msg.c line 48
static struct anonymous$10 msgmap[9l] = { { .priority=0, .tag="fatal" }, { .priority=0, .tag="emergency" }, { .priority=1, .tag="alert" }, { .priority=2, .tag="critical" }, { .priority=3, .tag="error" }, { .priority=4, .tag="warning" }, { .priority=5, .tag="notice" }, { .priority=6, .tag="info" }, { .priority=7, .tag="debug" } };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// opterr
// file /usr/include/getopt.h line 76
extern signed int opterr;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// options
// file options.c line 77
static struct anonymous$13 options;
// optopt
// file /usr/include/getopt.h line 80
extern signed int optopt;
// pcache
// file mpacket.c line 39
static struct anonymous$8 pcache;
// pid_holder
// file backup_pid.c line 117
static struct anonymous$6 pid_holder;
// pids1
// file backup_pid.c line 110
static struct backup_pids pids1;
// pids2
// file backup_pid.c line 111
static struct backup_pids pids2;
// priority
// file backup_fork.c line 41
static signed int priority;
// self
// file autodir.c line 91
static struct anonymous$16 self;
// spid
// file lockfile.c line 64
static char spid[128l];
// spid_len
// file lockfile.c line 65
static signed int spid_len;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stop
// file backup_child.c line 45
static signed int stop;
// wcache
// file workon.c line 53
static struct anonymous$15 wcache;
// whash
// file workon.c line 55
static struct wentry **whash;
// whash_size
// file workon.c line 56
static signed int whash_size;
// whash_used
// file workon.c line 57
static signed int whash_used;

// autodir_clean
// file autodir.c line 626
static void autodir_clean(void)
{
  mod_clean();
  if(!(self.sig_th == 0ul))
    pthread_cancel(self.sig_th);

  if(autodir.ioctlfd >= 0)
  {
    ioctl(autodir.ioctlfd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(0x93 << 0 + 8) | (unsigned int)(0x62 << 0) | (unsigned int)(0 << 0 + 8 + 8)), 0);
    close(autodir.ioctlfd);
  }

  if(autodir.k_pipe >= 0)
    close(autodir.k_pipe);

  signed int return_value_umount$1;
  if(!(autodir.mounted == 0))
  {
    return_value_umount$1=umount(autodir.path);
    if(!(return_value_umount$1 == 0))
      msglog(4 | 128, "autodir_clean: umount %s", autodir.path);

  }

  if(!(self.pid_file == ((char *)NULL)))
    unlink(self.pid_file);

}

// autodir_name
// file autodir.c line 650
char * autodir_name(void)
{
  return self.name;
}

// autodir_option_fg
// file autodir.c line 788
void autodir_option_fg(char ch, char *arg, signed int valid)
{
  self.fg = valid != 0 ? 1 : 0;
}

// autodir_option_multipath
// file autodir.c line 793
void autodir_option_multipath(char ch, char *arg, signed int valid)
{
  self.multi_path = valid != 0 ? 1 : 0;
}

// autodir_option_multiprefix
// file autodir.c line 800
void autodir_option_multiprefix(char ch, char *arg, signed int valid)
{
  if(valid == 0)
    self.multi_prefix = (char)46;

  else
  {
    if(!(arg[1l] == 0))
      msglog(0, "Invalid argument for multi prefix -%c option", ch);

    self.multi_prefix = *arg;
  }
}

// autodir_option_path
// file autodir.c line 762
void autodir_option_path(char ch, char *arg, signed int valid)
{
  if(valid == 0)
    msglog(0, "autofs directory option -%c missing", ch);

  signed int return_value_check_abs_path$1;
  return_value_check_abs_path$1=check_abs_path(arg);
  if(return_value_check_abs_path$1 == 0)
    msglog(0, "invalid argument for path -%c option", ch);

  autodir.path = arg;
}

// autodir_option_pidfile
// file autodir.c line 771
void autodir_option_pidfile(char ch, char *arg, signed int valid)
{
  signed int return_value_check_abs_path$1;
  if(valid == 0)
    self.pid_file = (char *)(void *)0;

  else
  {
    return_value_check_abs_path$1=check_abs_path(arg);
    if(return_value_check_abs_path$1 == 0)
      msglog(0, "invalid argument for pid file -%c option ", ch);

    else
      self.pid_file = arg;
  }
}

// autodir_option_timeout
// file autodir.c line 780
void autodir_option_timeout(char ch, char *arg, signed int valid)
{
  signed int return_value_string_to_number$1;
  if(valid == 0)
    autodir.time_out = 300;

  else
  {
    return_value_string_to_number$1=string_to_number(arg, &autodir.time_out);
    if(return_value_string_to_number$1 == 0)
      msglog(0, "invalid argument for timeout -%c option", ch);

  }
}

// autodir_setname
// file autodir.c line 94
static void autodir_setname(const char *name)
{
  signed int i = 0;
  signed int start = 0;
  self.name[(signed long int)0] = (char)0;
  i = 0;
  for( ; !(name[(signed long int)i] == 0); i = i + 1)
    if((signed int)name[(signed long int)i] == 47)
      start = i + 1;

  string_n_copy(self.name, name + (signed long int)start, (signed int)sizeof(char [256l]) /*256ul*/ );
}

// backarg_add
// file backup_argv.c line 66
static void backarg_add(char *arg)
{
  struct barg *tmp;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct barg) /*24ul*/ );
  tmp = (struct barg *)return_value_malloc$1;
  if(tmp == ((struct barg *)NULL))
    msglog(0, "backarg_add: malloc: could not allocate memory");

  tmp->arg = arg;
  char *return_value___builtin_strchr$2;
  return_value___builtin_strchr$2=__builtin_strchr(arg, 37);
  tmp->type = return_value___builtin_strchr$2 != ((char *)NULL) ? 2 : 1;
  tmp->next = (struct barg *)(void *)0;
  if(!(barg_list.end == ((struct barg *)NULL)))
  {
    barg_list.end->next = tmp;
    barg_list.end = tmp;
  }

  else
  {
    barg_list.end = tmp;
    barg_list.start = barg_list.end;
  }
  barg_list.count = barg_list.count + 1;
}

// backarg_clean
// file backup_argv.c line 203
static void backarg_clean(void)
{
  struct barg *bg;
  struct barg *tmp;
  bg = barg_list.start;
  while(!(bg == ((struct barg *)NULL)))
  {
    tmp = bg;
    bg = bg->next;
    free((void *)tmp);
  }
}

// backarg_expand
// file backup_argv.c line 92
static signed int backarg_expand(char *buf, const signed int len, const char *fmt, const char *dname, const char *dpath, const char *host, struct tm *tm)
{
  signed int i;
  signed int r = 1;
  signed int strf_expand = 0;
  signed int special = 0;
  char b[4353l];
  char c;
  struct cary ca;
  cary_init(&ca, b, (signed int)sizeof(char [4353l]) /*4353ul*/ );
  i = 0;
  do
  {
    c = fmt[(signed long int)i];
    if(r == 0 || c == 0)
      break;

    if(special == 0 && (signed int)c == 37)
      special = 1;

    else
      if(!(special == 0))
      {
        switch((signed int)c)
        {
          case 76:
          {
            r=cary_add_str(&ca, dpath);
            break;
          }
          case 78:
          {
            r=cary_add_str(&ca, dname);
            break;
          }
          case 75:
          {
            r=cary_add_str(&ca, host);
            break;
          }
          default:
          {
            cary_add(&ca, (char)37);
            r=cary_add(&ca, c);
            strf_expand = 1;
          }
        }
        special = 0;
      }

      else
        r=cary_add(&ca, c);
    i = i + 1;
  }
  while((_Bool)1);
  unsigned long int return_value_strftime$1;
  if(r == 0)
    return 0;

  else
    if(!(strf_expand == 0))
    {
      return_value_strftime$1=strftime(buf, (unsigned long int)len, b, tm);
      return return_value_strftime$1 != 0ul ? 1 : 0;
    }

    else
    {
      string_n_copy(buf, b, len);
      return 1;
    }
}

// backup_add
// file backup.h line 5
void backup_add(const char *name, const char *path)
{
  if(do_backup >= 1)
    backup_queue_add(name, path);

}

// backup_argv_get
// file backup_argv.h line 27
signed int backup_argv_get(const char *name, const char *path, char ***argv)
{
  char **av;
  char arg_buf[4353l];
  signed int i;
  signed int ret;
  struct tm tm;
  signed long int ct;
  struct barg *arg;
  ct=time((signed long int *)(void *)0);
  struct tm *return_value_localtime_r$1;
  return_value_localtime_r$1=localtime_r(&ct, &tm);
  if(return_value_localtime_r$1 == ((struct tm *)NULL))
  {
    fprintf(stderr, "backarg_get_argv: localtime_r error\n");
    return 0;
  }

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)(barg_list.count + 1));
    av = (char **)return_value_malloc$2;
    if(av == ((char **)NULL))
    {
      fprintf(stderr, "backarg_get_argv: malloc: could not allocate memory\n");
      return 0;
    }

    else
    {
      arg = barg_list.start;
      i = 0;
      for( ; !(i >= barg_list.count); i = i + 1)
      {
        if(arg->type == 1)
          av[(signed long int)i] = arg->arg;

        else
        {
          ret=backarg_expand(arg_buf, (const signed int)sizeof(char [4353l]) /*4353ul*/ , arg->arg, name, path, hostname, &tm);
          if(ret == 0)
          {
            fprintf(stderr, "backarg_get_argv: could not expand back args\n");
            return 0;
          }

          char *return_value___strdup$3;
          return_value___strdup$3=__strdup(arg_buf);
          av[(signed long int)i] = return_value___strdup$3;
          if(av[(signed long int)i] == ((char *)NULL))
          {
            fprintf(stderr, "backarg_get_argv: strdup: could not allocate memory\n");
            return 0;
          }

        }
        arg = arg->next;
      }
      av[(signed long int)barg_list.count] = (char *)(void *)0;
      *argv = av;
      return 1;
    }
  }
}

// backup_argv_init
// file backup_argv.h line 26
void backup_argv_init(char *bopt)
{
  char *arg;
  if(!(bopt == ((char *)NULL)))
  {
    signed int return_value_gethostname$1;
    return_value_gethostname$1=gethostname(hostname, sizeof(char [65l]) /*65ul*/ );
    if(!(return_value_gethostname$1 == 0))
      msglog(0 | 128, "backup_argv_init: gethostname");

    barg_list.start = (struct barg *)(void *)0;
    barg_list.end = barg_list.start;
    barg_list.count = 0;
    arg=strtok(bopt, " \f\n\r\t\v");
    while(!(arg == ((char *)NULL)))
    {
      backarg_add(arg);
      arg=strtok((char *)(void *)0, " \f\n\r\t\v");
    }
    signed int return_value_atexit$2;
    return_value_atexit$2=atexit(backarg_clean);
    if(!(return_value_atexit$2 == 0))
      msglog(0, "backup_argv_init: could not register cleanup method");

  }

}

// backup_child_add
// file backup_child.c line 109
static signed int backup_child_add(const char *name, signed int pid, signed long int started)
{
  unsigned int h;
  struct backup_pid **dptr;
  struct backup_pid *new_ent;
  struct backup_pid *ent;
  signed int tmp_statement_expression$1;
  if(!(pid >= 0))
    return 0;

  else
  {
    h=string_hash(name);
    started=time_mono();
    pthread_mutex_lock(&hash_lock$link3);
    do
    {
      dptr = &hash[(signed long int)(h % (unsigned int)hash_size)];
      for( ; !(*dptr == ((struct backup_pid *)NULL)); dptr = &(*dptr)->next)
        if((*dptr)->hash == h)
        {
          if(*name == (*dptr)->name[0l])
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$2;
            return_value___builtin_strcmp$2=__builtin_strcmp(name, (*dptr)->name);
            tmp_statement_expression$1 = return_value___builtin_strcmp$2;
            if(tmp_statement_expression$1 == 0)
              break;

          }

        }

    }
    while((_Bool)0);
    ent = *dptr;
    if(!(ent == ((struct backup_pid *)NULL)))
    {
      pthread_mutex_unlock(&hash_lock$link3);
      return 0;
    }

    else
    {
      new_ent=backup_pidmem_allocate();
      if(new_ent == ((struct backup_pid *)NULL))
      {
        pthread_mutex_unlock(&hash_lock$link3);
        msglog(2, "backup_child: could not allocate memory");
        return 0;
      }

      else
      {
        string_n_copy(new_ent->name, name, (signed int)sizeof(char [256l]) /*256ul*/ );
        new_ent->hash = h;
        new_ent->started = started;
        new_ent->pid = pid;
        new_ent->next = (struct backup_pid *)(void *)0;
        *dptr = new_ent;
        hash_used = hash_used + 1;
        pthread_mutex_unlock(&hash_lock$link3);
        return 1;
      }
    }
  }
}

// backup_child_count
// file backup_child.h line 8
signed int backup_child_count(void)
{
  signed int ret;
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&hash_lock$link3);
  if(!(return_value_pthread_mutex_trylock$1 == 0))
    return -1;

  else
  {
    ret = hash_used;
    pthread_mutex_unlock(&hash_lock$link3);
    return ret;
  }
}

// backup_child_init
// file backup_child.h line 4
void backup_child_init(signed int size, signed int blife)
{
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)size, sizeof(struct backup_pid *) /*8ul*/ );
  hash = (struct backup_pid **)return_value_calloc$1;
  if(hash == ((struct backup_pid **)NULL))
    msglog(0, "backup_child_init: could not allocate hash table");

  stop = 0;
  hash_used = 0;
  hash_size = size;
  pthread_mutex_init(&hash_lock$link3, &common_mutex_attr);
  backup_life$link1 = blife > 0 ? blife : 0;
  signed int return_value_thread_new_joinable$2;
  return_value_thread_new_joinable$2=thread_new_joinable(backup_monitor_thread, (void *)0, &backup_monitor_th);
  if(return_value_thread_new_joinable$2 == 0)
    msglog(0, "backup_child_init: could not start new thread");

}

// backup_child_kill
// file backup_child.h line 7
void backup_child_kill(const char *name)
{
  struct backup_pid *bp;
  signed int pid;
  pid=get_pid(name, &bp, 1);
  if(!(pid == 0))
  {
    backup_kill(pid, name);
    remove_pid(bp);
  }

}

// backup_child_start
// file backup_child.h line 5
void backup_child_start(const char *name, const char *path)
{
  signed int pid;
  pid=backup_fork_new(name, path);
  if(pid >= 1)
  {
    signed long int return_value_time_mono$1;
    return_value_time_mono$1=time_mono();
    signed int return_value_backup_child_add$2;
    return_value_backup_child_add$2=backup_child_add(name, pid, return_value_time_mono$1);
    if(return_value_backup_child_add$2 == 0)
      backup_kill(pid, name);

  }

}

// backup_child_stop
// file backup_child.h line 12
void backup_child_stop(void)
{
  stop = 1;
  pthread_join(backup_monitor_th, (void **)(void *)0);
  backup_signal_all();
  sleep((unsigned int)1);
  backup_kill_all();
}

// backup_child_stop_set
// file backup_child.h line 13
void backup_child_stop_set(void)
{
  stop = 1;
}

// backup_child_wait
// file backup_child.h line 6
void backup_child_wait(const char *name)
{
  struct backup_pid *bp;
  signed int pid;
  pid=get_pid(name, &bp, 0);
  if(!(pid == 0))
  {
    signed int return_value_backup_waitpid$1;
    return_value_backup_waitpid$1=backup_waitpid(pid, name, 0);
    if(!(return_value_backup_waitpid$1 >= 1))
    {
      pid=wait_pid(pid, bp);
      if(pid == 0)
        goto __CPROVER_DUMP_L4;

      backup_kill(pid, name);
    }

    remove_pid(bp);
  }


__CPROVER_DUMP_L4:
  ;
}

// backup_exec
// file backup_fork.c line 54
static void backup_exec(const char *name, const char *path)
{
  char **argv;
  reset_signals();
  setpriority(0, (unsigned int)0, priority);
  signed int return_value_backup_argv_get$1;
  return_value_backup_argv_get$1=backup_argv_get(name, path, &argv);
  if(return_value_backup_argv_get$1 == 0)
  {
    fprintf(stderr, "backup_exec: could not make argument vector");
    _exit(1);
  }

  signed int return_value_execv$4;
  return_value_execv$4=execv(argv[(signed long int)0], argv);
  if(!(return_value_execv$4 == 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    fprintf(stderr, "backup_exec: execv: %s", return_value_strerror$3);
    _exit(1);
  }

  _exit(1);
}

// backup_fast_kill
// file backup_fork.h line 8
void backup_fast_kill(signed int pid, const char *name)
{
  kill(-pid, 9);
  backup_waitpid(pid, name, 1);
}

// backup_fork_new
// file backup_fork.h line 4
signed int backup_fork_new(const char *name, const char *path)
{
  signed int pid;
  msglog(7, "starting backup for %s", name);
  pid=fork();
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(!(pid >= 0))
  {
    msglog(6 | 128, "fork: could not start backup for %s", name);
    return -1;
  }

  else
    if(pid == 0)
    {
      signed int return_value_setpgrp$3;
      return_value_setpgrp$3=setpgrp();
      if(return_value_setpgrp$3 == -1)
      {
        return_value___errno_location$1=__errno_location();
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        fprintf(stderr, "setpgrp: %s", return_value_strerror$2);
      }

      backup_exec(name, path);
    }

    else
      setpgid(pid, pid);
  return pid;
}

// backup_fork_option_pri
// file backup_fork.h line 10
void backup_fork_option_pri(char ch, char *arg, signed int valid)
{
  signed int pri;
  signed int return_value_string_to_number$1;
  if(valid == 0)
    priority = 30;

  else
  {
    return_value_string_to_number$1=string_to_number(arg, &pri);
    if(return_value_string_to_number$1 == 0)
      msglog(0, "invalid argument for -%c", ch);

    else
      if(pri >= 41 || !(pri >= 1))
        msglog(0, "invalid priority %d for -%c", pri, ch);

      else
        priority = pri - 21;
  }
}

// backup_init
// file backup.h line 4
void backup_init(void)
{
  if(!(do_backup == 0))
  {
    backup_argv_init(backup_path);
    backup_queue_init(backup_wait_before, backup_limit);
    backup_pid_init(backup_limit);
    backup_child_init(backup_limit, backup_life);
  }

}

// backup_kill
// file backup_fork.h line 6
void backup_kill(signed int pid, const char *name)
{
  signed int i;
  signed int return_value_backup_waitpid$1;
  return_value_backup_waitpid$1=backup_waitpid(pid, name, 0);
  if(return_value_backup_waitpid$1 == 0)
  {
    kill(-pid, 15);
    sleep((unsigned int)1);
    signed int return_value_backup_waitpid$2;
    return_value_backup_waitpid$2=backup_waitpid(pid, name, 0);
    if(return_value_backup_waitpid$2 == 0)
    {
      i = 0;
      for( ; !(i >= 3); i = i + 1)
      {
        kill(-pid, 9);
        sleep((unsigned int)1);
        signed int return_value_backup_waitpid$3;
        return_value_backup_waitpid$3=backup_waitpid(pid, name, 0);
        if(!(return_value_backup_waitpid$3 == 0))
          goto __CPROVER_DUMP_L6;

      }
      backup_waitpid(pid, name, 1);
    }

  }


__CPROVER_DUMP_L6:
  ;
}

// backup_kill_all
// file backup_child.c line 445
static void backup_kill_all(void)
{
  signed int i;
  struct backup_pid *bp;
  struct backup_pid **dptr;
  pthread_mutex_lock(&hash_lock$link3);
  i = 0;
  for( ; !(i >= hash_size); i = i + 1)
  {
    dptr = &hash[(signed long int)i];
    while(!(*dptr == ((struct backup_pid *)NULL)))
    {
      bp = *dptr;
      dptr = &bp->next;
      pthread_mutex_lock(&bp->lock);
      if(bp->pid >= 1)
      {
        backup_fast_kill(bp->pid, bp->name);
        bp->pid = 0;
        pthread_cond_broadcast(&bp->wait);
      }

      pthread_mutex_unlock(&bp->lock);
    }
  }
  pthread_mutex_unlock(&hash_lock$link3);
}

// backup_monitor_thread
// file backup_child.c line 260
static void * backup_monitor_thread(void *x)
{
  struct backup_pids *pids;
  signed int i = 0;
  signed int pid = 0;
  struct backup_pid *bp;
  signed long int now = (signed long int)0;
  sleep((unsigned int)1);
  _Bool tmp_if_expr$3;
  signed int return_value_backup_waitpid$2;
  while((_Bool)1)
  {
    pids=backup_pids_get();
    if(pids->count == 0)
    {
      backup_pids_unget(pids);
      if(!(stop == 0))
        pthread_exit((void *)0);

      sleep((unsigned int)2);
    }

    else
    {
      if(backup_life$link1 >= 1)
        now=time_mono();

      i = 0;
      for( ; !(i >= pids->size); i = i + 1)
      {
        if(!(stop == 0))
        {
          backup_pids_unget(pids);
          pthread_exit((void *)0);
        }

        bp = pids->s[(signed long int)i];
        if(!(bp == ((struct backup_pid *)NULL)))
        {
          if(bp->pid >= 1)
          {
            signed int return_value_pthread_mutex_trylock$1;
            return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&bp->lock);
            if(return_value_pthread_mutex_trylock$1 == 0)
            {
              pid = bp->pid;
              if(pid >= 1)
                bp->pid = 0;

              pthread_mutex_unlock(&bp->lock);
              if(pid >= 1)
              {
                if(backup_life$link1 >= 1)
                  tmp_if_expr$3 = now - bp->started > (signed long int)backup_life$link1 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$3 = (_Bool)0;
                if(tmp_if_expr$3)
                {
                  msglog(7, "backup timedout for %s", (const void *)bp->name);
                  backup_kill(pid, bp->name);
                }

                else
                {
                  return_value_backup_waitpid$2=backup_waitpid(pid, bp->name, 0);
                  if(!(return_value_backup_waitpid$2 >= 1))
                  {
                    pthread_mutex_lock(&bp->lock);
                    if(bp->kill == 0)
                    {
                      bp->pid = pid;
                      pthread_mutex_unlock(&bp->lock);
                      goto __CPROVER_DUMP_L14;
                    }

                    pthread_mutex_unlock(&bp->lock);
                    backup_kill(pid, bp->name);
                  }

                }
                remove_pid(bp);
              }

            }

          }

        }


      __CPROVER_DUMP_L14:
        ;
      }
      backup_pids_unget(pids);
      if(!(stop == 0))
        pthread_exit((void *)0);

      sleep((unsigned int)2);
    }
  }
}

// backup_option_life
// file backup.h line 15
void backup_option_life(char ch, char *arg, signed int valid)
{
  signed int life = 0;
  signed int return_value_string_to_number$1;
  if(valid == 0)
    goto __CPROVER_DUMP_L4;

  else
  {
    return_value_string_to_number$1=string_to_number(arg, &life);
    if(return_value_string_to_number$1 == 0)
      msglog(0, "invalid argument for -%c", ch);

    else
      backup_life = life;
  }

__CPROVER_DUMP_L4:
  ;
}

// backup_option_max_proc
// file backup.h line 14
void backup_option_max_proc(char ch, char *arg, signed int valid)
{
  signed int return_value_string_to_number$1;
  if(valid == 0)
    backup_limit = 200;

  else
  {
    return_value_string_to_number$1=string_to_number(arg, &backup_limit);
    if(backup_limit == 0 || return_value_string_to_number$1 == 0)
      msglog(0, "invalid argument for -%c", ch);

  }
}

// backup_option_nokill
// file backup.h line 13
void backup_option_nokill(char ch, char *arg, signed int valid)
{
  backup_nokill = valid != 0 ? 1 : 0;
}

// backup_option_path
// file backup.h line 10
void backup_option_path(char ch, char *arg, signed int valid)
{
  if(!(valid == 0))
  {
    if(!((signed int)*arg == 47))
      msglog(0, "absolute path expected for option -%c", ch);

    backup_path = arg;
    do_backup = 1;
  }

}

// backup_option_wait
// file backup.h line 11
void backup_option_wait(char ch, char *arg, signed int valid)
{
  signed int wt;
  signed int return_value_string_to_number$1;
  if(valid == 0)
    backup_wait_before = 0;

  else
  {
    return_value_string_to_number$1=string_to_number(arg, &wt);
    if(return_value_string_to_number$1 == 0)
      msglog(0, "invalid argument for -%c", ch);

    else
      if(wt >= 86401)
        msglog(0, "argument exceeding upper limit for -%c", ch);

      else
        backup_wait_before = wt;
  }
}

// backup_option_wait2finish
// file backup.h line 12
void backup_option_wait2finish(char ch, char *arg, signed int valid)
{
  backup_wait2finish = valid != 0 ? 1 : 0;
}

// backup_pid_init
// file backup_pid.h line 34
void backup_pid_init(signed int size)
{
  pthread_mutex_init(&bcache$link1.lock, &common_mutex_attr);
  bcache$link1.list = ((struct backup_pid *)NULL);
  bcache$link1.count = 0;
  size = size + size / 4;
  pthread_mutex_init(&pid_holder.lock, &common_mutex_attr);
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)size, sizeof(struct backup_pid) /*392ul*/ );
  pids1.s = (struct backup_pid **)return_value_calloc$1;
  pids1.free_slot = 0;
  pids1.in_use = 0;
  pids1.size = size;
  pids1.count = 0;
  pids1.to_free = ((struct backup_pid *)NULL);
  pid_holder.pids1 = &pids1;
  void *return_value_calloc$2;
  return_value_calloc$2=calloc((unsigned long int)size, sizeof(struct backup_pid) /*392ul*/ );
  pids2.s = (struct backup_pid **)return_value_calloc$2;
  pids2.free_slot = 0;
  pids2.in_use = 0;
  pids2.size = size;
  pids2.count = 0;
  pids2.to_free = ((struct backup_pid *)NULL);
  pid_holder.pids2 = &pids2;
}

// backup_pidmem_allocate
// file backup_pid.h line 38
struct backup_pid * backup_pidmem_allocate(void)
{
  struct backup_pid *bp;
  signed int pids_idx;
  struct backup_pids *pids = ((struct backup_pids *)NULL);
  bp=entry_allocate$link1();
  bp->pid = -1;
  pthread_mutex_init(&bp->lock, &common_mutex_attr);
  pthread_cond_init(&bp->wait, &common_cond_attr);
  pthread_mutex_lock(&pid_holder.lock);
  pids = pid_holder.pids1;
  pids_idx=free_slot_get(pids);
  if(!(pids_idx >= 0))
  {
    pthread_mutex_unlock(&pid_holder.lock);
    entry_free$link1(bp);
    return (struct backup_pid *)(void *)0;
  }

  else
  {
    bp->pids = pids;
    bp->pids_idx = pids_idx;
    pids->s[(signed long int)pids_idx] = bp;
    pids->count = pids->count + 1;
    pthread_mutex_unlock(&pid_holder.lock);
    return bp;
  }
}

// backup_pidmem_free
// file backup_pid.h line 39
void backup_pidmem_free(struct backup_pid *bp)
{
  pthread_mutex_lock(&pid_holder.lock);
  if(!(bp->pids->in_use == 0))
  {
    bp->next = bp->pids->to_free;
    bp->pids->to_free = bp;
    pthread_mutex_unlock(&pid_holder.lock);
  }

  else
  {
    bp->pids->s[(signed long int)bp->pids_idx] = ((struct backup_pid *)NULL);
    bp->pids->count = bp->pids->count - 1;
    pthread_mutex_unlock(&pid_holder.lock);
    bp->next = (struct backup_pid *)(void *)0;
    pthread_mutex_destroy(&bp->lock);
    pthread_cond_destroy(&bp->wait);
    entry_free$link1(bp);
  }
}

// backup_pids_get
// file backup_pid.h line 35
struct backup_pids * backup_pids_get(void)
{
  struct backup_pids *pids;
  pthread_mutex_lock(&pid_holder.lock);
  if(!(pid_holder.pids2->in_use == 0))
  {
    pthread_mutex_unlock(&pid_holder.lock);
    return (struct backup_pids *)(void *)0;
  }

  else
  {
    pid_holder.pids1->in_use = 1;
    pids = pid_holder.pids1;
    pid_holder.pids1 = pid_holder.pids2;
    pid_holder.pids2 = pids;
    pthread_mutex_unlock(&pid_holder.lock);
    return pids;
  }
}

// backup_pids_unget
// file backup_pid.h line 36
void backup_pids_unget(struct backup_pids *pids)
{
  struct backup_pid *to_free = ((struct backup_pid *)NULL);
  struct backup_pid *bp;
  signed int free_slot = -1;
  pthread_mutex_lock(&pid_holder.lock);
  to_free = pids->to_free;
  pids->to_free = (struct backup_pid *)(void *)0;
  bp = to_free;
  for( ; !(bp == ((struct backup_pid *)NULL)); bp = bp->next)
  {
    pids->s[(signed long int)bp->pids_idx] = ((struct backup_pid *)NULL);
    pids->count = pids->count - 1;
    if(!(free_slot >= 0))
      free_slot = bp->pids_idx;

  }
  pids->in_use = 0;
  if(!(free_slot == -1))
    pids->free_slot = free_slot;

  pthread_mutex_unlock(&pid_holder.lock);
  bp = to_free;
  for( ; !(bp == ((struct backup_pid *)NULL)); bp = bp->next)
  {
    pthread_mutex_destroy(&bp->lock);
    pthread_cond_destroy(&bp->wait);
  }
  entry_free$link1(to_free);
}

// backup_queue_add
// file backup_queue.h line 6
void backup_queue_add(const char *name, const char *path)
{
  signed int r;
  struct bqueue *bc;
  if(BQ.stop == 0)
  {
    bc=entry_allocate();
    if(bc == ((struct bqueue *)NULL))
      msglog(2, "backup_queue_add: could not get free entry");

    else
    {
      string_n_copy(bc->dname, name, (signed int)sizeof(char [256l]) /*256ul*/ );
      string_n_copy(bc->dpath, path, (signed int)sizeof(char [4097l]) /*4097ul*/ );
      bc->estamp=time_mono();
      pthread_mutex_lock(&BQ.lock);
      r=queue_entry_add(bc);
      pthread_mutex_unlock(&BQ.lock);
      if(r == 0)
        entry_free(bc);

    }
  }

}

// backup_queue_init
// file backup_queue.h line 4
void backup_queue_init(signed int bwait, signed int maxproc)
{
  memset((void *)&BQ, 0, sizeof(struct anonymous$19) /*168ul*/ );
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)13, sizeof(struct bqueue *) /*8ul*/ );
  BQ.hash = (struct bqueue **)return_value_calloc$1;
  if(BQ.hash == ((struct bqueue **)NULL))
    msglog(0, "backup_queue_init: could not allocate memory");

  BQ.hash_size = 13;
  BQ.wait = (signed long int)bwait;
  BQ.maxproc = maxproc;
  pthread_mutex_init(&BQ.lock, &common_mutex_attr);
  pthread_cond_init(&BQ.bchain_wait, &common_cond_attr);
  pthread_mutex_init(&bcache.lock, &common_mutex_attr);
  bcache.list = (struct bqueue *)(void *)0;
  bcache.count = 0;
  signed int return_value_thread_new_joinable$2;
  return_value_thread_new_joinable$2=thread_new_joinable(queue_watch_thread, (void *)0, &BQ.queue_watch);
  if(return_value_thread_new_joinable$2 == 0)
    msglog(0, "backup_queue_init: could not start new thread");

}

// backup_queue_remove
// file backup_queue.h line 5
signed int backup_queue_remove(const char *name)
{
  struct bqueue *bq;
  unsigned int backup_queue_remove$$1$$hash;
  backup_queue_remove$$1$$hash=string_hash(name);
  pthread_mutex_lock(&BQ.lock);
  bq=queue_entry_locate(name, backup_queue_remove$$1$$hash, (signed int)(backup_queue_remove$$1$$hash % (unsigned int)BQ.hash_size));
  if(!(bq == ((struct bqueue *)NULL)))
  {
    if(!(bq->in_bchain == 0))
    {
      pthread_cond_wait(&BQ.bchain_wait, &BQ.lock);
      pthread_mutex_unlock(&BQ.lock);
      return 0;
    }

    queue_entry_release(bq);
    pthread_mutex_unlock(&BQ.lock);
    entry_free(bq);
    return 1;
  }

  else
  {
    pthread_mutex_unlock(&BQ.lock);
    return 0;
  }
}

// backup_queue_stop
// file backup_queue.h line 8
void backup_queue_stop(void)
{
  BQ.stop = 1;
  pthread_join(BQ.queue_watch, (void **)(void *)0);
}

// backup_queue_stop_set
// file backup_queue.h line 7
void backup_queue_stop_set(void)
{
  BQ.stop = 1;
}

// backup_remove
// file backup.h line 6
void backup_remove(const char *name, signed int force)
{
  if(backup_nokill == 0 && do_backup >= 1)
  {
    backup_queue_remove(name);
    if(force == 0 && !(backup_wait2finish == 0))
      backup_child_wait(name);

    else
      backup_child_kill(name);
  }

}

// backup_signal_all
// file backup_child.c line 424
static void backup_signal_all(void)
{
  signed int i;
  struct backup_pid *bp;
  struct backup_pid **dptr;
  pthread_mutex_lock(&hash_lock$link3);
  i = 0;
  for( ; !(i >= hash_size); i = i + 1)
  {
    dptr = &hash[(signed long int)i];
    while(!(*dptr == ((struct backup_pid *)NULL)))
    {
      bp = *dptr;
      dptr = &bp->next;
      pthread_mutex_lock(&bp->lock);
      if(bp->pid >= 1)
        backup_soft_signal(bp->pid);

      pthread_mutex_unlock(&bp->lock);
    }
  }
  pthread_mutex_unlock(&hash_lock$link3);
}

// backup_soft_signal
// file backup_fork.h line 7
void backup_soft_signal(signed int pid)
{
  kill(-pid, 15);
}

// backup_stop
// file backup.h line 7
void backup_stop(void)
{
  if(!(do_backup == 0))
  {
    backup_stop_set();
    backup_queue_stop();
    backup_child_stop();
  }

}

// backup_stop_set
// file backup.h line 8
void backup_stop_set(void)
{
  if(!(do_backup == 0))
  {
    do_backup = -1;
    backup_child_stop_set();
    backup_queue_stop_set();
  }

}

// backup_waitpid
// file backup_fork.h line 5
signed int backup_waitpid(signed int pid, const char *name, signed int block)
{
  signed int status;
  signed int backup_waitpid$$1$$options = block != 0 ? 0 : 1;
  signed int wrv;
  signed int *return_value___errno_location$1;
  do
  {

  again:
    ;
    wrv=waitpid(pid, &status, backup_waitpid$$1$$options);
    if(wrv == -1)
    {
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 4)
      {
        msglog(4, "waitpid: EINTR received. trying again...");
        sleep((unsigned int)1);
        goto again;
      }

    }

    if(wrv == -1)
    {
      msglog(4 | 128, "waitpid %ld for %s", (signed long int)pid, name);
      return 1;
      break;
    }

    if(wrv == 0)
    {
      return 0;
      break;
    }

    if(!(wrv >= 1))
      break;

    /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous$3
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
    ;
    if((0x7f & status) == 0)
    {
      msglog(7, "backup process %ld for %s exited with %d", (signed long int)pid, name, (((union anonymous$3){ .__in=status }).__i & 0xff00) >> 8);
      break;
    }

    if((signed int)((127 & (signed char)status) + 1) >> 1 >= 1)
    {
      msglog(7, "backup process %ld for %s caught signal %d", (signed long int)pid, name, ((union anonymous$3){ .__in=status }).__i & 0x7f);
      break;
    }

    msglog(6, "backup process %ld for %s stopped", (signed long int)pid, name);
  }
  while((_Bool)1);
  return 1;
}

// bchain_process
// file backup_queue.c line 338
static void bchain_process(void)
{
  struct bqueue *bc;
  struct bqueue *next;
  bc = BQ.bchain;
  for( ; !(bc == ((struct bqueue *)NULL)); bc = bc->bchain_next)
  {
    backup_child_start(bc->dname, bc->dpath);
    mono_nanosleep((signed long int)100000000);
  }
  pthread_mutex_lock(&BQ.lock);
  bc = BQ.bchain;
  for( ; !(bc == ((struct bqueue *)NULL)); bc = bc->bchain_next)
    queue_entry_release(bc);
  pthread_mutex_unlock(&BQ.lock);
  pthread_cond_broadcast(&BQ.bchain_wait);
  bc = BQ.bchain;
  for( ; !(bc == ((struct bqueue *)NULL)); bc = next)
  {
    next = bc->bchain_next;
    entry_free(bc);
  }
}

// become_daemon
// file autodir.c line 537
static void become_daemon(void)
{
  signed int pid;
  signed int nullfd;
  chdir("/");
  pid=fork();
  if(pid >= 1)
    exit(0);

  else
    if(!(pid >= 0))
      msglog(0 | 128, "become_daemon: fork");

  setsid();
  msg_console_off();
  msg_syslog_on();
  nullfd=open("/dev/null", 02);
  _Bool tmp_if_expr$3;
  signed int return_value_dup2$2;
  _Bool tmp_if_expr$5;
  signed int return_value_dup2$4;
  if(!(nullfd >= 0))
    msglog(4 | 128, "become_daemon: open /dev/null");

  else
  {
    signed int return_value_dup2$1;
    return_value_dup2$1=dup2(nullfd, 0);
    if(!(return_value_dup2$1 >= 0))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_dup2$2=dup2(nullfd, 1);
      tmp_if_expr$3 = return_value_dup2$2 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_dup2$4=dup2(nullfd, 2);
      tmp_if_expr$5 = return_value_dup2$4 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      msglog(4 | 128, "become_daemon: dup2");

    close(nullfd);
  }
}

// cary_add
// file miscfuncs.c line 103
signed int cary_add(struct cary *c, char ch)
{
  signed int tmp_post$1;
  if(c->cur == c->max + -1)
    return 0;

  else
  {
    tmp_post$1 = c->cur;
    c->cur = c->cur + 1;
    c->array[(signed long int)tmp_post$1] = ch;
    c->array[(signed long int)c->cur] = (char)0;
    return 1;
  }
}

// cary_add_str
// file miscfuncs.c line 114
signed int cary_add_str(struct cary *ca, const char *str)
{
  signed int i = 0;
  signed int tmp_post$1;
  signed int return_value_cary_add$2;
  if(str == ((const char *)NULL))
    return 1;

  else
  {
    while(!(str[(signed long int)i] == 0))
    {
      tmp_post$1 = i;
      i = i + 1;
      return_value_cary_add$2=cary_add(ca, str[(signed long int)tmp_post$1]);
      if(return_value_cary_add$2 == 0)
        break;

    }
    return str[(signed long int)i] != 0 ? 0 : 1;
  }
}

// cary_init
// file miscfuncs.c line 95
void cary_init(struct cary *c, char *buf, signed int max)
{
  c->array = buf;
  c->array[(signed long int)0] = (char)0;
  c->max = max;
  c->cur = 0;
}

// check_abs_path
// file miscfuncs.h line 37
signed int check_abs_path(char *path)
{
  signed int i = 0;
  signed int j = 0;
  signed int sl = 0;
  char c;
  _Bool tmp_if_expr$1;
  if(path == ((char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)path[(signed long int)0] != 47 ? (_Bool)1 : (_Bool)0;
  signed int tmp_post$2;
  signed int tmp_post$3;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    do
    {
      c = path[(signed long int)i];
      if(c == 0)
        break;

      if((signed int)c == 47)
      {
        if(!(sl == 0))
        {
          i = i + 1;
          continue;
        }

        sl = 1;
      }

      else
        sl = 0;
      tmp_post$2 = j;
      j = j + 1;
      tmp_post$3 = i;
      i = i + 1;
      path[(signed long int)tmp_post$2] = path[(signed long int)tmp_post$3];
    }
    while((_Bool)1);
    if((signed int)path[(signed long int)(j + -1)] == 47)
      path[(signed long int)(j - 1)] = (char)0;

    else
      path[(signed long int)j] = (char)0;
    return 1;
  }
}

// condattr_init
// file thread.c line 96
static void condattr_init(void)
{
  const char *myname = "condattr_init";
  time_mono_init();
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1=pthread_condattr_init(&common_cond_attr);
  if(!(*return_value___errno_location$1 == 0))
    msglog(0 | 128, "%s: pthread_condattr_init", myname);

  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2=pthread_condattr_setpshared(&common_cond_attr, 0);
  if(!(*return_value___errno_location$2 == 0))
    msglog(0 | 128, "%s: pthread_condattr_setpshared: PTHREAD_PROCESS_PRIVATE", myname);

  signed int *return_value___errno_location$3;
  return_value___errno_location$3=__errno_location();
  *return_value___errno_location$3=pthread_condattr_setclock(&common_cond_attr, clockid);
  if(!(*return_value___errno_location$3 == 0))
    msglog(0 | 128, "%s: pthread_condattr_setclock", myname);

}

// create_dir
// file miscfuncs.h line 42
signed int create_dir(const char *dir, unsigned int mode)
{
  char path[4097l];
  struct stat st;
  char *p;
  _Bool tmp_if_expr$2;
  const unsigned short int **return_value___ctype_b_loc$1;
  if(dir == ((const char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    tmp_if_expr$2 = !(((signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)dir[(signed long int)0]] & (signed int)(unsigned short int)32768) != 0) ? (_Bool)1 : (_Bool)0;
  }
  char *tmp_if_expr$3;
  signed int *return_value___errno_location$6;
  signed int *return_value___errno_location$8;
  char *return_value___builtin_strchr$5;
  signed int *return_value___errno_location$10;
  if(tmp_if_expr$2)
  {
    msglog(4, "create_dir: invalid dir name %s", dir);
    return 0;
  }

  else
  {
    string_n_copy(path, dir, (signed int)sizeof(char [4097l]) /*4097ul*/ );
    if((signed int)path[0l] == 47)
      tmp_if_expr$3 = path + (signed long int)1;

    else
      tmp_if_expr$3 = path;
    p = tmp_if_expr$3;
    char *return_value___builtin_strchr$4;
    return_value___builtin_strchr$4=__builtin_strchr(p, 47);
    p = return_value___builtin_strchr$4;
    for( ; !(p == ((char *)NULL)); p = return_value___builtin_strchr$5)
    {
      *p = (char)0;
      signed int return_value_lstat$7;
      return_value_lstat$7=lstat$link1(path, &st);
      if(return_value_lstat$7 == 0)
      {
        if((61440u & st.st_mode) == 16384u)
        {
          *p = (char)47;
          goto __CPROVER_DUMP_L12;
        }

        else
        {
          msglog(4, "create_dir: path %s exists but not directory", (const void *)path);
          return 0;
        }
      }

      else
      {
        return_value___errno_location$6=__errno_location();
        if(!(*return_value___errno_location$6 == 2))
        {
          msglog(4 | 128, "create_dir: lstat %s", (const void *)path);
          return 0;
        }

      }
      signed int return_value_mkdir$9;
      return_value_mkdir$9=mkdir(path, mode);
      if(return_value_mkdir$9 == -1)
      {
        return_value___errno_location$8=__errno_location();
        if(!(*return_value___errno_location$8 == 17))
        {
          msglog(4 | 128, "create_dir: mkdir %s", p);
          return 0;
        }

      }

      *p = (char)47;

    __CPROVER_DUMP_L12:
      ;
      return_value___builtin_strchr$5=__builtin_strchr(p + (signed long int)1, 47);
    }
    signed int return_value_mkdir$11;
    return_value_mkdir$11=mkdir(path, mode);
    if(return_value_mkdir$11 == -1)
    {
      return_value___errno_location$10=__errno_location();
      if(*return_value___errno_location$10 == 17)
        goto __CPROVER_DUMP_L14;

      msglog(4 | 128, "create_dir: mkdir %s", p);
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L14:
      ;
      return 1;
    }
  }
}

// dropcap_drop
// file dropcap.h line 26
void dropcap_drop(void)
{
  struct _cap_struct *ct;
  const char *caps = "cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_sys_admin+ep cap_dac_read_search+epi";
  ct=cap_from_text(caps);
  if(ct == ((struct _cap_struct *)NULL))
    msglog(0 | 128, "dropcap_drop: cap_from_text");

  msglog(7, "giving up unnecessary root privileges");
  signed int return_value_cap_set_proc$1;
  return_value_cap_set_proc$1=cap_set_proc(ct);
  if(!(return_value_cap_set_proc$1 == 0))
  {
    msglog(4 | 128, "dropcap_drop: cap_set_proc");
    msglog(5, "could not drop root privileges");
  }

  cap_free((void *)ct);
}

// entry_allocate
// file backup_queue.c line 142
static struct bqueue * entry_allocate(void)
{
  struct bqueue *tmp;
  if(bcache.count >= 1)
  {
    pthread_mutex_lock(&bcache.lock);
    if(!(bcache.count >= 1))
    {
      pthread_mutex_unlock(&bcache.lock);
      goto dalloc;
    }

    tmp = bcache.list;
    bcache.list = bcache.list->next;
    bcache.count = bcache.count - 1;
    pthread_mutex_unlock(&bcache.lock);
    memset((void *)tmp, 0, sizeof(struct bqueue) /*4416ul*/ );
    return tmp;
  }

  else
  {

  dalloc:
    ;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct bqueue) /*4416ul*/ );
    tmp = (struct bqueue *)return_value_malloc$1;
    if(!(tmp == ((struct bqueue *)NULL)))
      memset((void *)tmp, 0, sizeof(struct bqueue) /*4416ul*/ );

    return tmp;
  }
}

// entry_allocate$link1
// file backup_pid.c line 66
static struct backup_pid * entry_allocate$link1(void)
{
  struct backup_pid *tmp$link1;
  static struct backup_pid *list = ((struct backup_pid *)NULL);
  if(!(list == ((struct backup_pid *)NULL)))
  {
    tmp$link1 = list;
    list = list->next;
    memset((void *)tmp$link1, 0, sizeof(struct backup_pid) /*392ul*/ );
    return tmp$link1;
  }

  else
    if(bcache$link1.count >= 1)
    {
      pthread_mutex_lock(&bcache$link1.lock);
      if(!(bcache$link1.count >= 1))
      {
        pthread_mutex_unlock(&bcache$link1.lock);
        goto dalloc;
      }

      tmp$link1 = bcache$link1.list;
      list = bcache$link1.list->next;
      bcache$link1.list = (struct backup_pid *)(void *)0;
      bcache$link1.count = 0;
      pthread_mutex_unlock(&bcache$link1.lock);
      memset((void *)tmp$link1, 0, sizeof(struct backup_pid) /*392ul*/ );
      return tmp$link1;
    }

    else
    {

    dalloc:
      ;
      void *return_value_malloc$1$link1;
      return_value_malloc$1$link1=malloc(sizeof(struct backup_pid) /*392ul*/ );
      tmp$link1 = (struct backup_pid *)return_value_malloc$1$link1;
      if(!(tmp$link1 == ((struct backup_pid *)NULL)))
        memset((void *)tmp$link1, 0, sizeof(struct backup_pid) /*392ul*/ );

      return tmp$link1;
    }
}

// entry_free
// file backup_queue.c line 117
static void entry_free(struct bqueue *bq)
{
  struct bqueue *tmp;
  if(!(bcache.count >= 50))
  {
    pthread_mutex_lock(&bcache.lock);
    if(bcache.count >= 50)
    {
      pthread_mutex_unlock(&bcache.lock);
      free((void *)bq);
      goto __CPROVER_DUMP_L3;
    }

    tmp = bcache.list;
    bcache.list = bq;
    bq->next = tmp;
    bcache.count = bcache.count + 1;
    pthread_mutex_unlock(&bcache.lock);
  }

  else
    free((void *)bq);

__CPROVER_DUMP_L3:
  ;
}

// entry_free$link1
// file backup_pid.c line 41
static void entry_free$link1(struct backup_pid *to_free)
{
  struct backup_pid *next;
  if(!(bcache$link1.count >= 50))
  {
    pthread_mutex_lock(&bcache$link1.lock);
    for( ; !(to_free == ((struct backup_pid *)NULL)) && !(bcache$link1.count >= 50); bcache$link1.count = bcache$link1.count + 1)
    {
      next = to_free->next;
      to_free->next = bcache$link1.list;
      bcache$link1.list = to_free;
      to_free = next;
    }
    pthread_mutex_unlock(&bcache$link1.lock);
  }

  for( ; !(to_free == ((struct backup_pid *)NULL)); to_free = next)
  {
    next = to_free->next;
    free((void *)to_free);
  }
}

// exclusive_lock
// file lockfile.c line 278
static signed int exclusive_lock(signed int fd, const char *path)
{
  struct flock lk;
  lk.l_type = (signed short int)1;
  lk.l_start = (signed long int)0;
  lk.l_whence = (signed short int)0;
  lk.l_len = (signed long int)0;
  signed int return_value_fcntl$3;
  return_value_fcntl$3=fcntl(fd, 6, &lk);
  signed int *return_value___errno_location$1;
  if(return_value_fcntl$3 == -1)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(!(*return_value___errno_location$2 == 11))
    {
      return_value___errno_location$1=__errno_location();
      if(!(*return_value___errno_location$1 == 13))
        msglog(4 | 128, "fcntl F_SETLK: %s", path);

    }

    return 0;
  }

  return 1;
}

// expire_start
// file expire.h line 26
void expire_start(signed int time_out, signed int ioctlfd, signed int *shutdown)
{
  signed int i;
  expire.stop = 0;
  expire.cur = 1;
  expire.ioctlfd = ioctlfd;
  expire.shutdown = shutdown;
  pthread_mutex_init(&expire.lock, &common_mutex_attr);
  if(!(time_out == 0))
  {
    i = 0;
    for( ; !(i >= 10); i = i + 1)
      expire.threads[(signed long int)i] = (unsigned long int)0;
    signed int return_value_thread_new_joinable$1;
    return_value_thread_new_joinable$1=thread_new_joinable(main_expire_mounts, (void *)0, &expire.main);
    if(return_value_thread_new_joinable$1 == 0)
      msglog(0, "could not start expire thread");

  }

}

// expire_stop
// file expire.h line 27
void expire_stop(void)
{
  pthread_join(expire.main, (void **)(void *)0);
}

// expire_stop_set
// file expire.h line 28
void expire_stop_set(void)
{
  pthread_mutex_lock(&expire.lock);
  expire.stop = 1;
  pthread_mutex_unlock(&expire.lock);
}

// extra_expire_mounts
// file expire.c line 69
static void * extra_expire_mounts(void *x)
{
  signed int i;
  signed int r;
  signed int life = 5;
  signed int j;
  unsigned long int *ptr = (unsigned long int *)x;
  pthread_setcanceltype(1, (signed int *)(void *)0);
  if(*ptr == 0ul)
  {
    pthread_mutex_lock(&expire.lock);
    pthread_mutex_unlock(&expire.lock);
  }

  j = 0;
  for( ; !(j >= 100); j = j + 1)
  {
    i = 0;
    r = 0;
    for( ; r == 0; i = i + 1)
      r=ioctl(expire.ioctlfd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(0x93 << 0 + 8) | (unsigned int)(0x66 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, (void *)0);
    life = i < 2 ? life - 1 : 5;
    if(life == 0)
    {
      pthread_mutex_lock(&expire.lock);
      if(!(expire.stop == 0))
      {
        pthread_mutex_unlock(&expire.lock);
        return (void *)0;
      }

      pthread_detach(*ptr);
      *ptr = (unsigned long int)0;
      pthread_mutex_unlock(&expire.lock);
      return (void *)0;
    }

    sleep((unsigned int)1);
  }
  pthread_mutex_lock(&expire.lock);
  if(!(expire.stop == 0))
  {
    pthread_mutex_unlock(&expire.lock);
    return (void *)0;
  }

  else
  {
    pthread_detach(*ptr);
    *ptr = (unsigned long int)0;
    pthread_mutex_unlock(&expire.lock);
    return (void *)0;
  }
}

// free_hash
// file lockfile.c line 471
static void free_hash(void)
{
  signed int i;
  struct lentry *le;
  struct lentry *tmp;
  i = 0;
  signed int return_value_unlink$1;
  for( ; !(i >= lhash_size); i = i + 1)
    if(!(lhash[(signed long int)i] == ((struct lentry *)NULL)))
    {
      le = lhash[(signed long int)i];
      while(!(le == ((struct lentry *)NULL)))
      {
        if(le->fd == -1)
          break;

        tmp = le;
        le = le->next;
        signed int return_value_exclusive_lock$2;
        return_value_exclusive_lock$2=exclusive_lock(tmp->fd, tmp->path);
        if(!(return_value_exclusive_lock$2 == 0))
        {
          return_value_unlink$1=unlink(tmp->path);
          if(return_value_unlink$1 == -1)
            msglog(4 | 128, "unlink %s", (const void *)tmp->path);

        }

        close(tmp->fd);
        lentry_free(tmp);
      }
    }

  free((void *)lhash);
}

// free_slot_get
// file backup_pid.c line 195
static signed int free_slot_get(struct backup_pids *pids)
{
  signed int start;
  signed int i;
  start = pids->free_slot;
  i = start;
  while((_Bool)1)
  {
    if(pids->s[(signed long int)i] == ((struct backup_pid *)NULL))
    {
      pids->free_slot = pids->free_slot + 1;
      pids->free_slot = pids->free_slot % pids->size;
      return i;
    }

    i = (i + 1) % pids->size;
    if(i == start)
      break;

  }
  return -1;
}

// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat(signed int __fd, struct stat *__statbuf)
{
  signed int return_value___fxstat$1;
  return_value___fxstat$1=__fxstat(1, __fd, __statbuf);
  return return_value___fxstat$1;
}

// fstat$link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat$link1(signed int __fd$link1, struct stat *__statbuf$link1)
{
  signed int return_value___fxstat$1$link1;
  return_value___fxstat$1$link1=__fxstat(1, __fd$link1, __statbuf$link1);
  return return_value___fxstat$1$link1;
}

// get_cache
// file thread_cache.c line 40
static struct packet * get_cache(struct thread_cache *tc)
{
  struct packet *pkt;
  signed int return_value_pthread_mutex_trylock$1;
  do
  {
    return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&tc->lock);
    if(return_value_pthread_mutex_trylock$1 == 0)
      break;

    sleep((unsigned int)1);
  }
  while((_Bool)1);
  pkt = tc->pkt_slots[(signed long int)tc->out];
  _Bool tmp_if_expr$2;
  for( ; (_Bool)1; pkt = tc->pkt_slots[(signed long int)tc->out])
  {
    if(!(pkt == ((struct packet *)NULL)))
    {
      tc->pkt_slots[(signed long int)tc->out] = (struct packet *)(void *)0;
      tc->out = (tc->out + 1) % tc->n_slots;
      pthread_mutex_unlock(&tc->lock);
      return pkt;
    }

    if(!(tc->stop == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = tc->thread_waiting >= tc->max_thread_wait ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      tc->thread_count = tc->thread_count - 1;
      if(!(tc->stop == 0))
      {
        if(tc->thread_count == 0)
          pthread_cond_signal(&tc->count_cond);

      }

      pthread_mutex_unlock(&tc->lock);
      pthread_exit((void *)0);
    }

    tc->thread_waiting = tc->thread_waiting + 1;
    pthread_cond_wait(&tc->waiting_cond, &tc->lock);
    tc->thread_waiting = tc->thread_waiting - 1;
  }
}

// get_pid
// file backup_child.c line 150
static signed int get_pid(const char *name, struct backup_pid **id, signed int mark_kill)
{
  unsigned int h;
  struct backup_pid **dptr;
  struct backup_pid *bp;
  signed int pid;
  h=string_hash(name);
  pthread_mutex_lock(&hash_lock$link3);
  signed int tmp_statement_expression$1;
  do
  {
    dptr = &hash[(signed long int)(h % (unsigned int)hash_size)];
    for( ; !(*dptr == ((struct backup_pid *)NULL)); dptr = &(*dptr)->next)
      if((*dptr)->hash == h)
      {
        if(*name == (*dptr)->name[0l])
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp$2;
          return_value___builtin_strcmp$2=__builtin_strcmp(name, (*dptr)->name);
          tmp_statement_expression$1 = return_value___builtin_strcmp$2;
          if(tmp_statement_expression$1 == 0)
            break;

        }

      }

  }
  while((_Bool)0);
  bp = *dptr;
  if(!(bp == ((struct backup_pid *)NULL)))
  {
    pthread_mutex_lock(&bp->lock);
    pthread_mutex_unlock(&hash_lock$link3);
    pid = bp->pid;
    if(pid >= 1)
    {
      bp->pid = 0;
      pthread_mutex_unlock(&bp->lock);
      *id = bp;
      return pid;
    }

    if(!(mark_kill == 0))
      bp->kill = 1;

    bp->waiting = bp->waiting + 1;
    pthread_cond_wait(&bp->wait, &bp->lock);
    bp->waiting = bp->waiting - 1;
    if(bp->waiting == 0)
    {
      pthread_mutex_unlock(&bp->lock);
      backup_pidmem_free(bp);
      return 0;
    }

    pthread_mutex_unlock(&bp->lock);
    return 0;
  }

  else
  {
    pthread_mutex_unlock(&hash_lock$link3);
    return 0;
  }
}

// handle_events
// file autodir.c line 497
static void handle_events(signed int fd)
{
  struct packet *pkt;
  union autofs_packet_union *autopkt;
  while((_Bool)1)
  {
    pkt=packet_allocate();
    if(pkt == ((struct packet *)NULL))
    {
      msglog(3, "handle_events: could not get free packet");
      sleep((unsigned int)3);
    }

    else
    {
      autopkt = &pkt->ap;
      signed int return_value_poll_read$1;
      return_value_poll_read$1=poll_read(autodir.k_pipe, (char *)autopkt, (signed int)sizeof(union autofs_packet_union) /*272ul*/ );
      if(!(return_value_poll_read$1 == 1))
        goto __CPROVER_DUMP_L10;

      if(!(autopkt->hdr.proto_version == 4))
      {
        msglog(2, "autofs protocol '%d' not supported", autopkt->hdr.proto_version);
        goto __CPROVER_DUMP_L10;
      }

      if(autopkt->hdr.type == 0)
        thread_cache_new(&self.missing_tc, pkt);

      else
        if(autopkt->hdr.type == 2)
          thread_cache_new(&self.expire_tc, pkt);

        else
        {
          msglog(2, "handle_events: unexpected autofs packet type %d", autopkt->hdr.type);
          goto __CPROVER_DUMP_L10;
        }
    }
  }

__CPROVER_DUMP_L10:
  ;
}

// handle_expire
// file autodir.c line 430
static void handle_expire(struct packet *pkt)
{
  signed int len;
  signed int r;
  char name[256l];
  char *n;
  char path[4097l];
  struct autofs_packet_expire_multi *exppkt;
  unsigned int wqt;
  exppkt = &pkt->ap.expire_multi;
  wqt = exppkt->wait_queue_token;
  _Bool tmp_if_expr$1;
  if(exppkt->len >= 256)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = exppkt->len < 1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = exppkt->name[(signed long int)exppkt->len] != 0 ? (_Bool)1 : (_Bool)0;
  char *tmp_if_expr$4;
  if(tmp_if_expr$2)
  {
    send_fail(wqt);
    packet_free(pkt);
  }

  else
  {
    string_n_copy(name, exppkt->name, (signed int)sizeof(char [256l]) /*256ul*/ );
    len = exppkt->len;
    packet_free(pkt);
    string_safe(name, 32);
    signed int return_value_workon_name$3;
    return_value_workon_name$3=workon_name(name);
    if(return_value_workon_name$3 == 0)
      send_ready(wqt);

    else
    {
      snprintf(path, sizeof(char [4097l]) /*4097ul*/ , "%s/%s", autodir.path, (const void *)name);
      msglog(7, "unmounting %s", (const void *)path);
      r=umount_dir(path);
      if(r == 1)
      {
        mod_dir(path, (signed int)sizeof(char [4097l]) /*4097ul*/ , name);
        lockfile_remove(name);
        if(!(self.multi_path == 0))
        {
          if(self.multi_prefix == name[0l])
            tmp_if_expr$4 = name + (signed long int)1;

          else
            tmp_if_expr$4 = name;
          n = tmp_if_expr$4;
          signed int return_value_multipath_dec$5;
          return_value_multipath_dec$5=multipath_dec(n);
          if(return_value_multipath_dec$5 == 0)
          {
            if(self.stop == 0)
              backup_add(n, path);

          }

        }

        else
          if(self.stop == 0)
            backup_add(name, path);

        send_ready(wqt);
      }

      else
        if(r == 2)
          send_ready(wqt);

        else
          send_fail(wqt);
      workon_release(name);
      goto __CPROVER_DUMP_L15;
    }
  }

__CPROVER_DUMP_L15:
  ;
}

// handle_missing
// file autodir.c line 301
static void handle_missing(struct packet *pkt)
{
  signed int len;
  char mname[256l];
  char *name = mname;
  char vpath[4097l];
  char rpath[4097l];
  struct stat st;
  unsigned int wqt;
  struct autofs_packet_missing *pmis = &pkt->ap.missing;
  wqt = pmis->wait_queue_token;
  _Bool tmp_if_expr$1;
  if(pmis->len >= 256)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = pmis->len < 1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = pmis->name[(signed long int)pmis->len] != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_workon_name$4;
  signed int *return_value___errno_location$6;
  signed int return_value_mkdir$8;
  signed int return_value_multipath_inc$12;
  if(tmp_if_expr$2)
  {
    send_fail(wqt);
    packet_free(pkt);
  }

  else
  {
    string_n_copy(mname, pmis->name, (signed int)sizeof(char [256l]) /*256ul*/ );
    len = pmis->len;
    packet_free(pkt);
    if(!(self.stop == 0))
      missing_exit((char *)(void *)0, (char *)(void *)0, wqt, 0);

    else
    {
      string_safe(mname, 32);
      if(!(self.multi_path == 0))
      {
        if(self.multi_prefix == mname[0l])
          name = name + 1l;

      }

      if(*name == 0)
      {
        msglog(6, "invalid directory '%s' requested", (const void *)mname);
        missing_exit((char *)(void *)0, (char *)(void *)0, wqt, 0);
      }

      else
      {
        signed int return_value_workon_name$3;
        return_value_workon_name$3=workon_name(mname);
        if(return_value_workon_name$3 == 0)
          missing_exit((char *)(void *)0, (char *)(void *)0, wqt, 0);

        else
        {
          backup_remove(name, (signed int)(name != mname));
          if(!(mname == name))
          {
            return_value_workon_name$4=workon_name(name);
            if(!(return_value_workon_name$4 == 0))
              goto __CPROVER_DUMP_L10;

            missing_exit(mname, (char *)(void *)0, wqt, 0);
          }

          else
          {

          __CPROVER_DUMP_L10:
            ;
            snprintf(vpath, sizeof(char [4097l]) /*4097ul*/ , "%s/%s", autodir.path, (const void *)mname);
            signed int *return_value___errno_location$5;
            return_value___errno_location$5=__errno_location();
            *return_value___errno_location$5 = 0;
            signed int return_value_lstat$7;
            return_value_lstat$7=lstat(vpath, &st);
            if(!(return_value_lstat$7 == 0))
            {
              return_value___errno_location$6=__errno_location();
              if(*return_value___errno_location$6 == 2)
                goto __CPROVER_DUMP_L11;

              msglog(4 | 128, "handle_missing: lstat %s", (const void *)vpath);
              missing_exit(mname, name, wqt, 0);
            }

            else
            {

            __CPROVER_DUMP_L11:
              ;
              signed int *return_value___errno_location$9;
              return_value___errno_location$9=__errno_location();
              if(*return_value___errno_location$9 == 0)
              {
                if(!((61440u & st.st_mode) == 16384u))
                {
                  msglog(2, "handle_missing: unexpected file type %s", (const void *)vpath);
                  missing_exit(mname, name, wqt, 0);
                  goto __CPROVER_DUMP_L20;
                }

                if(!(autodir.dev == st.st_dev))
                {
                  missing_exit(mname, name, wqt, 1);
                  goto __CPROVER_DUMP_L20;
                }

              }

              else
              {
                return_value_mkdir$8=mkdir(vpath, (unsigned int)0700);
                if(!(return_value_mkdir$8 == 0))
                {
                  msglog(4 | 128, "handle_missing: mkdir %s", (const void *)vpath);
                  missing_exit(mname, name, wqt, 0);
                  goto __CPROVER_DUMP_L20;
                }

              }
              signed int return_value_lockfile_create$10;
              return_value_lockfile_create$10=lockfile_create(mname);
              if(return_value_lockfile_create$10 == 0)
              {
                msglog(4, "handle_missing: could not get lock file for %s", (const void *)mname);
                rmdir(vpath);
                missing_exit(mname, name, wqt, 0);
              }

              else
              {
                signed int return_value;
                return_value=mod_dowork(name, autodir.path, rpath, (signed int)sizeof(char [4097l]) /*4097ul*/ );
                if(return_value == 0)
                {
                  msglog(2, "module %s failed on %s", self.module_name, name);
                  rmdir(vpath);
                  lockfile_remove(mname);
                  missing_exit(mname, name, wqt, 0);
                }

                else
                {
                  msglog(7, "mounting %s on %s", (const void *)rpath, (const void *)vpath);
                  signed int return_value_mount$11;
                  return_value_mount$11=mount(rpath, vpath, (const char *)(void *)0, (unsigned long int)4096, (void *)0);
                  if(!(return_value_mount$11 == 0))
                  {
                    msglog(4 | 128, "handle_missing: mount %s", (const void *)rpath);
                    rmdir(vpath);
                    lockfile_remove(mname);
                    missing_exit(mname, name, wqt, 0);
                  }

                  else
                    if(!(self.multi_path == 0))
                    {
                      return_value_multipath_inc$12=multipath_inc(name);
                      umount(vpath);
                      rmdir(vpath);
                      lockfile_remove(mname);
                      missing_exit(mname, name, wqt, 0);
                    }

                    else
                      missing_exit(mname, name, wqt, 1);
                }
              }
            }
          }
        }
      }
    }
  }

__CPROVER_DUMP_L20:
  ;
}

// hash_resize
// file backup_queue.c line 200
static void hash_resize(void)
{
  signed int new_size;
  signed int old_size = BQ.hash_size;
  struct bqueue **new_hash;
  struct bqueue **dptr;
  struct bqueue **h = BQ.hash;
  struct bqueue *entry;
  struct bqueue *next;
  new_size = BQ.hash_size * 2;
  new_size = new_size | 1;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)new_size, sizeof(struct bqueue *) /*8ul*/ );
  new_hash = (struct bqueue **)return_value_calloc$1;
  signed int tmp_post$2;
  struct bqueue **tmp_post$3;
  if(!(new_hash == ((struct bqueue **)NULL)))
  {
    do
    {
      tmp_post$2 = old_size;
      old_size = old_size - 1;
      if(!(tmp_post$2 >= 1))
        break;

      tmp_post$3 = h;
      h = h + 1l;
      entry = *tmp_post$3;
      for( ; !(entry == ((struct bqueue *)NULL)); entry = next)
      {
        next = entry->next;
        dptr = &new_hash[(signed long int)(entry->hash % (unsigned int)new_size)];
        if(!(*dptr == ((struct bqueue *)NULL)))
        {
          entry->next = *dptr;
          (*dptr)->prev = entry;
        }

        else
          entry->next = (struct bqueue *)(void *)0;
        *dptr = entry;
        entry->prev = (struct bqueue *)(void *)0;
      }
    }
    while((_Bool)1);
    BQ.hash_size = new_size;
    free((void *)BQ.hash);
    BQ.hash = new_hash;
  }

}

// lentry_free
// file lockfile.c line 100
static void lentry_free(struct lentry *le)
{
  struct lentry *tmp;
  if(!(le == ((struct lentry *)NULL)))
  {
    if(!(lcache.count >= 50))
    {
      pthread_mutex_lock(&lcache.lock);
      if(lcache.count >= 50)
      {
        pthread_mutex_unlock(&lcache.lock);
        free((void *)le);
        goto __CPROVER_DUMP_L5;
      }

      tmp = lcache.list;
      lcache.list = le;
      le->next = tmp;
      lcache.count = lcache.count + 1;
      pthread_mutex_unlock(&lcache.lock);
      goto __CPROVER_DUMP_L5;
    }

    else
      free((void *)le);
  }


__CPROVER_DUMP_L5:
  ;
}

// lentry_malloc
// file lockfile.c line 77
static struct lentry * lentry_malloc(void)
{
  struct lentry *ent;
  if(lcache.count >= 1)
  {
    pthread_mutex_lock(&lcache.lock);
    if(!(lcache.count >= 1))
    {
      pthread_mutex_unlock(&lcache.lock);
      goto dyn_alloc;
    }

    ent = lcache.list;
    lcache.list = lcache.list->next;
    lcache.count = lcache.count - 1;
    pthread_mutex_unlock(&lcache.lock);
    return ent;
  }

  else
  {

  dyn_alloc:
    ;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct lentry) /*4376ul*/ );
    return (struct lentry *)return_value_malloc$1;
  }
}

// lhash_resize
// file lockfile.c line 129
static void lhash_resize(void)
{
  signed int new_size;
  signed int old_size = lhash_size;
  struct lentry **new_lhash;
  struct lentry **dptr;
  struct lentry **h = lhash;
  struct lentry *lentry;
  struct lentry *next;
  new_size = lhash_size * 2;
  new_size = new_size | 1;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)new_size, sizeof(struct lentry *) /*8ul*/ );
  new_lhash = (struct lentry **)return_value_calloc$1;
  signed int tmp_post$2;
  struct lentry **tmp_post$3;
  if(!(new_lhash == ((struct lentry **)NULL)))
  {
    do
    {
      tmp_post$2 = old_size;
      old_size = old_size - 1;
      if(!(tmp_post$2 >= 1))
        break;

      tmp_post$3 = h;
      h = h + 1l;
      lentry = *tmp_post$3;
      for( ; !(lentry == ((struct lentry *)NULL)); lentry = next)
      {
        next = lentry->next;
        dptr = &new_lhash[(signed long int)(lentry->hash % (unsigned int)new_size)];
        lentry->next = *dptr;
        *dptr = lentry;
      }
    }
    while((_Bool)1);
    lhash_size = new_size;
    free((void *)lhash);
    lhash = new_lhash;
  }

}

// lockfile_add2hash
// file lockfile.c line 183
static struct lentry * lockfile_add2hash(const char *name, const char *path, signed int *exist)
{
  unsigned int lockfile_add2hash$$1$$hash;
  signed int key;
  struct lentry *ent;
  struct lentry **dptr;
  *exist = 0;
  ent=lentry_malloc();
  signed int tmp_statement_expression$1;
  if(ent == ((struct lentry *)NULL))
  {
    msglog(2, "lockfile_add2hash: could not allocate memory");
    return (struct lentry *)(void *)0;
  }

  else
  {
    lockfile_add2hash$$1$$hash=string_hash(name);
    key = (signed int)(lockfile_add2hash$$1$$hash % (unsigned int)lhash_size);
    string_n_copy(ent->name, name, (signed int)sizeof(char [256l]) /*256ul*/ );
    string_n_copy(ent->path, path, (signed int)sizeof(char [4097l]) /*4097ul*/ );
    ent->fd = -1;
    ent->hash = lockfile_add2hash$$1$$hash;
    ent->next = (struct lentry *)(void *)0;
    pthread_mutex_lock(&hash_lock$link1);
    do
    {
      dptr = &lhash[(signed long int)(lockfile_add2hash$$1$$hash % (unsigned int)lhash_size)];
      for( ; !(*dptr == ((struct lentry *)NULL)); dptr = &(*dptr)->next)
        if((*dptr)->hash == lockfile_add2hash$$1$$hash)
        {
          if(*name == (*dptr)->name[0l])
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$2;
            return_value___builtin_strcmp$2=__builtin_strcmp(name, (*dptr)->name);
            tmp_statement_expression$1 = return_value___builtin_strcmp$2;
            if(tmp_statement_expression$1 == 0)
              break;

          }

        }

    }
    while((_Bool)0);
    if(!(*dptr == ((struct lentry *)NULL)))
    {
      if(!((*dptr)->fd == -1))
        *exist = 1;

      pthread_mutex_unlock(&hash_lock$link1);
      if(*exist == 0)
        msglog(2, "lockfile_add2hash: Invalid state: %s", name);

      lentry_free(ent);
      return (struct lentry *)(void *)0;
    }

    else
    {
      *dptr = ent;
      lhash_used = lhash_used + 1;
      if(!(lhash_size >= lhash_used))
        lhash_resize();

      pthread_mutex_unlock(&hash_lock$link1);
      return ent;
    }
  }
}

// lockfile_clean
// file lockfile.c line 537
static void lockfile_clean(void)
{
  if(!(lockdir == ((char *)NULL)))
    free((void *)lockdir);

  lockfile_hash_clean();
}

// lockfile_create
// file lockfile.h line 28
signed int lockfile_create(const char *name)
{
  signed int fd = -1;
  signed int i;
  signed int exist;
  char path[4097l];
  struct stat st;
  struct lentry *le;
  _Bool tmp_if_expr$1;
  if(lockfiles == 0)
    return 1;

  else
  {
    if(name == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = !(*name != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      msglog(4, "lockfile_create: invalid name");
      return 0;
    }

    else
    {
      snprintf(path, sizeof(char [4097l]) /*4097ul*/ , "%s/%s.lock", lockdir, name);
      le=lockfile_add2hash(name, path, &exist);
      if(le == ((struct lentry *)NULL))
        return exist != 0 ? 1 : 0;

      else
      {
        i = 0;
        for( ; !(i >= 10); i = i + 1)
        {
          fd=open(path, 02 | 0100, 0644);
          if(fd == -1)
          {
            msglog(4 | 128, "open %s", (const void *)path);
            lockfile_unhash(name, 1);
            return 0;
          }

          signed int return_value_fcntl$2;
          return_value_fcntl$2=fcntl(fd, 2, 1);
          if(return_value_fcntl$2 == -1)
            msglog(4 | 128, "lockfile_create: fcntl FD_CLOEXEC %s", (const void *)path);

          signed int return_value_shared_lock$3;
          return_value_shared_lock$3=shared_lock(fd, path);
          if(return_value_shared_lock$3 == 0)
          {
            lockfile_unhash(name, 1);
            close(fd);
            return 0;
          }

          signed int return_value_fstat$4;
          return_value_fstat$4=fstat$link1(fd, &st);
          if(!(return_value_fstat$4 == 0))
          {
            lockfile_unhash(name, 1);
            close(fd);
            msglog(4 | 128, "fstat %s", (const void *)path);
            return 0;
          }

          if(!(st.st_nlink == 0ul))
            break;

          close(fd);
        }
        if(i >= 10)
        {
          lockfile_unhash(name, 1);
          msglog(6, "Giving up on dead file %s", (const void *)path);
          return 0;
        }

        else
        {
          signed int return_value_write_all$5;
          return_value_write_all$5=write_all(fd, spid, spid_len);
          if(return_value_write_all$5 == 0)
          {
            msglog(6, "could not write pid %s to lock file %s", (const void *)spid, (const void *)path);
            lockfile_unhash(name, 1);
            close(fd);
            return 0;
          }

          else
          {
            le->fd = fd;
            return 1;
          }
        }
      }
    }
  }
}

// lockfile_hash_clean
// file lockfile.c line 496
static void lockfile_hash_clean(void)
{
  struct lentry *le;
  struct lentry *tmp;
  pthread_mutex_destroy(&hash_lock$link1);
  if(!(lhash == ((struct lentry **)NULL)))
    free_hash();

  pthread_mutex_destroy(&lcache.lock);
  le = lcache.list;
  while(!(le == ((struct lentry *)NULL)))
  {
    tmp = le;
    le = le->next;
    free((void *)tmp);
  }
}

// lockfile_hash_init
// file lockfile.c line 518
static void lockfile_hash_init(void)
{
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)13, sizeof(struct lentry *) /*8ul*/ );
  lhash = (struct lentry **)return_value_calloc$1;
  if(lhash == ((struct lentry **)NULL))
    msglog(0, "lockfile_hash_init: could not allocate hash table");

  lhash_used = 0;
  lhash_size = 13;
  pthread_mutex_init(&hash_lock$link1, &common_mutex_attr);
  pthread_mutex_init(&lcache.lock, &common_mutex_attr);
  lcache.list = (struct lentry *)(void *)0;
  lcache.count = 0;
}

// lockfile_init
// file lockfile.h line 32
void lockfile_init(signed int pid, const char *mod_name)
{
  signed long int lpid = (signed long int)pid;
  char ldir[4097l];
  if(!(lockfiles == 0))
  {
    spid_len=snprintf(spid, sizeof(char [128l]) /*128ul*/ , "%ld \n", lpid);
    if(spid_len == -1 || (unsigned long int)spid_len >= sizeof(char [128l]) /*128ul*/ )
      msglog(0, "lockfile_init: overflow for pid buffer");

    if(lockdir == ((char *)NULL))
    {
      snprintf(ldir, sizeof(char [4097l]) /*4097ul*/ , "%s/%s", (const void *)"/var/lock", mod_name);
      msglog(6, "using default lock dir '%s'", (const void *)ldir);
      char *return_value___strdup$1;
      return_value___strdup$1=__strdup(ldir);
      lockdir = return_value___strdup$1;
      if(lockdir == ((char *)NULL))
        msglog(0, "lockfile_init: could not allocate memory");

    }

    signed int return_value_create_dir$2;
    return_value_create_dir$2=create_dir(lockdir, (unsigned int)0755);
    if(return_value_create_dir$2 == 0)
      msglog(0, "could not create lock dir %s", lockdir);

    lockfile_hash_init();
    signed int return_value_atexit$3;
    return_value_atexit$3=atexit(lockfile_clean);
    if(!(return_value_atexit$3 == 0))
    {
      lockfile_clean();
      msglog(0, "lockfile_init: could not reigster cleanup method");
    }

  }

}

// lockfile_option_lockdir
// file lockfile.h line 30
void lockfile_option_lockdir(char ch, char *arg, signed int valid)
{
  signed int return_value_check_abs_path$2;
  if(valid == 0)
    lockdir = (char *)(void *)0;

  else
  {
    return_value_check_abs_path$2=check_abs_path(arg);
    if(return_value_check_abs_path$2 == 0)
      msglog(0, "invalid argument for path -%c option", ch);

    else
    {
      char *return_value___strdup$1;
      return_value___strdup$1=__strdup(arg);
      lockdir = return_value___strdup$1;
      if(lockdir == ((char *)NULL))
        msglog(0, "lockfile_option_lockdir: could not allocate memeory");

    }
  }
}

// lockfile_option_lockfiles
// file lockfile.h line 31
void lockfile_option_lockfiles(char ch, char *arg, signed int valid)
{
  lockfiles = valid != 0 ? 1 : 0;
}

// lockfile_remove
// file lockfile.h line 29
void lockfile_remove(const char *name)
{
  struct lentry *le;
  _Bool tmp_if_expr$1;
  signed int return_value_unlink$2;
  if(!(lockfiles == 0))
  {
    if(name == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = !(*name != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      msglog(4, "lockfile_remove: invalid name");

    else
    {
      le=lockfile_unhash(name, 0);
      if(le == ((struct lentry *)NULL))
        msglog(2, "could not remove lock file for %s", name);

      else
      {
        signed int return_value_exclusive_lock$3;
        return_value_exclusive_lock$3=exclusive_lock(le->fd, le->path);
        if(!(return_value_exclusive_lock$3 == 0))
        {
          return_value_unlink$2=unlink(le->path);
          if(return_value_unlink$2 == -1)
            msglog(4 | 128, "unlink %s", (const void *)le->path);

        }

        close(le->fd);
        lentry_free(le);
      }
    }
  }

}

// lockfile_sleep
// file lockfile.c line 303
static signed int lockfile_sleep(signed int n)
{
  signed int i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    if(!(lockstop == 0))
      return 0;

    sleep((unsigned int)3);
  }
  return 1;
}

// lockfile_stop_set
// file lockfile.h line 33
void lockfile_stop_set(void)
{
  lockstop = 1;
}

// lockfile_unhash
// file lockfile.c line 239
static struct lentry * lockfile_unhash(const char *name, signed int force)
{
  unsigned int lockfile_unhash$$1$$hash;
  lockfile_unhash$$1$$hash=string_hash(name);
  struct lentry **dptr;
  struct lentry *ent;
  pthread_mutex_lock(&hash_lock$link1);
  signed int tmp_statement_expression$1;
  do
  {
    dptr = &lhash[(signed long int)(lockfile_unhash$$1$$hash % (unsigned int)lhash_size)];
    for( ; !(*dptr == ((struct lentry *)NULL)); dptr = &(*dptr)->next)
      if((*dptr)->hash == lockfile_unhash$$1$$hash)
      {
        if(*name == (*dptr)->name[0l])
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp$2;
          return_value___builtin_strcmp$2=__builtin_strcmp(name, (*dptr)->name);
          tmp_statement_expression$1 = return_value___builtin_strcmp$2;
          if(tmp_statement_expression$1 == 0)
            break;

        }

      }

  }
  while((_Bool)0);
  ent = *dptr;
  if(ent == ((struct lentry *)NULL))
  {
    pthread_mutex_unlock(&hash_lock$link1);
    msglog(2, "lockfile_unhash: entry for %s does not exist", name);
    return (struct lentry *)(void *)0;
  }

  else
  {
    lhash_used = lhash_used - 1;
    if(ent->fd == -1)
    {
      if(!(force == 0))
        goto __CPROVER_DUMP_L6;

      pthread_mutex_unlock(&hash_lock$link1);
      msglog(2, "lockfile_unhash: Invalid state for %s", name);
      return (struct lentry *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      *dptr = ent->next;
      pthread_mutex_unlock(&hash_lock$link1);
      if(!(force == 0))
      {
        lentry_free(ent);
        return (struct lentry *)(void *)0;
      }

      else
        return ent;
    }
  }
}

// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 459
static inline signed int lstat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___lxstat$1;
  return_value___lxstat$1=__lxstat(1, __path, __statbuf);
  return return_value___lxstat$1;
}

// lstat$link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 459
static inline signed int lstat$link1(const char *__path$link1, struct stat *__statbuf$link1)
{
  signed int return_value___lxstat$1$link1;
  return_value___lxstat$1$link1=__lxstat(1, __path$link1, __statbuf$link1);
  return return_value___lxstat$1$link1;
}

// main
// file autodir.c line 655
signed int main(signed int argc, char **argv)
{
  unsigned long int timeout;
  autodir_setname(argv[(signed long int)0]);
  msg_init();
  msg_console_on();
  unsigned int return_value_geteuid$1;
  return_value_geteuid$1=geteuid();
  if(!(return_value_geteuid$1 == 0u))
    msglog(0, "this program must be run by root");

  dropcap_drop();
  signal_block();
  option_init(argc, argv);
  module_load(autodir.path);
  self.module_name=module_name();
  msg_modname_prefix(self.module_name);
  thread_init();
  packet_init();
  workon_init();
  time_mono_init();
  if(!(self.multi_path == 0))
    multipath_init();

  if(!(self.fg == 0))
    setpgrp();

  else
    become_daemon();
  self.pid=getpid();
  self.pgrp=getpgrp();
  self.shutdown = 0;
  self.stop = 0;
  self.sig_th = (unsigned long int)0;
  backup_init();
  lockfile_init(self.pid, self.module_name);
  thread_cache_init(&self.expire_tc, handle_expire, 100, 10);
  thread_cache_init(&self.missing_tc, handle_missing, 1000, 30);
  write_pidfile(self.pid);
  autodir.ioctlfd = -1;
  autodir.k_pipe = autodir.ioctlfd;
  autodir.mounted = 0;
  signed int return_value_atexit$2;
  return_value_atexit$2=atexit(autodir_clean);
  if(!(return_value_atexit$2 == 0))
    msglog(0, "could not register autodir cleanup method");

  char *return_value_autodir_name$3;
  return_value_autodir_name$3=autodir_name();
  msglog(7, "starting %s version %s", return_value_autodir_name$3, (const void *)"0.99.9");
  create_dir(autodir.path, (unsigned int)0700);
  signed int return_value_thread_new_joinable$4;
  return_value_thread_new_joinable$4=thread_new_joinable(signal_handle, (void *)0, &self.sig_th);
  if(return_value_thread_new_joinable$4 == 0)
    msglog(0, "could not start signal handler thread");

  mount_autodir(autodir.path, self.pgrp, self.pid, 4, 4);
  signed int return_value_ioctl$5;
  return_value_ioctl$5=ioctl(autodir.ioctlfd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(0x93 << 0 + 8) | (unsigned int)(0x63 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &autodir.proto);
  if(return_value_ioctl$5 == -1)
    msglog(0 | 128, "ioctl: AUTOFS_IOC_PROTOVER");

  timeout = (unsigned long int)autodir.time_out;
  ioctl(autodir.ioctlfd, (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(0x93 << 0 + 8) | (unsigned int)(0x64 << 0)) | sizeof(unsigned long int) /*8ul*/  << 0 + 8 + 8, &timeout);
  if(!(autodir.proto == 4))
    msglog(0, "unsupported autofs protocol version");

  expire_start(autodir.time_out, autodir.ioctlfd, &self.shutdown);
  handle_events(autodir.k_pipe);
  self.stop = 1;
  backup_stop_set();
  lockfile_stop_set();
  expire_stop_set();
  msglog(7, "shutting down");
  expire_stop();
  backup_stop();
  thread_cache_stop(&self.expire_tc);
  thread_cache_stop(&self.missing_tc);
  umount_all();
  exit(0);
}

// main_expire_mounts
// file expire.c line 173
static void * main_expire_mounts(void *x)
{
  signed int i;
  signed int r;
  pthread_setcanceltype(1, (signed int *)(void *)0);
  while((_Bool)1)
  {
    i = 0;
    r = 0;
    for( ; r == 0 && !(i >= 500); i = i + 1)
      r=ioctl(expire.ioctlfd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(0x93 << 0 + 8) | (unsigned int)(0x66 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, (void *)0);
    if(!(expire.stop == 0))
    {
      if(i == 500)
        continue;

      wait_extra_expirethread();
      *expire.shutdown = 1;
      return (void *)0;
    }

    if(i == 500)
      start_extra_expire_thread();

    else
      if(!(i >= 2))
        sleep((unsigned int)1);

  }
  return (void *)0;
}

// mentry_free
// file multipath.c line 88
static void mentry_free(struct mentry *me)
{
  struct mentry *tmp;
  if(!(me == ((struct mentry *)NULL)))
  {
    if(!(mcache.count >= 50))
    {
      tmp = mcache.list;
      mcache.list = me;
      me->next = tmp;
      mcache.count = mcache.count + 1;
      goto __CPROVER_DUMP_L4;
    }

    else
      free((void *)me);
  }


__CPROVER_DUMP_L4:
  ;
}

// mentry_malloc
// file multipath.c line 72
static struct mentry * mentry_malloc(void)
{
  struct mentry *tmp;
  if(mcache.count >= 1)
  {
    tmp = mcache.list;
    mcache.list = mcache.list->next;
    mcache.count = mcache.count - 1;
    return tmp;
  }

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct mentry) /*272ul*/ );
    return (struct mentry *)return_value_malloc$1;
  }
}

// mhash_resize
// file multipath.c line 104
static void mhash_resize(void)
{
  signed int new_size;
  signed int old_size = mhash_size;
  struct mentry **new_mhash;
  struct mentry **dptr;
  struct mentry **h = mhash;
  struct mentry *entry;
  struct mentry *next;
  new_size = mhash_size * 2;
  new_size = new_size | 1;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)new_size, sizeof(struct mentry *) /*8ul*/ );
  new_mhash = (struct mentry **)return_value_calloc$1;
  signed int tmp_post$2;
  struct mentry **tmp_post$3;
  if(!(new_mhash == ((struct mentry **)NULL)))
  {
    do
    {
      tmp_post$2 = old_size;
      old_size = old_size - 1;
      if(!(tmp_post$2 >= 1))
        break;

      tmp_post$3 = h;
      h = h + 1l;
      entry = *tmp_post$3;
      for( ; !(entry == ((struct mentry *)NULL)); entry = next)
      {
        next = entry->next;
        dptr = &new_mhash[(signed long int)(entry->hash % (unsigned int)new_size)];
        entry->next = *dptr;
        *dptr = entry;
      }
    }
    while((_Bool)1);
    mhash_size = new_size;
    free((void *)mhash);
    mhash = new_mhash;
  }

}

// missing_exit
// file autodir.c line 287
static void missing_exit(char *mname, char *name, unsigned int wqt, signed int result)
{
  if(result == 1)
    send_ready(wqt);

  else
    send_fail(wqt);
  if(!(mname == ((char *)NULL)))
    workon_release(mname);

  if(!(mname == name) && !(name == ((char *)NULL)))
    workon_release(name);

}

// module_check
// file module.c line 72
static void module_check(void)
{
  struct stat st;
  signed int return_value_stat$4;
  return_value_stat$4=stat(module.mod_path, &st);
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  if(!(return_value_stat$4 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 2)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 == 20 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      msglog(0, "could not find module at %s", module.mod_path);

    else
      msglog(0 | 128, "module_check: stat");
  }

  if(!((61440u & st.st_mode) == 32768u))
    msglog(0, "module %s is not regular file", module.mod_path);

  if(!((2u & st.st_mode) == 0u))
    msglog(0, "module %s has world write permissions", module.mod_path);

  if(!(st.st_uid == 0u))
    msglog(0, "module %s is not owned by root", module.mod_path);

}

// module_clean
// file module.c line 94
static void module_clean(void)
{
  if(!(module.handle == ((struct lt__handle *)NULL)))
    lt_dlclose(module.handle);

}

// module_load
// file module.h line 39
void module_load(char *apath)
{
  module.handle = ((struct lt__handle *)NULL);
  module_check();
  signed int return_value_atexit$1;
  return_value_atexit$1=atexit(module_clean);
  if(!(return_value_atexit$1 == 0))
    msglog(0, "could not register module cleanup method");

  signed int return_value_lt_dlinit$3;
  return_value_lt_dlinit$3=lt_dlinit();
  const char *return_value_lt_dlerror$2;
  if(!(return_value_lt_dlinit$3 == 0))
  {
    return_value_lt_dlerror$2=lt_dlerror();
    msglog(0, "module_load: lt_dlinit: %s", return_value_lt_dlerror$2);
  }

  module.handle=lt_dlopenext(module.mod_path);
  const char *return_value_lt_dlerror$4;
  if(module.handle == ((struct lt__handle *)NULL))
  {
    return_value_lt_dlerror$4=lt_dlerror();
    msglog(0, "module open error: %s", return_value_lt_dlerror$4);
  }

  void *return_value_module_symbol$5;
  return_value_module_symbol$5=module_symbol("module_init");
  mod_init = (struct module_info * (*)(char *, const char *))return_value_module_symbol$5;
  void *return_value_module_symbol$6;
  return_value_module_symbol$6=module_symbol("module_dir");
  mod_dir = (void (*)(char *, signed int, const char *))return_value_module_symbol$6;
  void *return_value_module_symbol$7;
  return_value_module_symbol$7=module_symbol("module_dowork");
  mod_dowork = (signed int (*)(const char *, const char *, char *, signed int))return_value_module_symbol$7;
  void *return_value_module_symbol$8;
  return_value_module_symbol$8=module_symbol("module_clean");
  mod_clean = (void (*)(void))return_value_module_symbol$8;
  modinfo=mod_init(module.mod_subopt, apath);
  if(modinfo == ((struct module_info *)NULL))
    msglog(0, "could not initialize module");

  if(!(modinfo->protocol == 1001))
    msglog(0, "required protocol '%d', module protocol '%d' not supported", 1001, modinfo->protocol);

  if(modinfo->name == ((const char *)NULL))
    msglog(0, "missing module name info");

  msglog(7, "module %s loaded from %s", modinfo->name, module.mod_path);
}

// module_name
// file module.h line 42
const char * module_name(void)
{
  return modinfo->name;
}

// module_option_modopt
// file module.h line 41
void module_option_modopt(char ch, char *arg, signed int valid)
{
  module.mod_subopt = valid != 0 ? arg : (char *)(void *)0;
}

// module_option_modpath
// file module.h line 40
void module_option_modpath(char ch, char *arg, signed int valid)
{
  if(valid == 0)
    msglog(0, "module option -%c missing", ch);

  _Bool tmp_if_expr$1;
  if(arg == ((char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)arg[(signed long int)0] != 47 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    msglog(0, "module option -%c argument is not absolute path", ch);

  module.mod_path = arg;
}

// module_symbol
// file module.c line 61
static void * module_symbol(const char *sname)
{
  void *ptr;
  ptr=lt_dlsym(module.handle, sname);
  if(ptr == NULL)
    msglog(0, "'%s' symbol not defined in module %s", sname, module.mod_path);

  return ptr;
}

// mono_nanosleep
// file time_mono.h line 19
void mono_nanosleep(signed long int nsec)
{
  struct timespec tp;
  tp.tv_sec = (signed long int)0;
  tp.tv_nsec = nsec;
  signed int return_value_clock_nanosleep$1;
  return_value_clock_nanosleep$1=clock_nanosleep(clockid, 0, &tp, (struct timespec *)(void *)0);
  if(!(return_value_clock_nanosleep$1 == 0))
    msglog(4 | 128, "mono_nanosleep: clock_nanosleep");

  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// mount_autodir
// file autodir.c line 192
static void mount_autodir(char *path, signed int pgrp, signed int pid, signed int minp, signed int maxp)
{
  signed int pipefd[2l];
  char mount_autodir$$1$$options[128l];
  char our_name[128l];
  char dot_path[4097l];
  struct stat st;
  signed int return_value_pipe$1;
  return_value_pipe$1=pipe(pipefd);
  if(!(return_value_pipe$1 >= 0))
    msglog(0 | 128, "mount_autodir: pipe");

  snprintf(mount_autodir$$1$$options, sizeof(char [128l]) /*128ul*/ , "fd=%d,pgrp=%u,minproto=%d,maxproto=%d", pipefd[(signed long int)1], (unsigned int)pgrp, minp, maxp);
  char *return_value_autodir_name$2;
  return_value_autodir_name$2=autodir_name();
  snprintf(our_name, sizeof(char [128l]) /*128ul*/ , "%s(pid%u)", return_value_autodir_name$2, (unsigned int)pid);
  signed int return_value_mount$3;
  return_value_mount$3=mount(our_name, path, "autofs", (unsigned long int)0xc0ed0000, (const void *)mount_autodir$$1$$options);
  if(!(return_value_mount$3 == 0))
  {
    close(pipefd[(signed long int)0]);
    close(pipefd[(signed long int)1]);
    msglog(0 | 128, "incorrect autofs module loaded? mount %s", path);
  }

  autodir.mounted = 1;
  close(pipefd[(signed long int)1]);
  autodir.k_pipe = pipefd[(signed long int)0];
  signed int return_value_fcntl$4;
  return_value_fcntl$4=fcntl(autodir.k_pipe, 4, 04000);
  if(!(return_value_fcntl$4 == 0))
    msglog(0 | 128, "mount_autodir: fcntl");

  snprintf(dot_path, sizeof(char [4097l]) /*4097ul*/ , "%s/.", path);
  autodir.ioctlfd=open(dot_path, 00);
  if(!(autodir.ioctlfd >= 0))
    msglog(0 | 128, "mount_autodir: open %s", (const void *)dot_path);

  signed int return_value_fstat$5;
  return_value_fstat$5=fstat(autodir.ioctlfd, &st);
  if(!(return_value_fstat$5 >= 0))
    msglog(0 | 128, "mount_autodir: fstat %s", (const void *)dot_path);

  autodir.dev = st.st_dev;
}

// msg_clean
// file msg.c line 148
static void msg_clean(void)
{
  if(!(mg.slog_init == 0))
    closelog();

  if(!(mg.modname_prefix == ((char *)NULL)))
    free((void *)mg.modname_prefix);

  pthread_mutex_destroy(&mg.strerror_lock);
}

// msg_console
// file msg.c line 69
static void msg_console(signed int msgprio, const char *txt)
{
  struct _IO_FILE *stream = msgprio < 7 ? stderr : stdout;
  char *return_value_autodir_name$1;
  char *return_value_autodir_name$2;
  if(!(mg.modname_prefix == ((char *)NULL)))
  {
    return_value_autodir_name$1=autodir_name();
    fprintf(stream, "%s [%s] %s: %.*s\n", return_value_autodir_name$1, mg.modname_prefix, msgmap[(signed long int)msgprio].tag, (signed int)1024, txt);
  }

  else
  {
    return_value_autodir_name$2=autodir_name();
    fprintf(stream, "%s %s: %.*s\n", return_value_autodir_name$2, msgmap[(signed long int)msgprio].tag, (signed int)1024, txt);
  }
}

// msg_console_off
// file msg.h line 50
void msg_console_off(void)
{
  mg.msg_which = mg.msg_which & ~1;
}

// msg_console_on
// file msg.h line 49
void msg_console_on(void)
{
  mg.msg_which = mg.msg_which | 1;
}

// msg_init
// file msg.h line 48
void msg_init(void)
{
  mg.slog_init = 0;
  mg.msg_which = 0;
  mg.modname_prefix = (char *)(void *)0;
  pthread_mutex_init(&mg.strerror_lock, &common_mutex_attr);
  signed int return_value_atexit$1;
  return_value_atexit$1=atexit(msg_clean);
  if(!(return_value_atexit$1 == 0))
    msglog(0, "msg_init: could not add msg cleanup method");

}

// msg_modname_prefix
// file msg.h line 53
void msg_modname_prefix(const char *modname)
{
  char *return_value___strdup$1;
  return_value___strdup$1=__strdup(modname);
  mg.modname_prefix = return_value___strdup$1;
}

// msg_option_verbose
// file msg.c line 202
void msg_option_verbose(char ch, char *arg, signed int valid)
{
  mg.verbose_log = valid != 0 ? 1 : 0;
}

// msg_syslog
// file msg.c line 86
static void msg_syslog(signed int msgprio, const char *txt)
{
  if(!(mg.modname_prefix == ((char *)NULL)))
    syslog(msgmap[(signed long int)msgprio].priority, "[%s] %s: %.*s", mg.modname_prefix, msgmap[(signed long int)msgprio].tag, (signed int)1024, txt);

  else
    syslog(msgmap[(signed long int)msgprio].priority, "%s: %.*s", msgmap[(signed long int)msgprio].tag, (signed int)1024, txt);
}

// msg_syslog_off
// file msg.c line 190
void msg_syslog_off(void)
{
  mg.msg_which = mg.msg_which & ~2;
}

// msg_syslog_on
// file msg.h line 51
void msg_syslog_on(void)
{
  if(mg.slog_init == 0)
  {
    char *return_value_autodir_name$1;
    return_value_autodir_name$1=autodir_name();
    openlog(return_value_autodir_name$1, 0x08 | 0x02, 3 << 3);
    mg.slog_init = 1;
  }

  mg.msg_which = mg.msg_which | 2;
}

// msglog
// file msg.h line 54
void msglog(signed int mprio, const char *fmt, ...)
{
  char buf[1024l];
  char *b = buf;
  signed int len;
  signed int sz = (signed int)sizeof(char [1024l]) /*1024ul*/ ;
  signed int pri = mprio & 15;
  signed int saved_errno;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  saved_errno = *return_value___errno_location$1;
  char *es;
  void **ap;
  _Bool tmp_if_expr$2;
  char *tmp_post$3;
  char *tmp_post$4;
  if(!(mg.verbose_log == 0) || !(pri >= 7))
  {
    if(!(fmt == ((const char *)NULL)) && !(pri >= 9))
    {
      ap = (void **)&fmt;
      len=vsnprintf(b, (unsigned long int)sz, fmt, ap);
      ap = ((void **)NULL);
      if(len >= sz || !(len >= 1))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = b[(signed long int)len] != 0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$2)
      {
        b = b + (signed long int)len;
        sz = sz - len;
        if(sz >= 4 && !((128 & mprio) == 0))
        {
          tmp_post$3 = b;
          b = b + 1l;
          *tmp_post$3 = (char)58;
          tmp_post$4 = b;
          b = b + 1l;
          *tmp_post$4 = (char)32;
          *b = (char)0;
          sz = sz - 2;
          pthread_mutex_lock(&mg.strerror_lock);
          es=strerror(saved_errno);
          string_n_copy(b, es, sz);
          pthread_mutex_unlock(&mg.strerror_lock);
        }

        if(!((1 & mg.msg_which) == 0))
          msg_console(pri, buf);

        if(!((2 & mg.msg_which) == 0))
          msg_syslog(pri, buf);

        if(pri == 0)
          exit(1);

      }

    }

  }

}

// multipath_clean
// file multipath.c line 238
static void multipath_clean(void)
{
  signed int i;
  struct mentry *me;
  struct mentry *tmp;
  pthread_mutex_destroy(&hash_lock$link2);
  if(!(mhash == ((struct mentry **)NULL)))
  {
    i = 0;
    for( ; !(i >= mhash_size); i = i + 1)
      if(!(mhash[(signed long int)i] == ((struct mentry *)NULL)))
      {
        me = mhash[(signed long int)i];
        while(!(me == ((struct mentry *)NULL)))
        {
          tmp = me;
          me = me->next;
          free((void *)tmp);
        }
      }

    free((void *)mhash);
  }

  me = mcache.list;
  while(!(me == ((struct mentry *)NULL)))
  {
    tmp = me;
    me = me->next;
    free((void *)tmp);
  }
}

// multipath_dec
// file multipath.h line 7
signed int multipath_dec(const char *name)
{
  unsigned int multipath_dec$$1$$hash;
  signed int count;
  struct mentry **dptr;
  struct mentry *ent;
  _Bool tmp_if_expr$1;
  if(name == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(*name != 0) ? (_Bool)1 : (_Bool)0;
  signed int tmp_statement_expression$2;
  if(tmp_if_expr$1)
  {
    msglog(4, "lockfile_unhash: invalid name");
    return 0;
  }

  else
  {
    multipath_dec$$1$$hash=string_hash(name);
    pthread_mutex_lock(&hash_lock$link2);
    do
    {
      dptr = &mhash[(signed long int)(multipath_dec$$1$$hash % (unsigned int)mhash_size)];
      for( ; !(*dptr == ((struct mentry *)NULL)); dptr = &(*dptr)->next)
        if((*dptr)->hash == multipath_dec$$1$$hash)
        {
          if(*name == (*dptr)->name[0l])
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$3;
            return_value___builtin_strcmp$3=__builtin_strcmp(name, (*dptr)->name);
            tmp_statement_expression$2 = return_value___builtin_strcmp$3;
            if(tmp_statement_expression$2 == 0)
              break;

          }

        }

    }
    while((_Bool)0);
    ent = *dptr;
    if(ent == ((struct mentry *)NULL))
    {
      pthread_mutex_unlock(&hash_lock$link2);
      msglog(2, "multipath_dec: entry for %s does not exist", name);
      return -1;
    }

    else
    {
      ent->count = ent->count - 1;
      count = ent->count;
      if(count == 0)
      {
        *dptr = ent->next;
        mentry_free(ent);
        mhash_used = mhash_used - 1;
      }

      pthread_mutex_unlock(&hash_lock$link2);
      return count;
    }
  }
}

// multipath_inc
// file multipath.h line 6
signed int multipath_inc(const char *name)
{
  unsigned int multipath_inc$$1$$hash;
  struct mentry *ent;
  struct mentry **dptr;
  _Bool tmp_if_expr$1;
  if(name == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(*name != 0) ? (_Bool)1 : (_Bool)0;
  signed int tmp_statement_expression$2;
  if(tmp_if_expr$1)
  {
    msglog(4, "multipath_inc: invalid name");
    return 0;
  }

  else
  {
    multipath_inc$$1$$hash=string_hash(name);
    pthread_mutex_lock(&hash_lock$link2);
    do
    {
      dptr = &mhash[(signed long int)(multipath_inc$$1$$hash % (unsigned int)mhash_size)];
      for( ; !(*dptr == ((struct mentry *)NULL)); dptr = &(*dptr)->next)
        if((*dptr)->hash == multipath_inc$$1$$hash)
        {
          if(*name == (*dptr)->name[0l])
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$3;
            return_value___builtin_strcmp$3=__builtin_strcmp(name, (*dptr)->name);
            tmp_statement_expression$2 = return_value___builtin_strcmp$3;
            if(tmp_statement_expression$2 == 0)
              break;

          }

        }

    }
    while((_Bool)0);
    if(*dptr == ((struct mentry *)NULL))
    {
      ent=mentry_malloc();
      if(ent == ((struct mentry *)NULL))
      {
        pthread_mutex_unlock(&hash_lock$link2);
        msglog(2, "multipath_inc: could not allocate memory");
        return 0;
      }

      ent->count = 1;
      string_n_copy(ent->name, name, (signed int)sizeof(char [256l]) /*256ul*/ );
      ent->hash = multipath_inc$$1$$hash;
      ent->next = (struct mentry *)(void *)0;
      *dptr = ent;
      mhash_used = mhash_used + 1;
      if(!(mhash_size >= mhash_used))
        mhash_resize();

      pthread_mutex_unlock(&hash_lock$link2);
      return 1;
    }

    else
    {
      (*dptr)->count = (*dptr)->count + 1;
      pthread_mutex_unlock(&hash_lock$link2);
      return 1;
    }
  }
}

// multipath_init
// file multipath.h line 4
void multipath_init(void)
{
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)3, sizeof(struct mentry *) /*8ul*/ );
  mhash = (struct mentry **)return_value_calloc$1;
  if(mhash == ((struct mentry **)NULL))
    msglog(0, "multipath_init: could not allocate hash table");

  mhash_used = 0;
  mhash_size = 3;
  pthread_mutex_init(&hash_lock$link2, &common_mutex_attr);
  mcache.list = (struct mentry *)(void *)0;
  mcache.count = 0;
  signed int return_value_atexit$2;
  return_value_atexit$2=atexit(multipath_clean);
  if(!(return_value_atexit$2 == 0))
  {
    multipath_clean();
    msglog(0, "multipath_init: could not register cleanup method");
  }

}

// mutexattr_init
// file thread.c line 77
static void mutexattr_init(void)
{
  const char *myname = "mutex_init";
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1=pthread_mutexattr_init(&common_mutex_attr);
  if(!(*return_value___errno_location$1 == 0))
    msglog(0 | 128, "%s: pthread_mutexattr_init", myname);

  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2=pthread_mutexattr_setpshared(&common_mutex_attr, 0);
  if(!(*return_value___errno_location$2 == 0))
    msglog(0 | 128, "%s: pthread_mutexattr_setpshared PTHREAD_PROCESS_PRIVATE", myname);

  signed int *return_value___errno_location$3;
  return_value___errno_location$3=__errno_location();
  *return_value___errno_location$3=pthread_mutexattr_settype(&common_mutex_attr, 0);
  if(!(*return_value___errno_location$3 == 0))
    msglog(0 | 128, "%s: pthread_mutexattr_settype PTHREAD_MUTEX_NORMAL: %m", myname);

}

// octal_string2dec
// file miscfuncs.c line 145
signed int octal_string2dec(const char *str, unsigned int *oct)
{
  signed int i = 0;
  unsigned int val = (unsigned int)0;
  _Bool tmp_if_expr$2;
  const unsigned short int **return_value___ctype_b_loc$1;
  if(str == ((const char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    tmp_if_expr$2 = !(((signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*str] & (signed int)(unsigned short int)32768) != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    return 0;

  else
  {
    if((signed int)*str == 48)
      str = str + 1l;

    for( ; !(str[(signed long int)i] == 0); i = i + 1)
    {
      if(!((signed int)str[(signed long int)i] >= 48))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)str[(signed long int)i] > 55 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        return 0;

      val = val * (unsigned int)8 + (unsigned int)((signed int)str[(signed long int)i] - 48);
    }
    *oct = val;
    return i;
  }
}

// option_call_cbs
// file options.c line 143
static void option_call_cbs(void)
{
  signed int i;
  struct opt_cb *tmp = options.opt;
  i = 0;
  if(!(i >= options.count))
  {
    if(!(tmp->req_arg == 0))
      tmp->cb(tmp->opch, tmp->arg_str, tmp->valid);

    else
      tmp->cb(tmp->opch, (char *)(void *)0, tmp->valid);
    tmp = tmp + 1l;
    i = i + 1;
  }

}

// option_help
// file options.c line 124
static void option_help(char ch, char *arg, signed int valid)
{
  if(!(valid == 0))
  {
    option_usage();
    exit(0);
  }

}

// option_init
// file options.h line 26
void option_init(signed int argc, char **argv)
{
  options.count = 0;
  options.ostr[(signed long int)0] = (char)0;
  if(!(argc >= 2))
  {
    option_usage();
    exit(1);
  }

  cary_init(&options.ca, options.ostr, (signed int)sizeof(char [41l]) /*41ul*/ );
  option_register((const char)104, option_help, 0);
  option_register((const char)118, option_version, 0);
  option_register((const char)100, autodir_option_path, 1);
  option_register((const char)108, autodir_option_pidfile, 1);
  option_register((const char)116, autodir_option_timeout, 1);
  option_register((const char)102, autodir_option_fg, 0);
  option_register((const char)109, module_option_modpath, 1);
  option_register((const char)111, module_option_modopt, 1);
  option_register((const char)119, backup_option_wait, 1);
  option_register((const char)110, backup_option_wait2finish, 0);
  option_register((const char)78, backup_option_nokill, 0);
  option_register((const char)99, backup_option_max_proc, 1);
  option_register((const char)112, backup_fork_option_pri, 1);
  option_register((const char)98, backup_option_path, 1);
  option_register((const char)76, backup_option_life, 1);
  option_register((const char)107, lockfile_option_lockfiles, 0);
  option_register((const char)114, lockfile_option_lockdir, 1);
  option_register((const char)97, autodir_option_multipath, 0);
  option_register((const char)86, msg_option_verbose, 0);
  option_register((const char)120, autodir_option_multiprefix, 1);
  option_process(argv, argc);
}

// option_is_exist
// file options.c line 79
static struct opt_cb * option_is_exist(char opch)
{
  signed int i = 0;
  for( ; !(i >= options.count); i = i + 1)
    if(options.opt[(signed long int)i].opch == opch)
      return options.opt + (signed long int)i;

  return (struct opt_cb *)(void *)0;
}

// option_process
// file options.c line 159
static void option_process(char **argv, signed int argc)
{
  signed int c;
  struct opt_cb *ocb;
  opterr = 0;
  _Bool tmp_if_expr$1;
  do
  {
    c=getopt(argc, argv, options.ostr);
    if(c == -1)
      break;

    if(c == 63)
    {
      ocb=option_is_exist((char)optopt);
      if(!(ocb == ((struct opt_cb *)NULL)))
        tmp_if_expr$1 = ocb->req_arg != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        msglog(0, "missing argument for -%c", optopt);

      else
        if(ocb == ((struct opt_cb *)NULL))
          msglog(0, "unknown option -%c", optopt);

        else
          msglog(0, "option processing error");
    }

    else
    {
      ocb=option_is_exist((char)c);
      if(!(ocb == ((struct opt_cb *)NULL)))
      {
        ocb->valid = 1;
        if(!(ocb->req_arg == 0))
          ocb->arg_str = optarg;

      }

    }
  }
  while((_Bool)1);
  if(!(argc == optind))
    msglog(0, "unexpected argument %s", argv[(signed long int)optind]);

  option_call_cbs();
}

// option_register
// file options.c line 191
static void option_register(const char opch, void (* const cb)(char, char *, signed int), const signed int areq)
{
  _Bool tmp_if_expr$2;
  struct opt_cb *return_value_option_is_exist$1;
  if(options.count == 20)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_option_is_exist$1=option_is_exist(opch);
    tmp_if_expr$2 = return_value_option_is_exist$1 != ((struct opt_cb *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    msglog(0, "option_register: could not register option -%c", opch);

  cary_add(&options.ca, opch);
  if(areq == 1)
    cary_add(&options.ca, (char)58);

  options.opt[(signed long int)options.count].req_arg = (signed int)(areq == 1);
  options.opt[(signed long int)options.count].opch = opch;
  options.opt[(signed long int)options.count].cb = cb;
  options.opt[(signed long int)options.count].arg_str = (char *)(void *)0;
  options.opt[(signed long int)options.count].valid = 0;
  options.count = options.count + 1;
}

// option_usage
// file options.c line 93
static void option_usage(void)
{
  char *return_value_autodir_name$1;
  return_value_autodir_name$1=autodir_name();
  printf("Usage: %s [OPTIONS]\n\n", return_value_autodir_name$1);
  printf("\t-%c\t%s\n", 100, (const void *)"mount point for autofs file system");
  printf("\t-%c\t%s\n", 108, (const void *)"pid file path");
  printf("\t-%c\t%s\n", 116, (const void *)"time in seconds for unmounting of inactive directories");
  printf("\t-%c\t%s\n", 109, (const void *)"module absolute path");
  printf("\t-%c\t%s\n", 111, (const void *)"module sub-options");
  printf("\t-%c\t%s\n", 119, (const void *)"wait period for backup process to begin after unmount");
  printf("\t-%c\t%s\n", 110, (const void *)"not to kill backup process but wait for it to finish");
  printf("\t-%c\t%s\n", 78, (const void *)"not to kill backup process and not to wait for it to finish");
  printf("\t-%c\t%s\n", 99, (const void *)"maximum backup processes");
  printf("\t-%c\t%s\n", 76, (const void *)"maximum time in seconds backup can run");
  printf("\t-%c\t%s\n", 112, (const void *)"backup process priority");
  printf("\t-%c\t%s\n", 98, (const void *)"backup executable absolute path");
  printf("\t-%c\t%s\n", 107, (const void *)"use backup locks");
  printf("\t-%c\t%s\n", 114, (const void *)"backup lock files directory path");
  printf("\t-%c\t%s\n", 97, (const void *)"multi path support");
  printf("\t-%c\t%s\n", 120, (const void *)"multi path prefix");
  printf("\t-%c\t%s\n", 102, (const void *)"stay foreground and log messages to console");
  printf("\t-%c\t%s\n", 86, (const void *)"verbose logging");
  printf("\t-%c\t%s\n", 118, (const void *)"version");
  printf("\t-%c\t%s\n", 104, (const void *)"help -- this text");
  printf("\n\n");
}

// option_version
// file options.c line 133
static void option_version(char ch, char *arg, signed int valid)
{
  if(!(valid == 0))
  {
    char *return_value_autodir_name$1;
    return_value_autodir_name$1=autodir_name();
    printf("%s: Version %s\n\n", return_value_autodir_name$1, (const void *)"0.99.9");
    exit(0);
  }

}

// packet_allocate
// file mpacket.h line 40
struct packet * packet_allocate(void)
{
  struct packet *pkt;
  static struct packet *list = (struct packet *)(void *)0;
  while(list == ((struct packet *)NULL))
  {
    list=packet_get_free_list();
    if(!(list == ((struct packet *)NULL)))
      break;

    msglog(2, "packet_allocate: could not get free packet list");
    sleep((unsigned int)1);
  }
  pkt = list;
  list = list->next;
  return pkt;
}

// packet_clean
// file mpacket.c line 107
static void packet_clean(void)
{
  struct packet *pk;
  struct packet *tmp;
  pk = pcache.list;
  while(!(pk == ((struct packet *)NULL)))
  {
    tmp = pk;
    pk = pk->next;
    free((void *)tmp);
  }
  pthread_mutex_destroy(&pcache.lock);
}

// packet_free
// file mpacket.h line 41
void packet_free(struct packet *pk)
{
  struct packet *tmp;
  if(!(pk == ((struct packet *)NULL)))
  {
    if(!(pcache.count >= 150))
    {
      pthread_mutex_lock(&pcache.lock);
      tmp = pcache.list;
      pcache.list = pk;
      pk->next = tmp;
      pcache.count = pcache.count + 1;
      pthread_mutex_unlock(&pcache.lock);
      goto __CPROVER_DUMP_L4;
    }

    else
      free((void *)pk);
  }


__CPROVER_DUMP_L4:
  ;
}

// packet_get_free_list
// file mpacket.c line 43
static struct packet * packet_get_free_list(void)
{
  struct packet *list;
  if(pcache.count >= 1)
  {
    pthread_mutex_lock(&pcache.lock);
    if(!(pcache.count >= 1))
    {
      pthread_mutex_unlock(&pcache.lock);
      goto dalloc;
    }

    list = pcache.list;
    pcache.list = (struct packet *)(void *)0;
    pcache.count = 0;
    pthread_mutex_unlock(&pcache.lock);
    return list;
  }

  else
  {

  dalloc:
    ;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct packet) /*288ul*/ );
    list = (struct packet *)return_value_malloc$1;
    if(!(list == ((struct packet *)NULL)))
      list->next = (struct packet *)(void *)0;

    return list;
  }
}

// packet_init
// file mpacket.h line 39
void packet_init(void)
{
  pcache.list = (struct packet *)(void *)0;
  pcache.count = 0;
  pthread_mutex_init(&pcache.lock, &common_mutex_attr);
  signed int return_value_atexit$1;
  return_value_atexit$1=atexit(packet_clean);
  if(!(return_value_atexit$1 == 0))
  {
    packet_clean();
    msglog(0, "packet_init: could not register cleanup method");
  }

}

// poll_read
// file autodir.c line 236
static signed int poll_read(signed int fd, char *buf, signed int sz)
{
  signed int r;
  signed int n;
  struct pollfd pf;
  pf.fd = fd;
  pf.events = (signed short int)0x001;
  signed int *return_value___errno_location$1;
  signed long int return_value_read$2;
  signed int *return_value___errno_location$3;
  while(!(sz == 0))
  {
    r=poll(&pf, (unsigned long int)1, 1000);
    if(r == -1)
    {
      return_value___errno_location$1=__errno_location();
      if(!(*return_value___errno_location$1 == 4))
      {
        msglog(4 | 128, "poll_read: poll");
        return -1;
      }

    }

    if(r == 0 && !(self.shutdown == 0))
      return 0;

    if(r >= 1)
    {
      do
      {
        return_value_read$2=read(fd, (void *)buf, (unsigned long int)sz);
        n = (signed int)return_value_read$2;
        if(!(n == -1))
          break;

        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 4))
          break;

      }
      while((_Bool)1);
      if(n >= 1)
      {
        sz = sz - n;
        buf = buf + (signed long int)n;
      }

      else
        if(n == 0)
        {
          msglog(2, "poll_read: kernel pipe closed");
          return -1;
        }

        else
          if(n == -1)
          {
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            if(*return_value___errno_location$4 == 11)
            {
              sleep((unsigned int)1);
              continue;
            }

            msglog(4 | 128, "poll_read: read");
            return -1;
          }

    }

  }
  return 1;
}

// queue_entry_add
// file backup_queue.c line 281
static signed int queue_entry_add(struct bqueue *new)
{
  signed int key;
  unsigned int queue_entry_add$$1$$hash;
  struct bqueue **dptr;
  BQ.hash_used = BQ.hash_used + 1;
  if(!(BQ.hash_size >= BQ.hash_used))
    hash_resize();

  new->hash=string_hash(new->dname);
  queue_entry_add$$1$$hash = new->hash;
  key = (signed int)(queue_entry_add$$1$$hash % (unsigned int)BQ.hash_size);
  struct bqueue *return_value_queue_entry_locate$1;
  return_value_queue_entry_locate$1=queue_entry_locate(new->dname, queue_entry_add$$1$$hash, key);
  if(!(return_value_queue_entry_locate$1 == ((struct bqueue *)NULL)))
    return 0;

  else
  {
    dptr = &BQ.hash[(signed long int)key];
    new->next = *dptr;
    if(!(*dptr == ((struct bqueue *)NULL)))
      (*dptr)->prev = new;

    *dptr = new;
    new->prev = (struct bqueue *)(void *)0;
    new->next_t = (struct bqueue *)(void *)0;
    if(BQ.start_t == ((struct bqueue *)NULL))
    {
      new->prev_t = (struct bqueue *)(void *)0;
      BQ.end_t = new;
      BQ.start_t = BQ.end_t;
      BQ.cur_t = BQ.start_t;
    }

    else
    {
      new->prev_t = BQ.end_t;
      if(BQ.cur_t == ((struct bqueue *)NULL))
        BQ.cur_t = new;

      BQ.end_t->next_t = new;
      BQ.end_t = new;
    }
    return 1;
  }
}

// queue_entry_locate
// file backup_queue.c line 182
static struct bqueue * queue_entry_locate(const char *name, unsigned int hash, signed int key)
{
  struct bqueue *bq = BQ.hash[(signed long int)key];
  signed int tmp_statement_expression$1;
  for( ; !(bq == ((struct bqueue *)NULL)); bq = bq->next)
    if(hash == bq->hash)
    {
      if(*name == bq->dname[0l])
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp$2;
        return_value___builtin_strcmp$2=__builtin_strcmp(bq->dname, name);
        tmp_statement_expression$1 = return_value___builtin_strcmp$2;
        if(tmp_statement_expression$1 == 0)
          return bq;

      }

    }

  return (struct bqueue *)(void *)0;
}

// queue_entry_release
// file backup_queue.c line 243
static void queue_entry_release(struct bqueue *bq)
{
  struct bqueue *nxt;
  struct bqueue *prv;
  signed int key;
  BQ.hash_used = BQ.hash_used - 1;
  prv = bq->prev_t;
  nxt = bq->next_t;
  if(bq == BQ.start_t)
    BQ.start_t = nxt;

  if(bq == BQ.cur_t)
    BQ.cur_t = nxt;

  if(bq == BQ.end_t)
    BQ.end_t = prv;

  if(!(nxt == ((struct bqueue *)NULL)))
    nxt->prev_t = prv;

  if(!(prv == ((struct bqueue *)NULL)))
    prv->next_t = nxt;

  prv = bq->prev;
  nxt = bq->next;
  if(!(nxt == ((struct bqueue *)NULL)))
    nxt->prev = prv;

  if(!(prv == ((struct bqueue *)NULL)))
    prv->next = nxt;

  key = (signed int)(bq->hash % (unsigned int)BQ.hash_size);
  if(BQ.hash[(signed long int)key] == bq)
    BQ.hash[(signed long int)key] = nxt;

}

// queue_watch_thread
// file backup_queue.c line 381
static void * queue_watch_thread(void *x)
{
  signed int dift;
  signed int i;
  signed long int cte;
  struct bqueue **bchain;
  signed int child_count;
  _Bool tmp_if_expr$2;
  signed int return_value_pthread_mutex_trylock$1;
  _Bool tmp_if_expr$3;
  while((_Bool)1)
  {
    dift = 0;
    queue_watch_wait(dift);
    child_count=backup_child_count();
    if(!(child_count >= 0))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&BQ.lock);
      tmp_if_expr$2 = return_value_pthread_mutex_trylock$1 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      dift = 1;

    else
    {
      cte=time_mono();
      if(BQ.cur_t == ((struct bqueue *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        dift = (signed int)(BQ.wait - (cte - BQ.cur_t->estamp));
        tmp_if_expr$3 = dift > 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        pthread_mutex_unlock(&BQ.lock);

      else
      {
        bchain = &BQ.bchain;
        *bchain = (struct bqueue *)(void *)0;
        i = 0;
        for( ; BQ.maxproc >= child_count + i && !(BQ.cur_t == ((struct bqueue *)NULL)) && !(i >= 300) && (BQ.wait == 0l || !(dift >= 1)); i = i + 1)
        {
          *bchain = BQ.cur_t;
          BQ.cur_t->in_bchain = 1;
          bchain = &BQ.cur_t->bchain_next;
          *bchain = (struct bqueue *)(void *)0;
          BQ.cur_t = BQ.cur_t->next_t;
          if(!(BQ.cur_t == ((struct bqueue *)NULL)))
            dift = (signed int)(BQ.wait - (cte - BQ.cur_t->estamp));

        }
        pthread_mutex_unlock(&BQ.lock);
        if(!(BQ.bchain == ((struct bqueue *)NULL)))
          bchain_process();

      }
    }
  }
}

// queue_watch_wait
// file backup_queue.c line 364
static void queue_watch_wait(signed int dift)
{
  while(BQ.cur_t == ((struct bqueue *)NULL) || dift >= 1)
  {
    sleep((unsigned int)1);
    if(dift >= 1)
      dift = dift - 1;

    if(!(BQ.stop == 0))
      pthread_exit((void *)0);

  }
  if(!(BQ.stop == 0))
    pthread_exit((void *)0);

}

// remove_pid
// file backup_child.c line 207
static void remove_pid(struct backup_pid *bp)
{
  struct backup_pid **dptr;
  pthread_mutex_lock(&hash_lock$link3);
  do
  {
    dptr = &hash[(signed long int)(bp->hash % (unsigned int)hash_size)];
    for( ; !(*dptr == ((struct backup_pid *)NULL)); dptr = &(*dptr)->next)
      if(*dptr == bp)
        break;

  }
  while((_Bool)0);
  if(!(*dptr == ((struct backup_pid *)NULL)))
  {
    *dptr = bp->next;
    hash_used = hash_used - 1;
    pthread_mutex_unlock(&hash_lock$link3);
    pthread_mutex_lock(&bp->lock);
    pthread_mutex_unlock(&bp->lock);
    if(!(bp->waiting == 0))
    {
      pthread_cond_broadcast(&bp->wait);
      goto __CPROVER_DUMP_L6;
    }

    backup_pidmem_free(bp);
  }

  else
    pthread_mutex_unlock(&hash_lock$link3);

__CPROVER_DUMP_L6:
  ;
}

// rename_dir
// file miscfuncs.c line 275
signed int rename_dir(const char *from, const char *to_dir, const char *to_name, const char *tme_format)
{
  char to[4097l];
  signed long int now;
  struct tm tmval;
  char str_time[256l];
  signed int try;
  now=time((signed long int *)(void *)0);
  try = 0;
  _Bool tmp_if_expr$5;
  signed int *return_value___errno_location$4;
  for( ; !(try >= 10); try = try + 1)
  {
    struct tm *return_value_localtime_r$1;
    return_value_localtime_r$1=localtime_r(&now, &tmval);
    if(return_value_localtime_r$1 == ((struct tm *)NULL))
    {
      msglog(4, "localtime_r: could not convert current time");
      return -1;
    }

    unsigned long int return_value_strftime$2;
    return_value_strftime$2=strftime(str_time, sizeof(char [256l]) /*256ul*/ , tme_format, &tmval);
    if(return_value_strftime$2 == 0ul)
    {
      msglog(4, "strftime: could not make the time");
      return -1;
    }

    snprintf(to, sizeof(char [4097l]) /*4097ul*/ , "%s/%s%s", to_dir, to_name, (const void *)str_time);
    signed int return_value_rename$6;
    return_value_rename$6=rename(from, to);
    if(!(return_value_rename$6 == 0))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      if(*return_value___errno_location$3 == 39)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value___errno_location$4=__errno_location();
        tmp_if_expr$5 = *return_value___errno_location$4 == 17 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
      {
        now = now + 1l;
        goto __CPROVER_DUMP_L8;
      }

      msglog(5 | 128, "could not rename %s to %s", from, (const void *)to);
      return -1;
    }

    return 0;

  __CPROVER_DUMP_L8:
    ;
  }
  return -1;
}

// reset_signals
// file backup_fork.c line 43
static void reset_signals(void)
{
  struct anonymous$2 set;
  sigfillset(&set);
  signed int return_value_sigprocmask$1;
  return_value_sigprocmask$1=sigprocmask(1, &set, (struct anonymous$2 *)(void *)0);
  if(!(return_value_sigprocmask$1 == 0))
    msglog(4 | 128, "reset_signals: sigprocmask");

}

// send_fail
// file autodir.c line 113
static void send_fail(unsigned int wait_queue_token)
{
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(autodir.ioctlfd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(0x93 << 0 + 8) | (unsigned int)(0x61 << 0) | (unsigned int)(0 << 0 + 8 + 8)), wait_queue_token);
  if(!(return_value_ioctl$1 >= 0))
    msglog(4 | 128, "ioctl AUTOFS_IOC_FAIL");

}

// send_ready
// file autodir.c line 107
static void send_ready(unsigned int wait_queue_token)
{
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(autodir.ioctlfd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(0x93 << 0 + 8) | (unsigned int)(0x60 << 0) | (unsigned int)(0 << 0 + 8 + 8)), wait_queue_token);
  if(!(return_value_ioctl$1 >= 0))
    msglog(4 | 128, "ioctl AUTOFS_IOC_READY");

}

// shared_lock
// file lockfile.c line 316
static signed int shared_lock(signed int fd, const char *path)
{
  signed int wait_msg = 0;
  struct flock lk;
  lk.l_type = (signed short int)0;
  lk.l_start = (signed long int)0;
  lk.l_whence = (signed short int)0;
  lk.l_len = (signed long int)0;
  signed int return_value_fcntl$1;
  _Bool tmp_if_expr$6;
  signed int *return_value___errno_location$5;
  signed int tmp_post$2;
  do
  {
    return_value_fcntl$1=fcntl(fd, 6, &lk);
    if(!(return_value_fcntl$1 == -1))
      break;

    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    if(*return_value___errno_location$4 == 11)
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value___errno_location$5=__errno_location();
      tmp_if_expr$6 = *return_value___errno_location$5 == 13 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
    {
      tmp_post$2 = wait_msg;
      wait_msg = wait_msg + 1;
      if(tmp_post$2 == 0)
        msglog(6, "waiting for lock file: %s", path);

      signed int return_value_lockfile_sleep$3;
      return_value_lockfile_sleep$3=lockfile_sleep(3);
      if(return_value_lockfile_sleep$3 == 0)
        return 0;

      continue;
    }

    msglog(4 | 128, "fcntl F_SETLK");
    return 0;
  }
  while((_Bool)1);
  return 1;
}

// signal_block
// file autodir.c line 617
static void signal_block(void)
{
  struct anonymous$2 set;
  sigfillset(&set);
  signed int return_value_sigprocmask$1;
  return_value_sigprocmask$1=sigprocmask(2, &set, (struct anonymous$2 *)(void *)0);
  if(!(return_value_sigprocmask$1 == 0))
    msglog(0 | 128, "signal_block: sigprocmask");

}

// signal_handle
// file autodir.c line 588
static void * signal_handle(void *v)
{
  signed int sig;
  struct anonymous$2 set;
  pthread_setcanceltype(1, (signed int *)(void *)0);
  sigfillset(&set);
  while((_Bool)1)
  {
    sig = 0;
    sigwait(&set, &sig);
    if(!(sig == 1) && !(sig == 10) && !(sig == 13) && !(sig == 14) && !(sig == 17))
    {
      msglog(6, "signal received %d", sig);
      self.stop = 1;
      backup_stop_set();
      lockfile_stop_set();
      expire_stop_set();
      return (void *)0;
    }

  }
}

// start_extra_expire_thread
// file expire.c line 133
static void start_extra_expire_thread(void)
{
  signed int i = 0;
  for( ; !(i >= 10); i = i + 1)
  {
    if(expire.threads[(signed long int)expire.cur] == 0ul)
    {
      pthread_mutex_lock(&expire.lock);
      signed int return_value_thread_new_joinable$1;
      return_value_thread_new_joinable$1=thread_new_joinable(extra_expire_mounts, (void *)&expire.threads[(signed long int)expire.cur], &expire.threads[(signed long int)expire.cur]);
      if(!(return_value_thread_new_joinable$1 == 0))
        expire.cur = (expire.cur + 1) % 10;

      pthread_mutex_unlock(&expire.lock);
      goto __CPROVER_DUMP_L5;
    }

    expire.cur = (expire.cur + 1) % 10;
  }
  msglog(6, "could not start extra expire thread");

__CPROVER_DUMP_L5:
  ;
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// string_hash
// file miscfuncs.c line 244
unsigned int string_hash(const char *str)
{
  unsigned long int h = (unsigned long int)0;
  unsigned long int g;
  const char *tmp_post$1;
  while(!(*str == 0))
  {
    tmp_post$1 = str;
    str = str + 1l;
    h = (h << 4) + (unsigned long int)*tmp_post$1;
    g = h & (unsigned long int)0xf0000000;
    if(!(g == 0ul))
    {
      h = h ^ g >> 24;
      h = h ^ g;
    }

  }
  return (unsigned int)h;
}

// string_n_copy
// file miscfuncs.h line 36
char * string_n_copy(char *str1, const char *str2, signed int len)
{
  signed int i = 0;
  if(str1 == ((char *)NULL))
    return (char *)(void *)0;

  else
    if(str2 == ((const char *)NULL))
    {
      *str1 = (char)0;
      return (char *)(void *)0;
    }

    else
    {
      for( ; !(str2[(signed long int)i] == 0); i = i + 1)
      {
        if(i == len + -1)
          break;

        str1[(signed long int)i] = str2[(signed long int)i];
      }
      str1[(signed long int)i] = (char)0;
      return str1 + (signed long int)i;
    }
}

// string_safe
// file miscfuncs.h line 46
void string_safe(char *str, signed int rep)
{
  _Bool tmp_if_expr$2;
  const unsigned short int **return_value___ctype_b_loc$1;
  while(!(*str == 0))
  {
    if(!((-128 & (signed int)*str) == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      tmp_if_expr$2 = !(((signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*str] & (signed int)(unsigned short int)16384) != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      *str = (char)rep;

    str = str + 1l;
  }
}

// string_to_number
// file miscfuncs.h line 41
signed int string_to_number(const char *str, signed int *num)
{
  signed int i = 0;
  signed int val = 0;
  if(str == ((const char *)NULL))
    return 0;

  else
  {
    while(!(str[(signed long int)i] == 0))
    {
      const unsigned short int **return_value___ctype_b_loc$1;
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)str[(signed long int)i]]) == 0))
        val = val * 10 + ((signed int)str[(signed long int)i] - 48);

      else
        return 0;
      i = i + 1;
    }
    *num = val;
    return 1;
  }
}

// thread_attribute_init
// file thread.c line 54
static void thread_attribute_init(union pthread_attr_t *attr, signed int joinable, unsigned long int stacksz)
{
  signed int j = joinable != 0 ? 0 : 1;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1=pthread_attr_init(attr);
  if(!(*return_value___errno_location$1 == 0))
    msglog(0 | 128, "thread_attribute_init: pthread_attr_init");

  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2=pthread_attr_setdetachstate(attr, j);
  if(!(*return_value___errno_location$2 == 0))
    msglog(0 | 128, "thread_attribute_init: pthread_attr_setdetachstate");

  signed int *return_value___errno_location$3;
  if(!(stacksz == 0ul))
  {
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3=pthread_attr_setstacksize(attr, stacksz);
    if(!(*return_value___errno_location$3 == 0))
      msglog(0 | 128, "thread_attribute_init: pthread_attr_setstacksize %d", stacksz);

  }

  signed int *return_value___errno_location$4;
  return_value___errno_location$4=__errno_location();
  *return_value___errno_location$4=pthread_attr_setscope(attr, 0);
  if(!(*return_value___errno_location$4 == 0))
    msglog(0 | 128, "thread_attribute_init: pthread_attr_setscope PTHREAD_SCOPE_SYSTEM");

}

// thread_cache_init
// file thread_cache.h line 62
void thread_cache_init(struct thread_cache *tc, void (*cb)(struct packet *), signed int n_slots, signed int max_thread_wait)
{
  pthread_mutex_init(&tc->lock, &common_mutex_attr);
  pthread_cond_init(&tc->count_cond, &common_cond_attr);
  pthread_cond_init(&tc->waiting_cond, &common_cond_attr);
  tc->stop = 0;
  tc->cb = cb;
  tc->thread_count = 0;
  tc->pending_count = 0;
  tc->thread_waiting = 0;
  tc->n_slots = n_slots;
  tc->max_thread_wait = max_thread_wait;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)n_slots, sizeof(struct packet *) /*8ul*/ );
  tc->pkt_slots = (struct packet **)return_value_calloc$1;
  if(tc->pkt_slots == ((struct packet **)NULL))
    msglog(0, "thread_cache_init: could not allocate memory");

  tc->in = 0;
  tc->out = 0;
}

// thread_cache_new
// file thread_cache.h line 61
void thread_cache_new(struct thread_cache *tc, struct packet *pkt)
{
  signed int pkt_pending;
  pkt->tc = tc;
  pthread_mutex_lock(&tc->lock);
  signed int tmp_if_expr$1;
  if(tc->in >= tc->out)
    tmp_if_expr$1 = tc->in - tc->out;

  else
    tmp_if_expr$1 = (tc->n_slots - tc->out) + tc->in;
  pkt_pending = tmp_if_expr$1;
  _Bool tmp_if_expr$4;
  if(tc->thread_waiting == 0)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = tc->pkt_slots[(signed long int)tc->in] != ((struct packet *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = pkt_pending > tc->thread_waiting ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$5)
  {
    if(tc->pending_count >= 30001)
    {
      tc->thread_count = tc->thread_count + tc->pending_count;
      tc->pending_count = 0;
    }

    pthread_mutex_unlock(&tc->lock);
    signed int return_value_thread_new$2;
    return_value_thread_new$2=thread_new(thread_cache_thread, (void *)pkt, (unsigned long int *)(void *)0);
    if(!(return_value_thread_new$2 == 0))
    {
      tc->pending_count = tc->pending_count + 1;
      goto __CPROVER_DUMP_L13;
    }

    pthread_mutex_lock(&tc->lock);
    if(tc->thread_waiting == 0)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = tc->pkt_slots[(signed long int)tc->in] != ((struct packet *)NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      pthread_mutex_unlock(&tc->lock);
      thread_new_wait(thread_cache_thread, (void *)pkt, (signed long int)1);
      tc->pending_count = tc->pending_count + 1;
      goto __CPROVER_DUMP_L13;
    }

  }

  tc->pkt_slots[(signed long int)tc->in] = pkt;
  tc->in = (tc->in + 1) % tc->n_slots;
  pthread_mutex_unlock(&tc->lock);
  pthread_cond_signal(&tc->waiting_cond);

__CPROVER_DUMP_L13:
  ;
}

// thread_cache_stop
// file thread_cache.h line 64
void thread_cache_stop(struct thread_cache *tc)
{
  signed int i;
  struct timespec timeout;
  tc->stop = 1;
  pthread_mutex_lock(&tc->lock);
  tc->thread_count = tc->thread_count + tc->pending_count;
  tc->pending_count = 0;
  i = 0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(i >= 3))
      tmp_if_expr$1 = tc->thread_count != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    thread_cond_timespec(&timeout, (signed long int)(2 * i + 1));
    pthread_cond_broadcast(&tc->waiting_cond);
    pthread_cond_timedwait(&tc->count_cond, &tc->lock, &timeout);
    i = i + 1;
  }
  while((_Bool)1);
  pthread_mutex_unlock(&tc->lock);
}

// thread_cache_thread
// file thread_cache.c line 81
static void * thread_cache_thread(void *x)
{
  signed int i = 0;
  struct packet *pkt = (struct packet *)x;
  struct thread_cache *tc;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  pthread_detach(return_value_pthread_self$1);
  tc = pkt->tc;
  tc->cb(pkt);
  i = i + 1;
  if(!(i >= 301))
    pkt=get_cache(tc);

  pthread_mutex_lock(&tc->lock);
  tc->thread_count = tc->thread_count - 1;
  pthread_mutex_unlock(&tc->lock);
  pthread_exit((void *)0);
}

// thread_cond_timespec
// file time_mono.h line 18
struct timespec * thread_cond_timespec(struct timespec *tp, signed long int sec)
{
  signed int return_value_clock_gettime$1;
  return_value_clock_gettime$1=clock_gettime(clockid, tp);
  if(!(return_value_clock_gettime$1 == 0))
    msglog(0 | 128, "thread_cond_timespec: clock_gettime failed");

  tp->tv_sec = tp->tv_sec + sec;
  return tp;
}

// thread_init
// file thread.h line 34
void thread_init(void)
{
  thread_attribute_init(&cmn_attr, 0, (unsigned long int)0);
  thread_attribute_init(&join_attr, 1, (unsigned long int)0);
  mutexattr_init();
  condattr_init();
}

// thread_new
// file thread.h line 35
signed int thread_new(void * (*th_func)(void *), void *data, unsigned long int *pt)
{
  unsigned long int p;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1=pthread_create(&p, &cmn_attr, th_func, data);
  if(!(*return_value___errno_location$1 == 0))
  {
    msglog(4 | 128, "thread_new: pthread_create");
    if(!(pt == ((unsigned long int *)NULL)))
      *pt = (unsigned long int)0;

    return 0;
  }

  else
  {
    if(!(pt == ((unsigned long int *)NULL)))
      *pt = p;

    return 1;
  }
}

// thread_new_joinable
// file thread.h line 37
signed int thread_new_joinable(void * (*th_func)(void *), void *data, unsigned long int *pt)
{
  unsigned long int p;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1=pthread_create(&p, &join_attr, th_func, data);
  if(!(*return_value___errno_location$1 == 0))
  {
    msglog(4 | 128, "thread_new_joinable: pthread_create");
    if(!(pt == ((unsigned long int *)NULL)))
      *pt = (unsigned long int)0;

    return 0;
  }

  else
  {
    if(!(pt == ((unsigned long int *)NULL)))
      *pt = p;

    return 1;
  }
}

// thread_new_wait
// file thread.h line 36
unsigned long int thread_new_wait(void * (*th_func)(void *), void *data, signed long int retry)
{
  unsigned long int pt;
  if(!(retry >= 1l))
    retry = (signed long int)5;

  signed int *return_value___errno_location$1;
  do
  {
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1=pthread_create(&pt, &cmn_attr, th_func, data);
    if(*return_value___errno_location$1 == 0)
      break;

    msglog(4 | 128, "thread_new_wait: pthread_create");
    sleep((unsigned int)retry);
  }
  while((_Bool)1);
  return pt;
}

// time_mono
// file time_mono.h line 14
signed long int time_mono(void)
{
  const char *myname = "time_monotonic";
  struct timespec tp;
  signed int return_value_clock_gettime$1;
  return_value_clock_gettime$1=clock_gettime(clockid, &tp);
  if(!(return_value_clock_gettime$1 == 0))
    msglog(0 | 128, "%s: clock_gettime failed", myname);

  return tp.tv_sec;
}

// time_mono_init
// file time_mono.h line 7
extern void time_mono_init(void)
{
  if(initialized == 0)
  {
    signed long int return_value_sysconf$1;
    return_value_sysconf$1=sysconf(149);
    if(return_value_sysconf$1 >= 1l)
      clockid = 1;

    time_mono();
    initialized = 1;
  }

}

// umount_all
// file autodir.c line 159
static signed int umount_all(void)
{
  char path[4097l];
  struct dirent *de;
  struct __dirstream *dp;
  dp=opendir(autodir.path);
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$5;
  signed int tmp_statement_expression$3;
  if(dp == ((struct __dirstream *)NULL))
  {
    msglog(4 | 128, "umount_all: opendir %s", autodir.path);
    return 0;
  }

  else
  {
    do
    {
      de=readdir(dp);
      if(de == ((struct dirent *)NULL))
        break;

      unsigned long int __s1_len;
      unsigned long int umount_all$$1$$2$$1$$__s2_len;
      signed int return_value___builtin_strcmp$2;
      return_value___builtin_strcmp$2=__builtin_strcmp(de->d_name, ".");
      tmp_statement_expression$1 = return_value___builtin_strcmp$2;
      if(tmp_statement_expression$1 == 0)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        unsigned long int umount_all$$1$$2$$2$$__s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp$4;
        return_value___builtin_strcmp$4=__builtin_strcmp(de->d_name, "..");
        tmp_statement_expression$3 = return_value___builtin_strcmp$4;
        tmp_if_expr$5 = !(tmp_statement_expression$3 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$5)
      {
        snprintf(path, sizeof(char [4097l]) /*4097ul*/ , "%s/%s", autodir.path, (const void *)de->d_name);
        signed int return_value_umount_dir$6;
        return_value_umount_dir$6=umount_dir(path);
        if(!(return_value_umount_dir$6 == 1))
        {
          msglog(5, "could not unmount %s", (const void *)path);
          continue;
        }

        else
          lockfile_remove(de->d_name);
      }

    }
    while((_Bool)1);
    closedir(dp);
    return 1;
  }
}

// umount_dir
// file autodir.c line 124
static signed int umount_dir(char *path)
{
  struct stat st;
  signed int return_value_lstat$2;
  return_value_lstat$2=lstat(path, &st);
  if(!(return_value_lstat$2 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 2)
      return 1;

    msglog(4 | 128, "umount_dir: lstat %s", path);
    return 0;
  }

  if(!((61440u & st.st_mode) == 16384u))
  {
    msglog(2, "umount_dir: not directory: %s", path);
    return 0;
  }

  else
  {
    if(!(st.st_dev == autodir.dev))
    {
      signed int return_value_umount$4;
      return_value_umount$4=umount(path);
      if(!(return_value_umount$4 == 0))
      {
        msglog(6 | 128, "umount %s", path);
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(*return_value___errno_location$3 == 16)
          return 2;

      }

    }

    signed int return_value_rmdir$5;
    return_value_rmdir$5=rmdir(path);
    if(!(return_value_rmdir$5 == 0))
    {
      msglog(4 | 128, "umount_dir: rmdir %s", path);
      return 0;
    }

    else
      return 1;
  }
}

// wait_extra_expirethread
// file expire.c line 158
static void wait_extra_expirethread(void)
{
  signed int i;
  pthread_mutex_lock(&expire.lock);
  pthread_mutex_unlock(&expire.lock);
  i = 0;
  for( ; !(i >= 10); i = i + 1)
    if(!(expire.threads[(signed long int)i] == 0ul))
      pthread_join(expire.threads[(signed long int)i], (void **)(void *)0);

}

// wait_pid
// file backup_child.c line 235
static signed int wait_pid(signed int pid, struct backup_pid *bp)
{
  pthread_mutex_lock(&bp->lock);
  if(bp->kill == 0)
  {
    bp->pid = pid;
    bp->waiting = bp->waiting + 1;
    pthread_cond_wait(&bp->wait, &bp->lock);
    bp->waiting = bp->waiting - 1;
    if(bp->waiting == 0)
    {
      pthread_mutex_unlock(&bp->lock);
      backup_pidmem_free(bp);
      return 0;
    }

    pthread_mutex_unlock(&bp->lock);
    return 0;
  }

  else
  {
    pthread_mutex_unlock(&bp->lock);
    return pid;
  }
}

// wentry_free
// file workon.c line 88
static void wentry_free(struct wentry *we)
{
  struct wentry *tmp;
  if(!(we == ((struct wentry *)NULL)))
  {
    pthread_mutex_destroy(&we->wait);
    if(!(wcache.count >= 50))
    {
      pthread_mutex_lock(&wcache.lock);
      if(wcache.count >= 50)
      {
        pthread_mutex_unlock(&wcache.lock);
        free((void *)we);
        goto __CPROVER_DUMP_L5;
      }

      tmp = wcache.list;
      wcache.list = we;
      we->next = tmp;
      wcache.count = wcache.count + 1;
      pthread_mutex_unlock(&wcache.lock);
      goto __CPROVER_DUMP_L5;
    }

    else
      free((void *)we);
  }


__CPROVER_DUMP_L5:
  ;
}

// wentry_malloc
// file workon.c line 65
static struct wentry * wentry_malloc(void)
{
  struct wentry *tmp;
  if(wcache.count >= 1)
  {
    pthread_mutex_lock(&wcache.lock);
    if(!(wcache.count >= 1))
    {
      pthread_mutex_unlock(&wcache.lock);
      goto dyn_alloc;
    }

    tmp = wcache.list;
    wcache.list = wcache.list->next;
    wcache.count = wcache.count - 1;
    pthread_mutex_unlock(&wcache.lock);
    return tmp;
  }

  else
  {

  dyn_alloc:
    ;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct wentry) /*312ul*/ );
    return (struct wentry *)return_value_malloc$1;
  }
}

// whash_resize
// file workon.c line 116
static void whash_resize(void)
{
  signed int new_size;
  signed int old_size = whash_size;
  struct wentry **new_whash;
  struct wentry **dptr;
  struct wentry **h = whash;
  struct wentry *wentry;
  struct wentry *next;
  new_size = whash_size * 2;
  new_size = new_size | 1;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)new_size, sizeof(struct wentry *) /*8ul*/ );
  new_whash = (struct wentry **)return_value_calloc$1;
  signed int tmp_post$2;
  struct wentry **tmp_post$3;
  if(!(new_whash == ((struct wentry **)NULL)))
  {
    do
    {
      tmp_post$2 = old_size;
      old_size = old_size - 1;
      if(!(tmp_post$2 >= 1))
        break;

      tmp_post$3 = h;
      h = h + 1l;
      wentry = *tmp_post$3;
      for( ; !(wentry == ((struct wentry *)NULL)); wentry = next)
      {
        next = wentry->next;
        dptr = &new_whash[(signed long int)(wentry->hash % (unsigned int)new_size)];
        wentry->next = *dptr;
        *dptr = wentry;
      }
    }
    while((_Bool)1);
    whash_size = new_size;
    free((void *)whash);
    whash = new_whash;
  }

}

// workon_cleanup
// file workon.c line 259
static void workon_cleanup(void)
{
  signed int i;
  struct wentry *we;
  struct wentry *tmp;
  pthread_mutex_destroy(&hash_lock);
  i = 0;
  for( ; !(i >= whash_size); i = i + 1)
    if(!(whash[(signed long int)i] == ((struct wentry *)NULL)))
    {
      we = whash[(signed long int)i];
      while(!(we == ((struct wentry *)NULL)))
      {
        pthread_mutex_destroy(&we->wait);
        tmp = we;
        we = we->next;
        free((void *)tmp);
      }
    }

  free((void *)whash);
  pthread_mutex_destroy(&wcache.lock);
  we = wcache.list;
  while(!(we == ((struct wentry *)NULL)))
  {
    tmp = we;
    we = we->next;
    free((void *)tmp);
  }
}

// workon_init
// file workon.h line 27
void workon_init(void)
{
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)13, sizeof(struct wentry *) /*8ul*/ );
  whash = (struct wentry **)return_value_calloc$1;
  if(whash == ((struct wentry **)NULL))
    msglog(0, "workon_init: could not allocate hash table");

  whash_used = 0;
  whash_size = 13;
  pthread_mutex_init(&hash_lock, &common_mutex_attr);
  wcache.list = (struct wentry *)(void *)0;
  wcache.count = 0;
  pthread_mutex_init(&wcache.lock, &common_mutex_attr);
  signed int return_value_atexit$2;
  return_value_atexit$2=atexit(workon_cleanup);
  if(!(return_value_atexit$2 == 0))
  {
    workon_cleanup();
    msglog(0, "workon_init: could not reigster cleanup method");
  }

}

// workon_name
// file workon.h line 28
signed int workon_name(const char *name)
{
  unsigned int workon_name$$1$$hash;
  struct wentry **dptr;
  struct wentry *new_ent;
  struct wentry *ent;
  _Bool tmp_if_expr$1;
  if(name == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(*name != 0) ? (_Bool)1 : (_Bool)0;
  signed int tmp_statement_expression$2;
  if(tmp_if_expr$1)
  {
    msglog(4, "workon_name: invalid name");
    return 0;
  }

  else
  {
    new_ent=wentry_malloc();
    if(new_ent == ((struct wentry *)NULL))
    {
      msglog(2, "workon_name: could not allocate memory");
      return 0;
    }

    else
    {
      workon_name$$1$$hash=string_hash(name);
      string_n_copy(new_ent->name, name, (signed int)sizeof(char [256l]) /*256ul*/ );
      new_ent->hash = workon_name$$1$$hash;
      new_ent->in_use = 1;
      new_ent->next = (struct wentry *)(void *)0;
      pthread_mutex_init(&new_ent->wait, &common_mutex_attr);
      pthread_mutex_lock(&hash_lock);
      do
      {
        dptr = &whash[(signed long int)(workon_name$$1$$hash % (unsigned int)whash_size)];
        for( ; !(*dptr == ((struct wentry *)NULL)); dptr = &(*dptr)->next)
          if((*dptr)->hash == workon_name$$1$$hash)
          {
            if(*name == (*dptr)->name[0l])
            {
              unsigned long int __s1_len;
              unsigned long int __s2_len;
              signed int return_value___builtin_strcmp$3;
              return_value___builtin_strcmp$3=__builtin_strcmp(name, (*dptr)->name);
              tmp_statement_expression$2 = return_value___builtin_strcmp$3;
              if(tmp_statement_expression$2 == 0)
                break;

            }

          }

      }
      while((_Bool)0);
      ent = *dptr;
      if(!(ent == ((struct wentry *)NULL)))
      {
        ent->in_use = ent->in_use + 1;
        pthread_mutex_unlock(&hash_lock);
        wentry_free(new_ent);
        pthread_mutex_lock(&ent->wait);
        return 1;
      }

      else
      {
        *dptr = new_ent;
        whash_used = whash_used + 1;
        if(!(whash_size >= whash_used))
          whash_resize();

        pthread_mutex_unlock(&hash_lock);
        pthread_mutex_lock(&new_ent->wait);
        return 1;
      }
    }
  }
}

// workon_release
// file workon.h line 29
void workon_release(const char *name)
{
  struct wentry **dptr;
  struct wentry *ent;
  struct wentry *tmp = (struct wentry *)(void *)0;
  unsigned int workon_release$$1$$hash;
  _Bool tmp_if_expr$1;
  if(name == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(*name != 0) ? (_Bool)1 : (_Bool)0;
  signed int tmp_statement_expression$2;
  if(tmp_if_expr$1)
    msglog(4, "workon_release: invalid name");

  else
  {
    workon_release$$1$$hash=string_hash(name);
    pthread_mutex_lock(&hash_lock);
    do
    {
      dptr = &whash[(signed long int)(workon_release$$1$$hash % (unsigned int)whash_size)];
      for( ; !(*dptr == ((struct wentry *)NULL)); dptr = &(*dptr)->next)
        if((*dptr)->hash == workon_release$$1$$hash)
        {
          if(*name == (*dptr)->name[0l])
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$3;
            return_value___builtin_strcmp$3=__builtin_strcmp(name, (*dptr)->name);
            tmp_statement_expression$2 = return_value___builtin_strcmp$3;
            if(tmp_statement_expression$2 == 0)
              break;

          }

        }

    }
    while((_Bool)0);
    ent = *dptr;
    if(ent == ((struct wentry *)NULL))
    {
      pthread_mutex_unlock(&hash_lock);
      msglog(2, "workon_release: entry for %s does not exist", name);
    }

    else
    {
      ent->in_use = ent->in_use - 1;
      if(ent->in_use == 0)
      {
        *dptr = ent->next;
        tmp = ent;
        whash_used = whash_used - 1;
      }

      pthread_mutex_unlock(&hash_lock);
      pthread_mutex_unlock(&ent->wait);
      if(!(tmp == ((struct wentry *)NULL)))
        wentry_free(tmp);

    }
  }
}

// write_all
// file miscfuncs.c line 223
signed int write_all(signed int fd, const char *buf, signed int buf_sz)
{
  signed int n;
  do
  {
    signed long int return_value_write$1;
    return_value_write$1=write(fd, (const void *)buf, (unsigned long int)buf_sz);
    n = (signed int)return_value_write$1;
    if(!(n >= 1))
    {
      if(!(n == 0))
        msglog(4 | 128, "write_all: write");

      return 0;
    }

    buf_sz = buf_sz - n;
    buf = buf + (signed long int)n;
  }
  while(!(buf_sz == 0));
  return 1;
}

// write_pidfile
// file autodir.c line 570
static void write_pidfile(signed int pid)
{
  struct _IO_FILE *pidfp;
  if(!(self.pid_file == ((char *)NULL)))
  {
    pidfp=fopen(self.pid_file, "wt");
    if(!(pidfp == ((struct _IO_FILE *)NULL)))
    {
      fprintf(pidfp, "%lu\n", (unsigned long int)pid);
      fclose(pidfp);
    }

    else
      msglog(5 | 128, "write_pidfile: failed to write pid file %s", self.pid_file);
  }

}

