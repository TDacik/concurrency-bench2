// tag-#anon#ST[ARR128{U8}_U8_'cert_verify_md'||ARR128{U8}_U8_'finish_md'||S32'finish_md_len'||ARR128{U8}_U8_'peer_finish_md'||S32'peer_finish_md_len'||U64'message_size'||S32'message_type'||U32'_pad0'||*{cSYM#tag-ssl_cipher_st#}_cSYM#tag-ssl_cipher_st#_'new_cipher'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ecdh'||S32'next_state'||S32'reuse_message'||S32'cert_req'||S32'ctype_num'||ARR9{S8}_S8_'ctype'||U56'_pad1'||*{SYM#tag-stack_st_X509_NAME#}_SYM#tag-stack_st_X509_NAME#_'ca_names'||S32'use_rsa_tmp'||S32'key_block_length'||*{U8}_U8_'key_block'||*{cSYM#tag-evp_cipher_st#}_cSYM#tag-evp_cipher_st#_'new_sym_enc'||*{cSYM#tag-env_md_st#}_cSYM#tag-env_md_st#_'new_hash'||S32'new_mac_pkey_type'||S32'new_mac_secret_size'||*{cSYM#tag-ssl_comp_st#}_cSYM#tag-ssl_comp_st#_'new_compression'||S32'cert_request'||U32'_pad2'|]
// file /usr/include/openssl/ssl3.h line 553
struct anonymous_11;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_2;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_7;

// tag-#anon#ST[S32'sess_connect'||S32'sess_connect_renegotiate'||S32'sess_connect_good'||S32'sess_accept'||S32'sess_accept_renegotiate'||S32'sess_accept_good'||S32'sess_miss'||S32'sess_timeout'||S32'sess_cache_full'||S32'sess_hit'||S32'sess_cb_hit'|]
// file /usr/include/openssl/ssl.h line 964
struct anonymous_12;

// tag-#anon#ST[U32'conn_id_length'||U32'cert_type'||U32'cert_length'||U32'csl'||U32'clear'||U32'enc'||ARR32{U8}_U8_'ccl'||U32'cipher_spec_length'||U32'session_id_length'||U32'clen'||U32'rlen'|]
// file /usr/include/openssl/ssl2.h line 203
struct anonymous_10;

// tag-#anon#UN[*{S32}_S32_'inherit'||*{SYM#tag-stack_st_ASIdOrRange#}_SYM#tag-stack_st_ASIdOrRange#_'asIdsOrRanges'|]
// file /usr/include/openssl/x509v3.h line 783
union anonymous_4;

// tag-#anon#UN[*{S8}_S8_'ptr'||*{SYM#tag-otherName_st#}_SYM#tag-otherName_st#_'otherName'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'rfc822Name'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'dNSName'||*{SYM#tag-asn1_type_st#}_SYM#tag-asn1_type_st#_'x400Address'||*{SYM#tag-X509_name_st#}_SYM#tag-X509_name_st#_'directoryName'||*{SYM#tag-EDIPartyName_st#}_SYM#tag-EDIPartyName_st#_'ediPartyName'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'uniformResourceIdentifier'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'iPAddress'||*{SYM#tag-asn1_object_st#}_SYM#tag-asn1_object_st#_'registeredID'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'ip'||*{SYM#tag-X509_name_st#}_SYM#tag-X509_name_st#_'dirn'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'ia5'||*{SYM#tag-asn1_object_st#}_SYM#tag-asn1_object_st#_'rid'||*{SYM#tag-asn1_type_st#}_SYM#tag-asn1_type_st#_'other'|]
// file /usr/include/openssl/x509v3.h line 188
union anonymous_5;

// tag-#anon#UN[*{S8}_S8_'ptr'||*{SYM#tag-rsa_st#}_SYM#tag-rsa_st#_'rsa'||*{SYM#tag-dsa_st#}_SYM#tag-dsa_st#_'dsa'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous_8;

// tag-#anon#UN[*{S8}_S8_'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'asn1_string'||*{SYM#tag-asn1_object_st#}_SYM#tag-asn1_object_st#_'object'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'integer'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'enumerated'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bit_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'octet_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'printablestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'t61string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'ia5string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bmpstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'universalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utctime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalizedtime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'visiblestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utf8string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'set'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'sequence'||*{SYM#tag-ASN1_VALUE_st#}_SYM#tag-ASN1_VALUE_st#_'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous;

// tag-#anon#UN[*{SYM#tag-stack_st_GENERAL_NAME#}_SYM#tag-stack_st_GENERAL_NAME#_'fullname'||*{SYM#tag-stack_st_X509_NAME_ENTRY#}_SYM#tag-stack_st_X509_NAME_ENTRY#_'relativename'|]
// file /usr/include/openssl/x509v3.h line 228
union anonymous_0;

// tag-#anon#UN[*{V(S32|S32|*{V}_V_)->V}_V(S32|S32|*{V}_V_)->V_'cb_1'||*{S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32}_S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32_'cb_2'|]
// file /usr/include/openssl/bn.h line 351
union anonymous_6;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_9;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_3;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_1;

// tag-ASIdentifierChoice_st
// file /usr/include/openssl/x509v3.h line 781
struct ASIdentifierChoice_st;

// tag-ASIdentifiers_st
// file /usr/include/openssl/x509.h line 293
struct ASIdentifiers_st;

// tag-ASN1_ENCODING_st
// file /usr/include/openssl/asn1.h line 257
struct ASN1_ENCODING_st;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-AUTHORITY_KEYID_st
// file /usr/include/openssl/ossl_typ.h line 186
struct AUTHORITY_KEYID_st;

// tag-DIST_POINT_NAME_st
// file /usr/include/openssl/x509v3.h line 226
struct DIST_POINT_NAME_st;

// tag-DSA_SIG_st
// file /usr/include/openssl/dsa.h line 124
struct DSA_SIG_st;

// tag-EDIPartyName_st
// file /usr/include/openssl/x509v3.h line 172
struct EDIPartyName_st;

// tag-GENERAL_NAME_st
// file /usr/include/openssl/x509v3.h line 177
struct GENERAL_NAME_st;

// tag-ISSUING_DIST_POINT_st
// file /usr/include/openssl/ossl_typ.h line 188
struct ISSUING_DIST_POINT_st;

// tag-NAME_CONSTRAINTS_st
// file /usr/include/openssl/ossl_typ.h line 189
struct NAME_CONSTRAINTS_st;

// tag-X509_POLICY_CACHE_st
// file /usr/include/openssl/ossl_typ.h line 184
struct X509_POLICY_CACHE_st;

// tag-X509_POLICY_TREE_st
// file /usr/include/openssl/ossl_typ.h line 183
struct X509_POLICY_TREE_st;

// tag-X509_VERIFY_PARAM_ID_st
// file /usr/include/openssl/x509_vfy.h line 159
struct X509_VERIFY_PARAM_ID_st;

// tag-X509_VERIFY_PARAM_st
// file /usr/include/openssl/x509_vfy.h line 167
struct X509_VERIFY_PARAM_st;

// tag-X509_algor_st
// file /usr/include/openssl/ossl_typ.h line 155
struct X509_algor_st;

// tag-X509_crl_info_st
// file /usr/include/openssl/x509.h line 441
struct X509_crl_info_st;

// tag-X509_crl_st
// file /usr/include/openssl/ossl_typ.h line 156
struct X509_crl_st;

// tag-X509_name_st
// file /usr/include/openssl/ossl_typ.h line 159
struct X509_name_st;

// tag-X509_pubkey_st
// file /usr/include/openssl/ossl_typ.h line 160
struct X509_pubkey_st;

// tag-X509_val_st
// file /usr/include/openssl/x509.h line 152
struct X509_val_st;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_mosquitto_packet
// file ./mosquitto_internal.h line 122
struct _mosquitto_packet;

// tag-_mosquitto_protocol
// file ./mosquitto_internal.h line 108
enum _mosquitto_protocol { mosq_p_invalid=0, mosq_p_mqtt31=1, mosq_p_mqtt311=2, mosq_p_mqtts=3 };

// tag-_pqueue
// file /usr/include/openssl/pqueue.h line 70
struct _pqueue;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-ares_channeldata
// file /usr/include/ares.h line 272
struct ares_channeldata;

// tag-ares_srv_reply
// file /usr/include/ares.h line 457
struct ares_srv_reply;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-bn_blinding_st
// file /usr/include/openssl/ossl_typ.h line 122
struct bn_blinding_st;

// tag-bn_gencb_st
// file /usr/include/openssl/ossl_typ.h line 125
struct bn_gencb_st;

// tag-bn_mont_ctx_st
// file /usr/include/openssl/ossl_typ.h line 123
struct bn_mont_ctx_st;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-cert_st
// file /usr/include/openssl/ssl.h line 1035
struct cert_st;

// tag-comp_ctx_st
// file /usr/include/openssl/comp.h line 11
struct comp_ctx_st;

// tag-comp_method_st
// file /usr/include/openssl/comp.h line 13
struct comp_method_st;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-dh_method
// file /usr/include/openssl/ossl_typ.h line 141
struct dh_method;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dsa_method
// file /usr/include/openssl/ossl_typ.h line 144
struct dsa_method;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-dtls1_bitmap_st
// file /usr/include/openssl/dtls1.h line 128
struct dtls1_bitmap_st;

// tag-dtls1_retransmit_state
// file /usr/include/openssl/dtls1.h line 135
struct dtls1_retransmit_state;

// tag-dtls1_state_st
// file /usr/include/openssl/ssl.h line 1493
struct dtls1_state_st;

// tag-dtls1_timeout_st
// file /usr/include/openssl/dtls1.h line 162
struct dtls1_timeout_st;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-hm_header_st
// file /usr/include/openssl/dtls1.h line 147
struct hm_header_st;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-lhash_st_SSL_SESSION
// file /usr/include/openssl/ssl.h line 923
struct lhash_st_SSL_SESSION;

// tag-mosq_config
// file client_shared.h line 33
struct mosq_config;

// tag-mosq_opt_t
// file ../lib/mosquitto.h line 87
enum mosq_opt_t { MOSQ_OPT_PROTOCOL_VERSION=1 };

// tag-mosquitto
// file ./mosquitto.h line 106
struct mosquitto;

// tag-mosquitto_client_state
// file ./mosquitto_internal.h line 89
enum mosquitto_client_state { mosq_cs_new=0, mosq_cs_connected=1, mosq_cs_disconnecting=2, mosq_cs_connect_async=3, mosq_cs_connect_pending=4, mosq_cs_connect_srv=5, mosq_cs_disconnect_ws=6, mosq_cs_disconnected=7, mosq_cs_socks5_new=8, mosq_cs_socks5_start=9, mosq_cs_socks5_request=10, mosq_cs_socks5_reply=11, mosq_cs_socks5_auth_ok=12, mosq_cs_socks5_userpass_reply=13, mosq_cs_socks5_send_userpass=14, mosq_cs_expiring=15 };

// tag-mosquitto_db
// file ./read_handle.h line 20
struct mosquitto_db;

// tag-mosquitto_message
// file ./mosquitto.h line 97
struct mosquitto_message;

// tag-mosquitto_message_all
// file ./mosquitto_internal.h line 135
struct mosquitto_message_all;

// tag-mosquitto_msg_direction
// file ./mosquitto_internal.h line 69
enum mosquitto_msg_direction { mosq_md_in=0, mosq_md_out=1 };

// tag-mosquitto_msg_state
// file ./mosquitto_internal.h line 74
enum mosquitto_msg_state { mosq_ms_invalid=0, mosq_ms_publish_qos0=1, mosq_ms_publish_qos1=2, mosq_ms_wait_for_puback=3, mosq_ms_publish_qos2=4, mosq_ms_wait_for_pubrec=5, mosq_ms_resend_pubrel=6, mosq_ms_wait_for_pubrel=7, mosq_ms_resend_pubcomp=8, mosq_ms_wait_for_pubcomp=9, mosq_ms_send_pubrec=10, mosq_ms_queued=11 };

// tag-otherName_st
// file /usr/include/openssl/x509v3.h line 167
struct otherName_st;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-record_pqueue_st
// file /usr/include/openssl/dtls1.h line 171
struct record_pqueue_st;

// tag-rsa_meth_st
// file /usr/include/openssl/ossl_typ.h line 147
struct rsa_meth_st;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-sess_cert_st
// file /usr/include/openssl/ssl.h line 531
struct sess_cert_st;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-srp_ctx_st
// file /usr/include/openssl/ssl.h line 849
struct srp_ctx_st;

// tag-srtp_protection_profile_st
// file /usr/include/openssl/ssl.h line 383
struct srtp_protection_profile_st;

// tag-ssl2_state_st
// file /usr/include/openssl/ssl.h line 1491
struct ssl2_state_st;

// tag-ssl3_buf_freelist_st
// file /usr/include/openssl/ssl.h line 1114
struct ssl3_buf_freelist_st;

// tag-ssl3_buffer_st
// file /usr/include/openssl/ssl3.h line 438
struct ssl3_buffer_st;

// tag-ssl3_enc_method
// file /usr/include/openssl/ssl.h line 466
struct ssl3_enc_method;

// tag-ssl3_record_st
// file /usr/include/openssl/ssl3.h line 403
struct ssl3_record_st;

// tag-ssl3_state_st
// file /usr/include/openssl/ssl.h line 1492
struct ssl3_state_st;

// tag-ssl_cipher_st
// file /usr/include/openssl/ssl.h line 375
struct ssl_cipher_st;

// tag-ssl_comp_st
// file /usr/include/openssl/ssl.h line 908
struct ssl_comp_st;

// tag-ssl_ctx_st
// file /usr/include/openssl/ossl_typ.h line 179
struct ssl_ctx_st;

// tag-ssl_method_st
// file /usr/include/openssl/ssl.h line 374
struct ssl_method_st;

// tag-ssl_session_st
// file /usr/include/openssl/ssl.h line 376
struct ssl_session_st;

// tag-ssl_st
// file /usr/include/openssl/ossl_typ.h line 178
struct ssl_st;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_ASIdOrRange
// file /usr/include/openssl/x509v3.h line 775
struct stack_st_ASIdOrRange;

// tag-stack_st_ASN1_OBJECT
// file /usr/include/openssl/asn1.h line 793
struct stack_st_ASN1_OBJECT;

// tag-stack_st_DIST_POINT
// file /usr/include/openssl/x509.h line 288
struct stack_st_DIST_POINT;

// tag-stack_st_GENERAL_NAME
// file /usr/include/openssl/x509.h line 289
struct stack_st_GENERAL_NAME;

// tag-stack_st_GENERAL_NAMES
// file /usr/include/openssl/x509.h line 471
struct stack_st_GENERAL_NAMES;

// tag-stack_st_GENERAL_SUBTREE
// file /usr/include/openssl/x509v3.h line 330
struct stack_st_GENERAL_SUBTREE;

// tag-stack_st_IPAddressFamily
// file /usr/include/openssl/x509.h line 292
struct stack_st_IPAddressFamily;

// tag-stack_st_OCSP_RESPID
// file /usr/include/openssl/ssl.h line 1610
struct stack_st_OCSP_RESPID;

// tag-stack_st_SRTP_PROTECTION_PROFILE
// file /usr/include/openssl/ssl.h line 388
struct stack_st_SRTP_PROTECTION_PROFILE;

// tag-stack_st_SSL_CIPHER
// file /usr/include/openssl/ssl.h line 380
struct stack_st_SSL_CIPHER;

// tag-stack_st_SSL_COMP
// file /usr/include/openssl/ssl.h line 922
struct stack_st_SSL_COMP;

// tag-stack_st_X509
// file /usr/include/openssl/x509.h line 301
struct stack_st_X509;

// tag-stack_st_X509_ALGOR
// file /usr/include/openssl/asn1.h line 162
struct stack_st_X509_ALGOR;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stack_st_X509_CRL
// file /usr/include/openssl/x509.h line 476
struct stack_st_X509_CRL;

// tag-stack_st_X509_EXTENSION
// file /usr/include/openssl/x509.h line 202
struct stack_st_X509_EXTENSION;

// tag-stack_st_X509_LOOKUP
// file /usr/include/openssl/x509_vfy.h line 136
struct stack_st_X509_LOOKUP;

// tag-stack_st_X509_NAME
// file /usr/include/openssl/x509.h line 192
struct stack_st_X509_NAME;

// tag-stack_st_X509_NAME_ENTRY
// file /usr/include/openssl/x509.h line 175
struct stack_st_X509_NAME_ENTRY;

// tag-stack_st_X509_OBJECT
// file /usr/include/openssl/x509_vfy.h line 137
struct stack_st_X509_OBJECT;

// tag-stack_st_X509_REVOKED
// file /usr/include/openssl/x509.h line 438
struct stack_st_X509_REVOKED;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tls_session_ticket_ext_st
// file /usr/include/openssl/ssl.h line 373
struct tls_session_ticket_ext_st;

// tag-x509_cert_aux_st
// file /usr/include/openssl/x509.h line 262
struct x509_cert_aux_st;

// tag-x509_cinf_st
// file /usr/include/openssl/x509.h line 242
struct x509_cinf_st;

// tag-x509_crl_method_st
// file /usr/include/openssl/ossl_typ.h line 157
struct x509_crl_method_st;

// tag-x509_st
// file /usr/include/openssl/ossl_typ.h line 154
struct x509_st;

// tag-x509_store_ctx_st
// file /usr/include/openssl/ossl_typ.h line 162
struct x509_store_ctx_st;

// tag-x509_store_st
// file /usr/include/openssl/ossl_typ.h line 161
struct x509_store_st;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// ASN1_STRING_data
// file /usr/include/openssl/asn1.h line 812
unsigned char * ASN1_STRING_data(struct asn1_string_st *);
// BIO_new_socket
// file /usr/include/openssl/bio.h line 757
struct bio_st * BIO_new_socket(signed int, signed int);
// BN_bn2bin
// file /usr/include/openssl/bn.h line 442
signed int BN_bn2bin(const struct bignum_st *, unsigned char *);
// BN_free
// file /usr/include/openssl/bn.h line 492
void BN_free(struct bignum_st *);
// BN_hex2bn
// file /usr/include/openssl/bn.h line 532
signed int BN_hex2bn(struct bignum_st **, const char *);
// BN_num_bits
// file /usr/include/openssl/bn.h line 434
signed int BN_num_bits(const struct bignum_st *);
// CONF_modules_unload
// file /usr/include/openssl/conf.h line 189
void CONF_modules_unload(signed int);
// CRYPTO_cleanup_all_ex_data
// file /usr/include/openssl/crypto.h line 431
void CRYPTO_cleanup_all_ex_data(void);
// ENGINE_cleanup
// file /usr/include/openssl/engine.h line 591
void ENGINE_cleanup(void);
// ERR_error_string
// file /usr/include/openssl/err.h line 334
char * ERR_error_string(unsigned long int, char *);
// ERR_free_strings
// file /usr/include/openssl/err.h line 353
void ERR_free_strings(void);
// ERR_get_error
// file /usr/include/openssl/err.h line 321
unsigned long int ERR_get_error(void);
// ERR_remove_state
// file /usr/include/openssl/err.h line 357
void ERR_remove_state(unsigned long int);
// EVP_cleanup
// file /usr/include/openssl/evp.h line 927
void EVP_cleanup(void);
// OPENSSL_add_all_algorithms_noconf
// file /usr/include/openssl/evp.h line 905
void OPENSSL_add_all_algorithms_noconf(void);
// SSL_CTX_check_private_key
// file /usr/include/openssl/ssl.h line 2285
signed int SSL_CTX_check_private_key(const struct ssl_ctx_st *);
// SSL_CTX_ctrl
// file /usr/include/openssl/ssl.h line 2339
signed long int SSL_CTX_ctrl(struct ssl_ctx_st *, signed int, signed long int, void *);
// SSL_CTX_free
// file /usr/include/openssl/ssl.h line 2132
void SSL_CTX_free(struct ssl_ctx_st *);
// SSL_CTX_load_verify_locations
// file /usr/include/openssl/ssl.h line 2442
signed int SSL_CTX_load_verify_locations(struct ssl_ctx_st *, const char *, const char *);
// SSL_CTX_new
// file /usr/include/openssl/ssl.h line 2131
struct ssl_ctx_st * SSL_CTX_new(const struct ssl_method_st *);
// SSL_CTX_set_cipher_list
// file /usr/include/openssl/ssl.h line 2130
signed int SSL_CTX_set_cipher_list(struct ssl_ctx_st *, const char *);
// SSL_CTX_set_default_passwd_cb
// file /usr/include/openssl/ssl.h line 2282
void SSL_CTX_set_default_passwd_cb(struct ssl_ctx_st *, signed int (*)(char *, signed int, signed int, void *));
// SSL_CTX_set_default_passwd_cb_userdata
// file /usr/include/openssl/ssl.h line 2283
void SSL_CTX_set_default_passwd_cb_userdata(struct ssl_ctx_st *, void *);
// SSL_CTX_set_psk_client_callback
// file /usr/include/openssl/ssl.h line 1321
void SSL_CTX_set_psk_client_callback(struct ssl_ctx_st *, unsigned int (*)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int));
// SSL_CTX_set_verify
// file /usr/include/openssl/ssl.h line 2262
void SSL_CTX_set_verify(struct ssl_ctx_st *, signed int, signed int (*)(signed int, struct x509_store_ctx_st *));
// SSL_CTX_use_PrivateKey_file
// file /usr/include/openssl/ssl.h line 2199
signed int SSL_CTX_use_PrivateKey_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_CTX_use_certificate_chain_file
// file /usr/include/openssl/ssl.h line 2202
signed int SSL_CTX_use_certificate_chain_file(struct ssl_ctx_st *, const char *);
// SSL_connect
// file /usr/include/openssl/ssl.h line 2333
signed int SSL_connect(struct ssl_st *);
// SSL_free
// file /usr/include/openssl/ssl.h line 2331
void SSL_free(struct ssl_st *);
// SSL_get_error
// file /usr/include/openssl/ssl.h line 2342
signed int SSL_get_error(const struct ssl_st *, signed int);
// SSL_get_ex_data
// file /usr/include/openssl/ssl.h line 2460
void * SSL_get_ex_data(const struct ssl_st *, signed int);
// SSL_get_ex_data_X509_STORE_CTX_idx
// file /usr/include/openssl/ssl.h line 2477
signed int SSL_get_ex_data_X509_STORE_CTX_idx(void);
// SSL_get_ex_new_index
// file /usr/include/openssl/ssl.h line 2461
signed int SSL_get_ex_new_index(signed long int, void *, signed int (*)(void *, void *, struct crypto_ex_data_st *, signed int, signed long int, void *), signed int (*)(struct crypto_ex_data_st *, struct crypto_ex_data_st *, void *, signed int, signed long int, void *), void (*)(void *, void *, struct crypto_ex_data_st *, signed int, signed long int, void *));
// SSL_library_init
// file /usr/include/openssl/ssl.h line 2419
signed int SSL_library_init(void);
// SSL_load_error_strings
// file /usr/include/openssl/ssl.h line 2216
void SSL_load_error_strings(void);
// SSL_new
// file /usr/include/openssl/ssl.h line 2291
struct ssl_st * SSL_new(struct ssl_ctx_st *);
// SSL_pending
// file /usr/include/openssl/ssl.h line 2154
signed int SSL_pending(const struct ssl_st *);
// SSL_read
// file /usr/include/openssl/ssl.h line 2334
signed int SSL_read(struct ssl_st *, void *, signed int);
// SSL_set_bio
// file /usr/include/openssl/ssl.h line 2161
void SSL_set_bio(struct ssl_st *, struct bio_st *, struct bio_st *);
// SSL_set_ex_data
// file /usr/include/openssl/ssl.h line 2459
signed int SSL_set_ex_data(struct ssl_st *, signed int, void *);
// SSL_shutdown
// file /usr/include/openssl/ssl.h line 2397
signed int SSL_shutdown(struct ssl_st *);
// SSL_write
// file /usr/include/openssl/ssl.h line 2336
signed int SSL_write(struct ssl_st *, const void *, signed int);
// TLSv1_1_client_method
// file /usr/include/openssl/ssl.h line 2373
const struct ssl_method_st * TLSv1_1_client_method(void);
// TLSv1_2_client_method
// file /usr/include/openssl/ssl.h line 2377
const struct ssl_method_st * TLSv1_2_client_method(void);
// TLSv1_client_method
// file /usr/include/openssl/ssl.h line 2369
const struct ssl_method_st * TLSv1_client_method(void);
// X509_NAME_get_text_by_NID
// file /usr/include/openssl/x509.h line 1011
signed int X509_NAME_get_text_by_NID(struct X509_name_st *, signed int, char *, signed int);
// X509_STORE_CTX_get_current_cert
// file /usr/include/openssl/x509_vfy.h line 541
struct x509_st * X509_STORE_CTX_get_current_cert(struct x509_store_ctx_st *);
// X509_STORE_CTX_get_error_depth
// file /usr/include/openssl/x509_vfy.h line 540
signed int X509_STORE_CTX_get_error_depth(struct x509_store_ctx_st *);
// X509_STORE_CTX_get_ex_data
// file /usr/include/openssl/x509_vfy.h line 537
void * X509_STORE_CTX_get_ex_data(struct x509_store_ctx_st *, signed int);
// X509_get_ext_d2i
// file /usr/include/openssl/x509.h line 1071
void * X509_get_ext_d2i(struct x509_st *, signed int, signed int *, signed int *);
// X509_get_subject_name
// file /usr/include/openssl/x509.h line 907
struct X509_name_st * X509_get_subject_name(struct x509_st *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _mosquitto_calloc
// file ./memory_mosq.h line 27
void * _mosquitto_calloc(unsigned long int nmemb, unsigned long int size);
// _mosquitto_check_keepalive
// file ./util_mosq.h line 32
void _mosquitto_check_keepalive(struct mosquitto *mosq);
// _mosquitto_connect_init
// file mosquitto.c line 392
static signed int _mosquitto_connect_init(struct mosquitto *mosq, const char *host, signed int port, signed int keepalive, const char *bind_address);
// _mosquitto_destroy
// file mosquitto.c line 275
void _mosquitto_destroy(struct mosquitto *mosq);
// _mosquitto_fopen
// file ./util_mosq.h line 35
struct _IO_FILE * _mosquitto_fopen(const char *path, const char *mode);
// _mosquitto_free
// file ./memory_mosq.h line 28
void _mosquitto_free(void *mem);
// _mosquitto_handle_connack
// file ./read_handle.h line 23
signed int _mosquitto_handle_connack(struct mosquitto *mosq);
// _mosquitto_handle_pingreq
// file ./read_handle.h line 24
signed int _mosquitto_handle_pingreq(struct mosquitto *mosq);
// _mosquitto_handle_pingresp
// file ./read_handle.h line 25
signed int _mosquitto_handle_pingresp(struct mosquitto *mosq);
// _mosquitto_handle_pubackcomp
// file ./read_handle.h line 29
signed int _mosquitto_handle_pubackcomp(struct mosquitto *mosq, const char *type);
// _mosquitto_handle_publish
// file read_handle.c line 64
signed int _mosquitto_handle_publish(struct mosquitto *mosq);
// _mosquitto_handle_pubrec
// file ./read_handle.h line 32
signed int _mosquitto_handle_pubrec(struct mosquitto *mosq);
// _mosquitto_handle_pubrel
// file ./read_handle.h line 33
signed int _mosquitto_handle_pubrel(struct mosquitto_db *db, struct mosquitto *mosq);
// _mosquitto_handle_suback
// file ./read_handle.h line 34
signed int _mosquitto_handle_suback(struct mosquitto *mosq);
// _mosquitto_handle_unsuback
// file ./read_handle.h line 35
signed int _mosquitto_handle_unsuback(struct mosquitto *mosq);
// _mosquitto_hex2bin
// file ./util_mosq.h line 38
signed int _mosquitto_hex2bin(const char *hex, unsigned char *bin, signed int bin_max_len);
// _mosquitto_log_printf
// file ./logging_mosq.h line 21
signed int _mosquitto_log_printf(struct mosquitto *mosq, signed int priority, const char *fmt, ...);
// _mosquitto_loop_rc_handle
// file mosquitto.c line 1109
static signed int _mosquitto_loop_rc_handle(struct mosquitto *mosq, signed int rc);
// _mosquitto_malloc
// file ./memory_mosq.h line 29
void * _mosquitto_malloc(unsigned long int size);
// _mosquitto_message_cleanup
// file ./messages_mosq.h line 23
void _mosquitto_message_cleanup(struct mosquitto_message_all **message);
// _mosquitto_message_cleanup_all
// file ./messages_mosq.h line 22
void _mosquitto_message_cleanup_all(struct mosquitto *mosq);
// _mosquitto_message_delete
// file messages_mosq.c line 83
signed int _mosquitto_message_delete(struct mosquitto *mosq, unsigned short int mid, enum mosquitto_msg_direction dir);
// _mosquitto_message_out_update
// file messages_mosq.c line 371
signed int _mosquitto_message_out_update(struct mosquitto *mosq, unsigned short int mid, enum mosquitto_msg_state state);
// _mosquitto_message_queue
// file ./messages_mosq.h line 25
signed int _mosquitto_message_queue(struct mosquitto *mosq, struct mosquitto_message_all *message, enum mosquitto_msg_direction dir);
// _mosquitto_message_remove
// file messages_mosq.c line 214
signed int _mosquitto_message_remove(struct mosquitto *mosq, unsigned short int mid, enum mosquitto_msg_direction dir, struct mosquitto_message_all **message);
// _mosquitto_message_retry_check
// file ./messages_mosq.h line 28
void _mosquitto_message_retry_check(struct mosquitto *mosq);
// _mosquitto_message_retry_check_actual
// file messages_mosq.c line 312
void _mosquitto_message_retry_check_actual(struct mosquitto *mosq, struct mosquitto_message_all *messages, union anonymous_1 *mutex);
// _mosquitto_messages_reconnect_reset
// file ./messages_mosq.h line 26
void _mosquitto_messages_reconnect_reset(struct mosquitto *mosq);
// _mosquitto_mid_generate
// file ./util_mosq.h line 34
unsigned short int _mosquitto_mid_generate(struct mosquitto *mosq);
// _mosquitto_net_cleanup
// file ./net_mosq.h line 53
void _mosquitto_net_cleanup(void);
// _mosquitto_net_init
// file ./net_mosq.h line 52
void _mosquitto_net_init(void);
// _mosquitto_net_read
// file net_mosq.c line 654
signed long int _mosquitto_net_read(struct mosquitto *mosq, void *buf, unsigned long int count);
// _mosquitto_net_write
// file net_mosq.c line 702
signed long int _mosquitto_net_write(struct mosquitto *mosq, void *buf, unsigned long int count);
// _mosquitto_packet_alloc
// file ./util_mosq.h line 28
signed int _mosquitto_packet_alloc(struct _mosquitto_packet *packet);
// _mosquitto_packet_cleanup
// file ./net_mosq.h line 55
void _mosquitto_packet_cleanup(struct _mosquitto_packet *packet);
// _mosquitto_packet_handle
// file ./read_handle.h line 22
signed int _mosquitto_packet_handle(struct mosquitto *mosq);
// _mosquitto_packet_queue
// file net_mosq.c line 146
signed int _mosquitto_packet_queue(struct mosquitto *mosq, struct _mosquitto_packet *packet);
// _mosquitto_packet_read
// file ./net_mosq.h line 84
signed int _mosquitto_packet_read(struct mosquitto *mosq);
// _mosquitto_packet_write
// file ./net_mosq.h line 80
signed int _mosquitto_packet_write(struct mosquitto *mosq);
// _mosquitto_read_byte
// file net_mosq.c line 561
signed int _mosquitto_read_byte(struct _mosquitto_packet *packet, unsigned char *byte);
// _mosquitto_read_bytes
// file net_mosq.c line 581
signed int _mosquitto_read_bytes(struct _mosquitto_packet *packet, void *bytes, unsigned int count);
// _mosquitto_read_string
// file net_mosq.c line 601
signed int _mosquitto_read_string(struct _mosquitto_packet *packet, char **str);
// _mosquitto_read_uint16
// file net_mosq.c line 631
signed int _mosquitto_read_uint16(struct _mosquitto_packet *packet, unsigned short int *word);
// _mosquitto_realloc
// file memory_mosq.c line 91
void * _mosquitto_realloc(void *ptr, unsigned long int size);
// _mosquitto_reconnect
// file mosquitto.c line 472
static signed int _mosquitto_reconnect(struct mosquitto *mosq, _Bool blocking);
// _mosquitto_send_command_with_mid
// file send_mosq.c line 200
signed int _mosquitto_send_command_with_mid(struct mosquitto *mosq, unsigned char command, unsigned short int mid, _Bool dup);
// _mosquitto_send_connect
// file ./send_mosq.h line 25
signed int _mosquitto_send_connect(struct mosquitto *mosq, unsigned short int keepalive, _Bool clean_session);
// _mosquitto_send_disconnect
// file ./send_mosq.h line 26
signed int _mosquitto_send_disconnect(struct mosquitto *mosq);
// _mosquitto_send_pingreq
// file send_mosq.c line 38
signed int _mosquitto_send_pingreq(struct mosquitto *mosq);
// _mosquitto_send_pingresp
// file ./send_mosq.h line 28
signed int _mosquitto_send_pingresp(struct mosquitto *mosq);
// _mosquitto_send_puback
// file ./send_mosq.h line 29
signed int _mosquitto_send_puback(struct mosquitto *mosq, unsigned short int mid);
// _mosquitto_send_pubcomp
// file ./send_mosq.h line 30
signed int _mosquitto_send_pubcomp(struct mosquitto *mosq, unsigned short int mid);
// _mosquitto_send_publish
// file ./send_mosq.h line 31
signed int _mosquitto_send_publish(struct mosquitto *mosq, unsigned short int mid, const char *topic, unsigned int payloadlen, const void *payload, signed int qos, _Bool retain, _Bool dup);
// _mosquitto_send_pubrec
// file ./send_mosq.h line 32
signed int _mosquitto_send_pubrec(struct mosquitto *mosq, unsigned short int mid);
// _mosquitto_send_pubrel
// file ./send_mosq.h line 33
signed int _mosquitto_send_pubrel(struct mosquitto *mosq, unsigned short int mid);
// _mosquitto_send_real_publish
// file send_mosq.c line 248
signed int _mosquitto_send_real_publish(struct mosquitto *mosq, unsigned short int mid, const char *topic, unsigned int payloadlen, const void *payload, signed int qos, _Bool retain, _Bool dup);
// _mosquitto_send_simple_command
// file send_mosq.c line 227
signed int _mosquitto_send_simple_command(struct mosquitto *mosq, unsigned char command);
// _mosquitto_send_subscribe
// file ./send_mosq.h line 34
signed int _mosquitto_send_subscribe(struct mosquitto *mosq, signed int *mid, const char *topic, unsigned char topic_qos);
// _mosquitto_send_unsubscribe
// file ./send_mosq.h line 35
signed int _mosquitto_send_unsubscribe(struct mosquitto *mosq, signed int *mid, const char *topic);
// _mosquitto_server_certificate_verify
// file ./tls_mosq.h line 37
signed int _mosquitto_server_certificate_verify(signed int preverify_ok, struct x509_store_ctx_st *ctx);
// _mosquitto_socket_close
// file ./net_mosq.h line 61
signed int _mosquitto_socket_close(struct mosquitto *mosq);
// _mosquitto_socket_connect
// file ./net_mosq.h line 57
signed int _mosquitto_socket_connect(struct mosquitto *mosq, const char *host, unsigned short int port, const char *bind_address, _Bool blocking);
// _mosquitto_socket_nonblock
// file net_mosq.c line 1049
signed int _mosquitto_socket_nonblock(signed int sock);
// _mosquitto_socketpair
// file ./net_mosq.h line 65
signed int _mosquitto_socketpair(signed int *pairR, signed int *pairW);
// _mosquitto_strdup
// file ./memory_mosq.h line 35
char * _mosquitto_strdup(const char *s);
// _mosquitto_thread_main
// file thread_mosq.c line 76
void * _mosquitto_thread_main(void *obj);
// _mosquitto_try_connect
// file net_mosq.c line 271
signed int _mosquitto_try_connect(struct mosquitto *mosq, const char *host, unsigned short int port, signed int *sock, const char *bind_address, _Bool blocking);
// _mosquitto_verify_certificate_hostname
// file tls_mosq.c line 103
signed int _mosquitto_verify_certificate_hostname(struct x509_st *cert, const char *hostname);
// _mosquitto_will_clear
// file ./will_mosq.h line 24
signed int _mosquitto_will_clear(struct mosquitto *mosq);
// _mosquitto_will_set
// file ./will_mosq.h line 23
signed int _mosquitto_will_set(struct mosquitto *mosq, const char *topic, signed int payloadlen, const void *payload, signed int qos, _Bool retain);
// _mosquitto_write_byte
// file net_mosq.c line 572
void _mosquitto_write_byte(struct _mosquitto_packet *packet, unsigned char byte);
// _mosquitto_write_bytes
// file net_mosq.c line 592
void _mosquitto_write_bytes(struct _mosquitto_packet *packet, const void *bytes, unsigned int count);
// _mosquitto_write_string
// file net_mosq.c line 624
void _mosquitto_write_string(struct _mosquitto_packet *packet, const char *str, unsigned short int length);
// _mosquitto_write_uint16
// file net_mosq.c line 648
void _mosquitto_write_uint16(struct _mosquitto_packet *packet, unsigned short int word);
// ares_fds
// file /usr/include/ares.h line 385
signed int ares_fds(struct ares_channeldata *, struct anonymous_2 *, struct anonymous_2 *);
// ares_init
// file /usr/include/ares.h line 303
signed int ares_init(struct ares_channeldata **);
// ares_library_cleanup
// file /usr/include/ares.h line 299
void ares_library_cleanup(void);
// ares_library_init
// file /usr/include/ares.h line 297
signed int ares_library_init(signed int);
// ares_parse_srv_reply
// file /usr/include/ares.h line 528
signed int ares_parse_srv_reply(const unsigned char *, signed int, struct ares_srv_reply **);
// ares_process
// file /usr/include/ares.h line 397
void ares_process(struct ares_channeldata *, struct anonymous_2 *, struct anonymous_2 *);
// ares_search
// file /usr/include/ares.h line 353
void ares_search(struct ares_channeldata *, const char *, signed int, signed int, void (*)(void *, signed int, signed int, unsigned char *, signed int), void *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// client_config_cleanup
// file client_shared.h line 92
void client_config_cleanup(struct mosq_config *cfg);
// client_config_line_proc
// file client_shared.c line 238
static signed int client_config_line_proc(struct mosq_config *cfg, signed int pub_or_sub, signed int argc, char **argv);
// client_config_load
// file client_shared.h line 91
signed int client_config_load(struct mosq_config *cfg, signed int pub_or_sub, signed int argc, char **argv);
// client_connect
// file client_shared.h line 95
signed int client_connect(struct mosquitto *mosq, struct mosq_config *cfg);
// client_id_generate
// file client_shared.h line 94
signed int client_id_generate(struct mosq_config *cfg, const char *id_base);
// client_opts_set
// file client_shared.h line 93
signed int client_opts_set(struct mosquitto *mosq, struct mosq_config *cfg);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init_config
// file client_shared.c line 37
void init_config(struct mosq_config *cfg);
// load_file
// file pub_client.c line 159
signed int load_file(const char *filename);
// load_stdin
// file pub_client.c line 127
signed int load_stdin(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mosquitto__cmp_hostname_wildcard
// file tls_mosq.c line 73
signed int mosquitto__cmp_hostname_wildcard(char *certname, const char *hostname);
// mosquitto__parse_socks_url
// file client_shared.c line 812
static signed int mosquitto__parse_socks_url(struct mosq_config *cfg, char *url);
// mosquitto__socket_connect_tls
// file ./net_mosq.h line 89
signed int mosquitto__socket_connect_tls(struct mosquitto *mosq);
// mosquitto__socks5_read
// file ./socks_mosq.h line 21
signed int mosquitto__socks5_read(struct mosquitto *mosq);
// mosquitto__socks5_send
// file ./socks_mosq.h line 20
signed int mosquitto__socks5_send(struct mosquitto *mosq);
// mosquitto__urldecode
// file client_shared.c line 769
static signed int mosquitto__urldecode(char *str);
// mosquitto_connack_string
// file ../lib/mosquitto.h line 1382
const char * mosquitto_connack_string(signed int connack_code);
// mosquitto_connect
// file mosquitto.c line 427
signed int mosquitto_connect(struct mosquitto *mosq, const char *host, signed int port, signed int keepalive);
// mosquitto_connect_async
// file mosquitto.c line 445
signed int mosquitto_connect_async(struct mosquitto *mosq, const char *host, signed int port, signed int keepalive);
// mosquitto_connect_bind
// file ../lib/mosquitto.h line 382
signed int mosquitto_connect_bind(struct mosquitto *mosq, const char *host, signed int port, signed int keepalive, const char *bind_address);
// mosquitto_connect_bind_async
// file mosquitto.c line 450
signed int mosquitto_connect_bind_async(struct mosquitto *mosq, const char *host, signed int port, signed int keepalive, const char *bind_address);
// mosquitto_connect_callback_set
// file ../lib/mosquitto.h line 1111
void mosquitto_connect_callback_set(struct mosquitto *mosq, void (*on_connect)(struct mosquitto *, void *, signed int));

//
void on_connect_object(struct mosquitto *, void *, signed int);
// mosquitto_connect_srv
// file ../lib/mosquitto.h line 486
signed int mosquitto_connect_srv(struct mosquitto *mosq, const char *host, signed int keepalive, const char *bind_address);
// mosquitto_destroy
// file ../lib/mosquitto.h line 232
void mosquitto_destroy(struct mosquitto *mosq);
// mosquitto_disconnect
// file ../lib/mosquitto.h line 563
signed int mosquitto_disconnect(struct mosquitto *mosq);
// mosquitto_disconnect_callback_set
// file ../lib/mosquitto.h line 1131
void mosquitto_disconnect_callback_set(struct mosquitto *mosq, void (*on_disconnect)(struct mosquitto *, void *, signed int));

//
void on_disconnect_object(struct mosquitto *, void *, signed int);
// mosquitto_lib_cleanup
// file ../lib/mosquitto.h line 188
signed int mosquitto_lib_cleanup(void);
// mosquitto_lib_init
// file ../lib/mosquitto.h line 175
signed int mosquitto_lib_init(void);
// mosquitto_lib_version
// file ../lib/mosquitto.h line 160
signed int mosquitto_lib_version(signed int *major, signed int *minor, signed int *revision);
// mosquitto_log_callback_set
// file ../lib/mosquitto.h line 1234
void mosquitto_log_callback_set(struct mosquitto *mosq, void (*on_log)(struct mosquitto *, void *, signed int, const char *));

//
void on_log_object(struct mosquitto *, void *, signed int, const char *);
// mosquitto_loop
// file ../lib/mosquitto.h line 722
signed int mosquitto_loop(struct mosquitto *mosq, signed int timeout, signed int max_packets);
// mosquitto_loop_forever
// file mosquitto.c line 989
signed int mosquitto_loop_forever(struct mosquitto *mosq, signed int timeout, signed int max_packets);
// mosquitto_loop_misc
// file mosquitto.c line 1071
signed int mosquitto_loop_misc(struct mosquitto *mosq);
// mosquitto_loop_read
// file mosquitto.c line 1130
signed int mosquitto_loop_read(struct mosquitto *mosq, signed int max_packets);
// mosquitto_loop_start
// file ../lib/mosquitto.h line 778
signed int mosquitto_loop_start(struct mosquitto *mosq);
// mosquitto_loop_stop
// file ../lib/mosquitto.h line 802
signed int mosquitto_loop_stop(struct mosquitto *mosq, _Bool force);
// mosquitto_loop_write
// file mosquitto.c line 1164
signed int mosquitto_loop_write(struct mosquitto *mosq, signed int max_packets);
// mosquitto_max_inflight_messages_set
// file ../lib/mosquitto.h line 1296
signed int mosquitto_max_inflight_messages_set(struct mosquitto *mosq, unsigned int max_inflight_messages);
// mosquitto_message_callback_set
// file mosquitto.c line 1249
void mosquitto_message_callback_set(struct mosquitto *mosq, void (*on_message)(struct mosquitto *, void *, struct mosquitto_message *));

//
void on_message_object(struct mosquitto *, void *, struct mosquitto_message *);
// mosquitto_message_copy
// file messages_mosq.c line 59
signed int mosquitto_message_copy(struct mosquitto_message *dst, struct mosquitto_message *src);
// mosquitto_message_free
// file messages_mosq.c line 96
void mosquitto_message_free(struct mosquitto_message **message);
// mosquitto_message_retry_set
// file messages_mosq.c line 365
void mosquitto_message_retry_set(struct mosquitto *mosq, unsigned int message_retry);
// mosquitto_new
// file ../lib/mosquitto.h line 219
struct mosquitto * mosquitto_new(const char *id, _Bool clean_session, void *userdata);
// mosquitto_opts_set
// file ../lib/mosquitto.h line 947
signed int mosquitto_opts_set(struct mosquitto *mosq, enum mosq_opt_t option, void *value);
// mosquitto_pub_topic_check
// file ../lib/mosquitto.h line 1502
signed int mosquitto_pub_topic_check(const char *str);
// mosquitto_publish
// file ../lib/mosquitto.h line 600
signed int mosquitto_publish(struct mosquitto *mosq, signed int *mid, const char *topic, signed int payloadlen, const void *payload, signed int qos, _Bool retain);
// mosquitto_publish_callback_set
// file ../lib/mosquitto.h line 1149
void mosquitto_publish_callback_set(struct mosquitto *mosq, void (*on_publish)(struct mosquitto *, void *, signed int));

//
void on_publish_object(struct mosquitto *, void *, signed int);
// mosquitto_reconnect
// file mosquitto.c line 467
signed int mosquitto_reconnect(struct mosquitto *mosq);
// mosquitto_reconnect_async
// file mosquitto.c line 462
signed int mosquitto_reconnect_async(struct mosquitto *mosq);
// mosquitto_reconnect_delay_set
// file mosquitto.c line 263
signed int mosquitto_reconnect_delay_set(struct mosquitto *mosq, unsigned int reconnect_delay, unsigned int reconnect_delay_max, _Bool reconnect_exponential_backoff);
// mosquitto_reinitialise
// file mosquitto.c line 126
signed int mosquitto_reinitialise(struct mosquitto *mosq, const char *id, _Bool clean_session, void *userdata);
// mosquitto_socket
// file mosquitto.c line 386
signed int mosquitto_socket(struct mosquitto *mosq);
// mosquitto_socks5_set
// file ../lib/mosquitto.h line 1349
signed int mosquitto_socks5_set(struct mosquitto *mosq, const char *host, signed int port, const char *username, const char *password);
// mosquitto_strerror
// file ../lib/mosquitto.h line 1369
const char * mosquitto_strerror(signed int mosq_errno);
// mosquitto_sub_topic_check
// file ../lib/mosquitto.h line 1529
signed int mosquitto_sub_topic_check(const char *str);
// mosquitto_sub_topic_tokenise
// file mosquitto.c line 1348
signed int mosquitto_sub_topic_tokenise(const char *subtopic, char ***topics, signed int *count);
// mosquitto_sub_topic_tokens_free
// file mosquitto.c line 1407
signed int mosquitto_sub_topic_tokens_free(char ***topics, signed int count);
// mosquitto_subscribe
// file mosquitto.c line 624
signed int mosquitto_subscribe(struct mosquitto *mosq, signed int *mid, const char *sub, signed int qos);
// mosquitto_subscribe_callback_set
// file mosquitto.c line 1256
void mosquitto_subscribe_callback_set(struct mosquitto *mosq, void (*on_subscribe)(struct mosquitto *, void *, signed int, signed int, const signed int *));

//
void on_subscribe_object(struct mosquitto *, void *, signed int, signed int, const signed int *);
// mosquitto_threaded_set
// file thread_mosq.c line 102
signed int mosquitto_threaded_set(struct mosquitto *mosq, _Bool threaded);
// mosquitto_time
// file ./time_mosq.h line 20
signed long int mosquitto_time(void);
// mosquitto_tls_insecure_set
// file ../lib/mosquitto.h line 1026
signed int mosquitto_tls_insecure_set(struct mosquitto *mosq, _Bool value);
// mosquitto_tls_opts_set
// file ../lib/mosquitto.h line 1060
signed int mosquitto_tls_opts_set(struct mosquitto *mosq, signed int cert_reqs, const char *tls_version, const char *ciphers);
// mosquitto_tls_psk_set
// file ../lib/mosquitto.h line 1087
signed int mosquitto_tls_psk_set(struct mosquitto *mosq, const char *psk, const char *identity, const char *ciphers);
// mosquitto_tls_set
// file ../lib/mosquitto.h line 996
signed int mosquitto_tls_set(struct mosquitto *mosq, const char *cafile, const char *capath, const char *certfile, const char *keyfile, signed int (*pw_callback)(char *, signed int, signed int, void *));

//

// mosquitto_topic_matches_sub
// file util_mosq.c line 220
signed int mosquitto_topic_matches_sub(const char *sub, const char *topic, _Bool *result);
// mosquitto_unsubscribe
// file mosquitto.c line 634
signed int mosquitto_unsubscribe(struct mosquitto *mosq, signed int *mid, const char *sub);
// mosquitto_unsubscribe_callback_set
// file mosquitto.c line 1263
void mosquitto_unsubscribe_callback_set(struct mosquitto *mosq, void (*on_unsubscribe)(struct mosquitto *, void *, signed int));

//
void on_unsubscribe_object(struct mosquitto *, void *, signed int);
// mosquitto_user_data_set
// file mosquitto.c line 1277
void mosquitto_user_data_set(struct mosquitto *mosq, void *userdata);
// mosquitto_username_pw_set
// file ../lib/mosquitto.h line 326
signed int mosquitto_username_pw_set(struct mosquitto *mosq, const char *username, const char *password);
// mosquitto_want_write
// file mosquitto.c line 1191
_Bool mosquitto_want_write(struct mosquitto *mosq);
// mosquitto_will_clear
// file mosquitto.c line 229
signed int mosquitto_will_clear(struct mosquitto *mosq);
// mosquitto_will_set
// file ../lib/mosquitto.h line 286
signed int mosquitto_will_set(struct mosquitto *mosq, const char *topic, signed int payloadlen, const void *payload, signed int qos, _Bool retain);
// my_connect_callback
// file pub_client.c line 56
void my_connect_callback(struct mosquitto *mosq, void *obj, signed int result);
// my_disconnect_callback
// file pub_client.c line 103
void my_disconnect_callback(struct mosquitto *mosq, void *obj, signed int rc);
// my_log_callback
// file pub_client.c line 122
void my_log_callback(struct mosquitto *mosq, void *obj, signed int level, const char *str);
// my_publish_callback
// file pub_client.c line 108
void my_publish_callback(struct mosquitto *mosq, void *obj, signed int mid);
// print_usage
// file pub_client.c line 201
void print_usage(void);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pselect
// file /usr/include/x86_64-linux-gnu/sys/select.h line 118
extern signed int pselect(signed int, struct anonymous_2 *, struct anonymous_2 *, struct anonymous_2 *, struct timespec *, const struct anonymous_7 *);
// psk_client_callback
// file net_mosq.c line 253
static unsigned int psk_client_callback(struct ssl_st *ssl, const char *hint, char *identity, unsigned int max_identity_len, unsigned char *psk, unsigned int max_psk_len);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_equal
// file /usr/include/pthread.h line 280
extern signed int pthread_equal(unsigned long int, unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_1 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_1 *, const union anonymous_3 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_1 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_1 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sk_num
// file /usr/include/openssl/stack.h line 77
signed int sk_num(const struct stack_st *);
// sk_value
// file /usr/include/openssl/stack.h line 78
void * sk_value(const struct stack_st *, signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// srv_callback
// file srv_mosq.c line 31
static void srv_callback(void *arg, signed int status, signed int timeouts, unsigned char *abuf, signed int alen);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strerror_r
// file /usr/include/string.h line 426
extern signed int strerror_r(signed int, char *, unsigned long int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_11
{
  // cert_verify_md
  unsigned char cert_verify_md[128l];
  // finish_md
  unsigned char finish_md[128l];
  // finish_md_len
  signed int finish_md_len;
  // peer_finish_md
  unsigned char peer_finish_md[128l];
  // peer_finish_md_len
  signed int peer_finish_md_len;
  // message_size
  unsigned long int message_size;
  // message_type
  signed int message_type;
  // new_cipher
  const struct ssl_cipher_st *new_cipher;
  // dh
  struct dh_st *dh;
  // ecdh
  struct ec_key_st *ecdh;
  // next_state
  signed int next_state;
  // reuse_message
  signed int reuse_message;
  // cert_req
  signed int cert_req;
  // ctype_num
  signed int ctype_num;
  // ctype
  char ctype[9l];
  // ca_names
  struct stack_st_X509_NAME *ca_names;
  // use_rsa_tmp
  signed int use_rsa_tmp;
  // key_block_length
  signed int key_block_length;
  // key_block
  unsigned char *key_block;
  // new_sym_enc
  const struct evp_cipher_st *new_sym_enc;
  // new_hash
  const struct env_md_st *new_hash;
  // new_mac_pkey_type
  signed int new_mac_pkey_type;
  // new_mac_secret_size
  signed int new_mac_secret_size;
  // new_compression
  const struct ssl_comp_st *new_compression;
  // cert_request
  signed int cert_request;
};

struct anonymous_2
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_7
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_12
{
  // sess_connect
  signed int sess_connect;
  // sess_connect_renegotiate
  signed int sess_connect_renegotiate;
  // sess_connect_good
  signed int sess_connect_good;
  // sess_accept
  signed int sess_accept;
  // sess_accept_renegotiate
  signed int sess_accept_renegotiate;
  // sess_accept_good
  signed int sess_accept_good;
  // sess_miss
  signed int sess_miss;
  // sess_timeout
  signed int sess_timeout;
  // sess_cache_full
  signed int sess_cache_full;
  // sess_hit
  signed int sess_hit;
  // sess_cb_hit
  signed int sess_cb_hit;
};

struct anonymous_10
{
  // conn_id_length
  unsigned int conn_id_length;
  // cert_type
  unsigned int cert_type;
  // cert_length
  unsigned int cert_length;
  // csl
  unsigned int csl;
  // clear
  unsigned int clear;
  // enc
  unsigned int enc;
  // ccl
  unsigned char ccl[32l];
  // cipher_spec_length
  unsigned int cipher_spec_length;
  // session_id_length
  unsigned int session_id_length;
  // clen
  unsigned int clen;
  // rlen
  unsigned int rlen;
};

union anonymous_4
{
  // inherit
  signed int *inherit;
  // asIdsOrRanges
  struct stack_st_ASIdOrRange *asIdsOrRanges;
};

union anonymous_5
{
  // ptr
  char *ptr;
  // otherName
  struct otherName_st *otherName;
  // rfc822Name
  struct asn1_string_st *rfc822Name;
  // dNSName
  struct asn1_string_st *dNSName;
  // x400Address
  struct asn1_type_st *x400Address;
  // directoryName
  struct X509_name_st *directoryName;
  // ediPartyName
  struct EDIPartyName_st *ediPartyName;
  // uniformResourceIdentifier
  struct asn1_string_st *uniformResourceIdentifier;
  // iPAddress
  struct asn1_string_st *iPAddress;
  // registeredID
  struct asn1_object_st *registeredID;
  // ip
  struct asn1_string_st *ip;
  // dirn
  struct X509_name_st *dirn;
  // ia5
  struct asn1_string_st *ia5;
  // rid
  struct asn1_object_st *rid;
  // other
  struct asn1_type_st *other;
};

union anonymous_8
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous_0
{
  // fullname
  struct stack_st_GENERAL_NAME *fullname;
  // relativename
  struct stack_st_X509_NAME_ENTRY *relativename;
};

union anonymous_6
{
  // cb_1
  void (*cb_1)(signed int, signed int, void *);
  // cb_2
  signed int (*cb_2)(signed int, signed int, struct bn_gencb_st *);
};

union anonymous_9
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_3
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_1
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ASIdentifierChoice_st
{
  // type
  signed int type;
  // u
  union anonymous_4 u;
};

struct ASIdentifiers_st
{
  // asnum
  struct ASIdentifierChoice_st *asnum;
  // rdi
  struct ASIdentifierChoice_st *rdi;
};

struct ASN1_ENCODING_st
{
  // enc
  unsigned char *enc;
  // len
  signed long int len;
  // modified
  signed int modified;
};

struct AUTHORITY_KEYID_st
{
  // keyid
  struct asn1_string_st *keyid;
  // issuer
  struct stack_st_GENERAL_NAME *issuer;
  // serial
  struct asn1_string_st *serial;
};

struct DIST_POINT_NAME_st
{
  // type
  signed int type;
  // name
  union anonymous_0 name;
  // dpname
  struct X509_name_st *dpname;
};

struct DSA_SIG_st
{
  // r
  struct bignum_st *r;
  // s
  struct bignum_st *s;
};

struct EDIPartyName_st
{
  // nameAssigner
  struct asn1_string_st *nameAssigner;
  // partyName
  struct asn1_string_st *partyName;
};

struct GENERAL_NAME_st
{
  // type
  signed int type;
  // d
  union anonymous_5 d;
};

struct ISSUING_DIST_POINT_st
{
  // distpoint
  struct DIST_POINT_NAME_st *distpoint;
  // onlyuser
  signed int onlyuser;
  // onlyCA
  signed int onlyCA;
  // onlysomereasons
  struct asn1_string_st *onlysomereasons;
  // indirectCRL
  signed int indirectCRL;
  // onlyattr
  signed int onlyattr;
};

struct NAME_CONSTRAINTS_st
{
  // permittedSubtrees
  struct stack_st_GENERAL_SUBTREE *permittedSubtrees;
  // excludedSubtrees
  struct stack_st_GENERAL_SUBTREE *excludedSubtrees;
};

struct X509_VERIFY_PARAM_st
{
  // name
  char *name;
  // check_time
  signed long int check_time;
  // inh_flags
  unsigned long int inh_flags;
  // flags
  unsigned long int flags;
  // purpose
  signed int purpose;
  // trust
  signed int trust;
  // depth
  signed int depth;
  // policies
  struct stack_st_ASN1_OBJECT *policies;
  // id
  struct X509_VERIFY_PARAM_ID_st *id;
};

struct X509_algor_st
{
  // algorithm
  struct asn1_object_st *algorithm;
  // parameter
  struct asn1_type_st *parameter;
};

struct X509_crl_info_st
{
  // version
  struct asn1_string_st *version;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // issuer
  struct X509_name_st *issuer;
  // lastUpdate
  struct asn1_string_st *lastUpdate;
  // nextUpdate
  struct asn1_string_st *nextUpdate;
  // revoked
  struct stack_st_X509_REVOKED *revoked;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct X509_crl_st
{
  // crl
  struct X509_crl_info_st *crl;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
  // flags
  signed int flags;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // idp
  struct ISSUING_DIST_POINT_st *idp;
  // idp_flags
  signed int idp_flags;
  // idp_reasons
  signed int idp_reasons;
  // crl_number
  struct asn1_string_st *crl_number;
  // base_crl_number
  struct asn1_string_st *base_crl_number;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // issuers
  struct stack_st_GENERAL_NAMES *issuers;
  // meth
  const struct x509_crl_method_st *meth;
  // meth_data
  void *meth_data;
};

struct X509_name_st
{
  // entries
  struct stack_st_X509_NAME_ENTRY *entries;
  // modified
  signed int modified;
  // bytes
  struct buf_mem_st *bytes;
  // canon_enc
  unsigned char *canon_enc;
  // canon_enclen
  signed int canon_enclen;
};

struct X509_pubkey_st
{
  // algor
  struct X509_algor_st *algor;
  // public_key
  struct asn1_string_st *public_key;
  // pkey
  struct evp_pkey_st *pkey;
};

struct X509_val_st
{
  // notBefore
  struct asn1_string_st *notBefore;
  // notAfter
  struct asn1_string_st *notAfter;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _mosquitto_packet
{
  // payload
  unsigned char *payload;
  // next
  struct _mosquitto_packet *next;
  // remaining_mult
  unsigned int remaining_mult;
  // remaining_length
  unsigned int remaining_length;
  // packet_length
  unsigned int packet_length;
  // to_process
  unsigned int to_process;
  // pos
  unsigned int pos;
  // mid
  unsigned short int mid;
  // command
  unsigned char command;
  // remaining_count
  signed char remaining_count;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct ares_srv_reply
{
  // next
  struct ares_srv_reply *next;
  // host
  char *host;
  // priority
  unsigned short int priority;
  // weight
  unsigned short int weight;
  // port
  unsigned short int port;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous value;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct bn_gencb_st
{
  // ver
  unsigned int ver;
  // arg
  void *arg;
  // cb
  union anonymous_6 cb;
};

struct bn_mont_ctx_st
{
  // ri
  signed int ri;
  // RR
  struct bignum_st RR;
  // N
  struct bignum_st N;
  // Ni
  struct bignum_st Ni;
  // n0
  unsigned long int n0[2l];
  // flags
  signed int flags;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct comp_ctx_st
{
  // meth
  struct comp_method_st *meth;
  // compress_in
  unsigned long int compress_in;
  // compress_out
  unsigned long int compress_out;
  // expand_in
  unsigned long int expand_in;
  // expand_out
  unsigned long int expand_out;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct comp_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // init
  signed int (*init)(struct comp_ctx_st *);
  // finish
  void (*finish)(struct comp_ctx_st *);
  // compress
  signed int (*compress)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // expand
  signed int (*expand)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // ctrl
  signed long int (*ctrl)(void);
  // callback_ctrl
  signed long int (*callback_ctrl)(void);
};

struct dh_method
{
  // name
  const char *name;
  // generate_key
  signed int (*generate_key)(struct dh_st *);
  // compute_key
  signed int (*compute_key)(unsigned char *, const struct bignum_st *, struct dh_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(const struct dh_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dh_st *);
  // finish
  signed int (*finish)(struct dh_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // generate_params
  signed int (*generate_params)(struct dh_st *, signed int, signed int, struct bn_gencb_st *);
};

struct dh_st
{
  // pad
  signed int pad;
  // version
  signed int version;
  // p
  struct bignum_st *p;
  // g
  struct bignum_st *g;
  // length
  signed long int length;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // q
  struct bignum_st *q;
  // j
  struct bignum_st *j;
  // seed
  unsigned char *seed;
  // seedlen
  signed int seedlen;
  // counter
  struct bignum_st *counter;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dh_method *meth;
  // engine
  struct engine_st *engine;
};

struct dsa_method
{
  // name
  const char *name;
  // dsa_do_sign
  struct DSA_SIG_st * (*dsa_do_sign)(const unsigned char *, signed int, struct dsa_st *);
  // dsa_sign_setup
  signed int (*dsa_sign_setup)(struct dsa_st *, struct bignum_ctx *, struct bignum_st **, struct bignum_st **);
  // dsa_do_verify
  signed int (*dsa_do_verify)(const unsigned char *, signed int, struct DSA_SIG_st *, struct dsa_st *);
  // dsa_mod_exp
  signed int (*dsa_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dsa_st *);
  // finish
  signed int (*finish)(struct dsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // dsa_paramgen
  signed int (*dsa_paramgen)(struct dsa_st *, signed int, const unsigned char *, signed int, signed int *, unsigned long int *, struct bn_gencb_st *);
  // dsa_keygen
  signed int (*dsa_keygen)(struct dsa_st *);
};

struct dsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // write_params
  signed int write_params;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // g
  struct bignum_st *g;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // kinv
  struct bignum_st *kinv;
  // r
  struct bignum_st *r;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dsa_method *meth;
  // engine
  struct engine_st *engine;
};

struct dtls1_bitmap_st
{
  // map
  unsigned long int map;
  // max_seq_num
  unsigned char max_seq_num[8l];
};

struct dtls1_retransmit_state
{
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // session
  struct ssl_session_st *session;
  // epoch
  unsigned short int epoch;
};

struct record_pqueue_st
{
  // epoch
  unsigned short int epoch;
  // q
  struct _pqueue *q;
};

struct hm_header_st
{
  // type
  unsigned char type;
  // msg_len
  unsigned long int msg_len;
  // seq
  unsigned short int seq;
  // frag_off
  unsigned long int frag_off;
  // frag_len
  unsigned long int frag_len;
  // is_ccs
  unsigned int is_ccs;
  // saved_retransmit_state
  struct dtls1_retransmit_state saved_retransmit_state;
};

struct dtls1_timeout_st
{
  // read_timeouts
  unsigned int read_timeouts;
  // write_timeouts
  unsigned int write_timeouts;
  // num_alerts
  unsigned int num_alerts;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct dtls1_state_st
{
  // send_cookie
  unsigned int send_cookie;
  // cookie
  unsigned char cookie[256l];
  // rcvd_cookie
  unsigned char rcvd_cookie[256l];
  // cookie_len
  unsigned int cookie_len;
  // r_epoch
  unsigned short int r_epoch;
  // w_epoch
  unsigned short int w_epoch;
  // bitmap
  struct dtls1_bitmap_st bitmap;
  // next_bitmap
  struct dtls1_bitmap_st next_bitmap;
  // handshake_write_seq
  unsigned short int handshake_write_seq;
  // next_handshake_write_seq
  unsigned short int next_handshake_write_seq;
  // handshake_read_seq
  unsigned short int handshake_read_seq;
  // last_write_sequence
  unsigned char last_write_sequence[8l];
  // unprocessed_rcds
  struct record_pqueue_st unprocessed_rcds;
  // processed_rcds
  struct record_pqueue_st processed_rcds;
  // buffered_messages
  struct _pqueue *buffered_messages;
  // sent_messages
  struct _pqueue *sent_messages;
  // buffered_app_data
  struct record_pqueue_st buffered_app_data;
  // listen
  unsigned int listen;
  // link_mtu
  unsigned int link_mtu;
  // mtu
  unsigned int mtu;
  // w_msg_hdr
  struct hm_header_st w_msg_hdr;
  // r_msg_hdr
  struct hm_header_st r_msg_hdr;
  // timeout
  struct dtls1_timeout_st timeout;
  // next_timeout
  struct timeval next_timeout;
  // timeout_duration
  unsigned short int timeout_duration;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[12l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // retransmitting
  unsigned int retransmitting;
  // change_cipher_spec_ok
  unsigned int change_cipher_spec_ok;
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous_8 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_9 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct lhash_st_SSL_SESSION
{
  // dummy
  signed int dummy;
};

struct mosq_config
{
  // id
  char *id;
  // id_prefix
  char *id_prefix;
  // protocol_version
  signed int protocol_version;
  // keepalive
  signed int keepalive;
  // host
  char *host;
  // port
  signed int port;
  // qos
  signed int qos;
  // retain
  _Bool retain;
  // pub_mode
  signed int pub_mode;
  // file_input
  char *file_input;
  // message
  char *message;
  // msglen
  signed long int msglen;
  // topic
  char *topic;
  // bind_address
  char *bind_address;
  // use_srv
  _Bool use_srv;
  // debug
  _Bool debug;
  // quiet
  _Bool quiet;
  // max_inflight
  unsigned int max_inflight;
  // username
  char *username;
  // password
  char *password;
  // will_topic
  char *will_topic;
  // will_payload
  char *will_payload;
  // will_payloadlen
  signed long int will_payloadlen;
  // will_qos
  signed int will_qos;
  // will_retain
  _Bool will_retain;
  // cafile
  char *cafile;
  // capath
  char *capath;
  // certfile
  char *certfile;
  // keyfile
  char *keyfile;
  // ciphers
  char *ciphers;
  // insecure
  _Bool insecure;
  // tls_version
  char *tls_version;
  // psk
  char *psk;
  // psk_identity
  char *psk_identity;
  // clean_session
  _Bool clean_session;
  // topics
  char **topics;
  // topic_count
  signed int topic_count;
  // no_retain
  _Bool no_retain;
  // filter_outs
  char **filter_outs;
  // filter_out_count
  signed int filter_out_count;
  // verbose
  _Bool verbose;
  // eol
  _Bool eol;
  // msg_count
  signed int msg_count;
  // socks5_host
  char *socks5_host;
  // socks5_port
  signed int socks5_port;
  // socks5_username
  char *socks5_username;
  // socks5_password
  char *socks5_password;
};

struct mosquitto
{
  // sock
  signed int sock;
  // sockpairR
  signed int sockpairR;
  // sockpairW
  signed int sockpairW;
  // protocol
  enum _mosquitto_protocol protocol;
  // address
  char *address;
  // id
  char *id;
  // username
  char *username;
  // password
  char *password;
  // keepalive
  unsigned short int keepalive;
  // last_mid
  unsigned short int last_mid;
  // state
  enum mosquitto_client_state state;
  // last_msg_in
  signed long int last_msg_in;
  // last_msg_out
  signed long int last_msg_out;
  // ping_t
  signed long int ping_t;
  // in_packet
  struct _mosquitto_packet in_packet;
  // current_out_packet
  struct _mosquitto_packet *current_out_packet;
  // out_packet
  struct _mosquitto_packet *out_packet;
  // will
  struct mosquitto_message *will;
  // ssl
  struct ssl_st *ssl;
  // ssl_ctx
  struct ssl_ctx_st *ssl_ctx;
  // tls_cafile
  char *tls_cafile;
  // tls_capath
  char *tls_capath;
  // tls_certfile
  char *tls_certfile;
  // tls_keyfile
  char *tls_keyfile;
  // tls_pw_callback
  signed int (*tls_pw_callback)(char *, signed int, signed int, void *);
  // tls_version
  char *tls_version;
  // tls_ciphers
  char *tls_ciphers;
  // tls_psk
  char *tls_psk;
  // tls_psk_identity
  char *tls_psk_identity;
  // tls_cert_reqs
  signed int tls_cert_reqs;
  // tls_insecure
  _Bool tls_insecure;
  // want_write
  _Bool want_write;
  // want_connect
  _Bool want_connect;
  // callback_mutex
  union anonymous_1 callback_mutex;
  // log_callback_mutex
  union anonymous_1 log_callback_mutex;
  // msgtime_mutex
  union anonymous_1 msgtime_mutex;
  // out_packet_mutex
  union anonymous_1 out_packet_mutex;
  // current_out_packet_mutex
  union anonymous_1 current_out_packet_mutex;
  // state_mutex
  union anonymous_1 state_mutex;
  // in_message_mutex
  union anonymous_1 in_message_mutex;
  // out_message_mutex
  union anonymous_1 out_message_mutex;
  // mid_mutex
  union anonymous_1 mid_mutex;
  // thread_id
  unsigned long int thread_id;
  // clean_session
  _Bool clean_session;
  // socks5_host
  char *socks5_host;
  // socks5_port
  signed int socks5_port;
  // socks5_username
  char *socks5_username;
  // socks5_password
  char *socks5_password;
  // userdata
  void *userdata;
  // in_callback
  _Bool in_callback;
  // message_retry
  unsigned int message_retry;
  // last_retry_check
  signed long int last_retry_check;
  // in_messages
  struct mosquitto_message_all *in_messages;
  // in_messages_last
  struct mosquitto_message_all *in_messages_last;
  // out_messages
  struct mosquitto_message_all *out_messages;
  // out_messages_last
  struct mosquitto_message_all *out_messages_last;
  // on_connect
  void (*on_connect)(struct mosquitto *, void *, signed int);
  // on_disconnect
  void (*on_disconnect)(struct mosquitto *, void *, signed int);
  // on_publish
  void (*on_publish)(struct mosquitto *, void *, signed int);
  // on_message
  void (*on_message)(struct mosquitto *, void *, struct mosquitto_message *);
  // on_subscribe
  void (*on_subscribe)(struct mosquitto *, void *, signed int, signed int, const signed int *);
  // on_unsubscribe
  void (*on_unsubscribe)(struct mosquitto *, void *, signed int);
  // on_log
  void (*on_log)(struct mosquitto *, void *, signed int, const char *);
  // host
  char *host;
  // port
  signed int port;
  // in_queue_len
  signed int in_queue_len;
  // out_queue_len
  signed int out_queue_len;
  // bind_address
  char *bind_address;
  // reconnect_delay
  unsigned int reconnect_delay;
  // reconnect_delay_max
  unsigned int reconnect_delay_max;
  // reconnect_exponential_backoff
  _Bool reconnect_exponential_backoff;
  // threaded
  _Bool threaded;
  // out_packet_last
  struct _mosquitto_packet *out_packet_last;
  // inflight_messages
  signed int inflight_messages;
  // max_inflight_messages
  signed int max_inflight_messages;
  // achan
  struct ares_channeldata *achan;
};

struct mosquitto_message
{
  // mid
  signed int mid;
  // topic
  char *topic;
  // payload
  void *payload;
  // payloadlen
  signed int payloadlen;
  // qos
  signed int qos;
  // retain
  _Bool retain;
};

struct mosquitto_message_all
{
  // next
  struct mosquitto_message_all *next;
  // timestamp
  signed long int timestamp;
  // state
  enum mosquitto_msg_state state;
  // dup
  _Bool dup;
  // msg
  struct mosquitto_message msg;
};

struct otherName_st
{
  // type_id
  struct asn1_object_st *type_id;
  // value
  struct asn1_type_st *value;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rsa_meth_st
{
  // name
  const char *name;
  // rsa_pub_enc
  signed int (*rsa_pub_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_pub_dec
  signed int (*rsa_pub_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_enc
  signed int (*rsa_priv_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_dec
  signed int (*rsa_priv_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_mod_exp
  signed int (*rsa_mod_exp)(struct bignum_st *, const struct bignum_st *, struct rsa_st *, struct bignum_ctx *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct rsa_st *);
  // finish
  signed int (*finish)(struct rsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // rsa_sign
  signed int (*rsa_sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, const struct rsa_st *);
  // rsa_verify
  signed int (*rsa_verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, const struct rsa_st *);
  // rsa_keygen
  signed int (*rsa_keygen)(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
};

struct rsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // meth
  const struct rsa_meth_st *meth;
  // engine
  struct engine_st *engine;
  // n
  struct bignum_st *n;
  // e
  struct bignum_st *e;
  // d
  struct bignum_st *d;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // dmp1
  struct bignum_st *dmp1;
  // dmq1
  struct bignum_st *dmq1;
  // iqmp
  struct bignum_st *iqmp;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
  // flags
  signed int flags;
  // _method_mod_n
  struct bn_mont_ctx_st *_method_mod_n;
  // _method_mod_p
  struct bn_mont_ctx_st *_method_mod_p;
  // _method_mod_q
  struct bn_mont_ctx_st *_method_mod_q;
  // bignum_data
  char *bignum_data;
  // blinding
  struct bn_blinding_st *blinding;
  // mt_blinding
  struct bn_blinding_st *mt_blinding;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct srp_ctx_st
{
  // SRP_cb_arg
  void *SRP_cb_arg;
  // TLS_ext_srp_username_callback
  signed int (*TLS_ext_srp_username_callback)(struct ssl_st *, signed int *, void *);
  // SRP_verify_param_callback
  signed int (*SRP_verify_param_callback)(struct ssl_st *, void *);
  // SRP_give_srp_client_pwd_callback
  char * (*SRP_give_srp_client_pwd_callback)(struct ssl_st *, void *);
  // login
  char *login;
  // N
  struct bignum_st *N;
  // g
  struct bignum_st *g;
  // s
  struct bignum_st *s;
  // B
  struct bignum_st *B;
  // A
  struct bignum_st *A;
  // a
  struct bignum_st *a;
  // b
  struct bignum_st *b;
  // v
  struct bignum_st *v;
  // info
  char *info;
  // strength
  signed int strength;
  // srp_Mask
  unsigned long int srp_Mask;
};

struct srtp_protection_profile_st
{
  // name
  const char *name;
  // id
  unsigned long int id;
};

struct ssl2_state_st
{
  // three_byte_header
  signed int three_byte_header;
  // clear_text
  signed int clear_text;
  // escape
  signed int escape;
  // ssl2_rollback
  signed int ssl2_rollback;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_buf
  const unsigned char *wpend_buf;
  // wpend_off
  signed int wpend_off;
  // wpend_len
  signed int wpend_len;
  // wpend_ret
  signed int wpend_ret;
  // rbuf_left
  signed int rbuf_left;
  // rbuf_offs
  signed int rbuf_offs;
  // rbuf
  unsigned char *rbuf;
  // wbuf
  unsigned char *wbuf;
  // write_ptr
  unsigned char *write_ptr;
  // padding
  unsigned int padding;
  // rlength
  unsigned int rlength;
  // ract_data_length
  signed int ract_data_length;
  // wlength
  unsigned int wlength;
  // wact_data_length
  signed int wact_data_length;
  // ract_data
  unsigned char *ract_data;
  // wact_data
  unsigned char *wact_data;
  // mac_data
  unsigned char *mac_data;
  // read_key
  unsigned char *read_key;
  // write_key
  unsigned char *write_key;
  // challenge_length
  unsigned int challenge_length;
  // challenge
  unsigned char challenge[32l];
  // conn_id_length
  unsigned int conn_id_length;
  // conn_id
  unsigned char conn_id[16l];
  // key_material_length
  unsigned int key_material_length;
  // key_material
  unsigned char key_material[48l];
  // read_sequence
  unsigned long int read_sequence;
  // write_sequence
  unsigned long int write_sequence;
  // tmp
  struct anonymous_10 tmp;
};

struct ssl3_buffer_st
{
  // buf
  unsigned char *buf;
  // len
  unsigned long int len;
  // offset
  signed int offset;
  // left
  signed int left;
};

struct ssl3_record_st
{
  // type
  signed int type;
  // length
  unsigned int length;
  // off
  unsigned int off;
  // data
  unsigned char *data;
  // input
  unsigned char *input;
  // comp
  unsigned char *comp;
  // epoch
  unsigned long int epoch;
  // seq_num
  unsigned char seq_num[8l];
};

struct ssl3_state_st
{
  // flags
  signed long int flags;
  // delay_buf_pop_ret
  signed int delay_buf_pop_ret;
  // read_sequence
  unsigned char read_sequence[8l];
  // read_mac_secret_size
  signed int read_mac_secret_size;
  // read_mac_secret
  unsigned char read_mac_secret[64l];
  // write_sequence
  unsigned char write_sequence[8l];
  // write_mac_secret_size
  signed int write_mac_secret_size;
  // write_mac_secret
  unsigned char write_mac_secret[64l];
  // server_random
  unsigned char server_random[32l];
  // client_random
  unsigned char client_random[32l];
  // need_empty_fragments
  signed int need_empty_fragments;
  // empty_fragment_done
  signed int empty_fragment_done;
  // init_extra
  signed int init_extra;
  // rbuf
  struct ssl3_buffer_st rbuf;
  // wbuf
  struct ssl3_buffer_st wbuf;
  // rrec
  struct ssl3_record_st rrec;
  // wrec
  struct ssl3_record_st wrec;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[4l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_type
  signed int wpend_type;
  // wpend_ret
  signed int wpend_ret;
  // wpend_buf
  const unsigned char *wpend_buf;
  // handshake_buffer
  struct bio_st *handshake_buffer;
  // handshake_dgst
  struct env_md_ctx_st **handshake_dgst;
  // change_cipher_spec
  signed int change_cipher_spec;
  // warn_alert
  signed int warn_alert;
  // fatal_alert
  signed int fatal_alert;
  // alert_dispatch
  signed int alert_dispatch;
  // send_alert
  unsigned char send_alert[2l];
  // renegotiate
  signed int renegotiate;
  // total_renegotiations
  signed int total_renegotiations;
  // num_renegotiations
  signed int num_renegotiations;
  // in_read_app_data
  signed int in_read_app_data;
  // client_opaque_prf_input
  void *client_opaque_prf_input;
  // client_opaque_prf_input_len
  unsigned long int client_opaque_prf_input_len;
  // server_opaque_prf_input
  void *server_opaque_prf_input;
  // server_opaque_prf_input_len
  unsigned long int server_opaque_prf_input_len;
  // tmp
  struct anonymous_11 tmp;
  // previous_client_finished
  unsigned char previous_client_finished[64l];
  // previous_client_finished_len
  unsigned char previous_client_finished_len;
  // previous_server_finished
  unsigned char previous_server_finished[64l];
  // previous_server_finished_len
  unsigned char previous_server_finished_len;
  // send_connection_binding
  signed int send_connection_binding;
  // next_proto_neg_seen
  signed int next_proto_neg_seen;
  // is_probably_safari
  char is_probably_safari;
  // alpn_selected
  unsigned char *alpn_selected;
  // alpn_selected_len
  unsigned int alpn_selected_len;
};

struct ssl_cipher_st
{
  // valid
  signed int valid;
  // name
  const char *name;
  // id
  unsigned long int id;
  // algorithm_mkey
  unsigned long int algorithm_mkey;
  // algorithm_auth
  unsigned long int algorithm_auth;
  // algorithm_enc
  unsigned long int algorithm_enc;
  // algorithm_mac
  unsigned long int algorithm_mac;
  // algorithm_ssl
  unsigned long int algorithm_ssl;
  // algo_strength
  unsigned long int algo_strength;
  // algorithm2
  unsigned long int algorithm2;
  // strength_bits
  signed int strength_bits;
  // alg_bits
  signed int alg_bits;
};

struct ssl_comp_st
{
  // id
  signed int id;
  // name
  const char *name;
  // method
  struct comp_method_st *method;
};

struct ssl_ctx_st
{
  // method
  const struct ssl_method_st *method;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // cert_store
  struct x509_store_st *cert_store;
  // sessions
  struct lhash_st_SSL_SESSION *sessions;
  // session_cache_size
  unsigned long int session_cache_size;
  // session_cache_head
  struct ssl_session_st *session_cache_head;
  // session_cache_tail
  struct ssl_session_st *session_cache_tail;
  // session_cache_mode
  signed int session_cache_mode;
  // session_timeout
  signed long int session_timeout;
  // new_session_cb
  signed int (*new_session_cb)(struct ssl_st *, struct ssl_session_st *);
  // remove_session_cb
  void (*remove_session_cb)(struct ssl_ctx_st *, struct ssl_session_st *);
  // get_session_cb
  struct ssl_session_st * (*get_session_cb)(struct ssl_st *, unsigned char *, signed int, signed int *);
  // stats
  struct anonymous_12 stats;
  // references
  signed int references;
  // app_verify_callback
  signed int (*app_verify_callback)(struct x509_store_ctx_st *, void *);
  // app_verify_arg
  void *app_verify_arg;
  // default_passwd_callback
  signed int (*default_passwd_callback)(char *, signed int, signed int, void *);
  // default_passwd_callback_userdata
  void *default_passwd_callback_userdata;
  // client_cert_cb
  signed int (*client_cert_cb)(struct ssl_st *, struct x509_st **, struct evp_pkey_st **);
  // app_gen_cookie_cb
  signed int (*app_gen_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int *);
  // app_verify_cookie_cb
  signed int (*app_verify_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // rsa_md5
  const struct env_md_st *rsa_md5;
  // md5
  const struct env_md_st *md5;
  // sha1
  const struct env_md_st *sha1;
  // extra_certs
  struct stack_st_X509 *extra_certs;
  // comp_methods
  struct stack_st_SSL_COMP *comp_methods;
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // cert
  struct cert_st *cert;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // verify_mode
  signed int verify_mode;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // default_verify_callback
  signed int (*default_verify_callback)(signed int, struct x509_store_ctx_st *);
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // param
  struct X509_VERIFY_PARAM_st *param;
  // quiet_shutdown
  signed int quiet_shutdown;
  // max_send_fragment
  unsigned int max_send_fragment;
  // client_cert_engine
  struct engine_st *client_cert_engine;
  // tlsext_servername_callback
  signed int (*tlsext_servername_callback)(struct ssl_st *, signed int *, void *);
  // tlsext_servername_arg
  void *tlsext_servername_arg;
  // tlsext_tick_key_name
  unsigned char tlsext_tick_key_name[16l];
  // tlsext_tick_hmac_key
  unsigned char tlsext_tick_hmac_key[16l];
  // tlsext_tick_aes_key
  unsigned char tlsext_tick_aes_key[16l];
  // tlsext_ticket_key_cb
  signed int (*tlsext_ticket_key_cb)(struct ssl_st *, unsigned char *, unsigned char *, struct evp_cipher_ctx_st *, struct hmac_ctx_st *, signed int);
  // tlsext_status_cb
  signed int (*tlsext_status_cb)(struct ssl_st *, void *);
  // tlsext_status_arg
  void *tlsext_status_arg;
  // tlsext_opaque_prf_input_callback
  signed int (*tlsext_opaque_prf_input_callback)(struct ssl_st *, void *, unsigned long int, void *);
  // tlsext_opaque_prf_input_callback_arg
  void *tlsext_opaque_prf_input_callback_arg;
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // freelist_max_len
  unsigned int freelist_max_len;
  // wbuf_freelist
  struct ssl3_buf_freelist_st *wbuf_freelist;
  // rbuf_freelist
  struct ssl3_buf_freelist_st *rbuf_freelist;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // next_protos_advertised_cb
  signed int (*next_protos_advertised_cb)(struct ssl_st *, const unsigned char **, unsigned int *, void *);
  // next_protos_advertised_cb_arg
  void *next_protos_advertised_cb_arg;
  // next_proto_select_cb
  signed int (*next_proto_select_cb)(struct ssl_st *, unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // next_proto_select_cb_arg
  void *next_proto_select_cb_arg;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // alpn_select_cb
  signed int (*alpn_select_cb)(struct ssl_st *, const unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // alpn_select_cb_arg
  void *alpn_select_cb_arg;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
};

struct ssl_method_st
{
  // version
  signed int version;
  // ssl_new
  signed int (*ssl_new)(struct ssl_st *);
  // ssl_clear
  void (*ssl_clear)(struct ssl_st *);
  // ssl_free
  void (*ssl_free)(struct ssl_st *);
  // ssl_accept
  signed int (*ssl_accept)(struct ssl_st *);
  // ssl_connect
  signed int (*ssl_connect)(struct ssl_st *);
  // ssl_read
  signed int (*ssl_read)(struct ssl_st *, void *, signed int);
  // ssl_peek
  signed int (*ssl_peek)(struct ssl_st *, void *, signed int);
  // ssl_write
  signed int (*ssl_write)(struct ssl_st *, const void *, signed int);
  // ssl_shutdown
  signed int (*ssl_shutdown)(struct ssl_st *);
  // ssl_renegotiate
  signed int (*ssl_renegotiate)(struct ssl_st *);
  // ssl_renegotiate_check
  signed int (*ssl_renegotiate_check)(struct ssl_st *);
  // ssl_get_message
  signed long int (*ssl_get_message)(struct ssl_st *, signed int, signed int, signed int, signed long int, signed int *);
  // ssl_read_bytes
  signed int (*ssl_read_bytes)(struct ssl_st *, signed int, unsigned char *, signed int, signed int);
  // ssl_write_bytes
  signed int (*ssl_write_bytes)(struct ssl_st *, signed int, const void *, signed int);
  // ssl_dispatch_alert
  signed int (*ssl_dispatch_alert)(struct ssl_st *);
  // ssl_ctrl
  signed long int (*ssl_ctrl)(struct ssl_st *, signed int, signed long int, void *);
  // ssl_ctx_ctrl
  signed long int (*ssl_ctx_ctrl)(struct ssl_ctx_st *, signed int, signed long int, void *);
  // get_cipher_by_char
  const struct ssl_cipher_st * (*get_cipher_by_char)(const unsigned char *);
  // put_cipher_by_char
  signed int (*put_cipher_by_char)(const struct ssl_cipher_st *, unsigned char *);
  // ssl_pending
  signed int (*ssl_pending)(const struct ssl_st *);
  // num_ciphers
  signed int (*num_ciphers)(void);
  // get_cipher
  const struct ssl_cipher_st * (*get_cipher)(unsigned int);
  // get_ssl_method
  struct ssl_method_st * (*get_ssl_method)(signed int);
  // get_timeout
  signed long int (*get_timeout)(void);
  // ssl3_enc
  struct ssl3_enc_method *ssl3_enc;
  // ssl_version
  signed int (*ssl_version)(void);
  // ssl_callback_ctrl
  signed long int (*ssl_callback_ctrl)(struct ssl_st *, signed int, void (*)(void));
  // ssl_ctx_callback_ctrl
  signed long int (*ssl_ctx_callback_ctrl)(struct ssl_ctx_st *, signed int, void (*)(void));
};

struct ssl_session_st
{
  // ssl_version
  signed int ssl_version;
  // key_arg_length
  unsigned int key_arg_length;
  // key_arg
  unsigned char key_arg[8l];
  // master_key_length
  signed int master_key_length;
  // master_key
  unsigned char master_key[48l];
  // session_id_length
  unsigned int session_id_length;
  // session_id
  unsigned char session_id[32l];
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_identity
  char *psk_identity;
  // not_resumable
  signed int not_resumable;
  // sess_cert
  struct sess_cert_st *sess_cert;
  // peer
  struct x509_st *peer;
  // verify_result
  signed long int verify_result;
  // references
  signed int references;
  // timeout
  signed long int timeout;
  // time
  signed long int time;
  // compress_meth
  unsigned int compress_meth;
  // cipher
  const struct ssl_cipher_st *cipher;
  // cipher_id
  unsigned long int cipher_id;
  // ciphers
  struct stack_st_SSL_CIPHER *ciphers;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // prev
  struct ssl_session_st *prev;
  // next
  struct ssl_session_st *next;
  // tlsext_hostname
  char *tlsext_hostname;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_tick
  unsigned char *tlsext_tick;
  // tlsext_ticklen
  unsigned long int tlsext_ticklen;
  // tlsext_tick_lifetime_hint
  signed long int tlsext_tick_lifetime_hint;
  // srp_username
  char *srp_username;
};

struct ssl_st
{
  // version
  signed int version;
  // type
  signed int type;
  // method
  const struct ssl_method_st *method;
  // rbio
  struct bio_st *rbio;
  // wbio
  struct bio_st *wbio;
  // bbio
  struct bio_st *bbio;
  // rwstate
  signed int rwstate;
  // in_handshake
  signed int in_handshake;
  // handshake_func
  signed int (*handshake_func)(struct ssl_st *);
  // server
  signed int server;
  // new_session
  signed int new_session;
  // quiet_shutdown
  signed int quiet_shutdown;
  // shutdown
  signed int shutdown;
  // state
  signed int state;
  // rstate
  signed int rstate;
  // init_buf
  struct buf_mem_st *init_buf;
  // init_msg
  void *init_msg;
  // init_num
  signed int init_num;
  // init_off
  signed int init_off;
  // packet
  unsigned char *packet;
  // packet_length
  unsigned int packet_length;
  // s2
  struct ssl2_state_st *s2;
  // s3
  struct ssl3_state_st *s3;
  // d1
  struct dtls1_state_st *d1;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // hit
  signed int hit;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // mac_flags
  signed int mac_flags;
  // enc_read_ctx
  struct evp_cipher_ctx_st *enc_read_ctx;
  // read_hash
  struct env_md_ctx_st *read_hash;
  // expand
  struct comp_ctx_st *expand;
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // cert
  struct cert_st *cert;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // session
  struct ssl_session_st *session;
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // verify_mode
  signed int verify_mode;
  // verify_callback
  signed int (*verify_callback)(signed int, struct x509_store_ctx_st *);
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // error
  signed int error;
  // error_code
  signed int error_code;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // ctx
  struct ssl_ctx_st *ctx;
  // debug
  signed int debug;
  // verify_result
  signed long int verify_result;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // references
  signed int references;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // first_packet
  signed int first_packet;
  // client_version
  signed int client_version;
  // max_send_fragment
  unsigned int max_send_fragment;
  // tlsext_debug_cb
  void (*tlsext_debug_cb)(struct ssl_st *, signed int, signed int, unsigned char *, signed int, void *);
  // tlsext_debug_arg
  void *tlsext_debug_arg;
  // tlsext_hostname
  char *tlsext_hostname;
  // servername_done
  signed int servername_done;
  // tlsext_status_type
  signed int tlsext_status_type;
  // tlsext_status_expected
  signed int tlsext_status_expected;
  // tlsext_ocsp_ids
  struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  // tlsext_ocsp_exts
  struct stack_st_X509_EXTENSION *tlsext_ocsp_exts;
  // tlsext_ocsp_resp
  unsigned char *tlsext_ocsp_resp;
  // tlsext_ocsp_resplen
  signed int tlsext_ocsp_resplen;
  // tlsext_ticket_expected
  signed int tlsext_ticket_expected;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_opaque_prf_input
  void *tlsext_opaque_prf_input;
  // tlsext_opaque_prf_input_len
  unsigned long int tlsext_opaque_prf_input_len;
  // tlsext_session_ticket
  struct tls_session_ticket_ext_st *tlsext_session_ticket;
  // tls_session_ticket_ext_cb
  signed int (*tls_session_ticket_ext_cb)(struct ssl_st *, const unsigned char *, signed int, void *);
  // tls_session_ticket_ext_cb_arg
  void *tls_session_ticket_ext_cb_arg;
  // tls_session_secret_cb
  signed int (*tls_session_secret_cb)(struct ssl_st *, void *, signed int *, struct stack_st_SSL_CIPHER *, struct ssl_cipher_st **, void *);
  // tls_session_secret_cb_arg
  void *tls_session_secret_cb_arg;
  // initial_ctx
  struct ssl_ctx_st *initial_ctx;
  // next_proto_negotiated
  unsigned char *next_proto_negotiated;
  // next_proto_negotiated_len
  unsigned char next_proto_negotiated_len;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // srtp_profile
  struct srtp_protection_profile_st *srtp_profile;
  // tlsext_heartbeat
  unsigned int tlsext_heartbeat;
  // tlsext_hb_pending
  unsigned int tlsext_hb_pending;
  // tlsext_hb_seq
  unsigned int tlsext_hb_seq;
  // renegotiate
  signed int renegotiate;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_ASIdOrRange
{
  // stack
  struct stack_st stack;
};

struct stack_st_ASN1_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_DIST_POINT
{
  // stack
  struct stack_st stack;
};

struct stack_st_GENERAL_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_GENERAL_SUBTREE
{
  // stack
  struct stack_st stack;
};

struct stack_st_IPAddressFamily
{
  // stack
  struct stack_st stack;
};

struct stack_st_SRTP_PROTECTION_PROFILE
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_CIPHER
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_COMP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ALGOR
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ATTRIBUTE
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_CRL
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_EXTENSION
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_LOOKUP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME_ENTRY
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_REVOKED
{
  // stack
  struct stack_st stack;
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tls_session_ticket_ext_st
{
  // length
  unsigned short int length;
  // data
  void *data;
};

struct x509_cert_aux_st
{
  // trust
  struct stack_st_ASN1_OBJECT *trust;
  // reject
  struct stack_st_ASN1_OBJECT *reject;
  // alias
  struct asn1_string_st *alias;
  // keyid
  struct asn1_string_st *keyid;
  // other
  struct stack_st_X509_ALGOR *other;
};

struct x509_cinf_st
{
  // version
  struct asn1_string_st *version;
  // serialNumber
  struct asn1_string_st *serialNumber;
  // signature
  struct X509_algor_st *signature;
  // issuer
  struct X509_name_st *issuer;
  // validity
  struct X509_val_st *validity;
  // subject
  struct X509_name_st *subject;
  // key
  struct X509_pubkey_st *key;
  // issuerUID
  struct asn1_string_st *issuerUID;
  // subjectUID
  struct asn1_string_st *subjectUID;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct x509_st
{
  // cert_info
  struct x509_cinf_st *cert_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // valid
  signed int valid;
  // references
  signed int references;
  // name
  char *name;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // ex_pathlen
  signed long int ex_pathlen;
  // ex_pcpathlen
  signed long int ex_pcpathlen;
  // ex_flags
  unsigned long int ex_flags;
  // ex_kusage
  unsigned long int ex_kusage;
  // ex_xkusage
  unsigned long int ex_xkusage;
  // ex_nscert
  unsigned long int ex_nscert;
  // skid
  struct asn1_string_st *skid;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // policy_cache
  struct X509_POLICY_CACHE_st *policy_cache;
  // crldp
  struct stack_st_DIST_POINT *crldp;
  // altname
  struct stack_st_GENERAL_NAME *altname;
  // nc
  struct NAME_CONSTRAINTS_st *nc;
  // rfc3779_addr
  struct stack_st_IPAddressFamily *rfc3779_addr;
  // rfc3779_asid
  struct ASIdentifiers_st *rfc3779_asid;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // aux
  struct x509_cert_aux_st *aux;
};

struct x509_store_ctx_st
{
  // ctx
  struct x509_store_st *ctx;
  // current_method
  signed int current_method;
  // cert
  struct x509_st *cert;
  // untrusted
  struct stack_st_X509 *untrusted;
  // crls
  struct stack_st_X509_CRL *crls;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // other_ctx
  void *other_ctx;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // check_policy
  signed int (*check_policy)(struct x509_store_ctx_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // valid
  signed int valid;
  // last_untrusted
  signed int last_untrusted;
  // chain
  struct stack_st_X509 *chain;
  // tree
  struct X509_POLICY_TREE_st *tree;
  // explicit_policy
  signed int explicit_policy;
  // error_depth
  signed int error_depth;
  // error
  signed int error;
  // current_cert
  struct x509_st *current_cert;
  // current_issuer
  struct x509_st *current_issuer;
  // current_crl
  struct X509_crl_st *current_crl;
  // current_crl_score
  signed int current_crl_score;
  // current_reasons
  unsigned int current_reasons;
  // parent
  struct x509_store_ctx_st *parent;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct x509_store_st
{
  // cache
  signed int cache;
  // objs
  struct stack_st_X509_OBJECT *objs;
  // get_cert_methods
  struct stack_st_X509_LOOKUP *get_cert_methods;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
};


// connected
// file pub_client.c line 50
static _Bool connected = (_Bool)1;
// disconnect_sent
// file pub_client.c line 53
static _Bool disconnect_sent = (_Bool)0;
// last_mid
// file pub_client.c line 48
static signed int last_mid = -1;
// last_mid_sent
// file pub_client.c line 49
static signed int last_mid_sent = -1;
// message
// file pub_client.c line 41
static char *message = (char *)(void *)0;
// mid_sent
// file pub_client.c line 47
static signed int mid_sent = 0;
// mode
// file pub_client.c line 45
static signed int mode = 0;
// msglen
// file pub_client.c line 42
static signed long int msglen = (signed long int)0;
// password
// file pub_client.c line 52
static char *password = (char *)(void *)0;
// qos
// file pub_client.c line 43
static signed int qos = 0;
// quiet
// file pub_client.c line 54
static _Bool quiet = (_Bool)0;
// retain
// file pub_client.c line 44
static signed int retain = 0;
// status
// file pub_client.c line 46
static signed int status = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// tls_ex_index_mosq
// file net_mosq.c line 87
signed int tls_ex_index_mosq = -1;
// topic
// file pub_client.c line 40
static char *topic = (char *)(void *)0;
// username
// file pub_client.c line 51
static char *username = (char *)(void *)0;

// _mosquitto_calloc
// file ./memory_mosq.h line 27
void * _mosquitto_calloc(unsigned long int nmemb, unsigned long int size)
{
  void *mem;
  mem=calloc(nmemb, size);
  return mem;
}

// _mosquitto_check_keepalive
// file ./util_mosq.h line 32
void _mosquitto_check_keepalive(struct mosquitto *mosq)
{
  signed long int last_msg_out;
  signed long int last_msg_in;
  signed long int now;
  now=mosquitto_time();
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  pthread_mutex_lock(&mosq->msgtime_mutex);
  last_msg_out = mosq->last_msg_out;
  last_msg_in = mosq->last_msg_in;
  pthread_mutex_unlock(&mosq->msgtime_mutex);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(!(mosq->keepalive == 0))
  {
    if(!(mosq->sock == -1))
    {
      if(now + -last_msg_out >= (signed long int)mosq->keepalive)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = now - last_msg_in >= (signed long int)mosq->keepalive ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        if((signed int)mosq->state == mosq_cs_connected)
          tmp_if_expr_1 = mosq->ping_t == (signed long int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(tmp_if_expr_1)
        {
          _mosquitto_send_pingreq(mosq);
          pthread_mutex_lock(&mosq->msgtime_mutex);
          mosq->last_msg_in = now;
          mosq->last_msg_out = now;
          pthread_mutex_unlock(&mosq->msgtime_mutex);
        }

        else
        {
          _mosquitto_socket_close(mosq);
          pthread_mutex_lock(&mosq->state_mutex);
          if((signed int)mosq->state == mosq_cs_disconnecting)
            rc = 0;

          else
            rc = 1;
          pthread_mutex_unlock(&mosq->state_mutex);
          pthread_mutex_lock(&mosq->callback_mutex);
          if(!(mosq->on_disconnect == ((void (*)(struct mosquitto *, void *, signed int))NULL)))
          {
            mosq->in_callback = (_Bool)1;
            mosq->on_disconnect(mosq, mosq->userdata, rc);
            mosq->in_callback = (_Bool)0;
          }

          pthread_mutex_unlock(&mosq->callback_mutex);
        }
      }

    }

  }

}

// _mosquitto_connect_init
// file mosquitto.c line 392
static signed int _mosquitto_connect_init(struct mosquitto *mosq, const char *host, signed int port, signed int keepalive, const char *bind_address)
{
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
    if(host == ((const char *)NULL) || !(port >= 1))
      return 3;

    else
    {
      if(!(mosq->host == ((char *)NULL)))
        _mosquitto_free((void *)mosq->host);

      mosq->host=_mosquitto_strdup(host);
      if(mosq->host == ((char *)NULL))
        return 1;

      else
      {
        mosq->port = port;
        if(!(mosq->bind_address == ((char *)NULL)))
          _mosquitto_free((void *)mosq->bind_address);

        if(!(bind_address == ((const char *)NULL)))
        {
          mosq->bind_address=_mosquitto_strdup(bind_address);
          if(!(mosq->bind_address == ((char *)NULL)))
            goto __CPROVER_DUMP_L6;

          return 1;
        }

        else
        {

        __CPROVER_DUMP_L6:
          ;
          mosq->keepalive = (unsigned short int)keepalive;
          if(!(mosq->sockpairR == -1))
          {
            close(mosq->sockpairR);
            mosq->sockpairR = -1;
          }

          if(!(mosq->sockpairW == -1))
          {
            close(mosq->sockpairW);
            mosq->sockpairW = -1;
          }

          signed int return_value__mosquitto_socketpair_1;
          return_value__mosquitto_socketpair_1=_mosquitto_socketpair(&mosq->sockpairR, &mosq->sockpairW);
          if(!(return_value__mosquitto_socketpair_1 == 0))
            _mosquitto_log_printf(mosq, 0x04, "Warning: Unable to open socket pair, outgoing publish commands may be delayed.");

          return 0;
        }
      }
    }
}

// _mosquitto_destroy
// file mosquitto.c line 275
void _mosquitto_destroy(struct mosquitto *mosq)
{
  struct _mosquitto_packet *packet;
  unsigned long int return_value_pthread_self_1;
  signed int return_value_pthread_equal_2;
  if(!(mosq == ((struct mosquitto *)NULL)))
  {
    if(!(mosq->threaded == (_Bool)0))
    {
      return_value_pthread_self_1=pthread_self();
      return_value_pthread_equal_2=pthread_equal(mosq->thread_id, return_value_pthread_self_1);
      if(return_value_pthread_equal_2 == 0)
      {
        pthread_cancel(mosq->thread_id);
        pthread_join(mosq->thread_id, (void **)(void *)0);
        mosq->threaded = (_Bool)0;
      }

    }

    if(!(mosq->id == ((char *)NULL)))
    {
      pthread_mutex_destroy(&mosq->callback_mutex);
      pthread_mutex_destroy(&mosq->log_callback_mutex);
      pthread_mutex_destroy(&mosq->state_mutex);
      pthread_mutex_destroy(&mosq->out_packet_mutex);
      pthread_mutex_destroy(&mosq->current_out_packet_mutex);
      pthread_mutex_destroy(&mosq->msgtime_mutex);
      pthread_mutex_destroy(&mosq->in_message_mutex);
      pthread_mutex_destroy(&mosq->out_message_mutex);
      pthread_mutex_destroy(&mosq->mid_mutex);
    }

    if(!(mosq->sock == -1))
      _mosquitto_socket_close(mosq);

    _mosquitto_message_cleanup_all(mosq);
    _mosquitto_will_clear(mosq);
    if(!(mosq->ssl == ((struct ssl_st *)NULL)))
      SSL_free(mosq->ssl);

    if(!(mosq->ssl_ctx == ((struct ssl_ctx_st *)NULL)))
      SSL_CTX_free(mosq->ssl_ctx);

    if(!(mosq->tls_cafile == ((char *)NULL)))
      _mosquitto_free((void *)mosq->tls_cafile);

    if(!(mosq->tls_capath == ((char *)NULL)))
      _mosquitto_free((void *)mosq->tls_capath);

    if(!(mosq->tls_certfile == ((char *)NULL)))
      _mosquitto_free((void *)mosq->tls_certfile);

    if(!(mosq->tls_keyfile == ((char *)NULL)))
      _mosquitto_free((void *)mosq->tls_keyfile);

    if(!(mosq->tls_pw_callback == ((signed int (*)(char *, signed int, signed int, void *))NULL)))
      mosq->tls_pw_callback = (signed int (*)(char *, signed int, signed int, void *))(void *)0;

    if(!(mosq->tls_version == ((char *)NULL)))
      _mosquitto_free((void *)mosq->tls_version);

    if(!(mosq->tls_ciphers == ((char *)NULL)))
      _mosquitto_free((void *)mosq->tls_ciphers);

    if(!(mosq->tls_psk == ((char *)NULL)))
      _mosquitto_free((void *)mosq->tls_psk);

    if(!(mosq->tls_psk_identity == ((char *)NULL)))
      _mosquitto_free((void *)mosq->tls_psk_identity);

    if(!(mosq->address == ((char *)NULL)))
    {
      _mosquitto_free((void *)mosq->address);
      mosq->address = (char *)(void *)0;
    }

    if(!(mosq->id == ((char *)NULL)))
    {
      _mosquitto_free((void *)mosq->id);
      mosq->id = (char *)(void *)0;
    }

    if(!(mosq->username == ((char *)NULL)))
    {
      _mosquitto_free((void *)mosq->username);
      mosq->username = (char *)(void *)0;
    }

    if(!(mosq->password == ((char *)NULL)))
    {
      _mosquitto_free((void *)mosq->password);
      mosq->password = (char *)(void *)0;
    }

    if(!(mosq->host == ((char *)NULL)))
    {
      _mosquitto_free((void *)mosq->host);
      mosq->host = (char *)(void *)0;
    }

    if(!(mosq->bind_address == ((char *)NULL)))
    {
      _mosquitto_free((void *)mosq->bind_address);
      mosq->bind_address = (char *)(void *)0;
    }

    if(!(mosq->out_packet == ((struct _mosquitto_packet *)NULL)))
    {
      if(mosq->current_out_packet == ((struct _mosquitto_packet *)NULL))
      {
        mosq->current_out_packet = mosq->out_packet;
        mosq->out_packet = mosq->out_packet->next;
      }

    }

    while(!(mosq->current_out_packet == ((struct _mosquitto_packet *)NULL)))
    {
      packet = mosq->current_out_packet;
      mosq->current_out_packet = mosq->out_packet;
      if(!(mosq->out_packet == ((struct _mosquitto_packet *)NULL)))
        mosq->out_packet = mosq->out_packet->next;

      _mosquitto_packet_cleanup(packet);
      _mosquitto_free((void *)packet);
    }
    _mosquitto_packet_cleanup(&mosq->in_packet);
    if(!(mosq->sockpairR == -1))
    {
      close(mosq->sockpairR);
      mosq->sockpairR = -1;
    }

    if(!(mosq->sockpairW == -1))
    {
      close(mosq->sockpairW);
      mosq->sockpairW = -1;
    }

  }

}

// _mosquitto_fopen
// file ./util_mosq.h line 35
struct _IO_FILE * _mosquitto_fopen(const char *path, const char *mode)
{
  struct _IO_FILE *return_value_fopen_1;
  return_value_fopen_1=fopen(path, mode);
  return return_value_fopen_1;
}

// _mosquitto_free
// file ./memory_mosq.h line 28
void _mosquitto_free(void *mem)
{
  free(mem);
}

// _mosquitto_handle_connack
// file ./read_handle.h line 23
signed int _mosquitto_handle_connack(struct mosquitto *mosq)
{
  unsigned char byte;
  unsigned char result;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  _mosquitto_log_printf(mosq, 0x10, "Client %s received CONNACK", mosq->id);
  rc=_mosquitto_read_byte(&mosq->in_packet, &byte);
  if(!(rc == 0))
    return rc;

  else
  {
    rc=_mosquitto_read_byte(&mosq->in_packet, &result);
    if(!(rc == 0))
      return rc;

    else
    {
      pthread_mutex_lock(&mosq->callback_mutex);
      if(!(mosq->on_connect == ((void (*)(struct mosquitto *, void *, signed int))NULL)))
      {
        mosq->in_callback = (_Bool)1;
        mosq->on_connect(mosq, mosq->userdata, (signed int)result);
        mosq->in_callback = (_Bool)0;
      }

      pthread_mutex_unlock(&mosq->callback_mutex);
      switch((signed int)result)
      {
        case 0:
        {
          if(!((signed int)mosq->state == mosq_cs_disconnecting))
            mosq->state = (enum mosquitto_client_state)mosq_cs_connected;

          return 0;
        }
        case 1:

        case 2:

        case 3:

        case 4:

        case 5:
          return 5;
        default:
          return 2;
      }
    }
  }
}

// _mosquitto_handle_pingreq
// file ./read_handle.h line 24
signed int _mosquitto_handle_pingreq(struct mosquitto *mosq)
{
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  _mosquitto_log_printf(mosq, 0x10, "Client %s received PINGREQ", mosq->id);
  signed int return_value__mosquitto_send_pingresp_1;
  return_value__mosquitto_send_pingresp_1=_mosquitto_send_pingresp(mosq);
  return return_value__mosquitto_send_pingresp_1;
}

// _mosquitto_handle_pingresp
// file ./read_handle.h line 25
signed int _mosquitto_handle_pingresp(struct mosquitto *mosq)
{
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  mosq->ping_t = (signed long int)0;
  _mosquitto_log_printf(mosq, 0x10, "Client %s received PINGRESP", mosq->id);
  return 0;
}

// _mosquitto_handle_pubackcomp
// file ./read_handle.h line 29
signed int _mosquitto_handle_pubackcomp(struct mosquitto *mosq, const char *type)
{
  unsigned short int mid;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  rc=_mosquitto_read_uint16(&mosq->in_packet, &mid);
  if(!(rc == 0))
    return rc;

  else
  {
    _mosquitto_log_printf(mosq, 0x10, "Client %s received %s (Mid: %d)", mosq->id, type, mid);
    signed int return_value__mosquitto_message_delete_1;
    return_value__mosquitto_message_delete_1=_mosquitto_message_delete(mosq, mid, (enum mosquitto_msg_direction)mosq_md_out);
    if(return_value__mosquitto_message_delete_1 == 0)
    {
      pthread_mutex_lock(&mosq->callback_mutex);
      if(!(mosq->on_publish == ((void (*)(struct mosquitto *, void *, signed int))NULL)))
      {
        mosq->in_callback = (_Bool)1;
        mosq->on_publish(mosq, mosq->userdata, (signed int)mid);
        mosq->in_callback = (_Bool)0;
      }

      pthread_mutex_unlock(&mosq->callback_mutex);
    }

    return 0;
  }
}

// _mosquitto_handle_publish
// file read_handle.c line 64
signed int _mosquitto_handle_publish(struct mosquitto *mosq)
{
  unsigned char header;
  struct mosquitto_message_all *_mosquitto_handle_publish__1__message;
  signed int rc = 0;
  unsigned short int mid;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  void *return_value__mosquitto_calloc_1;
  return_value__mosquitto_calloc_1=_mosquitto_calloc((unsigned long int)1, sizeof(struct mosquitto_message_all) /*64ul*/ );
  _mosquitto_handle_publish__1__message = (struct mosquitto_message_all *)return_value__mosquitto_calloc_1;
  if(_mosquitto_handle_publish__1__message == ((struct mosquitto_message_all *)NULL))
    return 1;

  else
  {
    header = mosq->in_packet.command;
    _mosquitto_handle_publish__1__message->dup = (_Bool)(((signed int)header & 0x08) >> 3);
    _mosquitto_handle_publish__1__message->msg.qos = ((signed int)header & 0x06) >> 1;
    _mosquitto_handle_publish__1__message->msg.retain = (_Bool)((signed int)header & 0x01);
    rc=_mosquitto_read_string(&mosq->in_packet, &_mosquitto_handle_publish__1__message->msg.topic);
    if(!(rc == 0))
    {
      _mosquitto_message_cleanup(&_mosquitto_handle_publish__1__message);
      return rc;
    }

    else
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(_mosquitto_handle_publish__1__message->msg.topic);
      if(return_value_strlen_2 == 0ul)
      {
        _mosquitto_message_cleanup(&_mosquitto_handle_publish__1__message);
        return 2;
      }

      else
      {
        if(_mosquitto_handle_publish__1__message->msg.qos >= 1)
        {
          rc=_mosquitto_read_uint16(&mosq->in_packet, &mid);
          if(!(rc == 0))
          {
            _mosquitto_message_cleanup(&_mosquitto_handle_publish__1__message);
            return rc;
          }

          _mosquitto_handle_publish__1__message->msg.mid = (signed int)mid;
        }

        _mosquitto_handle_publish__1__message->msg.payloadlen = (signed int)(mosq->in_packet.remaining_length - mosq->in_packet.pos);
        if(!(_mosquitto_handle_publish__1__message->msg.payloadlen == 0))
        {
          _mosquitto_handle_publish__1__message->msg.payload=_mosquitto_calloc((unsigned long int)(_mosquitto_handle_publish__1__message->msg.payloadlen + 1), sizeof(unsigned char) /*1ul*/ );
          if(_mosquitto_handle_publish__1__message->msg.payload == NULL)
          {
            _mosquitto_message_cleanup(&_mosquitto_handle_publish__1__message);
            return 1;
          }

          rc=_mosquitto_read_bytes(&mosq->in_packet, _mosquitto_handle_publish__1__message->msg.payload, (unsigned int)_mosquitto_handle_publish__1__message->msg.payloadlen);
          if(rc == 0)
            goto __CPROVER_DUMP_L7;

          _mosquitto_message_cleanup(&_mosquitto_handle_publish__1__message);
          return rc;
        }

        else
        {

        __CPROVER_DUMP_L7:
          ;
          _mosquitto_log_printf(mosq, 0x10, "Client %s received PUBLISH (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))", mosq->id, _mosquitto_handle_publish__1__message->dup, _mosquitto_handle_publish__1__message->msg.qos, _mosquitto_handle_publish__1__message->msg.retain, _mosquitto_handle_publish__1__message->msg.mid, _mosquitto_handle_publish__1__message->msg.topic, (signed long int)_mosquitto_handle_publish__1__message->msg.payloadlen);
          _mosquitto_handle_publish__1__message->timestamp=mosquitto_time();
          switch(_mosquitto_handle_publish__1__message->msg.qos)
          {
            case 0:
            {
              pthread_mutex_lock(&mosq->callback_mutex);
              if(!(mosq->on_message == ((void (*)(struct mosquitto *, void *, struct mosquitto_message *))NULL)))
              {
                mosq->in_callback = (_Bool)1;
                mosq->on_message(mosq, mosq->userdata, &_mosquitto_handle_publish__1__message->msg);
                mosq->in_callback = (_Bool)0;
              }

              pthread_mutex_unlock(&mosq->callback_mutex);
              _mosquitto_message_cleanup(&_mosquitto_handle_publish__1__message);
              return 0;
            }
            case 1:
            {
              rc=_mosquitto_send_puback(mosq, (unsigned short int)_mosquitto_handle_publish__1__message->msg.mid);
              pthread_mutex_lock(&mosq->callback_mutex);
              if(!(mosq->on_message == ((void (*)(struct mosquitto *, void *, struct mosquitto_message *))NULL)))
              {
                mosq->in_callback = (_Bool)1;
                mosq->on_message(mosq, mosq->userdata, &_mosquitto_handle_publish__1__message->msg);
                mosq->in_callback = (_Bool)0;
              }

              pthread_mutex_unlock(&mosq->callback_mutex);
              _mosquitto_message_cleanup(&_mosquitto_handle_publish__1__message);
              return rc;
            }
            case 2:
            {
              rc=_mosquitto_send_pubrec(mosq, (unsigned short int)_mosquitto_handle_publish__1__message->msg.mid);
              pthread_mutex_lock(&mosq->in_message_mutex);
              _mosquitto_handle_publish__1__message->state = (enum mosquitto_msg_state)mosq_ms_wait_for_pubrel;
              _mosquitto_message_queue(mosq, _mosquitto_handle_publish__1__message, (enum mosquitto_msg_direction)mosq_md_in);
              pthread_mutex_unlock(&mosq->in_message_mutex);
              return rc;
            }
            default:
            {
              _mosquitto_message_cleanup(&_mosquitto_handle_publish__1__message);
              return 2;
            }
          }
        }
      }
    }
  }
}

// _mosquitto_handle_pubrec
// file ./read_handle.h line 32
signed int _mosquitto_handle_pubrec(struct mosquitto *mosq)
{
  unsigned short int mid;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  rc=_mosquitto_read_uint16(&mosq->in_packet, &mid);
  if(!(rc == 0))
    return rc;

  else
  {
    _mosquitto_log_printf(mosq, 0x10, "Client %s received PUBREC (Mid: %d)", mosq->id, mid);
    rc=_mosquitto_message_out_update(mosq, mid, (enum mosquitto_msg_state)mosq_ms_wait_for_pubcomp);
    if(!(rc == 0))
      return rc;

    else
    {
      rc=_mosquitto_send_pubrel(mosq, mid);
      if(!(rc == 0))
        return rc;

      else
        return 0;
    }
  }
}

// _mosquitto_handle_pubrel
// file ./read_handle.h line 33
signed int _mosquitto_handle_pubrel(struct mosquitto_db *db, struct mosquitto *mosq)
{
  unsigned short int mid;
  struct mosquitto_message_all *_mosquitto_handle_pubrel__1__message = (struct mosquitto_message_all *)(void *)0;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  if((signed int)mosq->protocol == mosq_p_mqtt311)
  {
    if((0x0F & (signed int)mosq->in_packet.command) == 0x02)
      goto __CPROVER_DUMP_L1;

    return 2;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    rc=_mosquitto_read_uint16(&mosq->in_packet, &mid);
    if(!(rc == 0))
      return rc;

    else
    {
      _mosquitto_log_printf(mosq, 0x10, "Client %s received PUBREL (Mid: %d)", mosq->id, mid);
      signed int return_value__mosquitto_message_remove_1;
      return_value__mosquitto_message_remove_1=_mosquitto_message_remove(mosq, mid, (enum mosquitto_msg_direction)mosq_md_in, &_mosquitto_handle_pubrel__1__message);
      if(return_value__mosquitto_message_remove_1 == 0)
      {
        pthread_mutex_lock(&mosq->callback_mutex);
        if(!(mosq->on_message == ((void (*)(struct mosquitto *, void *, struct mosquitto_message *))NULL)))
        {
          mosq->in_callback = (_Bool)1;
          mosq->on_message(mosq, mosq->userdata, &_mosquitto_handle_pubrel__1__message->msg);
          mosq->in_callback = (_Bool)0;
        }

        pthread_mutex_unlock(&mosq->callback_mutex);
        _mosquitto_message_cleanup(&_mosquitto_handle_pubrel__1__message);
      }

      rc=_mosquitto_send_pubcomp(mosq, mid);
      if(!(rc == 0))
        return rc;

      else
        return 0;
    }
  }
}

// _mosquitto_handle_suback
// file ./read_handle.h line 34
signed int _mosquitto_handle_suback(struct mosquitto *mosq)
{
  unsigned short int mid;
  unsigned char _mosquitto_handle_suback__1__qos;
  signed int *granted_qos;
  signed int qos_count;
  signed int i = 0;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  _mosquitto_log_printf(mosq, 0x10, "Client %s received SUBACK", mosq->id);
  rc=_mosquitto_read_uint16(&mosq->in_packet, &mid);
  if(!(rc == 0))
    return rc;

  else
  {
    qos_count = (signed int)(mosq->in_packet.remaining_length - mosq->in_packet.pos);
    void *return_value__mosquitto_malloc_1;
    return_value__mosquitto_malloc_1=_mosquitto_malloc((unsigned long int)qos_count * sizeof(signed int) /*4ul*/ );
    granted_qos = (signed int *)return_value__mosquitto_malloc_1;
    if(granted_qos == ((signed int *)NULL))
      return 1;

    else
    {
      for( ; !(mosq->in_packet.pos >= mosq->in_packet.remaining_length); i = i + 1)
      {
        rc=_mosquitto_read_byte(&mosq->in_packet, &_mosquitto_handle_suback__1__qos);
        if(!(rc == 0))
        {
          _mosquitto_free((void *)granted_qos);
          return rc;
        }

        granted_qos[(signed long int)i] = (signed int)_mosquitto_handle_suback__1__qos;
      }
      pthread_mutex_lock(&mosq->callback_mutex);
      if(!(mosq->on_subscribe == ((void (*)(struct mosquitto *, void *, signed int, signed int, const signed int *))NULL)))
      {
        mosq->in_callback = (_Bool)1;
        mosq->on_subscribe(mosq, mosq->userdata, (signed int)mid, qos_count, granted_qos);
        mosq->in_callback = (_Bool)0;
      }

      pthread_mutex_unlock(&mosq->callback_mutex);
      _mosquitto_free((void *)granted_qos);
      return 0;
    }
  }
}

// _mosquitto_handle_unsuback
// file ./read_handle.h line 35
signed int _mosquitto_handle_unsuback(struct mosquitto *mosq)
{
  unsigned short int mid;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  _mosquitto_log_printf(mosq, 0x10, "Client %s received UNSUBACK", mosq->id);
  rc=_mosquitto_read_uint16(&mosq->in_packet, &mid);
  if(!(rc == 0))
    return rc;

  else
  {
    pthread_mutex_lock(&mosq->callback_mutex);
    if(!(mosq->on_unsubscribe == ((void (*)(struct mosquitto *, void *, signed int))NULL)))
    {
      mosq->in_callback = (_Bool)1;
      mosq->on_unsubscribe(mosq, mosq->userdata, (signed int)mid);
      mosq->in_callback = (_Bool)0;
    }

    pthread_mutex_unlock(&mosq->callback_mutex);
    return 0;
  }
}

// _mosquitto_hex2bin
// file ./util_mosq.h line 38
signed int _mosquitto_hex2bin(const char *hex, unsigned char *bin, signed int bin_max_len)
{
  struct bignum_st *bn = (struct bignum_st *)(void *)0;
  signed int len;
  signed int return_value_BN_hex2bn_1;
  return_value_BN_hex2bn_1=BN_hex2bn(&bn, hex);
  if(return_value_BN_hex2bn_1 == 0)
  {
    if(!(bn == ((struct bignum_st *)NULL)))
      BN_free(bn);

    return 0;
  }

  else
  {
    signed int return_value_BN_num_bits_2;
    return_value_BN_num_bits_2=BN_num_bits(bn);
    if(!(bin_max_len >= (7 + return_value_BN_num_bits_2) / 8))
    {
      BN_free(bn);
      return 0;
    }

    else
    {
      len=BN_bn2bin(bn, bin);
      BN_free(bn);
      return len;
    }
  }
}

// _mosquitto_log_printf
// file ./logging_mosq.h line 21
signed int _mosquitto_log_printf(struct mosquitto *mosq, signed int priority, const char *fmt, ...)
{
  void **va;
  char *s;
  signed int len;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  /* assertion fmt */
  assert(fmt != ((const char *)NULL));
  pthread_mutex_lock(&mosq->log_callback_mutex);
  if(!(mosq->on_log == ((void (*)(struct mosquitto *, void *, signed int, const char *))NULL)))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(fmt);
    len = (signed int)(return_value_strlen_1 + (unsigned long int)500);
    void *return_value__mosquitto_malloc_2;
    return_value__mosquitto_malloc_2=_mosquitto_malloc((unsigned long int)len * sizeof(char) /*1ul*/ );
    s = (char *)return_value__mosquitto_malloc_2;
    if(s == ((char *)NULL))
    {
      pthread_mutex_unlock(&mosq->log_callback_mutex);
      return 1;
    }

    va = (void **)&fmt;
    vsnprintf(s, (unsigned long int)len, fmt, va);
    va = ((void **)NULL);
    s[(signed long int)(len - 1)] = (char)0;
    mosq->on_log(mosq, mosq->userdata, priority, s);
    _mosquitto_free((void *)s);
  }

  pthread_mutex_unlock(&mosq->log_callback_mutex);
  return 0;
}

// _mosquitto_loop_rc_handle
// file mosquitto.c line 1109
static signed int _mosquitto_loop_rc_handle(struct mosquitto *mosq, signed int rc)
{
  if(!(rc == 0))
  {
    _mosquitto_socket_close(mosq);
    pthread_mutex_lock(&mosq->state_mutex);
    if((signed int)mosq->state == mosq_cs_disconnecting)
      rc = 0;

    pthread_mutex_unlock(&mosq->state_mutex);
    pthread_mutex_lock(&mosq->callback_mutex);
    if(!(mosq->on_disconnect == ((void (*)(struct mosquitto *, void *, signed int))NULL)))
    {
      mosq->in_callback = (_Bool)1;
      mosq->on_disconnect(mosq, mosq->userdata, rc);
      mosq->in_callback = (_Bool)0;
    }

    pthread_mutex_unlock(&mosq->callback_mutex);
    return rc;
  }

  else
    return rc;
}

// _mosquitto_malloc
// file ./memory_mosq.h line 29
void * _mosquitto_malloc(unsigned long int size)
{
  void *mem;
  mem=malloc(size);
  return mem;
}

// _mosquitto_message_cleanup
// file ./messages_mosq.h line 23
void _mosquitto_message_cleanup(struct mosquitto_message_all **message)
{
  struct mosquitto_message_all *msg;
  _Bool tmp_if_expr_1;
  if(message == ((struct mosquitto_message_all **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*message != ((struct mosquitto_message_all *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    msg = *message;
    if(!(msg->msg.topic == ((char *)NULL)))
      _mosquitto_free((void *)msg->msg.topic);

    if(!(msg->msg.payload == NULL))
      _mosquitto_free(msg->msg.payload);

    _mosquitto_free((void *)msg);
  }

}

// _mosquitto_message_cleanup_all
// file ./messages_mosq.h line 22
void _mosquitto_message_cleanup_all(struct mosquitto *mosq)
{
  struct mosquitto_message_all *tmp;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  for( ; !(mosq->in_messages == ((struct mosquitto_message_all *)NULL)); mosq->in_messages = tmp)
  {
    tmp = mosq->in_messages->next;
    _mosquitto_message_cleanup(&mosq->in_messages);
  }
  for( ; !(mosq->out_messages == ((struct mosquitto_message_all *)NULL)); mosq->out_messages = tmp)
  {
    tmp = mosq->out_messages->next;
    _mosquitto_message_cleanup(&mosq->out_messages);
  }
}

// _mosquitto_message_delete
// file messages_mosq.c line 83
signed int _mosquitto_message_delete(struct mosquitto *mosq, unsigned short int mid, enum mosquitto_msg_direction dir)
{
  struct mosquitto_message_all *_mosquitto_message_delete__1__message;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  rc=_mosquitto_message_remove(mosq, mid, dir, &_mosquitto_message_delete__1__message);
  if(rc == 0)
    _mosquitto_message_cleanup(&_mosquitto_message_delete__1__message);

  return rc;
}

// _mosquitto_message_out_update
// file messages_mosq.c line 371
signed int _mosquitto_message_out_update(struct mosquitto *mosq, unsigned short int mid, enum mosquitto_msg_state state)
{
  struct mosquitto_message_all *_mosquitto_message_out_update__1__message;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  pthread_mutex_lock(&mosq->out_message_mutex);
  _mosquitto_message_out_update__1__message = mosq->out_messages;
  for( ; !(_mosquitto_message_out_update__1__message == ((struct mosquitto_message_all *)NULL)); _mosquitto_message_out_update__1__message = _mosquitto_message_out_update__1__message->next)
    if(_mosquitto_message_out_update__1__message->msg.mid == (signed int)mid)
    {
      _mosquitto_message_out_update__1__message->state = state;
      _mosquitto_message_out_update__1__message->timestamp=mosquitto_time();
      pthread_mutex_unlock(&mosq->out_message_mutex);
      return 0;
    }

  pthread_mutex_unlock(&mosq->out_message_mutex);
  return 6;
}

// _mosquitto_message_queue
// file ./messages_mosq.h line 25
signed int _mosquitto_message_queue(struct mosquitto *mosq, struct mosquitto_message_all *message, enum mosquitto_msg_direction dir)
{
  signed int rc = 0;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  /* assertion message */
  assert(message != ((struct mosquitto_message_all *)NULL));
  _Bool tmp_if_expr_1;
  if((signed int)dir == mosq_md_out)
  {
    mosq->out_queue_len = mosq->out_queue_len + 1;
    message->next = (struct mosquitto_message_all *)(void *)0;
    if(!(mosq->out_messages_last == ((struct mosquitto_message_all *)NULL)))
      mosq->out_messages_last->next = message;

    else
      mosq->out_messages = message;
    mosq->out_messages_last = message;
    if(message->msg.qos >= 1)
    {
      if(mosq->max_inflight_messages == 0)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = mosq->inflight_messages < mosq->max_inflight_messages ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        mosq->inflight_messages = mosq->inflight_messages + 1;

      else
        rc = 1;
    }

  }

  else
  {
    mosq->in_queue_len = mosq->in_queue_len + 1;
    message->next = (struct mosquitto_message_all *)(void *)0;
    if(!(mosq->in_messages_last == ((struct mosquitto_message_all *)NULL)))
      mosq->in_messages_last->next = message;

    else
      mosq->in_messages = message;
    mosq->in_messages_last = message;
  }
  return rc;
}

// _mosquitto_message_remove
// file messages_mosq.c line 214
signed int _mosquitto_message_remove(struct mosquitto *mosq, unsigned short int mid, enum mosquitto_msg_direction dir, struct mosquitto_message_all **message)
{
  struct mosquitto_message_all *cur;
  struct mosquitto_message_all *prev = (struct mosquitto_message_all *)(void *)0;
  _Bool found = (_Bool)0;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  /* assertion message */
  assert(message != ((struct mosquitto_message_all **)NULL));
  _Bool tmp_if_expr_1;
  if((signed int)dir == mosq_md_out)
  {
    pthread_mutex_lock(&mosq->out_message_mutex);
    cur = mosq->out_messages;
    for( ; !(cur == ((struct mosquitto_message_all *)NULL)); cur = cur->next)
    {
      if(cur->msg.mid == (signed int)mid)
      {
        if(!(prev == ((struct mosquitto_message_all *)NULL)))
          prev->next = cur->next;

        else
          mosq->out_messages = cur->next;
        *message = cur;
        mosq->out_queue_len = mosq->out_queue_len - 1;
        if(cur->next == ((struct mosquitto_message_all *)NULL))
          mosq->out_messages_last = prev;

        else
          if(mosq->out_messages == ((struct mosquitto_message_all *)NULL))
            mosq->out_messages_last = (struct mosquitto_message_all *)(void *)0;

        if(cur->msg.qos >= 1)
          mosq->inflight_messages = mosq->inflight_messages - 1;

        found = (_Bool)1;
        break;
      }

      prev = cur;
    }
    if(!(found == (_Bool)0))
    {
      cur = mosq->out_messages;
      for( ; !(cur == ((struct mosquitto_message_all *)NULL)); cur = cur->next)
      {
        if(mosq->max_inflight_messages == 0)
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = mosq->inflight_messages < mosq->max_inflight_messages ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          if(cur->msg.qos >= 1)
          {
            if((signed int)cur->state == mosq_ms_invalid)
            {
              mosq->inflight_messages = mosq->inflight_messages + 1;
              if(cur->msg.qos == 1)
                cur->state = (enum mosquitto_msg_state)mosq_ms_wait_for_puback;

              else
                if(cur->msg.qos == 2)
                  cur->state = (enum mosquitto_msg_state)mosq_ms_wait_for_pubrec;

              rc=_mosquitto_send_publish(mosq, (unsigned short int)cur->msg.mid, cur->msg.topic, (unsigned int)cur->msg.payloadlen, cur->msg.payload, cur->msg.qos, cur->msg.retain, cur->dup);
              if(!(rc == 0))
              {
                pthread_mutex_unlock(&mosq->out_message_mutex);
                return rc;
              }

            }

          }

        }

        else
        {
          pthread_mutex_unlock(&mosq->out_message_mutex);
          return 0;
        }
      }
      pthread_mutex_unlock(&mosq->out_message_mutex);
      return 0;
    }

    else
    {
      pthread_mutex_unlock(&mosq->out_message_mutex);
      return 6;
    }
  }

  else
  {
    pthread_mutex_lock(&mosq->in_message_mutex);
    cur = mosq->in_messages;
    for( ; !(cur == ((struct mosquitto_message_all *)NULL)); cur = cur->next)
    {
      if(cur->msg.mid == (signed int)mid)
      {
        if(!(prev == ((struct mosquitto_message_all *)NULL)))
          prev->next = cur->next;

        else
          mosq->in_messages = cur->next;
        *message = cur;
        mosq->in_queue_len = mosq->in_queue_len - 1;
        if(cur->next == ((struct mosquitto_message_all *)NULL))
          mosq->in_messages_last = prev;

        else
          if(mosq->in_messages == ((struct mosquitto_message_all *)NULL))
            mosq->in_messages_last = (struct mosquitto_message_all *)(void *)0;

        found = (_Bool)1;
        break;
      }

      prev = cur;
    }
    pthread_mutex_unlock(&mosq->in_message_mutex);
    if(!(found == (_Bool)0))
      return 0;

    else
      return 6;
  }
}

// _mosquitto_message_retry_check
// file ./messages_mosq.h line 28
void _mosquitto_message_retry_check(struct mosquitto *mosq)
{
  _mosquitto_message_retry_check_actual(mosq, mosq->out_messages, &mosq->out_message_mutex);
  _mosquitto_message_retry_check_actual(mosq, mosq->in_messages, &mosq->in_message_mutex);
}

// _mosquitto_message_retry_check_actual
// file messages_mosq.c line 312
void _mosquitto_message_retry_check_actual(struct mosquitto *mosq, struct mosquitto_message_all *messages, union anonymous_1 *mutex)
{
  signed long int now;
  now=mosquitto_time();
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  pthread_mutex_lock(mutex);
  for( ; !(messages == ((struct mosquitto_message_all *)NULL)); messages = messages->next)
    if(!(messages->timestamp + (signed long int)mosq->message_retry >= now))
      switch((signed int)messages->state)
      {
        case mosq_ms_wait_for_puback:

        case mosq_ms_wait_for_pubrec:
        {
          messages->timestamp = now;
          messages->dup = (_Bool)1;
          _mosquitto_send_publish(mosq, (unsigned short int)messages->msg.mid, messages->msg.topic, (unsigned int)messages->msg.payloadlen, messages->msg.payload, messages->msg.qos, messages->msg.retain, messages->dup);
          break;
        }
        case mosq_ms_wait_for_pubrel:
        {
          messages->timestamp = now;
          messages->dup = (_Bool)1;
          _mosquitto_send_pubrec(mosq, (unsigned short int)messages->msg.mid);
          break;
        }
        case mosq_ms_wait_for_pubcomp:
        {
          messages->timestamp = now;
          messages->dup = (_Bool)1;
          _mosquitto_send_pubrel(mosq, (unsigned short int)messages->msg.mid);
        }
      }

  pthread_mutex_unlock(mutex);
}

// _mosquitto_messages_reconnect_reset
// file ./messages_mosq.h line 26
void _mosquitto_messages_reconnect_reset(struct mosquitto *mosq)
{
  struct mosquitto_message_all *_mosquitto_messages_reconnect_reset__1__message;
  struct mosquitto_message_all *prev = (struct mosquitto_message_all *)(void *)0;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  pthread_mutex_lock(&mosq->in_message_mutex);
  _mosquitto_messages_reconnect_reset__1__message = mosq->in_messages;
  mosq->in_queue_len = 0;
  for( ; !(_mosquitto_messages_reconnect_reset__1__message == ((struct mosquitto_message_all *)NULL)); _mosquitto_messages_reconnect_reset__1__message = _mosquitto_messages_reconnect_reset__1__message->next)
  {
    mosq->in_queue_len = mosq->in_queue_len + 1;
    _mosquitto_messages_reconnect_reset__1__message->timestamp = (signed long int)0;
    if(!(_mosquitto_messages_reconnect_reset__1__message->msg.qos == 2))
    {
      if(!(prev == ((struct mosquitto_message_all *)NULL)))
      {
        prev->next = _mosquitto_messages_reconnect_reset__1__message->next;
        _mosquitto_message_cleanup(&_mosquitto_messages_reconnect_reset__1__message);
        _mosquitto_messages_reconnect_reset__1__message = prev;
      }

      else
      {
        mosq->in_messages = _mosquitto_messages_reconnect_reset__1__message->next;
        _mosquitto_message_cleanup(&_mosquitto_messages_reconnect_reset__1__message);
        _mosquitto_messages_reconnect_reset__1__message = mosq->in_messages;
      }
    }

    prev = _mosquitto_messages_reconnect_reset__1__message;
  }
  mosq->in_messages_last = prev;
  pthread_mutex_unlock(&mosq->in_message_mutex);
  pthread_mutex_lock(&mosq->out_message_mutex);
  mosq->inflight_messages = 0;
  _mosquitto_messages_reconnect_reset__1__message = mosq->out_messages;
  mosq->out_queue_len = 0;
  _Bool tmp_if_expr_1;
  for( ; !(_mosquitto_messages_reconnect_reset__1__message == ((struct mosquitto_message_all *)NULL)); _mosquitto_messages_reconnect_reset__1__message = _mosquitto_messages_reconnect_reset__1__message->next)
  {
    mosq->out_queue_len = mosq->out_queue_len + 1;
    _mosquitto_messages_reconnect_reset__1__message->timestamp = (signed long int)0;
    if(mosq->max_inflight_messages == 0)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = mosq->inflight_messages < mosq->max_inflight_messages ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(_mosquitto_messages_reconnect_reset__1__message->msg.qos >= 1)
        mosq->inflight_messages = mosq->inflight_messages + 1;

      if(_mosquitto_messages_reconnect_reset__1__message->msg.qos == 1)
        _mosquitto_messages_reconnect_reset__1__message->state = (enum mosquitto_msg_state)mosq_ms_wait_for_puback;

    }

    else
      _mosquitto_messages_reconnect_reset__1__message->state = (enum mosquitto_msg_state)mosq_ms_invalid;
    prev = _mosquitto_messages_reconnect_reset__1__message;
  }
  mosq->out_messages_last = prev;
  pthread_mutex_unlock(&mosq->out_message_mutex);
}

// _mosquitto_mid_generate
// file ./util_mosq.h line 34
unsigned short int _mosquitto_mid_generate(struct mosquitto *mosq)
{
  unsigned short int mid;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  pthread_mutex_lock(&mosq->mid_mutex);
  mosq->last_mid = mosq->last_mid + 1;
  if((signed int)mosq->last_mid == 0)
    mosq->last_mid = mosq->last_mid + 1;

  mid = mosq->last_mid;
  pthread_mutex_unlock(&mosq->mid_mutex);
  return mid;
}

// _mosquitto_net_cleanup
// file ./net_mosq.h line 53
void _mosquitto_net_cleanup(void)
{
  ERR_remove_state((unsigned long int)0);
  ENGINE_cleanup();
  CONF_modules_unload(1);
  ERR_free_strings();
  EVP_cleanup();
  CRYPTO_cleanup_all_ex_data();
  ares_library_cleanup();
}

// _mosquitto_net_init
// file ./net_mosq.h line 52
void _mosquitto_net_init(void)
{
  ares_library_init(1 << 0);
  SSL_load_error_strings();
  SSL_library_init();
  OPENSSL_add_all_algorithms_noconf();
  if(tls_ex_index_mosq == -1)
    tls_ex_index_mosq=SSL_get_ex_new_index((signed long int)0, (void *)"client context", (signed int (*)(void *, void *, struct crypto_ex_data_st *, signed int, signed long int, void *))(void *)0, (signed int (*)(struct crypto_ex_data_st *, struct crypto_ex_data_st *, void *, signed int, signed long int, void *))(void *)0, (void (*)(void *, void *, struct crypto_ex_data_st *, signed int, signed long int, void *))(void *)0);

}

// _mosquitto_net_read
// file net_mosq.c line 654
signed long int _mosquitto_net_read(struct mosquitto *mosq, void *buf, unsigned long int count)
{
  signed int ret;
  signed int err;
  char ebuf[256l];
  unsigned long int e;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  if(!(mosq->ssl == ((struct ssl_st *)NULL)))
  {
    ret=SSL_read(mosq->ssl, buf, (signed int)count);
    if(!(ret >= 1))
    {
      err=SSL_get_error(mosq->ssl, ret);
      if(err == 2)
      {
        ret = -1;
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 11;
      }

      else
        if(err == 3)
        {
          ret = -1;
          mosq->want_write = (_Bool)1;
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          *return_value___errno_location_3 = 11;
        }

        else
        {
          e=ERR_get_error();
          while(!(e == 0ul))
          {
            char *return_value_ERR_error_string_4;
            return_value_ERR_error_string_4=ERR_error_string(e, ebuf);
            _mosquitto_log_printf(mosq, 0x08, "OpenSSL Error: %s", return_value_ERR_error_string_4);
            e=ERR_get_error();
          }
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          *return_value___errno_location_5 = 71;
        }
    }

    return (signed long int)ret;
  }

  else
  {
    signed long int return_value_read_6;
    return_value_read_6=read(mosq->sock, buf, count);
    return return_value_read_6;
  }
}

// _mosquitto_net_write
// file net_mosq.c line 702
signed long int _mosquitto_net_write(struct mosquitto *mosq, void *buf, unsigned long int count)
{
  signed int ret;
  signed int err;
  char ebuf[256l];
  unsigned long int e;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  if(!(mosq->ssl == ((struct ssl_st *)NULL)))
  {
    mosq->want_write = (_Bool)0;
    ret=SSL_write(mosq->ssl, buf, (signed int)count);
    if(!(ret >= 0))
    {
      err=SSL_get_error(mosq->ssl, ret);
      if(err == 2)
      {
        ret = -1;
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 11;
      }

      else
        if(err == 3)
        {
          ret = -1;
          mosq->want_write = (_Bool)1;
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          *return_value___errno_location_3 = 11;
        }

        else
        {
          e=ERR_get_error();
          while(!(e == 0ul))
          {
            char *return_value_ERR_error_string_4;
            return_value_ERR_error_string_4=ERR_error_string(e, ebuf);
            _mosquitto_log_printf(mosq, 0x08, "OpenSSL Error: %s", return_value_ERR_error_string_4);
            e=ERR_get_error();
          }
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          *return_value___errno_location_5 = 71;
        }
    }

    return (signed long int)ret;
  }

  else
  {
    signed long int return_value_write_6;
    return_value_write_6=write(mosq->sock, buf, count);
    return return_value_write_6;
  }
}

// _mosquitto_packet_alloc
// file ./util_mosq.h line 28
signed int _mosquitto_packet_alloc(struct _mosquitto_packet *packet)
{
  unsigned char remaining_bytes[5l];
  unsigned char byte;
  unsigned int remaining_length;
  signed int i;
  /* assertion packet */
  assert(packet != ((struct _mosquitto_packet *)NULL));
  remaining_length = packet->remaining_length;
  packet->payload = (unsigned char *)(void *)0;
  packet->remaining_count = (signed char)0;
  _Bool tmp_if_expr_1;
  do
  {
    byte = (unsigned char)(remaining_length % (unsigned int)128);
    remaining_length = remaining_length / (unsigned int)128;
    if(remaining_length >= 1u)
      byte = (unsigned char)((signed int)byte | 0x80);

    remaining_bytes[(signed long int)packet->remaining_count] = byte;
    packet->remaining_count = packet->remaining_count + 1;
    if(remaining_length >= 1u)
      tmp_if_expr_1 = (signed int)packet->remaining_count < 5 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
  }
  while(tmp_if_expr_1);
  if((signed int)packet->remaining_count == 5)
    return 9;

  else
  {
    packet->packet_length = packet->remaining_length + (unsigned int)1 + (unsigned int)packet->remaining_count;
    void *return_value__mosquitto_malloc_2;
    return_value__mosquitto_malloc_2=_mosquitto_malloc(sizeof(unsigned char) /*1ul*/  * (unsigned long int)packet->packet_length);
    packet->payload = (unsigned char *)return_value__mosquitto_malloc_2;
    if(packet->payload == ((unsigned char *)NULL))
      return 1;

    else
    {
      packet->payload[(signed long int)0] = packet->command;
      i = 0;
      for( ; !(i >= (signed int)packet->remaining_count); i = i + 1)
        packet->payload[(signed long int)(i + 1)] = remaining_bytes[(signed long int)i];
      packet->pos = (unsigned int)(1 + (signed int)packet->remaining_count);
      return 0;
    }
  }
}

// _mosquitto_packet_cleanup
// file ./net_mosq.h line 55
void _mosquitto_packet_cleanup(struct _mosquitto_packet *packet)
{
  if(!(packet == ((struct _mosquitto_packet *)NULL)))
  {
    packet->command = (unsigned char)0;
    packet->remaining_count = (signed char)0;
    packet->remaining_mult = (unsigned int)1;
    packet->remaining_length = (unsigned int)0;
    if(!(packet->payload == ((unsigned char *)NULL)))
      _mosquitto_free((void *)packet->payload);

    packet->payload = (unsigned char *)(void *)0;
    packet->to_process = (unsigned int)0;
    packet->pos = (unsigned int)0;
  }

}

// _mosquitto_packet_handle
// file ./read_handle.h line 22
signed int _mosquitto_packet_handle(struct mosquitto *mosq)
{
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  signed int return_value__mosquitto_handle_pingreq_1;
  signed int return_value__mosquitto_handle_pingresp_2;
  signed int return_value__mosquitto_handle_pubackcomp_3;
  signed int return_value__mosquitto_handle_pubackcomp_4;
  signed int return_value__mosquitto_handle_publish_5;
  signed int return_value__mosquitto_handle_pubrec_6;
  signed int return_value__mosquitto_handle_pubrel_7;
  signed int return_value__mosquitto_handle_connack_8;
  signed int return_value__mosquitto_handle_suback_9;
  signed int return_value__mosquitto_handle_unsuback_10;
  switch((signed int)mosq->in_packet.command & 0xF0)
  {
    case 0xC0:
    {
      return_value__mosquitto_handle_pingreq_1=_mosquitto_handle_pingreq(mosq);
      return return_value__mosquitto_handle_pingreq_1;
    }
    case 0xD0:
    {
      return_value__mosquitto_handle_pingresp_2=_mosquitto_handle_pingresp(mosq);
      return return_value__mosquitto_handle_pingresp_2;
    }
    case 0x40:
    {
      return_value__mosquitto_handle_pubackcomp_3=_mosquitto_handle_pubackcomp(mosq, "PUBACK");
      return return_value__mosquitto_handle_pubackcomp_3;
    }
    case 0x70:
    {
      return_value__mosquitto_handle_pubackcomp_4=_mosquitto_handle_pubackcomp(mosq, "PUBCOMP");
      return return_value__mosquitto_handle_pubackcomp_4;
    }
    case 0x30:
    {
      return_value__mosquitto_handle_publish_5=_mosquitto_handle_publish(mosq);
      return return_value__mosquitto_handle_publish_5;
    }
    case 0x50:
    {
      return_value__mosquitto_handle_pubrec_6=_mosquitto_handle_pubrec(mosq);
      return return_value__mosquitto_handle_pubrec_6;
    }
    case 0x60:
    {
      return_value__mosquitto_handle_pubrel_7=_mosquitto_handle_pubrel((struct mosquitto_db *)(void *)0, mosq);
      return return_value__mosquitto_handle_pubrel_7;
    }
    case 0x20:
    {
      return_value__mosquitto_handle_connack_8=_mosquitto_handle_connack(mosq);
      return return_value__mosquitto_handle_connack_8;
    }
    case 0x90:
    {
      return_value__mosquitto_handle_suback_9=_mosquitto_handle_suback(mosq);
      return return_value__mosquitto_handle_suback_9;
    }
    case 0xB0:
    {
      return_value__mosquitto_handle_unsuback_10=_mosquitto_handle_unsuback(mosq);
      return return_value__mosquitto_handle_unsuback_10;
    }
    default:
    {
      _mosquitto_log_printf(mosq, 0x08, "Error: Unrecognised command %d\n", (signed int)mosq->in_packet.command & 0xF0);
      return 2;
    }
  }
}

// _mosquitto_packet_queue
// file net_mosq.c line 146
signed int _mosquitto_packet_queue(struct mosquitto *mosq, struct _mosquitto_packet *packet)
{
  char sockpair_data = (char)0;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  /* assertion packet */
  assert(packet != ((struct _mosquitto_packet *)NULL));
  packet->pos = (unsigned int)0;
  packet->to_process = packet->packet_length;
  packet->next = (struct _mosquitto_packet *)(void *)0;
  pthread_mutex_lock(&mosq->out_packet_mutex);
  if(!(mosq->out_packet == ((struct _mosquitto_packet *)NULL)))
    mosq->out_packet_last->next = packet;

  else
    mosq->out_packet = packet;
  mosq->out_packet_last = packet;
  pthread_mutex_unlock(&mosq->out_packet_mutex);
  if(!(mosq->sockpairW == -1))
  {
    signed long int return_value_write_1;
    return_value_write_1=write(mosq->sockpairW, (const void *)&sockpair_data, (unsigned long int)1);
  }

  _Bool tmp_if_expr_3;
  if((signed int)mosq->in_callback == 0)
    tmp_if_expr_3 = (signed int)mosq->threaded == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
  {
    signed int return_value__mosquitto_packet_write_2;
    return_value__mosquitto_packet_write_2=_mosquitto_packet_write(mosq);
    return return_value__mosquitto_packet_write_2;
  }

  else
    return 0;
}

// _mosquitto_packet_read
// file ./net_mosq.h line 84
signed int _mosquitto_packet_read(struct mosquitto *mosq)
{
  unsigned char byte;
  signed long int read_length;
  signed int rc = 0;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_3;
  _Bool tmp_if_expr_8;
  signed int *return_value___errno_location_7;
  _Bool tmp_if_expr_13;
  signed int *return_value___errno_location_12;
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
    if(mosq->sock == -1)
      return 4;

    else
      if((signed int)mosq->state == mosq_cs_connect_pending)
        return 0;

      else
      {
        if(mosq->in_packet.command == 0)
        {
          read_length=_mosquitto_net_read(mosq, (void *)&byte, (unsigned long int)1);
          if(read_length == 1l)
            mosq->in_packet.command = byte;

          else
          {
            if(read_length == 0l)
              return 7;

            signed int *return_value___errno_location_2;
            return_value___errno_location_2=__errno_location();
            if(*return_value___errno_location_2 == 11)
              tmp_if_expr_4 = (_Bool)1;

            else
            {
              return_value___errno_location_3=__errno_location();
              tmp_if_expr_4 = *return_value___errno_location_3 == 11 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_4)
              return 0;

            else
            {
              signed int *return_value___errno_location_1;
              return_value___errno_location_1=__errno_location();
              if(*return_value___errno_location_1 == 104)
                return 7;

              return 14;
            }
          }
        }

        if(!((signed int)mosq->in_packet.remaining_count >= 1))
        {
          do
          {
            read_length=_mosquitto_net_read(mosq, (void *)&byte, (unsigned long int)1);
            if(read_length == 1l)
            {
              mosq->in_packet.remaining_count = mosq->in_packet.remaining_count - 1;
              if(!((signed int)mosq->in_packet.remaining_count >= -4))
                return 2;

              mosq->in_packet.remaining_length = mosq->in_packet.remaining_length + (unsigned int)((signed int)byte & 127) * mosq->in_packet.remaining_mult;
              mosq->in_packet.remaining_mult = mosq->in_packet.remaining_mult * (unsigned int)128;
            }

            else
            {
              if(read_length == 0l)
                return 7;

              signed int *return_value___errno_location_6;
              return_value___errno_location_6=__errno_location();
              if(*return_value___errno_location_6 == 11)
                tmp_if_expr_8 = (_Bool)1;

              else
              {
                return_value___errno_location_7=__errno_location();
                tmp_if_expr_8 = *return_value___errno_location_7 == 11 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_8)
                return 0;

              else
              {
                signed int *return_value___errno_location_5;
                return_value___errno_location_5=__errno_location();
                if(*return_value___errno_location_5 == 104)
                  return 7;

                return 14;
              }
            }
          }
          while(!((128 & (signed int)byte) == 0));
          mosq->in_packet.remaining_count = mosq->in_packet.remaining_count * (signed char)-1;
          if(mosq->in_packet.remaining_length >= 1u)
          {
            void *return_value__mosquitto_malloc_9;
            return_value__mosquitto_malloc_9=_mosquitto_malloc((unsigned long int)mosq->in_packet.remaining_length * sizeof(unsigned char) /*1ul*/ );
            mosq->in_packet.payload = (unsigned char *)return_value__mosquitto_malloc_9;
            if(mosq->in_packet.payload == ((unsigned char *)NULL))
              return 1;

            mosq->in_packet.to_process = mosq->in_packet.remaining_length;
          }

        }

        while(mosq->in_packet.to_process >= 1u)
        {
          read_length=_mosquitto_net_read(mosq, (void *)&mosq->in_packet.payload[(signed long int)mosq->in_packet.pos], (unsigned long int)mosq->in_packet.to_process);
          if(read_length >= 1l)
          {
            mosq->in_packet.to_process = mosq->in_packet.to_process - (unsigned int)read_length;
            mosq->in_packet.pos = mosq->in_packet.pos + (unsigned int)read_length;
          }

          else
          {
            signed int *return_value___errno_location_11;
            return_value___errno_location_11=__errno_location();
            if(*return_value___errno_location_11 == 11)
              tmp_if_expr_13 = (_Bool)1;

            else
            {
              return_value___errno_location_12=__errno_location();
              tmp_if_expr_13 = *return_value___errno_location_12 == 11 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_13)
            {
              if(mosq->in_packet.to_process >= 1001u)
              {
                pthread_mutex_lock(&mosq->msgtime_mutex);
                mosq->last_msg_in=mosquitto_time();
                pthread_mutex_unlock(&mosq->msgtime_mutex);
              }

              return 0;
            }

            else
            {
              signed int *return_value___errno_location_10;
              return_value___errno_location_10=__errno_location();
              if(*return_value___errno_location_10 == 104)
                return 7;

              return 14;
            }
          }
        }
        mosq->in_packet.pos = (unsigned int)0;
        rc=_mosquitto_packet_handle(mosq);
        _mosquitto_packet_cleanup(&mosq->in_packet);
        pthread_mutex_lock(&mosq->msgtime_mutex);
        mosq->last_msg_in=mosquitto_time();
        pthread_mutex_unlock(&mosq->msgtime_mutex);
        return rc;
      }
}

// _mosquitto_packet_write
// file ./net_mosq.h line 80
signed int _mosquitto_packet_write(struct mosquitto *mosq)
{
  signed long int write_length;
  struct _mosquitto_packet *packet;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_3;
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
    if(mosq->sock == -1)
      return 4;

    else
    {
      pthread_mutex_lock(&mosq->current_out_packet_mutex);
      pthread_mutex_lock(&mosq->out_packet_mutex);
      if(!(mosq->out_packet == ((struct _mosquitto_packet *)NULL)))
      {
        if(mosq->current_out_packet == ((struct _mosquitto_packet *)NULL))
        {
          mosq->current_out_packet = mosq->out_packet;
          mosq->out_packet = mosq->out_packet->next;
          if(mosq->out_packet == ((struct _mosquitto_packet *)NULL))
            mosq->out_packet_last = (struct _mosquitto_packet *)(void *)0;

        }

      }

      pthread_mutex_unlock(&mosq->out_packet_mutex);
      if((signed int)mosq->state == mosq_cs_connect_pending)
      {
        pthread_mutex_unlock(&mosq->current_out_packet_mutex);
        return 0;
      }

      else
      {
        while(!(mosq->current_out_packet == ((struct _mosquitto_packet *)NULL)))
        {
          packet = mosq->current_out_packet;
          while(packet->to_process >= 1u)
          {
            write_length=_mosquitto_net_write(mosq, (void *)&packet->payload[(signed long int)packet->pos], (unsigned long int)packet->to_process);
            if(write_length >= 1l)
            {
              packet->to_process = packet->to_process - (unsigned int)write_length;
              packet->pos = packet->pos + (unsigned int)write_length;
            }

            else
            {
              signed int *return_value___errno_location_2;
              return_value___errno_location_2=__errno_location();
              if(*return_value___errno_location_2 == 11)
                tmp_if_expr_4 = (_Bool)1;

              else
              {
                return_value___errno_location_3=__errno_location();
                tmp_if_expr_4 = *return_value___errno_location_3 == 11 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_4)
              {
                pthread_mutex_unlock(&mosq->current_out_packet_mutex);
                return 0;
              }

              else
              {
                pthread_mutex_unlock(&mosq->current_out_packet_mutex);
                signed int *return_value___errno_location_1;
                return_value___errno_location_1=__errno_location();
                if(*return_value___errno_location_1 == 104)
                  return 7;

                return 14;
              }
            }
          }
          if((0xF6 & (signed int)packet->command) == 0x30)
          {
            pthread_mutex_lock(&mosq->callback_mutex);
            if(!(mosq->on_publish == ((void (*)(struct mosquitto *, void *, signed int))NULL)))
            {
              mosq->in_callback = (_Bool)1;
              mosq->on_publish(mosq, mosq->userdata, (signed int)packet->mid);
              mosq->in_callback = (_Bool)0;
            }

            pthread_mutex_unlock(&mosq->callback_mutex);
          }

          else
            if((0xF0 & (signed int)packet->command) == 0xE0)
            {
              _mosquitto_socket_close(mosq);
              pthread_mutex_lock(&mosq->out_packet_mutex);
              mosq->current_out_packet = mosq->out_packet;
              if(!(mosq->out_packet == ((struct _mosquitto_packet *)NULL)))
              {
                mosq->out_packet = mosq->out_packet->next;
                if(mosq->out_packet == ((struct _mosquitto_packet *)NULL))
                  mosq->out_packet_last = (struct _mosquitto_packet *)(void *)0;

              }

              pthread_mutex_unlock(&mosq->out_packet_mutex);
              _mosquitto_packet_cleanup(packet);
              _mosquitto_free((void *)packet);
              pthread_mutex_lock(&mosq->msgtime_mutex);
              mosq->last_msg_out=mosquitto_time();
              pthread_mutex_unlock(&mosq->msgtime_mutex);
              pthread_mutex_lock(&mosq->callback_mutex);
              if(!(mosq->on_disconnect == ((void (*)(struct mosquitto *, void *, signed int))NULL)))
              {
                mosq->in_callback = (_Bool)1;
                mosq->on_disconnect(mosq, mosq->userdata, 0);
                mosq->in_callback = (_Bool)0;
              }

              pthread_mutex_unlock(&mosq->callback_mutex);
              pthread_mutex_unlock(&mosq->current_out_packet_mutex);
              return 0;
            }

          pthread_mutex_lock(&mosq->out_packet_mutex);
          mosq->current_out_packet = mosq->out_packet;
          if(!(mosq->out_packet == ((struct _mosquitto_packet *)NULL)))
          {
            mosq->out_packet = mosq->out_packet->next;
            if(mosq->out_packet == ((struct _mosquitto_packet *)NULL))
              mosq->out_packet_last = (struct _mosquitto_packet *)(void *)0;

          }

          pthread_mutex_unlock(&mosq->out_packet_mutex);
          _mosquitto_packet_cleanup(packet);
          _mosquitto_free((void *)packet);
          pthread_mutex_lock(&mosq->msgtime_mutex);
          mosq->last_msg_out=mosquitto_time();
          pthread_mutex_unlock(&mosq->msgtime_mutex);
        }
        pthread_mutex_unlock(&mosq->current_out_packet_mutex);
        return 0;
      }
    }
}

// _mosquitto_read_byte
// file net_mosq.c line 561
signed int _mosquitto_read_byte(struct _mosquitto_packet *packet, unsigned char *byte)
{
  /* assertion packet */
  assert(packet != ((struct _mosquitto_packet *)NULL));
  if(!(packet->remaining_length >= 1u + packet->pos))
    return 2;

  else
  {
    *byte = packet->payload[(signed long int)packet->pos];
    packet->pos = packet->pos + 1u;
    return 0;
  }
}

// _mosquitto_read_bytes
// file net_mosq.c line 581
signed int _mosquitto_read_bytes(struct _mosquitto_packet *packet, void *bytes, unsigned int count)
{
  /* assertion packet */
  assert(packet != ((struct _mosquitto_packet *)NULL));
  if(!(packet->remaining_length >= packet->pos + count))
    return 2;

  else
  {
    memcpy(bytes, (const void *)&packet->payload[(signed long int)packet->pos], (unsigned long int)count);
    packet->pos = packet->pos + count;
    return 0;
  }
}

// _mosquitto_read_string
// file net_mosq.c line 601
signed int _mosquitto_read_string(struct _mosquitto_packet *packet, char **str)
{
  unsigned short int len;
  signed int rc;
  /* assertion packet */
  assert(packet != ((struct _mosquitto_packet *)NULL));
  rc=_mosquitto_read_uint16(packet, &len);
  if(!(rc == 0))
    return rc;

  else
    if(!(packet->remaining_length >= packet->pos + (unsigned int)len))
      return 2;

    else
    {
      void *return_value__mosquitto_malloc_1;
      return_value__mosquitto_malloc_1=_mosquitto_malloc((unsigned long int)((signed int)len + 1));
      *str = (char *)return_value__mosquitto_malloc_1;
      if(!(*str == ((char *)NULL)))
      {
        memcpy((void *)*str, (const void *)&packet->payload[(signed long int)packet->pos], (unsigned long int)len);
        (*str)[(signed long int)len] = (char)0;
        packet->pos = packet->pos + (unsigned int)len;
      }

      else
        return 1;
      return 0;
    }
}

// _mosquitto_read_uint16
// file net_mosq.c line 631
signed int _mosquitto_read_uint16(struct _mosquitto_packet *packet, unsigned short int *word)
{
  unsigned char msb;
  unsigned char lsb;
  /* assertion packet */
  assert(packet != ((struct _mosquitto_packet *)NULL));
  if(!(packet->remaining_length >= 2u + packet->pos))
    return 2;

  else
  {
    msb = packet->payload[(signed long int)packet->pos];
    packet->pos = packet->pos + 1u;
    lsb = packet->payload[(signed long int)packet->pos];
    packet->pos = packet->pos + 1u;
    *word = (unsigned short int)(((signed int)msb << 8) + (signed int)lsb);
    return 0;
  }
}

// _mosquitto_realloc
// file memory_mosq.c line 91
void * _mosquitto_realloc(void *ptr, unsigned long int size)
{
  void *mem;
  mem=realloc(ptr, size);
  return mem;
}

// _mosquitto_reconnect
// file mosquitto.c line 472
static signed int _mosquitto_reconnect(struct mosquitto *mosq, _Bool blocking)
{
  signed int rc;
  struct _mosquitto_packet *packet;
  _Bool tmp_if_expr_1;
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    if(mosq->host == ((char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = mosq->port <= 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return 3;

    else
    {
      pthread_mutex_lock(&mosq->state_mutex);
      if(!(mosq->socks5_host == ((char *)NULL)))
        mosq->state = (enum mosquitto_client_state)mosq_cs_socks5_new;

      else
        mosq->state = (enum mosquitto_client_state)mosq_cs_new;
      pthread_mutex_unlock(&mosq->state_mutex);
      pthread_mutex_lock(&mosq->msgtime_mutex);
      mosq->last_msg_in=mosquitto_time();
      mosq->last_msg_out=mosquitto_time();
      pthread_mutex_unlock(&mosq->msgtime_mutex);
      mosq->ping_t = (signed long int)0;
      _mosquitto_packet_cleanup(&mosq->in_packet);
      pthread_mutex_lock(&mosq->current_out_packet_mutex);
      pthread_mutex_lock(&mosq->out_packet_mutex);
      if(!(mosq->out_packet == ((struct _mosquitto_packet *)NULL)))
      {
        if(mosq->current_out_packet == ((struct _mosquitto_packet *)NULL))
        {
          mosq->current_out_packet = mosq->out_packet;
          mosq->out_packet = mosq->out_packet->next;
        }

      }

      while(!(mosq->current_out_packet == ((struct _mosquitto_packet *)NULL)))
      {
        packet = mosq->current_out_packet;
        mosq->current_out_packet = mosq->out_packet;
        if(!(mosq->out_packet == ((struct _mosquitto_packet *)NULL)))
          mosq->out_packet = mosq->out_packet->next;

        _mosquitto_packet_cleanup(packet);
        _mosquitto_free((void *)packet);
      }
      pthread_mutex_unlock(&mosq->out_packet_mutex);
      pthread_mutex_unlock(&mosq->current_out_packet_mutex);
      _mosquitto_messages_reconnect_reset(mosq);
      if(!(mosq->socks5_host == ((char *)NULL)))
        rc=_mosquitto_socket_connect(mosq, mosq->socks5_host, (unsigned short int)mosq->socks5_port, mosq->bind_address, blocking);

      else
        rc=_mosquitto_socket_connect(mosq, mosq->host, (unsigned short int)mosq->port, mosq->bind_address, blocking);
      if(rc >= 1)
        return rc;

      else
        if(!(mosq->socks5_host == ((char *)NULL)))
        {
          signed int return_value_mosquitto__socks5_send_2;
          return_value_mosquitto__socks5_send_2=mosquitto__socks5_send(mosq);
          return return_value_mosquitto__socks5_send_2;
        }

        else
        {
          signed int return_value__mosquitto_send_connect_3;
          return_value__mosquitto_send_connect_3=_mosquitto_send_connect(mosq, mosq->keepalive, mosq->clean_session);
          return return_value__mosquitto_send_connect_3;
        }
    }
  }
}

// _mosquitto_send_command_with_mid
// file send_mosq.c line 200
signed int _mosquitto_send_command_with_mid(struct mosquitto *mosq, unsigned char command, unsigned short int mid, _Bool dup)
{
  struct _mosquitto_packet *packet = (struct _mosquitto_packet *)(void *)0;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  void *return_value__mosquitto_calloc_1;
  return_value__mosquitto_calloc_1=_mosquitto_calloc((unsigned long int)1, sizeof(struct _mosquitto_packet) /*40ul*/ );
  packet = (struct _mosquitto_packet *)return_value__mosquitto_calloc_1;
  if(packet == ((struct _mosquitto_packet *)NULL))
    return 1;

  else
  {
    packet->command = command;
    if(!(dup == (_Bool)0))
      packet->command = packet->command | (unsigned char)8;

    packet->remaining_length = (unsigned int)2;
    rc=_mosquitto_packet_alloc(packet);
    if(!(rc == 0))
    {
      _mosquitto_free((void *)packet);
      return rc;
    }

    else
    {
      packet->payload[(signed long int)(packet->pos + (unsigned int)0)] = (unsigned char)(((signed int)mid & 0xFF00) >> 8);
      packet->payload[(signed long int)(packet->pos + (unsigned int)1)] = (unsigned char)((signed int)mid & 0x00FF);
      signed int return_value__mosquitto_packet_queue_2;
      return_value__mosquitto_packet_queue_2=_mosquitto_packet_queue(mosq, packet);
      return return_value__mosquitto_packet_queue_2;
    }
  }
}

// _mosquitto_send_connect
// file ./send_mosq.h line 25
signed int _mosquitto_send_connect(struct mosquitto *mosq, unsigned short int keepalive, _Bool clean_session)
{
  struct _mosquitto_packet *packet = (struct _mosquitto_packet *)(void *)0;
  signed int payloadlen;
  unsigned char will = (unsigned char)0;
  unsigned char byte;
  signed int rc;
  unsigned char version;
  char *clientid;
  char *_mosquitto_send_connect__1__username;
  char *_mosquitto_send_connect__1__password;
  signed int headerlen;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  /* assertion mosq->id */
  assert(mosq->id != ((char *)NULL));
  clientid = mosq->id;
  _mosquitto_send_connect__1__username = mosq->username;
  _mosquitto_send_connect__1__password = mosq->password;
  if((signed int)mosq->protocol == mosq_p_mqtt31)
  {
    version = (unsigned char)3;
    headerlen = 12;
  }

  else
    if((signed int)mosq->protocol == mosq_p_mqtt311)
    {
      version = (unsigned char)4;
      headerlen = 10;
    }

    else
      return 3;
  void *return_value__mosquitto_calloc_1;
  return_value__mosquitto_calloc_1=_mosquitto_calloc((unsigned long int)1, sizeof(struct _mosquitto_packet) /*40ul*/ );
  packet = (struct _mosquitto_packet *)return_value__mosquitto_calloc_1;
  if(packet == ((struct _mosquitto_packet *)NULL))
    return 1;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(clientid);
    payloadlen = (signed int)((unsigned long int)2 + return_value_strlen_2);
    if(!(mosq->will == ((struct mosquitto_message *)NULL)))
    {
      will = (unsigned char)1;
      /* assertion mosq->will->topic */
      assert(mosq->will->topic != ((char *)NULL));
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(mosq->will->topic);
      payloadlen = payloadlen + (signed int)((unsigned long int)2 + return_value_strlen_3 + (unsigned long int)2 + (unsigned long int)mosq->will->payloadlen);
    }

    if(!(_mosquitto_send_connect__1__username == ((char *)NULL)))
    {
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(_mosquitto_send_connect__1__username);
      payloadlen = payloadlen + (signed int)((unsigned long int)2 + return_value_strlen_4);
      if(!(_mosquitto_send_connect__1__password == ((char *)NULL)))
      {
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(_mosquitto_send_connect__1__password);
        payloadlen = payloadlen + (signed int)((unsigned long int)2 + return_value_strlen_5);
      }

    }

    packet->command = (unsigned char)0x10;
    packet->remaining_length = (unsigned int)(headerlen + payloadlen);
    rc=_mosquitto_packet_alloc(packet);
    if(!(rc == 0))
    {
      _mosquitto_free((void *)packet);
      return rc;
    }

    else
    {
      if((signed int)version == 3)
      {
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen("MQIsdp");
        _mosquitto_write_string(packet, "MQIsdp", (unsigned short int)return_value_strlen_6);
      }

      else
        if((signed int)version == 4)
        {
          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen("MQTT");
          _mosquitto_write_string(packet, "MQTT", (unsigned short int)return_value_strlen_7);
        }

      _mosquitto_write_byte(packet, version);
      byte = (unsigned char)(((signed int)clean_session & 0x1) << 1);
      if(!(will == 0))
        byte = (unsigned char)((signed int)byte | ((signed int)mosq->will->retain & 0x1) << 5 | (mosq->will->qos & 0x3) << 3 | ((signed int)will & 0x1) << 2);

      if(!(_mosquitto_send_connect__1__username == ((char *)NULL)))
      {
        byte = (unsigned char)((signed int)byte | 0x1 << 7);
        if(!(mosq->password == ((char *)NULL)))
          byte = (unsigned char)((signed int)byte | 0x1 << 6);

      }

      _mosquitto_write_byte(packet, byte);
      _mosquitto_write_uint16(packet, keepalive);
      unsigned long int return_value_strlen_8;
      return_value_strlen_8=strlen(clientid);
      _mosquitto_write_string(packet, clientid, (unsigned short int)return_value_strlen_8);
      if(!(will == 0))
      {
        unsigned long int return_value_strlen_9;
        return_value_strlen_9=strlen(mosq->will->topic);
        _mosquitto_write_string(packet, mosq->will->topic, (unsigned short int)return_value_strlen_9);
        _mosquitto_write_string(packet, (const char *)mosq->will->payload, (unsigned short int)mosq->will->payloadlen);
      }

      if(!(_mosquitto_send_connect__1__username == ((char *)NULL)))
      {
        unsigned long int return_value_strlen_10;
        return_value_strlen_10=strlen(_mosquitto_send_connect__1__username);
        _mosquitto_write_string(packet, _mosquitto_send_connect__1__username, (unsigned short int)return_value_strlen_10);
        if(!(_mosquitto_send_connect__1__password == ((char *)NULL)))
        {
          unsigned long int return_value_strlen_11;
          return_value_strlen_11=strlen(_mosquitto_send_connect__1__password);
          _mosquitto_write_string(packet, _mosquitto_send_connect__1__password, (unsigned short int)return_value_strlen_11);
        }

      }

      mosq->keepalive = keepalive;
      _mosquitto_log_printf(mosq, 0x10, "Client %s sending CONNECT", clientid);
      signed int return_value__mosquitto_packet_queue_12;
      return_value__mosquitto_packet_queue_12=_mosquitto_packet_queue(mosq, packet);
      return return_value__mosquitto_packet_queue_12;
    }
  }
}

// _mosquitto_send_disconnect
// file ./send_mosq.h line 26
signed int _mosquitto_send_disconnect(struct mosquitto *mosq)
{
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  _mosquitto_log_printf(mosq, 0x10, "Client %s sending DISCONNECT", mosq->id);
  signed int return_value__mosquitto_send_simple_command_1;
  return_value__mosquitto_send_simple_command_1=_mosquitto_send_simple_command(mosq, (unsigned char)0xE0);
  return return_value__mosquitto_send_simple_command_1;
}

// _mosquitto_send_pingreq
// file send_mosq.c line 38
signed int _mosquitto_send_pingreq(struct mosquitto *mosq)
{
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  _mosquitto_log_printf(mosq, 0x10, "Client %s sending PINGREQ", mosq->id);
  rc=_mosquitto_send_simple_command(mosq, (unsigned char)0xC0);
  if(rc == 0)
    mosq->ping_t=mosquitto_time();

  return rc;
}

// _mosquitto_send_pingresp
// file ./send_mosq.h line 28
signed int _mosquitto_send_pingresp(struct mosquitto *mosq)
{
  if(!(mosq == ((struct mosquitto *)NULL)))
    _mosquitto_log_printf(mosq, 0x10, "Client %s sending PINGRESP", mosq->id);

  signed int return_value__mosquitto_send_simple_command_1;
  return_value__mosquitto_send_simple_command_1=_mosquitto_send_simple_command(mosq, (unsigned char)0xD0);
  return return_value__mosquitto_send_simple_command_1;
}

// _mosquitto_send_puback
// file ./send_mosq.h line 29
signed int _mosquitto_send_puback(struct mosquitto *mosq, unsigned short int mid)
{
  if(!(mosq == ((struct mosquitto *)NULL)))
    _mosquitto_log_printf(mosq, 0x10, "Client %s sending PUBACK (Mid: %d)", mosq->id, mid);

  signed int return_value__mosquitto_send_command_with_mid_1;
  return_value__mosquitto_send_command_with_mid_1=_mosquitto_send_command_with_mid(mosq, (unsigned char)0x40, mid, (_Bool)0);
  return return_value__mosquitto_send_command_with_mid_1;
}

// _mosquitto_send_pubcomp
// file ./send_mosq.h line 30
signed int _mosquitto_send_pubcomp(struct mosquitto *mosq, unsigned short int mid)
{
  if(!(mosq == ((struct mosquitto *)NULL)))
    _mosquitto_log_printf(mosq, 0x10, "Client %s sending PUBCOMP (Mid: %d)", mosq->id, mid);

  signed int return_value__mosquitto_send_command_with_mid_1;
  return_value__mosquitto_send_command_with_mid_1=_mosquitto_send_command_with_mid(mosq, (unsigned char)0x70, mid, (_Bool)0);
  return return_value__mosquitto_send_command_with_mid_1;
}

// _mosquitto_send_publish
// file ./send_mosq.h line 31
signed int _mosquitto_send_publish(struct mosquitto *mosq, unsigned short int mid, const char *topic, unsigned int payloadlen, const void *payload, signed int qos, _Bool retain, _Bool dup)
{
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  /* assertion topic */
  assert(topic != ((const char *)NULL));
  if(mosq->sock == -1)
    return 4;

  else
  {
    _mosquitto_log_printf(mosq, 0x10, "Client %s sending PUBLISH (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))", mosq->id, dup, qos, retain, mid, topic, (signed long int)payloadlen);
    signed int return_value__mosquitto_send_real_publish_1;
    return_value__mosquitto_send_real_publish_1=_mosquitto_send_real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup);
    return return_value__mosquitto_send_real_publish_1;
  }
}

// _mosquitto_send_pubrec
// file ./send_mosq.h line 32
signed int _mosquitto_send_pubrec(struct mosquitto *mosq, unsigned short int mid)
{
  if(!(mosq == ((struct mosquitto *)NULL)))
    _mosquitto_log_printf(mosq, 0x10, "Client %s sending PUBREC (Mid: %d)", mosq->id, mid);

  signed int return_value__mosquitto_send_command_with_mid_1;
  return_value__mosquitto_send_command_with_mid_1=_mosquitto_send_command_with_mid(mosq, (unsigned char)0x50, mid, (_Bool)0);
  return return_value__mosquitto_send_command_with_mid_1;
}

// _mosquitto_send_pubrel
// file ./send_mosq.h line 33
signed int _mosquitto_send_pubrel(struct mosquitto *mosq, unsigned short int mid)
{
  if(!(mosq == ((struct mosquitto *)NULL)))
    _mosquitto_log_printf(mosq, 0x10, "Client %s sending PUBREL (Mid: %d)", mosq->id, mid);

  signed int return_value__mosquitto_send_command_with_mid_1;
  return_value__mosquitto_send_command_with_mid_1=_mosquitto_send_command_with_mid(mosq, (unsigned char)(0x60 | 2), mid, (_Bool)0);
  return return_value__mosquitto_send_command_with_mid_1;
}

// _mosquitto_send_real_publish
// file send_mosq.c line 248
signed int _mosquitto_send_real_publish(struct mosquitto *mosq, unsigned short int mid, const char *topic, unsigned int payloadlen, const void *payload, signed int qos, _Bool retain, _Bool dup)
{
  struct _mosquitto_packet *packet = (struct _mosquitto_packet *)(void *)0;
  signed int packetlen;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  /* assertion topic */
  assert(topic != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(topic);
  packetlen = (signed int)((unsigned long int)2 + return_value_strlen_1 + (unsigned long int)payloadlen);
  if(qos >= 1)
    packetlen = packetlen + 2;

  void *return_value__mosquitto_calloc_2;
  return_value__mosquitto_calloc_2=_mosquitto_calloc((unsigned long int)1, sizeof(struct _mosquitto_packet) /*40ul*/ );
  packet = (struct _mosquitto_packet *)return_value__mosquitto_calloc_2;
  if(packet == ((struct _mosquitto_packet *)NULL))
    return 1;

  else
  {
    packet->mid = mid;
    packet->command = (unsigned char)(0x30 | ((signed int)dup & 0x1) << 3 | qos << 1 | (signed int)retain);
    packet->remaining_length = (unsigned int)packetlen;
    rc=_mosquitto_packet_alloc(packet);
    if(!(rc == 0))
    {
      _mosquitto_free((void *)packet);
      return rc;
    }

    else
    {
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(topic);
      _mosquitto_write_string(packet, topic, (unsigned short int)return_value_strlen_3);
      if(qos >= 1)
        _mosquitto_write_uint16(packet, mid);

      if(!(payloadlen == 0u))
        _mosquitto_write_bytes(packet, payload, payloadlen);

      signed int return_value__mosquitto_packet_queue_4;
      return_value__mosquitto_packet_queue_4=_mosquitto_packet_queue(mosq, packet);
      return return_value__mosquitto_packet_queue_4;
    }
  }
}

// _mosquitto_send_simple_command
// file send_mosq.c line 227
signed int _mosquitto_send_simple_command(struct mosquitto *mosq, unsigned char command)
{
  struct _mosquitto_packet *packet = (struct _mosquitto_packet *)(void *)0;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  void *return_value__mosquitto_calloc_1;
  return_value__mosquitto_calloc_1=_mosquitto_calloc((unsigned long int)1, sizeof(struct _mosquitto_packet) /*40ul*/ );
  packet = (struct _mosquitto_packet *)return_value__mosquitto_calloc_1;
  if(packet == ((struct _mosquitto_packet *)NULL))
    return 1;

  else
  {
    packet->command = command;
    packet->remaining_length = (unsigned int)0;
    rc=_mosquitto_packet_alloc(packet);
    if(!(rc == 0))
    {
      _mosquitto_free((void *)packet);
      return rc;
    }

    else
    {
      signed int return_value__mosquitto_packet_queue_2;
      return_value__mosquitto_packet_queue_2=_mosquitto_packet_queue(mosq, packet);
      return return_value__mosquitto_packet_queue_2;
    }
  }
}

// _mosquitto_send_subscribe
// file ./send_mosq.h line 34
signed int _mosquitto_send_subscribe(struct mosquitto *mosq, signed int *mid, const char *topic, unsigned char topic_qos)
{
  struct _mosquitto_packet *packet = (struct _mosquitto_packet *)(void *)0;
  unsigned int packetlen;
  unsigned short int local_mid;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  /* assertion topic */
  assert(topic != ((const char *)NULL));
  void *return_value__mosquitto_calloc_1;
  return_value__mosquitto_calloc_1=_mosquitto_calloc((unsigned long int)1, sizeof(struct _mosquitto_packet) /*40ul*/ );
  packet = (struct _mosquitto_packet *)return_value__mosquitto_calloc_1;
  if(packet == ((struct _mosquitto_packet *)NULL))
    return 1;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(topic);
    packetlen = (unsigned int)((unsigned long int)(2 + 2) + return_value_strlen_2 + (unsigned long int)1);
    packet->command = (unsigned char)(0x80 | 1 << 1);
    packet->remaining_length = packetlen;
    rc=_mosquitto_packet_alloc(packet);
    if(!(rc == 0))
    {
      _mosquitto_free((void *)packet);
      return rc;
    }

    else
    {
      local_mid=_mosquitto_mid_generate(mosq);
      if(!(mid == ((signed int *)NULL)))
        *mid = (signed int)local_mid;

      _mosquitto_write_uint16(packet, local_mid);
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(topic);
      _mosquitto_write_string(packet, topic, (unsigned short int)return_value_strlen_3);
      _mosquitto_write_byte(packet, topic_qos);
      _mosquitto_log_printf(mosq, 0x10, "Client %s sending SUBSCRIBE (Mid: %d, Topic: %s, QoS: %d)", mosq->id, local_mid, topic, topic_qos);
      signed int return_value__mosquitto_packet_queue_4;
      return_value__mosquitto_packet_queue_4=_mosquitto_packet_queue(mosq, packet);
      return return_value__mosquitto_packet_queue_4;
    }
  }
}

// _mosquitto_send_unsubscribe
// file ./send_mosq.h line 35
signed int _mosquitto_send_unsubscribe(struct mosquitto *mosq, signed int *mid, const char *topic)
{
  struct _mosquitto_packet *packet = (struct _mosquitto_packet *)(void *)0;
  unsigned int packetlen;
  unsigned short int local_mid;
  signed int rc;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  /* assertion topic */
  assert(topic != ((const char *)NULL));
  void *return_value__mosquitto_calloc_1;
  return_value__mosquitto_calloc_1=_mosquitto_calloc((unsigned long int)1, sizeof(struct _mosquitto_packet) /*40ul*/ );
  packet = (struct _mosquitto_packet *)return_value__mosquitto_calloc_1;
  if(packet == ((struct _mosquitto_packet *)NULL))
    return 1;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(topic);
    packetlen = (unsigned int)((unsigned long int)(2 + 2) + return_value_strlen_2);
    packet->command = (unsigned char)(0xA0 | 1 << 1);
    packet->remaining_length = packetlen;
    rc=_mosquitto_packet_alloc(packet);
    if(!(rc == 0))
    {
      _mosquitto_free((void *)packet);
      return rc;
    }

    else
    {
      local_mid=_mosquitto_mid_generate(mosq);
      if(!(mid == ((signed int *)NULL)))
        *mid = (signed int)local_mid;

      _mosquitto_write_uint16(packet, local_mid);
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(topic);
      _mosquitto_write_string(packet, topic, (unsigned short int)return_value_strlen_3);
      _mosquitto_log_printf(mosq, 0x10, "Client %s sending UNSUBSCRIBE (Mid: %d, Topic: %s)", mosq->id, local_mid, topic);
      signed int return_value__mosquitto_packet_queue_4;
      return_value__mosquitto_packet_queue_4=_mosquitto_packet_queue(mosq, packet);
      return return_value__mosquitto_packet_queue_4;
    }
  }
}

// _mosquitto_server_certificate_verify
// file ./tls_mosq.h line 37
signed int _mosquitto_server_certificate_verify(signed int preverify_ok, struct x509_store_ctx_st *ctx)
{
  struct mosquitto *mosq;
  struct ssl_st *ssl;
  struct x509_st *cert;
  if(preverify_ok == 0)
    return 0;

  else
  {
    signed int return_value_SSL_get_ex_data_X509_STORE_CTX_idx_1;
    return_value_SSL_get_ex_data_X509_STORE_CTX_idx_1=SSL_get_ex_data_X509_STORE_CTX_idx();
    void *return_value_X509_STORE_CTX_get_ex_data_2;
    return_value_X509_STORE_CTX_get_ex_data_2=X509_STORE_CTX_get_ex_data(ctx, return_value_SSL_get_ex_data_X509_STORE_CTX_idx_1);
    ssl = (struct ssl_st *)return_value_X509_STORE_CTX_get_ex_data_2;
    void *return_value_SSL_get_ex_data_3;
    return_value_SSL_get_ex_data_3=SSL_get_ex_data(ssl, tls_ex_index_mosq);
    mosq = (struct mosquitto *)return_value_SSL_get_ex_data_3;
    if(mosq == ((struct mosquitto *)NULL))
      return 0;

    else
      if((signed int)mosq->tls_insecure == 0)
      {
        signed int return_value_X509_STORE_CTX_get_error_depth_5;
        return_value_X509_STORE_CTX_get_error_depth_5=X509_STORE_CTX_get_error_depth(ctx);
        if(return_value_X509_STORE_CTX_get_error_depth_5 == 0)
        {
          cert=X509_STORE_CTX_get_current_cert(ctx);
          signed int return_value__mosquitto_verify_certificate_hostname_4;
          return_value__mosquitto_verify_certificate_hostname_4=_mosquitto_verify_certificate_hostname(cert, mosq->host);
          return return_value__mosquitto_verify_certificate_hostname_4;
        }

        else
          return preverify_ok;
      }

      else
        return preverify_ok;
  }
}

// _mosquitto_socket_close
// file ./net_mosq.h line 61
signed int _mosquitto_socket_close(struct mosquitto *mosq)
{
  signed int rc = 0;
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  if(!(mosq->ssl == ((struct ssl_st *)NULL)))
  {
    SSL_shutdown(mosq->ssl);
    SSL_free(mosq->ssl);
    mosq->ssl = (struct ssl_st *)(void *)0;
  }

  if(!(mosq->ssl_ctx == ((struct ssl_ctx_st *)NULL)))
  {
    SSL_CTX_free(mosq->ssl_ctx);
    mosq->ssl_ctx = (struct ssl_ctx_st *)(void *)0;
  }

  if(mosq->sock >= 0)
  {
    rc=close(mosq->sock);
    mosq->sock = -1;
  }

  return rc;
}

// _mosquitto_socket_connect
// file ./net_mosq.h line 57
signed int _mosquitto_socket_connect(struct mosquitto *mosq, const char *host, unsigned short int port, const char *bind_address, _Bool blocking)
{
  signed int sock = -1;
  signed int rc;
  signed int ret;
  struct bio_st *bio;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  if(host == ((const char *)NULL) || mosq == ((struct mosquitto *)NULL) || port == 0)
    return 3;

  else
  {
    rc=_mosquitto_try_connect(mosq, host, port, &sock, bind_address, blocking);
    if(rc >= 1)
      return rc;

    else
    {
      if(!(mosq->tls_cafile == ((char *)NULL)))
        tmp_if_expr_11 = (_Bool)1;

      else
        tmp_if_expr_11 = mosq->tls_capath != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_11)
        tmp_if_expr_12 = (_Bool)1;

      else
        tmp_if_expr_12 = mosq->tls_psk != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_12)
      {
        if(mosq->tls_version == ((char *)NULL))
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_strcmp_6=strcmp(mosq->tls_version, "tlsv1.2");
          tmp_if_expr_7 = !(return_value_strcmp_6 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          const struct ssl_method_st *return_value_TLSv1_2_client_method_1;
          return_value_TLSv1_2_client_method_1=TLSv1_2_client_method();
          mosq->ssl_ctx=SSL_CTX_new(return_value_TLSv1_2_client_method_1);
        }

        else
        {
          return_value_strcmp_5=strcmp(mosq->tls_version, "tlsv1.1");
          if(return_value_strcmp_5 == 0)
          {
            const struct ssl_method_st *return_value_TLSv1_1_client_method_2;
            return_value_TLSv1_1_client_method_2=TLSv1_1_client_method();
            mosq->ssl_ctx=SSL_CTX_new(return_value_TLSv1_1_client_method_2);
          }

          else
          {
            return_value_strcmp_4=strcmp(mosq->tls_version, "tlsv1");
            if(return_value_strcmp_4 == 0)
            {
              const struct ssl_method_st *return_value_TLSv1_client_method_3;
              return_value_TLSv1_client_method_3=TLSv1_client_method();
              mosq->ssl_ctx=SSL_CTX_new(return_value_TLSv1_client_method_3);
            }

            else
            {
              _mosquitto_log_printf(mosq, 0x08, "Error: Protocol %s not supported.", mosq->tls_version);
              close(sock);
              return 3;
            }
          }
        }
        if(mosq->ssl_ctx == ((struct ssl_ctx_st *)NULL))
        {
          _mosquitto_log_printf(mosq, 0x08, "Error: Unable to create TLS context.");
          close(sock);
          return 8;
        }

        SSL_CTX_ctrl(mosq->ssl_ctx, 32, 0x00020000L, (void *)0);
        SSL_CTX_ctrl(mosq->ssl_ctx, 33, 0x00000010L, (void *)0);
        if(!(mosq->tls_ciphers == ((char *)NULL)))
        {
          ret=SSL_CTX_set_cipher_list(mosq->ssl_ctx, mosq->tls_ciphers);
          if(ret == 0)
          {
            _mosquitto_log_printf(mosq, 0x08, "Error: Unable to set TLS ciphers. Check cipher list \"%s\".", mosq->tls_ciphers);
            close(sock);
            return 8;
          }

        }

        if(!(mosq->tls_cafile == ((char *)NULL)))
          tmp_if_expr_9 = (_Bool)1;

        else
          tmp_if_expr_9 = mosq->tls_capath != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_9)
        {
          ret=SSL_CTX_load_verify_locations(mosq->ssl_ctx, mosq->tls_cafile, mosq->tls_capath);
          if(ret == 0)
          {
            if(!(mosq->tls_cafile == ((char *)NULL)))
              tmp_if_expr_8 = mosq->tls_capath != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_8 = (_Bool)0;
            if(tmp_if_expr_8)
              _mosquitto_log_printf(mosq, 0x08, "Error: Unable to load CA certificates, check cafile \"%s\" and capath \"%s\".", mosq->tls_cafile, mosq->tls_capath);

            else
              if(!(mosq->tls_cafile == ((char *)NULL)))
                _mosquitto_log_printf(mosq, 0x08, "Error: Unable to load CA certificates, check cafile \"%s\".", mosq->tls_cafile);

              else
                _mosquitto_log_printf(mosq, 0x08, "Error: Unable to load CA certificates, check capath \"%s\".", mosq->tls_capath);
            close(sock);
            return 8;
          }

          if(mosq->tls_cert_reqs == 0)
            SSL_CTX_set_verify(mosq->ssl_ctx, 0x00, (signed int (*)(signed int, struct x509_store_ctx_st *))(void *)0);

          else
            SSL_CTX_set_verify(mosq->ssl_ctx, 0x01, _mosquitto_server_certificate_verify);
          if(!(mosq->tls_pw_callback == ((signed int (*)(char *, signed int, signed int, void *))NULL)))
          {
            SSL_CTX_set_default_passwd_cb(mosq->ssl_ctx, mosq->tls_pw_callback);
            SSL_CTX_set_default_passwd_cb_userdata(mosq->ssl_ctx, (void *)mosq);
          }

          if(!(mosq->tls_certfile == ((char *)NULL)))
          {
            ret=SSL_CTX_use_certificate_chain_file(mosq->ssl_ctx, mosq->tls_certfile);
            if(!(ret == 1))
            {
              _mosquitto_log_printf(mosq, 0x08, "Error: Unable to load client certificate \"%s\".", mosq->tls_certfile);
              close(sock);
              return 8;
            }

          }

          if(!(mosq->tls_keyfile == ((char *)NULL)))
          {
            ret=SSL_CTX_use_PrivateKey_file(mosq->ssl_ctx, mosq->tls_keyfile, 1);
            if(!(ret == 1))
            {
              _mosquitto_log_printf(mosq, 0x08, "Error: Unable to load client key file \"%s\".", mosq->tls_keyfile);
              close(sock);
              return 8;
            }

            ret=SSL_CTX_check_private_key(mosq->ssl_ctx);
            if(!(ret == 1))
            {
              _mosquitto_log_printf(mosq, 0x08, "Error: Client certificate/key are inconsistent.");
              close(sock);
              return 8;
            }

          }

        }

        else
          if(!(mosq->tls_psk == ((char *)NULL)))
            SSL_CTX_set_psk_client_callback(mosq->ssl_ctx, psk_client_callback);

        mosq->ssl=SSL_new(mosq->ssl_ctx);
        if(mosq->ssl == ((struct ssl_st *)NULL))
        {
          close(sock);
          return 8;
        }

        SSL_set_ex_data(mosq->ssl, tls_ex_index_mosq, (void *)mosq);
        bio=BIO_new_socket(sock, 0x00);
        if(bio == ((struct bio_st *)NULL))
        {
          close(sock);
          return 8;
        }

        SSL_set_bio(mosq->ssl, bio, bio);
        mosq->sock = sock;
        signed int return_value_mosquitto__socket_connect_tls_10;
        return_value_mosquitto__socket_connect_tls_10=mosquitto__socket_connect_tls(mosq);
        if(!(return_value_mosquitto__socket_connect_tls_10 == 0))
          return 8;

      }

      mosq->sock = sock;
      return rc;
    }
  }
}

// _mosquitto_socket_nonblock
// file net_mosq.c line 1049
signed int _mosquitto_socket_nonblock(signed int sock)
{
  signed int opt;
  opt=fcntl(sock, 3, 0);
  if(opt == -1)
  {
    close(sock);
    return 1;
  }

  else
  {
    signed int return_value_fcntl_1;
    return_value_fcntl_1=fcntl(sock, 4, opt | 04000);
    if(return_value_fcntl_1 == -1)
    {
      close(sock);
      return 1;
    }

    else
      return 0;
  }
}

// _mosquitto_socketpair
// file ./net_mosq.h line 65
signed int _mosquitto_socketpair(signed int *pairR, signed int *pairW)
{
  signed int sv[2l];
  signed int return_value_socketpair_1;
  return_value_socketpair_1=socketpair(1, 1, 0, sv);
  if(return_value_socketpair_1 == -1)
    return 14;

  else
  {
    signed int return_value__mosquitto_socket_nonblock_2;
    return_value__mosquitto_socket_nonblock_2=_mosquitto_socket_nonblock(sv[(signed long int)0]);
    if(!(return_value__mosquitto_socket_nonblock_2 == 0))
    {
      close(sv[(signed long int)0]);
      close(sv[(signed long int)1]);
      return 14;
    }

    else
    {
      signed int return_value__mosquitto_socket_nonblock_3;
      return_value__mosquitto_socket_nonblock_3=_mosquitto_socket_nonblock(sv[(signed long int)1]);
      if(!(return_value__mosquitto_socket_nonblock_3 == 0))
      {
        close(sv[(signed long int)0]);
        close(sv[(signed long int)1]);
        return 14;
      }

      else
      {
        *pairR = sv[(signed long int)0];
        *pairW = sv[(signed long int)1];
        return 0;
      }
    }
  }
}

// _mosquitto_strdup
// file ./memory_mosq.h line 35
char * _mosquitto_strdup(const char *s)
{
  char *str;
  str=strdup(s);
  return str;
}

// _mosquitto_thread_main
// file thread_mosq.c line 76
void * _mosquitto_thread_main(void *obj)
{
  struct mosquitto *mosq = (struct mosquitto *)obj;
  if(mosq == ((struct mosquitto *)NULL))
    return (void *)0;

  else
  {
    pthread_mutex_lock(&mosq->state_mutex);
    if((signed int)mosq->state == mosq_cs_connect_async)
    {
      pthread_mutex_unlock(&mosq->state_mutex);
      mosquitto_reconnect(mosq);
    }

    else
      pthread_mutex_unlock(&mosq->state_mutex);
    if(mosq->keepalive == 0)
      mosquitto_loop_forever(mosq, 1000 * 86400, 1);

    else
      mosquitto_loop_forever(mosq, (signed int)mosq->keepalive * 1000, 1);
    return obj;
  }
}

// _mosquitto_try_connect
// file net_mosq.c line 271
signed int _mosquitto_try_connect(struct mosquitto *mosq, const char *host, unsigned short int port, signed int *sock, const char *bind_address, _Bool blocking)
{
  struct addrinfo hints;
  struct addrinfo *ainfo;
  struct addrinfo *rp;
  struct addrinfo *ainfo_bind;
  struct addrinfo *rp_bind;
  signed int s;
  signed int rc = 0;
  *sock = -1;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  _Bool tmp_if_expr_1;
  if(!(mosq->tls_cafile == ((char *)NULL)))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = mosq->tls_capath != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = mosq->tls_psk != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    hints.ai_family = 2;

  else
    hints.ai_family = 0;
  hints.ai_flags = 0x0020;
  hints.ai_socktype = 1;
  s=getaddrinfo(host, (const char *)(void *)0, &hints, &ainfo);
  if(!(s == 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = s;
    return 15;
  }

  if(!(bind_address == ((const char *)NULL)))
  {
    s=getaddrinfo(bind_address, (const char *)(void *)0, &hints, &ainfo_bind);
    if(!(s == 0))
    {
      freeaddrinfo(ainfo);
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = s;
      return 15;
    }

  }

  rp = ainfo;
  _Bool tmp_if_expr_12;
  signed int *return_value___errno_location_11;
  _Bool tmp_if_expr_14;
  signed int *return_value___errno_location_13;
  signed int *return_value___errno_location_7;
  _Bool tmp_if_expr_9;
  signed int *return_value___errno_location_8;
  for( ; !(rp == ((struct addrinfo *)NULL)); rp = rp->ai_next)
  {
    *sock=socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    if(!(*sock == -1))
    {
      if(rp->ai_family == 2)
        ((struct sockaddr_in *)rp->ai_addr)->sin_port=htons(port);

      else
        if(rp->ai_family == 10)
          ((struct sockaddr_in6 *)rp->ai_addr)->sin6_port=htons(port);

        else
        {
          close(*sock);
          goto __CPROVER_DUMP_L28;
        }
      if(!(bind_address == ((const char *)NULL)))
      {
        rp_bind = ainfo_bind;
        for( ; !(rp_bind == ((struct addrinfo *)NULL)); rp_bind = rp_bind->ai_next)
        {
          signed int return_value_bind_5;
          return_value_bind_5=bind(*sock, rp_bind->ai_addr, rp_bind->ai_addrlen);
          if(return_value_bind_5 == 0)
            break;

        }
        if(!(rp_bind == ((struct addrinfo *)NULL)))
          goto __CPROVER_DUMP_L15;

        close(*sock);
      }

      else
      {

      __CPROVER_DUMP_L15:
        ;
        if(blocking == (_Bool)0)
        {
          signed int return_value__mosquitto_socket_nonblock_6;
          return_value__mosquitto_socket_nonblock_6=_mosquitto_socket_nonblock(*sock);
          if(!(return_value__mosquitto_socket_nonblock_6 == 0))
          {
            close(*sock);
            goto __CPROVER_DUMP_L28;
          }

        }

        rc=connect(*sock, rp->ai_addr, rp->ai_addrlen);
        if(rc == 0)
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          return_value___errno_location_11=__errno_location();
          tmp_if_expr_12 = *return_value___errno_location_11 == 115 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_12)
          tmp_if_expr_14 = (_Bool)1;

        else
        {
          return_value___errno_location_13=__errno_location();
          tmp_if_expr_14 = *return_value___errno_location_13 == 11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_14)
        {
          if(!(rc >= 0))
          {
            return_value___errno_location_7=__errno_location();
            if(*return_value___errno_location_7 == 115)
              tmp_if_expr_9 = (_Bool)1;

            else
            {
              return_value___errno_location_8=__errno_location();
              tmp_if_expr_9 = *return_value___errno_location_8 == 11 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_9)
              rc = -1;

          }

          if(!(blocking == (_Bool)0))
          {
            signed int return_value__mosquitto_socket_nonblock_10;
            return_value__mosquitto_socket_nonblock_10=_mosquitto_socket_nonblock(*sock);
            if(!(return_value__mosquitto_socket_nonblock_10 == 0))
            {
              close(*sock);
              goto __CPROVER_DUMP_L28;
            }

          }

          break;
        }

        close(*sock);
        *sock = -1;
      }
    }


  __CPROVER_DUMP_L28:
    ;
  }
  freeaddrinfo(ainfo);
  if(!(bind_address == ((const char *)NULL)))
    freeaddrinfo(ainfo_bind);

  if(rp == ((struct addrinfo *)NULL))
    return 14;

  else
    return rc;
}

// _mosquitto_verify_certificate_hostname
// file tls_mosq.c line 103
signed int _mosquitto_verify_certificate_hostname(struct x509_st *cert, const char *hostname)
{
  signed int i;
  char name[256l];
  struct X509_name_st *subj;
  _Bool have_san_dns = (_Bool)0;
  struct stack_st_GENERAL_NAME *san;
  const struct GENERAL_NAME_st *nval;
  const unsigned char *data;
  unsigned char ipv6_addr[16l];
  unsigned char ipv4_addr[4l];
  signed int ipv6_ok;
  signed int ipv4_ok;
  ipv6_ok=inet_pton(10, hostname, (void *)&ipv6_addr);
  ipv4_ok=inet_pton(2, hostname, (void *)&ipv4_addr);
  void *return_value_X509_get_ext_d2i_1;
  return_value_X509_get_ext_d2i_1=X509_get_ext_d2i(cert, 85, (signed int *)(void *)0, (signed int *)(void *)0);
  san = (struct stack_st_GENERAL_NAME *)return_value_X509_get_ext_d2i_1;
  signed int return_value_sk_num_2;
  signed int return_value_mosquitto__cmp_hostname_wildcard_4;
  if(!(san == ((struct stack_st_GENERAL_NAME *)NULL)))
  {
    i = 0;
    do
    {
      return_value_sk_num_2=sk_num((struct stack_st *)(1 != 0 ? san : (struct stack_st_GENERAL_NAME *)0));
      if(i >= return_value_sk_num_2)
        break;

      void *return_value_sk_value_3;
      return_value_sk_value_3=sk_value((struct stack_st *)(1 != 0 ? san : (struct stack_st_GENERAL_NAME *)0), i);
      nval = (struct GENERAL_NAME_st *)return_value_sk_value_3;
      if(nval->type == 2)
      {
        data=ASN1_STRING_data(nval->d.dNSName);
        if(!(data == ((const unsigned char *)NULL)))
        {
          return_value_mosquitto__cmp_hostname_wildcard_4=mosquitto__cmp_hostname_wildcard((char *)data, hostname);
          if(return_value_mosquitto__cmp_hostname_wildcard_4 == 0)
            return 1;

        }

        have_san_dns = (_Bool)1;
      }

      else
        if(nval->type == 7)
        {
          data=ASN1_STRING_data(nval->d.iPAddress);
          if(nval->d.iPAddress->length == 4 && !(ipv4_ok == 0))
          {
            signed int return_value_memcmp_5;
            return_value_memcmp_5=memcmp((const void *)ipv4_addr, (const void *)data, (unsigned long int)4);
            if(return_value_memcmp_5 == 0)
              return 1;

          }

          else
            if(nval->d.iPAddress->length == 16)
            {
              if(!(ipv6_ok == 0))
              {
                signed int return_value_memcmp_6;
                return_value_memcmp_6=memcmp((const void *)ipv6_addr, (const void *)data, (unsigned long int)16);
                if(return_value_memcmp_6 == 0)
                  return 1;

              }

            }

        }

      i = i + 1;
    }
    while((_Bool)1);
    if(have_san_dns == (_Bool)0)
      goto __CPROVER_DUMP_L9;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L9:
    ;
    subj=X509_get_subject_name(cert);
    signed int return_value_X509_NAME_get_text_by_NID_8;
    return_value_X509_NAME_get_text_by_NID_8=X509_NAME_get_text_by_NID(subj, 13, name, (signed int)sizeof(char [256l]) /*256ul*/ );
    if(return_value_X509_NAME_get_text_by_NID_8 >= 1)
    {
      name[(signed long int)(sizeof(char [256l]) /*256ul*/  - (unsigned long int)1)] = (char)0;
      signed int return_value_mosquitto__cmp_hostname_wildcard_7;
      return_value_mosquitto__cmp_hostname_wildcard_7=mosquitto__cmp_hostname_wildcard(name, hostname);
      if(return_value_mosquitto__cmp_hostname_wildcard_7 == 0)
        return 1;

    }

    return 0;
  }
}

// _mosquitto_will_clear
// file ./will_mosq.h line 24
signed int _mosquitto_will_clear(struct mosquitto *mosq)
{
  if(mosq->will == ((struct mosquitto_message *)NULL))
    return 0;

  else
  {
    if(!(mosq->will->topic == ((char *)NULL)))
    {
      _mosquitto_free((void *)mosq->will->topic);
      mosq->will->topic = (char *)(void *)0;
    }

    if(!(mosq->will->payload == NULL))
    {
      _mosquitto_free(mosq->will->payload);
      mosq->will->payload = (void *)0;
    }

    _mosquitto_free((void *)mosq->will);
    mosq->will = (struct mosquitto_message *)(void *)0;
    return 0;
  }
}

// _mosquitto_will_set
// file ./will_mosq.h line 23
signed int _mosquitto_will_set(struct mosquitto *mosq, const char *topic, signed int payloadlen, const void *payload, signed int qos, _Bool retain)
{
  signed int rc = 0;
  if(topic == ((const char *)NULL) || mosq == ((struct mosquitto *)NULL))
    return 3;

  else
    if(payloadlen >= 268435456 || !(payloadlen >= 0))
      return 9;

    else
      if(payload == NULL && payloadlen >= 1)
        return 3;

      else
      {
        signed int return_value_mosquitto_pub_topic_check_1;
        return_value_mosquitto_pub_topic_check_1=mosquitto_pub_topic_check(topic);
        if(!(return_value_mosquitto_pub_topic_check_1 == 0))
          return 3;

        else
        {
          if(!(mosq->will == ((struct mosquitto_message *)NULL)))
          {
            if(!(mosq->will->topic == ((char *)NULL)))
            {
              _mosquitto_free((void *)mosq->will->topic);
              mosq->will->topic = (char *)(void *)0;
            }

            if(!(mosq->will->payload == NULL))
            {
              _mosquitto_free(mosq->will->payload);
              mosq->will->payload = (void *)0;
            }

            _mosquitto_free((void *)mosq->will);
            mosq->will = (struct mosquitto_message *)(void *)0;
          }

          void *return_value__mosquitto_calloc_2;
          return_value__mosquitto_calloc_2=_mosquitto_calloc((unsigned long int)1, sizeof(struct mosquitto_message) /*40ul*/ );
          mosq->will = (struct mosquitto_message *)return_value__mosquitto_calloc_2;
          if(mosq->will == ((struct mosquitto_message *)NULL))
            return 1;

          else
          {
            mosq->will->topic=_mosquitto_strdup(topic);
            if(mosq->will->topic == ((char *)NULL))
              rc = 1;

            else
            {
              mosq->will->payloadlen = payloadlen;
              if(mosq->will->payloadlen >= 1)
              {
                if(payload == NULL)
                {
                  rc = 3;
                  goto cleanup;
                }

                mosq->will->payload=_mosquitto_malloc(sizeof(char) /*1ul*/  * (unsigned long int)mosq->will->payloadlen);
                if(mosq->will->payload == NULL)
                {
                  rc = 1;
                  goto cleanup;
                }

                memcpy(mosq->will->payload, payload, (unsigned long int)payloadlen);
              }

              mosq->will->qos = qos;
              mosq->will->retain = retain;
              return 0;
            }

          cleanup:
            ;
            if(!(mosq->will == ((struct mosquitto_message *)NULL)))
            {
              if(!(mosq->will->topic == ((char *)NULL)))
                _mosquitto_free((void *)mosq->will->topic);

              if(!(mosq->will->payload == NULL))
                _mosquitto_free(mosq->will->payload);

            }

            _mosquitto_free((void *)mosq->will);
            mosq->will = (struct mosquitto_message *)(void *)0;
            return rc;
          }
        }
      }
}

// _mosquitto_write_byte
// file net_mosq.c line 572
void _mosquitto_write_byte(struct _mosquitto_packet *packet, unsigned char byte)
{
  /* assertion packet */
  assert(packet != ((struct _mosquitto_packet *)NULL));
  /* assertion packet->pos+1 <= packet->packet_length */
  assert(packet->pos + (unsigned int)1 <= packet->packet_length);
  packet->payload[(signed long int)packet->pos] = byte;
  packet->pos = packet->pos + 1u;
}

// _mosquitto_write_bytes
// file net_mosq.c line 592
void _mosquitto_write_bytes(struct _mosquitto_packet *packet, const void *bytes, unsigned int count)
{
  /* assertion packet */
  assert(packet != ((struct _mosquitto_packet *)NULL));
  /* assertion packet->pos+count <= packet->packet_length */
  assert(packet->pos + count <= packet->packet_length);
  memcpy((void *)&packet->payload[(signed long int)packet->pos], bytes, (unsigned long int)count);
  packet->pos = packet->pos + count;
}

// _mosquitto_write_string
// file net_mosq.c line 624
void _mosquitto_write_string(struct _mosquitto_packet *packet, const char *str, unsigned short int length)
{
  /* assertion packet */
  assert(packet != ((struct _mosquitto_packet *)NULL));
  _mosquitto_write_uint16(packet, length);
  _mosquitto_write_bytes(packet, (const void *)str, (unsigned int)length);
}

// _mosquitto_write_uint16
// file net_mosq.c line 648
void _mosquitto_write_uint16(struct _mosquitto_packet *packet, unsigned short int word)
{
  _mosquitto_write_byte(packet, (unsigned char)(((signed int)word & 0xFF00) >> 8));
  _mosquitto_write_byte(packet, (unsigned char)((signed int)word & 0x00FF));
}

// client_config_cleanup
// file client_shared.h line 92
void client_config_cleanup(struct mosq_config *cfg)
{
  signed int i;
  free((void *)cfg->id);
  free((void *)cfg->id_prefix);
  free((void *)cfg->host);
  free((void *)cfg->file_input);
  free((void *)cfg->message);
  free((void *)cfg->topic);
  free((void *)cfg->bind_address);
  free((void *)cfg->username);
  free((void *)cfg->password);
  free((void *)cfg->will_topic);
  free((void *)cfg->will_payload);
  free((void *)cfg->cafile);
  free((void *)cfg->capath);
  free((void *)cfg->certfile);
  free((void *)cfg->keyfile);
  free((void *)cfg->ciphers);
  free((void *)cfg->tls_version);
  free((void *)cfg->psk);
  free((void *)cfg->psk_identity);
  if(!(cfg->topics == ((char **)NULL)))
  {
    i = 0;
    for( ; !(i >= cfg->topic_count); i = i + 1)
      free((void *)cfg->topics[(signed long int)i]);
    free((void *)cfg->topics);
  }

  if(!(cfg->filter_outs == ((char **)NULL)))
  {
    i = 0;
    for( ; !(i >= cfg->filter_out_count); i = i + 1)
      free((void *)cfg->filter_outs[(signed long int)i]);
    free((void *)cfg->filter_outs);
  }

  free((void *)cfg->socks5_host);
  free((void *)cfg->socks5_username);
  free((void *)cfg->socks5_password);
}

// client_config_line_proc
// file client_shared.c line 238
static signed int client_config_line_proc(struct mosq_config *cfg, signed int pub_or_sub, signed int argc, char **argv)
{
  signed int i = 1;
  _Bool tmp_if_expr_97;
  signed int return_value_strcmp_96;
  _Bool tmp_if_expr_1;
  signed int return_value_strcmp_94;
  signed int return_value_strcmp_93;
  signed int return_value_strcmp_92;
  signed int return_value_strcmp_91;
  signed int return_value_strcmp_90;
  signed int return_value_strcmp_89;
  signed int return_value_strcmp_86;
  _Bool tmp_if_expr_88;
  signed int return_value_strcmp_87;
  signed int return_value_strcmp_83;
  _Bool tmp_if_expr_85;
  signed int return_value_strcmp_84;
  signed int return_value_strcmp_82;
  signed int return_value_strcmp_79;
  _Bool tmp_if_expr_81;
  signed int return_value_strcmp_80;
  signed int return_value_strcmp_78;
  signed int return_value_strcmp_75;
  _Bool tmp_if_expr_77;
  signed int return_value_strcmp_76;
  signed int return_value_strcmp_72;
  _Bool tmp_if_expr_74;
  signed int return_value_strcmp_73;
  signed int return_value_strcmp_69;
  _Bool tmp_if_expr_71;
  signed int return_value_strcmp_70;
  signed int return_value_strcmp_68;
  signed int return_value_strcmp_65;
  _Bool tmp_if_expr_67;
  signed int return_value_strcmp_66;
  signed int return_value_strcmp_62;
  _Bool tmp_if_expr_64;
  signed int return_value_strcmp_63;
  signed int return_value_strcmp_61;
  signed int return_value_strcmp_58;
  _Bool tmp_if_expr_60;
  signed int return_value_strcmp_59;
  signed int return_value_strcmp_55;
  _Bool tmp_if_expr_57;
  signed int return_value_strcmp_56;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_54;
  signed int return_value_strcmp_53;
  signed int return_value_strcmp_52;
  signed int return_value_strcmp_49;
  _Bool tmp_if_expr_51;
  signed int return_value_strcmp_50;
  _Bool tmp_if_expr_7;
  signed int return_value_strcmp_48;
  signed int return_value_strcmp_45;
  _Bool tmp_if_expr_47;
  signed int return_value_strcmp_46;
  signed int return_value_strcmp_42;
  _Bool tmp_if_expr_44;
  signed int return_value_strcmp_43;
  signed int return_value_strcmp_41;
  signed int return_value_strcmp_38;
  _Bool tmp_if_expr_40;
  signed int return_value_strcmp_39;
  signed int return_value_strcmp_35;
  _Bool tmp_if_expr_37;
  signed int return_value_strcmp_36;
  signed int return_value_strcmp_34;
  signed int return_value_strcmp_31;
  _Bool tmp_if_expr_33;
  signed int return_value_strcmp_32;
  signed int return_value_strcmp_28;
  _Bool tmp_if_expr_30;
  signed int return_value_strcmp_29;
  signed int return_value_strcmp_27;
  signed int return_value_strcmp_26;
  _Bool tmp_if_expr_14;
  signed int return_value_strcmp_25;
  signed int return_value_strcmp_24;
  signed int return_value_strcmp_21;
  _Bool tmp_if_expr_23;
  signed int return_value_strcmp_22;
  signed int return_value_strcmp_20;
  signed int return_value_strcmp_19;
  signed int return_value_strcmp_16;
  _Bool tmp_if_expr_18;
  signed int return_value_strcmp_17;
  for( ; !(i >= argc); i = i + 1)
  {
    signed int return_value_strcmp_95;
    return_value_strcmp_95=strcmp(argv[(signed long int)i], "-p");
    if(return_value_strcmp_95 == 0)
      tmp_if_expr_97 = (_Bool)1;

    else
    {
      return_value_strcmp_96=strcmp(argv[(signed long int)i], "--port");
      tmp_if_expr_97 = !(return_value_strcmp_96 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_97)
    {
      if(i == argc + -1)
      {
        fprintf(stderr, "Error: -p argument given but no port specified.\n\n");
        return 1;
      }

      else
      {
        cfg->port=atoi(argv[(signed long int)(i + 1)]);
        if(!(cfg->port >= 1))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = cfg->port > 65535 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          fprintf(stderr, "Error: Invalid port given: %d\n", cfg->port);
          return 1;
        }

      }
      i = i + 1;
    }

    else
    {
      return_value_strcmp_94=strcmp(argv[(signed long int)i], "-A");
      if(return_value_strcmp_94 == 0)
      {
        if(i == argc + -1)
        {
          fprintf(stderr, "Error: -A argument given but no address specified.\n\n");
          return 1;
        }

        else
          cfg->bind_address=strdup(argv[(signed long int)(i + 1)]);
        i = i + 1;
      }

      else
      {
        return_value_strcmp_93=strcmp(argv[(signed long int)i], "--cafile");
        if(return_value_strcmp_93 == 0)
        {
          if(i == argc + -1)
          {
            fprintf(stderr, "Error: --cafile argument given but no file specified.\n\n");
            return 1;
          }

          else
            cfg->cafile=strdup(argv[(signed long int)(i + 1)]);
          i = i + 1;
        }

        else
        {
          return_value_strcmp_92=strcmp(argv[(signed long int)i], "--capath");
          if(return_value_strcmp_92 == 0)
          {
            if(i == argc + -1)
            {
              fprintf(stderr, "Error: --capath argument given but no directory specified.\n\n");
              return 1;
            }

            else
              cfg->capath=strdup(argv[(signed long int)(i + 1)]);
            i = i + 1;
          }

          else
          {
            return_value_strcmp_91=strcmp(argv[(signed long int)i], "--cert");
            if(return_value_strcmp_91 == 0)
            {
              if(i == argc + -1)
              {
                fprintf(stderr, "Error: --cert argument given but no file specified.\n\n");
                return 1;
              }

              else
                cfg->certfile=strdup(argv[(signed long int)(i + 1)]);
              i = i + 1;
            }

            else
            {
              return_value_strcmp_90=strcmp(argv[(signed long int)i], "--ciphers");
              if(return_value_strcmp_90 == 0)
              {
                if(i == argc + -1)
                {
                  fprintf(stderr, "Error: --ciphers argument given but no ciphers specified.\n\n");
                  return 1;
                }

                else
                  cfg->ciphers=strdup(argv[(signed long int)(i + 1)]);
                i = i + 1;
              }

              else
              {
                return_value_strcmp_89=strcmp(argv[(signed long int)i], "-C");
                if(return_value_strcmp_89 == 0)
                {
                  if(pub_or_sub == 1)
                    goto unknown_option;

                  else
                  {
                    if(i == argc + -1)
                    {
                      fprintf(stderr, "Error: -C argument given but no count specified.\n\n");
                      return 1;
                    }

                    else
                    {
                      cfg->msg_count=atoi(argv[(signed long int)(i + 1)]);
                      if(!(cfg->msg_count >= 1))
                      {
                        fprintf(stderr, "Error: Invalid message count \"%d\".\n\n", cfg->msg_count);
                        return 1;
                      }

                    }
                    i = i + 1;
                  }
                }

                else
                {
                  return_value_strcmp_86=strcmp(argv[(signed long int)i], "-d");
                  if(return_value_strcmp_86 == 0)
                    tmp_if_expr_88 = (_Bool)1;

                  else
                  {
                    return_value_strcmp_87=strcmp(argv[(signed long int)i], "--debug");
                    tmp_if_expr_88 = !(return_value_strcmp_87 != 0) ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_88)
                    cfg->debug = (_Bool)1;

                  else
                  {
                    return_value_strcmp_83=strcmp(argv[(signed long int)i], "-f");
                    if(return_value_strcmp_83 == 0)
                      tmp_if_expr_85 = (_Bool)1;

                    else
                    {
                      return_value_strcmp_84=strcmp(argv[(signed long int)i], "--file");
                      tmp_if_expr_85 = !(return_value_strcmp_84 != 0) ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr_85)
                    {
                      if(pub_or_sub == 2)
                        goto unknown_option;

                      if(!(cfg->pub_mode == 0))
                      {
                        fprintf(stderr, "Error: Only one type of message can be sent at once.\n\n");
                        return 1;
                      }

                      else
                        if(i == argc + -1)
                        {
                          fprintf(stderr, "Error: -f argument given but no file specified.\n\n");
                          return 1;
                        }

                        else
                        {
                          cfg->pub_mode = 4;
                          cfg->file_input=strdup(argv[(signed long int)(i + 1)]);
                        }
                      i = i + 1;
                    }

                    else
                    {
                      return_value_strcmp_82=strcmp(argv[(signed long int)i], "--help");
                      if(return_value_strcmp_82 == 0)
                        return 2;

                      else
                      {
                        return_value_strcmp_79=strcmp(argv[(signed long int)i], "-h");
                        if(return_value_strcmp_79 == 0)
                          tmp_if_expr_81 = (_Bool)1;

                        else
                        {
                          return_value_strcmp_80=strcmp(argv[(signed long int)i], "--host");
                          tmp_if_expr_81 = !(return_value_strcmp_80 != 0) ? (_Bool)1 : (_Bool)0;
                        }
                        if(tmp_if_expr_81)
                        {
                          if(i == argc + -1)
                          {
                            fprintf(stderr, "Error: -h argument given but no host specified.\n\n");
                            return 1;
                          }

                          else
                            cfg->host=strdup(argv[(signed long int)(i + 1)]);
                          i = i + 1;
                        }

                        else
                        {
                          return_value_strcmp_78=strcmp(argv[(signed long int)i], "--insecure");
                          if(return_value_strcmp_78 == 0)
                            cfg->insecure = (_Bool)1;

                          else
                          {
                            return_value_strcmp_75=strcmp(argv[(signed long int)i], "-i");
                            if(return_value_strcmp_75 == 0)
                              tmp_if_expr_77 = (_Bool)1;

                            else
                            {
                              return_value_strcmp_76=strcmp(argv[(signed long int)i], "--id");
                              tmp_if_expr_77 = !(return_value_strcmp_76 != 0) ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr_77)
                            {
                              if(!(cfg->id_prefix == ((char *)NULL)))
                              {
                                fprintf(stderr, "Error: -i and -I argument cannot be used together.\n\n");
                                return 1;
                              }

                              if(i == argc + -1)
                              {
                                fprintf(stderr, "Error: -i argument given but no id specified.\n\n");
                                return 1;
                              }

                              else
                                cfg->id=strdup(argv[(signed long int)(i + 1)]);
                              i = i + 1;
                            }

                            else
                            {
                              return_value_strcmp_72=strcmp(argv[(signed long int)i], "-I");
                              if(return_value_strcmp_72 == 0)
                                tmp_if_expr_74 = (_Bool)1;

                              else
                              {
                                return_value_strcmp_73=strcmp(argv[(signed long int)i], "--id-prefix");
                                tmp_if_expr_74 = !(return_value_strcmp_73 != 0) ? (_Bool)1 : (_Bool)0;
                              }
                              if(tmp_if_expr_74)
                              {
                                if(!(cfg->id == ((char *)NULL)))
                                {
                                  fprintf(stderr, "Error: -i and -I argument cannot be used together.\n\n");
                                  return 1;
                                }

                                if(i == argc + -1)
                                {
                                  fprintf(stderr, "Error: -I argument given but no id prefix specified.\n\n");
                                  return 1;
                                }

                                else
                                  cfg->id_prefix=strdup(argv[(signed long int)(i + 1)]);
                                i = i + 1;
                              }

                              else
                              {
                                return_value_strcmp_69=strcmp(argv[(signed long int)i], "-k");
                                if(return_value_strcmp_69 == 0)
                                  tmp_if_expr_71 = (_Bool)1;

                                else
                                {
                                  return_value_strcmp_70=strcmp(argv[(signed long int)i], "--keepalive");
                                  tmp_if_expr_71 = !(return_value_strcmp_70 != 0) ? (_Bool)1 : (_Bool)0;
                                }
                                if(tmp_if_expr_71)
                                {
                                  if(i == argc + -1)
                                  {
                                    fprintf(stderr, "Error: -k argument given but no keepalive specified.\n\n");
                                    return 1;
                                  }

                                  else
                                  {
                                    cfg->keepalive=atoi(argv[(signed long int)(i + 1)]);
                                    if(cfg->keepalive >= 65536)
                                    {
                                      fprintf(stderr, "Error: Invalid keepalive given: %d\n", cfg->keepalive);
                                      return 1;
                                    }

                                  }
                                  i = i + 1;
                                }

                                else
                                {
                                  return_value_strcmp_68=strcmp(argv[(signed long int)i], "--key");
                                  if(return_value_strcmp_68 == 0)
                                  {
                                    if(i == argc + -1)
                                    {
                                      fprintf(stderr, "Error: --key argument given but no file specified.\n\n");
                                      return 1;
                                    }

                                    else
                                      cfg->keyfile=strdup(argv[(signed long int)(i + 1)]);
                                    i = i + 1;
                                  }

                                  else
                                  {
                                    return_value_strcmp_65=strcmp(argv[(signed long int)i], "-l");
                                    if(return_value_strcmp_65 == 0)
                                      tmp_if_expr_67 = (_Bool)1;

                                    else
                                    {
                                      return_value_strcmp_66=strcmp(argv[(signed long int)i], "--stdin-line");
                                      tmp_if_expr_67 = !(return_value_strcmp_66 != 0) ? (_Bool)1 : (_Bool)0;
                                    }
                                    if(tmp_if_expr_67)
                                    {
                                      if(pub_or_sub == 2)
                                        goto unknown_option;

                                      if(!(cfg->pub_mode == 0))
                                      {
                                        fprintf(stderr, "Error: Only one type of message can be sent at once.\n\n");
                                        return 1;
                                      }

                                      else
                                        cfg->pub_mode = 2;
                                    }

                                    else
                                    {
                                      return_value_strcmp_62=strcmp(argv[(signed long int)i], "-m");
                                      if(return_value_strcmp_62 == 0)
                                        tmp_if_expr_64 = (_Bool)1;

                                      else
                                      {
                                        return_value_strcmp_63=strcmp(argv[(signed long int)i], "--message");
                                        tmp_if_expr_64 = !(return_value_strcmp_63 != 0) ? (_Bool)1 : (_Bool)0;
                                      }
                                      if(tmp_if_expr_64)
                                      {
                                        if(pub_or_sub == 2)
                                          goto unknown_option;

                                        if(!(cfg->pub_mode == 0))
                                        {
                                          fprintf(stderr, "Error: Only one type of message can be sent at once.\n\n");
                                          return 1;
                                        }

                                        else
                                          if(i == argc + -1)
                                          {
                                            fprintf(stderr, "Error: -m argument given but no message specified.\n\n");
                                            return 1;
                                          }

                                          else
                                          {
                                            cfg->message=strdup(argv[(signed long int)(i + 1)]);
                                            unsigned long int return_value_strlen_2;
                                            return_value_strlen_2=strlen(cfg->message);
                                            cfg->msglen = (signed long int)return_value_strlen_2;
                                            cfg->pub_mode = 1;
                                          }
                                        i = i + 1;
                                      }

                                      else
                                      {
                                        return_value_strcmp_61=strcmp(argv[(signed long int)i], "-M");
                                        if(return_value_strcmp_61 == 0)
                                        {
                                          if(i == argc + -1)
                                          {
                                            fprintf(stderr, "Error: -M argument given but max_inflight not specified.\n\n");
                                            return 1;
                                          }

                                          else
                                          {
                                            signed int return_value_atoi_3;
                                            return_value_atoi_3=atoi(argv[(signed long int)(i + 1)]);
                                            cfg->max_inflight = (unsigned int)return_value_atoi_3;
                                          }
                                          i = i + 1;
                                        }

                                        else
                                        {
                                          return_value_strcmp_58=strcmp(argv[(signed long int)i], "-n");
                                          if(return_value_strcmp_58 == 0)
                                            tmp_if_expr_60 = (_Bool)1;

                                          else
                                          {
                                            return_value_strcmp_59=strcmp(argv[(signed long int)i], "--null-message");
                                            tmp_if_expr_60 = !(return_value_strcmp_59 != 0) ? (_Bool)1 : (_Bool)0;
                                          }
                                          if(tmp_if_expr_60)
                                          {
                                            if(pub_or_sub == 2)
                                              goto unknown_option;

                                            if(!(cfg->pub_mode == 0))
                                            {
                                              fprintf(stderr, "Error: Only one type of message can be sent at once.\n\n");
                                              return 1;
                                            }

                                            else
                                              cfg->pub_mode = 5;
                                          }

                                          else
                                          {
                                            return_value_strcmp_55=strcmp(argv[(signed long int)i], "-V");
                                            if(return_value_strcmp_55 == 0)
                                              tmp_if_expr_57 = (_Bool)1;

                                            else
                                            {
                                              return_value_strcmp_56=strcmp(argv[(signed long int)i], "--protocol-version");
                                              tmp_if_expr_57 = !(return_value_strcmp_56 != 0) ? (_Bool)1 : (_Bool)0;
                                            }
                                            if(tmp_if_expr_57)
                                            {
                                              if(i == argc + -1)
                                              {
                                                fprintf(stderr, "Error: --protocol-version argument given but no version specified.\n\n");
                                                return 1;
                                              }

                                              else
                                              {
                                                signed int return_value_strcmp_5;
                                                return_value_strcmp_5=strcmp(argv[(signed long int)(i + 1)], "mqttv31");
                                                if(return_value_strcmp_5 == 0)
                                                  cfg->protocol_version = 3;

                                                else
                                                {
                                                  return_value_strcmp_4=strcmp(argv[(signed long int)(i + 1)], "mqttv311");
                                                  if(return_value_strcmp_4 == 0)
                                                    cfg->protocol_version = 4;

                                                  else
                                                  {
                                                    fprintf(stderr, "Error: Invalid protocol version argument given.\n\n");
                                                    return 1;
                                                  }
                                                }
                                                i = i + 1;
                                              }
                                            }

                                            else
                                            {
                                              return_value_strcmp_54=strcmp(argv[(signed long int)i], "--proxy");
                                              if(return_value_strcmp_54 == 0)
                                              {
                                                if(i == argc + -1)
                                                {
                                                  fprintf(stderr, "Error: --proxy argument given but no proxy url specified.\n\n");
                                                  return 1;
                                                }

                                                else
                                                {
                                                  signed int return_value_mosquitto__parse_socks_url_6;
                                                  return_value_mosquitto__parse_socks_url_6=mosquitto__parse_socks_url(cfg, argv[(signed long int)(i + 1)]);
                                                  if(!(return_value_mosquitto__parse_socks_url_6 == 0))
                                                    return 1;

                                                  i = i + 1;
                                                }
                                              }

                                              else
                                              {
                                                return_value_strcmp_53=strcmp(argv[(signed long int)i], "--psk");
                                                if(return_value_strcmp_53 == 0)
                                                {
                                                  if(i == argc + -1)
                                                  {
                                                    fprintf(stderr, "Error: --psk argument given but no key specified.\n\n");
                                                    return 1;
                                                  }

                                                  else
                                                    cfg->psk=strdup(argv[(signed long int)(i + 1)]);
                                                  i = i + 1;
                                                }

                                                else
                                                {
                                                  return_value_strcmp_52=strcmp(argv[(signed long int)i], "--psk-identity");
                                                  if(return_value_strcmp_52 == 0)
                                                  {
                                                    if(i == argc + -1)
                                                    {
                                                      fprintf(stderr, "Error: --psk-identity argument given but no identity specified.\n\n");
                                                      return 1;
                                                    }

                                                    else
                                                      cfg->psk_identity=strdup(argv[(signed long int)(i + 1)]);
                                                    i = i + 1;
                                                  }

                                                  else
                                                  {
                                                    return_value_strcmp_49=strcmp(argv[(signed long int)i], "-q");
                                                    if(return_value_strcmp_49 == 0)
                                                      tmp_if_expr_51 = (_Bool)1;

                                                    else
                                                    {
                                                      return_value_strcmp_50=strcmp(argv[(signed long int)i], "--qos");
                                                      tmp_if_expr_51 = !(return_value_strcmp_50 != 0) ? (_Bool)1 : (_Bool)0;
                                                    }
                                                    if(tmp_if_expr_51)
                                                    {
                                                      if(i == argc + -1)
                                                      {
                                                        fprintf(stderr, "Error: -q argument given but no QoS specified.\n\n");
                                                        return 1;
                                                      }

                                                      else
                                                      {
                                                        cfg->qos=atoi(argv[(signed long int)(i + 1)]);
                                                        if(!(cfg->qos >= 0))
                                                          tmp_if_expr_7 = (_Bool)1;

                                                        else
                                                          tmp_if_expr_7 = cfg->qos > 2 ? (_Bool)1 : (_Bool)0;
                                                        if(tmp_if_expr_7)
                                                        {
                                                          fprintf(stderr, "Error: Invalid QoS given: %d\n", cfg->qos);
                                                          return 1;
                                                        }

                                                      }
                                                      i = i + 1;
                                                    }

                                                    else
                                                    {
                                                      return_value_strcmp_48=strcmp(argv[(signed long int)i], "--quiet");
                                                      if(return_value_strcmp_48 == 0)
                                                        cfg->quiet = (_Bool)1;

                                                      else
                                                      {
                                                        return_value_strcmp_45=strcmp(argv[(signed long int)i], "-r");
                                                        if(return_value_strcmp_45 == 0)
                                                          tmp_if_expr_47 = (_Bool)1;

                                                        else
                                                        {
                                                          return_value_strcmp_46=strcmp(argv[(signed long int)i], "--retain");
                                                          tmp_if_expr_47 = !(return_value_strcmp_46 != 0) ? (_Bool)1 : (_Bool)0;
                                                        }
                                                        if(tmp_if_expr_47)
                                                        {
                                                          if(pub_or_sub == 2)
                                                            goto unknown_option;

                                                          cfg->retain = (_Bool)1;
                                                        }

                                                        else
                                                        {
                                                          return_value_strcmp_42=strcmp(argv[(signed long int)i], "-s");
                                                          if(return_value_strcmp_42 == 0)
                                                            tmp_if_expr_44 = (_Bool)1;

                                                          else
                                                          {
                                                            return_value_strcmp_43=strcmp(argv[(signed long int)i], "--stdin-file");
                                                            tmp_if_expr_44 = !(return_value_strcmp_43 != 0) ? (_Bool)1 : (_Bool)0;
                                                          }
                                                          if(tmp_if_expr_44)
                                                          {
                                                            if(pub_or_sub == 2)
                                                              goto unknown_option;

                                                            if(!(cfg->pub_mode == 0))
                                                            {
                                                              fprintf(stderr, "Error: Only one type of message can be sent at once.\n\n");
                                                              return 1;
                                                            }

                                                            else
                                                              cfg->pub_mode = 3;
                                                          }

                                                          else
                                                          {
                                                            return_value_strcmp_41=strcmp(argv[(signed long int)i], "-S");
                                                            if(return_value_strcmp_41 == 0)
                                                              cfg->use_srv = (_Bool)1;

                                                            else
                                                            {
                                                              return_value_strcmp_38=strcmp(argv[(signed long int)i], "-t");
                                                              if(return_value_strcmp_38 == 0)
                                                                tmp_if_expr_40 = (_Bool)1;

                                                              else
                                                              {
                                                                return_value_strcmp_39=strcmp(argv[(signed long int)i], "--topic");
                                                                tmp_if_expr_40 = !(return_value_strcmp_39 != 0) ? (_Bool)1 : (_Bool)0;
                                                              }
                                                              if(tmp_if_expr_40)
                                                              {
                                                                if(i == argc + -1)
                                                                {
                                                                  fprintf(stderr, "Error: -t argument given but no topic specified.\n\n");
                                                                  return 1;
                                                                }

                                                                else
                                                                {
                                                                  if(pub_or_sub == 1)
                                                                  {
                                                                    signed int return_value_mosquitto_pub_topic_check_8;
                                                                    return_value_mosquitto_pub_topic_check_8=mosquitto_pub_topic_check(argv[(signed long int)(i + 1)]);
                                                                    if(return_value_mosquitto_pub_topic_check_8 == 3)
                                                                    {
                                                                      fprintf(stderr, "Error: Invalid publish topic '%s', does it contain '+' or '#'?\n", argv[(signed long int)(i + 1)]);
                                                                      return 1;
                                                                    }

                                                                    cfg->topic=strdup(argv[(signed long int)(i + 1)]);
                                                                  }

                                                                  else
                                                                  {
                                                                    signed int return_value_mosquitto_sub_topic_check_9;
                                                                    return_value_mosquitto_sub_topic_check_9=mosquitto_sub_topic_check(argv[(signed long int)(i + 1)]);
                                                                    if(return_value_mosquitto_sub_topic_check_9 == 3)
                                                                    {
                                                                      fprintf(stderr, "Error: Invalid subscription topic '%s', are all '+' and '#' wildcards correct?\n", argv[(signed long int)(i + 1)]);
                                                                      return 1;
                                                                    }

                                                                    cfg->topic_count = cfg->topic_count + 1;
                                                                    void *return_value_realloc_10;
                                                                    return_value_realloc_10=realloc((void *)cfg->topics, (unsigned long int)cfg->topic_count * sizeof(char *) /*8ul*/ );
                                                                    cfg->topics = (char **)return_value_realloc_10;
                                                                    cfg->topics[(signed long int)(cfg->topic_count - 1)]=strdup(argv[(signed long int)(i + 1)]);
                                                                  }
                                                                  i = i + 1;
                                                                }
                                                              }

                                                              else
                                                              {
                                                                return_value_strcmp_35=strcmp(argv[(signed long int)i], "-T");
                                                                if(return_value_strcmp_35 == 0)
                                                                  tmp_if_expr_37 = (_Bool)1;

                                                                else
                                                                {
                                                                  return_value_strcmp_36=strcmp(argv[(signed long int)i], "--filter-out");
                                                                  tmp_if_expr_37 = !(return_value_strcmp_36 != 0) ? (_Bool)1 : (_Bool)0;
                                                                }
                                                                if(tmp_if_expr_37)
                                                                {
                                                                  if(pub_or_sub == 1)
                                                                    goto unknown_option;

                                                                  if(i == argc + -1)
                                                                  {
                                                                    fprintf(stderr, "Error: -T argument given but no topic filter specified.\n\n");
                                                                    return 1;
                                                                  }

                                                                  else
                                                                  {
                                                                    signed int return_value_mosquitto_sub_topic_check_11;
                                                                    return_value_mosquitto_sub_topic_check_11=mosquitto_sub_topic_check(argv[(signed long int)(i + 1)]);
                                                                    if(return_value_mosquitto_sub_topic_check_11 == 3)
                                                                    {
                                                                      fprintf(stderr, "Error: Invalid filter topic '%s', are all '+' and '#' wildcards correct?\n", argv[(signed long int)(i + 1)]);
                                                                      return 1;
                                                                    }

                                                                    cfg->filter_out_count = cfg->filter_out_count + 1;
                                                                    void *return_value_realloc_12;
                                                                    return_value_realloc_12=realloc((void *)cfg->filter_outs, (unsigned long int)cfg->filter_out_count * sizeof(char *) /*8ul*/ );
                                                                    cfg->filter_outs = (char **)return_value_realloc_12;
                                                                    cfg->filter_outs[(signed long int)(cfg->filter_out_count - 1)]=strdup(argv[(signed long int)(i + 1)]);
                                                                  }
                                                                  i = i + 1;
                                                                }

                                                                else
                                                                {
                                                                  return_value_strcmp_34=strcmp(argv[(signed long int)i], "--tls-version");
                                                                  if(return_value_strcmp_34 == 0)
                                                                  {
                                                                    if(i == argc + -1)
                                                                    {
                                                                      fprintf(stderr, "Error: --tls-version argument given but no version specified.\n\n");
                                                                      return 1;
                                                                    }

                                                                    else
                                                                      cfg->tls_version=strdup(argv[(signed long int)(i + 1)]);
                                                                    i = i + 1;
                                                                  }

                                                                  else
                                                                  {
                                                                    return_value_strcmp_31=strcmp(argv[(signed long int)i], "-u");
                                                                    if(return_value_strcmp_31 == 0)
                                                                      tmp_if_expr_33 = (_Bool)1;

                                                                    else
                                                                    {
                                                                      return_value_strcmp_32=strcmp(argv[(signed long int)i], "--username");
                                                                      tmp_if_expr_33 = !(return_value_strcmp_32 != 0) ? (_Bool)1 : (_Bool)0;
                                                                    }
                                                                    if(tmp_if_expr_33)
                                                                    {
                                                                      if(i == argc + -1)
                                                                      {
                                                                        fprintf(stderr, "Error: -u argument given but no username specified.\n\n");
                                                                        return 1;
                                                                      }

                                                                      else
                                                                        cfg->username=strdup(argv[(signed long int)(i + 1)]);
                                                                      i = i + 1;
                                                                    }

                                                                    else
                                                                    {
                                                                      return_value_strcmp_28=strcmp(argv[(signed long int)i], "-P");
                                                                      if(return_value_strcmp_28 == 0)
                                                                        tmp_if_expr_30 = (_Bool)1;

                                                                      else
                                                                      {
                                                                        return_value_strcmp_29=strcmp(argv[(signed long int)i], "--pw");
                                                                        tmp_if_expr_30 = !(return_value_strcmp_29 != 0) ? (_Bool)1 : (_Bool)0;
                                                                      }
                                                                      if(tmp_if_expr_30)
                                                                      {
                                                                        if(i == argc + -1)
                                                                        {
                                                                          fprintf(stderr, "Error: -P argument given but no password specified.\n\n");
                                                                          return 1;
                                                                        }

                                                                        else
                                                                          cfg->password=strdup(argv[(signed long int)(i + 1)]);
                                                                        i = i + 1;
                                                                      }

                                                                      else
                                                                      {
                                                                        return_value_strcmp_27=strcmp(argv[(signed long int)i], "--will-payload");
                                                                        if(return_value_strcmp_27 == 0)
                                                                        {
                                                                          if(i == argc + -1)
                                                                          {
                                                                            fprintf(stderr, "Error: --will-payload argument given but no will payload specified.\n\n");
                                                                            return 1;
                                                                          }

                                                                          else
                                                                          {
                                                                            cfg->will_payload=strdup(argv[(signed long int)(i + 1)]);
                                                                            unsigned long int return_value_strlen_13;
                                                                            return_value_strlen_13=strlen(cfg->will_payload);
                                                                            cfg->will_payloadlen = (signed long int)return_value_strlen_13;
                                                                          }
                                                                          i = i + 1;
                                                                        }

                                                                        else
                                                                        {
                                                                          return_value_strcmp_26=strcmp(argv[(signed long int)i], "--will-qos");
                                                                          if(return_value_strcmp_26 == 0)
                                                                          {
                                                                            if(i == argc + -1)
                                                                            {
                                                                              fprintf(stderr, "Error: --will-qos argument given but no will QoS specified.\n\n");
                                                                              return 1;
                                                                            }

                                                                            else
                                                                            {
                                                                              cfg->will_qos=atoi(argv[(signed long int)(i + 1)]);
                                                                              if(!(cfg->will_qos >= 0))
                                                                                tmp_if_expr_14 = (_Bool)1;

                                                                              else
                                                                                tmp_if_expr_14 = cfg->will_qos > 2 ? (_Bool)1 : (_Bool)0;
                                                                              if(tmp_if_expr_14)
                                                                              {
                                                                                fprintf(stderr, "Error: Invalid will QoS %d.\n\n", cfg->will_qos);
                                                                                return 1;
                                                                              }

                                                                            }
                                                                            i = i + 1;
                                                                          }

                                                                          else
                                                                          {
                                                                            return_value_strcmp_25=strcmp(argv[(signed long int)i], "--will-retain");
                                                                            if(return_value_strcmp_25 == 0)
                                                                              cfg->will_retain = (_Bool)1;

                                                                            else
                                                                            {
                                                                              return_value_strcmp_24=strcmp(argv[(signed long int)i], "--will-topic");
                                                                              if(return_value_strcmp_24 == 0)
                                                                              {
                                                                                if(i == argc + -1)
                                                                                {
                                                                                  fprintf(stderr, "Error: --will-topic argument given but no will topic specified.\n\n");
                                                                                  return 1;
                                                                                }

                                                                                else
                                                                                {
                                                                                  signed int return_value_mosquitto_pub_topic_check_15;
                                                                                  return_value_mosquitto_pub_topic_check_15=mosquitto_pub_topic_check(argv[(signed long int)(i + 1)]);
                                                                                  if(return_value_mosquitto_pub_topic_check_15 == 3)
                                                                                  {
                                                                                    fprintf(stderr, "Error: Invalid will topic '%s', does it contain '+' or '#'?\n", argv[(signed long int)(i + 1)]);
                                                                                    return 1;
                                                                                  }

                                                                                  cfg->will_topic=strdup(argv[(signed long int)(i + 1)]);
                                                                                }
                                                                                i = i + 1;
                                                                              }

                                                                              else
                                                                              {
                                                                                return_value_strcmp_21=strcmp(argv[(signed long int)i], "-c");
                                                                                if(return_value_strcmp_21 == 0)
                                                                                  tmp_if_expr_23 = (_Bool)1;

                                                                                else
                                                                                {
                                                                                  return_value_strcmp_22=strcmp(argv[(signed long int)i], "--disable-clean-session");
                                                                                  tmp_if_expr_23 = !(return_value_strcmp_22 != 0) ? (_Bool)1 : (_Bool)0;
                                                                                }
                                                                                if(tmp_if_expr_23)
                                                                                {
                                                                                  if(pub_or_sub == 1)
                                                                                    goto unknown_option;

                                                                                  cfg->clean_session = (_Bool)0;
                                                                                }

                                                                                else
                                                                                {
                                                                                  return_value_strcmp_20=strcmp(argv[(signed long int)i], "-N");
                                                                                  if(return_value_strcmp_20 == 0)
                                                                                  {
                                                                                    if(pub_or_sub == 1)
                                                                                      goto unknown_option;

                                                                                    cfg->eol = (_Bool)0;
                                                                                  }

                                                                                  else
                                                                                  {
                                                                                    return_value_strcmp_19=strcmp(argv[(signed long int)i], "-R");
                                                                                    if(return_value_strcmp_19 == 0)
                                                                                    {
                                                                                      if(pub_or_sub == 1)
                                                                                        goto unknown_option;

                                                                                      cfg->no_retain = (_Bool)1;
                                                                                    }

                                                                                    else
                                                                                    {
                                                                                      return_value_strcmp_16=strcmp(argv[(signed long int)i], "-v");
                                                                                      if(return_value_strcmp_16 == 0)
                                                                                        tmp_if_expr_18 = (_Bool)1;

                                                                                      else
                                                                                      {
                                                                                        return_value_strcmp_17=strcmp(argv[(signed long int)i], "--verbose");
                                                                                        tmp_if_expr_18 = !(return_value_strcmp_17 != 0) ? (_Bool)1 : (_Bool)0;
                                                                                      }
                                                                                      if(tmp_if_expr_18)
                                                                                      {
                                                                                        if(pub_or_sub == 1)
                                                                                          goto unknown_option;

                                                                                        cfg->verbose = (_Bool)1;
                                                                                      }

                                                                                      else
                                                                                        goto unknown_option;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;

unknown_option:
  ;
  fprintf(stderr, "Error: Unknown option '%s'.\n", argv[(signed long int)i]);
  return 1;
}

// client_config_load
// file client_shared.h line 91
signed int client_config_load(struct mosq_config *cfg, signed int pub_or_sub, signed int argc, char **argv)
{
  signed int rc;
  struct _IO_FILE *fptr;
  char line[1024l];
  signed int count;
  char *loc = (char *)(void *)0;
  signed int len;
  char *args[3l];
  char *env;
  args[(signed long int)0] = (char *)(void *)0;
  init_config(cfg);
  env=getenv("XDG_CONFIG_HOME");
  if(!(env == ((char *)NULL)))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(env);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen("/mosquitto_pub");
    len = (signed int)(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)1);
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)len);
    loc = (char *)return_value_malloc_3;
    if(pub_or_sub == 1)
      snprintf(loc, (unsigned long int)len, "%s/mosquitto_pub", env);

    else
      snprintf(loc, (unsigned long int)len, "%s/mosquitto_sub", env);
    loc[(signed long int)(len - 1)] = (char)0;
  }

  else
  {
    env=getenv("HOME");
    if(!(env == ((char *)NULL)))
    {
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(env);
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen("/.config/mosquitto_pub");
      len = (signed int)(return_value_strlen_4 + return_value_strlen_5 + (unsigned long int)1);
      void *return_value_malloc_6;
      return_value_malloc_6=malloc((unsigned long int)len);
      loc = (char *)return_value_malloc_6;
      if(pub_or_sub == 1)
        snprintf(loc, (unsigned long int)len, "%s/.config/mosquitto_pub", env);

      else
        snprintf(loc, (unsigned long int)len, "%s/.config/mosquitto_sub", env);
      loc[(signed long int)(len - 1)] = (char)0;
    }

    else
      fprintf(stderr, "Warning: Unable to locate configuration directory, default config not loaded.\n");
  }
  char *return_value_fgets_7;
  unsigned long int return_value_strlen_8;
  unsigned long int return_value_strlen_9;
  if(!(loc == ((char *)NULL)))
  {
    fptr=fopen(loc, "rt");
    if(!(fptr == ((struct _IO_FILE *)NULL)))
    {
      do
      {
        return_value_fgets_7=fgets(line, 1024, fptr);
        if(return_value_fgets_7 == ((char *)NULL))
          break;

        if(!((signed int)line[0l] == 35))
        {
          do
          {
            return_value_strlen_8=strlen(line);
            if(!((signed int)line[-1l + (signed long int)return_value_strlen_8] == 10))
            {
              return_value_strlen_9=strlen(line);
              if(!((signed int)line[-1l + (signed long int)return_value_strlen_9] == 13))
                break;

            }

            unsigned long int return_value_strlen_10;
            return_value_strlen_10=strlen(line);
            line[(signed long int)(return_value_strlen_10 - (unsigned long int)1)] = (char)0;
          }
          while((_Bool)1);
          args[(signed long int)1]=strtok(line, " ");
          if(!(args[1l] == ((char *)NULL)))
          {
            args[(signed long int)2]=strtok((char *)(void *)0, " ");
            if(!(args[2l] == ((char *)NULL)))
              count = 3;

            else
              count = 2;
            rc=client_config_line_proc(cfg, pub_or_sub, count, args);
            if(!(rc == 0))
            {
              fclose(fptr);
              free((void *)loc);
              return rc;
            }

          }

        }

      }
      while((_Bool)1);
      fclose(fptr);
    }

    free((void *)loc);
  }

  rc=client_config_line_proc(cfg, pub_or_sub, argc, argv);
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_15;
  if(!(rc == 0))
    return rc;

  else
    if(!(cfg->will_payload == ((char *)NULL)))
    {
      if(!(cfg->will_topic == ((char *)NULL)))
        goto __CPROVER_DUMP_L20;

      fprintf(stderr, "Error: Will payload given, but no will topic given.\n");
      return 1;
    }

    else
    {

    __CPROVER_DUMP_L20:
      ;
      if(!(cfg->will_retain == (_Bool)0))
      {
        if(!(cfg->will_topic == ((char *)NULL)))
          goto __CPROVER_DUMP_L21;

        fprintf(stderr, "Error: Will retain given, but no will topic given.\n");
        return 1;
      }

      else
      {

      __CPROVER_DUMP_L21:
        ;
        if(!(cfg->password == ((char *)NULL)))
        {
          if(cfg->username == ((char *)NULL))
          {
            if(cfg->quiet == (_Bool)0)
              fprintf(stderr, "Warning: Not using password since username not set.\n");

          }

        }

        if(!(cfg->certfile == ((char *)NULL)))
          tmp_if_expr_11 = !(cfg->keyfile != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_11 = (_Bool)0;
        if(tmp_if_expr_11)
          tmp_if_expr_13 = (_Bool)1;

        else
        {
          if(!(cfg->keyfile == ((char *)NULL)))
            tmp_if_expr_12 = !(cfg->certfile != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_12 = (_Bool)0;
          tmp_if_expr_13 = tmp_if_expr_12 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_13)
        {
          fprintf(stderr, "Error: Both certfile and keyfile must be provided if one of them is.\n");
          return 1;
        }

        else
        {
          if(!(cfg->cafile == ((char *)NULL)))
            tmp_if_expr_14 = (_Bool)1;

          else
            tmp_if_expr_14 = cfg->capath != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_14)
          {
            if(cfg->psk == ((char *)NULL))
              goto __CPROVER_DUMP_L33;

            if(cfg->quiet == (_Bool)0)
              fprintf(stderr, "Error: Only one of --psk or --cafile/--capath may be used at once.\n");

            return 1;
          }

          else
          {

          __CPROVER_DUMP_L33:
            ;
            if(!(cfg->psk == ((char *)NULL)))
            {
              if(!(cfg->psk_identity == ((char *)NULL)))
                goto __CPROVER_DUMP_L35;

              if(cfg->quiet == (_Bool)0)
                fprintf(stderr, "Error: --psk-identity required if --psk used.\n");

              return 1;
            }

            else
            {

            __CPROVER_DUMP_L35:
              ;
              if(pub_or_sub == 2)
              {
                if((signed int)cfg->clean_session == 0)
                {
                  if(!(cfg->id_prefix == ((char *)NULL)))
                    tmp_if_expr_15 = (_Bool)1;

                  else
                    tmp_if_expr_15 = !(cfg->id != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_15)
                  {
                    if(cfg->quiet == (_Bool)0)
                      fprintf(stderr, "Error: You must provide a client id if you are using the -c option.\n");

                    return 1;
                  }

                }

                if(!(cfg->topic_count == 0))
                  goto __CPROVER_DUMP_L41;

                if(cfg->quiet == (_Bool)0)
                  fprintf(stderr, "Error: You must specify a topic to subscribe to.\n");

                return 1;
              }

              else
              {

              __CPROVER_DUMP_L41:
                ;
                if(cfg->host == ((char *)NULL))
                  cfg->host = "localhost";

                return 0;
              }
            }
          }
        }
      }
    }
}

// client_connect
// file client_shared.h line 95
signed int client_connect(struct mosquitto *mosq, struct mosq_config *cfg)
{
  char err[1024l];
  signed int rc;
  if(!(cfg->use_srv == (_Bool)0))
    rc=mosquitto_connect_srv(mosq, cfg->host, cfg->keepalive, cfg->bind_address);

  else
    rc=mosquitto_connect_bind(mosq, cfg->host, cfg->port, cfg->keepalive, cfg->bind_address);
  if(rc >= 1)
  {
    if(cfg->quiet == (_Bool)0)
    {
      if(rc == 14)
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        strerror_r(*return_value___errno_location_1, err, (unsigned long int)1024);
        fprintf(stderr, "Error: %s\n", (const void *)err);
      }

      else
      {
        const char *return_value_mosquitto_strerror_2;
        return_value_mosquitto_strerror_2=mosquitto_strerror(rc);
        fprintf(stderr, "Unable to connect (%s).\n", return_value_mosquitto_strerror_2);
      }
    }

    mosquitto_lib_cleanup();
    return rc;
  }

  else
    return 0;
}

// client_id_generate
// file client_shared.h line 94
signed int client_id_generate(struct mosq_config *cfg, const char *id_base)
{
  signed int len;
  char hostname[256l];
  if(!(cfg->id_prefix == ((char *)NULL)))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(cfg->id_prefix);
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)10);
    cfg->id = (char *)return_value_malloc_2;
    if(cfg->id == ((char *)NULL))
    {
      if(cfg->quiet == (_Bool)0)
        fprintf(stderr, "Error: Out of memory.\n");

      mosquitto_lib_cleanup();
      return 1;
    }

    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(cfg->id_prefix);
    signed int return_value_getpid_4;
    return_value_getpid_4=getpid();
    snprintf(cfg->id, return_value_strlen_3 + (unsigned long int)10, "%s%d", cfg->id_prefix, return_value_getpid_4);
  }

  else
    if(cfg->id == ((char *)NULL))
    {
      hostname[(signed long int)0] = (char)0;
      gethostname(hostname, (unsigned long int)256);
      hostname[(signed long int)255] = (char)0;
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(id_base);
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen("/-");
      unsigned long int return_value_strlen_7;
      return_value_strlen_7=strlen(hostname);
      len = (signed int)(return_value_strlen_5 + return_value_strlen_6 + (unsigned long int)6 + return_value_strlen_7);
      void *return_value_malloc_8;
      return_value_malloc_8=malloc((unsigned long int)len);
      cfg->id = (char *)return_value_malloc_8;
      if(cfg->id == ((char *)NULL))
      {
        if(cfg->quiet == (_Bool)0)
          fprintf(stderr, "Error: Out of memory.\n");

        mosquitto_lib_cleanup();
        return 1;
      }

      signed int return_value_getpid_9;
      return_value_getpid_9=getpid();
      snprintf(cfg->id, (unsigned long int)len, "%s/%d-%s", id_base, return_value_getpid_9, (const void *)hostname);
      unsigned long int return_value_strlen_10;
      return_value_strlen_10=strlen(cfg->id);
      if(return_value_strlen_10 >= 24ul)
        cfg->id[(signed long int)23] = (char)0;

    }

  return 0;
}

// client_opts_set
// file client_shared.h line 93
signed int client_opts_set(struct mosquitto *mosq, struct mosq_config *cfg)
{
  signed int rc;
  signed int return_value_mosquitto_will_set_1;
  signed int return_value_mosquitto_username_pw_set_2;
  _Bool tmp_if_expr_4;
  signed int return_value_mosquitto_tls_set_3;
  signed int return_value_mosquitto_tls_insecure_set_5;
  signed int return_value_mosquitto_tls_psk_set_6;
  signed int return_value_mosquitto_tls_opts_set_7;
  if(!(cfg->will_topic == ((char *)NULL)))
  {
    return_value_mosquitto_will_set_1=mosquitto_will_set(mosq, cfg->will_topic, (signed int)cfg->will_payloadlen, (const void *)cfg->will_payload, cfg->will_qos, cfg->will_retain);
    if(return_value_mosquitto_will_set_1 == 0)
      goto __CPROVER_DUMP_L2;

    if(cfg->quiet == (_Bool)0)
      fprintf(stderr, "Error: Problem setting will.\n");

    mosquitto_lib_cleanup();
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(!(cfg->username == ((char *)NULL)))
    {
      return_value_mosquitto_username_pw_set_2=mosquitto_username_pw_set(mosq, cfg->username, cfg->password);
      if(return_value_mosquitto_username_pw_set_2 == 0)
        goto __CPROVER_DUMP_L4;

      if(cfg->quiet == (_Bool)0)
        fprintf(stderr, "Error: Problem setting username and password.\n");

      mosquitto_lib_cleanup();
      return 1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      if(!(cfg->cafile == ((char *)NULL)))
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = cfg->capath != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
      {
        return_value_mosquitto_tls_set_3=mosquitto_tls_set(mosq, cfg->cafile, cfg->capath, cfg->certfile, cfg->keyfile, (signed int (*)(char *, signed int, signed int, void *))(void *)0);
        if(return_value_mosquitto_tls_set_3 == 0)
          goto __CPROVER_DUMP_L8;

        if(cfg->quiet == (_Bool)0)
          fprintf(stderr, "Error: Problem setting TLS options.\n");

        mosquitto_lib_cleanup();
        return 1;
      }

      else
      {

      __CPROVER_DUMP_L8:
        ;
        if(!(cfg->insecure == (_Bool)0))
        {
          return_value_mosquitto_tls_insecure_set_5=mosquitto_tls_insecure_set(mosq, (_Bool)1);
          if(return_value_mosquitto_tls_insecure_set_5 == 0)
            goto __CPROVER_DUMP_L10;

          if(cfg->quiet == (_Bool)0)
            fprintf(stderr, "Error: Problem setting TLS insecure option.\n");

          mosquitto_lib_cleanup();
          return 1;
        }

        else
        {

        __CPROVER_DUMP_L10:
          ;
          if(!(cfg->psk == ((char *)NULL)))
          {
            return_value_mosquitto_tls_psk_set_6=mosquitto_tls_psk_set(mosq, cfg->psk, cfg->psk_identity, (const char *)(void *)0);
            if(return_value_mosquitto_tls_psk_set_6 == 0)
              goto __CPROVER_DUMP_L12;

            if(cfg->quiet == (_Bool)0)
              fprintf(stderr, "Error: Problem setting TLS-PSK options.\n");

            mosquitto_lib_cleanup();
            return 1;
          }

          else
          {

          __CPROVER_DUMP_L12:
            ;
            if(!(cfg->tls_version == ((char *)NULL)))
            {
              return_value_mosquitto_tls_opts_set_7=mosquitto_tls_opts_set(mosq, 1, cfg->tls_version, cfg->ciphers);
              if(return_value_mosquitto_tls_opts_set_7 == 0)
                goto __CPROVER_DUMP_L14;

              if(cfg->quiet == (_Bool)0)
                fprintf(stderr, "Error: Problem setting TLS options.\n");

              mosquitto_lib_cleanup();
              return 1;
            }

            else
            {

            __CPROVER_DUMP_L14:
              ;
              mosquitto_max_inflight_messages_set(mosq, cfg->max_inflight);
              if(!(cfg->socks5_host == ((char *)NULL)))
              {
                rc=mosquitto_socks5_set(mosq, cfg->socks5_host, cfg->socks5_port, cfg->socks5_username, cfg->socks5_password);
                if(rc == 0)
                  goto __CPROVER_DUMP_L15;

                mosquitto_lib_cleanup();
                return rc;
              }

              else
              {

              __CPROVER_DUMP_L15:
                ;
                mosquitto_opts_set(mosq, (enum mosq_opt_t)MOSQ_OPT_PROTOCOL_VERSION, (void *)&cfg->protocol_version);
                return 0;
              }
            }
          }
        }
      }
    }
  }
}

// init_config
// file client_shared.c line 37
void init_config(struct mosq_config *cfg)
{
  memset((void *)cfg, 0, sizeof(struct mosq_config) /*296ul*/ );
  cfg->port = 1883;
  cfg->max_inflight = (unsigned int)20;
  cfg->keepalive = 60;
  cfg->clean_session = (_Bool)1;
  cfg->eol = (_Bool)1;
  cfg->protocol_version = 3;
}

// load_file
// file pub_client.c line 159
signed int load_file(const char *filename)
{
  signed long int pos;
  signed long int rlen;
  struct _IO_FILE *fptr = (struct _IO_FILE *)(void *)0;
  fptr=fopen(filename, "rb");
  if(fptr == ((struct _IO_FILE *)NULL))
  {
    if(quiet == (_Bool)0)
      fprintf(stderr, "Error: Unable to open file \"%s\".\n", filename);

    return 1;
  }

  else
  {
    mode = 4;
    fseek(fptr, (signed long int)0, 2);
    msglen=ftell(fptr);
    if(msglen >= 268435456l)
    {
      fclose(fptr);
      if(quiet == (_Bool)0)
        fprintf(stderr, "Error: File \"%s\" is too large (>268,435,455 bytes).\n", filename);

      return 1;
    }

    else
      if(msglen == 0l)
      {
        fclose(fptr);
        if(quiet == (_Bool)0)
          fprintf(stderr, "Error: File \"%s\" is empty.\n", filename);

        return 1;
      }

      else
        if(!(msglen >= 0l))
        {
          fclose(fptr);
          if(quiet == (_Bool)0)
            fprintf(stderr, "Error: Unable to determine size of file \"%s\".\n", filename);

          return 1;
        }

    fseek(fptr, (signed long int)0, 0);
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)msglen);
    message = (char *)return_value_malloc_1;
    if(message == ((char *)NULL))
    {
      fclose(fptr);
      if(quiet == (_Bool)0)
        fprintf(stderr, "Error: Out of memory.\n");

      return 1;
    }

    else
    {
      pos = (signed long int)0;
      while(!(pos >= msglen))
      {
        unsigned long int return_value_fread_2;
        return_value_fread_2=fread((void *)&message[pos], sizeof(char) /*1ul*/ , (unsigned long int)(msglen - pos), fptr);
        rlen = (signed long int)return_value_fread_2;
        pos = pos + rlen;
      }
      fclose(fptr);
      return 0;
    }
  }
}

// load_stdin
// file pub_client.c line 127
signed int load_stdin(void)
{
  signed long int pos = (signed long int)0;
  signed long int rlen;
  char buf[1024l];
  char *aux_message = (char *)(void *)0;
  mode = 3;
  signed int return_value_feof_1;
  do
  {
    return_value_feof_1=feof(stdin);
    if(!(return_value_feof_1 == 0))
      break;

    unsigned long int return_value_fread_2;
    return_value_fread_2=fread((void *)buf, (unsigned long int)1, (unsigned long int)1024, stdin);
    rlen = (signed long int)return_value_fread_2;
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)message, (unsigned long int)(pos + rlen));
    aux_message = (char *)return_value_realloc_3;
    if(aux_message == ((char *)NULL))
    {
      if(quiet == (_Bool)0)
        fprintf(stderr, "Error: Out of memory.\n");

      free((void *)message);
      return 1;
    }

    else
      message = aux_message;
    memcpy((void *)&message[pos], (const void *)buf, (unsigned long int)rlen);
    pos = pos + rlen;
  }
  while((_Bool)1);
  msglen = pos;
  if(msglen == 0l)
  {
    if(quiet == (_Bool)0)
      fprintf(stderr, "Error: Zero length input.\n");

    return 1;
  }

  else
    return 0;
}

// main
// file pub_client.c line 290
signed int main(signed int argc, char **argv)
{
  struct mosq_config cfg;
  struct mosquitto *mosq = (struct mosquitto *)(void *)0;
  signed int rc;
  signed int rc2;
  char *buf;
  signed int buf_len = 1024;
  signed int buf_len_actual;
  signed int read_len;
  signed int pos;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)buf_len);
  buf = (char *)return_value_malloc_1;
  char *return_value_fgets_7;
  if(buf == ((char *)NULL))
  {
    fprintf(stderr, "Error: Out of memory.\n");
    return 1;
  }

  else
  {
    memset((void *)&cfg, 0, sizeof(struct mosq_config) /*296ul*/ );
    rc=client_config_load(&cfg, 1, argc, argv);
    if(!(rc == 0))
    {
      client_config_cleanup(&cfg);
      if(rc == 2)
        print_usage();

      else
        fprintf(stderr, "\nUse 'mosquitto_pub --help' to see usage.\n");
      return 1;
    }

    else
    {
      topic = cfg.topic;
      message = cfg.message;
      msglen = cfg.msglen;
      qos = cfg.qos;
      retain = (signed int)cfg.retain;
      mode = cfg.pub_mode;
      username = cfg.username;
      password = cfg.password;
      quiet = cfg.quiet;
      if(cfg.pub_mode == 3)
      {
        signed int return_value_load_stdin_2;
        return_value_load_stdin_2=load_stdin();
        if(!(return_value_load_stdin_2 == 0))
        {
          fprintf(stderr, "Error loading input from stdin.\n");
          return 1;
        }

      }

      else
        if(!(cfg.file_input == ((char *)NULL)))
        {
          signed int return_value_load_file_3;
          return_value_load_file_3=load_file(cfg.file_input);
          if(!(return_value_load_file_3 == 0))
          {
            fprintf(stderr, "Error loading input file \"%s\".\n", cfg.file_input);
            return 1;
          }

        }

      if(topic == ((char *)NULL) || mode == 0)
      {
        fprintf(stderr, "Error: Both topic and message must be supplied.\n");
        print_usage();
        return 1;
      }

      else
      {
        mosquitto_lib_init();
        signed int return_value_client_id_generate_4;
        return_value_client_id_generate_4=client_id_generate(&cfg, "mosqpub");
        if(!(return_value_client_id_generate_4 == 0))
          return 1;

        else
        {
          mosq=mosquitto_new(cfg.id, (_Bool)1, (void *)0);
          if(mosq == ((struct mosquitto *)NULL))
          {
            signed int *return_value___errno_location_5;
            return_value___errno_location_5=__errno_location();
            switch(*return_value___errno_location_5)
            {
              case 12:
              {
                if(quiet == (_Bool)0)
                  fprintf(stderr, "Error: Out of memory.\n");

                break;
              }
              case 22:
                if(quiet == (_Bool)0)
                  fprintf(stderr, "Error: Invalid id.\n");

            }
            mosquitto_lib_cleanup();
            return 1;
          }

          if(!(cfg.debug == (_Bool)0))
            mosquitto_log_callback_set(mosq, my_log_callback);

          mosquitto_connect_callback_set(mosq, my_connect_callback);
          mosquitto_disconnect_callback_set(mosq, my_disconnect_callback);
          mosquitto_publish_callback_set(mosq, my_publish_callback);
          signed int return_value_client_opts_set_6;
          return_value_client_opts_set_6=client_opts_set(mosq, &cfg);
          if(!(return_value_client_opts_set_6 == 0))
            return 1;

          else
          {
            rc=client_connect(mosq, &cfg);
            if(!(rc == 0))
              return rc;

            else
            {
              if(mode == 2)
                mosquitto_loop_start(mosq);

              while((_Bool)1)
              {
                if(mode == 2)
                {
                  if(status == 1)
                  {
                    pos = 0;
                    read_len = buf_len;
                    do
                    {
                      return_value_fgets_7=fgets(&buf[(signed long int)pos], read_len, stdin);
                      if(return_value_fgets_7 == ((char *)NULL))
                        break;

                      unsigned long int return_value_strlen_8;
                      return_value_strlen_8=strlen(buf);
                      buf_len_actual = (signed int)return_value_strlen_8;
                      if((signed int)buf[(signed long int)(buf_len_actual + -1)] == 10)
                      {
                        buf[(signed long int)(buf_len_actual - 1)] = (char)0;
                        rc2=mosquitto_publish(mosq, &mid_sent, topic, buf_len_actual - 1, (const void *)buf, qos, (_Bool)retain);
                        if(!(rc2 == 0))
                        {
                          if(quiet == (_Bool)0)
                            fprintf(stderr, "Error: Publish returned %d, disconnecting.\n", rc2);

                          mosquitto_disconnect(mosq);
                        }

                        break;
                      }

                      else
                      {
                        buf_len = buf_len + 1024;
                        pos = pos + 1023;
                        read_len = 1024;
                        void *return_value_realloc_9;
                        return_value_realloc_9=realloc((void *)buf, (unsigned long int)buf_len);
                        buf = (char *)return_value_realloc_9;
                        if(buf == ((char *)NULL))
                        {
                          fprintf(stderr, "Error: Out of memory.\n");
                          return 1;
                        }

                      }
                    }
                    while((_Bool)1);
                    signed int return_value_feof_10;
                    return_value_feof_10=feof(stdin);
                    if(!(return_value_feof_10 == 0))
                    {
                      last_mid = mid_sent;
                      status = 2;
                    }

                  }

                  else
                    if(status == 2)
                    {
                      if(last_mid_sent == last_mid && (signed int)disconnect_sent == 0)
                      {
                        mosquitto_disconnect(mosq);
                        disconnect_sent = (_Bool)1;
                      }

                      usleep((unsigned int)100000);
                    }

                  rc = 0;
                }

                else
                  rc=mosquitto_loop(mosq, -1, 1);
                if(!(rc == 0) || connected == (_Bool)0)
                  break;

              }
              if(mode == 2)
                mosquitto_loop_stop(mosq, (_Bool)0);

              if(mode == 4 && !(message == ((char *)NULL)))
                free((void *)message);

              mosquitto_destroy(mosq);
              mosquitto_lib_cleanup();
              if(!(rc == 0))
              {
                const char *return_value_mosquitto_strerror_11;
                return_value_mosquitto_strerror_11=mosquitto_strerror(rc);
                fprintf(stderr, "Error: %s\n", return_value_mosquitto_strerror_11);
              }

              return rc;
            }
          }
        }
      }
    }
  }
}

// mosquitto__cmp_hostname_wildcard
// file tls_mosq.c line 73
signed int mosquitto__cmp_hostname_wildcard(char *certname, const char *hostname)
{
  signed int i;
  signed int len;
  if(certname == ((char *)NULL) || hostname == ((const char *)NULL))
    return 1;

  else
    if((signed int)*certname == 42)
    {
      if(!((signed int)certname[1l] == 46))
        return 1;

      certname = certname + (signed long int)2;
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(hostname);
      len = (signed int)return_value_strlen_1;
      i = 0;
      for( ; !(i >= len + -1); i = i + 1)
        if((signed int)hostname[(signed long int)i] == 46)
        {
          hostname = hostname + (signed long int)(i + 1);
          break;
        }

      signed int return_value_strcasecmp_2;
      return_value_strcasecmp_2=strcasecmp(certname, hostname);
      return return_value_strcasecmp_2;
    }

    else
    {
      signed int return_value_strcasecmp_3;
      return_value_strcasecmp_3=strcasecmp(certname, hostname);
      return return_value_strcasecmp_3;
    }
}

// mosquitto__parse_socks_url
// file client_shared.c line 812
static signed int mosquitto__parse_socks_url(struct mosq_config *cfg, char *url)
{
  char *str;
  signed int i;
  char *mosquitto__parse_socks_url__1__username = (char *)(void *)0;
  char *mosquitto__parse_socks_url__1__password = (char *)(void *)0;
  char *host = (char *)(void *)0;
  char *port = (char *)(void *)0;
  char *username_or_host = (char *)(void *)0;
  signed int start;
  signed int len;
  _Bool have_auth = (_Bool)0;
  signed int port_int;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen("socks5h://");
  signed int return_value_strncmp_3;
  return_value_strncmp_3=strncmp(url, "socks5h://", return_value_strlen_2);
  if(return_value_strncmp_3 == 0)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen("socks5h://");
    str = url + (signed long int)return_value_strlen_1;
  }

  else
  {
    fprintf(stderr, "Error: Unsupported proxy protocol: %s\n", url);
    return 1;
  }
  start = 0;
  i = 0;
  unsigned long int return_value_strlen_4;
  do
  {
    return_value_strlen_4=strlen(str);
    if((unsigned long int)i >= return_value_strlen_4)
      break;

    if((signed int)str[(signed long int)i] == 58)
    {
      if(i == start)
        goto cleanup;

      if(!(have_auth == (_Bool)0))
      {
        if(!(host == ((char *)NULL)))
          goto cleanup;

        len = i - start;
        void *return_value_malloc_5;
        return_value_malloc_5=malloc((unsigned long int)(len + 1));
        host = (char *)return_value_malloc_5;
        memcpy((void *)host, (const void *)&str[(signed long int)start], (unsigned long int)len);
        host[(signed long int)len] = (char)0;
        start = i + 1;
      }

      else
        if(username_or_host == ((char *)NULL))
        {
          len = i - start;
          void *return_value_malloc_6;
          return_value_malloc_6=malloc((unsigned long int)(len + 1));
          username_or_host = (char *)return_value_malloc_6;
          memcpy((void *)username_or_host, (const void *)&str[(signed long int)start], (unsigned long int)len);
          username_or_host[(signed long int)len] = (char)0;
          start = i + 1;
        }

    }

    else
      if((signed int)str[(signed long int)i] == 64)
      {
        if(i == start)
          goto cleanup;

        have_auth = (_Bool)1;
        if(!(username_or_host == ((char *)NULL)))
        {
          mosquitto__parse_socks_url__1__username = username_or_host;
          username_or_host = (char *)(void *)0;
          len = i - start;
          void *return_value_malloc_7;
          return_value_malloc_7=malloc((unsigned long int)(len + 1));
          mosquitto__parse_socks_url__1__password = (char *)return_value_malloc_7;
          memcpy((void *)mosquitto__parse_socks_url__1__password, (const void *)&str[(signed long int)start], (unsigned long int)len);
          mosquitto__parse_socks_url__1__password[(signed long int)len] = (char)0;
          start = i + 1;
        }

        else
        {
          if(!(mosquitto__parse_socks_url__1__username == ((char *)NULL)))
            goto cleanup;

          len = i - start;
          void *return_value_malloc_8;
          return_value_malloc_8=malloc((unsigned long int)(len + 1));
          mosquitto__parse_socks_url__1__username = (char *)return_value_malloc_8;
          memcpy((void *)mosquitto__parse_socks_url__1__username, (const void *)&str[(signed long int)start], (unsigned long int)len);
          mosquitto__parse_socks_url__1__username[(signed long int)len] = (char)0;
          start = i + 1;
        }
      }

    i = i + 1;
  }
  while((_Bool)1);
  if(!(start >= i))
  {
    len = i - start;
    if(!(host == ((char *)NULL)))
    {
      void *return_value_malloc_9;
      return_value_malloc_9=malloc((unsigned long int)(len + 1));
      port = (char *)return_value_malloc_9;
      memcpy((void *)port, (const void *)&str[(signed long int)start], (unsigned long int)len);
      port[(signed long int)len] = (char)0;
    }

    else
      if(!(username_or_host == ((char *)NULL)))
      {
        host = username_or_host;
        username_or_host = (char *)(void *)0;
        void *return_value_malloc_10;
        return_value_malloc_10=malloc((unsigned long int)(len + 1));
        port = (char *)return_value_malloc_10;
        memcpy((void *)port, (const void *)&str[(signed long int)start], (unsigned long int)len);
        port[(signed long int)len] = (char)0;
      }

      else
      {
        void *return_value_malloc_11;
        return_value_malloc_11=malloc((unsigned long int)(len + 1));
        host = (char *)return_value_malloc_11;
        memcpy((void *)host, (const void *)&str[(signed long int)start], (unsigned long int)len);
        host[(signed long int)len] = (char)0;
      }
  }

  signed int return_value_mosquitto__urldecode_12;
  signed int return_value_mosquitto__urldecode_13;
  if(host == ((char *)NULL))
    fprintf(stderr, "Error: Invalid proxy.\n");

  else
  {
    return_value_mosquitto__urldecode_12=mosquitto__urldecode(mosquitto__parse_socks_url__1__username);
    if(return_value_mosquitto__urldecode_12 == 0)
    {
      return_value_mosquitto__urldecode_13=mosquitto__urldecode(mosquitto__parse_socks_url__1__password);
      if(return_value_mosquitto__urldecode_13 == 0)
      {
        if(!(port == ((char *)NULL)))
        {
          port_int=atoi(port);
          if(port_int >= 65536 || !(port_int >= 1))
          {
            fprintf(stderr, "Error: Invalid proxy port %d\n", port_int);
            goto cleanup;
          }

          free((void *)port);
        }

        else
          port_int = 1080;
        cfg->socks5_username = mosquitto__parse_socks_url__1__username;
        cfg->socks5_password = mosquitto__parse_socks_url__1__password;
        cfg->socks5_host = host;
        cfg->socks5_port = port_int;
        return 0;
      }

    }

  }

cleanup:
  ;
  if(!(username_or_host == ((char *)NULL)))
    free((void *)username_or_host);

  if(!(mosquitto__parse_socks_url__1__username == ((char *)NULL)))
    free((void *)mosquitto__parse_socks_url__1__username);

  if(!(mosquitto__parse_socks_url__1__password == ((char *)NULL)))
    free((void *)mosquitto__parse_socks_url__1__password);

  if(!(host == ((char *)NULL)))
    free((void *)host);

  if(!(port == ((char *)NULL)))
    free((void *)port);

  return 1;
}

// mosquitto__socket_connect_tls
// file ./net_mosq.h line 89
signed int mosquitto__socket_connect_tls(struct mosquitto *mosq)
{
  signed int ret;
  ret=SSL_connect(mosq->ssl);
  if(!(ret == 1))
  {
    ret=SSL_get_error(mosq->ssl, ret);
    if(ret == 2)
      mosq->want_connect = (_Bool)1;

    else
      if(ret == 3)
      {
        mosq->want_write = (_Bool)1;
        mosq->want_connect = (_Bool)1;
      }

      else
      {
        close(mosq->sock);
        mosq->sock = -1;
        return 8;
      }
  }

  else
    mosq->want_connect = (_Bool)0;
  return 0;
}

// mosquitto__socks5_read
// file ./socks_mosq.h line 21
signed int mosquitto__socks5_read(struct mosquitto *mosq)
{
  signed long int len;
  unsigned char *payload;
  unsigned char i;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_3;
  signed int return_value_mosquitto__socks5_send_5;
  signed int return_value_mosquitto__socks5_send_6;
  _Bool tmp_if_expr_10;
  signed int *return_value___errno_location_9;
  _Bool tmp_if_expr_15;
  signed int *return_value___errno_location_14;
  if((signed int)mosq->state == mosq_cs_socks5_start)
  {
    while(mosq->in_packet.to_process >= 1u)
    {
      len=_mosquitto_net_read(mosq, (void *)&mosq->in_packet.payload[(signed long int)mosq->in_packet.pos], (unsigned long int)mosq->in_packet.to_process);
      if(len >= 1l)
      {
        mosq->in_packet.pos = mosq->in_packet.pos + (unsigned int)len;
        mosq->in_packet.to_process = mosq->in_packet.to_process - (unsigned int)len;
      }

      else
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        if(*return_value___errno_location_2 == 11)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value___errno_location_3=__errno_location();
          tmp_if_expr_4 = *return_value___errno_location_3 == 11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          return 0;

        else
        {
          _mosquitto_packet_cleanup(&mosq->in_packet);
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          switch(*return_value___errno_location_1)
          {
            case 0:
              return 16;
            case 104:
              return 7;
            default:
              return 14;
          }
        }
      }
    }
    if(!((signed int)*mosq->in_packet.payload == 5))
    {
      _mosquitto_packet_cleanup(&mosq->in_packet);
      return 16;
    }

    switch((signed int)mosq->in_packet.payload[(signed long int)1])
    {
      case 0x00:
      {
        _mosquitto_packet_cleanup(&mosq->in_packet);
        mosq->state = (enum mosquitto_client_state)mosq_cs_socks5_auth_ok;
        return_value_mosquitto__socks5_send_5=mosquitto__socks5_send(mosq);
        return return_value_mosquitto__socks5_send_5;
      }
      case 0x02:
      {
        _mosquitto_packet_cleanup(&mosq->in_packet);
        mosq->state = (enum mosquitto_client_state)mosq_cs_socks5_send_userpass;
        return_value_mosquitto__socks5_send_6=mosquitto__socks5_send(mosq);
        return return_value_mosquitto__socks5_send_6;
      }
      default:
      {
        _mosquitto_packet_cleanup(&mosq->in_packet);
        return 11;
      }
    }
  }

  else
    if((signed int)mosq->state == mosq_cs_socks5_userpass_reply)
    {
      while(mosq->in_packet.to_process >= 1u)
      {
        len=_mosquitto_net_read(mosq, (void *)&mosq->in_packet.payload[(signed long int)mosq->in_packet.pos], (unsigned long int)mosq->in_packet.to_process);
        if(len >= 1l)
        {
          mosq->in_packet.pos = mosq->in_packet.pos + (unsigned int)len;
          mosq->in_packet.to_process = mosq->in_packet.to_process - (unsigned int)len;
        }

        else
        {
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          if(*return_value___errno_location_8 == 11)
            tmp_if_expr_10 = (_Bool)1;

          else
          {
            return_value___errno_location_9=__errno_location();
            tmp_if_expr_10 = *return_value___errno_location_9 == 11 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_10)
            return 0;

          else
          {
            _mosquitto_packet_cleanup(&mosq->in_packet);
            signed int *return_value___errno_location_7;
            return_value___errno_location_7=__errno_location();
            switch(*return_value___errno_location_7)
            {
              case 0:
                return 16;
              case 104:
                return 7;
              default:
                return 14;
            }
          }
        }
      }
      if(!((signed int)*mosq->in_packet.payload == 1))
      {
        _mosquitto_packet_cleanup(&mosq->in_packet);
        return 16;
      }

      if((signed int)mosq->in_packet.payload[1l] == 0)
      {
        _mosquitto_packet_cleanup(&mosq->in_packet);
        mosq->state = (enum mosquitto_client_state)mosq_cs_socks5_auth_ok;
        signed int return_value_mosquitto__socks5_send_11;
        return_value_mosquitto__socks5_send_11=mosquitto__socks5_send(mosq);
        return return_value_mosquitto__socks5_send_11;
      }

      else
      {
        i = mosq->in_packet.payload[(signed long int)1];
        _mosquitto_packet_cleanup(&mosq->in_packet);
        switch((signed int)i)
        {
          case 0x02:
            return 11;
          case 0x03:

          case 0x04:

          case 0x05:
            return 4;
          case 0x01:

          case 0x06:

          case 0x07:

          case 0x08:
            return 16;
          default:
            return 3;
        }
        return 16;
      }
    }

    else
      if((signed int)mosq->state == mosq_cs_socks5_request)
      {
        while(mosq->in_packet.to_process >= 1u)
        {
          len=_mosquitto_net_read(mosq, (void *)&mosq->in_packet.payload[(signed long int)mosq->in_packet.pos], (unsigned long int)mosq->in_packet.to_process);
          if(len >= 1l)
          {
            mosq->in_packet.pos = mosq->in_packet.pos + (unsigned int)len;
            mosq->in_packet.to_process = mosq->in_packet.to_process - (unsigned int)len;
          }

          else
          {
            signed int *return_value___errno_location_13;
            return_value___errno_location_13=__errno_location();
            if(*return_value___errno_location_13 == 11)
              tmp_if_expr_15 = (_Bool)1;

            else
            {
              return_value___errno_location_14=__errno_location();
              tmp_if_expr_15 = *return_value___errno_location_14 == 11 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_15)
              return 0;

            else
            {
              _mosquitto_packet_cleanup(&mosq->in_packet);
              signed int *return_value___errno_location_12;
              return_value___errno_location_12=__errno_location();
              switch(*return_value___errno_location_12)
              {
                case 0:
                  return 16;
                case 104:
                  return 7;
                default:
                  return 14;
              }
            }
          }
        }
        if(mosq->in_packet.packet_length == 5u)
        {
          if((signed int)mosq->in_packet.payload[3l] == 1)
          {
            mosq->in_packet.to_process = mosq->in_packet.to_process + (unsigned int)((4 + 2) - 1);
            mosq->in_packet.packet_length = mosq->in_packet.packet_length + (unsigned int)((4 + 2) - 1);
          }

          else
            if((signed int)mosq->in_packet.payload[3l] == 4)
            {
              mosq->in_packet.to_process = mosq->in_packet.to_process + (unsigned int)((16 + 2) - 1);
              mosq->in_packet.packet_length = mosq->in_packet.packet_length + (unsigned int)((16 + 2) - 1);
            }

            else
              if((signed int)mosq->in_packet.payload[3l] == 3)
              {
                if((signed int)mosq->in_packet.payload[4l] >= 1)
                {
                  if(!((signed int)mosq->in_packet.payload[4l] >= 256))
                  {
                    mosq->in_packet.to_process = mosq->in_packet.to_process + (unsigned int)mosq->in_packet.payload[(signed long int)4];
                    mosq->in_packet.packet_length = mosq->in_packet.packet_length + (unsigned int)mosq->in_packet.payload[(signed long int)4];
                  }

                }

              }

              else
              {
                _mosquitto_packet_cleanup(&mosq->in_packet);
                return 2;
              }
          void *return_value__mosquitto_realloc_16;
          return_value__mosquitto_realloc_16=_mosquitto_realloc((void *)mosq->in_packet.payload, (unsigned long int)mosq->in_packet.packet_length);
          payload = (unsigned char *)return_value__mosquitto_realloc_16;
          if(!(payload == ((unsigned char *)NULL)))
            mosq->in_packet.payload = payload;

          else
          {
            _mosquitto_packet_cleanup(&mosq->in_packet);
            return 1;
          }
          return 0;
        }

        if(!((signed int)*mosq->in_packet.payload == 5))
        {
          _mosquitto_packet_cleanup(&mosq->in_packet);
          return 16;
        }

        if((signed int)mosq->in_packet.payload[1l] == 0)
        {
          _mosquitto_packet_cleanup(&mosq->in_packet);
          mosq->state = (enum mosquitto_client_state)mosq_cs_new;
          signed int return_value__mosquitto_send_connect_17;
          return_value__mosquitto_send_connect_17=_mosquitto_send_connect(mosq, mosq->keepalive, mosq->clean_session);
          return return_value__mosquitto_send_connect_17;
        }

        else
        {
          i = mosq->in_packet.payload[(signed long int)1];
          _mosquitto_packet_cleanup(&mosq->in_packet);
          mosq->state = (enum mosquitto_client_state)mosq_cs_socks5_new;
          switch((signed int)i)
          {
            case 0x02:
              return 11;
            case 0x03:

            case 0x04:

            case 0x05:
              return 4;
            case 0x01:

            case 0x06:

            case 0x07:

            case 0x08:
              return 16;
            default:
              return 3;
          }
        }
      }

      else
      {
        signed int return_value__mosquitto_packet_read_18;
        return_value__mosquitto_packet_read_18=_mosquitto_packet_read(mosq);
        return return_value__mosquitto_packet_read_18;
      }
  return 0;
}

// mosquitto__socks5_send
// file ./socks_mosq.h line 20
signed int mosquitto__socks5_send(struct mosquitto *mosq)
{
  struct _mosquitto_packet *packet;
  signed int slen;
  signed int ulen;
  signed int plen;
  if((signed int)mosq->state == mosq_cs_socks5_new)
  {
    void *return_value__mosquitto_calloc_1;
    return_value__mosquitto_calloc_1=_mosquitto_calloc((unsigned long int)1, sizeof(struct _mosquitto_packet) /*40ul*/ );
    packet = (struct _mosquitto_packet *)return_value__mosquitto_calloc_1;
    if(packet == ((struct _mosquitto_packet *)NULL))
      return 1;

    if(!(mosq->socks5_username == ((char *)NULL)))
      packet->packet_length = (unsigned int)4;

    else
      packet->packet_length = (unsigned int)3;
    void *return_value__mosquitto_malloc_2;
    return_value__mosquitto_malloc_2=_mosquitto_malloc(sizeof(unsigned char) /*1ul*/  * (unsigned long int)packet->packet_length);
    packet->payload = (unsigned char *)return_value__mosquitto_malloc_2;
    packet->payload[(signed long int)0] = (unsigned char)0x05;
    if(!(mosq->socks5_username == ((char *)NULL)))
    {
      packet->payload[(signed long int)1] = (unsigned char)2;
      packet->payload[(signed long int)2] = (unsigned char)0x00;
      packet->payload[(signed long int)3] = (unsigned char)0x02;
    }

    else
    {
      packet->payload[(signed long int)1] = (unsigned char)1;
      packet->payload[(signed long int)2] = (unsigned char)0x00;
    }
    pthread_mutex_lock(&mosq->state_mutex);
    mosq->state = (enum mosquitto_client_state)mosq_cs_socks5_start;
    pthread_mutex_unlock(&mosq->state_mutex);
    mosq->in_packet.pos = (unsigned int)0;
    mosq->in_packet.packet_length = (unsigned int)2;
    mosq->in_packet.to_process = (unsigned int)2;
    void *return_value__mosquitto_malloc_3;
    return_value__mosquitto_malloc_3=_mosquitto_malloc(sizeof(unsigned char) /*1ul*/  * (unsigned long int)2);
    mosq->in_packet.payload = (unsigned char *)return_value__mosquitto_malloc_3;
    if(mosq->in_packet.payload == ((unsigned char *)NULL))
    {
      _mosquitto_free((void *)packet->payload);
      _mosquitto_free((void *)packet);
      return 1;
    }

    signed int return_value__mosquitto_packet_queue_4;
    return_value__mosquitto_packet_queue_4=_mosquitto_packet_queue(mosq, packet);
    return return_value__mosquitto_packet_queue_4;
  }

  else
    if((signed int)mosq->state == mosq_cs_socks5_auth_ok)
    {
      void *return_value__mosquitto_calloc_5;
      return_value__mosquitto_calloc_5=_mosquitto_calloc((unsigned long int)1, sizeof(struct _mosquitto_packet) /*40ul*/ );
      packet = (struct _mosquitto_packet *)return_value__mosquitto_calloc_5;
      if(packet == ((struct _mosquitto_packet *)NULL))
        return 1;

      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(mosq->host);
      packet->packet_length = (unsigned int)((unsigned long int)7 + return_value_strlen_6);
      void *return_value__mosquitto_malloc_7;
      return_value__mosquitto_malloc_7=_mosquitto_malloc(sizeof(unsigned char) /*1ul*/  * (unsigned long int)packet->packet_length);
      packet->payload = (unsigned char *)return_value__mosquitto_malloc_7;
      unsigned long int return_value_strlen_8;
      return_value_strlen_8=strlen(mosq->host);
      slen = (signed int)return_value_strlen_8;
      packet->payload[(signed long int)0] = (unsigned char)0x05;
      packet->payload[(signed long int)1] = (unsigned char)1;
      packet->payload[(signed long int)2] = (unsigned char)0;
      packet->payload[(signed long int)3] = (unsigned char)3;
      packet->payload[(signed long int)4] = (unsigned char)slen;
      memcpy((void *)&packet->payload[(signed long int)5], (const void *)mosq->host, (unsigned long int)slen);
      packet->payload[(signed long int)(5 + slen)] = (unsigned char)((mosq->port & 0xFF00) >> 8);
      packet->payload[(signed long int)(6 + slen)] = (unsigned char)(mosq->port & 0x00FF);
      pthread_mutex_lock(&mosq->state_mutex);
      mosq->state = (enum mosquitto_client_state)mosq_cs_socks5_request;
      pthread_mutex_unlock(&mosq->state_mutex);
      mosq->in_packet.pos = (unsigned int)0;
      mosq->in_packet.packet_length = (unsigned int)5;
      mosq->in_packet.to_process = (unsigned int)5;
      void *return_value__mosquitto_malloc_9;
      return_value__mosquitto_malloc_9=_mosquitto_malloc(sizeof(unsigned char) /*1ul*/  * (unsigned long int)5);
      mosq->in_packet.payload = (unsigned char *)return_value__mosquitto_malloc_9;
      if(mosq->in_packet.payload == ((unsigned char *)NULL))
      {
        _mosquitto_free((void *)packet->payload);
        _mosquitto_free((void *)packet);
        return 1;
      }

      signed int return_value__mosquitto_packet_queue_10;
      return_value__mosquitto_packet_queue_10=_mosquitto_packet_queue(mosq, packet);
      return return_value__mosquitto_packet_queue_10;
    }

    else
      if((signed int)mosq->state == mosq_cs_socks5_send_userpass)
      {
        void *return_value__mosquitto_calloc_11;
        return_value__mosquitto_calloc_11=_mosquitto_calloc((unsigned long int)1, sizeof(struct _mosquitto_packet) /*40ul*/ );
        packet = (struct _mosquitto_packet *)return_value__mosquitto_calloc_11;
        if(packet == ((struct _mosquitto_packet *)NULL))
          return 1;

        unsigned long int return_value_strlen_12;
        return_value_strlen_12=strlen(mosq->socks5_username);
        ulen = (signed int)return_value_strlen_12;
        unsigned long int return_value_strlen_13;
        return_value_strlen_13=strlen(mosq->socks5_password);
        plen = (signed int)return_value_strlen_13;
        packet->packet_length = (unsigned int)(3 + ulen + plen);
        void *return_value__mosquitto_malloc_14;
        return_value__mosquitto_malloc_14=_mosquitto_malloc(sizeof(unsigned char) /*1ul*/  * (unsigned long int)packet->packet_length);
        packet->payload = (unsigned char *)return_value__mosquitto_malloc_14;
        packet->payload[(signed long int)0] = (unsigned char)0x01;
        packet->payload[(signed long int)1] = (unsigned char)ulen;
        memcpy((void *)&packet->payload[(signed long int)2], (const void *)mosq->socks5_username, (unsigned long int)ulen);
        packet->payload[(signed long int)(2 + ulen)] = (unsigned char)plen;
        memcpy((void *)&packet->payload[(signed long int)(3 + ulen)], (const void *)mosq->socks5_password, (unsigned long int)plen);
        pthread_mutex_lock(&mosq->state_mutex);
        mosq->state = (enum mosquitto_client_state)mosq_cs_socks5_userpass_reply;
        pthread_mutex_unlock(&mosq->state_mutex);
        mosq->in_packet.pos = (unsigned int)0;
        mosq->in_packet.packet_length = (unsigned int)2;
        mosq->in_packet.to_process = (unsigned int)2;
        void *return_value__mosquitto_malloc_15;
        return_value__mosquitto_malloc_15=_mosquitto_malloc(sizeof(unsigned char) /*1ul*/  * (unsigned long int)2);
        mosq->in_packet.payload = (unsigned char *)return_value__mosquitto_malloc_15;
        if(mosq->in_packet.payload == ((unsigned char *)NULL))
        {
          _mosquitto_free((void *)packet->payload);
          _mosquitto_free((void *)packet);
          return 1;
        }

        signed int return_value__mosquitto_packet_queue_16;
        return_value__mosquitto_packet_queue_16=_mosquitto_packet_queue(mosq, packet);
        return return_value__mosquitto_packet_queue_16;
      }

  return 0;
}

// mosquitto__urldecode
// file client_shared.c line 769
static signed int mosquitto__urldecode(char *str)
{
  signed int i;
  signed int j;
  signed int len;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  if(str == ((char *)NULL))
    return 0;

  else
  {
    char *return_value_strchr_1;
    return_value_strchr_1=strchr(str, 37);
    if(return_value_strchr_1 == ((char *)NULL))
      return 0;

    else
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(str);
      len = (signed int)return_value_strlen_2;
      i = 0;
      for( ; !(i >= len); i = i + 1)
        if((signed int)str[(signed long int)i] == 37)
        {
          if(2 + i >= len)
            return 1;

          if((signed int)str[(signed long int)(1 + i)] == 50)
            tmp_if_expr_6 = (signed int)str[(signed long int)(i + 2)] == 53 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6 = (_Bool)0;
          if(tmp_if_expr_6)
          {
            str[(signed long int)i] = (char)37;
            len = len - 2;
            j = i + 1;
            for( ; !(j >= len); j = j + 1)
              str[(signed long int)j] = str[(signed long int)(j + 2)];
            str[(signed long int)j] = (char)0;
          }

          else
          {
            if((signed int)str[(signed long int)(1 + i)] == 51)
            {
              if((signed int)str[(signed long int)(2 + i)] == 65)
                tmp_if_expr_4 = (_Bool)1;

              else
                tmp_if_expr_4 = (signed int)str[(signed long int)(i + 2)] == 97 ? (_Bool)1 : (_Bool)0;
              tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_5 = (_Bool)0;
            if(tmp_if_expr_5)
            {
              str[(signed long int)i] = (char)58;
              len = len - 2;
              j = i + 1;
              for( ; !(j >= len); j = j + 1)
                str[(signed long int)j] = str[(signed long int)(j + 2)];
              str[(signed long int)j] = (char)0;
            }

            else
            {
              if((signed int)str[(signed long int)(1 + i)] == 52)
                tmp_if_expr_3 = (signed int)str[(signed long int)(i + 2)] == 48 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_3 = (_Bool)0;
              if(tmp_if_expr_3)
              {
                str[(signed long int)i] = (char)58;
                len = len - 2;
                j = i + 1;
                for( ; !(j >= len); j = j + 1)
                  str[(signed long int)j] = str[(signed long int)(j + 2)];
                str[(signed long int)j] = (char)0;
              }

              else
                return 1;
            }
          }
        }

      return 0;
    }
  }
}

// mosquitto_connack_string
// file ../lib/mosquitto.h line 1382
const char * mosquitto_connack_string(signed int connack_code)
{
  switch(connack_code)
  {
    case 0:
      return "Connection Accepted.";
    case 1:
      return "Connection Refused: unacceptable protocol version.";
    case 2:
      return "Connection Refused: identifier rejected.";
    case 3:
      return "Connection Refused: broker unavailable.";
    case 4:
      return "Connection Refused: bad user name or password.";
    case 5:
      return "Connection Refused: not authorised.";
    default:
      return "Connection Refused: unknown reason.";
  }
}

// mosquitto_connect
// file mosquitto.c line 427
signed int mosquitto_connect(struct mosquitto *mosq, const char *host, signed int port, signed int keepalive)
{
  signed int return_value_mosquitto_connect_bind_1;
  return_value_mosquitto_connect_bind_1=mosquitto_connect_bind(mosq, host, port, keepalive, (const char *)(void *)0);
  return return_value_mosquitto_connect_bind_1;
}

// mosquitto_connect_async
// file mosquitto.c line 445
signed int mosquitto_connect_async(struct mosquitto *mosq, const char *host, signed int port, signed int keepalive)
{
  signed int return_value_mosquitto_connect_bind_async_1;
  return_value_mosquitto_connect_bind_async_1=mosquitto_connect_bind_async(mosq, host, port, keepalive, (const char *)(void *)0);
  return return_value_mosquitto_connect_bind_async_1;
}

// mosquitto_connect_bind
// file ../lib/mosquitto.h line 382
signed int mosquitto_connect_bind(struct mosquitto *mosq, const char *host, signed int port, signed int keepalive, const char *bind_address)
{
  signed int rc;
  rc=_mosquitto_connect_init(mosq, host, port, keepalive, bind_address);
  if(!(rc == 0))
    return rc;

  else
  {
    pthread_mutex_lock(&mosq->state_mutex);
    mosq->state = (enum mosquitto_client_state)mosq_cs_new;
    pthread_mutex_unlock(&mosq->state_mutex);
    signed int return_value__mosquitto_reconnect_1;
    return_value__mosquitto_reconnect_1=_mosquitto_reconnect(mosq, (_Bool)1);
    return return_value__mosquitto_reconnect_1;
  }
}

// mosquitto_connect_bind_async
// file mosquitto.c line 450
signed int mosquitto_connect_bind_async(struct mosquitto *mosq, const char *host, signed int port, signed int keepalive, const char *bind_address)
{
  signed int rc;
  rc=_mosquitto_connect_init(mosq, host, port, keepalive, bind_address);
  if(!(rc == 0))
    return rc;

  else
  {
    pthread_mutex_lock(&mosq->state_mutex);
    mosq->state = (enum mosquitto_client_state)mosq_cs_connect_async;
    pthread_mutex_unlock(&mosq->state_mutex);
    signed int return_value__mosquitto_reconnect_1;
    return_value__mosquitto_reconnect_1=_mosquitto_reconnect(mosq, (_Bool)0);
    return return_value__mosquitto_reconnect_1;
  }
}

// mosquitto_connect_callback_set
// file ../lib/mosquitto.h line 1111
void mosquitto_connect_callback_set(struct mosquitto *mosq, void (*on_connect)(struct mosquitto *, void *, signed int))
{
  pthread_mutex_lock(&mosq->callback_mutex);
  mosq->on_connect = on_connect;
  pthread_mutex_unlock(&mosq->callback_mutex);
}

// mosquitto_connect_srv
// file ../lib/mosquitto.h line 486
signed int mosquitto_connect_srv(struct mosquitto *mosq, const char *host, signed int keepalive, const char *bind_address)
{
  char *h;
  signed int rc;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    rc=ares_init(&mosq->achan);
    if(!(rc == 0))
      return 13;

    else
    {
      if(!(host == ((const char *)NULL)))
      {
        if(!(mosq->tls_cafile == ((char *)NULL)))
          tmp_if_expr_7 = (_Bool)1;

        else
          tmp_if_expr_7 = mosq->tls_capath != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_7)
          tmp_if_expr_8 = (_Bool)1;

        else
          tmp_if_expr_8 = mosq->tls_psk != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_8)
        {
          unsigned long int return_value_strlen_1;
          return_value_strlen_1=strlen(host);
          unsigned long int return_value_strlen_2;
          return_value_strlen_2=strlen("_secure-mqtt._tcp.");
          void *return_value__mosquitto_malloc_3;
          return_value__mosquitto_malloc_3=_mosquitto_malloc(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)1);
          h = (char *)return_value__mosquitto_malloc_3;
          if(h == ((char *)NULL))
            return 1;

          sprintf(h, "_secure-mqtt._tcp.%s", host);
        }

        else
        {
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(host);
          unsigned long int return_value_strlen_5;
          return_value_strlen_5=strlen("_mqtt._tcp.");
          void *return_value__mosquitto_malloc_6;
          return_value__mosquitto_malloc_6=_mosquitto_malloc(return_value_strlen_4 + return_value_strlen_5 + (unsigned long int)1);
          h = (char *)return_value__mosquitto_malloc_6;
          if(h == ((char *)NULL))
            return 1;

          sprintf(h, "_mqtt._tcp.%s", host);
        }
        ares_search(mosq->achan, h, 1, 33, srv_callback, (void *)mosq);
        _mosquitto_free((void *)h);
      }

      pthread_mutex_lock(&mosq->state_mutex);
      mosq->state = (enum mosquitto_client_state)mosq_cs_connect_srv;
      pthread_mutex_unlock(&mosq->state_mutex);
      mosq->keepalive = (unsigned short int)keepalive;
      return 0;
    }
  }
}

// mosquitto_destroy
// file ../lib/mosquitto.h line 232
void mosquitto_destroy(struct mosquitto *mosq)
{
  if(!(mosq == ((struct mosquitto *)NULL)))
  {
    _mosquitto_destroy(mosq);
    _mosquitto_free((void *)mosq);
  }

}

// mosquitto_disconnect
// file ../lib/mosquitto.h line 563
signed int mosquitto_disconnect(struct mosquitto *mosq)
{
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    pthread_mutex_lock(&mosq->state_mutex);
    mosq->state = (enum mosquitto_client_state)mosq_cs_disconnecting;
    pthread_mutex_unlock(&mosq->state_mutex);
    if(mosq->sock == -1)
      return 4;

    else
    {
      signed int return_value__mosquitto_send_disconnect_1;
      return_value__mosquitto_send_disconnect_1=_mosquitto_send_disconnect(mosq);
      return return_value__mosquitto_send_disconnect_1;
    }
  }
}

// mosquitto_disconnect_callback_set
// file ../lib/mosquitto.h line 1131
void mosquitto_disconnect_callback_set(struct mosquitto *mosq, void (*on_disconnect)(struct mosquitto *, void *, signed int))
{
  pthread_mutex_lock(&mosq->callback_mutex);
  mosq->on_disconnect = on_disconnect;
  pthread_mutex_unlock(&mosq->callback_mutex);
}

// mosquitto_lib_cleanup
// file ../lib/mosquitto.h line 188
signed int mosquitto_lib_cleanup(void)
{
  _mosquitto_net_cleanup();
  return 0;
}

// mosquitto_lib_init
// file ../lib/mosquitto.h line 175
signed int mosquitto_lib_init(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  srand((unsigned int)(tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000));
  _mosquitto_net_init();
  return 0;
}

// mosquitto_lib_version
// file ../lib/mosquitto.h line 160
signed int mosquitto_lib_version(signed int *major, signed int *minor, signed int *revision)
{
  if(!(major == ((signed int *)NULL)))
    *major = 1;

  if(!(minor == ((signed int *)NULL)))
    *minor = 4;

  if(!(revision == ((signed int *)NULL)))
    *revision = 8;

  return 1 * 1000000 + 4 * 1000 + 8;
}

// mosquitto_log_callback_set
// file ../lib/mosquitto.h line 1234
void mosquitto_log_callback_set(struct mosquitto *mosq, void (*on_log)(struct mosquitto *, void *, signed int, const char *))
{
  pthread_mutex_lock(&mosq->log_callback_mutex);
  mosq->on_log = on_log;
  pthread_mutex_unlock(&mosq->log_callback_mutex);
}

// mosquitto_loop
// file ../lib/mosquitto.h line 722
signed int mosquitto_loop(struct mosquitto *mosq, signed int timeout, signed int max_packets)
{
  struct timespec local_timeout;
  struct anonymous_2 readfds;
  struct anonymous_2 writefds;
  signed int fdcount;
  signed int rc;
  char pairbuf;
  signed int maxfd = 0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  signed int return_value_SSL_pending_4;
  _Bool tmp_if_expr_8;
  if(mosq == ((struct mosquitto *)NULL) || !(max_packets >= 1))
    return 3;

  else
  {
    if(mosq->sock >= 1024)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = mosq->sockpairR >= 1024 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return 3;

    else
    {
      do
      {
        signed int __d0;
        signed int mosquitto_loop__1__2____d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(mosquitto_loop__1__2____d1) : "a"(0), "0"(sizeof(struct anonymous_2) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readfds)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      do
      {
        signed int mosquitto_loop__1__3____d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(mosquitto_loop__1__3____d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_2) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&writefds)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      if(!(mosq->sock == -1))
      {
        maxfd = mosq->sock;
        (&readfds)->__fds_bits[(signed long int)(mosq->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->__fds_bits[(signed long int)(mosq->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << mosq->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        pthread_mutex_lock(&mosq->current_out_packet_mutex);
        pthread_mutex_lock(&mosq->out_packet_mutex);
        if(!(mosq->out_packet == ((struct _mosquitto_packet *)NULL)))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = mosq->current_out_packet != ((struct _mosquitto_packet *)NULL) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          (&writefds)->__fds_bits[(signed long int)(mosq->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writefds)->__fds_bits[(signed long int)(mosq->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << mosq->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

        if(!(mosq->ssl == ((struct ssl_st *)NULL)))
        {
          if(!(mosq->want_write == (_Bool)0))
            (&writefds)->__fds_bits[(signed long int)(mosq->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writefds)->__fds_bits[(signed long int)(mosq->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << mosq->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

          else
            if(!(mosq->want_connect == (_Bool)0))
              (&writefds)->__fds_bits[(signed long int)(mosq->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writefds)->__fds_bits[(signed long int)(mosq->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << mosq->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));

        }

        pthread_mutex_unlock(&mosq->out_packet_mutex);
        pthread_mutex_unlock(&mosq->current_out_packet_mutex);
      }

      else
        if(!(mosq->achan == ((struct ares_channeldata *)NULL)))
        {
          pthread_mutex_lock(&mosq->state_mutex);
          if((signed int)mosq->state == mosq_cs_connect_srv)
          {
            rc=ares_fds(mosq->achan, &readfds, &writefds);
            if(!(maxfd >= rc))
              maxfd = rc;

          }

          else
          {
            pthread_mutex_unlock(&mosq->state_mutex);
            return 4;
          }
          pthread_mutex_unlock(&mosq->state_mutex);
        }

      if(!(mosq->sockpairR == -1))
      {
        (&readfds)->__fds_bits[(signed long int)(mosq->sockpairR / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->__fds_bits[(signed long int)(mosq->sockpairR / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << mosq->sockpairR % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        if(!(maxfd >= mosq->sockpairR))
          maxfd = mosq->sockpairR;

      }

      if(timeout >= 0)
      {
        local_timeout.tv_sec = (signed long int)(timeout / 1000);
        local_timeout.tv_nsec = (signed long int)((double)((signed long int)timeout - local_timeout.tv_sec * (signed long int)1000) * 1e6);
      }

      else
      {
        local_timeout.tv_sec = (signed long int)1;
        local_timeout.tv_nsec = (signed long int)0;
      }
      fdcount=pselect(maxfd + 1, &readfds, &writefds, (struct anonymous_2 *)(void *)0, &local_timeout, (const struct anonymous_7 *)(void *)0);
      if(fdcount == -1)
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        if(*return_value___errno_location_3 == 4)
          return 0;

        else
          return 14;
      }

      else
      {
        if(!(mosq->sock == -1))
        {
          if(!((readfds.__fds_bits[(signed long int)(mosq->sock / 8)] & (signed long int)(1UL << mosq->sock % 8)) == 0l))
          {
            if(!(mosq->want_connect == (_Bool)0))
            {
              rc=mosquitto__socket_connect_tls(mosq);
              if(!(rc == 0))
                return rc;

            }

            else
              do
              {
                rc=mosquitto_loop_read(mosq, max_packets);
                if(!(rc == 0))
                  tmp_if_expr_6 = (_Bool)1;

                else
                  tmp_if_expr_6 = mosq->sock == -1 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_6)
                  return rc;

                if(!(mosq->ssl == ((struct ssl_st *)NULL)))
                {
                  return_value_SSL_pending_4=SSL_pending(mosq->ssl);
                  tmp_if_expr_5 = return_value_SSL_pending_4 != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_5 = (_Bool)0;
              }
              while(tmp_if_expr_5);
          }

          if(!(mosq->sockpairR == -1))
          {
            if(!((readfds.__fds_bits[(signed long int)(mosq->sockpairR / 8)] & (signed long int)(1UL << mosq->sockpairR % 8)) == 0l))
            {
              signed long int return_value_read_7;
              return_value_read_7=read(mosq->sockpairR, (void *)&pairbuf, (unsigned long int)1);
              (&writefds)->__fds_bits[(signed long int)(mosq->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writefds)->__fds_bits[(signed long int)(mosq->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << mosq->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
            }

          }

          if(!((writefds.__fds_bits[(signed long int)(mosq->sock / 8)] & (signed long int)(1UL << mosq->sock % 8)) == 0l))
          {
            if(!(mosq->want_connect == (_Bool)0))
            {
              rc=mosquitto__socket_connect_tls(mosq);
              if(!(rc == 0))
                return rc;

            }

            else
            {
              rc=mosquitto_loop_write(mosq, max_packets);
              if(!(rc == 0))
                tmp_if_expr_8 = (_Bool)1;

              else
                tmp_if_expr_8 = mosq->sock == -1 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_8)
                return rc;

            }
          }

        }

        if(!(mosq->achan == ((struct ares_channeldata *)NULL)))
          ares_process(mosq->achan, &readfds, &writefds);

      }
      signed int return_value_mosquitto_loop_misc_9;
      return_value_mosquitto_loop_misc_9=mosquitto_loop_misc(mosq);
      return return_value_mosquitto_loop_misc_9;
    }
  }
}

// mosquitto_loop_forever
// file mosquitto.c line 989
signed int mosquitto_loop_forever(struct mosquitto *mosq, signed int timeout, signed int max_packets)
{
  signed int run = 1;
  signed int rc;
  unsigned int reconnects = (unsigned int)0;
  unsigned long int reconnect_delay;
  _Bool tmp_if_expr_2;
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    if((signed int)mosq->state == mosq_cs_connect_async)
      mosquitto_reconnect(mosq);

    while(!(run == 0))
    {
      do
      {
        rc=mosquitto_loop(mosq, timeout, max_packets);
        if(rc == 0 && !(reconnects == 0u))
          reconnects = (unsigned int)0;

      }
      while(rc == 0 && !(run == 0));
      if(!(rc == 1) && !(rc == 2) && !(rc == 3) && !(rc == 6) && !(rc == 8) && !(rc == 9) && !(rc == 10) && !(rc == 11) && !(rc == 12) && !(rc == 13) && !(rc == 15) && !(rc == 16))
      {
        if(rc == 14)
          goto __CPROVER_DUMP_L6;

      }

      else
        return rc;

    __CPROVER_DUMP_L6:
      ;
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 71)
        return rc;

      do
      {
        rc = 0;
        pthread_mutex_lock(&mosq->state_mutex);
        if((signed int)mosq->state == mosq_cs_disconnecting)
        {
          run = 0;
          pthread_mutex_unlock(&mosq->state_mutex);
        }

        else
        {
          pthread_mutex_unlock(&mosq->state_mutex);
          if(mosq->reconnect_delay >= 1u)
            tmp_if_expr_2 = mosq->reconnect_exponential_backoff != (_Bool)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_2 = (_Bool)0;
          if(tmp_if_expr_2)
            reconnect_delay = (unsigned long int)(mosq->reconnect_delay * reconnects * reconnects);

          else
            reconnect_delay = (unsigned long int)mosq->reconnect_delay;
          if(!((unsigned long int)mosq->reconnect_delay_max >= reconnect_delay))
            reconnect_delay = (unsigned long int)mosq->reconnect_delay_max;

          else
            reconnects = reconnects + 1u;
          sleep((unsigned int)reconnect_delay);
          pthread_mutex_lock(&mosq->state_mutex);
          if((signed int)mosq->state == mosq_cs_disconnecting)
          {
            run = 0;
            pthread_mutex_unlock(&mosq->state_mutex);
          }

          else
          {
            pthread_mutex_unlock(&mosq->state_mutex);
            rc=mosquitto_reconnect(mosq);
          }
        }
      }
      while(!(rc == 0) && !(run == 0));
    }
    return rc;
  }
}

// mosquitto_loop_misc
// file mosquitto.c line 1071
signed int mosquitto_loop_misc(struct mosquitto *mosq)
{
  signed long int now;
  signed int rc;
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
    if(mosq->sock == -1)
      return 4;

    else
    {
      _mosquitto_check_keepalive(mosq);
      now=mosquitto_time();
      if(!(1l + mosq->last_retry_check >= now))
      {
        _mosquitto_message_retry_check(mosq);
        mosq->last_retry_check = now;
      }

      if(!(mosq->ping_t == 0l))
      {
        if(!(now + -mosq->ping_t >= (signed long int)mosq->keepalive))
          goto __CPROVER_DUMP_L7;

        _mosquitto_socket_close(mosq);
        pthread_mutex_lock(&mosq->state_mutex);
        if((signed int)mosq->state == mosq_cs_disconnecting)
          rc = 0;

        else
          rc = 1;
        pthread_mutex_unlock(&mosq->state_mutex);
        pthread_mutex_lock(&mosq->callback_mutex);
        if(!(mosq->on_disconnect == ((void (*)(struct mosquitto *, void *, signed int))NULL)))
        {
          mosq->in_callback = (_Bool)1;
          mosq->on_disconnect(mosq, mosq->userdata, rc);
          mosq->in_callback = (_Bool)0;
        }

        pthread_mutex_unlock(&mosq->callback_mutex);
        return 7;
      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        return 0;
      }
    }
}

// mosquitto_loop_read
// file mosquitto.c line 1130
signed int mosquitto_loop_read(struct mosquitto *mosq, signed int max_packets)
{
  signed int rc;
  signed int i;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  if(!(max_packets >= 1))
    return 3;

  else
  {
    pthread_mutex_lock(&mosq->out_message_mutex);
    max_packets = mosq->out_queue_len;
    pthread_mutex_unlock(&mosq->out_message_mutex);
    pthread_mutex_lock(&mosq->in_message_mutex);
    max_packets = max_packets + mosq->in_queue_len;
    pthread_mutex_unlock(&mosq->in_message_mutex);
    if(!(max_packets >= 1))
      max_packets = 1;

    i = 0;
    for( ; !(i >= max_packets); i = i + 1)
    {
      if(!(mosq->socks5_host == ((char *)NULL)))
        rc=mosquitto__socks5_read(mosq);

      else
        rc=_mosquitto_packet_read(mosq);
      if(!(rc == 0))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value___errno_location_4=__errno_location();
        tmp_if_expr_5 = *return_value___errno_location_4 == 11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
      {
        signed int return_value__mosquitto_loop_rc_handle_1;
        return_value__mosquitto_loop_rc_handle_1=_mosquitto_loop_rc_handle(mosq, rc);
        return return_value__mosquitto_loop_rc_handle_1;
      }

    }
    return rc;
  }
}

// mosquitto_loop_start
// file ../lib/mosquitto.h line 778
signed int mosquitto_loop_start(struct mosquitto *mosq)
{
  _Bool tmp_if_expr_1;
  if(mosq == ((struct mosquitto *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = mosq->threaded != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 3;

  else
  {
    mosq->threaded = (_Bool)1;
    pthread_create(&mosq->thread_id, (const union pthread_attr_t *)(void *)0, _mosquitto_thread_main, (void *)mosq);
    return 0;
  }
}

// mosquitto_loop_stop
// file ../lib/mosquitto.h line 802
signed int mosquitto_loop_stop(struct mosquitto *mosq, _Bool force)
{
  char sockpair_data = (char)0;
  _Bool tmp_if_expr_1;
  if(mosq == ((struct mosquitto *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(mosq->threaded != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 3;

  else
  {
    if(!(mosq->sockpairW == -1))
    {
      signed long int return_value_write_2;
      return_value_write_2=write(mosq->sockpairW, (const void *)&sockpair_data, (unsigned long int)1);
    }

    if(!(force == (_Bool)0))
      pthread_cancel(mosq->thread_id);

    pthread_join(mosq->thread_id, (void **)(void *)0);
    mosq->thread_id=pthread_self();
    mosq->threaded = (_Bool)0;
    return 0;
  }
}

// mosquitto_loop_write
// file mosquitto.c line 1164
signed int mosquitto_loop_write(struct mosquitto *mosq, signed int max_packets)
{
  signed int rc;
  signed int i;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  if(!(max_packets >= 1))
    return 3;

  else
  {
    pthread_mutex_lock(&mosq->out_message_mutex);
    max_packets = mosq->out_queue_len;
    pthread_mutex_unlock(&mosq->out_message_mutex);
    pthread_mutex_lock(&mosq->in_message_mutex);
    max_packets = max_packets + mosq->in_queue_len;
    pthread_mutex_unlock(&mosq->in_message_mutex);
    if(!(max_packets >= 1))
      max_packets = 1;

    i = 0;
    for( ; !(i >= max_packets); i = i + 1)
    {
      rc=_mosquitto_packet_write(mosq);
      if(!(rc == 0))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value___errno_location_4=__errno_location();
        tmp_if_expr_5 = *return_value___errno_location_4 == 11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
      {
        signed int return_value__mosquitto_loop_rc_handle_1;
        return_value__mosquitto_loop_rc_handle_1=_mosquitto_loop_rc_handle(mosq, rc);
        return return_value__mosquitto_loop_rc_handle_1;
      }

    }
    return rc;
  }
}

// mosquitto_max_inflight_messages_set
// file ../lib/mosquitto.h line 1296
signed int mosquitto_max_inflight_messages_set(struct mosquitto *mosq, unsigned int max_inflight_messages)
{
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    mosq->max_inflight_messages = (signed int)max_inflight_messages;
    return 0;
  }
}

// mosquitto_message_callback_set
// file mosquitto.c line 1249
void mosquitto_message_callback_set(struct mosquitto *mosq, void (*on_message)(struct mosquitto *, void *, struct mosquitto_message *))
{
  pthread_mutex_lock(&mosq->callback_mutex);
  mosq->on_message = on_message;
  pthread_mutex_unlock(&mosq->callback_mutex);
}

// mosquitto_message_copy
// file messages_mosq.c line 59
signed int mosquitto_message_copy(struct mosquitto_message *dst, struct mosquitto_message *src)
{
  if(dst == ((struct mosquitto_message *)NULL) || src == ((struct mosquitto_message *)NULL))
    return 3;

  else
  {
    dst->mid = src->mid;
    dst->topic=_mosquitto_strdup(src->topic);
    if(dst->topic == ((char *)NULL))
      return 1;

    else
    {
      dst->qos = src->qos;
      dst->retain = src->retain;
      if(!(src->payloadlen == 0))
      {
        dst->payload=_mosquitto_malloc((unsigned long int)src->payloadlen);
        if(dst->payload == NULL)
        {
          _mosquitto_free((void *)dst->topic);
          return 1;
        }

        memcpy(dst->payload, src->payload, (unsigned long int)src->payloadlen);
        dst->payloadlen = src->payloadlen;
      }

      else
      {
        dst->payloadlen = 0;
        dst->payload = (void *)0;
      }
      return 0;
    }
  }
}

// mosquitto_message_free
// file messages_mosq.c line 96
void mosquitto_message_free(struct mosquitto_message **message)
{
  struct mosquitto_message *msg;
  _Bool tmp_if_expr_1;
  if(message == ((struct mosquitto_message **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*message != ((struct mosquitto_message *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    msg = *message;
    if(!(msg->topic == ((char *)NULL)))
      _mosquitto_free((void *)msg->topic);

    if(!(msg->payload == NULL))
      _mosquitto_free(msg->payload);

    _mosquitto_free((void *)msg);
  }

}

// mosquitto_message_retry_set
// file messages_mosq.c line 365
void mosquitto_message_retry_set(struct mosquitto *mosq, unsigned int message_retry)
{
  /* assertion mosq */
  assert(mosq != ((struct mosquitto *)NULL));
  if(!(mosq == ((struct mosquitto *)NULL)))
    mosq->message_retry = message_retry;

}

// mosquitto_new
// file ../lib/mosquitto.h line 219
struct mosquitto * mosquitto_new(const char *id, _Bool clean_session, void *userdata)
{
  struct mosquitto *mosq = (struct mosquitto *)(void *)0;
  signed int rc;
  if(id == ((const char *)NULL) && (signed int)clean_session == 0)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return (struct mosquitto *)(void *)0;
  }

  signal(13, (void (*)(signed int))1);
  void *return_value__mosquitto_calloc_2;
  return_value__mosquitto_calloc_2=_mosquitto_calloc((unsigned long int)1, sizeof(struct mosquitto) /*832ul*/ );
  mosq = (struct mosquitto *)return_value__mosquitto_calloc_2;
  if(!(mosq == ((struct mosquitto *)NULL)))
  {
    mosq->sock = -1;
    mosq->sockpairR = -1;
    mosq->sockpairW = -1;
    mosq->thread_id=pthread_self();
    rc=mosquitto_reinitialise(mosq, id, clean_session, userdata);
    if(!(rc == 0))
    {
      mosquitto_destroy(mosq);
      if(rc == 3)
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = 22;
      }

      else
        if(rc == 1)
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          *return_value___errno_location_4 = 12;
        }

      return (struct mosquitto *)(void *)0;
    }

  }

  else
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    *return_value___errno_location_5 = 12;
  }
  return mosq;
}

// mosquitto_opts_set
// file ../lib/mosquitto.h line 947
signed int mosquitto_opts_set(struct mosquitto *mosq, enum mosq_opt_t option, void *value)
{
  signed int ival;
  if(value == NULL || mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    if((signed int)option == MOSQ_OPT_PROTOCOL_VERSION)
    {
      ival = *((signed int *)value);
      if(ival == 3)
        mosq->protocol = (enum _mosquitto_protocol)mosq_p_mqtt31;

      else
        if(ival == 4)
          mosq->protocol = (enum _mosquitto_protocol)mosq_p_mqtt311;

        else
          return 3;
      goto __CPROVER_DUMP_L7;
    }

    return 3;

  __CPROVER_DUMP_L7:
    ;
    return 0;
  }
}

// mosquitto_pub_topic_check
// file ../lib/mosquitto.h line 1502
signed int mosquitto_pub_topic_check(const char *str)
{
  signed int len = 0;
  _Bool tmp_if_expr_1;
  for( ; !(str == ((const char *)NULL)); str = &str[(signed long int)1])
  {
    if(*str == 0)
      break;

    if((signed int)*str == 43)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)str[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return 3;

    len = len + 1;
  }
  if(len >= 65536)
    return 3;

  else
    return 0;
}

// mosquitto_publish
// file ../lib/mosquitto.h line 600
signed int mosquitto_publish(struct mosquitto *mosq, signed int *mid, const char *topic, signed int payloadlen, const void *payload, signed int qos, _Bool retain)
{
  struct mosquitto_message_all *mosquitto_publish__1__message;
  unsigned short int local_mid;
  signed int queue_status;
  if(topic == ((const char *)NULL) || mosq == ((struct mosquitto *)NULL) || qos >= 3 || !(qos >= 0))
    return 3;

  else
    if((signed int)*topic == 0)
      return 3;

    else
      if(payloadlen >= 268435456 || !(payloadlen >= 0))
        return 9;

      else
      {
        signed int return_value_mosquitto_pub_topic_check_1;
        return_value_mosquitto_pub_topic_check_1=mosquitto_pub_topic_check(topic);
        if(!(return_value_mosquitto_pub_topic_check_1 == 0))
          return 3;

        else
        {
          local_mid=_mosquitto_mid_generate(mosq);
          if(!(mid == ((signed int *)NULL)))
            *mid = (signed int)local_mid;

          if(qos == 0)
          {
            signed int return_value__mosquitto_send_publish_2;
            return_value__mosquitto_send_publish_2=_mosquitto_send_publish(mosq, local_mid, topic, (unsigned int)payloadlen, payload, qos, retain, (_Bool)0);
            return return_value__mosquitto_send_publish_2;
          }

          else
          {
            void *return_value__mosquitto_calloc_3;
            return_value__mosquitto_calloc_3=_mosquitto_calloc((unsigned long int)1, sizeof(struct mosquitto_message_all) /*64ul*/ );
            mosquitto_publish__1__message = (struct mosquitto_message_all *)return_value__mosquitto_calloc_3;
            if(mosquitto_publish__1__message == ((struct mosquitto_message_all *)NULL))
              return 1;

            mosquitto_publish__1__message->next = (struct mosquitto_message_all *)(void *)0;
            mosquitto_publish__1__message->timestamp=mosquitto_time();
            mosquitto_publish__1__message->msg.mid = (signed int)local_mid;
            mosquitto_publish__1__message->msg.topic=_mosquitto_strdup(topic);
            if(mosquitto_publish__1__message->msg.topic == ((char *)NULL))
            {
              _mosquitto_message_cleanup(&mosquitto_publish__1__message);
              return 1;
            }

            if(!(payloadlen == 0))
            {
              mosquitto_publish__1__message->msg.payloadlen = payloadlen;
              mosquitto_publish__1__message->msg.payload=_mosquitto_malloc((unsigned long int)payloadlen * sizeof(unsigned char) /*1ul*/ );
              if(mosquitto_publish__1__message->msg.payload == NULL)
              {
                _mosquitto_message_cleanup(&mosquitto_publish__1__message);
                return 1;
              }

              memcpy(mosquitto_publish__1__message->msg.payload, payload, (unsigned long int)payloadlen * sizeof(unsigned char) /*1ul*/ );
            }

            else
            {
              mosquitto_publish__1__message->msg.payloadlen = 0;
              mosquitto_publish__1__message->msg.payload = (void *)0;
            }
            mosquitto_publish__1__message->msg.qos = qos;
            mosquitto_publish__1__message->msg.retain = retain;
            mosquitto_publish__1__message->dup = (_Bool)0;
            pthread_mutex_lock(&mosq->out_message_mutex);
            queue_status=_mosquitto_message_queue(mosq, mosquitto_publish__1__message, (enum mosquitto_msg_direction)mosq_md_out);
            if(queue_status == 0)
            {
              if(qos == 1)
                mosquitto_publish__1__message->state = (enum mosquitto_msg_state)mosq_ms_wait_for_puback;

              else
                if(qos == 2)
                  mosquitto_publish__1__message->state = (enum mosquitto_msg_state)mosq_ms_wait_for_pubrec;

              pthread_mutex_unlock(&mosq->out_message_mutex);
              signed int return_value__mosquitto_send_publish_4;
              return_value__mosquitto_send_publish_4=_mosquitto_send_publish(mosq, (unsigned short int)mosquitto_publish__1__message->msg.mid, mosquitto_publish__1__message->msg.topic, (unsigned int)mosquitto_publish__1__message->msg.payloadlen, mosquitto_publish__1__message->msg.payload, mosquitto_publish__1__message->msg.qos, mosquitto_publish__1__message->msg.retain, mosquitto_publish__1__message->dup);
              return return_value__mosquitto_send_publish_4;
            }

            else
            {
              mosquitto_publish__1__message->state = (enum mosquitto_msg_state)mosq_ms_invalid;
              pthread_mutex_unlock(&mosq->out_message_mutex);
              return 0;
            }
          }
        }
      }
}

// mosquitto_publish_callback_set
// file ../lib/mosquitto.h line 1149
void mosquitto_publish_callback_set(struct mosquitto *mosq, void (*on_publish)(struct mosquitto *, void *, signed int))
{
  pthread_mutex_lock(&mosq->callback_mutex);
  mosq->on_publish = on_publish;
  pthread_mutex_unlock(&mosq->callback_mutex);
}

// mosquitto_reconnect
// file mosquitto.c line 467
signed int mosquitto_reconnect(struct mosquitto *mosq)
{
  signed int return_value__mosquitto_reconnect_1;
  return_value__mosquitto_reconnect_1=_mosquitto_reconnect(mosq, (_Bool)1);
  return return_value__mosquitto_reconnect_1;
}

// mosquitto_reconnect_async
// file mosquitto.c line 462
signed int mosquitto_reconnect_async(struct mosquitto *mosq)
{
  signed int return_value__mosquitto_reconnect_1;
  return_value__mosquitto_reconnect_1=_mosquitto_reconnect(mosq, (_Bool)0);
  return return_value__mosquitto_reconnect_1;
}

// mosquitto_reconnect_delay_set
// file mosquitto.c line 263
signed int mosquitto_reconnect_delay_set(struct mosquitto *mosq, unsigned int reconnect_delay, unsigned int reconnect_delay_max, _Bool reconnect_exponential_backoff)
{
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    mosq->reconnect_delay = reconnect_delay;
    mosq->reconnect_delay_max = reconnect_delay_max;
    mosq->reconnect_exponential_backoff = reconnect_exponential_backoff;
    return 0;
  }
}

// mosquitto_reinitialise
// file mosquitto.c line 126
signed int mosquitto_reinitialise(struct mosquitto *mosq, const char *id, _Bool clean_session, void *userdata)
{
  signed int i;
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
    if(id == ((const char *)NULL) && (signed int)clean_session == 0)
      return 3;

    else
    {
      _mosquitto_destroy(mosq);
      memset((void *)mosq, 0, sizeof(struct mosquitto) /*832ul*/ );
      if(!(userdata == NULL))
        mosq->userdata = userdata;

      else
        mosq->userdata = (void *)mosq;
      mosq->protocol = (enum _mosquitto_protocol)mosq_p_mqtt31;
      mosq->sock = -1;
      mosq->sockpairR = -1;
      mosq->sockpairW = -1;
      mosq->keepalive = (unsigned short int)60;
      mosq->message_retry = (unsigned int)20;
      mosq->last_retry_check = (signed long int)0;
      mosq->clean_session = clean_session;
      if(!(id == ((const char *)NULL)))
      {
        if((signed int)*id == 0)
          return 3;

        mosq->id=_mosquitto_strdup(id);
      }

      else
      {
        void *return_value__mosquitto_calloc_1;
        return_value__mosquitto_calloc_1=_mosquitto_calloc((unsigned long int)24, sizeof(char) /*1ul*/ );
        mosq->id = (char *)return_value__mosquitto_calloc_1;
        if(mosq->id == ((char *)NULL))
          return 1;

        mosq->id[(signed long int)0] = (char)109;
        mosq->id[(signed long int)1] = (char)111;
        mosq->id[(signed long int)2] = (char)115;
        mosq->id[(signed long int)3] = (char)113;
        mosq->id[(signed long int)4] = (char)47;
        i = 5;
        for( ; !(i >= 23); i = i + 1)
        {
          signed int return_value_rand_2;
          return_value_rand_2=rand();
          mosq->id[(signed long int)i] = (char)(return_value_rand_2 % 73 + 48);
        }
      }
      mosq->in_packet.payload = (unsigned char *)(void *)0;
      _mosquitto_packet_cleanup(&mosq->in_packet);
      mosq->out_packet = (struct _mosquitto_packet *)(void *)0;
      mosq->current_out_packet = (struct _mosquitto_packet *)(void *)0;
      mosq->last_msg_in=mosquitto_time();
      mosq->last_msg_out=mosquitto_time();
      mosq->ping_t = (signed long int)0;
      mosq->last_mid = (unsigned short int)0;
      mosq->state = (enum mosquitto_client_state)mosq_cs_new;
      mosq->in_messages = (struct mosquitto_message_all *)(void *)0;
      mosq->in_messages_last = (struct mosquitto_message_all *)(void *)0;
      mosq->out_messages = (struct mosquitto_message_all *)(void *)0;
      mosq->out_messages_last = (struct mosquitto_message_all *)(void *)0;
      mosq->max_inflight_messages = 20;
      mosq->will = (struct mosquitto_message *)(void *)0;
      mosq->on_connect = (void (*)(struct mosquitto *, void *, signed int))(void *)0;
      mosq->on_publish = (void (*)(struct mosquitto *, void *, signed int))(void *)0;
      mosq->on_message = (void (*)(struct mosquitto *, void *, struct mosquitto_message *))(void *)0;
      mosq->on_subscribe = (void (*)(struct mosquitto *, void *, signed int, signed int, const signed int *))(void *)0;
      mosq->on_unsubscribe = (void (*)(struct mosquitto *, void *, signed int))(void *)0;
      mosq->host = (char *)(void *)0;
      mosq->port = 1883;
      mosq->in_callback = (_Bool)0;
      mosq->in_queue_len = 0;
      mosq->out_queue_len = 0;
      mosq->reconnect_delay = (unsigned int)1;
      mosq->reconnect_delay_max = (unsigned int)1;
      mosq->reconnect_exponential_backoff = (_Bool)0;
      mosq->threaded = (_Bool)0;
      mosq->ssl = (struct ssl_st *)(void *)0;
      mosq->tls_cert_reqs = 0x01;
      mosq->tls_insecure = (_Bool)0;
      mosq->want_write = (_Bool)0;
      pthread_mutex_init(&mosq->callback_mutex, (const union anonymous_3 *)(void *)0);
      pthread_mutex_init(&mosq->log_callback_mutex, (const union anonymous_3 *)(void *)0);
      pthread_mutex_init(&mosq->state_mutex, (const union anonymous_3 *)(void *)0);
      pthread_mutex_init(&mosq->out_packet_mutex, (const union anonymous_3 *)(void *)0);
      pthread_mutex_init(&mosq->current_out_packet_mutex, (const union anonymous_3 *)(void *)0);
      pthread_mutex_init(&mosq->msgtime_mutex, (const union anonymous_3 *)(void *)0);
      pthread_mutex_init(&mosq->in_message_mutex, (const union anonymous_3 *)(void *)0);
      pthread_mutex_init(&mosq->out_message_mutex, (const union anonymous_3 *)(void *)0);
      pthread_mutex_init(&mosq->mid_mutex, (const union anonymous_3 *)(void *)0);
      mosq->thread_id=pthread_self();
      return 0;
    }
}

// mosquitto_socket
// file mosquitto.c line 386
signed int mosquitto_socket(struct mosquitto *mosq)
{
  if(mosq == ((struct mosquitto *)NULL))
    return -1;

  else
    return mosq->sock;
}

// mosquitto_socks5_set
// file ../lib/mosquitto.h line 1349
signed int mosquitto_socks5_set(struct mosquitto *mosq, const char *host, signed int port, const char *username, const char *password)
{
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    if(host == ((const char *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_strlen_1=strlen(host);
      tmp_if_expr_2 = return_value_strlen_1 > (unsigned long int)256 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      return 3;

    else
      if(port >= 65536 || !(port >= 1))
        return 3;

      else
      {
        if(!(mosq->socks5_host == ((char *)NULL)))
          _mosquitto_free((void *)mosq->socks5_host);

        mosq->socks5_host=_mosquitto_strdup(host);
        if(mosq->socks5_host == ((char *)NULL))
          return 1;

        else
        {
          mosq->socks5_port = port;
          if(!(mosq->socks5_username == ((char *)NULL)))
            _mosquitto_free((void *)mosq->socks5_username);

          if(!(mosq->socks5_password == ((char *)NULL)))
            _mosquitto_free((void *)mosq->socks5_password);

          if(!(username == ((const char *)NULL)))
          {
            mosq->socks5_username=_mosquitto_strdup(username);
            if(mosq->socks5_username == ((char *)NULL))
              return 1;

            if(password == ((const char *)NULL))
              goto __CPROVER_DUMP_L11;

            mosq->socks5_password=_mosquitto_strdup(password);
            if(!(mosq->socks5_password == ((char *)NULL)))
              goto __CPROVER_DUMP_L11;

            _mosquitto_free((void *)mosq->socks5_username);
            return 1;
          }

          else
          {

          __CPROVER_DUMP_L11:
            ;
            return 0;
          }
        }
      }
  }
}

// mosquitto_strerror
// file ../lib/mosquitto.h line 1369
const char * mosquitto_strerror(signed int mosq_errno)
{
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  switch(mosq_errno)
  {
    case -1:
      return "Connection pending.";
    case 0:
      return "No error.";
    case 1:
      return "Out of memory.";
    case 2:
      return "A network protocol error occurred when communicating with the broker.";
    case 3:
      return "Invalid function arguments provided.";
    case 4:
      return "The client is not currently connected.";
    case 5:
      return "The connection was refused.";
    case 6:
      return "Message not found (internal error).";
    case 7:
      return "The connection was lost.";
    case 8:
      return "A TLS error occurred.";
    case 9:
      return "Payload too large.";
    case 10:
      return "This feature is not supported.";
    case 11:
      return "Authorisation failed.";
    case 12:
      return "Access denied by ACL.";
    case 13:
      return "Unknown error.";
    case 14:
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      return return_value_strerror_2;
    }
    case 15:
      return "Lookup error.";
    case 16:
      return "Proxy error.";
    default:
      return "Unknown error.";
  }
}

// mosquitto_sub_topic_check
// file ../lib/mosquitto.h line 1529
signed int mosquitto_sub_topic_check(const char *str)
{
  char c = (char)0;
  signed int len = 0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  for( ; !(str == ((const char *)NULL)); str = &str[(signed long int)1])
  {
    if(*str == 0)
      break;

    if((signed int)*str == 43)
    {
      if(!((signed int)c == 0) && !((signed int)c == 47))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        if(!((signed int)str[1l] == 0))
          tmp_if_expr_1 = (signed int)str[(signed long int)1] != 47 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        return 3;

    }

    else
      if((signed int)*str == 35)
      {
        if(!((signed int)c == 0) && !((signed int)c == 47))
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)str[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
          return 3;

      }

    len = len + 1;
    c = str[(signed long int)0];
  }
  if(len >= 65536)
    return 3;

  else
    return 0;
}

// mosquitto_sub_topic_tokenise
// file mosquitto.c line 1348
signed int mosquitto_sub_topic_tokenise(const char *subtopic, char ***topics, signed int *count)
{
  signed int len;
  signed int hier_count = 1;
  signed int start;
  signed int stop;
  signed int hier;
  signed int tlen;
  signed int i;
  signed int j;
  _Bool tmp_if_expr_4;
  if(topics == ((char ***)NULL) || count == ((signed int *)NULL) || subtopic == ((const char *)NULL))
    return 3;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(subtopic);
    len = (signed int)return_value_strlen_1;
    i = 0;
    for( ; !(i >= len); i = i + 1)
      if((signed int)subtopic[(signed long int)i] == 47)
      {
        if(len + -1 >= i)
          hier_count = hier_count + 1;

      }

    void *return_value__mosquitto_calloc_2;
    return_value__mosquitto_calloc_2=_mosquitto_calloc((unsigned long int)hier_count, sizeof(char *) /*8ul*/ );
    *topics = (char **)return_value__mosquitto_calloc_2;
    if(*topics == ((char **)NULL))
      return 1;

    else
    {
      start = 0;
      stop = 0;
      hier = 0;
      i = 0;
      for( ; !(i >= 1 + len); i = i + 1)
      {
        if((signed int)subtopic[(signed long int)i] == 47)
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = (signed int)subtopic[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_4)
        {
          stop = i;
          if(!(start == stop))
          {
            tlen = (stop - start) + 1;
            void *return_value__mosquitto_calloc_3;
            return_value__mosquitto_calloc_3=_mosquitto_calloc((unsigned long int)tlen, sizeof(char) /*1ul*/ );
            (*topics)[(signed long int)hier] = (char *)return_value__mosquitto_calloc_3;
            if((*topics)[(signed long int)hier] == ((char *)NULL))
            {
              i = 0;
              for( ; !(i >= hier_count); i = i + 1)
                if(!((*topics)[(signed long int)hier] == ((char *)NULL)))
                  _mosquitto_free((void *)(*topics)[(signed long int)hier]);

              _mosquitto_free((void *)*topics);
              return 1;
            }

            j = start;
            for( ; !(j >= stop); j = j + 1)
              (*topics)[(signed long int)hier][(signed long int)(j - start)] = subtopic[(signed long int)j];
          }

          start = i + 1;
          hier = hier + 1;
        }

      }
      *count = hier_count;
      return 0;
    }
  }
}

// mosquitto_sub_topic_tokens_free
// file mosquitto.c line 1407
signed int mosquitto_sub_topic_tokens_free(char ***topics, signed int count)
{
  signed int i;
  _Bool tmp_if_expr_1;
  if(topics == ((char ***)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*topics != ((char **)NULL)) ? (_Bool)1 : (_Bool)0;
  if(!(count >= 1) || tmp_if_expr_1)
    return 3;

  else
  {
    i = 0;
    for( ; !(i >= count); i = i + 1)
      if(!((*topics)[(signed long int)i] == ((char *)NULL)))
        _mosquitto_free((void *)(*topics)[(signed long int)i]);

    _mosquitto_free((void *)*topics);
    return 0;
  }
}

// mosquitto_subscribe
// file mosquitto.c line 624
signed int mosquitto_subscribe(struct mosquitto *mosq, signed int *mid, const char *sub, signed int qos)
{
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
    if(mosq->sock == -1)
      return 4;

    else
    {
      signed int return_value_mosquitto_sub_topic_check_1;
      return_value_mosquitto_sub_topic_check_1=mosquitto_sub_topic_check(sub);
      if(!(return_value_mosquitto_sub_topic_check_1 == 0))
        return 3;

      else
      {
        signed int return_value__mosquitto_send_subscribe_2;
        return_value__mosquitto_send_subscribe_2=_mosquitto_send_subscribe(mosq, mid, sub, (unsigned char)qos);
        return return_value__mosquitto_send_subscribe_2;
      }
    }
}

// mosquitto_subscribe_callback_set
// file mosquitto.c line 1256
void mosquitto_subscribe_callback_set(struct mosquitto *mosq, void (*on_subscribe)(struct mosquitto *, void *, signed int, signed int, const signed int *))
{
  pthread_mutex_lock(&mosq->callback_mutex);
  mosq->on_subscribe = on_subscribe;
  pthread_mutex_unlock(&mosq->callback_mutex);
}

// mosquitto_threaded_set
// file thread_mosq.c line 102
signed int mosquitto_threaded_set(struct mosquitto *mosq, _Bool threaded)
{
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    mosq->threaded = threaded;
    return 0;
  }
}

// mosquitto_time
// file ./time_mosq.h line 20
signed long int mosquitto_time(void)
{
  struct timespec tp;
  clock_gettime(1, &tp);
  return tp.tv_sec;
}

// mosquitto_tls_insecure_set
// file ../lib/mosquitto.h line 1026
signed int mosquitto_tls_insecure_set(struct mosquitto *mosq, _Bool value)
{
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    mosq->tls_insecure = value;
    return 0;
  }
}

// mosquitto_tls_opts_set
// file ../lib/mosquitto.h line 1060
signed int mosquitto_tls_opts_set(struct mosquitto *mosq, signed int cert_reqs, const char *tls_version, const char *ciphers)
{
  _Bool tmp_if_expr_3;
  signed int return_value_strcasecmp_2;
  _Bool tmp_if_expr_5;
  signed int return_value_strcasecmp_4;
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    mosq->tls_cert_reqs = cert_reqs;
    if(!(tls_version == ((const char *)NULL)))
    {
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(tls_version, "tlsv1.2");
      if(return_value_strcasecmp_1 == 0)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_strcasecmp_2=strcasecmp(tls_version, "tlsv1.1");
        tmp_if_expr_3 = !(return_value_strcasecmp_2 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_strcasecmp_4=strcasecmp(tls_version, "tlsv1");
        tmp_if_expr_5 = !(return_value_strcasecmp_4 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
      {
        mosq->tls_version=_mosquitto_strdup(tls_version);
        if(mosq->tls_version == ((char *)NULL))
          return 1;

      }

      else
        return 3;
    }

    else
    {
      mosq->tls_version=_mosquitto_strdup("tlsv1.2");
      if(mosq->tls_version == ((char *)NULL))
        return 1;

    }
    if(!(ciphers == ((const char *)NULL)))
    {
      mosq->tls_ciphers=_mosquitto_strdup(ciphers);
      if(mosq->tls_ciphers == ((char *)NULL))
        return 1;

    }

    else
      mosq->tls_ciphers = (char *)(void *)0;
    return 0;
  }
}

// mosquitto_tls_psk_set
// file ../lib/mosquitto.h line 1087
signed int mosquitto_tls_psk_set(struct mosquitto *mosq, const char *psk, const char *identity, const char *ciphers)
{
  if(identity == ((const char *)NULL) || psk == ((const char *)NULL) || mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    unsigned long int return_value_strspn_1;
    return_value_strspn_1=strspn(psk, "0123456789abcdefABCDEF");
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(psk);
    if(!(return_value_strspn_1 >= return_value_strlen_2))
      return 3;

    else
    {
      mosq->tls_psk=_mosquitto_strdup(psk);
      if(mosq->tls_psk == ((char *)NULL))
        return 1;

      else
      {
        mosq->tls_psk_identity=_mosquitto_strdup(identity);
        if(mosq->tls_psk_identity == ((char *)NULL))
        {
          _mosquitto_free((void *)mosq->tls_psk);
          return 1;
        }

        else
        {
          if(!(ciphers == ((const char *)NULL)))
          {
            mosq->tls_ciphers=_mosquitto_strdup(ciphers);
            if(mosq->tls_ciphers == ((char *)NULL))
              return 1;

          }

          else
            mosq->tls_ciphers = (char *)(void *)0;
          return 0;
        }
      }
    }
  }
}

// mosquitto_tls_set
// file ../lib/mosquitto.h line 996
signed int mosquitto_tls_set(struct mosquitto *mosq, const char *cafile, const char *capath, const char *certfile, const char *keyfile, signed int (*pw_callback)(char *, signed int, signed int, void *))
{
  struct _IO_FILE *fptr;
  if(mosq == ((struct mosquitto *)NULL) || cafile == ((const char *)NULL) && capath == ((const char *)NULL) || certfile == ((const char *)NULL) && !(keyfile == ((const char *)NULL)) || keyfile == ((const char *)NULL) && !(certfile == ((const char *)NULL)))
    return 3;

  else
  {
    if(!(cafile == ((const char *)NULL)))
    {
      fptr=_mosquitto_fopen(cafile, "rt");
      if(!(fptr == ((struct _IO_FILE *)NULL)))
        fclose(fptr);

      else
        return 3;
      mosq->tls_cafile=_mosquitto_strdup(cafile);
      if(mosq->tls_cafile == ((char *)NULL))
        return 1;

    }

    else
      if(!(mosq->tls_cafile == ((char *)NULL)))
      {
        _mosquitto_free((void *)mosq->tls_cafile);
        mosq->tls_cafile = (char *)(void *)0;
      }

    if(!(capath == ((const char *)NULL)))
    {
      mosq->tls_capath=_mosquitto_strdup(capath);
      if(mosq->tls_capath == ((char *)NULL))
        return 1;

    }

    else
      if(!(mosq->tls_capath == ((char *)NULL)))
      {
        _mosquitto_free((void *)mosq->tls_capath);
        mosq->tls_capath = (char *)(void *)0;
      }

    if(!(certfile == ((const char *)NULL)))
    {
      fptr=_mosquitto_fopen(certfile, "rt");
      if(!(fptr == ((struct _IO_FILE *)NULL)))
        fclose(fptr);

      else
      {
        if(!(mosq->tls_cafile == ((char *)NULL)))
        {
          _mosquitto_free((void *)mosq->tls_cafile);
          mosq->tls_cafile = (char *)(void *)0;
        }

        if(!(mosq->tls_capath == ((char *)NULL)))
        {
          _mosquitto_free((void *)mosq->tls_capath);
          mosq->tls_capath = (char *)(void *)0;
        }

        return 3;
      }
      mosq->tls_certfile=_mosquitto_strdup(certfile);
      if(mosq->tls_certfile == ((char *)NULL))
        return 1;

    }

    else
    {
      if(!(mosq->tls_certfile == ((char *)NULL)))
        _mosquitto_free((void *)mosq->tls_certfile);

      mosq->tls_certfile = (char *)(void *)0;
    }
    if(!(keyfile == ((const char *)NULL)))
    {
      fptr=_mosquitto_fopen(keyfile, "rt");
      if(!(fptr == ((struct _IO_FILE *)NULL)))
        fclose(fptr);

      else
      {
        if(!(mosq->tls_cafile == ((char *)NULL)))
        {
          _mosquitto_free((void *)mosq->tls_cafile);
          mosq->tls_cafile = (char *)(void *)0;
        }

        if(!(mosq->tls_capath == ((char *)NULL)))
        {
          _mosquitto_free((void *)mosq->tls_capath);
          mosq->tls_capath = (char *)(void *)0;
        }

        if(!(mosq->tls_certfile == ((char *)NULL)))
        {
          _mosquitto_free((void *)mosq->tls_certfile);
          mosq->tls_certfile = (char *)(void *)0;
        }

        return 3;
      }
      mosq->tls_keyfile=_mosquitto_strdup(keyfile);
      if(mosq->tls_keyfile == ((char *)NULL))
        return 1;

    }

    else
    {
      if(!(mosq->tls_keyfile == ((char *)NULL)))
        _mosquitto_free((void *)mosq->tls_keyfile);

      mosq->tls_keyfile = (char *)(void *)0;
    }
    mosq->tls_pw_callback = pw_callback;
    return 0;
  }
}

// mosquitto_topic_matches_sub
// file util_mosq.c line 220
signed int mosquitto_topic_matches_sub(const char *sub, const char *topic, _Bool *result)
{
  signed int slen;
  signed int tlen;
  signed int spos;
  signed int tpos;
  _Bool multilevel_wildcard = (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  if(result == ((_Bool *)NULL) || sub == ((const char *)NULL) || topic == ((const char *)NULL))
    return 3;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(sub);
    slen = (signed int)return_value_strlen_1;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(topic);
    tlen = (signed int)return_value_strlen_2;
    if(!(slen == 0) && !(tlen == 0))
    {
      if((signed int)*sub == 36)
        tmp_if_expr_3 = (signed int)topic[(signed long int)0] != 36 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        if((signed int)*topic == 36)
          tmp_if_expr_4 = (signed int)sub[(signed long int)0] != 36 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_5)
        goto __CPROVER_DUMP_L8;

      *result = (_Bool)0;
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      spos = 0;
      tpos = 0;
      while(!(spos >= slen) && !(tpos >= tlen))
        if(sub[(signed long int)spos] == topic[(signed long int)tpos])
        {
          if(tpos == tlen + -1)
          {
            if(spos == slen + -3)
            {
              if((signed int)sub[(signed long int)(1 + spos)] == 47)
              {
                if((signed int)sub[(signed long int)(2 + spos)] == 35)
                {
                  *result = (_Bool)1;
                  multilevel_wildcard = (_Bool)1;
                  return 0;
                }

              }

            }

          }

          spos = spos + 1;
          tpos = tpos + 1;
          if(spos == slen && tpos == tlen)
          {
            *result = (_Bool)1;
            return 0;
          }

          else
            if(spos == slen + -1 && tpos == tlen)
            {
              if((signed int)sub[(signed long int)spos] == 43)
              {
                spos = spos + 1;
                *result = (_Bool)1;
                return 0;
              }

            }

        }

        else
          if((signed int)sub[(signed long int)spos] == 43)
          {
            spos = spos + 1;
            for( ; !(tpos >= tlen); tpos = tpos + 1)
              if((signed int)topic[(signed long int)tpos] == 47)
                break;

            if(spos == slen && tpos == tlen)
            {
              *result = (_Bool)1;
              return 0;
            }

          }

          else
            if((signed int)sub[(signed long int)spos] == 35)
            {
              multilevel_wildcard = (_Bool)1;
              if(!(1 + spos == slen))
              {
                *result = (_Bool)0;
                return 0;
              }

              else
              {
                *result = (_Bool)1;
                return 0;
              }
            }

            else
            {
              *result = (_Bool)0;
              return 0;
            }
      if((signed int)multilevel_wildcard == 0 && (!(spos >= slen) || !(tpos >= tlen)))
        *result = (_Bool)0;

      return 0;
    }
  }
}

// mosquitto_unsubscribe
// file mosquitto.c line 634
signed int mosquitto_unsubscribe(struct mosquitto *mosq, signed int *mid, const char *sub)
{
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
    if(mosq->sock == -1)
      return 4;

    else
    {
      signed int return_value_mosquitto_sub_topic_check_1;
      return_value_mosquitto_sub_topic_check_1=mosquitto_sub_topic_check(sub);
      if(!(return_value_mosquitto_sub_topic_check_1 == 0))
        return 3;

      else
      {
        signed int return_value__mosquitto_send_unsubscribe_2;
        return_value__mosquitto_send_unsubscribe_2=_mosquitto_send_unsubscribe(mosq, mid, sub);
        return return_value__mosquitto_send_unsubscribe_2;
      }
    }
}

// mosquitto_unsubscribe_callback_set
// file mosquitto.c line 1263
void mosquitto_unsubscribe_callback_set(struct mosquitto *mosq, void (*on_unsubscribe)(struct mosquitto *, void *, signed int))
{
  pthread_mutex_lock(&mosq->callback_mutex);
  mosq->on_unsubscribe = on_unsubscribe;
  pthread_mutex_unlock(&mosq->callback_mutex);
}

// mosquitto_user_data_set
// file mosquitto.c line 1277
void mosquitto_user_data_set(struct mosquitto *mosq, void *userdata)
{
  if(!(mosq == ((struct mosquitto *)NULL)))
    mosq->userdata = userdata;

}

// mosquitto_username_pw_set
// file ../lib/mosquitto.h line 326
signed int mosquitto_username_pw_set(struct mosquitto *mosq, const char *username, const char *password)
{
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    if(!(mosq->username == ((char *)NULL)))
    {
      _mosquitto_free((void *)mosq->username);
      mosq->username = (char *)(void *)0;
    }

    if(!(mosq->password == ((char *)NULL)))
    {
      _mosquitto_free((void *)mosq->password);
      mosq->password = (char *)(void *)0;
    }

    if(!(username == ((const char *)NULL)))
    {
      mosq->username=_mosquitto_strdup(username);
      if(mosq->username == ((char *)NULL))
        return 1;

      if(password == ((const char *)NULL))
        goto __CPROVER_DUMP_L5;

      mosq->password=_mosquitto_strdup(password);
      if(!(mosq->password == ((char *)NULL)))
        goto __CPROVER_DUMP_L5;

      _mosquitto_free((void *)mosq->username);
      mosq->username = (char *)(void *)0;
      return 1;
    }

    else
    {

    __CPROVER_DUMP_L5:
      ;
      return 0;
    }
  }
}

// mosquitto_want_write
// file mosquitto.c line 1191
_Bool mosquitto_want_write(struct mosquitto *mosq)
{
  _Bool tmp_if_expr_2;
  if(!(mosq->out_packet == ((struct _mosquitto_packet *)NULL)))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = mosq->current_out_packet != ((struct _mosquitto_packet *)NULL) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_1;
  if(tmp_if_expr_2)
    return (_Bool)1;

  else
  {
    if(!(mosq->ssl == ((struct ssl_st *)NULL)))
      tmp_if_expr_1 = mosq->want_write != (_Bool)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      return (_Bool)1;

    else
      return (_Bool)0;
  }
}

// mosquitto_will_clear
// file mosquitto.c line 229
signed int mosquitto_will_clear(struct mosquitto *mosq)
{
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    signed int return_value__mosquitto_will_clear_1;
    return_value__mosquitto_will_clear_1=_mosquitto_will_clear(mosq);
    return return_value__mosquitto_will_clear_1;
  }
}

// mosquitto_will_set
// file ../lib/mosquitto.h line 286
signed int mosquitto_will_set(struct mosquitto *mosq, const char *topic, signed int payloadlen, const void *payload, signed int qos, _Bool retain)
{
  if(mosq == ((struct mosquitto *)NULL))
    return 3;

  else
  {
    signed int return_value__mosquitto_will_set_1;
    return_value__mosquitto_will_set_1=_mosquitto_will_set(mosq, topic, payloadlen, payload, qos, retain);
    return return_value__mosquitto_will_set_1;
  }
}

// my_connect_callback
// file pub_client.c line 56
void my_connect_callback(struct mosquitto *mosq, void *obj, signed int result)
{
  signed int rc = 0;
  if(result == 0)
  {
    switch(mode)
    {
      case 1:

      case 4:

      case 3:
      {
        rc=mosquitto_publish(mosq, &mid_sent, topic, (signed int)msglen, (const void *)message, qos, (_Bool)retain);
        break;
      }
      case 5:
      {
        rc=mosquitto_publish(mosq, &mid_sent, topic, 0, (void *)0, qos, (_Bool)retain);
        break;
      }
      case 2:
        status = 1;
    }
    if(!(rc == 0))
    {
      if(quiet == (_Bool)0)
        switch(rc)
        {
          case 3:
          {
            fprintf(stderr, "Error: Invalid input. Does your topic contain '+' or '#'?\n");
            break;
          }
          case 1:
          {
            fprintf(stderr, "Error: Out of memory when trying to publish message.\n");
            break;
          }
          case 4:
          {
            fprintf(stderr, "Error: Client not connected when trying to publish.\n");
            break;
          }
          case 2:
          {
            fprintf(stderr, "Error: Protocol error when communicating with broker.\n");
            break;
          }
          case 9:
            fprintf(stderr, "Error: Message payload is too large.\n");
        }

      mosquitto_disconnect(mosq);
    }

  }

  else
    if(quiet == (_Bool)0 && !(result == 0))
    {
      const char *return_value_mosquitto_connack_string_1;
      return_value_mosquitto_connack_string_1=mosquitto_connack_string(result);
      fprintf(stderr, "%s\n", return_value_mosquitto_connack_string_1);
    }

}

// my_disconnect_callback
// file pub_client.c line 103
void my_disconnect_callback(struct mosquitto *mosq, void *obj, signed int rc)
{
  connected = (_Bool)0;
}

// my_log_callback
// file pub_client.c line 122
void my_log_callback(struct mosquitto *mosq, void *obj, signed int level, const char *str)
{
  printf("%s\n", str);
}

// my_publish_callback
// file pub_client.c line 108
void my_publish_callback(struct mosquitto *mosq, void *obj, signed int mid)
{
  last_mid_sent = mid;
  if(mode == 2)
  {
    if(mid == last_mid)
    {
      mosquitto_disconnect(mosq);
      disconnect_sent = (_Bool)1;
    }

  }

  else
    if((signed int)disconnect_sent == 0)
    {
      mosquitto_disconnect(mosq);
      disconnect_sent = (_Bool)1;
    }

}

// print_usage
// file pub_client.c line 201
void print_usage(void)
{
  signed int major;
  signed int minor;
  signed int revision;
  mosquitto_lib_version(&major, &minor, &revision);
  printf("mosquitto_pub is a simple mqtt client that will publish a message on a single topic and exit.\n");
  printf("mosquitto_pub version %s running on libmosquitto %d.%d.%d.\n\n", (const void *)"1.4.8", major, minor, revision);
  printf("Usage: mosquitto_pub [-h host] [-k keepalive] [-p port] [-q qos] [-r] {-f file | -l | -n | -m message} -t topic\n");
  printf("                     [-A bind_address] [-S]\n");
  printf("                     [-i id] [-I id_prefix]\n");
  printf("                     [-d] [--quiet]\n");
  printf("                     [-M max_inflight]\n");
  printf("                     [-u username [-P password]]\n");
  printf("                     [--will-topic [--will-payload payload] [--will-qos qos] [--will-retain]]\n");
  printf("                     [{--cafile file | --capath dir} [--cert file] [--key file]\n");
  printf("                      [--ciphers ciphers] [--insecure]]\n");
  printf("                     [--psk hex-key --psk-identity identity [--ciphers ciphers]]\n");
  printf("                     [--proxy socks-url]\n");
  printf("       mosquitto_pub --help\n\n");
  printf(" -A : bind the outgoing socket to this host/ip address. Use to control which interface\n");
  printf("      the client communicates over.\n");
  printf(" -d : enable debug messages.\n");
  printf(" -f : send the contents of a file as the message.\n");
  printf(" -h : mqtt host to connect to. Defaults to localhost.\n");
  printf(" -i : id to use for this client. Defaults to mosquitto_pub_ appended with the process id.\n");
  printf(" -I : define the client id as id_prefix appended with the process id. Useful for when the\n");
  printf("      broker is using the clientid_prefixes option.\n");
  printf(" -k : keep alive in seconds for this client. Defaults to 60.\n");
  printf(" -l : read messages from stdin, sending a separate message for each line.\n");
  printf(" -m : message payload to send.\n");
  printf(" -M : the maximum inflight messages for QoS 1/2..\n");
  printf(" -n : send a null (zero length) message.\n");
  printf(" -p : network port to connect to. Defaults to 1883.\n");
  printf(" -P : provide a password (requires MQTT 3.1 broker)\n");
  printf(" -q : quality of service level to use for all messages. Defaults to 0.\n");
  printf(" -r : message should be retained.\n");
  printf(" -s : read message from stdin, sending the entire input as a message.\n");
  printf(" -S : use SRV lookups to determine which host to connect to.\n");
  printf(" -t : mqtt topic to publish to.\n");
  printf(" -u : provide a username (requires MQTT 3.1 broker)\n");
  printf(" -V : specify the version of the MQTT protocol to use when connecting.\n");
  printf("      Can be mqttv31 or mqttv311. Defaults to mqttv31.\n");
  printf(" --help : display this message.\n");
  printf(" --quiet : don't print error messages.\n");
  printf(" --will-payload : payload for the client Will, which is sent by the broker in case of\n");
  printf("                  unexpected disconnection. If not given and will-topic is set, a zero\n");
  printf("                  length message will be sent.\n");
  printf(" --will-qos : QoS level for the client Will.\n");
  printf(" --will-retain : if given, make the client Will retained.\n");
  printf(" --will-topic : the topic on which to publish the client Will.\n");
  printf(" --cafile : path to a file containing trusted CA certificates to enable encrypted\n");
  printf("            communication.\n");
  printf(" --capath : path to a directory containing trusted CA certificates to enable encrypted\n");
  printf("            communication.\n");
  printf(" --cert : client certificate for authentication, if required by server.\n");
  printf(" --key : client private key for authentication, if required by server.\n");
  printf(" --ciphers : openssl compatible list of TLS ciphers to support.\n");
  printf(" --tls-version : TLS protocol version, can be one of tlsv1.2 tlsv1.1 or tlsv1.\n");
  printf("                 Defaults to tlsv1.2 if available.\n");
  printf(" --insecure : do not check that the server certificate hostname matches the remote\n");
  printf("              hostname. Using this option means that you cannot be sure that the\n");
  printf("              remote host is the server you wish to connect to and so is insecure.\n");
  printf("              Do not use this option in a production environment.\n");
  printf(" --psk : pre-shared-key in hexadecimal (no leading 0x) to enable TLS-PSK mode.\n");
  printf(" --psk-identity : client identity string for TLS-PSK mode.\n");
  printf(" --proxy : SOCKS5 proxy URL of the form:\n");
  printf("           socks5h://[username[:password]@]hostname[:port]\n");
  printf("           Only \"none\" and \"username\" authentication is supported.\n");
  printf("\nSee http://mosquitto.org/ for more information.\n\n");
}

// psk_client_callback
// file net_mosq.c line 253
static unsigned int psk_client_callback(struct ssl_st *ssl, const char *hint, char *identity, unsigned int max_identity_len, unsigned char *psk, unsigned int max_psk_len)
{
  struct mosquitto *mosq;
  signed int len;
  void *return_value_SSL_get_ex_data_1;
  return_value_SSL_get_ex_data_1=SSL_get_ex_data(ssl, tls_ex_index_mosq);
  mosq = (struct mosquitto *)return_value_SSL_get_ex_data_1;
  if(mosq == ((struct mosquitto *)NULL))
    return (unsigned int)0;

  else
  {
    snprintf(identity, (unsigned long int)max_identity_len, "%s", mosq->tls_psk_identity);
    len=_mosquitto_hex2bin(mosq->tls_psk, psk, (signed int)max_psk_len);
    if(!(len >= 0))
      return (unsigned int)0;

    else
      return (unsigned int)len;
  }
}

// srv_callback
// file srv_mosq.c line 31
static void srv_callback(void *arg, signed int status, signed int timeouts, unsigned char *abuf, signed int alen)
{
  struct mosquitto *mosq = (struct mosquitto *)arg;
  struct ares_srv_reply *reply = (struct ares_srv_reply *)(void *)0;
  if(status == 0)
  {
    status=ares_parse_srv_reply(abuf, alen, &reply);
    if(status == 0)
      mosquitto_connect(mosq, reply->host, (signed int)reply->port, (signed int)mosq->keepalive);

  }

  else
  {
    _mosquitto_log_printf(mosq, 0x08, "Error: SRV lookup failed (%d).", status);
    pthread_mutex_lock(&mosq->callback_mutex);
    if(!(mosq->on_disconnect == ((void (*)(struct mosquitto *, void *, signed int))NULL)))
    {
      mosq->in_callback = (_Bool)1;
      mosq->on_disconnect(mosq, mosq->userdata, 2);
      mosq->in_callback = (_Bool)0;
    }

    pthread_mutex_unlock(&mosq->callback_mutex);
  }
}

