// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$15;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$13;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$6;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$5;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#}$SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#$'__cancel_jmp_buf'||ARR4{*{V}$V$}$*{V}$V$$'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous$1;

// tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous$0;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous$17;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$9;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$12;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$11;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$8;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$10;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$14;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$4;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$3;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$16;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$7;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$2;

// tag-LDAPDerefRes
// file /usr/include/ldap.h line 2485
struct LDAPDerefRes;

// tag-LDAPDerefSpec
// file /usr/include/ldap.h line 2474
struct LDAPDerefSpec;

// tag-LDAPDerefVal
// file /usr/include/ldap.h line 2479
struct LDAPDerefVal;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-berelement
// file /usr/include/lber.h line 171
struct berelement;

// tag-berval
// file /usr/include/lber.h line 212
struct berval;

// tag-dict_entry
// file dict.c line 52
struct dict_entry;

// tag-dictionary
// file dict.h line 31
struct dictionary;

// tag-dn2uid_cache_entry
// file passwd.c line 164
struct dn2uid_cache_entry;

// tag-ether_addr
// file /usr/include/net/ethernet.h line 32
struct ether_addr;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-ldap
// file /usr/include/ldap.h line 752
struct ldap;

// tag-ldap_config
// file cfg.h line 83
struct ldap_config;

// tag-ldap_conncb
// file /usr/include/ldap.h line 930
struct ldap_conncb;

// tag-ldap_map_selector
// file cfg.h line 59
enum ldap_map_selector { LM_ALIASES=0, LM_ETHERS=1, LM_GROUP=2, LM_HOSTS=3, LM_NETGROUP=4, LM_NETWORKS=5, LM_PASSWD=6, LM_PROTOCOLS=7, LM_RPC=8, LM_SERVICES=9, LM_SHADOW=10, LM_NFSIDMAP=11, LM_NONE=12 };

// tag-ldap_session
// file myldap.h line 51
struct ldap_session;

// tag-ldap_ssl_options
// file cfg.h line 52
enum ldap_ssl_options { SSL_OFF=0, SSL_LDAPS=1, SSL_START_TLS=2 };

// tag-ldap_url_desc
// file /usr/include/ldap.h line 769
struct ldap_url_desc;

// tag-ldapcontrol
// file /usr/include/ldap.h line 244
struct ldapcontrol;

// tag-ldapmod
// file /usr/include/ldap.h line 724
struct ldapmod;

// tag-ldapmsg
// file /usr/include/ldap.h line 721
struct ldapmsg;

// tag-log_cfg
// file log.c line 43
struct log_cfg;

// tag-mod_vals_u
// file /usr/include/ldap.h line 739
union mod_vals_u;

// tag-myldap_entry
// file myldap.h line 64
struct myldap_entry;

// tag-myldap_search
// file myldap.h line 61
struct myldap_search;

// tag-myldap_uri
// file cfg.h line 75
struct myldap_uri;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-passpolicyerror_enum
// file /usr/include/ldap.h line 2280
enum passpolicyerror_enum { PP_passwordExpired=0, PP_accountLocked=1, PP_changeAfterReset=2, PP_passwordModNotAllowed=3, PP_mustSupplyOldPassword=4, PP_insufficientPasswordQuality=5, PP_passwordTooShort=6, PP_passwordTooYoung=7, PP_passwordInHistory=8, PP_noError=65535 };

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-sasl_interact
// file /usr/include/sasl/sasl.h line 884
struct sasl_interact;

// tag-set
// file ../common/set.h line 32
struct set;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-sockbuf
// file /usr/include/lber.h line 172
struct sockbuf;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tio_buffer
// file tio.c line 55
struct tio_buffer;

// tag-tio_fileinfo
// file tio.h line 46
struct tio_fileinfo;

// tag-ucred
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 311
struct ucred;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __h_errno_location
// file /usr/include/netdb.h line 61
extern signed int * __h_errno_location(void);
// __nss_configure_lookup
// file /usr/include/nss.h line 58
extern signed int __nss_configure_lookup(const char *, const char *);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous$1 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous$1 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous$1 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$2, unsigned int *);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// add_uri
// file cfg.c line 390
static void add_uri(const char *filename, signed int lnr, struct ldap_config *cfg, const char *uri);
// add_uris_from_dns
// file cfg.c line 423
static void add_uris_from_dns(const char *filename, signed int lnr, struct ldap_config *cfg, const char *domain);
// addlogging
// file log.c line 84
static void addlogging(signed int loglevel, const char *scheme, struct _IO_FILE *fp);
// adjust_oom_score
// file nslcd.c line 654
static void adjust_oom_score(void);
// alias_init
// file common.h line 206
void alias_init(void);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// attmap_add_attributes
// file attmap.c line 302
struct set * attmap_add_attributes(struct set *set, const char *attr);
// attmap_get_value
// file attmap.h line 92
const char * attmap_get_value(struct myldap_entry *entry, const char *attr, char *buffer, unsigned long int buflen);
// attmap_get_var
// file attmap.h line 83
const char ** attmap_get_var(enum ldap_map_selector map, const char *name);
// attmap_set_mapping
// file attmap.h line 87
const char * attmap_set_mapping(const char **var, const char *value);
// autzsearch_var_add
// file pam.c line 354
static void autzsearch_var_add(struct dictionary *dict, const char *name, const char *value);
// autzsearch_var_get
// file pam.c line 397
static const char * autzsearch_var_get(const char *name, void *expander_attr);
// autzsearch_vars_free
// file pam.c line 378
static void autzsearch_vars_free(struct dictionary *dict);
// base_get_var
// file attmap.h line 72
const char ** base_get_var(enum ldap_map_selector map);
// ber_bvfree
// file /usr/include/lber.h line 611
extern void ber_bvfree(struct berval *);
// ber_free
// file /usr/include/lber.h line 454
extern void ber_free(struct berelement *, signed int);
// ber_set_option
// file /usr/include/lber.h line 543
extern signed int ber_set_option(void *, signed int, const void *);
// bervalues_to_values
// file myldap.c line 1891
static const char ** bervalues_to_values(struct berval **bvalues);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$2, unsigned int);
// binsid2id
// file common.c line 330
unsigned long int binsid2id(const char *binsid);
// cfg_defaults
// file cfg.c line 1146
static void cfg_defaults(struct ldap_config *cfg);
// cfg_dump
// file cfg.c line 1626
static void cfg_dump(void);
// cfg_getdomainname
// file cfg.c line 411
static const char * cfg_getdomainname(const char *filename, signed int lnr);
// cfg_init
// file cfg.h line 144
void cfg_init(const char *fname);
// cfg_read
// file cfg.c line 1210
static void cfg_read(const char *filename, struct ldap_config *cfg);
// change
// file usermod.c line 145
static signed int change(struct ldap_session *session, const char *userdn, const char *homedir, const char *shell);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// check_argumentcount
// file cfg.c line 100
static inline void check_argumentcount(const char *filename, signed int lnr, const char *keyword, signed int condition);
// check_permissions
// file cfg.c line 1124
static void check_permissions(const char *filename, const char *keyword);
// check_shadow
// file pam.c line 159
static signed int check_shadow(struct ldap_session *session, const char *username, char *authzmsg, unsigned long int authzmsgsz, signed int check_maxdays, signed int check_mindays);
// chmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 283
extern signed int chmod(const char *, unsigned int);
// clearenv
// file /usr/include/stdlib.h line 595
extern signed int clearenv(void);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closefd
// file daemonize.c line 128
static void closefd(void);
// connect_cb
// file myldap.c line 782
static signed int connect_cb(struct ldap *ld, struct sockbuf *sb, struct ldap_url_desc *srv, struct sockaddr *addr, struct ldap_conncb *ctx);
// create_pidfile
// file nslcd.c line 465
static void create_pidfile(const char *filename);
// create_socket
// file nslcd.c line 246
static signed int create_socket(const char *filename);
// daemonize_closefds
// file daemonize.h line 45
void daemonize_closefds(void);
// daemonize_daemon
// file daemonize.h line 60
signed int daemonize_daemon(void);
// daemonize_ready
// file daemonize.h line 65
void daemonize_ready(signed int status, const char *message);
// daemonize_redirect_stdio
// file daemonize.h line 48
void daemonize_redirect_stdio(void);
// dict_free
// file ../common/dict.h line 64
void dict_free(struct dictionary *dict);
// dict_get
// file ../common/dict.h line 48
void * dict_get(struct dictionary *dict, const char *key);
// dict_getany
// file dict.c line 179
const char * dict_getany(struct dictionary *dict);
// dict_keys
// file ../common/dict.h line 68
const char ** dict_keys(struct dictionary *dict);
// dict_new
// file ../common/dict.h line 35
struct dictionary * dict_new(void);
// dict_put
// file ../common/dict.h line 43
signed int dict_put(struct dictionary *dict, const char *key, void *value);
// dirname
// file /usr/include/libgen.h line 26
extern char * dirname(char *);
// disable_nss_ldap
// file nslcd.c line 601
static void disable_nss_ldap(void);
// disconnect_cb
// file myldap.c line 796
static void disconnect_cb(struct ldap *ld, struct sockbuf *sb, struct ldap_conncb *ctx);
// display_usage
// file nslcd.c line 130
static void display_usage(struct _IO_FILE *fp, const char *program_name);
// display_version
// file nslcd.c line 120
static void display_version(struct _IO_FILE *fp);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// dn2uid
// file common.h line 118
char * dn2uid(struct ldap_session *session, const char *dn, char *buf, unsigned long int buflen);
// do_autzsearches
// file pam.c line 406
static signed int do_autzsearches(struct ldap_session *session, const char *filter);
// do_bind
// file myldap.c line 605
static signed int do_bind(struct ldap_session *session, struct ldap *ld, const char *uri);
// do_close
// file myldap.c line 900
static void do_close(struct ldap_session *session);
// do_open
// file myldap.c line 1011
static signed int do_open(struct ldap_session *session);
// do_ppolicy_bind
// file myldap.c line 522
static signed int do_ppolicy_bind(struct ldap_session *session, struct ldap *ld, const char *uri);
// do_rebind
// file myldap.c line 704
static signed int do_rebind(struct ldap *ld, const char *url, unsigned long int request, signed int msgid, void *arg);
// do_retry_search
// file myldap.c line 1236
static signed int do_retry_search(struct myldap_search *search);
// do_sasl_interact
// file myldap.c line 338
static signed int do_sasl_interact(struct ldap *ld, unsigned int flags, void *defaults, void *_interact);
// do_set_options
// file myldap.c line 805
static signed int do_set_options(struct ldap_session *session);
// do_try_search
// file myldap.c line 1101
static signed int do_try_search(struct myldap_search *search);
// do_write_group
// file group.c line 229
static signed int do_write_group(struct tio_fileinfo *fp, struct myldap_entry *entry, const char **names, unsigned int *gids, signed int numgids, const char *passwd, const char **members, const char *reqname);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// empty_expander
// file expr.c line 70
static const char * empty_expander(const char *name, void *expander_arg);
// endpwent
// file /usr/include/pwd.h line 78
extern void endpwent(void);
// endusershell
// file /usr/include/unistd.h line 930
extern void endusershell(void);
// entry_expand
// file attmap.c line 245
static const char * entry_expand(const char *name, void *expander_attr);
// entry_has_valid_uid
// file passwd.c line 171
static signed int entry_has_valid_uid(struct myldap_entry *entry);
// ether_aton_r
// file /usr/include/netinet/ether.h line 36
extern struct ether_addr * ether_aton_r(const char *, struct ether_addr *);
// ether_init
// file common.h line 207
void ether_init(void);
// ether_ntoa_r
// file /usr/include/netinet/ether.h line 31
extern char * ether_ntoa_r(struct ether_addr *, char *);
// exec_invalidate
// file invalidator.c line 65
static void exec_invalidate(const char *db);
// execvpe
// file /usr/include/unistd.h line 590
extern signed int execvpe(const char *, char * const *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exithandler
// file nslcd.c line 201
static void exithandler(void);
// expr_parse
// file ../common/expr.h line 34
const char * expr_parse(const char *str, char *buffer, unsigned long int buflen, const char * (*expander)(const char *, void *), void *expander_arg);
// expr_parse::expander$object
//
const char * expander$object(const char *, void *);
// expr_vars
// file ../common/expr.h line 39
struct set * expr_vars(const char *str, struct set *set);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// filter_get_var
// file attmap.h line 78
const char ** filter_get_var(enum ldap_map_selector map);
// find_db
// file nsswitch.c line 74
static const char * find_db(const char *line, const char *db);
// find_rdn_value
// file myldap.c line 1998
static const char * find_rdn_value(char **exploded_rdn, const char *attr);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// get_base_from_rootdse
// file cfg.c line 1075
static char * get_base_from_rootdse(void);
// get_boolean
// file cfg.c line 201
static signed int get_boolean(const char *filename, signed int lnr, const char *keyword, char **line);
// get_eol
// file cfg.c line 163
static void get_eol(const char *filename, signed int lnr, const char *keyword, char **line);
// get_exploded_rdn
// file myldap.c line 2035
static char ** get_exploded_rdn(const char *dn);
// get_int
// file cfg.c line 173
static signed int get_int(const char *filename, signed int lnr, const char *keyword, char **line);
// get_linedup
// file cfg.c line 152
static char * get_linedup(const char *filename, signed int lnr, const char *keyword, char **line);
// get_map
// file cfg.c line 567
static enum ldap_map_selector get_map(char **line);
// get_session
// file usermod.c line 107
static struct ldap_session * get_session(const char *binddn, const char *userdn, const char *password, signed int *rcp);
// get_shadow_properties
// file shadow.c line 192
void get_shadow_properties(struct myldap_entry *entry, signed long int *lastchangedate, signed long int *mindays, signed long int *maxdays, signed long int *warndays, signed long int *inactdays, signed long int *expiredate, unsigned long int *flag);
// get_strdup
// file cfg.c line 143
static char * get_strdup(const char *filename, signed int lnr, const char *keyword, char **line);
// get_time
// file cfg.c line 250
static signed long int get_time(const char *filename, signed int lnr, const char *keyword, char **line);
// get_token
// file cfg.c line 116
static char * get_token(char **line, char *buf, unsigned long int buflen);
// get_userpassword
// file common.c line 183
const char * get_userpassword(struct myldap_entry *entry, const char *attr, char *buffer, unsigned long int buflen);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getfqdn
// file common.c line 118
const char * getfqdn(void);
// getgrnam
// file /usr/include/grp.h line 110
extern struct group * getgrnam(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getmembers
// file group.c line 259
static void getmembers(struct myldap_entry *entry, struct ldap_session *session, struct set *members, struct set *seen, struct set *subgroups);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpeercred
// file ../compat/getpeercred.h line 33
signed int getpeercred(signed int sock, unsigned int *uid, unsigned int *gid, signed int *pid);
// getpeername
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 141
extern signed int getpeername(signed int, union anonymous$2, unsigned int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwent
// file /usr/include/pwd.h line 84
extern struct passwd * getpwent(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// getusershell
// file /usr/include/unistd.h line 929
extern char * getusershell(void);
// group_init
// file common.h line 208
void group_init(void);
// growhashtable
// file dict.c line 83
static void growhashtable(struct dictionary *dict);
// gss_krb5_ccache_name
// file /usr/include/gssapi/gssapi_krb5.h line 167
unsigned int gss_krb5_ccache_name(unsigned int *, const char *, const char **);
// handle_base
// file cfg.c line 605
static void handle_base(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg);
// handle_cache
// file cfg.c line 1043
static void handle_cache(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg);
// handle_deref
// file cfg.c line 695
static void handle_deref(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg);
// handle_filter
// file cfg.c line 730
static void handle_filter(const char *filename, signed int lnr, const char *keyword, char *line);
// handle_gid
// file cfg.c line 314
static void handle_gid(const char *filename, signed int lnr, const char *keyword, char *line, unsigned int *gid);
// handle_krb5_ccname
// file cfg.c line 485
static void handle_krb5_ccname(const char *filename, signed int lnr, const char *keyword, char *line);
// handle_log
// file cfg.c line 364
static void handle_log(const char *filename, signed int lnr, const char *keyword, char *line);
// handle_map
// file cfg.c line 752
static void handle_map(const char *filename, signed int lnr, const char *keyword, char *line);
// handle_nss_initgroups_ignoreusers
// file cfg.c line 844
static void handle_nss_initgroups_ignoreusers(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg);
// handle_pam_authz_search
// file cfg.c line 944
static void handle_pam_authz_search(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg);
// handle_pam_password_prohibit_message
// file cfg.c line 991
static void handle_pam_password_prohibit_message(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg);
// handle_ppolicy_controls
// file myldap.c line 409
static void handle_ppolicy_controls(struct ldap_session *session, struct ldap *ld, struct ldapcontrol **ctrls);
// handle_reconnect_invalidate
// file cfg.c line 1009
static void handle_reconnect_invalidate(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg);
// handle_requests
// file invalidator.c line 154
static void handle_requests(signed int fd);
// handle_scope
// file cfg.c line 651
static void handle_scope(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg);
// handle_tls_reqcert
// file cfg.c line 798
static void handle_tls_reqcert(const char *filename, signed int lnr, const char *keyword, char *line);
// handle_uid
// file cfg.c line 273
static void handle_uid(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg);
// handle_validnames
// file cfg.c line 889
static void handle_validnames(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg);
// handleconnection
// file nslcd.c line 352
static void handleconnection(signed int sock, struct ldap_session *session);
// has_service
// file nsswitch.c line 93
static signed int has_service(const char *services, const char *service, const char *filename, signed int lnr);
// host_init
// file common.h line 209
void host_init(void);
// hstrerror
// file /usr/include/netdb.h line 95
extern const char * hstrerror(signed int);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// initgroups
// file /usr/include/grp.h line 200
extern signed int initgroups(const char *, unsigned int);
// install_sighandler
// file nslcd.c line 502
static void install_sighandler(signed int signum, void (*handler)(signed int));
// install_sighandler::handler$object
//
void handler$object(signed int);
// invalidator_do
// file common.h line 151
void invalidator_do(enum ldap_map_selector map);
// invalidator_start
// file common.h line 148
signed int invalidator_start(void);
// is_locked
// file nslcd.c line 439
static signed int is_locked(const char *filename);
// is_valid_entry
// file myldap.c line 329
static inline signed int is_valid_entry(struct myldap_entry *entry);
// is_valid_homedir
// file usermod.c line 68
static signed int is_valid_homedir(const char *homedir);
// is_valid_shell
// file usermod.c line 90
static signed int is_valid_shell(const char *shell);
// isvalidname
// file common.c line 205
signed int isvalidname(const char *name);
// lchown
// file /usr/include/unistd.h line 483
extern signed int lchown(const char *, unsigned int, unsigned int);
// ldap_abandon
// file /usr/include/ldap.h line 1122
extern signed int ldap_abandon(struct ldap *, signed int);
// ldap_control_free
// file /usr/include/ldap.h line 1037
extern void ldap_control_free(struct ldapcontrol *);
// ldap_controls_free
// file /usr/include/ldap.h line 1041
extern void ldap_controls_free(struct ldapcontrol **);
// ldap_count_values_len
// file /usr/include/ldap.h line 1806
extern signed int ldap_count_values_len(struct berval **);
// ldap_create_deref_control
// file /usr/include/ldap.h line 2499
extern signed int ldap_create_deref_control(struct ldap *, struct LDAPDerefSpec *, signed int, struct ldapcontrol **);
// ldap_create_page_control
// file /usr/include/ldap.h line 2112
extern signed int ldap_create_page_control(struct ldap *, signed int, struct berval *, signed int, struct ldapcontrol **);
// ldap_derefresponse_free
// file /usr/include/ldap.h line 2506
extern void ldap_derefresponse_free(struct LDAPDerefRes *);
// ldap_domain2dn
// file /usr/include/ldap.h line 1056
extern signed int ldap_domain2dn(const char *, char **);
// ldap_domain2hostlist
// file /usr/include/ldap.h line 1066
extern signed int ldap_domain2hostlist(const char *, char **);
// ldap_err2string
// file /usr/include/ldap.h line 1364
extern char * ldap_err2string(signed int);
// ldap_explode_dn
// file /usr/include/ldap.h line 1743
extern char ** ldap_explode_dn(const char *, signed int);
// ldap_explode_rdn
// file /usr/include/ldap.h line 1748
extern char ** ldap_explode_rdn(const char *, signed int);
// ldap_first_attribute
// file /usr/include/ldap.h line 1784
extern char * ldap_first_attribute(struct ldap *, struct ldapmsg *, struct berelement **);
// ldap_get_dn
// file /usr/include/ldap.h line 1642
extern char * ldap_get_dn(struct ldap *, struct ldapmsg *);
// ldap_get_entry_controls
// file /usr/include/ldap.h line 1618
extern signed int ldap_get_entry_controls(struct ldap *, struct ldapmsg *, struct ldapcontrol ***);
// ldap_get_option
// file /usr/include/ldap.h line 958
extern signed int ldap_get_option(struct ldap *, signed int, void *);
// ldap_get_values
// file /usr/include/ldap.h line 1815
extern char ** ldap_get_values(struct ldap *, struct ldapmsg *, const char *);
// ldap_get_values_len
// file /usr/include/ldap.h line 1800
extern struct berval ** ldap_get_values_len(struct ldap *, struct ldapmsg *, const char *);
// ldap_initialize
// file /usr/include/ldap.h line 1521
extern signed int ldap_initialize(struct ldap **, const char *);
// ldap_memfree
// file /usr/include/ldap.h line 1982
extern void ldap_memfree(void *);
// ldap_modify_ext_s
// file /usr/include/ldap.h line 1410
extern signed int ldap_modify_ext_s(struct ldap *, const char *, struct ldapmod **, struct ldapcontrol **, struct ldapcontrol **);
// ldap_msgfree
// file /usr/include/ldap.h line 1849
extern signed int ldap_msgfree(struct ldapmsg *);
// ldap_next_attribute
// file /usr/include/ldap.h line 1790
extern char * ldap_next_attribute(struct ldap *, struct ldapmsg *, struct berelement *);
// ldap_parse_deref_control
// file /usr/include/ldap.h line 2516
extern signed int ldap_parse_deref_control(struct ldap *, struct ldapcontrol **, struct LDAPDerefRes **);
// ldap_parse_page_control
// file /usr/include/ldap.h line 2121
extern signed int ldap_parse_page_control(struct ldap *, struct ldapcontrol **, signed int *, struct berval **);
// ldap_parse_passwordpolicy_control
// file /usr/include/ldap.h line 2299
extern signed int ldap_parse_passwordpolicy_control(struct ldap *, struct ldapcontrol *, signed int *, signed int *, enum passpolicyerror_enum *);
// ldap_parse_result
// file /usr/include/ldap.h line 1353
extern signed int ldap_parse_result(struct ldap *, struct ldapmsg *, signed int *, char **, char **, char ***, struct ldapcontrol ***, signed int);
// ldap_passwd_s
// file /usr/include/ldap.h line 2264
extern signed int ldap_passwd_s(struct ldap *, struct berval *, struct berval *, struct berval *, struct berval *, struct ldapcontrol **, struct ldapcontrol **);
// ldap_passwordpolicy_err2txt
// file /usr/include/ldap.h line 2307
extern const char * ldap_passwordpolicy_err2txt(enum passpolicyerror_enum);
// ldap_result
// file /usr/include/ldap.h line 1833
extern signed int ldap_result(struct ldap *, signed int, signed int, struct timeval *, struct ldapmsg **);
// ldap_sasl_bind
// file /usr/include/ldap.h line 1166
extern signed int ldap_sasl_bind(struct ldap *, const char *, const char *, struct berval *, struct ldapcontrol **, struct ldapcontrol **, signed int *);
// ldap_sasl_interactive_bind_s
// file /usr/include/ldap.h line 1213
extern signed int ldap_sasl_interactive_bind_s(struct ldap *, const char *, const char *, struct ldapcontrol **, struct ldapcontrol **, unsigned int, signed int (*)(struct ldap *, unsigned int, void *, void *), void *);
// ldap_search_ext
// file /usr/include/ldap.h line 1867
extern signed int ldap_search_ext(struct ldap *, const char *, signed int, const char *, char **, signed int, struct ldapcontrol **, struct ldapcontrol **, struct timeval *, signed int, signed int *);
// ldap_set_option
// file /usr/include/ldap.h line 964
extern signed int ldap_set_option(struct ldap *, signed int, const void *);
// ldap_set_rebind_proc
// file /usr/include/ldap.h line 976
extern signed int ldap_set_rebind_proc(struct ldap *, signed int (*)(struct ldap *, const char *, unsigned long int, signed int, void *), void *);
// ldap_simple_bind_s
// file /usr/include/ldap.h line 1271
extern signed int ldap_simple_bind_s(struct ldap *, const char *, const char *);
// ldap_start_tls_s
// file /usr/include/ldap.h line 1549
extern signed int ldap_start_tls_s(struct ldap *, struct ldapcontrol **, struct ldapcontrol **);
// ldap_unbind
// file /usr/include/ldap.h line 1947
extern signed int ldap_unbind(struct ldap *);
// ldap_value_free
// file /usr/include/ldap.h line 1825
extern void ldap_value_free(char **);
// ldap_value_free_len
// file /usr/include/ldap.h line 1810
extern void ldap_value_free_len(struct berval **);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// lockf
// file /usr/include/unistd.h line 1081
extern signed int lockf(signed int, signed int, signed long int);
// log_addlogging_file
// file log.c line 109
void log_addlogging_file(signed int loglevel, const char *filename);
// log_addlogging_none
// file log.c line 136
void log_addlogging_none(void);
// log_addlogging_syslog
// file log.c line 129
void log_addlogging_syslog(signed int loglevel);
// log_clearsession
// file log.h line 51
void log_clearsession(void);
// log_log
// file log.h line 59
void log_log(signed int pri, const char *format, ...);
// log_log_config
// file log.c line 321
void log_log_config(void);
// log_newsession
// file log.h line 47
void log_newsession(void);
// log_setdefaultloglevel
// file log.h line 30
void log_setdefaultloglevel(signed int loglevel);
// log_setrequest
// file log.c line 200
void log_setrequest(const char *format, ...);
// log_startlogging
// file log.h line 43
void log_startlogging(void);
// loglevel2str
// file log.c line 306
static const char * loglevel2str(signed int loglevel);
// lookup_dn2uid
// file passwd.c line 219
char * lookup_dn2uid(struct ldap_session *session, const char *dn, signed int *rcp, char *buf, unsigned long int buflen);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// map2name
// file invalidator.c line 43
static const char * map2name(enum ldap_map_selector map);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mkdirname
// file nslcd.c line 227
static void mkdirname(const char *filename);
// mkfilter_alias_byname
// file alias.c line 64
static signed int mkfilter_alias_byname(const char *name, char *buffer, unsigned long int buflen);
// mkfilter_ether_byether
// file ether.c line 81
static signed int mkfilter_ether_byether(const char *addrstr, char *buffer, unsigned long int buflen);
// mkfilter_ether_byname
// file ether.c line 66
static signed int mkfilter_ether_byname(const char *name, char *buffer, unsigned long int buflen);
// mkfilter_group_bygid
// file group.c line 108
static signed int mkfilter_group_bygid(unsigned int gid, char *buffer, unsigned long int buflen);
// mkfilter_group_bymember
// file group.c line 133
static signed int mkfilter_group_bymember(struct ldap_session *session, const char *uid, char *buffer, unsigned long int buflen);
// mkfilter_group_bymemberdn
// file group.c line 164
static signed int mkfilter_group_bymemberdn(const char *dn, char *buffer, unsigned long int buflen);
// mkfilter_group_byname
// file group.c line 91
static signed int mkfilter_group_byname(const char *name, char *buffer, unsigned long int buflen);
// mkfilter_host_byaddr
// file host.c line 81
static signed int mkfilter_host_byaddr(const char *addrstr, char *buffer, unsigned long int buflen);
// mkfilter_host_byname
// file host.c line 67
static signed int mkfilter_host_byname(const char *name, char *buffer, unsigned long int buflen);
// mkfilter_netgroup_byname
// file netgroup.c line 65
static signed int mkfilter_netgroup_byname(const char *name, char *buffer, unsigned long int buflen);
// mkfilter_network_byaddr
// file network.c line 80
static signed int mkfilter_network_byaddr(const char *addrstr, char *buffer, unsigned long int buflen);
// mkfilter_network_byname
// file network.c line 65
static signed int mkfilter_network_byname(const char *name, char *buffer, unsigned long int buflen);
// mkfilter_passwd_byname
// file passwd.c line 87
static signed int mkfilter_passwd_byname(const char *name, char *buffer, unsigned long int buflen);
// mkfilter_passwd_byuid
// file passwd.c line 104
static signed int mkfilter_passwd_byuid(unsigned int uid, char *buffer, unsigned long int buflen);
// mkfilter_protocol_byname
// file protocol.c line 65
static signed int mkfilter_protocol_byname(const char *name, char *buffer, unsigned long int buflen);
// mkfilter_protocol_bynumber
// file protocol.c line 82
static signed int mkfilter_protocol_bynumber(signed int protocol, char *buffer, unsigned long int buflen);
// mkfilter_rpc_byname
// file rpc.c line 67
static signed int mkfilter_rpc_byname(const char *name, char *buffer, unsigned long int buflen);
// mkfilter_rpc_bynumber
// file rpc.c line 81
static signed int mkfilter_rpc_bynumber(signed int number, char *buffer, unsigned long int buflen);
// mkfilter_service_byname
// file service.c line 68
static signed int mkfilter_service_byname(const char *name, const char *protocol, char *buffer, unsigned long int buflen);
// mkfilter_service_bynumber
// file service.c line 95
static signed int mkfilter_service_bynumber(signed int number, const char *protocol, char *buffer, unsigned long int buflen);
// mkfilter_shadow_byname
// file shadow.c line 73
static signed int mkfilter_shadow_byname(const char *name, char *buffer, unsigned long int buflen);
// my_isalpha
// file expr.c line 36
static inline signed int my_isalpha(const char c);
// my_isalphanum
// file expr.c line 41
static inline signed int my_isalphanum(const char c);
// myldap_cpy_dn
// file myldap.c line 1704
char * myldap_cpy_dn(struct myldap_entry *entry, char *buf, unsigned long int buflen);
// myldap_cpy_rdn_value
// file myldap.c line 2094
const char * myldap_cpy_rdn_value(const char *dn, const char *attr, char *buf, unsigned long int buflen);
// myldap_create_session
// file myldap.h line 69
struct ldap_session * myldap_create_session(void);
// myldap_entry_free
// file myldap.c line 216
static void myldap_entry_free(struct myldap_entry *entry);
// myldap_entry_new
// file myldap.c line 191
static struct myldap_entry * myldap_entry_new(struct myldap_search *search);
// myldap_err
// file myldap.c line 157
static void myldap_err(signed int pri, struct ldap *ld, signed int rc, const char *format, ...);
// myldap_error_message
// file myldap.c line 2428
signed int myldap_error_message(struct ldap_session *session, signed int rc, char *buffer, unsigned long int buflen);
// myldap_escape
// file myldap.c line 2285
signed int myldap_escape(const char *src, char *buffer, unsigned long int buflen);
// myldap_get_deref_values
// file myldap.c line 2138
const char *** myldap_get_deref_values(struct myldap_entry *entry, const char *derefattr, const char *getattr);
// myldap_get_dn
// file myldap.h line 120
const char * myldap_get_dn(struct myldap_entry *entry);
// myldap_get_entry
// file myldap.c line 1461
struct myldap_entry * myldap_get_entry(struct myldap_search *search, signed int *rcp);
// myldap_get_policy_response
// file myldap.c line 1092
void myldap_get_policy_response(struct ldap_session *session, signed int *response, const char **message);
// myldap_get_ranged_values
// file myldap.c line 1720
static char ** myldap_get_ranged_values(struct myldap_entry *entry, const char *attr);
// myldap_get_rdn_value
// file myldap.c line 2068
const char * myldap_get_rdn_value(struct myldap_entry *entry, const char *attr);
// myldap_get_values
// file myldap.c line 1818
const char ** myldap_get_values(struct myldap_entry *entry, const char *attr);
// myldap_get_values_len
// file myldap.c line 1925
const char ** myldap_get_values_len(struct myldap_entry *entry, const char *attr);
// myldap_has_objectclass
// file myldap.c line 2116
signed int myldap_has_objectclass(struct myldap_entry *entry, const char *objectclass);
// myldap_immediate_reconnect
// file myldap.h line 95
void myldap_immediate_reconnect(void);
// myldap_modify
// file myldap.c line 2417
signed int myldap_modify(struct ldap_session *session, const char *dn, struct ldapmod **mods);
// myldap_passwd
// file myldap.c line 2367
signed int myldap_passwd(struct ldap_session *session, const char *userdn, const char *oldpassword, const char *newpasswd);
// myldap_search
// file myldap.c line 1374
struct myldap_search * myldap_search(struct ldap_session *session, const char *base, signed int scope, const char *filter, const char **attrs, signed int *rcp);
// myldap_search_close
// file myldap.c line 1425
void myldap_search_close(struct myldap_search *search);
// myldap_search_new
// file myldap.c line 240
static struct myldap_search * myldap_search_new(struct ldap_session *session, const char *base, signed int scope, const char *filter, const char **attrs);
// myldap_session_check
// file myldap.h line 87
void myldap_session_check(struct ldap_session *session);
// myldap_session_cleanup
// file myldap.h line 82
void myldap_session_cleanup(struct ldap_session *session);
// myldap_session_close
// file myldap.h line 91
void myldap_session_close(struct ldap_session *session);
// myldap_session_new
// file myldap.c line 303
static struct ldap_session * myldap_session_new(void);
// myldap_set_credentials
// file myldap.c line 1064
signed int myldap_set_credentials(struct ldap_session *session, const char *dn, const char *password);
// myldap_set_debuglevel
// file myldap.h line 160
signed int myldap_set_debuglevel(signed int level);
// mysnprintf
// file common.h line 64
signed int mysnprintf(char *buffer, unsigned long int buflen, const char *format, ...);
// netgroup_init
// file common.h line 210
void netgroup_init(void);
// network_init
// file common.h line 211
void network_init(void);
// nslcd_alias_all
// file common.h line 222
signed int nslcd_alias_all(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_alias_byname
// file common.h line 221
signed int nslcd_alias_byname(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_config_get
// file common.h line 220
signed int nslcd_config_get(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_ether_all
// file common.h line 225
signed int nslcd_ether_all(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_ether_byether
// file common.h line 224
signed int nslcd_ether_byether(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_ether_byname
// file common.h line 223
signed int nslcd_ether_byname(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_group_all
// file common.h line 229
signed int nslcd_group_all(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_group_bygid
// file common.h line 227
signed int nslcd_group_bygid(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_group_bymember
// file common.h line 228
signed int nslcd_group_bymember(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_group_byname
// file common.h line 226
signed int nslcd_group_byname(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_host_all
// file common.h line 232
signed int nslcd_host_all(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_host_byaddr
// file common.h line 231
signed int nslcd_host_byaddr(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_host_byname
// file common.h line 230
signed int nslcd_host_byname(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_netgroup_all
// file common.h line 234
signed int nslcd_netgroup_all(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_netgroup_byname
// file common.h line 233
signed int nslcd_netgroup_byname(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_network_all
// file common.h line 237
signed int nslcd_network_all(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_network_byaddr
// file common.h line 236
signed int nslcd_network_byaddr(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_network_byname
// file common.h line 235
signed int nslcd_network_byname(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_pam_authc
// file common.h line 252
signed int nslcd_pam_authc(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid);
// nslcd_pam_authz
// file common.h line 253
signed int nslcd_pam_authz(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_pam_pwmod
// file common.h line 256
signed int nslcd_pam_pwmod(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid);
// nslcd_pam_sess_c
// file common.h line 255
signed int nslcd_pam_sess_c(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_pam_sess_o
// file common.h line 254
signed int nslcd_pam_sess_o(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_passwd_all
// file common.h line 240
signed int nslcd_passwd_all(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid);
// nslcd_passwd_byname
// file common.h line 238
signed int nslcd_passwd_byname(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid);
// nslcd_passwd_byuid
// file common.h line 239
signed int nslcd_passwd_byuid(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid);
// nslcd_protocol_all
// file common.h line 243
signed int nslcd_protocol_all(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_protocol_byname
// file common.h line 241
signed int nslcd_protocol_byname(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_protocol_bynumber
// file common.h line 242
signed int nslcd_protocol_bynumber(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_rpc_all
// file common.h line 246
signed int nslcd_rpc_all(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_rpc_byname
// file common.h line 244
signed int nslcd_rpc_byname(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_rpc_bynumber
// file common.h line 245
signed int nslcd_rpc_bynumber(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_service_all
// file common.h line 249
signed int nslcd_service_all(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_service_byname
// file common.h line 247
signed int nslcd_service_byname(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_service_bynumber
// file common.h line 248
signed int nslcd_service_bynumber(struct tio_fileinfo *fp, struct ldap_session *session);
// nslcd_shadow_all
// file common.h line 251
signed int nslcd_shadow_all(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid);
// nslcd_shadow_byname
// file common.h line 250
signed int nslcd_shadow_byname(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid);
// nslcd_usermod
// file common.h line 257
signed int nslcd_usermod(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid);
// nsswitch_check_reload
// file nsswitch.c line 48
void nsswitch_check_reload(void);
// nsswitch_shadow_uses_ldap
// file nsswitch.c line 172
signed int nsswitch_shadow_uses_ldap(void);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// parse_boolean
// file cfg.c line 183
static signed int parse_boolean(const char *filename, signed int lnr, const char *value);
// parse_cmdline
// file nslcd.c line 154
static void parse_cmdline(signed int argc, char **argv);
// parse_dollar_expression
// file expr.c line 84
static const char * parse_dollar_expression(const char *str, signed int *ptr, char *buffer, unsigned long int buflen, const char * (*expander)(const char *, void *), void *expander_arg);
// parse_dollar_expression::expander$object
//
const char * expander$object(const char *, void *);
// parse_expression
// file expr.c line 208
static const char * parse_expression(const char *str, signed int *ptr, signed int endat, char *buffer, unsigned long int buflen, const char * (*expander)(const char *, void *), void *expander_arg);
// parse_expression::expander$object
//
const char * expander$object(const char *, void *);
// parse_loglevel
// file cfg.c line 342
static signed int parse_loglevel(const char *filename, signed int lnr, const char *value);
// parse_map
// file cfg.c line 536
static enum ldap_map_selector parse_map(const char *value);
// parse_name
// file expr.c line 47
static const char * parse_name(const char *str, signed int *ptr, char *buffer, unsigned long int buflen);
// parse_time
// file cfg.c line 220
static signed long int parse_time(const char *filename, signed int lnr, const char *value);
// passwd_init
// file common.h line 212
void passwd_init(void);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// print_boolean
// file cfg.c line 210
static const char * print_boolean(signed int bool);
// print_deref
// file cfg.c line 718
static const char * print_deref(signed int deref);
// print_map
// file cfg.c line 584
static const char * print_map(enum ldap_map_selector map);
// print_scope
// file cfg.c line 681
static const char * print_scope(signed int scope);
// print_ssl
// file cfg.c line 787
static const char * print_ssl(signed int ssl);
// print_time
// file cfg.c line 259
static void print_time(signed long int t, char *buffer, unsigned long int buflen);
// print_tls_reqcert
// file cfg.c line 829
static const char * print_tls_reqcert(signed int value);
// protocol_init
// file common.h line 213
void protocol_init(void);
// pthread_atfork
// file /usr/include/pthread.h line 1147
extern signed int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$7 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$7 *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$5 *, struct anonymous$5 *);
// pthread_timedjoin_np
// file /usr/include/pthread.h line 265
extern signed int pthread_timedjoin_np(unsigned long int, void **, struct timespec *);
// putenv
// file /usr/include/stdlib.h line 578
extern signed int putenv(char *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_address
// file common.c line 252
signed int read_address(struct tio_fileinfo *fp, char *addr, signed int *addrlen, signed int *af);
// read_header
// file nslcd.c line 334
static signed int read_header(struct tio_fileinfo *fp, signed int *action);
// read_response
// file daemonize.c line 70
static signed int read_response(signed int fd, char *buffer, unsigned long int bufsz);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regerror
// file /usr/include/regex.h line 571
extern unsigned long int regerror(signed int, const struct re_pattern_buffer *, char *, unsigned long int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous$17 *, signed int);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// rpc_init
// file common.h line 214
void rpc_init(void);
// scope_get_var
// file attmap.h line 75
signed int * scope_get_var(enum ldap_map_selector map);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$6 *, struct anonymous$6 *, struct anonymous$6 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// service_init
// file common.h line 215
void service_init(void);
// set_add
// file ../common/set.h line 43
signed int set_add(struct set *set, const char *value);
// set_contains
// file ../common/set.h line 47
signed int set_contains(struct set *set, const char *value);
// set_free
// file ../common/set.h line 57
void set_free(struct set *set);
// set_new
// file ../common/set.h line 36
struct set * set_new(void);
// set_pop
// file ../common/set.h line 53
char * set_pop(struct set *set);
// set_socket_timeout
// file myldap.c line 743
static signed int set_socket_timeout(struct ldap *ld, signed long int sec, signed long int usec);
// set_tolist
// file ../common/set.h line 61
const char ** set_tolist(struct set *set);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setpwent
// file /usr/include/pwd.h line 72
extern void setpwent(void);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// setusershell
// file /usr/include/unistd.h line 931
extern void setusershell(void);
// shadow_init
// file common.h line 216
void shadow_init(void);
// shadow_uid2entry
// file shadow.c line 271
struct myldap_entry * shadow_uid2entry(struct ldap_session *session, const char *username, signed int *rcp);
// shadow_uses_ldap
// file nsswitch.c line 131
static signed int shadow_uses_ldap(void);
// sid2search
// file common.c line 280
char * sid2search(const char *sid);
// sig_handler
// file nslcd.c line 194
static void sig_handler(signed int signum);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous$5 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$5 *);
// signame
// file common.h line 68
const char * signame(signed int signum);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// stringhash
// file dict.c line 73
static unsigned int stringhash(const char *str);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/strings.h line 120
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strndup
// file /usr/include/string.h line 183
extern char * strndup(const char *, unsigned long int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoui
// file common.c line 344
unsigned int strtoui(const char *nptr, char **endptr, signed int base);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tio_close
// file ../common/tio.h line 71
signed int tio_close(struct tio_fileinfo *fp);
// tio_fdopen
// file ../common/tio.h line 50
struct tio_fileinfo * tio_fdopen(signed int fd, signed int readtimeout, signed int writetimeout, unsigned long int initreadsize, unsigned long int maxreadsize, unsigned long int initwritesize, unsigned long int maxwritesize);
// tio_flush
// file tio.c line 382
signed int tio_flush(struct tio_fileinfo *fp);
// tio_flush_nonblock
// file tio.c line 400
static signed int tio_flush_nonblock(struct tio_fileinfo *fp);
// tio_mark
// file tio.c line 498
void tio_mark(struct tio_fileinfo *fp);
// tio_read
// file ../common/tio.h line 56
signed int tio_read(struct tio_fileinfo *fp, void *buf, unsigned long int count);
// tio_reset
// file tio.c line 511
signed int tio_reset(struct tio_fileinfo *fp);
// tio_skip
// file tio.c line 288
signed int tio_skip(struct tio_fileinfo *fp, unsigned long int count);
// tio_skipall
// file tio.c line 294
signed int tio_skipall(struct tio_fileinfo *fp, signed int timeout);
// tio_time_remaining
// file tio.c line 90
static inline signed int tio_time_remaining(struct timespec *deadline, signed int timeout);
// tio_wait
// file tio.c line 157
static signed int tio_wait(signed int fd, signed short int events, signed int timeout, struct timespec *deadline);
// tio_write
// file ../common/tio.h line 65
signed int tio_write(struct tio_fileinfo *fp, const void *buf, unsigned long int count);
// tio_writebuf
// file tio.c line 327
static signed int tio_writebuf(struct tio_fileinfo *fp);
// to_date
// file shadow.c line 118
static signed long int to_date(const char *dn, const char *date, const char *attr);
// try_autzsearch
// file pam.c line 444
static signed int try_autzsearch(struct ldap_session *session, const char *dn, const char *username, const char *servicename, const char *ruser, const char *rhost, const char *tty);
// try_bind
// file pam.c line 44
static signed int try_bind(const char *userdn, const char *password, signed int *authzrc, char *authzmsg, unsigned long int authzmsgsz);
// try_pwmod
// file pam.c line 684
static signed int try_pwmod(struct ldap_session *oldsession, const char *binddn, const char *userdn, const char *oldpassword, const char *newpassword, char *authzmsg, unsigned long int authzmsg_len);
// uid2dn
// file common.h line 125
char * uid2dn(struct ldap_session *session, const char *uid, char *buf, unsigned long int buflen);
// uid2entry
// file passwd.c line 351
struct myldap_entry * uid2entry(struct ldap_session *session, const char *uid, signed int *rcp);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_lastchange
// file pam.c line 618
static signed int update_lastchange(struct ldap_session *session, const char *userdn);
// update_username
// file pam.c line 124
static void update_username(struct myldap_entry *entry, char *username, unsigned long int username_len);
// validate_user
// file pam.c line 99
static struct myldap_entry * validate_user(struct ldap_session *session, char *username, signed int *rcp);
// validate_user$link1
// file usermod.c line 43
static struct myldap_entry * validate_user$link1(struct ldap_session *session$link1, char *username$link1, signed int *rcp$link1);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// wait_for_response
// file daemonize.c line 93
static signed int wait_for_response(signed int fd);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// worker
// file nslcd.c line 523
static void * worker(void *arg);
// worker::1::1::__cancel_routine$object
//
void __cancel_routine$object(void *);
// worker_cleanup
// file nslcd.c line 517
static void worker_cleanup(void *arg);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_address
// file common.c line 211
signed int write_address(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *attr, const char *addr);
// write_alias
// file alias.c line 95
static signed int write_alias(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqalias);
// write_ether
// file ether.c line 113
static signed int write_ether(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqname, const char *reqether);
// write_group
// file group.c line 320
static signed int write_group(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqname, const unsigned int *reqgid, signed int wantmembers, struct ldap_session *session);
// write_host
// file host.c line 113
static signed int write_host(struct tio_fileinfo *fp, struct myldap_entry *entry);
// write_netgroup
// file netgroup.c line 195
static signed int write_netgroup(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqname);
// write_netgroup_triple
// file netgroup.c line 126
static signed int write_netgroup_triple(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *triple);
// write_network
// file network.c line 112
static signed int write_network(struct tio_fileinfo *fp, struct myldap_entry *entry);
// write_passwd
// file passwd.c line 410
static signed int write_passwd(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *requser, const unsigned int *requid, unsigned int calleruid);
// write_protocol
// file protocol.c line 105
static signed int write_protocol(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqname);
// write_rpc
// file rpc.c line 104
static signed int write_rpc(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqname);
// write_service
// file service.c line 132
static signed int write_service(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqname, const char *reqprotocol);
// write_shadow
// file shadow.c line 222
static signed int write_shadow(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *requser, unsigned int calleruid);
// write_string_stripspace_len
// file netgroup.c line 97
static signed int write_string_stripspace_len(struct tio_fileinfo *fp, const char *str, signed int len);
// xstrdup
// file cfg.c line 81
static char * xstrdup(const char *s);

struct anonymous$15
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$13
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$6
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$5
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$0
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous$1
{
  // __cancel_jmp_buf
  struct anonymous$0 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous$17
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous$9
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$12
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$11
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$10
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$14
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$16
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$9 _kill;
  // _timer
  struct anonymous$10 _timer;
  // _rt
  struct anonymous$11 _rt;
  // _sigchld
  struct anonymous$12 _sigchld;
  // _sigfault
  struct anonymous$13 _sigfault;
  // _sigpoll
  struct anonymous$14 _sigpoll;
  // _sigsys
  struct anonymous$15 _sigsys;
};

struct anonymous$8
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$16 _sifields;
};

union anonymous$4
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$8 *, void *);
};

union anonymous$3
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$7
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$2
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct berval
{
  // bv_len
  unsigned long int bv_len;
  // bv_val
  char *bv_val;
};

struct LDAPDerefRes
{
  // derefAttr
  char *derefAttr;
  // derefVal
  struct berval derefVal;
  // attrVals
  struct LDAPDerefVal *attrVals;
  // next
  struct LDAPDerefRes *next;
};

struct LDAPDerefSpec
{
  // derefAttr
  char *derefAttr;
  // attributes
  char **attributes;
};

struct LDAPDerefVal
{
  // type
  char *type;
  // vals
  struct berval *vals;
  // next
  struct LDAPDerefVal *next;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct dict_entry
{
  // hash
  unsigned int hash;
  // key
  const char *key;
  // value
  void *value;
  // next
  struct dict_entry *next;
};

struct dictionary
{
  // size
  signed int size;
  // num
  signed int num;
  // table
  struct dict_entry **table;
};

struct dn2uid_cache_entry
{
  // timestamp
  signed long int timestamp;
  // uid
  char *uid;
};

struct ether_addr
{
  // ether_addr_octet
  unsigned char ether_addr_octet[6l];
} __attribute__ ((__packed__));

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in6_addr
{
  // __in6_u
  union anonymous$3 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct myldap_uri
{
  // uri
  char *uri;
  // firstfail
  signed long int firstfail;
  // lastfail
  signed long int lastfail;
};

struct re_pattern_buffer
{
  // buffer
  unsigned char *buffer;
  // allocated
  unsigned long int allocated;
  // used
  unsigned long int used;
  // syntax
  unsigned long int syntax;
  // fastmap
  char *fastmap;
  // translate
  unsigned char *translate;
  // re_nsub
  unsigned long int re_nsub;
  // can_be_null
  unsigned int can_be_null : 1;
  // regs_allocated
  unsigned int regs_allocated : 2;
  // fastmap_accurate
  unsigned int fastmap_accurate : 1;
  // no_sub
  unsigned int no_sub : 1;
  // not_bol
  unsigned int not_bol : 1;
  // not_eol
  unsigned int not_eol : 1;
  // newline_anchor
  unsigned int newline_anchor : 1;
};

struct ldap_config
{
  // threads
  signed int threads;
  // uidname
  char *uidname;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // uris
  struct myldap_uri uris[32l];
  // ldap_version
  signed int ldap_version;
  // binddn
  char *binddn;
  // bindpw
  char *bindpw;
  // rootpwmoddn
  char *rootpwmoddn;
  // rootpwmodpw
  char *rootpwmodpw;
  // sasl_mech
  char *sasl_mech;
  // sasl_realm
  char *sasl_realm;
  // sasl_authcid
  char *sasl_authcid;
  // sasl_authzid
  char *sasl_authzid;
  // sasl_secprops
  char *sasl_secprops;
  // sasl_canonicalize
  signed int sasl_canonicalize;
  // bases
  const char *bases[31l];
  // scope
  signed int scope;
  // deref
  signed int deref;
  // referrals
  signed int referrals;
  // bind_timelimit
  signed int bind_timelimit;
  // timelimit
  signed int timelimit;
  // idle_timelimit
  signed int idle_timelimit;
  // reconnect_sleeptime
  signed int reconnect_sleeptime;
  // reconnect_retrytime
  signed int reconnect_retrytime;
  // ssl
  enum ldap_ssl_options ssl;
  // pagesize
  signed int pagesize;
  // nss_initgroups_ignoreusers
  struct set *nss_initgroups_ignoreusers;
  // nss_min_uid
  unsigned int nss_min_uid;
  // nss_nested_groups
  signed int nss_nested_groups;
  // nss_getgrent_skipmembers
  signed int nss_getgrent_skipmembers;
  // nss_disable_enumeration
  signed int nss_disable_enumeration;
  // validnames
  struct re_pattern_buffer validnames;
  // validnames_str
  char *validnames_str;
  // ignorecase
  signed int ignorecase;
  // pam_authz_searches
  char *pam_authz_searches[8l];
  // pam_password_prohibit_message
  char *pam_password_prohibit_message;
  // reconnect_invalidate
  char reconnect_invalidate[12l];
  // cache_dn2uid_positive
  signed long int cache_dn2uid_positive;
  // cache_dn2uid_negative
  signed long int cache_dn2uid_negative;
};

struct ldap_conncb
{
  // lc_add
  signed int (*lc_add)(struct ldap *, struct sockbuf *, struct ldap_url_desc *, struct sockaddr *, struct ldap_conncb *);
  // lc_del
  void (*lc_del)(struct ldap *, struct sockbuf *, struct ldap_conncb *);
  // lc_arg
  void *lc_arg;
};

struct myldap_search
{
  // session
  struct ldap_session *session;
  // valid
  signed int valid;
  // base
  const char *base;
  // scope
  signed int scope;
  // filter
  const char *filter;
  // attrs
  char **attrs;
  // entry
  struct myldap_entry *entry;
  // msgid
  signed int msgid;
  // msg
  struct ldapmsg *msg;
  // cookie
  struct berval *cookie;
  // may_retry_search
  signed int may_retry_search;
  // count
  signed int count;
};

struct ldap_session
{
  // ld
  struct ldap *ld;
  // lastactivity
  signed long int lastactivity;
  // current_uri
  signed int current_uri;
  // searches
  struct myldap_search *searches[4l];
  // binddn
  char binddn[512l];
  // bindpw
  char bindpw[128l];
  // policy_response
  signed int policy_response;
  // policy_message
  char policy_message[1024l];
};

struct ldap_url_desc
{
  // lud_next
  struct ldap_url_desc *lud_next;
  // lud_scheme
  char *lud_scheme;
  // lud_host
  char *lud_host;
  // lud_port
  signed int lud_port;
  // lud_dn
  char *lud_dn;
  // lud_attrs
  char **lud_attrs;
  // lud_scope
  signed int lud_scope;
  // lud_filter
  char *lud_filter;
  // lud_exts
  char **lud_exts;
  // lud_crit_exts
  signed int lud_crit_exts;
};

struct ldapcontrol
{
  // ldctl_oid
  char *ldctl_oid;
  // ldctl_value
  struct berval ldctl_value;
  // ldctl_iscritical
  char ldctl_iscritical;
};

union mod_vals_u
{
  // modv_strvals
  char **modv_strvals;
  // modv_bvals
  struct berval **modv_bvals;
};

struct ldapmod
{
  // mod_op
  signed int mod_op;
  // mod_type
  char *mod_type;
  // mod_vals
  union mod_vals_u mod_vals;
};

struct log_cfg
{
  // loglevel
  signed int loglevel;
  // scheme
  const char *scheme;
  // fp
  struct _IO_FILE *fp;
  // next
  struct log_cfg *next;
};

struct myldap_entry
{
  // search
  struct myldap_search *search;
  // dn
  const char *dn;
  // exploded_rdn
  char **exploded_rdn;
  // attributevalues
  char **attributevalues[16l];
  // buffers
  char **buffers[8l];
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sasl_interact
{
  // id
  unsigned long int id;
  // challenge
  const char *challenge;
  // prompt
  const char *prompt;
  // defresult
  const char *defresult;
  // result
  const void *result;
  // len
  unsigned int len;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$4 __sigaction_handler;
  // sa_mask
  struct anonymous$5 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct tio_buffer
{
  // buffer
  unsigned char *buffer;
  // size
  unsigned long int size;
  // maxsize
  unsigned long int maxsize;
  // start
  unsigned long int start;
  // len
  unsigned long int len;
};

struct tio_fileinfo
{
  // fd
  signed int fd;
  // readbuffer
  struct tio_buffer readbuffer;
  // writebuffer
  struct tio_buffer writebuffer;
  // readtimeout
  signed int readtimeout;
  // writetimeout
  signed int writetimeout;
  // read_resettable
  signed int read_resettable;
};

struct ucred
{
  // pid
  signed int pid;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
};


// alias_attrs
// file alias.c line 60
static const char *alias_attrs[3l];
// alias_bases
// file alias.c line 47
const char *alias_bases[31l] = { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// alias_filter
// file alias.c line 53
const char *alias_filter = "(objectClass=nisMailAlias)";
// alias_scope
// file alias.c line 50
signed int alias_scope = (signed int)-1;
// attmap_alias_cn
// file alias.c line 56
const char *attmap_alias_cn = "cn";
// attmap_alias_rfc822MailMember
// file alias.c line 57
const char *attmap_alias_rfc822MailMember = "rfc822MailMember";
// attmap_ether_cn
// file ether.c line 58
const char *attmap_ether_cn = "cn";
// attmap_ether_macAddress
// file ether.c line 59
const char *attmap_ether_macAddress = "macAddress";
// attmap_group_cn
// file group.c line 65
const char *attmap_group_cn = "cn";
// attmap_group_gidNumber
// file group.c line 67
const char *attmap_group_gidNumber = "gidNumber";
// attmap_group_member
// file group.c line 69
const char *attmap_group_member = "member";
// attmap_group_memberUid
// file group.c line 68
const char *attmap_group_memberUid = "memberUid";
// attmap_group_userPassword
// file group.c line 66
const char *attmap_group_userPassword = "\"*\"";
// attmap_host_cn
// file host.c line 59
const char *attmap_host_cn = "cn";
// attmap_host_ipHostNumber
// file host.c line 60
const char *attmap_host_ipHostNumber = "ipHostNumber";
// attmap_netgroup_cn
// file netgroup.c line 58
const char *attmap_netgroup_cn = "cn";
// attmap_netgroup_memberNisNetgroup
// file netgroup.c line 60
const char *attmap_netgroup_memberNisNetgroup = "memberNisNetgroup";
// attmap_netgroup_nisNetgroupTriple
// file netgroup.c line 59
const char *attmap_netgroup_nisNetgroupTriple = "nisNetgroupTriple";
// attmap_network_cn
// file network.c line 57
const char *attmap_network_cn = "cn";
// attmap_network_ipNetworkNumber
// file network.c line 58
const char *attmap_network_ipNetworkNumber = "ipNetworkNumber";
// attmap_passwd_gecos
// file passwd.c line 63
const char *attmap_passwd_gecos = "\"${gecos:-$cn}\"";
// attmap_passwd_gidNumber
// file passwd.c line 62
const char *attmap_passwd_gidNumber = "gidNumber";
// attmap_passwd_homeDirectory
// file passwd.c line 64
const char *attmap_passwd_homeDirectory = "homeDirectory";
// attmap_passwd_loginShell
// file passwd.c line 65
const char *attmap_passwd_loginShell = "loginShell";
// attmap_passwd_uid
// file passwd.c line 59
const char *attmap_passwd_uid = "uid";
// attmap_passwd_uidNumber
// file passwd.c line 61
const char *attmap_passwd_uidNumber = "uidNumber";
// attmap_passwd_userPassword
// file passwd.c line 60
const char *attmap_passwd_userPassword = "\"*\"";
// attmap_protocol_cn
// file protocol.c line 59
const char *attmap_protocol_cn = "cn";
// attmap_protocol_ipProtocolNumber
// file protocol.c line 60
const char *attmap_protocol_ipProtocolNumber = "ipProtocolNumber";
// attmap_rpc_cn
// file rpc.c line 61
const char *attmap_rpc_cn = "cn";
// attmap_rpc_oncRpcNumber
// file rpc.c line 62
const char *attmap_rpc_oncRpcNumber = "oncRpcNumber";
// attmap_service_cn
// file service.c line 61
const char *attmap_service_cn = "cn";
// attmap_service_ipServicePort
// file service.c line 62
const char *attmap_service_ipServicePort = "ipServicePort";
// attmap_service_ipServiceProtocol
// file service.c line 63
const char *attmap_service_ipServiceProtocol = "ipServiceProtocol";
// attmap_shadow_shadowExpire
// file shadow.c line 64
const char *attmap_shadow_shadowExpire = "\"${shadowExpire:--1}\"";
// attmap_shadow_shadowFlag
// file shadow.c line 65
const char *attmap_shadow_shadowFlag = "\"${shadowFlag:-0}\"";
// attmap_shadow_shadowInactive
// file shadow.c line 63
const char *attmap_shadow_shadowInactive = "\"${shadowInactive:--1}\"";
// attmap_shadow_shadowLastChange
// file shadow.c line 59
const char *attmap_shadow_shadowLastChange = "\"${shadowLastChange:--1}\"";
// attmap_shadow_shadowMax
// file shadow.c line 61
const char *attmap_shadow_shadowMax = "\"${shadowMax:--1}\"";
// attmap_shadow_shadowMin
// file shadow.c line 60
const char *attmap_shadow_shadowMin = "\"${shadowMin:--1}\"";
// attmap_shadow_shadowWarning
// file shadow.c line 62
const char *attmap_shadow_shadowWarning = "\"${shadowWarning:--1}\"";
// attmap_shadow_uid
// file shadow.c line 57
const char *attmap_shadow_uid = "uid";
// attmap_shadow_userPassword
// file shadow.c line 58
const char *attmap_shadow_userPassword = "\"*\"";
// ber_pvt_opt_on
// file /usr/include/lber.h line 164
extern char ber_pvt_opt_on;
// builtinSid
// file group.c line 76
static char *builtinSid = (char *)(void *)0;
// cached_shadow_lastcheck
// file nsswitch.c line 39
static signed long int cached_shadow_lastcheck = (signed long int)0;
// cached_shadow_uses_ldap
// file nsswitch.c line 38
static signed int cached_shadow_uses_ldap = 22;
// daemonizefd
// file daemonize.c line 42
static signed int daemonizefd = -1;
// default_group_userPassword
// file group.c line 81
static const char *default_group_userPassword = "*";
// default_passwd_userPassword
// file passwd.c line 73
static const char *default_passwd_userPassword = "*";
// default_shadow_userPassword
// file shadow.c line 68
static const char *default_shadow_userPassword = "*";
// dn2uid_cache
// file passwd.c line 163
static struct dictionary *dn2uid_cache = (struct dictionary *)(void *)0;
// dn2uid_cache_mutex
// file passwd.c line 162
static union anonymous$7 dn2uid_cache_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// ether_attrs
// file ether.c line 62
static const char *ether_attrs[3l];
// ether_bases
// file ether.c line 49
const char *ether_bases[31l] = { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// ether_filter
// file ether.c line 55
const char *ether_filter = "(objectClass=ieee802Device)";
// ether_scope
// file ether.c line 52
signed int ether_scope = (signed int)-1;
// first_search
// file myldap.c line 155
signed int first_search = 1;
// gidSid
// file group.c line 73
static char *gidSid = (char *)(void *)0;
// gidSid$link1
// file passwd.c line 70
static char *gidSid$link1 = (char *)(void *)0;
// group_attrs
// file group.c line 84
static const char **group_attrs = (const char **)(void *)0;
// group_bases
// file group.c line 56
const char *group_bases[31l] = { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// group_bymember_attrs
// file group.c line 87
static const char **group_bymember_attrs = (const char **)(void *)0;
// group_filter
// file group.c line 62
const char *group_filter = "(objectClass=posixGroup)";
// group_scope
// file group.c line 59
signed int group_scope = (signed int)-1;
// host_attrs
// file host.c line 63
static const char *host_attrs[3l];
// host_bases
// file host.c line 50
const char *host_bases[31l] = { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// host_filter
// file host.c line 56
const char *host_filter = "(objectClass=ipHost)";
// host_scope
// file host.c line 53
signed int host_scope = (signed int)-1;
// loglist
// file log.c line 48
static struct log_cfg *loglist = (struct log_cfg *)(void *)0;
// max_builtin_rid
// file group.c line 78
const unsigned int max_builtin_rid = (const unsigned int)552;
// min_builtin_rid
// file group.c line 77
const unsigned int min_builtin_rid = (const unsigned int)544;
// netgroup_attrs
// file netgroup.c line 63
static const char *netgroup_attrs[4l];
// netgroup_bases
// file netgroup.c line 49
const char *netgroup_bases[31l] = { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// netgroup_filter
// file netgroup.c line 55
const char *netgroup_filter = "(objectClass=nisNetgroup)";
// netgroup_scope
// file netgroup.c line 52
signed int netgroup_scope = (signed int)-1;
// network_attrs
// file network.c line 61
static const char *network_attrs[3l];
// network_bases
// file network.c line 48
const char *network_bases[31l] = { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// network_filter
// file network.c line 54
const char *network_filter = "(objectClass=ipNetwork)";
// network_scope
// file network.c line 51
signed int network_scope = (signed int)-1;
// nslcd_cfg
// file cfg.c line 62
struct ldap_config *nslcd_cfg = (struct ldap_config *)(void *)0;
// nslcd_checkonly
// file nslcd.c line 92
static signed int nslcd_checkonly = 0;
// nslcd_debugging
// file nslcd.c line 86
static signed int nslcd_debugging = 0;
// nslcd_nofork
// file nslcd.c line 89
static signed int nslcd_nofork = 0;
// nslcd_options
// file nslcd.c line 143
static struct option nslcd_options[6l] = { { .name="check", .has_arg=0, .flag=(signed int *)(void *)0, .val=99 },
    { .name="debug", .has_arg=0, .flag=(signed int *)(void *)0, .val=100 },
    { .name="nofork", .has_arg=0, .flag=(signed int *)(void *)0, .val=110 },
    { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="version", .has_arg=0, .flag=(signed int *)(void *)0, .val=86 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
// nslcd_receivedsignal
// file nslcd.c line 95
static volatile signed int nslcd_receivedsignal = 0;
// nslcd_serversocket
// file nslcd.c line 98
static signed int nslcd_serversocket = -1;
// nslcd_threads
// file nslcd.c line 101
static unsigned long int *nslcd_threads;
// nsswitch_mtime
// file nsswitch.c line 41
static signed long int nsswitch_mtime = (signed long int)0;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// passwd_attrs
// file passwd.c line 83
static const char **passwd_attrs = (const char **)(void *)0;
// passwd_bases
// file passwd.c line 50
const char *passwd_bases[31l] = { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// passwd_filter
// file passwd.c line 56
const char *passwd_filter = "(objectClass=posixAccount)";
// passwd_scope
// file passwd.c line 53
signed int passwd_scope = (signed int)-1;
// prelogging_loglevel
// file log.c line 51
static signed int prelogging_loglevel = 6;
// protocol_attrs
// file protocol.c line 63
static const char *protocol_attrs[3l];
// protocol_bases
// file protocol.c line 50
const char *protocol_bases[31l] = { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// protocol_filter
// file protocol.c line 56
const char *protocol_filter = "(objectClass=ipProtocol)";
// protocol_scope
// file protocol.c line 53
signed int protocol_scope = (signed int)-1;
// requestid
// file log.c line 61
static char *requestid = (char *)(void *)0;
// rpc_attrs
// file rpc.c line 65
static const char *rpc_attrs[3l];
// rpc_bases
// file rpc.c line 52
const char *rpc_bases[31l] = { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// rpc_filter
// file rpc.c line 58
const char *rpc_filter = "(objectClass=oncRpc)";
// rpc_scope
// file rpc.c line 55
signed int rpc_scope = (signed int)-1;
// service_attrs
// file service.c line 66
static const char *service_attrs[4l];
// service_bases
// file service.c line 52
const char *service_bases[31l] = { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// service_filter
// file service.c line 58
const char *service_filter = "(objectClass=ipService)";
// service_scope
// file service.c line 55
signed int service_scope = (signed int)-1;
// sessionid
// file log.c line 58
static char *sessionid = (char *)(void *)0;
// shadow_attrs
// file shadow.c line 71
static const char **shadow_attrs = (const char **)(void *)0;
// shadow_bases
// file shadow.c line 48
const char *shadow_bases[31l] = { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// shadow_filter
// file shadow.c line 54
const char *shadow_filter = "(objectClass=shadowAccount)";
// shadow_scope
// file shadow.c line 51
signed int shadow_scope = (signed int)-1;
// signalfd
// file invalidator.c line 40
static signed int signalfd = -1;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// uidSid
// file passwd.c line 69
static char *uidSid = (char *)(void *)0;
// uris_mutex
// file myldap.c line 1234
union anonymous$7 uris_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };

// add_uri
// file cfg.c line 390
static void add_uri(const char *filename, signed int lnr, struct ldap_config *cfg, const char *uri)
{
  signed int i = 0;
  for( ; !(cfg->uris[(signed long int)i].uri == ((char *)NULL)); i = i + 1)
    ;
  if(i >= 31)
  {
    log_log(3, "%s:%d: maximum number of URIs exceeded", filename, lnr);
    exit(1);
  }

  cfg->uris[(signed long int)i].uri=xstrdup(uri);
}

// add_uris_from_dns
// file cfg.c line 423
static void add_uris_from_dns(const char *filename, signed int lnr, struct ldap_config *cfg, const char *domain)
{
  signed int rc;
  char *hostlist = (char *)(void *)0;
  char *nxt;
  char buf[(signed long int)(sizeof(char [8l]) * 9) /*72l*/ ];
  log_log(7, "query %s for SRV records", domain);
  rc=ldap_domain2hostlist(domain, &hostlist);
  if(!(rc == 0x00))
  {
    char *return_value_ldap_err2string$1;
    return_value_ldap_err2string$1=ldap_err2string(rc);
    log_log(3, "%s:%d: no servers found in DNS zone %s: %s", filename, lnr, domain, return_value_ldap_err2string$1);
    exit(1);
  }

  _Bool tmp_if_expr$2;
  if(hostlist == ((char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)*hostlist == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    log_log(3, "%s:%d: no servers found in DNS zone %s", filename, lnr, domain);
    exit(1);
  }

  _Bool tmp_if_expr$15;
  unsigned long int return_value_strlen$13;
  signed int return_value_strcmp$14;
  unsigned long int return_value_strlen$7;
  signed int return_value_strcmp$8;
  unsigned long int return_value_strlen$6;
  while(!(hostlist == ((char *)NULL)))
  {
    nxt=strchr(hostlist, 32);
    if(!(nxt == ((char *)NULL)))
    {
      *nxt = (char)0;
      nxt = nxt + 1l;
    }

    unsigned long int return_value_strlen$12;
    return_value_strlen$12=strlen(hostlist);
    if(return_value_strlen$12 >= 5ul)
    {
      return_value_strlen$13=strlen(hostlist);
      return_value_strcmp$14=strcmp((hostlist + (signed long int)return_value_strlen$13) - (signed long int)4, ":636");
      tmp_if_expr$15 = return_value_strcmp$14 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$15 = (_Bool)0;
    if(tmp_if_expr$15)
    {
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(hostlist);
      hostlist[(signed long int)(return_value_strlen$3 - (unsigned long int)4)] = (char)0;
      signed int return_value_mysnprintf$5;
      return_value_mysnprintf$5=mysnprintf(buf, sizeof(char [72l]) /*72ul*/ , "ldaps://%s", hostlist);
      if(!(return_value_mysnprintf$5 == 0))
      {
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(hostlist);
        log_log(3, "add_uris_from_dns(): buf buffer too small (%lu required)", (unsigned long int)return_value_strlen$4 + (unsigned long int)8);
        exit(1);
      }

    }

    else
    {
      unsigned long int return_value_strlen$9;
      return_value_strlen$9=strlen(hostlist);
      if(return_value_strlen$9 >= 5ul)
      {
        return_value_strlen$7=strlen(hostlist);
        return_value_strcmp$8=strcmp((hostlist + (signed long int)return_value_strlen$7) - (signed long int)4, ":389");
        if(return_value_strcmp$8 == 0)
        {
          return_value_strlen$6=strlen(hostlist);
          hostlist[(signed long int)(return_value_strlen$6 - (unsigned long int)4)] = (char)0;
        }

      }

      signed int return_value_mysnprintf$11;
      return_value_mysnprintf$11=mysnprintf(buf, sizeof(char [72l]) /*72ul*/ , "ldap://%s", hostlist);
      if(!(return_value_mysnprintf$11 == 0))
      {
        unsigned long int return_value_strlen$10;
        return_value_strlen$10=strlen(hostlist);
        log_log(3, "add_uris_from_dns(): buf buffer too small (%lu required)", (unsigned long int)return_value_strlen$10 + (unsigned long int)7);
        exit(1);
      }

    }
    log_log(7, "add_uris_from_dns(): found uri: %s", (const void *)buf);
    add_uri(filename, lnr, cfg, buf);
    hostlist = nxt;
  }
}

// addlogging
// file log.c line 84
static void addlogging(signed int loglevel, const char *scheme, struct _IO_FILE *fp)
{
  struct log_cfg *tmp;
  struct log_cfg *lst;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct log_cfg) /*32ul*/ );
  tmp = (struct log_cfg *)return_value_malloc$1;
  if(tmp == ((struct log_cfg *)NULL))
  {
    log_log(2, "malloc() returned NULL");
    exit(1);
  }

  tmp->loglevel = loglevel;
  tmp->scheme = scheme;
  tmp->fp = fp;
  tmp->next = (struct log_cfg *)(void *)0;
  if(loglist == ((struct log_cfg *)NULL))
    loglist = tmp;

  else
  {
    lst = loglist;
    for( ; !(lst->next == ((struct log_cfg *)NULL)); lst = lst->next)
      ;
    lst->next = tmp;
  }
}

// adjust_oom_score
// file nslcd.c line 654
static void adjust_oom_score(void)
{
  signed int oom_adj_fd;
  oom_adj_fd=open("/proc/self/oom_score_adj", 01);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(oom_adj_fd >= 0)
  {
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen("-1000");
    signed long int return_value_write$4;
    return_value_write$4=write(oom_adj_fd, (const void *)"-1000", return_value_strlen$3);
    if(!(return_value_write$4 >= 0l))
    {
      return_value___errno_location$1=__errno_location();
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_log(4, "writing oom score adjustment of %s failed: %s", (const void *)"-1000", return_value_strerror$2);
    }

    close(oom_adj_fd);
  }

  else
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    log_log(7, "could not open %s to adjust the OOM score: %s", (const void *)"/proc/self/oom_score_adj", return_value_strerror$6);
  }
}

// alias_init
// file common.h line 206
void alias_init(void)
{
  signed int i;
  if(alias_bases[0l] == ((const char *)NULL))
  {
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      alias_bases[(signed long int)i] = nslcd_cfg->bases[(signed long int)i];
  }

  if(alias_scope == -1)
    alias_scope = nslcd_cfg->scope;

  alias_attrs[(signed long int)0] = attmap_alias_cn;
  alias_attrs[(signed long int)1] = attmap_alias_rfc822MailMember;
  alias_attrs[(signed long int)2] = (const char *)(void *)0;
}

// attmap_add_attributes
// file attmap.c line 302
struct set * attmap_add_attributes(struct set *set, const char *attr)
{
  if(!((signed int)*attr == 34))
    set_add(set, attr);

  else
    expr_vars(attr, set);
  return set;
}

// attmap_get_value
// file attmap.h line 92
const char * attmap_get_value(struct myldap_entry *entry, const char *attr, char *buffer, unsigned long int buflen)
{
  const char **values;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$6;
  const char *return_value_expr_parse$5;
  unsigned long int return_value_strlen$7;
  if(buffer == ((char *)NULL) || !(buflen >= 1ul))
    return (const char *)(void *)0;

  else
  {
    buffer[(signed long int)0] = (char)0;
    if(!((signed int)*attr == 34))
    {
      values=myldap_get_values(entry, attr);
      if(values == ((const char **)NULL))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = values[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        return (const char *)(void *)0;

      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(values[(signed long int)0]);
      if(return_value_strlen$3 >= buflen)
      {
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(values[(signed long int)0]);
        log_log(3, "attmap_get_value(): buffer too small (%lu required)", (unsigned long int)return_value_strlen$2);
        return (const char *)(void *)0;
      }

      strncpy(buffer, values[(signed long int)0], buflen);
      buffer[(signed long int)(buflen - (unsigned long int)1)] = (char)0;
      return buffer;
    }

    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(attr);
    if(!((signed int)attr[-1l + (signed long int)return_value_strlen$4] == 34))
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value_expr_parse$5=expr_parse(attr + (signed long int)1, buffer, buflen, entry_expand, (void *)entry);
      tmp_if_expr$6 = return_value_expr_parse$5 == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
    {
      log_log(3, "attribute mapping %s is invalid", attr);
      buffer[(signed long int)0] = (char)0;
      return (const char *)(void *)0;
    }

    else
    {
      unsigned long int return_value_strlen$8;
      return_value_strlen$8=strlen(buffer);
      if((signed int)buffer[-1l + (signed long int)return_value_strlen$8] == 34)
      {
        return_value_strlen$7=strlen(buffer);
        buffer[(signed long int)(return_value_strlen$7 - (unsigned long int)1)] = (char)0;
      }

      return buffer;
    }
  }
}

// attmap_get_var
// file attmap.h line 83
const char ** attmap_get_var(enum ldap_map_selector map, const char *name)
{
  if((signed int)map == LM_ALIASES)
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(name, "cn");
    if(return_value_strcasecmp$1 == 0)
      return &attmap_alias_cn;

    signed int return_value_strcasecmp$2;
    return_value_strcasecmp$2=strcasecmp(name, "rfc822MailMember");
    if(return_value_strcasecmp$2 == 0)
      return &attmap_alias_rfc822MailMember;

  }

  else
    if((signed int)map == LM_ETHERS)
    {
      signed int return_value_strcasecmp$3;
      return_value_strcasecmp$3=strcasecmp(name, "cn");
      if(return_value_strcasecmp$3 == 0)
        return &attmap_ether_cn;

      signed int return_value_strcasecmp$4;
      return_value_strcasecmp$4=strcasecmp(name, "macAddress");
      if(return_value_strcasecmp$4 == 0)
        return &attmap_ether_macAddress;

    }

    else
      if((signed int)map == LM_GROUP)
      {
        signed int return_value_strcasecmp$5;
        return_value_strcasecmp$5=strcasecmp(name, "cn");
        if(return_value_strcasecmp$5 == 0)
          return &attmap_group_cn;

        signed int return_value_strcasecmp$6;
        return_value_strcasecmp$6=strcasecmp(name, "userPassword");
        if(return_value_strcasecmp$6 == 0)
          return &attmap_group_userPassword;

        signed int return_value_strcasecmp$7;
        return_value_strcasecmp$7=strcasecmp(name, "gidNumber");
        if(return_value_strcasecmp$7 == 0)
          return &attmap_group_gidNumber;

        signed int return_value_strcasecmp$8;
        return_value_strcasecmp$8=strcasecmp(name, "memberUid");
        if(return_value_strcasecmp$8 == 0)
          return &attmap_group_memberUid;

        signed int return_value_strcasecmp$9;
        return_value_strcasecmp$9=strcasecmp(name, "member");
        if(return_value_strcasecmp$9 == 0)
          return &attmap_group_member;

      }

      else
        if((signed int)map == LM_HOSTS)
        {
          signed int return_value_strcasecmp$10;
          return_value_strcasecmp$10=strcasecmp(name, "cn");
          if(return_value_strcasecmp$10 == 0)
            return &attmap_host_cn;

          signed int return_value_strcasecmp$11;
          return_value_strcasecmp$11=strcasecmp(name, "ipHostNumber");
          if(return_value_strcasecmp$11 == 0)
            return &attmap_host_ipHostNumber;

        }

        else
          if((signed int)map == LM_NETGROUP)
          {
            signed int return_value_strcasecmp$12;
            return_value_strcasecmp$12=strcasecmp(name, "cn");
            if(return_value_strcasecmp$12 == 0)
              return &attmap_netgroup_cn;

            signed int return_value_strcasecmp$13;
            return_value_strcasecmp$13=strcasecmp(name, "nisNetgroupTriple");
            if(return_value_strcasecmp$13 == 0)
              return &attmap_netgroup_nisNetgroupTriple;

            signed int return_value_strcasecmp$14;
            return_value_strcasecmp$14=strcasecmp(name, "memberNisNetgroup");
            if(return_value_strcasecmp$14 == 0)
              return &attmap_netgroup_memberNisNetgroup;

          }

          else
            if((signed int)map == LM_NETWORKS)
            {
              signed int return_value_strcasecmp$15;
              return_value_strcasecmp$15=strcasecmp(name, "cn");
              if(return_value_strcasecmp$15 == 0)
                return &attmap_network_cn;

              signed int return_value_strcasecmp$16;
              return_value_strcasecmp$16=strcasecmp(name, "ipNetworkNumber");
              if(return_value_strcasecmp$16 == 0)
                return &attmap_network_ipNetworkNumber;

            }

            else
              if((signed int)map == LM_PASSWD)
              {
                signed int return_value_strcasecmp$17;
                return_value_strcasecmp$17=strcasecmp(name, "uid");
                if(return_value_strcasecmp$17 == 0)
                  return &attmap_passwd_uid;

                signed int return_value_strcasecmp$18;
                return_value_strcasecmp$18=strcasecmp(name, "userPassword");
                if(return_value_strcasecmp$18 == 0)
                  return &attmap_passwd_userPassword;

                signed int return_value_strcasecmp$19;
                return_value_strcasecmp$19=strcasecmp(name, "uidNumber");
                if(return_value_strcasecmp$19 == 0)
                  return &attmap_passwd_uidNumber;

                signed int return_value_strcasecmp$20;
                return_value_strcasecmp$20=strcasecmp(name, "gidNumber");
                if(return_value_strcasecmp$20 == 0)
                  return &attmap_passwd_gidNumber;

                signed int return_value_strcasecmp$21;
                return_value_strcasecmp$21=strcasecmp(name, "gecos");
                if(return_value_strcasecmp$21 == 0)
                  return &attmap_passwd_gecos;

                signed int return_value_strcasecmp$22;
                return_value_strcasecmp$22=strcasecmp(name, "homeDirectory");
                if(return_value_strcasecmp$22 == 0)
                  return &attmap_passwd_homeDirectory;

                signed int return_value_strcasecmp$23;
                return_value_strcasecmp$23=strcasecmp(name, "loginShell");
                if(return_value_strcasecmp$23 == 0)
                  return &attmap_passwd_loginShell;

              }

              else
                if((signed int)map == LM_PROTOCOLS)
                {
                  signed int return_value_strcasecmp$24;
                  return_value_strcasecmp$24=strcasecmp(name, "cn");
                  if(return_value_strcasecmp$24 == 0)
                    return &attmap_protocol_cn;

                  signed int return_value_strcasecmp$25;
                  return_value_strcasecmp$25=strcasecmp(name, "ipProtocolNumber");
                  if(return_value_strcasecmp$25 == 0)
                    return &attmap_protocol_ipProtocolNumber;

                }

                else
                  if((signed int)map == LM_RPC)
                  {
                    signed int return_value_strcasecmp$26;
                    return_value_strcasecmp$26=strcasecmp(name, "cn");
                    if(return_value_strcasecmp$26 == 0)
                      return &attmap_rpc_cn;

                    signed int return_value_strcasecmp$27;
                    return_value_strcasecmp$27=strcasecmp(name, "oncRpcNumber");
                    if(return_value_strcasecmp$27 == 0)
                      return &attmap_rpc_oncRpcNumber;

                  }

                  else
                    if((signed int)map == LM_SERVICES)
                    {
                      signed int return_value_strcasecmp$28;
                      return_value_strcasecmp$28=strcasecmp(name, "cn");
                      if(return_value_strcasecmp$28 == 0)
                        return &attmap_service_cn;

                      signed int return_value_strcasecmp$29;
                      return_value_strcasecmp$29=strcasecmp(name, "ipServicePort");
                      if(return_value_strcasecmp$29 == 0)
                        return &attmap_service_ipServicePort;

                      signed int return_value_strcasecmp$30;
                      return_value_strcasecmp$30=strcasecmp(name, "ipServiceProtocol");
                      if(return_value_strcasecmp$30 == 0)
                        return &attmap_service_ipServiceProtocol;

                    }

                    else
                      if((signed int)map == LM_SHADOW)
                      {
                        signed int return_value_strcasecmp$31;
                        return_value_strcasecmp$31=strcasecmp(name, "uid");
                        if(return_value_strcasecmp$31 == 0)
                          return &attmap_shadow_uid;

                        signed int return_value_strcasecmp$32;
                        return_value_strcasecmp$32=strcasecmp(name, "userPassword");
                        if(return_value_strcasecmp$32 == 0)
                          return &attmap_shadow_userPassword;

                        signed int return_value_strcasecmp$33;
                        return_value_strcasecmp$33=strcasecmp(name, "shadowLastChange");
                        if(return_value_strcasecmp$33 == 0)
                          return &attmap_shadow_shadowLastChange;

                        signed int return_value_strcasecmp$34;
                        return_value_strcasecmp$34=strcasecmp(name, "shadowMin");
                        if(return_value_strcasecmp$34 == 0)
                          return &attmap_shadow_shadowMin;

                        signed int return_value_strcasecmp$35;
                        return_value_strcasecmp$35=strcasecmp(name, "shadowMax");
                        if(return_value_strcasecmp$35 == 0)
                          return &attmap_shadow_shadowMax;

                        signed int return_value_strcasecmp$36;
                        return_value_strcasecmp$36=strcasecmp(name, "shadowWarning");
                        if(return_value_strcasecmp$36 == 0)
                          return &attmap_shadow_shadowWarning;

                        signed int return_value_strcasecmp$37;
                        return_value_strcasecmp$37=strcasecmp(name, "shadowInactive");
                        if(return_value_strcasecmp$37 == 0)
                          return &attmap_shadow_shadowInactive;

                        signed int return_value_strcasecmp$38;
                        return_value_strcasecmp$38=strcasecmp(name, "shadowExpire");
                        if(return_value_strcasecmp$38 == 0)
                          return &attmap_shadow_shadowExpire;

                        signed int return_value_strcasecmp$39;
                        return_value_strcasecmp$39=strcasecmp(name, "shadowFlag");
                        if(return_value_strcasecmp$39 == 0)
                          return &attmap_shadow_shadowFlag;

                      }

  return (const char **)(void *)0;
}

// attmap_set_mapping
// file attmap.h line 87
const char * attmap_set_mapping(const char **var, const char *value)
{
  signed int return_value_strcmp$1;
  if((signed int)*value == 34)
  {
    if(!(var == &attmap_group_member) && !(var == &attmap_group_userPassword) && !(var == &attmap_passwd_gecos) && !(var == &attmap_passwd_gidNumber) && !(var == &attmap_passwd_homeDirectory) && !(var == &attmap_passwd_loginShell) && !(var == &attmap_passwd_userPassword) && !(var == &attmap_shadow_shadowExpire) && !(var == &attmap_shadow_shadowFlag) && !(var == &attmap_shadow_shadowInactive) && !(var == &attmap_shadow_shadowLastChange) && !(var == &attmap_shadow_shadowMax) && !(var == &attmap_shadow_shadowMin) && !(var == &attmap_shadow_shadowWarning) && !(var == &attmap_shadow_userPassword))
      return (const char *)(void *)0;

    if(var == &attmap_group_member)
    {
      return_value_strcmp$1=strcmp(value, "\"\"");
      if(!(return_value_strcmp$1 == 0))
        return (const char *)(void *)0;

    }

  }

  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  if(*var == ((const char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strcmp$2=strcmp(*var, value);
    tmp_if_expr$3 = return_value_strcmp$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    *var=strdup(value);

  return *var;
}

// autzsearch_var_add
// file pam.c line 354
static void autzsearch_var_add(struct dictionary *dict, const char *name, const char *value)
{
  unsigned long int sz;
  char *escaped_value;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(value);
  sz = ((return_value_strlen$1 + (unsigned long int)8) * (unsigned long int)120) / (unsigned long int)100;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sz);
  escaped_value = (char *)return_value_malloc$2;
  if(escaped_value == ((char *)NULL))
    log_log(2, "autzsearch_var_add(): malloc() failed to allocate memory");

  else
  {
    signed int return_value_myldap_escape$3;
    return_value_myldap_escape$3=myldap_escape(value, escaped_value, sz);
    if(!(return_value_myldap_escape$3 == 0))
    {
      log_log(3, "autzsearch_var_add(): escaped_value buffer too small");
      free((void *)escaped_value);
    }

    else
      dict_put(dict, name, (void *)escaped_value);
  }
}

// autzsearch_var_get
// file pam.c line 397
static const char * autzsearch_var_get(const char *name, void *expander_attr)
{
  struct dictionary *dict = (struct dictionary *)expander_attr;
  void *return_value_dict_get$1;
  return_value_dict_get$1=dict_get(dict, name);
  return (const char *)return_value_dict_get$1;
}

// autzsearch_vars_free
// file pam.c line 378
static void autzsearch_vars_free(struct dictionary *dict)
{
  signed int i;
  const char **keys;
  void *value;
  keys=dict_keys(dict);
  i = 0;
  for( ; !(keys[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    value=dict_get(dict, keys[(signed long int)i]);
    if(!(value == NULL))
      free(value);

  }
  free((void *)keys);
}

// base_get_var
// file attmap.h line 72
const char ** base_get_var(enum ldap_map_selector map)
{
  switch((signed int)map)
  {
    case LM_ALIASES:
      return alias_bases;
    case LM_ETHERS:
      return ether_bases;
    case LM_GROUP:
      return group_bases;
    case LM_HOSTS:
      return host_bases;
    case LM_NETGROUP:
      return netgroup_bases;
    case LM_NETWORKS:
      return network_bases;
    case LM_PASSWD:
      return passwd_bases;
    case LM_PROTOCOLS:
      return protocol_bases;
    case LM_RPC:
      return rpc_bases;
    case LM_SERVICES:
      return service_bases;
    case LM_SHADOW:
      return shadow_bases;
    case LM_NFSIDMAP:

    case LM_NONE:

    default:
      return (const char **)(void *)0;
  }
}

// bervalues_to_values
// file myldap.c line 1891
static const char ** bervalues_to_values(struct berval **bvalues)
{
  signed int num_values;
  signed int i;
  unsigned long int sz;
  char *buf;
  char **values;
  num_values=ldap_count_values_len(bvalues);
  sz = (unsigned long int)(num_values + 1) * sizeof(char *) /*8ul*/ ;
  i = 0;
  for( ; !(i >= num_values); i = i + 1)
    sz = sz + bvalues[(signed long int)i]->bv_len + (unsigned long int)1;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sz);
  values = (char **)return_value_malloc$1;
  if(values == ((char **)NULL))
  {
    log_log(2, "bervalues_to_values(): malloc() failed to allocate memory");
    return (const char **)(void *)0;
  }

  else
  {
    buf = (char *)values;
    buf = buf + (signed long int)((unsigned long int)(num_values + 1) * sizeof(char *) /*8ul*/ );
    i = 0;
    for( ; !(i >= num_values); i = i + 1)
    {
      values[(signed long int)i] = buf;
      memcpy((void *)values[(signed long int)i], (const void *)bvalues[(signed long int)i]->bv_val, bvalues[(signed long int)i]->bv_len);
      values[(signed long int)i][(signed long int)bvalues[(signed long int)i]->bv_len] = (char)0;
      buf = buf + (signed long int)(bvalues[(signed long int)i]->bv_len + (unsigned long int)1);
    }
    values[(signed long int)i] = (char *)(void *)0;
    return (const char **)values;
  }
}

// binsid2id
// file common.c line 330
unsigned long int binsid2id(const char *binsid)
{
  signed int i = (signed int)((unsigned int)(2 + 6) + (((unsigned int)binsid[(signed long int)1] & (unsigned int)0xff) - (unsigned int)1) * (unsigned int)4);
  return (unsigned long int)binsid[(signed long int)i] & (unsigned long int)0xff | ((unsigned long int)binsid[(signed long int)(i + 1)] & (unsigned long int)0xff) << 8 | ((unsigned long int)binsid[(signed long int)(i + 2)] & (unsigned long int)0xff) << 16 | ((unsigned long int)binsid[(signed long int)(i + 3)] & (unsigned long int)0xff) << 24;
}

// cfg_defaults
// file cfg.c line 1146
static void cfg_defaults(struct ldap_config *cfg)
{
  signed int i;
  memset((void *)cfg, 0, sizeof(struct ldap_config) /*1376ul*/ );
  cfg->threads = 5;
  cfg->uidname = (char *)(void *)0;
  cfg->uid = (unsigned int)-1;
  cfg->gid = (unsigned int)-1;
  i = 0;
  for( ; !(i >= 1); i = i + 1)
  {
    cfg->uris[(signed long int)i].uri = (char *)(void *)0;
    cfg->uris[(signed long int)i].firstfail = (signed long int)0;
    cfg->uris[(signed long int)i].lastfail = (signed long int)0;
  }
  cfg->ldap_version = 3;
  cfg->binddn = (char *)(void *)0;
  cfg->bindpw = (char *)(void *)0;
  cfg->rootpwmoddn = (char *)(void *)0;
  cfg->rootpwmodpw = (char *)(void *)0;
  cfg->sasl_mech = (char *)(void *)0;
  cfg->sasl_realm = (char *)(void *)0;
  cfg->sasl_authcid = (char *)(void *)0;
  cfg->sasl_authzid = (char *)(void *)0;
  cfg->sasl_secprops = (char *)(void *)0;
  cfg->sasl_canonicalize = -1;
  i = 0;
  for( ; !(i >= 31); i = i + 1)
    cfg->bases[(signed long int)i] = (const char *)(void *)0;
  cfg->scope = (signed int)0x0002;
  cfg->deref = 0x00;
  cfg->referrals = 1;
  cfg->bind_timelimit = 10;
  cfg->timelimit = 0;
  cfg->idle_timelimit = 0;
  cfg->reconnect_sleeptime = 1;
  cfg->reconnect_retrytime = 10;
  cfg->ssl = (enum ldap_ssl_options)SSL_OFF;
  cfg->pagesize = 0;
  cfg->nss_initgroups_ignoreusers = (struct set *)(void *)0;
  cfg->nss_min_uid = (unsigned int)0;
  cfg->nss_nested_groups = 0;
  cfg->nss_getgrent_skipmembers = 0;
  cfg->nss_disable_enumeration = 0;
  cfg->validnames_str = (char *)(void *)0;
  handle_validnames("cfg.c", 1197, "", "/^[a-z0-9._@$()]([a-z0-9._@$() \\~-]*[a-z0-9._@$()~-])?$/i", cfg);
  cfg->ignorecase = 0;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    cfg->pam_authz_searches[(signed long int)i] = (char *)(void *)0;
  cfg->pam_password_prohibit_message = (char *)(void *)0;
  i = 0;
  for( ; !(i >= LM_NONE); i = i + 1)
    cfg->reconnect_invalidate[(signed long int)i] = (char)0;
  cfg->cache_dn2uid_positive = (signed long int)(15 * 60);
  cfg->cache_dn2uid_negative = (signed long int)(15 * 60);
}

// cfg_dump
// file cfg.c line 1626
static void cfg_dump(void)
{
  signed int i;
  signed int rc;
  enum ldap_map_selector map;
  char *str;
  const char **strp;
  char buffer[1024l];
  signed int *scopep;
  log_log(7, "CFG: threads %d", nslcd_cfg->threads);
  if(!(nslcd_cfg->uidname == ((char *)NULL)))
    log_log(7, "CFG: uid %s", nslcd_cfg->uidname);

  else
    if(!(nslcd_cfg->uid == 4294967295u))
      log_log(7, "CFG: uid %lu", (unsigned long int)nslcd_cfg->uid);

    else
      log_log(7, "CFG: # uid not set");
  if(!(nslcd_cfg->gid == 4294967295u))
    log_log(7, "CFG: gid %lu", (unsigned long int)nslcd_cfg->gid);

  else
    log_log(7, "CFG: # gid not set");
  log_log_config();
  i = 0;
  for( ; !(i >= 1); i = i + 1)
    if(!(nslcd_cfg->uris[(signed long int)i].uri == ((char *)NULL)))
      log_log(7, "CFG: uri %s", nslcd_cfg->uris[(signed long int)i].uri);

  log_log(7, "CFG: ldap_version %d", nslcd_cfg->ldap_version);
  if(!(nslcd_cfg->binddn == ((char *)NULL)))
    log_log(7, "CFG: binddn %s", nslcd_cfg->binddn);

  if(!(nslcd_cfg->bindpw == ((char *)NULL)))
    log_log(7, "CFG: bindpw ***");

  if(!(nslcd_cfg->rootpwmoddn == ((char *)NULL)))
    log_log(7, "CFG: rootpwmoddn %s", nslcd_cfg->rootpwmoddn);

  if(!(nslcd_cfg->rootpwmodpw == ((char *)NULL)))
    log_log(7, "CFG: rootpwmodpw ***");

  if(!(nslcd_cfg->sasl_mech == ((char *)NULL)))
    log_log(7, "CFG: sasl_mech %s", nslcd_cfg->sasl_mech);

  if(!(nslcd_cfg->sasl_realm == ((char *)NULL)))
    log_log(7, "CFG: sasl_realm %s", nslcd_cfg->sasl_realm);

  if(!(nslcd_cfg->sasl_authcid == ((char *)NULL)))
    log_log(7, "CFG: sasl_authcid %s", nslcd_cfg->sasl_authcid);

  if(!(nslcd_cfg->sasl_authzid == ((char *)NULL)))
    log_log(7, "CFG: sasl_authzid %s", nslcd_cfg->sasl_authzid);

  if(!(nslcd_cfg->sasl_secprops == ((char *)NULL)))
    log_log(7, "CFG: sasl_secprops %s", nslcd_cfg->sasl_secprops);

  const char *return_value_print_boolean$1;
  if(nslcd_cfg->sasl_canonicalize >= 0)
  {
    return_value_print_boolean$1=print_boolean(nslcd_cfg->sasl_canonicalize);
    log_log(7, "CFG: sasl_canonicalize %s", return_value_print_boolean$1);
  }

  str=getenv("KRB5CCNAME");
  if(!(str == ((char *)NULL)))
    log_log(7, "CFG: krb5_ccname %s", str);

  i = 0;
  for( ; !(i >= 31); i = i + 1)
    if(!(nslcd_cfg->bases[(signed long int)i] == ((const char *)NULL)))
      log_log(7, "CFG: base %s", nslcd_cfg->bases[(signed long int)i]);

  map = (enum ldap_map_selector)LM_ALIASES;
  const char *return_value_print_map$2;
  for( ; !((signed int)map >= LM_NONE); map = (enum ldap_map_selector)((signed int)map + 1))
  {
    strp=base_get_var(map);
    if(!(strp == ((const char **)NULL)))
    {
      i = 0;
      for( ; !(i >= 31); i = i + 1)
        if(!(strp[(signed long int)i] == ((const char *)NULL)))
        {
          return_value_print_map$2=print_map(map);
          log_log(7, "CFG: base %s %s", return_value_print_map$2, strp[(signed long int)i]);
        }

    }

  }
  const char *return_value_print_scope$3;
  return_value_print_scope$3=print_scope(nslcd_cfg->scope);
  log_log(7, "CFG: scope %s", return_value_print_scope$3);
  map = (enum ldap_map_selector)LM_ALIASES;
  const char *return_value_print_map$4;
  const char *return_value_print_scope$5;
  for( ; !((signed int)map >= LM_NONE); map = (enum ldap_map_selector)((signed int)map + 1))
  {
    scopep=scope_get_var(map);
    if(!(scopep == ((signed int *)NULL)))
    {
      if(!(*scopep == -1))
      {
        return_value_print_map$4=print_map(map);
        return_value_print_scope$5=print_scope(*scopep);
        log_log(7, "CFG: scope %s %s", return_value_print_map$4, return_value_print_scope$5);
      }

    }

  }
  const char *return_value_print_deref$6;
  return_value_print_deref$6=print_deref(nslcd_cfg->deref);
  log_log(7, "CFG: deref %s", return_value_print_deref$6);
  const char *return_value_print_boolean$7;
  return_value_print_boolean$7=print_boolean(nslcd_cfg->referrals);
  log_log(7, "CFG: referrals %s", return_value_print_boolean$7);
  map = (enum ldap_map_selector)LM_ALIASES;
  const char *return_value_print_map$8;
  for( ; !((signed int)map >= LM_NONE); map = (enum ldap_map_selector)((signed int)map + 1))
  {
    strp=filter_get_var(map);
    if(!(strp == ((const char **)NULL)))
    {
      if(!(*strp == ((const char *)NULL)))
      {
        return_value_print_map$8=print_map(map);
        log_log(7, "CFG: filter %s %s", return_value_print_map$8, *strp);
      }

    }

  }
  signed int return_value_strcmp$10;
  return_value_strcmp$10=strcmp(attmap_alias_cn, "cn");
  const char *return_value_print_map$9;
  if(!(return_value_strcmp$10 == 0))
  {
    return_value_print_map$9=print_map((enum ldap_map_selector)LM_ALIASES);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$9, (const void *)"cn", attmap_alias_cn);
  }

  signed int return_value_strcmp$12;
  return_value_strcmp$12=strcmp(attmap_alias_rfc822MailMember, "rfc822MailMember");
  const char *return_value_print_map$11;
  if(!(return_value_strcmp$12 == 0))
  {
    return_value_print_map$11=print_map((enum ldap_map_selector)LM_ALIASES);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$11, (const void *)"rfc822MailMember", attmap_alias_rfc822MailMember);
  }

  signed int return_value_strcmp$14;
  return_value_strcmp$14=strcmp(attmap_ether_cn, "cn");
  const char *return_value_print_map$13;
  if(!(return_value_strcmp$14 == 0))
  {
    return_value_print_map$13=print_map((enum ldap_map_selector)LM_ETHERS);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$13, (const void *)"cn", attmap_ether_cn);
  }

  signed int return_value_strcmp$16;
  return_value_strcmp$16=strcmp(attmap_ether_macAddress, "macAddress");
  const char *return_value_print_map$15;
  if(!(return_value_strcmp$16 == 0))
  {
    return_value_print_map$15=print_map((enum ldap_map_selector)LM_ETHERS);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$15, (const void *)"macAddress", attmap_ether_macAddress);
  }

  signed int return_value_strcmp$18;
  return_value_strcmp$18=strcmp(attmap_group_cn, "cn");
  const char *return_value_print_map$17;
  if(!(return_value_strcmp$18 == 0))
  {
    return_value_print_map$17=print_map((enum ldap_map_selector)LM_GROUP);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$17, (const void *)"cn", attmap_group_cn);
  }

  signed int return_value_strcmp$20;
  return_value_strcmp$20=strcmp(attmap_group_userPassword, "userPassword");
  const char *return_value_print_map$19;
  if(!(return_value_strcmp$20 == 0))
  {
    return_value_print_map$19=print_map((enum ldap_map_selector)LM_GROUP);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$19, (const void *)"userPassword", attmap_group_userPassword);
  }

  signed int return_value_strcmp$22;
  return_value_strcmp$22=strcmp(attmap_group_gidNumber, "gidNumber");
  const char *return_value_print_map$21;
  if(!(return_value_strcmp$22 == 0))
  {
    return_value_print_map$21=print_map((enum ldap_map_selector)LM_GROUP);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$21, (const void *)"gidNumber", attmap_group_gidNumber);
  }

  signed int return_value_strcmp$24;
  return_value_strcmp$24=strcmp(attmap_group_memberUid, "memberUid");
  const char *return_value_print_map$23;
  if(!(return_value_strcmp$24 == 0))
  {
    return_value_print_map$23=print_map((enum ldap_map_selector)LM_GROUP);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$23, (const void *)"memberUid", attmap_group_memberUid);
  }

  signed int return_value_strcmp$26;
  return_value_strcmp$26=strcmp(attmap_group_member, "member");
  const char *return_value_print_map$25;
  if(!(return_value_strcmp$26 == 0))
  {
    return_value_print_map$25=print_map((enum ldap_map_selector)LM_GROUP);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$25, (const void *)"member", attmap_group_member);
  }

  signed int return_value_strcmp$28;
  return_value_strcmp$28=strcmp(attmap_host_cn, "cn");
  const char *return_value_print_map$27;
  if(!(return_value_strcmp$28 == 0))
  {
    return_value_print_map$27=print_map((enum ldap_map_selector)LM_HOSTS);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$27, (const void *)"cn", attmap_host_cn);
  }

  signed int return_value_strcmp$30;
  return_value_strcmp$30=strcmp(attmap_host_ipHostNumber, "ipHostNumber");
  const char *return_value_print_map$29;
  if(!(return_value_strcmp$30 == 0))
  {
    return_value_print_map$29=print_map((enum ldap_map_selector)LM_HOSTS);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$29, (const void *)"ipHostNumber", attmap_host_ipHostNumber);
  }

  signed int return_value_strcmp$32;
  return_value_strcmp$32=strcmp(attmap_netgroup_cn, "cn");
  const char *return_value_print_map$31;
  if(!(return_value_strcmp$32 == 0))
  {
    return_value_print_map$31=print_map((enum ldap_map_selector)LM_NETGROUP);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$31, (const void *)"cn", attmap_netgroup_cn);
  }

  signed int return_value_strcmp$34;
  return_value_strcmp$34=strcmp(attmap_netgroup_nisNetgroupTriple, "nisNetgroupTriple");
  const char *return_value_print_map$33;
  if(!(return_value_strcmp$34 == 0))
  {
    return_value_print_map$33=print_map((enum ldap_map_selector)LM_NETGROUP);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$33, (const void *)"nisNetgroupTriple", attmap_netgroup_nisNetgroupTriple);
  }

  signed int return_value_strcmp$36;
  return_value_strcmp$36=strcmp(attmap_netgroup_memberNisNetgroup, "memberNisNetgroup");
  const char *return_value_print_map$35;
  if(!(return_value_strcmp$36 == 0))
  {
    return_value_print_map$35=print_map((enum ldap_map_selector)LM_NETGROUP);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$35, (const void *)"memberNisNetgroup", attmap_netgroup_memberNisNetgroup);
  }

  signed int return_value_strcmp$38;
  return_value_strcmp$38=strcmp(attmap_network_cn, "cn");
  const char *return_value_print_map$37;
  if(!(return_value_strcmp$38 == 0))
  {
    return_value_print_map$37=print_map((enum ldap_map_selector)LM_NETWORKS);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$37, (const void *)"cn", attmap_network_cn);
  }

  signed int return_value_strcmp$40;
  return_value_strcmp$40=strcmp(attmap_network_ipNetworkNumber, "ipNetworkNumber");
  const char *return_value_print_map$39;
  if(!(return_value_strcmp$40 == 0))
  {
    return_value_print_map$39=print_map((enum ldap_map_selector)LM_NETWORKS);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$39, (const void *)"ipNetworkNumber", attmap_network_ipNetworkNumber);
  }

  signed int return_value_strcmp$42;
  return_value_strcmp$42=strcmp(attmap_passwd_uid, "uid");
  const char *return_value_print_map$41;
  if(!(return_value_strcmp$42 == 0))
  {
    return_value_print_map$41=print_map((enum ldap_map_selector)LM_PASSWD);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$41, (const void *)"uid", attmap_passwd_uid);
  }

  signed int return_value_strcmp$44;
  return_value_strcmp$44=strcmp(attmap_passwd_userPassword, "userPassword");
  const char *return_value_print_map$43;
  if(!(return_value_strcmp$44 == 0))
  {
    return_value_print_map$43=print_map((enum ldap_map_selector)LM_PASSWD);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$43, (const void *)"userPassword", attmap_passwd_userPassword);
  }

  signed int return_value_strcmp$46;
  return_value_strcmp$46=strcmp(attmap_passwd_uidNumber, "uidNumber");
  const char *return_value_print_map$45;
  if(!(return_value_strcmp$46 == 0))
  {
    return_value_print_map$45=print_map((enum ldap_map_selector)LM_PASSWD);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$45, (const void *)"uidNumber", attmap_passwd_uidNumber);
  }

  signed int return_value_strcmp$48;
  return_value_strcmp$48=strcmp(attmap_passwd_gidNumber, "gidNumber");
  const char *return_value_print_map$47;
  if(!(return_value_strcmp$48 == 0))
  {
    return_value_print_map$47=print_map((enum ldap_map_selector)LM_PASSWD);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$47, (const void *)"gidNumber", attmap_passwd_gidNumber);
  }

  signed int return_value_strcmp$50;
  return_value_strcmp$50=strcmp(attmap_passwd_gecos, "gecos");
  const char *return_value_print_map$49;
  if(!(return_value_strcmp$50 == 0))
  {
    return_value_print_map$49=print_map((enum ldap_map_selector)LM_PASSWD);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$49, (const void *)"gecos", attmap_passwd_gecos);
  }

  signed int return_value_strcmp$52;
  return_value_strcmp$52=strcmp(attmap_passwd_homeDirectory, "homeDirectory");
  const char *return_value_print_map$51;
  if(!(return_value_strcmp$52 == 0))
  {
    return_value_print_map$51=print_map((enum ldap_map_selector)LM_PASSWD);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$51, (const void *)"homeDirectory", attmap_passwd_homeDirectory);
  }

  signed int return_value_strcmp$54;
  return_value_strcmp$54=strcmp(attmap_passwd_loginShell, "loginShell");
  const char *return_value_print_map$53;
  if(!(return_value_strcmp$54 == 0))
  {
    return_value_print_map$53=print_map((enum ldap_map_selector)LM_PASSWD);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$53, (const void *)"loginShell", attmap_passwd_loginShell);
  }

  signed int return_value_strcmp$56;
  return_value_strcmp$56=strcmp(attmap_protocol_cn, "cn");
  const char *return_value_print_map$55;
  if(!(return_value_strcmp$56 == 0))
  {
    return_value_print_map$55=print_map((enum ldap_map_selector)LM_PROTOCOLS);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$55, (const void *)"cn", attmap_protocol_cn);
  }

  signed int return_value_strcmp$58;
  return_value_strcmp$58=strcmp(attmap_protocol_ipProtocolNumber, "ipProtocolNumber");
  const char *return_value_print_map$57;
  if(!(return_value_strcmp$58 == 0))
  {
    return_value_print_map$57=print_map((enum ldap_map_selector)LM_PROTOCOLS);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$57, (const void *)"ipProtocolNumber", attmap_protocol_ipProtocolNumber);
  }

  signed int return_value_strcmp$60;
  return_value_strcmp$60=strcmp(attmap_rpc_cn, "cn");
  const char *return_value_print_map$59;
  if(!(return_value_strcmp$60 == 0))
  {
    return_value_print_map$59=print_map((enum ldap_map_selector)LM_RPC);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$59, (const void *)"cn", attmap_rpc_cn);
  }

  signed int return_value_strcmp$62;
  return_value_strcmp$62=strcmp(attmap_rpc_oncRpcNumber, "oncRpcNumber");
  const char *return_value_print_map$61;
  if(!(return_value_strcmp$62 == 0))
  {
    return_value_print_map$61=print_map((enum ldap_map_selector)LM_RPC);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$61, (const void *)"oncRpcNumber", attmap_rpc_oncRpcNumber);
  }

  signed int return_value_strcmp$64;
  return_value_strcmp$64=strcmp(attmap_service_cn, "cn");
  const char *return_value_print_map$63;
  if(!(return_value_strcmp$64 == 0))
  {
    return_value_print_map$63=print_map((enum ldap_map_selector)LM_SERVICES);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$63, (const void *)"cn", attmap_service_cn);
  }

  signed int return_value_strcmp$66;
  return_value_strcmp$66=strcmp(attmap_service_ipServicePort, "ipServicePort");
  const char *return_value_print_map$65;
  if(!(return_value_strcmp$66 == 0))
  {
    return_value_print_map$65=print_map((enum ldap_map_selector)LM_SERVICES);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$65, (const void *)"ipServicePort", attmap_service_ipServicePort);
  }

  signed int return_value_strcmp$68;
  return_value_strcmp$68=strcmp(attmap_service_ipServiceProtocol, "ipServiceProtocol");
  const char *return_value_print_map$67;
  if(!(return_value_strcmp$68 == 0))
  {
    return_value_print_map$67=print_map((enum ldap_map_selector)LM_SERVICES);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$67, (const void *)"ipServiceProtocol", attmap_service_ipServiceProtocol);
  }

  signed int return_value_strcmp$70;
  return_value_strcmp$70=strcmp(attmap_shadow_uid, "uid");
  const char *return_value_print_map$69;
  if(!(return_value_strcmp$70 == 0))
  {
    return_value_print_map$69=print_map((enum ldap_map_selector)LM_SHADOW);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$69, (const void *)"uid", attmap_shadow_uid);
  }

  signed int return_value_strcmp$72;
  return_value_strcmp$72=strcmp(attmap_shadow_userPassword, "userPassword");
  const char *return_value_print_map$71;
  if(!(return_value_strcmp$72 == 0))
  {
    return_value_print_map$71=print_map((enum ldap_map_selector)LM_SHADOW);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$71, (const void *)"userPassword", attmap_shadow_userPassword);
  }

  signed int return_value_strcmp$74;
  return_value_strcmp$74=strcmp(attmap_shadow_shadowLastChange, "shadowLastChange");
  const char *return_value_print_map$73;
  if(!(return_value_strcmp$74 == 0))
  {
    return_value_print_map$73=print_map((enum ldap_map_selector)LM_SHADOW);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$73, (const void *)"shadowLastChange", attmap_shadow_shadowLastChange);
  }

  signed int return_value_strcmp$76;
  return_value_strcmp$76=strcmp(attmap_shadow_shadowMin, "shadowMin");
  const char *return_value_print_map$75;
  if(!(return_value_strcmp$76 == 0))
  {
    return_value_print_map$75=print_map((enum ldap_map_selector)LM_SHADOW);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$75, (const void *)"shadowMin", attmap_shadow_shadowMin);
  }

  signed int return_value_strcmp$78;
  return_value_strcmp$78=strcmp(attmap_shadow_shadowMax, "shadowMax");
  const char *return_value_print_map$77;
  if(!(return_value_strcmp$78 == 0))
  {
    return_value_print_map$77=print_map((enum ldap_map_selector)LM_SHADOW);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$77, (const void *)"shadowMax", attmap_shadow_shadowMax);
  }

  signed int return_value_strcmp$80;
  return_value_strcmp$80=strcmp(attmap_shadow_shadowWarning, "shadowWarning");
  const char *return_value_print_map$79;
  if(!(return_value_strcmp$80 == 0))
  {
    return_value_print_map$79=print_map((enum ldap_map_selector)LM_SHADOW);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$79, (const void *)"shadowWarning", attmap_shadow_shadowWarning);
  }

  signed int return_value_strcmp$82;
  return_value_strcmp$82=strcmp(attmap_shadow_shadowInactive, "shadowInactive");
  const char *return_value_print_map$81;
  if(!(return_value_strcmp$82 == 0))
  {
    return_value_print_map$81=print_map((enum ldap_map_selector)LM_SHADOW);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$81, (const void *)"shadowInactive", attmap_shadow_shadowInactive);
  }

  signed int return_value_strcmp$84;
  return_value_strcmp$84=strcmp(attmap_shadow_shadowExpire, "shadowExpire");
  const char *return_value_print_map$83;
  if(!(return_value_strcmp$84 == 0))
  {
    return_value_print_map$83=print_map((enum ldap_map_selector)LM_SHADOW);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$83, (const void *)"shadowExpire", attmap_shadow_shadowExpire);
  }

  signed int return_value_strcmp$86;
  return_value_strcmp$86=strcmp(attmap_shadow_shadowFlag, "shadowFlag");
  const char *return_value_print_map$85;
  if(!(return_value_strcmp$86 == 0))
  {
    return_value_print_map$85=print_map((enum ldap_map_selector)LM_SHADOW);
    log_log(7, "CFG: map %s %s %s", return_value_print_map$85, (const void *)"shadowFlag", attmap_shadow_shadowFlag);
  }

  log_log(7, "CFG: bind_timelimit %d", nslcd_cfg->bind_timelimit);
  log_log(7, "CFG: timelimit %d", nslcd_cfg->timelimit);
  log_log(7, "CFG: idle_timelimit %d", nslcd_cfg->idle_timelimit);
  log_log(7, "CFG: reconnect_sleeptime %d", nslcd_cfg->reconnect_sleeptime);
  log_log(7, "CFG: reconnect_retrytime %d", nslcd_cfg->reconnect_retrytime);
  const char *return_value_print_ssl$87;
  return_value_print_ssl$87=print_ssl((signed int)nslcd_cfg->ssl);
  log_log(7, "CFG: ssl %s", return_value_print_ssl$87);
  rc=ldap_get_option((struct ldap *)(void *)0, 0x6006, (void *)&i);
  char *return_value_ldap_err2string$88;
  const char *return_value_print_tls_reqcert$89;
  if(!(rc == 0x00))
  {
    return_value_ldap_err2string$88=ldap_err2string(rc);
    log_log(7, "CFG: # tls_reqcert ERROR: %s", return_value_ldap_err2string$88);
  }

  else
  {
    return_value_print_tls_reqcert$89=print_tls_reqcert(i);
    log_log(7, "CFG: tls_reqcert %s", return_value_print_tls_reqcert$89);
  }
  str = (char *)(void *)0;
  rc=ldap_get_option((struct ldap *)(void *)0, 0x6003, (void *)&str);
  char *return_value_ldap_err2string$90;
  if(!(rc == 0x00))
  {
    return_value_ldap_err2string$90=ldap_err2string(rc);
    log_log(7, "CFG: # %s ERROR: %s", (const void *)"tls_cacertdir", return_value_ldap_err2string$90);
  }

  else
    if(!(str == ((char *)NULL)))
    {
      if(!((signed int)*str == 0))
        log_log(7, "CFG: %s %s", (const void *)"tls_cacertdir", str);

    }

  if(!(str == ((char *)NULL)))
    ldap_memfree((void *)str);

  str = (char *)(void *)0;
  rc=ldap_get_option((struct ldap *)(void *)0, 0x6002, (void *)&str);
  char *return_value_ldap_err2string$91;
  if(!(rc == 0x00))
  {
    return_value_ldap_err2string$91=ldap_err2string(rc);
    log_log(7, "CFG: # %s ERROR: %s", (const void *)"tls_cacertfile", return_value_ldap_err2string$91);
  }

  else
    if(!(str == ((char *)NULL)))
    {
      if(!((signed int)*str == 0))
        log_log(7, "CFG: %s %s", (const void *)"tls_cacertfile", str);

    }

  if(!(str == ((char *)NULL)))
    ldap_memfree((void *)str);

  str = (char *)(void *)0;
  rc=ldap_get_option((struct ldap *)(void *)0, 0x6009, (void *)&str);
  char *return_value_ldap_err2string$92;
  if(!(rc == 0x00))
  {
    return_value_ldap_err2string$92=ldap_err2string(rc);
    log_log(7, "CFG: # %s ERROR: %s", (const void *)"tls_randfile", return_value_ldap_err2string$92);
  }

  else
    if(!(str == ((char *)NULL)))
    {
      if(!((signed int)*str == 0))
        log_log(7, "CFG: %s %s", (const void *)"tls_randfile", str);

    }

  if(!(str == ((char *)NULL)))
    ldap_memfree((void *)str);

  str = (char *)(void *)0;
  rc=ldap_get_option((struct ldap *)(void *)0, 0x6008, (void *)&str);
  char *return_value_ldap_err2string$93;
  if(!(rc == 0x00))
  {
    return_value_ldap_err2string$93=ldap_err2string(rc);
    log_log(7, "CFG: # %s ERROR: %s", (const void *)"tls_ciphers", return_value_ldap_err2string$93);
  }

  else
    if(!(str == ((char *)NULL)))
    {
      if(!((signed int)*str == 0))
        log_log(7, "CFG: %s %s", (const void *)"tls_ciphers", str);

    }

  if(!(str == ((char *)NULL)))
    ldap_memfree((void *)str);

  str = (char *)(void *)0;
  rc=ldap_get_option((struct ldap *)(void *)0, 0x6004, (void *)&str);
  char *return_value_ldap_err2string$94;
  if(!(rc == 0x00))
  {
    return_value_ldap_err2string$94=ldap_err2string(rc);
    log_log(7, "CFG: # %s ERROR: %s", (const void *)"tls_cert", return_value_ldap_err2string$94);
  }

  else
    if(!(str == ((char *)NULL)))
    {
      if(!((signed int)*str == 0))
        log_log(7, "CFG: %s %s", (const void *)"tls_cert", str);

    }

  if(!(str == ((char *)NULL)))
    ldap_memfree((void *)str);

  str = (char *)(void *)0;
  rc=ldap_get_option((struct ldap *)(void *)0, 0x6005, (void *)&str);
  char *return_value_ldap_err2string$95;
  if(!(rc == 0x00))
  {
    return_value_ldap_err2string$95=ldap_err2string(rc);
    log_log(7, "CFG: # %s ERROR: %s", (const void *)"tls_key", return_value_ldap_err2string$95);
  }

  else
    if(!(str == ((char *)NULL)))
    {
      if(!((signed int)*str == 0))
        log_log(7, "CFG: %s %s", (const void *)"tls_key", str);

    }

  if(!(str == ((char *)NULL)))
    ldap_memfree((void *)str);

  log_log(7, "CFG: pagesize %d", nslcd_cfg->pagesize);
  unsigned long int return_value_strlen$96;
  if(!(nslcd_cfg->nss_initgroups_ignoreusers == ((struct set *)NULL)))
  {
    strp=set_tolist(nslcd_cfg->nss_initgroups_ignoreusers);
    if(strp == ((const char **)NULL))
    {
      log_log(2, "malloc() failed to allocate memory");
      exit(1);
    }

    buffer[(signed long int)0] = (char)0;
    i = 0;
    for( ; !(strp[(signed long int)i] == ((const char *)NULL)); i = i + 1)
    {
      if(i >= 1)
      {
        return_value_strlen$96=strlen(buffer);
        strncat(buffer, ",", (sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - return_value_strlen$96);
      }

      unsigned long int return_value_strlen$97;
      return_value_strlen$97=strlen(buffer);
      strncat(buffer, strp[(signed long int)i], (sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - return_value_strlen$97);
    }
    free((void *)strp);
    unsigned long int return_value_strlen$98;
    return_value_strlen$98=strlen(buffer);
    if(return_value_strlen$98 >= 1020ul)
      strcpy((buffer + (signed long int)sizeof(char [1024l]) /*1024ul*/ ) - (signed long int)4, "...");

    log_log(7, "CFG: nss_initgroups_ignoreusers %s", (const void *)buffer);
  }

  log_log(7, "CFG: nss_min_uid %lu", (unsigned long int)nslcd_cfg->nss_min_uid);
  const char *return_value_print_boolean$99;
  return_value_print_boolean$99=print_boolean(nslcd_cfg->nss_nested_groups);
  log_log(7, "CFG: nss_nested_groups %s", return_value_print_boolean$99);
  const char *return_value_print_boolean$100;
  return_value_print_boolean$100=print_boolean(nslcd_cfg->nss_getgrent_skipmembers);
  log_log(7, "CFG: nss_getgrent_skipmembers %s", return_value_print_boolean$100);
  const char *return_value_print_boolean$101;
  return_value_print_boolean$101=print_boolean(nslcd_cfg->nss_disable_enumeration);
  log_log(7, "CFG: nss_disable_enumeration %s", return_value_print_boolean$101);
  log_log(7, "CFG: validnames %s", nslcd_cfg->validnames_str);
  const char *return_value_print_boolean$102;
  return_value_print_boolean$102=print_boolean(nslcd_cfg->ignorecase);
  log_log(7, "CFG: ignorecase %s", return_value_print_boolean$102);
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    if(!(nslcd_cfg->pam_authz_searches[(signed long int)i] == ((char *)NULL)))
      log_log(7, "CFG: pam_authz_search %s", nslcd_cfg->pam_authz_searches[(signed long int)i]);

  if(!(nslcd_cfg->pam_password_prohibit_message == ((char *)NULL)))
    log_log(7, "CFG: pam_password_prohibit_message \"%s\"", nslcd_cfg->pam_password_prohibit_message);

  buffer[(signed long int)0] = (char)0;
  i = 0;
  unsigned long int return_value_strlen$103;
  for( ; !(i >= LM_NONE); i = i + 1)
    if(!(nslcd_cfg->reconnect_invalidate[(signed long int)i] == 0))
    {
      if(!((signed int)buffer[0l] == 0))
      {
        return_value_strlen$103=strlen(buffer);
        strncat(buffer, ",", (sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - return_value_strlen$103);
      }

      const char *return_value_print_map$104;
      return_value_print_map$104=print_map((enum ldap_map_selector)i);
      unsigned long int return_value_strlen$105;
      return_value_strlen$105=strlen(buffer);
      strncat(buffer, return_value_print_map$104, (sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - return_value_strlen$105);
    }

  if(!((signed int)buffer[0l] == 0))
    log_log(7, "CFG: reconnect_invalidate %s", (const void *)buffer);

  print_time(nslcd_cfg->cache_dn2uid_positive, buffer, sizeof(char [1024l]) /*1024ul*/  / (unsigned long int)2);
  print_time(nslcd_cfg->cache_dn2uid_positive, buffer + (signed long int)(sizeof(char [1024l]) /*1024ul*/  / (unsigned long int)2), sizeof(char [1024l]) /*1024ul*/  / (unsigned long int)2);
  log_log(7, "CFG: cache dn2uid %s %s", (const void *)buffer, buffer + (signed long int)(sizeof(char [1024l]) /*1024ul*/  / (unsigned long int)2));
}

// cfg_getdomainname
// file cfg.c line 411
static const char * cfg_getdomainname(const char *filename, signed int lnr)
{
  const char *fqdn;
  const char *domain;
  fqdn=getfqdn();
  if(!(fqdn == ((const char *)NULL)))
  {
    domain=strchr(fqdn, 46);
    if(domain == ((const char *)NULL))
      goto __CPROVER_DUMP_L1;

    if((signed int)domain[1l] == 0)
      goto __CPROVER_DUMP_L1;

    return domain + (signed long int)1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    log_log(3, "%s:%d: unable to determinate a domain name", filename, lnr);
    exit(1);
  }
}

// cfg_init
// file cfg.h line 144
void cfg_init(const char *fname)
{
  signed int i;
  if(!(nslcd_cfg == ((struct ldap_config *)NULL)))
  {
    log_log(2, "cfg_init() may only be called once");
    exit(1);
  }

  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ldap_config) /*1376ul*/ );
  nslcd_cfg = (struct ldap_config *)return_value_malloc$1;
  if(nslcd_cfg == ((struct ldap_config *)NULL))
  {
    log_log(2, "malloc() failed to allocate memory");
    exit(1);
  }

  cfg_defaults(nslcd_cfg);
  cfg_read(fname, nslcd_cfg);
  if(nslcd_cfg->uris[0l].uri == ((char *)NULL))
  {
    log_log(3, "no URIs defined in config");
    exit(1);
  }

  if((signed int)nslcd_cfg->ssl == SSL_LDAPS)
  {
    i = 0;
    for( ; !(nslcd_cfg->uris[(signed long int)i].uri == ((char *)NULL)); i = i + 1)
    {
      signed int return_value_strncasecmp$2;
      return_value_strncasecmp$2=strncasecmp(nslcd_cfg->uris[(signed long int)i].uri, "ldaps://", (unsigned long int)8);
      if(!(return_value_strncasecmp$2 == 0))
        log_log(4, "%s doesn't start with ldaps:// and \"ssl on\" is specified", nslcd_cfg->uris[(signed long int)i].uri);

    }
  }

  if(nslcd_cfg->bases[0l] == ((const char *)NULL))
    nslcd_cfg->bases[(signed long int)0]=get_base_from_rootdse();

  _Bool tmp_if_expr$3;
  if(nslcd_cfg->bases[0l] == ((const char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = (signed int)nslcd_cfg->bases[(signed long int)0][(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    log_log(3, "no base defined in config and couldn't get one from server");
    exit(1);
  }

  cfg_dump();
  alias_init();
  ether_init();
  group_init();
  host_init();
  netgroup_init();
  network_init();
  passwd_init();
  protocol_init();
  rpc_init();
  service_init();
  shadow_init();
}

// cfg_read
// file cfg.c line 1210
static void cfg_read(const char *filename, struct ldap_config *cfg)
{
  struct _IO_FILE *fp;
  signed int lnr = 0;
  char linebuf[4096l];
  char *line;
  char keyword[32l];
  char token[64l];
  signed int i;
  signed int rc;
  char *value;
  fp=fopen(filename, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(3, "cannot open config file (%s): %s", filename, return_value_strerror$2);
    exit(1);
  }

  char *return_value_fgets$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  const unsigned short int **return_value___ctype_b_loc$6;
  signed int return_value_strcasecmp$82;
  signed int return_value_strcasecmp$81;
  signed int return_value_strcasecmp$80;
  signed int return_value_strcasecmp$79;
  _Bool tmp_if_expr$9;
  char *return_value_get_token$10;
  signed int return_value_strncasecmp$13;
  signed int return_value_strcasecmp$78;
  signed int return_value_strcasecmp$77;
  signed int return_value_strcasecmp$76;
  signed int return_value_strcasecmp$75;
  signed int return_value_strcasecmp$74;
  signed int return_value_strcasecmp$73;
  signed int return_value_strcasecmp$72;
  signed int return_value_strcasecmp$71;
  signed int return_value_strcasecmp$70;
  signed int return_value_strcasecmp$69;
  signed int return_value_strcasecmp$62;
  _Bool tmp_if_expr$64;
  signed int return_value_strcasecmp$63;
  _Bool tmp_if_expr$66;
  signed int return_value_strcasecmp$65;
  _Bool tmp_if_expr$68;
  signed int return_value_strcasecmp$67;
  signed int return_value_strcasecmp$61;
  signed int return_value_strcasecmp$60;
  signed int return_value_strcasecmp$59;
  signed int return_value_strcasecmp$58;
  signed int return_value_strcasecmp$57;
  signed int return_value_strcasecmp$56;
  signed int return_value_strcasecmp$55;
  signed int return_value_strcasecmp$54;
  signed int return_value_strcasecmp$53;
  signed int return_value_strcasecmp$52;
  signed int return_value_strcasecmp$51;
  signed int return_value_strcasecmp$50;
  signed int return_value_strcasecmp$49;
  signed int return_value_strcasecmp$48;
  _Bool tmp_if_expr$19;
  signed int return_value_strcasecmp$18;
  signed int return_value_parse_boolean$16;
  signed int return_value_strcasecmp$47;
  signed int return_value_strcasecmp$46;
  signed int return_value_strcasecmp$43;
  _Bool tmp_if_expr$45;
  signed int return_value_strcasecmp$44;
  signed int return_value_strcasecmp$42;
  signed int return_value_strcasecmp$41;
  signed int return_value_strcasecmp$40;
  signed int return_value_strcasecmp$39;
  signed int return_value_strcasecmp$38;
  signed int return_value_strcasecmp$37;
  signed int return_value_strcasecmp$36;
  signed int return_value_strcasecmp$35;
  signed int return_value_strcasecmp$34;
  signed int return_value_strcasecmp$33;
  signed int return_value_strcasecmp$32;
  signed int return_value_strcasecmp$31;
  signed int return_value_strcasecmp$30;
  signed int return_value_strcasecmp$29;
  signed int return_value_strcasecmp$28;
  signed int return_value_strcasecmp$27;
  do
  {
    return_value_fgets$3=fgets(linebuf, (signed int)sizeof(char [4096l]) /*4096ul*/ , fp);
    if(return_value_fgets$3 == ((char *)NULL))
      break;

    lnr = lnr + 1;
    line = linebuf;
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(line);
    i = (signed int)return_value_strlen$4;
    if(!(i >= 1))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = (signed int)line[(signed long int)(i - 1)] != 10 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
    {
      log_log(3, "%s:%d: line too long or last line missing newline", filename, lnr);
      exit(1);
    }

    line[(signed long int)(i - 1)] = (char)0;
    if(!((signed int)*line == 35))
    {
      i = i - 1;
      do
      {
        if(i >= 1)
        {
          return_value___ctype_b_loc$6=__ctype_b_loc();
          tmp_if_expr$7 = ((signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)line[(signed long int)(i - 1)]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$7 = (_Bool)0;
        if(!tmp_if_expr$7)
          break;

        line[(signed long int)(i - 1)] = (char)0;
        i = i - 1;
      }
      while((_Bool)1);
      char *return_value_get_token$8;
      return_value_get_token$8=get_token(&line, keyword, sizeof(char [32l]) /*32ul*/ );
      if(!(return_value_get_token$8 == ((char *)NULL)))
      {
        signed int return_value_strcasecmp$83;
        return_value_strcasecmp$83=strcasecmp(keyword, "threads");
        if(return_value_strcasecmp$83 == 0)
        {
          cfg->threads=get_int(filename, lnr, keyword, &line);
          get_eol(filename, lnr, keyword, &line);
        }

        else
        {
          return_value_strcasecmp$82=strcasecmp(keyword, "uid");
          if(return_value_strcasecmp$82 == 0)
            handle_uid(filename, lnr, keyword, line, cfg);

          else
          {
            return_value_strcasecmp$81=strcasecmp(keyword, "gid");
            if(return_value_strcasecmp$81 == 0)
              handle_gid(filename, lnr, keyword, line, &cfg->gid);

            else
            {
              return_value_strcasecmp$80=strcasecmp(keyword, "log");
              if(return_value_strcasecmp$80 == 0)
                handle_log(filename, lnr, keyword, line);

              else
              {
                return_value_strcasecmp$79=strcasecmp(keyword, "uri");
                if(return_value_strcasecmp$79 == 0)
                {
                  if(!(line == ((char *)NULL)))
                    tmp_if_expr$9 = (signed int)*line != 0 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$9 = (_Bool)0;
                  check_argumentcount(filename, lnr, keyword, (signed int)tmp_if_expr$9);
                  do
                  {
                    return_value_get_token$10=get_token(&line, token, sizeof(char [64l]) /*64ul*/ );
                    if(return_value_get_token$10 == ((char *)NULL))
                      break;

                    signed int return_value_strcasecmp$14;
                    return_value_strcasecmp$14=strcasecmp(token, "dns");
                    if(return_value_strcasecmp$14 == 0)
                    {
                      const char *return_value_cfg_getdomainname$11;
                      return_value_cfg_getdomainname$11=cfg_getdomainname(filename, lnr);
                      add_uris_from_dns(filename, lnr, cfg, return_value_cfg_getdomainname$11);
                    }

                    else
                    {
                      return_value_strncasecmp$13=strncasecmp(token, "dns:", (unsigned long int)4);
                      if(return_value_strncasecmp$13 == 0)
                      {
                        char *return_value_strdup$12;
                        return_value_strdup$12=strdup(token + (signed long int)4);
                        add_uris_from_dns(filename, lnr, cfg, return_value_strdup$12);
                      }

                      else
                        add_uri(filename, lnr, cfg, token);
                    }
                  }
                  while((_Bool)1);
                }

                else
                {
                  return_value_strcasecmp$78=strcasecmp(keyword, "ldap_version");
                  if(return_value_strcasecmp$78 == 0)
                  {
                    cfg->ldap_version=get_int(filename, lnr, keyword, &line);
                    get_eol(filename, lnr, keyword, &line);
                  }

                  else
                  {
                    return_value_strcasecmp$77=strcasecmp(keyword, "binddn");
                    if(return_value_strcasecmp$77 == 0)
                      cfg->binddn=get_linedup(filename, lnr, keyword, &line);

                    else
                    {
                      return_value_strcasecmp$76=strcasecmp(keyword, "bindpw");
                      if(return_value_strcasecmp$76 == 0)
                      {
                        check_permissions(filename, keyword);
                        cfg->bindpw=get_linedup(filename, lnr, keyword, &line);
                      }

                      else
                      {
                        return_value_strcasecmp$75=strcasecmp(keyword, "rootpwmoddn");
                        if(return_value_strcasecmp$75 == 0)
                          cfg->rootpwmoddn=get_linedup(filename, lnr, keyword, &line);

                        else
                        {
                          return_value_strcasecmp$74=strcasecmp(keyword, "rootpwmodpw");
                          if(return_value_strcasecmp$74 == 0)
                          {
                            check_permissions(filename, keyword);
                            cfg->rootpwmodpw=get_linedup(filename, lnr, keyword, &line);
                          }

                          else
                          {
                            return_value_strcasecmp$73=strcasecmp(keyword, "sasl_mech");
                            if(return_value_strcasecmp$73 == 0)
                            {
                              cfg->sasl_mech=get_strdup(filename, lnr, keyword, &line);
                              get_eol(filename, lnr, keyword, &line);
                            }

                            else
                            {
                              return_value_strcasecmp$72=strcasecmp(keyword, "sasl_realm");
                              if(return_value_strcasecmp$72 == 0)
                              {
                                cfg->sasl_realm=get_strdup(filename, lnr, keyword, &line);
                                get_eol(filename, lnr, keyword, &line);
                              }

                              else
                              {
                                return_value_strcasecmp$71=strcasecmp(keyword, "sasl_authcid");
                                if(return_value_strcasecmp$71 == 0)
                                {
                                  cfg->sasl_authcid=get_strdup(filename, lnr, keyword, &line);
                                  get_eol(filename, lnr, keyword, &line);
                                }

                                else
                                {
                                  return_value_strcasecmp$70=strcasecmp(keyword, "sasl_authzid");
                                  if(return_value_strcasecmp$70 == 0)
                                  {
                                    cfg->sasl_authzid=get_strdup(filename, lnr, keyword, &line);
                                    get_eol(filename, lnr, keyword, &line);
                                  }

                                  else
                                  {
                                    return_value_strcasecmp$69=strcasecmp(keyword, "sasl_secprops");
                                    if(return_value_strcasecmp$69 == 0)
                                    {
                                      cfg->sasl_secprops=get_strdup(filename, lnr, keyword, &line);
                                      get_eol(filename, lnr, keyword, &line);
                                    }

                                    else
                                    {
                                      return_value_strcasecmp$62=strcasecmp(keyword, "sasl_canonicalize");
                                      if(return_value_strcasecmp$62 == 0)
                                        tmp_if_expr$64 = (_Bool)1;

                                      else
                                      {
                                        return_value_strcasecmp$63=strcasecmp(keyword, "sasl_canonicalise");
                                        tmp_if_expr$64 = return_value_strcasecmp$63 == 0 ? (_Bool)1 : (_Bool)0;
                                      }
                                      if(tmp_if_expr$64)
                                        tmp_if_expr$66 = (_Bool)1;

                                      else
                                      {
                                        return_value_strcasecmp$65=strcasecmp(keyword, "ldap_sasl_canonicalize");
                                        tmp_if_expr$66 = return_value_strcasecmp$65 == 0 ? (_Bool)1 : (_Bool)0;
                                      }
                                      if(tmp_if_expr$66)
                                        tmp_if_expr$68 = (_Bool)1;

                                      else
                                      {
                                        return_value_strcasecmp$67=strcasecmp(keyword, "sasl_canon");
                                        tmp_if_expr$68 = return_value_strcasecmp$67 == 0 ? (_Bool)1 : (_Bool)0;
                                      }
                                      if(tmp_if_expr$68)
                                      {
                                        cfg->sasl_canonicalize=get_boolean(filename, lnr, keyword, &line);
                                        get_eol(filename, lnr, keyword, &line);
                                      }

                                      else
                                      {
                                        return_value_strcasecmp$61=strcasecmp(keyword, "sasl_nocanon");
                                        if(return_value_strcasecmp$61 == 0)
                                        {
                                          cfg->sasl_canonicalize=get_boolean(filename, lnr, keyword, &line);
                                          cfg->sasl_canonicalize = (signed int)!(cfg->sasl_canonicalize != 0);
                                          get_eol(filename, lnr, keyword, &line);
                                        }

                                        else
                                        {
                                          return_value_strcasecmp$60=strcasecmp(keyword, "krb5_ccname");
                                          if(return_value_strcasecmp$60 == 0)
                                            handle_krb5_ccname(filename, lnr, keyword, line);

                                          else
                                          {
                                            return_value_strcasecmp$59=strcasecmp(keyword, "base");
                                            if(return_value_strcasecmp$59 == 0)
                                              handle_base(filename, lnr, keyword, line, cfg);

                                            else
                                            {
                                              return_value_strcasecmp$58=strcasecmp(keyword, "scope");
                                              if(return_value_strcasecmp$58 == 0)
                                                handle_scope(filename, lnr, keyword, line, cfg);

                                              else
                                              {
                                                return_value_strcasecmp$57=strcasecmp(keyword, "deref");
                                                if(return_value_strcasecmp$57 == 0)
                                                  handle_deref(filename, lnr, keyword, line, cfg);

                                                else
                                                {
                                                  return_value_strcasecmp$56=strcasecmp(keyword, "referrals");
                                                  if(return_value_strcasecmp$56 == 0)
                                                  {
                                                    cfg->referrals=get_boolean(filename, lnr, keyword, &line);
                                                    get_eol(filename, lnr, keyword, &line);
                                                  }

                                                  else
                                                  {
                                                    return_value_strcasecmp$55=strcasecmp(keyword, "filter");
                                                    if(return_value_strcasecmp$55 == 0)
                                                      handle_filter(filename, lnr, keyword, line);

                                                    else
                                                    {
                                                      return_value_strcasecmp$54=strcasecmp(keyword, "map");
                                                      if(return_value_strcasecmp$54 == 0)
                                                        handle_map(filename, lnr, keyword, line);

                                                      else
                                                      {
                                                        return_value_strcasecmp$53=strcasecmp(keyword, "bind_timelimit");
                                                        if(return_value_strcasecmp$53 == 0)
                                                        {
                                                          cfg->bind_timelimit=get_int(filename, lnr, keyword, &line);
                                                          get_eol(filename, lnr, keyword, &line);
                                                        }

                                                        else
                                                        {
                                                          return_value_strcasecmp$52=strcasecmp(keyword, "timelimit");
                                                          if(return_value_strcasecmp$52 == 0)
                                                          {
                                                            cfg->timelimit=get_int(filename, lnr, keyword, &line);
                                                            get_eol(filename, lnr, keyword, &line);
                                                          }

                                                          else
                                                          {
                                                            return_value_strcasecmp$51=strcasecmp(keyword, "idle_timelimit");
                                                            if(return_value_strcasecmp$51 == 0)
                                                            {
                                                              cfg->idle_timelimit=get_int(filename, lnr, keyword, &line);
                                                              get_eol(filename, lnr, keyword, &line);
                                                            }

                                                            else
                                                            {
                                                              return_value_strcasecmp$50=strcasecmp(keyword, "reconnect_sleeptime");
                                                              if(return_value_strcasecmp$50 == 0)
                                                              {
                                                                cfg->reconnect_sleeptime=get_int(filename, lnr, keyword, &line);
                                                                get_eol(filename, lnr, keyword, &line);
                                                              }

                                                              else
                                                              {
                                                                return_value_strcasecmp$49=strcasecmp(keyword, "reconnect_retrytime");
                                                                if(return_value_strcasecmp$49 == 0)
                                                                {
                                                                  cfg->reconnect_retrytime=get_int(filename, lnr, keyword, &line);
                                                                  get_eol(filename, lnr, keyword, &line);
                                                                }

                                                                else
                                                                {
                                                                  return_value_strcasecmp$48=strcasecmp(keyword, "ssl");
                                                                  if(return_value_strcasecmp$48 == 0)
                                                                  {
                                                                    char *return_value_get_token$15;
                                                                    return_value_get_token$15=get_token(&line, token, sizeof(char [64l]) /*64ul*/ );
                                                                    check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$15 != (char *)(void *)0));
                                                                    signed int return_value_strcasecmp$17;
                                                                    return_value_strcasecmp$17=strcasecmp(token, "start_tls");
                                                                    if(return_value_strcasecmp$17 == 0)
                                                                      tmp_if_expr$19 = (_Bool)1;

                                                                    else
                                                                    {
                                                                      return_value_strcasecmp$18=strcasecmp(token, "starttls");
                                                                      tmp_if_expr$19 = return_value_strcasecmp$18 == 0 ? (_Bool)1 : (_Bool)0;
                                                                    }
                                                                    if(tmp_if_expr$19)
                                                                      cfg->ssl = (enum ldap_ssl_options)SSL_START_TLS;

                                                                    else
                                                                    {
                                                                      return_value_parse_boolean$16=parse_boolean(filename, lnr, token);
                                                                      if(!(return_value_parse_boolean$16 == 0))
                                                                        cfg->ssl = (enum ldap_ssl_options)SSL_LDAPS;

                                                                    }
                                                                    get_eol(filename, lnr, keyword, &line);
                                                                  }

                                                                  else
                                                                  {
                                                                    return_value_strcasecmp$47=strcasecmp(keyword, "tls_reqcert");
                                                                    if(return_value_strcasecmp$47 == 0)
                                                                      handle_tls_reqcert(filename, lnr, keyword, line);

                                                                    else
                                                                    {
                                                                      return_value_strcasecmp$46=strcasecmp(keyword, "tls_cacertdir");
                                                                      if(return_value_strcasecmp$46 == 0)
                                                                      {
                                                                        value=get_strdup(filename, lnr, keyword, &line);
                                                                        get_eol(filename, lnr, keyword, &line);
                                                                        log_log(7, "ldap_set_option(LDAP_OPT_X_TLS_CACERTDIR,\"%s\")", value);
                                                                        rc=ldap_set_option((struct ldap *)(void *)0, 0x6003, (const void *)value);
                                                                        if(!(rc == 0x00))
                                                                        {
                                                                          char *return_value_ldap_err2string$20;
                                                                          return_value_ldap_err2string$20=ldap_err2string(rc);
                                                                          log_log(3, "ldap_set_option(LDAP_OPT_X_TLS_CACERTDIR) failed: %s", return_value_ldap_err2string$20);
                                                                          exit(1);
                                                                        }

                                                                        free((void *)value);
                                                                      }

                                                                      else
                                                                      {
                                                                        return_value_strcasecmp$43=strcasecmp(keyword, "tls_cacertfile");
                                                                        if(return_value_strcasecmp$43 == 0)
                                                                          tmp_if_expr$45 = (_Bool)1;

                                                                        else
                                                                        {
                                                                          return_value_strcasecmp$44=strcasecmp(keyword, "tls_cacert");
                                                                          tmp_if_expr$45 = return_value_strcasecmp$44 == 0 ? (_Bool)1 : (_Bool)0;
                                                                        }
                                                                        if(tmp_if_expr$45)
                                                                        {
                                                                          value=get_strdup(filename, lnr, keyword, &line);
                                                                          get_eol(filename, lnr, keyword, &line);
                                                                          log_log(7, "ldap_set_option(LDAP_OPT_X_TLS_CACERTFILE,\"%s\")", value);
                                                                          rc=ldap_set_option((struct ldap *)(void *)0, 0x6002, (const void *)value);
                                                                          if(!(rc == 0x00))
                                                                          {
                                                                            char *return_value_ldap_err2string$21;
                                                                            return_value_ldap_err2string$21=ldap_err2string(rc);
                                                                            log_log(3, "ldap_set_option(LDAP_OPT_X_TLS_CACERTFILE) failed: %s", return_value_ldap_err2string$21);
                                                                            exit(1);
                                                                          }

                                                                          free((void *)value);
                                                                        }

                                                                        else
                                                                        {
                                                                          return_value_strcasecmp$42=strcasecmp(keyword, "tls_randfile");
                                                                          if(return_value_strcasecmp$42 == 0)
                                                                          {
                                                                            value=get_strdup(filename, lnr, keyword, &line);
                                                                            get_eol(filename, lnr, keyword, &line);
                                                                            log_log(7, "ldap_set_option(LDAP_OPT_X_TLS_RANDOM_FILE,\"%s\")", value);
                                                                            rc=ldap_set_option((struct ldap *)(void *)0, 0x6009, (const void *)value);
                                                                            if(!(rc == 0x00))
                                                                            {
                                                                              char *return_value_ldap_err2string$22;
                                                                              return_value_ldap_err2string$22=ldap_err2string(rc);
                                                                              log_log(3, "ldap_set_option(LDAP_OPT_X_TLS_RANDOM_FILE) failed: %s", return_value_ldap_err2string$22);
                                                                              exit(1);
                                                                            }

                                                                            free((void *)value);
                                                                          }

                                                                          else
                                                                          {
                                                                            return_value_strcasecmp$41=strcasecmp(keyword, "tls_ciphers");
                                                                            if(return_value_strcasecmp$41 == 0)
                                                                            {
                                                                              value=get_linedup(filename, lnr, keyword, &line);
                                                                              log_log(7, "ldap_set_option(LDAP_OPT_X_TLS_CIPHER_SUITE,\"%s\")", value);
                                                                              rc=ldap_set_option((struct ldap *)(void *)0, 0x6008, (const void *)value);
                                                                              if(!(rc == 0x00))
                                                                              {
                                                                                char *return_value_ldap_err2string$23;
                                                                                return_value_ldap_err2string$23=ldap_err2string(rc);
                                                                                log_log(3, "ldap_set_option(LDAP_OPT_X_TLS_CIPHER_SUITE) failed: %s", return_value_ldap_err2string$23);
                                                                                exit(1);
                                                                              }

                                                                              free((void *)value);
                                                                            }

                                                                            else
                                                                            {
                                                                              return_value_strcasecmp$40=strcasecmp(keyword, "tls_cert");
                                                                              if(return_value_strcasecmp$40 == 0)
                                                                              {
                                                                                value=get_strdup(filename, lnr, keyword, &line);
                                                                                get_eol(filename, lnr, keyword, &line);
                                                                                log_log(7, "ldap_set_option(LDAP_OPT_X_TLS_CERTFILE,\"%s\")", value);
                                                                                rc=ldap_set_option((struct ldap *)(void *)0, 0x6004, (const void *)value);
                                                                                if(!(rc == 0x00))
                                                                                {
                                                                                  char *return_value_ldap_err2string$24;
                                                                                  return_value_ldap_err2string$24=ldap_err2string(rc);
                                                                                  log_log(3, "ldap_set_option(LDAP_OPT_X_TLS_CERTFILE) failed: %s", return_value_ldap_err2string$24);
                                                                                  exit(1);
                                                                                }

                                                                                free((void *)value);
                                                                              }

                                                                              else
                                                                              {
                                                                                return_value_strcasecmp$39=strcasecmp(keyword, "tls_key");
                                                                                if(return_value_strcasecmp$39 == 0)
                                                                                {
                                                                                  value=get_strdup(filename, lnr, keyword, &line);
                                                                                  get_eol(filename, lnr, keyword, &line);
                                                                                  log_log(7, "ldap_set_option(LDAP_OPT_X_TLS_KEYFILE,\"%s\")", value);
                                                                                  rc=ldap_set_option((struct ldap *)(void *)0, 0x6005, (const void *)value);
                                                                                  if(!(rc == 0x00))
                                                                                  {
                                                                                    char *return_value_ldap_err2string$25;
                                                                                    return_value_ldap_err2string$25=ldap_err2string(rc);
                                                                                    log_log(3, "ldap_set_option(LDAP_OPT_X_TLS_KEYFILE) failed: %s", return_value_ldap_err2string$25);
                                                                                    exit(1);
                                                                                  }

                                                                                  free((void *)value);
                                                                                }

                                                                                else
                                                                                {
                                                                                  return_value_strcasecmp$38=strcasecmp(keyword, "pagesize");
                                                                                  if(return_value_strcasecmp$38 == 0)
                                                                                  {
                                                                                    cfg->pagesize=get_int(filename, lnr, keyword, &line);
                                                                                    get_eol(filename, lnr, keyword, &line);
                                                                                  }

                                                                                  else
                                                                                  {
                                                                                    return_value_strcasecmp$37=strcasecmp(keyword, "nss_initgroups_ignoreusers");
                                                                                    if(return_value_strcasecmp$37 == 0)
                                                                                      handle_nss_initgroups_ignoreusers(filename, lnr, keyword, line, cfg);

                                                                                    else
                                                                                    {
                                                                                      return_value_strcasecmp$36=strcasecmp(keyword, "nss_min_uid");
                                                                                      if(return_value_strcasecmp$36 == 0)
                                                                                      {
                                                                                        signed int return_value_get_int$26;
                                                                                        return_value_get_int$26=get_int(filename, lnr, keyword, &line);
                                                                                        cfg->nss_min_uid = (unsigned int)return_value_get_int$26;
                                                                                        get_eol(filename, lnr, keyword, &line);
                                                                                      }

                                                                                      else
                                                                                      {
                                                                                        return_value_strcasecmp$35=strcasecmp(keyword, "nss_nested_groups");
                                                                                        if(return_value_strcasecmp$35 == 0)
                                                                                        {
                                                                                          cfg->nss_nested_groups=get_boolean(filename, lnr, keyword, &line);
                                                                                          get_eol(filename, lnr, keyword, &line);
                                                                                        }

                                                                                        else
                                                                                        {
                                                                                          return_value_strcasecmp$34=strcasecmp(keyword, "nss_getgrent_skipmembers");
                                                                                          if(return_value_strcasecmp$34 == 0)
                                                                                          {
                                                                                            cfg->nss_getgrent_skipmembers=get_boolean(filename, lnr, keyword, &line);
                                                                                            get_eol(filename, lnr, keyword, &line);
                                                                                          }

                                                                                          else
                                                                                          {
                                                                                            return_value_strcasecmp$33=strcasecmp(keyword, "nss_disable_enumeration");
                                                                                            if(return_value_strcasecmp$33 == 0)
                                                                                            {
                                                                                              cfg->nss_getgrent_skipmembers=get_boolean(filename, lnr, keyword, &line);
                                                                                              get_eol(filename, lnr, keyword, &line);
                                                                                            }

                                                                                            else
                                                                                            {
                                                                                              return_value_strcasecmp$32=strcasecmp(keyword, "validnames");
                                                                                              if(return_value_strcasecmp$32 == 0)
                                                                                                handle_validnames(filename, lnr, keyword, line, cfg);

                                                                                              else
                                                                                              {
                                                                                                return_value_strcasecmp$31=strcasecmp(keyword, "ignorecase");
                                                                                                if(return_value_strcasecmp$31 == 0)
                                                                                                {
                                                                                                  cfg->ignorecase=get_boolean(filename, lnr, keyword, &line);
                                                                                                  get_eol(filename, lnr, keyword, &line);
                                                                                                }

                                                                                                else
                                                                                                {
                                                                                                  return_value_strcasecmp$30=strcasecmp(keyword, "pam_authz_search");
                                                                                                  if(return_value_strcasecmp$30 == 0)
                                                                                                    handle_pam_authz_search(filename, lnr, keyword, line, cfg);

                                                                                                  else
                                                                                                  {
                                                                                                    return_value_strcasecmp$29=strcasecmp(keyword, "pam_password_prohibit_message");
                                                                                                    if(return_value_strcasecmp$29 == 0)
                                                                                                      handle_pam_password_prohibit_message(filename, lnr, keyword, line, cfg);

                                                                                                    else
                                                                                                    {
                                                                                                      return_value_strcasecmp$28=strcasecmp(keyword, "reconnect_invalidate");
                                                                                                      if(return_value_strcasecmp$28 == 0)
                                                                                                        handle_reconnect_invalidate(filename, lnr, keyword, line, cfg);

                                                                                                      else
                                                                                                      {
                                                                                                        return_value_strcasecmp$27=strcasecmp(keyword, "cache");
                                                                                                        if(return_value_strcasecmp$27 == 0)
                                                                                                          handle_cache(filename, lnr, keyword, line, cfg);

                                                                                                        else
                                                                                                        {
                                                                                                          log_log(3, "%s:%d: unknown keyword: '%s'", filename, lnr, (const void *)keyword);
                                                                                                          exit(1);
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

    }

  }
  while((_Bool)1);
  fclose(fp);
}

// change
// file usermod.c line 145
static signed int change(struct ldap_session *session, const char *userdn, const char *homedir, const char *shell)
{
  char *strvals[6l];
  struct ldapmod mods[3l];
  struct ldapmod *modsp[3l];
  signed int i = 0;
  if(!(homedir == ((const char *)NULL)))
  {
    if(!((signed int)*attmap_passwd_homeDirectory == 34))
    {
      strvals[(signed long int)(i * 2)] = (char *)homedir;
      strvals[(signed long int)(i * 2 + 1)] = (char *)(void *)0;
      mods[(signed long int)i].mod_op = 0x0002;
      mods[(signed long int)i].mod_type = (char *)attmap_passwd_homeDirectory;
      mods[(signed long int)i].mod_vals.modv_strvals = strvals + (signed long int)(i * 2);
      modsp[(signed long int)i] = mods + (signed long int)i;
      i = i + 1;
    }

  }

  if(!(shell == ((const char *)NULL)))
  {
    if(!((signed int)*attmap_passwd_loginShell == 34))
    {
      strvals[(signed long int)(i * 2)] = (char *)shell;
      strvals[(signed long int)(i * 2 + 1)] = (char *)(void *)0;
      mods[(signed long int)i].mod_op = 0x0002;
      mods[(signed long int)i].mod_type = (char *)attmap_passwd_loginShell;
      mods[(signed long int)i].mod_vals.modv_strvals = strvals + (signed long int)(i * 2);
      modsp[(signed long int)i] = mods + (signed long int)i;
      i = i + 1;
    }

  }

  modsp[(signed long int)i] = (struct ldapmod *)(void *)0;
  signed int return_value_myldap_modify$1;
  return_value_myldap_modify$1=myldap_modify(session, userdn, modsp);
  return return_value_myldap_modify$1;
}

// check_argumentcount
// file cfg.c line 100
static inline void check_argumentcount(const char *filename, signed int lnr, const char *keyword, signed int condition)
{
  if(condition == 0)
  {
    log_log(3, "%s:%d: %s: wrong number of arguments", filename, lnr, keyword);
    exit(1);
  }

}

// check_permissions
// file cfg.c line 1124
static void check_permissions(const char *filename, const char *keyword)
{
  struct stat sb;
  signed int return_value_stat$3;
  return_value_stat$3=stat(filename, &sb);
  if(!(return_value_stat$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(3, "cannot stat() %s: %s", filename, return_value_strerror$2);
    exit(1);
  }

  if(!((7u & sb.st_mode) == 0u))
  {
    if(!(keyword == ((const char *)NULL)))
      log_log(3, "%s: file should not be world readable if %s is set", filename, keyword);

    else
      log_log(3, "%s: file should not be world readable", filename);
    exit(1);
  }

}

// check_shadow
// file pam.c line 159
static signed int check_shadow(struct ldap_session *session, const char *username, char *authzmsg, unsigned long int authzmsgsz, signed int check_maxdays, signed int check_mindays)
{
  struct myldap_entry *entry = (struct myldap_entry *)(void *)0;
  signed long int today;
  signed long int lastchangedate;
  signed long int mindays;
  signed long int maxdays;
  signed long int warndays;
  signed long int inactdays;
  signed long int expiredate;
  unsigned long int flag;
  signed long int daysleft;
  signed long int inactleft;
  entry=shadow_uid2entry(session, username, (signed int *)(void *)0);
  const char *return_value_myldap_get_dn$4;
  unsigned long int return_value_strlen$5;
  unsigned long int return_value_strlen$6;
  unsigned long int return_value_strlen$7;
  unsigned long int return_value_strlen$8;
  if(entry == ((struct myldap_entry *)NULL))
    return 0;

  else
  {
    signed long int return_value_time$1;
    return_value_time$1=time((signed long int *)(void *)0);
    today = (signed long int)(return_value_time$1 / (signed long int)(60 * 60 * 24));
    get_shadow_properties(entry, &lastchangedate, &mindays, &maxdays, &warndays, &inactdays, &expiredate, &flag);
    if(today >= expiredate && !(expiredate == -1l))
    {
      daysleft = today - expiredate;
      mysnprintf(authzmsg, authzmsgsz - (unsigned long int)1, "account expired %ld days ago", daysleft);
      const char *return_value_myldap_get_dn$2;
      return_value_myldap_get_dn$2=myldap_get_dn(entry);
      log_log(4, "%s: %s: %s", return_value_myldap_get_dn$2, attmap_shadow_shadowExpire, authzmsg);
      return 13;
    }

    if(!(check_maxdays == 0))
    {
      if(lastchangedate == 0l)
      {
        mysnprintf(authzmsg, authzmsgsz - (unsigned long int)1, "need a new password");
        const char *return_value_myldap_get_dn$3;
        return_value_myldap_get_dn$3=myldap_get_dn(entry);
        log_log(4, "%s: %s: %s", return_value_myldap_get_dn$3, attmap_shadow_shadowLastChange, authzmsg);
        return 12;
      }

      else
        if(!(today >= lastchangedate))
        {
          return_value_myldap_get_dn$4=myldap_get_dn(entry);
          log_log(4, "%s: %s: password changed in the future", return_value_myldap_get_dn$4, attmap_shadow_shadowLastChange);
        }

        else
          if(!(maxdays == -1l))
          {
            daysleft = (lastchangedate + maxdays) - today;
            if(daysleft == 0l)
              mysnprintf(authzmsg, authzmsgsz - (unsigned long int)1, "password will expire today");

            else
              if(!(daysleft >= 0l))
                mysnprintf(authzmsg, authzmsgsz - (unsigned long int)1, "password expired %ld days ago", -daysleft);

            if(!(inactdays == -1l) && !(daysleft >= 1l))
            {
              inactleft = (lastchangedate + maxdays + inactdays) - today;
              if(inactleft == 0l)
              {
                return_value_strlen$5=strlen(authzmsg);
                return_value_strlen$6=strlen(authzmsg);
                mysnprintf(authzmsg + (signed long int)return_value_strlen$5, (authzmsgsz - return_value_strlen$6) - (unsigned long int)1, ", account will be locked today");
              }

              else
                if(inactleft >= 1l)
                {
                  return_value_strlen$7=strlen(authzmsg);
                  return_value_strlen$8=strlen(authzmsg);
                  mysnprintf(authzmsg + (signed long int)return_value_strlen$7, (authzmsgsz - return_value_strlen$8) - (unsigned long int)1, ", account will be locked in %ld days", inactleft);
                }

                else
                {
                  unsigned long int return_value_strlen$9;
                  return_value_strlen$9=strlen(authzmsg);
                  unsigned long int return_value_strlen$10;
                  return_value_strlen$10=strlen(authzmsg);
                  mysnprintf(authzmsg + (signed long int)return_value_strlen$9, (authzmsgsz - return_value_strlen$10) - (unsigned long int)1, ", account locked %ld days ago", -inactleft);
                  const char *return_value_myldap_get_dn$11;
                  return_value_myldap_get_dn$11=myldap_get_dn(entry);
                  log_log(4, "%s: %s: %s", return_value_myldap_get_dn$11, attmap_shadow_shadowInactive, authzmsg);
                  return 27;
                }
            }

            if(!(daysleft >= 1l))
            {
              const char *return_value_myldap_get_dn$12;
              return_value_myldap_get_dn$12=myldap_get_dn(entry);
              log_log(4, "%s: %s: %s", return_value_myldap_get_dn$12, attmap_shadow_shadowMax, authzmsg);
              return 12;
            }

            if(warndays >= 1l && warndays >= daysleft)
            {
              mysnprintf(authzmsg, authzmsgsz - (unsigned long int)1, "password will expire in %ld days", daysleft);
              const char *return_value_myldap_get_dn$13;
              return_value_myldap_get_dn$13=myldap_get_dn(entry);
              log_log(4, "%s: %s: %s", return_value_myldap_get_dn$13, attmap_shadow_shadowWarning, authzmsg);
            }

          }

    }

    if(!(check_mindays == 0))
    {
      daysleft = (lastchangedate + mindays) - today;
      if(daysleft >= 1l && !(mindays == -1l))
      {
        mysnprintf(authzmsg, authzmsgsz - (unsigned long int)1, "password cannot be changed for another %ld days", daysleft);
        const char *return_value_myldap_get_dn$14;
        return_value_myldap_get_dn$14=myldap_get_dn(entry);
        log_log(4, "%s: %s: %s", return_value_myldap_get_dn$14, attmap_shadow_shadowMin, authzmsg);
        return 20;
      }

    }

    return 0;
  }
}

// closefd
// file daemonize.c line 128
static void closefd(void)
{
  if(daemonizefd >= 0)
  {
    close(daemonizefd);
    daemonizefd = -1;
  }

}

// connect_cb
// file myldap.c line 782
static signed int connect_cb(struct ldap *ld, struct sockbuf *sb, struct ldap_url_desc *srv, struct sockaddr *addr, struct ldap_conncb *ctx)
{
  if(!(nslcd_cfg->timelimit == 0))
    set_socket_timeout(ld, (signed long int)nslcd_cfg->timelimit, (signed long int)500000);

  return 0x00;
}

// create_pidfile
// file nslcd.c line 465
static void create_pidfile(const char *filename)
{
  signed int fd;
  char buffer[20l];
  if(!(filename == ((const char *)NULL)))
  {
    mkdirname(filename);
    fd=open(filename, 02 | 0100, 0644);
    if(!(fd >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_log(3, "cannot create pid file (%s): %s", filename, return_value_strerror$2);
      exit(1);
    }

    signed int return_value_lockf$5;
    return_value_lockf$5=lockf(fd, 2, (signed long int)0);
    if(!(return_value_lockf$5 >= 0))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      log_log(3, "cannot lock pid file (%s): %s", filename, return_value_strerror$4);
      exit(1);
    }

    signed int return_value_ftruncate$8;
    return_value_ftruncate$8=ftruncate(fd, (signed long int)0);
    if(!(return_value_ftruncate$8 >= 0))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      log_log(3, "cannot truncate pid file (%s): %s", filename, return_value_strerror$7);
      exit(1);
    }

    signed int return_value_getpid$9;
    return_value_getpid$9=getpid();
    mysnprintf(buffer, sizeof(char [20l]) /*20ul*/ , "%lu\n", (unsigned long int)return_value_getpid$9);
    unsigned long int return_value_strlen$12;
    return_value_strlen$12=strlen(buffer);
    signed long int return_value_write$13;
    return_value_write$13=write(fd, (const void *)buffer, return_value_strlen$12);
    unsigned long int return_value_strlen$14;
    return_value_strlen$14=strlen(buffer);
    if(!(return_value_write$13 == (signed long int)(signed int)return_value_strlen$14))
    {
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      char *return_value_strerror$11;
      return_value_strerror$11=strerror(*return_value___errno_location$10);
      log_log(3, "error writing pid file (%s): %s", filename, return_value_strerror$11);
      exit(1);
    }

  }

}

// create_socket
// file nslcd.c line 246
static signed int create_socket(const char *filename)
{
  signed int sock;
  signed int i;
  struct sockaddr_un addr;
  sock=socket(1, 1, 0);
  if(!(sock >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(3, "cannot create socket: %s", return_value_strerror$2);
    exit(1);
  }

  if(sock >= 1024)
  {
    log_log(3, "socket file descriptor number too high (%d)", sock);
    exit(1);
  }

  signed int return_value_unlink$5;
  return_value_unlink$5=unlink(filename);
  if(!(return_value_unlink$5 >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    log_log(7, "unlink() of %s failed (ignored): %s", filename, return_value_strerror$4);
  }

  i=fcntl(sock, 3, 0);
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  if(!(i >= 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    char *return_value_strerror$7;
    return_value_strerror$7=strerror(*return_value___errno_location$6);
    log_log(3, "fctnl(F_GETFL) failed: %s", return_value_strerror$7);
    signed int return_value_close$10;
    return_value_close$10=close(sock);
    if(!(return_value_close$10 == 0))
    {
      return_value___errno_location$8=__errno_location();
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "problem closing socket: %s", return_value_strerror$9);
    }

    exit(1);
  }

  signed int return_value_fcntl$16;
  return_value_fcntl$16=fcntl(sock, 4, i | 04000);
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  if(!(return_value_fcntl$16 >= 0))
  {
    signed int *return_value___errno_location$11;
    return_value___errno_location$11=__errno_location();
    char *return_value_strerror$12;
    return_value_strerror$12=strerror(*return_value___errno_location$11);
    log_log(3, "fctnl(F_SETFL,O_NONBLOCK) failed: %s", return_value_strerror$12);
    signed int return_value_close$15;
    return_value_close$15=close(sock);
    if(!(return_value_close$15 == 0))
    {
      return_value___errno_location$13=__errno_location();
      return_value_strerror$14=strerror(*return_value___errno_location$13);
      log_log(4, "problem closing socket: %s", return_value_strerror$14);
    }

    exit(1);
  }

  mkdirname(filename);
  memset((void *)&addr, 0, sizeof(struct sockaddr_un) /*110ul*/ );
  addr.sun_family = (unsigned short int)1;
  strncpy(addr.sun_path, filename, sizeof(char [108l]) /*108ul*/ );
  addr.sun_path[(signed long int)(sizeof(char [108l]) /*108ul*/  - (unsigned long int)1)] = (char)0;
  unsigned long int return_value_strlen$22;
  return_value_strlen$22=strlen((&addr)->sun_path);
  signed int return_value_bind$23;
  return_value_bind$23=bind(sock, (struct sockaddr *)&addr, (unsigned int)((unsigned long int)((struct sockaddr_un *)0)->sun_path + return_value_strlen$22));
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  if(!(return_value_bind$23 == 0))
  {
    signed int *return_value___errno_location$17;
    return_value___errno_location$17=__errno_location();
    char *return_value_strerror$18;
    return_value_strerror$18=strerror(*return_value___errno_location$17);
    log_log(3, "bind() to %s failed: %s", filename, return_value_strerror$18);
    signed int return_value_close$21;
    return_value_close$21=close(sock);
    if(!(return_value_close$21 == 0))
    {
      return_value___errno_location$19=__errno_location();
      return_value_strerror$20=strerror(*return_value___errno_location$19);
      log_log(4, "problem closing socket: %s", return_value_strerror$20);
    }

    exit(1);
  }

  signed int return_value_fcntl$29;
  return_value_fcntl$29=fcntl(sock, 2, 1);
  signed int *return_value___errno_location$26;
  char *return_value_strerror$27;
  if(!(return_value_fcntl$29 >= 0))
  {
    signed int *return_value___errno_location$24;
    return_value___errno_location$24=__errno_location();
    char *return_value_strerror$25;
    return_value_strerror$25=strerror(*return_value___errno_location$24);
    log_log(3, "fctnl(F_SETFL,FD_CLOEXEC) on %s failed: %s", filename, return_value_strerror$25);
    signed int return_value_close$28;
    return_value_close$28=close(sock);
    if(!(return_value_close$28 == 0))
    {
      return_value___errno_location$26=__errno_location();
      return_value_strerror$27=strerror(*return_value___errno_location$26);
      log_log(4, "problem closing socket: %s", return_value_strerror$27);
    }

    exit(1);
  }

  signed int return_value_chmod$35;
  return_value_chmod$35=chmod(filename, (unsigned int)0666);
  signed int *return_value___errno_location$32;
  char *return_value_strerror$33;
  if(!(return_value_chmod$35 == 0))
  {
    signed int *return_value___errno_location$30;
    return_value___errno_location$30=__errno_location();
    char *return_value_strerror$31;
    return_value_strerror$31=strerror(*return_value___errno_location$30);
    log_log(3, "chmod(0666) of %s failed: %s", filename, return_value_strerror$31);
    signed int return_value_close$34;
    return_value_close$34=close(sock);
    if(!(return_value_close$34 == 0))
    {
      return_value___errno_location$32=__errno_location();
      return_value_strerror$33=strerror(*return_value___errno_location$32);
      log_log(4, "problem closing socket: %s", return_value_strerror$33);
    }

    exit(1);
  }

  signed int return_value_listen$41;
  return_value_listen$41=listen(sock, 128);
  signed int *return_value___errno_location$38;
  char *return_value_strerror$39;
  if(!(return_value_listen$41 >= 0))
  {
    signed int *return_value___errno_location$36;
    return_value___errno_location$36=__errno_location();
    char *return_value_strerror$37;
    return_value_strerror$37=strerror(*return_value___errno_location$36);
    log_log(3, "listen() failed: %s", return_value_strerror$37);
    signed int return_value_close$40;
    return_value_close$40=close(sock);
    if(!(return_value_close$40 == 0))
    {
      return_value___errno_location$38=__errno_location();
      return_value_strerror$39=strerror(*return_value___errno_location$38);
      log_log(4, "problem closing socket: %s", return_value_strerror$39);
    }

    exit(1);
  }

  return sock;
}

// daemonize_closefds
// file daemonize.h line 45
void daemonize_closefds(void)
{
  signed int i;
  signed long int return_value_sysconf$1;
  return_value_sysconf$1=sysconf(4);
  i = (signed int)(return_value_sysconf$1 - (signed long int)1);
  if(!(i >= 0))
    i = 32;

  for( ; i >= 4; i = i - 1)
    close(i);
}

// daemonize_daemon
// file daemonize.h line 60
signed int daemonize_daemon(void)
{
  signed int pipefds[2l];
  signed int i;
  signed int return_value_pipe$3;
  return_value_pipe$3=pipe(pipefds);
  if(!(return_value_pipe$3 >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(3, "pipe() failed: %s", return_value_strerror$2);
    return -1;
  }

  i=fcntl(pipefds[(signed long int)1], 3, 0);
  if(!(i >= 0))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    log_log(3, "fcntl() failed: %s", return_value_strerror$5);
    close(pipefds[(signed long int)0]);
    close(pipefds[(signed long int)1]);
    return -1;
  }

  signed int return_value_fcntl$8;
  return_value_fcntl$8=fcntl(pipefds[(signed long int)1], 4, i | 04000);
  if(!(return_value_fcntl$8 >= 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    char *return_value_strerror$7;
    return_value_strerror$7=strerror(*return_value___errno_location$6);
    log_log(3, "fcntl() failed: %s", return_value_strerror$7);
    close(pipefds[(signed long int)0]);
    close(pipefds[(signed long int)1]);
    return -1;
  }

  signed int return_value_fork$9;
  return_value_fork$9=fork();
  signed int *return_value___errno_location$10;
  char *return_value_strerror$11;
  if(!(return_value_fork$9 == 0))
  {
    if(return_value_fork$9 == -1)
      goto __CPROVER_DUMP_L5;

  }

  else
  {
    close(pipefds[(signed long int)0]);
    goto __CPROVER_DUMP_L7;

  __CPROVER_DUMP_L5:
    ;
    return_value___errno_location$10=__errno_location();
    return_value_strerror$11=strerror(*return_value___errno_location$10);
    log_log(3, "fork() failed: %s", return_value_strerror$11);
    close(pipefds[(signed long int)0]);
    close(pipefds[(signed long int)1]);
    return -1;
  }
  close(pipefds[(signed long int)1]);
  signed int return_value_wait_for_response$12;
  return_value_wait_for_response$12=wait_for_response(pipefds[(signed long int)0]);
  return return_value_wait_for_response$12;

__CPROVER_DUMP_L7:
  ;
  signed int return_value_setsid$15;
  return_value_setsid$15=setsid();
  if(!(return_value_setsid$15 >= 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    char *return_value_strerror$14;
    return_value_strerror$14=strerror(*return_value___errno_location$13);
    log_log(3, "setsid() failed: %s", return_value_strerror$14);
    close(pipefds[(signed long int)1]);
    _exit(1);
  }

  signed int return_value_fork$16;
  return_value_fork$16=fork();
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  if(!(return_value_fork$16 == 0))
  {
    if(return_value_fork$16 == -1)
      goto __CPROVER_DUMP_L10;

  }

  else
  {
    goto __CPROVER_DUMP_L12;

  __CPROVER_DUMP_L10:
    ;
    return_value___errno_location$17=__errno_location();
    return_value_strerror$18=strerror(*return_value___errno_location$17);
    log_log(3, "fork() failed: %s", return_value_strerror$18);
    close(pipefds[(signed long int)1]);
    _exit(1);
  }
  close(pipefds[(signed long int)1]);
  _exit(0);

__CPROVER_DUMP_L12:
  ;
  daemonizefd = pipefds[(signed long int)1];
  fcntl(daemonizefd, 2, 1);
  pthread_atfork((void (*)(void))(void *)0, (void (*)(void))(void *)0, closefd);
  return 0;
}

// daemonize_ready
// file daemonize.h line 65
void daemonize_ready(signed int status, const char *message)
{
  signed int l;
  _Bool tmp_if_expr$2;
  if(daemonizefd >= 0)
  {
    write(daemonizefd, (const void *)&status, sizeof(signed int) /*4ul*/ );
    if(message == ((const char *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)message[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      l = 0;
      write(daemonizefd, (const void *)&l, sizeof(signed int) /*4ul*/ );
    }

    else
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(message);
      l = (signed int)return_value_strlen$1;
      write(daemonizefd, (const void *)&l, sizeof(signed int) /*4ul*/ );
      write(daemonizefd, (const void *)message, (unsigned long int)l);
    }
    close(daemonizefd);
    daemonizefd = -1;
  }

}

// daemonize_redirect_stdio
// file daemonize.h line 48
void daemonize_redirect_stdio(void)
{
  close(0);
  close(1);
  close(2);
  open("/dev/null", 02);
  dup(0);
  dup(0);
}

// dict_free
// file ../common/dict.h line 64
void dict_free(struct dictionary *dict)
{
  struct dict_entry *entry;
  struct dict_entry *etmp;
  signed int i = 0;
  for( ; !(i >= dict->size); i = i + 1)
  {
    entry = dict->table[(signed long int)i];
    while(!(entry == ((struct dict_entry *)NULL)))
    {
      etmp = entry;
      entry = entry->next;
      free((void *)etmp);
    }
  }
  free((void *)dict->table);
  free((void *)dict);
}

// dict_get
// file ../common/dict.h line 48
void * dict_get(struct dictionary *dict, const char *key)
{
  unsigned int hash;
  struct dict_entry *entry;
  hash=stringhash(key);
  entry = dict->table[(signed long int)(hash % (unsigned int)dict->size)];
  signed int return_value_strcmp$1;
  for( ; !(entry == ((struct dict_entry *)NULL)); entry = entry->next)
    if(entry->hash == hash)
    {
      return_value_strcmp$1=strcmp(entry->key, key);
      if(return_value_strcmp$1 == 0)
        return entry->value;

    }

  return (void *)0;
}

// dict_getany
// file dict.c line 179
const char * dict_getany(struct dictionary *dict)
{
  signed int i = 0;
  for( ; !(i >= dict->size); i = i + 1)
    if(!(dict->table[(signed long int)i] == ((struct dict_entry *)NULL)))
      return dict->table[(signed long int)i]->key;

  return (const char *)(void *)0;
}

// dict_keys
// file ../common/dict.h line 68
const char ** dict_keys(struct dictionary *dict)
{
  signed int i;
  struct dict_entry *entry;
  char *buf;
  const char **values;
  unsigned long int sz;
  signed int num = 0;
  sz = (unsigned long int)0;
  i = 0;
  for( ; !(i >= dict->size); i = i + 1)
  {
    entry = dict->table[(signed long int)i];
    while(!(entry == ((struct dict_entry *)NULL)))
    {
      num = num + 1;
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(entry->key);
      sz = sz + return_value_strlen$1 + (unsigned long int)1;
      entry = entry->next;
    }
  }
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)(num + 1) * sizeof(char *) /*8ul*/  + sz);
  buf = (char *)return_value_malloc$2;
  signed int tmp_post$3;
  if(buf == ((char *)NULL))
    return (const char **)(void *)0;

  else
  {
    values = (const char **)(void *)buf;
    buf = buf + (signed long int)((unsigned long int)(num + 1) * sizeof(char *) /*8ul*/ );
    num = 0;
    i = 0;
    for( ; !(i >= dict->size); i = i + 1)
    {
      entry = dict->table[(signed long int)i];
      while(!(entry == ((struct dict_entry *)NULL)))
      {
        strcpy(buf, entry->key);
        tmp_post$3 = num;
        num = num + 1;
        values[(signed long int)tmp_post$3] = buf;
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(buf);
        buf = buf + (signed long int)(return_value_strlen$4 + (unsigned long int)1);
        entry = entry->next;
      }
    }
    values[(signed long int)num] = (const char *)(void *)0;
    return values;
  }
}

// dict_new
// file ../common/dict.h line 35
struct dictionary * dict_new(void)
{
  struct dictionary *dict;
  signed int i;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dictionary) /*16ul*/ );
  dict = (struct dictionary *)return_value_malloc$1;
  if(dict == ((struct dictionary *)NULL))
    return (struct dictionary *)(void *)0;

  else
  {
    dict->size = 7;
    dict->num = 0;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)7 * sizeof(struct dict_entry *) /*8ul*/ );
    dict->table = (struct dict_entry **)return_value_malloc$2;
    if(dict->table == ((struct dict_entry **)NULL))
    {
      free((void *)dict);
      return (struct dictionary *)(void *)0;
    }

    else
    {
      i = 0;
      for( ; !(i >= 7); i = i + 1)
        dict->table[(signed long int)i] = (struct dict_entry *)(void *)0;
      return dict;
    }
  }
}

// dict_put
// file ../common/dict.h line 43
signed int dict_put(struct dictionary *dict, const char *key, void *value)
{
  unsigned int hash;
  signed int l;
  char *buf;
  signed int idx;
  struct dict_entry *entry;
  struct dict_entry *prev;
  if(dict->num >= (400 * dict->size) / 100)
    growhashtable(dict);

  hash=stringhash(key);
  idx = (signed int)(hash % (unsigned int)dict->size);
  entry = dict->table[(signed long int)idx];
  prev = (struct dict_entry *)(void *)0;
  signed int return_value_strcmp$1;
  for( ; !(entry == ((struct dict_entry *)NULL)); entry = entry->next)
  {
    if(entry->hash == hash)
    {
      return_value_strcmp$1=strcmp(entry->key, key);
      if(return_value_strcmp$1 == 0)
      {
        if(value == NULL)
        {
          if(prev == ((struct dict_entry *)NULL))
            dict->table[(signed long int)idx] = entry->next;

          else
            prev->next = entry->next;
          free((void *)entry);
          dict->num = dict->num - 1;
          return 0;
        }

        entry->value = value;
        return 0;
      }

    }

    prev = entry;
  }
  if(value == NULL)
    return 0;

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(key);
    l = (signed int)(return_value_strlen$2 + (unsigned long int)1);
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(sizeof(struct dict_entry) /*32ul*/  + (unsigned long int)l);
    buf = (char *)return_value_malloc$3;
    if(buf == ((char *)NULL))
      return -1;

    else
    {
      entry = (struct dict_entry *)(void *)buf;
      buf = buf + (signed long int)sizeof(struct dict_entry) /*32ul*/ ;
      strcpy(buf, key);
      entry->hash = hash;
      entry->key = buf;
      entry->value = value;
      entry->next = dict->table[(signed long int)idx];
      dict->table[(signed long int)idx] = entry;
      dict->num = dict->num + 1;
      return 0;
    }
  }
}

// disable_nss_ldap
// file nslcd.c line 601
static void disable_nss_ldap(void)
{
  void *handle;
  char *error;
  char **version_info;
  signed int *enable_flag;
  handle=dlopen("libnss_ldap.so.2", 0x00001 | 0x01000);
  if(handle == NULL)
  {
    char *return_value_dlerror$1;
    return_value_dlerror$1=dlerror();
    log_log(4, "Warning: NSS_LDAP module not loaded: %s", return_value_dlerror$1);
    goto __CPROVER_DUMP_L6;
  }

  dlerror();
  void *return_value_dlsym$2;
  return_value_dlsym$2=dlsym(handle, "_nss_ldap_version");
  version_info = (char **)return_value_dlsym$2;
  error=dlerror();
  if(error == ((char *)NULL) && !(version_info == ((char **)NULL)))
    log_log(7, "NSS_LDAP %s %s", version_info[(signed long int)0], version_info[(signed long int)1]);

  else
    log_log(4, "Warning: NSS_LDAP version missing: %s", error);
  dlerror();
  void *return_value_dlsym$3;
  return_value_dlsym$3=dlsym(handle, "_nss_ldap_enablelookups");
  enable_flag = (signed int *)return_value_dlsym$3;
  error=dlerror();
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(enable_flag == ((signed int *)NULL) || !(error == ((char *)NULL)))
  {
    log_log(4, "Warning: %s (probably older NSS module loaded)", error);
    signed int return_value___nss_configure_lookup$6;
    return_value___nss_configure_lookup$6=__nss_configure_lookup("hosts", "files dns");
    if(!(return_value___nss_configure_lookup$6 == 0))
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_log(3, "unable to override hosts lookup method: %s", return_value_strerror$5);
    }

    dlclose(handle);
    goto __CPROVER_DUMP_L6;
  }

  *enable_flag = 0;
  dlclose(handle);

__CPROVER_DUMP_L6:
  ;
}

// disconnect_cb
// file myldap.c line 796
static void disconnect_cb(struct ldap *ld, struct sockbuf *sb, struct ldap_conncb *ctx)
{
  ;
}

// display_usage
// file nslcd.c line 130
static void display_usage(struct _IO_FILE *fp, const char *program_name)
{
  fprintf(fp, "Usage: %s [OPTION]...\n", program_name);
  fprintf(fp, "Name Service LDAP connection daemon.\n");
  fprintf(fp, "  -c, --check        check if the daemon already is running\n");
  fprintf(fp, "  -d, --debug        don't fork and print debugging to stderr\n");
  fprintf(fp, "  -n, --nofork       don't fork\n");
  fprintf(fp, "      --help         display this help and exit\n");
  fprintf(fp, "      --version      output version information and exit\n");
  fprintf(fp, "\nReport bugs to <%s>.\n", (const void *)"nss-pam-ldapd-users@lists.arthurdejong.org");
}

// display_version
// file nslcd.c line 120
static void display_version(struct _IO_FILE *fp)
{
  fprintf(fp, "%s\n", (const void *)"nss-pam-ldapd 0.9.6");
  fprintf(fp, "Written by Luke Howard and Arthur de Jong.\n\n");
  fprintf(fp, "Copyright (C) 1997-2015 Luke Howard, Arthur de Jong and West Consulting\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
}

// dn2uid
// file common.h line 118
char * dn2uid(struct ldap_session *session, const char *dn, char *buf, unsigned long int buflen)
{
  struct dn2uid_cache_entry *cacheentry = (struct dn2uid_cache_entry *)(void *)0;
  char *uid;
  _Bool tmp_if_expr$1;
  if(dn == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*dn == 0 ? (_Bool)1 : (_Bool)0;
  char *return_value_lookup_dn2uid$4;
  void *return_value_dict_get$9;
  _Bool tmp_if_expr$8;
  unsigned long int return_value_strlen$7;
  signed long int return_value_time$5;
  signed long int return_value_time$6;
  char *tmp_if_expr$13;
  char *return_value_strdup$12;
  _Bool tmp_if_expr$17;
  signed int return_value_strcmp$16;
  char *tmp_if_expr$15;
  char *return_value_strdup$14;
  if(tmp_if_expr$1)
    return (char *)(void *)0;

  else
  {
    const char *return_value_myldap_cpy_rdn_value$3;
    return_value_myldap_cpy_rdn_value$3=myldap_cpy_rdn_value(dn, attmap_passwd_uid, buf, buflen);
    if(!(return_value_myldap_cpy_rdn_value$3 == ((const char *)NULL)))
    {
      signed int return_value_isvalidname$2;
      return_value_isvalidname$2=isvalidname(buf);
      if(return_value_isvalidname$2 == 0)
        return (char *)(void *)0;

      return buf;
    }

    if(nslcd_cfg->cache_dn2uid_positive == 0l)
    {
      if(!(nslcd_cfg->cache_dn2uid_negative == 0l))
        goto __CPROVER_DUMP_L6;

      return_value_lookup_dn2uid$4=lookup_dn2uid(session, dn, (signed int *)(void *)0, buf, buflen);
      return return_value_lookup_dn2uid$4;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      pthread_mutex_lock(&dn2uid_cache_mutex);
      if(dn2uid_cache == ((struct dictionary *)NULL))
        dn2uid_cache=dict_new();

      if(!(dn2uid_cache == ((struct dictionary *)NULL)))
      {
        return_value_dict_get$9=dict_get(dn2uid_cache, dn);
        cacheentry = (struct dn2uid_cache_entry *)return_value_dict_get$9;
        if(!(cacheentry == ((struct dn2uid_cache_entry *)NULL)))
        {
          if(!(cacheentry->uid == ((char *)NULL)))
          {
            return_value_strlen$7=strlen(cacheentry->uid);
            tmp_if_expr$8 = return_value_strlen$7 < buflen ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$8 = (_Bool)0;
          if(tmp_if_expr$8)
          {
            if(nslcd_cfg->cache_dn2uid_positive >= 1l)
            {
              return_value_time$5=time((signed long int *)(void *)0);
              if(!(return_value_time$5 >= cacheentry->timestamp + nslcd_cfg->cache_dn2uid_positive))
              {
                strcpy(buf, cacheentry->uid);
                pthread_mutex_unlock(&dn2uid_cache_mutex);
                return buf;
              }

            }

          }

          else
            if(nslcd_cfg->cache_dn2uid_negative >= 1l)
            {
              return_value_time$6=time((signed long int *)(void *)0);
              if(!(return_value_time$6 >= cacheentry->timestamp + nslcd_cfg->cache_dn2uid_negative))
              {
                pthread_mutex_unlock(&dn2uid_cache_mutex);
                return (char *)(void *)0;
              }

            }

        }

      }

      pthread_mutex_unlock(&dn2uid_cache_mutex);
      uid=lookup_dn2uid(session, dn, (signed int *)(void *)0, buf, buflen);
      pthread_mutex_lock(&dn2uid_cache_mutex);
      void *return_value_dict_get$10;
      return_value_dict_get$10=dict_get(dn2uid_cache, dn);
      cacheentry = (struct dn2uid_cache_entry *)return_value_dict_get$10;
      if(cacheentry == ((struct dn2uid_cache_entry *)NULL))
      {
        void *return_value_malloc$11;
        return_value_malloc$11=malloc(sizeof(struct dn2uid_cache_entry) /*16ul*/ );
        cacheentry = (struct dn2uid_cache_entry *)return_value_malloc$11;
        if(!(cacheentry == ((struct dn2uid_cache_entry *)NULL)))
        {
          cacheentry->uid = (char *)(void *)0;
          dict_put(dn2uid_cache, dn, (void *)cacheentry);
        }

      }

      if(!(cacheentry == ((struct dn2uid_cache_entry *)NULL)))
      {
        cacheentry->timestamp=time((signed long int *)(void *)0);
        if(cacheentry->uid == ((char *)NULL))
        {
          if(!(uid == ((char *)NULL)))
          {
            return_value_strdup$12=strdup(uid);
            tmp_if_expr$13 = return_value_strdup$12;
          }

          else
            tmp_if_expr$13 = (char *)(void *)0;
          cacheentry->uid = tmp_if_expr$13;
        }

        else
        {
          if(uid == ((char *)NULL))
            tmp_if_expr$17 = (_Bool)1;

          else
          {
            return_value_strcmp$16=strcmp(cacheentry->uid, uid);
            tmp_if_expr$17 = return_value_strcmp$16 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$17)
          {
            free((void *)cacheentry->uid);
            if(!(uid == ((char *)NULL)))
            {
              return_value_strdup$14=strdup(uid);
              tmp_if_expr$15 = return_value_strdup$14;
            }

            else
              tmp_if_expr$15 = (char *)(void *)0;
            cacheentry->uid = tmp_if_expr$15;
          }

        }
      }

      pthread_mutex_unlock(&dn2uid_cache_mutex);
      return uid;
    }
  }
}

// do_autzsearches
// file pam.c line 406
static signed int do_autzsearches(struct ldap_session *session, const char *filter)
{
  signed int i;
  signed int rc;
  const char *base;
  struct myldap_search *search;
  struct myldap_entry *entry;
  static const char *attrs[2l];
  attrs[(signed long int)0] = "dn";
  attrs[(signed long int)1] = (const char *)(void *)0;
  log_log(7, "trying pam_authz_search \"%s\"", filter);
  i = 0;
  do
  {
    base = nslcd_cfg->bases[(signed long int)i];
    if(base == ((const char *)NULL))
      break;

    search=myldap_search(session, base, (signed int)0x0002, filter, attrs, &rc);
    if(search == ((struct myldap_search *)NULL))
    {
      char *return_value_ldap_err2string$1;
      return_value_ldap_err2string$1=ldap_err2string(rc);
      log_log(3, "pam_authz_search \"%s\" failed: %s", filter, return_value_ldap_err2string$1);
      return rc;
    }

    entry=myldap_get_entry(search, &rc);
    if(!(entry == ((struct myldap_entry *)NULL)))
    {
      const char *return_value_myldap_get_dn$2;
      return_value_myldap_get_dn$2=myldap_get_dn(entry);
      log_log(7, "pam_authz_search found \"%s\"", return_value_myldap_get_dn$2);
      return 0x00;
    }

    i = i + 1;
  }
  while((_Bool)1);
  log_log(3, "pam_authz_search \"%s\" found no matches", filter);
  if(rc == 0x00)
    rc = 0x20;

  return rc;
}

// do_bind
// file myldap.c line 605
static signed int do_bind(struct ldap_session *session, struct ldap *ld, const char *uri)
{
  signed int rc;
  if((signed int)nslcd_cfg->ssl == SSL_START_TLS)
  {
    log_log(7, "ldap_start_tls_s()");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 0;
    rc=ldap_start_tls_s(ld, (struct ldapcontrol **)(void *)0, (struct ldapcontrol **)(void *)0);
    if(!(rc == 0x00))
    {
      myldap_err(4, ld, rc, "ldap_start_tls_s() failed (uri=%s)", uri);
      return rc;
    }

  }

  if(!((signed int)session->binddn[0l] == 0))
  {
    signed int return_value_do_ppolicy_bind$2;
    return_value_do_ppolicy_bind$2=do_ppolicy_bind(session, ld, uri);
    return return_value_do_ppolicy_bind$2;
  }

  if(!(nslcd_cfg->sasl_mech == ((char *)NULL)))
  {
    if(!(nslcd_cfg->sasl_secprops == ((char *)NULL)))
    {
      log_log(7, "ldap_set_option(LDAP_OPT_X_SASL_SECPROPS,\"%s\")", nslcd_cfg->sasl_secprops);
      rc=ldap_set_option(ld, 0x6106, (void *)nslcd_cfg->sasl_secprops);
      if(!(rc == 0x00))
      {
        myldap_err(3, ld, rc, "ldap_set_option(LDAP_OPT_X_SASL_SECPROPS) failed");
        return rc;
      }

    }

    if(!(nslcd_cfg->binddn == ((char *)NULL)))
      log_log(7, "ldap_sasl_interactive_bind_s(\"%s\",\"%s\") (uri=\"%s\")", nslcd_cfg->binddn, nslcd_cfg->sasl_mech, uri);

    else
      log_log(7, "ldap_sasl_interactive_bind_s(NULL,\"%s\") (uri=\"%s\")", nslcd_cfg->sasl_mech, uri);
    signed int return_value_ldap_sasl_interactive_bind_s$3;
    return_value_ldap_sasl_interactive_bind_s$3=ldap_sasl_interactive_bind_s(ld, nslcd_cfg->binddn, nslcd_cfg->sasl_mech, (struct ldapcontrol **)(void *)0, (struct ldapcontrol **)(void *)0, 2U, do_sasl_interact, (void *)nslcd_cfg);
    return return_value_ldap_sasl_interactive_bind_s$3;
  }

  if(!(nslcd_cfg->binddn == ((char *)NULL)))
    log_log(7, "ldap_simple_bind_s(\"%s\",%s) (uri=\"%s\")", nslcd_cfg->binddn, nslcd_cfg->bindpw != ((char *)NULL) ? "\"***\"" : "NULL", uri);

  else
    log_log(7, "ldap_simple_bind_s(NULL,%s) (uri=\"%s\")", nslcd_cfg->bindpw != ((char *)NULL) ? "\"***\"" : "NULL", uri);
  signed int return_value_ldap_simple_bind_s$4;
  return_value_ldap_simple_bind_s$4=ldap_simple_bind_s(ld, nslcd_cfg->binddn, nslcd_cfg->bindpw);
  return return_value_ldap_simple_bind_s$4;
}

// do_close
// file myldap.c line 900
static void do_close(struct ldap_session *session)
{
  signed int i;
  signed int rc;
  signed long int sec;
  if(!(session->ld == ((struct ldap *)NULL)))
  {
    if(!(nslcd_cfg->timelimit == 0))
    {
      sec = (signed long int)(nslcd_cfg->timelimit / 2);
      if(sec == 0l)
        sec = (signed long int)1;

      set_socket_timeout(session->ld, sec, (signed long int)0);
    }

    i = 0;
    for( ; !(i >= 4); i = i + 1)
      if(!(session->searches[(signed long int)i] == ((struct myldap_search *)NULL)))
      {
        if(!(session->searches[(signed long int)i]->msg == ((struct ldapmsg *)NULL)))
        {
          ldap_msgfree(session->searches[(signed long int)i]->msg);
          session->searches[(signed long int)i]->msg = (struct ldapmsg *)(void *)0;
        }

        if(!(session->searches[(signed long int)i]->msgid == -1))
        {
          log_log(7, "ldap_abandon()");
          signed int return_value_ldap_abandon$2;
          return_value_ldap_abandon$2=ldap_abandon(session->searches[(signed long int)i]->session->ld, session->searches[(signed long int)i]->msgid);
          if(!(return_value_ldap_abandon$2 == 0))
          {
            signed int return_value_ldap_get_option$1;
            return_value_ldap_get_option$1=ldap_get_option(session->ld, 0x0031, (void *)&rc);
            if(!(return_value_ldap_get_option$1 == 0x00))
              rc = 0x50;

            myldap_err(4, session->ld, rc, "ldap_abandon() failed to abandon search");
          }

          session->searches[(signed long int)i]->msgid = -1;
        }

        session->searches[(signed long int)i]->valid = 0;
      }

    log_log(7, "ldap_unbind()");
    rc=ldap_unbind(session->ld);
    session->ld = (struct ldap *)(void *)0;
    if(!(rc == 0x00))
      myldap_err(4, session->ld, rc, "ldap_unbind() failed");

  }

}

// do_open
// file myldap.c line 1011
static signed int do_open(struct ldap_session *session)
{
  signed int rc;
  if(!(session->ld == ((struct ldap *)NULL)))
    return 0x00;

  else
  {
    session->ld = (struct ldap *)(void *)0;
    session->lastactivity = (signed long int)0;
    log_log(7, "ldap_initialize(%s)", nslcd_cfg->uris[(signed long int)session->current_uri].uri);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 0;
    rc=ldap_initialize(&session->ld, nslcd_cfg->uris[(signed long int)session->current_uri].uri);
    if(!(rc == 0x00))
    {
      myldap_err(4, session->ld, rc, "ldap_initialize(%s) failed", nslcd_cfg->uris[(signed long int)session->current_uri].uri);
      if(!(session->ld == ((struct ldap *)NULL)))
        do_close(session);

      return rc;
    }

    else
      if(session->ld == ((struct ldap *)NULL))
      {
        log_log(4, "ldap_initialize() returned NULL");
        return -2;
      }

    rc=do_set_options(session);
    if(!(rc == 0x00))
    {
      do_close(session);
      return rc;
    }

    else
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 0;
      rc=do_bind(session, session->ld, nslcd_cfg->uris[(signed long int)session->current_uri].uri);
      if(!(rc == 0x00))
      {
        myldap_err((signed int)session->binddn[(signed long int)0] == 0 ? 4 : 7, session->ld, rc, "failed to bind to LDAP server %s", nslcd_cfg->uris[(signed long int)session->current_uri].uri);
        do_close(session);
        return rc;
      }

      else
      {
        time(&session->lastactivity);
        return 0x00;
      }
    }
  }
}

// do_ppolicy_bind
// file myldap.c line 522
static signed int do_ppolicy_bind(struct ldap_session *session, struct ldap *ld, const char *uri)
{
  signed int rc;
  signed int parserc;
  struct berval cred;
  struct ldapcontrol passwd_policy_req;
  struct ldapcontrol *requestctrls[2l];
  struct ldapcontrol **responsectrls;
  signed int msgid;
  struct timeval timeout;
  struct ldapmsg *result;
  passwd_policy_req.ldctl_oid = "1.3.6.1.4.1.42.2.27.8.5.1";
  passwd_policy_req.ldctl_value.bv_val = (char *)(void *)0;
  passwd_policy_req.ldctl_value.bv_len = (unsigned long int)0;
  passwd_policy_req.ldctl_iscritical = (char)0;
  requestctrls[(signed long int)0] = &passwd_policy_req;
  requestctrls[(signed long int)1] = (struct ldapcontrol *)(void *)0;
  cred.bv_val = (char *)session->bindpw;
  cred.bv_len=strlen(session->bindpw);
  log_log(7, "ldap_sasl_bind(\"%s\",%s) (uri=\"%s\")", (const void *)session->binddn, (signed int)session->bindpw[(signed long int)0] != 0 ? "\"***\"" : "\"\"", uri);
  rc=ldap_sasl_bind(ld, session->binddn, (char *)0, &cred, requestctrls, (struct ldapcontrol **)(void *)0, &msgid);
  if(!(rc == 0x00))
    return rc;

  else
    if(msgid == -1)
    {
      myldap_err(4, ld, rc, "ldap_sasl_bind() failed (msgid=-1, uri=%s)", uri);
      return 0x01;
    }

    else
    {
      timeout.tv_sec = (signed long int)nslcd_cfg->bind_timelimit;
      timeout.tv_usec = (signed long int)0;
      result = (struct ldapmsg *)(void *)0;
      rc=ldap_result(ld, msgid, 0x01, &timeout, &result);
      if(rc == -1)
      {
        signed int return_value_ldap_get_option$1;
        return_value_ldap_get_option$1=ldap_get_option(ld, 0x0031, (void *)&rc);
        if(!(return_value_ldap_get_option$1 == 0x00))
          rc = 0x34;

        myldap_err(3, ld, rc, "ldap_result() failed");
        if(!(result == ((struct ldapmsg *)NULL)))
          ldap_msgfree(result);

        return -2;
      }

      if(rc == 0)
      {
        log_log(3, "ldap_result() timed out");
        if(!(result == ((struct ldapmsg *)NULL)))
          ldap_msgfree(result);

        return -5;
      }

      else
      {
        responsectrls = (struct ldapcontrol **)(void *)0;
        parserc=ldap_parse_result(ld, result, &rc, (char **)(void *)0, (char **)(void *)0, (char ***)(void *)0, &responsectrls, 1);
        if(!(parserc == 0x00))
        {
          myldap_err(3, ld, parserc, "ldap_parse_result() failed");
          if(!(responsectrls == ((struct ldapcontrol **)NULL)))
            ldap_controls_free(responsectrls);

          return parserc;
        }

        else
        {
          if(!(responsectrls == ((struct ldapcontrol **)NULL)))
          {
            handle_ppolicy_controls(session, ld, responsectrls);
            ldap_controls_free(responsectrls);
          }

          if(!(rc == 0x00))
          {
            myldap_err(7, ld, rc, "ldap_parse_result() result");
            return rc;
          }

          else
            return 0x00;
        }
      }
    }
}

// do_rebind
// file myldap.c line 704
static signed int do_rebind(struct ldap *ld, const char *url, unsigned long int request, signed int msgid, void *arg)
{
  struct ldap_session *session = (struct ldap_session *)arg;
  log_log(7, "rebinding to %s", url);
  signed int return_value_do_bind$1;
  return_value_do_bind$1=do_bind(session, ld, url);
  return return_value_do_bind$1;
}

// do_retry_search
// file myldap.c line 1236
static signed int do_retry_search(struct myldap_search *search)
{
  signed int sleeptime = 0;
  signed int start_uri;
  signed long int endtime;
  signed long int nexttry;
  signed long int t;
  signed int rc = 0x34;
  struct myldap_uri *current_uri;
  signed int dotry[31l];
  signed int do_invalidate = 0;
  start_uri = 0;
  for( ; !(start_uri >= 31); start_uri = start_uri + 1)
    dotry[(signed long int)start_uri] = 1;
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  endtime = return_value_time$1 + (signed long int)nslcd_cfg->reconnect_retrytime;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  while((_Bool)1)
  {
    nexttry = endtime;
    pthread_mutex_lock(&uris_mutex);
    start_uri = search->session->current_uri;
    do
    {
      current_uri = &nslcd_cfg->uris[(signed long int)search->session->current_uri];
      if(!(dotry[(signed long int)search->session->current_uri] == 0))
      {
        if(!(current_uri->firstfail + (signed long int)nslcd_cfg->reconnect_retrytime >= current_uri->lastfail))
        {
          t=time((signed long int *)(void *)0);
          tmp_if_expr$3 = t < current_uri->lastfail + (signed long int)nslcd_cfg->reconnect_retrytime ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
        {
          log_log(7, "not retrying server %s which failed just %d second(s) ago and has been failing for %d seconds", current_uri->uri, (signed int)(t - current_uri->lastfail), (signed int)(t - current_uri->firstfail));
          dotry[(signed long int)search->session->current_uri] = 0;
        }

        else
        {
          pthread_mutex_unlock(&uris_mutex);
          rc=do_try_search(search);
          if(rc == 0x00)
          {
            pthread_mutex_lock(&uris_mutex);
            if(current_uri->lastfail >= 1l)
              tmp_if_expr$2 = (_Bool)1;

            else
              tmp_if_expr$2 = search->session->current_uri != start_uri ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$2)
            {
              log_log(6, "connected to LDAP server %s", current_uri->uri);
              do_invalidate = 1;
            }

            if(!(first_search == 0))
            {
              do_invalidate = 1;
              first_search = 0;
            }

            current_uri->firstfail = (signed long int)0;
            current_uri->lastfail = (signed long int)0;
            pthread_mutex_unlock(&uris_mutex);
            search->valid = 1;
            if(!(do_invalidate == 0))
              invalidator_do((enum ldap_map_selector)LM_NONE);

            return 0x00;
          }

          do_close(search->session);
          pthread_mutex_lock(&uris_mutex);
          t=time((signed long int *)(void *)0);
          if((signed int)search->session->binddn[0l] == 0)
          {
            if(current_uri->firstfail == 0l)
              current_uri->firstfail = t;

            current_uri->lastfail = t;
          }

          if(rc == 0x07 || rc == 0x31 || rc == 0x32)
            dotry[(signed long int)search->session->current_uri] = 0;

          else
            if(current_uri->firstfail + (signed long int)nslcd_cfg->reconnect_retrytime >= t)
            {
              t = t + (signed long int)nslcd_cfg->reconnect_sleeptime;
              if(!(t >= nexttry))
                nexttry = t;

            }

        }
      }

      search->session->current_uri = search->session->current_uri + 1;
      if(nslcd_cfg->uris[(signed long int)search->session->current_uri].uri == ((char *)NULL))
        search->session->current_uri = 0;

    }
    while(!(search->session->current_uri == start_uri));
    pthread_mutex_unlock(&uris_mutex);
    if(nexttry >= endtime)
    {
      if((signed int)search->session->binddn[0l] == 0)
        myldap_err(3, search->session->ld, rc, "no available LDAP server found");

      return rc;
    }

    signed long int return_value_time$4;
    return_value_time$4=time((signed long int *)(void *)0);
    sleeptime = (signed int)(nexttry - return_value_time$4);
    if(sleeptime >= 1)
    {
      log_log(4, "no available LDAP server found, sleeping %d seconds", sleeptime);
      sleep((unsigned int)sleeptime);
    }

  }
}

// do_sasl_interact
// file myldap.c line 338
static signed int do_sasl_interact(struct ldap *ld, unsigned int flags, void *defaults, void *_interact)
{
  struct ldap_config *cfg = (struct ldap_config *)defaults;
  struct sasl_interact *interact = (struct sasl_interact *)_interact;
  for( ; !(interact->id == 0ul); interact = interact + 1l)
    switch(interact->id)
    {
      case (unsigned long int)0x4008:
      {
        if(!(cfg->sasl_realm == ((char *)NULL)))
        {
          log_log(7, "do_sasl_interact(): returning sasl_realm \"%s\"", cfg->sasl_realm);
          interact->result = (const void *)cfg->sasl_realm;
          unsigned long int return_value_strlen$1;
          return_value_strlen$1=strlen(cfg->sasl_realm);
          interact->len = (unsigned int)return_value_strlen$1;
        }

        else
          log_log(7, "do_sasl_interact(): were asked for sasl_realm but we don't have any");
        break;
      }
      case (unsigned long int)0x4002:
      {
        if(!(cfg->sasl_authcid == ((char *)NULL)))
        {
          log_log(7, "do_sasl_interact(): returning sasl_authcid \"%s\"", cfg->sasl_authcid);
          interact->result = (const void *)cfg->sasl_authcid;
          unsigned long int return_value_strlen$2;
          return_value_strlen$2=strlen(cfg->sasl_authcid);
          interact->len = (unsigned int)return_value_strlen$2;
        }

        else
          log_log(7, "do_sasl_interact(): were asked for sasl_authcid but we don't have any");
        break;
      }
      case (unsigned long int)0x4001:
      {
        if(!(cfg->sasl_authzid == ((char *)NULL)))
        {
          log_log(7, "do_sasl_interact(): returning sasl_authzid \"%s\"", cfg->sasl_authzid);
          interact->result = (const void *)cfg->sasl_authzid;
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(cfg->sasl_authzid);
          interact->len = (unsigned int)return_value_strlen$3;
        }

        else
          log_log(7, "do_sasl_interact(): were asked for sasl_authzid but we don't have any");
        break;
      }
      case (unsigned long int)0x4004:
        if(!(cfg->bindpw == ((char *)NULL)))
        {
          log_log(7, "do_sasl_interact(): returning bindpw \"***\"");
          interact->result = (const void *)cfg->bindpw;
          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(cfg->bindpw);
          interact->len = (unsigned int)return_value_strlen$4;
        }

        else
          log_log(7, "do_sasl_interact(): were asked for bindpw but we don't have any");
    }
  return 0x00;
}

// do_set_options
// file myldap.c line 805
static signed int do_set_options(struct ldap_session *session)
{
  signed int rc;
  struct timeval tv;
  signed int i;
  log_log(7, "ldap_set_rebind_proc()");
  rc=ldap_set_rebind_proc(session->ld, do_rebind, (void *)session);
  _Bool tmp_if_expr$2;
  signed int return_value_strncasecmp$1;
  if(!(rc == 0x00))
  {
    myldap_err(3, session->ld, rc, "ldap_set_rebind_proc() failed");
    return rc;
  }

  else
  {
    log_log(7, "ldap_set_option(LDAP_OPT_PROTOCOL_VERSION,%d)", nslcd_cfg->ldap_version);
    rc=ldap_set_option(session->ld, 0x0011, (const void *)&nslcd_cfg->ldap_version);
    if(!(rc == 0x00))
    {
      myldap_err(3, session->ld, rc, "ldap_set_option(LDAP_OPT_PROTOCOL_VERSION) failed");
      return rc;
    }

    else
    {
      log_log(7, "ldap_set_option(LDAP_OPT_DEREF,%d)", nslcd_cfg->deref);
      rc=ldap_set_option(session->ld, 0x0002, (const void *)&nslcd_cfg->deref);
      if(!(rc == 0x00))
      {
        myldap_err(3, session->ld, rc, "ldap_set_option(LDAP_OPT_DEREF) failed");
        return rc;
      }

      else
      {
        log_log(7, "ldap_set_option(LDAP_OPT_TIMELIMIT,%d)", nslcd_cfg->timelimit);
        rc=ldap_set_option(session->ld, 0x0004, (const void *)&nslcd_cfg->timelimit);
        if(!(rc == 0x00))
        {
          myldap_err(3, session->ld, rc, "ldap_set_option(LDAP_OPT_TIMELIMIT) failed");
          return rc;
        }

        else
        {
          tv.tv_sec = (signed long int)nslcd_cfg->bind_timelimit;
          tv.tv_usec = (signed long int)0;
          log_log(7, "ldap_set_option(LDAP_OPT_TIMEOUT,%d)", nslcd_cfg->timelimit);
          rc=ldap_set_option(session->ld, 0x5002, (const void *)&tv);
          if(!(rc == 0x00))
          {
            myldap_err(3, session->ld, rc, "ldap_set_option(LDAP_OPT_TIMEOUT) failed");
            return rc;
          }

          else
          {
            log_log(7, "ldap_set_option(LDAP_OPT_NETWORK_TIMEOUT,%d)", nslcd_cfg->timelimit);
            rc=ldap_set_option(session->ld, 0x5005, (const void *)&tv);
            if(!(rc == 0x00))
            {
              myldap_err(3, session->ld, rc, "ldap_set_option(LDAP_OPT_NETWORK_TIMEOUT) failed");
              return rc;
            }

            else
            {
              log_log(7, "ldap_set_option(LDAP_OPT_REFERRALS,%s)", nslcd_cfg->referrals != 0 ? "LDAP_OPT_ON" : "LDAP_OPT_OFF");
              rc=ldap_set_option(session->ld, 0x0008, nslcd_cfg->referrals != 0 ? (void *)&ber_pvt_opt_on : (void *)0);
              if(!(rc == 0x00))
              {
                myldap_err(3, session->ld, rc, "ldap_set_option(LDAP_OPT_REFERRALS) failed");
                return rc;
              }

              else
              {
                log_log(7, "ldap_set_option(LDAP_OPT_RESTART,LDAP_OPT_ON)");
                rc=ldap_set_option(session->ld, 0x0009, (void *)&ber_pvt_opt_on);
                if(!(rc == 0x00))
                {
                  myldap_err(3, session->ld, rc, "ldap_set_option(LDAP_OPT_RESTART) failed");
                  return rc;
                }

                else
                {
                  static struct ldap_conncb cb;
                  cb.lc_add = connect_cb;
                  cb.lc_del = disconnect_cb;
                  cb.lc_arg = (void *)0;
                  rc=ldap_set_option(session->ld, 0x5011, (void *)&cb);
                  if(!(rc == 0x00))
                  {
                    myldap_err(3, session->ld, rc, "ldap_set_option(LDAP_OPT_CONNECT_CB) failed");
                    return rc;
                  }

                  else
                  {
                    if((signed int)nslcd_cfg->ssl == SSL_LDAPS)
                      tmp_if_expr$2 = (_Bool)1;

                    else
                    {
                      return_value_strncasecmp$1=strncasecmp(nslcd_cfg->uris[(signed long int)session->current_uri].uri, "ldaps://", (unsigned long int)8);
                      tmp_if_expr$2 = return_value_strncasecmp$1 == 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr$2)
                    {
                      i = 1;
                      log_log(7, "ldap_set_option(LDAP_OPT_X_TLS,LDAP_OPT_X_TLS_HARD)");
                      rc=ldap_set_option(session->ld, 0x6000, (const void *)&i);
                      if(rc == 0x00)
                        goto __CPROVER_DUMP_L12;

                      myldap_err(3, session->ld, rc, "ldap_set_option(LDAP_OPT_X_TLS) failed");
                      return rc;
                    }

                    else
                    {

                    __CPROVER_DUMP_L12:
                      ;
                      if(nslcd_cfg->sasl_canonicalize >= 0)
                      {
                        log_log(7, "ldap_set_option(LDAP_OPT_X_SASL_NOCANON,%s)", nslcd_cfg->sasl_canonicalize != 0 ? "LDAP_OPT_OFF" : "LDAP_OPT_ON");
                        rc=ldap_set_option(session->ld, 0x610b, nslcd_cfg->sasl_canonicalize != 0 ? (void *)0 : (void *)&ber_pvt_opt_on);
                        if(rc == 0x00)
                          goto __CPROVER_DUMP_L13;

                        myldap_err(3, session->ld, rc, "ldap_set_option(LDAP_OPT_X_SASL_NOCANON) failed");
                        return rc;
                      }

                      else
                      {

                      __CPROVER_DUMP_L13:
                        ;
                        return 0x00;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// do_try_search
// file myldap.c line 1101
static signed int do_try_search(struct myldap_search *search)
{
  signed int ctrlidx = 0;
  signed int rc;
  struct ldapcontrol *serverctrls[3l];
  signed int i;
  struct LDAPDerefSpec ds[2l];
  char *deref_attrs[2l];
  signed int msgid;
  rc=do_open(search->session);
  signed int return_value_strcasecmp$1;
  struct ldapcontrol **tmp_if_expr$3;
  if(!(rc == 0x00))
    return rc;

  else
    if(nslcd_cfg->pagesize >= 1)
    {
      if(search->scope == 0x0000)
        goto __CPROVER_DUMP_L3;

      rc=ldap_create_page_control(search->session->ld, nslcd_cfg->pagesize, search->cookie, 0, &serverctrls[(signed long int)ctrlidx]);
      if(rc == 0x00)
      {
        ctrlidx = ctrlidx + 1;
        goto __CPROVER_DUMP_L3;
      }

      myldap_err(4, search->session->ld, rc, "ldap_create_page_control() failed");
      serverctrls[(signed long int)ctrlidx] = (struct ldapcontrol *)(void *)0;
      if(search->cookie == ((struct berval *)NULL))
        goto __CPROVER_DUMP_L3;

      return rc;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      i = 0;
      for( ; !(search->attrs[(signed long int)i] == ((char *)NULL)); i = i + 1)
      {
        return_value_strcasecmp$1=strcasecmp(search->attrs[(signed long int)i], attmap_group_member);
        if(return_value_strcasecmp$1 == 0)
        {
          deref_attrs[(signed long int)0] = (char *)(void *)attmap_passwd_uid;
          deref_attrs[(signed long int)1] = (char *)(void *)0;
          ds[(signed long int)0].derefAttr = (char *)(void *)attmap_group_member;
          ds[(signed long int)0].attributes = deref_attrs;
          ds[(signed long int)1].derefAttr = (char *)(void *)0;
          ds[(signed long int)1].attributes = (char **)(void *)0;
          rc=ldap_create_deref_control(search->session->ld, ds, 0, &serverctrls[(signed long int)ctrlidx]);
          if(rc == 0x00)
            ctrlidx = ctrlidx + 1;

          else
          {
            myldap_err(4, search->session->ld, rc, "ldap_create_deref_control() failed");
            serverctrls[(signed long int)ctrlidx] = (struct ldapcontrol *)(void *)0;
          }
        }

      }
      serverctrls[(signed long int)ctrlidx] = (struct ldapcontrol *)(void *)0;
      if(ctrlidx >= 1)
      {
        rc = 0x00;
        signed int return_value_ldap_set_option$2;
        return_value_ldap_set_option$2=ldap_set_option(search->session->ld, 0x0031, (const void *)&rc);
        if(!(return_value_ldap_set_option$2 == 0x00))
          log_log(4, "failed to clear the error flag");

      }

      if(serverctrls[0l] == ((struct ldapcontrol *)NULL))
        tmp_if_expr$3 = (struct ldapcontrol **)(void *)0;

      else
        tmp_if_expr$3 = serverctrls;
      rc=ldap_search_ext(search->session->ld, search->base, search->scope, search->filter, (char **)search->attrs, 0, tmp_if_expr$3, (struct ldapcontrol **)(void *)0, (struct timeval *)(void *)0, 0, &msgid);
      ctrlidx = 0;
      for( ; !(serverctrls[(signed long int)ctrlidx] == ((struct ldapcontrol *)NULL)); ctrlidx = ctrlidx + 1)
        ldap_control_free(serverctrls[(signed long int)ctrlidx]);
      if(!(rc == 0x00))
      {
        myldap_err(4, search->session->ld, rc, "ldap_search_ext() failed");
        return rc;
      }

      else
      {
        time(&search->session->lastactivity);
        search->msgid = msgid;
        return 0x00;
      }
    }
}

// do_write_group
// file group.c line 229
static signed int do_write_group(struct tio_fileinfo *fp, struct myldap_entry *entry, const char **names, unsigned int *gids, signed int numgids, const char *passwd, const char **members, const char *reqname)
{
  signed int tmpint32;
  signed int tmp2int32;
  signed int tmp3int32;
  signed int i;
  signed int j;
  i = 0;
  _Bool tmp_if_expr$99;
  signed int tmp_if_expr$98;
  signed int return_value_strcasecmp$96;
  signed int return_value_strcmp$97;
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  signed int *return_value___errno_location$10;
  char *return_value_strerror$11;
  signed int *return_value___errno_location$12;
  char *return_value_strerror$13;
  signed int *return_value___errno_location$18;
  char *return_value_strerror$19;
  signed int *return_value___errno_location$20;
  char *return_value_strerror$21;
  signed int *return_value___errno_location$25;
  char *return_value_strerror$26;
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  signed int *return_value___errno_location$32;
  char *return_value_strerror$33;
  signed int *return_value___errno_location$34;
  char *return_value_strerror$35;
  signed int *return_value___errno_location$40;
  char *return_value_strerror$41;
  signed int *return_value___errno_location$42;
  char *return_value_strerror$43;
  signed int *return_value___errno_location$47;
  char *return_value_strerror$48;
  signed int *return_value___errno_location$49;
  char *return_value_strerror$50;
  signed int *return_value___errno_location$54;
  char *return_value_strerror$55;
  signed int *return_value___errno_location$56;
  char *return_value_strerror$57;
  signed int *return_value___errno_location$61;
  char *return_value_strerror$62;
  signed int *return_value___errno_location$63;
  char *return_value_strerror$64;
  signed int *return_value___errno_location$68;
  char *return_value_strerror$69;
  signed int *return_value___errno_location$70;
  char *return_value_strerror$71;
  signed int *return_value___errno_location$75;
  char *return_value_strerror$76;
  signed int *return_value___errno_location$77;
  char *return_value_strerror$78;
  signed int *return_value___errno_location$83;
  char *return_value_strerror$84;
  signed int *return_value___errno_location$85;
  char *return_value_strerror$86;
  signed int *return_value___errno_location$90;
  char *return_value_strerror$91;
  signed int *return_value___errno_location$92;
  char *return_value_strerror$93;
  for( ; !(names[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_isvalidname$100;
    return_value_isvalidname$100=isvalidname(names[(signed long int)i]);
    if(return_value_isvalidname$100 == 0)
    {
      const char *return_value_myldap_get_dn$1;
      return_value_myldap_get_dn$1=myldap_get_dn(entry);
      log_log(4, "%s: %s: denied by validnames option", return_value_myldap_get_dn$1, attmap_group_cn);
    }

    else
    {
      if(reqname == ((const char *)NULL))
        tmp_if_expr$99 = (_Bool)1;

      else
      {
        if(nslcd_cfg->ignorecase == 1)
        {
          return_value_strcasecmp$96=strcasecmp(reqname, names[(signed long int)i]);
          tmp_if_expr$98 = return_value_strcasecmp$96;
        }

        else
        {
          return_value_strcmp$97=strcmp(reqname, names[(signed long int)i]);
          tmp_if_expr$98 = return_value_strcmp$97;
        }
        tmp_if_expr$99 = tmp_if_expr$98 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$99)
      {
        j = 0;
        for( ; !(j >= numgids); j = j + 1)
        {
          unsigned int return_value_htonl$2;
          return_value_htonl$2=htonl((unsigned int)(signed int)1);
          tmpint32 = (signed int)return_value_htonl$2;
          signed int return_value_tio_write$8;
          return_value_tio_write$8=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$8 == 0))
          {
            signed int *return_value___errno_location$7;
            return_value___errno_location$7=__errno_location();
            if(*return_value___errno_location$7 == 32)
            {
              return_value___errno_location$3=__errno_location();
              return_value_strerror$4=strerror(*return_value___errno_location$3);
              log_log(7, "error writing to client: %s", return_value_strerror$4);
            }

            else
            {
              return_value___errno_location$5=__errno_location();
              return_value_strerror$6=strerror(*return_value___errno_location$5);
              log_log(4, "error writing to client: %s", return_value_strerror$6);
            }
            return -1;
          }

          if(names[(signed long int)i] == ((const char *)NULL))
          {
            unsigned int return_value_htonl$9;
            return_value_htonl$9=htonl((unsigned int)(signed int)0);
            tmpint32 = (signed int)return_value_htonl$9;
            signed int return_value_tio_write$15;
            return_value_tio_write$15=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$15 == 0))
            {
              signed int *return_value___errno_location$14;
              return_value___errno_location$14=__errno_location();
              if(*return_value___errno_location$14 == 32)
              {
                return_value___errno_location$10=__errno_location();
                return_value_strerror$11=strerror(*return_value___errno_location$10);
                log_log(7, "error writing to client: %s", return_value_strerror$11);
              }

              else
              {
                return_value___errno_location$12=__errno_location();
                return_value_strerror$13=strerror(*return_value___errno_location$12);
                log_log(4, "error writing to client: %s", return_value_strerror$13);
              }
              return -1;
            }

          }

          else
          {
            unsigned long int return_value_strlen$16;
            return_value_strlen$16=strlen(names[(signed long int)i]);
            unsigned int return_value_htonl$17;
            return_value_htonl$17=htonl((unsigned int)(signed int)return_value_strlen$16);
            tmpint32 = (signed int)return_value_htonl$17;
            signed int return_value_tio_write$23;
            return_value_tio_write$23=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$23 == 0))
            {
              signed int *return_value___errno_location$22;
              return_value___errno_location$22=__errno_location();
              if(*return_value___errno_location$22 == 32)
              {
                return_value___errno_location$18=__errno_location();
                return_value_strerror$19=strerror(*return_value___errno_location$18);
                log_log(7, "error writing to client: %s", return_value_strerror$19);
              }

              else
              {
                return_value___errno_location$20=__errno_location();
                return_value_strerror$21=strerror(*return_value___errno_location$20);
                log_log(4, "error writing to client: %s", return_value_strerror$21);
              }
              return -1;
            }

            unsigned int return_value_ntohl$24;
            return_value_ntohl$24=ntohl((unsigned int)tmpint32);
            tmpint32 = (signed int)return_value_ntohl$24;
            if(tmpint32 >= 1)
            {
              signed int return_value_tio_write$30;
              return_value_tio_write$30=tio_write(fp, (const void *)names[(signed long int)i], (unsigned long int)tmpint32);
              if(!(return_value_tio_write$30 == 0))
              {
                signed int *return_value___errno_location$29;
                return_value___errno_location$29=__errno_location();
                if(*return_value___errno_location$29 == 32)
                {
                  return_value___errno_location$25=__errno_location();
                  return_value_strerror$26=strerror(*return_value___errno_location$25);
                  log_log(7, "error writing to client: %s", return_value_strerror$26);
                }

                else
                {
                  return_value___errno_location$27=__errno_location();
                  return_value_strerror$28=strerror(*return_value___errno_location$27);
                  log_log(4, "error writing to client: %s", return_value_strerror$28);
                }
                return -1;
              }

            }

          }
          if(passwd == ((const char *)NULL))
          {
            unsigned int return_value_htonl$31;
            return_value_htonl$31=htonl((unsigned int)(signed int)0);
            tmpint32 = (signed int)return_value_htonl$31;
            signed int return_value_tio_write$37;
            return_value_tio_write$37=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$37 == 0))
            {
              signed int *return_value___errno_location$36;
              return_value___errno_location$36=__errno_location();
              if(*return_value___errno_location$36 == 32)
              {
                return_value___errno_location$32=__errno_location();
                return_value_strerror$33=strerror(*return_value___errno_location$32);
                log_log(7, "error writing to client: %s", return_value_strerror$33);
              }

              else
              {
                return_value___errno_location$34=__errno_location();
                return_value_strerror$35=strerror(*return_value___errno_location$34);
                log_log(4, "error writing to client: %s", return_value_strerror$35);
              }
              return -1;
            }

          }

          else
          {
            unsigned long int return_value_strlen$38;
            return_value_strlen$38=strlen(passwd);
            unsigned int return_value_htonl$39;
            return_value_htonl$39=htonl((unsigned int)(signed int)return_value_strlen$38);
            tmpint32 = (signed int)return_value_htonl$39;
            signed int return_value_tio_write$45;
            return_value_tio_write$45=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$45 == 0))
            {
              signed int *return_value___errno_location$44;
              return_value___errno_location$44=__errno_location();
              if(*return_value___errno_location$44 == 32)
              {
                return_value___errno_location$40=__errno_location();
                return_value_strerror$41=strerror(*return_value___errno_location$40);
                log_log(7, "error writing to client: %s", return_value_strerror$41);
              }

              else
              {
                return_value___errno_location$42=__errno_location();
                return_value_strerror$43=strerror(*return_value___errno_location$42);
                log_log(4, "error writing to client: %s", return_value_strerror$43);
              }
              return -1;
            }

            unsigned int return_value_ntohl$46;
            return_value_ntohl$46=ntohl((unsigned int)tmpint32);
            tmpint32 = (signed int)return_value_ntohl$46;
            if(tmpint32 >= 1)
            {
              signed int return_value_tio_write$52;
              return_value_tio_write$52=tio_write(fp, (const void *)passwd, (unsigned long int)tmpint32);
              if(!(return_value_tio_write$52 == 0))
              {
                signed int *return_value___errno_location$51;
                return_value___errno_location$51=__errno_location();
                if(*return_value___errno_location$51 == 32)
                {
                  return_value___errno_location$47=__errno_location();
                  return_value_strerror$48=strerror(*return_value___errno_location$47);
                  log_log(7, "error writing to client: %s", return_value_strerror$48);
                }

                else
                {
                  return_value___errno_location$49=__errno_location();
                  return_value_strerror$50=strerror(*return_value___errno_location$49);
                  log_log(4, "error writing to client: %s", return_value_strerror$50);
                }
                return -1;
              }

            }

          }
          unsigned int return_value_htonl$53;
          return_value_htonl$53=htonl((unsigned int)(signed int)gids[(signed long int)j]);
          tmpint32 = (signed int)return_value_htonl$53;
          signed int return_value_tio_write$59;
          return_value_tio_write$59=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$59 == 0))
          {
            signed int *return_value___errno_location$58;
            return_value___errno_location$58=__errno_location();
            if(*return_value___errno_location$58 == 32)
            {
              return_value___errno_location$54=__errno_location();
              return_value_strerror$55=strerror(*return_value___errno_location$54);
              log_log(7, "error writing to client: %s", return_value_strerror$55);
            }

            else
            {
              return_value___errno_location$56=__errno_location();
              return_value_strerror$57=strerror(*return_value___errno_location$56);
              log_log(4, "error writing to client: %s", return_value_strerror$57);
            }
            return -1;
          }

          if(members == ((const char **)NULL))
          {
            unsigned int return_value_htonl$60;
            return_value_htonl$60=htonl((unsigned int)(signed int)0);
            tmpint32 = (signed int)return_value_htonl$60;
            signed int return_value_tio_write$66;
            return_value_tio_write$66=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$66 == 0))
            {
              signed int *return_value___errno_location$65;
              return_value___errno_location$65=__errno_location();
              if(*return_value___errno_location$65 == 32)
              {
                return_value___errno_location$61=__errno_location();
                return_value_strerror$62=strerror(*return_value___errno_location$61);
                log_log(7, "error writing to client: %s", return_value_strerror$62);
              }

              else
              {
                return_value___errno_location$63=__errno_location();
                return_value_strerror$64=strerror(*return_value___errno_location$63);
                log_log(4, "error writing to client: %s", return_value_strerror$64);
              }
              return -1;
            }

          }

          else
          {
            tmp3int32 = 0;
            for( ; !(members[(signed long int)tmp3int32] == ((const char *)NULL)); tmp3int32 = tmp3int32 + 1)
              ;
            unsigned int return_value_htonl$67;
            return_value_htonl$67=htonl((unsigned int)(signed int)tmp3int32);
            tmpint32 = (signed int)return_value_htonl$67;
            signed int return_value_tio_write$73;
            return_value_tio_write$73=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$73 == 0))
            {
              signed int *return_value___errno_location$72;
              return_value___errno_location$72=__errno_location();
              if(*return_value___errno_location$72 == 32)
              {
                return_value___errno_location$68=__errno_location();
                return_value_strerror$69=strerror(*return_value___errno_location$68);
                log_log(7, "error writing to client: %s", return_value_strerror$69);
              }

              else
              {
                return_value___errno_location$70=__errno_location();
                return_value_strerror$71=strerror(*return_value___errno_location$70);
                log_log(4, "error writing to client: %s", return_value_strerror$71);
              }
              return -1;
            }

            tmp2int32 = 0;
            for( ; !(tmp2int32 >= tmp3int32); tmp2int32 = tmp2int32 + 1)
              if(members[(signed long int)tmp2int32] == ((const char *)NULL))
              {
                unsigned int return_value_htonl$74;
                return_value_htonl$74=htonl((unsigned int)(signed int)0);
                tmpint32 = (signed int)return_value_htonl$74;
                signed int return_value_tio_write$80;
                return_value_tio_write$80=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                if(!(return_value_tio_write$80 == 0))
                {
                  signed int *return_value___errno_location$79;
                  return_value___errno_location$79=__errno_location();
                  if(*return_value___errno_location$79 == 32)
                  {
                    return_value___errno_location$75=__errno_location();
                    return_value_strerror$76=strerror(*return_value___errno_location$75);
                    log_log(7, "error writing to client: %s", return_value_strerror$76);
                  }

                  else
                  {
                    return_value___errno_location$77=__errno_location();
                    return_value_strerror$78=strerror(*return_value___errno_location$77);
                    log_log(4, "error writing to client: %s", return_value_strerror$78);
                  }
                  return -1;
                }

              }

              else
              {
                unsigned long int return_value_strlen$81;
                return_value_strlen$81=strlen(members[(signed long int)tmp2int32]);
                unsigned int return_value_htonl$82;
                return_value_htonl$82=htonl((unsigned int)(signed int)return_value_strlen$81);
                tmpint32 = (signed int)return_value_htonl$82;
                signed int return_value_tio_write$88;
                return_value_tio_write$88=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                if(!(return_value_tio_write$88 == 0))
                {
                  signed int *return_value___errno_location$87;
                  return_value___errno_location$87=__errno_location();
                  if(*return_value___errno_location$87 == 32)
                  {
                    return_value___errno_location$83=__errno_location();
                    return_value_strerror$84=strerror(*return_value___errno_location$83);
                    log_log(7, "error writing to client: %s", return_value_strerror$84);
                  }

                  else
                  {
                    return_value___errno_location$85=__errno_location();
                    return_value_strerror$86=strerror(*return_value___errno_location$85);
                    log_log(4, "error writing to client: %s", return_value_strerror$86);
                  }
                  return -1;
                }

                unsigned int return_value_ntohl$89;
                return_value_ntohl$89=ntohl((unsigned int)tmpint32);
                tmpint32 = (signed int)return_value_ntohl$89;
                if(tmpint32 >= 1)
                {
                  signed int return_value_tio_write$95;
                  return_value_tio_write$95=tio_write(fp, (const void *)members[(signed long int)tmp2int32], (unsigned long int)tmpint32);
                  if(!(return_value_tio_write$95 == 0))
                  {
                    signed int *return_value___errno_location$94;
                    return_value___errno_location$94=__errno_location();
                    if(*return_value___errno_location$94 == 32)
                    {
                      return_value___errno_location$90=__errno_location();
                      return_value_strerror$91=strerror(*return_value___errno_location$90);
                      log_log(7, "error writing to client: %s", return_value_strerror$91);
                    }

                    else
                    {
                      return_value___errno_location$92=__errno_location();
                      return_value_strerror$93=strerror(*return_value___errno_location$92);
                      log_log(4, "error writing to client: %s", return_value_strerror$93);
                    }
                    return -1;
                  }

                }

              }
          }
        }
      }

    }
  }
  return 0;
}

// empty_expander
// file expr.c line 70
static const char * empty_expander(const char *name, void *expander_arg)
{
  return "";
}

// entry_expand
// file attmap.c line 245
static const char * entry_expand(const char *name, void *expander_attr)
{
  struct myldap_entry *entry = (struct myldap_entry *)expander_attr;
  const char **values;
  signed int return_value_strcasecmp$2;
  return_value_strcasecmp$2=strcasecmp(name, "dn");
  const char *return_value_myldap_get_dn$1;
  if(return_value_strcasecmp$2 == 0)
  {
    return_value_myldap_get_dn$1=myldap_get_dn(entry);
    return return_value_myldap_get_dn$1;
  }

  else
  {
    values=myldap_get_values(entry, name);
    if(values == ((const char **)NULL))
      return "";

    else
    {
      if(!(*values == ((const char *)NULL)))
      {
        if(!(values[1l] == ((const char *)NULL)))
        {
          const char *return_value_myldap_get_dn$3;
          return_value_myldap_get_dn$3=myldap_get_dn(entry);
          log_log(4, "%s: %s: multiple values", return_value_myldap_get_dn$3, name);
        }

      }

      return values[(signed long int)0];
    }
  }
}

// entry_has_valid_uid
// file passwd.c line 171
static signed int entry_has_valid_uid(struct myldap_entry *entry)
{
  signed int i;
  const char **values;
  char *tmp;
  unsigned int uid;
  _Bool tmp_if_expr$2;
  unsigned long int return_value_binsid2id$3;
  _Bool tmp_if_expr$11;
  signed int *return_value___errno_location$8;
  _Bool tmp_if_expr$10;
  char *return_value_strchr$9;
  if(nslcd_cfg->nss_min_uid == 0u)
    return 1;

  else
  {
    values=myldap_get_values_len(entry, attmap_passwd_uidNumber);
    if(values == ((const char **)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = values[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      const char *return_value_myldap_get_dn$1;
      return_value_myldap_get_dn$1=myldap_get_dn(entry);
      log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_passwd_uidNumber);
      return 0;
    }

    i = 0;
    for( ; !(values[(signed long int)i] == ((const char *)NULL)); i = i + 1)
    {
      if(!(uidSid == ((char *)NULL)))
      {
        return_value_binsid2id$3=binsid2id(values[(signed long int)i]);
        uid = (unsigned int)return_value_binsid2id$3;
      }

      else
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 0;
        unsigned int return_value_strtoui$5;
        return_value_strtoui$5=strtoui(values[(signed long int)i], &tmp, 10);
        uid = (unsigned int)return_value_strtoui$5;
        if((signed int)*values[(signed long int)i] == 0)
          tmp_if_expr$11 = (_Bool)1;

        else
          tmp_if_expr$11 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$11)
        {
          const char *return_value_myldap_get_dn$6;
          return_value_myldap_get_dn$6=myldap_get_dn(entry);
          log_log(4, "%s: %s: non-numeric", return_value_myldap_get_dn$6, attmap_passwd_uidNumber);
          goto __CPROVER_DUMP_L15;
        }

        else
        {
          return_value___errno_location$8=__errno_location();
          if(!(*return_value___errno_location$8 == 0))
            tmp_if_expr$10 = (_Bool)1;

          else
          {
            return_value_strchr$9=strchr(values[(signed long int)i], 45);
            tmp_if_expr$10 = return_value_strchr$9 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$10)
          {
            const char *return_value_myldap_get_dn$7;
            return_value_myldap_get_dn$7=myldap_get_dn(entry);
            log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$7, attmap_passwd_uidNumber);
            goto __CPROVER_DUMP_L15;
          }

        }
      }
      if(uid >= nslcd_cfg->nss_min_uid)
        return 1;


    __CPROVER_DUMP_L15:
      ;
    }
    return 0;
  }
}

// ether_init
// file common.h line 207
void ether_init(void)
{
  signed int i;
  if(ether_bases[0l] == ((const char *)NULL))
  {
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      ether_bases[(signed long int)i] = nslcd_cfg->bases[(signed long int)i];
  }

  if(ether_scope == -1)
    ether_scope = nslcd_cfg->scope;

  ether_attrs[(signed long int)0] = attmap_ether_cn;
  ether_attrs[(signed long int)1] = attmap_ether_macAddress;
  ether_attrs[(signed long int)2] = (const char *)(void *)0;
}

// exec_invalidate
// file invalidator.c line 65
static void exec_invalidate(const char *db)
{
  signed int cpid;
  signed int i;
  signed int status;
  char *argv[4l];
  char cmdline[80l];
  char *newenviron[1l] = { (char *)(void *)0 };
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(db, "nfsidmap");
  if(return_value_strcmp$1 == 0)
  {
    argv[(signed long int)0] = "nfsidmap";
    argv[(signed long int)1] = "-c";
    argv[(signed long int)2] = (char *)(void *)0;
  }

  else
  {
    argv[(signed long int)0] = "nscd";
    argv[(signed long int)1] = "-i";
    argv[(signed long int)2] = (char *)db;
    argv[(signed long int)3] = (char *)(void *)0;
  }
  char *tmp_if_expr$2;
  if(!(argv[2l] == ((char *)NULL)))
    tmp_if_expr$2 = argv[(signed long int)2];

  else
    tmp_if_expr$2 = "";
  signed int return_value_mysnprintf$3;
  return_value_mysnprintf$3=mysnprintf(cmdline, (unsigned long int)80, "%s %s%s%s", argv[(signed long int)0], argv[(signed long int)1], argv[(signed long int)2] != (char *)(void *)0 ? " " : "", tmp_if_expr$2);
  signed long int return_value_sysconf$4;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  _Bool tmp_if_expr$8;
  signed int *return_value___errno_location$7;
  signed int *return_value___errno_location$10;
  char *return_value_strerror$11;
  if(!(return_value_mysnprintf$3 == 0))
    log_log(3, "exec_invalidate(): cmdline buffer too small");

  else
  {
    log_log(7, "invalidator: %s", (const void *)cmdline);
    cpid=fork();
    if(!(cpid == 0))
    {
      if(cpid == -1)
        goto __CPROVER_DUMP_L9;

    }

    else
    {
      return_value_sysconf$4=sysconf(4);
      i = (signed int)(return_value_sysconf$4 - (signed long int)1);
      if(!(i >= 0))
        i = 32;

      for( ; i >= 0; i = i - 1)
        close(i);
      execvpe(argv[(signed long int)0], argv, newenviron);
      _exit(1);
      goto __CPROVER_DUMP_L19;

    __CPROVER_DUMP_L9:
      ;
      return_value___errno_location$5=__errno_location();
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      log_log(3, "invalidator: fork() failed: %s", return_value_strerror$6);
      goto __CPROVER_DUMP_L19;
    }
    do
    {
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      *return_value___errno_location$9 = 0;
      i=waitpid(cpid, &status, 0);
      if(!(i >= 0))
      {
        return_value___errno_location$7=__errno_location();
        tmp_if_expr$8 = *return_value___errno_location$7 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$8 = (_Bool)0;
    }
    while(tmp_if_expr$8);
    /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous$18
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
    ;
    if(!(i >= 0))
    {
      return_value___errno_location$10=__errno_location();
      return_value_strerror$11=strerror(*return_value___errno_location$10);
      log_log(3, "invalidator: waitpid(%d) failed: %s", (signed int)cpid, return_value_strerror$11);
    }

    else
      if((0x7f & status) == 0)
      {
        i = (((union anonymous$18){ .__in=status }).__i & 0xff00) >> 8;
        if(i == 0)
          log_log(7, "invalidator: %s (pid %d) success", (const void *)cmdline, (signed int)cpid);

        else
          log_log(7, "invalidator: %s (pid %d) failed (%d)", (const void *)cmdline, (signed int)cpid, i);
      }

      else
        if((signed int)((127 & (signed char)status) + 1) >> 1 >= 1)
        {
          i = ((union anonymous$18){ .__in=status }).__i & 0x7f;
          const char *return_value_signame$12;
          return_value_signame$12=signame(i);
          log_log(3, "invalidator: %s (pid %d) killed by %s (%d)", (const void *)cmdline, (signed int)cpid, return_value_signame$12, i);
        }

        else
          log_log(3, "invalidator: %s (pid %d) had unknown failure", (const void *)cmdline, (signed int)cpid);
    goto __CPROVER_DUMP_L19;
  }

__CPROVER_DUMP_L19:
  ;
}

// exithandler
// file nslcd.c line 201
static void exithandler(void)
{
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(nslcd_serversocket >= 0)
  {
    signed int return_value_close$3;
    return_value_close$3=close(nslcd_serversocket);
    if(!(return_value_close$3 == 0))
    {
      return_value___errno_location$1=__errno_location();
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_log(4, "problem closing server socket (ignored): %s", return_value_strerror$2);
    }

  }

  signed int return_value_unlink$6;
  return_value_unlink$6=unlink("/var/run/nslcd/socket");
  if(!(return_value_unlink$6 >= 0))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    log_log(7, "unlink() of /var/run/nslcd/socket failed (ignored): %s", return_value_strerror$5);
  }

  signed int return_value_unlink$9;
  return_value_unlink$9=unlink("/var/run/nslcd/nslcd.pid");
  if(!(return_value_unlink$9 >= 0))
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(*return_value___errno_location$7);
    log_log(7, "unlink() of /var/run/nslcd/nslcd.pid failed (ignored): %s", return_value_strerror$8);
  }

  log_log(6, "version %s bailing out", (const void *)"0.9.6");
}

// expr_parse
// file ../common/expr.h line 34
const char * expr_parse(const char *str, char *buffer, unsigned long int buflen, const char * (*expander)(const char *, void *), void *expander_arg)
{
  signed int i = 0;
  const char *return_value_parse_expression$1;
  return_value_parse_expression$1=parse_expression(str, &i, 0, buffer, buflen, expander, expander_arg);
  return return_value_parse_expression$1;
}

// expr_vars
// file ../common/expr.h line 39
struct set * expr_vars(const char *str, struct set *set)
{
  char varname[30l];
  signed int i = 0;
  if(set == ((struct set *)NULL))
    set=set_new();

  const char *return_value_parse_name$1;
  if(set == ((struct set *)NULL))
    return (struct set *)(void *)0;

  else
  {
    while(!((signed int)str[(signed long int)i] == 0))
      switch((signed int)str[(signed long int)i])
      {
        case 36:
        {
          i = i + 1;
          if((signed int)str[(signed long int)i] == 123)
            i = i + 1;

          return_value_parse_name$1=parse_name(str, &i, varname, sizeof(char [30l]) /*30ul*/ );
          if(!(return_value_parse_name$1 == ((const char *)NULL)))
            set_add(set, varname);

          break;
        }
        case 92:
          i = i + 1;
        default:
          i = i + 1;
      }
    return set;
  }
}

// filter_get_var
// file attmap.h line 78
const char ** filter_get_var(enum ldap_map_selector map)
{
  switch((signed int)map)
  {
    case LM_ALIASES:
      return &alias_filter;
    case LM_ETHERS:
      return &ether_filter;
    case LM_GROUP:
      return &group_filter;
    case LM_HOSTS:
      return &host_filter;
    case LM_NETGROUP:
      return &netgroup_filter;
    case LM_NETWORKS:
      return &network_filter;
    case LM_PASSWD:
      return &passwd_filter;
    case LM_PROTOCOLS:
      return &protocol_filter;
    case LM_RPC:
      return &rpc_filter;
    case LM_SERVICES:
      return &service_filter;
    case LM_SHADOW:
      return &shadow_filter;
    case LM_NFSIDMAP:

    case LM_NONE:

    default:
      return (const char **)(void *)0;
  }
}

// find_db
// file nsswitch.c line 74
static const char * find_db(const char *line, const char *db)
{
  signed int i;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(db);
  i = (signed int)return_value_strlen$1;
  signed int return_value_strncmp$2;
  return_value_strncmp$2=strncmp(line, db, (unsigned long int)i);
  const unsigned short int **return_value___ctype_b_loc$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  if(!(return_value_strncmp$2 == 0))
    return (const char *)(void *)0;

  else
  {
    do
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)line[(signed long int)i]]) == 0)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    if(!((signed int)line[(signed long int)i] == 58))
      return (const char *)(void *)0;

    else
    {
      i = i + 1;
      do
      {
        return_value___ctype_b_loc$4=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)line[(signed long int)i]]) == 0)
          break;

        i = i + 1;
      }
      while((_Bool)1);
      return line + (signed long int)i;
    }
  }
}

// find_rdn_value
// file myldap.c line 1998
static const char * find_rdn_value(char **exploded_rdn, const char *attr)
{
  signed int i;
  signed int j;
  signed int l;
  const unsigned short int **return_value___ctype_b_loc$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  if(exploded_rdn == ((char **)NULL))
    return (const char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(attr);
    l = (signed int)return_value_strlen$1;
    i = 0;
    for( ; !(exploded_rdn[(signed long int)i] == ((char *)NULL)); i = i + 1)
    {
      signed int return_value_strncasecmp$2;
      return_value_strncasecmp$2=strncasecmp(exploded_rdn[(signed long int)i], attr, (unsigned long int)l);
      if(return_value_strncasecmp$2 == 0)
      {
        j = l;
        do
        {
          return_value___ctype_b_loc$3=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)exploded_rdn[(signed long int)i][(signed long int)j]]) == 0)
            break;

          j = j + 1;
        }
        while((_Bool)1);
        if((signed int)exploded_rdn[(signed long int)i][(signed long int)j] == 61)
        {
          j = j + 1;
          do
          {
            return_value___ctype_b_loc$4=__ctype_b_loc();
            if((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)exploded_rdn[(signed long int)i][(signed long int)j]]) == 0)
              break;

            j = j + 1;
          }
          while((_Bool)1);
          if(!((signed int)exploded_rdn[(signed long int)i][(signed long int)j] == 0))
            return exploded_rdn[(signed long int)i] + (signed long int)j;

        }

      }

    }
    return (const char *)(void *)0;
  }
}

// get_base_from_rootdse
// file cfg.c line 1075
static char * get_base_from_rootdse(void)
{
  struct ldap_session *session;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *attrs[2l] = { "+", (const char *)(void *)0 };
  signed int i;
  signed int rc;
  const char **values;
  char *base = (char *)(void *)0;
  session=myldap_create_session();
  /* assertion session != ((void *)0) */
  assert(session != (struct ldap_session *)(void *)0);
  search=myldap_search(session, "", (signed int)0x0000, "(objectClass=*)", attrs, (signed int *)(void *)0);
  if(search == ((struct myldap_search *)NULL))
  {
    myldap_session_close(session);
    return (char *)(void *)0;
  }

  else
  {
    i = 0;
    do
    {
      entry=myldap_get_entry(search, &rc);
      if(entry == ((struct myldap_entry *)NULL))
        break;

      values=myldap_get_values(entry, "defaultNamingContext");
      if(!(values == ((const char **)NULL)))
      {
        if(!(*values == ((const char *)NULL)))
        {
          base=xstrdup(values[(signed long int)0]);
          log_log(7, "get_basedn_from_rootdse(): found attribute defaultNamingContext with value %s", values[(signed long int)0]);
          break;
        }

      }

      values=myldap_get_values(entry, "namingContexts");
      if(!(values == ((const char **)NULL)))
      {
        if(!(*values == ((const char *)NULL)))
        {
          base=xstrdup(values[(signed long int)0]);
          log_log(7, "get_basedn_from_rootdse(): found attribute namingContexts with value %s", values[(signed long int)0]);
          break;
        }

      }

      i = i + 1;
    }
    while((_Bool)1);
    myldap_session_close(session);
    return base;
  }
}

// get_boolean
// file cfg.c line 201
static signed int get_boolean(const char *filename, signed int lnr, const char *keyword, char **line)
{
  char token[32l];
  char *return_value_get_token$1;
  return_value_get_token$1=get_token(line, token, sizeof(char [32l]) /*32ul*/ );
  check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$1 != (char *)(void *)0));
  signed int return_value_parse_boolean$2;
  return_value_parse_boolean$2=parse_boolean(filename, lnr, token);
  return return_value_parse_boolean$2;
}

// get_eol
// file cfg.c line 163
static void get_eol(const char *filename, signed int lnr, const char *keyword, char **line)
{
  if(!(line == ((char **)NULL)))
  {
    if(!(*line == ((char *)NULL)))
    {
      if(!((signed int)*(*line) == 0))
      {
        log_log(3, "%s:%d: %s: too many arguments", filename, lnr, keyword);
        exit(1);
      }

    }

  }

}

// get_exploded_rdn
// file myldap.c line 2035
static char ** get_exploded_rdn(const char *dn)
{
  char **exploded_dn;
  char **exploded_rdn;
  _Bool tmp_if_expr$2;
  signed int return_value_strcasecmp$1;
  if(dn == ((const char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_strcasecmp$1=strcasecmp(dn, "unknown");
    tmp_if_expr$2 = return_value_strcasecmp$1 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$9;
  if(tmp_if_expr$2)
    return (char **)(void *)0;

  else
  {
    exploded_dn=ldap_explode_dn(dn, 0);
    if(exploded_dn == ((char **)NULL))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = exploded_dn[(signed long int)0] == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      log_log(4, "ldap_explode_dn(%s) returned NULL: %s", dn, return_value_strerror$4);
      return (char **)(void *)0;
    }

    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    *return_value___errno_location$6 = 0;
    exploded_rdn=ldap_explode_rdn(exploded_dn[(signed long int)0], 0);
    if(exploded_rdn == ((char **)NULL))
      tmp_if_expr$9 = (_Bool)1;

    else
      tmp_if_expr$9 = exploded_rdn[(signed long int)0] == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$9)
    {
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      char *return_value_strerror$8;
      return_value_strerror$8=strerror(*return_value___errno_location$7);
      log_log(4, "ldap_explode_rdn(%s) returned NULL: %s", exploded_dn[(signed long int)0], return_value_strerror$8);
      if(!(exploded_rdn == ((char **)NULL)))
        ldap_value_free(exploded_rdn);

      ldap_value_free(exploded_dn);
      return (char **)(void *)0;
    }

    ldap_value_free(exploded_dn);
    return exploded_rdn;
  }
}

// get_int
// file cfg.c line 173
static signed int get_int(const char *filename, signed int lnr, const char *keyword, char **line)
{
  char token[32l];
  char *return_value_get_token$1;
  return_value_get_token$1=get_token(line, token, sizeof(char [32l]) /*32ul*/ );
  check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$1 != (char *)(void *)0));
  signed int return_value_atoi$2;
  return_value_atoi$2=atoi(token);
  return return_value_atoi$2;
}

// get_linedup
// file cfg.c line 152
static char * get_linedup(const char *filename, signed int lnr, const char *keyword, char **line)
{
  char *var;
  _Bool tmp_if_expr$1;
  if(!(*line == ((char *)NULL)))
    tmp_if_expr$1 = (signed int)*(*line) != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  check_argumentcount(filename, lnr, keyword, (signed int)tmp_if_expr$1);
  var=xstrdup(*line);
  *line = (char *)(void *)0;
  return var;
}

// get_map
// file cfg.c line 567
static enum ldap_map_selector get_map(char **line)
{
  char token[32l];
  char *old;
  enum ldap_map_selector map;
  old = *line;
  char *return_value_get_token$1;
  return_value_get_token$1=get_token(line, token, sizeof(char [32l]) /*32ul*/ );
  if(return_value_get_token$1 == ((char *)NULL))
    return (enum ldap_map_selector)LM_NONE;

  else
  {
    map=parse_map(token);
    if((signed int)map == LM_NONE)
      *line = old;

    return map;
  }
}

// get_session
// file usermod.c line 107
static struct ldap_session * get_session(const char *binddn, const char *userdn, const char *password, signed int *rcp)
{
  struct ldap_session *session;
  char buffer[512l];
  session=myldap_create_session();
  _Bool tmp_if_expr$3;
  if(session == ((struct ldap_session *)NULL))
  {
    *rcp = 0x34;
    return (struct ldap_session *)(void *)0;
  }

  else
  {
    signed int return_value_myldap_set_credentials$1;
    return_value_myldap_set_credentials$1=myldap_set_credentials(session, binddn, password);
    if(!(return_value_myldap_set_credentials$1 == 0))
      return (struct ldap_session *)(void *)0;

    else
    {
      char *return_value_lookup_dn2uid$2;
      return_value_lookup_dn2uid$2=lookup_dn2uid(session, userdn, rcp, buffer, sizeof(char [512l]) /*512ul*/ );
      if(return_value_lookup_dn2uid$2 == ((char *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = *rcp != 0x00 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        myldap_session_close(session);
        return (struct ldap_session *)(void *)0;
      }

      else
        return session;
    }
  }
}

// get_shadow_properties
// file shadow.c line 192
void get_shadow_properties(struct myldap_entry *entry, signed long int *lastchangedate, signed long int *mindays, signed long int *maxdays, signed long int *warndays, signed long int *inactdays, signed long int *expiredate, unsigned long int *flag)
{
  char buffer[64l];
  const char *tmpvalue;
  char *tmp;
  tmpvalue=attmap_get_value(entry, attmap_shadow_shadowLastChange, buffer, sizeof(char [64l]) /*64ul*/ );
  if(tmpvalue == ((const char *)NULL))
    tmpvalue = "";

  const char *return_value_myldap_get_dn$1;
  return_value_myldap_get_dn$1=myldap_get_dn(entry);
  *lastchangedate=to_date(return_value_myldap_get_dn$1, tmpvalue, attmap_shadow_shadowLastChange);
  tmpvalue=attmap_get_value(entry, attmap_shadow_shadowMin, buffer, sizeof(char [64l]) /*64ul*/ );
  if(tmpvalue == ((const char *)NULL))
    tmpvalue = "";

  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = 0;
  *mindays=strtol(tmpvalue, &tmp, 10);
  _Bool tmp_if_expr$6;
  if((signed int)*tmpvalue == 0)
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location$5;
  if(tmp_if_expr$6)
  {
    const char *return_value_myldap_get_dn$3;
    return_value_myldap_get_dn$3=myldap_get_dn(entry);
    log_log(4, "%s: %s: non-numeric", return_value_myldap_get_dn$3, attmap_shadow_shadowMin);
    *mindays = (signed long int)-1;
  }

  else
  {
    return_value___errno_location$5=__errno_location();
    if(!(*return_value___errno_location$5 == 0))
    {
      const char *return_value_myldap_get_dn$4;
      return_value_myldap_get_dn$4=myldap_get_dn(entry);
      log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$4, attmap_shadow_shadowMin);
      *mindays = (signed long int)-1;
    }

  }
  tmpvalue=attmap_get_value(entry, attmap_shadow_shadowMax, buffer, sizeof(char [64l]) /*64ul*/ );
  if(tmpvalue == ((const char *)NULL))
    tmpvalue = "";

  signed int *return_value___errno_location$7;
  return_value___errno_location$7=__errno_location();
  *return_value___errno_location$7 = 0;
  *maxdays=strtol(tmpvalue, &tmp, 10);
  _Bool tmp_if_expr$11;
  if((signed int)*tmpvalue == 0)
    tmp_if_expr$11 = (_Bool)1;

  else
    tmp_if_expr$11 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location$10;
  if(tmp_if_expr$11)
  {
    const char *return_value_myldap_get_dn$8;
    return_value_myldap_get_dn$8=myldap_get_dn(entry);
    log_log(4, "%s: %s: non-numeric", return_value_myldap_get_dn$8, attmap_shadow_shadowMax);
    *maxdays = (signed long int)-1;
  }

  else
  {
    return_value___errno_location$10=__errno_location();
    if(!(*return_value___errno_location$10 == 0))
    {
      const char *return_value_myldap_get_dn$9;
      return_value_myldap_get_dn$9=myldap_get_dn(entry);
      log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$9, attmap_shadow_shadowMax);
      *maxdays = (signed long int)-1;
    }

  }
  tmpvalue=attmap_get_value(entry, attmap_shadow_shadowWarning, buffer, sizeof(char [64l]) /*64ul*/ );
  if(tmpvalue == ((const char *)NULL))
    tmpvalue = "";

  signed int *return_value___errno_location$12;
  return_value___errno_location$12=__errno_location();
  *return_value___errno_location$12 = 0;
  *warndays=strtol(tmpvalue, &tmp, 10);
  _Bool tmp_if_expr$16;
  if((signed int)*tmpvalue == 0)
    tmp_if_expr$16 = (_Bool)1;

  else
    tmp_if_expr$16 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location$15;
  if(tmp_if_expr$16)
  {
    const char *return_value_myldap_get_dn$13;
    return_value_myldap_get_dn$13=myldap_get_dn(entry);
    log_log(4, "%s: %s: non-numeric", return_value_myldap_get_dn$13, attmap_shadow_shadowWarning);
    *warndays = (signed long int)-1;
  }

  else
  {
    return_value___errno_location$15=__errno_location();
    if(!(*return_value___errno_location$15 == 0))
    {
      const char *return_value_myldap_get_dn$14;
      return_value_myldap_get_dn$14=myldap_get_dn(entry);
      log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$14, attmap_shadow_shadowWarning);
      *warndays = (signed long int)-1;
    }

  }
  tmpvalue=attmap_get_value(entry, attmap_shadow_shadowInactive, buffer, sizeof(char [64l]) /*64ul*/ );
  if(tmpvalue == ((const char *)NULL))
    tmpvalue = "";

  signed int *return_value___errno_location$17;
  return_value___errno_location$17=__errno_location();
  *return_value___errno_location$17 = 0;
  *inactdays=strtol(tmpvalue, &tmp, 10);
  _Bool tmp_if_expr$21;
  if((signed int)*tmpvalue == 0)
    tmp_if_expr$21 = (_Bool)1;

  else
    tmp_if_expr$21 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location$20;
  if(tmp_if_expr$21)
  {
    const char *return_value_myldap_get_dn$18;
    return_value_myldap_get_dn$18=myldap_get_dn(entry);
    log_log(4, "%s: %s: non-numeric", return_value_myldap_get_dn$18, attmap_shadow_shadowInactive);
    *inactdays = (signed long int)-1;
  }

  else
  {
    return_value___errno_location$20=__errno_location();
    if(!(*return_value___errno_location$20 == 0))
    {
      const char *return_value_myldap_get_dn$19;
      return_value_myldap_get_dn$19=myldap_get_dn(entry);
      log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$19, attmap_shadow_shadowInactive);
      *inactdays = (signed long int)-1;
    }

  }
  tmpvalue=attmap_get_value(entry, attmap_shadow_shadowExpire, buffer, sizeof(char [64l]) /*64ul*/ );
  if(tmpvalue == ((const char *)NULL))
    tmpvalue = "";

  signed int *return_value___errno_location$22;
  return_value___errno_location$22=__errno_location();
  *return_value___errno_location$22 = 0;
  *expiredate=strtol(tmpvalue, &tmp, 10);
  _Bool tmp_if_expr$26;
  if((signed int)*tmpvalue == 0)
    tmp_if_expr$26 = (_Bool)1;

  else
    tmp_if_expr$26 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location$25;
  if(tmp_if_expr$26)
  {
    const char *return_value_myldap_get_dn$23;
    return_value_myldap_get_dn$23=myldap_get_dn(entry);
    log_log(4, "%s: %s: non-numeric", return_value_myldap_get_dn$23, attmap_shadow_shadowExpire);
    *expiredate = (signed long int)-1;
  }

  else
  {
    return_value___errno_location$25=__errno_location();
    if(!(*return_value___errno_location$25 == 0))
    {
      const char *return_value_myldap_get_dn$24;
      return_value_myldap_get_dn$24=myldap_get_dn(entry);
      log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$24, attmap_shadow_shadowExpire);
      *expiredate = (signed long int)-1;
    }

  }
  tmpvalue=attmap_get_value(entry, attmap_shadow_shadowFlag, buffer, sizeof(char [64l]) /*64ul*/ );
  if(tmpvalue == ((const char *)NULL))
    tmpvalue = "";

  signed int *return_value___errno_location$27;
  return_value___errno_location$27=__errno_location();
  *return_value___errno_location$27 = 0;
  signed long int return_value_strtol$28;
  return_value_strtol$28=strtol(tmpvalue, &tmp, 10);
  *flag = (unsigned long int)return_value_strtol$28;
  _Bool tmp_if_expr$32;
  if((signed int)*tmpvalue == 0)
    tmp_if_expr$32 = (_Bool)1;

  else
    tmp_if_expr$32 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location$31;
  if(tmp_if_expr$32)
  {
    const char *return_value_myldap_get_dn$29;
    return_value_myldap_get_dn$29=myldap_get_dn(entry);
    log_log(4, "%s: %s: non-numeric", return_value_myldap_get_dn$29, attmap_shadow_shadowFlag);
    *flag = (unsigned long int)0;
  }

  else
  {
    return_value___errno_location$31=__errno_location();
    if(!(*return_value___errno_location$31 == 0))
    {
      const char *return_value_myldap_get_dn$30;
      return_value_myldap_get_dn$30=myldap_get_dn(entry);
      log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$30, attmap_shadow_shadowFlag);
      *flag = (unsigned long int)0;
    }

  }
  signed int return_value_strcasecmp$33;
  return_value_strcasecmp$33=strcasecmp(attmap_shadow_shadowLastChange, "pwdLastSet");
  if(return_value_strcasecmp$33 == 0)
  {
    if(!((65536ul & *flag) == 0ul))
      *maxdays = (signed long int)-1;

    *flag = (unsigned long int)0;
  }

}

// get_strdup
// file cfg.c line 143
static char * get_strdup(const char *filename, signed int lnr, const char *keyword, char **line)
{
  char token[4096l];
  char *return_value_get_token$1;
  return_value_get_token$1=get_token(line, token, sizeof(char [4096l]) /*4096ul*/ );
  check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$1 != (char *)(void *)0));
  char *return_value_xstrdup$2;
  return_value_xstrdup$2=xstrdup(token);
  return return_value_xstrdup$2;
}

// get_time
// file cfg.c line 250
static signed long int get_time(const char *filename, signed int lnr, const char *keyword, char **line)
{
  char token[32l];
  char *return_value_get_token$1;
  return_value_get_token$1=get_token(line, token, sizeof(char [32l]) /*32ul*/ );
  check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$1 != (char *)(void *)0));
  signed long int return_value_parse_time$2;
  return_value_parse_time$2=parse_time(filename, lnr, token);
  return return_value_parse_time$2;
}

// get_token
// file cfg.c line 116
static char * get_token(char **line, char *buf, unsigned long int buflen)
{
  unsigned long int len;
  _Bool tmp_if_expr$1;
  if(line == ((char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = *line == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)*(*line) == 0 ? (_Bool)1 : (_Bool)0;
  if(buf == ((char *)NULL) || tmp_if_expr$2)
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strspn$3;
    return_value_strspn$3=strspn(*line, " \t\n\r");
    *line = *line + (signed long int)return_value_strspn$3;
    len=strcspn(*line, " \t\n\r");
    if(len == 0ul)
    {
      *line = (char *)(void *)0;
      return (char *)(void *)0;
    }

    else
    {
      if(len >= buflen)
        len = buflen - (unsigned long int)1;

      strncpy(buf, *line, len);
      buf[(signed long int)len] = (char)0;
      *line = *line + (signed long int)len;
      unsigned long int return_value_strspn$4;
      return_value_strspn$4=strspn(*line, " \t\n\r");
      *line = *line + (signed long int)return_value_strspn$4;
      return buf;
    }
  }
}

// get_userpassword
// file common.c line 183
const char * get_userpassword(struct myldap_entry *entry, const char *attr, char *buffer, unsigned long int buflen)
{
  const char *tmpvalue;
  tmpvalue=attmap_get_value(entry, attr, buffer, buflen);
  if(tmpvalue == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    signed int return_value_strncasecmp$1;
    return_value_strncasecmp$1=strncasecmp(tmpvalue, "{crypt}", (unsigned long int)7);
    if(return_value_strncasecmp$1 == 0)
      return tmpvalue + (signed long int)7;

    else
    {
      signed int return_value_strncasecmp$2;
      return_value_strncasecmp$2=strncasecmp(tmpvalue, "crypt$", (unsigned long int)6);
      if(return_value_strncasecmp$2 == 0)
        return tmpvalue + (signed long int)6;

      else
        return tmpvalue;
    }
  }
}

// getfqdn
// file common.c line 118
const char * getfqdn(void)
{
  char hostname[65l];
  signed int hostnamelen;
  signed int i;
  struct hostent *host = (struct hostent *)(void *)0;
  static char *fqdn = (char *)(void *)0;
  if(!(fqdn == ((char *)NULL)))
    return fqdn;

  else
  {
    signed int return_value_gethostname$3;
    return_value_gethostname$3=gethostname(hostname, sizeof(char [65l]) /*65ul*/ );
    if(!(return_value_gethostname$3 >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_log(3, "gethostname() failed: %s", return_value_strerror$2);
      return (const char *)(void *)0;
    }

    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(hostname);
    hostnamelen = (signed int)return_value_strlen$4;
    host=gethostbyname(hostname);
    if(host == ((struct hostent *)NULL))
    {
      signed int *return_value___h_errno_location$5;
      return_value___h_errno_location$5=__h_errno_location();
      const char *return_value_hstrerror$6;
      return_value_hstrerror$6=hstrerror(*return_value___h_errno_location$5);
      log_log(3, "gethostbyname(%s): %s", (const void *)hostname, return_value_hstrerror$6);
      fqdn=strdup(hostname);
      return fqdn;
    }

    signed int return_value_strncasecmp$7;
    return_value_strncasecmp$7=strncasecmp(hostname, host->h_name, (unsigned long int)hostnamelen);
    if(return_value_strncasecmp$7 == 0)
    {
      if(!((signed int)host->h_name[(signed long int)hostnamelen] == 46))
        goto __CPROVER_DUMP_L4;

      if((signed int)host->h_name[(signed long int)(1 + hostnamelen)] == 0)
        goto __CPROVER_DUMP_L4;

      fqdn=strdup(host->h_name);
      return fqdn;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      i = 0;
      for( ; !(host->h_aliases[(signed long int)i] == ((char *)NULL)); i = i + 1)
      {
        signed int return_value_strncasecmp$8;
        return_value_strncasecmp$8=strncasecmp(hostname, host->h_aliases[(signed long int)i], (unsigned long int)hostnamelen);
        if(return_value_strncasecmp$8 == 0)
        {
          if((signed int)host->h_aliases[(signed long int)i][(signed long int)hostnamelen] == 46)
          {
            if(!((signed int)host->h_aliases[(signed long int)i][(signed long int)(1 + hostnamelen)] == 0))
            {
              fqdn=strdup(host->h_aliases[(signed long int)i]);
              return fqdn;
            }

          }

        }

      }
      char *return_value_strchr$9;
      return_value_strchr$9=strchr(host->h_name, 46);
      if(!(return_value_strchr$9 == ((char *)NULL)))
      {
        fqdn=strdup(host->h_name);
        return fqdn;
      }

      else
      {
        i = 0;
        for( ; !(host->h_aliases[(signed long int)i] == ((char *)NULL)); i = i + 1)
        {
          char *return_value_strchr$10;
          return_value_strchr$10=strchr(host->h_aliases[(signed long int)i], 46);
          if(!(return_value_strchr$10 == ((char *)NULL)))
          {
            fqdn=strdup(host->h_aliases[(signed long int)i]);
            return fqdn;
          }

        }
        fqdn=strdup(hostname);
        return fqdn;
      }
    }
  }
}

// getmembers
// file group.c line 259
static void getmembers(struct myldap_entry *entry, struct ldap_session *session, struct set *members, struct set *seen, struct set *subgroups)
{
  char buf[256l];
  signed int i;
  const char **values;
  const char ***derefs;
  values=myldap_get_values(entry, attmap_group_memberUid);
  if(!(values == ((const char **)NULL)))
  {
    i = 0;
    for( ; !(values[(signed long int)i] == ((const char *)NULL)); i = i + 1)
    {
      signed int return_value_isvalidname$1;
      return_value_isvalidname$1=isvalidname(values[(signed long int)i]);
      if(!(return_value_isvalidname$1 == 0))
        set_add(members, values[(signed long int)i]);

    }
  }

  signed int return_value_strcasecmp$2;
  return_value_strcasecmp$2=strcasecmp(attmap_group_member, "\"\"");
  _Bool tmp_if_expr$4;
  signed int return_value_set_contains$3;
  _Bool tmp_if_expr$7;
  signed int return_value_set_contains$6;
  if(!(return_value_strcasecmp$2 == 0))
  {
    derefs=myldap_get_deref_values(entry, attmap_group_member, attmap_passwd_uid);
    if(!(derefs == ((const char ***)NULL)))
    {
      i = 0;
      for( ; !((*derefs)[(signed long int)i] == ((const char *)NULL)); i = i + 1)
        set_add(members, derefs[(signed long int)0][(signed long int)i]);
      i = 0;
      for( ; !(derefs[1l][(signed long int)i] == ((const char *)NULL)); i = i + 1)
      {
        if(seen == ((struct set *)NULL))
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_set_contains$3=set_contains(seen, derefs[(signed long int)1][(signed long int)i]);
          tmp_if_expr$4 = !(return_value_set_contains$3 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          if(!(seen == ((struct set *)NULL)))
            set_add(seen, derefs[(signed long int)1][(signed long int)i]);

          if(!(subgroups == ((struct set *)NULL)))
            set_add(subgroups, derefs[(signed long int)1][(signed long int)i]);

        }

      }
    }

    else
    {
      values=myldap_get_values(entry, attmap_group_member);
      if(!(values == ((const char **)NULL)))
      {
        i = 0;
        for( ; !(values[(signed long int)i] == ((const char *)NULL)); i = i + 1)
        {
          if(seen == ((struct set *)NULL))
            tmp_if_expr$7 = (_Bool)1;

          else
          {
            return_value_set_contains$6=set_contains(seen, values[(signed long int)i]);
            tmp_if_expr$7 = !(return_value_set_contains$6 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$7)
          {
            if(!(seen == ((struct set *)NULL)))
              set_add(seen, values[(signed long int)i]);

            char *return_value_dn2uid$5;
            return_value_dn2uid$5=dn2uid(session, values[(signed long int)i], buf, sizeof(char [256l]) /*256ul*/ );
            if(!(return_value_dn2uid$5 == ((char *)NULL)))
              set_add(members, buf);

            else
              if(!(subgroups == ((struct set *)NULL)))
                set_add(subgroups, values[(signed long int)i]);

          }

        }
      }

    }
  }

}

// getpeercred
// file ../compat/getpeercred.h line 33
signed int getpeercred(signed int sock, unsigned int *uid, unsigned int *gid, signed int *pid)
{
  unsigned int l;
  struct ucred cred;
  cred.pid = (signed int)0;
  cred.uid = (unsigned int)-1;
  cred.gid = (unsigned int)-1;
  l = (unsigned int)sizeof(struct ucred) /*12ul*/ ;
  signed int return_value_getsockopt$1;
  return_value_getsockopt$1=getsockopt(sock, 1, 17, (void *)&cred, &l);
  if(!(return_value_getsockopt$1 >= 0))
    return -1;

  else
  {
    if(!(uid == ((unsigned int *)NULL)))
      *uid = cred.uid;

    if(!(gid == ((unsigned int *)NULL)))
      *gid = cred.gid;

    if(!(pid == ((signed int *)NULL)))
      *pid = cred.pid;

    return 0;
  }
}

// group_init
// file common.h line 208
void group_init(void)
{
  signed int i;
  struct set *set;
  if(group_bases[0l] == ((const char *)NULL))
  {
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      group_bases[(signed long int)i] = nslcd_cfg->bases[(signed long int)i];
  }

  if(group_scope == -1)
    group_scope = nslcd_cfg->scope;

  signed int return_value_strncasecmp$1;
  return_value_strncasecmp$1=strncasecmp(attmap_group_gidNumber, "objectSid:", (unsigned long int)10);
  if(return_value_strncasecmp$1 == 0)
  {
    gidSid=sid2search(attmap_group_gidNumber + (signed long int)10);
    builtinSid=sid2search("S-1-5-32");
    attmap_group_gidNumber=strndup(attmap_group_gidNumber, (unsigned long int)9);
  }

  set=set_new();
  attmap_add_attributes(set, attmap_group_cn);
  attmap_add_attributes(set, attmap_group_userPassword);
  attmap_add_attributes(set, attmap_group_gidNumber);
  if(nslcd_cfg->nss_getgrent_skipmembers == 0)
  {
    attmap_add_attributes(set, attmap_group_memberUid);
    attmap_add_attributes(set, attmap_group_member);
  }

  group_attrs=set_tolist(set);
  if(group_attrs == ((const char **)NULL))
  {
    log_log(2, "malloc() failed to allocate memory");
    exit(1);
  }

  set_free(set);
  set=set_new();
  attmap_add_attributes(set, attmap_group_cn);
  attmap_add_attributes(set, attmap_group_userPassword);
  attmap_add_attributes(set, attmap_group_gidNumber);
  group_bymember_attrs=set_tolist(set);
  if(group_bymember_attrs == ((const char **)NULL))
  {
    log_log(2, "malloc() failed to allocate memory");
    exit(1);
  }

  set_free(set);
}

// growhashtable
// file dict.c line 83
static void growhashtable(struct dictionary *dict)
{
  signed int i;
  signed int newsize;
  struct dict_entry **newtable;
  struct dict_entry *entry;
  struct dict_entry *tmp;
  newsize = dict->size * 3 + 1;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)newsize * sizeof(struct dict_entry *) /*8ul*/ );
  newtable = (struct dict_entry **)return_value_malloc$1;
  if(!(newtable == ((struct dict_entry **)NULL)))
  {
    i = 0;
    for( ; !(i >= newsize); i = i + 1)
      newtable[(signed long int)i] = (struct dict_entry *)(void *)0;
    i = 0;
    for( ; !(i >= dict->size); i = i + 1)
    {
      entry = dict->table[(signed long int)i];
      for( ; !(entry == ((struct dict_entry *)NULL)); newtable[(signed long int)(tmp->hash % (unsigned int)newsize)] = tmp)
      {
        tmp = entry;
        entry = entry->next;
        tmp->next = newtable[(signed long int)(tmp->hash % (unsigned int)newsize)];
      }
    }
    free((void *)dict->table);
    dict->size = newsize;
    dict->table = newtable;
  }

}

// handle_base
// file cfg.c line 605
static void handle_base(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg)
{
  const char **bases;
  signed int i;
  char *value;
  const char *domain = (const char *)(void *)0;
  char *domaindn = (char *)(void *)0;
  enum ldap_map_selector return_value_get_map$1;
  return_value_get_map$1=get_map(&line);
  bases=base_get_var(return_value_get_map$1);
  if(bases == ((const char **)NULL))
    bases = cfg->bases;

  value=get_linedup(filename, lnr, keyword, &line);
  signed int return_value_strcasecmp$2;
  return_value_strcasecmp$2=strcasecmp(value, "domain");
  if(return_value_strcasecmp$2 == 0)
  {
    free((void *)value);
    domain=cfg_getdomainname(filename, lnr);
    ldap_domain2dn(domain, &domaindn);
    log_log(7, "set_base(): setting base to %s from domain", domaindn);
    value=xstrdup(domaindn);
  }

  i = 0;
  for( ; !(i >= 31); i = i + 1)
    if(bases[(signed long int)i] == ((const char *)NULL))
    {
      bases[(signed long int)i] = value;
      goto __CPROVER_DUMP_L6;
    }

  log_log(3, "%s:%d: maximum number of base options per map (%d) exceeded", filename, lnr, 31);
  exit(1);

__CPROVER_DUMP_L6:
  ;
}

// handle_cache
// file cfg.c line 1043
static void handle_cache(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg)
{
  char cache[16l];
  signed long int value1;
  signed long int value2;
  char *return_value_get_token$1;
  return_value_get_token$1=get_token(&line, cache, sizeof(char [16l]) /*16ul*/ );
  check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$1 != (char *)(void *)0));
  value1=get_time(filename, lnr, keyword, &line);
  _Bool tmp_if_expr$2;
  if(!(line == ((char *)NULL)))
    tmp_if_expr$2 = (signed int)*line != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    value2=get_time(filename, lnr, keyword, &line);

  else
    value2 = value1;
  get_eol(filename, lnr, keyword, &line);
  signed int return_value_strcasecmp$3;
  return_value_strcasecmp$3=strcasecmp(cache, "dn2uid");
  if(return_value_strcasecmp$3 == 0)
  {
    cfg->cache_dn2uid_positive = value1;
    cfg->cache_dn2uid_negative = value2;
  }

  else
  {
    log_log(3, "%s:%d: unknown cache: '%s'", filename, lnr, (const void *)cache);
    exit(1);
  }
}

// handle_deref
// file cfg.c line 695
static void handle_deref(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg)
{
  char token[32l];
  char *return_value_get_token$1;
  return_value_get_token$1=get_token(&line, token, sizeof(char [32l]) /*32ul*/ );
  check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$1 != (char *)(void *)0));
  get_eol(filename, lnr, keyword, &line);
  signed int return_value_strcasecmp$5;
  return_value_strcasecmp$5=strcasecmp(token, "never");
  signed int return_value_strcasecmp$4;
  signed int return_value_strcasecmp$3;
  signed int return_value_strcasecmp$2;
  if(return_value_strcasecmp$5 == 0)
    cfg->deref = 0x00;

  else
  {
    return_value_strcasecmp$4=strcasecmp(token, "searching");
    if(return_value_strcasecmp$4 == 0)
      cfg->deref = 0x01;

    else
    {
      return_value_strcasecmp$3=strcasecmp(token, "finding");
      if(return_value_strcasecmp$3 == 0)
        cfg->deref = 0x02;

      else
      {
        return_value_strcasecmp$2=strcasecmp(token, "always");
        if(return_value_strcasecmp$2 == 0)
          cfg->deref = 0x03;

        else
        {
          log_log(3, "%s:%d: wrong argument: '%s'", filename, lnr, (const void *)token);
          exit(1);
        }
      }
    }
  }
}

// handle_filter
// file cfg.c line 730
static void handle_filter(const char *filename, signed int lnr, const char *keyword, char *line)
{
  const char **var;
  const char *map = line;
  enum ldap_map_selector return_value_get_map$1;
  return_value_get_map$1=get_map(&line);
  var=filter_get_var(return_value_get_map$1);
  if(var == ((const char **)NULL))
  {
    log_log(3, "%s:%d: unknown map: '%s'", filename, lnr, map);
    exit(1);
  }

  _Bool tmp_if_expr$2;
  if(!(line == ((char *)NULL)))
    tmp_if_expr$2 = (signed int)*line != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  check_argumentcount(filename, lnr, keyword, (signed int)tmp_if_expr$2);
  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(*var, line);
  if(!(return_value_strcmp$3 == 0))
    *var=xstrdup(line);

}

// handle_gid
// file cfg.c line 314
static void handle_gid(const char *filename, signed int lnr, const char *keyword, char *line, unsigned int *gid)
{
  char token[32l];
  struct group *grent;
  char *tmp;
  char *return_value_get_token$1;
  return_value_get_token$1=get_token(&line, token, sizeof(char [32l]) /*32ul*/ );
  check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$1 != (char *)(void *)0));
  get_eol(filename, lnr, keyword, &line);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = 0;
  unsigned int return_value_strtoui$3;
  return_value_strtoui$3=strtoui(token, &tmp, 10);
  *gid = (unsigned int)return_value_strtoui$3;
  signed int *return_value___errno_location$5;
  char *return_value_strchr$4;
  if(!((signed int)token[0l] == 0))
  {
    if(!((signed int)*tmp == 0))
      goto __CPROVER_DUMP_L1;

    return_value___errno_location$5=__errno_location();
    if(!(*return_value___errno_location$5 == 0))
      goto __CPROVER_DUMP_L1;

    return_value_strchr$4=strchr(token, 45);
    if(!(return_value_strchr$4 == ((char *)NULL)))
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    grent=getgrnam(token);
    if(!(grent == ((struct group *)NULL)))
      *gid = grent->gr_gid;

    else
    {
      log_log(3, "%s:%d: %s: not a valid gid: '%s'", filename, lnr, keyword, (const void *)token);
      exit(1);
    }
  }
}

// handle_krb5_ccname
// file cfg.c line 485
static void handle_krb5_ccname(const char *filename, signed int lnr, const char *keyword, char *line)
{
  char token[80l];
  const char *ccname;
  const char *ccfile;
  unsigned long int ccenvlen;
  char *ccenv;
  unsigned int minor_status;
  char *return_value_get_token$1;
  return_value_get_token$1=get_token(&line, token, sizeof(char [80l]) /*80ul*/ );
  check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$1 != (char *)(void *)0));
  get_eol(filename, lnr, keyword, &line);
  ccname = token;
  signed int return_value_strncasecmp$6;
  return_value_strncasecmp$6=strncasecmp(ccname, "FILE:", sizeof(char [6l]) /*6ul*/  - (unsigned long int)1);
  _Bool tmp_if_expr$8;
  signed int return_value_strncasecmp$7;
  if(return_value_strncasecmp$6 == 0)
    tmp_if_expr$8 = (_Bool)1;

  else
  {
    return_value_strncasecmp$7=strncasecmp(ccname, "WRFILE:", sizeof(char [8l]) /*8ul*/  - (unsigned long int)1);
    tmp_if_expr$8 = return_value_strncasecmp$7 == 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$8)
  {
    char *return_value_strchr$2;
    return_value_strchr$2=strchr(ccname, 58);
    ccfile = return_value_strchr$2 + (signed long int)1;
    signed int return_value_access$5;
    return_value_access$5=access(ccfile, 4);
    if(!(return_value_access$5 == 0))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      log_log(3, "%s:%d: error accessing %s: %s", filename, lnr, ccfile, return_value_strerror$4);
      exit(1);
    }

  }

  unsigned long int return_value_strlen$9;
  return_value_strlen$9=strlen(ccname);
  ccenvlen = return_value_strlen$9 + sizeof(char [12l]) /*12ul*/ ;
  void *return_value_malloc$10;
  return_value_malloc$10=malloc(ccenvlen);
  ccenv = (char *)return_value_malloc$10;
  if(ccenv == ((char *)NULL))
  {
    log_log(2, "malloc() failed to allocate memory");
    exit(1);
  }

  mysnprintf(ccenv, ccenvlen, "KRB5CCNAME=%s", ccname);
  putenv(ccenv);
  unsigned int return_value_gss_krb5_ccache_name$11;
  return_value_gss_krb5_ccache_name$11=gss_krb5_ccache_name(&minor_status, ccname, (const char **)(void *)0);
  if(!(return_value_gss_krb5_ccache_name$11 == 0u))
  {
    log_log(3, "%s:%d: unable to set default credential cache: %s", filename, lnr, ccname);
    exit(1);
  }

}

// handle_log
// file cfg.c line 364
static void handle_log(const char *filename, signed int lnr, const char *keyword, char *line)
{
  signed int level = 6;
  char scheme[64l];
  char loglevel[32l];
  char *return_value_get_token$1;
  return_value_get_token$1=get_token(&line, scheme, sizeof(char [64l]) /*64ul*/ );
  check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$1 != (char *)(void *)0));
  char *return_value_get_token$2;
  return_value_get_token$2=get_token(&line, loglevel, sizeof(char [32l]) /*32ul*/ );
  if(!(return_value_get_token$2 == ((char *)NULL)))
    level=parse_loglevel(filename, lnr, loglevel);

  get_eol(filename, lnr, keyword, &line);
  signed int return_value_strcasecmp$4;
  return_value_strcasecmp$4=strcasecmp(scheme, "none");
  signed int return_value_strcasecmp$3;
  if(return_value_strcasecmp$4 == 0)
    log_addlogging_none();

  else
  {
    return_value_strcasecmp$3=strcasecmp(scheme, "syslog");
    if(return_value_strcasecmp$3 == 0)
      log_addlogging_syslog(level);

    else
      if((signed int)scheme[0l] == 47)
        log_addlogging_file(level, scheme);

      else
      {
        log_log(3, "%s:%d: %s: invalid argument '%s'", filename, lnr, keyword, (const void *)scheme);
        exit(1);
      }
  }
}

// handle_map
// file cfg.c line 752
static void handle_map(const char *filename, signed int lnr, const char *keyword, char *line)
{
  enum ldap_map_selector map;
  const char **var;
  char oldatt[32l];
  char newatt[1024l];
  map=get_map(&line);
  if((signed int)map == LM_NONE)
  {
    log_log(3, "%s:%d: unknown map: '%s'", filename, lnr, line);
    exit(1);
  }

  char *return_value_get_token$1;
  return_value_get_token$1=get_token(&line, oldatt, sizeof(char [32l]) /*32ul*/ );
  _Bool tmp_if_expr$3;
  char *return_value_get_token$2;
  if(!(return_value_get_token$1 == ((char *)NULL)))
  {
    return_value_get_token$2=get_token(&line, newatt, sizeof(char [1024l]) /*1024ul*/ );
    tmp_if_expr$3 = return_value_get_token$2 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  check_argumentcount(filename, lnr, keyword, (signed int)tmp_if_expr$3);
  get_eol(filename, lnr, keyword, &line);
  var=attmap_get_var(map, oldatt);
  if(var == ((const char **)NULL))
  {
    log_log(3, "%s:%d: unknown attribute to map: '%s'", filename, lnr, (const void *)oldatt);
    exit(1);
  }

  const char *return_value_attmap_set_mapping$4;
  return_value_attmap_set_mapping$4=attmap_set_mapping(var, newatt);
  if(return_value_attmap_set_mapping$4 == ((const char *)NULL))
  {
    log_log(3, "%s:%d: attribute %s cannot be an expression", filename, lnr, (const void *)oldatt);
    exit(1);
  }

}

// handle_nss_initgroups_ignoreusers
// file cfg.c line 844
static void handle_nss_initgroups_ignoreusers(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg)
{
  char token[4096l];
  char *username;
  char *next;
  struct passwd *pwent;
  _Bool tmp_if_expr$1;
  if(!(line == ((char *)NULL)))
    tmp_if_expr$1 = (signed int)*line != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  check_argumentcount(filename, lnr, keyword, (signed int)tmp_if_expr$1);
  if(cfg->nss_initgroups_ignoreusers == ((struct set *)NULL))
    cfg->nss_initgroups_ignoreusers=set_new();

  char *return_value_get_token$2;
  do
  {
    return_value_get_token$2=get_token(&line, token, sizeof(char [4096l]) /*4096ul*/ );
    if(return_value_get_token$2 == ((char *)NULL))
      break;

    signed int return_value_strcasecmp$3;
    return_value_strcasecmp$3=strcasecmp(token, "alllocal");
    if(return_value_strcasecmp$3 == 0)
    {
      setpwent();
      do
      {
        pwent=getpwent();
        if(pwent == ((struct passwd *)NULL))
          break;

        set_add(cfg->nss_initgroups_ignoreusers, pwent->pw_name);
      }
      while((_Bool)1);
      endpwent();
    }

    else
    {
      next = token;
      while(!((signed int)*next == 0))
      {
        username = next;
        for( ; !((signed int)*next == 0); next = next + 1l)
          if((signed int)*next == 44)
            break;

        if((signed int)*next == 44)
        {
          *next = (char)0;
          next = next + 1l;
        }

        pwent=getpwnam(username);
        if(pwent == ((struct passwd *)NULL))
          log_log(3, "%s:%d: user '%s' does not exist", filename, lnr, username);

        set_add(cfg->nss_initgroups_ignoreusers, username);
      }
    }
  }
  while((_Bool)1);
}

// handle_pam_authz_search
// file cfg.c line 944
static void handle_pam_authz_search(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg)
{
  struct set *set;
  const char **list;
  signed int i;
  _Bool tmp_if_expr$1;
  if(!(line == ((char *)NULL)))
    tmp_if_expr$1 = (signed int)*line != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  check_argumentcount(filename, lnr, keyword, (signed int)tmp_if_expr$1);
  i = 0;
  _Bool tmp_if_expr$2;
  do
  {
    if(!(i >= 8))
      tmp_if_expr$2 = cfg->pam_authz_searches[(signed long int)i] != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  if(i >= 8)
  {
    log_log(3, "%s:%d: maximum number of pam_authz_search options (%d) exceeded", filename, lnr, 8);
    exit(1);
  }

  cfg->pam_authz_searches[(signed long int)i]=xstrdup(line);
  set=expr_vars(cfg->pam_authz_searches[(signed long int)i], (struct set *)(void *)0);
  list=set_tolist(set);
  if(list == ((const char **)NULL))
  {
    log_log(2, "malloc() failed to allocate memory");
    exit(1);
  }

  i = 0;
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  for( ; !(list[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_strcmp$11;
    return_value_strcmp$11=strcmp(list[(signed long int)i], "username");
    if(!(return_value_strcmp$11 == 0))
    {
      return_value_strcmp$10=strcmp(list[(signed long int)i], "service");
      if(!(return_value_strcmp$10 == 0))
      {
        return_value_strcmp$9=strcmp(list[(signed long int)i], "ruser");
        if(!(return_value_strcmp$9 == 0))
        {
          return_value_strcmp$8=strcmp(list[(signed long int)i], "rhost");
          if(!(return_value_strcmp$8 == 0))
          {
            return_value_strcmp$7=strcmp(list[(signed long int)i], "tty");
            if(!(return_value_strcmp$7 == 0))
            {
              return_value_strcmp$6=strcmp(list[(signed long int)i], "hostname");
              if(!(return_value_strcmp$6 == 0))
              {
                return_value_strcmp$5=strcmp(list[(signed long int)i], "fqdn");
                if(!(return_value_strcmp$5 == 0))
                {
                  return_value_strcmp$4=strcmp(list[(signed long int)i], "dn");
                  if(!(return_value_strcmp$4 == 0))
                  {
                    return_value_strcmp$3=strcmp(list[(signed long int)i], "uid");
                    if(!(return_value_strcmp$3 == 0))
                    {
                      log_log(3, "%s:%d: unknown variable $%s", filename, lnr, list[(signed long int)i]);
                      exit(1);
                    }

                  }

                }

              }

            }

          }

        }

      }

    }

  }
  set_free(set);
  free((void *)list);
}

// handle_pam_password_prohibit_message
// file cfg.c line 991
static void handle_pam_password_prohibit_message(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg)
{
  char *value;
  signed int l;
  value=get_linedup(filename, lnr, keyword, &line);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(value);
  l = (signed int)return_value_strlen$1;
  if((signed int)*value == 34)
  {
    if((signed int)value[(signed long int)(l + -1)] == 34)
    {
      value[(signed long int)(l - 1)] = (char)0;
      value = value + 1l;
    }

  }

  cfg->pam_password_prohibit_message = value;
}

// handle_ppolicy_controls
// file myldap.c line 409
static void handle_ppolicy_controls(struct ldap_session *session, struct ldap *ld, struct ldapcontrol **ctrls)
{
  signed int i;
  signed int rc;
  session->policy_response = 0;
  strncpy(session->policy_message, "", sizeof(char [1024l]) /*1024ul*/ );
  i = 0;
  signed int return_value_strcmp$17;
  signed int return_value_strcmp$16;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$15;
  unsigned long int return_value_strlen$14;
  unsigned long int return_value_strlen$13;
  for( ; !(ctrls[(signed long int)i] == ((struct ldapcontrol *)NULL)); i = i + 1)
  {
    signed int return_value_strcmp$18;
    return_value_strcmp$18=strcmp(ctrls[(signed long int)i]->ldctl_oid, "2.16.840.1.113730.3.4.4");
    if(return_value_strcmp$18 == 0)
    {
      log_log(7, "got LDAP_CONTROL_PWEXPIRED (password expired, user should change)");
      if(session->policy_response == 0)
        session->policy_response = 12;

    }

    else
    {
      return_value_strcmp$17=strcmp(ctrls[(signed long int)i]->ldctl_oid, "2.16.840.1.113730.3.4.5");
      if(return_value_strcmp$17 == 0)
      {
        char seconds[32l];
        signed long int sec;
        mysnprintf(seconds, sizeof(char [32l]) /*32ul*/ , "%.*s", (signed int)ctrls[(signed long int)i]->ldctl_value.bv_len, ctrls[(signed long int)i]->ldctl_value.bv_val);
        sec=atol(seconds);
        log_log(7, "got LDAP_CONTROL_PWEXPIRING (password will expire in %ld seconds)", sec);
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(session->policy_message);
        if(return_value_strlen$1 == 0ul)
          mysnprintf(session->policy_message, sizeof(char [1024l]) /*1024ul*/ , "password will expire in %ld seconds", sec);

      }

      else
      {
        return_value_strcmp$16=strcmp(ctrls[(signed long int)i]->ldctl_oid, "1.3.6.1.4.1.42.2.27.8.5.1");
        if(return_value_strcmp$16 == 0)
        {
          signed int expire = 0;
          signed int grace = 0;
          enum passpolicyerror_enum error = (enum passpolicyerror_enum)-1;
          rc=ldap_parse_passwordpolicy_control(ld, ctrls[(signed long int)i], &expire, &grace, &error);
          if(!(rc == 0x00))
            myldap_err(4, ld, rc, "ldap_parse_passwordpolicy_control() failed (ignored)");

          else
          {
            const char *return_value_ldap_passwordpolicy_err2txt$2;
            return_value_ldap_passwordpolicy_err2txt$2=ldap_passwordpolicy_err2txt(error);
            log_log(7, "got LDAP_CONTROL_PASSWORDPOLICYRESPONSE (%s)", return_value_ldap_passwordpolicy_err2txt$2);
            if(expire >= 0)
              log_log(7, "got LDAP_CONTROL_PASSWORDPOLICYRESPONSE (password will expire in %d seconds)", expire);

            if(grace >= 0)
              log_log(7, "got LDAP_CONTROL_PASSWORDPOLICYRESPONSE (%d grace logins left)", grace);

            if((signed int)error == PP_passwordExpired)
            {
              if(session->policy_response == 0)
                tmp_if_expr$11 = (_Bool)1;

              else
                tmp_if_expr$11 = session->policy_response == 12 ? (_Bool)1 : (_Bool)0;
              tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$12 = (_Bool)0;
            if(tmp_if_expr$12)
            {
              session->policy_response = 12;
              const char *return_value_ldap_passwordpolicy_err2txt$3;
              return_value_ldap_passwordpolicy_err2txt$3=ldap_passwordpolicy_err2txt(error);
              mysnprintf(session->policy_message, sizeof(char [1024l]) /*1024ul*/ , "%s", return_value_ldap_passwordpolicy_err2txt$3);
            }

            else
            {
              if((signed int)error == PP_accountLocked)
              {
                if(session->policy_response == 0)
                  tmp_if_expr$9 = (_Bool)1;

                else
                  tmp_if_expr$9 = session->policy_response == 12 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$10 = (_Bool)0;
              if(tmp_if_expr$10)
              {
                session->policy_response = 13;
                const char *return_value_ldap_passwordpolicy_err2txt$4;
                return_value_ldap_passwordpolicy_err2txt$4=ldap_passwordpolicy_err2txt(error);
                mysnprintf(session->policy_message, sizeof(char [1024l]) /*1024ul*/ , "%s", return_value_ldap_passwordpolicy_err2txt$4);
              }

              else
              {
                if((signed int)error == PP_changeAfterReset)
                  tmp_if_expr$8 = session->policy_response == 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$8 = (_Bool)0;
                if(tmp_if_expr$8)
                {
                  session->policy_response = 12;
                  const char *return_value_ldap_passwordpolicy_err2txt$5;
                  return_value_ldap_passwordpolicy_err2txt$5=ldap_passwordpolicy_err2txt(error);
                  mysnprintf(session->policy_message, sizeof(char [1024l]) /*1024ul*/ , "%s", return_value_ldap_passwordpolicy_err2txt$5);
                }

                else
                  if(!((signed int)error == PP_noError))
                  {
                    if(session->policy_response == 0)
                      tmp_if_expr$7 = (_Bool)1;

                    else
                      tmp_if_expr$7 = session->policy_response == 12 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr$7)
                    {
                      session->policy_response = 6;
                      const char *return_value_ldap_passwordpolicy_err2txt$6;
                      return_value_ldap_passwordpolicy_err2txt$6=ldap_passwordpolicy_err2txt(error);
                      mysnprintf(session->policy_message, sizeof(char [1024l]) /*1024ul*/ , "%s", return_value_ldap_passwordpolicy_err2txt$6);
                    }

                  }

              }
            }
            if(expire >= 0)
            {
              return_value_strlen$14=strlen(session->policy_message);
              tmp_if_expr$15 = return_value_strlen$14 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$15 = (_Bool)0;
            if(tmp_if_expr$15)
              mysnprintf(session->policy_message, sizeof(char [1024l]) /*1024ul*/ , "Password will expire in %d seconds", expire);

            else
              if(grace >= 0)
              {
                return_value_strlen$13=strlen(session->policy_message);
                if(return_value_strlen$13 == 0ul)
                  mysnprintf(session->policy_message, sizeof(char [1024l]) /*1024ul*/ , "Password expired, %d grace logins left", grace);

              }

          }
        }

      }
    }
  }
}

// handle_reconnect_invalidate
// file cfg.c line 1009
static void handle_reconnect_invalidate(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg)
{
  char token[4096l];
  char *name;
  char *next;
  enum ldap_map_selector map;
  _Bool tmp_if_expr$1;
  if(!(line == ((char *)NULL)))
    tmp_if_expr$1 = (signed int)*line != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  check_argumentcount(filename, lnr, keyword, (signed int)tmp_if_expr$1);
  char *return_value_get_token$2;
  do
  {
    return_value_get_token$2=get_token(&line, token, sizeof(char [4096l]) /*4096ul*/ );
    if(return_value_get_token$2 == ((char *)NULL))
      break;

    next = token;
    for( ; !((signed int)*next == 0); cfg->reconnect_invalidate[(signed long int)map] = (char)1)
    {
      name = next;
      for( ; !((signed int)*next == 0); next = next + 1l)
        if((signed int)*next == 44)
          break;

      if((signed int)*next == 44)
      {
        *next = (char)0;
        next = next + 1l;
      }

      map=parse_map(name);
      if((signed int)map == LM_NONE)
      {
        log_log(3, "%s:%d: unknown map: '%s'", filename, lnr, name);
        exit(1);
      }

    }
  }
  while((_Bool)1);
}

// handle_requests
// file invalidator.c line 154
static void handle_requests(signed int fd)
{
  signed int i;
  unsigned char c;
  const char *db;
  log_log(7, "invalidator: starting");
  chdir("/");
  putenv("PATH=/usr/sbin:/usr/bin:/sbin:/bin");
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  while((_Bool)1)
  {
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)&c, sizeof(unsigned char) /*1ul*/ );
    i = (signed int)return_value_read$1;
    if(i == 0)
    {
      log_log(3, "invalidator: EOF");
      _exit(0);
    }

    else
      if(!(i >= 0))
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        if(*return_value___errno_location$6 == 4)
        {
          return_value___errno_location$2=__errno_location();
          return_value_strerror$3=strerror(*return_value___errno_location$2);
          log_log(7, "invalidator: read failed (ignored): %s", return_value_strerror$3);
        }

        else
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          char *return_value_strerror$5;
          return_value_strerror$5=strerror(*return_value___errno_location$4);
          log_log(3, "invalidator: read failed: %s", return_value_strerror$5);
          _exit(0);
        }
      }

      else
      {
        db=map2name((enum ldap_map_selector)c);
        if(db == ((const char *)NULL))
          log_log(3, "invalidator: invalid db received");

        else
          exec_invalidate(db);
      }
  }
}

// handle_scope
// file cfg.c line 651
static void handle_scope(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg)
{
  char token[32l];
  signed int *var;
  enum ldap_map_selector return_value_get_map$1;
  return_value_get_map$1=get_map(&line);
  var=scope_get_var(return_value_get_map$1);
  char *return_value_get_token$2;
  return_value_get_token$2=get_token(&line, token, sizeof(char [32l]) /*32ul*/ );
  check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$2 != (char *)(void *)0));
  get_eol(filename, lnr, keyword, &line);
  if(var == ((signed int *)NULL))
    var = &cfg->scope;

  signed int return_value_strcasecmp$8;
  return_value_strcasecmp$8=strcasecmp(token, "sub");
  _Bool tmp_if_expr$10;
  signed int return_value_strcasecmp$9;
  if(return_value_strcasecmp$8 == 0)
    tmp_if_expr$10 = (_Bool)1;

  else
  {
    return_value_strcasecmp$9=strcasecmp(token, "subtree");
    tmp_if_expr$10 = return_value_strcasecmp$9 == 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcasecmp$5;
  _Bool tmp_if_expr$7;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$4;
  signed int return_value_strcasecmp$3;
  if(tmp_if_expr$10)
    *var = (signed int)0x0002;

  else
  {
    return_value_strcasecmp$5=strcasecmp(token, "one");
    if(return_value_strcasecmp$5 == 0)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value_strcasecmp$6=strcasecmp(token, "onelevel");
      tmp_if_expr$7 = return_value_strcasecmp$6 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
      *var = (signed int)0x0001;

    else
    {
      return_value_strcasecmp$4=strcasecmp(token, "base");
      if(return_value_strcasecmp$4 == 0)
        *var = (signed int)0x0000;

      else
      {
        return_value_strcasecmp$3=strcasecmp(token, "children");
        if(return_value_strcasecmp$3 == 0)
          *var = (signed int)0x0003;

        else
        {
          log_log(3, "%s:%d: not a scope argument: '%s'", filename, lnr, (const void *)token);
          exit(1);
        }
      }
    }
  }
}

// handle_tls_reqcert
// file cfg.c line 798
static void handle_tls_reqcert(const char *filename, signed int lnr, const char *keyword, char *line)
{
  char token[16l];
  signed int value;
  signed int rc;
  char *return_value_get_token$1;
  return_value_get_token$1=get_token(&line, token, sizeof(char [16l]) /*16ul*/ );
  check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$1 != (char *)(void *)0));
  get_eol(filename, lnr, keyword, &line);
  signed int return_value_strcasecmp$8;
  return_value_strcasecmp$8=strcasecmp(token, "never");
  _Bool tmp_if_expr$10;
  signed int return_value_strcasecmp$9;
  if(return_value_strcasecmp$8 == 0)
    tmp_if_expr$10 = (_Bool)1;

  else
  {
    return_value_strcasecmp$9=strcasecmp(token, "no");
    tmp_if_expr$10 = return_value_strcasecmp$9 == 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcasecmp$7;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$3;
  _Bool tmp_if_expr$5;
  signed int return_value_strcasecmp$4;
  signed int return_value_strcasecmp$2;
  if(tmp_if_expr$10)
    value = 0;

  else
  {
    return_value_strcasecmp$7=strcasecmp(token, "allow");
    if(return_value_strcasecmp$7 == 0)
      value = 3;

    else
    {
      return_value_strcasecmp$6=strcasecmp(token, "try");
      if(return_value_strcasecmp$6 == 0)
        value = 4;

      else
      {
        return_value_strcasecmp$3=strcasecmp(token, "demand");
        if(return_value_strcasecmp$3 == 0)
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          return_value_strcasecmp$4=strcasecmp(token, "yes");
          tmp_if_expr$5 = return_value_strcasecmp$4 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$5)
          value = 2;

        else
        {
          return_value_strcasecmp$2=strcasecmp(token, "hard");
          if(return_value_strcasecmp$2 == 0)
            value = 1;

          else
          {
            log_log(3, "%s:%d: %s: invalid argument: '%s'", filename, lnr, keyword, (const void *)token);
            exit(1);
          }
        }
      }
    }
  }
  log_log(7, "ldap_set_option(LDAP_OPT_X_TLS_REQUIRE_CERT,%s)", (const void *)token);
  rc=ldap_set_option((struct ldap *)(void *)0, 0x6006, (const void *)&value);
  if(!(rc == 0x00))
  {
    char *return_value_ldap_err2string$11;
    return_value_ldap_err2string$11=ldap_err2string(rc);
    log_log(3, "ldap_set_option(LDAP_OPT_X_TLS_REQUIRE_CERT) failed: %s", return_value_ldap_err2string$11);
    exit(1);
  }

}

// handle_uid
// file cfg.c line 273
static void handle_uid(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg)
{
  char token[32l];
  struct passwd *pwent;
  char *tmp;
  char *return_value_get_token$1;
  return_value_get_token$1=get_token(&line, token, sizeof(char [32l]) /*32ul*/ );
  check_argumentcount(filename, lnr, keyword, (signed int)(return_value_get_token$1 != (char *)(void *)0));
  get_eol(filename, lnr, keyword, &line);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = 0;
  unsigned int return_value_strtoui$3;
  return_value_strtoui$3=strtoui(token, &tmp, 10);
  cfg->uid = (unsigned int)return_value_strtoui$3;
  signed int *return_value___errno_location$5;
  char *return_value_strchr$4;
  if(!((signed int)token[0l] == 0))
  {
    if(!((signed int)*tmp == 0))
      goto __CPROVER_DUMP_L2;

    return_value___errno_location$5=__errno_location();
    if(!(*return_value___errno_location$5 == 0))
      goto __CPROVER_DUMP_L2;

    return_value_strchr$4=strchr(token, 45);
    if(!(return_value_strchr$4 == ((char *)NULL)))
      goto __CPROVER_DUMP_L2;

    pwent=getpwuid(cfg->uid);
    if(pwent == ((struct passwd *)NULL))
      goto __CPROVER_DUMP_L2;

    if(cfg->gid == 4294967295u)
      cfg->gid = pwent->pw_gid;

    cfg->uidname=strdup(pwent->pw_name);
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    pwent=getpwnam(token);
    if(!(pwent == ((struct passwd *)NULL)))
    {
      cfg->uid = pwent->pw_uid;
      if(cfg->gid == 4294967295u)
        cfg->gid = pwent->pw_gid;

      cfg->uidname=strdup(token);
    }

    else
    {
      log_log(3, "%s:%d: %s: not a valid uid: '%s'", filename, lnr, keyword, (const void *)token);
      exit(1);
    }
  }
}

// handle_validnames
// file cfg.c line 889
static void handle_validnames(const char *filename, signed int lnr, const char *keyword, char *line, struct ldap_config *cfg)
{
  char *value;
  signed int i;
  signed int l;
  signed int flags = 1 | ((1 << 1) << 1) << 1;
  value=get_linedup(filename, lnr, keyword, &line);
  if(!(cfg->validnames_str == ((char *)NULL)))
  {
    free((void *)cfg->validnames_str);
    regfree(&cfg->validnames);
  }

  cfg->validnames_str=strdup(value);
  if(!((signed int)*value == 47))
  {
    log_log(3, "%s:%d: regular expression incorrectly delimited", filename, lnr);
    exit(1);
  }

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(value);
  l = (signed int)return_value_strlen$1;
  if((signed int)value[(signed long int)(l + -1)] == 105)
  {
    value[(signed long int)(l - 1)] = (char)0;
    l = l - 1;
    flags = flags | 1 << 1;
  }

  if(!((signed int)value[(signed long int)(l + -1)] == 47))
  {
    log_log(3, "%s:%d: regular expression incorrectly delimited", filename, lnr);
    exit(1);
  }

  value[(signed long int)(l - 1)] = (char)0;
  i=regcomp(&cfg->validnames, value + (signed long int)1, flags);
  if(!(i == 0))
  {
    unsigned long int return_value_regerror$2;
    return_value_regerror$2=regerror(i, &cfg->validnames, (char *)(void *)0, (unsigned long int)0);
    l = (signed int)return_value_regerror$2;
    void *return_value_malloc$3;
    return_value_malloc$3=malloc((unsigned long int)l);
    value = (char *)return_value_malloc$3;
    if(value == ((char *)NULL))
      log_log(3, "%s:%d: invalid regular expression", filename, lnr);

    else
    {
      regerror(i, &cfg->validnames, value, (unsigned long int)l);
      log_log(3, "%s:%d: invalid regular expression: %s", filename, lnr, value);
    }
    exit(1);
  }

  free((void *)value);
}

// handleconnection
// file nslcd.c line 352
static void handleconnection(signed int sock, struct ldap_session *session)
{
  struct tio_fileinfo *fp;
  signed int action;
  unsigned int uid = (unsigned int)-1;
  unsigned int gid = (unsigned int)-1;
  signed int pid = (signed int)-1;
  signed int return_value_getpeercred$3;
  return_value_getpeercred$3=getpeercred(sock, &uid, &gid, &pid);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(!(return_value_getpeercred$3 == 0))
  {
    return_value___errno_location$1=__errno_location();
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(7, "connection from unknown client: %s", return_value_strerror$2);
  }

  else
    log_log(7, "connection from pid=%lu uid=%lu gid=%lu", (unsigned long int)pid, (unsigned long int)uid, (unsigned long int)gid);
  fp=tio_fdopen(sock, 500, 60 * 1000, (unsigned long int)32, (unsigned long int)64, (unsigned long int)1024, (unsigned long int)(1 * 1024 * 1024));
  if(fp == ((struct tio_fileinfo *)NULL))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    log_log(4, "cannot create stream for writing: %s", return_value_strerror$5);
    close(sock);
    goto __CPROVER_DUMP_L48;
  }

  signed int return_value_read_header$6;
  return_value_read_header$6=read_header(fp, &action);
  if(!(return_value_read_header$6 == 0))
    tio_close(fp);

  else
  {
    switch(action)
    {
      case 0x00010001:
      {
        nslcd_config_get(fp, session);
        break;
      }
      case 0x00020001:
      {
        nslcd_alias_byname(fp, session);
        break;
      }
      case 0x00020008:
      {
        nslcd_alias_all(fp, session);
        break;
      }
      case 0x00030001:
      {
        nslcd_ether_byname(fp, session);
        break;
      }
      case 0x00030002:
      {
        nslcd_ether_byether(fp, session);
        break;
      }
      case 0x00030008:
      {
        nslcd_ether_all(fp, session);
        break;
      }
      case 0x00040001:
      {
        nslcd_group_byname(fp, session);
        break;
      }
      case 0x00040002:
      {
        nslcd_group_bygid(fp, session);
        break;
      }
      case 0x00040006:
      {
        nslcd_group_bymember(fp, session);
        break;
      }
      case 0x00040008:
      {
        if(nslcd_cfg->nss_disable_enumeration == 0)
          nslcd_group_all(fp, session);

        break;
      }
      case 0x00050001:
      {
        nslcd_host_byname(fp, session);
        break;
      }
      case 0x00050002:
      {
        nslcd_host_byaddr(fp, session);
        break;
      }
      case 0x00050008:
      {
        nslcd_host_all(fp, session);
        break;
      }
      case 0x00060001:
      {
        nslcd_netgroup_byname(fp, session);
        break;
      }
      case 0x00060008:
      {
        nslcd_netgroup_all(fp, session);
        break;
      }
      case 0x00070001:
      {
        nslcd_network_byname(fp, session);
        break;
      }
      case 0x00070002:
      {
        nslcd_network_byaddr(fp, session);
        break;
      }
      case 0x00070008:
      {
        nslcd_network_all(fp, session);
        break;
      }
      case 0x00080001:
      {
        nslcd_passwd_byname(fp, session, uid);
        break;
      }
      case 0x00080002:
      {
        nslcd_passwd_byuid(fp, session, uid);
        break;
      }
      case 0x00080008:
      {
        if(nslcd_cfg->nss_disable_enumeration == 0)
          nslcd_passwd_all(fp, session, uid);

        break;
      }
      case 0x00090001:
      {
        nslcd_protocol_byname(fp, session);
        break;
      }
      case 0x00090002:
      {
        nslcd_protocol_bynumber(fp, session);
        break;
      }
      case 0x00090008:
      {
        nslcd_protocol_all(fp, session);
        break;
      }
      case 0x000a0001:
      {
        nslcd_rpc_byname(fp, session);
        break;
      }
      case 0x000a0002:
      {
        nslcd_rpc_bynumber(fp, session);
        break;
      }
      case 0x000a0008:
      {
        nslcd_rpc_all(fp, session);
        break;
      }
      case 0x000b0001:
      {
        nslcd_service_byname(fp, session);
        break;
      }
      case 0x000b0002:
      {
        nslcd_service_bynumber(fp, session);
        break;
      }
      case 0x000b0008:
      {
        nslcd_service_all(fp, session);
        break;
      }
      case 0x000c0001:
      {
        nslcd_shadow_byname(fp, session, uid);
        break;
      }
      case 0x000c0008:
      {
        if(nslcd_cfg->nss_disable_enumeration == 0)
          nslcd_shadow_all(fp, session, uid);

        break;
      }
      case 0x000d0001:
      {
        nslcd_pam_authc(fp, session, uid);
        break;
      }
      case 0x000d0002:
      {
        nslcd_pam_authz(fp, session);
        break;
      }
      case 0x000d0003:
      {
        nslcd_pam_sess_o(fp, session);
        break;
      }
      case 0x000d0004:
      {
        nslcd_pam_sess_c(fp, session);
        break;
      }
      case 0x000d0005:
      {
        nslcd_pam_pwmod(fp, session, uid);
        break;
      }
      case 0x000e0001:
      {
        nslcd_usermod(fp, session, uid);
        break;
      }
      default:
        log_log(4, "invalid request id: 0x%08x", (unsigned int)action);
    }
    myldap_session_cleanup(session);
    tio_close(fp);
    goto __CPROVER_DUMP_L48;
  }

__CPROVER_DUMP_L48:
  ;
}

// has_service
// file nsswitch.c line 93
static signed int has_service(const char *services, const char *service, const char *filename, signed int lnr)
{
  signed int i = 0;
  signed int l;
  const unsigned short int **return_value___ctype_b_loc$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  const unsigned short int **return_value___ctype_b_loc$5;
  const unsigned short int **return_value___ctype_b_loc$6;
  if(services == ((const char *)NULL))
    return 0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(service);
    l = (signed int)return_value_strlen$1;
    while(!((signed int)services[(signed long int)i] == 0))
    {
      do
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)services[(signed long int)i]]) == 0)
          break;

        i = i + 1;
      }
      while((_Bool)1);
      signed int return_value_strncmp$4;
      return_value_strncmp$4=strncmp(services + (signed long int)i, service, (unsigned long int)l);
      if(return_value_strncmp$4 == 0)
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if((8 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)services[(signed long int)(i + l)]]) == 0)
          return 1;

      }

      i = i + 1;
      do
      {
        return_value___ctype_b_loc$5=__ctype_b_loc();
        if((8 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)services[(signed long int)i]]) == 0)
          break;

        i = i + 1;
      }
      while((_Bool)1);
      do
      {
        return_value___ctype_b_loc$6=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)services[(signed long int)i]]) == 0)
          break;

        i = i + 1;
      }
      while((_Bool)1);
      if((signed int)services[(signed long int)i] == 91)
      {
        i = i + 1;
        for( ; !((signed int)services[(signed long int)i] == 93); i = i + 1)
          if((signed int)services[(signed long int)i] == 0)
            break;

        if(!((signed int)services[(signed long int)i] == 93))
        {
          log_log(4, "%s: error parsing line %d", filename, lnr);
          return 0;
        }

        i = i + 1;
      }

    }
    return 0;
  }
}

// host_init
// file common.h line 209
void host_init(void)
{
  signed int i;
  if(host_bases[0l] == ((const char *)NULL))
  {
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      host_bases[(signed long int)i] = nslcd_cfg->bases[(signed long int)i];
  }

  if(host_scope == -1)
    host_scope = nslcd_cfg->scope;

  host_attrs[(signed long int)0] = attmap_host_cn;
  host_attrs[(signed long int)1] = attmap_host_ipHostNumber;
  host_attrs[(signed long int)2] = (const char *)(void *)0;
}

// install_sighandler
// file nslcd.c line 502
static void install_sighandler(signed int signum, void (*handler)(signed int))
{
  struct sigaction act;
  memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
  act.__sigaction_handler.sa_handler = handler;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0x10000000 | 1;
  signed int return_value_sigaction$4;
  return_value_sigaction$4=sigaction(signum, &act, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction$4 == 0))
  {
    const char *return_value_signame$1;
    return_value_signame$1=signame(signum);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    log_log(3, "error installing signal handler for '%s': %s", return_value_signame$1, return_value_strerror$3);
    exit(1);
  }

}

// invalidator_do
// file common.h line 151
void invalidator_do(enum ldap_map_selector map)
{
  unsigned char c;
  signed int rc;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  if(signalfd >= 0)
  {
    if((signed int)map == LM_NONE)
    {
      map = (enum ldap_map_selector)0;
      for( ; !((signed int)map >= LM_NONE); map = (enum ldap_map_selector)((signed int)map + 1))
        if(!(nslcd_cfg->reconnect_invalidate[(signed long int)map] == 0))
          invalidator_do(map);

    }

    else
    {
      c = (unsigned char)map;
      signed long int return_value_write$1;
      return_value_write$1=write(signalfd, (const void *)&c, sizeof(unsigned char) /*1ul*/ );
      rc = (signed int)return_value_write$1;
      if(!(rc >= 1))
      {
        return_value___errno_location$2=__errno_location();
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        log_log(4, "error signalling invalidator: %s", return_value_strerror$3);
      }

    }
  }

}

// invalidator_start
// file common.h line 148
signed int invalidator_start(void)
{
  signed int pipefds[2l];
  signed int cpid;
  signed int i;
  signed int return_value_pipe$3;
  return_value_pipe$3=pipe(pipefds);
  if(!(return_value_pipe$3 >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(3, "pipe() failed: %s", return_value_strerror$2);
    return -1;
  }

  i=fcntl(pipefds[(signed long int)1], 3, 0);
  if(!(i >= 0))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    log_log(3, "fctnl(F_GETFL) failed: %s", return_value_strerror$5);
    close(pipefds[(signed long int)0]);
    close(pipefds[(signed long int)1]);
    return -1;
  }

  signed int return_value_fcntl$8;
  return_value_fcntl$8=fcntl(pipefds[(signed long int)1], 4, i | 04000);
  if(!(return_value_fcntl$8 >= 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    char *return_value_strerror$7;
    return_value_strerror$7=strerror(*return_value___errno_location$6);
    log_log(3, "fctnl(F_SETFL,O_NONBLOCK) failed: %s", return_value_strerror$7);
    close(pipefds[(signed long int)0]);
    close(pipefds[(signed long int)1]);
    return -1;
  }

  cpid=fork();
  if(!(cpid >= 0))
  {
    signed int *return_value___errno_location$9;
    return_value___errno_location$9=__errno_location();
    char *return_value_strerror$10;
    return_value_strerror$10=strerror(*return_value___errno_location$9);
    log_log(3, "fork() failed: %s", return_value_strerror$10);
    close(pipefds[(signed long int)0]);
    close(pipefds[(signed long int)1]);
    return -1;
  }

  if(cpid == 0)
  {
    close(pipefds[(signed long int)1]);
    handle_requests(pipefds[(signed long int)0]);
    _exit(1);
  }

  close(pipefds[(signed long int)0]);
  signalfd = pipefds[(signed long int)1];
  return 0;
}

// is_locked
// file nslcd.c line 439
static signed int is_locked(const char *filename)
{
  signed int fd;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  if(!(filename == ((const char *)NULL)))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 0;
    fd=open(filename, 02, 0644);
    if(!(fd >= 0))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(*return_value___errno_location$2 == 2)
        return 0;

      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      log_log(3, "cannot open lock file (%s): %s", filename, return_value_strerror$4);
      exit(1);
    }

    signed int return_value_lockf$8;
    return_value_lockf$8=lockf(fd, 3, (signed long int)0);
    if(!(return_value_lockf$8 >= 0))
    {
      signed int return_value_close$7;
      return_value_close$7=close(fd);
      if(!(return_value_close$7 == 0))
      {
        return_value___errno_location$5=__errno_location();
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "problem closing fd: %s", return_value_strerror$6);
      }

      return -1;
    }

    signed int return_value_close$11;
    return_value_close$11=close(fd);
    if(!(return_value_close$11 == 0))
    {
      return_value___errno_location$9=__errno_location();
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_log(4, "problem closing fd: %s", return_value_strerror$10);
    }

  }

  return 0;
}

// is_valid_entry
// file myldap.c line 329
static inline signed int is_valid_entry(struct myldap_entry *entry)
{
  _Bool tmp_if_expr$1;
  if(!(entry == ((struct myldap_entry *)NULL)))
    tmp_if_expr$1 = entry->search != (struct myldap_search *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = entry->search->session != (struct ldap_session *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = entry->search->session->ld != (struct ldap *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = entry->search->msg != (struct ldapmsg *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$4 = (_Bool)0;
  return (signed int)tmp_if_expr$4;
}

// is_valid_homedir
// file usermod.c line 68
static signed int is_valid_homedir(const char *homedir)
{
  struct stat sb;
  if(!((signed int)*homedir == 47))
    return 0;

  else
  {
    signed int return_value_stat$3;
    return_value_stat$3=stat(homedir, &sb);
    if(!(return_value_stat$3 == 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_log(7, "cannot stat() %s: %s", homedir, return_value_strerror$2);
      return 0;
    }

    if(!((61440u & sb.st_mode) == 16384u))
    {
      log_log(7, "%s: not a directory", homedir);
      return 0;
    }

    else
      return 1;
  }
}

// is_valid_shell
// file usermod.c line 90
static signed int is_valid_shell(const char *shell)
{
  signed int valid = 0;
  char *l;
  setusershell();
  do
  {
    l=getusershell();
    if(l == ((char *)NULL))
      break;

    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(l, shell);
    if(return_value_strcmp$1 == 0)
    {
      valid = 1;
      break;
    }

  }
  while((_Bool)1);
  endusershell();
  return valid;
}

// isvalidname
// file common.c line 205
signed int isvalidname(const char *name)
{
  signed int return_value_regexec$1;
  return_value_regexec$1=regexec(&nslcd_cfg->validnames, name, (unsigned long int)0, (struct anonymous$17 *)(void *)0, 0);
  return (signed int)(return_value_regexec$1 == 0);
}

// log_addlogging_file
// file log.c line 109
void log_addlogging_file(signed int loglevel, const char *filename)
{
  struct _IO_FILE *fp;
  filename=strdup(filename);
  if(filename == ((const char *)NULL))
  {
    log_log(2, "strdup() returned NULL");
    exit(1);
  }

  fp=fopen(filename, "a");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(3, "cannot open logfile (%s) for appending: %s", filename, return_value_strerror$2);
    exit(1);
  }

  addlogging(loglevel, filename, fp);
}

// log_addlogging_none
// file log.c line 136
void log_addlogging_none(void)
{
  addlogging(0, "none", (struct _IO_FILE *)(void *)0);
}

// log_addlogging_syslog
// file log.c line 129
void log_addlogging_syslog(signed int loglevel)
{
  openlog("nslcd", 0x01, 3 << 3);
  addlogging(loglevel, "syslog", (struct _IO_FILE *)(void *)0);
}

// log_clearsession
// file log.h line 51
void log_clearsession(void)
{
  if(!(sessionid == ((char *)NULL)))
    sessionid[(signed long int)0] = (char)0;

  if(!(requestid == ((char *)NULL)))
    requestid[(signed long int)0] = (char)0;

}

// log_log
// file log.h line 59
void log_log(signed int pri, const char *format, ...)
{
  signed int res;
  struct log_cfg *lst;
  char buffer[200l];
  void **ap = (void **)&format;
  res=vsnprintf(buffer, sizeof(char [200l]) /*200ul*/ , format, ap);
  if(res >= (signed int)sizeof(char [200l]) /*200*/  || !(res >= 0))
  {
    buffer[(signed long int)(sizeof(char [200l]) /*200ul*/  - (unsigned long int)2)] = (char)46;
    buffer[(signed long int)(sizeof(char [200l]) /*200ul*/  - (unsigned long int)3)] = (char)46;
    buffer[(signed long int)(sizeof(char [200l]) /*200ul*/  - (unsigned long int)4)] = (char)46;
  }

  buffer[(signed long int)(sizeof(char [200l]) /*200ul*/  - (unsigned long int)1)] = (char)0;
  ap = ((void **)NULL);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  if(prelogging_loglevel >= 0)
  {
    if(prelogging_loglevel >= pri)
    {
      if(!(requestid == ((char *)NULL)))
        tmp_if_expr$2 = (signed int)requestid[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        fprintf(stderr, "%s: [%s] <%s> %s%s\n", (const void *)"nslcd", sessionid, requestid, pri == 7 ? "DEBUG: " : "", (const void *)buffer);

      else
      {
        if(!(sessionid == ((char *)NULL)))
          tmp_if_expr$1 = (signed int)sessionid[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          fprintf(stderr, "%s: [%s] %s%s\n", (const void *)"nslcd", sessionid, pri == 7 ? "DEBUG: " : "", (const void *)buffer);

        else
          fprintf(stderr, "%s: %s%s\n", (const void *)"nslcd", pri == 7 ? "DEBUG: " : "", (const void *)buffer);
      }
    }

  }

  else
  {
    lst = loglist;
    for( ; !(lst == ((struct log_cfg *)NULL)); lst = lst->next)
      if(lst->loglevel >= pri)
      {
        if(lst->fp == ((struct _IO_FILE *)NULL))
        {
          if(!(requestid == ((char *)NULL)))
            tmp_if_expr$4 = (signed int)requestid[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
            syslog(pri, "[%s] <%s> %s%s", sessionid, requestid, pri == 7 ? "DEBUG: " : "", (const void *)buffer);

          else
          {
            if(!(sessionid == ((char *)NULL)))
              tmp_if_expr$3 = (signed int)sessionid[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$3 = (_Bool)0;
            if(tmp_if_expr$3)
              syslog(pri, "[%s] %s%s", sessionid, pri == 7 ? "DEBUG: " : "", (const void *)buffer);

            else
              syslog(pri, "%s%s", pri == 7 ? "DEBUG: " : "", (const void *)buffer);
          }
        }

        else
        {
          if(!(requestid == ((char *)NULL)))
            tmp_if_expr$6 = (signed int)requestid[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$6 = (_Bool)0;
          if(tmp_if_expr$6)
            fprintf(lst->fp, "%s: [%s] <%s> %s%s\n", (const void *)"nslcd", sessionid, requestid, pri == 7 ? "DEBUG: " : "", (const void *)buffer);

          else
          {
            if(!(sessionid == ((char *)NULL)))
              tmp_if_expr$5 = (signed int)sessionid[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$5 = (_Bool)0;
            if(tmp_if_expr$5)
              fprintf(lst->fp, "%s: [%s] %s%s\n", (const void *)"nslcd", sessionid, pri == 7 ? "DEBUG: " : "", (const void *)buffer);

            else
              fprintf(lst->fp, "%s: %s%s\n", (const void *)"nslcd", pri == 7 ? "DEBUG: " : "", (const void *)buffer);
          }
          fflush(lst->fp);
        }
      }

  }
}

// log_log_config
// file log.c line 321
void log_log_config(void)
{
  struct log_cfg *lst = loglist;
  const char *return_value_loglevel2str$1;
  for( ; !(lst == ((struct log_cfg *)NULL)); lst = lst->next)
    if(lst->loglevel == 0)
      log_log(7, "CFG: log %s", lst->scheme);

    else
    {
      return_value_loglevel2str$1=loglevel2str(lst->loglevel);
      log_log(7, "CFG: log %s %s", lst->scheme, return_value_loglevel2str$1);
    }
}

// log_newsession
// file log.h line 47
void log_newsession(void)
{
  if(sessionid == ((char *)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)7);
    sessionid = (char *)return_value_malloc$1;
    if(sessionid == ((char *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      fprintf(stderr, "malloc() failed: %s", return_value_strerror$3);
      goto __CPROVER_DUMP_L4;
    }

  }

  signed int return_value_rand$4;
  return_value_rand$4=rand();
  sprintf(sessionid, "%06x", (signed int)(return_value_rand$4 & 0xffffff));
  if(!(requestid == ((char *)NULL)))
    requestid[(signed long int)0] = (char)0;


__CPROVER_DUMP_L4:
  ;
}

// log_setdefaultloglevel
// file log.h line 30
void log_setdefaultloglevel(signed int loglevel)
{
  prelogging_loglevel = loglevel;
}

// log_setrequest
// file log.c line 200
void log_setrequest(const char *format, ...)
{
  void **ap;
  if(requestid == ((char *)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)40);
    requestid = (char *)return_value_malloc$1;
    if(requestid == ((char *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      fprintf(stderr, "malloc() failed: %s", return_value_strerror$3);
      goto __CPROVER_DUMP_L3;
    }

  }

  ap = (void **)&format;
  vsnprintf(requestid, (unsigned long int)40, format, ap);
  requestid[(signed long int)(40 - 1)] = (char)0;
  ap = ((void **)NULL);

__CPROVER_DUMP_L3:
  ;
}

// log_startlogging
// file log.h line 43
void log_startlogging(void)
{
  if(loglist == ((struct log_cfg *)NULL))
    log_addlogging_syslog(6);

  prelogging_loglevel = -1;
}

// loglevel2str
// file log.c line 306
static const char * loglevel2str(signed int loglevel)
{
  switch(loglevel)
  {
    case 2:
      return "crit";
    case 3:
      return "error";
    case 4:
      return "warning";
    case 5:
      return "notice";
    case 6:
      return "info";
    case 7:
      return "debug";
    default:
      return "???";
  }
}

// lookup_dn2uid
// file passwd.c line 219
char * lookup_dn2uid(struct ldap_session *session, const char *dn, signed int *rcp, char *buf, unsigned long int buflen)
{
  struct myldap_search *search;
  struct myldap_entry *entry;
  signed int rc = 0x00;
  const char **values;
  char *uid = (char *)(void *)0;
  if(rcp == ((signed int *)NULL))
    rcp = &rc;

  static const char *attrs[3l];
  attrs[(signed long int)0] = attmap_passwd_uid;
  attrs[(signed long int)1] = attmap_passwd_uidNumber;
  attrs[(signed long int)2] = (const char *)(void *)0;
  search=myldap_search(session, dn, (signed int)0x0000, passwd_filter, attrs, rcp);
  if(search == ((struct myldap_search *)NULL))
  {
    char *return_value_ldap_err2string$1;
    return_value_ldap_err2string$1=ldap_err2string(*rcp);
    log_log(4, "%s: lookup error: %s", dn, return_value_ldap_err2string$1);
    return (char *)(void *)0;
  }

  entry=myldap_get_entry(search, rcp);
  char *return_value_ldap_err2string$2;
  if(entry == ((struct myldap_entry *)NULL))
  {
    if(!(*rcp == 0x00))
    {
      return_value_ldap_err2string$2=ldap_err2string(*rcp);
      log_log(4, "%s: lookup error: %s", dn, return_value_ldap_err2string$2);
    }

    return (char *)(void *)0;
  }

  signed int return_value_entry_has_valid_uid$5;
  return_value_entry_has_valid_uid$5=entry_has_valid_uid(entry);
  signed int return_value_isvalidname$4;
  unsigned long int return_value_strlen$3;
  if(!(return_value_entry_has_valid_uid$5 == 0))
  {
    values=myldap_get_values(entry, attmap_passwd_uid);
    if(!(values == ((const char **)NULL)))
    {
      if(!(*values == ((const char *)NULL)))
      {
        return_value_isvalidname$4=isvalidname(values[(signed long int)0]);
        if(!(return_value_isvalidname$4 == 0))
        {
          return_value_strlen$3=strlen(values[(signed long int)0]);
          if(!(return_value_strlen$3 >= buflen))
          {
            strcpy(buf, values[(signed long int)0]);
            uid = buf;
          }

        }

      }

    }

  }

  myldap_search_close(search);
  return uid;
}

// main
// file nslcd.c line 672
signed int main(signed int argc, char **argv)
{
  signed int i;
  struct anonymous$5 signalmask;
  struct anonymous$5 oldmask;
  struct timespec ts;
  sigemptyset(&signalmask);
  sigaddset(&signalmask, 1);
  sigaddset(&signalmask, 2);
  sigaddset(&signalmask, 3);
  sigaddset(&signalmask, 6);
  sigaddset(&signalmask, 13);
  sigaddset(&signalmask, 15);
  sigaddset(&signalmask, 10);
  sigaddset(&signalmask, 12);
  pthread_sigmask(0, &signalmask, &oldmask);
  daemonize_closefds();
  parse_cmdline(argc, argv);
  signed int return_value_clearenv$1;
  return_value_clearenv$1=clearenv();
  _Bool tmp_if_expr$3;
  signed int return_value_putenv$2;
  if(!(return_value_clearenv$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_putenv$2=putenv("HOME=/");
    tmp_if_expr$3 = return_value_putenv$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  signed int return_value_putenv$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_putenv$4=putenv("TMPDIR=/tmp");
    tmp_if_expr$5 = return_value_putenv$4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_putenv$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_putenv$6=putenv("LDAPNOINIT=1");
    tmp_if_expr$7 = return_value_putenv$6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
  {
    log_log(3, "clearing environment failed");
    exit(1);
  }

  disable_nss_ldap();
  signed int return_value_myldap_set_debuglevel$8;
  return_value_myldap_set_debuglevel$8=myldap_set_debuglevel(nslcd_debugging);
  if(!(return_value_myldap_set_debuglevel$8 == 0x00))
    exit(1);

  cfg_init("/etc/nslcd.conf");
  umask((unsigned int)0022);
  if(!(nslcd_checkonly == 0))
  {
    signed int return_value_is_locked$9;
    return_value_is_locked$9=is_locked("/var/run/nslcd/nslcd.pid");
    if(!(return_value_is_locked$9 == 0))
    {
      log_log(7, "pidfile (%s) is locked", (const void *)"/var/run/nslcd/nslcd.pid");
      exit(0);
    }

    else
    {
      log_log(7, "pidfile (%s) is not locked", (const void *)"/var/run/nslcd/nslcd.pid");
      exit(1);
    }
  }

  signed int return_value_chdir$12;
  return_value_chdir$12=chdir("/");
  if(!(return_value_chdir$12 == 0))
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    char *return_value_strerror$11;
    return_value_strerror$11=strerror(*return_value___errno_location$10);
    log_log(3, "chdir failed: %s", return_value_strerror$11);
    exit(1);
  }

  signed int return_value_is_locked$15;
  return_value_is_locked$15=is_locked("/var/run/nslcd/nslcd.pid");
  if(!(return_value_is_locked$15 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    char *return_value_strerror$14;
    return_value_strerror$14=strerror(*return_value___errno_location$13);
    log_log(3, "nslcd may already be active, cannot acquire lock (%s): %s", (const void *)"/var/run/nslcd/nslcd.pid", return_value_strerror$14);
    exit(1);
  }

  if(nslcd_debugging == 0 && nslcd_nofork == 0)
  {
    signed int *return_value___errno_location$16;
    return_value___errno_location$16=__errno_location();
    *return_value___errno_location$16 = 0;
    signed int return_value_daemonize_daemon$19;
    return_value_daemonize_daemon$19=daemonize_daemon();
    if(!(return_value_daemonize_daemon$19 == 0))
    {
      signed int *return_value___errno_location$17;
      return_value___errno_location$17=__errno_location();
      char *return_value_strerror$18;
      return_value_strerror$18=strerror(*return_value___errno_location$17);
      log_log(3, "unable to daemonize: %s", return_value_strerror$18);
      exit(1);
    }

  }

  if(nslcd_debugging == 0)
  {
    daemonize_redirect_stdio();
    log_startlogging();
  }

  create_pidfile("/var/run/nslcd/nslcd.pid");
  log_log(6, "version %s starting", (const void *)"0.9.6");
  signed int return_value_atexit$22;
  return_value_atexit$22=atexit(exithandler);
  if(!(return_value_atexit$22 == 0))
  {
    signed int *return_value___errno_location$20;
    return_value___errno_location$20=__errno_location();
    char *return_value_strerror$21;
    return_value_strerror$21=strerror(*return_value___errno_location$20);
    log_log(3, "atexit() failed: %s", return_value_strerror$21);
    daemonize_ready(1, "atexit() failed\n");
    exit(1);
  }

  adjust_oom_score();
  nslcd_serversocket=create_socket("/var/run/nslcd/socket");
  i = 0;
  for( ; !(i >= LM_NONE); i = i + 1)
    if(!(nslcd_cfg->reconnect_invalidate[(signed long int)i] == 0))
      break;

  if(!(i >= LM_NONE))
    invalidator_start();

  signed int *return_value___errno_location$23;
  char *return_value_strerror$24;
  if(!(nslcd_cfg->gid == 4294967295u))
  {
    if(!(nslcd_cfg->uidname == ((char *)NULL)))
    {
      signed int return_value_initgroups$25;
      return_value_initgroups$25=initgroups(nslcd_cfg->uidname, nslcd_cfg->gid);
      if(!(return_value_initgroups$25 >= 0))
      {
        return_value___errno_location$23=__errno_location();
        return_value_strerror$24=strerror(*return_value___errno_location$23);
        log_log(4, "cannot initgroups(\"%s\",%lu) (ignored): %s", nslcd_cfg->uidname, (unsigned long int)nslcd_cfg->gid, return_value_strerror$24);
      }

      else
        log_log(7, "initgroups(\"%s\",%lu) done", nslcd_cfg->uidname, (unsigned long int)nslcd_cfg->gid);
    }

  }

  if(!(nslcd_cfg->gid == 4294967295u))
  {
    signed int return_value_setgid$28;
    return_value_setgid$28=setgid(nslcd_cfg->gid);
    if(!(return_value_setgid$28 == 0))
    {
      signed int *return_value___errno_location$26;
      return_value___errno_location$26=__errno_location();
      char *return_value_strerror$27;
      return_value_strerror$27=strerror(*return_value___errno_location$26);
      log_log(3, "cannot setgid(%lu): %s", (unsigned long int)nslcd_cfg->gid, return_value_strerror$27);
      daemonize_ready(1, "cannot setgid()\n");
      exit(1);
    }

    log_log(7, "setgid(%lu) done", (unsigned long int)nslcd_cfg->gid);
  }

  if(!(nslcd_cfg->uid == 4294967295u))
  {
    signed int return_value_setuid$31;
    return_value_setuid$31=setuid(nslcd_cfg->uid);
    if(!(return_value_setuid$31 == 0))
    {
      signed int *return_value___errno_location$29;
      return_value___errno_location$29=__errno_location();
      char *return_value_strerror$30;
      return_value_strerror$30=strerror(*return_value___errno_location$29);
      log_log(3, "cannot setuid(%lu): %s", (unsigned long int)nslcd_cfg->uid, return_value_strerror$30);
      daemonize_ready(1, "cannot setuid()\n");
      exit(1);
    }

    log_log(7, "setuid(%lu) done", (unsigned long int)nslcd_cfg->uid);
  }

  log_log(6, "accepting connections");
  void *return_value_malloc$32;
  return_value_malloc$32=malloc((unsigned long int)nslcd_cfg->threads * sizeof(unsigned long int) /*8ul*/ );
  nslcd_threads = (unsigned long int *)return_value_malloc$32;
  if(nslcd_threads == ((unsigned long int *)NULL))
  {
    log_log(2, "main(): malloc() failed to allocate memory");
    daemonize_ready(1, "malloc() failed to allocate memory\n");
    exit(1);
  }

  i = 0;
  for( ; !(i >= nslcd_cfg->threads); i = i + 1)
  {
    signed int return_value_pthread_create$35;
    return_value_pthread_create$35=pthread_create(&nslcd_threads[(signed long int)i], (const union pthread_attr_t *)(void *)0, worker, (void *)0);
    if(!(return_value_pthread_create$35 == 0))
    {
      signed int *return_value___errno_location$33;
      return_value___errno_location$33=__errno_location();
      char *return_value_strerror$34;
      return_value_strerror$34=strerror(*return_value___errno_location$33);
      log_log(3, "unable to start worker thread %d: %s", i, return_value_strerror$34);
      daemonize_ready(1, "unable to start worker thread\n");
      exit(1);
    }

  }
  install_sighandler(1, sig_handler);
  install_sighandler(2, sig_handler);
  install_sighandler(3, sig_handler);
  install_sighandler(6, sig_handler);
  install_sighandler(13, (void (*)(signed int))1);
  install_sighandler(15, sig_handler);
  install_sighandler(10, sig_handler);
  install_sighandler(12, (void (*)(signed int))1);
  daemonize_ready(0, (const char *)(void *)0);
  pthread_sigmask(2, &oldmask, (struct anonymous$5 *)(void *)0);
  while(nslcd_receivedsignal == 0 || nslcd_receivedsignal == 10)
  {
    sleep((unsigned int)0x7fffffff);
    if(nslcd_receivedsignal == 10)
    {
      const char *return_value_signame$36;
      return_value_signame$36=signame(nslcd_receivedsignal);
      log_log(6, "caught signal %s (%d), refresh retries", return_value_signame$36, nslcd_receivedsignal);
      myldap_immediate_reconnect();
      nslcd_receivedsignal = 0;
    }

  }
  const char *return_value_signame$37;
  return_value_signame$37=signame(nslcd_receivedsignal);
  log_log(6, "caught signal %s (%d), shutting down", return_value_signame$37, nslcd_receivedsignal);
  i = 0;
  signed int return_value_pthread_cancel$40;
  signed int *return_value___errno_location$38;
  char *return_value_strerror$39;
  for( ; !(i >= nslcd_cfg->threads); i = i + 1)
  {
    return_value_pthread_cancel$40=pthread_cancel(nslcd_threads[(signed long int)i]);
    if(!(return_value_pthread_cancel$40 == 0))
    {
      return_value___errno_location$38=__errno_location();
      return_value_strerror$39=strerror(*return_value___errno_location$38);
      log_log(4, "failed to stop thread %d (ignored): %s", i, return_value_strerror$39);
    }

  }
  close(nslcd_serversocket);
  nslcd_serversocket = -1;
  signed long int return_value_time$41;
  return_value_time$41=time((signed long int *)(void *)0);
  ts.tv_sec = return_value_time$41 + (signed long int)3;
  ts.tv_nsec = (signed long int)0;
  i = 0;
  for( ; !(i >= nslcd_cfg->threads); i = i + 1)
  {
    pthread_timedjoin_np(nslcd_threads[(signed long int)i], (void **)(void *)0, &ts);
    signed int return_value_pthread_kill$42;
    return_value_pthread_kill$42=pthread_kill(nslcd_threads[(signed long int)i], 0);
    if(return_value_pthread_kill$42 == 0)
      log_log(3, "thread %d is still running, shutting down anyway", i);

  }
  return 1;
}

// map2name
// file invalidator.c line 43
static const char * map2name(enum ldap_map_selector map)
{
  switch((signed int)map)
  {
    case LM_ALIASES:
      return "aliases";
    case LM_ETHERS:
      return "ethers";
    case LM_GROUP:
      return "group";
    case LM_HOSTS:
      return "hosts";
    case LM_NETGROUP:
      return "netgroup";
    case LM_NETWORKS:
      return "networks";
    case LM_PASSWD:
      return "passwd";
    case LM_PROTOCOLS:
      return "protocols";
    case LM_RPC:
      return "rpc";
    case LM_SERVICES:
      return "services";
    case LM_SHADOW:
      return "shadow";
    case LM_NFSIDMAP:
      return "nfsidmap";
    case LM_NONE:

    default:
      return (const char *)(void *)0;
  }
}

// mkdirname
// file nslcd.c line 227
static void mkdirname(const char *filename)
{
  char *tmpname;
  char *path;
  tmpname=strdup(filename);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(!(tmpname == ((char *)NULL)))
  {
    path=dirname(tmpname);
    signed int return_value_mkdir$4;
    return_value_mkdir$4=mkdir(path, (unsigned int)0755);
    if(return_value_mkdir$4 == 0)
    {
      signed int return_value_lchown$3;
      return_value_lchown$3=lchown(path, nslcd_cfg->uid, nslcd_cfg->gid);
      if(!(return_value_lchown$3 >= 0))
      {
        return_value___errno_location$1=__errno_location();
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        log_log(4, "problem setting permissions for %s: %s", path, return_value_strerror$2);
      }

    }

    free((void *)tmpname);
  }

}

// mkfilter_alias_byname
// file alias.c line 64
static signed int mkfilter_alias_byname(const char *name, char *buffer, unsigned long int buflen)
{
  char safename[300l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(name, safename, sizeof(char [300l]) /*300ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_alias_byname(): safename buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", alias_filter, attmap_alias_cn, (const void *)safename);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_ether_byether
// file ether.c line 81
static signed int mkfilter_ether_byether(const char *addrstr, char *buffer, unsigned long int buflen)
{
  signed int return_value_mysnprintf$1;
  return_value_mysnprintf$1=mysnprintf(buffer, buflen, "(&%s(%s=%s))", ether_filter, attmap_ether_macAddress, addrstr);
  return return_value_mysnprintf$1;
}

// mkfilter_ether_byname
// file ether.c line 66
static signed int mkfilter_ether_byname(const char *name, char *buffer, unsigned long int buflen)
{
  char safename[65l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(name, safename, sizeof(char [65l]) /*65ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_ether_byname(): safename buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", ether_filter, attmap_ether_cn, (const void *)safename);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_group_bygid
// file group.c line 108
static signed int mkfilter_group_bygid(unsigned int gid, char *buffer, unsigned long int buflen)
{
  signed int return_value_mysnprintf$1;
  if(!(gidSid == ((char *)NULL)))
  {
    if(max_builtin_rid >= gid && gid >= min_builtin_rid)
    {
      return_value_mysnprintf$1=mysnprintf(buffer, buflen, "(&%s(%s=%s\\%02x\\%02x\\%02x\\%02x))", group_filter, attmap_group_gidNumber, builtinSid, (signed int)(gid & (unsigned int)0xff), (signed int)(gid >> 8 & (unsigned int)0xff), (signed int)(gid >> 16 & (unsigned int)0xff), (signed int)(gid >> 24 & (unsigned int)0xff));
      return return_value_mysnprintf$1;
    }

    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s\\%02x\\%02x\\%02x\\%02x))", group_filter, attmap_group_gidNumber, gidSid, (signed int)(gid & (unsigned int)0xff), (signed int)(gid >> 8 & (unsigned int)0xff), (signed int)(gid >> 16 & (unsigned int)0xff), (signed int)(gid >> 24 & (unsigned int)0xff));
    return return_value_mysnprintf$2;
  }

  else
  {
    signed int return_value_mysnprintf$3;
    return_value_mysnprintf$3=mysnprintf(buffer, buflen, "(&%s(%s=%lu))", group_filter, attmap_group_gidNumber, (unsigned long int)gid);
    return return_value_mysnprintf$3;
  }
}

// mkfilter_group_bymember
// file group.c line 133
static signed int mkfilter_group_bymember(struct ldap_session *session, const char *uid, char *buffer, unsigned long int buflen)
{
  char dn[512l];
  char safeuid[300l];
  char safedn[600l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(uid, safeuid, sizeof(char [300l]) /*300ul*/ );
  _Bool tmp_if_expr$5;
  char *return_value_uid2dn$4;
  signed int return_value_mysnprintf$2;
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_group_bymember(): safeuid buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_strcasecmp$3;
    return_value_strcasecmp$3=strcasecmp(attmap_group_member, "\"\"");
    if(return_value_strcasecmp$3 == 0)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_uid2dn$4=uid2dn(session, uid, dn, sizeof(char [512l]) /*512ul*/ );
      tmp_if_expr$5 = return_value_uid2dn$4 == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
    {
      return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", group_filter, attmap_group_memberUid, (const void *)safeuid);
      return return_value_mysnprintf$2;
    }

    else
    {
      signed int return_value_myldap_escape$6;
      return_value_myldap_escape$6=myldap_escape(dn, safedn, sizeof(char [600l]) /*600ul*/ );
      if(!(return_value_myldap_escape$6 == 0))
      {
        log_log(3, "mkfilter_group_bymember(): safedn buffer too small");
        return -1;
      }

      else
      {
        signed int return_value_mysnprintf$7;
        return_value_mysnprintf$7=mysnprintf(buffer, buflen, "(&%s(|(%s=%s)(%s=%s)))", group_filter, attmap_group_memberUid, (const void *)safeuid, attmap_group_member, (const void *)safedn);
        return return_value_mysnprintf$7;
      }
    }
  }
}

// mkfilter_group_bymemberdn
// file group.c line 164
static signed int mkfilter_group_bymemberdn(const char *dn, char *buffer, unsigned long int buflen)
{
  char safedn[600l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(dn, safedn, sizeof(char [600l]) /*600ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_group_bymemberdn(): safedn buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", group_filter, attmap_group_member, (const void *)safedn);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_group_byname
// file group.c line 91
static signed int mkfilter_group_byname(const char *name, char *buffer, unsigned long int buflen)
{
  char safename[300l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(name, safename, sizeof(char [300l]) /*300ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_group_byname(): safename buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", group_filter, attmap_group_cn, (const void *)safename);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_host_byaddr
// file host.c line 81
static signed int mkfilter_host_byaddr(const char *addrstr, char *buffer, unsigned long int buflen)
{
  char safeaddr[64l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(addrstr, safeaddr, sizeof(char [64l]) /*64ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_host_byaddr(): safeaddr buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", host_filter, attmap_host_ipHostNumber, (const void *)safeaddr);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_host_byname
// file host.c line 67
static signed int mkfilter_host_byname(const char *name, char *buffer, unsigned long int buflen)
{
  char safename[65l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(name, safename, sizeof(char [65l]) /*65ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_host_byname(): safename buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", host_filter, attmap_host_cn, (const void *)safename);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_netgroup_byname
// file netgroup.c line 65
static signed int mkfilter_netgroup_byname(const char *name, char *buffer, unsigned long int buflen)
{
  char safename[300l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(name, safename, sizeof(char [300l]) /*300ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_netgroup_byname(): safename buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", netgroup_filter, attmap_netgroup_cn, (const void *)safename);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_network_byaddr
// file network.c line 80
static signed int mkfilter_network_byaddr(const char *addrstr, char *buffer, unsigned long int buflen)
{
  char safeaddr[64l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(addrstr, safeaddr, sizeof(char [64l]) /*64ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_network_byaddr(): safeaddr buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", network_filter, attmap_network_ipNetworkNumber, (const void *)safeaddr);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_network_byname
// file network.c line 65
static signed int mkfilter_network_byname(const char *name, char *buffer, unsigned long int buflen)
{
  char safename[65l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(name, safename, sizeof(char [65l]) /*65ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_network_byname(): safename buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", network_filter, attmap_network_cn, (const void *)safename);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_passwd_byname
// file passwd.c line 87
static signed int mkfilter_passwd_byname(const char *name, char *buffer, unsigned long int buflen)
{
  char safename[300l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(name, safename, sizeof(char [300l]) /*300ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_passwd_byname(): safename buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", passwd_filter, attmap_passwd_uid, (const void *)safename);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_passwd_byuid
// file passwd.c line 104
static signed int mkfilter_passwd_byuid(unsigned int uid, char *buffer, unsigned long int buflen)
{
  if(!(uidSid == ((char *)NULL)))
  {
    signed int return_value_mysnprintf$1;
    return_value_mysnprintf$1=mysnprintf(buffer, buflen, "(&%s(%s=%s\\%02x\\%02x\\%02x\\%02x))", passwd_filter, attmap_passwd_uidNumber, uidSid, (signed int)(uid & (unsigned int)0xff), (signed int)(uid >> 8 & (unsigned int)0xff), (signed int)(uid >> 16 & (unsigned int)0xff), (signed int)(uid >> 24 & (unsigned int)0xff));
    return return_value_mysnprintf$1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%lu))", passwd_filter, attmap_passwd_uidNumber, (unsigned long int)uid);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_protocol_byname
// file protocol.c line 65
static signed int mkfilter_protocol_byname(const char *name, char *buffer, unsigned long int buflen)
{
  char safename[300l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(name, safename, sizeof(char [300l]) /*300ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_protocol_byname(): safename buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", protocol_filter, attmap_protocol_cn, (const void *)safename);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_protocol_bynumber
// file protocol.c line 82
static signed int mkfilter_protocol_bynumber(signed int protocol, char *buffer, unsigned long int buflen)
{
  signed int return_value_mysnprintf$1;
  return_value_mysnprintf$1=mysnprintf(buffer, buflen, "(&%s(%s=%d))", protocol_filter, attmap_protocol_ipProtocolNumber, protocol);
  return return_value_mysnprintf$1;
}

// mkfilter_rpc_byname
// file rpc.c line 67
static signed int mkfilter_rpc_byname(const char *name, char *buffer, unsigned long int buflen)
{
  char safename[300l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(name, safename, sizeof(char [300l]) /*300ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_rpc_byname(): safename buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", rpc_filter, attmap_rpc_cn, (const void *)safename);
    return return_value_mysnprintf$2;
  }
}

// mkfilter_rpc_bynumber
// file rpc.c line 81
static signed int mkfilter_rpc_bynumber(signed int number, char *buffer, unsigned long int buflen)
{
  signed int return_value_mysnprintf$1;
  return_value_mysnprintf$1=mysnprintf(buffer, buflen, "(&%s(%s=%d))", rpc_filter, attmap_rpc_oncRpcNumber, number);
  return return_value_mysnprintf$1;
}

// mkfilter_service_byname
// file service.c line 68
static signed int mkfilter_service_byname(const char *name, const char *protocol, char *buffer, unsigned long int buflen)
{
  char safename[300l];
  char safeprotocol[300l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(name, safename, sizeof(char [300l]) /*300ul*/ );
  signed int return_value_mysnprintf$4;
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_service_byname(): safename buffer too small");
    return -1;
  }

  else
    if(!((signed int)*protocol == 0))
    {
      signed int return_value_myldap_escape$2;
      return_value_myldap_escape$2=myldap_escape(protocol, safeprotocol, sizeof(char [300l]) /*300ul*/ );
      if(!(return_value_myldap_escape$2 == 0))
      {
        log_log(3, "mkfilter_service_byname(): safeprotocol buffer too small");
        return -1;
      }

      signed int return_value_mysnprintf$3;
      return_value_mysnprintf$3=mysnprintf(buffer, buflen, "(&%s(%s=%s)(%s=%s))", service_filter, attmap_service_cn, (const void *)safename, attmap_service_ipServiceProtocol, (const void *)safeprotocol);
      return return_value_mysnprintf$3;
    }

    else
    {
      return_value_mysnprintf$4=mysnprintf(buffer, buflen, "(&%s(%s=%s))", service_filter, attmap_service_cn, (const void *)safename);
      return return_value_mysnprintf$4;
    }
}

// mkfilter_service_bynumber
// file service.c line 95
static signed int mkfilter_service_bynumber(signed int number, const char *protocol, char *buffer, unsigned long int buflen)
{
  char safeprotocol[300l];
  signed int return_value_mysnprintf$3;
  if(!((signed int)*protocol == 0))
  {
    signed int return_value_myldap_escape$1;
    return_value_myldap_escape$1=myldap_escape(protocol, safeprotocol, sizeof(char [300l]) /*300ul*/ );
    if(!(return_value_myldap_escape$1 == 0))
    {
      log_log(3, "mkfilter_service_bynumber(): safeprotocol buffer too small");
      return -1;
    }

    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%d)(%s=%s))", service_filter, attmap_service_ipServicePort, number, attmap_service_ipServiceProtocol, (const void *)safeprotocol);
    return return_value_mysnprintf$2;
  }

  else
  {
    return_value_mysnprintf$3=mysnprintf(buffer, buflen, "(&%s(%s=%d))", service_filter, attmap_service_ipServicePort, number);
    return return_value_mysnprintf$3;
  }
}

// mkfilter_shadow_byname
// file shadow.c line 73
static signed int mkfilter_shadow_byname(const char *name, char *buffer, unsigned long int buflen)
{
  char safename[300l];
  signed int return_value_myldap_escape$1;
  return_value_myldap_escape$1=myldap_escape(name, safename, sizeof(char [300l]) /*300ul*/ );
  if(!(return_value_myldap_escape$1 == 0))
  {
    log_log(3, "mkfilter_shadow_byname(): safename buffer too small");
    return -1;
  }

  else
  {
    signed int return_value_mysnprintf$2;
    return_value_mysnprintf$2=mysnprintf(buffer, buflen, "(&%s(%s=%s))", shadow_filter, attmap_shadow_uid, (const void *)safename);
    return return_value_mysnprintf$2;
  }
}

// my_isalpha
// file expr.c line 36
static inline signed int my_isalpha(const char c)
{
  return (signed int)((signed int)c >= 97 && (signed int)c <= 122 || (signed int)c >= 65 && (signed int)c <= 90);
}

// my_isalphanum
// file expr.c line 41
static inline signed int my_isalphanum(const char c)
{
  signed int return_value_my_isalpha$1;
  return_value_my_isalpha$1=my_isalpha(c);
  return (signed int)(return_value_my_isalpha$1 != 0 ? (_Bool)1 : ((signed int)c >= 48 && (signed int)c <= 57 ? (_Bool)1 : (_Bool)0));
}

// myldap_cpy_dn
// file myldap.c line 1704
char * myldap_cpy_dn(struct myldap_entry *entry, char *buf, unsigned long int buflen)
{
  const char *dn;
  dn=myldap_get_dn(entry);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(dn);
  if(!(return_value_strlen$1 >= buflen))
    strcpy(buf, dn);

  else
    buf = (char *)(void *)0;
  return buf;
}

// myldap_cpy_rdn_value
// file myldap.c line 2094
const char * myldap_cpy_rdn_value(const char *dn, const char *attr, char *buf, unsigned long int buflen)
{
  char **exploded_rdn;
  const char *value;
  exploded_rdn=get_exploded_rdn(dn);
  _Bool tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(exploded_rdn == ((char **)NULL))
    return (const char *)(void *)0;

  else
  {
    value=find_rdn_value(exploded_rdn, attr);
    if(!(value == ((const char *)NULL)))
    {
      return_value_strlen$1=strlen(value);
      tmp_if_expr$2 = return_value_strlen$1 < buflen ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      strcpy(buf, value);

    else
      value = (const char *)(void *)0;
    ldap_value_free(exploded_rdn);
    return value != (const char *)(void *)0 ? buf : (char *)(void *)0;
  }
}

// myldap_create_session
// file myldap.h line 69
struct ldap_session * myldap_create_session(void)
{
  struct ldap_session *return_value_myldap_session_new$1;
  return_value_myldap_session_new$1=myldap_session_new();
  return return_value_myldap_session_new$1;
}

// myldap_entry_free
// file myldap.c line 216
static void myldap_entry_free(struct myldap_entry *entry)
{
  signed int i;
  if(!(entry->dn == ((const char *)NULL)))
    ldap_memfree((void *)(char *)entry->dn);

  if(!(entry->exploded_rdn == ((char **)NULL)))
    ldap_value_free(entry->exploded_rdn);

  i = 0;
  for( ; !(i >= 16); i = i + 1)
    if(!(entry->attributevalues[(signed long int)i] == ((char **)NULL)))
      ldap_value_free(entry->attributevalues[(signed long int)i]);

  i = 0;
  for( ; !(i >= 8); i = i + 1)
    if(!(entry->buffers[(signed long int)i] == ((char **)NULL)))
      free((void *)entry->buffers[(signed long int)i]);

  ldap_msgfree(entry->search->msg);
  entry->search->msg = (struct ldapmsg *)(void *)0;
  free((void *)entry);
}

// myldap_entry_new
// file myldap.c line 191
static struct myldap_entry * myldap_entry_new(struct myldap_search *search)
{
  struct myldap_entry *entry;
  signed int i;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct myldap_entry) /*216ul*/ );
  entry = (struct myldap_entry *)return_value_malloc$1;
  if(entry == ((struct myldap_entry *)NULL))
  {
    log_log(2, "myldap_entry_new(): malloc() failed to allocate memory");
    exit(1);
  }

  entry->search = search;
  entry->dn = (const char *)(void *)0;
  entry->exploded_rdn = (char **)(void *)0;
  i = 0;
  for( ; !(i >= 16); i = i + 1)
    entry->attributevalues[(signed long int)i] = (char **)(void *)0;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    entry->buffers[(signed long int)i] = (char **)(void *)0;
  return entry;
}

// myldap_err
// file myldap.c line 157
static void myldap_err(signed int pri, struct ldap *ld, signed int rc, const char *format, ...)
{
  char message[1024l];
  char *msg_ldap = (char *)(void *)0;
  char *msg_diag = (char *)(void *)0;
  char *msg_errno = (char *)(void *)0;
  void **ap = (void **)&format;
  vsnprintf(message, sizeof(char [1024l]) /*1024ul*/ , format, ap);
  message[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
  ap = ((void **)NULL);
  if(!(rc == 0x00))
  {
    msg_ldap=ldap_err2string(rc);
    if(!(ld == ((struct ldap *)NULL)))
      ldap_get_option(ld, 0x0032, (void *)&msg_diag);

  }

  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  signed int *return_value___errno_location$1;
  if(!(*return_value___errno_location$2 == 0))
  {
    return_value___errno_location$1=__errno_location();
    msg_errno=strerror(*return_value___errno_location$1);
  }

  log_log(pri, "%s%s%s%s%s%s%s", (const void *)message, msg_ldap == (char *)(void *)0 ? "" : ": ", msg_ldap == (char *)(void *)0 ? "" : msg_ldap, msg_diag == (char *)(void *)0 ? "" : ": ", msg_diag == (char *)(void *)0 ? "" : msg_diag, msg_errno == (char *)(void *)0 ? "" : ": ", msg_errno == (char *)(void *)0 ? "" : msg_errno);
  if(!(msg_diag == ((char *)NULL)))
    ldap_memfree((void *)msg_diag);

}

// myldap_error_message
// file myldap.c line 2428
signed int myldap_error_message(struct ldap_session *session, signed int rc, char *buffer, unsigned long int buflen)
{
  char *msg_diag = (char *)(void *)0;
  if(buffer == ((char *)NULL) || session == ((struct ldap_session *)NULL) || !(buflen >= 1ul))
  {
    log_log(3, "myldap_error_message(): invalid parameter passed");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return 0x50;
  }

  buffer[(signed long int)0] = (char)0;
  if(!(session->ld == ((struct ldap *)NULL)))
    ldap_get_option(session->ld, 0x0032, (void *)&msg_diag);

  _Bool tmp_if_expr$2;
  if(!(msg_diag == ((char *)NULL)))
    tmp_if_expr$2 = (signed int)msg_diag[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  char *tmp_if_expr$4;
  char *return_value_ldap_err2string$3;
  if(tmp_if_expr$2)
    tmp_if_expr$4 = msg_diag;

  else
  {
    return_value_ldap_err2string$3=ldap_err2string(rc);
    tmp_if_expr$4 = return_value_ldap_err2string$3;
  }
  mysnprintf(buffer, buflen - (unsigned long int)1, "%s", tmp_if_expr$4);
  if(!(msg_diag == ((char *)NULL)))
    ldap_memfree((void *)msg_diag);

  return 0x00;
}

// myldap_escape
// file myldap.c line 2285
signed int myldap_escape(const char *src, char *buffer, unsigned long int buflen)
{
  unsigned long int pos = (unsigned long int)0;
  unsigned long int tmp_post$1;
  for( ; !((signed int)*src == 0); src = src + 1l)
  {
    if(4ul + pos >= buflen)
      return -1;

    switch((signed int)*src)
    {
      case 42:
      {
        strcpy(buffer + (signed long int)pos, "\\2a");
        pos = pos + (unsigned long int)3;
        break;
      }
      case 40:
      {
        strcpy(buffer + (signed long int)pos, "\\28");
        pos = pos + (unsigned long int)3;
        break;
      }
      case 41:
      {
        strcpy(buffer + (signed long int)pos, "\\29");
        pos = pos + (unsigned long int)3;
        break;
      }
      case 92:
      {
        strcpy(buffer + (signed long int)pos, "\\5c");
        pos = pos + (unsigned long int)3;
        break;
      }
      default:
      {
        tmp_post$1 = pos;
        pos = pos + 1ul;
        buffer[(signed long int)tmp_post$1] = *src;
      }
    }
  }
  buffer[(signed long int)pos] = (char)0;
  return 0;
}

// myldap_get_deref_values
// file myldap.c line 2138
const char *** myldap_get_deref_values(struct myldap_entry *entry, const char *derefattr, const char *getattr)
{
  struct ldapcontrol **entryctrls;
  struct LDAPDerefRes *deref;
  struct LDAPDerefRes *d;
  struct LDAPDerefVal *a;
  signed int i;
  signed int pass;
  signed int rc;
  signed int found;
  signed int counts[2l];
  unsigned long int sizes[2l];
  unsigned long int size;
  char *buffer = (char *)(void *)0;
  char ***results = (char ***)(void *)0;
  rc=ldap_get_entry_controls(entry->search->session->ld, entry->search->msg, &entryctrls);
  signed int return_value_strcasecmp$11;
  signed int return_value_strcasecmp$6;
  signed int tmp_post$4;
  signed int tmp_post$9;
  if(!(rc == 0x00))
  {
    myldap_err(4, entry->search->session->ld, rc, "ldap_get_entry_controls() failed");
    return (const char ***)(void *)0;
  }

  else
    if(entryctrls == ((struct ldapcontrol **)NULL))
      return (const char ***)(void *)0;

    else
    {
      rc=ldap_parse_deref_control(entry->search->session->ld, entryctrls, &deref);
      if(deref == ((struct LDAPDerefRes *)NULL) || !(rc == 0x00))
      {
        if(!(rc == 0x00) && !(rc == -13))
          myldap_err(4, entry->search->session->ld, rc, "ldap_parse_deref_control() failed");

        rc = 0x00;
        signed int return_value_ldap_set_option$1;
        return_value_ldap_set_option$1=ldap_set_option(entry->search->session->ld, 0x0031, (const void *)&rc);
        if(!(return_value_ldap_set_option$1 == 0x00))
          log_log(4, "failed to clear the error flag");

        ldap_controls_free(entryctrls);
        return (const char ***)(void *)0;
      }

      pass = 0;
      for( ; !(pass >= 2); pass = pass + 1)
      {
        i = 0;
        for( ; !(i >= 2); i = i + 1)
        {
          counts[(signed long int)i] = 0;
          sizes[(signed long int)i] = (unsigned long int)0;
        }
        d = deref;
        for( ; !(d == ((struct LDAPDerefRes *)NULL)); d = d->next)
          if(!(d->derefAttr == ((char *)NULL)))
          {
            if(!(d->derefVal.bv_val == ((char *)NULL)))
            {
              return_value_strcasecmp$11=strcasecmp(derefattr, d->derefAttr);
              if(return_value_strcasecmp$11 == 0)
              {
                found = 0;
                a = d->attrVals;
                for( ; !(a == ((struct LDAPDerefVal *)NULL)); a = a->next)
                  if(!(a->type == ((char *)NULL)))
                  {
                    if(!(a->vals == ((struct berval *)NULL)))
                    {
                      return_value_strcasecmp$6=strcasecmp(getattr, a->type);
                      if(return_value_strcasecmp$6 == 0)
                      {
                        i = 0;
                        for( ; !((a->vals + (signed long int)i)->bv_val == ((char *)NULL)); i = i + 1)
                        {
                          found = 1;
                          if(results == ((char ***)NULL))
                          {
                            const char *return_value_myldap_get_dn$2;
                            return_value_myldap_get_dn$2=myldap_get_dn(entry);
                            log_log(7, "deref %s %s=%s -> %s=%s", return_value_myldap_get_dn$2, d->derefAttr, d->derefVal.bv_val, a->type, (a->vals + (signed long int)i)->bv_val);
                            counts[(signed long int)0] = counts[(signed long int)0] + 1;
                            unsigned long int return_value_strlen$3;
                            return_value_strlen$3=strlen((a->vals + (signed long int)i)->bv_val);
                            sizes[(signed long int)0] = sizes[(signed long int)0] + return_value_strlen$3 + (unsigned long int)1;
                          }

                          else
                          {
                            strcpy(buffer, (a->vals + (signed long int)i)->bv_val);
                            tmp_post$4 = counts[(signed long int)0];
                            counts[(signed long int)0] = counts[(signed long int)0] + 1;
                            results[(signed long int)0][(signed long int)tmp_post$4] = buffer;
                            unsigned long int return_value_strlen$5;
                            return_value_strlen$5=strlen(buffer);
                            buffer = buffer + (signed long int)(return_value_strlen$5 + (unsigned long int)1);
                          }
                        }
                      }

                    }

                  }

                if(found == 0)
                {
                  if(results == ((char ***)NULL))
                  {
                    const char *return_value_myldap_get_dn$7;
                    return_value_myldap_get_dn$7=myldap_get_dn(entry);
                    log_log(7, "no %s deref %s %s=%s", getattr, return_value_myldap_get_dn$7, d->derefAttr, d->derefVal.bv_val);
                    counts[(signed long int)1] = counts[(signed long int)1] + 1;
                    unsigned long int return_value_strlen$8;
                    return_value_strlen$8=strlen(d->derefVal.bv_val);
                    sizes[(signed long int)1] = sizes[(signed long int)1] + return_value_strlen$8 + (unsigned long int)1;
                  }

                  else
                  {
                    strcpy(buffer, d->derefVal.bv_val);
                    tmp_post$9 = counts[(signed long int)1];
                    counts[(signed long int)1] = counts[(signed long int)1] + 1;
                    results[(signed long int)1][(signed long int)tmp_post$9] = buffer;
                    unsigned long int return_value_strlen$10;
                    return_value_strlen$10=strlen(buffer);
                    buffer = buffer + (signed long int)(return_value_strlen$10 + (unsigned long int)1);
                  }
                }

              }

            }

          }

        if(results == ((char ***)NULL))
        {
          size = sizeof(char **) /*8ul*/  * (unsigned long int)3;
          i = 0;
          for( ; !(i >= 2); i = i + 1)
            size = size + sizeof(char *) /*8ul*/  * (unsigned long int)(counts[(signed long int)i] + 1);
          i = 0;
          for( ; !(i >= 2); i = i + 1)
            size = size + sizeof(char) /*1ul*/  * sizes[(signed long int)i];
          void *return_value_malloc$12;
          return_value_malloc$12=malloc(size);
          buffer = (char *)return_value_malloc$12;
          if(buffer == ((char *)NULL))
          {
            log_log(2, "myldap_get_deref_values(): malloc() failed to allocate memory");
            return (const char ***)(void *)0;
          }

          results = (char ***)(void *)buffer;
          buffer = buffer + (signed long int)(sizeof(char **) /*8ul*/  * (unsigned long int)3);
          i = 0;
          for( ; !(i >= 2); i = i + 1)
          {
            results[(signed long int)i] = (char **)buffer;
            buffer = buffer + (signed long int)(sizeof(char *) /*8ul*/  * (unsigned long int)(counts[(signed long int)i] + 1));
          }
          results[(signed long int)i] = (char **)(void *)0;
        }

      }
      results[(signed long int)0][(signed long int)counts[(signed long int)0]] = (char *)(void *)0;
      results[(signed long int)1][(signed long int)counts[(signed long int)1]] = (char *)(void *)0;
      ldap_derefresponse_free(deref);
      ldap_controls_free(entryctrls);
      i = 0;
      for( ; !(i >= 8); i = i + 1)
        if(entry->buffers[(signed long int)i] == ((char **)NULL))
        {
          entry->buffers[(signed long int)i] = (char **)(void *)results;
          return (const char ***)results;
        }

      log_log(3, "myldap_get_deref_values() couldn't store results, increase MAX_BUFFERS_PER_ENTRY");
      free((void *)results);
      return (const char ***)(void *)0;
    }
}

// myldap_get_dn
// file myldap.h line 120
const char * myldap_get_dn(struct myldap_entry *entry)
{
  signed int rc;
  signed int return_value_is_valid_entry$2;
  return_value_is_valid_entry$2=is_valid_entry(entry);
  if(return_value_is_valid_entry$2 == 0)
  {
    log_log(3, "myldap_get_dn(): invalid result entry passed");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return "unknown";
  }

  if(entry->dn == ((const char *)NULL))
  {
    if(!(entry->search->valid == 0))
    {
      entry->dn=ldap_get_dn(entry->search->session->ld, entry->search->msg);
      if(entry->dn == ((const char *)NULL))
      {
        signed int return_value_ldap_get_option$3;
        return_value_ldap_get_option$3=ldap_get_option(entry->search->session->ld, 0x0031, (void *)&rc);
        if(!(return_value_ldap_get_option$3 == 0x00))
          rc = 0x34;

        myldap_err(4, entry->search->session->ld, rc, "ldap_get_dn() returned NULL");
        if(rc == 0x34 || rc == -1)
          do_close(entry->search->session);

      }

    }

  }

  if(entry->dn == ((const char *)NULL))
    return "unknown";

  else
    return entry->dn;
}

// myldap_get_entry
// file myldap.c line 1461
struct myldap_entry * myldap_get_entry(struct myldap_search *search, signed int *rcp)
{
  signed int rc;
  signed int parserc;
  struct timeval tv;
  struct timeval *tvp;
  struct ldapcontrol **resultcontrols;
  signed int count;
  _Bool tmp_if_expr$2;
  if(search == ((struct myldap_search *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = search->session == (struct ldap_session *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = search->session->ld == (struct ldap *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    log_log(3, "myldap_get_entry(): invalid search passed");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    if(!(rcp == ((signed int *)NULL)))
      *rcp = 0x01;

    return (struct myldap_entry *)(void *)0;
  }

  struct myldap_entry *return_value_myldap_get_entry$4;
  const char *return_value_myldap_get_dn$6;
  _Bool tmp_if_expr$8;
  signed int return_value_ldap_get_option$9;
  struct myldap_entry *return_value_myldap_get_entry$10;
  if(search->valid == 0)
  {
    log_log(4, "myldap_get_entry(): connection was closed");
    if(!(search->may_retry_search == 0))
    {
      log_log(7, "myldap_get_entry(): retry search");
      search->may_retry_search = 0;
      signed int return_value_do_retry_search$5;
      return_value_do_retry_search$5=do_retry_search(search);
      if(return_value_do_retry_search$5 == 0x00)
      {
        return_value_myldap_get_entry$4=myldap_get_entry(search, rcp);
        return return_value_myldap_get_entry$4;
      }

    }

    myldap_search_close(search);
    if(!(rcp == ((signed int *)NULL)))
      *rcp = -1;

    return (struct myldap_entry *)(void *)0;
  }

  else
  {
    if(nslcd_cfg->timelimit == 0)
      tvp = (struct timeval *)(void *)0;

    else
    {
      tv.tv_sec = (signed long int)nslcd_cfg->timelimit;
      tv.tv_usec = (signed long int)0;
      tvp = &tv;
    }
    if(!(search->entry == ((struct myldap_entry *)NULL)))
    {
      myldap_entry_free(search->entry);
      search->entry = (struct myldap_entry *)(void *)0;
    }

    while((_Bool)1)
    {
      if(!(search->msg == ((struct ldapmsg *)NULL)))
      {
        ldap_msgfree(search->msg);
        search->msg = (struct ldapmsg *)(void *)0;
      }

      rc=ldap_result(search->session->ld, search->msgid, 0x00, tvp, &search->msg);
      switch(rc)
      {
        case (signed int)(unsigned long int)0x64U:
        {
          time(&search->session->lastactivity);
          search->entry=myldap_entry_new(search);
          if(!(rcp == ((signed int *)NULL)))
            *rcp = 0x00;

          if(!(search->count >= 10))
          {
            return_value_myldap_get_dn$6=myldap_get_dn(search->entry);
            log_log(7, "ldap_result(): %s", return_value_myldap_get_dn$6);
          }

          search->count = search->count + 1;
          search->may_retry_search = 0;
          return search->entry;
        }
        case (signed int)(unsigned long int)0x65U:
        {
          resultcontrols = (struct ldapcontrol **)(void *)0;
          if(!(search->cookie == ((struct berval *)NULL)))
          {
            ber_bvfree(search->cookie);
            search->cookie = (struct berval *)(void *)0;
          }

          parserc=ldap_parse_result(search->session->ld, search->msg, &rc, (char **)(void *)0, (char **)(void *)0, (char ***)(void *)0, &resultcontrols, 1);
          search->msg = (struct ldapmsg *)(void *)0;
          if(!(parserc == 0x00) && !(parserc == -15))
          {
            if(!(resultcontrols == ((struct ldapcontrol **)NULL)))
              ldap_controls_free(resultcontrols);

            myldap_err(3, search->session->ld, parserc, "ldap_parse_result() failed");
            myldap_search_close(search);
            if(!(rcp == ((signed int *)NULL)))
              *rcp = parserc;

            return (struct myldap_entry *)(void *)0;
          }

          if(!(rc == 0x00) && !(rc == -15))
          {
            if(!(resultcontrols == ((struct ldapcontrol **)NULL)))
              ldap_controls_free(resultcontrols);

            myldap_err(3, search->session->ld, rc, "ldap_result() failed");
            if(rc == 0x34 || rc == -1)
              do_close(search->session);

            myldap_search_close(search);
            if(!(rcp == ((signed int *)NULL)))
              *rcp = rc;

            return (struct myldap_entry *)(void *)0;
          }

          if(!(resultcontrols == ((struct ldapcontrol **)NULL)))
          {
            rc=ldap_parse_page_control(search->session->ld, resultcontrols, &count, &search->cookie);
            if(!(rc == 0x00))
            {
              if(!(rc == -13))
                myldap_err(4, search->session->ld, rc, "ldap_parse_page_control() failed");

              rc = 0x00;
              signed int return_value_ldap_set_option$7;
              return_value_ldap_set_option$7=ldap_set_option(search->session->ld, 0x0031, (const void *)&rc);
              if(!(return_value_ldap_set_option$7 == 0x00))
                log_log(4, "failed to clear the error flag");

            }

            ldap_controls_free(resultcontrols);
          }

          search->msgid = -1;
          if(search->cookie == ((struct berval *)NULL))
            tmp_if_expr$8 = (_Bool)1;

          else
            tmp_if_expr$8 = search->cookie->bv_len == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$8)
          {
            if(search->count >= 11)
              log_log(7, "ldap_result(): ... %d more results", search->count - 10);

            log_log(7, "ldap_result(): end of results (%d total)", search->count);
            myldap_search_close(search);
            if(!(rcp == ((signed int *)NULL)))
              *rcp = 0x00;

            return (struct myldap_entry *)(void *)0;
          }

          rc=do_try_search(search);
          if(!(rc == 0x00))
          {
            if(rc == 0x34 || rc == -1)
              do_close(search->session);

            myldap_search_close(search);
            if(!(rcp == ((signed int *)NULL)))
              *rcp = rc;

            return (struct myldap_entry *)(void *)0;
          }

          break;
        }
        case (signed int)(unsigned long int)0x73U:
          break;
        default:
        {
          if(!(rc == -1))
          {
            if(rc == 0)
              goto __CPROVER_DUMP_L43;

          }

          else
          {
            return_value_ldap_get_option$9=ldap_get_option(search->session->ld, 0x0031, (void *)&rc);
            if(!(return_value_ldap_get_option$9 == 0x00))
              rc = 0x34;

            myldap_err(3, search->session->ld, rc, "ldap_result() failed");
            goto __CPROVER_DUMP_L45;

          __CPROVER_DUMP_L43:
            ;
            log_log(3, "ldap_result() timed out");
            rc = 0x03;
            goto __CPROVER_DUMP_L45;
          }
          log_log(4, "ldap_result() returned unexpected result type");
          rc = 0x02;

        __CPROVER_DUMP_L45:
          ;
          if(rc == 0x00 || rc == 0x01 || rc == 0x02 || rc == 0x03 || rc == 0x34 || rc == -1)
          {
            do_close(search->session);
            if(!(search->may_retry_search == 0))
            {
              log_log(7, "myldap_get_entry(): retry search");
              search->may_retry_search = 0;
              signed int return_value_do_retry_search$11;
              return_value_do_retry_search$11=do_retry_search(search);
              if(return_value_do_retry_search$11 == 0x00)
              {
                return_value_myldap_get_entry$10=myldap_get_entry(search, rcp);
                return return_value_myldap_get_entry$10;
              }

            }

          }

          myldap_search_close(search);
          if(!(rcp == ((signed int *)NULL)))
            *rcp = rc;

          return (struct myldap_entry *)(void *)0;
        }
      }
    }
  }
}

// myldap_get_policy_response
// file myldap.c line 1092
void myldap_get_policy_response(struct ldap_session *session, signed int *response, const char **message)
{
  if(!(response == ((signed int *)NULL)))
    *response = session->policy_response;

  if(!(message == ((const char **)NULL)))
    *message = session->policy_message;

}

// myldap_get_ranged_values
// file myldap.c line 1720
static char ** myldap_get_ranged_values(struct myldap_entry *entry, const char *attr)
{
  char **values;
  char *attn;
  const char *attrs[2l];
  struct berelement *ber;
  signed int i;
  signed int startat = 0;
  signed int nxt = 0;
  char attbuf[80l];
  const char *dn;
  dn=myldap_get_dn(entry);
  struct ldap_session *session = entry->search->session;
  struct myldap_search *search = (struct myldap_search *)(void *)0;
  struct set *set = (struct set *)(void *)0;
  signed int return_value_mysnprintf$2;
  return_value_mysnprintf$2=mysnprintf(attbuf, sizeof(char [80l]) /*80ul*/ , "%s;range=0-*", attr);
  if(!(return_value_mysnprintf$2 == 0))
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(attr);
    log_log(3, "myldap_get_ranged_values(): attbuf buffer too small (%lu required)", (unsigned long int)return_value_strlen$1 + (unsigned long int)10);
    return (char **)(void *)0;
  }

  _Bool tmp_if_expr$7;
  while((_Bool)1)
  {
    ber = (struct berelement *)(void *)0;
    attn=ldap_first_attribute(entry->search->session->ld, entry->search->msg, &ber);
    values = (char **)(void *)0;
    while(!(attn == ((char *)NULL)))
    {
      unsigned long int return_value_strlen$5;
      return_value_strlen$5=strlen(attbuf);
      signed int return_value_strncasecmp$6;
      return_value_strncasecmp$6=strncasecmp(attn, attbuf, return_value_strlen$5 - (unsigned long int)1);
      if(return_value_strncasecmp$6 == 0)
      {
        log_log(7, "found ranged results %s", attn);
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(attbuf);
        signed int return_value_atoi$4;
        return_value_atoi$4=atoi((attn + (signed long int)return_value_strlen$3) - (signed long int)1);
        nxt = return_value_atoi$4 + 1;
        values=ldap_get_values(entry->search->session->ld, entry->search->msg, attn);
        ldap_memfree((void *)attn);
        break;
      }

      ldap_memfree((void *)attn);
      attn=ldap_next_attribute(entry->search->session->ld, entry->search->msg, ber);
    }
    ber_free(ber, 0);
    if(values == ((char **)NULL))
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = *values == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      break;

    if(set == ((struct set *)NULL))
    {
      set=set_new();
      if(set == ((struct set *)NULL))
      {
        ldap_value_free(values);
        log_log(2, "myldap_get_ranged_values(): set_new() failed to allocate memory");
        return (char **)(void *)0;
      }

    }

    i = 0;
    for( ; !(values[(signed long int)i] == ((char *)NULL)); i = i + 1)
      set_add(set, values[(signed long int)i]);
    ldap_value_free(values);
    if(startat >= nxt)
      break;

    startat = nxt;
    signed int return_value_mysnprintf$8;
    return_value_mysnprintf$8=mysnprintf(attbuf, sizeof(char [80l]) /*80ul*/ , "%s;range=%d-*", attr, startat);
    if(!(return_value_mysnprintf$8 == 0))
    {
      log_log(3, "myldap_get_ranged_values(): attbuf buffer too small");
      break;
    }

    attrs[(signed long int)0] = attbuf;
    attrs[(signed long int)1] = (const char *)(void *)0;
    if(!(search == ((struct myldap_search *)NULL)))
      myldap_search_close(search);

    search=myldap_search(session, dn, (signed int)0x0000, "(objectClass=*)", attrs, (signed int *)(void *)0);
    if(search == ((struct myldap_search *)NULL))
      break;

    entry=myldap_get_entry(search, (signed int *)(void *)0);
    if(entry == ((struct myldap_entry *)NULL))
      break;

  }
  if(!(search == ((struct myldap_search *)NULL)))
    myldap_search_close(search);

  if(set == ((struct set *)NULL))
    return (char **)(void *)0;

  else
  {
    const char **return_value_set_tolist$9;
    return_value_set_tolist$9=set_tolist(set);
    values = (char **)return_value_set_tolist$9;
    set_free(set);
    if(values == ((char **)NULL))
      log_log(2, "myldap_get_ranged_values(): malloc() failed to allocate memory");

    return values;
  }
}

// myldap_get_rdn_value
// file myldap.c line 2068
const char * myldap_get_rdn_value(struct myldap_entry *entry, const char *attr)
{
  signed int return_value_is_valid_entry$3;
  return_value_is_valid_entry$3=is_valid_entry(entry);
  if(return_value_is_valid_entry$3 == 0)
  {
    log_log(3, "myldap_get_rdn_value(): invalid result entry passed");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (const char *)(void *)0;
  }

  else
    if(attr == ((const char *)NULL))
    {
      log_log(3, "myldap_get_rdn_value(): invalid attribute name passed");
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 22;
      return (const char *)(void *)0;
    }

  if(entry->exploded_rdn == ((char **)NULL))
  {
    const char *return_value_myldap_get_dn$4;
    return_value_myldap_get_dn$4=myldap_get_dn(entry);
    entry->exploded_rdn=get_exploded_rdn(return_value_myldap_get_dn$4);
    if(entry->exploded_rdn == ((char **)NULL))
      return (const char *)(void *)0;

  }

  const char *return_value_find_rdn_value$5;
  return_value_find_rdn_value$5=find_rdn_value(entry->exploded_rdn, attr);
  return return_value_find_rdn_value$5;
}

// myldap_get_values
// file myldap.c line 1818
const char ** myldap_get_values(struct myldap_entry *entry, const char *attr)
{
  char **values;
  signed int rc;
  signed int i;
  signed int return_value_is_valid_entry$3;
  return_value_is_valid_entry$3=is_valid_entry(entry);
  if(return_value_is_valid_entry$3 == 0)
  {
    log_log(3, "myldap_get_values(): invalid result entry passed");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (const char **)(void *)0;
  }

  else
    if(attr == ((const char *)NULL))
    {
      log_log(3, "myldap_get_values(): invalid attribute name passed");
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 22;
      return (const char **)(void *)0;
    }

  const char *return_value_myldap_get_dn$6;
  if(entry->search->valid == 0)
    return (const char **)(void *)0;

  else
  {
    values=ldap_get_values(entry->search->session->ld, entry->search->msg, attr);
    if(values == ((char **)NULL))
    {
      signed int return_value_ldap_get_option$4;
      return_value_ldap_get_option$4=ldap_get_option(entry->search->session->ld, 0x0031, (void *)&rc);
      if(!(return_value_ldap_get_option$4 == 0x00))
        rc = 0x34;

      if(rc == -4)
      {
        rc = 0x00;
        signed int return_value_ldap_set_option$5;
        return_value_ldap_set_option$5=ldap_set_option(entry->search->session->ld, 0x0031, (const void *)&rc);
        if(!(return_value_ldap_set_option$5 == 0x00))
          log_log(4, "failed to clear the error flag");

      }

      else
        if(rc == 0x00)
        {
          values=myldap_get_ranged_values(entry, attr);
          if(values == ((char **)NULL))
            return (const char **)(void *)0;

          i = 0;
          for( ; !(i >= 8); i = i + 1)
            if(entry->buffers[(signed long int)i] == ((char **)NULL))
            {
              entry->buffers[(signed long int)i] = values;
              return (const char **)entry->buffers[(signed long int)i];
            }

          log_log(3, "ldap_get_values() couldn't store results, increase MAX_BUFFERS_PER_ENTRY");
          free((void *)values);
          return (const char **)(void *)0;
        }

        else
        {
          return_value_myldap_get_dn$6=myldap_get_dn(entry);
          myldap_err(4, entry->search->session->ld, rc, "ldap_get_values() of attribute \"%s\" on entry \"%s\" returned NULL", attr, return_value_myldap_get_dn$6);
        }
      return (const char **)(void *)0;
    }

    i = 0;
    for( ; !(i >= 16); i = i + 1)
      if(entry->attributevalues[(signed long int)i] == ((char **)NULL))
      {
        entry->attributevalues[(signed long int)i] = values;
        return (const char **)values;
      }

    log_log(3, "ldap_get_values() couldn't store results, increase MAX_ATTRIBUTES_PER_ENTRY");
    ldap_value_free(values);
    return (const char **)(void *)0;
  }
}

// myldap_get_values_len
// file myldap.c line 1925
const char ** myldap_get_values_len(struct myldap_entry *entry, const char *attr)
{
  const char **values;
  struct berval **bvalues;
  signed int rc;
  signed int i;
  signed int return_value_is_valid_entry$3;
  return_value_is_valid_entry$3=is_valid_entry(entry);
  if(return_value_is_valid_entry$3 == 0)
  {
    log_log(3, "myldap_get_values_len(): invalid result entry passed");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (const char **)(void *)0;
  }

  else
    if(attr == ((const char *)NULL))
    {
      log_log(3, "myldap_get_values_len(): invalid attribute name passed");
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 22;
      return (const char **)(void *)0;
    }

  if(entry->search->valid == 0)
    return (const char **)(void *)0;

  else
  {
    bvalues=ldap_get_values_len(entry->search->session->ld, entry->search->msg, attr);
    if(bvalues == ((struct berval **)NULL))
    {
      signed int return_value_ldap_get_option$4;
      return_value_ldap_get_option$4=ldap_get_option(entry->search->session->ld, 0x0031, (void *)&rc);
      if(!(return_value_ldap_get_option$4 == 0x00))
        rc = 0x34;

      if(rc == -4)
      {
        rc = 0x00;
        signed int return_value_ldap_set_option$5;
        return_value_ldap_set_option$5=ldap_set_option(entry->search->session->ld, 0x0031, (const void *)&rc);
        if(!(return_value_ldap_set_option$5 == 0x00))
          log_log(4, "failed to clear the error flag");

        return (const char **)(void *)0;
      }

      else
        if(rc == 0x00)
        {
          char **return_value_myldap_get_ranged_values$6;
          return_value_myldap_get_ranged_values$6=myldap_get_ranged_values(entry, attr);
          values = (const char **)return_value_myldap_get_ranged_values$6;
        }

        else
        {
          const char *return_value_myldap_get_dn$7;
          return_value_myldap_get_dn$7=myldap_get_dn(entry);
          myldap_err(4, entry->search->session->ld, rc, "myldap_get_values_len() of attribute \"%s\" on entry \"%s\" returned NULL", attr, return_value_myldap_get_dn$7);
          return (const char **)(void *)0;
        }
    }

    else
    {
      values=bervalues_to_values(bvalues);
      ldap_value_free_len(bvalues);
    }
    if(values == ((const char **)NULL))
      return (const char **)(void *)0;

    else
    {
      i = 0;
      for( ; !(i >= 8); i = i + 1)
        if(entry->buffers[(signed long int)i] == ((char **)NULL))
        {
          entry->buffers[(signed long int)i] = (char **)values;
          return values;
        }

      log_log(3, "myldap_get_values_len() couldn't store results, increase MAX_BUFFERS_PER_ENTRY");
      free((void *)values);
      return (const char **)(void *)0;
    }
  }
}

// myldap_has_objectclass
// file myldap.c line 2116
signed int myldap_has_objectclass(struct myldap_entry *entry, const char *objectclass)
{
  const char **values;
  signed int i;
  signed int return_value_is_valid_entry$2;
  return_value_is_valid_entry$2=is_valid_entry(entry);
  if(objectclass == ((const char *)NULL) || return_value_is_valid_entry$2 == 0)
  {
    log_log(3, "myldap_has_objectclass(): invalid argument passed");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return 0;
  }

  values=myldap_get_values(entry, "objectClass");
  if(values == ((const char **)NULL))
    return 0;

  else
  {
    i = 0;
    for( ; !(values[(signed long int)i] == ((const char *)NULL)); i = i + 1)
    {
      signed int return_value_strcasecmp$3;
      return_value_strcasecmp$3=strcasecmp(values[(signed long int)i], objectclass);
      if(return_value_strcasecmp$3 == 0)
        return -1;

    }
    return 0;
  }
}

// myldap_immediate_reconnect
// file myldap.h line 95
void myldap_immediate_reconnect(void)
{
  signed int i;
  signed long int t;
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  t = return_value_time$1 - (signed long int)nslcd_cfg->reconnect_retrytime;
  pthread_mutex_lock(&uris_mutex);
  i = 0;
  for( ; !(i >= 1); i = i + 1)
    if(!(t >= nslcd_cfg->uris[(signed long int)i].lastfail))
    {
      if(!(nslcd_cfg->uris[(signed long int)i].firstfail + (signed long int)nslcd_cfg->reconnect_retrytime >= nslcd_cfg->uris[(signed long int)i].lastfail))
      {
        log_log(7, "moving lastfail of %s %d second(s) back to force retry", nslcd_cfg->uris[(signed long int)i].uri, (signed int)(nslcd_cfg->uris[(signed long int)i].lastfail - t));
        nslcd_cfg->uris[(signed long int)i].lastfail = t;
      }

    }

  pthread_mutex_unlock(&uris_mutex);
}

// myldap_modify
// file myldap.c line 2417
signed int myldap_modify(struct ldap_session *session, const char *dn, struct ldapmod **mods)
{
  if(dn == ((const char *)NULL) || session == ((struct ldap_session *)NULL))
  {
    log_log(3, "myldap_passwd(): invalid parameter passed");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return 0x50;
  }

  signed int return_value_ldap_modify_ext_s$2;
  return_value_ldap_modify_ext_s$2=ldap_modify_ext_s(session->ld, dn, mods, (struct ldapcontrol **)(void *)0, (struct ldapcontrol **)(void *)0);
  return return_value_ldap_modify_ext_s$2;
}

// myldap_passwd
// file myldap.c line 2367
signed int myldap_passwd(struct ldap_session *session, const char *userdn, const char *oldpassword, const char *newpasswd)
{
  signed int rc;
  struct berval ber_userdn;
  struct berval ber_oldpassword;
  struct berval ber_newpassword;
  struct berval ber_retpassword;
  if(newpasswd == ((const char *)NULL) || userdn == ((const char *)NULL) || session == ((struct ldap_session *)NULL))
  {
    log_log(3, "myldap_passwd(): invalid parameter passed");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return 0x50;
  }

  log_log(7, "myldap_passwd(userdn=\"%s\",oldpasswd=%s,newpasswd=\"***\")", userdn, oldpassword != ((const char *)NULL) ? "\"***\"" : "NULL");
  ber_userdn.bv_val = (char *)userdn;
  ber_userdn.bv_len=strlen(userdn);
  ber_newpassword.bv_val = (char *)newpasswd;
  ber_newpassword.bv_len=strlen(newpasswd);
  ber_retpassword.bv_val = (char *)(void *)0;
  ber_retpassword.bv_len = (unsigned long int)0;
  log_log(7, "myldap_passwd(): try ldap_passwd_s() without old password");
  rc=ldap_passwd_s(session->ld, &ber_userdn, (struct berval *)(void *)0, &ber_newpassword, &ber_retpassword, (struct ldapcontrol **)(void *)0, (struct ldapcontrol **)(void *)0);
  if(!(rc == 0x00))
    myldap_err(3, session->ld, rc, "ldap_passwd_s() without old password failed");

  if(!(ber_retpassword.bv_val == ((char *)NULL)))
    ldap_memfree((void *)ber_retpassword.bv_val);

  if(!(oldpassword == ((const char *)NULL)) && !(rc == 0x00))
  {
    log_log(7, "myldap_passwd(): try ldap_passwd_s() with old password");
    ber_oldpassword.bv_val = (char *)oldpassword;
    ber_oldpassword.bv_len=strlen(oldpassword);
    rc=ldap_passwd_s(session->ld, &ber_userdn, &ber_oldpassword, &ber_newpassword, &ber_retpassword, (struct ldapcontrol **)(void *)0, (struct ldapcontrol **)(void *)0);
    if(!(rc == 0x00))
      myldap_err(3, session->ld, rc, "ldap_passwd_s() with old password failed");

    if(!(ber_retpassword.bv_val == ((char *)NULL)))
      ldap_memfree((void *)ber_retpassword.bv_val);

  }

  return rc;
}

// myldap_search
// file myldap.c line 1374
struct myldap_search * myldap_search(struct ldap_session *session, const char *base, signed int scope, const char *filter, const char **attrs, signed int *rcp)
{
  struct myldap_search *search;
  signed int i;
  signed int rc;
  if(attrs == ((const char **)NULL) || base == ((const char *)NULL) || filter == ((const char *)NULL) || session == ((struct ldap_session *)NULL))
  {
    log_log(3, "myldap_search(): invalid parameter passed");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    if(!(rcp == ((signed int *)NULL)))
      *rcp = 0x01;

    return (struct myldap_search *)(void *)0;
  }

  log_log(7, "myldap_search(base=\"%s\", filter=\"%s\")", base, filter);
  myldap_session_check(session);
  search=myldap_search_new(session, base, scope, filter, attrs);
  i = 0;
  _Bool tmp_if_expr$2;
  do
  {
    if(!(i >= 4))
      tmp_if_expr$2 = session->searches[(signed long int)i] != (struct myldap_search *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  if(i >= 4)
  {
    log_log(3, "myldap_search(): too many searches registered with session (max %d)", 4);
    myldap_search_close(search);
    if(!(rcp == ((signed int *)NULL)))
      *rcp = 0x01;

    return (struct myldap_search *)(void *)0;
  }

  else
  {
    session->searches[(signed long int)i] = search;
    rc=do_retry_search(search);
    if(!(rc == 0x00))
    {
      myldap_search_close(search);
      if(!(rcp == ((signed int *)NULL)))
        *rcp = rc;

      return (struct myldap_search *)(void *)0;
    }

    else
    {
      if(!(rcp == ((signed int *)NULL)))
        *rcp = 0x00;

      return search;
    }
  }
}

// myldap_search_close
// file myldap.c line 1425
void myldap_search_close(struct myldap_search *search)
{
  signed int i;
  if(!(search == ((struct myldap_search *)NULL)))
  {
    if(!(search->msg == ((struct ldapmsg *)NULL)))
    {
      ldap_msgfree(search->msg);
      search->msg = (struct ldapmsg *)(void *)0;
    }

    if(!(search->session->ld == ((struct ldap *)NULL)))
    {
      if(!(search->msgid == -1))
      {
        ldap_abandon(search->session->ld, search->msgid);
        search->msgid = -1;
      }

    }

    i = 0;
    for( ; !(i >= 4); i = i + 1)
      if(search->session->searches[(signed long int)i] == search)
        search->session->searches[(signed long int)i] = (struct myldap_search *)(void *)0;

    if(!(search->entry == ((struct myldap_entry *)NULL)))
      myldap_entry_free(search->entry);

    if(!(search->cookie == ((struct berval *)NULL)))
      ber_bvfree(search->cookie);

    if(!(search->msg == ((struct ldapmsg *)NULL)))
      ldap_msgfree(search->msg);

    free((void *)search);
  }

}

// myldap_search_new
// file myldap.c line 240
static struct myldap_search * myldap_search_new(struct ldap_session *session, const char *base, signed int scope, const char *filter, const char **attrs)
{
  char *buffer;
  struct myldap_search *search;
  signed int i;
  unsigned long int sz = sizeof(struct myldap_search) /*88ul*/ ;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(base);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(filter);
  sz = sz + return_value_strlen$1 + (unsigned long int)1 + return_value_strlen$2 + (unsigned long int)1;
  i = 0;
  unsigned long int return_value_strlen$3;
  for( ; !(attrs[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    return_value_strlen$3=strlen(attrs[(signed long int)i]);
    sz = sz + return_value_strlen$3 + (unsigned long int)1;
  }
  sz = sz + (unsigned long int)(i + 1) * sizeof(char *) /*8ul*/ ;
  void *return_value_malloc$4;
  return_value_malloc$4=malloc(sz);
  buffer = (char *)return_value_malloc$4;
  if(buffer == ((char *)NULL))
  {
    log_log(2, "myldap_search_new(): malloc() failed to allocate memory");
    exit(1);
  }

  search = (struct myldap_search *)(void *)buffer;
  buffer = buffer + (signed long int)sizeof(struct myldap_search) /*88ul*/ ;
  search->session = session;
  search->valid = 1;
  search->attrs = (char **)(void *)buffer;
  buffer = buffer + (signed long int)((unsigned long int)(i + 1) * sizeof(char *) /*8ul*/ );
  strcpy(buffer, base);
  search->base = buffer;
  unsigned long int return_value_strlen$5;
  return_value_strlen$5=strlen(base);
  buffer = buffer + (signed long int)(return_value_strlen$5 + (unsigned long int)1);
  search->scope = scope;
  strcpy(buffer, filter);
  search->filter = buffer;
  unsigned long int return_value_strlen$6;
  return_value_strlen$6=strlen(filter);
  buffer = buffer + (signed long int)(return_value_strlen$6 + (unsigned long int)1);
  i = 0;
  for( ; !(attrs[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    strcpy(buffer, attrs[(signed long int)i]);
    search->attrs[(signed long int)i] = buffer;
    unsigned long int return_value_strlen$7;
    return_value_strlen$7=strlen(attrs[(signed long int)i]);
    buffer = buffer + (signed long int)(return_value_strlen$7 + (unsigned long int)1);
  }
  search->attrs[(signed long int)i] = (char *)(void *)0;
  search->cookie = (struct berval *)(void *)0;
  search->msg = (struct ldapmsg *)(void *)0;
  search->msgid = -1;
  search->may_retry_search = 1;
  search->entry = (struct myldap_entry *)(void *)0;
  search->count = 0;
  return search;
}

// myldap_session_check
// file myldap.h line 87
void myldap_session_check(struct ldap_session *session)
{
  signed int i;
  signed long int current_time;
  signed int sd;
  signed int rc;
  struct sockaddr sa;
  unsigned int salen = (unsigned int)sizeof(struct sockaddr) /*16ul*/ ;
  if(session == ((struct ldap_session *)NULL))
  {
    log_log(3, "myldap_session_check(): invalid parameter passed");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    goto __CPROVER_DUMP_L10;
  }

  if(!(session->ld == ((struct ldap *)NULL)))
  {
    rc=ldap_get_option(session->ld, 0x0001, (void *)&sd);
    if(!(rc == 0x00))
      myldap_err(4, session->ld, rc, "ldap_get_option(LDAP_OPT_DESC) failed (ignored)");

    else
    {
      signed int return_value_getpeername$3;
      return_value_getpeername$3=getpeername(sd, &sa, &salen);
      if(return_value_getpeername$3 == -1)
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        if(*return_value___errno_location$2 == 107)
        {
          log_log(7, "myldap_session_check(): connection reset by peer");
          do_close(session);
          goto __CPROVER_DUMP_L10;
        }

      }

    }
    if(nslcd_cfg->idle_timelimit >= 1)
    {
      i = 0;
      for( ; !(i >= 4); i = i + 1)
        if(!(session->searches[(signed long int)i] == ((struct myldap_search *)NULL)))
        {
          if(!(session->searches[(signed long int)i]->valid == 0))
            goto __CPROVER_DUMP_L10;

        }

      time(&current_time);
      if(!(session->lastactivity + (signed long int)nslcd_cfg->idle_timelimit >= current_time))
      {
        log_log(7, "myldap_session_check(): idle_timelimit reached");
        do_close(session);
      }

    }

  }


__CPROVER_DUMP_L10:
  ;
}

// myldap_session_cleanup
// file myldap.h line 82
void myldap_session_cleanup(struct ldap_session *session)
{
  signed int i;
  if(session == ((struct ldap_session *)NULL))
    log_log(3, "myldap_session_cleanup(): invalid session passed");

  else
  {
    i = 0;
    for( ; !(i >= 4); i = i + 1)
      if(!(session->searches[(signed long int)i] == ((struct myldap_search *)NULL)))
      {
        myldap_search_close(session->searches[(signed long int)i]);
        session->searches[(signed long int)i] = (struct myldap_search *)(void *)0;
      }

  }
}

// myldap_session_close
// file myldap.h line 91
void myldap_session_close(struct ldap_session *session)
{
  if(session == ((struct ldap_session *)NULL))
    log_log(3, "myldap_session_cleanup(): invalid session passed");

  else
  {
    myldap_session_cleanup(session);
    do_close(session);
    memset((void *)session->bindpw, 0, sizeof(char [128l]) /*128ul*/ );
    free((void *)session);
  }
}

// myldap_session_new
// file myldap.c line 303
static struct ldap_session * myldap_session_new(void)
{
  struct ldap_session *session;
  signed int i;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ldap_session) /*1728ul*/ );
  session = (struct ldap_session *)return_value_malloc$1;
  if(session == ((struct ldap_session *)NULL))
  {
    log_log(2, "myldap_session_new(): malloc() failed to allocate memory");
    exit(1);
  }

  session->ld = (struct ldap *)(void *)0;
  session->lastactivity = (signed long int)0;
  session->current_uri = 0;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    session->searches[(signed long int)i] = (struct myldap_search *)(void *)0;
  session->binddn[(signed long int)0] = (char)0;
  memset((void *)session->bindpw, 0, sizeof(char [128l]) /*128ul*/ );
  session->bindpw[(signed long int)0] = (char)0;
  session->policy_response = 0;
  session->policy_message[(signed long int)0] = (char)0;
  return session;
}

// myldap_set_credentials
// file myldap.c line 1064
signed int myldap_set_credentials(struct ldap_session *session, const char *dn, const char *password)
{
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(dn);
  if(return_value_strlen$2 >= sizeof(char [512l]) /*512ul*/ )
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(dn);
    log_log(3, "myldap_set_credentials(): binddn buffer too small (%lu required)", (unsigned long int)return_value_strlen$1);
    return -1;
  }

  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(password);
  if(return_value_strlen$4 >= sizeof(char [128l]) /*128ul*/ )
  {
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(password);
    log_log(3, "myldap_set_credentials(): bindpw buffer too small (%lu required)", (unsigned long int)return_value_strlen$3);
    return -1;
  }

  strncpy(session->binddn, dn, sizeof(char [512l]) /*512ul*/ );
  session->binddn[(signed long int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1)] = (char)0;
  strncpy(session->bindpw, password, sizeof(char [128l]) /*128ul*/ );
  session->bindpw[(signed long int)(sizeof(char [128l]) /*128ul*/  - (unsigned long int)1)] = (char)0;
  return 0;
}

// myldap_set_debuglevel
// file myldap.h line 160
signed int myldap_set_debuglevel(signed int level)
{
  signed int i;
  signed int rc;
  if(level >= 2)
  {
    log_log(7, "ber_set_option(LBER_OPT_LOG_PRINT_FILE)");
    rc=ber_set_option((void *)0, 0x8004, (const void *)stderr);
    if(!(rc == 0x00))
    {
      myldap_err(3, (struct ldap *)(void *)0, rc, "ber_set_option(LBER_OPT_LOG_PRINT_FILE) failed");
      return rc;
    }

    if(level >= 3)
    {
      i = -1;
      log_log(7, "ber_set_option(LBER_OPT_DEBUG_LEVEL,-1)");
      rc=ber_set_option((void *)0, 0x02, (const void *)&i);
      if(!(rc == 0x00))
      {
        myldap_err(3, (struct ldap *)(void *)0, rc, "ber_set_option(LBER_OPT_DEBUG_LEVEL) failed");
        return rc;
      }

    }

    i = -1;
    log_log(7, "ldap_set_option(LDAP_OPT_DEBUG_LEVEL,-1)");
    rc=ldap_set_option((struct ldap *)(void *)0, 0x5001, (const void *)&i);
    if(rc == 0x00)
      goto __CPROVER_DUMP_L3;

    myldap_err(3, (struct ldap *)(void *)0, rc, "ldap_set_option(LDAP_OPT_DEBUG_LEVEL) failed");
    return rc;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    return 0x00;
  }
}

// mysnprintf
// file common.h line 64
signed int mysnprintf(char *buffer, unsigned long int buflen, const char *format, ...)
{
  signed int res;
  void **ap = (void **)&format;
  res=vsnprintf(buffer, buflen, format, ap);
  ap = ((void **)NULL);
  buffer[(signed long int)(buflen - (unsigned long int)1)] = (char)0;
  return (signed int)(res < 0 || (unsigned long int)res >= buflen);
}

// netgroup_init
// file common.h line 210
void netgroup_init(void)
{
  signed int i;
  if(netgroup_bases[0l] == ((const char *)NULL))
  {
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      netgroup_bases[(signed long int)i] = nslcd_cfg->bases[(signed long int)i];
  }

  if(netgroup_scope == -1)
    netgroup_scope = nslcd_cfg->scope;

  netgroup_attrs[(signed long int)0] = attmap_netgroup_cn;
  netgroup_attrs[(signed long int)1] = attmap_netgroup_nisNetgroupTriple;
  netgroup_attrs[(signed long int)2] = attmap_netgroup_memberNisNetgroup;
  netgroup_attrs[(signed long int)3] = (const char *)(void *)0;
}

// network_init
// file common.h line 211
void network_init(void)
{
  signed int i;
  if(network_bases[0l] == ((const char *)NULL))
  {
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      network_bases[(signed long int)i] = nslcd_cfg->bases[(signed long int)i];
  }

  if(network_scope == -1)
    network_scope = nslcd_cfg->scope;

  network_attrs[(signed long int)0] = attmap_network_cn;
  network_attrs[(signed long int)1] = attmap_network_ipNetworkNumber;
  network_attrs[(signed long int)2] = (const char *)(void *)0;
}

// nslcd_alias_all
// file common.h line 222
signed int nslcd_alias_all(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  const char *filter;
  log_setrequest("alias(all)");
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$1;
  signed int return_value_tio_write$7;
  return_value_tio_write$7=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(return_value_tio_write$7 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    if(*return_value___errno_location$6 == 32)
    {
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_log(7, "error writing to client: %s", return_value_strerror$3);
    }

    else
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_log(4, "error writing to client: %s", return_value_strerror$5);
    }
    return -1;
  }

  unsigned int return_value_htonl$8;
  return_value_htonl$8=htonl((unsigned int)(signed int)0x00020008);
  tmpint32 = (signed int)return_value_htonl$8;
  signed int return_value_tio_write$14;
  return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(!(return_value_tio_write$14 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    if(*return_value___errno_location$13 == 32)
    {
      return_value___errno_location$9=__errno_location();
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_log(7, "error writing to client: %s", return_value_strerror$10);
    }

    else
    {
      return_value___errno_location$11=__errno_location();
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      log_log(4, "error writing to client: %s", return_value_strerror$12);
    }
    return -1;
  }

  filter = alias_filter;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  i = 0;
  do
  {
    base = alias_bases[(signed long int)i];
    if(base == ((const char *)NULL))
      break;

    search=myldap_search(session, base, alias_scope, filter, alias_attrs, (signed int *)(void *)0);
    if(search == ((struct myldap_search *)NULL))
      return -1;

    do
    {
      entry=myldap_get_entry(search, &rc);
      if(entry == ((struct myldap_entry *)NULL))
        break;

      signed int return_value_write_alias$15;
      return_value_write_alias$15=write_alias(fp, entry, (const char *)(void *)0);
      if(!(return_value_write_alias$15 == 0))
        return -1;

    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  if(rc == 0x00)
  {
    unsigned int return_value_htonl$16;
    return_value_htonl$16=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$16;
    signed int return_value_tio_write$22;
    return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$22 == 0))
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      if(*return_value___errno_location$21 == 32)
      {
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        log_log(7, "error writing to client: %s", return_value_strerror$18);
      }

      else
      {
        return_value___errno_location$19=__errno_location();
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        log_log(4, "error writing to client: %s", return_value_strerror$20);
      }
      return -1;
    }

  }

  return 0;
}

// nslcd_alias_byname
// file common.h line 221
signed int nslcd_alias_byname(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  char name[256l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$16;
  char *return_value_strerror$17;
  signed int *return_value___errno_location$18;
  char *return_value_strerror$19;
  signed int *return_value___errno_location$25;
  char *return_value_strerror$26;
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)name, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    name[(signed long int)tmpint32] = (char)0;
    log_setrequest("alias=\"%s\"", (const void *)name);
    unsigned int return_value_htonl$8;
    return_value_htonl$8=htonl((unsigned int)(signed int)0x00000002);
    tmpint32 = (signed int)return_value_htonl$8;
    signed int return_value_tio_write$14;
    return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$14 == 0))
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      if(*return_value___errno_location$13 == 32)
      {
        return_value___errno_location$9=__errno_location();
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        log_log(7, "error writing to client: %s", return_value_strerror$10);
      }

      else
      {
        return_value___errno_location$11=__errno_location();
        return_value_strerror$12=strerror(*return_value___errno_location$11);
        log_log(4, "error writing to client: %s", return_value_strerror$12);
      }
      return -1;
    }

    unsigned int return_value_htonl$15;
    return_value_htonl$15=htonl((unsigned int)(signed int)0x00020001);
    tmpint32 = (signed int)return_value_htonl$15;
    signed int return_value_tio_write$21;
    return_value_tio_write$21=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$21 == 0))
    {
      signed int *return_value___errno_location$20;
      return_value___errno_location$20=__errno_location();
      if(*return_value___errno_location$20 == 32)
      {
        return_value___errno_location$16=__errno_location();
        return_value_strerror$17=strerror(*return_value___errno_location$16);
        log_log(7, "error writing to client: %s", return_value_strerror$17);
      }

      else
      {
        return_value___errno_location$18=__errno_location();
        return_value_strerror$19=strerror(*return_value___errno_location$18);
        log_log(4, "error writing to client: %s", return_value_strerror$19);
      }
      return -1;
    }

    signed int return_value_mkfilter_alias_byname$22;
    return_value_mkfilter_alias_byname$22=mkfilter_alias_byname(name, filter, sizeof(char [4096l]) /*4096ul*/ );
    if(!(return_value_mkfilter_alias_byname$22 == 0))
    {
      log_log(3, "nslcd_alias_byname(): filter buffer too small");
      return -1;
    }

    else
    {
      i = 0;
      do
      {
        base = alias_bases[(signed long int)i];
        if(base == ((const char *)NULL))
          break;

        search=myldap_search(session, base, alias_scope, filter, alias_attrs, (signed int *)(void *)0);
        if(search == ((struct myldap_search *)NULL))
          return -1;

        do
        {
          entry=myldap_get_entry(search, &rc);
          if(entry == ((struct myldap_entry *)NULL))
            break;

          signed int return_value_write_alias$23;
          return_value_write_alias$23=write_alias(fp, entry, name);
          if(!(return_value_write_alias$23 == 0))
            return -1;

        }
        while((_Bool)1);
        i = i + 1;
      }
      while((_Bool)1);
      if(rc == 0x00)
      {
        unsigned int return_value_htonl$24;
        return_value_htonl$24=htonl((unsigned int)(signed int)2);
        tmpint32 = (signed int)return_value_htonl$24;
        signed int return_value_tio_write$30;
        return_value_tio_write$30=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$30 == 0))
        {
          signed int *return_value___errno_location$29;
          return_value___errno_location$29=__errno_location();
          if(*return_value___errno_location$29 == 32)
          {
            return_value___errno_location$25=__errno_location();
            return_value_strerror$26=strerror(*return_value___errno_location$25);
            log_log(7, "error writing to client: %s", return_value_strerror$26);
          }

          else
          {
            return_value___errno_location$27=__errno_location();
            return_value_strerror$28=strerror(*return_value___errno_location$27);
            log_log(4, "error writing to client: %s", return_value_strerror$28);
          }
          return -1;
        }

      }

      return 0;
    }
  }
}

// nslcd_config_get
// file common.h line 220
signed int nslcd_config_get(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  signed int cfgopt;
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  cfgopt = (signed int)return_value_ntohl$4;
  log_setrequest("config=%d", (signed int)cfgopt);
  log_log(7, "nslcd_config_get(%d)", (signed int)cfgopt);
  unsigned int return_value_htonl$5;
  return_value_htonl$5=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$5;
  signed int return_value_tio_write$11;
  return_value_tio_write$11=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  if(!(return_value_tio_write$11 == 0))
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    if(*return_value___errno_location$10 == 32)
    {
      return_value___errno_location$6=__errno_location();
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      log_log(7, "error writing to client: %s", return_value_strerror$7);
    }

    else
    {
      return_value___errno_location$8=__errno_location();
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error writing to client: %s", return_value_strerror$9);
    }
    return -1;
  }

  unsigned int return_value_htonl$12;
  return_value_htonl$12=htonl((unsigned int)(signed int)0x00010001);
  tmpint32 = (signed int)return_value_htonl$12;
  signed int return_value_tio_write$18;
  return_value_tio_write$18=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  if(!(return_value_tio_write$18 == 0))
  {
    signed int *return_value___errno_location$17;
    return_value___errno_location$17=__errno_location();
    if(*return_value___errno_location$17 == 32)
    {
      return_value___errno_location$13=__errno_location();
      return_value_strerror$14=strerror(*return_value___errno_location$13);
      log_log(7, "error writing to client: %s", return_value_strerror$14);
    }

    else
    {
      return_value___errno_location$15=__errno_location();
      return_value_strerror$16=strerror(*return_value___errno_location$15);
      log_log(4, "error writing to client: %s", return_value_strerror$16);
    }
    return -1;
  }

  unsigned int return_value_htonl$19;
  return_value_htonl$19=htonl((unsigned int)(signed int)1);
  tmpint32 = (signed int)return_value_htonl$19;
  signed int return_value_tio_write$25;
  return_value_tio_write$25=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$20;
  char *return_value_strerror$21;
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  if(!(return_value_tio_write$25 == 0))
  {
    signed int *return_value___errno_location$24;
    return_value___errno_location$24=__errno_location();
    if(*return_value___errno_location$24 == 32)
    {
      return_value___errno_location$20=__errno_location();
      return_value_strerror$21=strerror(*return_value___errno_location$20);
      log_log(7, "error writing to client: %s", return_value_strerror$21);
    }

    else
    {
      return_value___errno_location$22=__errno_location();
      return_value_strerror$23=strerror(*return_value___errno_location$22);
      log_log(4, "error writing to client: %s", return_value_strerror$23);
    }
    return -1;
  }

  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  signed int *return_value___errno_location$29;
  char *return_value_strerror$30;
  signed int *return_value___errno_location$35;
  char *return_value_strerror$36;
  signed int *return_value___errno_location$37;
  char *return_value_strerror$38;
  signed int *return_value___errno_location$42;
  char *return_value_strerror$43;
  signed int *return_value___errno_location$44;
  char *return_value_strerror$45;
  if(cfgopt == 1)
  {
    if(nslcd_cfg->pam_password_prohibit_message == ((char *)NULL))
    {
      unsigned int return_value_htonl$26;
      return_value_htonl$26=htonl((unsigned int)(signed int)0);
      tmpint32 = (signed int)return_value_htonl$26;
      signed int return_value_tio_write$32;
      return_value_tio_write$32=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$32 == 0))
      {
        signed int *return_value___errno_location$31;
        return_value___errno_location$31=__errno_location();
        if(*return_value___errno_location$31 == 32)
        {
          return_value___errno_location$27=__errno_location();
          return_value_strerror$28=strerror(*return_value___errno_location$27);
          log_log(7, "error writing to client: %s", return_value_strerror$28);
        }

        else
        {
          return_value___errno_location$29=__errno_location();
          return_value_strerror$30=strerror(*return_value___errno_location$29);
          log_log(4, "error writing to client: %s", return_value_strerror$30);
        }
        return -1;
      }

    }

    else
    {
      unsigned long int return_value_strlen$33;
      return_value_strlen$33=strlen(nslcd_cfg->pam_password_prohibit_message);
      unsigned int return_value_htonl$34;
      return_value_htonl$34=htonl((unsigned int)(signed int)return_value_strlen$33);
      tmpint32 = (signed int)return_value_htonl$34;
      signed int return_value_tio_write$40;
      return_value_tio_write$40=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$40 == 0))
      {
        signed int *return_value___errno_location$39;
        return_value___errno_location$39=__errno_location();
        if(*return_value___errno_location$39 == 32)
        {
          return_value___errno_location$35=__errno_location();
          return_value_strerror$36=strerror(*return_value___errno_location$35);
          log_log(7, "error writing to client: %s", return_value_strerror$36);
        }

        else
        {
          return_value___errno_location$37=__errno_location();
          return_value_strerror$38=strerror(*return_value___errno_location$37);
          log_log(4, "error writing to client: %s", return_value_strerror$38);
        }
        return -1;
      }

      unsigned int return_value_ntohl$41;
      return_value_ntohl$41=ntohl((unsigned int)tmpint32);
      tmpint32 = (signed int)return_value_ntohl$41;
      if(tmpint32 >= 1)
      {
        signed int return_value_tio_write$47;
        return_value_tio_write$47=tio_write(fp, (const void *)nslcd_cfg->pam_password_prohibit_message, (unsigned long int)tmpint32);
        if(!(return_value_tio_write$47 == 0))
        {
          signed int *return_value___errno_location$46;
          return_value___errno_location$46=__errno_location();
          if(*return_value___errno_location$46 == 32)
          {
            return_value___errno_location$42=__errno_location();
            return_value_strerror$43=strerror(*return_value___errno_location$42);
            log_log(7, "error writing to client: %s", return_value_strerror$43);
          }

          else
          {
            return_value___errno_location$44=__errno_location();
            return_value_strerror$45=strerror(*return_value___errno_location$44);
            log_log(4, "error writing to client: %s", return_value_strerror$45);
          }
          return -1;
        }

      }

    }
  }

  unsigned int return_value_htonl$48;
  return_value_htonl$48=htonl((unsigned int)(signed int)2);
  tmpint32 = (signed int)return_value_htonl$48;
  signed int return_value_tio_write$54;
  return_value_tio_write$54=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$49;
  char *return_value_strerror$50;
  signed int *return_value___errno_location$51;
  char *return_value_strerror$52;
  if(!(return_value_tio_write$54 == 0))
  {
    signed int *return_value___errno_location$53;
    return_value___errno_location$53=__errno_location();
    if(*return_value___errno_location$53 == 32)
    {
      return_value___errno_location$49=__errno_location();
      return_value_strerror$50=strerror(*return_value___errno_location$49);
      log_log(7, "error writing to client: %s", return_value_strerror$50);
    }

    else
    {
      return_value___errno_location$51=__errno_location();
      return_value_strerror$52=strerror(*return_value___errno_location$51);
      log_log(4, "error writing to client: %s", return_value_strerror$52);
    }
    return -1;
  }

  return 0;
}

// nslcd_ether_all
// file common.h line 225
signed int nslcd_ether_all(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  const char *filter;
  log_setrequest("ether(all)");
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$1;
  signed int return_value_tio_write$7;
  return_value_tio_write$7=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(return_value_tio_write$7 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    if(*return_value___errno_location$6 == 32)
    {
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_log(7, "error writing to client: %s", return_value_strerror$3);
    }

    else
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_log(4, "error writing to client: %s", return_value_strerror$5);
    }
    return -1;
  }

  unsigned int return_value_htonl$8;
  return_value_htonl$8=htonl((unsigned int)(signed int)0x00030008);
  tmpint32 = (signed int)return_value_htonl$8;
  signed int return_value_tio_write$14;
  return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(!(return_value_tio_write$14 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    if(*return_value___errno_location$13 == 32)
    {
      return_value___errno_location$9=__errno_location();
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_log(7, "error writing to client: %s", return_value_strerror$10);
    }

    else
    {
      return_value___errno_location$11=__errno_location();
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      log_log(4, "error writing to client: %s", return_value_strerror$12);
    }
    return -1;
  }

  filter = ether_filter;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  i = 0;
  do
  {
    base = ether_bases[(signed long int)i];
    if(base == ((const char *)NULL))
      break;

    search=myldap_search(session, base, ether_scope, filter, ether_attrs, (signed int *)(void *)0);
    if(search == ((struct myldap_search *)NULL))
      return -1;

    do
    {
      entry=myldap_get_entry(search, &rc);
      if(entry == ((struct myldap_entry *)NULL))
        break;

      signed int return_value_write_ether$15;
      return_value_write_ether$15=write_ether(fp, entry, (const char *)(void *)0, (const char *)(void *)0);
      if(!(return_value_write_ether$15 == 0))
        return -1;

    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  if(rc == 0x00)
  {
    unsigned int return_value_htonl$16;
    return_value_htonl$16=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$16;
    signed int return_value_tio_write$22;
    return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$22 == 0))
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      if(*return_value___errno_location$21 == 32)
      {
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        log_log(7, "error writing to client: %s", return_value_strerror$18);
      }

      else
      {
        return_value___errno_location$19=__errno_location();
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        log_log(4, "error writing to client: %s", return_value_strerror$20);
      }
      return -1;
    }

  }

  return 0;
}

// nslcd_ether_byether
// file common.h line 224
signed int nslcd_ether_byether(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  struct ether_addr addr;
  char addrstr[20l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&addr, (unsigned long int)sizeof(unsigned char [6l]) /*6ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  char *return_value_ether_ntoa_r$4;
  return_value_ether_ntoa_r$4=ether_ntoa_r(&addr, addrstr);
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  signed int *return_value___errno_location$24;
  char *return_value_strerror$25;
  if(return_value_ether_ntoa_r$4 == ((char *)NULL))
    return -1;

  else
  {
    log_setrequest("ether=%s", (const void *)addrstr);
    unsigned int return_value_htonl$5;
    return_value_htonl$5=htonl((unsigned int)(signed int)0x00000002);
    tmpint32 = (signed int)return_value_htonl$5;
    signed int return_value_tio_write$11;
    return_value_tio_write$11=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$11 == 0))
    {
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      if(*return_value___errno_location$10 == 32)
      {
        return_value___errno_location$6=__errno_location();
        return_value_strerror$7=strerror(*return_value___errno_location$6);
        log_log(7, "error writing to client: %s", return_value_strerror$7);
      }

      else
      {
        return_value___errno_location$8=__errno_location();
        return_value_strerror$9=strerror(*return_value___errno_location$8);
        log_log(4, "error writing to client: %s", return_value_strerror$9);
      }
      return -1;
    }

    unsigned int return_value_htonl$12;
    return_value_htonl$12=htonl((unsigned int)(signed int)0x00030002);
    tmpint32 = (signed int)return_value_htonl$12;
    signed int return_value_tio_write$18;
    return_value_tio_write$18=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$18 == 0))
    {
      signed int *return_value___errno_location$17;
      return_value___errno_location$17=__errno_location();
      if(*return_value___errno_location$17 == 32)
      {
        return_value___errno_location$13=__errno_location();
        return_value_strerror$14=strerror(*return_value___errno_location$13);
        log_log(7, "error writing to client: %s", return_value_strerror$14);
      }

      else
      {
        return_value___errno_location$15=__errno_location();
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        log_log(4, "error writing to client: %s", return_value_strerror$16);
      }
      return -1;
    }

    signed int return_value_mkfilter_ether_byether$19;
    return_value_mkfilter_ether_byether$19=mkfilter_ether_byether(addrstr, filter, sizeof(char [4096l]) /*4096ul*/ );
    if(!(return_value_mkfilter_ether_byether$19 == 0))
    {
      log_log(3, "nslcd_ether_byether(): filter buffer too small");
      return -1;
    }

    else
    {
      i = 0;
      do
      {
        base = ether_bases[(signed long int)i];
        if(base == ((const char *)NULL))
          break;

        search=myldap_search(session, base, ether_scope, filter, ether_attrs, (signed int *)(void *)0);
        if(search == ((struct myldap_search *)NULL))
          return -1;

        do
        {
          entry=myldap_get_entry(search, &rc);
          if(entry == ((struct myldap_entry *)NULL))
            break;

          signed int return_value_write_ether$20;
          return_value_write_ether$20=write_ether(fp, entry, (const char *)(void *)0, addrstr);
          if(!(return_value_write_ether$20 == 0))
            return -1;

        }
        while((_Bool)1);
        i = i + 1;
      }
      while((_Bool)1);
      if(rc == 0x00)
      {
        unsigned int return_value_htonl$21;
        return_value_htonl$21=htonl((unsigned int)(signed int)2);
        tmpint32 = (signed int)return_value_htonl$21;
        signed int return_value_tio_write$27;
        return_value_tio_write$27=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$27 == 0))
        {
          signed int *return_value___errno_location$26;
          return_value___errno_location$26=__errno_location();
          if(*return_value___errno_location$26 == 32)
          {
            return_value___errno_location$22=__errno_location();
            return_value_strerror$23=strerror(*return_value___errno_location$22);
            log_log(7, "error writing to client: %s", return_value_strerror$23);
          }

          else
          {
            return_value___errno_location$24=__errno_location();
            return_value_strerror$25=strerror(*return_value___errno_location$24);
            log_log(4, "error writing to client: %s", return_value_strerror$25);
          }
          return -1;
        }

      }

      return 0;
    }
  }
}

// nslcd_ether_byname
// file common.h line 223
signed int nslcd_ether_byname(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  char name[65l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$16;
  char *return_value_strerror$17;
  signed int *return_value___errno_location$18;
  char *return_value_strerror$19;
  signed int *return_value___errno_location$25;
  char *return_value_strerror$26;
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  if((unsigned long int)tmpint32 >= sizeof(char [65l]) /*65ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [65l]) /*65ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)name, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    name[(signed long int)tmpint32] = (char)0;
    log_setrequest("ether=\"%s\"", (const void *)name);
    unsigned int return_value_htonl$8;
    return_value_htonl$8=htonl((unsigned int)(signed int)0x00000002);
    tmpint32 = (signed int)return_value_htonl$8;
    signed int return_value_tio_write$14;
    return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$14 == 0))
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      if(*return_value___errno_location$13 == 32)
      {
        return_value___errno_location$9=__errno_location();
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        log_log(7, "error writing to client: %s", return_value_strerror$10);
      }

      else
      {
        return_value___errno_location$11=__errno_location();
        return_value_strerror$12=strerror(*return_value___errno_location$11);
        log_log(4, "error writing to client: %s", return_value_strerror$12);
      }
      return -1;
    }

    unsigned int return_value_htonl$15;
    return_value_htonl$15=htonl((unsigned int)(signed int)0x00030001);
    tmpint32 = (signed int)return_value_htonl$15;
    signed int return_value_tio_write$21;
    return_value_tio_write$21=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$21 == 0))
    {
      signed int *return_value___errno_location$20;
      return_value___errno_location$20=__errno_location();
      if(*return_value___errno_location$20 == 32)
      {
        return_value___errno_location$16=__errno_location();
        return_value_strerror$17=strerror(*return_value___errno_location$16);
        log_log(7, "error writing to client: %s", return_value_strerror$17);
      }

      else
      {
        return_value___errno_location$18=__errno_location();
        return_value_strerror$19=strerror(*return_value___errno_location$18);
        log_log(4, "error writing to client: %s", return_value_strerror$19);
      }
      return -1;
    }

    signed int return_value_mkfilter_ether_byname$22;
    return_value_mkfilter_ether_byname$22=mkfilter_ether_byname(name, filter, sizeof(char [4096l]) /*4096ul*/ );
    if(!(return_value_mkfilter_ether_byname$22 == 0))
    {
      log_log(3, "nslcd_ether_byname(): filter buffer too small");
      return -1;
    }

    else
    {
      i = 0;
      do
      {
        base = ether_bases[(signed long int)i];
        if(base == ((const char *)NULL))
          break;

        search=myldap_search(session, base, ether_scope, filter, ether_attrs, (signed int *)(void *)0);
        if(search == ((struct myldap_search *)NULL))
          return -1;

        do
        {
          entry=myldap_get_entry(search, &rc);
          if(entry == ((struct myldap_entry *)NULL))
            break;

          signed int return_value_write_ether$23;
          return_value_write_ether$23=write_ether(fp, entry, name, (const char *)(void *)0);
          if(!(return_value_write_ether$23 == 0))
            return -1;

        }
        while((_Bool)1);
        i = i + 1;
      }
      while((_Bool)1);
      if(rc == 0x00)
      {
        unsigned int return_value_htonl$24;
        return_value_htonl$24=htonl((unsigned int)(signed int)2);
        tmpint32 = (signed int)return_value_htonl$24;
        signed int return_value_tio_write$30;
        return_value_tio_write$30=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$30 == 0))
        {
          signed int *return_value___errno_location$29;
          return_value___errno_location$29=__errno_location();
          if(*return_value___errno_location$29 == 32)
          {
            return_value___errno_location$25=__errno_location();
            return_value_strerror$26=strerror(*return_value___errno_location$25);
            log_log(7, "error writing to client: %s", return_value_strerror$26);
          }

          else
          {
            return_value___errno_location$27=__errno_location();
            return_value_strerror$28=strerror(*return_value___errno_location$27);
            log_log(4, "error writing to client: %s", return_value_strerror$28);
          }
          return -1;
        }

      }

      return 0;
    }
  }
}

// nslcd_group_all
// file common.h line 229
signed int nslcd_group_all(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  const char *filter;
  log_setrequest("group(all)");
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$1;
  signed int return_value_tio_write$7;
  return_value_tio_write$7=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(return_value_tio_write$7 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    if(*return_value___errno_location$6 == 32)
    {
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_log(7, "error writing to client: %s", return_value_strerror$3);
    }

    else
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_log(4, "error writing to client: %s", return_value_strerror$5);
    }
    return -1;
  }

  unsigned int return_value_htonl$8;
  return_value_htonl$8=htonl((unsigned int)(signed int)0x00040008);
  tmpint32 = (signed int)return_value_htonl$8;
  signed int return_value_tio_write$14;
  return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(!(return_value_tio_write$14 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    if(*return_value___errno_location$13 == 32)
    {
      return_value___errno_location$9=__errno_location();
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_log(7, "error writing to client: %s", return_value_strerror$10);
    }

    else
    {
      return_value___errno_location$11=__errno_location();
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      log_log(4, "error writing to client: %s", return_value_strerror$12);
    }
    return -1;
  }

  filter = group_filter;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  i = 0;
  do
  {
    base = group_bases[(signed long int)i];
    if(base == ((const char *)NULL))
      break;

    search=myldap_search(session, base, group_scope, filter, group_attrs, (signed int *)(void *)0);
    if(search == ((struct myldap_search *)NULL))
      return -1;

    do
    {
      entry=myldap_get_entry(search, &rc);
      if(entry == ((struct myldap_entry *)NULL))
        break;

      signed int return_value_write_group$15;
      return_value_write_group$15=write_group(fp, entry, (const char *)(void *)0, (const unsigned int *)(void *)0, 1, session);
      if(!(return_value_write_group$15 == 0))
        return -1;

    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  if(rc == 0x00)
  {
    unsigned int return_value_htonl$16;
    return_value_htonl$16=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$16;
    signed int return_value_tio_write$22;
    return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$22 == 0))
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      if(*return_value___errno_location$21 == 32)
      {
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        log_log(7, "error writing to client: %s", return_value_strerror$18);
      }

      else
      {
        return_value___errno_location$19=__errno_location();
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        log_log(4, "error writing to client: %s", return_value_strerror$20);
      }
      return -1;
    }

  }

  return 0;
}

// nslcd_group_bygid
// file common.h line 227
signed int nslcd_group_bygid(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  unsigned int gid;
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  gid = (unsigned int)(signed int)return_value_ntohl$4;
  log_setrequest("group=%lu", (unsigned long int)gid);
  unsigned int return_value_htonl$5;
  return_value_htonl$5=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$5;
  signed int return_value_tio_write$11;
  return_value_tio_write$11=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  if(!(return_value_tio_write$11 == 0))
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    if(*return_value___errno_location$10 == 32)
    {
      return_value___errno_location$6=__errno_location();
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      log_log(7, "error writing to client: %s", return_value_strerror$7);
    }

    else
    {
      return_value___errno_location$8=__errno_location();
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error writing to client: %s", return_value_strerror$9);
    }
    return -1;
  }

  unsigned int return_value_htonl$12;
  return_value_htonl$12=htonl((unsigned int)(signed int)0x00040002);
  tmpint32 = (signed int)return_value_htonl$12;
  signed int return_value_tio_write$18;
  return_value_tio_write$18=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  if(!(return_value_tio_write$18 == 0))
  {
    signed int *return_value___errno_location$17;
    return_value___errno_location$17=__errno_location();
    if(*return_value___errno_location$17 == 32)
    {
      return_value___errno_location$13=__errno_location();
      return_value_strerror$14=strerror(*return_value___errno_location$13);
      log_log(7, "error writing to client: %s", return_value_strerror$14);
    }

    else
    {
      return_value___errno_location$15=__errno_location();
      return_value_strerror$16=strerror(*return_value___errno_location$15);
      log_log(4, "error writing to client: %s", return_value_strerror$16);
    }
    return -1;
  }

  signed int return_value_mkfilter_group_bygid$19;
  return_value_mkfilter_group_bygid$19=mkfilter_group_bygid(gid, filter, sizeof(char [4096l]) /*4096ul*/ );
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  signed int *return_value___errno_location$24;
  char *return_value_strerror$25;
  if(!(return_value_mkfilter_group_bygid$19 == 0))
  {
    log_log(3, "nslcd_group_bygid(): filter buffer too small");
    return -1;
  }

  else
  {
    i = 0;
    do
    {
      base = group_bases[(signed long int)i];
      if(base == ((const char *)NULL))
        break;

      search=myldap_search(session, base, group_scope, filter, group_attrs, (signed int *)(void *)0);
      if(search == ((struct myldap_search *)NULL))
        return -1;

      do
      {
        entry=myldap_get_entry(search, &rc);
        if(entry == ((struct myldap_entry *)NULL))
          break;

        signed int return_value_write_group$20;
        return_value_write_group$20=write_group(fp, entry, (const char *)(void *)0, &gid, 1, session);
        if(!(return_value_write_group$20 == 0))
          return -1;

      }
      while((_Bool)1);
      i = i + 1;
    }
    while((_Bool)1);
    if(rc == 0x00)
    {
      unsigned int return_value_htonl$21;
      return_value_htonl$21=htonl((unsigned int)(signed int)2);
      tmpint32 = (signed int)return_value_htonl$21;
      signed int return_value_tio_write$27;
      return_value_tio_write$27=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$27 == 0))
      {
        signed int *return_value___errno_location$26;
        return_value___errno_location$26=__errno_location();
        if(*return_value___errno_location$26 == 32)
        {
          return_value___errno_location$22=__errno_location();
          return_value_strerror$23=strerror(*return_value___errno_location$22);
          log_log(7, "error writing to client: %s", return_value_strerror$23);
        }

        else
        {
          return_value___errno_location$24=__errno_location();
          return_value_strerror$25=strerror(*return_value___errno_location$24);
          log_log(4, "error writing to client: %s", return_value_strerror$25);
        }
        return -1;
      }

    }

    return 0;
  }
}

// nslcd_group_bymember
// file common.h line 228
signed int nslcd_group_bymember(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *dn;
  const char *base;
  signed int rc;
  signed int i;
  char name[256l];
  char filter[4096l];
  struct set *seen = (struct set *)(void *)0;
  struct set *tocheck = (struct set *)(void *)0;
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int return_value_set_contains$30;
  signed int *return_value___errno_location$10;
  char *return_value_strerror$11;
  signed int *return_value___errno_location$12;
  char *return_value_strerror$13;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  signed int *return_value___errno_location$24;
  char *return_value_strerror$25;
  signed int *return_value___errno_location$26;
  char *return_value_strerror$27;
  signed int *return_value___errno_location$32;
  char *return_value_strerror$33;
  signed int *return_value___errno_location$34;
  char *return_value_strerror$35;
  signed int *return_value___errno_location$39;
  char *return_value_strerror$40;
  signed int *return_value___errno_location$41;
  char *return_value_strerror$42;
  signed int return_value_strcasecmp$46;
  _Bool tmp_if_expr$49;
  signed int return_value_set_contains$48;
  signed int *return_value___errno_location$54;
  char *return_value_strerror$55;
  signed int *return_value___errno_location$56;
  char *return_value_strerror$57;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)name, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    name[(signed long int)tmpint32] = (char)0;
    log_setrequest("group/member=\"%s\"", (const void *)name);
    signed int return_value_isvalidname$8;
    return_value_isvalidname$8=isvalidname(name);
    if(return_value_isvalidname$8 == 0)
    {
      log_log(4, "request denied by validnames option");
      return -1;
    }

    else
    {
      if(!(nslcd_cfg->nss_initgroups_ignoreusers == ((struct set *)NULL)))
      {
        return_value_set_contains$30=set_contains(nslcd_cfg->nss_initgroups_ignoreusers, name);
        if(!(return_value_set_contains$30 == 0))
        {
          log_log(7, "ignored group member");
          unsigned int return_value_htonl$9;
          return_value_htonl$9=htonl((unsigned int)(signed int)0x00000002);
          tmpint32 = (signed int)return_value_htonl$9;
          signed int return_value_tio_write$15;
          return_value_tio_write$15=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$15 == 0))
          {
            signed int *return_value___errno_location$14;
            return_value___errno_location$14=__errno_location();
            if(*return_value___errno_location$14 == 32)
            {
              return_value___errno_location$10=__errno_location();
              return_value_strerror$11=strerror(*return_value___errno_location$10);
              log_log(7, "error writing to client: %s", return_value_strerror$11);
            }

            else
            {
              return_value___errno_location$12=__errno_location();
              return_value_strerror$13=strerror(*return_value___errno_location$12);
              log_log(4, "error writing to client: %s", return_value_strerror$13);
            }
            return -1;
          }

          unsigned int return_value_htonl$16;
          return_value_htonl$16=htonl((unsigned int)(signed int)0x00040006);
          tmpint32 = (signed int)return_value_htonl$16;
          signed int return_value_tio_write$22;
          return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$22 == 0))
          {
            signed int *return_value___errno_location$21;
            return_value___errno_location$21=__errno_location();
            if(*return_value___errno_location$21 == 32)
            {
              return_value___errno_location$17=__errno_location();
              return_value_strerror$18=strerror(*return_value___errno_location$17);
              log_log(7, "error writing to client: %s", return_value_strerror$18);
            }

            else
            {
              return_value___errno_location$19=__errno_location();
              return_value_strerror$20=strerror(*return_value___errno_location$19);
              log_log(4, "error writing to client: %s", return_value_strerror$20);
            }
            return -1;
          }

          unsigned int return_value_htonl$23;
          return_value_htonl$23=htonl((unsigned int)(signed int)2);
          tmpint32 = (signed int)return_value_htonl$23;
          signed int return_value_tio_write$29;
          return_value_tio_write$29=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$29 == 0))
          {
            signed int *return_value___errno_location$28;
            return_value___errno_location$28=__errno_location();
            if(*return_value___errno_location$28 == 32)
            {
              return_value___errno_location$24=__errno_location();
              return_value_strerror$25=strerror(*return_value___errno_location$24);
              log_log(7, "error writing to client: %s", return_value_strerror$25);
            }

            else
            {
              return_value___errno_location$26=__errno_location();
              return_value_strerror$27=strerror(*return_value___errno_location$26);
              log_log(4, "error writing to client: %s", return_value_strerror$27);
            }
            return -1;
          }

          return 0;
        }

      }

      unsigned int return_value_htonl$31;
      return_value_htonl$31=htonl((unsigned int)(signed int)0x00000002);
      tmpint32 = (signed int)return_value_htonl$31;
      signed int return_value_tio_write$37;
      return_value_tio_write$37=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$37 == 0))
      {
        signed int *return_value___errno_location$36;
        return_value___errno_location$36=__errno_location();
        if(*return_value___errno_location$36 == 32)
        {
          return_value___errno_location$32=__errno_location();
          return_value_strerror$33=strerror(*return_value___errno_location$32);
          log_log(7, "error writing to client: %s", return_value_strerror$33);
        }

        else
        {
          return_value___errno_location$34=__errno_location();
          return_value_strerror$35=strerror(*return_value___errno_location$34);
          log_log(4, "error writing to client: %s", return_value_strerror$35);
        }
        return -1;
      }

      unsigned int return_value_htonl$38;
      return_value_htonl$38=htonl((unsigned int)(signed int)0x00040006);
      tmpint32 = (signed int)return_value_htonl$38;
      signed int return_value_tio_write$44;
      return_value_tio_write$44=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$44 == 0))
      {
        signed int *return_value___errno_location$43;
        return_value___errno_location$43=__errno_location();
        if(*return_value___errno_location$43 == 32)
        {
          return_value___errno_location$39=__errno_location();
          return_value_strerror$40=strerror(*return_value___errno_location$39);
          log_log(7, "error writing to client: %s", return_value_strerror$40);
        }

        else
        {
          return_value___errno_location$41=__errno_location();
          return_value_strerror$42=strerror(*return_value___errno_location$41);
          log_log(4, "error writing to client: %s", return_value_strerror$42);
        }
        return -1;
      }

      signed int return_value_mkfilter_group_bymember$45;
      return_value_mkfilter_group_bymember$45=mkfilter_group_bymember(session, name, filter, sizeof(char [4096l]) /*4096ul*/ );
      if(!(return_value_mkfilter_group_bymember$45 == 0))
      {
        log_log(4, "nslcd_group_bymember(): filter buffer too small");
        return -1;
      }

      else
      {
        if(!(nslcd_cfg->nss_nested_groups == 0))
        {
          return_value_strcasecmp$46=strcasecmp(attmap_group_member, "\"\"");
          if(!(return_value_strcasecmp$46 == 0))
          {
            seen=set_new();
            tocheck=set_new();
            if(tocheck == ((struct set *)NULL) && !(seen == ((struct set *)NULL)))
            {
              set_free(seen);
              seen = (struct set *)(void *)0;
            }

            else
              if(seen == ((struct set *)NULL) && !(tocheck == ((struct set *)NULL)))
              {
                set_free(tocheck);
                tocheck = (struct set *)(void *)0;
              }

          }

        }

        i = 0;
        do
        {
          base = group_bases[(signed long int)i];
          if(base == ((const char *)NULL))
            break;

          search=myldap_search(session, base, group_scope, filter, group_bymember_attrs, (signed int *)(void *)0);
          if(search == ((struct myldap_search *)NULL))
          {
            if(!(seen == ((struct set *)NULL)))
            {
              set_free(seen);
              set_free(tocheck);
            }

            return -1;
          }

          do
          {
            entry=myldap_get_entry(search, &rc);
            if(entry == ((struct myldap_entry *)NULL))
              break;

            if(seen == ((struct set *)NULL))
              tmp_if_expr$49 = (_Bool)1;

            else
            {
              dn=myldap_get_dn(entry);
              return_value_set_contains$48=set_contains(seen, dn);
              tmp_if_expr$49 = !(return_value_set_contains$48 != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$49)
            {
              if(!(seen == ((struct set *)NULL)))
              {
                set_add(seen, dn);
                set_add(tocheck, dn);
              }

              signed int return_value_write_group$47;
              return_value_write_group$47=write_group(fp, entry, (const char *)(void *)0, (const unsigned int *)(void *)0, 0, session);
              if(!(return_value_write_group$47 == 0))
              {
                if(!(seen == ((struct set *)NULL)))
                {
                  set_free(seen);
                  set_free(tocheck);
                }

                return -1;
              }

            }

          }
          while((_Bool)1);
          i = i + 1;
        }
        while((_Bool)1);
        if(!(tocheck == ((struct set *)NULL)))
        {
          do
          {
            dn=set_pop(tocheck);
            if(dn == ((const char *)NULL))
              break;

            signed int return_value_mkfilter_group_bymemberdn$50;
            return_value_mkfilter_group_bymemberdn$50=mkfilter_group_bymemberdn(dn, filter, sizeof(char [4096l]) /*4096ul*/ );
            if(!(return_value_mkfilter_group_bymemberdn$50 == 0))
            {
              log_log(4, "nslcd_group_bymember(): filter buffer too small");
              free((void *)dn);
              set_free(seen);
              set_free(tocheck);
              return -1;
            }

            free((void *)dn);
            i = 0;
            do
            {
              base = group_bases[(signed long int)i];
              if(base == ((const char *)NULL))
                break;

              search=myldap_search(session, base, group_scope, filter, group_bymember_attrs, (signed int *)(void *)0);
              if(!(search == ((struct myldap_search *)NULL)))
                do
                {
                  entry=myldap_get_entry(search, (signed int *)(void *)0);
                  if(entry == ((struct myldap_entry *)NULL))
                    break;

                  dn=myldap_get_dn(entry);
                  signed int return_value_set_contains$52;
                  return_value_set_contains$52=set_contains(seen, dn);
                  if(return_value_set_contains$52 == 0)
                  {
                    set_add(seen, dn);
                    set_add(tocheck, dn);
                    signed int return_value_write_group$51;
                    return_value_write_group$51=write_group(fp, entry, (const char *)(void *)0, (const unsigned int *)(void *)0, 0, session);
                    if(!(return_value_write_group$51 == 0))
                    {
                      set_free(seen);
                      set_free(tocheck);
                      return -1;
                    }

                  }

                }
                while((_Bool)1);

              i = i + 1;
            }
            while((_Bool)1);
          }
          while((_Bool)1);
          set_free(seen);
          set_free(tocheck);
        }

        if(rc == 0x00)
        {
          unsigned int return_value_htonl$53;
          return_value_htonl$53=htonl((unsigned int)(signed int)2);
          tmpint32 = (signed int)return_value_htonl$53;
          signed int return_value_tio_write$59;
          return_value_tio_write$59=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$59 == 0))
          {
            signed int *return_value___errno_location$58;
            return_value___errno_location$58=__errno_location();
            if(*return_value___errno_location$58 == 32)
            {
              return_value___errno_location$54=__errno_location();
              return_value_strerror$55=strerror(*return_value___errno_location$54);
              log_log(7, "error writing to client: %s", return_value_strerror$55);
            }

            else
            {
              return_value___errno_location$56=__errno_location();
              return_value_strerror$57=strerror(*return_value___errno_location$56);
              log_log(4, "error writing to client: %s", return_value_strerror$57);
            }
            return -1;
          }

        }

        return 0;
      }
    }
  }
}

// nslcd_group_byname
// file common.h line 226
signed int nslcd_group_byname(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  char name[256l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$10;
  char *return_value_strerror$11;
  signed int *return_value___errno_location$12;
  char *return_value_strerror$13;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  signed int *return_value___errno_location$26;
  char *return_value_strerror$27;
  signed int *return_value___errno_location$28;
  char *return_value_strerror$29;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)name, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    name[(signed long int)tmpint32] = (char)0;
    log_setrequest("group=\"%s\"", (const void *)name);
    signed int return_value_isvalidname$8;
    return_value_isvalidname$8=isvalidname(name);
    if(return_value_isvalidname$8 == 0)
    {
      log_log(4, "request denied by validnames option");
      return -1;
    }

    else
    {
      unsigned int return_value_htonl$9;
      return_value_htonl$9=htonl((unsigned int)(signed int)0x00000002);
      tmpint32 = (signed int)return_value_htonl$9;
      signed int return_value_tio_write$15;
      return_value_tio_write$15=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$15 == 0))
      {
        signed int *return_value___errno_location$14;
        return_value___errno_location$14=__errno_location();
        if(*return_value___errno_location$14 == 32)
        {
          return_value___errno_location$10=__errno_location();
          return_value_strerror$11=strerror(*return_value___errno_location$10);
          log_log(7, "error writing to client: %s", return_value_strerror$11);
        }

        else
        {
          return_value___errno_location$12=__errno_location();
          return_value_strerror$13=strerror(*return_value___errno_location$12);
          log_log(4, "error writing to client: %s", return_value_strerror$13);
        }
        return -1;
      }

      unsigned int return_value_htonl$16;
      return_value_htonl$16=htonl((unsigned int)(signed int)0x00040001);
      tmpint32 = (signed int)return_value_htonl$16;
      signed int return_value_tio_write$22;
      return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$22 == 0))
      {
        signed int *return_value___errno_location$21;
        return_value___errno_location$21=__errno_location();
        if(*return_value___errno_location$21 == 32)
        {
          return_value___errno_location$17=__errno_location();
          return_value_strerror$18=strerror(*return_value___errno_location$17);
          log_log(7, "error writing to client: %s", return_value_strerror$18);
        }

        else
        {
          return_value___errno_location$19=__errno_location();
          return_value_strerror$20=strerror(*return_value___errno_location$19);
          log_log(4, "error writing to client: %s", return_value_strerror$20);
        }
        return -1;
      }

      signed int return_value_mkfilter_group_byname$23;
      return_value_mkfilter_group_byname$23=mkfilter_group_byname(name, filter, sizeof(char [4096l]) /*4096ul*/ );
      if(!(return_value_mkfilter_group_byname$23 == 0))
      {
        log_log(3, "nslcd_group_byname(): filter buffer too small");
        return -1;
      }

      else
      {
        i = 0;
        do
        {
          base = group_bases[(signed long int)i];
          if(base == ((const char *)NULL))
            break;

          search=myldap_search(session, base, group_scope, filter, group_attrs, (signed int *)(void *)0);
          if(search == ((struct myldap_search *)NULL))
            return -1;

          do
          {
            entry=myldap_get_entry(search, &rc);
            if(entry == ((struct myldap_entry *)NULL))
              break;

            signed int return_value_write_group$24;
            return_value_write_group$24=write_group(fp, entry, name, (const unsigned int *)(void *)0, 1, session);
            if(!(return_value_write_group$24 == 0))
              return -1;

          }
          while((_Bool)1);
          i = i + 1;
        }
        while((_Bool)1);
        if(rc == 0x00)
        {
          unsigned int return_value_htonl$25;
          return_value_htonl$25=htonl((unsigned int)(signed int)2);
          tmpint32 = (signed int)return_value_htonl$25;
          signed int return_value_tio_write$31;
          return_value_tio_write$31=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$31 == 0))
          {
            signed int *return_value___errno_location$30;
            return_value___errno_location$30=__errno_location();
            if(*return_value___errno_location$30 == 32)
            {
              return_value___errno_location$26=__errno_location();
              return_value_strerror$27=strerror(*return_value___errno_location$26);
              log_log(7, "error writing to client: %s", return_value_strerror$27);
            }

            else
            {
              return_value___errno_location$28=__errno_location();
              return_value_strerror$29=strerror(*return_value___errno_location$28);
              log_log(4, "error writing to client: %s", return_value_strerror$29);
            }
            return -1;
          }

        }

        return 0;
      }
    }
  }
}

// nslcd_host_all
// file common.h line 232
signed int nslcd_host_all(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  const char *filter;
  log_setrequest("host(all)");
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$1;
  signed int return_value_tio_write$7;
  return_value_tio_write$7=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(return_value_tio_write$7 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    if(*return_value___errno_location$6 == 32)
    {
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_log(7, "error writing to client: %s", return_value_strerror$3);
    }

    else
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_log(4, "error writing to client: %s", return_value_strerror$5);
    }
    return -1;
  }

  unsigned int return_value_htonl$8;
  return_value_htonl$8=htonl((unsigned int)(signed int)0x00050008);
  tmpint32 = (signed int)return_value_htonl$8;
  signed int return_value_tio_write$14;
  return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(!(return_value_tio_write$14 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    if(*return_value___errno_location$13 == 32)
    {
      return_value___errno_location$9=__errno_location();
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_log(7, "error writing to client: %s", return_value_strerror$10);
    }

    else
    {
      return_value___errno_location$11=__errno_location();
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      log_log(4, "error writing to client: %s", return_value_strerror$12);
    }
    return -1;
  }

  filter = host_filter;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  i = 0;
  do
  {
    base = host_bases[(signed long int)i];
    if(base == ((const char *)NULL))
      break;

    search=myldap_search(session, base, host_scope, filter, host_attrs, (signed int *)(void *)0);
    if(search == ((struct myldap_search *)NULL))
      return -1;

    do
    {
      entry=myldap_get_entry(search, &rc);
      if(entry == ((struct myldap_entry *)NULL))
        break;

      signed int return_value_write_host$15;
      return_value_write_host$15=write_host(fp, entry);
      if(!(return_value_write_host$15 == 0))
        return -1;

    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  if(rc == 0x00)
  {
    unsigned int return_value_htonl$16;
    return_value_htonl$16=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$16;
    signed int return_value_tio_write$22;
    return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$22 == 0))
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      if(*return_value___errno_location$21 == 32)
      {
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        log_log(7, "error writing to client: %s", return_value_strerror$18);
      }

      else
      {
        return_value___errno_location$19=__errno_location();
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        log_log(4, "error writing to client: %s", return_value_strerror$20);
      }
      return -1;
    }

  }

  return 0;
}

// nslcd_host_byaddr
// file common.h line 231
signed int nslcd_host_byaddr(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  signed int af;
  char addr[64l];
  signed int len = (signed int)sizeof(char [64l]) /*64ul*/ ;
  char addrstr[64l];
  char filter[4096l];
  len = (signed int)sizeof(char [64l]) /*64ul*/ ;
  signed int return_value_read_address$1;
  return_value_read_address$1=read_address(fp, addr, &len, &af);
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$20;
  char *return_value_strerror$21;
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  if(!(return_value_read_address$1 == 0))
    return -1;

  else
  {
    const char *return_value_inet_ntop$2;
    return_value_inet_ntop$2=inet_ntop(af, (const void *)addr, addrstr, (unsigned int)sizeof(char [64l]) /*64ul*/ );
    if(return_value_inet_ntop$2 == ((const char *)NULL))
    {
      log_log(4, "unable to convert address to string");
      return -1;
    }

    else
    {
      log_setrequest("host=%s", (const void *)addrstr);
      unsigned int return_value_htonl$3;
      return_value_htonl$3=htonl((unsigned int)(signed int)0x00000002);
      tmpint32 = (signed int)return_value_htonl$3;
      signed int return_value_tio_write$9;
      return_value_tio_write$9=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$9 == 0))
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        if(*return_value___errno_location$8 == 32)
        {
          return_value___errno_location$4=__errno_location();
          return_value_strerror$5=strerror(*return_value___errno_location$4);
          log_log(7, "error writing to client: %s", return_value_strerror$5);
        }

        else
        {
          return_value___errno_location$6=__errno_location();
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          log_log(4, "error writing to client: %s", return_value_strerror$7);
        }
        return -1;
      }

      unsigned int return_value_htonl$10;
      return_value_htonl$10=htonl((unsigned int)(signed int)0x00050002);
      tmpint32 = (signed int)return_value_htonl$10;
      signed int return_value_tio_write$16;
      return_value_tio_write$16=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$16 == 0))
      {
        signed int *return_value___errno_location$15;
        return_value___errno_location$15=__errno_location();
        if(*return_value___errno_location$15 == 32)
        {
          return_value___errno_location$11=__errno_location();
          return_value_strerror$12=strerror(*return_value___errno_location$11);
          log_log(7, "error writing to client: %s", return_value_strerror$12);
        }

        else
        {
          return_value___errno_location$13=__errno_location();
          return_value_strerror$14=strerror(*return_value___errno_location$13);
          log_log(4, "error writing to client: %s", return_value_strerror$14);
        }
        return -1;
      }

      signed int return_value_mkfilter_host_byaddr$17;
      return_value_mkfilter_host_byaddr$17=mkfilter_host_byaddr(addrstr, filter, sizeof(char [4096l]) /*4096ul*/ );
      if(!(return_value_mkfilter_host_byaddr$17 == 0))
      {
        log_log(3, "nslcd_host_byaddr(): filter buffer too small");
        return -1;
      }

      else
      {
        i = 0;
        do
        {
          base = host_bases[(signed long int)i];
          if(base == ((const char *)NULL))
            break;

          search=myldap_search(session, base, host_scope, filter, host_attrs, (signed int *)(void *)0);
          if(search == ((struct myldap_search *)NULL))
            return -1;

          do
          {
            entry=myldap_get_entry(search, &rc);
            if(entry == ((struct myldap_entry *)NULL))
              break;

            signed int return_value_write_host$18;
            return_value_write_host$18=write_host(fp, entry);
            if(!(return_value_write_host$18 == 0))
              return -1;

          }
          while((_Bool)1);
          i = i + 1;
        }
        while((_Bool)1);
        if(rc == 0x00)
        {
          unsigned int return_value_htonl$19;
          return_value_htonl$19=htonl((unsigned int)(signed int)2);
          tmpint32 = (signed int)return_value_htonl$19;
          signed int return_value_tio_write$25;
          return_value_tio_write$25=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$25 == 0))
          {
            signed int *return_value___errno_location$24;
            return_value___errno_location$24=__errno_location();
            if(*return_value___errno_location$24 == 32)
            {
              return_value___errno_location$20=__errno_location();
              return_value_strerror$21=strerror(*return_value___errno_location$20);
              log_log(7, "error writing to client: %s", return_value_strerror$21);
            }

            else
            {
              return_value___errno_location$22=__errno_location();
              return_value_strerror$23=strerror(*return_value___errno_location$22);
              log_log(4, "error writing to client: %s", return_value_strerror$23);
            }
            return -1;
          }

        }

        return 0;
      }
    }
  }
}

// nslcd_host_byname
// file common.h line 230
signed int nslcd_host_byname(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  char name[65l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$16;
  char *return_value_strerror$17;
  signed int *return_value___errno_location$18;
  char *return_value_strerror$19;
  signed int *return_value___errno_location$25;
  char *return_value_strerror$26;
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  if((unsigned long int)tmpint32 >= sizeof(char [65l]) /*65ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [65l]) /*65ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)name, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    name[(signed long int)tmpint32] = (char)0;
    log_setrequest("host=\"%s\"", (const void *)name);
    unsigned int return_value_htonl$8;
    return_value_htonl$8=htonl((unsigned int)(signed int)0x00000002);
    tmpint32 = (signed int)return_value_htonl$8;
    signed int return_value_tio_write$14;
    return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$14 == 0))
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      if(*return_value___errno_location$13 == 32)
      {
        return_value___errno_location$9=__errno_location();
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        log_log(7, "error writing to client: %s", return_value_strerror$10);
      }

      else
      {
        return_value___errno_location$11=__errno_location();
        return_value_strerror$12=strerror(*return_value___errno_location$11);
        log_log(4, "error writing to client: %s", return_value_strerror$12);
      }
      return -1;
    }

    unsigned int return_value_htonl$15;
    return_value_htonl$15=htonl((unsigned int)(signed int)0x00050001);
    tmpint32 = (signed int)return_value_htonl$15;
    signed int return_value_tio_write$21;
    return_value_tio_write$21=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$21 == 0))
    {
      signed int *return_value___errno_location$20;
      return_value___errno_location$20=__errno_location();
      if(*return_value___errno_location$20 == 32)
      {
        return_value___errno_location$16=__errno_location();
        return_value_strerror$17=strerror(*return_value___errno_location$16);
        log_log(7, "error writing to client: %s", return_value_strerror$17);
      }

      else
      {
        return_value___errno_location$18=__errno_location();
        return_value_strerror$19=strerror(*return_value___errno_location$18);
        log_log(4, "error writing to client: %s", return_value_strerror$19);
      }
      return -1;
    }

    signed int return_value_mkfilter_host_byname$22;
    return_value_mkfilter_host_byname$22=mkfilter_host_byname(name, filter, sizeof(char [4096l]) /*4096ul*/ );
    if(!(return_value_mkfilter_host_byname$22 == 0))
    {
      log_log(3, "nslcd_host_byname(): filter buffer too small");
      return -1;
    }

    else
    {
      i = 0;
      do
      {
        base = host_bases[(signed long int)i];
        if(base == ((const char *)NULL))
          break;

        search=myldap_search(session, base, host_scope, filter, host_attrs, (signed int *)(void *)0);
        if(search == ((struct myldap_search *)NULL))
          return -1;

        do
        {
          entry=myldap_get_entry(search, &rc);
          if(entry == ((struct myldap_entry *)NULL))
            break;

          signed int return_value_write_host$23;
          return_value_write_host$23=write_host(fp, entry);
          if(!(return_value_write_host$23 == 0))
            return -1;

        }
        while((_Bool)1);
        i = i + 1;
      }
      while((_Bool)1);
      if(rc == 0x00)
      {
        unsigned int return_value_htonl$24;
        return_value_htonl$24=htonl((unsigned int)(signed int)2);
        tmpint32 = (signed int)return_value_htonl$24;
        signed int return_value_tio_write$30;
        return_value_tio_write$30=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$30 == 0))
        {
          signed int *return_value___errno_location$29;
          return_value___errno_location$29=__errno_location();
          if(*return_value___errno_location$29 == 32)
          {
            return_value___errno_location$25=__errno_location();
            return_value_strerror$26=strerror(*return_value___errno_location$25);
            log_log(7, "error writing to client: %s", return_value_strerror$26);
          }

          else
          {
            return_value___errno_location$27=__errno_location();
            return_value_strerror$28=strerror(*return_value___errno_location$27);
            log_log(4, "error writing to client: %s", return_value_strerror$28);
          }
          return -1;
        }

      }

      return 0;
    }
  }
}

// nslcd_netgroup_all
// file common.h line 234
signed int nslcd_netgroup_all(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  const char *filter;
  log_setrequest("netgroup(all)");
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$1;
  signed int return_value_tio_write$7;
  return_value_tio_write$7=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(return_value_tio_write$7 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    if(*return_value___errno_location$6 == 32)
    {
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_log(7, "error writing to client: %s", return_value_strerror$3);
    }

    else
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_log(4, "error writing to client: %s", return_value_strerror$5);
    }
    return -1;
  }

  unsigned int return_value_htonl$8;
  return_value_htonl$8=htonl((unsigned int)(signed int)0x00060008);
  tmpint32 = (signed int)return_value_htonl$8;
  signed int return_value_tio_write$14;
  return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(!(return_value_tio_write$14 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    if(*return_value___errno_location$13 == 32)
    {
      return_value___errno_location$9=__errno_location();
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_log(7, "error writing to client: %s", return_value_strerror$10);
    }

    else
    {
      return_value___errno_location$11=__errno_location();
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      log_log(4, "error writing to client: %s", return_value_strerror$12);
    }
    return -1;
  }

  filter = netgroup_filter;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  i = 0;
  do
  {
    base = netgroup_bases[(signed long int)i];
    if(base == ((const char *)NULL))
      break;

    search=myldap_search(session, base, netgroup_scope, filter, netgroup_attrs, (signed int *)(void *)0);
    if(search == ((struct myldap_search *)NULL))
      return -1;

    do
    {
      entry=myldap_get_entry(search, &rc);
      if(entry == ((struct myldap_entry *)NULL))
        break;

      signed int return_value_write_netgroup$15;
      return_value_write_netgroup$15=write_netgroup(fp, entry, (const char *)(void *)0);
      if(!(return_value_write_netgroup$15 == 0))
        return -1;

    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  if(rc == 0x00)
  {
    unsigned int return_value_htonl$16;
    return_value_htonl$16=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$16;
    signed int return_value_tio_write$22;
    return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$22 == 0))
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      if(*return_value___errno_location$21 == 32)
      {
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        log_log(7, "error writing to client: %s", return_value_strerror$18);
      }

      else
      {
        return_value___errno_location$19=__errno_location();
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        log_log(4, "error writing to client: %s", return_value_strerror$20);
      }
      return -1;
    }

  }

  return 0;
}

// nslcd_netgroup_byname
// file common.h line 233
signed int nslcd_netgroup_byname(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  char name[256l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$16;
  char *return_value_strerror$17;
  signed int *return_value___errno_location$18;
  char *return_value_strerror$19;
  signed int *return_value___errno_location$25;
  char *return_value_strerror$26;
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)name, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    name[(signed long int)tmpint32] = (char)0;
    log_setrequest("netgroup=\"%s\"", (const void *)name);
    unsigned int return_value_htonl$8;
    return_value_htonl$8=htonl((unsigned int)(signed int)0x00000002);
    tmpint32 = (signed int)return_value_htonl$8;
    signed int return_value_tio_write$14;
    return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$14 == 0))
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      if(*return_value___errno_location$13 == 32)
      {
        return_value___errno_location$9=__errno_location();
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        log_log(7, "error writing to client: %s", return_value_strerror$10);
      }

      else
      {
        return_value___errno_location$11=__errno_location();
        return_value_strerror$12=strerror(*return_value___errno_location$11);
        log_log(4, "error writing to client: %s", return_value_strerror$12);
      }
      return -1;
    }

    unsigned int return_value_htonl$15;
    return_value_htonl$15=htonl((unsigned int)(signed int)0x00060001);
    tmpint32 = (signed int)return_value_htonl$15;
    signed int return_value_tio_write$21;
    return_value_tio_write$21=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$21 == 0))
    {
      signed int *return_value___errno_location$20;
      return_value___errno_location$20=__errno_location();
      if(*return_value___errno_location$20 == 32)
      {
        return_value___errno_location$16=__errno_location();
        return_value_strerror$17=strerror(*return_value___errno_location$16);
        log_log(7, "error writing to client: %s", return_value_strerror$17);
      }

      else
      {
        return_value___errno_location$18=__errno_location();
        return_value_strerror$19=strerror(*return_value___errno_location$18);
        log_log(4, "error writing to client: %s", return_value_strerror$19);
      }
      return -1;
    }

    signed int return_value_mkfilter_netgroup_byname$22;
    return_value_mkfilter_netgroup_byname$22=mkfilter_netgroup_byname(name, filter, sizeof(char [4096l]) /*4096ul*/ );
    if(!(return_value_mkfilter_netgroup_byname$22 == 0))
    {
      log_log(3, "nslcd_netgroup_byname(): filter buffer too small");
      return -1;
    }

    else
    {
      i = 0;
      do
      {
        base = netgroup_bases[(signed long int)i];
        if(base == ((const char *)NULL))
          break;

        search=myldap_search(session, base, netgroup_scope, filter, netgroup_attrs, (signed int *)(void *)0);
        if(search == ((struct myldap_search *)NULL))
          return -1;

        do
        {
          entry=myldap_get_entry(search, &rc);
          if(entry == ((struct myldap_entry *)NULL))
            break;

          signed int return_value_write_netgroup$23;
          return_value_write_netgroup$23=write_netgroup(fp, entry, name);
          if(!(return_value_write_netgroup$23 == 0))
            return -1;

        }
        while((_Bool)1);
        i = i + 1;
      }
      while((_Bool)1);
      if(rc == 0x00)
      {
        unsigned int return_value_htonl$24;
        return_value_htonl$24=htonl((unsigned int)(signed int)2);
        tmpint32 = (signed int)return_value_htonl$24;
        signed int return_value_tio_write$30;
        return_value_tio_write$30=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$30 == 0))
        {
          signed int *return_value___errno_location$29;
          return_value___errno_location$29=__errno_location();
          if(*return_value___errno_location$29 == 32)
          {
            return_value___errno_location$25=__errno_location();
            return_value_strerror$26=strerror(*return_value___errno_location$25);
            log_log(7, "error writing to client: %s", return_value_strerror$26);
          }

          else
          {
            return_value___errno_location$27=__errno_location();
            return_value_strerror$28=strerror(*return_value___errno_location$27);
            log_log(4, "error writing to client: %s", return_value_strerror$28);
          }
          return -1;
        }

      }

      return 0;
    }
  }
}

// nslcd_network_all
// file common.h line 237
signed int nslcd_network_all(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  const char *filter;
  log_setrequest("network(all)");
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$1;
  signed int return_value_tio_write$7;
  return_value_tio_write$7=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(return_value_tio_write$7 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    if(*return_value___errno_location$6 == 32)
    {
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_log(7, "error writing to client: %s", return_value_strerror$3);
    }

    else
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_log(4, "error writing to client: %s", return_value_strerror$5);
    }
    return -1;
  }

  unsigned int return_value_htonl$8;
  return_value_htonl$8=htonl((unsigned int)(signed int)0x00070008);
  tmpint32 = (signed int)return_value_htonl$8;
  signed int return_value_tio_write$14;
  return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(!(return_value_tio_write$14 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    if(*return_value___errno_location$13 == 32)
    {
      return_value___errno_location$9=__errno_location();
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_log(7, "error writing to client: %s", return_value_strerror$10);
    }

    else
    {
      return_value___errno_location$11=__errno_location();
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      log_log(4, "error writing to client: %s", return_value_strerror$12);
    }
    return -1;
  }

  filter = network_filter;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  i = 0;
  do
  {
    base = network_bases[(signed long int)i];
    if(base == ((const char *)NULL))
      break;

    search=myldap_search(session, base, network_scope, filter, network_attrs, (signed int *)(void *)0);
    if(search == ((struct myldap_search *)NULL))
      return -1;

    do
    {
      entry=myldap_get_entry(search, &rc);
      if(entry == ((struct myldap_entry *)NULL))
        break;

      signed int return_value_write_network$15;
      return_value_write_network$15=write_network(fp, entry);
      if(!(return_value_write_network$15 == 0))
        return -1;

    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  if(rc == 0x00)
  {
    unsigned int return_value_htonl$16;
    return_value_htonl$16=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$16;
    signed int return_value_tio_write$22;
    return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$22 == 0))
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      if(*return_value___errno_location$21 == 32)
      {
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        log_log(7, "error writing to client: %s", return_value_strerror$18);
      }

      else
      {
        return_value___errno_location$19=__errno_location();
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        log_log(4, "error writing to client: %s", return_value_strerror$20);
      }
      return -1;
    }

  }

  return 0;
}

// nslcd_network_byaddr
// file common.h line 236
signed int nslcd_network_byaddr(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  signed int af;
  char addr[64l];
  signed int len = (signed int)sizeof(char [64l]) /*64ul*/ ;
  char addrstr[64l];
  char filter[4096l];
  len = (signed int)sizeof(char [64l]) /*64ul*/ ;
  signed int return_value_read_address$1;
  return_value_read_address$1=read_address(fp, addr, &len, &af);
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$20;
  char *return_value_strerror$21;
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  if(!(return_value_read_address$1 == 0))
    return -1;

  else
  {
    const char *return_value_inet_ntop$2;
    return_value_inet_ntop$2=inet_ntop(af, (const void *)addr, addrstr, (unsigned int)sizeof(char [64l]) /*64ul*/ );
    if(return_value_inet_ntop$2 == ((const char *)NULL))
    {
      log_log(4, "unable to convert address to string");
      return -1;
    }

    else
    {
      log_setrequest("network=%s", (const void *)addrstr);
      unsigned int return_value_htonl$3;
      return_value_htonl$3=htonl((unsigned int)(signed int)0x00000002);
      tmpint32 = (signed int)return_value_htonl$3;
      signed int return_value_tio_write$9;
      return_value_tio_write$9=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$9 == 0))
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        if(*return_value___errno_location$8 == 32)
        {
          return_value___errno_location$4=__errno_location();
          return_value_strerror$5=strerror(*return_value___errno_location$4);
          log_log(7, "error writing to client: %s", return_value_strerror$5);
        }

        else
        {
          return_value___errno_location$6=__errno_location();
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          log_log(4, "error writing to client: %s", return_value_strerror$7);
        }
        return -1;
      }

      unsigned int return_value_htonl$10;
      return_value_htonl$10=htonl((unsigned int)(signed int)0x00070002);
      tmpint32 = (signed int)return_value_htonl$10;
      signed int return_value_tio_write$16;
      return_value_tio_write$16=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$16 == 0))
      {
        signed int *return_value___errno_location$15;
        return_value___errno_location$15=__errno_location();
        if(*return_value___errno_location$15 == 32)
        {
          return_value___errno_location$11=__errno_location();
          return_value_strerror$12=strerror(*return_value___errno_location$11);
          log_log(7, "error writing to client: %s", return_value_strerror$12);
        }

        else
        {
          return_value___errno_location$13=__errno_location();
          return_value_strerror$14=strerror(*return_value___errno_location$13);
          log_log(4, "error writing to client: %s", return_value_strerror$14);
        }
        return -1;
      }

      signed int return_value_mkfilter_network_byaddr$17;
      return_value_mkfilter_network_byaddr$17=mkfilter_network_byaddr(addrstr, filter, sizeof(char [4096l]) /*4096ul*/ );
      if(!(return_value_mkfilter_network_byaddr$17 == 0))
      {
        log_log(3, "nslcd_network_byaddr(): filter buffer too small");
        return -1;
      }

      else
      {
        i = 0;
        do
        {
          base = network_bases[(signed long int)i];
          if(base == ((const char *)NULL))
            break;

          search=myldap_search(session, base, network_scope, filter, network_attrs, (signed int *)(void *)0);
          if(search == ((struct myldap_search *)NULL))
            return -1;

          do
          {
            entry=myldap_get_entry(search, &rc);
            if(entry == ((struct myldap_entry *)NULL))
              break;

            signed int return_value_write_network$18;
            return_value_write_network$18=write_network(fp, entry);
            if(!(return_value_write_network$18 == 0))
              return -1;

          }
          while((_Bool)1);
          i = i + 1;
        }
        while((_Bool)1);
        if(rc == 0x00)
        {
          unsigned int return_value_htonl$19;
          return_value_htonl$19=htonl((unsigned int)(signed int)2);
          tmpint32 = (signed int)return_value_htonl$19;
          signed int return_value_tio_write$25;
          return_value_tio_write$25=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$25 == 0))
          {
            signed int *return_value___errno_location$24;
            return_value___errno_location$24=__errno_location();
            if(*return_value___errno_location$24 == 32)
            {
              return_value___errno_location$20=__errno_location();
              return_value_strerror$21=strerror(*return_value___errno_location$20);
              log_log(7, "error writing to client: %s", return_value_strerror$21);
            }

            else
            {
              return_value___errno_location$22=__errno_location();
              return_value_strerror$23=strerror(*return_value___errno_location$22);
              log_log(4, "error writing to client: %s", return_value_strerror$23);
            }
            return -1;
          }

        }

        return 0;
      }
    }
  }
}

// nslcd_network_byname
// file common.h line 235
signed int nslcd_network_byname(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  char name[65l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$16;
  char *return_value_strerror$17;
  signed int *return_value___errno_location$18;
  char *return_value_strerror$19;
  signed int *return_value___errno_location$25;
  char *return_value_strerror$26;
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  if((unsigned long int)tmpint32 >= sizeof(char [65l]) /*65ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [65l]) /*65ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)name, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    name[(signed long int)tmpint32] = (char)0;
    log_setrequest("network=\"%s\"", (const void *)name);
    unsigned int return_value_htonl$8;
    return_value_htonl$8=htonl((unsigned int)(signed int)0x00000002);
    tmpint32 = (signed int)return_value_htonl$8;
    signed int return_value_tio_write$14;
    return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$14 == 0))
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      if(*return_value___errno_location$13 == 32)
      {
        return_value___errno_location$9=__errno_location();
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        log_log(7, "error writing to client: %s", return_value_strerror$10);
      }

      else
      {
        return_value___errno_location$11=__errno_location();
        return_value_strerror$12=strerror(*return_value___errno_location$11);
        log_log(4, "error writing to client: %s", return_value_strerror$12);
      }
      return -1;
    }

    unsigned int return_value_htonl$15;
    return_value_htonl$15=htonl((unsigned int)(signed int)0x00070001);
    tmpint32 = (signed int)return_value_htonl$15;
    signed int return_value_tio_write$21;
    return_value_tio_write$21=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$21 == 0))
    {
      signed int *return_value___errno_location$20;
      return_value___errno_location$20=__errno_location();
      if(*return_value___errno_location$20 == 32)
      {
        return_value___errno_location$16=__errno_location();
        return_value_strerror$17=strerror(*return_value___errno_location$16);
        log_log(7, "error writing to client: %s", return_value_strerror$17);
      }

      else
      {
        return_value___errno_location$18=__errno_location();
        return_value_strerror$19=strerror(*return_value___errno_location$18);
        log_log(4, "error writing to client: %s", return_value_strerror$19);
      }
      return -1;
    }

    signed int return_value_mkfilter_network_byname$22;
    return_value_mkfilter_network_byname$22=mkfilter_network_byname(name, filter, sizeof(char [4096l]) /*4096ul*/ );
    if(!(return_value_mkfilter_network_byname$22 == 0))
    {
      log_log(3, "nslcd_network_byname(): filter buffer too small");
      return -1;
    }

    else
    {
      i = 0;
      do
      {
        base = network_bases[(signed long int)i];
        if(base == ((const char *)NULL))
          break;

        search=myldap_search(session, base, network_scope, filter, network_attrs, (signed int *)(void *)0);
        if(search == ((struct myldap_search *)NULL))
          return -1;

        do
        {
          entry=myldap_get_entry(search, &rc);
          if(entry == ((struct myldap_entry *)NULL))
            break;

          signed int return_value_write_network$23;
          return_value_write_network$23=write_network(fp, entry);
          if(!(return_value_write_network$23 == 0))
            return -1;

        }
        while((_Bool)1);
        i = i + 1;
      }
      while((_Bool)1);
      if(rc == 0x00)
      {
        unsigned int return_value_htonl$24;
        return_value_htonl$24=htonl((unsigned int)(signed int)2);
        tmpint32 = (signed int)return_value_htonl$24;
        signed int return_value_tio_write$30;
        return_value_tio_write$30=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$30 == 0))
        {
          signed int *return_value___errno_location$29;
          return_value___errno_location$29=__errno_location();
          if(*return_value___errno_location$29 == 32)
          {
            return_value___errno_location$25=__errno_location();
            return_value_strerror$26=strerror(*return_value___errno_location$25);
            log_log(7, "error writing to client: %s", return_value_strerror$26);
          }

          else
          {
            return_value___errno_location$27=__errno_location();
            return_value_strerror$28=strerror(*return_value___errno_location$27);
            log_log(4, "error writing to client: %s", return_value_strerror$28);
          }
          return -1;
        }

      }

      return 0;
    }
  }
}

// nslcd_pam_authc
// file common.h line 252
signed int nslcd_pam_authc(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid)
{
  signed int tmpint32;
  signed int rc;
  char username[256l];
  char service[256l];
  char ruser[256l];
  char rhost[65l];
  char tty[64l];
  char password[128l];
  const char *userdn;
  struct myldap_entry *entry;
  signed int authzrc = 0;
  char authzmsg[1024l];
  authzmsg[(signed long int)0] = (char)0;
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$44;
  char *return_value_strerror$45;
  signed int *return_value___errno_location$46;
  char *return_value_strerror$47;
  signed int *return_value___errno_location$51;
  char *return_value_strerror$52;
  signed int *return_value___errno_location$53;
  char *return_value_strerror$54;
  signed int *return_value___errno_location$59;
  char *return_value_strerror$60;
  signed int *return_value___errno_location$61;
  char *return_value_strerror$62;
  signed int *return_value___errno_location$66;
  char *return_value_strerror$67;
  signed int *return_value___errno_location$68;
  char *return_value_strerror$69;
  signed int *return_value___errno_location$73;
  char *return_value_strerror$74;
  signed int *return_value___errno_location$75;
  char *return_value_strerror$76;
  signed int *return_value___errno_location$80;
  char *return_value_strerror$81;
  signed int *return_value___errno_location$82;
  char *return_value_strerror$83;
  signed int *return_value___errno_location$88;
  char *return_value_strerror$89;
  signed int *return_value___errno_location$90;
  char *return_value_strerror$91;
  signed int *return_value___errno_location$95;
  char *return_value_strerror$96;
  signed int *return_value___errno_location$97;
  char *return_value_strerror$98;
  signed int *return_value___errno_location$102;
  char *return_value_strerror$103;
  signed int *return_value___errno_location$104;
  char *return_value_strerror$105;
  signed int *return_value___errno_location$109;
  char *return_value_strerror$110;
  signed int *return_value___errno_location$111;
  char *return_value_strerror$112;
  signed int *return_value___errno_location$117;
  char *return_value_strerror$118;
  signed int *return_value___errno_location$119;
  char *return_value_strerror$120;
  signed int *return_value___errno_location$124;
  char *return_value_strerror$125;
  signed int *return_value___errno_location$126;
  char *return_value_strerror$127;
  signed int *return_value___errno_location$131;
  char *return_value_strerror$132;
  signed int *return_value___errno_location$133;
  char *return_value_strerror$134;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)username, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    username[(signed long int)tmpint32] = (char)0;
    signed int return_value_tio_read$10;
    return_value_tio_read$10=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_read$10 == 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error reading from client: %s", return_value_strerror$9);
      return -1;
    }

    unsigned int return_value_ntohl$11;
    return_value_ntohl$11=ntohl((unsigned int)tmpint32);
    tmpint32 = (signed int)return_value_ntohl$11;
    if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
    {
      tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
      log_log(3, "client supplied argument %d bytes too large", tmpint32);
      return -1;
    }

    else
    {
      if(tmpint32 >= 1)
      {
        signed int return_value_tio_read$14;
        return_value_tio_read$14=tio_read(fp, (void *)service, (unsigned long int)tmpint32);
        if(!(return_value_tio_read$14 == 0))
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          char *return_value_strerror$13;
          return_value_strerror$13=strerror(*return_value___errno_location$12);
          log_log(4, "error reading from client: %s", return_value_strerror$13);
          return -1;
        }

      }

      service[(signed long int)tmpint32] = (char)0;
      signed int return_value_tio_read$17;
      return_value_tio_read$17=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_read$17 == 0))
      {
        signed int *return_value___errno_location$15;
        return_value___errno_location$15=__errno_location();
        char *return_value_strerror$16;
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        log_log(4, "error reading from client: %s", return_value_strerror$16);
        return -1;
      }

      unsigned int return_value_ntohl$18;
      return_value_ntohl$18=ntohl((unsigned int)tmpint32);
      tmpint32 = (signed int)return_value_ntohl$18;
      if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
      {
        tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
        log_log(3, "client supplied argument %d bytes too large", tmpint32);
        return -1;
      }

      else
      {
        if(tmpint32 >= 1)
        {
          signed int return_value_tio_read$21;
          return_value_tio_read$21=tio_read(fp, (void *)ruser, (unsigned long int)tmpint32);
          if(!(return_value_tio_read$21 == 0))
          {
            signed int *return_value___errno_location$19;
            return_value___errno_location$19=__errno_location();
            char *return_value_strerror$20;
            return_value_strerror$20=strerror(*return_value___errno_location$19);
            log_log(4, "error reading from client: %s", return_value_strerror$20);
            return -1;
          }

        }

        ruser[(signed long int)tmpint32] = (char)0;
        signed int return_value_tio_read$24;
        return_value_tio_read$24=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_read$24 == 0))
        {
          signed int *return_value___errno_location$22;
          return_value___errno_location$22=__errno_location();
          char *return_value_strerror$23;
          return_value_strerror$23=strerror(*return_value___errno_location$22);
          log_log(4, "error reading from client: %s", return_value_strerror$23);
          return -1;
        }

        unsigned int return_value_ntohl$25;
        return_value_ntohl$25=ntohl((unsigned int)tmpint32);
        tmpint32 = (signed int)return_value_ntohl$25;
        if((unsigned long int)tmpint32 >= sizeof(char [65l]) /*65ul*/ )
        {
          tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [65l]) /*65ul*/ ) + (unsigned long int)1);
          log_log(3, "client supplied argument %d bytes too large", tmpint32);
          return -1;
        }

        else
        {
          if(tmpint32 >= 1)
          {
            signed int return_value_tio_read$28;
            return_value_tio_read$28=tio_read(fp, (void *)rhost, (unsigned long int)tmpint32);
            if(!(return_value_tio_read$28 == 0))
            {
              signed int *return_value___errno_location$26;
              return_value___errno_location$26=__errno_location();
              char *return_value_strerror$27;
              return_value_strerror$27=strerror(*return_value___errno_location$26);
              log_log(4, "error reading from client: %s", return_value_strerror$27);
              return -1;
            }

          }

          rhost[(signed long int)tmpint32] = (char)0;
          signed int return_value_tio_read$31;
          return_value_tio_read$31=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_read$31 == 0))
          {
            signed int *return_value___errno_location$29;
            return_value___errno_location$29=__errno_location();
            char *return_value_strerror$30;
            return_value_strerror$30=strerror(*return_value___errno_location$29);
            log_log(4, "error reading from client: %s", return_value_strerror$30);
            return -1;
          }

          unsigned int return_value_ntohl$32;
          return_value_ntohl$32=ntohl((unsigned int)tmpint32);
          tmpint32 = (signed int)return_value_ntohl$32;
          if((unsigned long int)tmpint32 >= sizeof(char [64l]) /*64ul*/ )
          {
            tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [64l]) /*64ul*/ ) + (unsigned long int)1);
            log_log(3, "client supplied argument %d bytes too large", tmpint32);
            return -1;
          }

          else
          {
            if(tmpint32 >= 1)
            {
              signed int return_value_tio_read$35;
              return_value_tio_read$35=tio_read(fp, (void *)tty, (unsigned long int)tmpint32);
              if(!(return_value_tio_read$35 == 0))
              {
                signed int *return_value___errno_location$33;
                return_value___errno_location$33=__errno_location();
                char *return_value_strerror$34;
                return_value_strerror$34=strerror(*return_value___errno_location$33);
                log_log(4, "error reading from client: %s", return_value_strerror$34);
                return -1;
              }

            }

            tty[(signed long int)tmpint32] = (char)0;
            signed int return_value_tio_read$38;
            return_value_tio_read$38=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_read$38 == 0))
            {
              signed int *return_value___errno_location$36;
              return_value___errno_location$36=__errno_location();
              char *return_value_strerror$37;
              return_value_strerror$37=strerror(*return_value___errno_location$36);
              log_log(4, "error reading from client: %s", return_value_strerror$37);
              return -1;
            }

            unsigned int return_value_ntohl$39;
            return_value_ntohl$39=ntohl((unsigned int)tmpint32);
            tmpint32 = (signed int)return_value_ntohl$39;
            if((unsigned long int)tmpint32 >= sizeof(char [128l]) /*128ul*/ )
            {
              tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [128l]) /*128ul*/ ) + (unsigned long int)1);
              log_log(3, "client supplied argument %d bytes too large", tmpint32);
              return -1;
            }

            else
            {
              if(tmpint32 >= 1)
              {
                signed int return_value_tio_read$42;
                return_value_tio_read$42=tio_read(fp, (void *)password, (unsigned long int)tmpint32);
                if(!(return_value_tio_read$42 == 0))
                {
                  signed int *return_value___errno_location$40;
                  return_value___errno_location$40=__errno_location();
                  char *return_value_strerror$41;
                  return_value_strerror$41=strerror(*return_value___errno_location$40);
                  log_log(4, "error reading from client: %s", return_value_strerror$41);
                  return -1;
                }

              }

              password[(signed long int)tmpint32] = (char)0;
              log_setrequest("authc=\"%s\"", (const void *)username);
              log_log(7, "nslcd_pam_authc(\"%s\",\"%s\",\"%s\")", (const void *)username, (const void *)service, password[0l] != 0 ? "***" : "");
              unsigned int return_value_htonl$43;
              return_value_htonl$43=htonl((unsigned int)(signed int)0x00000002);
              tmpint32 = (signed int)return_value_htonl$43;
              signed int return_value_tio_write$49;
              return_value_tio_write$49=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$49 == 0))
              {
                signed int *return_value___errno_location$48;
                return_value___errno_location$48=__errno_location();
                if(*return_value___errno_location$48 == 32)
                {
                  return_value___errno_location$44=__errno_location();
                  return_value_strerror$45=strerror(*return_value___errno_location$44);
                  log_log(7, "error writing to client: %s", return_value_strerror$45);
                }

                else
                {
                  return_value___errno_location$46=__errno_location();
                  return_value_strerror$47=strerror(*return_value___errno_location$46);
                  log_log(4, "error writing to client: %s", return_value_strerror$47);
                }
                return -1;
              }

              unsigned int return_value_htonl$50;
              return_value_htonl$50=htonl((unsigned int)(signed int)0x000d0001);
              tmpint32 = (signed int)return_value_htonl$50;
              signed int return_value_tio_write$56;
              return_value_tio_write$56=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$56 == 0))
              {
                signed int *return_value___errno_location$55;
                return_value___errno_location$55=__errno_location();
                if(*return_value___errno_location$55 == 32)
                {
                  return_value___errno_location$51=__errno_location();
                  return_value_strerror$52=strerror(*return_value___errno_location$51);
                  log_log(7, "error writing to client: %s", return_value_strerror$52);
                }

                else
                {
                  return_value___errno_location$53=__errno_location();
                  return_value_strerror$54=strerror(*return_value___errno_location$53);
                  log_log(4, "error writing to client: %s", return_value_strerror$54);
                }
                return -1;
              }

              if((signed int)username[0l] == 0)
              {
                if(nslcd_cfg->rootpwmoddn == ((char *)NULL))
                {
                  log_log(5, "rootpwmoddn not configured");
                  memset((void *)password, 0, sizeof(char [128l]) /*128ul*/ );
                  return -1;
                }

                userdn = nslcd_cfg->rootpwmoddn;
                if((signed int)password[0l] == 0)
                {
                  if(calleruid == 0u)
                  {
                    if(!(nslcd_cfg->rootpwmodpw == ((char *)NULL)))
                    {
                      unsigned long int return_value_strlen$57;
                      return_value_strlen$57=strlen(nslcd_cfg->rootpwmodpw);
                      if(return_value_strlen$57 >= sizeof(char [128l]) /*128ul*/ )
                      {
                        log_log(3, "nslcd_pam_authc(): rootpwmodpw will not fit in password");
                        memset((void *)password, 0, sizeof(char [128l]) /*128ul*/ );
                        return -1;
                      }

                      strcpy(password, nslcd_cfg->rootpwmodpw);
                    }

                  }

                }

              }

              else
              {
                entry=validate_user(session, username, &rc);
                if(entry == ((struct myldap_entry *)NULL))
                {
                  if(rc == 0x20)
                  {
                    unsigned int return_value_htonl$58;
                    return_value_htonl$58=htonl((unsigned int)(signed int)2);
                    tmpint32 = (signed int)return_value_htonl$58;
                    signed int return_value_tio_write$64;
                    return_value_tio_write$64=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                    if(!(return_value_tio_write$64 == 0))
                    {
                      signed int *return_value___errno_location$63;
                      return_value___errno_location$63=__errno_location();
                      if(*return_value___errno_location$63 == 32)
                      {
                        return_value___errno_location$59=__errno_location();
                        return_value_strerror$60=strerror(*return_value___errno_location$59);
                        log_log(7, "error writing to client: %s", return_value_strerror$60);
                      }

                      else
                      {
                        return_value___errno_location$61=__errno_location();
                        return_value_strerror$62=strerror(*return_value___errno_location$61);
                        log_log(4, "error writing to client: %s", return_value_strerror$62);
                      }
                      return -1;
                    }

                  }

                  memset((void *)password, 0, sizeof(char [128l]) /*128ul*/ );
                  return -1;
                }

                userdn=myldap_get_dn(entry);
                update_username(entry, username, sizeof(char [256l]) /*256ul*/ );
              }
              rc=try_bind(userdn, password, &authzrc, authzmsg, sizeof(char [1024l]) /*1024ul*/ );
              if(rc == 0x00)
                log_log(7, "bind successful");

              switch(rc)
              {
                case 0x00:
                {
                  rc = 0;
                  break;
                }
                case 0x31:
                {
                  rc = 7;
                  break;
                }
                default:
                  rc = 7;
              }
              if(!((signed int)username[0l] == 0))
              {
                if(authzrc == 0)
                  authzrc=check_shadow(session, username, authzmsg, sizeof(char [1024l]) /*1024ul*/ , 1, 0);

              }

              unsigned int return_value_htonl$65;
              return_value_htonl$65=htonl((unsigned int)(signed int)1);
              tmpint32 = (signed int)return_value_htonl$65;
              signed int return_value_tio_write$71;
              return_value_tio_write$71=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$71 == 0))
              {
                signed int *return_value___errno_location$70;
                return_value___errno_location$70=__errno_location();
                if(*return_value___errno_location$70 == 32)
                {
                  return_value___errno_location$66=__errno_location();
                  return_value_strerror$67=strerror(*return_value___errno_location$66);
                  log_log(7, "error writing to client: %s", return_value_strerror$67);
                }

                else
                {
                  return_value___errno_location$68=__errno_location();
                  return_value_strerror$69=strerror(*return_value___errno_location$68);
                  log_log(4, "error writing to client: %s", return_value_strerror$69);
                }
                return -1;
              }

              unsigned int return_value_htonl$72;
              return_value_htonl$72=htonl((unsigned int)(signed int)rc);
              tmpint32 = (signed int)return_value_htonl$72;
              signed int return_value_tio_write$78;
              return_value_tio_write$78=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$78 == 0))
              {
                signed int *return_value___errno_location$77;
                return_value___errno_location$77=__errno_location();
                if(*return_value___errno_location$77 == 32)
                {
                  return_value___errno_location$73=__errno_location();
                  return_value_strerror$74=strerror(*return_value___errno_location$73);
                  log_log(7, "error writing to client: %s", return_value_strerror$74);
                }

                else
                {
                  return_value___errno_location$75=__errno_location();
                  return_value_strerror$76=strerror(*return_value___errno_location$75);
                  log_log(4, "error writing to client: %s", return_value_strerror$76);
                }
                return -1;
              }

              {
                unsigned long int return_value_strlen$86;
                return_value_strlen$86=strlen(username);
                unsigned int return_value_htonl$87;
                return_value_htonl$87=htonl((unsigned int)(signed int)return_value_strlen$86);
                tmpint32 = (signed int)return_value_htonl$87;
                signed int return_value_tio_write$93;
                return_value_tio_write$93=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                if(!(return_value_tio_write$93 == 0))
                {
                  signed int *return_value___errno_location$92;
                  return_value___errno_location$92=__errno_location();
                  if(*return_value___errno_location$92 == 32)
                  {
                    return_value___errno_location$88=__errno_location();
                    return_value_strerror$89=strerror(*return_value___errno_location$88);
                    log_log(7, "error writing to client: %s", return_value_strerror$89);
                  }

                  else
                  {
                    return_value___errno_location$90=__errno_location();
                    return_value_strerror$91=strerror(*return_value___errno_location$90);
                    log_log(4, "error writing to client: %s", return_value_strerror$91);
                  }
                  return -1;
                }

                unsigned int return_value_ntohl$94;
                return_value_ntohl$94=ntohl((unsigned int)tmpint32);
                tmpint32 = (signed int)return_value_ntohl$94;
                if(tmpint32 >= 1)
                {
                  signed int return_value_tio_write$100;
                  return_value_tio_write$100=tio_write(fp, (const void *)username, (unsigned long int)tmpint32);
                  if(!(return_value_tio_write$100 == 0))
                  {
                    signed int *return_value___errno_location$99;
                    return_value___errno_location$99=__errno_location();
                    if(*return_value___errno_location$99 == 32)
                    {
                      return_value___errno_location$95=__errno_location();
                      return_value_strerror$96=strerror(*return_value___errno_location$95);
                      log_log(7, "error writing to client: %s", return_value_strerror$96);
                    }

                    else
                    {
                      return_value___errno_location$97=__errno_location();
                      return_value_strerror$98=strerror(*return_value___errno_location$97);
                      log_log(4, "error writing to client: %s", return_value_strerror$98);
                    }
                    return -1;
                  }

                }

              }
              unsigned int return_value_htonl$101;
              return_value_htonl$101=htonl((unsigned int)(signed int)authzrc);
              tmpint32 = (signed int)return_value_htonl$101;
              signed int return_value_tio_write$107;
              return_value_tio_write$107=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$107 == 0))
              {
                signed int *return_value___errno_location$106;
                return_value___errno_location$106=__errno_location();
                if(*return_value___errno_location$106 == 32)
                {
                  return_value___errno_location$102=__errno_location();
                  return_value_strerror$103=strerror(*return_value___errno_location$102);
                  log_log(7, "error writing to client: %s", return_value_strerror$103);
                }

                else
                {
                  return_value___errno_location$104=__errno_location();
                  return_value_strerror$105=strerror(*return_value___errno_location$104);
                  log_log(4, "error writing to client: %s", return_value_strerror$105);
                }
                return -1;
              }

              {
                unsigned long int return_value_strlen$115;
                return_value_strlen$115=strlen(authzmsg);
                unsigned int return_value_htonl$116;
                return_value_htonl$116=htonl((unsigned int)(signed int)return_value_strlen$115);
                tmpint32 = (signed int)return_value_htonl$116;
                signed int return_value_tio_write$122;
                return_value_tio_write$122=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                if(!(return_value_tio_write$122 == 0))
                {
                  signed int *return_value___errno_location$121;
                  return_value___errno_location$121=__errno_location();
                  if(*return_value___errno_location$121 == 32)
                  {
                    return_value___errno_location$117=__errno_location();
                    return_value_strerror$118=strerror(*return_value___errno_location$117);
                    log_log(7, "error writing to client: %s", return_value_strerror$118);
                  }

                  else
                  {
                    return_value___errno_location$119=__errno_location();
                    return_value_strerror$120=strerror(*return_value___errno_location$119);
                    log_log(4, "error writing to client: %s", return_value_strerror$120);
                  }
                  return -1;
                }

                unsigned int return_value_ntohl$123;
                return_value_ntohl$123=ntohl((unsigned int)tmpint32);
                tmpint32 = (signed int)return_value_ntohl$123;
                if(tmpint32 >= 1)
                {
                  signed int return_value_tio_write$129;
                  return_value_tio_write$129=tio_write(fp, (const void *)authzmsg, (unsigned long int)tmpint32);
                  if(!(return_value_tio_write$129 == 0))
                  {
                    signed int *return_value___errno_location$128;
                    return_value___errno_location$128=__errno_location();
                    if(*return_value___errno_location$128 == 32)
                    {
                      return_value___errno_location$124=__errno_location();
                      return_value_strerror$125=strerror(*return_value___errno_location$124);
                      log_log(7, "error writing to client: %s", return_value_strerror$125);
                    }

                    else
                    {
                      return_value___errno_location$126=__errno_location();
                      return_value_strerror$127=strerror(*return_value___errno_location$126);
                      log_log(4, "error writing to client: %s", return_value_strerror$127);
                    }
                    return -1;
                  }

                }

              }
              unsigned int return_value_htonl$130;
              return_value_htonl$130=htonl((unsigned int)(signed int)2);
              tmpint32 = (signed int)return_value_htonl$130;
              signed int return_value_tio_write$136;
              return_value_tio_write$136=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$136 == 0))
              {
                signed int *return_value___errno_location$135;
                return_value___errno_location$135=__errno_location();
                if(*return_value___errno_location$135 == 32)
                {
                  return_value___errno_location$131=__errno_location();
                  return_value_strerror$132=strerror(*return_value___errno_location$131);
                  log_log(7, "error writing to client: %s", return_value_strerror$132);
                }

                else
                {
                  return_value___errno_location$133=__errno_location();
                  return_value_strerror$134=strerror(*return_value___errno_location$133);
                  log_log(4, "error writing to client: %s", return_value_strerror$134);
                }
                return -1;
              }

              memset((void *)password, 0, sizeof(char [128l]) /*128ul*/ );
              return 0;
            }
          }
        }
      }
    }
  }
}

// nslcd_pam_authz
// file common.h line 253
signed int nslcd_pam_authz(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  signed int rc;
  char username[256l];
  char service[256l];
  char ruser[256l];
  char rhost[65l];
  char tty[64l];
  struct myldap_entry *entry;
  char authzmsg[1024l];
  authzmsg[(signed long int)0] = (char)0;
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$37;
  char *return_value_strerror$38;
  signed int *return_value___errno_location$39;
  char *return_value_strerror$40;
  signed int *return_value___errno_location$44;
  char *return_value_strerror$45;
  signed int *return_value___errno_location$46;
  char *return_value_strerror$47;
  signed int *return_value___errno_location$51;
  char *return_value_strerror$52;
  signed int *return_value___errno_location$53;
  char *return_value_strerror$54;
  signed int *return_value___errno_location$59;
  char *return_value_strerror$60;
  signed int *return_value___errno_location$61;
  char *return_value_strerror$62;
  signed int *return_value___errno_location$66;
  char *return_value_strerror$67;
  signed int *return_value___errno_location$68;
  char *return_value_strerror$69;
  signed int *return_value___errno_location$73;
  char *return_value_strerror$74;
  signed int *return_value___errno_location$75;
  char *return_value_strerror$76;
  signed int *return_value___errno_location$81;
  char *return_value_strerror$82;
  signed int *return_value___errno_location$83;
  char *return_value_strerror$84;
  signed int *return_value___errno_location$88;
  char *return_value_strerror$89;
  signed int *return_value___errno_location$90;
  char *return_value_strerror$91;
  signed int *return_value___errno_location$95;
  char *return_value_strerror$96;
  signed int *return_value___errno_location$97;
  char *return_value_strerror$98;
  signed int *return_value___errno_location$102;
  char *return_value_strerror$103;
  signed int *return_value___errno_location$104;
  char *return_value_strerror$105;
  signed int *return_value___errno_location$109;
  char *return_value_strerror$110;
  signed int *return_value___errno_location$111;
  char *return_value_strerror$112;
  signed int *return_value___errno_location$116;
  char *return_value_strerror$117;
  signed int *return_value___errno_location$118;
  char *return_value_strerror$119;
  signed int *return_value___errno_location$124;
  char *return_value_strerror$125;
  signed int *return_value___errno_location$126;
  char *return_value_strerror$127;
  signed int *return_value___errno_location$131;
  char *return_value_strerror$132;
  signed int *return_value___errno_location$133;
  char *return_value_strerror$134;
  signed int *return_value___errno_location$138;
  char *return_value_strerror$139;
  signed int *return_value___errno_location$140;
  char *return_value_strerror$141;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)username, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    username[(signed long int)tmpint32] = (char)0;
    signed int return_value_tio_read$10;
    return_value_tio_read$10=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_read$10 == 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error reading from client: %s", return_value_strerror$9);
      return -1;
    }

    unsigned int return_value_ntohl$11;
    return_value_ntohl$11=ntohl((unsigned int)tmpint32);
    tmpint32 = (signed int)return_value_ntohl$11;
    if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
    {
      tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
      log_log(3, "client supplied argument %d bytes too large", tmpint32);
      return -1;
    }

    else
    {
      if(tmpint32 >= 1)
      {
        signed int return_value_tio_read$14;
        return_value_tio_read$14=tio_read(fp, (void *)service, (unsigned long int)tmpint32);
        if(!(return_value_tio_read$14 == 0))
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          char *return_value_strerror$13;
          return_value_strerror$13=strerror(*return_value___errno_location$12);
          log_log(4, "error reading from client: %s", return_value_strerror$13);
          return -1;
        }

      }

      service[(signed long int)tmpint32] = (char)0;
      signed int return_value_tio_read$17;
      return_value_tio_read$17=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_read$17 == 0))
      {
        signed int *return_value___errno_location$15;
        return_value___errno_location$15=__errno_location();
        char *return_value_strerror$16;
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        log_log(4, "error reading from client: %s", return_value_strerror$16);
        return -1;
      }

      unsigned int return_value_ntohl$18;
      return_value_ntohl$18=ntohl((unsigned int)tmpint32);
      tmpint32 = (signed int)return_value_ntohl$18;
      if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
      {
        tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
        log_log(3, "client supplied argument %d bytes too large", tmpint32);
        return -1;
      }

      else
      {
        if(tmpint32 >= 1)
        {
          signed int return_value_tio_read$21;
          return_value_tio_read$21=tio_read(fp, (void *)ruser, (unsigned long int)tmpint32);
          if(!(return_value_tio_read$21 == 0))
          {
            signed int *return_value___errno_location$19;
            return_value___errno_location$19=__errno_location();
            char *return_value_strerror$20;
            return_value_strerror$20=strerror(*return_value___errno_location$19);
            log_log(4, "error reading from client: %s", return_value_strerror$20);
            return -1;
          }

        }

        ruser[(signed long int)tmpint32] = (char)0;
        signed int return_value_tio_read$24;
        return_value_tio_read$24=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_read$24 == 0))
        {
          signed int *return_value___errno_location$22;
          return_value___errno_location$22=__errno_location();
          char *return_value_strerror$23;
          return_value_strerror$23=strerror(*return_value___errno_location$22);
          log_log(4, "error reading from client: %s", return_value_strerror$23);
          return -1;
        }

        unsigned int return_value_ntohl$25;
        return_value_ntohl$25=ntohl((unsigned int)tmpint32);
        tmpint32 = (signed int)return_value_ntohl$25;
        if((unsigned long int)tmpint32 >= sizeof(char [65l]) /*65ul*/ )
        {
          tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [65l]) /*65ul*/ ) + (unsigned long int)1);
          log_log(3, "client supplied argument %d bytes too large", tmpint32);
          return -1;
        }

        else
        {
          if(tmpint32 >= 1)
          {
            signed int return_value_tio_read$28;
            return_value_tio_read$28=tio_read(fp, (void *)rhost, (unsigned long int)tmpint32);
            if(!(return_value_tio_read$28 == 0))
            {
              signed int *return_value___errno_location$26;
              return_value___errno_location$26=__errno_location();
              char *return_value_strerror$27;
              return_value_strerror$27=strerror(*return_value___errno_location$26);
              log_log(4, "error reading from client: %s", return_value_strerror$27);
              return -1;
            }

          }

          rhost[(signed long int)tmpint32] = (char)0;
          signed int return_value_tio_read$31;
          return_value_tio_read$31=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_read$31 == 0))
          {
            signed int *return_value___errno_location$29;
            return_value___errno_location$29=__errno_location();
            char *return_value_strerror$30;
            return_value_strerror$30=strerror(*return_value___errno_location$29);
            log_log(4, "error reading from client: %s", return_value_strerror$30);
            return -1;
          }

          unsigned int return_value_ntohl$32;
          return_value_ntohl$32=ntohl((unsigned int)tmpint32);
          tmpint32 = (signed int)return_value_ntohl$32;
          if((unsigned long int)tmpint32 >= sizeof(char [64l]) /*64ul*/ )
          {
            tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [64l]) /*64ul*/ ) + (unsigned long int)1);
            log_log(3, "client supplied argument %d bytes too large", tmpint32);
            return -1;
          }

          else
          {
            if(tmpint32 >= 1)
            {
              signed int return_value_tio_read$35;
              return_value_tio_read$35=tio_read(fp, (void *)tty, (unsigned long int)tmpint32);
              if(!(return_value_tio_read$35 == 0))
              {
                signed int *return_value___errno_location$33;
                return_value___errno_location$33=__errno_location();
                char *return_value_strerror$34;
                return_value_strerror$34=strerror(*return_value___errno_location$33);
                log_log(4, "error reading from client: %s", return_value_strerror$34);
                return -1;
              }

            }

            tty[(signed long int)tmpint32] = (char)0;
            log_setrequest("authz=\"%s\"", (const void *)username);
            log_log(7, "nslcd_pam_authz(\"%s\",\"%s\",\"%s\",\"%s\",\"%s\")", (const void *)username, (const void *)service, (const void *)ruser, (const void *)rhost, (const void *)tty);
            unsigned int return_value_htonl$36;
            return_value_htonl$36=htonl((unsigned int)(signed int)0x00000002);
            tmpint32 = (signed int)return_value_htonl$36;
            signed int return_value_tio_write$42;
            return_value_tio_write$42=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$42 == 0))
            {
              signed int *return_value___errno_location$41;
              return_value___errno_location$41=__errno_location();
              if(*return_value___errno_location$41 == 32)
              {
                return_value___errno_location$37=__errno_location();
                return_value_strerror$38=strerror(*return_value___errno_location$37);
                log_log(7, "error writing to client: %s", return_value_strerror$38);
              }

              else
              {
                return_value___errno_location$39=__errno_location();
                return_value_strerror$40=strerror(*return_value___errno_location$39);
                log_log(4, "error writing to client: %s", return_value_strerror$40);
              }
              return -1;
            }

            unsigned int return_value_htonl$43;
            return_value_htonl$43=htonl((unsigned int)(signed int)0x000d0002);
            tmpint32 = (signed int)return_value_htonl$43;
            signed int return_value_tio_write$49;
            return_value_tio_write$49=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$49 == 0))
            {
              signed int *return_value___errno_location$48;
              return_value___errno_location$48=__errno_location();
              if(*return_value___errno_location$48 == 32)
              {
                return_value___errno_location$44=__errno_location();
                return_value_strerror$45=strerror(*return_value___errno_location$44);
                log_log(7, "error writing to client: %s", return_value_strerror$45);
              }

              else
              {
                return_value___errno_location$46=__errno_location();
                return_value_strerror$47=strerror(*return_value___errno_location$46);
                log_log(4, "error writing to client: %s", return_value_strerror$47);
              }
              return -1;
            }

            entry=validate_user(session, username, &rc);
            if(entry == ((struct myldap_entry *)NULL))
            {
              if(rc == 0x20)
              {
                unsigned int return_value_htonl$50;
                return_value_htonl$50=htonl((unsigned int)(signed int)2);
                tmpint32 = (signed int)return_value_htonl$50;
                signed int return_value_tio_write$56;
                return_value_tio_write$56=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                if(!(return_value_tio_write$56 == 0))
                {
                  signed int *return_value___errno_location$55;
                  return_value___errno_location$55=__errno_location();
                  if(*return_value___errno_location$55 == 32)
                  {
                    return_value___errno_location$51=__errno_location();
                    return_value_strerror$52=strerror(*return_value___errno_location$51);
                    log_log(7, "error writing to client: %s", return_value_strerror$52);
                  }

                  else
                  {
                    return_value___errno_location$53=__errno_location();
                    return_value_strerror$54=strerror(*return_value___errno_location$53);
                    log_log(4, "error writing to client: %s", return_value_strerror$54);
                  }
                  return -1;
                }

              }

              return -1;
            }

            else
            {
              const char *return_value_myldap_get_dn$57;
              return_value_myldap_get_dn$57=myldap_get_dn(entry);
              rc=try_autzsearch(session, return_value_myldap_get_dn$57, username, service, ruser, rhost, tty);
              if(!(rc == 0x00))
              {
                unsigned int return_value_htonl$58;
                return_value_htonl$58=htonl((unsigned int)(signed int)1);
                tmpint32 = (signed int)return_value_htonl$58;
                signed int return_value_tio_write$64;
                return_value_tio_write$64=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                if(!(return_value_tio_write$64 == 0))
                {
                  signed int *return_value___errno_location$63;
                  return_value___errno_location$63=__errno_location();
                  if(*return_value___errno_location$63 == 32)
                  {
                    return_value___errno_location$59=__errno_location();
                    return_value_strerror$60=strerror(*return_value___errno_location$59);
                    log_log(7, "error writing to client: %s", return_value_strerror$60);
                  }

                  else
                  {
                    return_value___errno_location$61=__errno_location();
                    return_value_strerror$62=strerror(*return_value___errno_location$61);
                    log_log(4, "error writing to client: %s", return_value_strerror$62);
                  }
                  return -1;
                }

                unsigned int return_value_htonl$65;
                return_value_htonl$65=htonl((unsigned int)(signed int)6);
                tmpint32 = (signed int)return_value_htonl$65;
                signed int return_value_tio_write$71;
                return_value_tio_write$71=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                if(!(return_value_tio_write$71 == 0))
                {
                  signed int *return_value___errno_location$70;
                  return_value___errno_location$70=__errno_location();
                  if(*return_value___errno_location$70 == 32)
                  {
                    return_value___errno_location$66=__errno_location();
                    return_value_strerror$67=strerror(*return_value___errno_location$66);
                    log_log(7, "error writing to client: %s", return_value_strerror$67);
                  }

                  else
                  {
                    return_value___errno_location$68=__errno_location();
                    return_value_strerror$69=strerror(*return_value___errno_location$68);
                    log_log(4, "error writing to client: %s", return_value_strerror$69);
                  }
                  return -1;
                }

                {
                  unsigned long int return_value_strlen$79;
                  return_value_strlen$79=strlen("LDAP authorisation check failed");
                  unsigned int return_value_htonl$80;
                  return_value_htonl$80=htonl((unsigned int)(signed int)return_value_strlen$79);
                  tmpint32 = (signed int)return_value_htonl$80;
                  signed int return_value_tio_write$86;
                  return_value_tio_write$86=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                  if(!(return_value_tio_write$86 == 0))
                  {
                    signed int *return_value___errno_location$85;
                    return_value___errno_location$85=__errno_location();
                    if(*return_value___errno_location$85 == 32)
                    {
                      return_value___errno_location$81=__errno_location();
                      return_value_strerror$82=strerror(*return_value___errno_location$81);
                      log_log(7, "error writing to client: %s", return_value_strerror$82);
                    }

                    else
                    {
                      return_value___errno_location$83=__errno_location();
                      return_value_strerror$84=strerror(*return_value___errno_location$83);
                      log_log(4, "error writing to client: %s", return_value_strerror$84);
                    }
                    return -1;
                  }

                  unsigned int return_value_ntohl$87;
                  return_value_ntohl$87=ntohl((unsigned int)tmpint32);
                  tmpint32 = (signed int)return_value_ntohl$87;
                  if(tmpint32 >= 1)
                  {
                    signed int return_value_tio_write$93;
                    return_value_tio_write$93=tio_write(fp, (const void *)"LDAP authorisation check failed", (unsigned long int)tmpint32);
                    if(!(return_value_tio_write$93 == 0))
                    {
                      signed int *return_value___errno_location$92;
                      return_value___errno_location$92=__errno_location();
                      if(*return_value___errno_location$92 == 32)
                      {
                        return_value___errno_location$88=__errno_location();
                        return_value_strerror$89=strerror(*return_value___errno_location$88);
                        log_log(7, "error writing to client: %s", return_value_strerror$89);
                      }

                      else
                      {
                        return_value___errno_location$90=__errno_location();
                        return_value_strerror$91=strerror(*return_value___errno_location$90);
                        log_log(4, "error writing to client: %s", return_value_strerror$91);
                      }
                      return -1;
                    }

                  }

                }
                unsigned int return_value_htonl$94;
                return_value_htonl$94=htonl((unsigned int)(signed int)2);
                tmpint32 = (signed int)return_value_htonl$94;
                signed int return_value_tio_write$100;
                return_value_tio_write$100=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                if(!(return_value_tio_write$100 == 0))
                {
                  signed int *return_value___errno_location$99;
                  return_value___errno_location$99=__errno_location();
                  if(*return_value___errno_location$99 == 32)
                  {
                    return_value___errno_location$95=__errno_location();
                    return_value_strerror$96=strerror(*return_value___errno_location$95);
                    log_log(7, "error writing to client: %s", return_value_strerror$96);
                  }

                  else
                  {
                    return_value___errno_location$97=__errno_location();
                    return_value_strerror$98=strerror(*return_value___errno_location$97);
                    log_log(4, "error writing to client: %s", return_value_strerror$98);
                  }
                  return -1;
                }

                return 0;
              }

              rc=check_shadow(session, username, authzmsg, sizeof(char [1024l]) /*1024ul*/ , 0, 0);
              unsigned int return_value_htonl$101;
              return_value_htonl$101=htonl((unsigned int)(signed int)1);
              tmpint32 = (signed int)return_value_htonl$101;
              signed int return_value_tio_write$107;
              return_value_tio_write$107=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$107 == 0))
              {
                signed int *return_value___errno_location$106;
                return_value___errno_location$106=__errno_location();
                if(*return_value___errno_location$106 == 32)
                {
                  return_value___errno_location$102=__errno_location();
                  return_value_strerror$103=strerror(*return_value___errno_location$102);
                  log_log(7, "error writing to client: %s", return_value_strerror$103);
                }

                else
                {
                  return_value___errno_location$104=__errno_location();
                  return_value_strerror$105=strerror(*return_value___errno_location$104);
                  log_log(4, "error writing to client: %s", return_value_strerror$105);
                }
                return -1;
              }

              unsigned int return_value_htonl$108;
              return_value_htonl$108=htonl((unsigned int)(signed int)rc);
              tmpint32 = (signed int)return_value_htonl$108;
              signed int return_value_tio_write$114;
              return_value_tio_write$114=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$114 == 0))
              {
                signed int *return_value___errno_location$113;
                return_value___errno_location$113=__errno_location();
                if(*return_value___errno_location$113 == 32)
                {
                  return_value___errno_location$109=__errno_location();
                  return_value_strerror$110=strerror(*return_value___errno_location$109);
                  log_log(7, "error writing to client: %s", return_value_strerror$110);
                }

                else
                {
                  return_value___errno_location$111=__errno_location();
                  return_value_strerror$112=strerror(*return_value___errno_location$111);
                  log_log(4, "error writing to client: %s", return_value_strerror$112);
                }
                return -1;
              }

              {
                unsigned long int return_value_strlen$122;
                return_value_strlen$122=strlen(authzmsg);
                unsigned int return_value_htonl$123;
                return_value_htonl$123=htonl((unsigned int)(signed int)return_value_strlen$122);
                tmpint32 = (signed int)return_value_htonl$123;
                signed int return_value_tio_write$129;
                return_value_tio_write$129=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                if(!(return_value_tio_write$129 == 0))
                {
                  signed int *return_value___errno_location$128;
                  return_value___errno_location$128=__errno_location();
                  if(*return_value___errno_location$128 == 32)
                  {
                    return_value___errno_location$124=__errno_location();
                    return_value_strerror$125=strerror(*return_value___errno_location$124);
                    log_log(7, "error writing to client: %s", return_value_strerror$125);
                  }

                  else
                  {
                    return_value___errno_location$126=__errno_location();
                    return_value_strerror$127=strerror(*return_value___errno_location$126);
                    log_log(4, "error writing to client: %s", return_value_strerror$127);
                  }
                  return -1;
                }

                unsigned int return_value_ntohl$130;
                return_value_ntohl$130=ntohl((unsigned int)tmpint32);
                tmpint32 = (signed int)return_value_ntohl$130;
                if(tmpint32 >= 1)
                {
                  signed int return_value_tio_write$136;
                  return_value_tio_write$136=tio_write(fp, (const void *)authzmsg, (unsigned long int)tmpint32);
                  if(!(return_value_tio_write$136 == 0))
                  {
                    signed int *return_value___errno_location$135;
                    return_value___errno_location$135=__errno_location();
                    if(*return_value___errno_location$135 == 32)
                    {
                      return_value___errno_location$131=__errno_location();
                      return_value_strerror$132=strerror(*return_value___errno_location$131);
                      log_log(7, "error writing to client: %s", return_value_strerror$132);
                    }

                    else
                    {
                      return_value___errno_location$133=__errno_location();
                      return_value_strerror$134=strerror(*return_value___errno_location$133);
                      log_log(4, "error writing to client: %s", return_value_strerror$134);
                    }
                    return -1;
                  }

                }

              }
              unsigned int return_value_htonl$137;
              return_value_htonl$137=htonl((unsigned int)(signed int)2);
              tmpint32 = (signed int)return_value_htonl$137;
              signed int return_value_tio_write$143;
              return_value_tio_write$143=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$143 == 0))
              {
                signed int *return_value___errno_location$142;
                return_value___errno_location$142=__errno_location();
                if(*return_value___errno_location$142 == 32)
                {
                  return_value___errno_location$138=__errno_location();
                  return_value_strerror$139=strerror(*return_value___errno_location$138);
                  log_log(7, "error writing to client: %s", return_value_strerror$139);
                }

                else
                {
                  return_value___errno_location$140=__errno_location();
                  return_value_strerror$141=strerror(*return_value___errno_location$140);
                  log_log(4, "error writing to client: %s", return_value_strerror$141);
                }
                return -1;
              }

              return 0;
            }
          }
        }
      }
    }
  }
}

// nslcd_pam_pwmod
// file common.h line 256
signed int nslcd_pam_pwmod(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid)
{
  signed int tmpint32;
  signed int rc;
  char username[256l];
  char service[256l];
  char ruser[256l];
  char rhost[65l];
  char tty[64l];
  signed int asroot;
  char oldpassword[128l];
  char newpassword[128l];
  const char *binddn = (const char *)(void *)0;
  struct myldap_entry *entry;
  char authzmsg[1024l];
  authzmsg[(signed long int)0] = (char)0;
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$55;
  char *return_value_strerror$56;
  signed int *return_value___errno_location$57;
  char *return_value_strerror$58;
  signed int *return_value___errno_location$62;
  char *return_value_strerror$63;
  signed int *return_value___errno_location$64;
  char *return_value_strerror$65;
  signed int *return_value___errno_location$69;
  char *return_value_strerror$70;
  signed int *return_value___errno_location$71;
  char *return_value_strerror$72;
  signed int *return_value___errno_location$76;
  char *return_value_strerror$77;
  signed int *return_value___errno_location$78;
  char *return_value_strerror$79;
  signed int *return_value___errno_location$83;
  char *return_value_strerror$84;
  signed int *return_value___errno_location$85;
  char *return_value_strerror$86;
  signed int *return_value___errno_location$90;
  char *return_value_strerror$91;
  signed int *return_value___errno_location$92;
  char *return_value_strerror$93;
  signed int *return_value___errno_location$98;
  char *return_value_strerror$99;
  signed int *return_value___errno_location$100;
  char *return_value_strerror$101;
  signed int *return_value___errno_location$105;
  char *return_value_strerror$106;
  signed int *return_value___errno_location$107;
  char *return_value_strerror$108;
  signed int *return_value___errno_location$112;
  char *return_value_strerror$113;
  signed int *return_value___errno_location$114;
  char *return_value_strerror$115;
  signed int *return_value___errno_location$120;
  char *return_value_strerror$121;
  signed int *return_value___errno_location$122;
  char *return_value_strerror$123;
  signed int *return_value___errno_location$127;
  char *return_value_strerror$128;
  signed int *return_value___errno_location$129;
  char *return_value_strerror$130;
  signed int *return_value___errno_location$134;
  char *return_value_strerror$135;
  signed int *return_value___errno_location$136;
  char *return_value_strerror$137;
  signed int *return_value___errno_location$142;
  char *return_value_strerror$143;
  signed int *return_value___errno_location$144;
  char *return_value_strerror$145;
  signed int *return_value___errno_location$149;
  char *return_value_strerror$150;
  signed int *return_value___errno_location$151;
  char *return_value_strerror$152;
  signed int *return_value___errno_location$156;
  char *return_value_strerror$157;
  signed int *return_value___errno_location$158;
  char *return_value_strerror$159;
  char *return_value_ldap_err2string$163;
  signed int *return_value___errno_location$165;
  char *return_value_strerror$166;
  signed int *return_value___errno_location$167;
  char *return_value_strerror$168;
  signed int *return_value___errno_location$172;
  char *return_value_strerror$173;
  signed int *return_value___errno_location$174;
  char *return_value_strerror$175;
  signed int *return_value___errno_location$179;
  char *return_value_strerror$180;
  signed int *return_value___errno_location$181;
  char *return_value_strerror$182;
  signed int *return_value___errno_location$187;
  char *return_value_strerror$188;
  signed int *return_value___errno_location$189;
  char *return_value_strerror$190;
  signed int *return_value___errno_location$194;
  char *return_value_strerror$195;
  signed int *return_value___errno_location$196;
  char *return_value_strerror$197;
  signed int *return_value___errno_location$201;
  char *return_value_strerror$202;
  signed int *return_value___errno_location$203;
  char *return_value_strerror$204;
  signed int *return_value___errno_location$209;
  char *return_value_strerror$210;
  signed int *return_value___errno_location$211;
  char *return_value_strerror$212;
  signed int *return_value___errno_location$216;
  char *return_value_strerror$217;
  signed int *return_value___errno_location$218;
  char *return_value_strerror$219;
  signed int *return_value___errno_location$223;
  char *return_value_strerror$224;
  signed int *return_value___errno_location$225;
  char *return_value_strerror$226;
  signed int *return_value___errno_location$231;
  char *return_value_strerror$232;
  signed int *return_value___errno_location$233;
  char *return_value_strerror$234;
  signed int *return_value___errno_location$238;
  char *return_value_strerror$239;
  signed int *return_value___errno_location$240;
  char *return_value_strerror$241;
  signed int *return_value___errno_location$245;
  char *return_value_strerror$246;
  signed int *return_value___errno_location$247;
  char *return_value_strerror$248;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)username, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    username[(signed long int)tmpint32] = (char)0;
    signed int return_value_tio_read$10;
    return_value_tio_read$10=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_read$10 == 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error reading from client: %s", return_value_strerror$9);
      return -1;
    }

    unsigned int return_value_ntohl$11;
    return_value_ntohl$11=ntohl((unsigned int)tmpint32);
    tmpint32 = (signed int)return_value_ntohl$11;
    if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
    {
      tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
      log_log(3, "client supplied argument %d bytes too large", tmpint32);
      return -1;
    }

    else
    {
      if(tmpint32 >= 1)
      {
        signed int return_value_tio_read$14;
        return_value_tio_read$14=tio_read(fp, (void *)service, (unsigned long int)tmpint32);
        if(!(return_value_tio_read$14 == 0))
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          char *return_value_strerror$13;
          return_value_strerror$13=strerror(*return_value___errno_location$12);
          log_log(4, "error reading from client: %s", return_value_strerror$13);
          return -1;
        }

      }

      service[(signed long int)tmpint32] = (char)0;
      signed int return_value_tio_read$17;
      return_value_tio_read$17=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_read$17 == 0))
      {
        signed int *return_value___errno_location$15;
        return_value___errno_location$15=__errno_location();
        char *return_value_strerror$16;
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        log_log(4, "error reading from client: %s", return_value_strerror$16);
        return -1;
      }

      unsigned int return_value_ntohl$18;
      return_value_ntohl$18=ntohl((unsigned int)tmpint32);
      tmpint32 = (signed int)return_value_ntohl$18;
      if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
      {
        tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
        log_log(3, "client supplied argument %d bytes too large", tmpint32);
        return -1;
      }

      else
      {
        if(tmpint32 >= 1)
        {
          signed int return_value_tio_read$21;
          return_value_tio_read$21=tio_read(fp, (void *)ruser, (unsigned long int)tmpint32);
          if(!(return_value_tio_read$21 == 0))
          {
            signed int *return_value___errno_location$19;
            return_value___errno_location$19=__errno_location();
            char *return_value_strerror$20;
            return_value_strerror$20=strerror(*return_value___errno_location$19);
            log_log(4, "error reading from client: %s", return_value_strerror$20);
            return -1;
          }

        }

        ruser[(signed long int)tmpint32] = (char)0;
        signed int return_value_tio_read$24;
        return_value_tio_read$24=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_read$24 == 0))
        {
          signed int *return_value___errno_location$22;
          return_value___errno_location$22=__errno_location();
          char *return_value_strerror$23;
          return_value_strerror$23=strerror(*return_value___errno_location$22);
          log_log(4, "error reading from client: %s", return_value_strerror$23);
          return -1;
        }

        unsigned int return_value_ntohl$25;
        return_value_ntohl$25=ntohl((unsigned int)tmpint32);
        tmpint32 = (signed int)return_value_ntohl$25;
        if((unsigned long int)tmpint32 >= sizeof(char [65l]) /*65ul*/ )
        {
          tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [65l]) /*65ul*/ ) + (unsigned long int)1);
          log_log(3, "client supplied argument %d bytes too large", tmpint32);
          return -1;
        }

        else
        {
          if(tmpint32 >= 1)
          {
            signed int return_value_tio_read$28;
            return_value_tio_read$28=tio_read(fp, (void *)rhost, (unsigned long int)tmpint32);
            if(!(return_value_tio_read$28 == 0))
            {
              signed int *return_value___errno_location$26;
              return_value___errno_location$26=__errno_location();
              char *return_value_strerror$27;
              return_value_strerror$27=strerror(*return_value___errno_location$26);
              log_log(4, "error reading from client: %s", return_value_strerror$27);
              return -1;
            }

          }

          rhost[(signed long int)tmpint32] = (char)0;
          signed int return_value_tio_read$31;
          return_value_tio_read$31=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_read$31 == 0))
          {
            signed int *return_value___errno_location$29;
            return_value___errno_location$29=__errno_location();
            char *return_value_strerror$30;
            return_value_strerror$30=strerror(*return_value___errno_location$29);
            log_log(4, "error reading from client: %s", return_value_strerror$30);
            return -1;
          }

          unsigned int return_value_ntohl$32;
          return_value_ntohl$32=ntohl((unsigned int)tmpint32);
          tmpint32 = (signed int)return_value_ntohl$32;
          if((unsigned long int)tmpint32 >= sizeof(char [64l]) /*64ul*/ )
          {
            tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [64l]) /*64ul*/ ) + (unsigned long int)1);
            log_log(3, "client supplied argument %d bytes too large", tmpint32);
            return -1;
          }

          else
          {
            if(tmpint32 >= 1)
            {
              signed int return_value_tio_read$35;
              return_value_tio_read$35=tio_read(fp, (void *)tty, (unsigned long int)tmpint32);
              if(!(return_value_tio_read$35 == 0))
              {
                signed int *return_value___errno_location$33;
                return_value___errno_location$33=__errno_location();
                char *return_value_strerror$34;
                return_value_strerror$34=strerror(*return_value___errno_location$33);
                log_log(4, "error reading from client: %s", return_value_strerror$34);
                return -1;
              }

            }

            tty[(signed long int)tmpint32] = (char)0;
            signed int return_value_tio_read$38;
            return_value_tio_read$38=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_read$38 == 0))
            {
              signed int *return_value___errno_location$36;
              return_value___errno_location$36=__errno_location();
              char *return_value_strerror$37;
              return_value_strerror$37=strerror(*return_value___errno_location$36);
              log_log(4, "error reading from client: %s", return_value_strerror$37);
              return -1;
            }

            unsigned int return_value_ntohl$39;
            return_value_ntohl$39=ntohl((unsigned int)tmpint32);
            asroot = (signed int)return_value_ntohl$39;
            signed int return_value_tio_read$42;
            return_value_tio_read$42=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_read$42 == 0))
            {
              signed int *return_value___errno_location$40;
              return_value___errno_location$40=__errno_location();
              char *return_value_strerror$41;
              return_value_strerror$41=strerror(*return_value___errno_location$40);
              log_log(4, "error reading from client: %s", return_value_strerror$41);
              return -1;
            }

            unsigned int return_value_ntohl$43;
            return_value_ntohl$43=ntohl((unsigned int)tmpint32);
            tmpint32 = (signed int)return_value_ntohl$43;
            if((unsigned long int)tmpint32 >= sizeof(char [128l]) /*128ul*/ )
            {
              tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [128l]) /*128ul*/ ) + (unsigned long int)1);
              log_log(3, "client supplied argument %d bytes too large", tmpint32);
              return -1;
            }

            else
            {
              if(tmpint32 >= 1)
              {
                signed int return_value_tio_read$46;
                return_value_tio_read$46=tio_read(fp, (void *)oldpassword, (unsigned long int)tmpint32);
                if(!(return_value_tio_read$46 == 0))
                {
                  signed int *return_value___errno_location$44;
                  return_value___errno_location$44=__errno_location();
                  char *return_value_strerror$45;
                  return_value_strerror$45=strerror(*return_value___errno_location$44);
                  log_log(4, "error reading from client: %s", return_value_strerror$45);
                  return -1;
                }

              }

              oldpassword[(signed long int)tmpint32] = (char)0;
              signed int return_value_tio_read$49;
              return_value_tio_read$49=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_read$49 == 0))
              {
                signed int *return_value___errno_location$47;
                return_value___errno_location$47=__errno_location();
                char *return_value_strerror$48;
                return_value_strerror$48=strerror(*return_value___errno_location$47);
                log_log(4, "error reading from client: %s", return_value_strerror$48);
                return -1;
              }

              unsigned int return_value_ntohl$50;
              return_value_ntohl$50=ntohl((unsigned int)tmpint32);
              tmpint32 = (signed int)return_value_ntohl$50;
              if((unsigned long int)tmpint32 >= sizeof(char [128l]) /*128ul*/ )
              {
                tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [128l]) /*128ul*/ ) + (unsigned long int)1);
                log_log(3, "client supplied argument %d bytes too large", tmpint32);
                return -1;
              }

              else
              {
                if(tmpint32 >= 1)
                {
                  signed int return_value_tio_read$53;
                  return_value_tio_read$53=tio_read(fp, (void *)newpassword, (unsigned long int)tmpint32);
                  if(!(return_value_tio_read$53 == 0))
                  {
                    signed int *return_value___errno_location$51;
                    return_value___errno_location$51=__errno_location();
                    char *return_value_strerror$52;
                    return_value_strerror$52=strerror(*return_value___errno_location$51);
                    log_log(4, "error reading from client: %s", return_value_strerror$52);
                    return -1;
                  }

                }

                newpassword[(signed long int)tmpint32] = (char)0;
                log_setrequest("pwmod=\"%s\"", (const void *)username);
                log_log(7, "nslcd_pam_pwmod(\"%s\",%s,\"%s\",\"%s\",\"%s\")", (const void *)username, asroot != 0 ? "asroot" : "asuser", (const void *)service, oldpassword[0l] != 0 ? "***" : "", newpassword[0l] != 0 ? "***" : "");
                unsigned int return_value_htonl$54;
                return_value_htonl$54=htonl((unsigned int)(signed int)0x00000002);
                tmpint32 = (signed int)return_value_htonl$54;
                signed int return_value_tio_write$60;
                return_value_tio_write$60=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                if(!(return_value_tio_write$60 == 0))
                {
                  signed int *return_value___errno_location$59;
                  return_value___errno_location$59=__errno_location();
                  if(*return_value___errno_location$59 == 32)
                  {
                    return_value___errno_location$55=__errno_location();
                    return_value_strerror$56=strerror(*return_value___errno_location$55);
                    log_log(7, "error writing to client: %s", return_value_strerror$56);
                  }

                  else
                  {
                    return_value___errno_location$57=__errno_location();
                    return_value_strerror$58=strerror(*return_value___errno_location$57);
                    log_log(4, "error writing to client: %s", return_value_strerror$58);
                  }
                  return -1;
                }

                unsigned int return_value_htonl$61;
                return_value_htonl$61=htonl((unsigned int)(signed int)0x000d0005);
                tmpint32 = (signed int)return_value_htonl$61;
                signed int return_value_tio_write$67;
                return_value_tio_write$67=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                if(!(return_value_tio_write$67 == 0))
                {
                  signed int *return_value___errno_location$66;
                  return_value___errno_location$66=__errno_location();
                  if(*return_value___errno_location$66 == 32)
                  {
                    return_value___errno_location$62=__errno_location();
                    return_value_strerror$63=strerror(*return_value___errno_location$62);
                    log_log(7, "error writing to client: %s", return_value_strerror$63);
                  }

                  else
                  {
                    return_value___errno_location$64=__errno_location();
                    return_value_strerror$65=strerror(*return_value___errno_location$64);
                    log_log(4, "error writing to client: %s", return_value_strerror$65);
                  }
                  return -1;
                }

                entry=validate_user(session, username, &rc);
                if(entry == ((struct myldap_entry *)NULL))
                {
                  if(rc == 0x20)
                  {
                    unsigned int return_value_htonl$68;
                    return_value_htonl$68=htonl((unsigned int)(signed int)2);
                    tmpint32 = (signed int)return_value_htonl$68;
                    signed int return_value_tio_write$74;
                    return_value_tio_write$74=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                    if(!(return_value_tio_write$74 == 0))
                    {
                      signed int *return_value___errno_location$73;
                      return_value___errno_location$73=__errno_location();
                      if(*return_value___errno_location$73 == 32)
                      {
                        return_value___errno_location$69=__errno_location();
                        return_value_strerror$70=strerror(*return_value___errno_location$69);
                        log_log(7, "error writing to client: %s", return_value_strerror$70);
                      }

                      else
                      {
                        return_value___errno_location$71=__errno_location();
                        return_value_strerror$72=strerror(*return_value___errno_location$71);
                        log_log(4, "error writing to client: %s", return_value_strerror$72);
                      }
                      return -1;
                    }

                  }

                  memset((void *)oldpassword, 0, sizeof(char [128l]) /*128ul*/ );
                  memset((void *)newpassword, 0, sizeof(char [128l]) /*128ul*/ );
                  return -1;
                }

                else
                {
                  if(!(nslcd_cfg->pam_password_prohibit_message == ((char *)NULL)))
                  {
                    log_log(5, "password change prohibited");
                    unsigned int return_value_htonl$75;
                    return_value_htonl$75=htonl((unsigned int)(signed int)1);
                    tmpint32 = (signed int)return_value_htonl$75;
                    signed int return_value_tio_write$81;
                    return_value_tio_write$81=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                    if(!(return_value_tio_write$81 == 0))
                    {
                      signed int *return_value___errno_location$80;
                      return_value___errno_location$80=__errno_location();
                      if(*return_value___errno_location$80 == 32)
                      {
                        return_value___errno_location$76=__errno_location();
                        return_value_strerror$77=strerror(*return_value___errno_location$76);
                        log_log(7, "error writing to client: %s", return_value_strerror$77);
                      }

                      else
                      {
                        return_value___errno_location$78=__errno_location();
                        return_value_strerror$79=strerror(*return_value___errno_location$78);
                        log_log(4, "error writing to client: %s", return_value_strerror$79);
                      }
                      return -1;
                    }

                    unsigned int return_value_htonl$82;
                    return_value_htonl$82=htonl((unsigned int)(signed int)6);
                    tmpint32 = (signed int)return_value_htonl$82;
                    signed int return_value_tio_write$88;
                    return_value_tio_write$88=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                    if(!(return_value_tio_write$88 == 0))
                    {
                      signed int *return_value___errno_location$87;
                      return_value___errno_location$87=__errno_location();
                      if(*return_value___errno_location$87 == 32)
                      {
                        return_value___errno_location$83=__errno_location();
                        return_value_strerror$84=strerror(*return_value___errno_location$83);
                        log_log(7, "error writing to client: %s", return_value_strerror$84);
                      }

                      else
                      {
                        return_value___errno_location$85=__errno_location();
                        return_value_strerror$86=strerror(*return_value___errno_location$85);
                        log_log(4, "error writing to client: %s", return_value_strerror$86);
                      }
                      return -1;
                    }

                    if(nslcd_cfg->pam_password_prohibit_message == ((char *)NULL))
                    {
                      unsigned int return_value_htonl$89;
                      return_value_htonl$89=htonl((unsigned int)(signed int)0);
                      tmpint32 = (signed int)return_value_htonl$89;
                      signed int return_value_tio_write$95;
                      return_value_tio_write$95=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                      if(!(return_value_tio_write$95 == 0))
                      {
                        signed int *return_value___errno_location$94;
                        return_value___errno_location$94=__errno_location();
                        if(*return_value___errno_location$94 == 32)
                        {
                          return_value___errno_location$90=__errno_location();
                          return_value_strerror$91=strerror(*return_value___errno_location$90);
                          log_log(7, "error writing to client: %s", return_value_strerror$91);
                        }

                        else
                        {
                          return_value___errno_location$92=__errno_location();
                          return_value_strerror$93=strerror(*return_value___errno_location$92);
                          log_log(4, "error writing to client: %s", return_value_strerror$93);
                        }
                        return -1;
                      }

                    }

                    else
                    {
                      unsigned long int return_value_strlen$96;
                      return_value_strlen$96=strlen(nslcd_cfg->pam_password_prohibit_message);
                      unsigned int return_value_htonl$97;
                      return_value_htonl$97=htonl((unsigned int)(signed int)return_value_strlen$96);
                      tmpint32 = (signed int)return_value_htonl$97;
                      signed int return_value_tio_write$103;
                      return_value_tio_write$103=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                      if(!(return_value_tio_write$103 == 0))
                      {
                        signed int *return_value___errno_location$102;
                        return_value___errno_location$102=__errno_location();
                        if(*return_value___errno_location$102 == 32)
                        {
                          return_value___errno_location$98=__errno_location();
                          return_value_strerror$99=strerror(*return_value___errno_location$98);
                          log_log(7, "error writing to client: %s", return_value_strerror$99);
                        }

                        else
                        {
                          return_value___errno_location$100=__errno_location();
                          return_value_strerror$101=strerror(*return_value___errno_location$100);
                          log_log(4, "error writing to client: %s", return_value_strerror$101);
                        }
                        return -1;
                      }

                      unsigned int return_value_ntohl$104;
                      return_value_ntohl$104=ntohl((unsigned int)tmpint32);
                      tmpint32 = (signed int)return_value_ntohl$104;
                      if(tmpint32 >= 1)
                      {
                        signed int return_value_tio_write$110;
                        return_value_tio_write$110=tio_write(fp, (const void *)nslcd_cfg->pam_password_prohibit_message, (unsigned long int)tmpint32);
                        if(!(return_value_tio_write$110 == 0))
                        {
                          signed int *return_value___errno_location$109;
                          return_value___errno_location$109=__errno_location();
                          if(*return_value___errno_location$109 == 32)
                          {
                            return_value___errno_location$105=__errno_location();
                            return_value_strerror$106=strerror(*return_value___errno_location$105);
                            log_log(7, "error writing to client: %s", return_value_strerror$106);
                          }

                          else
                          {
                            return_value___errno_location$107=__errno_location();
                            return_value_strerror$108=strerror(*return_value___errno_location$107);
                            log_log(4, "error writing to client: %s", return_value_strerror$108);
                          }
                          return -1;
                        }

                      }

                    }
                    unsigned int return_value_htonl$111;
                    return_value_htonl$111=htonl((unsigned int)(signed int)2);
                    tmpint32 = (signed int)return_value_htonl$111;
                    signed int return_value_tio_write$117;
                    return_value_tio_write$117=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                    if(!(return_value_tio_write$117 == 0))
                    {
                      signed int *return_value___errno_location$116;
                      return_value___errno_location$116=__errno_location();
                      if(*return_value___errno_location$116 == 32)
                      {
                        return_value___errno_location$112=__errno_location();
                        return_value_strerror$113=strerror(*return_value___errno_location$112);
                        log_log(7, "error writing to client: %s", return_value_strerror$113);
                      }

                      else
                      {
                        return_value___errno_location$114=__errno_location();
                        return_value_strerror$115=strerror(*return_value___errno_location$114);
                        log_log(4, "error writing to client: %s", return_value_strerror$115);
                      }
                      return -1;
                    }

                    memset((void *)oldpassword, 0, sizeof(char [128l]) /*128ul*/ );
                    memset((void *)newpassword, 0, sizeof(char [128l]) /*128ul*/ );
                    return 0;
                  }

                  if(!(asroot == 0))
                  {
                    binddn = nslcd_cfg->rootpwmoddn;
                    if((signed int)oldpassword[0l] == 0)
                    {
                      if(calleruid == 0u)
                      {
                        if(!(nslcd_cfg->rootpwmodpw == ((char *)NULL)))
                        {
                          unsigned long int return_value_strlen$118;
                          return_value_strlen$118=strlen(nslcd_cfg->rootpwmodpw);
                          if(return_value_strlen$118 >= sizeof(char [128l]) /*128ul*/ )
                          {
                            log_log(3, "nslcd_pam_pwmod(): rootpwmodpw will not fit in oldpassword");
                            memset((void *)oldpassword, 0, sizeof(char [128l]) /*128ul*/ );
                            memset((void *)newpassword, 0, sizeof(char [128l]) /*128ul*/ );
                            return -1;
                          }

                          strcpy(oldpassword, nslcd_cfg->rootpwmodpw);
                        }

                      }

                    }

                  }

                  else
                  {
                    binddn=myldap_get_dn(entry);
                    rc=check_shadow(session, username, authzmsg, sizeof(char [1024l]) /*1024ul*/ , 0, 1);
                    if(!(rc == 0))
                    {
                      unsigned int return_value_htonl$119;
                      return_value_htonl$119=htonl((unsigned int)(signed int)1);
                      tmpint32 = (signed int)return_value_htonl$119;
                      signed int return_value_tio_write$125;
                      return_value_tio_write$125=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                      if(!(return_value_tio_write$125 == 0))
                      {
                        signed int *return_value___errno_location$124;
                        return_value___errno_location$124=__errno_location();
                        if(*return_value___errno_location$124 == 32)
                        {
                          return_value___errno_location$120=__errno_location();
                          return_value_strerror$121=strerror(*return_value___errno_location$120);
                          log_log(7, "error writing to client: %s", return_value_strerror$121);
                        }

                        else
                        {
                          return_value___errno_location$122=__errno_location();
                          return_value_strerror$123=strerror(*return_value___errno_location$122);
                          log_log(4, "error writing to client: %s", return_value_strerror$123);
                        }
                        return -1;
                      }

                      unsigned int return_value_htonl$126;
                      return_value_htonl$126=htonl((unsigned int)(signed int)rc);
                      tmpint32 = (signed int)return_value_htonl$126;
                      signed int return_value_tio_write$132;
                      return_value_tio_write$132=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                      if(!(return_value_tio_write$132 == 0))
                      {
                        signed int *return_value___errno_location$131;
                        return_value___errno_location$131=__errno_location();
                        if(*return_value___errno_location$131 == 32)
                        {
                          return_value___errno_location$127=__errno_location();
                          return_value_strerror$128=strerror(*return_value___errno_location$127);
                          log_log(7, "error writing to client: %s", return_value_strerror$128);
                        }

                        else
                        {
                          return_value___errno_location$129=__errno_location();
                          return_value_strerror$130=strerror(*return_value___errno_location$129);
                          log_log(4, "error writing to client: %s", return_value_strerror$130);
                        }
                        return -1;
                      }

                      {
                        unsigned long int return_value_strlen$140;
                        return_value_strlen$140=strlen(authzmsg);
                        unsigned int return_value_htonl$141;
                        return_value_htonl$141=htonl((unsigned int)(signed int)return_value_strlen$140);
                        tmpint32 = (signed int)return_value_htonl$141;
                        signed int return_value_tio_write$147;
                        return_value_tio_write$147=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                        if(!(return_value_tio_write$147 == 0))
                        {
                          signed int *return_value___errno_location$146;
                          return_value___errno_location$146=__errno_location();
                          if(*return_value___errno_location$146 == 32)
                          {
                            return_value___errno_location$142=__errno_location();
                            return_value_strerror$143=strerror(*return_value___errno_location$142);
                            log_log(7, "error writing to client: %s", return_value_strerror$143);
                          }

                          else
                          {
                            return_value___errno_location$144=__errno_location();
                            return_value_strerror$145=strerror(*return_value___errno_location$144);
                            log_log(4, "error writing to client: %s", return_value_strerror$145);
                          }
                          return -1;
                        }

                        unsigned int return_value_ntohl$148;
                        return_value_ntohl$148=ntohl((unsigned int)tmpint32);
                        tmpint32 = (signed int)return_value_ntohl$148;
                        if(tmpint32 >= 1)
                        {
                          signed int return_value_tio_write$154;
                          return_value_tio_write$154=tio_write(fp, (const void *)authzmsg, (unsigned long int)tmpint32);
                          if(!(return_value_tio_write$154 == 0))
                          {
                            signed int *return_value___errno_location$153;
                            return_value___errno_location$153=__errno_location();
                            if(*return_value___errno_location$153 == 32)
                            {
                              return_value___errno_location$149=__errno_location();
                              return_value_strerror$150=strerror(*return_value___errno_location$149);
                              log_log(7, "error writing to client: %s", return_value_strerror$150);
                            }

                            else
                            {
                              return_value___errno_location$151=__errno_location();
                              return_value_strerror$152=strerror(*return_value___errno_location$151);
                              log_log(4, "error writing to client: %s", return_value_strerror$152);
                            }
                            return -1;
                          }

                        }

                      }
                      unsigned int return_value_htonl$155;
                      return_value_htonl$155=htonl((unsigned int)(signed int)2);
                      tmpint32 = (signed int)return_value_htonl$155;
                      signed int return_value_tio_write$161;
                      return_value_tio_write$161=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                      if(!(return_value_tio_write$161 == 0))
                      {
                        signed int *return_value___errno_location$160;
                        return_value___errno_location$160=__errno_location();
                        if(*return_value___errno_location$160 == 32)
                        {
                          return_value___errno_location$156=__errno_location();
                          return_value_strerror$157=strerror(*return_value___errno_location$156);
                          log_log(7, "error writing to client: %s", return_value_strerror$157);
                        }

                        else
                        {
                          return_value___errno_location$158=__errno_location();
                          return_value_strerror$159=strerror(*return_value___errno_location$158);
                          log_log(4, "error writing to client: %s", return_value_strerror$159);
                        }
                        return -1;
                      }

                      memset((void *)oldpassword, 0, sizeof(char [128l]) /*128ul*/ );
                      memset((void *)newpassword, 0, sizeof(char [128l]) /*128ul*/ );
                      return 0;
                    }

                  }
                  const char *return_value_myldap_get_dn$162;
                  return_value_myldap_get_dn$162=myldap_get_dn(entry);
                  rc=try_pwmod(session, binddn, return_value_myldap_get_dn$162, oldpassword, newpassword, authzmsg, sizeof(char [1024l]) /*1024ul*/ );
                  if(!(rc == 0x00))
                  {
                    if((signed int)authzmsg[0l] == 0)
                    {
                      return_value_ldap_err2string$163=ldap_err2string(rc);
                      mysnprintf(authzmsg, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, "password change failed: %s", return_value_ldap_err2string$163);
                    }

                    unsigned int return_value_htonl$164;
                    return_value_htonl$164=htonl((unsigned int)(signed int)1);
                    tmpint32 = (signed int)return_value_htonl$164;
                    signed int return_value_tio_write$170;
                    return_value_tio_write$170=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                    if(!(return_value_tio_write$170 == 0))
                    {
                      signed int *return_value___errno_location$169;
                      return_value___errno_location$169=__errno_location();
                      if(*return_value___errno_location$169 == 32)
                      {
                        return_value___errno_location$165=__errno_location();
                        return_value_strerror$166=strerror(*return_value___errno_location$165);
                        log_log(7, "error writing to client: %s", return_value_strerror$166);
                      }

                      else
                      {
                        return_value___errno_location$167=__errno_location();
                        return_value_strerror$168=strerror(*return_value___errno_location$167);
                        log_log(4, "error writing to client: %s", return_value_strerror$168);
                      }
                      return -1;
                    }

                    unsigned int return_value_htonl$171;
                    return_value_htonl$171=htonl((unsigned int)(signed int)6);
                    tmpint32 = (signed int)return_value_htonl$171;
                    signed int return_value_tio_write$177;
                    return_value_tio_write$177=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                    if(!(return_value_tio_write$177 == 0))
                    {
                      signed int *return_value___errno_location$176;
                      return_value___errno_location$176=__errno_location();
                      if(*return_value___errno_location$176 == 32)
                      {
                        return_value___errno_location$172=__errno_location();
                        return_value_strerror$173=strerror(*return_value___errno_location$172);
                        log_log(7, "error writing to client: %s", return_value_strerror$173);
                      }

                      else
                      {
                        return_value___errno_location$174=__errno_location();
                        return_value_strerror$175=strerror(*return_value___errno_location$174);
                        log_log(4, "error writing to client: %s", return_value_strerror$175);
                      }
                      return -1;
                    }

                    {
                      unsigned long int return_value_strlen$185;
                      return_value_strlen$185=strlen(authzmsg);
                      unsigned int return_value_htonl$186;
                      return_value_htonl$186=htonl((unsigned int)(signed int)return_value_strlen$185);
                      tmpint32 = (signed int)return_value_htonl$186;
                      signed int return_value_tio_write$192;
                      return_value_tio_write$192=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                      if(!(return_value_tio_write$192 == 0))
                      {
                        signed int *return_value___errno_location$191;
                        return_value___errno_location$191=__errno_location();
                        if(*return_value___errno_location$191 == 32)
                        {
                          return_value___errno_location$187=__errno_location();
                          return_value_strerror$188=strerror(*return_value___errno_location$187);
                          log_log(7, "error writing to client: %s", return_value_strerror$188);
                        }

                        else
                        {
                          return_value___errno_location$189=__errno_location();
                          return_value_strerror$190=strerror(*return_value___errno_location$189);
                          log_log(4, "error writing to client: %s", return_value_strerror$190);
                        }
                        return -1;
                      }

                      unsigned int return_value_ntohl$193;
                      return_value_ntohl$193=ntohl((unsigned int)tmpint32);
                      tmpint32 = (signed int)return_value_ntohl$193;
                      if(tmpint32 >= 1)
                      {
                        signed int return_value_tio_write$199;
                        return_value_tio_write$199=tio_write(fp, (const void *)authzmsg, (unsigned long int)tmpint32);
                        if(!(return_value_tio_write$199 == 0))
                        {
                          signed int *return_value___errno_location$198;
                          return_value___errno_location$198=__errno_location();
                          if(*return_value___errno_location$198 == 32)
                          {
                            return_value___errno_location$194=__errno_location();
                            return_value_strerror$195=strerror(*return_value___errno_location$194);
                            log_log(7, "error writing to client: %s", return_value_strerror$195);
                          }

                          else
                          {
                            return_value___errno_location$196=__errno_location();
                            return_value_strerror$197=strerror(*return_value___errno_location$196);
                            log_log(4, "error writing to client: %s", return_value_strerror$197);
                          }
                          return -1;
                        }

                      }

                    }
                    unsigned int return_value_htonl$200;
                    return_value_htonl$200=htonl((unsigned int)(signed int)2);
                    tmpint32 = (signed int)return_value_htonl$200;
                    signed int return_value_tio_write$206;
                    return_value_tio_write$206=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                    if(!(return_value_tio_write$206 == 0))
                    {
                      signed int *return_value___errno_location$205;
                      return_value___errno_location$205=__errno_location();
                      if(*return_value___errno_location$205 == 32)
                      {
                        return_value___errno_location$201=__errno_location();
                        return_value_strerror$202=strerror(*return_value___errno_location$201);
                        log_log(7, "error writing to client: %s", return_value_strerror$202);
                      }

                      else
                      {
                        return_value___errno_location$203=__errno_location();
                        return_value_strerror$204=strerror(*return_value___errno_location$203);
                        log_log(4, "error writing to client: %s", return_value_strerror$204);
                      }
                      return -1;
                    }

                    memset((void *)oldpassword, 0, sizeof(char [128l]) /*128ul*/ );
                    memset((void *)newpassword, 0, sizeof(char [128l]) /*128ul*/ );
                    return 0;
                  }

                  const char *return_value_myldap_get_dn$207;
                  return_value_myldap_get_dn$207=myldap_get_dn(entry);
                  log_log(5, "password changed for %s", return_value_myldap_get_dn$207);
                  unsigned int return_value_htonl$208;
                  return_value_htonl$208=htonl((unsigned int)(signed int)1);
                  tmpint32 = (signed int)return_value_htonl$208;
                  signed int return_value_tio_write$214;
                  return_value_tio_write$214=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                  if(!(return_value_tio_write$214 == 0))
                  {
                    signed int *return_value___errno_location$213;
                    return_value___errno_location$213=__errno_location();
                    if(*return_value___errno_location$213 == 32)
                    {
                      return_value___errno_location$209=__errno_location();
                      return_value_strerror$210=strerror(*return_value___errno_location$209);
                      log_log(7, "error writing to client: %s", return_value_strerror$210);
                    }

                    else
                    {
                      return_value___errno_location$211=__errno_location();
                      return_value_strerror$212=strerror(*return_value___errno_location$211);
                      log_log(4, "error writing to client: %s", return_value_strerror$212);
                    }
                    return -1;
                  }

                  unsigned int return_value_htonl$215;
                  return_value_htonl$215=htonl((unsigned int)(signed int)0);
                  tmpint32 = (signed int)return_value_htonl$215;
                  signed int return_value_tio_write$221;
                  return_value_tio_write$221=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                  if(!(return_value_tio_write$221 == 0))
                  {
                    signed int *return_value___errno_location$220;
                    return_value___errno_location$220=__errno_location();
                    if(*return_value___errno_location$220 == 32)
                    {
                      return_value___errno_location$216=__errno_location();
                      return_value_strerror$217=strerror(*return_value___errno_location$216);
                      log_log(7, "error writing to client: %s", return_value_strerror$217);
                    }

                    else
                    {
                      return_value___errno_location$218=__errno_location();
                      return_value_strerror$219=strerror(*return_value___errno_location$218);
                      log_log(4, "error writing to client: %s", return_value_strerror$219);
                    }
                    return -1;
                  }

                  {
                    unsigned long int return_value_strlen$229;
                    return_value_strlen$229=strlen("");
                    unsigned int return_value_htonl$230;
                    return_value_htonl$230=htonl((unsigned int)(signed int)return_value_strlen$229);
                    tmpint32 = (signed int)return_value_htonl$230;
                    signed int return_value_tio_write$236;
                    return_value_tio_write$236=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                    if(!(return_value_tio_write$236 == 0))
                    {
                      signed int *return_value___errno_location$235;
                      return_value___errno_location$235=__errno_location();
                      if(*return_value___errno_location$235 == 32)
                      {
                        return_value___errno_location$231=__errno_location();
                        return_value_strerror$232=strerror(*return_value___errno_location$231);
                        log_log(7, "error writing to client: %s", return_value_strerror$232);
                      }

                      else
                      {
                        return_value___errno_location$233=__errno_location();
                        return_value_strerror$234=strerror(*return_value___errno_location$233);
                        log_log(4, "error writing to client: %s", return_value_strerror$234);
                      }
                      return -1;
                    }

                    unsigned int return_value_ntohl$237;
                    return_value_ntohl$237=ntohl((unsigned int)tmpint32);
                    tmpint32 = (signed int)return_value_ntohl$237;
                    if(tmpint32 >= 1)
                    {
                      signed int return_value_tio_write$243;
                      return_value_tio_write$243=tio_write(fp, (const void *)"", (unsigned long int)tmpint32);
                      if(!(return_value_tio_write$243 == 0))
                      {
                        signed int *return_value___errno_location$242;
                        return_value___errno_location$242=__errno_location();
                        if(*return_value___errno_location$242 == 32)
                        {
                          return_value___errno_location$238=__errno_location();
                          return_value_strerror$239=strerror(*return_value___errno_location$238);
                          log_log(7, "error writing to client: %s", return_value_strerror$239);
                        }

                        else
                        {
                          return_value___errno_location$240=__errno_location();
                          return_value_strerror$241=strerror(*return_value___errno_location$240);
                          log_log(4, "error writing to client: %s", return_value_strerror$241);
                        }
                        return -1;
                      }

                    }

                  }
                  unsigned int return_value_htonl$244;
                  return_value_htonl$244=htonl((unsigned int)(signed int)2);
                  tmpint32 = (signed int)return_value_htonl$244;
                  signed int return_value_tio_write$250;
                  return_value_tio_write$250=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
                  if(!(return_value_tio_write$250 == 0))
                  {
                    signed int *return_value___errno_location$249;
                    return_value___errno_location$249=__errno_location();
                    if(*return_value___errno_location$249 == 32)
                    {
                      return_value___errno_location$245=__errno_location();
                      return_value_strerror$246=strerror(*return_value___errno_location$245);
                      log_log(7, "error writing to client: %s", return_value_strerror$246);
                    }

                    else
                    {
                      return_value___errno_location$247=__errno_location();
                      return_value_strerror$248=strerror(*return_value___errno_location$247);
                      log_log(4, "error writing to client: %s", return_value_strerror$248);
                    }
                    return -1;
                  }

                  memset((void *)oldpassword, 0, sizeof(char [128l]) /*128ul*/ );
                  memset((void *)newpassword, 0, sizeof(char [128l]) /*128ul*/ );
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
}

// nslcd_pam_sess_c
// file common.h line 255
signed int nslcd_pam_sess_c(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  char username[256l];
  char service[256l];
  char ruser[256l];
  char rhost[65l];
  char tty[64l];
  char nslcd_pam_sess_c$$1$$sessionid[64l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$44;
  char *return_value_strerror$45;
  signed int *return_value___errno_location$46;
  char *return_value_strerror$47;
  signed int *return_value___errno_location$51;
  char *return_value_strerror$52;
  signed int *return_value___errno_location$53;
  char *return_value_strerror$54;
  signed int *return_value___errno_location$58;
  char *return_value_strerror$59;
  signed int *return_value___errno_location$60;
  char *return_value_strerror$61;
  signed int *return_value___errno_location$65;
  char *return_value_strerror$66;
  signed int *return_value___errno_location$67;
  char *return_value_strerror$68;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)username, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    username[(signed long int)tmpint32] = (char)0;
    signed int return_value_tio_read$10;
    return_value_tio_read$10=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_read$10 == 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error reading from client: %s", return_value_strerror$9);
      return -1;
    }

    unsigned int return_value_ntohl$11;
    return_value_ntohl$11=ntohl((unsigned int)tmpint32);
    tmpint32 = (signed int)return_value_ntohl$11;
    if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
    {
      tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
      log_log(3, "client supplied argument %d bytes too large", tmpint32);
      return -1;
    }

    else
    {
      if(tmpint32 >= 1)
      {
        signed int return_value_tio_read$14;
        return_value_tio_read$14=tio_read(fp, (void *)service, (unsigned long int)tmpint32);
        if(!(return_value_tio_read$14 == 0))
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          char *return_value_strerror$13;
          return_value_strerror$13=strerror(*return_value___errno_location$12);
          log_log(4, "error reading from client: %s", return_value_strerror$13);
          return -1;
        }

      }

      service[(signed long int)tmpint32] = (char)0;
      signed int return_value_tio_read$17;
      return_value_tio_read$17=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_read$17 == 0))
      {
        signed int *return_value___errno_location$15;
        return_value___errno_location$15=__errno_location();
        char *return_value_strerror$16;
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        log_log(4, "error reading from client: %s", return_value_strerror$16);
        return -1;
      }

      unsigned int return_value_ntohl$18;
      return_value_ntohl$18=ntohl((unsigned int)tmpint32);
      tmpint32 = (signed int)return_value_ntohl$18;
      if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
      {
        tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
        log_log(3, "client supplied argument %d bytes too large", tmpint32);
        return -1;
      }

      else
      {
        if(tmpint32 >= 1)
        {
          signed int return_value_tio_read$21;
          return_value_tio_read$21=tio_read(fp, (void *)ruser, (unsigned long int)tmpint32);
          if(!(return_value_tio_read$21 == 0))
          {
            signed int *return_value___errno_location$19;
            return_value___errno_location$19=__errno_location();
            char *return_value_strerror$20;
            return_value_strerror$20=strerror(*return_value___errno_location$19);
            log_log(4, "error reading from client: %s", return_value_strerror$20);
            return -1;
          }

        }

        ruser[(signed long int)tmpint32] = (char)0;
        signed int return_value_tio_read$24;
        return_value_tio_read$24=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_read$24 == 0))
        {
          signed int *return_value___errno_location$22;
          return_value___errno_location$22=__errno_location();
          char *return_value_strerror$23;
          return_value_strerror$23=strerror(*return_value___errno_location$22);
          log_log(4, "error reading from client: %s", return_value_strerror$23);
          return -1;
        }

        unsigned int return_value_ntohl$25;
        return_value_ntohl$25=ntohl((unsigned int)tmpint32);
        tmpint32 = (signed int)return_value_ntohl$25;
        if((unsigned long int)tmpint32 >= sizeof(char [65l]) /*65ul*/ )
        {
          tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [65l]) /*65ul*/ ) + (unsigned long int)1);
          log_log(3, "client supplied argument %d bytes too large", tmpint32);
          return -1;
        }

        else
        {
          if(tmpint32 >= 1)
          {
            signed int return_value_tio_read$28;
            return_value_tio_read$28=tio_read(fp, (void *)rhost, (unsigned long int)tmpint32);
            if(!(return_value_tio_read$28 == 0))
            {
              signed int *return_value___errno_location$26;
              return_value___errno_location$26=__errno_location();
              char *return_value_strerror$27;
              return_value_strerror$27=strerror(*return_value___errno_location$26);
              log_log(4, "error reading from client: %s", return_value_strerror$27);
              return -1;
            }

          }

          rhost[(signed long int)tmpint32] = (char)0;
          signed int return_value_tio_read$31;
          return_value_tio_read$31=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_read$31 == 0))
          {
            signed int *return_value___errno_location$29;
            return_value___errno_location$29=__errno_location();
            char *return_value_strerror$30;
            return_value_strerror$30=strerror(*return_value___errno_location$29);
            log_log(4, "error reading from client: %s", return_value_strerror$30);
            return -1;
          }

          unsigned int return_value_ntohl$32;
          return_value_ntohl$32=ntohl((unsigned int)tmpint32);
          tmpint32 = (signed int)return_value_ntohl$32;
          if((unsigned long int)tmpint32 >= sizeof(char [64l]) /*64ul*/ )
          {
            tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [64l]) /*64ul*/ ) + (unsigned long int)1);
            log_log(3, "client supplied argument %d bytes too large", tmpint32);
            return -1;
          }

          else
          {
            if(tmpint32 >= 1)
            {
              signed int return_value_tio_read$35;
              return_value_tio_read$35=tio_read(fp, (void *)tty, (unsigned long int)tmpint32);
              if(!(return_value_tio_read$35 == 0))
              {
                signed int *return_value___errno_location$33;
                return_value___errno_location$33=__errno_location();
                char *return_value_strerror$34;
                return_value_strerror$34=strerror(*return_value___errno_location$33);
                log_log(4, "error reading from client: %s", return_value_strerror$34);
                return -1;
              }

            }

            tty[(signed long int)tmpint32] = (char)0;
            signed int return_value_tio_read$38;
            return_value_tio_read$38=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_read$38 == 0))
            {
              signed int *return_value___errno_location$36;
              return_value___errno_location$36=__errno_location();
              char *return_value_strerror$37;
              return_value_strerror$37=strerror(*return_value___errno_location$36);
              log_log(4, "error reading from client: %s", return_value_strerror$37);
              return -1;
            }

            unsigned int return_value_ntohl$39;
            return_value_ntohl$39=ntohl((unsigned int)tmpint32);
            tmpint32 = (signed int)return_value_ntohl$39;
            if((unsigned long int)tmpint32 >= sizeof(char [64l]) /*64ul*/ )
            {
              tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [64l]) /*64ul*/ ) + (unsigned long int)1);
              log_log(3, "client supplied argument %d bytes too large", tmpint32);
              return -1;
            }

            else
            {
              if(tmpint32 >= 1)
              {
                signed int return_value_tio_read$42;
                return_value_tio_read$42=tio_read(fp, (void *)nslcd_pam_sess_c$$1$$sessionid, (unsigned long int)tmpint32);
                if(!(return_value_tio_read$42 == 0))
                {
                  signed int *return_value___errno_location$40;
                  return_value___errno_location$40=__errno_location();
                  char *return_value_strerror$41;
                  return_value_strerror$41=strerror(*return_value___errno_location$40);
                  log_log(4, "error reading from client: %s", return_value_strerror$41);
                  return -1;
                }

              }

              nslcd_pam_sess_c$$1$$sessionid[(signed long int)tmpint32] = (char)0;
              log_setrequest("sess_c=\"%s\"", (const void *)username);
              log_log(7, "nslcd_pam_sess_c(\"%s\",\"%s\",%s)", (const void *)username, (const void *)service, (const void *)nslcd_pam_sess_c$$1$$sessionid);
              unsigned int return_value_htonl$43;
              return_value_htonl$43=htonl((unsigned int)(signed int)0x00000002);
              tmpint32 = (signed int)return_value_htonl$43;
              signed int return_value_tio_write$49;
              return_value_tio_write$49=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$49 == 0))
              {
                signed int *return_value___errno_location$48;
                return_value___errno_location$48=__errno_location();
                if(*return_value___errno_location$48 == 32)
                {
                  return_value___errno_location$44=__errno_location();
                  return_value_strerror$45=strerror(*return_value___errno_location$44);
                  log_log(7, "error writing to client: %s", return_value_strerror$45);
                }

                else
                {
                  return_value___errno_location$46=__errno_location();
                  return_value_strerror$47=strerror(*return_value___errno_location$46);
                  log_log(4, "error writing to client: %s", return_value_strerror$47);
                }
                return -1;
              }

              unsigned int return_value_htonl$50;
              return_value_htonl$50=htonl((unsigned int)(signed int)0x000d0004);
              tmpint32 = (signed int)return_value_htonl$50;
              signed int return_value_tio_write$56;
              return_value_tio_write$56=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$56 == 0))
              {
                signed int *return_value___errno_location$55;
                return_value___errno_location$55=__errno_location();
                if(*return_value___errno_location$55 == 32)
                {
                  return_value___errno_location$51=__errno_location();
                  return_value_strerror$52=strerror(*return_value___errno_location$51);
                  log_log(7, "error writing to client: %s", return_value_strerror$52);
                }

                else
                {
                  return_value___errno_location$53=__errno_location();
                  return_value_strerror$54=strerror(*return_value___errno_location$53);
                  log_log(4, "error writing to client: %s", return_value_strerror$54);
                }
                return -1;
              }

              unsigned int return_value_htonl$57;
              return_value_htonl$57=htonl((unsigned int)(signed int)1);
              tmpint32 = (signed int)return_value_htonl$57;
              signed int return_value_tio_write$63;
              return_value_tio_write$63=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$63 == 0))
              {
                signed int *return_value___errno_location$62;
                return_value___errno_location$62=__errno_location();
                if(*return_value___errno_location$62 == 32)
                {
                  return_value___errno_location$58=__errno_location();
                  return_value_strerror$59=strerror(*return_value___errno_location$58);
                  log_log(7, "error writing to client: %s", return_value_strerror$59);
                }

                else
                {
                  return_value___errno_location$60=__errno_location();
                  return_value_strerror$61=strerror(*return_value___errno_location$60);
                  log_log(4, "error writing to client: %s", return_value_strerror$61);
                }
                return -1;
              }

              unsigned int return_value_htonl$64;
              return_value_htonl$64=htonl((unsigned int)(signed int)2);
              tmpint32 = (signed int)return_value_htonl$64;
              signed int return_value_tio_write$70;
              return_value_tio_write$70=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$70 == 0))
              {
                signed int *return_value___errno_location$69;
                return_value___errno_location$69=__errno_location();
                if(*return_value___errno_location$69 == 32)
                {
                  return_value___errno_location$65=__errno_location();
                  return_value_strerror$66=strerror(*return_value___errno_location$65);
                  log_log(7, "error writing to client: %s", return_value_strerror$66);
                }

                else
                {
                  return_value___errno_location$67=__errno_location();
                  return_value_strerror$68=strerror(*return_value___errno_location$67);
                  log_log(4, "error writing to client: %s", return_value_strerror$68);
                }
                return -1;
              }

              return 0;
            }
          }
        }
      }
    }
  }
}

// nslcd_pam_sess_o
// file common.h line 254
signed int nslcd_pam_sess_o(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  char username[256l];
  char service[256l];
  char ruser[256l];
  char rhost[65l];
  char tty[64l];
  char nslcd_pam_sess_o$$1$$sessionid[25l];
  unsigned int i;
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int return_value_rand$36;
  signed int *return_value___errno_location$38;
  char *return_value_strerror$39;
  signed int *return_value___errno_location$40;
  char *return_value_strerror$41;
  signed int *return_value___errno_location$45;
  char *return_value_strerror$46;
  signed int *return_value___errno_location$47;
  char *return_value_strerror$48;
  signed int *return_value___errno_location$52;
  char *return_value_strerror$53;
  signed int *return_value___errno_location$54;
  char *return_value_strerror$55;
  signed int *return_value___errno_location$59;
  char *return_value_strerror$60;
  signed int *return_value___errno_location$61;
  char *return_value_strerror$62;
  signed int *return_value___errno_location$67;
  char *return_value_strerror$68;
  signed int *return_value___errno_location$69;
  char *return_value_strerror$70;
  signed int *return_value___errno_location$74;
  char *return_value_strerror$75;
  signed int *return_value___errno_location$76;
  char *return_value_strerror$77;
  signed int *return_value___errno_location$81;
  char *return_value_strerror$82;
  signed int *return_value___errno_location$83;
  char *return_value_strerror$84;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)username, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    username[(signed long int)tmpint32] = (char)0;
    signed int return_value_tio_read$10;
    return_value_tio_read$10=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_read$10 == 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error reading from client: %s", return_value_strerror$9);
      return -1;
    }

    unsigned int return_value_ntohl$11;
    return_value_ntohl$11=ntohl((unsigned int)tmpint32);
    tmpint32 = (signed int)return_value_ntohl$11;
    if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
    {
      tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
      log_log(3, "client supplied argument %d bytes too large", tmpint32);
      return -1;
    }

    else
    {
      if(tmpint32 >= 1)
      {
        signed int return_value_tio_read$14;
        return_value_tio_read$14=tio_read(fp, (void *)service, (unsigned long int)tmpint32);
        if(!(return_value_tio_read$14 == 0))
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          char *return_value_strerror$13;
          return_value_strerror$13=strerror(*return_value___errno_location$12);
          log_log(4, "error reading from client: %s", return_value_strerror$13);
          return -1;
        }

      }

      service[(signed long int)tmpint32] = (char)0;
      signed int return_value_tio_read$17;
      return_value_tio_read$17=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_read$17 == 0))
      {
        signed int *return_value___errno_location$15;
        return_value___errno_location$15=__errno_location();
        char *return_value_strerror$16;
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        log_log(4, "error reading from client: %s", return_value_strerror$16);
        return -1;
      }

      unsigned int return_value_ntohl$18;
      return_value_ntohl$18=ntohl((unsigned int)tmpint32);
      tmpint32 = (signed int)return_value_ntohl$18;
      if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
      {
        tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
        log_log(3, "client supplied argument %d bytes too large", tmpint32);
        return -1;
      }

      else
      {
        if(tmpint32 >= 1)
        {
          signed int return_value_tio_read$21;
          return_value_tio_read$21=tio_read(fp, (void *)ruser, (unsigned long int)tmpint32);
          if(!(return_value_tio_read$21 == 0))
          {
            signed int *return_value___errno_location$19;
            return_value___errno_location$19=__errno_location();
            char *return_value_strerror$20;
            return_value_strerror$20=strerror(*return_value___errno_location$19);
            log_log(4, "error reading from client: %s", return_value_strerror$20);
            return -1;
          }

        }

        ruser[(signed long int)tmpint32] = (char)0;
        signed int return_value_tio_read$24;
        return_value_tio_read$24=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_read$24 == 0))
        {
          signed int *return_value___errno_location$22;
          return_value___errno_location$22=__errno_location();
          char *return_value_strerror$23;
          return_value_strerror$23=strerror(*return_value___errno_location$22);
          log_log(4, "error reading from client: %s", return_value_strerror$23);
          return -1;
        }

        unsigned int return_value_ntohl$25;
        return_value_ntohl$25=ntohl((unsigned int)tmpint32);
        tmpint32 = (signed int)return_value_ntohl$25;
        if((unsigned long int)tmpint32 >= sizeof(char [65l]) /*65ul*/ )
        {
          tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [65l]) /*65ul*/ ) + (unsigned long int)1);
          log_log(3, "client supplied argument %d bytes too large", tmpint32);
          return -1;
        }

        else
        {
          if(tmpint32 >= 1)
          {
            signed int return_value_tio_read$28;
            return_value_tio_read$28=tio_read(fp, (void *)rhost, (unsigned long int)tmpint32);
            if(!(return_value_tio_read$28 == 0))
            {
              signed int *return_value___errno_location$26;
              return_value___errno_location$26=__errno_location();
              char *return_value_strerror$27;
              return_value_strerror$27=strerror(*return_value___errno_location$26);
              log_log(4, "error reading from client: %s", return_value_strerror$27);
              return -1;
            }

          }

          rhost[(signed long int)tmpint32] = (char)0;
          signed int return_value_tio_read$31;
          return_value_tio_read$31=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_read$31 == 0))
          {
            signed int *return_value___errno_location$29;
            return_value___errno_location$29=__errno_location();
            char *return_value_strerror$30;
            return_value_strerror$30=strerror(*return_value___errno_location$29);
            log_log(4, "error reading from client: %s", return_value_strerror$30);
            return -1;
          }

          unsigned int return_value_ntohl$32;
          return_value_ntohl$32=ntohl((unsigned int)tmpint32);
          tmpint32 = (signed int)return_value_ntohl$32;
          if((unsigned long int)tmpint32 >= sizeof(char [64l]) /*64ul*/ )
          {
            tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [64l]) /*64ul*/ ) + (unsigned long int)1);
            log_log(3, "client supplied argument %d bytes too large", tmpint32);
            return -1;
          }

          else
          {
            if(tmpint32 >= 1)
            {
              signed int return_value_tio_read$35;
              return_value_tio_read$35=tio_read(fp, (void *)tty, (unsigned long int)tmpint32);
              if(!(return_value_tio_read$35 == 0))
              {
                signed int *return_value___errno_location$33;
                return_value___errno_location$33=__errno_location();
                char *return_value_strerror$34;
                return_value_strerror$34=strerror(*return_value___errno_location$33);
                log_log(4, "error reading from client: %s", return_value_strerror$34);
                return -1;
              }

            }

            tty[(signed long int)tmpint32] = (char)0;
            i = (unsigned int)0;
            for( ; !((unsigned long int)i >= 24ul); i = i + 1u)
            {
              return_value_rand$36=rand();
              static const char alphabet[64l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 0 };
              nslcd_pam_sess_o$$1$$sessionid[(signed long int)i] = alphabet[(signed long int)((unsigned long int)return_value_rand$36 % (sizeof(const char [64l]) /*64ul*/  - (unsigned long int)1))];
            }
            nslcd_pam_sess_o$$1$$sessionid[(signed long int)i] = (char)0;
            log_setrequest("sess_o=\"%s\"", (const void *)username);
            log_log(7, "nslcd_pam_sess_o(\"%s\",\"%s\",\"%s\",\"%s\",\"%s\"): %s", (const void *)username, (const void *)service, (const void *)tty, (const void *)rhost, (const void *)ruser, (const void *)nslcd_pam_sess_o$$1$$sessionid);
            unsigned int return_value_htonl$37;
            return_value_htonl$37=htonl((unsigned int)(signed int)0x00000002);
            tmpint32 = (signed int)return_value_htonl$37;
            signed int return_value_tio_write$43;
            return_value_tio_write$43=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$43 == 0))
            {
              signed int *return_value___errno_location$42;
              return_value___errno_location$42=__errno_location();
              if(*return_value___errno_location$42 == 32)
              {
                return_value___errno_location$38=__errno_location();
                return_value_strerror$39=strerror(*return_value___errno_location$38);
                log_log(7, "error writing to client: %s", return_value_strerror$39);
              }

              else
              {
                return_value___errno_location$40=__errno_location();
                return_value_strerror$41=strerror(*return_value___errno_location$40);
                log_log(4, "error writing to client: %s", return_value_strerror$41);
              }
              return -1;
            }

            unsigned int return_value_htonl$44;
            return_value_htonl$44=htonl((unsigned int)(signed int)0x000d0003);
            tmpint32 = (signed int)return_value_htonl$44;
            signed int return_value_tio_write$50;
            return_value_tio_write$50=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$50 == 0))
            {
              signed int *return_value___errno_location$49;
              return_value___errno_location$49=__errno_location();
              if(*return_value___errno_location$49 == 32)
              {
                return_value___errno_location$45=__errno_location();
                return_value_strerror$46=strerror(*return_value___errno_location$45);
                log_log(7, "error writing to client: %s", return_value_strerror$46);
              }

              else
              {
                return_value___errno_location$47=__errno_location();
                return_value_strerror$48=strerror(*return_value___errno_location$47);
                log_log(4, "error writing to client: %s", return_value_strerror$48);
              }
              return -1;
            }

            unsigned int return_value_htonl$51;
            return_value_htonl$51=htonl((unsigned int)(signed int)1);
            tmpint32 = (signed int)return_value_htonl$51;
            signed int return_value_tio_write$57;
            return_value_tio_write$57=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$57 == 0))
            {
              signed int *return_value___errno_location$56;
              return_value___errno_location$56=__errno_location();
              if(*return_value___errno_location$56 == 32)
              {
                return_value___errno_location$52=__errno_location();
                return_value_strerror$53=strerror(*return_value___errno_location$52);
                log_log(7, "error writing to client: %s", return_value_strerror$53);
              }

              else
              {
                return_value___errno_location$54=__errno_location();
                return_value_strerror$55=strerror(*return_value___errno_location$54);
                log_log(4, "error writing to client: %s", return_value_strerror$55);
              }
              return -1;
            }

            {
              unsigned long int return_value_strlen$65;
              return_value_strlen$65=strlen(nslcd_pam_sess_o$$1$$sessionid);
              unsigned int return_value_htonl$66;
              return_value_htonl$66=htonl((unsigned int)(signed int)return_value_strlen$65);
              tmpint32 = (signed int)return_value_htonl$66;
              signed int return_value_tio_write$72;
              return_value_tio_write$72=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$72 == 0))
              {
                signed int *return_value___errno_location$71;
                return_value___errno_location$71=__errno_location();
                if(*return_value___errno_location$71 == 32)
                {
                  return_value___errno_location$67=__errno_location();
                  return_value_strerror$68=strerror(*return_value___errno_location$67);
                  log_log(7, "error writing to client: %s", return_value_strerror$68);
                }

                else
                {
                  return_value___errno_location$69=__errno_location();
                  return_value_strerror$70=strerror(*return_value___errno_location$69);
                  log_log(4, "error writing to client: %s", return_value_strerror$70);
                }
                return -1;
              }

              unsigned int return_value_ntohl$73;
              return_value_ntohl$73=ntohl((unsigned int)tmpint32);
              tmpint32 = (signed int)return_value_ntohl$73;
              if(tmpint32 >= 1)
              {
                signed int return_value_tio_write$79;
                return_value_tio_write$79=tio_write(fp, (const void *)nslcd_pam_sess_o$$1$$sessionid, (unsigned long int)tmpint32);
                if(!(return_value_tio_write$79 == 0))
                {
                  signed int *return_value___errno_location$78;
                  return_value___errno_location$78=__errno_location();
                  if(*return_value___errno_location$78 == 32)
                  {
                    return_value___errno_location$74=__errno_location();
                    return_value_strerror$75=strerror(*return_value___errno_location$74);
                    log_log(7, "error writing to client: %s", return_value_strerror$75);
                  }

                  else
                  {
                    return_value___errno_location$76=__errno_location();
                    return_value_strerror$77=strerror(*return_value___errno_location$76);
                    log_log(4, "error writing to client: %s", return_value_strerror$77);
                  }
                  return -1;
                }

              }

            }
            unsigned int return_value_htonl$80;
            return_value_htonl$80=htonl((unsigned int)(signed int)2);
            tmpint32 = (signed int)return_value_htonl$80;
            signed int return_value_tio_write$86;
            return_value_tio_write$86=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$86 == 0))
            {
              signed int *return_value___errno_location$85;
              return_value___errno_location$85=__errno_location();
              if(*return_value___errno_location$85 == 32)
              {
                return_value___errno_location$81=__errno_location();
                return_value_strerror$82=strerror(*return_value___errno_location$81);
                log_log(7, "error writing to client: %s", return_value_strerror$82);
              }

              else
              {
                return_value___errno_location$83=__errno_location();
                return_value_strerror$84=strerror(*return_value___errno_location$83);
                log_log(4, "error writing to client: %s", return_value_strerror$84);
              }
              return -1;
            }

            return 0;
          }
        }
      }
    }
  }
}

// nslcd_passwd_all
// file common.h line 240
signed int nslcd_passwd_all(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  const char *filter;
  log_setrequest("passwd(all)");
  nsswitch_check_reload();
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$1;
  signed int return_value_tio_write$7;
  return_value_tio_write$7=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(return_value_tio_write$7 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    if(*return_value___errno_location$6 == 32)
    {
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_log(7, "error writing to client: %s", return_value_strerror$3);
    }

    else
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_log(4, "error writing to client: %s", return_value_strerror$5);
    }
    return -1;
  }

  unsigned int return_value_htonl$8;
  return_value_htonl$8=htonl((unsigned int)(signed int)0x00080008);
  tmpint32 = (signed int)return_value_htonl$8;
  signed int return_value_tio_write$14;
  return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(!(return_value_tio_write$14 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    if(*return_value___errno_location$13 == 32)
    {
      return_value___errno_location$9=__errno_location();
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_log(7, "error writing to client: %s", return_value_strerror$10);
    }

    else
    {
      return_value___errno_location$11=__errno_location();
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      log_log(4, "error writing to client: %s", return_value_strerror$12);
    }
    return -1;
  }

  filter = passwd_filter;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  i = 0;
  do
  {
    base = passwd_bases[(signed long int)i];
    if(base == ((const char *)NULL))
      break;

    search=myldap_search(session, base, passwd_scope, filter, passwd_attrs, (signed int *)(void *)0);
    if(search == ((struct myldap_search *)NULL))
      return -1;

    do
    {
      entry=myldap_get_entry(search, &rc);
      if(entry == ((struct myldap_entry *)NULL))
        break;

      signed int return_value_write_passwd$15;
      return_value_write_passwd$15=write_passwd(fp, entry, (const char *)(void *)0, (const unsigned int *)(void *)0, calleruid);
      if(!(return_value_write_passwd$15 == 0))
        return -1;

    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  if(rc == 0x00)
  {
    unsigned int return_value_htonl$16;
    return_value_htonl$16=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$16;
    signed int return_value_tio_write$22;
    return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$22 == 0))
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      if(*return_value___errno_location$21 == 32)
      {
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        log_log(7, "error writing to client: %s", return_value_strerror$18);
      }

      else
      {
        return_value___errno_location$19=__errno_location();
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        log_log(4, "error writing to client: %s", return_value_strerror$20);
      }
      return -1;
    }

  }

  return 0;
}

// nslcd_passwd_byname
// file common.h line 238
signed int nslcd_passwd_byname(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  char name[256l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$10;
  char *return_value_strerror$11;
  signed int *return_value___errno_location$12;
  char *return_value_strerror$13;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  signed int *return_value___errno_location$26;
  char *return_value_strerror$27;
  signed int *return_value___errno_location$28;
  char *return_value_strerror$29;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)name, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    name[(signed long int)tmpint32] = (char)0;
    log_setrequest("passwd=\"%s\"", (const void *)name);
    signed int return_value_isvalidname$8;
    return_value_isvalidname$8=isvalidname(name);
    if(return_value_isvalidname$8 == 0)
    {
      log_log(4, "request denied by validnames option");
      return -1;
    }

    else
    {
      nsswitch_check_reload();
      unsigned int return_value_htonl$9;
      return_value_htonl$9=htonl((unsigned int)(signed int)0x00000002);
      tmpint32 = (signed int)return_value_htonl$9;
      signed int return_value_tio_write$15;
      return_value_tio_write$15=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$15 == 0))
      {
        signed int *return_value___errno_location$14;
        return_value___errno_location$14=__errno_location();
        if(*return_value___errno_location$14 == 32)
        {
          return_value___errno_location$10=__errno_location();
          return_value_strerror$11=strerror(*return_value___errno_location$10);
          log_log(7, "error writing to client: %s", return_value_strerror$11);
        }

        else
        {
          return_value___errno_location$12=__errno_location();
          return_value_strerror$13=strerror(*return_value___errno_location$12);
          log_log(4, "error writing to client: %s", return_value_strerror$13);
        }
        return -1;
      }

      unsigned int return_value_htonl$16;
      return_value_htonl$16=htonl((unsigned int)(signed int)0x00080001);
      tmpint32 = (signed int)return_value_htonl$16;
      signed int return_value_tio_write$22;
      return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$22 == 0))
      {
        signed int *return_value___errno_location$21;
        return_value___errno_location$21=__errno_location();
        if(*return_value___errno_location$21 == 32)
        {
          return_value___errno_location$17=__errno_location();
          return_value_strerror$18=strerror(*return_value___errno_location$17);
          log_log(7, "error writing to client: %s", return_value_strerror$18);
        }

        else
        {
          return_value___errno_location$19=__errno_location();
          return_value_strerror$20=strerror(*return_value___errno_location$19);
          log_log(4, "error writing to client: %s", return_value_strerror$20);
        }
        return -1;
      }

      signed int return_value_mkfilter_passwd_byname$23;
      return_value_mkfilter_passwd_byname$23=mkfilter_passwd_byname(name, filter, sizeof(char [4096l]) /*4096ul*/ );
      if(!(return_value_mkfilter_passwd_byname$23 == 0))
      {
        log_log(3, "nslcd_passwd_byname(): filter buffer too small");
        return -1;
      }

      else
      {
        i = 0;
        do
        {
          base = passwd_bases[(signed long int)i];
          if(base == ((const char *)NULL))
            break;

          search=myldap_search(session, base, passwd_scope, filter, passwd_attrs, (signed int *)(void *)0);
          if(search == ((struct myldap_search *)NULL))
            return -1;

          do
          {
            entry=myldap_get_entry(search, &rc);
            if(entry == ((struct myldap_entry *)NULL))
              break;

            signed int return_value_write_passwd$24;
            return_value_write_passwd$24=write_passwd(fp, entry, name, (const unsigned int *)(void *)0, calleruid);
            if(!(return_value_write_passwd$24 == 0))
              return -1;

          }
          while((_Bool)1);
          i = i + 1;
        }
        while((_Bool)1);
        if(rc == 0x00)
        {
          unsigned int return_value_htonl$25;
          return_value_htonl$25=htonl((unsigned int)(signed int)2);
          tmpint32 = (signed int)return_value_htonl$25;
          signed int return_value_tio_write$31;
          return_value_tio_write$31=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$31 == 0))
          {
            signed int *return_value___errno_location$30;
            return_value___errno_location$30=__errno_location();
            if(*return_value___errno_location$30 == 32)
            {
              return_value___errno_location$26=__errno_location();
              return_value_strerror$27=strerror(*return_value___errno_location$26);
              log_log(7, "error writing to client: %s", return_value_strerror$27);
            }

            else
            {
              return_value___errno_location$28=__errno_location();
              return_value_strerror$29=strerror(*return_value___errno_location$28);
              log_log(4, "error writing to client: %s", return_value_strerror$29);
            }
            return -1;
          }

        }

        return 0;
      }
    }
  }
}

// nslcd_passwd_byuid
// file common.h line 239
signed int nslcd_passwd_byuid(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  unsigned int uid;
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  uid = (unsigned int)(signed int)return_value_ntohl$4;
  log_setrequest("passwd=%lu", (unsigned long int)uid);
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  signed int *return_value___errno_location$20;
  char *return_value_strerror$21;
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  if(!(uid >= nslcd_cfg->nss_min_uid))
  {
    unsigned int return_value_htonl$5;
    return_value_htonl$5=htonl((unsigned int)(signed int)0x00000002);
    tmpint32 = (signed int)return_value_htonl$5;
    signed int return_value_tio_write$11;
    return_value_tio_write$11=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$11 == 0))
    {
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      if(*return_value___errno_location$10 == 32)
      {
        return_value___errno_location$6=__errno_location();
        return_value_strerror$7=strerror(*return_value___errno_location$6);
        log_log(7, "error writing to client: %s", return_value_strerror$7);
      }

      else
      {
        return_value___errno_location$8=__errno_location();
        return_value_strerror$9=strerror(*return_value___errno_location$8);
        log_log(4, "error writing to client: %s", return_value_strerror$9);
      }
      return -1;
    }

    unsigned int return_value_htonl$12;
    return_value_htonl$12=htonl((unsigned int)(signed int)0x00080002);
    tmpint32 = (signed int)return_value_htonl$12;
    signed int return_value_tio_write$18;
    return_value_tio_write$18=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$18 == 0))
    {
      signed int *return_value___errno_location$17;
      return_value___errno_location$17=__errno_location();
      if(*return_value___errno_location$17 == 32)
      {
        return_value___errno_location$13=__errno_location();
        return_value_strerror$14=strerror(*return_value___errno_location$13);
        log_log(7, "error writing to client: %s", return_value_strerror$14);
      }

      else
      {
        return_value___errno_location$15=__errno_location();
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        log_log(4, "error writing to client: %s", return_value_strerror$16);
      }
      return -1;
    }

    unsigned int return_value_htonl$19;
    return_value_htonl$19=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$19;
    signed int return_value_tio_write$25;
    return_value_tio_write$25=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$25 == 0))
    {
      signed int *return_value___errno_location$24;
      return_value___errno_location$24=__errno_location();
      if(*return_value___errno_location$24 == 32)
      {
        return_value___errno_location$20=__errno_location();
        return_value_strerror$21=strerror(*return_value___errno_location$20);
        log_log(7, "error writing to client: %s", return_value_strerror$21);
      }

      else
      {
        return_value___errno_location$22=__errno_location();
        return_value_strerror$23=strerror(*return_value___errno_location$22);
        log_log(4, "error writing to client: %s", return_value_strerror$23);
      }
      return -1;
    }

    return 0;
  }

  nsswitch_check_reload();
  unsigned int return_value_htonl$26;
  return_value_htonl$26=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$26;
  signed int return_value_tio_write$32;
  return_value_tio_write$32=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  signed int *return_value___errno_location$29;
  char *return_value_strerror$30;
  if(!(return_value_tio_write$32 == 0))
  {
    signed int *return_value___errno_location$31;
    return_value___errno_location$31=__errno_location();
    if(*return_value___errno_location$31 == 32)
    {
      return_value___errno_location$27=__errno_location();
      return_value_strerror$28=strerror(*return_value___errno_location$27);
      log_log(7, "error writing to client: %s", return_value_strerror$28);
    }

    else
    {
      return_value___errno_location$29=__errno_location();
      return_value_strerror$30=strerror(*return_value___errno_location$29);
      log_log(4, "error writing to client: %s", return_value_strerror$30);
    }
    return -1;
  }

  unsigned int return_value_htonl$33;
  return_value_htonl$33=htonl((unsigned int)(signed int)0x00080002);
  tmpint32 = (signed int)return_value_htonl$33;
  signed int return_value_tio_write$39;
  return_value_tio_write$39=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$34;
  char *return_value_strerror$35;
  signed int *return_value___errno_location$36;
  char *return_value_strerror$37;
  if(!(return_value_tio_write$39 == 0))
  {
    signed int *return_value___errno_location$38;
    return_value___errno_location$38=__errno_location();
    if(*return_value___errno_location$38 == 32)
    {
      return_value___errno_location$34=__errno_location();
      return_value_strerror$35=strerror(*return_value___errno_location$34);
      log_log(7, "error writing to client: %s", return_value_strerror$35);
    }

    else
    {
      return_value___errno_location$36=__errno_location();
      return_value_strerror$37=strerror(*return_value___errno_location$36);
      log_log(4, "error writing to client: %s", return_value_strerror$37);
    }
    return -1;
  }

  signed int return_value_mkfilter_passwd_byuid$40;
  return_value_mkfilter_passwd_byuid$40=mkfilter_passwd_byuid(uid, filter, sizeof(char [4096l]) /*4096ul*/ );
  signed int *return_value___errno_location$43;
  char *return_value_strerror$44;
  signed int *return_value___errno_location$45;
  char *return_value_strerror$46;
  if(!(return_value_mkfilter_passwd_byuid$40 == 0))
  {
    log_log(3, "nslcd_passwd_byuid(): filter buffer too small");
    return -1;
  }

  else
  {
    i = 0;
    do
    {
      base = passwd_bases[(signed long int)i];
      if(base == ((const char *)NULL))
        break;

      search=myldap_search(session, base, passwd_scope, filter, passwd_attrs, (signed int *)(void *)0);
      if(search == ((struct myldap_search *)NULL))
        return -1;

      do
      {
        entry=myldap_get_entry(search, &rc);
        if(entry == ((struct myldap_entry *)NULL))
          break;

        signed int return_value_write_passwd$41;
        return_value_write_passwd$41=write_passwd(fp, entry, (const char *)(void *)0, &uid, calleruid);
        if(!(return_value_write_passwd$41 == 0))
          return -1;

      }
      while((_Bool)1);
      i = i + 1;
    }
    while((_Bool)1);
    if(rc == 0x00)
    {
      unsigned int return_value_htonl$42;
      return_value_htonl$42=htonl((unsigned int)(signed int)2);
      tmpint32 = (signed int)return_value_htonl$42;
      signed int return_value_tio_write$48;
      return_value_tio_write$48=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$48 == 0))
      {
        signed int *return_value___errno_location$47;
        return_value___errno_location$47=__errno_location();
        if(*return_value___errno_location$47 == 32)
        {
          return_value___errno_location$43=__errno_location();
          return_value_strerror$44=strerror(*return_value___errno_location$43);
          log_log(7, "error writing to client: %s", return_value_strerror$44);
        }

        else
        {
          return_value___errno_location$45=__errno_location();
          return_value_strerror$46=strerror(*return_value___errno_location$45);
          log_log(4, "error writing to client: %s", return_value_strerror$46);
        }
        return -1;
      }

    }

    return 0;
  }
}

// nslcd_protocol_all
// file common.h line 243
signed int nslcd_protocol_all(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  const char *filter;
  log_setrequest("protocol(all)");
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$1;
  signed int return_value_tio_write$7;
  return_value_tio_write$7=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(return_value_tio_write$7 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    if(*return_value___errno_location$6 == 32)
    {
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_log(7, "error writing to client: %s", return_value_strerror$3);
    }

    else
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_log(4, "error writing to client: %s", return_value_strerror$5);
    }
    return -1;
  }

  unsigned int return_value_htonl$8;
  return_value_htonl$8=htonl((unsigned int)(signed int)0x00090008);
  tmpint32 = (signed int)return_value_htonl$8;
  signed int return_value_tio_write$14;
  return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(!(return_value_tio_write$14 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    if(*return_value___errno_location$13 == 32)
    {
      return_value___errno_location$9=__errno_location();
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_log(7, "error writing to client: %s", return_value_strerror$10);
    }

    else
    {
      return_value___errno_location$11=__errno_location();
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      log_log(4, "error writing to client: %s", return_value_strerror$12);
    }
    return -1;
  }

  filter = protocol_filter;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  i = 0;
  do
  {
    base = protocol_bases[(signed long int)i];
    if(base == ((const char *)NULL))
      break;

    search=myldap_search(session, base, protocol_scope, filter, protocol_attrs, (signed int *)(void *)0);
    if(search == ((struct myldap_search *)NULL))
      return -1;

    do
    {
      entry=myldap_get_entry(search, &rc);
      if(entry == ((struct myldap_entry *)NULL))
        break;

      signed int return_value_write_protocol$15;
      return_value_write_protocol$15=write_protocol(fp, entry, (const char *)(void *)0);
      if(!(return_value_write_protocol$15 == 0))
        return -1;

    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  if(rc == 0x00)
  {
    unsigned int return_value_htonl$16;
    return_value_htonl$16=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$16;
    signed int return_value_tio_write$22;
    return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$22 == 0))
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      if(*return_value___errno_location$21 == 32)
      {
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        log_log(7, "error writing to client: %s", return_value_strerror$18);
      }

      else
      {
        return_value___errno_location$19=__errno_location();
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        log_log(4, "error writing to client: %s", return_value_strerror$20);
      }
      return -1;
    }

  }

  return 0;
}

// nslcd_protocol_byname
// file common.h line 241
signed int nslcd_protocol_byname(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  char name[256l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$16;
  char *return_value_strerror$17;
  signed int *return_value___errno_location$18;
  char *return_value_strerror$19;
  signed int *return_value___errno_location$25;
  char *return_value_strerror$26;
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)name, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    name[(signed long int)tmpint32] = (char)0;
    log_setrequest("protocol=\"%s\"", (const void *)name);
    unsigned int return_value_htonl$8;
    return_value_htonl$8=htonl((unsigned int)(signed int)0x00000002);
    tmpint32 = (signed int)return_value_htonl$8;
    signed int return_value_tio_write$14;
    return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$14 == 0))
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      if(*return_value___errno_location$13 == 32)
      {
        return_value___errno_location$9=__errno_location();
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        log_log(7, "error writing to client: %s", return_value_strerror$10);
      }

      else
      {
        return_value___errno_location$11=__errno_location();
        return_value_strerror$12=strerror(*return_value___errno_location$11);
        log_log(4, "error writing to client: %s", return_value_strerror$12);
      }
      return -1;
    }

    unsigned int return_value_htonl$15;
    return_value_htonl$15=htonl((unsigned int)(signed int)0x00090001);
    tmpint32 = (signed int)return_value_htonl$15;
    signed int return_value_tio_write$21;
    return_value_tio_write$21=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$21 == 0))
    {
      signed int *return_value___errno_location$20;
      return_value___errno_location$20=__errno_location();
      if(*return_value___errno_location$20 == 32)
      {
        return_value___errno_location$16=__errno_location();
        return_value_strerror$17=strerror(*return_value___errno_location$16);
        log_log(7, "error writing to client: %s", return_value_strerror$17);
      }

      else
      {
        return_value___errno_location$18=__errno_location();
        return_value_strerror$19=strerror(*return_value___errno_location$18);
        log_log(4, "error writing to client: %s", return_value_strerror$19);
      }
      return -1;
    }

    signed int return_value_mkfilter_protocol_byname$22;
    return_value_mkfilter_protocol_byname$22=mkfilter_protocol_byname(name, filter, sizeof(char [4096l]) /*4096ul*/ );
    if(!(return_value_mkfilter_protocol_byname$22 == 0))
    {
      log_log(3, "nslcd_protocol_byname(): filter buffer too small");
      return -1;
    }

    else
    {
      i = 0;
      do
      {
        base = protocol_bases[(signed long int)i];
        if(base == ((const char *)NULL))
          break;

        search=myldap_search(session, base, protocol_scope, filter, protocol_attrs, (signed int *)(void *)0);
        if(search == ((struct myldap_search *)NULL))
          return -1;

        do
        {
          entry=myldap_get_entry(search, &rc);
          if(entry == ((struct myldap_entry *)NULL))
            break;

          signed int return_value_write_protocol$23;
          return_value_write_protocol$23=write_protocol(fp, entry, name);
          if(!(return_value_write_protocol$23 == 0))
            return -1;

        }
        while((_Bool)1);
        i = i + 1;
      }
      while((_Bool)1);
      if(rc == 0x00)
      {
        unsigned int return_value_htonl$24;
        return_value_htonl$24=htonl((unsigned int)(signed int)2);
        tmpint32 = (signed int)return_value_htonl$24;
        signed int return_value_tio_write$30;
        return_value_tio_write$30=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$30 == 0))
        {
          signed int *return_value___errno_location$29;
          return_value___errno_location$29=__errno_location();
          if(*return_value___errno_location$29 == 32)
          {
            return_value___errno_location$25=__errno_location();
            return_value_strerror$26=strerror(*return_value___errno_location$25);
            log_log(7, "error writing to client: %s", return_value_strerror$26);
          }

          else
          {
            return_value___errno_location$27=__errno_location();
            return_value_strerror$28=strerror(*return_value___errno_location$27);
            log_log(4, "error writing to client: %s", return_value_strerror$28);
          }
          return -1;
        }

      }

      return 0;
    }
  }
}

// nslcd_protocol_bynumber
// file common.h line 242
signed int nslcd_protocol_bynumber(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  signed int protocol;
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  protocol = (signed int)return_value_ntohl$4;
  log_setrequest("protocol=%lu", (unsigned long int)protocol);
  unsigned int return_value_htonl$5;
  return_value_htonl$5=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$5;
  signed int return_value_tio_write$11;
  return_value_tio_write$11=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  if(!(return_value_tio_write$11 == 0))
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    if(*return_value___errno_location$10 == 32)
    {
      return_value___errno_location$6=__errno_location();
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      log_log(7, "error writing to client: %s", return_value_strerror$7);
    }

    else
    {
      return_value___errno_location$8=__errno_location();
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error writing to client: %s", return_value_strerror$9);
    }
    return -1;
  }

  unsigned int return_value_htonl$12;
  return_value_htonl$12=htonl((unsigned int)(signed int)0x00090002);
  tmpint32 = (signed int)return_value_htonl$12;
  signed int return_value_tio_write$18;
  return_value_tio_write$18=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  if(!(return_value_tio_write$18 == 0))
  {
    signed int *return_value___errno_location$17;
    return_value___errno_location$17=__errno_location();
    if(*return_value___errno_location$17 == 32)
    {
      return_value___errno_location$13=__errno_location();
      return_value_strerror$14=strerror(*return_value___errno_location$13);
      log_log(7, "error writing to client: %s", return_value_strerror$14);
    }

    else
    {
      return_value___errno_location$15=__errno_location();
      return_value_strerror$16=strerror(*return_value___errno_location$15);
      log_log(4, "error writing to client: %s", return_value_strerror$16);
    }
    return -1;
  }

  signed int return_value_mkfilter_protocol_bynumber$19;
  return_value_mkfilter_protocol_bynumber$19=mkfilter_protocol_bynumber(protocol, filter, sizeof(char [4096l]) /*4096ul*/ );
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  signed int *return_value___errno_location$24;
  char *return_value_strerror$25;
  if(!(return_value_mkfilter_protocol_bynumber$19 == 0))
  {
    log_log(3, "nslcd_protocol_bynumber(): filter buffer too small");
    return -1;
  }

  else
  {
    i = 0;
    do
    {
      base = protocol_bases[(signed long int)i];
      if(base == ((const char *)NULL))
        break;

      search=myldap_search(session, base, protocol_scope, filter, protocol_attrs, (signed int *)(void *)0);
      if(search == ((struct myldap_search *)NULL))
        return -1;

      do
      {
        entry=myldap_get_entry(search, &rc);
        if(entry == ((struct myldap_entry *)NULL))
          break;

        signed int return_value_write_protocol$20;
        return_value_write_protocol$20=write_protocol(fp, entry, (const char *)(void *)0);
        if(!(return_value_write_protocol$20 == 0))
          return -1;

      }
      while((_Bool)1);
      i = i + 1;
    }
    while((_Bool)1);
    if(rc == 0x00)
    {
      unsigned int return_value_htonl$21;
      return_value_htonl$21=htonl((unsigned int)(signed int)2);
      tmpint32 = (signed int)return_value_htonl$21;
      signed int return_value_tio_write$27;
      return_value_tio_write$27=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$27 == 0))
      {
        signed int *return_value___errno_location$26;
        return_value___errno_location$26=__errno_location();
        if(*return_value___errno_location$26 == 32)
        {
          return_value___errno_location$22=__errno_location();
          return_value_strerror$23=strerror(*return_value___errno_location$22);
          log_log(7, "error writing to client: %s", return_value_strerror$23);
        }

        else
        {
          return_value___errno_location$24=__errno_location();
          return_value_strerror$25=strerror(*return_value___errno_location$24);
          log_log(4, "error writing to client: %s", return_value_strerror$25);
        }
        return -1;
      }

    }

    return 0;
  }
}

// nslcd_rpc_all
// file common.h line 246
signed int nslcd_rpc_all(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  const char *filter;
  log_setrequest("rpc(all)");
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$1;
  signed int return_value_tio_write$7;
  return_value_tio_write$7=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(return_value_tio_write$7 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    if(*return_value___errno_location$6 == 32)
    {
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_log(7, "error writing to client: %s", return_value_strerror$3);
    }

    else
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_log(4, "error writing to client: %s", return_value_strerror$5);
    }
    return -1;
  }

  unsigned int return_value_htonl$8;
  return_value_htonl$8=htonl((unsigned int)(signed int)0x000a0008);
  tmpint32 = (signed int)return_value_htonl$8;
  signed int return_value_tio_write$14;
  return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(!(return_value_tio_write$14 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    if(*return_value___errno_location$13 == 32)
    {
      return_value___errno_location$9=__errno_location();
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_log(7, "error writing to client: %s", return_value_strerror$10);
    }

    else
    {
      return_value___errno_location$11=__errno_location();
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      log_log(4, "error writing to client: %s", return_value_strerror$12);
    }
    return -1;
  }

  filter = rpc_filter;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  i = 0;
  do
  {
    base = rpc_bases[(signed long int)i];
    if(base == ((const char *)NULL))
      break;

    search=myldap_search(session, base, rpc_scope, filter, rpc_attrs, (signed int *)(void *)0);
    if(search == ((struct myldap_search *)NULL))
      return -1;

    do
    {
      entry=myldap_get_entry(search, &rc);
      if(entry == ((struct myldap_entry *)NULL))
        break;

      signed int return_value_write_rpc$15;
      return_value_write_rpc$15=write_rpc(fp, entry, (const char *)(void *)0);
      if(!(return_value_write_rpc$15 == 0))
        return -1;

    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  if(rc == 0x00)
  {
    unsigned int return_value_htonl$16;
    return_value_htonl$16=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$16;
    signed int return_value_tio_write$22;
    return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$22 == 0))
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      if(*return_value___errno_location$21 == 32)
      {
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        log_log(7, "error writing to client: %s", return_value_strerror$18);
      }

      else
      {
        return_value___errno_location$19=__errno_location();
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        log_log(4, "error writing to client: %s", return_value_strerror$20);
      }
      return -1;
    }

  }

  return 0;
}

// nslcd_rpc_byname
// file common.h line 244
signed int nslcd_rpc_byname(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  char name[256l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$16;
  char *return_value_strerror$17;
  signed int *return_value___errno_location$18;
  char *return_value_strerror$19;
  signed int *return_value___errno_location$25;
  char *return_value_strerror$26;
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)name, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    name[(signed long int)tmpint32] = (char)0;
    log_setrequest("rpc=\"%s\"", (const void *)name);
    unsigned int return_value_htonl$8;
    return_value_htonl$8=htonl((unsigned int)(signed int)0x00000002);
    tmpint32 = (signed int)return_value_htonl$8;
    signed int return_value_tio_write$14;
    return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$14 == 0))
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      if(*return_value___errno_location$13 == 32)
      {
        return_value___errno_location$9=__errno_location();
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        log_log(7, "error writing to client: %s", return_value_strerror$10);
      }

      else
      {
        return_value___errno_location$11=__errno_location();
        return_value_strerror$12=strerror(*return_value___errno_location$11);
        log_log(4, "error writing to client: %s", return_value_strerror$12);
      }
      return -1;
    }

    unsigned int return_value_htonl$15;
    return_value_htonl$15=htonl((unsigned int)(signed int)0x000a0001);
    tmpint32 = (signed int)return_value_htonl$15;
    signed int return_value_tio_write$21;
    return_value_tio_write$21=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$21 == 0))
    {
      signed int *return_value___errno_location$20;
      return_value___errno_location$20=__errno_location();
      if(*return_value___errno_location$20 == 32)
      {
        return_value___errno_location$16=__errno_location();
        return_value_strerror$17=strerror(*return_value___errno_location$16);
        log_log(7, "error writing to client: %s", return_value_strerror$17);
      }

      else
      {
        return_value___errno_location$18=__errno_location();
        return_value_strerror$19=strerror(*return_value___errno_location$18);
        log_log(4, "error writing to client: %s", return_value_strerror$19);
      }
      return -1;
    }

    signed int return_value_mkfilter_rpc_byname$22;
    return_value_mkfilter_rpc_byname$22=mkfilter_rpc_byname(name, filter, sizeof(char [4096l]) /*4096ul*/ );
    if(!(return_value_mkfilter_rpc_byname$22 == 0))
    {
      log_log(3, "nslcd_rpc_byname(): filter buffer too small");
      return -1;
    }

    else
    {
      i = 0;
      do
      {
        base = rpc_bases[(signed long int)i];
        if(base == ((const char *)NULL))
          break;

        search=myldap_search(session, base, rpc_scope, filter, rpc_attrs, (signed int *)(void *)0);
        if(search == ((struct myldap_search *)NULL))
          return -1;

        do
        {
          entry=myldap_get_entry(search, &rc);
          if(entry == ((struct myldap_entry *)NULL))
            break;

          signed int return_value_write_rpc$23;
          return_value_write_rpc$23=write_rpc(fp, entry, name);
          if(!(return_value_write_rpc$23 == 0))
            return -1;

        }
        while((_Bool)1);
        i = i + 1;
      }
      while((_Bool)1);
      if(rc == 0x00)
      {
        unsigned int return_value_htonl$24;
        return_value_htonl$24=htonl((unsigned int)(signed int)2);
        tmpint32 = (signed int)return_value_htonl$24;
        signed int return_value_tio_write$30;
        return_value_tio_write$30=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$30 == 0))
        {
          signed int *return_value___errno_location$29;
          return_value___errno_location$29=__errno_location();
          if(*return_value___errno_location$29 == 32)
          {
            return_value___errno_location$25=__errno_location();
            return_value_strerror$26=strerror(*return_value___errno_location$25);
            log_log(7, "error writing to client: %s", return_value_strerror$26);
          }

          else
          {
            return_value___errno_location$27=__errno_location();
            return_value_strerror$28=strerror(*return_value___errno_location$27);
            log_log(4, "error writing to client: %s", return_value_strerror$28);
          }
          return -1;
        }

      }

      return 0;
    }
  }
}

// nslcd_rpc_bynumber
// file common.h line 245
signed int nslcd_rpc_bynumber(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  signed int number;
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  number = (signed int)return_value_ntohl$4;
  log_setrequest("rpc=%lu", (unsigned long int)number);
  unsigned int return_value_htonl$5;
  return_value_htonl$5=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$5;
  signed int return_value_tio_write$11;
  return_value_tio_write$11=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  if(!(return_value_tio_write$11 == 0))
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    if(*return_value___errno_location$10 == 32)
    {
      return_value___errno_location$6=__errno_location();
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      log_log(7, "error writing to client: %s", return_value_strerror$7);
    }

    else
    {
      return_value___errno_location$8=__errno_location();
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error writing to client: %s", return_value_strerror$9);
    }
    return -1;
  }

  unsigned int return_value_htonl$12;
  return_value_htonl$12=htonl((unsigned int)(signed int)0x000a0002);
  tmpint32 = (signed int)return_value_htonl$12;
  signed int return_value_tio_write$18;
  return_value_tio_write$18=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  if(!(return_value_tio_write$18 == 0))
  {
    signed int *return_value___errno_location$17;
    return_value___errno_location$17=__errno_location();
    if(*return_value___errno_location$17 == 32)
    {
      return_value___errno_location$13=__errno_location();
      return_value_strerror$14=strerror(*return_value___errno_location$13);
      log_log(7, "error writing to client: %s", return_value_strerror$14);
    }

    else
    {
      return_value___errno_location$15=__errno_location();
      return_value_strerror$16=strerror(*return_value___errno_location$15);
      log_log(4, "error writing to client: %s", return_value_strerror$16);
    }
    return -1;
  }

  signed int return_value_mkfilter_rpc_bynumber$19;
  return_value_mkfilter_rpc_bynumber$19=mkfilter_rpc_bynumber(number, filter, sizeof(char [4096l]) /*4096ul*/ );
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  signed int *return_value___errno_location$24;
  char *return_value_strerror$25;
  if(!(return_value_mkfilter_rpc_bynumber$19 == 0))
  {
    log_log(3, "nslcd_rpc_bynumber(): filter buffer too small");
    return -1;
  }

  else
  {
    i = 0;
    do
    {
      base = rpc_bases[(signed long int)i];
      if(base == ((const char *)NULL))
        break;

      search=myldap_search(session, base, rpc_scope, filter, rpc_attrs, (signed int *)(void *)0);
      if(search == ((struct myldap_search *)NULL))
        return -1;

      do
      {
        entry=myldap_get_entry(search, &rc);
        if(entry == ((struct myldap_entry *)NULL))
          break;

        signed int return_value_write_rpc$20;
        return_value_write_rpc$20=write_rpc(fp, entry, (const char *)(void *)0);
        if(!(return_value_write_rpc$20 == 0))
          return -1;

      }
      while((_Bool)1);
      i = i + 1;
    }
    while((_Bool)1);
    if(rc == 0x00)
    {
      unsigned int return_value_htonl$21;
      return_value_htonl$21=htonl((unsigned int)(signed int)2);
      tmpint32 = (signed int)return_value_htonl$21;
      signed int return_value_tio_write$27;
      return_value_tio_write$27=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$27 == 0))
      {
        signed int *return_value___errno_location$26;
        return_value___errno_location$26=__errno_location();
        if(*return_value___errno_location$26 == 32)
        {
          return_value___errno_location$22=__errno_location();
          return_value_strerror$23=strerror(*return_value___errno_location$22);
          log_log(7, "error writing to client: %s", return_value_strerror$23);
        }

        else
        {
          return_value___errno_location$24=__errno_location();
          return_value_strerror$25=strerror(*return_value___errno_location$24);
          log_log(4, "error writing to client: %s", return_value_strerror$25);
        }
        return -1;
      }

    }

    return 0;
  }
}

// nslcd_service_all
// file common.h line 249
signed int nslcd_service_all(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  const char *filter;
  log_setrequest("service(all)");
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$1;
  signed int return_value_tio_write$7;
  return_value_tio_write$7=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(return_value_tio_write$7 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    if(*return_value___errno_location$6 == 32)
    {
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_log(7, "error writing to client: %s", return_value_strerror$3);
    }

    else
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_log(4, "error writing to client: %s", return_value_strerror$5);
    }
    return -1;
  }

  unsigned int return_value_htonl$8;
  return_value_htonl$8=htonl((unsigned int)(signed int)0x000b0008);
  tmpint32 = (signed int)return_value_htonl$8;
  signed int return_value_tio_write$14;
  return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(!(return_value_tio_write$14 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    if(*return_value___errno_location$13 == 32)
    {
      return_value___errno_location$9=__errno_location();
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_log(7, "error writing to client: %s", return_value_strerror$10);
    }

    else
    {
      return_value___errno_location$11=__errno_location();
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      log_log(4, "error writing to client: %s", return_value_strerror$12);
    }
    return -1;
  }

  filter = service_filter;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  i = 0;
  do
  {
    base = service_bases[(signed long int)i];
    if(base == ((const char *)NULL))
      break;

    search=myldap_search(session, base, service_scope, filter, service_attrs, (signed int *)(void *)0);
    if(search == ((struct myldap_search *)NULL))
      return -1;

    do
    {
      entry=myldap_get_entry(search, &rc);
      if(entry == ((struct myldap_entry *)NULL))
        break;

      signed int return_value_write_service$15;
      return_value_write_service$15=write_service(fp, entry, (const char *)(void *)0, (const char *)(void *)0);
      if(!(return_value_write_service$15 == 0))
        return -1;

    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  if(rc == 0x00)
  {
    unsigned int return_value_htonl$16;
    return_value_htonl$16=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$16;
    signed int return_value_tio_write$22;
    return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$22 == 0))
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      if(*return_value___errno_location$21 == 32)
      {
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        log_log(7, "error writing to client: %s", return_value_strerror$18);
      }

      else
      {
        return_value___errno_location$19=__errno_location();
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        log_log(4, "error writing to client: %s", return_value_strerror$20);
      }
      return -1;
    }

  }

  return 0;
}

// nslcd_service_byname
// file common.h line 247
signed int nslcd_service_byname(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  char name[256l];
  char protocol[256l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$16;
  char *return_value_strerror$17;
  signed int *return_value___errno_location$18;
  char *return_value_strerror$19;
  signed int *return_value___errno_location$23;
  char *return_value_strerror$24;
  signed int *return_value___errno_location$25;
  char *return_value_strerror$26;
  signed int *return_value___errno_location$32;
  char *return_value_strerror$33;
  signed int *return_value___errno_location$34;
  char *return_value_strerror$35;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)name, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    name[(signed long int)tmpint32] = (char)0;
    signed int return_value_tio_read$10;
    return_value_tio_read$10=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_read$10 == 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error reading from client: %s", return_value_strerror$9);
      return -1;
    }

    unsigned int return_value_ntohl$11;
    return_value_ntohl$11=ntohl((unsigned int)tmpint32);
    tmpint32 = (signed int)return_value_ntohl$11;
    if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
    {
      tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
      log_log(3, "client supplied argument %d bytes too large", tmpint32);
      return -1;
    }

    else
    {
      if(tmpint32 >= 1)
      {
        signed int return_value_tio_read$14;
        return_value_tio_read$14=tio_read(fp, (void *)protocol, (unsigned long int)tmpint32);
        if(!(return_value_tio_read$14 == 0))
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          char *return_value_strerror$13;
          return_value_strerror$13=strerror(*return_value___errno_location$12);
          log_log(4, "error reading from client: %s", return_value_strerror$13);
          return -1;
        }

      }

      protocol[(signed long int)tmpint32] = (char)0;
      log_setrequest("service=\"%s\"%s%s", (const void *)name, (signed int)protocol[0l] != 0 ? "/" : "", (const void *)protocol);
      unsigned int return_value_htonl$15;
      return_value_htonl$15=htonl((unsigned int)(signed int)0x00000002);
      tmpint32 = (signed int)return_value_htonl$15;
      signed int return_value_tio_write$21;
      return_value_tio_write$21=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$21 == 0))
      {
        signed int *return_value___errno_location$20;
        return_value___errno_location$20=__errno_location();
        if(*return_value___errno_location$20 == 32)
        {
          return_value___errno_location$16=__errno_location();
          return_value_strerror$17=strerror(*return_value___errno_location$16);
          log_log(7, "error writing to client: %s", return_value_strerror$17);
        }

        else
        {
          return_value___errno_location$18=__errno_location();
          return_value_strerror$19=strerror(*return_value___errno_location$18);
          log_log(4, "error writing to client: %s", return_value_strerror$19);
        }
        return -1;
      }

      unsigned int return_value_htonl$22;
      return_value_htonl$22=htonl((unsigned int)(signed int)0x000b0001);
      tmpint32 = (signed int)return_value_htonl$22;
      signed int return_value_tio_write$28;
      return_value_tio_write$28=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$28 == 0))
      {
        signed int *return_value___errno_location$27;
        return_value___errno_location$27=__errno_location();
        if(*return_value___errno_location$27 == 32)
        {
          return_value___errno_location$23=__errno_location();
          return_value_strerror$24=strerror(*return_value___errno_location$23);
          log_log(7, "error writing to client: %s", return_value_strerror$24);
        }

        else
        {
          return_value___errno_location$25=__errno_location();
          return_value_strerror$26=strerror(*return_value___errno_location$25);
          log_log(4, "error writing to client: %s", return_value_strerror$26);
        }
        return -1;
      }

      signed int return_value_mkfilter_service_byname$29;
      return_value_mkfilter_service_byname$29=mkfilter_service_byname(name, protocol, filter, sizeof(char [4096l]) /*4096ul*/ );
      if(!(return_value_mkfilter_service_byname$29 == 0))
      {
        log_log(3, "nslcd_service_byname(): filter buffer too small");
        return -1;
      }

      else
      {
        i = 0;
        do
        {
          base = service_bases[(signed long int)i];
          if(base == ((const char *)NULL))
            break;

          search=myldap_search(session, base, service_scope, filter, service_attrs, (signed int *)(void *)0);
          if(search == ((struct myldap_search *)NULL))
            return -1;

          do
          {
            entry=myldap_get_entry(search, &rc);
            if(entry == ((struct myldap_entry *)NULL))
              break;

            signed int return_value_write_service$30;
            return_value_write_service$30=write_service(fp, entry, name, protocol);
            if(!(return_value_write_service$30 == 0))
              return -1;

          }
          while((_Bool)1);
          i = i + 1;
        }
        while((_Bool)1);
        if(rc == 0x00)
        {
          unsigned int return_value_htonl$31;
          return_value_htonl$31=htonl((unsigned int)(signed int)2);
          tmpint32 = (signed int)return_value_htonl$31;
          signed int return_value_tio_write$37;
          return_value_tio_write$37=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$37 == 0))
          {
            signed int *return_value___errno_location$36;
            return_value___errno_location$36=__errno_location();
            if(*return_value___errno_location$36 == 32)
            {
              return_value___errno_location$32=__errno_location();
              return_value_strerror$33=strerror(*return_value___errno_location$32);
              log_log(7, "error writing to client: %s", return_value_strerror$33);
            }

            else
            {
              return_value___errno_location$34=__errno_location();
              return_value_strerror$35=strerror(*return_value___errno_location$34);
              log_log(4, "error writing to client: %s", return_value_strerror$35);
            }
            return -1;
          }

        }

        return 0;
      }
    }
  }
}

// nslcd_service_bynumber
// file common.h line 248
signed int nslcd_service_bynumber(struct tio_fileinfo *fp, struct ldap_session *session)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  signed int number;
  char protocol[256l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  number = (signed int)return_value_ntohl$4;
  signed int return_value_tio_read$7;
  return_value_tio_read$7=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$7 == 0))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    log_log(4, "error reading from client: %s", return_value_strerror$6);
    return -1;
  }

  unsigned int return_value_ntohl$8;
  return_value_ntohl$8=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$8;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  signed int *return_value___errno_location$20;
  char *return_value_strerror$21;
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  signed int *return_value___errno_location$29;
  char *return_value_strerror$30;
  signed int *return_value___errno_location$31;
  char *return_value_strerror$32;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$11;
      return_value_tio_read$11=tio_read(fp, (void *)protocol, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$11 == 0))
      {
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        char *return_value_strerror$10;
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        log_log(4, "error reading from client: %s", return_value_strerror$10);
        return -1;
      }

    }

    protocol[(signed long int)tmpint32] = (char)0;
    log_setrequest("service=%lu%s%s", (unsigned long int)number, (signed int)protocol[0l] != 0 ? "/" : "", (const void *)protocol);
    unsigned int return_value_htonl$12;
    return_value_htonl$12=htonl((unsigned int)(signed int)0x00000002);
    tmpint32 = (signed int)return_value_htonl$12;
    signed int return_value_tio_write$18;
    return_value_tio_write$18=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$18 == 0))
    {
      signed int *return_value___errno_location$17;
      return_value___errno_location$17=__errno_location();
      if(*return_value___errno_location$17 == 32)
      {
        return_value___errno_location$13=__errno_location();
        return_value_strerror$14=strerror(*return_value___errno_location$13);
        log_log(7, "error writing to client: %s", return_value_strerror$14);
      }

      else
      {
        return_value___errno_location$15=__errno_location();
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        log_log(4, "error writing to client: %s", return_value_strerror$16);
      }
      return -1;
    }

    unsigned int return_value_htonl$19;
    return_value_htonl$19=htonl((unsigned int)(signed int)0x000b0002);
    tmpint32 = (signed int)return_value_htonl$19;
    signed int return_value_tio_write$25;
    return_value_tio_write$25=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$25 == 0))
    {
      signed int *return_value___errno_location$24;
      return_value___errno_location$24=__errno_location();
      if(*return_value___errno_location$24 == 32)
      {
        return_value___errno_location$20=__errno_location();
        return_value_strerror$21=strerror(*return_value___errno_location$20);
        log_log(7, "error writing to client: %s", return_value_strerror$21);
      }

      else
      {
        return_value___errno_location$22=__errno_location();
        return_value_strerror$23=strerror(*return_value___errno_location$22);
        log_log(4, "error writing to client: %s", return_value_strerror$23);
      }
      return -1;
    }

    signed int return_value_mkfilter_service_bynumber$26;
    return_value_mkfilter_service_bynumber$26=mkfilter_service_bynumber(number, protocol, filter, sizeof(char [4096l]) /*4096ul*/ );
    if(!(return_value_mkfilter_service_bynumber$26 == 0))
    {
      log_log(3, "nslcd_service_bynumber(): filter buffer too small");
      return -1;
    }

    else
    {
      i = 0;
      do
      {
        base = service_bases[(signed long int)i];
        if(base == ((const char *)NULL))
          break;

        search=myldap_search(session, base, service_scope, filter, service_attrs, (signed int *)(void *)0);
        if(search == ((struct myldap_search *)NULL))
          return -1;

        do
        {
          entry=myldap_get_entry(search, &rc);
          if(entry == ((struct myldap_entry *)NULL))
            break;

          signed int return_value_write_service$27;
          return_value_write_service$27=write_service(fp, entry, (const char *)(void *)0, protocol);
          if(!(return_value_write_service$27 == 0))
            return -1;

        }
        while((_Bool)1);
        i = i + 1;
      }
      while((_Bool)1);
      if(rc == 0x00)
      {
        unsigned int return_value_htonl$28;
        return_value_htonl$28=htonl((unsigned int)(signed int)2);
        tmpint32 = (signed int)return_value_htonl$28;
        signed int return_value_tio_write$34;
        return_value_tio_write$34=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$34 == 0))
        {
          signed int *return_value___errno_location$33;
          return_value___errno_location$33=__errno_location();
          if(*return_value___errno_location$33 == 32)
          {
            return_value___errno_location$29=__errno_location();
            return_value_strerror$30=strerror(*return_value___errno_location$29);
            log_log(7, "error writing to client: %s", return_value_strerror$30);
          }

          else
          {
            return_value___errno_location$31=__errno_location();
            return_value_strerror$32=strerror(*return_value___errno_location$31);
            log_log(4, "error writing to client: %s", return_value_strerror$32);
          }
          return -1;
        }

      }

      return 0;
    }
  }
}

// nslcd_shadow_all
// file common.h line 251
signed int nslcd_shadow_all(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  const char *filter;
  log_setrequest("shadow(all)");
  unsigned int return_value_htonl$1;
  return_value_htonl$1=htonl((unsigned int)(signed int)0x00000002);
  tmpint32 = (signed int)return_value_htonl$1;
  signed int return_value_tio_write$7;
  return_value_tio_write$7=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(return_value_tio_write$7 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    if(*return_value___errno_location$6 == 32)
    {
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_log(7, "error writing to client: %s", return_value_strerror$3);
    }

    else
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_log(4, "error writing to client: %s", return_value_strerror$5);
    }
    return -1;
  }

  unsigned int return_value_htonl$8;
  return_value_htonl$8=htonl((unsigned int)(signed int)0x000c0008);
  tmpint32 = (signed int)return_value_htonl$8;
  signed int return_value_tio_write$14;
  return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(!(return_value_tio_write$14 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    if(*return_value___errno_location$13 == 32)
    {
      return_value___errno_location$9=__errno_location();
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_log(7, "error writing to client: %s", return_value_strerror$10);
    }

    else
    {
      return_value___errno_location$11=__errno_location();
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      log_log(4, "error writing to client: %s", return_value_strerror$12);
    }
    return -1;
  }

  filter = shadow_filter;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  i = 0;
  do
  {
    base = shadow_bases[(signed long int)i];
    if(base == ((const char *)NULL))
      break;

    search=myldap_search(session, base, shadow_scope, filter, shadow_attrs, (signed int *)(void *)0);
    if(search == ((struct myldap_search *)NULL))
      return -1;

    do
    {
      entry=myldap_get_entry(search, &rc);
      if(entry == ((struct myldap_entry *)NULL))
        break;

      signed int return_value_write_shadow$15;
      return_value_write_shadow$15=write_shadow(fp, entry, (const char *)(void *)0, calleruid);
      if(!(return_value_write_shadow$15 == 0))
        return -1;

    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  if(rc == 0x00)
  {
    unsigned int return_value_htonl$16;
    return_value_htonl$16=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$16;
    signed int return_value_tio_write$22;
    return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$22 == 0))
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      if(*return_value___errno_location$21 == 32)
      {
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        log_log(7, "error writing to client: %s", return_value_strerror$18);
      }

      else
      {
        return_value___errno_location$19=__errno_location();
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        log_log(4, "error writing to client: %s", return_value_strerror$20);
      }
      return -1;
    }

  }

  return 0;
}

// nslcd_shadow_byname
// file common.h line 250
signed int nslcd_shadow_byname(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid)
{
  signed int tmpint32;
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *base;
  signed int rc;
  signed int i;
  char name[256l];
  char filter[4096l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$16;
  char *return_value_strerror$17;
  signed int *return_value___errno_location$18;
  char *return_value_strerror$19;
  signed int *return_value___errno_location$25;
  char *return_value_strerror$26;
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)name, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    name[(signed long int)tmpint32] = (char)0;
    log_setrequest("shadow=\"%s\"", (const void *)name);
    unsigned int return_value_htonl$8;
    return_value_htonl$8=htonl((unsigned int)(signed int)0x00000002);
    tmpint32 = (signed int)return_value_htonl$8;
    signed int return_value_tio_write$14;
    return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$14 == 0))
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      if(*return_value___errno_location$13 == 32)
      {
        return_value___errno_location$9=__errno_location();
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        log_log(7, "error writing to client: %s", return_value_strerror$10);
      }

      else
      {
        return_value___errno_location$11=__errno_location();
        return_value_strerror$12=strerror(*return_value___errno_location$11);
        log_log(4, "error writing to client: %s", return_value_strerror$12);
      }
      return -1;
    }

    unsigned int return_value_htonl$15;
    return_value_htonl$15=htonl((unsigned int)(signed int)0x000c0001);
    tmpint32 = (signed int)return_value_htonl$15;
    signed int return_value_tio_write$21;
    return_value_tio_write$21=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$21 == 0))
    {
      signed int *return_value___errno_location$20;
      return_value___errno_location$20=__errno_location();
      if(*return_value___errno_location$20 == 32)
      {
        return_value___errno_location$16=__errno_location();
        return_value_strerror$17=strerror(*return_value___errno_location$16);
        log_log(7, "error writing to client: %s", return_value_strerror$17);
      }

      else
      {
        return_value___errno_location$18=__errno_location();
        return_value_strerror$19=strerror(*return_value___errno_location$18);
        log_log(4, "error writing to client: %s", return_value_strerror$19);
      }
      return -1;
    }

    signed int return_value_mkfilter_shadow_byname$22;
    return_value_mkfilter_shadow_byname$22=mkfilter_shadow_byname(name, filter, sizeof(char [4096l]) /*4096ul*/ );
    if(!(return_value_mkfilter_shadow_byname$22 == 0))
    {
      log_log(3, "nslcd_shadow_byname(): filter buffer too small");
      return -1;
    }

    else
    {
      i = 0;
      do
      {
        base = shadow_bases[(signed long int)i];
        if(base == ((const char *)NULL))
          break;

        search=myldap_search(session, base, shadow_scope, filter, shadow_attrs, (signed int *)(void *)0);
        if(search == ((struct myldap_search *)NULL))
          return -1;

        do
        {
          entry=myldap_get_entry(search, &rc);
          if(entry == ((struct myldap_entry *)NULL))
            break;

          signed int return_value_write_shadow$23;
          return_value_write_shadow$23=write_shadow(fp, entry, name, calleruid);
          if(!(return_value_write_shadow$23 == 0))
            return -1;

        }
        while((_Bool)1);
        i = i + 1;
      }
      while((_Bool)1);
      if(rc == 0x00)
      {
        unsigned int return_value_htonl$24;
        return_value_htonl$24=htonl((unsigned int)(signed int)2);
        tmpint32 = (signed int)return_value_htonl$24;
        signed int return_value_tio_write$30;
        return_value_tio_write$30=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$30 == 0))
        {
          signed int *return_value___errno_location$29;
          return_value___errno_location$29=__errno_location();
          if(*return_value___errno_location$29 == 32)
          {
            return_value___errno_location$25=__errno_location();
            return_value_strerror$26=strerror(*return_value___errno_location$25);
            log_log(7, "error writing to client: %s", return_value_strerror$26);
          }

          else
          {
            return_value___errno_location$27=__errno_location();
            return_value_strerror$28=strerror(*return_value___errno_location$27);
            log_log(4, "error writing to client: %s", return_value_strerror$28);
          }
          return -1;
        }

      }

      return 0;
    }
  }
}

// nslcd_usermod
// file common.h line 257
signed int nslcd_usermod(struct tio_fileinfo *fp, struct ldap_session *session, unsigned int calleruid)
{
  signed int tmpint32;
  signed int rc = 0x00;
  char username[256l];
  signed int asroot;
  signed int isroot;
  char password[128l];
  signed int param;
  char buffer[4096l];
  unsigned long int buflen = sizeof(char [4096l]) /*4096ul*/ ;
  unsigned long int bufptr = (unsigned long int)0;
  const char *value = (const char *)(void *)0;
  const char *fullname = (const char *)(void *)0;
  const char *roomnumber = (const char *)(void *)0;
  const char *workphone = (const char *)(void *)0;
  const char *homephone = (const char *)(void *)0;
  const char *other = (const char *)(void *)0;
  const char *homedir = (const char *)(void *)0;
  const char *shell = (const char *)(void *)0;
  const char *binddn = (const char *)(void *)0;
  struct myldap_entry *entry;
  struct ldap_session *newsession;
  char errmsg[1024l];
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  tmpint32 = (signed int)return_value_ntohl$4;
  signed int *return_value___errno_location$31;
  char *return_value_strerror$32;
  signed int *return_value___errno_location$33;
  char *return_value_strerror$34;
  signed int *return_value___errno_location$38;
  char *return_value_strerror$39;
  signed int *return_value___errno_location$40;
  char *return_value_strerror$41;
  signed int *return_value___errno_location$45;
  char *return_value_strerror$46;
  signed int *return_value___errno_location$47;
  char *return_value_strerror$48;
  signed int *return_value___errno_location$53;
  char *return_value_strerror$54;
  signed int *return_value___errno_location$55;
  char *return_value_strerror$56;
  signed int return_value_is_valid_homedir$88;
  signed int *return_value___errno_location$60;
  char *return_value_strerror$61;
  signed int *return_value___errno_location$62;
  char *return_value_strerror$63;
  signed int *return_value___errno_location$67;
  char *return_value_strerror$68;
  signed int *return_value___errno_location$69;
  char *return_value_strerror$70;
  signed int *return_value___errno_location$75;
  char *return_value_strerror$76;
  signed int *return_value___errno_location$77;
  char *return_value_strerror$78;
  signed int *return_value___errno_location$82;
  char *return_value_strerror$83;
  signed int *return_value___errno_location$84;
  char *return_value_strerror$85;
  signed int return_value_is_valid_shell$118;
  signed int *return_value___errno_location$90;
  char *return_value_strerror$91;
  signed int *return_value___errno_location$92;
  char *return_value_strerror$93;
  signed int *return_value___errno_location$97;
  char *return_value_strerror$98;
  signed int *return_value___errno_location$99;
  char *return_value_strerror$100;
  signed int *return_value___errno_location$105;
  char *return_value_strerror$106;
  signed int *return_value___errno_location$107;
  char *return_value_strerror$108;
  signed int *return_value___errno_location$112;
  char *return_value_strerror$113;
  signed int *return_value___errno_location$114;
  char *return_value_strerror$115;
  signed int *return_value___errno_location$125;
  char *return_value_strerror$126;
  signed int *return_value___errno_location$127;
  char *return_value_strerror$128;
  signed int *return_value___errno_location$132;
  char *return_value_strerror$133;
  signed int *return_value___errno_location$134;
  char *return_value_strerror$135;
  signed int *return_value___errno_location$140;
  char *return_value_strerror$141;
  signed int *return_value___errno_location$142;
  char *return_value_strerror$143;
  signed int *return_value___errno_location$147;
  char *return_value_strerror$148;
  signed int *return_value___errno_location$149;
  char *return_value_strerror$150;
  signed int *return_value___errno_location$154;
  char *return_value_strerror$155;
  signed int *return_value___errno_location$156;
  char *return_value_strerror$157;
  signed int *return_value___errno_location$161;
  char *return_value_strerror$162;
  signed int *return_value___errno_location$163;
  char *return_value_strerror$164;
  signed int *return_value___errno_location$169;
  char *return_value_strerror$170;
  signed int *return_value___errno_location$171;
  char *return_value_strerror$172;
  signed int *return_value___errno_location$176;
  char *return_value_strerror$177;
  signed int *return_value___errno_location$178;
  char *return_value_strerror$179;
  if((unsigned long int)tmpint32 >= sizeof(char [256l]) /*256ul*/ )
  {
    tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [256l]) /*256ul*/ ) + (unsigned long int)1);
    log_log(3, "client supplied argument %d bytes too large", tmpint32);
    return -1;
  }

  else
  {
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_read$7;
      return_value_tio_read$7=tio_read(fp, (void *)username, (unsigned long int)tmpint32);
      if(!(return_value_tio_read$7 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_log(4, "error reading from client: %s", return_value_strerror$6);
        return -1;
      }

    }

    username[(signed long int)tmpint32] = (char)0;
    signed int return_value_tio_read$10;
    return_value_tio_read$10=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_read$10 == 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error reading from client: %s", return_value_strerror$9);
      return -1;
    }

    unsigned int return_value_ntohl$11;
    return_value_ntohl$11=ntohl((unsigned int)tmpint32);
    asroot = (signed int)return_value_ntohl$11;
    signed int return_value_tio_read$14;
    return_value_tio_read$14=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_read$14 == 0))
    {
      signed int *return_value___errno_location$12;
      return_value___errno_location$12=__errno_location();
      char *return_value_strerror$13;
      return_value_strerror$13=strerror(*return_value___errno_location$12);
      log_log(4, "error reading from client: %s", return_value_strerror$13);
      return -1;
    }

    unsigned int return_value_ntohl$15;
    return_value_ntohl$15=ntohl((unsigned int)tmpint32);
    tmpint32 = (signed int)return_value_ntohl$15;
    if((unsigned long int)tmpint32 >= sizeof(char [128l]) /*128ul*/ )
    {
      tmpint32 = (signed int)(((unsigned long int)tmpint32 - sizeof(char [128l]) /*128ul*/ ) + (unsigned long int)1);
      log_log(3, "client supplied argument %d bytes too large", tmpint32);
      return -1;
    }

    else
    {
      if(tmpint32 >= 1)
      {
        signed int return_value_tio_read$18;
        return_value_tio_read$18=tio_read(fp, (void *)password, (unsigned long int)tmpint32);
        if(!(return_value_tio_read$18 == 0))
        {
          signed int *return_value___errno_location$16;
          return_value___errno_location$16=__errno_location();
          char *return_value_strerror$17;
          return_value_strerror$17=strerror(*return_value___errno_location$16);
          log_log(4, "error reading from client: %s", return_value_strerror$17);
          return -1;
        }

      }

      password[(signed long int)tmpint32] = (char)0;
      while((_Bool)1)
      {
        signed int return_value_tio_read$21;
        return_value_tio_read$21=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_read$21 == 0))
        {
          signed int *return_value___errno_location$19;
          return_value___errno_location$19=__errno_location();
          char *return_value_strerror$20;
          return_value_strerror$20=strerror(*return_value___errno_location$19);
          log_log(4, "error reading from client: %s", return_value_strerror$20);
          return -1;
        }

        unsigned int return_value_ntohl$22;
        return_value_ntohl$22=ntohl((unsigned int)tmpint32);
        param = (signed int)return_value_ntohl$22;
        if(param == 0)
          break;

        signed int return_value_tio_read$25;
        return_value_tio_read$25=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_read$25 == 0))
        {
          signed int *return_value___errno_location$23;
          return_value___errno_location$23=__errno_location();
          char *return_value_strerror$24;
          return_value_strerror$24=strerror(*return_value___errno_location$23);
          log_log(4, "error reading from client: %s", return_value_strerror$24);
          return -1;
        }

        unsigned int return_value_ntohl$26;
        return_value_ntohl$26=ntohl((unsigned int)tmpint32);
        tmpint32 = (signed int)return_value_ntohl$26;
        if(!(buflen >= bufptr + (unsigned long int)(1 + tmpint32)))
        {
          tmpint32 = (signed int)((bufptr + (unsigned long int)(tmpint32 + 1)) - buflen);
          log_log(3, "client supplied argument %d bytes too large", tmpint32);
          return -1;
        }

        if(tmpint32 >= 1)
        {
          signed int return_value_tio_read$29;
          return_value_tio_read$29=tio_read(fp, (void *)(buffer + (signed long int)bufptr), (unsigned long int)tmpint32);
          if(!(return_value_tio_read$29 == 0))
          {
            signed int *return_value___errno_location$27;
            return_value___errno_location$27=__errno_location();
            char *return_value_strerror$28;
            return_value_strerror$28=strerror(*return_value___errno_location$27);
            log_log(4, "error reading from client: %s", return_value_strerror$28);
            return -1;
          }

        }

        (buffer + (signed long int)bufptr)[(signed long int)tmpint32] = (char)0;
        value = buffer + (signed long int)bufptr;
        bufptr = bufptr + (unsigned long int)(tmpint32 + 1);
        switch(param)
        {
          case 2:
          {
            fullname = value;
            break;
          }
          case 3:
          {
            roomnumber = value;
            break;
          }
          case 4:
          {
            workphone = value;
            break;
          }
          case 5:
          {
            homephone = value;
            break;
          }
          case 6:
          {
            other = value;
            break;
          }
          case 7:
          {
            homedir = value;
            break;
          }
          case 8:
            shell = value;
        }
      }
      log_setrequest("usermod=\"%s\"", (const void *)username);
      log_log(7, "nslcd_usermod(\"%s\",%s,\"%s\")", (const void *)username, asroot != 0 ? "asroot" : "asuser", password[0l] != 0 ? "***" : "");
      if(!(fullname == ((const char *)NULL)))
        log_log(7, "nslcd_usermod(fullname=\"%s\")", fullname);

      if(!(roomnumber == ((const char *)NULL)))
        log_log(7, "nslcd_usermod(roomnumber=\"%s\")", roomnumber);

      if(!(workphone == ((const char *)NULL)))
        log_log(7, "nslcd_usermod(workphone=\"%s\")", workphone);

      if(!(homephone == ((const char *)NULL)))
        log_log(7, "nslcd_usermod(homephone=\"%s\")", homephone);

      if(!(other == ((const char *)NULL)))
        log_log(7, "nslcd_usermod(other=\"%s\")", other);

      if(!(homedir == ((const char *)NULL)))
        log_log(7, "nslcd_usermod(homedir=\"%s\")", homedir);

      if(!(shell == ((const char *)NULL)))
        log_log(7, "nslcd_usermod(shell=\"%s\")", shell);

      unsigned int return_value_htonl$30;
      return_value_htonl$30=htonl((unsigned int)(signed int)0x00000002);
      tmpint32 = (signed int)return_value_htonl$30;
      signed int return_value_tio_write$36;
      return_value_tio_write$36=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$36 == 0))
      {
        signed int *return_value___errno_location$35;
        return_value___errno_location$35=__errno_location();
        if(*return_value___errno_location$35 == 32)
        {
          return_value___errno_location$31=__errno_location();
          return_value_strerror$32=strerror(*return_value___errno_location$31);
          log_log(7, "error writing to client: %s", return_value_strerror$32);
        }

        else
        {
          return_value___errno_location$33=__errno_location();
          return_value_strerror$34=strerror(*return_value___errno_location$33);
          log_log(4, "error writing to client: %s", return_value_strerror$34);
        }
        return -1;
      }

      unsigned int return_value_htonl$37;
      return_value_htonl$37=htonl((unsigned int)(signed int)0x000e0001);
      tmpint32 = (signed int)return_value_htonl$37;
      signed int return_value_tio_write$43;
      return_value_tio_write$43=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$43 == 0))
      {
        signed int *return_value___errno_location$42;
        return_value___errno_location$42=__errno_location();
        if(*return_value___errno_location$42 == 32)
        {
          return_value___errno_location$38=__errno_location();
          return_value_strerror$39=strerror(*return_value___errno_location$38);
          log_log(7, "error writing to client: %s", return_value_strerror$39);
        }

        else
        {
          return_value___errno_location$40=__errno_location();
          return_value_strerror$41=strerror(*return_value___errno_location$40);
          log_log(4, "error writing to client: %s", return_value_strerror$41);
        }
        return -1;
      }

      entry=validate_user$link1(session, username, &rc);
      if(entry == ((struct myldap_entry *)NULL))
      {
        if(rc == 0x20)
        {
          unsigned int return_value_htonl$44;
          return_value_htonl$44=htonl((unsigned int)(signed int)2);
          tmpint32 = (signed int)return_value_htonl$44;
          signed int return_value_tio_write$50;
          return_value_tio_write$50=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$50 == 0))
          {
            signed int *return_value___errno_location$49;
            return_value___errno_location$49=__errno_location();
            if(*return_value___errno_location$49 == 32)
            {
              return_value___errno_location$45=__errno_location();
              return_value_strerror$46=strerror(*return_value___errno_location$45);
              log_log(7, "error writing to client: %s", return_value_strerror$46);
            }

            else
            {
              return_value___errno_location$47=__errno_location();
              return_value_strerror$48=strerror(*return_value___errno_location$47);
              log_log(4, "error writing to client: %s", return_value_strerror$48);
            }
            return -1;
          }

        }

        return -1;
      }

      else
      {
        isroot = (signed int)(calleruid == (unsigned int)0 && asroot != 0);
        if(!(asroot == 0))
        {
          if(nslcd_cfg->rootpwmoddn == ((char *)NULL))
          {
            log_log(5, "rootpwmoddn not configured");
            return -1;
          }

          binddn = nslcd_cfg->rootpwmoddn;
          if((signed int)password[0l] == 0)
          {
            if(!(isroot == 0))
            {
              if(!(nslcd_cfg->rootpwmodpw == ((char *)NULL)))
              {
                unsigned long int return_value_strlen$51;
                return_value_strlen$51=strlen(nslcd_cfg->rootpwmodpw);
                if(return_value_strlen$51 >= sizeof(char [128l]) /*128ul*/ )
                {
                  log_log(3, "nslcd_pam_pwmod(): rootpwmodpw will not fit in password");
                  return -1;
                }

                strcpy(password, nslcd_cfg->rootpwmodpw);
              }

            }

          }

        }

        else
          binddn=myldap_get_dn(entry);
        unsigned int return_value_htonl$52;
        return_value_htonl$52=htonl((unsigned int)(signed int)1);
        tmpint32 = (signed int)return_value_htonl$52;
        signed int return_value_tio_write$58;
        return_value_tio_write$58=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$58 == 0))
        {
          signed int *return_value___errno_location$57;
          return_value___errno_location$57=__errno_location();
          if(*return_value___errno_location$57 == 32)
          {
            return_value___errno_location$53=__errno_location();
            return_value_strerror$54=strerror(*return_value___errno_location$53);
            log_log(7, "error writing to client: %s", return_value_strerror$54);
          }

          else
          {
            return_value___errno_location$55=__errno_location();
            return_value_strerror$56=strerror(*return_value___errno_location$55);
            log_log(4, "error writing to client: %s", return_value_strerror$56);
          }
          return -1;
        }

        if(isroot == 0 && !(homedir == ((const char *)NULL)))
        {
          return_value_is_valid_homedir$88=is_valid_homedir(homedir);
          if(return_value_is_valid_homedir$88 == 0)
          {
            log_log(5, "invalid directory: %s", homedir);
            unsigned int return_value_htonl$59;
            return_value_htonl$59=htonl((unsigned int)(signed int)7);
            tmpint32 = (signed int)return_value_htonl$59;
            signed int return_value_tio_write$65;
            return_value_tio_write$65=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$65 == 0))
            {
              signed int *return_value___errno_location$64;
              return_value___errno_location$64=__errno_location();
              if(*return_value___errno_location$64 == 32)
              {
                return_value___errno_location$60=__errno_location();
                return_value_strerror$61=strerror(*return_value___errno_location$60);
                log_log(7, "error writing to client: %s", return_value_strerror$61);
              }

              else
              {
                return_value___errno_location$62=__errno_location();
                return_value_strerror$63=strerror(*return_value___errno_location$62);
                log_log(4, "error writing to client: %s", return_value_strerror$63);
              }
              return -1;
            }

            {
              unsigned long int return_value_strlen$73;
              return_value_strlen$73=strlen("invalid directory");
              unsigned int return_value_htonl$74;
              return_value_htonl$74=htonl((unsigned int)(signed int)return_value_strlen$73);
              tmpint32 = (signed int)return_value_htonl$74;
              signed int return_value_tio_write$80;
              return_value_tio_write$80=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$80 == 0))
              {
                signed int *return_value___errno_location$79;
                return_value___errno_location$79=__errno_location();
                if(*return_value___errno_location$79 == 32)
                {
                  return_value___errno_location$75=__errno_location();
                  return_value_strerror$76=strerror(*return_value___errno_location$75);
                  log_log(7, "error writing to client: %s", return_value_strerror$76);
                }

                else
                {
                  return_value___errno_location$77=__errno_location();
                  return_value_strerror$78=strerror(*return_value___errno_location$77);
                  log_log(4, "error writing to client: %s", return_value_strerror$78);
                }
                return -1;
              }

              unsigned int return_value_ntohl$81;
              return_value_ntohl$81=ntohl((unsigned int)tmpint32);
              tmpint32 = (signed int)return_value_ntohl$81;
              if(tmpint32 >= 1)
              {
                signed int return_value_tio_write$87;
                return_value_tio_write$87=tio_write(fp, (const void *)"invalid directory", (unsigned long int)tmpint32);
                if(!(return_value_tio_write$87 == 0))
                {
                  signed int *return_value___errno_location$86;
                  return_value___errno_location$86=__errno_location();
                  if(*return_value___errno_location$86 == 32)
                  {
                    return_value___errno_location$82=__errno_location();
                    return_value_strerror$83=strerror(*return_value___errno_location$82);
                    log_log(7, "error writing to client: %s", return_value_strerror$83);
                  }

                  else
                  {
                    return_value___errno_location$84=__errno_location();
                    return_value_strerror$85=strerror(*return_value___errno_location$84);
                    log_log(4, "error writing to client: %s", return_value_strerror$85);
                  }
                  return -1;
                }

              }

            }
            homedir = (const char *)(void *)0;
          }

        }

        if(isroot == 0 && !(shell == ((const char *)NULL)))
        {
          return_value_is_valid_shell$118=is_valid_shell(shell);
          if(return_value_is_valid_shell$118 == 0)
          {
            log_log(5, "invalid shell: %s", shell);
            unsigned int return_value_htonl$89;
            return_value_htonl$89=htonl((unsigned int)(signed int)8);
            tmpint32 = (signed int)return_value_htonl$89;
            signed int return_value_tio_write$95;
            return_value_tio_write$95=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$95 == 0))
            {
              signed int *return_value___errno_location$94;
              return_value___errno_location$94=__errno_location();
              if(*return_value___errno_location$94 == 32)
              {
                return_value___errno_location$90=__errno_location();
                return_value_strerror$91=strerror(*return_value___errno_location$90);
                log_log(7, "error writing to client: %s", return_value_strerror$91);
              }

              else
              {
                return_value___errno_location$92=__errno_location();
                return_value_strerror$93=strerror(*return_value___errno_location$92);
                log_log(4, "error writing to client: %s", return_value_strerror$93);
              }
              return -1;
            }

            {
              unsigned long int return_value_strlen$103;
              return_value_strlen$103=strlen("invalid shell");
              unsigned int return_value_htonl$104;
              return_value_htonl$104=htonl((unsigned int)(signed int)return_value_strlen$103);
              tmpint32 = (signed int)return_value_htonl$104;
              signed int return_value_tio_write$110;
              return_value_tio_write$110=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$110 == 0))
              {
                signed int *return_value___errno_location$109;
                return_value___errno_location$109=__errno_location();
                if(*return_value___errno_location$109 == 32)
                {
                  return_value___errno_location$105=__errno_location();
                  return_value_strerror$106=strerror(*return_value___errno_location$105);
                  log_log(7, "error writing to client: %s", return_value_strerror$106);
                }

                else
                {
                  return_value___errno_location$107=__errno_location();
                  return_value_strerror$108=strerror(*return_value___errno_location$107);
                  log_log(4, "error writing to client: %s", return_value_strerror$108);
                }
                return -1;
              }

              unsigned int return_value_ntohl$111;
              return_value_ntohl$111=ntohl((unsigned int)tmpint32);
              tmpint32 = (signed int)return_value_ntohl$111;
              if(tmpint32 >= 1)
              {
                signed int return_value_tio_write$117;
                return_value_tio_write$117=tio_write(fp, (const void *)"invalid shell", (unsigned long int)tmpint32);
                if(!(return_value_tio_write$117 == 0))
                {
                  signed int *return_value___errno_location$116;
                  return_value___errno_location$116=__errno_location();
                  if(*return_value___errno_location$116 == 32)
                  {
                    return_value___errno_location$112=__errno_location();
                    return_value_strerror$113=strerror(*return_value___errno_location$112);
                    log_log(7, "error writing to client: %s", return_value_strerror$113);
                  }

                  else
                  {
                    return_value___errno_location$114=__errno_location();
                    return_value_strerror$115=strerror(*return_value___errno_location$114);
                    log_log(4, "error writing to client: %s", return_value_strerror$115);
                  }
                  return -1;
                }

              }

            }
            shell = (const char *)(void *)0;
          }

        }

        const char *return_value_myldap_get_dn$119;
        return_value_myldap_get_dn$119=myldap_get_dn(entry);
        newsession=get_session(binddn, return_value_myldap_get_dn$119, password, &rc);
        if(!(newsession == ((struct ldap_session *)NULL)))
        {
          const char *return_value_myldap_get_dn$120;
          return_value_myldap_get_dn$120=myldap_get_dn(entry);
          rc=change(newsession, return_value_myldap_get_dn$120, homedir, shell);
          myldap_session_close(newsession);
        }

        if(!(rc == 0x00))
        {
          const char *return_value_myldap_get_dn$121;
          return_value_myldap_get_dn$121=myldap_get_dn(entry);
          char *return_value_ldap_err2string$122;
          return_value_ldap_err2string$122=ldap_err2string(rc);
          log_log(4, "%s: modification failed: %s", return_value_myldap_get_dn$121, return_value_ldap_err2string$122);
          char *return_value_ldap_err2string$123;
          return_value_ldap_err2string$123=ldap_err2string(rc);
          mysnprintf(errmsg, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, "change failed: %s", return_value_ldap_err2string$123);
          unsigned int return_value_htonl$124;
          return_value_htonl$124=htonl((unsigned int)(signed int)1);
          tmpint32 = (signed int)return_value_htonl$124;
          signed int return_value_tio_write$130;
          return_value_tio_write$130=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$130 == 0))
          {
            signed int *return_value___errno_location$129;
            return_value___errno_location$129=__errno_location();
            if(*return_value___errno_location$129 == 32)
            {
              return_value___errno_location$125=__errno_location();
              return_value_strerror$126=strerror(*return_value___errno_location$125);
              log_log(7, "error writing to client: %s", return_value_strerror$126);
            }

            else
            {
              return_value___errno_location$127=__errno_location();
              return_value_strerror$128=strerror(*return_value___errno_location$127);
              log_log(4, "error writing to client: %s", return_value_strerror$128);
            }
            return -1;
          }

          {
            unsigned long int return_value_strlen$138;
            return_value_strlen$138=strlen(errmsg);
            unsigned int return_value_htonl$139;
            return_value_htonl$139=htonl((unsigned int)(signed int)return_value_strlen$138);
            tmpint32 = (signed int)return_value_htonl$139;
            signed int return_value_tio_write$145;
            return_value_tio_write$145=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$145 == 0))
            {
              signed int *return_value___errno_location$144;
              return_value___errno_location$144=__errno_location();
              if(*return_value___errno_location$144 == 32)
              {
                return_value___errno_location$140=__errno_location();
                return_value_strerror$141=strerror(*return_value___errno_location$140);
                log_log(7, "error writing to client: %s", return_value_strerror$141);
              }

              else
              {
                return_value___errno_location$142=__errno_location();
                return_value_strerror$143=strerror(*return_value___errno_location$142);
                log_log(4, "error writing to client: %s", return_value_strerror$143);
              }
              return -1;
            }

            unsigned int return_value_ntohl$146;
            return_value_ntohl$146=ntohl((unsigned int)tmpint32);
            tmpint32 = (signed int)return_value_ntohl$146;
            if(tmpint32 >= 1)
            {
              signed int return_value_tio_write$152;
              return_value_tio_write$152=tio_write(fp, (const void *)errmsg, (unsigned long int)tmpint32);
              if(!(return_value_tio_write$152 == 0))
              {
                signed int *return_value___errno_location$151;
                return_value___errno_location$151=__errno_location();
                if(*return_value___errno_location$151 == 32)
                {
                  return_value___errno_location$147=__errno_location();
                  return_value_strerror$148=strerror(*return_value___errno_location$147);
                  log_log(7, "error writing to client: %s", return_value_strerror$148);
                }

                else
                {
                  return_value___errno_location$149=__errno_location();
                  return_value_strerror$150=strerror(*return_value___errno_location$149);
                  log_log(4, "error writing to client: %s", return_value_strerror$150);
                }
                return -1;
              }

            }

          }
          unsigned int return_value_htonl$153;
          return_value_htonl$153=htonl((unsigned int)(signed int)0);
          tmpint32 = (signed int)return_value_htonl$153;
          signed int return_value_tio_write$159;
          return_value_tio_write$159=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$159 == 0))
          {
            signed int *return_value___errno_location$158;
            return_value___errno_location$158=__errno_location();
            if(*return_value___errno_location$158 == 32)
            {
              return_value___errno_location$154=__errno_location();
              return_value_strerror$155=strerror(*return_value___errno_location$154);
              log_log(7, "error writing to client: %s", return_value_strerror$155);
            }

            else
            {
              return_value___errno_location$156=__errno_location();
              return_value_strerror$157=strerror(*return_value___errno_location$156);
              log_log(4, "error writing to client: %s", return_value_strerror$157);
            }
            return -1;
          }

          unsigned int return_value_htonl$160;
          return_value_htonl$160=htonl((unsigned int)(signed int)2);
          tmpint32 = (signed int)return_value_htonl$160;
          signed int return_value_tio_write$166;
          return_value_tio_write$166=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$166 == 0))
          {
            signed int *return_value___errno_location$165;
            return_value___errno_location$165=__errno_location();
            if(*return_value___errno_location$165 == 32)
            {
              return_value___errno_location$161=__errno_location();
              return_value_strerror$162=strerror(*return_value___errno_location$161);
              log_log(7, "error writing to client: %s", return_value_strerror$162);
            }

            else
            {
              return_value___errno_location$163=__errno_location();
              return_value_strerror$164=strerror(*return_value___errno_location$163);
              log_log(4, "error writing to client: %s", return_value_strerror$164);
            }
            return -1;
          }

          return 0;
        }

        const char *return_value_myldap_get_dn$167;
        return_value_myldap_get_dn$167=myldap_get_dn(entry);
        log_log(5, "changed information for %s", return_value_myldap_get_dn$167);
        unsigned int return_value_htonl$168;
        return_value_htonl$168=htonl((unsigned int)(signed int)0);
        tmpint32 = (signed int)return_value_htonl$168;
        signed int return_value_tio_write$174;
        return_value_tio_write$174=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$174 == 0))
        {
          signed int *return_value___errno_location$173;
          return_value___errno_location$173=__errno_location();
          if(*return_value___errno_location$173 == 32)
          {
            return_value___errno_location$169=__errno_location();
            return_value_strerror$170=strerror(*return_value___errno_location$169);
            log_log(7, "error writing to client: %s", return_value_strerror$170);
          }

          else
          {
            return_value___errno_location$171=__errno_location();
            return_value_strerror$172=strerror(*return_value___errno_location$171);
            log_log(4, "error writing to client: %s", return_value_strerror$172);
          }
          return -1;
        }

        unsigned int return_value_htonl$175;
        return_value_htonl$175=htonl((unsigned int)(signed int)2);
        tmpint32 = (signed int)return_value_htonl$175;
        signed int return_value_tio_write$181;
        return_value_tio_write$181=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$181 == 0))
        {
          signed int *return_value___errno_location$180;
          return_value___errno_location$180=__errno_location();
          if(*return_value___errno_location$180 == 32)
          {
            return_value___errno_location$176=__errno_location();
            return_value_strerror$177=strerror(*return_value___errno_location$176);
            log_log(7, "error writing to client: %s", return_value_strerror$177);
          }

          else
          {
            return_value___errno_location$178=__errno_location();
            return_value_strerror$179=strerror(*return_value___errno_location$178);
            log_log(4, "error writing to client: %s", return_value_strerror$179);
          }
          return -1;
        }

        return 0;
      }
    }
  }
}

// nsswitch_check_reload
// file nsswitch.c line 48
void nsswitch_check_reload(void)
{
  struct stat buf;
  signed long int t;
  if(!(cached_shadow_uses_ldap == 22))
  {
    t=time((signed long int *)(void *)0);
    if(!(60l + cached_shadow_lastcheck >= t))
    {
      cached_shadow_lastcheck = t;
      signed int return_value_stat$3;
      return_value_stat$3=stat("/etc/nsswitch.conf", &buf);
      if(!(return_value_stat$3 == 0))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        char *return_value_strerror$2;
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        log_log(3, "stat(%s) failed: %s", (const void *)"/etc/nsswitch.conf", return_value_strerror$2);
        cached_shadow_uses_ldap = 22;
        goto __CPROVER_DUMP_L4;
      }

      if(!(buf.st_mtim.tv_sec == nsswitch_mtime))
      {
        nsswitch_mtime = buf.st_mtim.tv_sec;
        cached_shadow_uses_ldap = 22;
      }

    }

  }


__CPROVER_DUMP_L4:
  ;
}

// nsswitch_shadow_uses_ldap
// file nsswitch.c line 172
signed int nsswitch_shadow_uses_ldap(void)
{
  if(cached_shadow_uses_ldap == 22)
  {
    log_log(6, "(re)loading %s", (const void *)"/etc/nsswitch.conf");
    cached_shadow_uses_ldap=shadow_uses_ldap();
    cached_shadow_lastcheck=time((signed long int *)(void *)0);
  }

  return cached_shadow_uses_ldap;
}

// parse_boolean
// file cfg.c line 183
static signed int parse_boolean(const char *filename, signed int lnr, const char *value)
{
  signed int return_value_strcasecmp$8;
  return_value_strcasecmp$8=strcasecmp(value, "on");
  _Bool tmp_if_expr$10;
  signed int return_value_strcasecmp$9;
  if(return_value_strcasecmp$8 == 0)
    tmp_if_expr$10 = (_Bool)1;

  else
  {
    return_value_strcasecmp$9=strcasecmp(value, "yes");
    tmp_if_expr$10 = return_value_strcasecmp$9 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$12;
  signed int return_value_strcasecmp$11;
  if(tmp_if_expr$10)
    tmp_if_expr$12 = (_Bool)1;

  else
  {
    return_value_strcasecmp$11=strcasecmp(value, "true");
    tmp_if_expr$12 = return_value_strcasecmp$11 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$14;
  signed int return_value_strcasecmp$13;
  if(tmp_if_expr$12)
    tmp_if_expr$14 = (_Bool)1;

  else
  {
    return_value_strcasecmp$13=strcasecmp(value, "1");
    tmp_if_expr$14 = return_value_strcasecmp$13 == 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcasecmp$1;
  _Bool tmp_if_expr$3;
  signed int return_value_strcasecmp$2;
  _Bool tmp_if_expr$5;
  signed int return_value_strcasecmp$4;
  _Bool tmp_if_expr$7;
  signed int return_value_strcasecmp$6;
  if(tmp_if_expr$14)
    return 1;

  else
  {
    return_value_strcasecmp$1=strcasecmp(value, "off");
    if(return_value_strcasecmp$1 == 0)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_strcasecmp$2=strcasecmp(value, "no");
      tmp_if_expr$3 = return_value_strcasecmp$2 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_strcasecmp$4=strcasecmp(value, "false");
      tmp_if_expr$5 = return_value_strcasecmp$4 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value_strcasecmp$6=strcasecmp(value, "0");
      tmp_if_expr$7 = return_value_strcasecmp$6 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
      return 0;

    else
    {
      log_log(3, "%s:%d: not a boolean argument: '%s'", filename, lnr, value);
      exit(1);
    }
  }
}

// parse_cmdline
// file nslcd.c line 154
static void parse_cmdline(signed int argc, char **argv)
{
  signed int optc;
  do
  {
    optc=getopt_long(argc, argv, "cndhV", nslcd_options, (signed int *)(void *)0);
    if(optc == -1)
      break;

    switch(optc)
    {
      case 99:
      {
        nslcd_checkonly = 1;
        break;
      }
      case 100:
      {
        nslcd_debugging = nslcd_debugging + 1;
        log_setdefaultloglevel(7);
        break;
      }
      case 110:
      {
        nslcd_nofork = nslcd_nofork + 1;
        break;
      }
      case 104:
      {
        display_usage(stdout, argv[(signed long int)0]);
        exit(0);
      }
      case 86:
      {
        display_version(stdout);
        exit(0);
      }
      case 58:

      case 63:

      default:
      {
        fprintf(stderr, "Try '%s --help' for more information.\n", argv[(signed long int)0]);
        exit(1);
      }
    }
  }
  while((_Bool)1);
  if(!(optind >= argc))
  {
    fprintf(stderr, "%s: unrecognized option '%s'\n", argv[(signed long int)0], argv[(signed long int)optind]);
    fprintf(stderr, "Try '%s --help' for more information.\n", argv[(signed long int)0]);
    exit(1);
  }

}

// parse_dollar_expression
// file expr.c line 84
static const char * parse_dollar_expression(const char *str, signed int *ptr, char *buffer, unsigned long int buflen, const char * (*expander)(const char *, void *), void *expander_arg)
{
  char varname[30l];
  const char *varvalue;
  signed int return_value_strncmp$14;
  _Bool tmp_if_expr$6;
  signed int return_value_strncmp$13;
  _Bool tmp_if_expr$9;
  const char *tmp_post$10;
  const char *tmp_post$11;
  if(ptr == ((signed int *)NULL) || buffer == ((char *)NULL) || str == ((const char *)NULL) || !(buflen >= 1ul))
    return (const char *)(void *)0;

  else
  {
    if((signed int)str[(signed long int)*ptr] == 123)
    {
      *ptr = *ptr + 1;
      const char *return_value_parse_name$1;
      return_value_parse_name$1=parse_name(str, ptr, varname, sizeof(char [30l]) /*30ul*/ );
      if(return_value_parse_name$1 == ((const char *)NULL))
        return (const char *)(void *)0;

      varvalue=expander(varname, expander_arg);
      if(varvalue == ((const char *)NULL))
        varvalue = "";

      if((signed int)str[(signed long int)*ptr] == 125)
      {
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(varvalue);
        if(return_value_strlen$2 >= buflen)
          return (const char *)(void *)0;

        strcpy(buffer, varvalue);
      }

      else
      {
        return_value_strncmp$14=strncmp(str + (signed long int)*ptr, ":-", (unsigned long int)2);
        if(return_value_strncmp$14 == 0)
        {
          *ptr = *ptr + 2;
          if(!(varvalue == ((const char *)NULL)))
            tmp_if_expr$6 = (signed int)*varvalue != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$6 = (_Bool)0;
          if(tmp_if_expr$6)
          {
            const char *return_value_parse_expression$3;
            return_value_parse_expression$3=parse_expression(str, ptr, 125, buffer, buflen, empty_expander, (void *)0);
            if(return_value_parse_expression$3 == ((const char *)NULL))
              return (const char *)(void *)0;

            unsigned long int return_value_strlen$4;
            return_value_strlen$4=strlen(varvalue);
            if(return_value_strlen$4 >= buflen)
              return (const char *)(void *)0;

            strcpy(buffer, varvalue);
          }

          else
          {
            const char *return_value_parse_expression$5;
            return_value_parse_expression$5=parse_expression(str, ptr, 125, buffer, buflen, expander, expander_arg);
            if(return_value_parse_expression$5 == ((const char *)NULL))
              return (const char *)(void *)0;

          }
        }

        else
        {
          return_value_strncmp$13=strncmp(str + (signed long int)*ptr, ":+", (unsigned long int)2);
          if(return_value_strncmp$13 == 0)
          {
            *ptr = *ptr + 2;
            if(!(varvalue == ((const char *)NULL)))
              tmp_if_expr$9 = (signed int)*varvalue != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$9 = (_Bool)0;
            if(tmp_if_expr$9)
            {
              const char *return_value_parse_expression$7;
              return_value_parse_expression$7=parse_expression(str, ptr, 125, buffer, buflen, expander, expander_arg);
              if(return_value_parse_expression$7 == ((const char *)NULL))
                return (const char *)(void *)0;

            }

            else
            {
              const char *return_value_parse_expression$8;
              return_value_parse_expression$8=parse_expression(str, ptr, 125, buffer, buflen, empty_expander, (void *)0);
              if(return_value_parse_expression$8 == ((const char *)NULL))
                return (const char *)(void *)0;

              buffer[(signed long int)0] = (char)0;
            }
          }

          else
            if((signed int)str[(signed long int)*ptr] == 35)
            {
              char c;
              const char *cp;
              const char *vp;
              signed int ismatch;
              unsigned long int vallen;
              *ptr = *ptr + 1;
              cp = str + (signed long int)*ptr;
              vp = varvalue;
              ismatch = 1;
              tmp_post$10 = cp;
              cp = cp + 1l;
              c = *tmp_post$10;
              if(!((signed int)c == 0))
              {
                if(!((signed int)c == 125))
                {
                  if(!(ismatch == 0))
                  {
                    if((signed int)*vp == 0)
                      ismatch = 0;

                  }

                  if((signed int)c == 63)
                    vp = vp + 1l;

                  else
                  {
                    if((signed int)c == 92)
                    {
                      tmp_post$11 = cp;
                      cp = cp + 1l;
                      c = *tmp_post$11;
                      if((signed int)c == 0)
                        return (const char *)(void *)0;

                    }

                    if(!(ismatch == 0))
                    {
                      if(!(*vp == c))
                        ismatch = 0;

                    }

                    vp = vp + 1l;
                  }
                }

              }

              if((signed int)c == 0)
                return (const char *)(void *)0;

              *ptr = (signed int)((cp - str) - (signed long int)1);
              if(ismatch == 0)
                vp = varvalue;

              unsigned long int return_value_strlen$12;
              return_value_strlen$12=strlen(vp);
              vallen = return_value_strlen$12 + (unsigned long int)1;
              if(!(buflen >= vallen))
                return (const char *)(void *)0;

              memcpy((void *)buffer, (const void *)vp, vallen);
            }

            else
              return (const char *)(void *)0;
        }
      }
      *ptr = *ptr + 1;
    }

    else
    {
      const char *return_value_parse_name$15;
      return_value_parse_name$15=parse_name(str, ptr, varname, sizeof(char [30l]) /*30ul*/ );
      if(return_value_parse_name$15 == ((const char *)NULL))
        return (const char *)(void *)0;

      varvalue=expander(varname, expander_arg);
      if(varvalue == ((const char *)NULL))
        varvalue = "";

      unsigned long int return_value_strlen$16;
      return_value_strlen$16=strlen(varvalue);
      if(return_value_strlen$16 >= buflen)
        return (const char *)(void *)0;

      strcpy(buffer, varvalue);
    }
    return buffer;
  }
}

// parse_expression
// file expr.c line 208
static const char * parse_expression(const char *str, signed int *ptr, signed int endat, char *buffer, unsigned long int buflen, const char * (*expander)(const char *, void *), void *expander_arg)
{
  signed int j = 0;
  const char *return_value_parse_dollar_expression$1;
  unsigned long int return_value_strlen$2;
  signed int tmp_post$3;
  while(!((signed int)str[(signed long int)*ptr] == endat))
  {
    if((signed int)str[(signed long int)*ptr] == 0)
      break;

    switch((signed int)str[(signed long int)*ptr])
    {
      case 36:
      {
        *ptr = *ptr + 1;
        if((unsigned long int)j >= buflen)
          return (const char *)(void *)0;

        return_value_parse_dollar_expression$1=parse_dollar_expression(str, ptr, buffer + (signed long int)j, buflen - (unsigned long int)j, expander, expander_arg);
        if(return_value_parse_dollar_expression$1 == ((const char *)NULL))
          return (const char *)(void *)0;

        return_value_strlen$2=strlen(buffer);
        j = (signed int)return_value_strlen$2;
        break;
      }
      case 92:
        *ptr = *ptr + 1;
      default:
      {
        if((unsigned long int)j >= buflen)
          return (const char *)(void *)0;

        tmp_post$3 = j;
        j = j + 1;
        buffer[(signed long int)tmp_post$3] = str[(signed long int)*ptr];
        *ptr = *ptr + 1;
      }
    }
  }
  signed int tmp_post$4;
  if((unsigned long int)j >= buflen)
    return (const char *)(void *)0;

  else
  {
    tmp_post$4 = j;
    j = j + 1;
    buffer[(signed long int)tmp_post$4] = (char)0;
    return buffer;
  }
}

// parse_loglevel
// file cfg.c line 342
static signed int parse_loglevel(const char *filename, signed int lnr, const char *value)
{
  signed int return_value_strcasecmp$8;
  return_value_strcasecmp$8=strcasecmp(value, "crit");
  signed int return_value_strcasecmp$5;
  _Bool tmp_if_expr$7;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$4;
  signed int return_value_strcasecmp$3;
  signed int return_value_strcasecmp$2;
  signed int return_value_strcasecmp$1;
  if(return_value_strcasecmp$8 == 0)
    return 2;

  else
  {
    return_value_strcasecmp$5=strcasecmp(value, "error");
    if(return_value_strcasecmp$5 == 0)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value_strcasecmp$6=strcasecmp(value, "err");
      tmp_if_expr$7 = return_value_strcasecmp$6 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
      return 3;

    else
    {
      return_value_strcasecmp$4=strcasecmp(value, "warning");
      if(return_value_strcasecmp$4 == 0)
        return 4;

      else
      {
        return_value_strcasecmp$3=strcasecmp(value, "notice");
        if(return_value_strcasecmp$3 == 0)
          return 5;

        else
        {
          return_value_strcasecmp$2=strcasecmp(value, "info");
          if(return_value_strcasecmp$2 == 0)
            return 6;

          else
          {
            return_value_strcasecmp$1=strcasecmp(value, "debug");
            if(return_value_strcasecmp$1 == 0)
              return 7;

            else
            {
              log_log(3, "%s:%d: not a log level '%s'", filename, lnr, value);
              exit(1);
            }
          }
        }
      }
    }
  }
}

// parse_map
// file cfg.c line 536
static enum ldap_map_selector parse_map(const char *value)
{
  signed int return_value_strcasecmp$22;
  return_value_strcasecmp$22=strcasecmp(value, "alias");
  _Bool tmp_if_expr$24;
  signed int return_value_strcasecmp$23;
  if(return_value_strcasecmp$22 == 0)
    tmp_if_expr$24 = (_Bool)1;

  else
  {
    return_value_strcasecmp$23=strcasecmp(value, "aliases");
    tmp_if_expr$24 = return_value_strcasecmp$23 == 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcasecmp$19;
  _Bool tmp_if_expr$21;
  signed int return_value_strcasecmp$20;
  signed int return_value_strcasecmp$18;
  signed int return_value_strcasecmp$15;
  _Bool tmp_if_expr$17;
  signed int return_value_strcasecmp$16;
  signed int return_value_strcasecmp$14;
  signed int return_value_strcasecmp$11;
  _Bool tmp_if_expr$13;
  signed int return_value_strcasecmp$12;
  signed int return_value_strcasecmp$10;
  signed int return_value_strcasecmp$7;
  _Bool tmp_if_expr$9;
  signed int return_value_strcasecmp$8;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$3;
  _Bool tmp_if_expr$5;
  signed int return_value_strcasecmp$4;
  signed int return_value_strcasecmp$2;
  signed int return_value_strcasecmp$1;
  if(tmp_if_expr$24)
    return (enum ldap_map_selector)LM_ALIASES;

  else
  {
    return_value_strcasecmp$19=strcasecmp(value, "ether");
    if(return_value_strcasecmp$19 == 0)
      tmp_if_expr$21 = (_Bool)1;

    else
    {
      return_value_strcasecmp$20=strcasecmp(value, "ethers");
      tmp_if_expr$21 = return_value_strcasecmp$20 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$21)
      return (enum ldap_map_selector)LM_ETHERS;

    else
    {
      return_value_strcasecmp$18=strcasecmp(value, "group");
      if(return_value_strcasecmp$18 == 0)
        return (enum ldap_map_selector)LM_GROUP;

      else
      {
        return_value_strcasecmp$15=strcasecmp(value, "host");
        if(return_value_strcasecmp$15 == 0)
          tmp_if_expr$17 = (_Bool)1;

        else
        {
          return_value_strcasecmp$16=strcasecmp(value, "hosts");
          tmp_if_expr$17 = return_value_strcasecmp$16 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$17)
          return (enum ldap_map_selector)LM_HOSTS;

        else
        {
          return_value_strcasecmp$14=strcasecmp(value, "netgroup");
          if(return_value_strcasecmp$14 == 0)
            return (enum ldap_map_selector)LM_NETGROUP;

          else
          {
            return_value_strcasecmp$11=strcasecmp(value, "network");
            if(return_value_strcasecmp$11 == 0)
              tmp_if_expr$13 = (_Bool)1;

            else
            {
              return_value_strcasecmp$12=strcasecmp(value, "networks");
              tmp_if_expr$13 = return_value_strcasecmp$12 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$13)
              return (enum ldap_map_selector)LM_NETWORKS;

            else
            {
              return_value_strcasecmp$10=strcasecmp(value, "passwd");
              if(return_value_strcasecmp$10 == 0)
                return (enum ldap_map_selector)LM_PASSWD;

              else
              {
                return_value_strcasecmp$7=strcasecmp(value, "protocol");
                if(return_value_strcasecmp$7 == 0)
                  tmp_if_expr$9 = (_Bool)1;

                else
                {
                  return_value_strcasecmp$8=strcasecmp(value, "protocols");
                  tmp_if_expr$9 = return_value_strcasecmp$8 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$9)
                  return (enum ldap_map_selector)LM_PROTOCOLS;

                else
                {
                  return_value_strcasecmp$6=strcasecmp(value, "rpc");
                  if(return_value_strcasecmp$6 == 0)
                    return (enum ldap_map_selector)LM_RPC;

                  else
                  {
                    return_value_strcasecmp$3=strcasecmp(value, "service");
                    if(return_value_strcasecmp$3 == 0)
                      tmp_if_expr$5 = (_Bool)1;

                    else
                    {
                      return_value_strcasecmp$4=strcasecmp(value, "services");
                      tmp_if_expr$5 = return_value_strcasecmp$4 == 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr$5)
                      return (enum ldap_map_selector)LM_SERVICES;

                    else
                    {
                      return_value_strcasecmp$2=strcasecmp(value, "shadow");
                      if(return_value_strcasecmp$2 == 0)
                        return (enum ldap_map_selector)LM_SHADOW;

                      else
                      {
                        return_value_strcasecmp$1=strcasecmp(value, "nfsidmap");
                        if(return_value_strcasecmp$1 == 0)
                          return (enum ldap_map_selector)LM_NFSIDMAP;

                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (enum ldap_map_selector)LM_NONE;
}

// parse_name
// file expr.c line 47
static const char * parse_name(const char *str, signed int *ptr, char *buffer, unsigned long int buflen)
{
  signed int i = 0;
  buffer[(signed long int)i] = (char)0;
  signed int return_value_my_isalpha$1;
  return_value_my_isalpha$1=my_isalpha(str[(signed long int)*ptr]);
  signed int return_value_my_isalphanum$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  if(return_value_my_isalpha$1 == 0)
    return (const char *)(void *)0;

  else
  {
    do
    {
      return_value_my_isalphanum$2=my_isalphanum(str[(signed long int)*ptr]);
      if(return_value_my_isalphanum$2 == 0)
      {
        if(!((signed int)str[(signed long int)*ptr] == 59))
          break;

      }

      if((unsigned long int)i >= buflen)
        return (const char *)(void *)0;

      tmp_post$3 = i;
      i = i + 1;
      tmp_post$4 = *ptr;
      *ptr = *ptr + 1;
      buffer[(signed long int)tmp_post$3] = str[(signed long int)tmp_post$4];
    }
    while((_Bool)1);
    if((unsigned long int)i >= buflen)
      return (const char *)(void *)0;

    else
    {
      tmp_post$5 = i;
      i = i + 1;
      buffer[(signed long int)tmp_post$5] = (char)0;
      return buffer;
    }
  }
}

// parse_time
// file cfg.c line 220
static signed long int parse_time(const char *filename, signed int lnr, const char *value)
{
  signed long int t;
  char *tmp = (char *)(void *)0;
  signed int return_value_strcasecmp$1;
  return_value_strcasecmp$1=strcasecmp(value, "off");
  _Bool tmp_if_expr$9;
  signed int return_value_strcasecmp$8;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$5;
  signed int return_value_strcasecmp$4;
  if(return_value_strcasecmp$1 == 0)
    return (signed long int)0;

  else
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 0;
    t=strtol(value, &tmp, 10);
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    if(!(*return_value___errno_location$3 == 0))
    {
      log_log(3, "%s:%d: value out of range: '%s'", filename, lnr, value);
      exit(1);
    }

    signed int return_value_strcasecmp$7;
    return_value_strcasecmp$7=strcasecmp(tmp, "");
    if(return_value_strcasecmp$7 == 0)
      tmp_if_expr$9 = (_Bool)1;

    else
    {
      return_value_strcasecmp$8=strcasecmp(tmp, "s");
      tmp_if_expr$9 = return_value_strcasecmp$8 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$9)
      return t;

    else
    {
      return_value_strcasecmp$6=strcasecmp(tmp, "m");
      if(return_value_strcasecmp$6 == 0)
        return t * (signed long int)60;

      else
      {
        return_value_strcasecmp$5=strcasecmp(tmp, "h");
        if(return_value_strcasecmp$5 == 0)
          return t * (signed long int)(60 * 60);

        else
        {
          return_value_strcasecmp$4=strcasecmp(tmp, "d");
          if(return_value_strcasecmp$4 == 0)
            return t * (signed long int)(60 * 60 * 24);

          else
          {
            log_log(3, "%s:%d: invalid time value: '%s'", filename, lnr, value);
            exit(1);
          }
        }
      }
    }
  }
}

// passwd_init
// file common.h line 212
void passwd_init(void)
{
  signed int i;
  struct set *set;
  if(passwd_bases[0l] == ((const char *)NULL))
  {
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      passwd_bases[(signed long int)i] = nslcd_cfg->bases[(signed long int)i];
  }

  if(passwd_scope == -1)
    passwd_scope = nslcd_cfg->scope;

  signed int return_value_strncasecmp$1;
  return_value_strncasecmp$1=strncasecmp(attmap_passwd_uidNumber, "objectSid:", (unsigned long int)10);
  if(return_value_strncasecmp$1 == 0)
  {
    uidSid=sid2search(attmap_passwd_uidNumber + (signed long int)10);
    attmap_passwd_uidNumber=strndup(attmap_passwd_uidNumber, (unsigned long int)9);
  }

  signed int return_value_strncasecmp$2;
  return_value_strncasecmp$2=strncasecmp(attmap_passwd_gidNumber, "objectSid:", (unsigned long int)10);
  if(return_value_strncasecmp$2 == 0)
  {
    gidSid$link1=sid2search(attmap_passwd_gidNumber + (signed long int)10);
    attmap_passwd_gidNumber=strndup(attmap_passwd_gidNumber, (unsigned long int)9);
  }

  set=set_new();
  attmap_add_attributes(set, "objectClass");
  attmap_add_attributes(set, attmap_passwd_uid);
  attmap_add_attributes(set, attmap_passwd_userPassword);
  attmap_add_attributes(set, attmap_passwd_uidNumber);
  attmap_add_attributes(set, attmap_passwd_gidNumber);
  attmap_add_attributes(set, attmap_passwd_gecos);
  attmap_add_attributes(set, attmap_passwd_homeDirectory);
  attmap_add_attributes(set, attmap_passwd_loginShell);
  passwd_attrs=set_tolist(set);
  if(passwd_attrs == ((const char **)NULL))
  {
    log_log(2, "malloc() failed to allocate memory");
    exit(1);
  }

  set_free(set);
}

// print_boolean
// file cfg.c line 210
static const char * print_boolean(signed int bool)
{
  if(!(bool == 0))
    return "yes";

  else
    return "no";
}

// print_deref
// file cfg.c line 718
static const char * print_deref(signed int deref)
{
  switch(deref)
  {
    case 0x00:
      return "never";
    case 0x01:
      return "searching";
    case 0x02:
      return "finding";
    case 0x03:
      return "always";
    default:
      return "???";
  }
}

// print_map
// file cfg.c line 584
static const char * print_map(enum ldap_map_selector map)
{
  switch((signed int)map)
  {
    case LM_ALIASES:
      return "aliases";
    case LM_ETHERS:
      return "ethers";
    case LM_GROUP:
      return "group";
    case LM_HOSTS:
      return "hosts";
    case LM_NETGROUP:
      return "netgroup";
    case LM_NETWORKS:
      return "networks";
    case LM_PASSWD:
      return "passwd";
    case LM_PROTOCOLS:
      return "protocols";
    case LM_RPC:
      return "rpc";
    case LM_SERVICES:
      return "services";
    case LM_SHADOW:
      return "shadow";
    case LM_NFSIDMAP:
      return "nfsidmap";
    case LM_NONE:

    default:
      return "???";
  }
}

// print_scope
// file cfg.c line 681
static const char * print_scope(signed int scope)
{
  switch(scope)
  {
    case (signed int)0x0002:
      return "sub";
    case (signed int)0x0001:
      return "one";
    case (signed int)0x0000:
      return "base";
    case (signed int)0x0003:
      return "children";
    default:
      return "???";
  }
}

// print_ssl
// file cfg.c line 787
static const char * print_ssl(signed int ssl)
{
  switch(ssl)
  {
    case SSL_OFF:
      return "off";
    case SSL_START_TLS:
      return "start_tls";
    case SSL_LDAPS:
      return "on";
    default:
      return "???";
  }
}

// print_time
// file cfg.c line 259
static void print_time(signed long int t, char *buffer, unsigned long int buflen)
{
  if(t == 0l)
    mysnprintf(buffer, buflen, "off");

  else
    if(t % 86400l == 0l)
      mysnprintf(buffer, buflen, "%ldd", (signed long int)(t / (signed long int)(60 * 60 * 24)));

    else
      if(t % 3600l == 0l)
        mysnprintf(buffer, buflen, "%ldh", (signed long int)(t / (signed long int)(60 * 60)));

      else
        if(t % 60l == 0l)
          mysnprintf(buffer, buflen, "%ldm", (signed long int)(t / (signed long int)60));

        else
          mysnprintf(buffer, buflen, "%lds", (signed long int)t);
}

// print_tls_reqcert
// file cfg.c line 829
static const char * print_tls_reqcert(signed int value)
{
  switch(value)
  {
    case 0:
      return "never";
    case 3:
      return "allow";
    case 4:
      return "try";
    case 2:
      return "demand";
    case 1:
      return "hard";
    default:
      return "???";
  }
}

// protocol_init
// file common.h line 213
void protocol_init(void)
{
  signed int i;
  if(protocol_bases[0l] == ((const char *)NULL))
  {
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      protocol_bases[(signed long int)i] = nslcd_cfg->bases[(signed long int)i];
  }

  if(protocol_scope == -1)
    protocol_scope = nslcd_cfg->scope;

  protocol_attrs[(signed long int)0] = attmap_protocol_cn;
  protocol_attrs[(signed long int)1] = attmap_protocol_ipProtocolNumber;
  protocol_attrs[(signed long int)2] = (const char *)(void *)0;
}

// read_address
// file common.c line 252
signed int read_address(struct tio_fileinfo *fp, char *addr, signed int *addrlen, signed int *af)
{
  signed int tmpint32;
  signed int len;
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  *af = (signed int)return_value_ntohl$4;
  if(!(*af == 2))
  {
    if(*af == 10)
      goto __CPROVER_DUMP_L2;

    log_log(4, "incorrect address family specified: %d", *af);
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    signed int return_value_tio_read$7;
    return_value_tio_read$7=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_read$7 == 0))
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      log_log(4, "error reading from client: %s", return_value_strerror$6);
      return -1;
    }

    unsigned int return_value_ntohl$8;
    return_value_ntohl$8=ntohl((unsigned int)tmpint32);
    len = (signed int)return_value_ntohl$8;
    if(!(*addrlen >= len) || !(len >= 1))
    {
      log_log(4, "address length incorrect: %d", len);
      return -1;
    }

    else
    {
      *addrlen = len;
      signed int return_value_tio_read$11;
      return_value_tio_read$11=tio_read(fp, (void *)addr, (unsigned long int)len);
      if(!(return_value_tio_read$11 == 0))
      {
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        char *return_value_strerror$10;
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        log_log(4, "error reading from client: %s", return_value_strerror$10);
        return -1;
      }

      return 0;
    }
  }
}

// read_header
// file nslcd.c line 334
static signed int read_header(struct tio_fileinfo *fp, signed int *action)
{
  signed int tmpint32;
  signed int protocol;
  signed int return_value_tio_read$3;
  return_value_tio_read$3=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_tio_read$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(4, "error reading from client: %s", return_value_strerror$2);
    return -1;
  }

  unsigned int return_value_ntohl$4;
  return_value_ntohl$4=ntohl((unsigned int)tmpint32);
  protocol = (signed int)return_value_ntohl$4;
  if(!(protocol == 0x00000002))
  {
    log_log(7, "invalid nslcd version id: 0x%08x", (unsigned int)protocol);
    return -1;
  }

  else
  {
    signed int return_value_tio_read$7;
    return_value_tio_read$7=tio_read(fp, (void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_read$7 == 0))
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      log_log(4, "error reading from client: %s", return_value_strerror$6);
      return -1;
    }

    unsigned int return_value_ntohl$8;
    return_value_ntohl$8=ntohl((unsigned int)tmpint32);
    *action = (signed int)return_value_ntohl$8;
    return 0;
  }
}

// read_response
// file daemonize.c line 70
static signed int read_response(signed int fd, char *buffer, unsigned long int bufsz)
{
  signed int rc;
  unsigned long int r = (unsigned long int)0;
  signed int *return_value___errno_location$4;
  _Bool tmp_if_expr$6;
  signed int *return_value___errno_location$5;
  while(!(r >= bufsz))
  {
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)(buffer + (signed long int)r), bufsz - r);
    rc = (signed int)return_value_read$1;
    if(rc == 0)
      break;

    else
      if(rc >= 1)
        r = r + (unsigned long int)rc;

      else
      {
        return_value___errno_location$4=__errno_location();
        if(*return_value___errno_location$4 == 4)
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          return_value___errno_location$5=__errno_location();
          tmp_if_expr$6 = *return_value___errno_location$5 == 11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$6)
          continue;

        else
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          char *return_value_strerror$3;
          return_value_strerror$3=strerror(*return_value___errno_location$2);
          log_log(3, "read_response(): read() failed: %s", return_value_strerror$3);
          return -1;
        }
      }
  }
  return (signed int)r;
}

// rpc_init
// file common.h line 214
void rpc_init(void)
{
  signed int i;
  if(rpc_bases[0l] == ((const char *)NULL))
  {
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      rpc_bases[(signed long int)i] = nslcd_cfg->bases[(signed long int)i];
  }

  if(rpc_scope == -1)
    rpc_scope = nslcd_cfg->scope;

  rpc_attrs[(signed long int)0] = attmap_rpc_cn;
  rpc_attrs[(signed long int)1] = attmap_rpc_oncRpcNumber;
  rpc_attrs[(signed long int)2] = (const char *)(void *)0;
}

// scope_get_var
// file attmap.h line 75
signed int * scope_get_var(enum ldap_map_selector map)
{
  switch((signed int)map)
  {
    case LM_ALIASES:
      return &alias_scope;
    case LM_ETHERS:
      return &ether_scope;
    case LM_GROUP:
      return &group_scope;
    case LM_HOSTS:
      return &host_scope;
    case LM_NETGROUP:
      return &netgroup_scope;
    case LM_NETWORKS:
      return &network_scope;
    case LM_PASSWD:
      return &passwd_scope;
    case LM_PROTOCOLS:
      return &protocol_scope;
    case LM_RPC:
      return &rpc_scope;
    case LM_SERVICES:
      return &service_scope;
    case LM_SHADOW:
      return &shadow_scope;
    case LM_NFSIDMAP:

    case LM_NONE:

    default:
      return (signed int *)(void *)0;
  }
}

// service_init
// file common.h line 215
void service_init(void)
{
  signed int i;
  if(service_bases[0l] == ((const char *)NULL))
  {
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      service_bases[(signed long int)i] = nslcd_cfg->bases[(signed long int)i];
  }

  if(service_scope == -1)
    service_scope = nslcd_cfg->scope;

  service_attrs[(signed long int)0] = attmap_service_cn;
  service_attrs[(signed long int)1] = attmap_service_ipServicePort;
  service_attrs[(signed long int)2] = attmap_service_ipServiceProtocol;
  service_attrs[(signed long int)3] = (const char *)(void *)0;
}

// set_add
// file ../common/set.h line 43
signed int set_add(struct set *set, const char *value)
{
  signed int return_value_dict_put$1;
  return_value_dict_put$1=dict_put((struct dictionary *)set, value, (void *)set);
  return return_value_dict_put$1;
}

// set_contains
// file ../common/set.h line 47
signed int set_contains(struct set *set, const char *value)
{
  void *return_value_dict_get$1;
  return_value_dict_get$1=dict_get((struct dictionary *)set, value);
  return (signed int)(return_value_dict_get$1 != (void *)0);
}

// set_free
// file ../common/set.h line 57
void set_free(struct set *set)
{
  dict_free((struct dictionary *)set);
}

// set_new
// file ../common/set.h line 36
struct set * set_new(void)
{
  struct dictionary *return_value_dict_new$1;
  return_value_dict_new$1=dict_new();
  return (struct set *)return_value_dict_new$1;
}

// set_pop
// file ../common/set.h line 53
char * set_pop(struct set *set)
{
  const char *key;
  char *value;
  key=dict_getany((struct dictionary *)set);
  if(key == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    value=strdup(key);
    dict_put((struct dictionary *)set, key, (void *)0);
    return value;
  }
}

// set_socket_timeout
// file myldap.c line 743
static signed int set_socket_timeout(struct ldap *ld, signed long int sec, signed long int usec)
{
  struct timeval tv;
  signed int rc = 0x00;
  signed int sd;
  log_log(7, "set_socket_timeout(%lu,%lu)", (unsigned long int)sec, (unsigned long int)usec);
  rc=ldap_get_option(ld, 0x0001, (void *)&sd);
  if(!(rc == 0x00))
  {
    myldap_err(3, ld, rc, "ldap_get_option(LDAP_OPT_DESC) failed");
    return rc;
  }

  else
    if(!(sd >= 1))
      return 0x00;

    else
    {
      memset((void *)&tv, 0, sizeof(struct timeval) /*16ul*/ );
      tv.tv_sec = sec;
      tv.tv_usec = usec;
      signed int return_value_setsockopt$3;
      return_value_setsockopt$3=setsockopt(sd, 1, 20, (void *)&tv, (unsigned int)sizeof(struct timeval) /*16ul*/ );
      if(!(return_value_setsockopt$3 == 0))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        char *return_value_strerror$2;
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        log_log(3, "setsockopt(%d,SO_RCVTIMEO) failed: %s", sd, return_value_strerror$2);
        rc = -2;
      }

      signed int return_value_setsockopt$6;
      return_value_setsockopt$6=setsockopt(sd, 1, 21, (void *)&tv, (unsigned int)sizeof(struct timeval) /*16ul*/ );
      if(!(return_value_setsockopt$6 == 0))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        char *return_value_strerror$5;
        return_value_strerror$5=strerror(*return_value___errno_location$4);
        log_log(3, "setsockopt(%d,SO_RCVTIMEO) failed: %s", sd, return_value_strerror$5);
        rc = -2;
      }

      return rc;
    }
}

// set_tolist
// file ../common/set.h line 61
const char ** set_tolist(struct set *set)
{
  const char **return_value_dict_keys$1;
  return_value_dict_keys$1=dict_keys((struct dictionary *)set);
  return return_value_dict_keys$1;
}

// shadow_init
// file common.h line 216
void shadow_init(void)
{
  signed int i;
  struct set *set;
  if(shadow_bases[0l] == ((const char *)NULL))
  {
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      shadow_bases[(signed long int)i] = nslcd_cfg->bases[(signed long int)i];
  }

  if(shadow_scope == -1)
    shadow_scope = nslcd_cfg->scope;

  set=set_new();
  attmap_add_attributes(set, attmap_shadow_uid);
  attmap_add_attributes(set, attmap_shadow_userPassword);
  attmap_add_attributes(set, attmap_shadow_shadowLastChange);
  attmap_add_attributes(set, attmap_shadow_shadowMax);
  attmap_add_attributes(set, attmap_shadow_shadowMin);
  attmap_add_attributes(set, attmap_shadow_shadowWarning);
  attmap_add_attributes(set, attmap_shadow_shadowInactive);
  attmap_add_attributes(set, attmap_shadow_shadowExpire);
  attmap_add_attributes(set, attmap_shadow_shadowFlag);
  shadow_attrs=set_tolist(set);
  if(shadow_attrs == ((const char **)NULL))
  {
    log_log(2, "malloc() failed to allocate memory");
    exit(1);
  }

  set_free(set);
}

// shadow_uid2entry
// file shadow.c line 271
struct myldap_entry * shadow_uid2entry(struct ldap_session *session, const char *username, signed int *rcp)
{
  struct myldap_search *search = (struct myldap_search *)(void *)0;
  struct myldap_entry *entry = (struct myldap_entry *)(void *)0;
  const char *base;
  char filter[4096l];
  signed int i;
  signed int return_value_isvalidname$1;
  return_value_isvalidname$1=isvalidname(username);
  _Bool tmp_if_expr$2;
  if(return_value_isvalidname$1 == 0)
  {
    if(!(rcp == ((signed int *)NULL)))
      *rcp = 0x15;

    return (struct myldap_entry *)(void *)0;
  }

  else
  {
    mkfilter_shadow_byname(username, filter, sizeof(char [4096l]) /*4096ul*/ );
    i = 0;
    do
    {
      if(!(i >= 31))
      {
        base = shadow_bases[(signed long int)i];
        tmp_if_expr$2 = base != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        break;

      search=myldap_search(session, base, shadow_scope, filter, shadow_attrs, rcp);
      if(search == ((struct myldap_search *)NULL))
      {
        if(!(rcp == ((signed int *)NULL)))
        {
          if(*rcp == 0x00)
            *rcp = 0x20;

        }

        return (struct myldap_entry *)(void *)0;
      }

      entry=myldap_get_entry(search, rcp);
      if(!(entry == ((struct myldap_entry *)NULL)))
        return entry;

      i = i + 1;
    }
    while((_Bool)1);
    if(!(rcp == ((signed int *)NULL)))
    {
      if(*rcp == 0x00)
        *rcp = 0x20;

    }

    return (struct myldap_entry *)(void *)0;
  }
}

// shadow_uses_ldap
// file nsswitch.c line 131
static signed int shadow_uses_ldap(void)
{
  struct _IO_FILE *fp;
  signed int lnr = 0;
  char linebuf[4096l];
  const char *services;
  signed int shadow_found = 0;
  signed int passwd_has_ldap = 0;
  fp=fopen("/etc/nsswitch.conf", "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_log(3, "cannot open %s: %s", (const void *)"/etc/nsswitch.conf", return_value_strerror$2);
    return 0;
  }

  char *return_value_fgets$3;
  do
  {
    return_value_fgets$3=fgets(linebuf, (signed int)sizeof(char [4096l]) /*4096ul*/ , fp);
    if(return_value_fgets$3 == ((char *)NULL))
      break;

    lnr = lnr + 1;
    services=find_db(linebuf, "shadow");
    if(!(services == ((const char *)NULL)))
    {
      shadow_found = 1;
      signed int return_value_has_service$4;
      return_value_has_service$4=has_service(services, "ldap", "/etc/nsswitch.conf", lnr);
      if(!(return_value_has_service$4 == 0))
      {
        fclose(fp);
        return 1;
      }

    }

    services=find_db(linebuf, "passwd");
    if(!(services == ((const char *)NULL)))
      passwd_has_ldap=has_service(services, "ldap", "/etc/nsswitch.conf", lnr);

  }
  while((_Bool)1);
  fclose(fp);
  if(!(shadow_found == 0))
    return 0;

  else
    return passwd_has_ldap;
}

// sid2search
// file common.c line 280
char * sid2search(const char *sid)
{
  const char *tmpsid = sid;
  char *res;
  char *tmp;
  signed int i = 0;
  unsigned long int l;
  signed int return_value_strncasecmp$1;
  return_value_strncasecmp$1=strncasecmp(sid, "S-", (unsigned long int)2);
  if(!(return_value_strncasecmp$1 == 0))
  {
    log_log(3, "error in SID %s", sid);
    exit(1);
  }

  while(!(tmpsid == ((const char *)NULL)))
  {
    i = i + 1;
    tmpsid=strchr(tmpsid + (signed long int)1, 45);
  }
  i = i - 2;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)(3 + 3 + 6 * 3 + i * 4 * 3 + 1));
  res = (char *)return_value_malloc$2;
  if(res == ((char *)NULL))
  {
    log_log(2, "malloc() failed to allocate memory");
    exit(1);
  }

  l=strtoul(sid + (signed long int)2, &tmp, 10);
  sprintf(res, "\\%02x\\%02x", (unsigned int)l & (unsigned int)0xff, (unsigned int)i);
  l=strtoul(tmp + (signed long int)1, &tmp, 10);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(res);
  sprintf(res + (signed long int)return_value_strlen$3, "\\00\\00\\%02x\\%02x\\%02x\\%02x", (unsigned int)(l >> 24 & (unsigned long int)0xff), (unsigned int)(l >> 16 & (unsigned long int)0xff), (unsigned int)(l >> 8 & (unsigned long int)0xff), (unsigned int)(l & (unsigned long int)0xff));
  while(!((signed int)*tmp == 0))
  {
    l=strtoul(tmp + (signed long int)1, &tmp, 10);
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(res);
    sprintf(res + (signed long int)return_value_strlen$4, "\\%02x\\%02x\\%02x\\%02x", (unsigned int)(l & (unsigned long int)0xff), (unsigned int)(l >> 8 & (unsigned long int)0xff), (unsigned int)(l >> 16 & (unsigned long int)0xff), (unsigned int)(l >> 24 & (unsigned long int)0xff));
  }
  return res;
}

// sig_handler
// file nslcd.c line 194
static void sig_handler(signed int signum)
{
  nslcd_receivedsignal = signum;
}

// signame
// file common.h line 68
const char * signame(signed int signum)
{
  switch(signum)
  {
    case 1:
      return "SIGHUP";
    case 2:
      return "SIGINT";
    case 3:
      return "SIGQUIT";
    case 4:
      return "SIGILL";
    case 6:
      return "SIGABRT";
    case 8:
      return "SIGFPE";
    case 9:
      return "SIGKILL";
    case 11:
      return "SIGSEGV";
    case 13:
      return "SIGPIPE";
    case 14:
      return "SIGALRM";
    case 15:
      return "SIGTERM";
    case 10:
      return "SIGUSR1";
    case 12:
      return "SIGUSR2";
    case 17:
      return "SIGCHLD";
    case 18:
      return "SIGCONT";
    case 19:
      return "SIGSTOP";
    case 20:
      return "SIGTSTP";
    case 21:
      return "SIGTTIN";
    case 22:
      return "SIGTTOU";
    case 7:
      return "SIGBUS";
    case 29:
      return "SIGPOLL";
    case 27:
      return "SIGPROF";
    case 31:
      return "SIGSYS";
    case 5:
      return "SIGTRAP";
    case 23:
      return "SIGURG";
    case 26:
      return "SIGVTALRM";
    case 24:
      return "SIGXCPU";
    case 25:
      return "SIGXFSZ";
    default:
      return "UNKNOWN";
  }
}

// stringhash
// file dict.c line 73
static unsigned int stringhash(const char *str)
{
  unsigned int hash = (unsigned int)5381;
  unsigned int c;
  const char *tmp_post$1;
  do
  {
    tmp_post$1 = str;
    str = str + 1l;
    c = (unsigned int)*tmp_post$1;
    if(c == 0u)
      break;

    hash = (unsigned int)33 * hash + c;
  }
  while((_Bool)1);
  return hash;
}

// strtoui
// file common.c line 344
unsigned int strtoui(const char *nptr, char **endptr, signed int base)
{
  unsigned long int val;
  val=strtoul(nptr, endptr, base);
  if(val >= 4294967296ul)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 34;
    return (unsigned int)0x7fffffff * 2U + 1U;
  }

  return (unsigned int)val;
}

// tio_close
// file ../common/tio.h line 71
signed int tio_close(struct tio_fileinfo *fp)
{
  signed int retv;
  retv=tio_flush(fp);
  signed int return_value_close$1;
  return_value_close$1=close(fp->fd);
  if(!(return_value_close$1 == 0))
    retv = -1;

  memset((void *)fp->readbuffer.buffer, 0, fp->readbuffer.size);
  memset((void *)fp->writebuffer.buffer, 0, fp->writebuffer.size);
  free((void *)fp->readbuffer.buffer);
  free((void *)fp->writebuffer.buffer);
  free((void *)fp);
  return retv;
}

// tio_fdopen
// file ../common/tio.h line 50
struct tio_fileinfo * tio_fdopen(signed int fd, signed int readtimeout, signed int writetimeout, unsigned long int initreadsize, unsigned long int maxreadsize, unsigned long int initwritesize, unsigned long int maxwritesize)
{
  struct tio_fileinfo *fp;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct tio_fileinfo) /*104ul*/ );
  fp = (struct tio_fileinfo *)return_value_malloc$1;
  if(fp == ((struct tio_fileinfo *)NULL))
    return (struct tio_fileinfo *)(void *)0;

  else
  {
    fp->fd = fd;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(initreadsize);
    fp->readbuffer.buffer = (unsigned char *)return_value_malloc$2;
    if(fp->readbuffer.buffer == ((unsigned char *)NULL))
    {
      free((void *)fp);
      return (struct tio_fileinfo *)(void *)0;
    }

    else
    {
      fp->readbuffer.size = initreadsize;
      fp->readbuffer.maxsize = maxreadsize;
      fp->readbuffer.start = (unsigned long int)0;
      fp->readbuffer.len = (unsigned long int)0;
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(initwritesize);
      fp->writebuffer.buffer = (unsigned char *)return_value_malloc$3;
      if(fp->writebuffer.buffer == ((unsigned char *)NULL))
      {
        free((void *)fp->readbuffer.buffer);
        free((void *)fp);
        return (struct tio_fileinfo *)(void *)0;
      }

      else
      {
        fp->writebuffer.size = initwritesize;
        fp->writebuffer.maxsize = maxwritesize;
        fp->writebuffer.start = (unsigned long int)0;
        fp->writebuffer.len = (unsigned long int)0;
        fp->readtimeout = readtimeout;
        fp->writetimeout = writetimeout;
        fp->read_resettable = 0;
        return fp;
      }
    }
  }
}

// tio_flush
// file tio.c line 382
signed int tio_flush(struct tio_fileinfo *fp)
{
  struct timespec deadline = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 };
  while(fp->writebuffer.len >= 1ul)
  {
    signed int return_value_tio_wait$1;
    return_value_tio_wait$1=tio_wait(fp->fd, (signed short int)0x004, fp->writetimeout, &deadline);
    if(!(return_value_tio_wait$1 == 0))
      return -1;

    signed int return_value_tio_writebuf$2;
    return_value_tio_writebuf$2=tio_writebuf(fp);
    if(!(return_value_tio_writebuf$2 == 0))
      return -1;

  }
  return 0;
}

// tio_flush_nonblock
// file tio.c line 400
static signed int tio_flush_nonblock(struct tio_fileinfo *fp)
{
  struct pollfd fds[1l];
  signed int rv;
  fds[(signed long int)0].fd = fp->fd;
  fds[(signed long int)0].events = (signed short int)0x004;
  rv=poll(fds, (unsigned long int)1, 0);
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  if(rv == 0)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(!(rv >= 0))
    {
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 4)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 11 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
    return 0;

  else
    if(!(rv >= 0))
      return -1;

    else
    {
      signed int return_value_tio_writebuf$6;
      return_value_tio_writebuf$6=tio_writebuf(fp);
      return return_value_tio_writebuf$6;
    }
}

// tio_mark
// file tio.c line 498
void tio_mark(struct tio_fileinfo *fp)
{
  if(fp->readbuffer.start >= 1ul)
  {
    if(fp->readbuffer.len >= 1ul)
    {
      memmove((void *)fp->readbuffer.buffer, (const void *)(fp->readbuffer.buffer + (signed long int)fp->readbuffer.start), fp->readbuffer.len);
      fp->readbuffer.start = (unsigned long int)0;
    }

  }

  fp->read_resettable = 1;
}

// tio_read
// file ../common/tio.h line 56
signed int tio_read(struct tio_fileinfo *fp, void *buf, unsigned long int count)
{
  struct timespec deadline = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 };
  signed int rv;
  unsigned char *tmp;
  unsigned long int newsz;
  unsigned long int len;
  unsigned char *ptr = (unsigned char *)buf;
  _Bool tmp_if_expr$6;
  signed int *return_value___errno_location$5;
  _Bool tmp_if_expr$8;
  signed int *return_value___errno_location$7;
  while((_Bool)1)
  {
    if(fp->readbuffer.len >= count)
    {
      if(count >= 1ul)
      {
        if(!(ptr == ((unsigned char *)NULL)))
          memcpy((void *)ptr, (const void *)(fp->readbuffer.buffer + (signed long int)fp->readbuffer.start), count);

        fp->readbuffer.start = fp->readbuffer.start + count;
        fp->readbuffer.len = fp->readbuffer.len - count;
      }

      return 0;
    }

    if(fp->readbuffer.len >= 1ul)
    {
      if(!(ptr == ((unsigned char *)NULL)))
      {
        memcpy((void *)ptr, (const void *)(fp->readbuffer.buffer + (signed long int)fp->readbuffer.start), fp->readbuffer.len);
        ptr = ptr + (signed long int)fp->readbuffer.len;
      }

      count = count - fp->readbuffer.len;
      fp->readbuffer.start = fp->readbuffer.start + fp->readbuffer.len;
      fp->readbuffer.len = (unsigned long int)0;
    }

    if(fp->read_resettable == 0)
      fp->readbuffer.start = (unsigned long int)0;

    else
      if(fp->readbuffer.start >= fp->readbuffer.size + 18446744073709551612ul)
      {
        if(!(fp->readbuffer.size >= fp->readbuffer.maxsize))
        {
          newsz = fp->readbuffer.size * (unsigned long int)2;
          if(!(fp->readbuffer.maxsize >= newsz))
            newsz = fp->readbuffer.maxsize;

          void *return_value_realloc$1;
          return_value_realloc$1=realloc((void *)fp->readbuffer.buffer, newsz);
          tmp = (unsigned char *)return_value_realloc$1;
          if(!(tmp == ((unsigned char *)NULL)))
          {
            fp->readbuffer.buffer = tmp;
            fp->readbuffer.size = newsz;
          }

        }

        if(fp->readbuffer.start >= fp->readbuffer.size + 18446744073709551612ul)
        {
          fp->readbuffer.start = (unsigned long int)0;
          fp->read_resettable = 0;
        }

      }

    signed int return_value_tio_wait$2;
    return_value_tio_wait$2=tio_wait(fp->fd, (signed short int)0x001, fp->readtimeout, &deadline);
    if(!(return_value_tio_wait$2 == 0))
      return -1;

    len = fp->readbuffer.size - fp->readbuffer.start;
    if(len >= 9223372036854775808ul)
      len = (unsigned long int)0x7fffffffffffffffL;

    signed long int return_value_read$3;
    return_value_read$3=read(fp->fd, (void *)(fp->readbuffer.buffer + (signed long int)fp->readbuffer.start), len);
    rv = (signed int)return_value_read$3;
    if(rv == 0)
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      *return_value___errno_location$4 = 104;
      return -1;
    }

    else
    {
      if(!(rv >= 0))
      {
        return_value___errno_location$5=__errno_location();
        tmp_if_expr$6 = *return_value___errno_location$5 != 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
      {
        return_value___errno_location$7=__errno_location();
        tmp_if_expr$8 = *return_value___errno_location$7 != 11 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$8 = (_Bool)0;
      if(tmp_if_expr$8)
        return -1;

      else
        if(rv >= 1)
          fp->readbuffer.len = (unsigned long int)rv;

    }
  }
}

// tio_reset
// file tio.c line 511
signed int tio_reset(struct tio_fileinfo *fp)
{
  if(fp->read_resettable == 0)
    return -1;

  else
  {
    fp->readbuffer.len = fp->readbuffer.len + fp->readbuffer.start;
    fp->readbuffer.start = (unsigned long int)0;
    return 0;
  }
}

// tio_skip
// file tio.c line 288
signed int tio_skip(struct tio_fileinfo *fp, unsigned long int count)
{
  signed int return_value_tio_read$1;
  return_value_tio_read$1=tio_read(fp, (void *)0, count);
  return return_value_tio_read$1;
}

// tio_skipall
// file tio.c line 294
signed int tio_skipall(struct tio_fileinfo *fp, signed int timeout)
{
  struct timespec deadline = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 };
  signed int rv;
  unsigned long int len;
  fp->readbuffer.start = (unsigned long int)0;
  fp->readbuffer.len = (unsigned long int)0;
  fp->read_resettable = 0;
  len = fp->readbuffer.size;
  if(len >= 9223372036854775808ul)
    len = (unsigned long int)0x7fffffffffffffffL;

  signed int *return_value___errno_location$3;
  signed int *return_value___errno_location$5;
  signed int *return_value___errno_location$4;
  while((_Bool)1)
  {
    signed int return_value_tio_wait$1;
    return_value_tio_wait$1=tio_wait(fp->fd, (signed short int)0x001, timeout, &deadline);
    if(!(return_value_tio_wait$1 == 0))
      return -1;

    signed long int return_value_read$2;
    return_value_read$2=read(fp->fd, (void *)fp->readbuffer.buffer, len);
    rv = (signed int)return_value_read$2;
    if(rv == 0)
      return 0;

    if(!(rv >= 0))
    {
      return_value___errno_location$3=__errno_location();
      if(*return_value___errno_location$3 == 11)
        return 0;

    }

    if(!(rv >= 0))
    {
      return_value___errno_location$5=__errno_location();
      if(!(*return_value___errno_location$5 == 4))
      {
        return_value___errno_location$4=__errno_location();
        if(!(*return_value___errno_location$4 == 11))
          return -1;

      }

    }

  }
}

// tio_time_remaining
// file tio.c line 90
static inline signed int tio_time_remaining(struct timespec *deadline, signed int timeout)
{
  struct timespec tv;
  if(deadline->tv_sec == 0l)
  {
    if(deadline->tv_nsec == 0l)
    {
      signed int return_value_clock_gettime$1;
      return_value_clock_gettime$1=clock_gettime(1, deadline);
      if(return_value_clock_gettime$1 == 0)
      {
        deadline->tv_sec = deadline->tv_sec + (signed long int)(timeout / 1000);
        deadline->tv_nsec = deadline->tv_nsec + (signed long int)((timeout % 1000) * 1000000);
      }

      return timeout;
    }

  }

  signed int return_value_clock_gettime$2;
  return_value_clock_gettime$2=clock_gettime(1, &tv);
  if(!(return_value_clock_gettime$2 == 0))
    return timeout;

  else
    return (signed int)((deadline->tv_sec - tv.tv_sec) * (signed long int)1000 + (deadline->tv_nsec - tv.tv_nsec) / (signed long int)1000000);
}

// tio_wait
// file tio.c line 157
static signed int tio_wait(signed int fd, signed short int events, signed int timeout, struct timespec *deadline)
{
  signed int t;
  struct pollfd fds[1l];
  signed int rv;
  signed int *return_value___errno_location$4;
  signed int *return_value___errno_location$3;
  while((_Bool)1)
  {
    fds[(signed long int)0].fd = fd;
    fds[(signed long int)0].events = events;
    t=tio_time_remaining(deadline, timeout);
    if(!(t >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 62;
      return -1;
    }

    if(!(timeout >= t))
      t = timeout;

    rv=poll(fds, (unsigned long int)1, t);
    if(rv >= 1)
      return 0;

    else
      if(rv == 0)
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        *return_value___errno_location$2 = 62;
        return -1;
      }

      else
      {
        return_value___errno_location$4=__errno_location();
        if(!(*return_value___errno_location$4 == 4))
        {
          return_value___errno_location$3=__errno_location();
          if(!(*return_value___errno_location$3 == 11))
            return -1;

        }

      }
  }
}

// tio_write
// file ../common/tio.h line 65
signed int tio_write(struct tio_fileinfo *fp, const void *buf, unsigned long int count)
{
  unsigned long int fr;
  unsigned char *tmp;
  unsigned long int newsz;
  const unsigned char *ptr = (const unsigned char *)buf;
  while(count >= 1ul)
  {
    fr = fp->writebuffer.size - (fp->writebuffer.start + fp->writebuffer.len);
    if(fr >= count)
    {
      memcpy((void *)(fp->writebuffer.buffer + (signed long int)fp->writebuffer.start + (signed long int)fp->writebuffer.len), (const void *)ptr, count);
      fp->writebuffer.len = fp->writebuffer.len + count;
      return 0;
    }

    else
      if(fr >= 1ul)
      {
        memcpy((void *)(fp->writebuffer.buffer + (signed long int)fp->writebuffer.start + (signed long int)fp->writebuffer.len), (const void *)ptr, fr);
        fp->writebuffer.len = fp->writebuffer.len + fr;
        ptr = ptr + (signed long int)fr;
        count = count - fr;
      }

    signed int return_value_tio_flush_nonblock$1;
    return_value_tio_flush_nonblock$1=tio_flush_nonblock(fp);
    if(!(return_value_tio_flush_nonblock$1 == 0))
      return -1;

    if(fp->writebuffer.len + fp->writebuffer.start >= fp->writebuffer.size)
    {
      if(!(fp->writebuffer.size >= fp->writebuffer.maxsize))
      {
        newsz = fp->writebuffer.size * (unsigned long int)2;
        if(!(fp->writebuffer.maxsize >= newsz))
          newsz = fp->writebuffer.maxsize;

        void *return_value_realloc$2;
        return_value_realloc$2=realloc((void *)fp->writebuffer.buffer, newsz);
        tmp = (unsigned char *)return_value_realloc$2;
        if(!(tmp == ((unsigned char *)NULL)))
        {
          fp->writebuffer.buffer = tmp;
          fp->writebuffer.size = newsz;
          continue;
        }

      }

      signed int return_value_tio_flush$3;
      return_value_tio_flush$3=tio_flush(fp);
      if(!(return_value_tio_flush$3 == 0))
        return -1;

    }

  }
  return 0;
}

// tio_writebuf
// file tio.c line 327
static signed int tio_writebuf(struct tio_fileinfo *fp)
{
  signed int rv;
  signed long int return_value_send$1;
  return_value_send$1=send(fp->fd, (const void *)(fp->writebuffer.buffer + (signed long int)fp->writebuffer.start), fp->writebuffer.len, 16384);
  rv = (signed int)return_value_send$1;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  _Bool tmp_if_expr$5;
  signed int *return_value___errno_location$4;
  if(rv == 0)
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    if(!(rv >= 0))
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 != 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
    {
      return_value___errno_location$4=__errno_location();
      tmp_if_expr$5 = *return_value___errno_location$4 != 11 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
    tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$6)
    return -1;

  else
  {
    if(rv >= 1)
    {
      fp->writebuffer.start = fp->writebuffer.start + (unsigned long int)rv;
      fp->writebuffer.len = fp->writebuffer.len - (unsigned long int)rv;
      if(fp->writebuffer.len == 0ul)
        fp->writebuffer.start = (unsigned long int)0;

      if(fp->writebuffer.start >= fp->writebuffer.size / 4ul)
      {
        memmove((void *)fp->writebuffer.buffer, (const void *)(fp->writebuffer.buffer + (signed long int)fp->writebuffer.start), fp->writebuffer.len);
        fp->writebuffer.start = (unsigned long int)0;
      }

    }

    return 0;
  }
}

// to_date
// file shadow.c line 118
static signed long int to_date(const char *dn, const char *date, const char *attr)
{
  char buffer[32l];
  signed long int value;
  char *tmp;
  unsigned long int l;
  signed int return_value_strcasecmp$5;
  return_value_strcasecmp$5=strcasecmp(attr, "pwdLastSet");
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$3;
  if(return_value_strcasecmp$5 == 0)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(date);
    l = return_value_strlen$1 - (unsigned long int)9;
    if(l >= 32ul)
      return (signed long int)-1;

    strncpy(buffer, date, l);
    buffer[(signed long int)l] = (char)0;
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 0;
    value=strtol(buffer, &tmp, 10);
    if((signed int)*date == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
    {
      log_log(4, "%s: %s: non-numeric", dn, attr);
      return (signed long int)-1;
    }

    else
    {
      return_value___errno_location$3=__errno_location();
      if(!(*return_value___errno_location$3 == 0))
      {
        log_log(4, "%s: %s: out of range", dn, attr);
        return (signed long int)-1;
      }

    }
    return value / (signed long int)864 - (signed long int)134774;
  }

  signed int *return_value___errno_location$6;
  return_value___errno_location$6=__errno_location();
  *return_value___errno_location$6 = 0;
  value=strtol(date, &tmp, 10);
  _Bool tmp_if_expr$8;
  if((signed int)*date == 0)
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location$7;
  if(tmp_if_expr$8)
  {
    log_log(4, "%s: %s: non-numeric", dn, attr);
    return (signed long int)-1;
  }

  else
  {
    return_value___errno_location$7=__errno_location();
    if(!(*return_value___errno_location$7 == 0))
    {
      log_log(4, "%s: %s: out of range", dn, attr);
      return (signed long int)-1;
    }

  }
  return value;
}

// try_autzsearch
// file pam.c line 444
static signed int try_autzsearch(struct ldap_session *session, const char *dn, const char *username, const char *servicename, const char *ruser, const char *rhost, const char *tty)
{
  char hostname[65l];
  const char *fqdn;
  struct dictionary *dict = (struct dictionary *)(void *)0;
  char filter[4096l];
  signed int rc = 0x00;
  const char *res;
  signed int i = 0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(i >= 8))
      tmp_if_expr$1 = nslcd_cfg->pam_authz_searches[(signed long int)i] != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    if(dict == ((struct dictionary *)NULL))
    {
      dict=dict_new();
      autzsearch_var_add(dict, "username", username);
      autzsearch_var_add(dict, "service", servicename);
      autzsearch_var_add(dict, "ruser", ruser);
      autzsearch_var_add(dict, "rhost", rhost);
      autzsearch_var_add(dict, "tty", tty);
      signed int return_value_gethostname$2;
      return_value_gethostname$2=gethostname(hostname, sizeof(char [65l]) /*65ul*/ );
      if(return_value_gethostname$2 == 0)
        autzsearch_var_add(dict, "hostname", hostname);

      fqdn=getfqdn();
      if(!(fqdn == ((const char *)NULL)))
        autzsearch_var_add(dict, "fqdn", fqdn);

      autzsearch_var_add(dict, "dn", dn);
      autzsearch_var_add(dict, "uid", username);
    }

    res=expr_parse(nslcd_cfg->pam_authz_searches[(signed long int)i], filter, sizeof(char [4096l]) /*4096ul*/ , autzsearch_var_get, (void *)dict);
    if(res == ((const char *)NULL))
    {
      autzsearch_vars_free(dict);
      dict_free(dict);
      log_log(3, "invalid pam_authz_search \"%s\"", nslcd_cfg->pam_authz_searches[(signed long int)i]);
      return -2;
    }

    rc=do_autzsearches(session, filter);
    if(!(rc == 0x00))
      break;

    i = i + 1;
  }
  while((_Bool)1);
  if(!(dict == ((struct dictionary *)NULL)))
  {
    autzsearch_vars_free(dict);
    dict_free(dict);
  }

  return rc;
}

// try_bind
// file pam.c line 44
static signed int try_bind(const char *userdn, const char *password, signed int *authzrc, char *authzmsg, unsigned long int authzmsgsz)
{
  struct ldap_session *session;
  struct myldap_search *search;
  struct myldap_entry *entry;
  signed int rc;
  const char *msg;
  session=myldap_create_session();
  if(session == ((struct ldap_session *)NULL))
    return 0x34;

  else
  {
    signed int return_value_myldap_set_credentials$1;
    return_value_myldap_set_credentials$1=myldap_set_credentials(session, userdn, password);
    if(!(return_value_myldap_set_credentials$1 == 0))
    {
      myldap_session_close(session);
      return -2;
    }

    else
    {
      static const char *attrs[2l];
      attrs[(signed long int)0] = "dn";
      attrs[(signed long int)1] = (const char *)(void *)0;
      search=myldap_search(session, userdn, (signed int)0x0000, "(objectClass=*)", attrs, &rc);
      if(search == ((struct myldap_search *)NULL) || !(rc == 0x00))
      {
        if(rc == 0x00)
          rc = -2;

        char *return_value_ldap_err2string$2;
        return_value_ldap_err2string$2=ldap_err2string(rc);
        log_log(4, "%s: %s", userdn, return_value_ldap_err2string$2);
      }

      else
      {
        entry=myldap_get_entry(search, &rc);
        if(entry == ((struct myldap_entry *)NULL) || !(rc == 0x00))
        {
          if(rc == 0x00)
            rc = -14;

          char *return_value_ldap_err2string$3;
          return_value_ldap_err2string$3=ldap_err2string(rc);
          log_log(4, "%s: %s", userdn, return_value_ldap_err2string$3);
        }

      }
      myldap_get_policy_response(session, authzrc, &msg);
      if(!(msg == ((const char *)NULL)))
      {
        if(!((signed int)*msg == 0))
        {
          mysnprintf(authzmsg, authzmsgsz - (unsigned long int)1, "%s", msg);
          log_log(4, "%s: %s", userdn, authzmsg);
        }

      }

      myldap_session_close(session);
      return rc;
    }
  }
}

// try_pwmod
// file pam.c line 684
static signed int try_pwmod(struct ldap_session *oldsession, const char *binddn, const char *userdn, const char *oldpassword, const char *newpassword, char *authzmsg, unsigned long int authzmsg_len)
{
  struct ldap_session *session;
  char buffer[1024l];
  signed int rc;
  session=myldap_create_session();
  signed int return_value_strcmp$2;
  if(session == ((struct ldap_session *)NULL))
    return 0x34;

  else
  {
    signed int return_value_myldap_set_credentials$1;
    return_value_myldap_set_credentials$1=myldap_set_credentials(session, binddn, oldpassword);
    if(!(return_value_myldap_set_credentials$1 == 0))
    {
      myldap_session_close(session);
      return -2;
    }

    else
    {
      char *return_value_lookup_dn2uid$5;
      return_value_lookup_dn2uid$5=lookup_dn2uid(session, userdn, &rc, buffer, sizeof(char [1024l]) /*1024ul*/ );
      if(!(return_value_lookup_dn2uid$5 == ((char *)NULL)))
      {
        if(rc == 0x00)
        {
          if(!(nslcd_cfg->rootpwmoddn == ((char *)NULL)))
          {
            return_value_strcmp$2=strcmp(binddn, nslcd_cfg->rootpwmoddn);
            if(return_value_strcmp$2 == 0)
              oldpassword = (const char *)(void *)0;

          }

          rc=myldap_passwd(session, userdn, oldpassword, newpassword);
          if(rc == 0x00)
          {
            signed int return_value_update_lastchange$3;
            return_value_update_lastchange$3=update_lastchange(session, userdn);
            if(!(return_value_update_lastchange$3 == 0x00))
              update_lastchange(oldsession, userdn);

          }

          else
          {
            signed int return_value_myldap_error_message$4;
            return_value_myldap_error_message$4=myldap_error_message(session, rc, buffer, sizeof(char [1024l]) /*1024ul*/ );
            if(return_value_myldap_error_message$4 == 0x00)
            {
              if(!((signed int)buffer[0l] == 0))
                mysnprintf(authzmsg, authzmsg_len - (unsigned long int)1, "password change failed: %s", (const void *)buffer);

            }

          }
        }

      }

      myldap_session_close(session);
      return rc;
    }
  }
}

// uid2dn
// file common.h line 125
char * uid2dn(struct ldap_session *session, const char *uid, char *buf, unsigned long int buflen)
{
  struct myldap_entry *entry;
  entry=uid2entry(session, uid, (signed int *)(void *)0);
  if(entry == ((struct myldap_entry *)NULL))
    return (char *)(void *)0;

  else
  {
    char *return_value_myldap_cpy_dn$1;
    return_value_myldap_cpy_dn$1=myldap_cpy_dn(entry, buf, buflen);
    return return_value_myldap_cpy_dn$1;
  }
}

// uid2entry
// file passwd.c line 351
struct myldap_entry * uid2entry(struct ldap_session *session, const char *uid, signed int *rcp)
{
  struct myldap_search *search = (struct myldap_search *)(void *)0;
  struct myldap_entry *entry = (struct myldap_entry *)(void *)0;
  const char *base;
  signed int i;
  char filter[4096l];
  signed int return_value_isvalidname$1;
  return_value_isvalidname$1=isvalidname(uid);
  _Bool tmp_if_expr$2;
  signed int return_value_entry_has_valid_uid$3;
  if(return_value_isvalidname$1 == 0)
  {
    if(!(rcp == ((signed int *)NULL)))
      *rcp = 0x15;

    return (struct myldap_entry *)(void *)0;
  }

  else
  {
    static const char *attrs[3l];
    attrs[(signed long int)0] = attmap_passwd_uid;
    attrs[(signed long int)1] = attmap_passwd_uidNumber;
    attrs[(signed long int)2] = (const char *)(void *)0;
    mkfilter_passwd_byname(uid, filter, sizeof(char [4096l]) /*4096ul*/ );
    i = 0;
    do
    {
      if(!(i >= 31))
      {
        base = passwd_bases[(signed long int)i];
        tmp_if_expr$2 = base != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        break;

      search=myldap_search(session, base, passwd_scope, filter, attrs, rcp);
      if(search == ((struct myldap_search *)NULL))
      {
        if(!(rcp == ((signed int *)NULL)))
        {
          if(*rcp == 0x00)
            *rcp = 0x20;

        }

        return (struct myldap_entry *)(void *)0;
      }

      entry=myldap_get_entry(search, rcp);
      if(!(entry == ((struct myldap_entry *)NULL)))
      {
        return_value_entry_has_valid_uid$3=entry_has_valid_uid(entry);
        if(!(return_value_entry_has_valid_uid$3 == 0))
          return entry;

      }

      i = i + 1;
    }
    while((_Bool)1);
    if(!(rcp == ((signed int *)NULL)))
    {
      if(*rcp == 0x00)
        *rcp = 0x20;

    }

    return (struct myldap_entry *)(void *)0;
  }
}

// update_lastchange
// file pam.c line 618
static signed int update_lastchange(struct ldap_session *session, const char *userdn)
{
  struct myldap_search *search;
  struct myldap_entry *entry;
  const char *attr;
  signed int rc;
  const char **values;
  struct ldapmod mod;
  struct ldapmod *mods[2l];
  char buffer[64l];
  char *strvals[2l];
  _Bool tmp_if_expr$2;
  if(attmap_shadow_shadowLastChange == ((const char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)attmap_shadow_shadowLastChange[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_strcmp$1;
  if(tmp_if_expr$2)
    return -2;

  else
  {
    return_value_strcmp$1=strcmp(attmap_shadow_shadowLastChange, "\"${shadowLastChange:--1}\"");
    if(return_value_strcmp$1 == 0)
      attr = "shadowLastChange";

    else
      if((signed int)*attmap_shadow_shadowLastChange == 34)
        return -2;

      else
        attr = attmap_shadow_shadowLastChange;
  }
  static const char *attrs[3l];
  attrs[(signed long int)0] = attmap_shadow_uid;
  attrs[(signed long int)1] = attr;
  attrs[(signed long int)2] = (const char *)(void *)0;
  search=myldap_search(session, userdn, (signed int)0x0000, shadow_filter, attrs, &rc);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  char *return_value_ldap_err2string$10;
  if(search == ((struct myldap_search *)NULL))
    return rc;

  else
  {
    entry=myldap_get_entry(search, &rc);
    if(entry == ((struct myldap_entry *)NULL))
      return rc;

    else
    {
      values=myldap_get_values(entry, attr);
      if(values == ((const char **)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = values[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)values[(signed long int)0][(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        return 0x10;

      else
      {
        signed int return_value_strcasecmp$9;
        return_value_strcasecmp$9=strcasecmp(attr, "pwdLastSet");
        if(return_value_strcasecmp$9 == 0)
        {
          signed long int return_value_time$5;
          return_value_time$5=time((signed long int *)(void *)0);
          signed int return_value_mysnprintf$6;
          return_value_mysnprintf$6=mysnprintf(buffer, sizeof(char [64l]) /*64ul*/ , "%ld000000000", (signed long int)return_value_time$5 / 100L + 134774L * 864L);
          if(!(return_value_mysnprintf$6 == 0))
            return -2;

        }

        else
        {
          signed long int return_value_time$7;
          return_value_time$7=time((signed long int *)(void *)0);
          signed int return_value_mysnprintf$8;
          return_value_mysnprintf$8=mysnprintf(buffer, sizeof(char [64l]) /*64ul*/ , "%ld", (signed long int)(return_value_time$7 / (signed long int)(60 * 60 * 24)));
          if(!(return_value_mysnprintf$8 == 0))
            return -2;

        }
        strvals[(signed long int)0] = buffer;
        strvals[(signed long int)1] = (char *)(void *)0;
        mod.mod_op = 0x0002;
        mod.mod_type = (char *)attr;
        mod.mod_vals.modv_strvals = strvals;
        mods[(signed long int)0] = &mod;
        mods[(signed long int)1] = (struct ldapmod *)(void *)0;
        rc=myldap_modify(session, userdn, mods);
        if(!(rc == 0x00))
        {
          return_value_ldap_err2string$10=ldap_err2string(rc);
          log_log(4, "%s: %s: modification failed: %s", userdn, attr, return_value_ldap_err2string$10);
        }

        else
          log_log(7, "%s: %s: modification succeeded", userdn, attr);
        return rc;
      }
    }
  }
}

// update_username
// file pam.c line 124
static void update_username(struct myldap_entry *entry, char *username, unsigned long int username_len)
{
  const char **values;
  const char *value;
  value=myldap_get_rdn_value(entry, attmap_passwd_uid);
  _Bool tmp_if_expr$2;
  if(value == ((const char *)NULL))
  {
    values=myldap_get_values(entry, attmap_passwd_uid);
    if(values == ((const char **)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = values[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      const char *return_value_myldap_get_dn$1;
      return_value_myldap_get_dn$1=myldap_get_dn(entry);
      log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_passwd_uid);
      goto __CPROVER_DUMP_L11;
    }

    value = values[(signed long int)0];
  }

  _Bool tmp_if_expr$5;
  signed int return_value_isvalidname$4;
  if(value == ((const char *)NULL))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_isvalidname$4=isvalidname(value);
    tmp_if_expr$5 = !(return_value_isvalidname$4 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  unsigned long int return_value_strlen$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_strlen$6=strlen(value);
    tmp_if_expr$7 = return_value_strlen$6 >= username_len ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
  {
    const char *return_value_myldap_get_dn$3;
    return_value_myldap_get_dn$3=myldap_get_dn(entry);
    log_log(4, "%s: %s: denied by validnames option", return_value_myldap_get_dn$3, attmap_passwd_uid);
    goto __CPROVER_DUMP_L11;
  }

  signed int return_value_strcmp$8;
  return_value_strcmp$8=strcmp(username, value);
  if(!(return_value_strcmp$8 == 0))
  {
    log_log(6, "username changed from \"%s\" to \"%s\"", username, value);
    strcpy(username, value);
  }


__CPROVER_DUMP_L11:
  ;
}

// validate_user
// file pam.c line 99
static struct myldap_entry * validate_user(struct ldap_session *session, char *username, signed int *rcp)
{
  signed int rc;
  struct myldap_entry *entry = (struct myldap_entry *)(void *)0;
  signed int return_value_isvalidname$1;
  return_value_isvalidname$1=isvalidname(username);
  if(return_value_isvalidname$1 == 0)
  {
    log_log(4, "request denied by validnames option");
    *rcp = 0x20;
    return (struct myldap_entry *)(void *)0;
  }

  else
  {
    entry=uid2entry(session, username, &rc);
    if(entry == ((struct myldap_entry *)NULL))
    {
      if(rc == 0x00)
        rc = 0x20;

      char *return_value_ldap_err2string$2;
      return_value_ldap_err2string$2=ldap_err2string(rc);
      log_log(7, "\"%s\": user not found: %s", username, return_value_ldap_err2string$2);
      *rcp = rc;
    }

    return entry;
  }
}

// validate_user$link1
// file usermod.c line 43
static struct myldap_entry * validate_user$link1(struct ldap_session *session$link1, char *username$link1, signed int *rcp$link1)
{
  signed int rc$link1;
  struct myldap_entry *entry$link1 = (struct myldap_entry *)(void *)0;
  signed int return_value_isvalidname$1$link1;
  return_value_isvalidname$1$link1=isvalidname(username$link1);
  if(return_value_isvalidname$1$link1 == 0)
  {
    log_log(4, "request denied by validnames option");
    *rcp$link1 = 0x20;
    return (struct myldap_entry *)(void *)0;
  }

  else
  {
    entry$link1=uid2entry(session$link1, username$link1, &rc$link1);
    if(entry$link1 == ((struct myldap_entry *)NULL))
    {
      if(rc$link1 == 0x00)
        rc$link1 = 0x20;

      char *return_value_ldap_err2string$2$link1;
      return_value_ldap_err2string$2$link1=ldap_err2string(rc$link1);
      log_log(7, "\"%s\": user not found: %s", username$link1, return_value_ldap_err2string$2$link1);
      *rcp$link1 = rc$link1;
      return (struct myldap_entry *)(void *)0;
    }

    return entry$link1;
  }
}

// wait_for_response
// file daemonize.c line 93
static signed int wait_for_response(signed int fd)
{
  signed int i;
  signed int l;
  signed int rc;
  char buffer[1024l];
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  i=read_response(fd, (char *)(void *)&rc, sizeof(signed int) /*4ul*/ );
  log_log(7, "DEBUG: wait_for_response(): i=%d, rc=%d", i, rc);
  signed int *return_value___errno_location$2;
  if(!((unsigned long int)i == sizeof(signed int) /*4ul*/ ))
  {
    log_log(3, "wait_for_response(): read_response() returned %d (expected %d)", i, (signed int)sizeof(signed int) /*4ul*/ );
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    if(*return_value___errno_location$3 == 0)
    {
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 61;
    }

    return -1;
  }

  i=read_response(fd, (char *)(void *)&l, sizeof(signed int) /*4ul*/ );
  log_log(7, "DEBUG: wait_for_response(): i=%d, l=%d", i, l);
  if(!((unsigned long int)i == sizeof(signed int) /*4ul*/ ) || !(l >= 1))
    _exit(rc);

  if((unsigned long int)l >= 1024ul)
    l = (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);

  i=read_response(fd, buffer, (unsigned long int)l);
  buffer[(signed long int)l] = (char)0;
  if(i == l)
    fprintf(stderr, "%s", (const void *)buffer);

  _exit(rc);
}

// worker
// file nslcd.c line 523
static void * worker(void *arg)
{
  struct ldap_session *session;
  signed int csock;
  signed int j;
  struct sockaddr_storage addr;
  unsigned int alen;
  struct anonymous$6 fds;
  struct timeval tv;
  session=myldap_create_session();
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  _Bool tmp_if_expr$12;
  signed int *return_value___errno_location$11;
  _Bool tmp_if_expr$14;
  signed int *return_value___errno_location$13;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  do
  {
    struct anonymous$1 __cancel_buf;
    void (*__cancel_routine)(void *) = worker_cleanup;
    void *__cancel_arg = (void *)session;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);

  __CPROVER_DUMP_L3:
    ;
    do
    {
      myldap_session_check(session);
      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$6) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&fds)->fds_bits[(signed long int)(nslcd_serversocket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->fds_bits[(signed long int)(nslcd_serversocket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << nslcd_serversocket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      tv.tv_sec = (signed long int)nslcd_cfg->idle_timelimit;
      tv.tv_usec = (signed long int)0;
      j=select(nslcd_serversocket + 1, &fds, (struct anonymous$6 *)(void *)0, (struct anonymous$6 *)(void *)0, nslcd_cfg->idle_timelimit > 0 ? &tv : (struct timeval *)(void *)0);
      if(!(j >= 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        if(*return_value___errno_location$5 == 4)
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          log_log(7, "select() failed (ignored): %s", return_value_strerror$2);
        }

        else
        {
          return_value___errno_location$3=__errno_location();
          return_value_strerror$4=strerror(*return_value___errno_location$3);
          log_log(3, "select() failed: %s", return_value_strerror$4);
        }
        goto __CPROVER_DUMP_L19;
      }

      if(!((fds.fds_bits[(signed long int)(nslcd_serversocket / 8)] & (signed long int)(1UL << nslcd_serversocket % 8)) == 0l))
      {
        alen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
        csock=accept(nslcd_serversocket, (struct sockaddr *)&addr, &alen);
        if(!(csock >= 0))
        {
          signed int *return_value___errno_location$10;
          return_value___errno_location$10=__errno_location();
          if(*return_value___errno_location$10 == 4)
            tmp_if_expr$12 = (_Bool)1;

          else
          {
            return_value___errno_location$11=__errno_location();
            tmp_if_expr$12 = *return_value___errno_location$11 == 11 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$12)
            tmp_if_expr$14 = (_Bool)1;

          else
          {
            return_value___errno_location$13=__errno_location();
            tmp_if_expr$14 = *return_value___errno_location$13 == 11 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$14)
          {
            return_value___errno_location$6=__errno_location();
            return_value_strerror$7=strerror(*return_value___errno_location$6);
            log_log(7, "accept() failed (ignored): %s", return_value_strerror$7);
          }

          else
          {
            return_value___errno_location$8=__errno_location();
            return_value_strerror$9=strerror(*return_value___errno_location$8);
            log_log(3, "accept() failed: %s", return_value_strerror$9);
          }
          goto __CPROVER_DUMP_L19;
        }

        j=fcntl(csock, 3, 0);
        if(!(j >= 0))
        {
          signed int *return_value___errno_location$15;
          return_value___errno_location$15=__errno_location();
          char *return_value_strerror$16;
          return_value_strerror$16=strerror(*return_value___errno_location$15);
          log_log(3, "fctnl(F_GETFL) failed: %s", return_value_strerror$16);
          signed int return_value_close$19;
          return_value_close$19=close(csock);
          if(!(return_value_close$19 == 0))
          {
            return_value___errno_location$17=__errno_location();
            return_value_strerror$18=strerror(*return_value___errno_location$17);
            log_log(4, "problem closing socket: %s", return_value_strerror$18);
          }

          goto __CPROVER_DUMP_L19;
        }

        signed int return_value_fcntl$25;
        return_value_fcntl$25=fcntl(csock, 4, j & ~04000);
        if(!(return_value_fcntl$25 >= 0))
        {
          signed int *return_value___errno_location$20;
          return_value___errno_location$20=__errno_location();
          char *return_value_strerror$21;
          return_value_strerror$21=strerror(*return_value___errno_location$20);
          log_log(3, "fctnl(F_SETFL,~O_NONBLOCK) failed: %s", return_value_strerror$21);
          signed int return_value_close$24;
          return_value_close$24=close(csock);
          if(!(return_value_close$24 == 0))
          {
            return_value___errno_location$22=__errno_location();
            return_value_strerror$23=strerror(*return_value___errno_location$22);
            log_log(4, "problem closing socket: %s", return_value_strerror$23);
          }

          goto __CPROVER_DUMP_L19;
        }

        log_newsession();
        handleconnection(csock, session);
        log_clearsession();
      }


    __CPROVER_DUMP_L19:
      ;
      goto __CPROVER_DUMP_L3;

    __CPROVER_DUMP_L20:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  return (void *)0;
}

// worker_cleanup
// file nslcd.c line 517
static void worker_cleanup(void *arg)
{
  struct ldap_session *session = (struct ldap_session *)arg;
  myldap_session_close(session);
}

// write_address
// file common.c line 211
signed int write_address(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *attr, const char *addr)
{
  signed int tmpint32;
  struct in_addr ipv4addr;
  struct in6_addr ipv6addr;
  signed int return_value_inet_pton$57;
  return_value_inet_pton$57=inet_pton(2, addr, (void *)&ipv4addr);
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int return_value_inet_pton$56;
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  signed int *return_value___errno_location$24;
  char *return_value_strerror$25;
  signed int *return_value___errno_location$29;
  char *return_value_strerror$30;
  signed int *return_value___errno_location$31;
  char *return_value_strerror$32;
  signed int *return_value___errno_location$35;
  char *return_value_strerror$36;
  signed int *return_value___errno_location$37;
  char *return_value_strerror$38;
  signed int *return_value___errno_location$43;
  char *return_value_strerror$44;
  signed int *return_value___errno_location$45;
  char *return_value_strerror$46;
  signed int *return_value___errno_location$50;
  char *return_value_strerror$51;
  signed int *return_value___errno_location$52;
  char *return_value_strerror$53;
  if(return_value_inet_pton$57 >= 1)
  {
    unsigned int return_value_htonl$1;
    return_value_htonl$1=htonl((unsigned int)(signed int)2);
    tmpint32 = (signed int)return_value_htonl$1;
    signed int return_value_tio_write$7;
    return_value_tio_write$7=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$7 == 0))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      if(*return_value___errno_location$6 == 32)
      {
        return_value___errno_location$2=__errno_location();
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        log_log(7, "error writing to client: %s", return_value_strerror$3);
      }

      else
      {
        return_value___errno_location$4=__errno_location();
        return_value_strerror$5=strerror(*return_value___errno_location$4);
        log_log(4, "error writing to client: %s", return_value_strerror$5);
      }
      return -1;
    }

    unsigned int return_value_htonl$8;
    return_value_htonl$8=htonl((unsigned int)(signed int)sizeof(struct in_addr) /*4ul*/ );
    tmpint32 = (signed int)return_value_htonl$8;
    signed int return_value_tio_write$14;
    return_value_tio_write$14=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$14 == 0))
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      if(*return_value___errno_location$13 == 32)
      {
        return_value___errno_location$9=__errno_location();
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        log_log(7, "error writing to client: %s", return_value_strerror$10);
      }

      else
      {
        return_value___errno_location$11=__errno_location();
        return_value_strerror$12=strerror(*return_value___errno_location$11);
        log_log(4, "error writing to client: %s", return_value_strerror$12);
      }
      return -1;
    }

    signed int return_value_tio_write$20;
    return_value_tio_write$20=tio_write(fp, (const void *)&ipv4addr, (unsigned long int)sizeof(struct in_addr) /*4ul*/ );
    if(!(return_value_tio_write$20 == 0))
    {
      signed int *return_value___errno_location$19;
      return_value___errno_location$19=__errno_location();
      if(*return_value___errno_location$19 == 32)
      {
        return_value___errno_location$15=__errno_location();
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        log_log(7, "error writing to client: %s", return_value_strerror$16);
      }

      else
      {
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        log_log(4, "error writing to client: %s", return_value_strerror$18);
      }
      return -1;
    }

  }

  else
  {
    return_value_inet_pton$56=inet_pton(10, addr, (void *)&ipv6addr);
    if(return_value_inet_pton$56 >= 1)
    {
      unsigned int return_value_htonl$21;
      return_value_htonl$21=htonl((unsigned int)(signed int)10);
      tmpint32 = (signed int)return_value_htonl$21;
      signed int return_value_tio_write$27;
      return_value_tio_write$27=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$27 == 0))
      {
        signed int *return_value___errno_location$26;
        return_value___errno_location$26=__errno_location();
        if(*return_value___errno_location$26 == 32)
        {
          return_value___errno_location$22=__errno_location();
          return_value_strerror$23=strerror(*return_value___errno_location$22);
          log_log(7, "error writing to client: %s", return_value_strerror$23);
        }

        else
        {
          return_value___errno_location$24=__errno_location();
          return_value_strerror$25=strerror(*return_value___errno_location$24);
          log_log(4, "error writing to client: %s", return_value_strerror$25);
        }
        return -1;
      }

      unsigned int return_value_htonl$28;
      return_value_htonl$28=htonl((unsigned int)(signed int)sizeof(struct in6_addr) /*16ul*/ );
      tmpint32 = (signed int)return_value_htonl$28;
      signed int return_value_tio_write$34;
      return_value_tio_write$34=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$34 == 0))
      {
        signed int *return_value___errno_location$33;
        return_value___errno_location$33=__errno_location();
        if(*return_value___errno_location$33 == 32)
        {
          return_value___errno_location$29=__errno_location();
          return_value_strerror$30=strerror(*return_value___errno_location$29);
          log_log(7, "error writing to client: %s", return_value_strerror$30);
        }

        else
        {
          return_value___errno_location$31=__errno_location();
          return_value_strerror$32=strerror(*return_value___errno_location$31);
          log_log(4, "error writing to client: %s", return_value_strerror$32);
        }
        return -1;
      }

      signed int return_value_tio_write$40;
      return_value_tio_write$40=tio_write(fp, (const void *)&ipv6addr, (unsigned long int)sizeof(struct in6_addr) /*16ul*/ );
      if(!(return_value_tio_write$40 == 0))
      {
        signed int *return_value___errno_location$39;
        return_value___errno_location$39=__errno_location();
        if(*return_value___errno_location$39 == 32)
        {
          return_value___errno_location$35=__errno_location();
          return_value_strerror$36=strerror(*return_value___errno_location$35);
          log_log(7, "error writing to client: %s", return_value_strerror$36);
        }

        else
        {
          return_value___errno_location$37=__errno_location();
          return_value_strerror$38=strerror(*return_value___errno_location$37);
          log_log(4, "error writing to client: %s", return_value_strerror$38);
        }
        return -1;
      }

    }

    else
    {
      const char *return_value_myldap_get_dn$41;
      return_value_myldap_get_dn$41=myldap_get_dn(entry);
      log_log(4, "%s: %s: \"%s\" unparsable", return_value_myldap_get_dn$41, attr, addr);
      unsigned int return_value_htonl$42;
      return_value_htonl$42=htonl((unsigned int)(signed int)-1);
      tmpint32 = (signed int)return_value_htonl$42;
      signed int return_value_tio_write$48;
      return_value_tio_write$48=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$48 == 0))
      {
        signed int *return_value___errno_location$47;
        return_value___errno_location$47=__errno_location();
        if(*return_value___errno_location$47 == 32)
        {
          return_value___errno_location$43=__errno_location();
          return_value_strerror$44=strerror(*return_value___errno_location$43);
          log_log(7, "error writing to client: %s", return_value_strerror$44);
        }

        else
        {
          return_value___errno_location$45=__errno_location();
          return_value_strerror$46=strerror(*return_value___errno_location$45);
          log_log(4, "error writing to client: %s", return_value_strerror$46);
        }
        return -1;
      }

      unsigned int return_value_htonl$49;
      return_value_htonl$49=htonl((unsigned int)(signed int)0);
      tmpint32 = (signed int)return_value_htonl$49;
      signed int return_value_tio_write$55;
      return_value_tio_write$55=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$55 == 0))
      {
        signed int *return_value___errno_location$54;
        return_value___errno_location$54=__errno_location();
        if(*return_value___errno_location$54 == 32)
        {
          return_value___errno_location$50=__errno_location();
          return_value_strerror$51=strerror(*return_value___errno_location$50);
          log_log(7, "error writing to client: %s", return_value_strerror$51);
        }

        else
        {
          return_value___errno_location$52=__errno_location();
          return_value_strerror$53=strerror(*return_value___errno_location$52);
          log_log(4, "error writing to client: %s", return_value_strerror$53);
        }
        return -1;
      }

    }
  }
  return 0;
}

// write_alias
// file alias.c line 95
static signed int write_alias(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqalias)
{
  signed int tmpint32;
  signed int tmp2int32;
  signed int tmp3int32;
  const char **names;
  const char **members;
  signed int i;
  names=myldap_get_values(entry, attmap_alias_cn);
  _Bool tmp_if_expr$2;
  if(names == ((const char **)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = names[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    const char *return_value_myldap_get_dn$1;
    return_value_myldap_get_dn$1=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_alias_cn);
    return 0;
  }

  members=myldap_get_values(entry, attmap_alias_rfc822MailMember);
  i = 0;
  _Bool tmp_if_expr$69;
  signed int return_value_strcasecmp$68;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  signed int *return_value___errno_location$21;
  char *return_value_strerror$22;
  signed int *return_value___errno_location$26;
  char *return_value_strerror$27;
  signed int *return_value___errno_location$28;
  char *return_value_strerror$29;
  signed int *return_value___errno_location$33;
  char *return_value_strerror$34;
  signed int *return_value___errno_location$35;
  char *return_value_strerror$36;
  signed int *return_value___errno_location$40;
  char *return_value_strerror$41;
  signed int *return_value___errno_location$42;
  char *return_value_strerror$43;
  signed int *return_value___errno_location$47;
  char *return_value_strerror$48;
  signed int *return_value___errno_location$49;
  char *return_value_strerror$50;
  signed int *return_value___errno_location$55;
  char *return_value_strerror$56;
  signed int *return_value___errno_location$57;
  char *return_value_strerror$58;
  signed int *return_value___errno_location$62;
  char *return_value_strerror$63;
  signed int *return_value___errno_location$64;
  char *return_value_strerror$65;
  for( ; !(names[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    if(reqalias == ((const char *)NULL))
      tmp_if_expr$69 = (_Bool)1;

    else
    {
      return_value_strcasecmp$68=strcasecmp(reqalias, names[(signed long int)i]);
      tmp_if_expr$69 = return_value_strcasecmp$68 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$69)
    {
      unsigned int return_value_htonl$3;
      return_value_htonl$3=htonl((unsigned int)(signed int)1);
      tmpint32 = (signed int)return_value_htonl$3;
      signed int return_value_tio_write$9;
      return_value_tio_write$9=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$9 == 0))
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        if(*return_value___errno_location$8 == 32)
        {
          return_value___errno_location$4=__errno_location();
          return_value_strerror$5=strerror(*return_value___errno_location$4);
          log_log(7, "error writing to client: %s", return_value_strerror$5);
        }

        else
        {
          return_value___errno_location$6=__errno_location();
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          log_log(4, "error writing to client: %s", return_value_strerror$7);
        }
        return -1;
      }

      if(names[(signed long int)i] == ((const char *)NULL))
      {
        unsigned int return_value_htonl$10;
        return_value_htonl$10=htonl((unsigned int)(signed int)0);
        tmpint32 = (signed int)return_value_htonl$10;
        signed int return_value_tio_write$16;
        return_value_tio_write$16=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$16 == 0))
        {
          signed int *return_value___errno_location$15;
          return_value___errno_location$15=__errno_location();
          if(*return_value___errno_location$15 == 32)
          {
            return_value___errno_location$11=__errno_location();
            return_value_strerror$12=strerror(*return_value___errno_location$11);
            log_log(7, "error writing to client: %s", return_value_strerror$12);
          }

          else
          {
            return_value___errno_location$13=__errno_location();
            return_value_strerror$14=strerror(*return_value___errno_location$13);
            log_log(4, "error writing to client: %s", return_value_strerror$14);
          }
          return -1;
        }

      }

      else
      {
        unsigned long int return_value_strlen$17;
        return_value_strlen$17=strlen(names[(signed long int)i]);
        unsigned int return_value_htonl$18;
        return_value_htonl$18=htonl((unsigned int)(signed int)return_value_strlen$17);
        tmpint32 = (signed int)return_value_htonl$18;
        signed int return_value_tio_write$24;
        return_value_tio_write$24=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$24 == 0))
        {
          signed int *return_value___errno_location$23;
          return_value___errno_location$23=__errno_location();
          if(*return_value___errno_location$23 == 32)
          {
            return_value___errno_location$19=__errno_location();
            return_value_strerror$20=strerror(*return_value___errno_location$19);
            log_log(7, "error writing to client: %s", return_value_strerror$20);
          }

          else
          {
            return_value___errno_location$21=__errno_location();
            return_value_strerror$22=strerror(*return_value___errno_location$21);
            log_log(4, "error writing to client: %s", return_value_strerror$22);
          }
          return -1;
        }

        unsigned int return_value_ntohl$25;
        return_value_ntohl$25=ntohl((unsigned int)tmpint32);
        tmpint32 = (signed int)return_value_ntohl$25;
        if(tmpint32 >= 1)
        {
          signed int return_value_tio_write$31;
          return_value_tio_write$31=tio_write(fp, (const void *)names[(signed long int)i], (unsigned long int)tmpint32);
          if(!(return_value_tio_write$31 == 0))
          {
            signed int *return_value___errno_location$30;
            return_value___errno_location$30=__errno_location();
            if(*return_value___errno_location$30 == 32)
            {
              return_value___errno_location$26=__errno_location();
              return_value_strerror$27=strerror(*return_value___errno_location$26);
              log_log(7, "error writing to client: %s", return_value_strerror$27);
            }

            else
            {
              return_value___errno_location$28=__errno_location();
              return_value_strerror$29=strerror(*return_value___errno_location$28);
              log_log(4, "error writing to client: %s", return_value_strerror$29);
            }
            return -1;
          }

        }

      }
      if(members == ((const char **)NULL))
      {
        unsigned int return_value_htonl$32;
        return_value_htonl$32=htonl((unsigned int)(signed int)0);
        tmpint32 = (signed int)return_value_htonl$32;
        signed int return_value_tio_write$38;
        return_value_tio_write$38=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$38 == 0))
        {
          signed int *return_value___errno_location$37;
          return_value___errno_location$37=__errno_location();
          if(*return_value___errno_location$37 == 32)
          {
            return_value___errno_location$33=__errno_location();
            return_value_strerror$34=strerror(*return_value___errno_location$33);
            log_log(7, "error writing to client: %s", return_value_strerror$34);
          }

          else
          {
            return_value___errno_location$35=__errno_location();
            return_value_strerror$36=strerror(*return_value___errno_location$35);
            log_log(4, "error writing to client: %s", return_value_strerror$36);
          }
          return -1;
        }

      }

      else
      {
        tmp3int32 = 0;
        for( ; !(members[(signed long int)tmp3int32] == ((const char *)NULL)); tmp3int32 = tmp3int32 + 1)
          ;
        unsigned int return_value_htonl$39;
        return_value_htonl$39=htonl((unsigned int)(signed int)tmp3int32);
        tmpint32 = (signed int)return_value_htonl$39;
        signed int return_value_tio_write$45;
        return_value_tio_write$45=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$45 == 0))
        {
          signed int *return_value___errno_location$44;
          return_value___errno_location$44=__errno_location();
          if(*return_value___errno_location$44 == 32)
          {
            return_value___errno_location$40=__errno_location();
            return_value_strerror$41=strerror(*return_value___errno_location$40);
            log_log(7, "error writing to client: %s", return_value_strerror$41);
          }

          else
          {
            return_value___errno_location$42=__errno_location();
            return_value_strerror$43=strerror(*return_value___errno_location$42);
            log_log(4, "error writing to client: %s", return_value_strerror$43);
          }
          return -1;
        }

        tmp2int32 = 0;
        for( ; !(tmp2int32 >= tmp3int32); tmp2int32 = tmp2int32 + 1)
          if(members[(signed long int)tmp2int32] == ((const char *)NULL))
          {
            unsigned int return_value_htonl$46;
            return_value_htonl$46=htonl((unsigned int)(signed int)0);
            tmpint32 = (signed int)return_value_htonl$46;
            signed int return_value_tio_write$52;
            return_value_tio_write$52=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$52 == 0))
            {
              signed int *return_value___errno_location$51;
              return_value___errno_location$51=__errno_location();
              if(*return_value___errno_location$51 == 32)
              {
                return_value___errno_location$47=__errno_location();
                return_value_strerror$48=strerror(*return_value___errno_location$47);
                log_log(7, "error writing to client: %s", return_value_strerror$48);
              }

              else
              {
                return_value___errno_location$49=__errno_location();
                return_value_strerror$50=strerror(*return_value___errno_location$49);
                log_log(4, "error writing to client: %s", return_value_strerror$50);
              }
              return -1;
            }

          }

          else
          {
            unsigned long int return_value_strlen$53;
            return_value_strlen$53=strlen(members[(signed long int)tmp2int32]);
            unsigned int return_value_htonl$54;
            return_value_htonl$54=htonl((unsigned int)(signed int)return_value_strlen$53);
            tmpint32 = (signed int)return_value_htonl$54;
            signed int return_value_tio_write$60;
            return_value_tio_write$60=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$60 == 0))
            {
              signed int *return_value___errno_location$59;
              return_value___errno_location$59=__errno_location();
              if(*return_value___errno_location$59 == 32)
              {
                return_value___errno_location$55=__errno_location();
                return_value_strerror$56=strerror(*return_value___errno_location$55);
                log_log(7, "error writing to client: %s", return_value_strerror$56);
              }

              else
              {
                return_value___errno_location$57=__errno_location();
                return_value_strerror$58=strerror(*return_value___errno_location$57);
                log_log(4, "error writing to client: %s", return_value_strerror$58);
              }
              return -1;
            }

            unsigned int return_value_ntohl$61;
            return_value_ntohl$61=ntohl((unsigned int)tmpint32);
            tmpint32 = (signed int)return_value_ntohl$61;
            if(tmpint32 >= 1)
            {
              signed int return_value_tio_write$67;
              return_value_tio_write$67=tio_write(fp, (const void *)members[(signed long int)tmp2int32], (unsigned long int)tmpint32);
              if(!(return_value_tio_write$67 == 0))
              {
                signed int *return_value___errno_location$66;
                return_value___errno_location$66=__errno_location();
                if(*return_value___errno_location$66 == 32)
                {
                  return_value___errno_location$62=__errno_location();
                  return_value_strerror$63=strerror(*return_value___errno_location$62);
                  log_log(7, "error writing to client: %s", return_value_strerror$63);
                }

                else
                {
                  return_value___errno_location$64=__errno_location();
                  return_value_strerror$65=strerror(*return_value___errno_location$64);
                  log_log(4, "error writing to client: %s", return_value_strerror$65);
                }
                return -1;
              }

            }

          }
      }
    }

  }
  return 0;
}

// write_ether
// file ether.c line 113
static signed int write_ether(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqname, const char *reqether)
{
  signed int tmpint32;
  struct ether_addr tmpaddr;
  const char *tmparr[2l];
  const char **names;
  const char **ethers;
  signed int i;
  signed int j;
  names=myldap_get_values(entry, attmap_ether_cn);
  _Bool tmp_if_expr$2;
  if(names == ((const char **)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = names[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    const char *return_value_myldap_get_dn$1;
    return_value_myldap_get_dn$1=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_ether_cn);
    return 0;
  }

  _Bool tmp_if_expr$4;
  if(!(reqether == ((const char *)NULL)))
  {
    ethers = tmparr;
    ethers[(signed long int)0] = reqether;
    ethers[(signed long int)1] = (const char *)(void *)0;
  }

  else
  {
    ethers=myldap_get_values(entry, attmap_ether_macAddress);
    if(ethers == ((const char **)NULL))
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = ethers[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
    {
      const char *return_value_myldap_get_dn$3;
      return_value_myldap_get_dn$3=myldap_get_dn(entry);
      log_log(4, "%s: %s: missing", return_value_myldap_get_dn$3, attmap_ether_macAddress);
      return 0;
    }

  }
  i = 0;
  _Bool tmp_if_expr$41;
  signed int return_value_strcasecmp$40;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  signed int *return_value___errno_location$21;
  char *return_value_strerror$22;
  signed int *return_value___errno_location$23;
  char *return_value_strerror$24;
  signed int *return_value___errno_location$28;
  char *return_value_strerror$29;
  signed int *return_value___errno_location$30;
  char *return_value_strerror$31;
  signed int *return_value___errno_location$34;
  char *return_value_strerror$35;
  signed int *return_value___errno_location$36;
  char *return_value_strerror$37;
  for( ; !(names[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    if(reqname == ((const char *)NULL))
      tmp_if_expr$41 = (_Bool)1;

    else
    {
      return_value_strcasecmp$40=strcasecmp(reqname, names[(signed long int)i]);
      tmp_if_expr$41 = return_value_strcasecmp$40 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$41)
    {
      j = 0;
      for( ; !(ethers[(signed long int)j] == ((const char *)NULL)); j = j + 1)
      {
        unsigned int return_value_htonl$5;
        return_value_htonl$5=htonl((unsigned int)(signed int)1);
        tmpint32 = (signed int)return_value_htonl$5;
        signed int return_value_tio_write$11;
        return_value_tio_write$11=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$11 == 0))
        {
          signed int *return_value___errno_location$10;
          return_value___errno_location$10=__errno_location();
          if(*return_value___errno_location$10 == 32)
          {
            return_value___errno_location$6=__errno_location();
            return_value_strerror$7=strerror(*return_value___errno_location$6);
            log_log(7, "error writing to client: %s", return_value_strerror$7);
          }

          else
          {
            return_value___errno_location$8=__errno_location();
            return_value_strerror$9=strerror(*return_value___errno_location$8);
            log_log(4, "error writing to client: %s", return_value_strerror$9);
          }
          return -1;
        }

        if(names[(signed long int)i] == ((const char *)NULL))
        {
          unsigned int return_value_htonl$12;
          return_value_htonl$12=htonl((unsigned int)(signed int)0);
          tmpint32 = (signed int)return_value_htonl$12;
          signed int return_value_tio_write$18;
          return_value_tio_write$18=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$18 == 0))
          {
            signed int *return_value___errno_location$17;
            return_value___errno_location$17=__errno_location();
            if(*return_value___errno_location$17 == 32)
            {
              return_value___errno_location$13=__errno_location();
              return_value_strerror$14=strerror(*return_value___errno_location$13);
              log_log(7, "error writing to client: %s", return_value_strerror$14);
            }

            else
            {
              return_value___errno_location$15=__errno_location();
              return_value_strerror$16=strerror(*return_value___errno_location$15);
              log_log(4, "error writing to client: %s", return_value_strerror$16);
            }
            return -1;
          }

        }

        else
        {
          unsigned long int return_value_strlen$19;
          return_value_strlen$19=strlen(names[(signed long int)i]);
          unsigned int return_value_htonl$20;
          return_value_htonl$20=htonl((unsigned int)(signed int)return_value_strlen$19);
          tmpint32 = (signed int)return_value_htonl$20;
          signed int return_value_tio_write$26;
          return_value_tio_write$26=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$26 == 0))
          {
            signed int *return_value___errno_location$25;
            return_value___errno_location$25=__errno_location();
            if(*return_value___errno_location$25 == 32)
            {
              return_value___errno_location$21=__errno_location();
              return_value_strerror$22=strerror(*return_value___errno_location$21);
              log_log(7, "error writing to client: %s", return_value_strerror$22);
            }

            else
            {
              return_value___errno_location$23=__errno_location();
              return_value_strerror$24=strerror(*return_value___errno_location$23);
              log_log(4, "error writing to client: %s", return_value_strerror$24);
            }
            return -1;
          }

          unsigned int return_value_ntohl$27;
          return_value_ntohl$27=ntohl((unsigned int)tmpint32);
          tmpint32 = (signed int)return_value_ntohl$27;
          if(tmpint32 >= 1)
          {
            signed int return_value_tio_write$33;
            return_value_tio_write$33=tio_write(fp, (const void *)names[(signed long int)i], (unsigned long int)tmpint32);
            if(!(return_value_tio_write$33 == 0))
            {
              signed int *return_value___errno_location$32;
              return_value___errno_location$32=__errno_location();
              if(*return_value___errno_location$32 == 32)
              {
                return_value___errno_location$28=__errno_location();
                return_value_strerror$29=strerror(*return_value___errno_location$28);
                log_log(7, "error writing to client: %s", return_value_strerror$29);
              }

              else
              {
                return_value___errno_location$30=__errno_location();
                return_value_strerror$31=strerror(*return_value___errno_location$30);
                log_log(4, "error writing to client: %s", return_value_strerror$31);
              }
              return -1;
            }

          }

        }
        ether_aton_r(ethers[(signed long int)j], &tmpaddr);
        signed int return_value_tio_write$39;
        return_value_tio_write$39=tio_write(fp, (const void *)&tmpaddr, (unsigned long int)sizeof(unsigned char [6l]) /*6ul*/ );
        if(!(return_value_tio_write$39 == 0))
        {
          signed int *return_value___errno_location$38;
          return_value___errno_location$38=__errno_location();
          if(*return_value___errno_location$38 == 32)
          {
            return_value___errno_location$34=__errno_location();
            return_value_strerror$35=strerror(*return_value___errno_location$34);
            log_log(7, "error writing to client: %s", return_value_strerror$35);
          }

          else
          {
            return_value___errno_location$36=__errno_location();
            return_value_strerror$37=strerror(*return_value___errno_location$36);
            log_log(4, "error writing to client: %s", return_value_strerror$37);
          }
          return -1;
        }

      }
    }

  }
  return 0;
}

// write_group
// file group.c line 320
static signed int write_group(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqname, const unsigned int *reqgid, signed int wantmembers, struct ldap_session *session)
{
  const char **names;
  const char **gidvalues;
  const char *passwd;
  const char **members = (const char **)(void *)0;
  struct set *set;
  struct set *seen = (struct set *)(void *)0;
  struct set *subgroups = (struct set *)(void *)0;
  unsigned int gids[5l];
  signed int numgids;
  char *tmp;
  char passbuffer[256l];
  struct myldap_search *search;
  struct myldap_entry *entry2;
  signed int rc;
  names=myldap_get_values(entry, attmap_group_cn);
  _Bool tmp_if_expr$2;
  if(names == ((const char **)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = names[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    const char *return_value_myldap_get_dn$1;
    return_value_myldap_get_dn$1=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_group_cn);
    return 0;
  }

  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  unsigned long int return_value_binsid2id$6;
  _Bool tmp_if_expr$14;
  signed int *return_value___errno_location$11;
  _Bool tmp_if_expr$13;
  char *return_value_strchr$12;
  if(!(reqgid == ((const unsigned int *)NULL)))
  {
    gids[(signed long int)0] = *reqgid;
    numgids = 1;
  }

  else
  {
    gidvalues=myldap_get_values_len(entry, attmap_group_gidNumber);
    if(gidvalues == ((const char **)NULL))
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = gidvalues[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
    {
      const char *return_value_myldap_get_dn$3;
      return_value_myldap_get_dn$3=myldap_get_dn(entry);
      log_log(4, "%s: %s: missing", return_value_myldap_get_dn$3, attmap_group_gidNumber);
      return 0;
    }

    numgids = 0;
    do
    {
      if(!(numgids >= 5))
        tmp_if_expr$5 = gidvalues[(signed long int)numgids] != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(!tmp_if_expr$5)
        break;

      if(!(gidSid == ((char *)NULL)))
      {
        return_value_binsid2id$6=binsid2id(gidvalues[(signed long int)numgids]);
        gids[(signed long int)numgids] = (unsigned int)return_value_binsid2id$6;
      }

      else
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        *return_value___errno_location$7 = 0;
        unsigned int return_value_strtoui$8;
        return_value_strtoui$8=strtoui(gidvalues[(signed long int)numgids], &tmp, 10);
        gids[(signed long int)numgids] = (unsigned int)return_value_strtoui$8;
        if((signed int)*gidvalues[(signed long int)numgids] == 0)
          tmp_if_expr$14 = (_Bool)1;

        else
          tmp_if_expr$14 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$14)
        {
          const char *return_value_myldap_get_dn$9;
          return_value_myldap_get_dn$9=myldap_get_dn(entry);
          log_log(4, "%s: %s: non-numeric", return_value_myldap_get_dn$9, attmap_group_gidNumber);
          return 0;
        }

        else
        {
          return_value___errno_location$11=__errno_location();
          if(!(*return_value___errno_location$11 == 0))
            tmp_if_expr$13 = (_Bool)1;

          else
          {
            return_value_strchr$12=strchr(gidvalues[(signed long int)numgids], 45);
            tmp_if_expr$13 = return_value_strchr$12 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$13)
          {
            const char *return_value_myldap_get_dn$10;
            return_value_myldap_get_dn$10=myldap_get_dn(entry);
            log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$10, attmap_group_gidNumber);
            return 0;
          }

        }
      }
      numgids = numgids + 1;
    }
    while((_Bool)1);
  }
  passwd=get_userpassword(entry, attmap_group_userPassword, passbuffer, sizeof(char [256l]) /*256ul*/ );
  if(passwd == ((const char *)NULL))
    passwd = default_group_userPassword;

  if(!(wantmembers == 0))
  {
    set=set_new();
    if(!(set == ((struct set *)NULL)))
    {
      if(!(nslcd_cfg->nss_nested_groups == 0))
      {
        seen=set_new();
        subgroups=set_new();
      }

      getmembers(entry, session, set, seen, subgroups);
      if(!(subgroups == ((struct set *)NULL)))
        do
        {
          tmp=set_pop(subgroups);
          if(tmp == ((char *)NULL))
            break;

          search=myldap_search(session, tmp, (signed int)0x0000, group_filter, group_attrs, (signed int *)(void *)0);
          if(!(search == ((struct myldap_search *)NULL)))
            do
            {
              entry2=myldap_get_entry(search, (signed int *)(void *)0);
              if(entry2 == ((struct myldap_entry *)NULL))
                break;

              getmembers(entry2, session, set, seen, subgroups);
            }
            while((_Bool)1);

          free((void *)tmp);
        }
        while((_Bool)1);

      members=set_tolist(set);
      set_free(set);
      if(!(seen == ((struct set *)NULL)))
        set_free(seen);

      if(!(subgroups == ((struct set *)NULL)))
        set_free(subgroups);

    }

  }

  rc=do_write_group(fp, entry, names, gids, numgids, passwd, members, reqname);
  if(!(members == ((const char **)NULL)))
    free((void *)members);

  return rc;
}

// write_host
// file host.c line 113
static signed int write_host(struct tio_fileinfo *fp, struct myldap_entry *entry)
{
  signed int tmpint32;
  signed int tmp2int32;
  signed int tmp3int32;
  signed int numaddr;
  signed int i;
  const char *hostname;
  const char **hostnames;
  const char **addresses;
  hostname=myldap_get_rdn_value(entry, attmap_host_cn);
  hostnames=myldap_get_values(entry, attmap_host_cn);
  _Bool tmp_if_expr$2;
  if(hostnames == ((const char **)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = hostnames[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    const char *return_value_myldap_get_dn$1;
    return_value_myldap_get_dn$1=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_host_cn);
    return 0;
  }

  if(hostname == ((const char *)NULL))
    hostname = hostnames[(signed long int)0];

  addresses=myldap_get_values(entry, attmap_host_ipHostNumber);
  _Bool tmp_if_expr$4;
  if(addresses == ((const char **)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = addresses[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$4)
  {
    const char *return_value_myldap_get_dn$3;
    return_value_myldap_get_dn$3=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$3, attmap_host_ipHostNumber);
    return 0;
  }

  unsigned int return_value_htonl$5;
  return_value_htonl$5=htonl((unsigned int)(signed int)1);
  tmpint32 = (signed int)return_value_htonl$5;
  signed int return_value_tio_write$11;
  return_value_tio_write$11=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  if(!(return_value_tio_write$11 == 0))
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    if(*return_value___errno_location$10 == 32)
    {
      return_value___errno_location$6=__errno_location();
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      log_log(7, "error writing to client: %s", return_value_strerror$7);
    }

    else
    {
      return_value___errno_location$8=__errno_location();
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error writing to client: %s", return_value_strerror$9);
    }
    return -1;
  }

  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  signed int *return_value___errno_location$21;
  char *return_value_strerror$22;
  signed int *return_value___errno_location$23;
  char *return_value_strerror$24;
  signed int *return_value___errno_location$28;
  char *return_value_strerror$29;
  signed int *return_value___errno_location$30;
  char *return_value_strerror$31;
  if(hostname == ((const char *)NULL))
  {
    unsigned int return_value_htonl$12;
    return_value_htonl$12=htonl((unsigned int)(signed int)0);
    tmpint32 = (signed int)return_value_htonl$12;
    signed int return_value_tio_write$18;
    return_value_tio_write$18=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$18 == 0))
    {
      signed int *return_value___errno_location$17;
      return_value___errno_location$17=__errno_location();
      if(*return_value___errno_location$17 == 32)
      {
        return_value___errno_location$13=__errno_location();
        return_value_strerror$14=strerror(*return_value___errno_location$13);
        log_log(7, "error writing to client: %s", return_value_strerror$14);
      }

      else
      {
        return_value___errno_location$15=__errno_location();
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        log_log(4, "error writing to client: %s", return_value_strerror$16);
      }
      return -1;
    }

  }

  else
  {
    unsigned long int return_value_strlen$19;
    return_value_strlen$19=strlen(hostname);
    unsigned int return_value_htonl$20;
    return_value_htonl$20=htonl((unsigned int)(signed int)return_value_strlen$19);
    tmpint32 = (signed int)return_value_htonl$20;
    signed int return_value_tio_write$26;
    return_value_tio_write$26=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$26 == 0))
    {
      signed int *return_value___errno_location$25;
      return_value___errno_location$25=__errno_location();
      if(*return_value___errno_location$25 == 32)
      {
        return_value___errno_location$21=__errno_location();
        return_value_strerror$22=strerror(*return_value___errno_location$21);
        log_log(7, "error writing to client: %s", return_value_strerror$22);
      }

      else
      {
        return_value___errno_location$23=__errno_location();
        return_value_strerror$24=strerror(*return_value___errno_location$23);
        log_log(4, "error writing to client: %s", return_value_strerror$24);
      }
      return -1;
    }

    unsigned int return_value_ntohl$27;
    return_value_ntohl$27=ntohl((unsigned int)tmpint32);
    tmpint32 = (signed int)return_value_ntohl$27;
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_write$33;
      return_value_tio_write$33=tio_write(fp, (const void *)hostname, (unsigned long int)tmpint32);
      if(!(return_value_tio_write$33 == 0))
      {
        signed int *return_value___errno_location$32;
        return_value___errno_location$32=__errno_location();
        if(*return_value___errno_location$32 == 32)
        {
          return_value___errno_location$28=__errno_location();
          return_value_strerror$29=strerror(*return_value___errno_location$28);
          log_log(7, "error writing to client: %s", return_value_strerror$29);
        }

        else
        {
          return_value___errno_location$30=__errno_location();
          return_value_strerror$31=strerror(*return_value___errno_location$30);
          log_log(4, "error writing to client: %s", return_value_strerror$31);
        }
        return -1;
      }

    }

  }
  tmp3int32 = 0;
  tmp2int32 = 0;
  signed int return_value_strcmp$34;
  for( ; !(hostnames[(signed long int)tmp2int32] == ((const char *)NULL)); tmp2int32 = tmp2int32 + 1)
  {
    return_value_strcmp$34=strcmp(hostnames[(signed long int)tmp2int32], hostname);
    if(!(return_value_strcmp$34 == 0))
      tmp3int32 = tmp3int32 + 1;

  }
  unsigned int return_value_htonl$35;
  return_value_htonl$35=htonl((unsigned int)(signed int)tmp3int32);
  tmpint32 = (signed int)return_value_htonl$35;
  signed int return_value_tio_write$41;
  return_value_tio_write$41=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$36;
  char *return_value_strerror$37;
  signed int *return_value___errno_location$38;
  char *return_value_strerror$39;
  if(!(return_value_tio_write$41 == 0))
  {
    signed int *return_value___errno_location$40;
    return_value___errno_location$40=__errno_location();
    if(*return_value___errno_location$40 == 32)
    {
      return_value___errno_location$36=__errno_location();
      return_value_strerror$37=strerror(*return_value___errno_location$36);
      log_log(7, "error writing to client: %s", return_value_strerror$37);
    }

    else
    {
      return_value___errno_location$38=__errno_location();
      return_value_strerror$39=strerror(*return_value___errno_location$38);
      log_log(4, "error writing to client: %s", return_value_strerror$39);
    }
    return -1;
  }

  tmp2int32 = 0;
  signed int *return_value___errno_location$43;
  char *return_value_strerror$44;
  signed int *return_value___errno_location$45;
  char *return_value_strerror$46;
  signed int *return_value___errno_location$51;
  char *return_value_strerror$52;
  signed int *return_value___errno_location$53;
  char *return_value_strerror$54;
  signed int *return_value___errno_location$58;
  char *return_value_strerror$59;
  signed int *return_value___errno_location$60;
  char *return_value_strerror$61;
  for( ; !(hostnames[(signed long int)tmp2int32] == ((const char *)NULL)); tmp2int32 = tmp2int32 + 1)
  {
    signed int return_value_strcmp$64;
    return_value_strcmp$64=strcmp(hostnames[(signed long int)tmp2int32], hostname);
    if(!(return_value_strcmp$64 == 0))
    {
      if(hostnames[(signed long int)tmp2int32] == ((const char *)NULL))
      {
        unsigned int return_value_htonl$42;
        return_value_htonl$42=htonl((unsigned int)(signed int)0);
        tmpint32 = (signed int)return_value_htonl$42;
        signed int return_value_tio_write$48;
        return_value_tio_write$48=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$48 == 0))
        {
          signed int *return_value___errno_location$47;
          return_value___errno_location$47=__errno_location();
          if(*return_value___errno_location$47 == 32)
          {
            return_value___errno_location$43=__errno_location();
            return_value_strerror$44=strerror(*return_value___errno_location$43);
            log_log(7, "error writing to client: %s", return_value_strerror$44);
          }

          else
          {
            return_value___errno_location$45=__errno_location();
            return_value_strerror$46=strerror(*return_value___errno_location$45);
            log_log(4, "error writing to client: %s", return_value_strerror$46);
          }
          return -1;
        }

      }

      else
      {
        unsigned long int return_value_strlen$49;
        return_value_strlen$49=strlen(hostnames[(signed long int)tmp2int32]);
        unsigned int return_value_htonl$50;
        return_value_htonl$50=htonl((unsigned int)(signed int)return_value_strlen$49);
        tmpint32 = (signed int)return_value_htonl$50;
        signed int return_value_tio_write$56;
        return_value_tio_write$56=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$56 == 0))
        {
          signed int *return_value___errno_location$55;
          return_value___errno_location$55=__errno_location();
          if(*return_value___errno_location$55 == 32)
          {
            return_value___errno_location$51=__errno_location();
            return_value_strerror$52=strerror(*return_value___errno_location$51);
            log_log(7, "error writing to client: %s", return_value_strerror$52);
          }

          else
          {
            return_value___errno_location$53=__errno_location();
            return_value_strerror$54=strerror(*return_value___errno_location$53);
            log_log(4, "error writing to client: %s", return_value_strerror$54);
          }
          return -1;
        }

        unsigned int return_value_ntohl$57;
        return_value_ntohl$57=ntohl((unsigned int)tmpint32);
        tmpint32 = (signed int)return_value_ntohl$57;
        if(tmpint32 >= 1)
        {
          signed int return_value_tio_write$63;
          return_value_tio_write$63=tio_write(fp, (const void *)hostnames[(signed long int)tmp2int32], (unsigned long int)tmpint32);
          if(!(return_value_tio_write$63 == 0))
          {
            signed int *return_value___errno_location$62;
            return_value___errno_location$62=__errno_location();
            if(*return_value___errno_location$62 == 32)
            {
              return_value___errno_location$58=__errno_location();
              return_value_strerror$59=strerror(*return_value___errno_location$58);
              log_log(7, "error writing to client: %s", return_value_strerror$59);
            }

            else
            {
              return_value___errno_location$60=__errno_location();
              return_value_strerror$61=strerror(*return_value___errno_location$60);
              log_log(4, "error writing to client: %s", return_value_strerror$61);
            }
            return -1;
          }

        }

      }
    }

  }
  numaddr = 0;
  for( ; !(addresses[(signed long int)numaddr] == ((const char *)NULL)); numaddr = numaddr + 1)
    ;
  unsigned int return_value_htonl$65;
  return_value_htonl$65=htonl((unsigned int)(signed int)numaddr);
  tmpint32 = (signed int)return_value_htonl$65;
  signed int return_value_tio_write$71;
  return_value_tio_write$71=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$66;
  char *return_value_strerror$67;
  signed int *return_value___errno_location$68;
  char *return_value_strerror$69;
  if(!(return_value_tio_write$71 == 0))
  {
    signed int *return_value___errno_location$70;
    return_value___errno_location$70=__errno_location();
    if(*return_value___errno_location$70 == 32)
    {
      return_value___errno_location$66=__errno_location();
      return_value_strerror$67=strerror(*return_value___errno_location$66);
      log_log(7, "error writing to client: %s", return_value_strerror$67);
    }

    else
    {
      return_value___errno_location$68=__errno_location();
      return_value_strerror$69=strerror(*return_value___errno_location$68);
      log_log(4, "error writing to client: %s", return_value_strerror$69);
    }
    return -1;
  }

  i = 0;
  for( ; !(i >= numaddr); i = i + 1)
  {
    signed int return_value_write_address$72;
    return_value_write_address$72=write_address(fp, entry, attmap_host_ipHostNumber, addresses[(signed long int)i]);
    if(!(return_value_write_address$72 == 0))
      return -1;

  }
  return 0;
}

// write_netgroup
// file netgroup.c line 195
static signed int write_netgroup(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqname)
{
  signed int tmpint32;
  signed int i;
  signed int j;
  const char **names;
  const char **triples;
  const char **members;
  names=myldap_get_values(entry, attmap_netgroup_cn);
  _Bool tmp_if_expr$2;
  if(names == ((const char **)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = names[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    const char *return_value_myldap_get_dn$1;
    return_value_myldap_get_dn$1=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_netgroup_cn);
    return 0;
  }

  triples=myldap_get_values(entry, attmap_netgroup_nisNetgroupTriple);
  members=myldap_get_values(entry, attmap_netgroup_memberNisNetgroup);
  i = 0;
  _Bool tmp_if_expr$52;
  signed int tmp_if_expr$51;
  signed int return_value_strcasecmp$49;
  signed int return_value_strcmp$50;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  signed int *return_value___errno_location$21;
  char *return_value_strerror$22;
  signed int *return_value___errno_location$26;
  char *return_value_strerror$27;
  signed int *return_value___errno_location$28;
  char *return_value_strerror$29;
  signed int return_value_write_netgroup_triple$32;
  signed int *return_value___errno_location$34;
  char *return_value_strerror$35;
  signed int *return_value___errno_location$36;
  char *return_value_strerror$37;
  signed int *return_value___errno_location$43;
  char *return_value_strerror$44;
  signed int *return_value___errno_location$45;
  char *return_value_strerror$46;
  for( ; !(names[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    if(reqname == ((const char *)NULL))
      tmp_if_expr$52 = (_Bool)1;

    else
    {
      if(nslcd_cfg->ignorecase == 1)
      {
        return_value_strcasecmp$49=strcasecmp(reqname, names[(signed long int)i]);
        tmp_if_expr$51 = return_value_strcasecmp$49;
      }

      else
      {
        return_value_strcmp$50=strcmp(reqname, names[(signed long int)i]);
        tmp_if_expr$51 = return_value_strcmp$50;
      }
      tmp_if_expr$52 = tmp_if_expr$51 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$52)
    {
      unsigned int return_value_htonl$3;
      return_value_htonl$3=htonl((unsigned int)(signed int)1);
      tmpint32 = (signed int)return_value_htonl$3;
      signed int return_value_tio_write$9;
      return_value_tio_write$9=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$9 == 0))
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        if(*return_value___errno_location$8 == 32)
        {
          return_value___errno_location$4=__errno_location();
          return_value_strerror$5=strerror(*return_value___errno_location$4);
          log_log(7, "error writing to client: %s", return_value_strerror$5);
        }

        else
        {
          return_value___errno_location$6=__errno_location();
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          log_log(4, "error writing to client: %s", return_value_strerror$7);
        }
        return -1;
      }

      if(names[(signed long int)i] == ((const char *)NULL))
      {
        unsigned int return_value_htonl$10;
        return_value_htonl$10=htonl((unsigned int)(signed int)0);
        tmpint32 = (signed int)return_value_htonl$10;
        signed int return_value_tio_write$16;
        return_value_tio_write$16=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$16 == 0))
        {
          signed int *return_value___errno_location$15;
          return_value___errno_location$15=__errno_location();
          if(*return_value___errno_location$15 == 32)
          {
            return_value___errno_location$11=__errno_location();
            return_value_strerror$12=strerror(*return_value___errno_location$11);
            log_log(7, "error writing to client: %s", return_value_strerror$12);
          }

          else
          {
            return_value___errno_location$13=__errno_location();
            return_value_strerror$14=strerror(*return_value___errno_location$13);
            log_log(4, "error writing to client: %s", return_value_strerror$14);
          }
          return -1;
        }

      }

      else
      {
        unsigned long int return_value_strlen$17;
        return_value_strlen$17=strlen(names[(signed long int)i]);
        unsigned int return_value_htonl$18;
        return_value_htonl$18=htonl((unsigned int)(signed int)return_value_strlen$17);
        tmpint32 = (signed int)return_value_htonl$18;
        signed int return_value_tio_write$24;
        return_value_tio_write$24=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$24 == 0))
        {
          signed int *return_value___errno_location$23;
          return_value___errno_location$23=__errno_location();
          if(*return_value___errno_location$23 == 32)
          {
            return_value___errno_location$19=__errno_location();
            return_value_strerror$20=strerror(*return_value___errno_location$19);
            log_log(7, "error writing to client: %s", return_value_strerror$20);
          }

          else
          {
            return_value___errno_location$21=__errno_location();
            return_value_strerror$22=strerror(*return_value___errno_location$21);
            log_log(4, "error writing to client: %s", return_value_strerror$22);
          }
          return -1;
        }

        unsigned int return_value_ntohl$25;
        return_value_ntohl$25=ntohl((unsigned int)tmpint32);
        tmpint32 = (signed int)return_value_ntohl$25;
        if(tmpint32 >= 1)
        {
          signed int return_value_tio_write$31;
          return_value_tio_write$31=tio_write(fp, (const void *)names[(signed long int)i], (unsigned long int)tmpint32);
          if(!(return_value_tio_write$31 == 0))
          {
            signed int *return_value___errno_location$30;
            return_value___errno_location$30=__errno_location();
            if(*return_value___errno_location$30 == 32)
            {
              return_value___errno_location$26=__errno_location();
              return_value_strerror$27=strerror(*return_value___errno_location$26);
              log_log(7, "error writing to client: %s", return_value_strerror$27);
            }

            else
            {
              return_value___errno_location$28=__errno_location();
              return_value_strerror$29=strerror(*return_value___errno_location$28);
              log_log(4, "error writing to client: %s", return_value_strerror$29);
            }
            return -1;
          }

        }

      }
      if(!(triples == ((const char **)NULL)))
      {
        j = 0;
        for( ; !(triples[(signed long int)j] == ((const char *)NULL)); j = j + 1)
        {
          return_value_write_netgroup_triple$32=write_netgroup_triple(fp, entry, triples[(signed long int)j]);
          if(!(return_value_write_netgroup_triple$32 == 0))
            return -1;

        }
      }

      if(!(members == ((const char **)NULL)))
      {
        j = 0;
        for( ; !(members[(signed long int)j] == ((const char *)NULL)); j = j + 1)
        {
          unsigned int return_value_htonl$33;
          return_value_htonl$33=htonl((unsigned int)(signed int)1);
          tmpint32 = (signed int)return_value_htonl$33;
          signed int return_value_tio_write$39;
          return_value_tio_write$39=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$39 == 0))
          {
            signed int *return_value___errno_location$38;
            return_value___errno_location$38=__errno_location();
            if(*return_value___errno_location$38 == 32)
            {
              return_value___errno_location$34=__errno_location();
              return_value_strerror$35=strerror(*return_value___errno_location$34);
              log_log(7, "error writing to client: %s", return_value_strerror$35);
            }

            else
            {
              return_value___errno_location$36=__errno_location();
              return_value_strerror$37=strerror(*return_value___errno_location$36);
              log_log(4, "error writing to client: %s", return_value_strerror$37);
            }
            return -1;
          }

          unsigned long int return_value_strlen$40;
          return_value_strlen$40=strlen(members[(signed long int)j]);
          signed int return_value_write_string_stripspace_len$41;
          return_value_write_string_stripspace_len$41=write_string_stripspace_len(fp, members[(signed long int)j], (signed int)return_value_strlen$40);
          if(!(return_value_write_string_stripspace_len$41 == 0))
            return -1;

        }
      }

      unsigned int return_value_htonl$42;
      return_value_htonl$42=htonl((unsigned int)(signed int)3);
      tmpint32 = (signed int)return_value_htonl$42;
      signed int return_value_tio_write$48;
      return_value_tio_write$48=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$48 == 0))
      {
        signed int *return_value___errno_location$47;
        return_value___errno_location$47=__errno_location();
        if(*return_value___errno_location$47 == 32)
        {
          return_value___errno_location$43=__errno_location();
          return_value_strerror$44=strerror(*return_value___errno_location$43);
          log_log(7, "error writing to client: %s", return_value_strerror$44);
        }

        else
        {
          return_value___errno_location$45=__errno_location();
          return_value_strerror$46=strerror(*return_value___errno_location$45);
          log_log(4, "error writing to client: %s", return_value_strerror$46);
        }
        return -1;
      }

    }

  }
  return 0;
}

// write_netgroup_triple
// file netgroup.c line 126
static signed int write_netgroup_triple(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *triple)
{
  signed int tmpint32;
  signed int i;
  signed int hostb;
  signed int hoste;
  signed int userb;
  signed int usere;
  signed int domainb;
  signed int domaine;
  i = 0;
  _Bool tmp_if_expr$2;
  const unsigned short int **return_value___ctype_b_loc$1;
  do
  {
    if(!((signed int)triple[(signed long int)i] == 0))
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      tmp_if_expr$2 = ((signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)triple[(signed long int)i]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  if(!((signed int)triple[(signed long int)i] == 40))
  {
    const char *return_value_myldap_get_dn$3;
    return_value_myldap_get_dn$3=myldap_get_dn(entry);
    log_log(4, "%s: %s: does not begin with '('", return_value_myldap_get_dn$3, attmap_netgroup_nisNetgroupTriple);
    return 0;
  }

  i = i + 1;
  hostb = i;
  _Bool tmp_if_expr$4;
  do
  {
    if(!((signed int)triple[(signed long int)i] == 0))
      tmp_if_expr$4 = (signed int)triple[(signed long int)i] != 44 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(!tmp_if_expr$4)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  hoste = i;
  signed int tmp_post$6 = i;
  i = i + 1;
  if(!((signed int)triple[(signed long int)tmp_post$6] == 44))
  {
    const char *return_value_myldap_get_dn$5;
    return_value_myldap_get_dn$5=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing ','", return_value_myldap_get_dn$5, attmap_netgroup_nisNetgroupTriple);
    return 0;
  }

  userb = i;
  _Bool tmp_if_expr$7;
  do
  {
    if(!((signed int)triple[(signed long int)i] == 0))
      tmp_if_expr$7 = (signed int)triple[(signed long int)i] != 44 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$7 = (_Bool)0;
    if(!tmp_if_expr$7)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  usere = i;
  signed int tmp_post$9 = i;
  i = i + 1;
  if(!((signed int)triple[(signed long int)tmp_post$9] == 44))
  {
    const char *return_value_myldap_get_dn$8;
    return_value_myldap_get_dn$8=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing ','", return_value_myldap_get_dn$8, attmap_netgroup_nisNetgroupTriple);
    return 0;
  }

  domainb = i;
  _Bool tmp_if_expr$10;
  do
  {
    if(!((signed int)triple[(signed long int)i] == 0))
      tmp_if_expr$10 = (signed int)triple[(signed long int)i] != 41 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$10 = (_Bool)0;
    if(!tmp_if_expr$10)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  domaine = i;
  signed int tmp_post$12 = i;
  i = i + 1;
  if(!((signed int)triple[(signed long int)tmp_post$12] == 41))
  {
    const char *return_value_myldap_get_dn$11;
    return_value_myldap_get_dn$11=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing ')'", return_value_myldap_get_dn$11, attmap_netgroup_nisNetgroupTriple);
    return 0;
  }

  _Bool tmp_if_expr$14;
  const unsigned short int **return_value___ctype_b_loc$13;
  do
  {
    if(!((signed int)triple[(signed long int)i] == 0))
    {
      return_value___ctype_b_loc$13=__ctype_b_loc();
      tmp_if_expr$14 = ((signed int)(*return_value___ctype_b_loc$13)[(signed long int)(signed int)triple[(signed long int)i]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$14 = (_Bool)0;
    if(!tmp_if_expr$14)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  if(!((signed int)triple[(signed long int)i] == 0))
  {
    const char *return_value_myldap_get_dn$15;
    return_value_myldap_get_dn$15=myldap_get_dn(entry);
    log_log(4, "%s: %s: contains trailing data", return_value_myldap_get_dn$15, attmap_netgroup_nisNetgroupTriple);
    return 0;
  }

  unsigned int return_value_htonl$16;
  return_value_htonl$16=htonl((unsigned int)(signed int)2);
  tmpint32 = (signed int)return_value_htonl$16;
  signed int return_value_tio_write$22;
  return_value_tio_write$22=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  if(!(return_value_tio_write$22 == 0))
  {
    signed int *return_value___errno_location$21;
    return_value___errno_location$21=__errno_location();
    if(*return_value___errno_location$21 == 32)
    {
      return_value___errno_location$17=__errno_location();
      return_value_strerror$18=strerror(*return_value___errno_location$17);
      log_log(7, "error writing to client: %s", return_value_strerror$18);
    }

    else
    {
      return_value___errno_location$19=__errno_location();
      return_value_strerror$20=strerror(*return_value___errno_location$19);
      log_log(4, "error writing to client: %s", return_value_strerror$20);
    }
    return -1;
  }

  signed int return_value_write_string_stripspace_len$23;
  return_value_write_string_stripspace_len$23=write_string_stripspace_len(fp, triple + (signed long int)hostb, hoste - hostb);
  if(!(return_value_write_string_stripspace_len$23 == 0))
    return -1;

  else
  {
    signed int return_value_write_string_stripspace_len$24;
    return_value_write_string_stripspace_len$24=write_string_stripspace_len(fp, triple + (signed long int)userb, usere - userb);
    if(!(return_value_write_string_stripspace_len$24 == 0))
      return -1;

    else
    {
      signed int return_value_write_string_stripspace_len$25;
      return_value_write_string_stripspace_len$25=write_string_stripspace_len(fp, triple + (signed long int)domainb, domaine - domainb);
      if(!(return_value_write_string_stripspace_len$25 == 0))
        return -1;

      else
        return 0;
    }
  }
}

// write_network
// file network.c line 112
static signed int write_network(struct tio_fileinfo *fp, struct myldap_entry *entry)
{
  signed int tmpint32;
  signed int tmp2int32;
  signed int tmp3int32;
  signed int numaddr;
  signed int i;
  const char *networkname;
  const char **networknames;
  const char **addresses;
  networkname=myldap_get_rdn_value(entry, attmap_network_cn);
  networknames=myldap_get_values(entry, attmap_network_cn);
  _Bool tmp_if_expr$2;
  if(networknames == ((const char **)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = networknames[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    const char *return_value_myldap_get_dn$1;
    return_value_myldap_get_dn$1=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_network_cn);
    return 0;
  }

  if(networkname == ((const char *)NULL))
    networkname = networknames[(signed long int)0];

  addresses=myldap_get_values(entry, attmap_network_ipNetworkNumber);
  _Bool tmp_if_expr$4;
  if(addresses == ((const char **)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = addresses[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$4)
  {
    const char *return_value_myldap_get_dn$3;
    return_value_myldap_get_dn$3=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$3, attmap_network_ipNetworkNumber);
    return 0;
  }

  unsigned int return_value_htonl$5;
  return_value_htonl$5=htonl((unsigned int)(signed int)1);
  tmpint32 = (signed int)return_value_htonl$5;
  signed int return_value_tio_write$11;
  return_value_tio_write$11=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  if(!(return_value_tio_write$11 == 0))
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    if(*return_value___errno_location$10 == 32)
    {
      return_value___errno_location$6=__errno_location();
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      log_log(7, "error writing to client: %s", return_value_strerror$7);
    }

    else
    {
      return_value___errno_location$8=__errno_location();
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error writing to client: %s", return_value_strerror$9);
    }
    return -1;
  }

  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  signed int *return_value___errno_location$21;
  char *return_value_strerror$22;
  signed int *return_value___errno_location$23;
  char *return_value_strerror$24;
  signed int *return_value___errno_location$28;
  char *return_value_strerror$29;
  signed int *return_value___errno_location$30;
  char *return_value_strerror$31;
  if(networkname == ((const char *)NULL))
  {
    unsigned int return_value_htonl$12;
    return_value_htonl$12=htonl((unsigned int)(signed int)0);
    tmpint32 = (signed int)return_value_htonl$12;
    signed int return_value_tio_write$18;
    return_value_tio_write$18=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$18 == 0))
    {
      signed int *return_value___errno_location$17;
      return_value___errno_location$17=__errno_location();
      if(*return_value___errno_location$17 == 32)
      {
        return_value___errno_location$13=__errno_location();
        return_value_strerror$14=strerror(*return_value___errno_location$13);
        log_log(7, "error writing to client: %s", return_value_strerror$14);
      }

      else
      {
        return_value___errno_location$15=__errno_location();
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        log_log(4, "error writing to client: %s", return_value_strerror$16);
      }
      return -1;
    }

  }

  else
  {
    unsigned long int return_value_strlen$19;
    return_value_strlen$19=strlen(networkname);
    unsigned int return_value_htonl$20;
    return_value_htonl$20=htonl((unsigned int)(signed int)return_value_strlen$19);
    tmpint32 = (signed int)return_value_htonl$20;
    signed int return_value_tio_write$26;
    return_value_tio_write$26=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$26 == 0))
    {
      signed int *return_value___errno_location$25;
      return_value___errno_location$25=__errno_location();
      if(*return_value___errno_location$25 == 32)
      {
        return_value___errno_location$21=__errno_location();
        return_value_strerror$22=strerror(*return_value___errno_location$21);
        log_log(7, "error writing to client: %s", return_value_strerror$22);
      }

      else
      {
        return_value___errno_location$23=__errno_location();
        return_value_strerror$24=strerror(*return_value___errno_location$23);
        log_log(4, "error writing to client: %s", return_value_strerror$24);
      }
      return -1;
    }

    unsigned int return_value_ntohl$27;
    return_value_ntohl$27=ntohl((unsigned int)tmpint32);
    tmpint32 = (signed int)return_value_ntohl$27;
    if(tmpint32 >= 1)
    {
      signed int return_value_tio_write$33;
      return_value_tio_write$33=tio_write(fp, (const void *)networkname, (unsigned long int)tmpint32);
      if(!(return_value_tio_write$33 == 0))
      {
        signed int *return_value___errno_location$32;
        return_value___errno_location$32=__errno_location();
        if(*return_value___errno_location$32 == 32)
        {
          return_value___errno_location$28=__errno_location();
          return_value_strerror$29=strerror(*return_value___errno_location$28);
          log_log(7, "error writing to client: %s", return_value_strerror$29);
        }

        else
        {
          return_value___errno_location$30=__errno_location();
          return_value_strerror$31=strerror(*return_value___errno_location$30);
          log_log(4, "error writing to client: %s", return_value_strerror$31);
        }
        return -1;
      }

    }

  }
  tmp3int32 = 0;
  tmp2int32 = 0;
  signed int return_value_strcmp$34;
  for( ; !(networknames[(signed long int)tmp2int32] == ((const char *)NULL)); tmp2int32 = tmp2int32 + 1)
  {
    return_value_strcmp$34=strcmp(networknames[(signed long int)tmp2int32], networkname);
    if(!(return_value_strcmp$34 == 0))
      tmp3int32 = tmp3int32 + 1;

  }
  unsigned int return_value_htonl$35;
  return_value_htonl$35=htonl((unsigned int)(signed int)tmp3int32);
  tmpint32 = (signed int)return_value_htonl$35;
  signed int return_value_tio_write$41;
  return_value_tio_write$41=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$36;
  char *return_value_strerror$37;
  signed int *return_value___errno_location$38;
  char *return_value_strerror$39;
  if(!(return_value_tio_write$41 == 0))
  {
    signed int *return_value___errno_location$40;
    return_value___errno_location$40=__errno_location();
    if(*return_value___errno_location$40 == 32)
    {
      return_value___errno_location$36=__errno_location();
      return_value_strerror$37=strerror(*return_value___errno_location$36);
      log_log(7, "error writing to client: %s", return_value_strerror$37);
    }

    else
    {
      return_value___errno_location$38=__errno_location();
      return_value_strerror$39=strerror(*return_value___errno_location$38);
      log_log(4, "error writing to client: %s", return_value_strerror$39);
    }
    return -1;
  }

  tmp2int32 = 0;
  signed int *return_value___errno_location$43;
  char *return_value_strerror$44;
  signed int *return_value___errno_location$45;
  char *return_value_strerror$46;
  signed int *return_value___errno_location$51;
  char *return_value_strerror$52;
  signed int *return_value___errno_location$53;
  char *return_value_strerror$54;
  signed int *return_value___errno_location$58;
  char *return_value_strerror$59;
  signed int *return_value___errno_location$60;
  char *return_value_strerror$61;
  for( ; !(networknames[(signed long int)tmp2int32] == ((const char *)NULL)); tmp2int32 = tmp2int32 + 1)
  {
    signed int return_value_strcmp$64;
    return_value_strcmp$64=strcmp(networknames[(signed long int)tmp2int32], networkname);
    if(!(return_value_strcmp$64 == 0))
    {
      if(networknames[(signed long int)tmp2int32] == ((const char *)NULL))
      {
        unsigned int return_value_htonl$42;
        return_value_htonl$42=htonl((unsigned int)(signed int)0);
        tmpint32 = (signed int)return_value_htonl$42;
        signed int return_value_tio_write$48;
        return_value_tio_write$48=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$48 == 0))
        {
          signed int *return_value___errno_location$47;
          return_value___errno_location$47=__errno_location();
          if(*return_value___errno_location$47 == 32)
          {
            return_value___errno_location$43=__errno_location();
            return_value_strerror$44=strerror(*return_value___errno_location$43);
            log_log(7, "error writing to client: %s", return_value_strerror$44);
          }

          else
          {
            return_value___errno_location$45=__errno_location();
            return_value_strerror$46=strerror(*return_value___errno_location$45);
            log_log(4, "error writing to client: %s", return_value_strerror$46);
          }
          return -1;
        }

      }

      else
      {
        unsigned long int return_value_strlen$49;
        return_value_strlen$49=strlen(networknames[(signed long int)tmp2int32]);
        unsigned int return_value_htonl$50;
        return_value_htonl$50=htonl((unsigned int)(signed int)return_value_strlen$49);
        tmpint32 = (signed int)return_value_htonl$50;
        signed int return_value_tio_write$56;
        return_value_tio_write$56=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$56 == 0))
        {
          signed int *return_value___errno_location$55;
          return_value___errno_location$55=__errno_location();
          if(*return_value___errno_location$55 == 32)
          {
            return_value___errno_location$51=__errno_location();
            return_value_strerror$52=strerror(*return_value___errno_location$51);
            log_log(7, "error writing to client: %s", return_value_strerror$52);
          }

          else
          {
            return_value___errno_location$53=__errno_location();
            return_value_strerror$54=strerror(*return_value___errno_location$53);
            log_log(4, "error writing to client: %s", return_value_strerror$54);
          }
          return -1;
        }

        unsigned int return_value_ntohl$57;
        return_value_ntohl$57=ntohl((unsigned int)tmpint32);
        tmpint32 = (signed int)return_value_ntohl$57;
        if(tmpint32 >= 1)
        {
          signed int return_value_tio_write$63;
          return_value_tio_write$63=tio_write(fp, (const void *)networknames[(signed long int)tmp2int32], (unsigned long int)tmpint32);
          if(!(return_value_tio_write$63 == 0))
          {
            signed int *return_value___errno_location$62;
            return_value___errno_location$62=__errno_location();
            if(*return_value___errno_location$62 == 32)
            {
              return_value___errno_location$58=__errno_location();
              return_value_strerror$59=strerror(*return_value___errno_location$58);
              log_log(7, "error writing to client: %s", return_value_strerror$59);
            }

            else
            {
              return_value___errno_location$60=__errno_location();
              return_value_strerror$61=strerror(*return_value___errno_location$60);
              log_log(4, "error writing to client: %s", return_value_strerror$61);
            }
            return -1;
          }

        }

      }
    }

  }
  numaddr = 0;
  for( ; !(addresses[(signed long int)numaddr] == ((const char *)NULL)); numaddr = numaddr + 1)
    ;
  unsigned int return_value_htonl$65;
  return_value_htonl$65=htonl((unsigned int)(signed int)numaddr);
  tmpint32 = (signed int)return_value_htonl$65;
  signed int return_value_tio_write$71;
  return_value_tio_write$71=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$66;
  char *return_value_strerror$67;
  signed int *return_value___errno_location$68;
  char *return_value_strerror$69;
  if(!(return_value_tio_write$71 == 0))
  {
    signed int *return_value___errno_location$70;
    return_value___errno_location$70=__errno_location();
    if(*return_value___errno_location$70 == 32)
    {
      return_value___errno_location$66=__errno_location();
      return_value_strerror$67=strerror(*return_value___errno_location$66);
      log_log(7, "error writing to client: %s", return_value_strerror$67);
    }

    else
    {
      return_value___errno_location$68=__errno_location();
      return_value_strerror$69=strerror(*return_value___errno_location$68);
      log_log(4, "error writing to client: %s", return_value_strerror$69);
    }
    return -1;
  }

  i = 0;
  for( ; !(i >= numaddr); i = i + 1)
  {
    signed int return_value_write_address$72;
    return_value_write_address$72=write_address(fp, entry, attmap_network_ipNetworkNumber, addresses[(signed long int)i]);
    if(!(return_value_write_address$72 == 0))
      return -1;

  }
  return 0;
}

// write_passwd
// file passwd.c line 410
static signed int write_passwd(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *requser, const unsigned int *requid, unsigned int calleruid)
{
  signed int tmpint32;
  const char **tmpvalues;
  char *tmp;
  const char **usernames;
  const char *passwd;
  unsigned int uids[5l];
  signed int numuids;
  char gidbuf[32l];
  unsigned int gid;
  char gecos[1024l];
  char homedir[256l];
  char shell[64l];
  char passbuffer[256l];
  signed int i;
  signed int j;
  usernames=myldap_get_values(entry, attmap_passwd_uid);
  _Bool tmp_if_expr$2;
  if(usernames == ((const char **)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = usernames[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    const char *return_value_myldap_get_dn$1;
    return_value_myldap_get_dn$1=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_passwd_uid);
    return 0;
  }

  signed int return_value_myldap_has_objectclass$3;
  return_value_myldap_has_objectclass$3=myldap_has_objectclass(entry, "shadowAccount");
  _Bool tmp_if_expr$5;
  signed int return_value_nsswitch_shadow_uses_ldap$4;
  if(!(return_value_myldap_has_objectclass$3 == 0))
  {
    return_value_nsswitch_shadow_uses_ldap$4=nsswitch_shadow_uses_ldap();
    tmp_if_expr$5 = return_value_nsswitch_shadow_uses_ldap$4 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$5 = (_Bool)0;
  if(tmp_if_expr$5)
    passwd = "x";

  else
  {
    passwd=get_userpassword(entry, attmap_passwd_userPassword, passbuffer, sizeof(char [256l]) /*256ul*/ );
    if(passwd == ((const char *)NULL) || !(calleruid == 0u))
      passwd = default_passwd_userPassword;

  }
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  unsigned long int return_value_binsid2id$9;
  _Bool tmp_if_expr$17;
  signed int *return_value___errno_location$14;
  _Bool tmp_if_expr$16;
  char *return_value_strchr$15;
  if(!(requid == ((const unsigned int *)NULL)))
  {
    uids[(signed long int)0] = *requid;
    numuids = 1;
  }

  else
  {
    tmpvalues=myldap_get_values_len(entry, attmap_passwd_uidNumber);
    if(tmpvalues == ((const char **)NULL))
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = tmpvalues[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
    {
      const char *return_value_myldap_get_dn$6;
      return_value_myldap_get_dn$6=myldap_get_dn(entry);
      log_log(4, "%s: %s: missing", return_value_myldap_get_dn$6, attmap_passwd_uidNumber);
      return 0;
    }

    numuids = 0;
    do
    {
      if(!(numuids >= 5))
        tmp_if_expr$8 = tmpvalues[(signed long int)numuids] != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$8 = (_Bool)0;
      if(!tmp_if_expr$8)
        break;

      if(!(uidSid == ((char *)NULL)))
      {
        return_value_binsid2id$9=binsid2id(tmpvalues[(signed long int)numuids]);
        uids[(signed long int)numuids] = (unsigned int)return_value_binsid2id$9;
      }

      else
      {
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        *return_value___errno_location$10 = 0;
        unsigned int return_value_strtoui$11;
        return_value_strtoui$11=strtoui(tmpvalues[(signed long int)numuids], &tmp, 10);
        uids[(signed long int)numuids] = (unsigned int)return_value_strtoui$11;
        if((signed int)*tmpvalues[(signed long int)numuids] == 0)
          tmp_if_expr$17 = (_Bool)1;

        else
          tmp_if_expr$17 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$17)
        {
          const char *return_value_myldap_get_dn$12;
          return_value_myldap_get_dn$12=myldap_get_dn(entry);
          log_log(4, "%s: %s: non-numeric", return_value_myldap_get_dn$12, attmap_passwd_uidNumber);
          return 0;
        }

        else
        {
          return_value___errno_location$14=__errno_location();
          if(!(*return_value___errno_location$14 == 0))
            tmp_if_expr$16 = (_Bool)1;

          else
          {
            return_value_strchr$15=strchr(tmpvalues[(signed long int)numuids], 45);
            tmp_if_expr$16 = return_value_strchr$15 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$16)
          {
            const char *return_value_myldap_get_dn$13;
            return_value_myldap_get_dn$13=myldap_get_dn(entry);
            log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$13, attmap_passwd_uidNumber);
            return 0;
          }

        }
      }
      numuids = numuids + 1;
    }
    while((_Bool)1);
  }
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$29;
  signed int *return_value___errno_location$26;
  _Bool tmp_if_expr$28;
  char *return_value_strchr$27;
  if(!(gidSid$link1 == ((char *)NULL)))
  {
    tmpvalues=myldap_get_values_len(entry, attmap_passwd_gidNumber);
    if(tmpvalues == ((const char **)NULL))
      tmp_if_expr$19 = (_Bool)1;

    else
      tmp_if_expr$19 = tmpvalues[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$19)
    {
      const char *return_value_myldap_get_dn$18;
      return_value_myldap_get_dn$18=myldap_get_dn(entry);
      log_log(4, "%s: %s: missing", return_value_myldap_get_dn$18, attmap_passwd_gidNumber);
      return 0;
    }

    unsigned long int return_value_binsid2id$20;
    return_value_binsid2id$20=binsid2id(tmpvalues[(signed long int)0]);
    gid = (unsigned int)return_value_binsid2id$20;
  }

  else
  {
    attmap_get_value(entry, attmap_passwd_gidNumber, gidbuf, sizeof(char [32l]) /*32ul*/ );
    if((signed int)gidbuf[0l] == 0)
    {
      const char *return_value_myldap_get_dn$21;
      return_value_myldap_get_dn$21=myldap_get_dn(entry);
      log_log(4, "%s: %s: missing", return_value_myldap_get_dn$21, attmap_passwd_gidNumber);
      return 0;
    }

    signed int *return_value___errno_location$22;
    return_value___errno_location$22=__errno_location();
    *return_value___errno_location$22 = 0;
    unsigned int return_value_strtoui$23;
    return_value_strtoui$23=strtoui(gidbuf, &tmp, 10);
    gid = (unsigned int)return_value_strtoui$23;
    if((signed int)gidbuf[0l] == 0)
      tmp_if_expr$29 = (_Bool)1;

    else
      tmp_if_expr$29 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$29)
    {
      const char *return_value_myldap_get_dn$24;
      return_value_myldap_get_dn$24=myldap_get_dn(entry);
      log_log(4, "%s: %s: non-numeric", return_value_myldap_get_dn$24, attmap_passwd_gidNumber);
      return 0;
    }

    else
    {
      return_value___errno_location$26=__errno_location();
      if(!(*return_value___errno_location$26 == 0))
        tmp_if_expr$28 = (_Bool)1;

      else
      {
        return_value_strchr$27=strchr(gidbuf, 45);
        tmp_if_expr$28 = return_value_strchr$27 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$28)
      {
        const char *return_value_myldap_get_dn$25;
        return_value_myldap_get_dn$25=myldap_get_dn(entry);
        log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$25, attmap_passwd_gidNumber);
        return 0;
      }

    }
  }
  attmap_get_value(entry, attmap_passwd_gecos, gecos, sizeof(char [1024l]) /*1024ul*/ );
  attmap_get_value(entry, attmap_passwd_homeDirectory, homedir, sizeof(char [256l]) /*256ul*/ );
  const char *return_value_myldap_get_dn$30;
  if((signed int)homedir[0l] == 0)
  {
    return_value_myldap_get_dn$30=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$30, attmap_passwd_homeDirectory);
  }

  attmap_get_value(entry, attmap_passwd_loginShell, shell, sizeof(char [64l]) /*64ul*/ );
  i = 0;
  _Bool tmp_if_expr$167;
  signed int tmp_if_expr$166;
  signed int return_value_strcasecmp$164;
  signed int return_value_strcmp$165;
  signed int *return_value___errno_location$33;
  char *return_value_strerror$34;
  signed int *return_value___errno_location$35;
  char *return_value_strerror$36;
  signed int *return_value___errno_location$40;
  char *return_value_strerror$41;
  signed int *return_value___errno_location$42;
  char *return_value_strerror$43;
  signed int *return_value___errno_location$48;
  char *return_value_strerror$49;
  signed int *return_value___errno_location$50;
  char *return_value_strerror$51;
  signed int *return_value___errno_location$55;
  char *return_value_strerror$56;
  signed int *return_value___errno_location$57;
  char *return_value_strerror$58;
  signed int *return_value___errno_location$62;
  char *return_value_strerror$63;
  signed int *return_value___errno_location$64;
  char *return_value_strerror$65;
  signed int *return_value___errno_location$70;
  char *return_value_strerror$71;
  signed int *return_value___errno_location$72;
  char *return_value_strerror$73;
  signed int *return_value___errno_location$77;
  char *return_value_strerror$78;
  signed int *return_value___errno_location$79;
  char *return_value_strerror$80;
  signed int *return_value___errno_location$84;
  char *return_value_strerror$85;
  signed int *return_value___errno_location$86;
  char *return_value_strerror$87;
  signed int *return_value___errno_location$91;
  char *return_value_strerror$92;
  signed int *return_value___errno_location$93;
  char *return_value_strerror$94;
  signed int *return_value___errno_location$98;
  char *return_value_strerror$99;
  signed int *return_value___errno_location$100;
  char *return_value_strerror$101;
  signed int *return_value___errno_location$106;
  char *return_value_strerror$107;
  signed int *return_value___errno_location$108;
  char *return_value_strerror$109;
  signed int *return_value___errno_location$113;
  char *return_value_strerror$114;
  signed int *return_value___errno_location$115;
  char *return_value_strerror$116;
  signed int *return_value___errno_location$120;
  char *return_value_strerror$121;
  signed int *return_value___errno_location$122;
  char *return_value_strerror$123;
  signed int *return_value___errno_location$128;
  char *return_value_strerror$129;
  signed int *return_value___errno_location$130;
  char *return_value_strerror$131;
  signed int *return_value___errno_location$135;
  char *return_value_strerror$136;
  signed int *return_value___errno_location$137;
  char *return_value_strerror$138;
  signed int *return_value___errno_location$142;
  char *return_value_strerror$143;
  signed int *return_value___errno_location$144;
  char *return_value_strerror$145;
  signed int *return_value___errno_location$150;
  char *return_value_strerror$151;
  signed int *return_value___errno_location$152;
  char *return_value_strerror$153;
  signed int *return_value___errno_location$157;
  char *return_value_strerror$158;
  signed int *return_value___errno_location$159;
  char *return_value_strerror$160;
  for( ; !(usernames[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    if(requser == ((const char *)NULL))
      tmp_if_expr$167 = (_Bool)1;

    else
    {
      if(nslcd_cfg->ignorecase == 1)
      {
        return_value_strcasecmp$164=strcasecmp(requser, usernames[(signed long int)i]);
        tmp_if_expr$166 = return_value_strcasecmp$164;
      }

      else
      {
        return_value_strcmp$165=strcmp(requser, usernames[(signed long int)i]);
        tmp_if_expr$166 = return_value_strcmp$165;
      }
      tmp_if_expr$167 = tmp_if_expr$166 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$167)
    {
      signed int return_value_isvalidname$163;
      return_value_isvalidname$163=isvalidname(usernames[(signed long int)i]);
      if(return_value_isvalidname$163 == 0)
      {
        const char *return_value_myldap_get_dn$31;
        return_value_myldap_get_dn$31=myldap_get_dn(entry);
        log_log(4, "%s: %s: denied by validnames option", return_value_myldap_get_dn$31, attmap_passwd_uid);
      }

      else
      {
        j = 0;
        for( ; !(j >= numuids); j = j + 1)
          if(uids[(signed long int)j] >= nslcd_cfg->nss_min_uid)
          {
            unsigned int return_value_htonl$32;
            return_value_htonl$32=htonl((unsigned int)(signed int)1);
            tmpint32 = (signed int)return_value_htonl$32;
            signed int return_value_tio_write$38;
            return_value_tio_write$38=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$38 == 0))
            {
              signed int *return_value___errno_location$37;
              return_value___errno_location$37=__errno_location();
              if(*return_value___errno_location$37 == 32)
              {
                return_value___errno_location$33=__errno_location();
                return_value_strerror$34=strerror(*return_value___errno_location$33);
                log_log(7, "error writing to client: %s", return_value_strerror$34);
              }

              else
              {
                return_value___errno_location$35=__errno_location();
                return_value_strerror$36=strerror(*return_value___errno_location$35);
                log_log(4, "error writing to client: %s", return_value_strerror$36);
              }
              return -1;
            }

            if(usernames[(signed long int)i] == ((const char *)NULL))
            {
              unsigned int return_value_htonl$39;
              return_value_htonl$39=htonl((unsigned int)(signed int)0);
              tmpint32 = (signed int)return_value_htonl$39;
              signed int return_value_tio_write$45;
              return_value_tio_write$45=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$45 == 0))
              {
                signed int *return_value___errno_location$44;
                return_value___errno_location$44=__errno_location();
                if(*return_value___errno_location$44 == 32)
                {
                  return_value___errno_location$40=__errno_location();
                  return_value_strerror$41=strerror(*return_value___errno_location$40);
                  log_log(7, "error writing to client: %s", return_value_strerror$41);
                }

                else
                {
                  return_value___errno_location$42=__errno_location();
                  return_value_strerror$43=strerror(*return_value___errno_location$42);
                  log_log(4, "error writing to client: %s", return_value_strerror$43);
                }
                return -1;
              }

            }

            else
            {
              unsigned long int return_value_strlen$46;
              return_value_strlen$46=strlen(usernames[(signed long int)i]);
              unsigned int return_value_htonl$47;
              return_value_htonl$47=htonl((unsigned int)(signed int)return_value_strlen$46);
              tmpint32 = (signed int)return_value_htonl$47;
              signed int return_value_tio_write$53;
              return_value_tio_write$53=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$53 == 0))
              {
                signed int *return_value___errno_location$52;
                return_value___errno_location$52=__errno_location();
                if(*return_value___errno_location$52 == 32)
                {
                  return_value___errno_location$48=__errno_location();
                  return_value_strerror$49=strerror(*return_value___errno_location$48);
                  log_log(7, "error writing to client: %s", return_value_strerror$49);
                }

                else
                {
                  return_value___errno_location$50=__errno_location();
                  return_value_strerror$51=strerror(*return_value___errno_location$50);
                  log_log(4, "error writing to client: %s", return_value_strerror$51);
                }
                return -1;
              }

              unsigned int return_value_ntohl$54;
              return_value_ntohl$54=ntohl((unsigned int)tmpint32);
              tmpint32 = (signed int)return_value_ntohl$54;
              if(tmpint32 >= 1)
              {
                signed int return_value_tio_write$60;
                return_value_tio_write$60=tio_write(fp, (const void *)usernames[(signed long int)i], (unsigned long int)tmpint32);
                if(!(return_value_tio_write$60 == 0))
                {
                  signed int *return_value___errno_location$59;
                  return_value___errno_location$59=__errno_location();
                  if(*return_value___errno_location$59 == 32)
                  {
                    return_value___errno_location$55=__errno_location();
                    return_value_strerror$56=strerror(*return_value___errno_location$55);
                    log_log(7, "error writing to client: %s", return_value_strerror$56);
                  }

                  else
                  {
                    return_value___errno_location$57=__errno_location();
                    return_value_strerror$58=strerror(*return_value___errno_location$57);
                    log_log(4, "error writing to client: %s", return_value_strerror$58);
                  }
                  return -1;
                }

              }

            }
            if(passwd == ((const char *)NULL))
            {
              unsigned int return_value_htonl$61;
              return_value_htonl$61=htonl((unsigned int)(signed int)0);
              tmpint32 = (signed int)return_value_htonl$61;
              signed int return_value_tio_write$67;
              return_value_tio_write$67=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$67 == 0))
              {
                signed int *return_value___errno_location$66;
                return_value___errno_location$66=__errno_location();
                if(*return_value___errno_location$66 == 32)
                {
                  return_value___errno_location$62=__errno_location();
                  return_value_strerror$63=strerror(*return_value___errno_location$62);
                  log_log(7, "error writing to client: %s", return_value_strerror$63);
                }

                else
                {
                  return_value___errno_location$64=__errno_location();
                  return_value_strerror$65=strerror(*return_value___errno_location$64);
                  log_log(4, "error writing to client: %s", return_value_strerror$65);
                }
                return -1;
              }

            }

            else
            {
              unsigned long int return_value_strlen$68;
              return_value_strlen$68=strlen(passwd);
              unsigned int return_value_htonl$69;
              return_value_htonl$69=htonl((unsigned int)(signed int)return_value_strlen$68);
              tmpint32 = (signed int)return_value_htonl$69;
              signed int return_value_tio_write$75;
              return_value_tio_write$75=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$75 == 0))
              {
                signed int *return_value___errno_location$74;
                return_value___errno_location$74=__errno_location();
                if(*return_value___errno_location$74 == 32)
                {
                  return_value___errno_location$70=__errno_location();
                  return_value_strerror$71=strerror(*return_value___errno_location$70);
                  log_log(7, "error writing to client: %s", return_value_strerror$71);
                }

                else
                {
                  return_value___errno_location$72=__errno_location();
                  return_value_strerror$73=strerror(*return_value___errno_location$72);
                  log_log(4, "error writing to client: %s", return_value_strerror$73);
                }
                return -1;
              }

              unsigned int return_value_ntohl$76;
              return_value_ntohl$76=ntohl((unsigned int)tmpint32);
              tmpint32 = (signed int)return_value_ntohl$76;
              if(tmpint32 >= 1)
              {
                signed int return_value_tio_write$82;
                return_value_tio_write$82=tio_write(fp, (const void *)passwd, (unsigned long int)tmpint32);
                if(!(return_value_tio_write$82 == 0))
                {
                  signed int *return_value___errno_location$81;
                  return_value___errno_location$81=__errno_location();
                  if(*return_value___errno_location$81 == 32)
                  {
                    return_value___errno_location$77=__errno_location();
                    return_value_strerror$78=strerror(*return_value___errno_location$77);
                    log_log(7, "error writing to client: %s", return_value_strerror$78);
                  }

                  else
                  {
                    return_value___errno_location$79=__errno_location();
                    return_value_strerror$80=strerror(*return_value___errno_location$79);
                    log_log(4, "error writing to client: %s", return_value_strerror$80);
                  }
                  return -1;
                }

              }

            }
            unsigned int return_value_htonl$83;
            return_value_htonl$83=htonl((unsigned int)(signed int)uids[(signed long int)j]);
            tmpint32 = (signed int)return_value_htonl$83;
            signed int return_value_tio_write$89;
            return_value_tio_write$89=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$89 == 0))
            {
              signed int *return_value___errno_location$88;
              return_value___errno_location$88=__errno_location();
              if(*return_value___errno_location$88 == 32)
              {
                return_value___errno_location$84=__errno_location();
                return_value_strerror$85=strerror(*return_value___errno_location$84);
                log_log(7, "error writing to client: %s", return_value_strerror$85);
              }

              else
              {
                return_value___errno_location$86=__errno_location();
                return_value_strerror$87=strerror(*return_value___errno_location$86);
                log_log(4, "error writing to client: %s", return_value_strerror$87);
              }
              return -1;
            }

            unsigned int return_value_htonl$90;
            return_value_htonl$90=htonl((unsigned int)(signed int)gid);
            tmpint32 = (signed int)return_value_htonl$90;
            signed int return_value_tio_write$96;
            return_value_tio_write$96=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_tio_write$96 == 0))
            {
              signed int *return_value___errno_location$95;
              return_value___errno_location$95=__errno_location();
              if(*return_value___errno_location$95 == 32)
              {
                return_value___errno_location$91=__errno_location();
                return_value_strerror$92=strerror(*return_value___errno_location$91);
                log_log(7, "error writing to client: %s", return_value_strerror$92);
              }

              else
              {
                return_value___errno_location$93=__errno_location();
                return_value_strerror$94=strerror(*return_value___errno_location$93);
                log_log(4, "error writing to client: %s", return_value_strerror$94);
              }
              return -1;
            }

            {
              unsigned long int return_value_strlen$104;
              return_value_strlen$104=strlen(gecos);
              unsigned int return_value_htonl$105;
              return_value_htonl$105=htonl((unsigned int)(signed int)return_value_strlen$104);
              tmpint32 = (signed int)return_value_htonl$105;
              signed int return_value_tio_write$111;
              return_value_tio_write$111=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$111 == 0))
              {
                signed int *return_value___errno_location$110;
                return_value___errno_location$110=__errno_location();
                if(*return_value___errno_location$110 == 32)
                {
                  return_value___errno_location$106=__errno_location();
                  return_value_strerror$107=strerror(*return_value___errno_location$106);
                  log_log(7, "error writing to client: %s", return_value_strerror$107);
                }

                else
                {
                  return_value___errno_location$108=__errno_location();
                  return_value_strerror$109=strerror(*return_value___errno_location$108);
                  log_log(4, "error writing to client: %s", return_value_strerror$109);
                }
                return -1;
              }

              unsigned int return_value_ntohl$112;
              return_value_ntohl$112=ntohl((unsigned int)tmpint32);
              tmpint32 = (signed int)return_value_ntohl$112;
              if(tmpint32 >= 1)
              {
                signed int return_value_tio_write$118;
                return_value_tio_write$118=tio_write(fp, (const void *)gecos, (unsigned long int)tmpint32);
                if(!(return_value_tio_write$118 == 0))
                {
                  signed int *return_value___errno_location$117;
                  return_value___errno_location$117=__errno_location();
                  if(*return_value___errno_location$117 == 32)
                  {
                    return_value___errno_location$113=__errno_location();
                    return_value_strerror$114=strerror(*return_value___errno_location$113);
                    log_log(7, "error writing to client: %s", return_value_strerror$114);
                  }

                  else
                  {
                    return_value___errno_location$115=__errno_location();
                    return_value_strerror$116=strerror(*return_value___errno_location$115);
                    log_log(4, "error writing to client: %s", return_value_strerror$116);
                  }
                  return -1;
                }

              }

            }
            {
              unsigned long int return_value_strlen$126;
              return_value_strlen$126=strlen(homedir);
              unsigned int return_value_htonl$127;
              return_value_htonl$127=htonl((unsigned int)(signed int)return_value_strlen$126);
              tmpint32 = (signed int)return_value_htonl$127;
              signed int return_value_tio_write$133;
              return_value_tio_write$133=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$133 == 0))
              {
                signed int *return_value___errno_location$132;
                return_value___errno_location$132=__errno_location();
                if(*return_value___errno_location$132 == 32)
                {
                  return_value___errno_location$128=__errno_location();
                  return_value_strerror$129=strerror(*return_value___errno_location$128);
                  log_log(7, "error writing to client: %s", return_value_strerror$129);
                }

                else
                {
                  return_value___errno_location$130=__errno_location();
                  return_value_strerror$131=strerror(*return_value___errno_location$130);
                  log_log(4, "error writing to client: %s", return_value_strerror$131);
                }
                return -1;
              }

              unsigned int return_value_ntohl$134;
              return_value_ntohl$134=ntohl((unsigned int)tmpint32);
              tmpint32 = (signed int)return_value_ntohl$134;
              if(tmpint32 >= 1)
              {
                signed int return_value_tio_write$140;
                return_value_tio_write$140=tio_write(fp, (const void *)homedir, (unsigned long int)tmpint32);
                if(!(return_value_tio_write$140 == 0))
                {
                  signed int *return_value___errno_location$139;
                  return_value___errno_location$139=__errno_location();
                  if(*return_value___errno_location$139 == 32)
                  {
                    return_value___errno_location$135=__errno_location();
                    return_value_strerror$136=strerror(*return_value___errno_location$135);
                    log_log(7, "error writing to client: %s", return_value_strerror$136);
                  }

                  else
                  {
                    return_value___errno_location$137=__errno_location();
                    return_value_strerror$138=strerror(*return_value___errno_location$137);
                    log_log(4, "error writing to client: %s", return_value_strerror$138);
                  }
                  return -1;
                }

              }

            }
            {
              unsigned long int return_value_strlen$148;
              return_value_strlen$148=strlen(shell);
              unsigned int return_value_htonl$149;
              return_value_htonl$149=htonl((unsigned int)(signed int)return_value_strlen$148);
              tmpint32 = (signed int)return_value_htonl$149;
              signed int return_value_tio_write$155;
              return_value_tio_write$155=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$155 == 0))
              {
                signed int *return_value___errno_location$154;
                return_value___errno_location$154=__errno_location();
                if(*return_value___errno_location$154 == 32)
                {
                  return_value___errno_location$150=__errno_location();
                  return_value_strerror$151=strerror(*return_value___errno_location$150);
                  log_log(7, "error writing to client: %s", return_value_strerror$151);
                }

                else
                {
                  return_value___errno_location$152=__errno_location();
                  return_value_strerror$153=strerror(*return_value___errno_location$152);
                  log_log(4, "error writing to client: %s", return_value_strerror$153);
                }
                return -1;
              }

              unsigned int return_value_ntohl$156;
              return_value_ntohl$156=ntohl((unsigned int)tmpint32);
              tmpint32 = (signed int)return_value_ntohl$156;
              if(tmpint32 >= 1)
              {
                signed int return_value_tio_write$162;
                return_value_tio_write$162=tio_write(fp, (const void *)shell, (unsigned long int)tmpint32);
                if(!(return_value_tio_write$162 == 0))
                {
                  signed int *return_value___errno_location$161;
                  return_value___errno_location$161=__errno_location();
                  if(*return_value___errno_location$161 == 32)
                  {
                    return_value___errno_location$157=__errno_location();
                    return_value_strerror$158=strerror(*return_value___errno_location$157);
                    log_log(7, "error writing to client: %s", return_value_strerror$158);
                  }

                  else
                  {
                    return_value___errno_location$159=__errno_location();
                    return_value_strerror$160=strerror(*return_value___errno_location$159);
                    log_log(4, "error writing to client: %s", return_value_strerror$160);
                  }
                  return -1;
                }

              }

            }
          }

      }
    }

  }
  return 0;
}

// write_protocol
// file protocol.c line 105
static signed int write_protocol(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqname)
{
  signed int tmpint32;
  signed int tmp2int32;
  signed int tmp3int32;
  const char *name;
  const char **aliases;
  const char **protos;
  char *tmp;
  signed long int proto;
  signed int i;
  name=myldap_get_rdn_value(entry, attmap_protocol_cn);
  aliases=myldap_get_values(entry, attmap_protocol_cn);
  _Bool tmp_if_expr$2;
  if(aliases == ((const char **)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = aliases[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    const char *return_value_myldap_get_dn$1;
    return_value_myldap_get_dn$1=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_protocol_cn);
    return 0;
  }

  if(name == ((const char *)NULL))
    name = aliases[(signed long int)0];

  signed int tmp_if_expr$9;
  signed int return_value_strcasecmp$7;
  signed int return_value_strcmp$8;
  _Bool tmp_if_expr$6;
  signed int tmp_if_expr$5;
  signed int return_value_strcasecmp$3;
  signed int return_value_strcmp$4;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$17;
  signed int *return_value___errno_location$16;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  signed int *return_value___errno_location$21;
  char *return_value_strerror$22;
  signed int *return_value___errno_location$26;
  char *return_value_strerror$27;
  signed int *return_value___errno_location$28;
  char *return_value_strerror$29;
  signed int *return_value___errno_location$34;
  char *return_value_strerror$35;
  signed int *return_value___errno_location$36;
  char *return_value_strerror$37;
  signed int *return_value___errno_location$41;
  char *return_value_strerror$42;
  signed int *return_value___errno_location$43;
  char *return_value_strerror$44;
  signed int return_value_strcmp$47;
  signed int *return_value___errno_location$49;
  char *return_value_strerror$50;
  signed int *return_value___errno_location$51;
  char *return_value_strerror$52;
  signed int *return_value___errno_location$56;
  char *return_value_strerror$57;
  signed int *return_value___errno_location$58;
  char *return_value_strerror$59;
  signed int *return_value___errno_location$64;
  char *return_value_strerror$65;
  signed int *return_value___errno_location$66;
  char *return_value_strerror$67;
  signed int *return_value___errno_location$71;
  char *return_value_strerror$72;
  signed int *return_value___errno_location$73;
  char *return_value_strerror$74;
  signed int *return_value___errno_location$79;
  char *return_value_strerror$80;
  signed int *return_value___errno_location$81;
  char *return_value_strerror$82;
  if(!(reqname == ((const char *)NULL)))
  {
    if(nslcd_cfg->ignorecase == 1)
    {
      return_value_strcasecmp$7=strcasecmp(reqname, name);
      tmp_if_expr$9 = return_value_strcasecmp$7;
    }

    else
    {
      return_value_strcmp$8=strcmp(reqname, name);
      tmp_if_expr$9 = return_value_strcmp$8;
    }
    if(tmp_if_expr$9 == 0)
      goto __CPROVER_DUMP_L13;

    i = 0;
    do
    {
      if(!(aliases[(signed long int)i] == ((const char *)NULL)))
      {
        if(nslcd_cfg->ignorecase == 1)
        {
          return_value_strcasecmp$3=strcasecmp(reqname, aliases[(signed long int)i]);
          tmp_if_expr$5 = return_value_strcasecmp$3;
        }

        else
        {
          return_value_strcmp$4=strcmp(reqname, aliases[(signed long int)i]);
          tmp_if_expr$5 = return_value_strcmp$4;
        }
        tmp_if_expr$6 = tmp_if_expr$5 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      if(!tmp_if_expr$6)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    if(!(aliases[(signed long int)i] == ((const char *)NULL)))
      goto __CPROVER_DUMP_L13;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L13:
    ;
    protos=myldap_get_values(entry, attmap_protocol_ipProtocolNumber);
    if(protos == ((const char **)NULL))
      tmp_if_expr$12 = (_Bool)1;

    else
      tmp_if_expr$12 = protos[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$12)
    {
      const char *return_value_myldap_get_dn$10;
      return_value_myldap_get_dn$10=myldap_get_dn(entry);
      log_log(4, "%s: %s: missing", return_value_myldap_get_dn$10, attmap_protocol_ipProtocolNumber);
      return 0;
    }

    else
      if(!(protos[1l] == ((const char *)NULL)))
      {
        const char *return_value_myldap_get_dn$11;
        return_value_myldap_get_dn$11=myldap_get_dn(entry);
        log_log(4, "%s: %s: multiple values", return_value_myldap_get_dn$11, attmap_protocol_ipProtocolNumber);
      }

    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    *return_value___errno_location$13 = 0;
    proto=strtol(protos[(signed long int)0], &tmp, 10);
    if((signed int)*(*protos) == 0)
      tmp_if_expr$17 = (_Bool)1;

    else
      tmp_if_expr$17 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$17)
    {
      const char *return_value_myldap_get_dn$14;
      return_value_myldap_get_dn$14=myldap_get_dn(entry);
      log_log(4, "%s: %s: non-numeric", return_value_myldap_get_dn$14, attmap_protocol_ipProtocolNumber);
      return 0;
    }

    else
    {
      return_value___errno_location$16=__errno_location();
      if(proto >= 256l || !(*return_value___errno_location$16 == 0) || !(proto >= 0l))
      {
        const char *return_value_myldap_get_dn$15;
        return_value_myldap_get_dn$15=myldap_get_dn(entry);
        log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$15, attmap_protocol_ipProtocolNumber);
        return 0;
      }

    }
    unsigned int return_value_htonl$18;
    return_value_htonl$18=htonl((unsigned int)(signed int)1);
    tmpint32 = (signed int)return_value_htonl$18;
    signed int return_value_tio_write$24;
    return_value_tio_write$24=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$24 == 0))
    {
      signed int *return_value___errno_location$23;
      return_value___errno_location$23=__errno_location();
      if(*return_value___errno_location$23 == 32)
      {
        return_value___errno_location$19=__errno_location();
        return_value_strerror$20=strerror(*return_value___errno_location$19);
        log_log(7, "error writing to client: %s", return_value_strerror$20);
      }

      else
      {
        return_value___errno_location$21=__errno_location();
        return_value_strerror$22=strerror(*return_value___errno_location$21);
        log_log(4, "error writing to client: %s", return_value_strerror$22);
      }
      return -1;
    }

    if(name == ((const char *)NULL))
    {
      unsigned int return_value_htonl$25;
      return_value_htonl$25=htonl((unsigned int)(signed int)0);
      tmpint32 = (signed int)return_value_htonl$25;
      signed int return_value_tio_write$31;
      return_value_tio_write$31=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$31 == 0))
      {
        signed int *return_value___errno_location$30;
        return_value___errno_location$30=__errno_location();
        if(*return_value___errno_location$30 == 32)
        {
          return_value___errno_location$26=__errno_location();
          return_value_strerror$27=strerror(*return_value___errno_location$26);
          log_log(7, "error writing to client: %s", return_value_strerror$27);
        }

        else
        {
          return_value___errno_location$28=__errno_location();
          return_value_strerror$29=strerror(*return_value___errno_location$28);
          log_log(4, "error writing to client: %s", return_value_strerror$29);
        }
        return -1;
      }

    }

    else
    {
      unsigned long int return_value_strlen$32;
      return_value_strlen$32=strlen(name);
      unsigned int return_value_htonl$33;
      return_value_htonl$33=htonl((unsigned int)(signed int)return_value_strlen$32);
      tmpint32 = (signed int)return_value_htonl$33;
      signed int return_value_tio_write$39;
      return_value_tio_write$39=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$39 == 0))
      {
        signed int *return_value___errno_location$38;
        return_value___errno_location$38=__errno_location();
        if(*return_value___errno_location$38 == 32)
        {
          return_value___errno_location$34=__errno_location();
          return_value_strerror$35=strerror(*return_value___errno_location$34);
          log_log(7, "error writing to client: %s", return_value_strerror$35);
        }

        else
        {
          return_value___errno_location$36=__errno_location();
          return_value_strerror$37=strerror(*return_value___errno_location$36);
          log_log(4, "error writing to client: %s", return_value_strerror$37);
        }
        return -1;
      }

      unsigned int return_value_ntohl$40;
      return_value_ntohl$40=ntohl((unsigned int)tmpint32);
      tmpint32 = (signed int)return_value_ntohl$40;
      if(tmpint32 >= 1)
      {
        signed int return_value_tio_write$46;
        return_value_tio_write$46=tio_write(fp, (const void *)name, (unsigned long int)tmpint32);
        if(!(return_value_tio_write$46 == 0))
        {
          signed int *return_value___errno_location$45;
          return_value___errno_location$45=__errno_location();
          if(*return_value___errno_location$45 == 32)
          {
            return_value___errno_location$41=__errno_location();
            return_value_strerror$42=strerror(*return_value___errno_location$41);
            log_log(7, "error writing to client: %s", return_value_strerror$42);
          }

          else
          {
            return_value___errno_location$43=__errno_location();
            return_value_strerror$44=strerror(*return_value___errno_location$43);
            log_log(4, "error writing to client: %s", return_value_strerror$44);
          }
          return -1;
        }

      }

    }
    tmp3int32 = 0;
    tmp2int32 = 0;
    for( ; !(aliases[(signed long int)tmp2int32] == ((const char *)NULL)); tmp2int32 = tmp2int32 + 1)
    {
      return_value_strcmp$47=strcmp(aliases[(signed long int)tmp2int32], name);
      if(!(return_value_strcmp$47 == 0))
        tmp3int32 = tmp3int32 + 1;

    }
    unsigned int return_value_htonl$48;
    return_value_htonl$48=htonl((unsigned int)(signed int)tmp3int32);
    tmpint32 = (signed int)return_value_htonl$48;
    signed int return_value_tio_write$54;
    return_value_tio_write$54=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$54 == 0))
    {
      signed int *return_value___errno_location$53;
      return_value___errno_location$53=__errno_location();
      if(*return_value___errno_location$53 == 32)
      {
        return_value___errno_location$49=__errno_location();
        return_value_strerror$50=strerror(*return_value___errno_location$49);
        log_log(7, "error writing to client: %s", return_value_strerror$50);
      }

      else
      {
        return_value___errno_location$51=__errno_location();
        return_value_strerror$52=strerror(*return_value___errno_location$51);
        log_log(4, "error writing to client: %s", return_value_strerror$52);
      }
      return -1;
    }

    tmp2int32 = 0;
    for( ; !(aliases[(signed long int)tmp2int32] == ((const char *)NULL)); tmp2int32 = tmp2int32 + 1)
    {
      signed int return_value_strcmp$77;
      return_value_strcmp$77=strcmp(aliases[(signed long int)tmp2int32], name);
      if(!(return_value_strcmp$77 == 0))
      {
        if(aliases[(signed long int)tmp2int32] == ((const char *)NULL))
        {
          unsigned int return_value_htonl$55;
          return_value_htonl$55=htonl((unsigned int)(signed int)0);
          tmpint32 = (signed int)return_value_htonl$55;
          signed int return_value_tio_write$61;
          return_value_tio_write$61=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$61 == 0))
          {
            signed int *return_value___errno_location$60;
            return_value___errno_location$60=__errno_location();
            if(*return_value___errno_location$60 == 32)
            {
              return_value___errno_location$56=__errno_location();
              return_value_strerror$57=strerror(*return_value___errno_location$56);
              log_log(7, "error writing to client: %s", return_value_strerror$57);
            }

            else
            {
              return_value___errno_location$58=__errno_location();
              return_value_strerror$59=strerror(*return_value___errno_location$58);
              log_log(4, "error writing to client: %s", return_value_strerror$59);
            }
            return -1;
          }

        }

        else
        {
          unsigned long int return_value_strlen$62;
          return_value_strlen$62=strlen(aliases[(signed long int)tmp2int32]);
          unsigned int return_value_htonl$63;
          return_value_htonl$63=htonl((unsigned int)(signed int)return_value_strlen$62);
          tmpint32 = (signed int)return_value_htonl$63;
          signed int return_value_tio_write$69;
          return_value_tio_write$69=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$69 == 0))
          {
            signed int *return_value___errno_location$68;
            return_value___errno_location$68=__errno_location();
            if(*return_value___errno_location$68 == 32)
            {
              return_value___errno_location$64=__errno_location();
              return_value_strerror$65=strerror(*return_value___errno_location$64);
              log_log(7, "error writing to client: %s", return_value_strerror$65);
            }

            else
            {
              return_value___errno_location$66=__errno_location();
              return_value_strerror$67=strerror(*return_value___errno_location$66);
              log_log(4, "error writing to client: %s", return_value_strerror$67);
            }
            return -1;
          }

          unsigned int return_value_ntohl$70;
          return_value_ntohl$70=ntohl((unsigned int)tmpint32);
          tmpint32 = (signed int)return_value_ntohl$70;
          if(tmpint32 >= 1)
          {
            signed int return_value_tio_write$76;
            return_value_tio_write$76=tio_write(fp, (const void *)aliases[(signed long int)tmp2int32], (unsigned long int)tmpint32);
            if(!(return_value_tio_write$76 == 0))
            {
              signed int *return_value___errno_location$75;
              return_value___errno_location$75=__errno_location();
              if(*return_value___errno_location$75 == 32)
              {
                return_value___errno_location$71=__errno_location();
                return_value_strerror$72=strerror(*return_value___errno_location$71);
                log_log(7, "error writing to client: %s", return_value_strerror$72);
              }

              else
              {
                return_value___errno_location$73=__errno_location();
                return_value_strerror$74=strerror(*return_value___errno_location$73);
                log_log(4, "error writing to client: %s", return_value_strerror$74);
              }
              return -1;
            }

          }

        }
      }

    }
    unsigned int return_value_htonl$78;
    return_value_htonl$78=htonl((unsigned int)(signed int)proto);
    tmpint32 = (signed int)return_value_htonl$78;
    signed int return_value_tio_write$84;
    return_value_tio_write$84=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$84 == 0))
    {
      signed int *return_value___errno_location$83;
      return_value___errno_location$83=__errno_location();
      if(*return_value___errno_location$83 == 32)
      {
        return_value___errno_location$79=__errno_location();
        return_value_strerror$80=strerror(*return_value___errno_location$79);
        log_log(7, "error writing to client: %s", return_value_strerror$80);
      }

      else
      {
        return_value___errno_location$81=__errno_location();
        return_value_strerror$82=strerror(*return_value___errno_location$81);
        log_log(4, "error writing to client: %s", return_value_strerror$82);
      }
      return -1;
    }

    return 0;
  }
}

// write_rpc
// file rpc.c line 104
static signed int write_rpc(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqname)
{
  signed int tmpint32;
  signed int tmp2int32;
  signed int tmp3int32;
  const char *name;
  const char **aliases;
  const char **numbers;
  char *tmp;
  unsigned long int number;
  signed int i;
  name=myldap_get_rdn_value(entry, attmap_rpc_cn);
  aliases=myldap_get_values(entry, attmap_rpc_cn);
  _Bool tmp_if_expr$2;
  if(aliases == ((const char **)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = aliases[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    const char *return_value_myldap_get_dn$1;
    return_value_myldap_get_dn$1=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_rpc_cn);
    return 0;
  }

  if(name == ((const char *)NULL))
    name = aliases[(signed long int)0];

  signed int tmp_if_expr$9;
  signed int return_value_strcasecmp$7;
  signed int return_value_strcmp$8;
  _Bool tmp_if_expr$6;
  signed int tmp_if_expr$5;
  signed int return_value_strcasecmp$3;
  signed int return_value_strcmp$4;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$18;
  signed int *return_value___errno_location$17;
  signed int *return_value___errno_location$20;
  char *return_value_strerror$21;
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  signed int *return_value___errno_location$29;
  char *return_value_strerror$30;
  signed int *return_value___errno_location$35;
  char *return_value_strerror$36;
  signed int *return_value___errno_location$37;
  char *return_value_strerror$38;
  signed int *return_value___errno_location$42;
  char *return_value_strerror$43;
  signed int *return_value___errno_location$44;
  char *return_value_strerror$45;
  signed int return_value_strcmp$48;
  signed int *return_value___errno_location$50;
  char *return_value_strerror$51;
  signed int *return_value___errno_location$52;
  char *return_value_strerror$53;
  signed int *return_value___errno_location$57;
  char *return_value_strerror$58;
  signed int *return_value___errno_location$59;
  char *return_value_strerror$60;
  signed int *return_value___errno_location$65;
  char *return_value_strerror$66;
  signed int *return_value___errno_location$67;
  char *return_value_strerror$68;
  signed int *return_value___errno_location$72;
  char *return_value_strerror$73;
  signed int *return_value___errno_location$74;
  char *return_value_strerror$75;
  signed int *return_value___errno_location$80;
  char *return_value_strerror$81;
  signed int *return_value___errno_location$82;
  char *return_value_strerror$83;
  if(!(reqname == ((const char *)NULL)))
  {
    if(nslcd_cfg->ignorecase == 1)
    {
      return_value_strcasecmp$7=strcasecmp(reqname, name);
      tmp_if_expr$9 = return_value_strcasecmp$7;
    }

    else
    {
      return_value_strcmp$8=strcmp(reqname, name);
      tmp_if_expr$9 = return_value_strcmp$8;
    }
    if(tmp_if_expr$9 == 0)
      goto __CPROVER_DUMP_L13;

    i = 0;
    do
    {
      if(!(aliases[(signed long int)i] == ((const char *)NULL)))
      {
        if(nslcd_cfg->ignorecase == 1)
        {
          return_value_strcasecmp$3=strcasecmp(reqname, aliases[(signed long int)i]);
          tmp_if_expr$5 = return_value_strcasecmp$3;
        }

        else
        {
          return_value_strcmp$4=strcmp(reqname, aliases[(signed long int)i]);
          tmp_if_expr$5 = return_value_strcmp$4;
        }
        tmp_if_expr$6 = tmp_if_expr$5 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      if(!tmp_if_expr$6)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    if(!(aliases[(signed long int)i] == ((const char *)NULL)))
      goto __CPROVER_DUMP_L13;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L13:
    ;
    numbers=myldap_get_values(entry, attmap_rpc_oncRpcNumber);
    if(numbers == ((const char **)NULL))
      tmp_if_expr$12 = (_Bool)1;

    else
      tmp_if_expr$12 = numbers[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$12)
    {
      const char *return_value_myldap_get_dn$10;
      return_value_myldap_get_dn$10=myldap_get_dn(entry);
      log_log(4, "%s: %s: missing", return_value_myldap_get_dn$10, attmap_rpc_oncRpcNumber);
      return 0;
    }

    else
      if(!(numbers[1l] == ((const char *)NULL)))
      {
        const char *return_value_myldap_get_dn$11;
        return_value_myldap_get_dn$11=myldap_get_dn(entry);
        log_log(4, "%s: %s: multiple values", return_value_myldap_get_dn$11, attmap_rpc_oncRpcNumber);
      }

    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    *return_value___errno_location$13 = 0;
    signed long int return_value_strtol$14;
    return_value_strtol$14=strtol(numbers[(signed long int)0], &tmp, 10);
    number = (unsigned long int)return_value_strtol$14;
    if((signed int)*(*numbers) == 0)
      tmp_if_expr$18 = (_Bool)1;

    else
      tmp_if_expr$18 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$18)
    {
      const char *return_value_myldap_get_dn$15;
      return_value_myldap_get_dn$15=myldap_get_dn(entry);
      log_log(4, "%s: %s: non-numeric", return_value_myldap_get_dn$15, attmap_rpc_oncRpcNumber);
      return 0;
    }

    else
    {
      return_value___errno_location$17=__errno_location();
      if(number >= 4294967296ul || !(*return_value___errno_location$17 == 0))
      {
        const char *return_value_myldap_get_dn$16;
        return_value_myldap_get_dn$16=myldap_get_dn(entry);
        log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$16, attmap_rpc_oncRpcNumber);
        return 0;
      }

    }
    unsigned int return_value_htonl$19;
    return_value_htonl$19=htonl((unsigned int)(signed int)1);
    tmpint32 = (signed int)return_value_htonl$19;
    signed int return_value_tio_write$25;
    return_value_tio_write$25=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$25 == 0))
    {
      signed int *return_value___errno_location$24;
      return_value___errno_location$24=__errno_location();
      if(*return_value___errno_location$24 == 32)
      {
        return_value___errno_location$20=__errno_location();
        return_value_strerror$21=strerror(*return_value___errno_location$20);
        log_log(7, "error writing to client: %s", return_value_strerror$21);
      }

      else
      {
        return_value___errno_location$22=__errno_location();
        return_value_strerror$23=strerror(*return_value___errno_location$22);
        log_log(4, "error writing to client: %s", return_value_strerror$23);
      }
      return -1;
    }

    if(name == ((const char *)NULL))
    {
      unsigned int return_value_htonl$26;
      return_value_htonl$26=htonl((unsigned int)(signed int)0);
      tmpint32 = (signed int)return_value_htonl$26;
      signed int return_value_tio_write$32;
      return_value_tio_write$32=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$32 == 0))
      {
        signed int *return_value___errno_location$31;
        return_value___errno_location$31=__errno_location();
        if(*return_value___errno_location$31 == 32)
        {
          return_value___errno_location$27=__errno_location();
          return_value_strerror$28=strerror(*return_value___errno_location$27);
          log_log(7, "error writing to client: %s", return_value_strerror$28);
        }

        else
        {
          return_value___errno_location$29=__errno_location();
          return_value_strerror$30=strerror(*return_value___errno_location$29);
          log_log(4, "error writing to client: %s", return_value_strerror$30);
        }
        return -1;
      }

    }

    else
    {
      unsigned long int return_value_strlen$33;
      return_value_strlen$33=strlen(name);
      unsigned int return_value_htonl$34;
      return_value_htonl$34=htonl((unsigned int)(signed int)return_value_strlen$33);
      tmpint32 = (signed int)return_value_htonl$34;
      signed int return_value_tio_write$40;
      return_value_tio_write$40=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$40 == 0))
      {
        signed int *return_value___errno_location$39;
        return_value___errno_location$39=__errno_location();
        if(*return_value___errno_location$39 == 32)
        {
          return_value___errno_location$35=__errno_location();
          return_value_strerror$36=strerror(*return_value___errno_location$35);
          log_log(7, "error writing to client: %s", return_value_strerror$36);
        }

        else
        {
          return_value___errno_location$37=__errno_location();
          return_value_strerror$38=strerror(*return_value___errno_location$37);
          log_log(4, "error writing to client: %s", return_value_strerror$38);
        }
        return -1;
      }

      unsigned int return_value_ntohl$41;
      return_value_ntohl$41=ntohl((unsigned int)tmpint32);
      tmpint32 = (signed int)return_value_ntohl$41;
      if(tmpint32 >= 1)
      {
        signed int return_value_tio_write$47;
        return_value_tio_write$47=tio_write(fp, (const void *)name, (unsigned long int)tmpint32);
        if(!(return_value_tio_write$47 == 0))
        {
          signed int *return_value___errno_location$46;
          return_value___errno_location$46=__errno_location();
          if(*return_value___errno_location$46 == 32)
          {
            return_value___errno_location$42=__errno_location();
            return_value_strerror$43=strerror(*return_value___errno_location$42);
            log_log(7, "error writing to client: %s", return_value_strerror$43);
          }

          else
          {
            return_value___errno_location$44=__errno_location();
            return_value_strerror$45=strerror(*return_value___errno_location$44);
            log_log(4, "error writing to client: %s", return_value_strerror$45);
          }
          return -1;
        }

      }

    }
    tmp3int32 = 0;
    tmp2int32 = 0;
    for( ; !(aliases[(signed long int)tmp2int32] == ((const char *)NULL)); tmp2int32 = tmp2int32 + 1)
    {
      return_value_strcmp$48=strcmp(aliases[(signed long int)tmp2int32], name);
      if(!(return_value_strcmp$48 == 0))
        tmp3int32 = tmp3int32 + 1;

    }
    unsigned int return_value_htonl$49;
    return_value_htonl$49=htonl((unsigned int)(signed int)tmp3int32);
    tmpint32 = (signed int)return_value_htonl$49;
    signed int return_value_tio_write$55;
    return_value_tio_write$55=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$55 == 0))
    {
      signed int *return_value___errno_location$54;
      return_value___errno_location$54=__errno_location();
      if(*return_value___errno_location$54 == 32)
      {
        return_value___errno_location$50=__errno_location();
        return_value_strerror$51=strerror(*return_value___errno_location$50);
        log_log(7, "error writing to client: %s", return_value_strerror$51);
      }

      else
      {
        return_value___errno_location$52=__errno_location();
        return_value_strerror$53=strerror(*return_value___errno_location$52);
        log_log(4, "error writing to client: %s", return_value_strerror$53);
      }
      return -1;
    }

    tmp2int32 = 0;
    for( ; !(aliases[(signed long int)tmp2int32] == ((const char *)NULL)); tmp2int32 = tmp2int32 + 1)
    {
      signed int return_value_strcmp$78;
      return_value_strcmp$78=strcmp(aliases[(signed long int)tmp2int32], name);
      if(!(return_value_strcmp$78 == 0))
      {
        if(aliases[(signed long int)tmp2int32] == ((const char *)NULL))
        {
          unsigned int return_value_htonl$56;
          return_value_htonl$56=htonl((unsigned int)(signed int)0);
          tmpint32 = (signed int)return_value_htonl$56;
          signed int return_value_tio_write$62;
          return_value_tio_write$62=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$62 == 0))
          {
            signed int *return_value___errno_location$61;
            return_value___errno_location$61=__errno_location();
            if(*return_value___errno_location$61 == 32)
            {
              return_value___errno_location$57=__errno_location();
              return_value_strerror$58=strerror(*return_value___errno_location$57);
              log_log(7, "error writing to client: %s", return_value_strerror$58);
            }

            else
            {
              return_value___errno_location$59=__errno_location();
              return_value_strerror$60=strerror(*return_value___errno_location$59);
              log_log(4, "error writing to client: %s", return_value_strerror$60);
            }
            return -1;
          }

        }

        else
        {
          unsigned long int return_value_strlen$63;
          return_value_strlen$63=strlen(aliases[(signed long int)tmp2int32]);
          unsigned int return_value_htonl$64;
          return_value_htonl$64=htonl((unsigned int)(signed int)return_value_strlen$63);
          tmpint32 = (signed int)return_value_htonl$64;
          signed int return_value_tio_write$70;
          return_value_tio_write$70=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$70 == 0))
          {
            signed int *return_value___errno_location$69;
            return_value___errno_location$69=__errno_location();
            if(*return_value___errno_location$69 == 32)
            {
              return_value___errno_location$65=__errno_location();
              return_value_strerror$66=strerror(*return_value___errno_location$65);
              log_log(7, "error writing to client: %s", return_value_strerror$66);
            }

            else
            {
              return_value___errno_location$67=__errno_location();
              return_value_strerror$68=strerror(*return_value___errno_location$67);
              log_log(4, "error writing to client: %s", return_value_strerror$68);
            }
            return -1;
          }

          unsigned int return_value_ntohl$71;
          return_value_ntohl$71=ntohl((unsigned int)tmpint32);
          tmpint32 = (signed int)return_value_ntohl$71;
          if(tmpint32 >= 1)
          {
            signed int return_value_tio_write$77;
            return_value_tio_write$77=tio_write(fp, (const void *)aliases[(signed long int)tmp2int32], (unsigned long int)tmpint32);
            if(!(return_value_tio_write$77 == 0))
            {
              signed int *return_value___errno_location$76;
              return_value___errno_location$76=__errno_location();
              if(*return_value___errno_location$76 == 32)
              {
                return_value___errno_location$72=__errno_location();
                return_value_strerror$73=strerror(*return_value___errno_location$72);
                log_log(7, "error writing to client: %s", return_value_strerror$73);
              }

              else
              {
                return_value___errno_location$74=__errno_location();
                return_value_strerror$75=strerror(*return_value___errno_location$74);
                log_log(4, "error writing to client: %s", return_value_strerror$75);
              }
              return -1;
            }

          }

        }
      }

    }
    unsigned int return_value_htonl$79;
    return_value_htonl$79=htonl((unsigned int)(signed int)number);
    tmpint32 = (signed int)return_value_htonl$79;
    signed int return_value_tio_write$85;
    return_value_tio_write$85=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_tio_write$85 == 0))
    {
      signed int *return_value___errno_location$84;
      return_value___errno_location$84=__errno_location();
      if(*return_value___errno_location$84 == 32)
      {
        return_value___errno_location$80=__errno_location();
        return_value_strerror$81=strerror(*return_value___errno_location$80);
        log_log(7, "error writing to client: %s", return_value_strerror$81);
      }

      else
      {
        return_value___errno_location$82=__errno_location();
        return_value_strerror$83=strerror(*return_value___errno_location$82);
        log_log(4, "error writing to client: %s", return_value_strerror$83);
      }
      return -1;
    }

    return 0;
  }
}

// write_service
// file service.c line 132
static signed int write_service(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *reqname, const char *reqprotocol)
{
  signed int tmpint32;
  signed int tmp2int32;
  signed int tmp3int32;
  const char *name;
  const char **aliases;
  const char **ports;
  const char **protocols;
  char *tmp;
  signed long int port;
  signed int i;
  name=myldap_get_rdn_value(entry, attmap_service_cn);
  aliases=myldap_get_values(entry, attmap_service_cn);
  _Bool tmp_if_expr$2;
  if(aliases == ((const char **)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = aliases[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    const char *return_value_myldap_get_dn$1;
    return_value_myldap_get_dn$1=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_service_cn);
    return 0;
  }

  if(name == ((const char *)NULL))
    name = aliases[(signed long int)0];

  signed int tmp_if_expr$9;
  signed int return_value_strcasecmp$7;
  signed int return_value_strcmp$8;
  _Bool tmp_if_expr$6;
  signed int tmp_if_expr$5;
  signed int return_value_strcasecmp$3;
  signed int return_value_strcmp$4;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$17;
  signed int *return_value___errno_location$16;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$109;
  _Bool tmp_if_expr$113;
  signed int tmp_if_expr$112;
  signed int return_value_strcasecmp$110;
  signed int return_value_strcmp$111;
  signed int *return_value___errno_location$21;
  char *return_value_strerror$22;
  signed int *return_value___errno_location$23;
  char *return_value_strerror$24;
  signed int *return_value___errno_location$28;
  char *return_value_strerror$29;
  signed int *return_value___errno_location$30;
  char *return_value_strerror$31;
  signed int *return_value___errno_location$36;
  char *return_value_strerror$37;
  signed int *return_value___errno_location$38;
  char *return_value_strerror$39;
  signed int *return_value___errno_location$43;
  char *return_value_strerror$44;
  signed int *return_value___errno_location$45;
  char *return_value_strerror$46;
  signed int return_value_strcmp$49;
  signed int *return_value___errno_location$51;
  char *return_value_strerror$52;
  signed int *return_value___errno_location$53;
  char *return_value_strerror$54;
  signed int *return_value___errno_location$58;
  char *return_value_strerror$59;
  signed int *return_value___errno_location$60;
  char *return_value_strerror$61;
  signed int *return_value___errno_location$66;
  char *return_value_strerror$67;
  signed int *return_value___errno_location$68;
  char *return_value_strerror$69;
  signed int *return_value___errno_location$73;
  char *return_value_strerror$74;
  signed int *return_value___errno_location$75;
  char *return_value_strerror$76;
  signed int *return_value___errno_location$81;
  char *return_value_strerror$82;
  signed int *return_value___errno_location$83;
  char *return_value_strerror$84;
  signed int *return_value___errno_location$88;
  char *return_value_strerror$89;
  signed int *return_value___errno_location$90;
  char *return_value_strerror$91;
  signed int *return_value___errno_location$96;
  char *return_value_strerror$97;
  signed int *return_value___errno_location$98;
  char *return_value_strerror$99;
  signed int *return_value___errno_location$103;
  char *return_value_strerror$104;
  signed int *return_value___errno_location$105;
  char *return_value_strerror$106;
  if(!(reqname == ((const char *)NULL)))
  {
    if(nslcd_cfg->ignorecase == 1)
    {
      return_value_strcasecmp$7=strcasecmp(reqname, name);
      tmp_if_expr$9 = return_value_strcasecmp$7;
    }

    else
    {
      return_value_strcmp$8=strcmp(reqname, name);
      tmp_if_expr$9 = return_value_strcmp$8;
    }
    if(tmp_if_expr$9 == 0)
      goto __CPROVER_DUMP_L13;

    i = 0;
    do
    {
      if(!(aliases[(signed long int)i] == ((const char *)NULL)))
      {
        if(nslcd_cfg->ignorecase == 1)
        {
          return_value_strcasecmp$3=strcasecmp(reqname, aliases[(signed long int)i]);
          tmp_if_expr$5 = return_value_strcasecmp$3;
        }

        else
        {
          return_value_strcmp$4=strcmp(reqname, aliases[(signed long int)i]);
          tmp_if_expr$5 = return_value_strcmp$4;
        }
        tmp_if_expr$6 = tmp_if_expr$5 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      if(!tmp_if_expr$6)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    if(!(aliases[(signed long int)i] == ((const char *)NULL)))
      goto __CPROVER_DUMP_L13;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L13:
    ;
    ports=myldap_get_values(entry, attmap_service_ipServicePort);
    if(ports == ((const char **)NULL))
      tmp_if_expr$12 = (_Bool)1;

    else
      tmp_if_expr$12 = ports[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$12)
    {
      const char *return_value_myldap_get_dn$10;
      return_value_myldap_get_dn$10=myldap_get_dn(entry);
      log_log(4, "%s: %s: missing", return_value_myldap_get_dn$10, attmap_service_ipServicePort);
      return 0;
    }

    else
      if(!(ports[1l] == ((const char *)NULL)))
      {
        const char *return_value_myldap_get_dn$11;
        return_value_myldap_get_dn$11=myldap_get_dn(entry);
        log_log(4, "%s: %s: multiple values", return_value_myldap_get_dn$11, attmap_service_ipServicePort);
      }

    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    *return_value___errno_location$13 = 0;
    port=strtol(ports[(signed long int)0], &tmp, 10);
    if((signed int)*(*ports) == 0)
      tmp_if_expr$17 = (_Bool)1;

    else
      tmp_if_expr$17 = (signed int)*tmp != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$17)
    {
      const char *return_value_myldap_get_dn$14;
      return_value_myldap_get_dn$14=myldap_get_dn(entry);
      log_log(4, "%s: %s: non-numeric value", return_value_myldap_get_dn$14, attmap_service_ipServicePort);
      return 0;
    }

    else
    {
      return_value___errno_location$16=__errno_location();
      if(port >= 65536l || !(*return_value___errno_location$16 == 0) || !(port >= 1l))
      {
        const char *return_value_myldap_get_dn$15;
        return_value_myldap_get_dn$15=myldap_get_dn(entry);
        log_log(4, "%s: %s: out of range", return_value_myldap_get_dn$15, attmap_service_ipServicePort);
        return 0;
      }

    }
    protocols=myldap_get_values(entry, attmap_service_ipServiceProtocol);
    if(protocols == ((const char **)NULL))
      tmp_if_expr$19 = (_Bool)1;

    else
      tmp_if_expr$19 = protocols[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$19)
    {
      const char *return_value_myldap_get_dn$18;
      return_value_myldap_get_dn$18=myldap_get_dn(entry);
      log_log(4, "%s: %s: missing", return_value_myldap_get_dn$18, attmap_service_ipServiceProtocol);
      return 0;
    }

    i = 0;
    for( ; !(protocols[(signed long int)i] == ((const char *)NULL)); i = i + 1)
    {
      if(reqprotocol == ((const char *)NULL))
        tmp_if_expr$109 = (_Bool)1;

      else
        tmp_if_expr$109 = (signed int)*reqprotocol == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$109)
        tmp_if_expr$113 = (_Bool)1;

      else
      {
        if(nslcd_cfg->ignorecase == 1)
        {
          return_value_strcasecmp$110=strcasecmp(reqprotocol, protocols[(signed long int)i]);
          tmp_if_expr$112 = return_value_strcasecmp$110;
        }

        else
        {
          return_value_strcmp$111=strcmp(reqprotocol, protocols[(signed long int)i]);
          tmp_if_expr$112 = return_value_strcmp$111;
        }
        tmp_if_expr$113 = tmp_if_expr$112 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$113)
      {
        unsigned int return_value_htonl$20;
        return_value_htonl$20=htonl((unsigned int)(signed int)1);
        tmpint32 = (signed int)return_value_htonl$20;
        signed int return_value_tio_write$26;
        return_value_tio_write$26=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$26 == 0))
        {
          signed int *return_value___errno_location$25;
          return_value___errno_location$25=__errno_location();
          if(*return_value___errno_location$25 == 32)
          {
            return_value___errno_location$21=__errno_location();
            return_value_strerror$22=strerror(*return_value___errno_location$21);
            log_log(7, "error writing to client: %s", return_value_strerror$22);
          }

          else
          {
            return_value___errno_location$23=__errno_location();
            return_value_strerror$24=strerror(*return_value___errno_location$23);
            log_log(4, "error writing to client: %s", return_value_strerror$24);
          }
          return -1;
        }

        if(name == ((const char *)NULL))
        {
          unsigned int return_value_htonl$27;
          return_value_htonl$27=htonl((unsigned int)(signed int)0);
          tmpint32 = (signed int)return_value_htonl$27;
          signed int return_value_tio_write$33;
          return_value_tio_write$33=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$33 == 0))
          {
            signed int *return_value___errno_location$32;
            return_value___errno_location$32=__errno_location();
            if(*return_value___errno_location$32 == 32)
            {
              return_value___errno_location$28=__errno_location();
              return_value_strerror$29=strerror(*return_value___errno_location$28);
              log_log(7, "error writing to client: %s", return_value_strerror$29);
            }

            else
            {
              return_value___errno_location$30=__errno_location();
              return_value_strerror$31=strerror(*return_value___errno_location$30);
              log_log(4, "error writing to client: %s", return_value_strerror$31);
            }
            return -1;
          }

        }

        else
        {
          unsigned long int return_value_strlen$34;
          return_value_strlen$34=strlen(name);
          unsigned int return_value_htonl$35;
          return_value_htonl$35=htonl((unsigned int)(signed int)return_value_strlen$34);
          tmpint32 = (signed int)return_value_htonl$35;
          signed int return_value_tio_write$41;
          return_value_tio_write$41=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$41 == 0))
          {
            signed int *return_value___errno_location$40;
            return_value___errno_location$40=__errno_location();
            if(*return_value___errno_location$40 == 32)
            {
              return_value___errno_location$36=__errno_location();
              return_value_strerror$37=strerror(*return_value___errno_location$36);
              log_log(7, "error writing to client: %s", return_value_strerror$37);
            }

            else
            {
              return_value___errno_location$38=__errno_location();
              return_value_strerror$39=strerror(*return_value___errno_location$38);
              log_log(4, "error writing to client: %s", return_value_strerror$39);
            }
            return -1;
          }

          unsigned int return_value_ntohl$42;
          return_value_ntohl$42=ntohl((unsigned int)tmpint32);
          tmpint32 = (signed int)return_value_ntohl$42;
          if(tmpint32 >= 1)
          {
            signed int return_value_tio_write$48;
            return_value_tio_write$48=tio_write(fp, (const void *)name, (unsigned long int)tmpint32);
            if(!(return_value_tio_write$48 == 0))
            {
              signed int *return_value___errno_location$47;
              return_value___errno_location$47=__errno_location();
              if(*return_value___errno_location$47 == 32)
              {
                return_value___errno_location$43=__errno_location();
                return_value_strerror$44=strerror(*return_value___errno_location$43);
                log_log(7, "error writing to client: %s", return_value_strerror$44);
              }

              else
              {
                return_value___errno_location$45=__errno_location();
                return_value_strerror$46=strerror(*return_value___errno_location$45);
                log_log(4, "error writing to client: %s", return_value_strerror$46);
              }
              return -1;
            }

          }

        }
        tmp3int32 = 0;
        tmp2int32 = 0;
        for( ; !(aliases[(signed long int)tmp2int32] == ((const char *)NULL)); tmp2int32 = tmp2int32 + 1)
        {
          return_value_strcmp$49=strcmp(aliases[(signed long int)tmp2int32], name);
          if(!(return_value_strcmp$49 == 0))
            tmp3int32 = tmp3int32 + 1;

        }
        unsigned int return_value_htonl$50;
        return_value_htonl$50=htonl((unsigned int)(signed int)tmp3int32);
        tmpint32 = (signed int)return_value_htonl$50;
        signed int return_value_tio_write$56;
        return_value_tio_write$56=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$56 == 0))
        {
          signed int *return_value___errno_location$55;
          return_value___errno_location$55=__errno_location();
          if(*return_value___errno_location$55 == 32)
          {
            return_value___errno_location$51=__errno_location();
            return_value_strerror$52=strerror(*return_value___errno_location$51);
            log_log(7, "error writing to client: %s", return_value_strerror$52);
          }

          else
          {
            return_value___errno_location$53=__errno_location();
            return_value_strerror$54=strerror(*return_value___errno_location$53);
            log_log(4, "error writing to client: %s", return_value_strerror$54);
          }
          return -1;
        }

        tmp2int32 = 0;
        for( ; !(aliases[(signed long int)tmp2int32] == ((const char *)NULL)); tmp2int32 = tmp2int32 + 1)
        {
          signed int return_value_strcmp$79;
          return_value_strcmp$79=strcmp(aliases[(signed long int)tmp2int32], name);
          if(!(return_value_strcmp$79 == 0))
          {
            if(aliases[(signed long int)tmp2int32] == ((const char *)NULL))
            {
              unsigned int return_value_htonl$57;
              return_value_htonl$57=htonl((unsigned int)(signed int)0);
              tmpint32 = (signed int)return_value_htonl$57;
              signed int return_value_tio_write$63;
              return_value_tio_write$63=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$63 == 0))
              {
                signed int *return_value___errno_location$62;
                return_value___errno_location$62=__errno_location();
                if(*return_value___errno_location$62 == 32)
                {
                  return_value___errno_location$58=__errno_location();
                  return_value_strerror$59=strerror(*return_value___errno_location$58);
                  log_log(7, "error writing to client: %s", return_value_strerror$59);
                }

                else
                {
                  return_value___errno_location$60=__errno_location();
                  return_value_strerror$61=strerror(*return_value___errno_location$60);
                  log_log(4, "error writing to client: %s", return_value_strerror$61);
                }
                return -1;
              }

            }

            else
            {
              unsigned long int return_value_strlen$64;
              return_value_strlen$64=strlen(aliases[(signed long int)tmp2int32]);
              unsigned int return_value_htonl$65;
              return_value_htonl$65=htonl((unsigned int)(signed int)return_value_strlen$64);
              tmpint32 = (signed int)return_value_htonl$65;
              signed int return_value_tio_write$71;
              return_value_tio_write$71=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_tio_write$71 == 0))
              {
                signed int *return_value___errno_location$70;
                return_value___errno_location$70=__errno_location();
                if(*return_value___errno_location$70 == 32)
                {
                  return_value___errno_location$66=__errno_location();
                  return_value_strerror$67=strerror(*return_value___errno_location$66);
                  log_log(7, "error writing to client: %s", return_value_strerror$67);
                }

                else
                {
                  return_value___errno_location$68=__errno_location();
                  return_value_strerror$69=strerror(*return_value___errno_location$68);
                  log_log(4, "error writing to client: %s", return_value_strerror$69);
                }
                return -1;
              }

              unsigned int return_value_ntohl$72;
              return_value_ntohl$72=ntohl((unsigned int)tmpint32);
              tmpint32 = (signed int)return_value_ntohl$72;
              if(tmpint32 >= 1)
              {
                signed int return_value_tio_write$78;
                return_value_tio_write$78=tio_write(fp, (const void *)aliases[(signed long int)tmp2int32], (unsigned long int)tmpint32);
                if(!(return_value_tio_write$78 == 0))
                {
                  signed int *return_value___errno_location$77;
                  return_value___errno_location$77=__errno_location();
                  if(*return_value___errno_location$77 == 32)
                  {
                    return_value___errno_location$73=__errno_location();
                    return_value_strerror$74=strerror(*return_value___errno_location$73);
                    log_log(7, "error writing to client: %s", return_value_strerror$74);
                  }

                  else
                  {
                    return_value___errno_location$75=__errno_location();
                    return_value_strerror$76=strerror(*return_value___errno_location$75);
                    log_log(4, "error writing to client: %s", return_value_strerror$76);
                  }
                  return -1;
                }

              }

            }
          }

        }
        unsigned int return_value_htonl$80;
        return_value_htonl$80=htonl((unsigned int)(signed int)port);
        tmpint32 = (signed int)return_value_htonl$80;
        signed int return_value_tio_write$86;
        return_value_tio_write$86=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$86 == 0))
        {
          signed int *return_value___errno_location$85;
          return_value___errno_location$85=__errno_location();
          if(*return_value___errno_location$85 == 32)
          {
            return_value___errno_location$81=__errno_location();
            return_value_strerror$82=strerror(*return_value___errno_location$81);
            log_log(7, "error writing to client: %s", return_value_strerror$82);
          }

          else
          {
            return_value___errno_location$83=__errno_location();
            return_value_strerror$84=strerror(*return_value___errno_location$83);
            log_log(4, "error writing to client: %s", return_value_strerror$84);
          }
          return -1;
        }

        if(protocols[(signed long int)i] == ((const char *)NULL))
        {
          unsigned int return_value_htonl$87;
          return_value_htonl$87=htonl((unsigned int)(signed int)0);
          tmpint32 = (signed int)return_value_htonl$87;
          signed int return_value_tio_write$93;
          return_value_tio_write$93=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$93 == 0))
          {
            signed int *return_value___errno_location$92;
            return_value___errno_location$92=__errno_location();
            if(*return_value___errno_location$92 == 32)
            {
              return_value___errno_location$88=__errno_location();
              return_value_strerror$89=strerror(*return_value___errno_location$88);
              log_log(7, "error writing to client: %s", return_value_strerror$89);
            }

            else
            {
              return_value___errno_location$90=__errno_location();
              return_value_strerror$91=strerror(*return_value___errno_location$90);
              log_log(4, "error writing to client: %s", return_value_strerror$91);
            }
            return -1;
          }

        }

        else
        {
          unsigned long int return_value_strlen$94;
          return_value_strlen$94=strlen(protocols[(signed long int)i]);
          unsigned int return_value_htonl$95;
          return_value_htonl$95=htonl((unsigned int)(signed int)return_value_strlen$94);
          tmpint32 = (signed int)return_value_htonl$95;
          signed int return_value_tio_write$101;
          return_value_tio_write$101=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
          if(!(return_value_tio_write$101 == 0))
          {
            signed int *return_value___errno_location$100;
            return_value___errno_location$100=__errno_location();
            if(*return_value___errno_location$100 == 32)
            {
              return_value___errno_location$96=__errno_location();
              return_value_strerror$97=strerror(*return_value___errno_location$96);
              log_log(7, "error writing to client: %s", return_value_strerror$97);
            }

            else
            {
              return_value___errno_location$98=__errno_location();
              return_value_strerror$99=strerror(*return_value___errno_location$98);
              log_log(4, "error writing to client: %s", return_value_strerror$99);
            }
            return -1;
          }

          unsigned int return_value_ntohl$102;
          return_value_ntohl$102=ntohl((unsigned int)tmpint32);
          tmpint32 = (signed int)return_value_ntohl$102;
          if(tmpint32 >= 1)
          {
            signed int return_value_tio_write$108;
            return_value_tio_write$108=tio_write(fp, (const void *)protocols[(signed long int)i], (unsigned long int)tmpint32);
            if(!(return_value_tio_write$108 == 0))
            {
              signed int *return_value___errno_location$107;
              return_value___errno_location$107=__errno_location();
              if(*return_value___errno_location$107 == 32)
              {
                return_value___errno_location$103=__errno_location();
                return_value_strerror$104=strerror(*return_value___errno_location$103);
                log_log(7, "error writing to client: %s", return_value_strerror$104);
              }

              else
              {
                return_value___errno_location$105=__errno_location();
                return_value_strerror$106=strerror(*return_value___errno_location$105);
                log_log(4, "error writing to client: %s", return_value_strerror$106);
              }
              return -1;
            }

          }

        }
      }

    }
    return 0;
  }
}

// write_shadow
// file shadow.c line 222
static signed int write_shadow(struct tio_fileinfo *fp, struct myldap_entry *entry, const char *requser, unsigned int calleruid)
{
  signed int tmpint32;
  const char **usernames;
  const char *passwd;
  signed long int lastchangedate;
  signed long int mindays;
  signed long int maxdays;
  signed long int warndays;
  signed long int inactdays;
  signed long int expiredate;
  unsigned long int flag;
  signed int i;
  char passbuffer[256l];
  usernames=myldap_get_values(entry, attmap_shadow_uid);
  _Bool tmp_if_expr$2;
  if(usernames == ((const char **)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = usernames[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    const char *return_value_myldap_get_dn$1;
    return_value_myldap_get_dn$1=myldap_get_dn(entry);
    log_log(4, "%s: %s: missing", return_value_myldap_get_dn$1, attmap_shadow_uid);
    return 0;
  }

  passwd=get_userpassword(entry, attmap_shadow_userPassword, passbuffer, sizeof(char [256l]) /*256ul*/ );
  if(passwd == ((const char *)NULL) || !(calleruid == 0u))
    passwd = default_shadow_userPassword;

  get_shadow_properties(entry, &lastchangedate, &mindays, &maxdays, &warndays, &inactdays, &expiredate, &flag);
  i = 0;
  _Bool tmp_if_expr$106;
  signed int tmp_if_expr$105;
  signed int return_value_strcasecmp$103;
  signed int return_value_strcmp$104;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int *return_value___errno_location$19;
  char *return_value_strerror$20;
  signed int *return_value___errno_location$21;
  char *return_value_strerror$22;
  signed int *return_value___errno_location$26;
  char *return_value_strerror$27;
  signed int *return_value___errno_location$28;
  char *return_value_strerror$29;
  signed int *return_value___errno_location$33;
  char *return_value_strerror$34;
  signed int *return_value___errno_location$35;
  char *return_value_strerror$36;
  signed int *return_value___errno_location$41;
  char *return_value_strerror$42;
  signed int *return_value___errno_location$43;
  char *return_value_strerror$44;
  signed int *return_value___errno_location$48;
  char *return_value_strerror$49;
  signed int *return_value___errno_location$50;
  char *return_value_strerror$51;
  signed int *return_value___errno_location$55;
  char *return_value_strerror$56;
  signed int *return_value___errno_location$57;
  char *return_value_strerror$58;
  signed int *return_value___errno_location$62;
  char *return_value_strerror$63;
  signed int *return_value___errno_location$64;
  char *return_value_strerror$65;
  signed int *return_value___errno_location$69;
  char *return_value_strerror$70;
  signed int *return_value___errno_location$71;
  char *return_value_strerror$72;
  signed int *return_value___errno_location$76;
  char *return_value_strerror$77;
  signed int *return_value___errno_location$78;
  char *return_value_strerror$79;
  signed int *return_value___errno_location$83;
  char *return_value_strerror$84;
  signed int *return_value___errno_location$85;
  char *return_value_strerror$86;
  signed int *return_value___errno_location$90;
  char *return_value_strerror$91;
  signed int *return_value___errno_location$92;
  char *return_value_strerror$93;
  signed int *return_value___errno_location$97;
  char *return_value_strerror$98;
  signed int *return_value___errno_location$99;
  char *return_value_strerror$100;
  for( ; !(usernames[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    if(requser == ((const char *)NULL))
      tmp_if_expr$106 = (_Bool)1;

    else
    {
      if(nslcd_cfg->ignorecase == 1)
      {
        return_value_strcasecmp$103=strcasecmp(requser, usernames[(signed long int)i]);
        tmp_if_expr$105 = return_value_strcasecmp$103;
      }

      else
      {
        return_value_strcmp$104=strcmp(requser, usernames[(signed long int)i]);
        tmp_if_expr$105 = return_value_strcmp$104;
      }
      tmp_if_expr$106 = tmp_if_expr$105 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$106)
    {
      unsigned int return_value_htonl$3;
      return_value_htonl$3=htonl((unsigned int)(signed int)1);
      tmpint32 = (signed int)return_value_htonl$3;
      signed int return_value_tio_write$9;
      return_value_tio_write$9=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$9 == 0))
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        if(*return_value___errno_location$8 == 32)
        {
          return_value___errno_location$4=__errno_location();
          return_value_strerror$5=strerror(*return_value___errno_location$4);
          log_log(7, "error writing to client: %s", return_value_strerror$5);
        }

        else
        {
          return_value___errno_location$6=__errno_location();
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          log_log(4, "error writing to client: %s", return_value_strerror$7);
        }
        return -1;
      }

      if(usernames[(signed long int)i] == ((const char *)NULL))
      {
        unsigned int return_value_htonl$10;
        return_value_htonl$10=htonl((unsigned int)(signed int)0);
        tmpint32 = (signed int)return_value_htonl$10;
        signed int return_value_tio_write$16;
        return_value_tio_write$16=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$16 == 0))
        {
          signed int *return_value___errno_location$15;
          return_value___errno_location$15=__errno_location();
          if(*return_value___errno_location$15 == 32)
          {
            return_value___errno_location$11=__errno_location();
            return_value_strerror$12=strerror(*return_value___errno_location$11);
            log_log(7, "error writing to client: %s", return_value_strerror$12);
          }

          else
          {
            return_value___errno_location$13=__errno_location();
            return_value_strerror$14=strerror(*return_value___errno_location$13);
            log_log(4, "error writing to client: %s", return_value_strerror$14);
          }
          return -1;
        }

      }

      else
      {
        unsigned long int return_value_strlen$17;
        return_value_strlen$17=strlen(usernames[(signed long int)i]);
        unsigned int return_value_htonl$18;
        return_value_htonl$18=htonl((unsigned int)(signed int)return_value_strlen$17);
        tmpint32 = (signed int)return_value_htonl$18;
        signed int return_value_tio_write$24;
        return_value_tio_write$24=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$24 == 0))
        {
          signed int *return_value___errno_location$23;
          return_value___errno_location$23=__errno_location();
          if(*return_value___errno_location$23 == 32)
          {
            return_value___errno_location$19=__errno_location();
            return_value_strerror$20=strerror(*return_value___errno_location$19);
            log_log(7, "error writing to client: %s", return_value_strerror$20);
          }

          else
          {
            return_value___errno_location$21=__errno_location();
            return_value_strerror$22=strerror(*return_value___errno_location$21);
            log_log(4, "error writing to client: %s", return_value_strerror$22);
          }
          return -1;
        }

        unsigned int return_value_ntohl$25;
        return_value_ntohl$25=ntohl((unsigned int)tmpint32);
        tmpint32 = (signed int)return_value_ntohl$25;
        if(tmpint32 >= 1)
        {
          signed int return_value_tio_write$31;
          return_value_tio_write$31=tio_write(fp, (const void *)usernames[(signed long int)i], (unsigned long int)tmpint32);
          if(!(return_value_tio_write$31 == 0))
          {
            signed int *return_value___errno_location$30;
            return_value___errno_location$30=__errno_location();
            if(*return_value___errno_location$30 == 32)
            {
              return_value___errno_location$26=__errno_location();
              return_value_strerror$27=strerror(*return_value___errno_location$26);
              log_log(7, "error writing to client: %s", return_value_strerror$27);
            }

            else
            {
              return_value___errno_location$28=__errno_location();
              return_value_strerror$29=strerror(*return_value___errno_location$28);
              log_log(4, "error writing to client: %s", return_value_strerror$29);
            }
            return -1;
          }

        }

      }
      if(passwd == ((const char *)NULL))
      {
        unsigned int return_value_htonl$32;
        return_value_htonl$32=htonl((unsigned int)(signed int)0);
        tmpint32 = (signed int)return_value_htonl$32;
        signed int return_value_tio_write$38;
        return_value_tio_write$38=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$38 == 0))
        {
          signed int *return_value___errno_location$37;
          return_value___errno_location$37=__errno_location();
          if(*return_value___errno_location$37 == 32)
          {
            return_value___errno_location$33=__errno_location();
            return_value_strerror$34=strerror(*return_value___errno_location$33);
            log_log(7, "error writing to client: %s", return_value_strerror$34);
          }

          else
          {
            return_value___errno_location$35=__errno_location();
            return_value_strerror$36=strerror(*return_value___errno_location$35);
            log_log(4, "error writing to client: %s", return_value_strerror$36);
          }
          return -1;
        }

      }

      else
      {
        unsigned long int return_value_strlen$39;
        return_value_strlen$39=strlen(passwd);
        unsigned int return_value_htonl$40;
        return_value_htonl$40=htonl((unsigned int)(signed int)return_value_strlen$39);
        tmpint32 = (signed int)return_value_htonl$40;
        signed int return_value_tio_write$46;
        return_value_tio_write$46=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_tio_write$46 == 0))
        {
          signed int *return_value___errno_location$45;
          return_value___errno_location$45=__errno_location();
          if(*return_value___errno_location$45 == 32)
          {
            return_value___errno_location$41=__errno_location();
            return_value_strerror$42=strerror(*return_value___errno_location$41);
            log_log(7, "error writing to client: %s", return_value_strerror$42);
          }

          else
          {
            return_value___errno_location$43=__errno_location();
            return_value_strerror$44=strerror(*return_value___errno_location$43);
            log_log(4, "error writing to client: %s", return_value_strerror$44);
          }
          return -1;
        }

        unsigned int return_value_ntohl$47;
        return_value_ntohl$47=ntohl((unsigned int)tmpint32);
        tmpint32 = (signed int)return_value_ntohl$47;
        if(tmpint32 >= 1)
        {
          signed int return_value_tio_write$53;
          return_value_tio_write$53=tio_write(fp, (const void *)passwd, (unsigned long int)tmpint32);
          if(!(return_value_tio_write$53 == 0))
          {
            signed int *return_value___errno_location$52;
            return_value___errno_location$52=__errno_location();
            if(*return_value___errno_location$52 == 32)
            {
              return_value___errno_location$48=__errno_location();
              return_value_strerror$49=strerror(*return_value___errno_location$48);
              log_log(7, "error writing to client: %s", return_value_strerror$49);
            }

            else
            {
              return_value___errno_location$50=__errno_location();
              return_value_strerror$51=strerror(*return_value___errno_location$50);
              log_log(4, "error writing to client: %s", return_value_strerror$51);
            }
            return -1;
          }

        }

      }
      unsigned int return_value_htonl$54;
      return_value_htonl$54=htonl((unsigned int)(signed int)lastchangedate);
      tmpint32 = (signed int)return_value_htonl$54;
      signed int return_value_tio_write$60;
      return_value_tio_write$60=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$60 == 0))
      {
        signed int *return_value___errno_location$59;
        return_value___errno_location$59=__errno_location();
        if(*return_value___errno_location$59 == 32)
        {
          return_value___errno_location$55=__errno_location();
          return_value_strerror$56=strerror(*return_value___errno_location$55);
          log_log(7, "error writing to client: %s", return_value_strerror$56);
        }

        else
        {
          return_value___errno_location$57=__errno_location();
          return_value_strerror$58=strerror(*return_value___errno_location$57);
          log_log(4, "error writing to client: %s", return_value_strerror$58);
        }
        return -1;
      }

      unsigned int return_value_htonl$61;
      return_value_htonl$61=htonl((unsigned int)(signed int)mindays);
      tmpint32 = (signed int)return_value_htonl$61;
      signed int return_value_tio_write$67;
      return_value_tio_write$67=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$67 == 0))
      {
        signed int *return_value___errno_location$66;
        return_value___errno_location$66=__errno_location();
        if(*return_value___errno_location$66 == 32)
        {
          return_value___errno_location$62=__errno_location();
          return_value_strerror$63=strerror(*return_value___errno_location$62);
          log_log(7, "error writing to client: %s", return_value_strerror$63);
        }

        else
        {
          return_value___errno_location$64=__errno_location();
          return_value_strerror$65=strerror(*return_value___errno_location$64);
          log_log(4, "error writing to client: %s", return_value_strerror$65);
        }
        return -1;
      }

      unsigned int return_value_htonl$68;
      return_value_htonl$68=htonl((unsigned int)(signed int)maxdays);
      tmpint32 = (signed int)return_value_htonl$68;
      signed int return_value_tio_write$74;
      return_value_tio_write$74=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$74 == 0))
      {
        signed int *return_value___errno_location$73;
        return_value___errno_location$73=__errno_location();
        if(*return_value___errno_location$73 == 32)
        {
          return_value___errno_location$69=__errno_location();
          return_value_strerror$70=strerror(*return_value___errno_location$69);
          log_log(7, "error writing to client: %s", return_value_strerror$70);
        }

        else
        {
          return_value___errno_location$71=__errno_location();
          return_value_strerror$72=strerror(*return_value___errno_location$71);
          log_log(4, "error writing to client: %s", return_value_strerror$72);
        }
        return -1;
      }

      unsigned int return_value_htonl$75;
      return_value_htonl$75=htonl((unsigned int)(signed int)warndays);
      tmpint32 = (signed int)return_value_htonl$75;
      signed int return_value_tio_write$81;
      return_value_tio_write$81=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$81 == 0))
      {
        signed int *return_value___errno_location$80;
        return_value___errno_location$80=__errno_location();
        if(*return_value___errno_location$80 == 32)
        {
          return_value___errno_location$76=__errno_location();
          return_value_strerror$77=strerror(*return_value___errno_location$76);
          log_log(7, "error writing to client: %s", return_value_strerror$77);
        }

        else
        {
          return_value___errno_location$78=__errno_location();
          return_value_strerror$79=strerror(*return_value___errno_location$78);
          log_log(4, "error writing to client: %s", return_value_strerror$79);
        }
        return -1;
      }

      unsigned int return_value_htonl$82;
      return_value_htonl$82=htonl((unsigned int)(signed int)inactdays);
      tmpint32 = (signed int)return_value_htonl$82;
      signed int return_value_tio_write$88;
      return_value_tio_write$88=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$88 == 0))
      {
        signed int *return_value___errno_location$87;
        return_value___errno_location$87=__errno_location();
        if(*return_value___errno_location$87 == 32)
        {
          return_value___errno_location$83=__errno_location();
          return_value_strerror$84=strerror(*return_value___errno_location$83);
          log_log(7, "error writing to client: %s", return_value_strerror$84);
        }

        else
        {
          return_value___errno_location$85=__errno_location();
          return_value_strerror$86=strerror(*return_value___errno_location$85);
          log_log(4, "error writing to client: %s", return_value_strerror$86);
        }
        return -1;
      }

      unsigned int return_value_htonl$89;
      return_value_htonl$89=htonl((unsigned int)(signed int)expiredate);
      tmpint32 = (signed int)return_value_htonl$89;
      signed int return_value_tio_write$95;
      return_value_tio_write$95=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$95 == 0))
      {
        signed int *return_value___errno_location$94;
        return_value___errno_location$94=__errno_location();
        if(*return_value___errno_location$94 == 32)
        {
          return_value___errno_location$90=__errno_location();
          return_value_strerror$91=strerror(*return_value___errno_location$90);
          log_log(7, "error writing to client: %s", return_value_strerror$91);
        }

        else
        {
          return_value___errno_location$92=__errno_location();
          return_value_strerror$93=strerror(*return_value___errno_location$92);
          log_log(4, "error writing to client: %s", return_value_strerror$93);
        }
        return -1;
      }

      unsigned int return_value_htonl$96;
      return_value_htonl$96=htonl((unsigned int)(signed int)flag);
      tmpint32 = (signed int)return_value_htonl$96;
      signed int return_value_tio_write$102;
      return_value_tio_write$102=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_tio_write$102 == 0))
      {
        signed int *return_value___errno_location$101;
        return_value___errno_location$101=__errno_location();
        if(*return_value___errno_location$101 == 32)
        {
          return_value___errno_location$97=__errno_location();
          return_value_strerror$98=strerror(*return_value___errno_location$97);
          log_log(7, "error writing to client: %s", return_value_strerror$98);
        }

        else
        {
          return_value___errno_location$99=__errno_location();
          return_value_strerror$100=strerror(*return_value___errno_location$99);
          log_log(4, "error writing to client: %s", return_value_strerror$100);
        }
        return -1;
      }

    }

  }
  return 0;
}

// write_string_stripspace_len
// file netgroup.c line 97
static signed int write_string_stripspace_len(struct tio_fileinfo *fp, const char *str, signed int len)
{
  signed int tmpint32;
  signed int i;
  signed int j;
  i = 0;
  _Bool tmp_if_expr$2;
  const unsigned short int **return_value___ctype_b_loc$1;
  do
  {
    if(!((signed int)str[(signed long int)i] == 0))
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      tmp_if_expr$2 = ((signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)str[(signed long int)i]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  j = len;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  do
  {
    if(!(i >= j))
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      tmp_if_expr$4 = ((signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)str[(signed long int)(j - 1)]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(!tmp_if_expr$4)
      break;

    j = j - 1;
  }
  while((_Bool)1);
  unsigned int return_value_htonl$5;
  return_value_htonl$5=htonl((unsigned int)(signed int)(j - i));
  tmpint32 = (signed int)return_value_htonl$5;
  signed int return_value_tio_write$11;
  return_value_tio_write$11=tio_write(fp, (const void *)&tmpint32, (unsigned long int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  if(!(return_value_tio_write$11 == 0))
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    if(*return_value___errno_location$10 == 32)
    {
      return_value___errno_location$6=__errno_location();
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      log_log(7, "error writing to client: %s", return_value_strerror$7);
    }

    else
    {
      return_value___errno_location$8=__errno_location();
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_log(4, "error writing to client: %s", return_value_strerror$9);
    }
    return -1;
  }

  signed int *return_value___errno_location$12;
  char *return_value_strerror$13;
  signed int *return_value___errno_location$14;
  char *return_value_strerror$15;
  if(!(i >= j))
  {
    signed int return_value_tio_write$17;
    return_value_tio_write$17=tio_write(fp, (const void *)(str + (signed long int)i), (unsigned long int)j - (unsigned long int)i);
    if(!(return_value_tio_write$17 == 0))
    {
      signed int *return_value___errno_location$16;
      return_value___errno_location$16=__errno_location();
      if(*return_value___errno_location$16 == 32)
      {
        return_value___errno_location$12=__errno_location();
        return_value_strerror$13=strerror(*return_value___errno_location$12);
        log_log(7, "error writing to client: %s", return_value_strerror$13);
      }

      else
      {
        return_value___errno_location$14=__errno_location();
        return_value_strerror$15=strerror(*return_value___errno_location$14);
        log_log(4, "error writing to client: %s", return_value_strerror$15);
      }
      return -1;
    }

  }

  return 0;
}

// xstrdup
// file cfg.c line 81
static char * xstrdup(const char *s)
{
  char *tmp;
  if(s == ((const char *)NULL))
  {
    log_log(2, "xstrdup() called with NULL");
    exit(1);
  }

  tmp=strdup(s);
  if(tmp == ((char *)NULL))
  {
    log_log(2, "strdup() failed to allocate memory");
    exit(1);
  }

  return tmp;
}

