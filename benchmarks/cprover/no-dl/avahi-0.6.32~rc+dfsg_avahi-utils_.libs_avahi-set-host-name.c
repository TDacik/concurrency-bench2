// #anon_enum_AVAHI_BROWSER_NEW=0_AVAHI_BROWSER_REMOVE=1_AVAHI_BROWSER_CACHE_EXHAUSTED=2_AVAHI_BROWSER_ALL_FOR_NOW=3_AVAHI_BROWSER_FAILURE=4
// file ../avahi-common/defs.h line 284
enum anonymous_2 { AVAHI_BROWSER_NEW=0, AVAHI_BROWSER_REMOVE=1, AVAHI_BROWSER_CACHE_EXHAUSTED=2, AVAHI_BROWSER_ALL_FOR_NOW=3, AVAHI_BROWSER_FAILURE=4 };

// #anon_enum_AVAHI_CLIENT_IGNORE_USER_CONFIG=1_AVAHI_CLIENT_NO_FAIL=2
// file ../avahi-client/client.h line 48
enum anonymous_8 { AVAHI_CLIENT_IGNORE_USER_CONFIG=1, AVAHI_CLIENT_NO_FAIL=2 };

// #anon_enum_AVAHI_CLIENT_S_REGISTERING=1_AVAHI_CLIENT_S_RUNNING=2_AVAHI_CLIENT_S_COLLISION=3_AVAHI_CLIENT_FAILURE=100_AVAHI_CLIENT_CONNECTING=101
// file ../avahi-client/client.h line 40
enum anonymous_7 { AVAHI_CLIENT_S_REGISTERING=1, AVAHI_CLIENT_S_RUNNING=2, AVAHI_CLIENT_S_COLLISION=3, AVAHI_CLIENT_FAILURE=100, AVAHI_CLIENT_CONNECTING=101 };

// #anon_enum_AVAHI_DOMAIN_BROWSER_BROWSE=0_AVAHI_DOMAIN_BROWSER_BROWSE_DEFAULT=1_AVAHI_DOMAIN_BROWSER_REGISTER=2_AVAHI_DOMAIN_BROWSER_REGISTER_DEFAULT=3_AVAHI_DOMAIN_BROWSER_BROWSE_LEGACY=4_AVAHI_DOMAIN_BROWSER_MAX=5
// file ../avahi-common/defs.h line 303
enum anonymous_0 { AVAHI_DOMAIN_BROWSER_BROWSE=0, AVAHI_DOMAIN_BROWSER_BROWSE_DEFAULT=1, AVAHI_DOMAIN_BROWSER_REGISTER=2, AVAHI_DOMAIN_BROWSER_REGISTER_DEFAULT=3, AVAHI_DOMAIN_BROWSER_BROWSE_LEGACY=4, AVAHI_DOMAIN_BROWSER_MAX=5 };

// #anon_enum_AVAHI_ENTRY_GROUP_UNCOMMITED=0_AVAHI_ENTRY_GROUP_REGISTERING=1_AVAHI_ENTRY_GROUP_ESTABLISHED=2_AVAHI_ENTRY_GROUP_COLLISION=3_AVAHI_ENTRY_GROUP_FAILURE=4
// file ../avahi-common/defs.h line 230
enum anonymous_27 { AVAHI_ENTRY_GROUP_UNCOMMITED=0, AVAHI_ENTRY_GROUP_REGISTERING=1, AVAHI_ENTRY_GROUP_ESTABLISHED=2, AVAHI_ENTRY_GROUP_COLLISION=3, AVAHI_ENTRY_GROUP_FAILURE=4 };

// #anon_enum_AVAHI_LOOKUP_RESULT_CACHED=1_AVAHI_LOOKUP_RESULT_WIDE_AREA=2_AVAHI_LOOKUP_RESULT_MULTICAST=4_AVAHI_LOOKUP_RESULT_LOCAL=8_AVAHI_LOOKUP_RESULT_OUR_OWN=16_AVAHI_LOOKUP_RESULT_STATIC=32
// file ../avahi-common/defs.h line 270
enum anonymous_3 { AVAHI_LOOKUP_RESULT_CACHED=1, AVAHI_LOOKUP_RESULT_WIDE_AREA=2, AVAHI_LOOKUP_RESULT_MULTICAST=4, AVAHI_LOOKUP_RESULT_LOCAL=8, AVAHI_LOOKUP_RESULT_OUR_OWN=16, AVAHI_LOOKUP_RESULT_STATIC=32 };

// #anon_enum_AVAHI_LOOKUP_USE_WIDE_AREA=1_AVAHI_LOOKUP_USE_MULTICAST=2_AVAHI_LOOKUP_NO_TXT=4_AVAHI_LOOKUP_NO_ADDRESS=8
// file ../avahi-common/defs.h line 260
enum anonymous_1 { AVAHI_LOOKUP_USE_WIDE_AREA=1, AVAHI_LOOKUP_USE_MULTICAST=2, AVAHI_LOOKUP_NO_TXT=4, AVAHI_LOOKUP_NO_ADDRESS=8 };

// #anon_enum_AVAHI_PUBLISH_UNIQUE=1_AVAHI_PUBLISH_NO_PROBE=2_AVAHI_PUBLISH_NO_ANNOUNCE=4_AVAHI_PUBLISH_ALLOW_MULTIPLE=8_AVAHI_PUBLISH_NO_REVERSE=16_AVAHI_PUBLISH_NO_COOKIE=32_AVAHI_PUBLISH_UPDATE=64_AVAHI_PUBLISH_USE_WIDE_AREA=128_AVAHI_PUBLISH_USE_MULTICAST=256
// file ../avahi-common/defs.h line 243
enum anonymous { AVAHI_PUBLISH_UNIQUE=1, AVAHI_PUBLISH_NO_PROBE=2, AVAHI_PUBLISH_NO_ANNOUNCE=4, AVAHI_PUBLISH_ALLOW_MULTIPLE=8, AVAHI_PUBLISH_NO_REVERSE=16, AVAHI_PUBLISH_NO_COOKIE=32, AVAHI_PUBLISH_UPDATE=64, AVAHI_PUBLISH_USE_WIDE_AREA=128, AVAHI_PUBLISH_USE_MULTICAST=256 };

// #anon_enum_AVAHI_RESOLVER_FOUND=0_AVAHI_RESOLVER_FAILURE=1
// file ../avahi-common/defs.h line 293
enum anonymous_6 { AVAHI_RESOLVER_FOUND=0, AVAHI_RESOLVER_FAILURE=1 };

// #anon_enum_AVAHI_WATCH_IN=1_AVAHI_WATCH_OUT=4_AVAHI_WATCH_ERR=8_AVAHI_WATCH_HUP=16
// file ../avahi-common/watch.h line 42
enum anonymous_9 { AVAHI_WATCH_IN=1, AVAHI_WATCH_OUT=4, AVAHI_WATCH_ERR=8, AVAHI_WATCH_HUP=16 };

// #anon_enum_COMMAND_UNSPEC=0_COMMAND_HELP=1_COMMAND_VERSION=2
// file avahi-set-host-name.c line 42
enum anonymous_5 { COMMAND_UNSPEC=0, COMMAND_HELP=1, COMMAND_VERSION=2 };

// #anon_enum_DBUS_BUS_SESSION=0_DBUS_BUS_SYSTEM=1_DBUS_BUS_STARTER=2
// file /usr/include/dbus-1.0/dbus/dbus-shared.h line 56
enum anonymous_29 { DBUS_BUS_SESSION=0, DBUS_BUS_SYSTEM=1, DBUS_BUS_STARTER=2 };

// #anon_enum_DBUS_DISPATCH_DATA_REMAINS=0_DBUS_DISPATCH_COMPLETE=1_DBUS_DISPATCH_NEED_MEMORY=2
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 79
enum anonymous_10 { DBUS_DISPATCH_DATA_REMAINS=0, DBUS_DISPATCH_COMPLETE=1, DBUS_DISPATCH_NEED_MEMORY=2 };

// #anon_enum_DBUS_HANDLER_RESULT_HANDLED=0_DBUS_HANDLER_RESULT_NOT_YET_HANDLED=1_DBUS_HANDLER_RESULT_NEED_MEMORY=2
// file /usr/include/dbus-1.0/dbus/dbus-shared.h line 66
enum anonymous_28 { DBUS_HANDLER_RESULT_HANDLED=0, DBUS_HANDLER_RESULT_NOT_YET_HANDLED=1, DBUS_HANDLER_RESULT_NEED_MEMORY=2 };

// #anon_enum_STATE_INIT=0_STATE_PREPARING=1_STATE_PREPARED=2_STATE_RUNNING=3_STATE_RAN=4_STATE_DISPATCHING=5_STATE_DISPATCHED=6_STATE_QUIT=7_STATE_FAILURE=8
// file simple-watch.c line 84
enum anonymous_4 { STATE_INIT=0, STATE_PREPARING=1, STATE_PREPARED=2, STATE_RUNNING=3, STATE_RAN=4, STATE_DISPATCHING=5, STATE_DISPATCHED=6, STATE_QUIT=7, STATE_FAILURE=8 };

// tag-#anon#ST[*{SYM#tag-DBusConnection#}_SYM#tag-DBusConnection#_'connection'||*{cSYM#tag-AvahiPoll#}_cSYM#tag-AvahiPoll#_'poll_api'||*{SYM#tag-AvahiTimeout#}_SYM#tag-AvahiTimeout#_'dispatch_timeout'||S32'ref'||U32'_pad0'|]
// file ../avahi-common/dbus-watch-glue.c line 61
struct anonymous_11;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_22;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_20;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_15;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_16;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_19;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_18;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_13;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_17;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_21;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_14;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_12;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_26;

// tag-#anon#UN[SYM#tag-AvahiIPv6Address#'ipv6'||SYM#tag-AvahiIPv4Address#'ipv4'||ARR1{U8}_U8_'data'|]
// file ../avahi-common/address.h line 73
union anonymous_23;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_25;

// tag-AvahiAddress
// file ../avahi-common/address.h line 70
struct AvahiAddress;

// tag-AvahiAddressResolver
// file lookup.h line 242
struct AvahiAddressResolver;

// tag-AvahiAllocator
// file malloc.h line 75
struct AvahiAllocator;

// tag-AvahiClient
// file client.h line 37
struct AvahiClient;

// tag-AvahiDomainBrowser
// file lookup.h line 44
struct AvahiDomainBrowser;

// tag-AvahiEntryGroup
// file publish.h line 43
struct AvahiEntryGroup;

// tag-AvahiHostNameResolver
// file lookup.h line 211
struct AvahiHostNameResolver;

// tag-AvahiIPv4Address
// file ../avahi-common/address.h line 60
struct AvahiIPv4Address;

// tag-AvahiIPv6Address
// file ../avahi-common/address.h line 65
struct AvahiIPv6Address;

// tag-AvahiPoll
// file ../avahi-common/watch.h line 39
struct AvahiPoll;

// tag-AvahiRList
// file rlist.h line 30
struct AvahiRList;

// tag-AvahiRecordBrowser
// file lookup.h line 276
struct AvahiRecordBrowser;

// tag-AvahiServiceBrowser
// file lookup.h line 78
struct AvahiServiceBrowser;

// tag-AvahiServiceResolver
// file lookup.h line 157
struct AvahiServiceResolver;

// tag-AvahiServiceTypeBrowser
// file lookup.h line 123
struct AvahiServiceTypeBrowser;

// tag-AvahiSimplePoll
// file simple-watch.h line 34
struct AvahiSimplePoll;

// tag-AvahiStringList
// file ../avahi-common/strlst.h line 40
struct AvahiStringList;

// tag-AvahiThreadedPoll
// file thread-watch.h line 32
struct AvahiThreadedPoll;

// tag-AvahiTimeout
// file ../avahi-common/watch.h line 36
struct AvahiTimeout;

// tag-AvahiWatch
// file ../avahi-common/watch.h line 33
struct AvahiWatch;

// tag-Config
// file avahi-set-host-name.c line 48
struct Config;

// tag-DBusConnection
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 51
struct DBusConnection;

// tag-DBusError
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 43
struct DBusError;

// tag-DBusMessage
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 44
struct DBusMessage;

// tag-DBusMessageIter
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 46
struct DBusMessageIter;

// tag-DBusTimeout
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 45
struct DBusTimeout;

// tag-DBusWatch
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 43
struct DBusWatch;

// tag-TimeoutData
// file ../avahi-common/dbus-watch-glue.c line 196
struct TimeoutData;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-error_map
// file ../avahi-common/dbus.c line 93
struct error_map;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// add_timeout
// file ../avahi-common/dbus-watch-glue.c line 254
static unsigned int add_timeout(struct DBusTimeout *dbus_timeout, void *userdata);
// add_watch
// file ../avahi-common/dbus-watch-glue.c line 165
static unsigned int add_watch(struct DBusWatch *dbus_watch, void *userdata);
// address_get_size
// file address.c line 35
static unsigned long int address_get_size(const struct AvahiAddress *a);
// address_get_size_link1
// file address.c line 35
static unsigned long int address_get_size_link1(const struct AvahiAddress *a_link1);
// append_rdata
// file entrygroup.c line 348
static signed int append_rdata(struct DBusMessage *message, const void *rdata, unsigned long int size);
// append_string_list
// file entrygroup.c line 363
static signed int append_string_list(struct DBusMessage *message, struct AvahiStringList *txt);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// avahi_address_cmp
// file address.c line 46
signed int avahi_address_cmp(const struct AvahiAddress *a, const struct AvahiAddress *b);
// avahi_address_parse
// file ../avahi-common/address.h line 95
struct AvahiAddress * avahi_address_parse(const char *s, signed int proto, struct AvahiAddress *ret_addr);
// avahi_address_resolver_event
// file internal.h line 166
enum anonymous_28 avahi_address_resolver_event(struct AvahiClient *client, enum anonymous_6 event, struct DBusMessage *message);
// avahi_address_resolver_free
// file lookup.h line 269
signed int avahi_address_resolver_free(struct AvahiAddressResolver *r);
// avahi_address_resolver_get_client
// file resolver.c line 755
struct AvahiClient * avahi_address_resolver_get_client(struct AvahiAddressResolver *r);
// avahi_address_resolver_new
// file resolver.c line 642
struct AvahiAddressResolver * avahi_address_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const struct AvahiAddress *a, enum anonymous_1 flags, void (*callback)(struct AvahiAddressResolver *, signed int, signed int, enum anonymous_6, const struct AvahiAddress *, const char *, enum anonymous_3, void *), void *userdata);
// avahi_address_resolver_new::callback_object
//
void callback_object(struct AvahiAddressResolver *, signed int, signed int, enum anonymous_6, const struct AvahiAddress *, const char *, enum anonymous_3, void *);
// avahi_address_snprint
// file ../avahi-common/address.h line 90
char * avahi_address_snprint(char *s, unsigned long int length, const struct AvahiAddress *a);
// avahi_af_to_proto
// file address.c line 137
signed int avahi_af_to_proto(signed int af);
// avahi_age
// file timeval.c line 76
signed long int avahi_age(struct timeval *a);
// avahi_alternative_host_name
// file alternative.c line 51
char * avahi_alternative_host_name(const char *s);
// avahi_alternative_service_name
// file alternative.c line 117
char * avahi_alternative_service_name(const char *s);
// avahi_client_errno
// file ../avahi-client/client.h line 99
signed int avahi_client_errno(struct AvahiClient *client);
// avahi_client_free
// file ../avahi-client/client.h line 72
void avahi_client_free(struct AvahiClient *client);
// avahi_client_get_domain_name
// file client.c line 742
const char * avahi_client_get_domain_name(struct AvahiClient *client);
// avahi_client_get_host_name
// file client.c line 756
const char * avahi_client_get_host_name(struct AvahiClient *client);
// avahi_client_get_host_name_fqdn
// file ../avahi-client/client.h line 91
const char * avahi_client_get_host_name_fqdn(struct AvahiClient *client);
// avahi_client_get_local_service_cookie
// file client.c line 846
unsigned int avahi_client_get_local_service_cookie(struct AvahiClient *client);
// avahi_client_get_state
// file client.c line 784
enum anonymous_7 avahi_client_get_state(struct AvahiClient *client);
// avahi_client_get_string_reply_and_block
// file client.c line 672
static char * avahi_client_get_string_reply_and_block(struct AvahiClient *client, const char *method, const char *param);
// avahi_client_get_version_string
// file ../avahi-client/client.h line 79
const char * avahi_client_get_version_string(struct AvahiClient *client);
// avahi_client_is_connected
// file client.c line 896
signed int avahi_client_is_connected(struct AvahiClient *client);
// avahi_client_new
// file ../avahi-client/client.h line 62
struct AvahiClient * avahi_client_new(const struct AvahiPoll *poll_api, enum anonymous_8 flags, void (*callback)(struct AvahiClient *, enum anonymous_7, void *), void *userdata, signed int *ret_error);
// avahi_client_new::callback_object
//
void callback_object(struct AvahiClient *, enum anonymous_7, void *);
// avahi_client_set_dbus_error
// file client.c line 51
signed int avahi_client_set_dbus_error(struct AvahiClient *client, struct DBusError *error);
// avahi_client_set_errno
// file client.c line 45
signed int avahi_client_set_errno(struct AvahiClient *client, signed int error);
// avahi_client_set_host_name
// file ../avahi-client/client.h line 85
signed int avahi_client_set_host_name(struct AvahiClient *client, const char *name);
// avahi_client_simple_method_call
// file client.c line 797
signed int avahi_client_simple_method_call(struct AvahiClient *client, const char *path, const char *interface, const char *method);
// avahi_dbus_bus_get
// file client.c line 445
static struct DBusConnection * avahi_dbus_bus_get(struct DBusError *error);
// avahi_dbus_connection_glue
// file ../avahi-common/dbus-watch-glue.h line 29
signed int avahi_dbus_connection_glue(struct DBusConnection *c, const struct AvahiPoll *poll_api);
// avahi_domain_browser_event
// file internal.h line 159
enum anonymous_28 avahi_domain_browser_event(struct AvahiClient *client, enum anonymous_2 event, struct DBusMessage *message);
// avahi_domain_browser_free
// file lookup.h line 71
signed int avahi_domain_browser_free(struct AvahiDomainBrowser *b);
// avahi_domain_browser_get_client
// file browser.c line 234
struct AvahiClient * avahi_domain_browser_get_client(struct AvahiDomainBrowser *b);
// avahi_domain_browser_new
// file browser.c line 104
struct AvahiDomainBrowser * avahi_domain_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous_0 btype, enum anonymous_1 flags, void (*callback)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous_2, const char *, enum anonymous_3, void *), void *userdata);
// avahi_domain_browser_new::callback_object
//
void callback_object(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous_2, const char *, enum anonymous_3, void *);
// avahi_domain_equal
// file ../avahi-common/domain.h line 62
signed int avahi_domain_equal(const char *a, const char *b);
// avahi_domain_hash
// file domain.c line 424
unsigned int avahi_domain_hash(const char *s);
// avahi_elapse_time
// file ../avahi-common/timeval.h line 50
struct timeval * avahi_elapse_time(struct timeval *tv, unsigned int msec, unsigned int jitter);
// avahi_entry_group_add_address
// file entrygroup.c line 721
signed int avahi_entry_group_add_address(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, const struct AvahiAddress *a);
// avahi_entry_group_add_record
// file entrygroup.c line 808
signed int avahi_entry_group_add_record(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, unsigned short int clazz, unsigned short int type, unsigned int ttl, const void *rdata, unsigned long int size);
// avahi_entry_group_add_service
// file entrygroup.c line 496
signed int avahi_entry_group_add_service(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, ...);
// avahi_entry_group_add_service_strlst
// file entrygroup.c line 402
signed int avahi_entry_group_add_service_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, struct AvahiStringList *txt);
// avahi_entry_group_add_service_subtype
// file entrygroup.c line 522
signed int avahi_entry_group_add_service_subtype(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, const char *type, const char *domain, const char *subtype);
// avahi_entry_group_commit
// file entrygroup.c line 253
signed int avahi_entry_group_commit(struct AvahiEntryGroup *group);
// avahi_entry_group_free
// file publish.h line 60
signed int avahi_entry_group_free(struct AvahiEntryGroup *group);
// avahi_entry_group_get_client
// file entrygroup.c line 290
struct AvahiClient * avahi_entry_group_get_client(struct AvahiEntryGroup *group);
// avahi_entry_group_get_state
// file entrygroup.c line 281
signed int avahi_entry_group_get_state(struct AvahiEntryGroup *group);
// avahi_entry_group_is_empty
// file entrygroup.c line 296
signed int avahi_entry_group_is_empty(struct AvahiEntryGroup *group);
// avahi_entry_group_new
// file entrygroup.c line 101
struct AvahiEntryGroup * avahi_entry_group_new(struct AvahiClient *client, void (*callback)(struct AvahiEntryGroup *, enum anonymous_27, void *), void *userdata);
// avahi_entry_group_new::callback_object
//
void callback_object(struct AvahiEntryGroup *, enum anonymous_27, void *);
// avahi_entry_group_reset
// file entrygroup.c line 267
signed int avahi_entry_group_reset(struct AvahiEntryGroup *group);
// avahi_entry_group_set_state
// file internal.h line 157
void avahi_entry_group_set_state(struct AvahiEntryGroup *group, enum anonymous_27 state);
// avahi_entry_group_update_service_txt
// file entrygroup.c line 611
signed int avahi_entry_group_update_service_txt(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, const char *type, const char *domain, ...);
// avahi_entry_group_update_service_txt_strlst
// file entrygroup.c line 633
signed int avahi_entry_group_update_service_txt_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, const char *type, const char *domain, struct AvahiStringList *txt);
// avahi_error_dbus_to_number
// file ../avahi-common/dbus.h line 112
signed int avahi_error_dbus_to_number(const char *s);
// avahi_error_number_to_dbus
// file ../avahi-common/dbus.c line 133
const char * avahi_error_number_to_dbus(signed int error);
// avahi_escape_label
// file domain.c line 116
char * avahi_escape_label(const char *src, unsigned long int src_length, char **ret_name, unsigned long int *ret_size);
// avahi_free
// file ../avahi-common/malloc.h line 42
void avahi_free(void *p);
// avahi_get_type_from_subtype
// file domain.c line 306
const char * avahi_get_type_from_subtype(const char *t);
// avahi_host_name_resolver_event
// file internal.h line 165
enum anonymous_28 avahi_host_name_resolver_event(struct AvahiClient *client, enum anonymous_6 event, struct DBusMessage *message);
// avahi_host_name_resolver_free
// file lookup.h line 239
signed int avahi_host_name_resolver_free(struct AvahiHostNameResolver *r);
// avahi_host_name_resolver_get_client
// file resolver.c line 558
struct AvahiClient * avahi_host_name_resolver_get_client(struct AvahiHostNameResolver *r);
// avahi_host_name_resolver_new
// file resolver.c line 424
struct AvahiHostNameResolver * avahi_host_name_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, signed int aprotocol, enum anonymous_1 flags, void (*callback)(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous_6, const char *, const struct AvahiAddress *, enum anonymous_3, void *), void *userdata);
// avahi_host_name_resolver_new::callback_object
//
void callback_object(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous_6, const char *, const struct AvahiAddress *, enum anonymous_3, void *);
// avahi_init_i18n
// file ../avahi-common/i18n.h line 51
void avahi_init_i18n(void);
// avahi_is_valid_domain_name
// file domain.c line 369
signed int avahi_is_valid_domain_name(const char *t);
// avahi_is_valid_fqdn
// file domain.c line 575
signed int avahi_is_valid_fqdn(const char *t);
// avahi_is_valid_host_name
// file domain.h line 103
signed int avahi_is_valid_host_name(const char *t);
// avahi_is_valid_service_name
// file domain.h line 100
signed int avahi_is_valid_service_name(const char *t);
// avahi_is_valid_service_subtype
// file domain.c line 363
signed int avahi_is_valid_service_subtype(const char *t);
// avahi_is_valid_service_type_generic
// file domain.c line 254
signed int avahi_is_valid_service_type_generic(const char *t);
// avahi_is_valid_service_type_strict
// file domain.c line 274
signed int avahi_is_valid_service_type_strict(const char *t);
// avahi_malloc
// file ../avahi-common/malloc.h line 36
void * avahi_malloc(unsigned long int size);
// avahi_malloc0
// file malloc.c line 113
void * avahi_malloc0(unsigned long int size);
// avahi_memdup
// file malloc.c line 248
void * avahi_memdup(const void *s, unsigned long int l);
// avahi_new_internal
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal(unsigned int n, unsigned long int k);
// avahi_new_internal_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link1(unsigned int n_link1, unsigned long int k_link1);
// avahi_new_internal_link1_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link1(unsigned int n_link1_link1, unsigned long int k_link1_link1);
// avahi_new_internal_link1_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link2(unsigned int n_link1_link2, unsigned long int k_link1_link2);
// avahi_new_internal_link2
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link2(unsigned int n_link2, unsigned long int k_link2);
// avahi_new_internal_link2_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link1(unsigned int n_link2_link1, unsigned long int k_link2_link1);
// avahi_new_internal_link2_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link2(unsigned int n_link2_link2, unsigned long int k_link2_link2);
// avahi_new_internal_link3
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link3(unsigned int n_link3, unsigned long int k_link3);
// avahi_new_internal_link3_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link1(unsigned int n_link3_link1, unsigned long int k_link3_link1);
// avahi_new_internal_link3_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link2(unsigned int n_link3_link2, unsigned long int k_link3_link2);
// avahi_new_internal_link4
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link4(unsigned int n_link4, unsigned long int k_link4);
// avahi_new_internal_link4_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link1(unsigned int n_link4_link1, unsigned long int k_link4_link1);
// avahi_new_internal_link4_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link2(unsigned int n_link4_link2, unsigned long int k_link4_link2);
// avahi_new_internal_link5
// file malloc.h line 48
static inline void * avahi_new_internal_link5(unsigned int n_link5, unsigned long int k_link5);
// avahi_new_internal_link6
// file malloc.h line 48
static inline void * avahi_new_internal_link6(unsigned int n_link6, unsigned long int k_link6);
// avahi_normalize_name
// file ../avahi-common/domain.h line 50
char * avahi_normalize_name(const char *s, char *ret_s, unsigned long int size);
// avahi_normalize_name_strdup
// file domain.c line 219
char * avahi_normalize_name_strdup(const char *s);
// avahi_nss_support
// file check-nss.c line 31
signed int avahi_nss_support(void);
// avahi_proto_to_af
// file address.c line 127
signed int avahi_proto_to_af(signed int proto);
// avahi_proto_to_string
// file address.c line 147
const char * avahi_proto_to_string(signed int proto);
// avahi_realloc
// file malloc.c line 146
void * avahi_realloc(void *p, unsigned long int size);
// avahi_record_browser_event
// file internal.h line 162
enum anonymous_28 avahi_record_browser_event(struct AvahiClient *client, enum anonymous_2 event, struct DBusMessage *message);
// avahi_record_browser_free
// file lookup.h line 308
signed int avahi_record_browser_free(struct AvahiRecordBrowser *b);
// avahi_record_browser_get_client
// file browser.c line 903
struct AvahiClient * avahi_record_browser_get_client(struct AvahiRecordBrowser *b);
// avahi_record_browser_new
// file browser.c line 786
struct AvahiRecordBrowser * avahi_record_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, unsigned short int clazz, unsigned short int type, enum anonymous_1 flags, void (*callback)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous_2, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous_3, void *), void *userdata);
// avahi_record_browser_new::callback_object
//
void callback_object(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous_2, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous_3, void *);
// avahi_reverse_lookup_name
// file address.c line 67
char * avahi_reverse_lookup_name(const struct AvahiAddress *a, char *ret_s, unsigned long int length);
// avahi_rlist_prepend
// file rlist.c line 29
struct AvahiRList * avahi_rlist_prepend(struct AvahiRList *r, void *data);
// avahi_rlist_remove
// file rlist.c line 41
struct AvahiRList * avahi_rlist_remove(struct AvahiRList *r, void *data);
// avahi_rlist_remove_by_link
// file rlist.c line 55
struct AvahiRList * avahi_rlist_remove_by_link(struct AvahiRList *r, struct AvahiRList *n);
// avahi_service_browser_event
// file internal.h line 161
enum anonymous_28 avahi_service_browser_event(struct AvahiClient *client, enum anonymous_2 event, struct DBusMessage *message);
// avahi_service_browser_free
// file lookup.h line 117
signed int avahi_service_browser_free(struct AvahiServiceBrowser *b);
// avahi_service_browser_get_client
// file browser.c line 686
struct AvahiClient * avahi_service_browser_get_client(struct AvahiServiceBrowser *b);
// avahi_service_browser_new
// file browser.c line 564
struct AvahiServiceBrowser * avahi_service_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *type, const char *domain, enum anonymous_1 flags, void (*callback)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous_2, const char *, const char *, const char *, enum anonymous_3, void *), void *userdata);
// avahi_service_browser_new::callback_object
//
void callback_object(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous_2, const char *, const char *, const char *, enum anonymous_3, void *);
// avahi_service_name_join
// file domain.c line 440
signed int avahi_service_name_join(char *p, unsigned long int size, const char *name, const char *type, const char *domain);
// avahi_service_name_split
// file domain.c line 496
signed int avahi_service_name_split(const char *p, char *name, unsigned long int name_size, char *type, unsigned long int type_size, char *domain, unsigned long int domain_size);
// avahi_service_resolver_event
// file internal.h line 164
enum anonymous_28 avahi_service_resolver_event(struct AvahiClient *client, enum anonymous_6 event, struct DBusMessage *message);
// avahi_service_resolver_free
// file lookup.h line 205
signed int avahi_service_resolver_free(struct AvahiServiceResolver *r);
// avahi_service_resolver_get_client
// file resolver.c line 318
struct AvahiClient * avahi_service_resolver_get_client(struct AvahiServiceResolver *r);
// avahi_service_resolver_new
// file resolver.c line 179
struct AvahiServiceResolver * avahi_service_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, const char *type, const char *domain, signed int aprotocol, enum anonymous_1 flags, void (*callback)(struct AvahiServiceResolver *, signed int, signed int, enum anonymous_6, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous_3, void *), void *userdata);
// avahi_service_resolver_new::callback_object
//
void callback_object(struct AvahiServiceResolver *, signed int, signed int, enum anonymous_6, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous_3, void *);
// avahi_service_type_browser_event
// file internal.h line 160
enum anonymous_28 avahi_service_type_browser_event(struct AvahiClient *client, enum anonymous_2 event, struct DBusMessage *message);
// avahi_service_type_browser_free
// file lookup.h line 150
signed int avahi_service_type_browser_free(struct AvahiServiceTypeBrowser *b);
// avahi_service_type_browser_get_client
// file browser.c line 465
struct AvahiClient * avahi_service_type_browser_get_client(struct AvahiServiceTypeBrowser *b);
// avahi_service_type_browser_new
// file browser.c line 350
struct AvahiServiceTypeBrowser * avahi_service_type_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous_1 flags, void (*callback)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous_2, const char *, const char *, enum anonymous_3, void *), void *userdata);
// avahi_service_type_browser_new::callback_object
//
void callback_object(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous_2, const char *, const char *, enum anonymous_3, void *);
// avahi_set_allocator
// file malloc.c line 196
void avahi_set_allocator(const struct AvahiAllocator *a);
// avahi_simple_poll_dispatch
// file simple-watch.c line 547
signed int avahi_simple_poll_dispatch(struct AvahiSimplePoll *s);
// avahi_simple_poll_free
// file ../avahi-common/simple-watch.h line 40
void avahi_simple_poll_free(struct AvahiSimplePoll *s);
// avahi_simple_poll_get
// file ../avahi-common/simple-watch.h line 45
const struct AvahiPoll * avahi_simple_poll_get(struct AvahiSimplePoll *s);
// avahi_simple_poll_iterate
// file simple-watch.c line 596
signed int avahi_simple_poll_iterate(struct AvahiSimplePoll *s, signed int timeout);
// avahi_simple_poll_loop
// file simple-watch.c line 640
signed int avahi_simple_poll_loop(struct AvahiSimplePoll *s);
// avahi_simple_poll_new
// file ../avahi-common/simple-watch.h line 37
struct AvahiSimplePoll * avahi_simple_poll_new(void);
// avahi_simple_poll_prepare
// file simple-watch.c line 450
signed int avahi_simple_poll_prepare(struct AvahiSimplePoll *s, signed int timeout);
// avahi_simple_poll_quit
// file ../avahi-common/simple-watch.h line 60
void avahi_simple_poll_quit(struct AvahiSimplePoll *s);
// avahi_simple_poll_run
// file simple-watch.c line 518
signed int avahi_simple_poll_run(struct AvahiSimplePoll *s);
// avahi_simple_poll_set_func
// file simple-watch.c line 630
void avahi_simple_poll_set_func(struct AvahiSimplePoll *s, signed int (*func)(struct pollfd *, unsigned int, signed int, void *), void *userdata);
// avahi_simple_poll_set_func::func_link1_object
//
signed int func_link1_object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_set_func::func_object
//
signed int func_object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_wakeup
// file simple-watch.c line 97
void avahi_simple_poll_wakeup(struct AvahiSimplePoll *s);
// avahi_strdup
// file ../avahi-common/malloc.h line 66
char * avahi_strdup(const char *s);
// avahi_strdup_printf
// file malloc.c line 235
char * avahi_strdup_printf(const char *fmt, ...);
// avahi_strdup_vprintf
// file malloc.c line 200
char * avahi_strdup_vprintf(const char *fmt, void **ap);
// avahi_strerror
// file ../avahi-common/error.h line 103
const char * avahi_strerror(signed int error);
// avahi_string_list_add
// file ../avahi-common/strlst.h line 73
struct AvahiStringList * avahi_string_list_add(struct AvahiStringList *l, const char *text);
// avahi_string_list_add_anonymous
// file strlst.c line 34
struct AvahiStringList * avahi_string_list_add_anonymous(struct AvahiStringList *l, unsigned long int size);
// avahi_string_list_add_arbitrary
// file ../avahi-common/strlst.h line 85
struct AvahiStringList * avahi_string_list_add_arbitrary(struct AvahiStringList *l, const unsigned char *text, unsigned long int size);
// avahi_string_list_add_many
// file strlst.c line 255
struct AvahiStringList * avahi_string_list_add_many(struct AvahiStringList *r, ...);
// avahi_string_list_add_many_va
// file strlst.c line 265
struct AvahiStringList * avahi_string_list_add_many_va(struct AvahiStringList *r, __builtin_va_list va);
// avahi_string_list_add_pair
// file strlst.c line 395
struct AvahiStringList * avahi_string_list_add_pair(struct AvahiStringList *l, const char *key, const char *value);
// avahi_string_list_add_pair_arbitrary
// file strlst.c line 404
struct AvahiStringList * avahi_string_list_add_pair_arbitrary(struct AvahiStringList *l, const char *key, const unsigned char *value, unsigned long int size);
// avahi_string_list_add_printf
// file strlst.c line 366
struct AvahiStringList * avahi_string_list_add_printf(struct AvahiStringList *l, const char *format, ...);
// avahi_string_list_add_vprintf
// file strlst.c line 326
struct AvahiStringList * avahi_string_list_add_vprintf(struct AvahiStringList *l, const char *format, void **va);
// avahi_string_list_copy
// file strlst.c line 293
struct AvahiStringList * avahi_string_list_copy(const struct AvahiStringList *l);
// avahi_string_list_equal
// file strlst.c line 235
signed int avahi_string_list_equal(const struct AvahiStringList *a, const struct AvahiStringList *b);
// avahi_string_list_find
// file strlst.c line 378
struct AvahiStringList * avahi_string_list_find(struct AvahiStringList *l, const char *key);
// avahi_string_list_free
// file ../avahi-common/strlst.h line 64
void avahi_string_list_free(struct AvahiStringList *l);
// avahi_string_list_get_next
// file strlst.c line 469
struct AvahiStringList * avahi_string_list_get_next(struct AvahiStringList *l);
// avahi_string_list_get_pair
// file strlst.c line 423
signed int avahi_string_list_get_pair(struct AvahiStringList *l, char **key, char **value, unsigned long int *size);
// avahi_string_list_get_service_cookie
// file strlst.c line 484
unsigned int avahi_string_list_get_service_cookie(struct AvahiStringList *l);
// avahi_string_list_get_size
// file strlst.c line 479
unsigned long int avahi_string_list_get_size(struct AvahiStringList *l);
// avahi_string_list_get_text
// file strlst.c line 474
unsigned char * avahi_string_list_get_text(struct AvahiStringList *l);
// avahi_string_list_length
// file strlst.c line 317
unsigned int avahi_string_list_length(const struct AvahiStringList *l);
// avahi_string_list_new
// file strlst.c line 274
struct AvahiStringList * avahi_string_list_new(const char *txt, ...);
// avahi_string_list_new_from_array
// file strlst.c line 305
struct AvahiStringList * avahi_string_list_new_from_array(const char **array, signed int length);
// avahi_string_list_new_va
// file ../avahi-common/strlst.h line 55
struct AvahiStringList * avahi_string_list_new_va(void **va);
// avahi_string_list_parse
// file strlst.c line 69
signed int avahi_string_list_parse(const void *data, unsigned long int size, struct AvahiStringList **ret);
// avahi_string_list_reverse
// file ../avahi-common/strlst.h line 130
struct AvahiStringList * avahi_string_list_reverse(struct AvahiStringList *l);
// avahi_string_list_serialize
// file strlst.c line 168
unsigned long int avahi_string_list_serialize(struct AvahiStringList *l, void *data, unsigned long int size);
// avahi_string_list_to_string
// file strlst.c line 131
char * avahi_string_list_to_string(struct AvahiStringList *l);
// avahi_strndup
// file malloc.c line 175
char * avahi_strndup(const char *s, unsigned long int max);
// avahi_threaded_poll_free
// file thread-watch.c line 107
void avahi_threaded_poll_free(struct AvahiThreadedPoll *p);
// avahi_threaded_poll_get
// file thread-watch.c line 123
const struct AvahiPoll * avahi_threaded_poll_get(struct AvahiThreadedPoll *p);
// avahi_threaded_poll_lock
// file thread-watch.c line 170
void avahi_threaded_poll_lock(struct AvahiThreadedPoll *p);
// avahi_threaded_poll_new
// file thread-watch.c line 77
struct AvahiThreadedPoll * avahi_threaded_poll_new(void);
// avahi_threaded_poll_quit
// file thread-watch.c line 161
void avahi_threaded_poll_quit(struct AvahiThreadedPoll *p);
// avahi_threaded_poll_start
// file thread-watch.c line 129
signed int avahi_threaded_poll_start(struct AvahiThreadedPoll *p);
// avahi_threaded_poll_stop
// file thread-watch.c line 142
signed int avahi_threaded_poll_stop(struct AvahiThreadedPoll *p);
// avahi_threaded_poll_unlock
// file thread-watch.c line 179
void avahi_threaded_poll_unlock(struct AvahiThreadedPoll *p);
// avahi_timeval_add
// file timeval.c line 59
struct timeval * avahi_timeval_add(struct timeval *a, signed long int usec);
// avahi_timeval_compare
// file timeval.c line 30
signed int avahi_timeval_compare(struct timeval *a, struct timeval *b);
// avahi_timeval_diff
// file timeval.c line 49
signed long int avahi_timeval_diff(struct timeval *a, struct timeval *b);
// avahi_unescape_label
// file domain.c line 41
char * avahi_unescape_label(const char **name, char *dest, unsigned long int size);
// avahi_utf8_valid
// file utf8.h line 29
const char * avahi_utf8_valid(const char *str);
// avahi_xdg_config_open
// file xdg-config.h line 25
struct _IO_FILE * avahi_xdg_config_open(const char *filename);
// bind_textdomain_codeset
// file /usr/include/libintl.h line 91
extern char * bind_textdomain_codeset(const char *, const char *);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_version
// file client.c line 351
static signed int check_version(struct AvahiClient *client, signed int *ret_error);
// cleanup_timeouts
// file simple-watch.c line 304
static void cleanup_timeouts(struct AvahiSimplePoll *s, signed int all);
// cleanup_timeouts_link1
// file simple-watch.c line 304
static void cleanup_timeouts_link1(struct AvahiSimplePoll *s_link1, signed int all_link1);
// cleanup_watches
// file simple-watch.c line 230
static void cleanup_watches(struct AvahiSimplePoll *s, signed int all);
// cleanup_watches_link1
// file simple-watch.c line 230
static void cleanup_watches_link1(struct AvahiSimplePoll *s_link1, signed int all_link1);
// clear_wakeup
// file simple-watch.c line 105
static void clear_wakeup(struct AvahiSimplePoll *s);
// clear_wakeup_link1
// file simple-watch.c line 105
static void clear_wakeup_link1(struct AvahiSimplePoll *s_link1);
// client_callback
// file avahi-set-host-name.c line 56
static void client_callback(struct AvahiClient *c, enum anonymous_7 state, void *userdata);
// client_set_state
// file client.c line 58
static void client_set_state(struct AvahiClient *client, enum anonymous_7 state);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_pipe_fds
// file sigint.c line 58
static void close_pipe_fds(void);
// connection_data_ref
// file ../avahi-common/dbus-watch-glue.c line 68
static struct anonymous_11 * connection_data_ref(struct anonymous_11 *d);
// connection_data_unref
// file ../avahi-common/dbus-watch-glue.c line 76
static void connection_data_unref(struct anonymous_11 *d);
// dbus_bus_add_match
// file /usr/include/dbus-1.0/dbus/dbus-bus.h line 83
void dbus_bus_add_match(struct DBusConnection *, const char *, struct DBusError *);
// dbus_bus_get_private
// file /usr/include/dbus-1.0/dbus/dbus-bus.h line 43
struct DBusConnection * dbus_bus_get_private(enum anonymous_29, struct DBusError *);
// dbus_connection_add_filter
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 295
unsigned int dbus_connection_add_filter(struct DBusConnection *, enum anonymous_28 (*)(struct DBusConnection *, struct DBusMessage *, void *), void *, void (*)(void *));
// dbus_connection_close
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 183
void dbus_connection_close(struct DBusConnection *);
// dbus_connection_dispatch
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 220
enum anonymous_10 dbus_connection_dispatch(struct DBusConnection *);
// dbus_connection_get_dispatch_status
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 218
enum anonymous_10 dbus_connection_get_dispatch_status(struct DBusConnection *);
// dbus_connection_get_is_connected
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 185
unsigned int dbus_connection_get_is_connected(struct DBusConnection *);
// dbus_connection_ref
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 179
struct DBusConnection * dbus_connection_ref(struct DBusConnection *);
// dbus_connection_send_with_reply_and_block
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 233
struct DBusMessage * dbus_connection_send_with_reply_and_block(struct DBusConnection *, struct DBusMessage *, signed int, struct DBusError *);
// dbus_connection_set_dispatch_status_function
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 257
void dbus_connection_set_dispatch_status_function(struct DBusConnection *, void (*)(struct DBusConnection *, enum anonymous_10, void *), void *, void (*)(void *));
// dbus_connection_set_exit_on_disconnect
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 197
void dbus_connection_set_exit_on_disconnect(struct DBusConnection *, unsigned int);
// dbus_connection_set_timeout_functions
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 245
unsigned int dbus_connection_set_timeout_functions(struct DBusConnection *, unsigned int (*)(struct DBusTimeout *, void *), void (*)(struct DBusTimeout *, void *), void (*)(struct DBusTimeout *, void *), void *, void (*)(void *));
// dbus_connection_set_watch_functions
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 238
unsigned int dbus_connection_set_watch_functions(struct DBusConnection *, unsigned int (*)(struct DBusWatch *, void *), void (*)(struct DBusWatch *, void *), void (*)(struct DBusWatch *, void *), void *, void (*)(void *));
// dbus_connection_unref
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 181
void dbus_connection_unref(struct DBusConnection *);
// dbus_error_free
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 67
void dbus_error_free(struct DBusError *);
// dbus_error_init
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 65
void dbus_error_init(struct DBusError *);
// dbus_error_is_set
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 84
unsigned int dbus_error_is_set(const struct DBusError *);
// dbus_message_append_args
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 189
unsigned int dbus_message_append_args(struct DBusMessage *, signed int, ...);
// dbus_message_get_args
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 197
unsigned int dbus_message_get_args(struct DBusMessage *, struct DBusError *, signed int, ...);
// dbus_message_get_interface
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 113
const char * dbus_message_get_interface(struct DBusMessage *);
// dbus_message_get_member
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 121
const char * dbus_message_get_member(struct DBusMessage *);
// dbus_message_get_path
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 105
const char * dbus_message_get_path(struct DBusMessage *);
// dbus_message_is_signal
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 152
unsigned int dbus_message_is_signal(struct DBusMessage *, const char *, const char *);
// dbus_message_iter_append_fixed_array
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 253
unsigned int dbus_message_iter_append_fixed_array(struct DBusMessageIter *, signed int, const void *, signed int);
// dbus_message_iter_close_container
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 263
unsigned int dbus_message_iter_close_container(struct DBusMessageIter *, struct DBusMessageIter *);
// dbus_message_iter_get_arg_type
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 220
signed int dbus_message_iter_get_arg_type(struct DBusMessageIter *);
// dbus_message_iter_get_basic
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 227
void dbus_message_iter_get_basic(struct DBusMessageIter *, void *);
// dbus_message_iter_get_element_type
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 222
signed int dbus_message_iter_get_element_type(struct DBusMessageIter *);
// dbus_message_iter_get_fixed_array
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 240
void dbus_message_iter_get_fixed_array(struct DBusMessageIter *, void *, signed int *);
// dbus_message_iter_init
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 211
unsigned int dbus_message_iter_init(struct DBusMessage *, struct DBusMessageIter *);
// dbus_message_iter_init_append
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 246
void dbus_message_iter_init_append(struct DBusMessage *, struct DBusMessageIter *);
// dbus_message_iter_next
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 216
unsigned int dbus_message_iter_next(struct DBusMessageIter *);
// dbus_message_iter_open_container
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 258
unsigned int dbus_message_iter_open_container(struct DBusMessageIter *, signed int, const char *, struct DBusMessageIter *);
// dbus_message_iter_recurse
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 224
void dbus_message_iter_recurse(struct DBusMessageIter *, struct DBusMessageIter *);
// dbus_message_new_method_call
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 72
struct DBusMessage * dbus_message_new_method_call(const char *, const char *, const char *, const char *);
// dbus_message_unref
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 98
void dbus_message_unref(struct DBusMessage *);
// dbus_timeout_get_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 482
void * dbus_timeout_get_data(struct DBusTimeout *);
// dbus_timeout_get_enabled
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 490
unsigned int dbus_timeout_get_enabled(struct DBusTimeout *);
// dbus_timeout_get_interval
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 480
signed int dbus_timeout_get_interval(struct DBusTimeout *);
// dbus_timeout_handle
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 488
unsigned int dbus_timeout_handle(struct DBusTimeout *);
// dbus_timeout_set_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 484
void dbus_timeout_set_data(struct DBusTimeout *, void *, void (*)(void *));
// dbus_watch_get_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 461
void * dbus_watch_get_data(struct DBusWatch *);
// dbus_watch_get_enabled
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 470
unsigned int dbus_watch_get_enabled(struct DBusWatch *);
// dbus_watch_get_flags
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 459
unsigned int dbus_watch_get_flags(struct DBusWatch *);
// dbus_watch_get_unix_fd
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 455
signed int dbus_watch_get_unix_fd(struct DBusWatch *);
// dbus_watch_handle
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 467
unsigned int dbus_watch_handle(struct DBusWatch *, unsigned int);
// dbus_watch_set_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 463
void dbus_watch_set_data(struct DBusWatch *, void *, void (*)(void *));
// defer_timeout_callback
// file browser.c line 83
static void defer_timeout_callback(struct AvahiTimeout *t, void *userdata);
// destroy_timeout
// file simple-watch.c line 296
static void destroy_timeout(struct AvahiTimeout *t);
// destroy_timeout_link1
// file simple-watch.c line 296
static void destroy_timeout_link1(struct AvahiTimeout *t_link1);
// destroy_watch
// file simple-watch.c line 218
static void destroy_watch(struct AvahiWatch *w);
// destroy_watch_link1
// file simple-watch.c line 218
static void destroy_watch_link1(struct AvahiWatch *w_link1);
// dgettext
// file /usr/include/libintl.h line 44
extern char * dgettext(const char *, const char *);
// dispatch_status
// file ../avahi-common/dbus-watch-glue.c line 310
static void dispatch_status(struct DBusConnection *connection, enum anonymous_10 new_status, void *userdata);
// dispatch_timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 97
static void dispatch_timeout_callback(struct AvahiTimeout *t, void *userdata);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// domain_browser_ref
// file browser.c line 77
static void domain_browser_ref(struct AvahiDomainBrowser *db);
// drop_incomplete_utf8
// file alternative.c line 34
static void drop_incomplete_utf8(char *c);
// drop_incomplete_utf8_link1
// file alternative.c line 34
static void drop_incomplete_utf8_link1(char *c_link1);
// entry_group_simple_method_call
// file entrygroup.c line 188
static signed int entry_group_simple_method_call(struct AvahiEntryGroup *group, const char *method);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// filter_func
// file client.c line 103
static enum anonymous_28 filter_func(struct DBusConnection *bus, struct DBusMessage *message, void *userdata);
// find_next_timeout
// file simple-watch.c line 425
static struct AvahiTimeout * find_next_timeout(struct AvahiSimplePoll *s);
// find_next_timeout_link1
// file simple-watch.c line 425
static struct AvahiTimeout * find_next_timeout_link1(struct AvahiSimplePoll *s_link1);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// get_server_state
// file client.c line 305
static signed int get_server_state(struct AvahiClient *client, signed int *ret_error);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// handler
// file sigint.c line 54
static void handler(signed int s);
// help
// file avahi-set-host-name.c line 71
static void help(struct _IO_FILE *f, const char *argv0);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init_server
// file client.c line 431
static signed int init_server(struct AvahiClient *client, signed int *ret_error);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// oom
// file malloc.c line 44
static void oom(void);
// oom_link1
// file malloc.c line 44
static void oom_link1(void);
// parse_command_line
// file avahi-set-host-name.c line 80
static signed int parse_command_line(struct Config *c, signed int argc, char **argv);
// parse_domain_file
// file browser.c line 58
static void parse_domain_file(struct AvahiDomainBrowser *b);
// parse_environment
// file browser.c line 41
static void parse_environment(struct AvahiDomainBrowser *b);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// poll_func
// file thread-watch.c line 48
static signed int poll_func(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata);
// poll_func_link1
// file thread-watch.c line 48
static signed int poll_func_link1(struct pollfd *ufds_link1, unsigned int nfds_link1, signed int timeout_link1, void *userdata_link1);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_equal
// file /usr/include/pthread.h line 280
extern signed int pthread_equal(unsigned long int, unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_25 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_25 *, const union anonymous_26 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_25 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_25 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_15 *, struct anonymous_15 *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// rebuild
// file simple-watch.c line 385
static signed int rebuild(struct AvahiSimplePoll *s);
// rebuild_link1
// file simple-watch.c line 385
static signed int rebuild_link1(struct AvahiSimplePoll *s_link1);
// remove_pollfd
// file simple-watch.c line 194
static void remove_pollfd(struct AvahiWatch *w);
// remove_pollfd_link1
// file simple-watch.c line 194
static void remove_pollfd_link1(struct AvahiWatch *w_link1);
// remove_timeout
// file ../avahi-common/dbus-watch-glue.c line 286
static void remove_timeout(struct DBusTimeout *dbus_timeout, void *userdata);
// remove_watch
// file ../avahi-common/dbus-watch-glue.c line 174
static void remove_watch(struct DBusWatch *dbus_watch, void *userdata);
// request_dispatch
// file ../avahi-common/dbus-watch-glue.c line 86
static void request_dispatch(struct anonymous_11 *d, signed int enable);
// retrieve_state
// file entrygroup.c line 52
static signed int retrieve_state(struct AvahiEntryGroup *group);
// set_nonblock
// file sigint.c line 40
static signed int set_nonblock(signed int fd);
// set_nonblock_link1
// file simple-watch.c line 118
static signed int set_nonblock_link1(signed int fd_link1);
// set_nonblock_link2
// file simple-watch.c line 118
static signed int set_nonblock_link2(signed int fd_link2);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_15 *);
// sigint_install
// file sigint.h line 25
signed int sigint_install(struct AvahiSimplePoll *spoll);
// sigint_uninstall
// file sigint.h line 26
void sigint_uninstall(void);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlcpy
// file domain.c line 482
static unsigned long int strlcpy(char *dest, const char *src, unsigned long int n);
// strlcpy_link1
// file domain.c line 482
static unsigned long int strlcpy_link1(char *dest_link1, const char *src_link1, unsigned long int n_link1);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok_r
// file /usr/include/string.h line 358
extern char * strtok_r(char *, const char *, char ** restrict );
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// system_poll
// file simple-watch.c line 626
static signed int system_poll(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata);
// system_poll_link1
// file simple-watch.c line 626
static signed int system_poll_link1(struct pollfd *ufds_link1, unsigned int nfds_link1, signed int timeout_link1, void *userdata_link1);
// thread
// file thread-watch.c line 62
static void * thread(void *userdata);
// thread_link1
// file thread-watch.c line 62
static void * thread_link1(void *userdata_link1);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 237
static void timeout_callback(struct AvahiTimeout *avahi_timeout, void *userdata);
// timeout_callback_link1
// file simple-watch.c line 441
static void timeout_callback_link1(struct AvahiTimeout *t);
// timeout_callback_link2
// file simple-watch.c line 441
static void timeout_callback_link2(struct AvahiTimeout *t_link1);
// timeout_data_ref
// file ../avahi-common/dbus-watch-glue.c line 203
static struct TimeoutData * timeout_data_ref(struct TimeoutData *t);
// timeout_data_unref
// file ../avahi-common/dbus-watch-glue.c line 211
static void timeout_data_unref(struct TimeoutData *t);
// timeout_free
// file simple-watch.c line 284
static void timeout_free(struct AvahiTimeout *t);
// timeout_free_link1
// file simple-watch.c line 284
static void timeout_free_link1(struct AvahiTimeout *t_link1);
// timeout_new
// file simple-watch.c line 244
static struct AvahiTimeout * timeout_new(const struct AvahiPoll *api, struct timeval *tv, void (*callback)(struct AvahiTimeout *, void *), void *userdata);
// timeout_new_link1
// file simple-watch.c line 244
static struct AvahiTimeout * timeout_new_link1(const struct AvahiPoll *api_link1, struct timeval *tv_link1, void (*callback_link1)(struct AvahiTimeout *, void *), void *userdata_link1);
// timeout_new::callback_link1_object
//
void callback_link1_object(struct AvahiTimeout *, void *);
// timeout_new::callback_object
//
void callback_object(struct AvahiTimeout *, void *);
// timeout_toggled
// file ../avahi-common/dbus-watch-glue.c line 300
static void timeout_toggled(struct DBusTimeout *dbus_timeout, void *userdata);
// timeout_update
// file simple-watch.c line 273
static void timeout_update(struct AvahiTimeout *t, struct timeval *tv);
// timeout_update_link1
// file simple-watch.c line 273
static void timeout_update_link1(struct AvahiTimeout *t_link1, struct timeval *tv_link1);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// translate_avahi_to_dbus
// file ../avahi-common/dbus-watch-glue.c line 46
static unsigned int translate_avahi_to_dbus(enum anonymous_9 e);
// translate_dbus_to_avahi
// file ../avahi-common/dbus-watch-glue.c line 31
static enum anonymous_9 translate_dbus_to_avahi(unsigned int f);
// update_timeout
// file ../avahi-common/dbus-watch-glue.c line 223
static void update_timeout(struct TimeoutData *timeout);
// update_watch
// file ../avahi-common/dbus-watch-glue.c line 125
static unsigned int update_watch(const struct AvahiPoll *poll_api, struct DBusWatch *dbus_watch);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// watch_callback
// file sigint.c line 67
static void watch_callback(struct AvahiWatch *w, signed int fd, enum anonymous_9 event, void *userdata);
// watch_callback_link1
// file ../avahi-common/dbus-watch-glue.c line 115
static void watch_callback_link1(struct AvahiWatch *avahi_watch, signed int fd_link1, enum anonymous_9 events, void *userdata_link1);
// watch_free
// file simple-watch.c line 203
static void watch_free(struct AvahiWatch *w);
// watch_free_link1
// file simple-watch.c line 203
static void watch_free_link1(struct AvahiWatch *w_link1);
// watch_get_events
// file simple-watch.c line 184
static enum anonymous_9 watch_get_events(struct AvahiWatch *w);
// watch_get_events_link1
// file simple-watch.c line 184
static enum anonymous_9 watch_get_events_link1(struct AvahiWatch *w_link1);
// watch_new
// file simple-watch.c line 132
static struct AvahiWatch * watch_new(const struct AvahiPoll *api, signed int fd, enum anonymous_9 event, void (*callback)(struct AvahiWatch *, signed int, enum anonymous_9, void *), void *userdata);
// watch_new_link1
// file simple-watch.c line 132
static struct AvahiWatch * watch_new_link1(const struct AvahiPoll *api_link1, signed int fd_link1, enum anonymous_9 event_link1, void (*callback_link1)(struct AvahiWatch *, signed int, enum anonymous_9, void *), void *userdata_link1);
// watch_new::callback_link1_object
//
void callback_link1_object(struct AvahiWatch *, signed int, enum anonymous_9, void *);
// watch_new::callback_object
//
void callback_object(struct AvahiWatch *, signed int, enum anonymous_9, void *);
// watch_toggled
// file ../avahi-common/dbus-watch-glue.c line 187
static void watch_toggled(struct DBusWatch *dbus_watch, void *userdata);
// watch_update
// file simple-watch.c line 168
static void watch_update(struct AvahiWatch *w, enum anonymous_9 events);
// watch_update_link1
// file simple-watch.c line 168
static void watch_update_link1(struct AvahiWatch *w_link1, enum anonymous_9 events_link1);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// xcalloc
// file malloc.c line 89
static void * xcalloc(unsigned long int nmemb, unsigned long int size);
// xcalloc_link1
// file malloc.c line 89
static void * xcalloc_link1(unsigned long int nmemb_link1, unsigned long int size_link1);
// xmalloc
// file malloc.c line 62
static void * xmalloc(unsigned long int size);
// xmalloc_link1
// file malloc.c line 62
static void * xmalloc_link1(unsigned long int size_link1);
// xrealloc
// file malloc.c line 75
static void * xrealloc(void *p, unsigned long int size);
// xrealloc_link1
// file malloc.c line 75
static void * xrealloc_link1(void *p_link1, unsigned long int size_link1);

struct anonymous_11
{
  // connection
  struct DBusConnection *connection;
  // poll_api
  const struct AvahiPoll *poll_api;
  // dispatch_timeout
  struct AvahiTimeout *dispatch_timeout;
  // ref
  signed int ref;
};

struct anonymous_22
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_20
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_15
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_16
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_19
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_18
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_17
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_21
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_12
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_16 _kill;
  // _timer
  struct anonymous_17 _timer;
  // _rt
  struct anonymous_18 _rt;
  // _sigchld
  struct anonymous_19 _sigchld;
  // _sigfault
  struct anonymous_20 _sigfault;
  // _sigpoll
  struct anonymous_21 _sigpoll;
  // _sigsys
  struct anonymous_22 _sigsys;
};

struct anonymous_13
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_12 _sifields;
};

union anonymous_14
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_13 *, void *);
};

union anonymous_26
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct AvahiIPv6Address
{
  // address
  unsigned char address[16l];
};

struct AvahiIPv4Address
{
  // address
  unsigned int address;
};

union anonymous_23
{
  // ipv6
  struct AvahiIPv6Address ipv6;
  // ipv4
  struct AvahiIPv4Address ipv4;
  // data
  unsigned char data[1l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_25
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct AvahiAddress
{
  // proto
  signed int proto;
  // data
  union anonymous_23 data;
};

struct AvahiAddressResolver
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiAddressResolver *, signed int, signed int, enum anonymous_6, const struct AvahiAddress *, const char *, enum anonymous_3, void *);
  // userdata
  void *userdata;
  // address_resolvers_next
  struct AvahiAddressResolver *address_resolvers_next;
  // address_resolvers_prev
  struct AvahiAddressResolver *address_resolvers_prev;
  // address
  struct AvahiAddress address;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiAllocator
{
  // malloc
  void * (*malloc)(unsigned long int);
  // free
  void (*free)(void *);
  // realloc
  void * (*realloc)(void *, unsigned long int);
  // calloc
  void * (*calloc)(unsigned long int, unsigned long int);
};

struct AvahiClient
{
  // poll_api
  const struct AvahiPoll *poll_api;
  // bus
  struct DBusConnection *bus;
  // error
  signed int error;
  // state
  enum anonymous_7 state;
  // flags
  enum anonymous_8 flags;
  // version_string
  char *version_string;
  // host_name
  char *host_name;
  // host_name_fqdn
  char *host_name_fqdn;
  // domain_name
  char *domain_name;
  // local_service_cookie
  unsigned int local_service_cookie;
  // local_service_cookie_valid
  signed int local_service_cookie_valid;
  // callback
  void (*callback)(struct AvahiClient *, enum anonymous_7, void *);
  // userdata
  void *userdata;
  // groups
  struct AvahiEntryGroup *groups;
  // domain_browsers
  struct AvahiDomainBrowser *domain_browsers;
  // service_browsers
  struct AvahiServiceBrowser *service_browsers;
  // service_type_browsers
  struct AvahiServiceTypeBrowser *service_type_browsers;
  // service_resolvers
  struct AvahiServiceResolver *service_resolvers;
  // host_name_resolvers
  struct AvahiHostNameResolver *host_name_resolvers;
  // address_resolvers
  struct AvahiAddressResolver *address_resolvers;
  // record_browsers
  struct AvahiRecordBrowser *record_browsers;
};

struct AvahiDomainBrowser
{
  // ref
  signed int ref;
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous_2, const char *, enum anonymous_3, void *);
  // userdata
  void *userdata;
  // domain_browsers_next
  struct AvahiDomainBrowser *domain_browsers_next;
  // domain_browsers_prev
  struct AvahiDomainBrowser *domain_browsers_prev;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
  // defer_timeout
  struct AvahiTimeout *defer_timeout;
  // static_browse_domains
  struct AvahiStringList *static_browse_domains;
};

struct AvahiEntryGroup
{
  // path
  char *path;
  // state
  enum anonymous_27 state;
  // state_valid
  signed int state_valid;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiEntryGroup *, enum anonymous_27, void *);
  // userdata
  void *userdata;
  // groups_next
  struct AvahiEntryGroup *groups_next;
  // groups_prev
  struct AvahiEntryGroup *groups_prev;
};

struct AvahiHostNameResolver
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous_6, const char *, const struct AvahiAddress *, enum anonymous_3, void *);
  // userdata
  void *userdata;
  // host_name_resolvers_next
  struct AvahiHostNameResolver *host_name_resolvers_next;
  // host_name_resolvers_prev
  struct AvahiHostNameResolver *host_name_resolvers_prev;
  // host_name
  char *host_name;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiPoll
{
  // userdata
  void *userdata;
  // watch_new
  struct AvahiWatch * (*watch_new)(const struct AvahiPoll *, signed int, enum anonymous_9, void (*)(struct AvahiWatch *, signed int, enum anonymous_9, void *), void *);
  // watch_update
  void (*watch_update)(struct AvahiWatch *, enum anonymous_9);
  // watch_get_events
  enum anonymous_9 (*watch_get_events)(struct AvahiWatch *);
  // watch_free
  void (*watch_free)(struct AvahiWatch *);
  // timeout_new
  struct AvahiTimeout * (*timeout_new)(const struct AvahiPoll *, struct timeval *, void (*)(struct AvahiTimeout *, void *), void *);
  // timeout_update
  void (*timeout_update)(struct AvahiTimeout *, struct timeval *);
  // timeout_free
  void (*timeout_free)(struct AvahiTimeout *);
};

struct AvahiRList
{
  // rlist_next
  struct AvahiRList *rlist_next;
  // rlist_prev
  struct AvahiRList *rlist_prev;
  // data
  void *data;
};

struct AvahiRecordBrowser
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous_2, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous_3, void *);
  // userdata
  void *userdata;
  // record_browsers_next
  struct AvahiRecordBrowser *record_browsers_next;
  // record_browsers_prev
  struct AvahiRecordBrowser *record_browsers_prev;
  // name
  char *name;
  // clazz
  unsigned short int clazz;
  // type
  unsigned short int type;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiServiceBrowser
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous_2, const char *, const char *, const char *, enum anonymous_3, void *);
  // userdata
  void *userdata;
  // service_browsers_next
  struct AvahiServiceBrowser *service_browsers_next;
  // service_browsers_prev
  struct AvahiServiceBrowser *service_browsers_prev;
  // type
  char *type;
  // domain
  char *domain;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiServiceResolver
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiServiceResolver *, signed int, signed int, enum anonymous_6, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous_3, void *);
  // userdata
  void *userdata;
  // service_resolvers_next
  struct AvahiServiceResolver *service_resolvers_next;
  // service_resolvers_prev
  struct AvahiServiceResolver *service_resolvers_prev;
  // name
  char *name;
  // type
  char *type;
  // domain
  char *domain;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiServiceTypeBrowser
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous_2, const char *, const char *, enum anonymous_3, void *);
  // userdata
  void *userdata;
  // service_type_browsers_next
  struct AvahiServiceTypeBrowser *service_type_browsers_next;
  // service_type_browsers_prev
  struct AvahiServiceTypeBrowser *service_type_browsers_prev;
  // domain
  char *domain;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiSimplePoll
{
  // api
  struct AvahiPoll api;
  // poll_func
  signed int (*poll_func)(struct pollfd *, unsigned int, signed int, void *);
  // poll_func_userdata
  void *poll_func_userdata;
  // pollfds
  struct pollfd *pollfds;
  // n_pollfds
  signed int n_pollfds;
  // max_pollfds
  signed int max_pollfds;
  // rebuild_pollfds
  signed int rebuild_pollfds;
  // watch_req_cleanup
  signed int watch_req_cleanup;
  // timeout_req_cleanup
  signed int timeout_req_cleanup;
  // quit
  signed int quit;
  // events_valid
  signed int events_valid;
  // n_watches
  signed int n_watches;
  // watches
  struct AvahiWatch *watches;
  // timeouts
  struct AvahiTimeout *timeouts;
  // wakeup_pipe
  signed int wakeup_pipe[2l];
  // wakeup_issued
  signed int wakeup_issued;
  // prepared_timeout
  signed int prepared_timeout;
  // state
  enum anonymous_4 state;
};

struct AvahiStringList
{
  // next
  struct AvahiStringList *next;
  // size
  unsigned long int size;
  // text
  unsigned char text[1l];
};

struct AvahiThreadedPoll
{
  // simple_poll
  struct AvahiSimplePoll *simple_poll;
  // thread_id
  unsigned long int thread_id;
  // mutex
  union anonymous_25 mutex;
  // thread_running
  signed int thread_running;
  // retval
  signed int retval;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct AvahiTimeout
{
  // simple_poll
  struct AvahiSimplePoll *simple_poll;
  // dead
  signed int dead;
  // enabled
  signed int enabled;
  // expiry
  struct timeval expiry;
  // callback
  void (*callback)(struct AvahiTimeout *, void *);
  // userdata
  void *userdata;
  // timeouts_next
  struct AvahiTimeout *timeouts_next;
  // timeouts_prev
  struct AvahiTimeout *timeouts_prev;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

struct AvahiWatch
{
  // simple_poll
  struct AvahiSimplePoll *simple_poll;
  // dead
  signed int dead;
  // idx
  signed int idx;
  // pollfd
  struct pollfd pollfd;
  // callback
  void (*callback)(struct AvahiWatch *, signed int, enum anonymous_9, void *);
  // userdata
  void *userdata;
  // watches_next
  struct AvahiWatch *watches_next;
  // watches_prev
  struct AvahiWatch *watches_prev;
};

struct Config
{
  // verbose
  signed int verbose;
  // command
  enum anonymous_5 command;
};

struct DBusError
{
  // name
  const char *name;
  // message
  const char *message;
  // dummy1
  unsigned int dummy1 : 1;
  // dummy2
  unsigned int dummy2 : 1;
  // dummy3
  unsigned int dummy3 : 1;
  // dummy4
  unsigned int dummy4 : 1;
  // dummy5
  unsigned int dummy5 : 1;
  // padding1
  void *padding1;
};

struct DBusMessageIter
{
  // dummy1
  void *dummy1;
  // dummy2
  void *dummy2;
  // dummy3
  unsigned int dummy3;
  // dummy4
  signed int dummy4;
  // dummy5
  signed int dummy5;
  // dummy6
  signed int dummy6;
  // dummy7
  signed int dummy7;
  // dummy8
  signed int dummy8;
  // dummy9
  signed int dummy9;
  // dummy10
  signed int dummy10;
  // dummy11
  signed int dummy11;
  // pad1
  signed int pad1;
  // pad2
  signed int pad2;
  // pad3
  void *pad3;
};

struct TimeoutData
{
  // poll_api
  const struct AvahiPoll *poll_api;
  // avahi_timeout
  struct AvahiTimeout *avahi_timeout;
  // dbus_timeout
  struct DBusTimeout *dbus_timeout;
  // ref
  signed int ref;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct error_map
{
  // dbus_error
  const char *dbus_error;
  // avahi_error
  signed int avahi_error;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_14 __sigaction_handler;
  // sa_mask
  struct anonymous_15 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// allocator
// file malloc.c line 40
static const struct AvahiAllocator *allocator = (const struct AvahiAllocator *)(void *)0;
// allocator_link1
// file malloc.c line 40
static const struct AvahiAllocator *allocator_link1 = (const struct AvahiAllocator *)(void *)0;
// client
// file avahi-set-host-name.c line 54
static struct AvahiClient *client = (struct AvahiClient *)(void *)0;
// error_map
// file ../avahi-common/dbus.c line 98
static struct error_map error_map[15l] = { { .dbus_error="org.freedesktop.DBus.Error.Failed", .avahi_error=-1 },
    { .dbus_error="org.freedesktop.DBus.Error.NoMemory", .avahi_error=-24 },
    { .dbus_error="org.freedesktop.DBus.Error.ServiceUnknown", .avahi_error=-26 },
    { .dbus_error="org.freedesktop.DBus.Error.BadAddress", .avahi_error=-26 },
    { .dbus_error="org.freedesktop.DBus.Error.NotSupported", .avahi_error=-49 },
    { .dbus_error="org.freedesktop.DBus.Error.LimitsExceeded", .avahi_error=-17 },
    { .dbus_error="org.freedesktop.DBus.Error.AccessDenied", .avahi_error=-20 },
    { .dbus_error="org.freedesktop.DBus.Error.AuthFailed", .avahi_error=-20 },
    { .dbus_error="org.freedesktop.DBus.Error.NoServer", .avahi_error=-26 },
    { .dbus_error="org.freedesktop.DBus.Error.Timeout", .avahi_error=-15 },
    { .dbus_error="org.freedesktop.DBus.Error.NoNetwork", .avahi_error=-5 },
    { .dbus_error="org.freedesktop.DBus.Error.Disconnected", .avahi_error=-23 },
    { .dbus_error="org.freedesktop.DBus.Error.InvalidArgs", .avahi_error=-51 },
    { .dbus_error="org.freedesktop.DBus.Error.TimedOut", .avahi_error=-15 },
    { .dbus_error=(const char *)(void *)0, .avahi_error=0 } };
// old_sigint_sa
// file sigint.c line 36
static struct sigaction old_sigint_sa;
// old_sigterm_sa
// file sigint.c line 36
static struct sigaction old_sigterm_sa;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// pipe_fds
// file sigint.c line 37
static signed int pipe_fds[2l] = { -1, -1 };
// simple_poll
// file avahi-set-host-name.c line 53
static struct AvahiSimplePoll *simple_poll = (struct AvahiSimplePoll *)(void *)0;
// simple_poll_link1
// file sigint.c line 35
static struct AvahiSimplePoll *simple_poll_link1 = (struct AvahiSimplePoll *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// table
// file ../avahi-common/dbus.c line 31
static const char * const table[54l] = { "org.freedesktop.Avahi.Success", "org.freedesktop.Avahi.Failure", "org.freedesktop.Avahi.BadStateError", "org.freedesktop.Avahi.InvalidHostNameError",
    "org.freedesktop.Avahi.InvalidDomainNameError",
    "org.freedesktop.Avahi.NoNetworkError", "org.freedesktop.Avahi.InvalidTTLError",
    "org.freedesktop.Avahi.IsPatternError", "org.freedesktop.Avahi.CollisionError", "org.freedesktop.Avahi.InvalidRecordError",
    "org.freedesktop.Avahi.InvalidServiceNameError",
    "org.freedesktop.Avahi.InvalidServiceTypeError",
    "org.freedesktop.Avahi.InvalidPortError",
    "org.freedesktop.Avahi.InvalidKeyError",
    "org.freedesktop.Avahi.InvalidAddressError",
    "org.freedesktop.Avahi.TimeoutError", "org.freedesktop.Avahi.TooManyClientsError",
    "org.freedesktop.Avahi.TooManyObjectsError",
    "org.freedesktop.Avahi.TooManyEntriesError",
    "org.freedesktop.Avahi.OSError", "org.freedesktop.DBus.Error.AccessDenied",
    "org.freedesktop.Avahi.InvalidOperationError",
    "org.freedesktop.Avahi.DBusError", "org.freedesktop.Avahi.DisconnectedError",
    "org.freedesktop.Avahi.NoMemoryError", "org.freedesktop.Avahi.InvalidObjectError",
    "org.freedesktop.Avahi.NoDaemonError", "org.freedesktop.Avahi.InvalidInterfaceError",
    "org.freedesktop.Avahi.InvalidInterfaceProtocolError",
    "org.freedesktop.Avahi.InvalidFlagsError",
    "org.freedesktop.Avahi.NotFoundError", "org.freedesktop.Avahi.InvalidConfigurationError",
    "org.freedesktop.Avahi.VersionMismatchError",
    "org.freedesktop.Avahi.InvalidServiceSubtypeError",
    "org.freedesktop.Avahi.InvalidPacketError",
    "org.freedesktop.Avahi.InvalidDNSErrorError",
    "org.freedesktop.Avahi.DNSFORMERR", "org.freedesktop.Avahi.DNSSERVFAIL", "org.freedesktop.Avahi.DNSNXDOMAIN", "org.freedesktop.Avahi.DNSNOTIMP", "org.freedesktop.Avahi.DNSREFUSED", "org.freedesktop.Avahi.DNSYXDOMAIN", "org.freedesktop.Avahi.DNSYXRRSET", "org.freedesktop.Avahi.DNSNXRRSET", "org.freedesktop.Avahi.DNSNOTAUTH", "org.freedesktop.Avahi.DNSNOTZONE", "org.freedesktop.Avahi.InvalidRDataError",
    "org.freedesktop.Avahi.InvalidDNSClassError",
    "org.freedesktop.Avahi.InvalidDNSTypeError",
    "org.freedesktop.Avahi.NotSupportedError",
    "org.freedesktop.Avahi.NotPermittedError",
    "org.freedesktop.Avahi.InvalidArgumentError",
    "org.freedesktop.Avahi.IsEmptyError", "org.freedesktop.Avahi.NoChangeError" };
// watch
// file sigint.c line 38
static struct AvahiWatch *watch = (struct AvahiWatch *)(void *)0;

// add_timeout
// file ../avahi-common/dbus-watch-glue.c line 254
static unsigned int add_timeout(struct DBusTimeout *dbus_timeout, void *userdata)
{
  struct TimeoutData *timeout;
  struct anonymous_11 *d = (struct anonymous_11 *)userdata;
  struct timeval tv;
  unsigned int b;
  /* assertion dbus_timeout */
  assert(dbus_timeout != ((struct DBusTimeout *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous_11 *)NULL));
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link4((unsigned int)1, sizeof(struct TimeoutData) /*32ul*/ );
  timeout = (struct TimeoutData *)return_value_avahi_new_internal_1;
  signed int return_value_dbus_timeout_get_interval_2;
  if(timeout == ((struct TimeoutData *)NULL))
    return (unsigned int)0;

  else
  {
    timeout->dbus_timeout = dbus_timeout;
    timeout->poll_api = d->poll_api;
    timeout->ref = 1;
    b=dbus_timeout_get_enabled(dbus_timeout);
    if(!(b == 0u))
    {
      return_value_dbus_timeout_get_interval_2=dbus_timeout_get_interval(dbus_timeout);
      avahi_elapse_time(&tv, (unsigned int)return_value_dbus_timeout_get_interval_2, (unsigned int)0);
    }

    timeout->avahi_timeout=d->poll_api->timeout_new(d->poll_api, b != 0u ? &tv : (struct timeval *)(void *)0, timeout_callback, (void *)timeout);
    if(timeout->avahi_timeout == ((struct AvahiTimeout *)NULL))
    {
      avahi_free((void *)timeout);
      return (unsigned int)0;
    }

    else
    {
      dbus_timeout_set_data(dbus_timeout, (void *)timeout, (void (*)(void *))timeout_data_unref);
      return (unsigned int)1;
    }
  }
}

// add_watch
// file ../avahi-common/dbus-watch-glue.c line 165
static unsigned int add_watch(struct DBusWatch *dbus_watch, void *userdata)
{
  struct anonymous_11 *d = (struct anonymous_11 *)userdata;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous_11 *)NULL));
  unsigned int return_value_update_watch_1;
  return_value_update_watch_1=update_watch(d->poll_api, dbus_watch);
  return return_value_update_watch_1;
}

// address_get_size
// file address.c line 35
static unsigned long int address_get_size(const struct AvahiAddress *a)
{
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  if(a->proto == 0)
    return (unsigned long int)4;

  else
    if(a->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// address_get_size_link1
// file address.c line 35
static unsigned long int address_get_size_link1(const struct AvahiAddress *a_link1)
{
  /* assertion a */
  assert(a_link1 != ((const struct AvahiAddress *)NULL));
  if(a_link1->proto == 0)
    return (unsigned long int)4;

  else
    if(a_link1->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// append_rdata
// file entrygroup.c line 348
static signed int append_rdata(struct DBusMessage *message, const void *rdata, unsigned long int size)
{
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_message_iter_init_append(message, &iter);
  unsigned int return_value_dbus_message_iter_open_container_1;
  return_value_dbus_message_iter_open_container_1=dbus_message_iter_open_container(&iter, (signed int)97, "y", &sub);
  _Bool tmp_if_expr_3;
  unsigned int return_value_dbus_message_iter_append_fixed_array_2;
  if(return_value_dbus_message_iter_open_container_1 == 0u)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_dbus_message_iter_append_fixed_array_2=dbus_message_iter_append_fixed_array(&sub, (signed int)121, (const void *)&rdata, (signed int)size);
    tmp_if_expr_3 = !(return_value_dbus_message_iter_append_fixed_array_2 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_message_iter_close_container_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_dbus_message_iter_close_container_4=dbus_message_iter_close_container(&iter, &sub);
    tmp_if_expr_5 = !(return_value_dbus_message_iter_close_container_4 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return -1;

  else
    return 0;
}

// append_string_list
// file entrygroup.c line 363
static signed int append_string_list(struct DBusMessage *message, struct AvahiStringList *txt)
{
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  signed int r = -1;
  struct AvahiStringList *p;
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_message_iter_init_append(message, &iter);
  txt=avahi_string_list_reverse(txt);
  unsigned int return_value_dbus_message_iter_open_container_1;
  return_value_dbus_message_iter_open_container_1=dbus_message_iter_open_container(&iter, (signed int)97, "ay", &sub);
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_message_iter_append_fixed_array_3;
  _Bool tmp_if_expr_6;
  unsigned int return_value_dbus_message_iter_close_container_5;
  unsigned int return_value_dbus_message_iter_close_container_7;
  if(!(return_value_dbus_message_iter_open_container_1 == 0u))
  {
    p = txt;
    for( ; !(p == ((struct AvahiStringList *)NULL)); p = p->next)
    {
      struct DBusMessageIter sub2;
      const unsigned char *data = p->text;
      unsigned int return_value_dbus_message_iter_open_container_2;
      return_value_dbus_message_iter_open_container_2=dbus_message_iter_open_container(&sub, (signed int)97, "y", &sub2);
      if(return_value_dbus_message_iter_open_container_2 == 0u)
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_dbus_message_iter_append_fixed_array_3=dbus_message_iter_append_fixed_array(&sub2, (signed int)121, (const void *)&data, (signed int)p->size);
        tmp_if_expr_4 = !(return_value_dbus_message_iter_append_fixed_array_3 != 0u) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_dbus_message_iter_close_container_5=dbus_message_iter_close_container(&sub, &sub2);
        tmp_if_expr_6 = !(return_value_dbus_message_iter_close_container_5 != 0u) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        goto fail;

    }
    return_value_dbus_message_iter_close_container_7=dbus_message_iter_close_container(&iter, &sub);
    if(!(return_value_dbus_message_iter_close_container_7 == 0u))
      r = 0;

  }


fail:
  ;
  txt=avahi_string_list_reverse(txt);
  return r;
}

// avahi_address_cmp
// file address.c line 46
signed int avahi_address_cmp(const struct AvahiAddress *a, const struct AvahiAddress *b)
{
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  /* assertion b */
  assert(b != ((const struct AvahiAddress *)NULL));
  if(!(a->proto == b->proto))
    return -1;

  else
  {
    unsigned long int return_value_address_get_size_1;
    return_value_address_get_size_1=address_get_size(a);
    signed int return_value_memcmp_2;
    return_value_memcmp_2=memcmp((const void *)a->data.data, (const void *)b->data.data, return_value_address_get_size_1);
    return return_value_memcmp_2;
  }
}

// avahi_address_parse
// file ../avahi-common/address.h line 95
struct AvahiAddress * avahi_address_parse(const char *s, signed int proto, struct AvahiAddress *ret_addr)
{
  /* assertion ret_addr */
  assert(ret_addr != ((struct AvahiAddress *)NULL));
  /* assertion s */
  assert(s != ((const char *)NULL));
  if(proto == -1)
  {
    signed int return_value_inet_pton_2;
    return_value_inet_pton_2=inet_pton(2, s, (void *)ret_addr->data.data);
    if(!(return_value_inet_pton_2 >= 1))
    {
      signed int return_value_inet_pton_1;
      return_value_inet_pton_1=inet_pton(10, s, (void *)ret_addr->data.data);
      if(!(return_value_inet_pton_1 >= 1))
        return (struct AvahiAddress *)(void *)0;

      else
        ret_addr->proto = 1;
    }

    else
      ret_addr->proto = 0;
  }

  else
  {
    signed int return_value_avahi_proto_to_af_3;
    return_value_avahi_proto_to_af_3=avahi_proto_to_af(proto);
    signed int return_value_inet_pton_4;
    return_value_inet_pton_4=inet_pton(return_value_avahi_proto_to_af_3, s, (void *)ret_addr->data.data);
    if(!(return_value_inet_pton_4 >= 1))
      return (struct AvahiAddress *)(void *)0;

    ret_addr->proto = proto;
  }
  return ret_addr;
}

// avahi_address_resolver_event
// file internal.h line 166
enum anonymous_28 avahi_address_resolver_event(struct AvahiClient *client, enum anonymous_6 event, struct DBusMessage *message)
{
  struct AvahiAddressResolver *r = (struct AvahiAddressResolver *)(void *)0;
  struct DBusError error;
  const char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  signed int interface;
  signed int protocol;
  signed int aprotocol;
  unsigned int flags;
  char *name;
  char *address;
  struct AvahiAddress a;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  struct AvahiAddress *return_value_avahi_address_parse_5;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  signed int return_value_avahi_error_dbus_to_number_9;
  if(!(path == ((const char *)NULL)))
  {
    r = client->address_resolvers;
    for( ; !(r == ((struct AvahiAddressResolver *)NULL)); r = r->address_resolvers_next)
    {
      return_value_strcmp_1=strcmp(r->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(r == ((struct AvahiAddressResolver *)NULL))
      goto fail;

    switch((signed int)event)
    {
      case AVAHI_RESOLVER_FOUND:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)105, &aprotocol, (signed int)115, &address, (signed int)115, &name, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        /* assertion address */
        assert(address != ((char *)NULL));
        return_value_avahi_address_parse_5=avahi_address_parse(address, (signed int)aprotocol, &a);
        if(return_value_avahi_address_parse_5 == ((struct AvahiAddress *)NULL))
        {
          fprintf(stderr, "Failed to parse address\n");
          goto fail;
        }

        r->callback(r, (signed int)interface, (signed int)protocol, (enum anonymous_6)AVAHI_RESOLVER_FOUND, &a, name, (enum anonymous_3)flags, r->userdata);
      }
      case AVAHI_RESOLVER_FAILURE:
      {
        return_value_dbus_message_get_args_6=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_6 == 0u)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
          tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_9=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(r->client, return_value_avahi_error_dbus_to_number_9);
        r->callback(r, r->interface, r->protocol, event, &r->address, (const char *)(void *)0, (enum anonymous_3)0, r->userdata);
      }
    }
    return (enum anonymous_28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous_28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_address_resolver_free
// file lookup.h line 269
signed int avahi_address_resolver_free(struct AvahiAddressResolver *r)
{
  struct AvahiClient *avahi_address_resolver_free__1__client;
  signed int ret = 0;
  /* assertion r */
  assert(r != ((struct AvahiAddressResolver *)NULL));
  avahi_address_resolver_free__1__client = r->client;
  signed int return_value_avahi_client_is_connected_1;
  if(!(r->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(avahi_address_resolver_free__1__client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      ret=avahi_client_simple_method_call(avahi_address_resolver_free__1__client, r->path, "org.freedesktop.Avahi.AddressResolver", "Free");

  }

  do
  {
    struct AvahiAddressResolver **_head = &avahi_address_resolver_free__1__client->address_resolvers;
    struct AvahiAddressResolver *_item = r;
    /* assertion _item */
    assert(_item != ((struct AvahiAddressResolver *)NULL));
    if(!(_item->address_resolvers_next == ((struct AvahiAddressResolver *)NULL)))
      _item->address_resolvers_next->address_resolvers_prev = _item->address_resolvers_prev;

    if(!(_item->address_resolvers_prev == ((struct AvahiAddressResolver *)NULL)))
      _item->address_resolvers_prev->address_resolvers_next = _item->address_resolvers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->address_resolvers_next;
    }
    _item->address_resolvers_prev = (struct AvahiAddressResolver *)(void *)0;
    _item->address_resolvers_next = _item->address_resolvers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)r->path);
  avahi_free((void *)r);
  return ret;
}

// avahi_address_resolver_get_client
// file resolver.c line 755
struct AvahiClient * avahi_address_resolver_get_client(struct AvahiAddressResolver *r)
{
  /* assertion r */
  assert(r != ((struct AvahiAddressResolver *)NULL));
  return r->client;
}

// avahi_address_resolver_new
// file resolver.c line 642
struct AvahiAddressResolver * avahi_address_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const struct AvahiAddress *a, enum anonymous_1 flags, void (*callback)(struct AvahiAddressResolver *, signed int, signed int, enum anonymous_6, const struct AvahiAddress *, const char *, enum anonymous_3, void *), void *userdata)
{
  struct DBusError error;
  struct AvahiAddressResolver *r = (struct AvahiAddressResolver *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  char *path;
  char addr[40l];
  char *address = addr;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  dbus_error_init(&error);
  char *return_value_avahi_address_snprint_1;
  return_value_avahi_address_snprint_1=avahi_address_snprint(addr, sizeof(char [40l]) /*40ul*/ , a);
  void *return_value_avahi_new_internal_3;
  unsigned int return_value_dbus_message_append_args_4;
  _Bool tmp_if_expr_6;
  unsigned int return_value_dbus_error_is_set_5;
  unsigned int return_value_dbus_message_get_args_7;
  _Bool tmp_if_expr_9;
  unsigned int return_value_dbus_error_is_set_8;
  if(return_value_avahi_address_snprint_1 == ((char *)NULL))
  {
    avahi_client_set_errno(client, -14);
    return (struct AvahiAddressResolver *)(void *)0;
  }

  else
  {
    signed int return_value_avahi_client_is_connected_2;
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(client);
    if(return_value_avahi_client_is_connected_2 == 0)
      avahi_client_set_errno(client, -2);

    else
    {
      return_value_avahi_new_internal_3=avahi_new_internal_link3((unsigned int)1, sizeof(struct AvahiAddressResolver) /*80ul*/ );
      r = (struct AvahiAddressResolver *)return_value_avahi_new_internal_3;
      if(r == ((struct AvahiAddressResolver *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        r->client = client;
        r->callback = callback;
        r->userdata = userdata;
        r->path = (char *)(void *)0;
        r->interface = interface;
        r->protocol = protocol;
        r->address = *a;
        do
        {
          struct AvahiAddressResolver **_head = &client->address_resolvers;
          struct AvahiAddressResolver *_item = r;
          /* assertion _item */
          assert(_item != ((struct AvahiAddressResolver *)NULL));
          _item->address_resolvers_next = *_head;
          if(!(_item->address_resolvers_next == ((struct AvahiAddressResolver *)NULL)))
            _item->address_resolvers_next->address_resolvers_prev = _item;

          _item->address_resolvers_prev = (struct AvahiAddressResolver *)(void *)0;
          *_head = _item;
        }
        while((_Bool)0);
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "AddressResolverNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args_4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &address, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args_4 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr_6 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_5=dbus_error_is_set(&error);
              tmp_if_expr_6 = return_value_dbus_error_is_set_5 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_6)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args_7=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args_7 == 0u)
                tmp_if_expr_9 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set_8=dbus_error_is_set(&error);
                tmp_if_expr_9 = return_value_dbus_error_is_set_8 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr_9)
                avahi_client_set_errno(client, -22);

              else
              {
                r->path=avahi_strdup(path);
                if(r->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return r;
                }
              }
            }
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_10;
    return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_10 == 0u))
    {
      avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(r == ((struct AvahiAddressResolver *)NULL)))
      avahi_address_resolver_free(r);

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return (struct AvahiAddressResolver *)(void *)0;
  }
}

// avahi_address_snprint
// file ../avahi-common/address.h line 90
char * avahi_address_snprint(char *s, unsigned long int length, const struct AvahiAddress *a)
{
  /* assertion s */
  assert(s != ((char *)NULL));
  /* assertion length */
  assert(length != 0ul);
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  signed int return_value_avahi_proto_to_af_1;
  return_value_avahi_proto_to_af_1=avahi_proto_to_af(a->proto);
  const char *return_value_inet_ntop_2;
  return_value_inet_ntop_2=inet_ntop(return_value_avahi_proto_to_af_1, (const void *)a->data.data, s, (unsigned int)length);
  if(return_value_inet_ntop_2 == ((const char *)NULL))
    return (char *)(void *)0;

  else
    return s;
}

// avahi_af_to_proto
// file address.c line 137
signed int avahi_af_to_proto(signed int af)
{
  if(af == 2)
    return 0;

  else
    if(af == 10)
      return 1;

    else
    {
      /* assertion af == 0 */
      assert(af == 0);
      return -1;
    }
}

// avahi_age
// file timeval.c line 76
signed long int avahi_age(struct timeval *a)
{
  struct timeval now;
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  gettimeofday(&now, (struct timezone *)(void *)0);
  signed long int return_value_avahi_timeval_diff_1;
  return_value_avahi_timeval_diff_1=avahi_timeval_diff(&now, a);
  return return_value_avahi_timeval_diff_1;
}

// avahi_alternative_host_name
// file alternative.c line 51
char * avahi_alternative_host_name(const char *s)
{
  const char *e;
  char *r;
  /* assertion s */
  assert(s != ((const char *)NULL));
  signed int return_value_avahi_is_valid_host_name_1;
  return_value_avahi_is_valid_host_name_1=avahi_is_valid_host_name(s);
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_5;
  if(return_value_avahi_is_valid_host_name_1 == 0)
    return (char *)(void *)0;

  else
  {
    e=strrchr(s, 45);
    if(!(e == ((const char *)NULL)))
    {
      const char *p;
      e = e + 1l;
      p = e;
      for( ; !(*p == 0); p = p + 1l)
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*p]) == 0)
        {
          e = (const char *)(void *)0;
          break;
        }

      }
      if(!(e == ((const char *)NULL)))
      {
        if((signed int)*e == 48)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)*e == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
          e = (const char *)(void *)0;

      }

    }

    if(!(e == ((const char *)NULL)))
    {
      char *avahi_alternative_host_name__1__2__c;
      char *m;
      unsigned long int l;
      signed int n;
      signed int return_value_atoi_4;
      return_value_atoi_4=atoi(e);
      n = return_value_atoi_4 + 1;
      m=avahi_strdup_printf("%i", n);
      if(m == ((char *)NULL))
        return (char *)(void *)0;

      l = (unsigned long int)((e - s) - (signed long int)1);
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(m);
      if(l >= 63ul + -return_value_strlen_6 + 18446744073709551615ul)
      {
        return_value_strlen_5=strlen(m);
        l = ((unsigned long int)(64 - 1) - return_value_strlen_5) - (unsigned long int)1;
      }

      avahi_alternative_host_name__1__2__c=avahi_strndup(s, l);
      if(avahi_alternative_host_name__1__2__c == ((char *)NULL))
      {
        avahi_free((void *)m);
        return (char *)(void *)0;
      }

      drop_incomplete_utf8(avahi_alternative_host_name__1__2__c);
      r=avahi_strdup_printf("%s-%s", avahi_alternative_host_name__1__2__c, m);
      avahi_free((void *)avahi_alternative_host_name__1__2__c);
      avahi_free((void *)m);
    }

    else
    {
      char *c;
      c=avahi_strndup(s, (unsigned long int)((64 - 1) - 2));
      if(c == ((char *)NULL))
        return (char *)(void *)0;

      drop_incomplete_utf8(c);
      r=avahi_strdup_printf("%s-2", c);
      avahi_free((void *)c);
    }
    signed int return_value_avahi_is_valid_host_name_7;
    return_value_avahi_is_valid_host_name_7=avahi_is_valid_host_name(r);
    /* assertion avahi_is_valid_host_name(r) */
    assert(return_value_avahi_is_valid_host_name_7 != 0);
    return r;
  }
}

// avahi_alternative_service_name
// file alternative.c line 117
char * avahi_alternative_service_name(const char *s)
{
  const char *e;
  char *r;
  /* assertion s */
  assert(s != ((const char *)NULL));
  signed int return_value_avahi_is_valid_service_name_1;
  return_value_avahi_is_valid_service_name_1=avahi_is_valid_service_name(s);
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_5;
  if(return_value_avahi_is_valid_service_name_1 == 0)
    return (char *)(void *)0;

  else
  {
    e=strstr(s, " #");
    if(!(e == ((const char *)NULL)))
    {
      const char *n;
      const char *p;
      e = e + (signed long int)2;
      do
      {
        n=strstr(e, " #");
        if(n == ((const char *)NULL))
          break;

        e = n + (signed long int)2;
      }
      while((_Bool)1);
      p = e;
      for( ; !(*p == 0); p = p + 1l)
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*p]) == 0)
        {
          e = (const char *)(void *)0;
          break;
        }

      }
      if(!(e == ((const char *)NULL)))
      {
        if((signed int)*e == 48)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)*e == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
          e = (const char *)(void *)0;

      }

    }

    if(!(e == ((const char *)NULL)))
    {
      char *c;
      char *m;
      unsigned long int l;
      signed int avahi_alternative_service_name__1__2__n;
      signed int return_value_atoi_4;
      return_value_atoi_4=atoi(e);
      avahi_alternative_service_name__1__2__n = return_value_atoi_4 + 1;
      m=avahi_strdup_printf("%i", avahi_alternative_service_name__1__2__n);
      if(m == ((char *)NULL))
        return (char *)(void *)0;

      l = (unsigned long int)((e - s) - (signed long int)2);
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(m);
      if(l >= 63ul + -return_value_strlen_6 + 18446744073709551614ul)
      {
        return_value_strlen_5=strlen(m);
        l = ((unsigned long int)(64 - 1) - return_value_strlen_5) - (unsigned long int)2;
      }

      c=avahi_strndup(s, l);
      if(c == ((char *)NULL))
      {
        avahi_free((void *)m);
        return (char *)(void *)0;
      }

      drop_incomplete_utf8(c);
      r=avahi_strdup_printf("%s #%s", c, m);
      avahi_free((void *)c);
      avahi_free((void *)m);
    }

    else
    {
      char *avahi_alternative_service_name__1__3__c;
      avahi_alternative_service_name__1__3__c=avahi_strndup(s, (unsigned long int)((64 - 1) - 3));
      if(avahi_alternative_service_name__1__3__c == ((char *)NULL))
        return (char *)(void *)0;

      drop_incomplete_utf8(avahi_alternative_service_name__1__3__c);
      r=avahi_strdup_printf("%s #2", avahi_alternative_service_name__1__3__c);
      avahi_free((void *)avahi_alternative_service_name__1__3__c);
    }
    signed int return_value_avahi_is_valid_service_name_7;
    return_value_avahi_is_valid_service_name_7=avahi_is_valid_service_name(r);
    /* assertion avahi_is_valid_service_name(r) */
    assert(return_value_avahi_is_valid_service_name_7 != 0);
    return r;
  }
}

// avahi_client_errno
// file ../avahi-client/client.h line 99
signed int avahi_client_errno(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  return client->error;
}

// avahi_client_free
// file ../avahi-client/client.h line 72
void avahi_client_free(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  if(!(client->bus == ((struct DBusConnection *)NULL)))
    dbus_connection_close(client->bus);

  while(!(client->groups == ((struct AvahiEntryGroup *)NULL)))
    avahi_entry_group_free(client->groups);
  while(!(client->domain_browsers == ((struct AvahiDomainBrowser *)NULL)))
    avahi_domain_browser_free(client->domain_browsers);
  while(!(client->service_browsers == ((struct AvahiServiceBrowser *)NULL)))
    avahi_service_browser_free(client->service_browsers);
  while(!(client->service_type_browsers == ((struct AvahiServiceTypeBrowser *)NULL)))
    avahi_service_type_browser_free(client->service_type_browsers);
  while(!(client->service_resolvers == ((struct AvahiServiceResolver *)NULL)))
    avahi_service_resolver_free(client->service_resolvers);
  while(!(client->host_name_resolvers == ((struct AvahiHostNameResolver *)NULL)))
    avahi_host_name_resolver_free(client->host_name_resolvers);
  while(!(client->address_resolvers == ((struct AvahiAddressResolver *)NULL)))
    avahi_address_resolver_free(client->address_resolvers);
  while(!(client->record_browsers == ((struct AvahiRecordBrowser *)NULL)))
    avahi_record_browser_free(client->record_browsers);
  if(!(client->bus == ((struct DBusConnection *)NULL)))
    dbus_connection_unref(client->bus);

  avahi_free((void *)client->version_string);
  avahi_free((void *)client->host_name);
  avahi_free((void *)client->host_name_fqdn);
  avahi_free((void *)client->domain_name);
  avahi_free((void *)client);
}

// avahi_client_get_domain_name
// file client.c line 742
const char * avahi_client_get_domain_name(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected_1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->domain_name == ((char *)NULL))
      client->domain_name=avahi_client_get_string_reply_and_block(client, "GetDomainName", (const char *)(void *)0);

    return client->domain_name;
  }
}

// avahi_client_get_host_name
// file client.c line 756
const char * avahi_client_get_host_name(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected_1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->host_name == ((char *)NULL))
      client->host_name=avahi_client_get_string_reply_and_block(client, "GetHostName", (const char *)(void *)0);

    return client->host_name;
  }
}

// avahi_client_get_host_name_fqdn
// file ../avahi-client/client.h line 91
const char * avahi_client_get_host_name_fqdn(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected_1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->host_name_fqdn == ((char *)NULL))
      client->host_name_fqdn=avahi_client_get_string_reply_and_block(client, "GetHostNameFqdn", (const char *)(void *)0);

    return client->host_name_fqdn;
  }
}

// avahi_client_get_local_service_cookie
// file client.c line 846
unsigned int avahi_client_get_local_service_cookie(struct AvahiClient *client)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  _Bool tmp_if_expr_3;
  unsigned int return_value_dbus_error_is_set_2;
  unsigned int return_value_dbus_message_get_args_4;
  _Bool tmp_if_expr_6;
  unsigned int return_value_dbus_error_is_set_5;
  if(return_value_avahi_client_is_connected_1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (unsigned int)0;
  }

  else
    if(!(client->local_service_cookie_valid == 0))
      return client->local_service_cookie;

    else
    {
      dbus_error_init(&error);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetLocalServiceCookie");
      if(message == ((struct DBusMessage *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_2=dbus_error_is_set(&error);
          tmp_if_expr_3 = return_value_dbus_error_is_set_2 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr_3)
        {
          return_value_dbus_message_get_args_4=dbus_message_get_args(reply, &error, (signed int)117, &client->local_service_cookie, (signed int)0);
          if(return_value_dbus_message_get_args_4 == 0u)
            tmp_if_expr_6 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_5=dbus_error_is_set(&error);
            tmp_if_expr_6 = return_value_dbus_error_is_set_5 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr_6)
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            client->local_service_cookie_valid = 1;
            return client->local_service_cookie;
          }

        }

      }

    fail:
      ;
      if(!(message == ((struct DBusMessage *)NULL)))
        dbus_message_unref(message);

      if(!(reply == ((struct DBusMessage *)NULL)))
        dbus_message_unref(reply);

      unsigned int return_value_dbus_error_is_set_7;
      return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
      if(!(return_value_dbus_error_is_set_7 == 0u))
      {
        avahi_client_set_dbus_error(client, &error);
        dbus_error_free(&error);
      }

      return (unsigned int)0;
    }
}

// avahi_client_get_state
// file client.c line 784
enum anonymous_7 avahi_client_get_state(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  return client->state;
}

// avahi_client_get_string_reply_and_block
// file client.c line 672
static char * avahi_client_get_string_reply_and_block(struct AvahiClient *client, const char *method, const char *param)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *ret;
  char *n;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion method */
  assert(method != ((const char *)NULL));
  dbus_error_init(&error);
  message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", method);
  _Bool tmp_if_expr_3;
  unsigned int return_value_dbus_error_is_set_2;
  unsigned int return_value_dbus_message_get_args_4;
  _Bool tmp_if_expr_6;
  unsigned int return_value_dbus_error_is_set_5;
  if(message == ((struct DBusMessage *)NULL))
    avahi_client_set_errno(client, -24);

  else
  {
    if(!(param == ((const char *)NULL)))
    {
      unsigned int return_value_dbus_message_append_args_1;
      return_value_dbus_message_append_args_1=dbus_message_append_args(message, (signed int)115, &param, (signed int)0);
      if(return_value_dbus_message_append_args_1 == 0u)
      {
        avahi_client_set_errno(client, -24);
        goto fail;
      }

    }

    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_2=dbus_error_is_set(&error);
      tmp_if_expr_3 = return_value_dbus_error_is_set_2 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_3)
    {
      return_value_dbus_message_get_args_4=dbus_message_get_args(reply, &error, (signed int)115, &ret, (signed int)0);
      if(return_value_dbus_message_get_args_4 == 0u)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_5=dbus_error_is_set(&error);
        tmp_if_expr_6 = return_value_dbus_error_is_set_5 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_6)
      {
        n=avahi_strdup(ret);
        if(n == ((char *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          dbus_message_unref(message);
          dbus_message_unref(reply);
          return n;
        }
      }

    }

  }

fail:
  ;
  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  unsigned int return_value_dbus_error_is_set_7;
  return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_7 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  return (char *)(void *)0;
}

// avahi_client_get_version_string
// file ../avahi-client/client.h line 79
const char * avahi_client_get_version_string(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected_1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->version_string == ((char *)NULL))
      client->version_string=avahi_client_get_string_reply_and_block(client, "GetVersionString", (const char *)(void *)0);

    return client->version_string;
  }
}

// avahi_client_is_connected
// file client.c line 896
signed int avahi_client_is_connected(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  _Bool tmp_if_expr_2;
  unsigned int return_value_dbus_connection_get_is_connected_1;
  if(!(client->bus == ((struct DBusConnection *)NULL)))
  {
    return_value_dbus_connection_get_is_connected_1=dbus_connection_get_is_connected(client->bus);
    tmp_if_expr_2 = return_value_dbus_connection_get_is_connected_1 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_2)
  {
    if((signed int)client->state == AVAHI_CLIENT_S_RUNNING)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)client->state == AVAHI_CLIENT_S_REGISTERING ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)client->state == AVAHI_CLIENT_S_COLLISION ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  return (signed int)tmp_if_expr_5;
}

// avahi_client_new
// file ../avahi-client/client.h line 62
struct AvahiClient * avahi_client_new(const struct AvahiPoll *poll_api, enum anonymous_8 flags, void (*callback)(struct AvahiClient *, enum anonymous_7, void *), void *userdata, signed int *ret_error)
{
  struct AvahiClient *avahi_client_new__1__client = (struct AvahiClient *)(void *)0;
  struct DBusError error;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  avahi_init_i18n();
  dbus_error_init(&error);
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal((unsigned int)1, sizeof(struct AvahiClient) /*152ul*/ );
  avahi_client_new__1__client = (struct AvahiClient *)return_value_avahi_new_internal_1;
  _Bool tmp_if_expr_3;
  unsigned int return_value_dbus_error_is_set_2;
  signed int return_value_avahi_dbus_connection_glue_4;
  unsigned int return_value_dbus_connection_add_filter_5;
  unsigned int return_value_dbus_error_is_set_6;
  unsigned int return_value_dbus_error_is_set_7;
  unsigned int return_value_dbus_error_is_set_8;
  _Bool tmp_if_expr_11;
  unsigned int return_value_dbus_error_is_set_10;
  if(avahi_client_new__1__client == ((struct AvahiClient *)NULL))
  {
    if(!(ret_error == ((signed int *)NULL)))
      *ret_error = -24;

  }

  else
  {
    avahi_client_new__1__client->poll_api = poll_api;
    avahi_client_new__1__client->error = 0;
    avahi_client_new__1__client->callback = callback;
    avahi_client_new__1__client->userdata = userdata;
    avahi_client_new__1__client->state = (enum anonymous_7)-1;
    avahi_client_new__1__client->flags = flags;
    avahi_client_new__1__client->host_name = (char *)(void *)0;
    avahi_client_new__1__client->host_name_fqdn = (char *)(void *)0;
    avahi_client_new__1__client->domain_name = (char *)(void *)0;
    avahi_client_new__1__client->version_string = (char *)(void *)0;
    avahi_client_new__1__client->local_service_cookie_valid = 0;
    do
      avahi_client_new__1__client->groups = (struct AvahiEntryGroup *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new__1__client->domain_browsers = (struct AvahiDomainBrowser *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new__1__client->service_browsers = (struct AvahiServiceBrowser *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new__1__client->service_type_browsers = (struct AvahiServiceTypeBrowser *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new__1__client->service_resolvers = (struct AvahiServiceResolver *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new__1__client->host_name_resolvers = (struct AvahiHostNameResolver *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new__1__client->address_resolvers = (struct AvahiAddressResolver *)(void *)0;
    while((_Bool)0);
    do
      avahi_client_new__1__client->record_browsers = (struct AvahiRecordBrowser *)(void *)0;
    while((_Bool)0);
    avahi_client_new__1__client->bus=avahi_dbus_bus_get(&error);
    if(avahi_client_new__1__client->bus == ((struct DBusConnection *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_2=dbus_error_is_set(&error);
      tmp_if_expr_3 = return_value_dbus_error_is_set_2 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
    {
      if(!(ret_error == ((signed int *)NULL)))
        *ret_error = -22;

    }

    else
    {
      return_value_avahi_dbus_connection_glue_4=avahi_dbus_connection_glue(avahi_client_new__1__client->bus, poll_api);
      if(!(return_value_avahi_dbus_connection_glue_4 >= 0))
      {
        if(!(ret_error == ((signed int *)NULL)))
          *ret_error = -24;

      }

      else
      {
        return_value_dbus_connection_add_filter_5=dbus_connection_add_filter(avahi_client_new__1__client->bus, filter_func, (void *)avahi_client_new__1__client, (void (*)(void *))(void *)0);
        if(return_value_dbus_connection_add_filter_5 == 0u)
        {
          if(!(ret_error == ((signed int *)NULL)))
            *ret_error = -24;

        }

        else
        {
          dbus_bus_add_match(avahi_client_new__1__client->bus, "type='signal', interface='org.freedesktop.Avahi.Server', sender='org.freedesktop.Avahi', path='/'", &error);
          return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
          if(return_value_dbus_error_is_set_6 == 0u)
          {
            dbus_bus_add_match(avahi_client_new__1__client->bus, "type='signal', interface='org.freedesktop.DBus', sender='org.freedesktop.DBus', path='/org/freedesktop/DBus'", &error);
            return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
            if(return_value_dbus_error_is_set_7 == 0u)
            {
              dbus_bus_add_match(avahi_client_new__1__client->bus, "type='signal', interface='org.freedesktop.DBus.Local'", &error);
              return_value_dbus_error_is_set_8=dbus_error_is_set(&error);
              if(return_value_dbus_error_is_set_8 == 0u)
              {
                message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.DBus.Peer", "Ping");
                if(!(message == ((struct DBusMessage *)NULL)))
                {
                  reply=dbus_connection_send_with_reply_and_block(avahi_client_new__1__client->bus, message, -1, &error);
                  if(reply == ((struct DBusMessage *)NULL))
                    tmp_if_expr_11 = (_Bool)1;

                  else
                  {
                    return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
                    tmp_if_expr_11 = return_value_dbus_error_is_set_10 != 0u ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_11)
                  {
                    dbus_error_free(&error);
                    if((AVAHI_CLIENT_NO_FAIL & (signed int)flags) == 0)
                    {
                      if(!(ret_error == ((signed int *)NULL)))
                        *ret_error = -26;

                      goto fail;
                    }

                    client_set_state(avahi_client_new__1__client, (enum anonymous_7)AVAHI_CLIENT_CONNECTING);
                  }

                  else
                  {
                    signed int return_value_init_server_9;
                    return_value_init_server_9=init_server(avahi_client_new__1__client, ret_error);
                    if(!(return_value_init_server_9 >= 0))
                      goto fail;

                  }
                  dbus_message_unref(message);
                  if(!(reply == ((struct DBusMessage *)NULL)))
                    dbus_message_unref(reply);

                  return avahi_client_new__1__client;
                }

              }

            }

          }

        }
      }
    }
  }

fail:
  ;
  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  if(!(avahi_client_new__1__client == ((struct AvahiClient *)NULL)))
    avahi_client_free(avahi_client_new__1__client);

  unsigned int return_value_dbus_error_is_set_13;
  return_value_dbus_error_is_set_13=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_13 == 0u))
  {
    if(!(ret_error == ((signed int *)NULL)))
    {
      signed int return_value_strcmp_12;
      return_value_strcmp_12=strcmp(error.name, "org.freedesktop.DBus.Error.FileNotFound");
      if(return_value_strcmp_12 == 0)
        *ret_error = -26;

      else
        *ret_error=avahi_error_dbus_to_number(error.name);
    }

    dbus_error_free(&error);
  }

  return (struct AvahiClient *)(void *)0;
}

// avahi_client_set_dbus_error
// file client.c line 51
signed int avahi_client_set_dbus_error(struct AvahiClient *client, struct DBusError *error)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion error */
  assert(error != ((struct DBusError *)NULL));
  signed int return_value_avahi_error_dbus_to_number_1;
  return_value_avahi_error_dbus_to_number_1=avahi_error_dbus_to_number(error->name);
  signed int return_value_avahi_client_set_errno_2;
  return_value_avahi_client_set_errno_2=avahi_client_set_errno(client, return_value_avahi_error_dbus_to_number_1);
  return return_value_avahi_client_set_errno_2;
}

// avahi_client_set_errno
// file client.c line 45
signed int avahi_client_set_errno(struct AvahiClient *client, signed int error)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  client->error = error;
  return client->error;
}

// avahi_client_set_host_name
// file ../avahi-client/client.h line 85
signed int avahi_client_set_host_name(struct AvahiClient *client, const char *name)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected_2;
  return_value_avahi_client_is_connected_2=avahi_client_is_connected(client);
  signed int return_value_avahi_client_set_errno_1;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_2 == 0)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "SetHostName");
    if(message == ((struct DBusMessage *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)115, &name, (signed int)0);
      if(return_value_dbus_message_append_args_3 == 0u)
        avahi_client_set_errno(client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
          tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr_5)
        {
          return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args_6 == 0u)
            tmp_if_expr_8 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
            tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr_8)
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            avahi_free((void *)client->host_name);
            client->host_name = (char *)(void *)0;
            avahi_free((void *)client->host_name_fqdn);
            client->host_name_fqdn = (char *)(void *)0;
            return 0;
          }

        }

      }
    }

  fail:
    ;
    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    unsigned int return_value_dbus_error_is_set_9;
    return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_9 == 0u))
    {
      avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    return client->error;
  }
}

// avahi_client_simple_method_call
// file client.c line 797
signed int avahi_client_simple_method_call(struct AvahiClient *client, const char *path, const char *interface, const char *method)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  dbus_error_init(&error);
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion path */
  assert(path != ((const char *)NULL));
  /* assertion interface */
  assert(interface != ((const char *)NULL));
  /* assertion method */
  assert(method != ((const char *)NULL));
  message=dbus_message_new_method_call("org.freedesktop.Avahi", path, interface, method);
  _Bool tmp_if_expr_2;
  unsigned int return_value_dbus_error_is_set_1;
  unsigned int return_value_dbus_message_get_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  if(message == ((struct DBusMessage *)NULL))
    r=avahi_client_set_errno(client, -24);

  else
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_1=dbus_error_is_set(&error);
      tmp_if_expr_2 = return_value_dbus_error_is_set_1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      r=avahi_client_set_errno(client, -22);

    else
    {
      return_value_dbus_message_get_args_3=dbus_message_get_args(reply, &error, (signed int)0);
      if(return_value_dbus_message_get_args_3 == 0u)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
        tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        r=avahi_client_set_errno(client, -22);

      else
      {
        dbus_message_unref(message);
        dbus_message_unref(reply);
        return 0;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_6;
  return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_6 == 0u))
  {
    r=avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return r;
}

// avahi_dbus_bus_get
// file client.c line 445
static struct DBusConnection * avahi_dbus_bus_get(struct DBusError *error)
{
  struct DBusConnection *c;
  c=dbus_bus_get_private((enum anonymous_29)DBUS_BUS_SYSTEM, error);
  if(c == ((struct DBusConnection *)NULL))
    return (struct DBusConnection *)(void *)0;

  else
  {
    dbus_connection_set_exit_on_disconnect(c, (unsigned int)0);
    return c;
  }
}

// avahi_dbus_connection_glue
// file ../avahi-common/dbus-watch-glue.h line 29
signed int avahi_dbus_connection_glue(struct DBusConnection *c, const struct AvahiPoll *poll_api)
{
  struct anonymous_11 *d = (struct anonymous_11 *)(void *)0;
  /* assertion c */
  assert(c != ((struct DBusConnection *)NULL));
  /* assertion poll_api */
  assert(poll_api != ((const struct AvahiPoll *)NULL));
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link4((unsigned int)1, sizeof(struct anonymous_11) /*32ul*/ );
  d = (struct anonymous_11 *)return_value_avahi_new_internal_1;
  struct anonymous_11 *return_value_connection_data_ref_2;
  unsigned int return_value_dbus_connection_set_watch_functions_3;
  struct anonymous_11 *return_value_connection_data_ref_4;
  unsigned int return_value_dbus_connection_set_timeout_functions_5;
  struct anonymous_11 *return_value_connection_data_ref_6;
  enum anonymous_10 return_value_dbus_connection_get_dispatch_status_7;
  if(!(d == ((struct anonymous_11 *)NULL)))
  {
    d->poll_api = poll_api;
    d->connection = c;
    d->ref = 1;
    d->dispatch_timeout=poll_api->timeout_new(poll_api, (struct timeval *)(void *)0, dispatch_timeout_callback, (void *)d);
    return_value_connection_data_ref_2=connection_data_ref(d);
    return_value_dbus_connection_set_watch_functions_3=dbus_connection_set_watch_functions(c, add_watch, remove_watch, watch_toggled, (void *)return_value_connection_data_ref_2, (void (*)(void *))connection_data_unref);
    return_value_connection_data_ref_4=connection_data_ref(d);
    return_value_dbus_connection_set_timeout_functions_5=dbus_connection_set_timeout_functions(c, add_timeout, remove_timeout, timeout_toggled, (void *)return_value_connection_data_ref_4, (void (*)(void *))connection_data_unref);
    return_value_connection_data_ref_6=connection_data_ref(d);
    dbus_connection_set_dispatch_status_function(c, dispatch_status, (void *)return_value_connection_data_ref_6, (void (*)(void *))connection_data_unref);
    return_value_dbus_connection_get_dispatch_status_7=dbus_connection_get_dispatch_status(c);
    if((signed int)return_value_dbus_connection_get_dispatch_status_7 == DBUS_DISPATCH_DATA_REMAINS)
      request_dispatch(d, 1);

    connection_data_unref(d);
    return 0;
  }

  else
  {

  fail:
    ;
    if(!(d == ((struct anonymous_11 *)NULL)))
    {
      d->poll_api->timeout_free(d->dispatch_timeout);
      avahi_free((void *)d);
    }

    return -1;
  }
}

// avahi_domain_browser_event
// file internal.h line 159
enum anonymous_28 avahi_domain_browser_event(struct AvahiClient *client, enum anonymous_2 event, struct DBusMessage *message)
{
  struct AvahiDomainBrowser *db = (struct AvahiDomainBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *domain = (char *)(void *)0;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  struct AvahiStringList *l;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_5;
  _Bool tmp_if_expr_7;
  unsigned int return_value_dbus_error_is_set_6;
  signed int return_value_avahi_error_dbus_to_number_8;
  signed int return_value_avahi_domain_equal_9;
  if(!(path == ((const char *)NULL)))
  {
    db = client->domain_browsers;
    for( ; !(db == ((struct AvahiDomainBrowser *)NULL)); db = db->domain_browsers_next)
    {
      return_value_strcmp_1=strcmp(db->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(db == ((struct AvahiDomainBrowser *)NULL))
      goto fail;

    interface = db->interface;
    protocol = db->protocol;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &domain, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args_5=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_5 == 0u)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
          tmp_if_expr_7 = return_value_dbus_error_is_set_6 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_8=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(db->client, return_value_avahi_error_dbus_to_number_8);
      }
    }
    if(!(domain == ((char *)NULL)))
    {
      l = db->static_browse_domains;
      for( ; !(l == ((struct AvahiStringList *)NULL)); l = l->next)
      {
        return_value_avahi_domain_equal_9=avahi_domain_equal((char *)l->text, domain);
        if(!(return_value_avahi_domain_equal_9 == 0))
          return (enum anonymous_28)DBUS_HANDLER_RESULT_HANDLED;

      }
    }

    db->callback(db, (signed int)interface, (signed int)protocol, event, domain, (enum anonymous_3)flags, db->userdata);
    return (enum anonymous_28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous_28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_domain_browser_free
// file lookup.h line 71
signed int avahi_domain_browser_free(struct AvahiDomainBrowser *b)
{
  struct AvahiClient *avahi_domain_browser_free__1__client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  /* assertion b->ref >= 1 */
  assert(b->ref >= 1);
  b->ref = b->ref - 1;
  signed int return_value_avahi_client_is_connected_1;
  if(b->ref >= 1)
    return 0;

  else
  {
    avahi_domain_browser_free__1__client = b->client;
    if(!(b->path == ((char *)NULL)))
    {
      return_value_avahi_client_is_connected_1=avahi_client_is_connected(b->client);
      if(!(return_value_avahi_client_is_connected_1 == 0))
        r=avahi_client_simple_method_call(avahi_domain_browser_free__1__client, b->path, "org.freedesktop.Avahi.DomainBrowser", "Free");

    }

    do
    {
      struct AvahiDomainBrowser **_head = &avahi_domain_browser_free__1__client->domain_browsers;
      struct AvahiDomainBrowser *_item = b;
      /* assertion _item */
      assert(_item != ((struct AvahiDomainBrowser *)NULL));
      if(!(_item->domain_browsers_next == ((struct AvahiDomainBrowser *)NULL)))
        _item->domain_browsers_next->domain_browsers_prev = _item->domain_browsers_prev;

      if(!(_item->domain_browsers_prev == ((struct AvahiDomainBrowser *)NULL)))
        _item->domain_browsers_prev->domain_browsers_next = _item->domain_browsers_next;

      else
      {
        /* assertion *_head == _item */
        assert(*_head == _item);
        *_head = _item->domain_browsers_next;
      }
      _item->domain_browsers_prev = (struct AvahiDomainBrowser *)(void *)0;
      _item->domain_browsers_next = _item->domain_browsers_prev;
    }
    while((_Bool)0);
    if(!(b->defer_timeout == ((struct AvahiTimeout *)NULL)))
      b->client->poll_api->timeout_free(b->defer_timeout);

    avahi_string_list_free(b->static_browse_domains);
    avahi_free((void *)b->path);
    avahi_free((void *)b);
    return r;
  }
}

// avahi_domain_browser_get_client
// file browser.c line 234
struct AvahiClient * avahi_domain_browser_get_client(struct AvahiDomainBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  return b->client;
}

// avahi_domain_browser_new
// file browser.c line 104
struct AvahiDomainBrowser * avahi_domain_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous_0 btype, enum anonymous_1 flags, void (*callback)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous_2, const char *, enum anonymous_3, void *), void *userdata)
{
  struct AvahiDomainBrowser *db = (struct AvahiDomainBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_interface;
  signed int i_protocol;
  signed int bt;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous_2, const char *, enum anonymous_3, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    return_value_avahi_new_internal_2=avahi_new_internal_link2((unsigned int)1, sizeof(struct AvahiDomainBrowser) /*80ul*/ );
    db = (struct AvahiDomainBrowser *)return_value_avahi_new_internal_2;
    if(db == ((struct AvahiDomainBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      db->ref = 1;
      db->client = client;
      db->callback = callback;
      db->userdata = userdata;
      db->path = (char *)(void *)0;
      db->interface = interface;
      db->protocol = protocol;
      db->static_browse_domains = (struct AvahiStringList *)(void *)0;
      db->defer_timeout = (struct AvahiTimeout *)(void *)0;
      do
      {
        struct AvahiDomainBrowser **_head = &client->domain_browsers;
        struct AvahiDomainBrowser *_item = db;
        /* assertion _item */
        assert(_item != ((struct AvahiDomainBrowser *)NULL));
        _item->domain_browsers_next = *_head;
        if(!(_item->domain_browsers_next == ((struct AvahiDomainBrowser *)NULL)))
          _item->domain_browsers_next->domain_browsers_prev = _item;

        _item->domain_browsers_prev = (struct AvahiDomainBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      if((AVAHI_CLIENT_IGNORE_USER_CONFIG & (signed int)client->flags) == 0)
      {
        parse_environment(db);
        parse_domain_file(db);
      }

      db->static_browse_domains=avahi_string_list_reverse(db->static_browse_domains);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "DomainBrowserNew");
      if(message == ((struct DBusMessage *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        i_interface = (signed int)interface;
        i_protocol = (signed int)protocol;
        u_flags = (unsigned int)flags;
        bt = (signed int)btype;
        return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &domain, (signed int)105, &bt, (signed int)117, &u_flags, (signed int)0);
        if(return_value_dbus_message_append_args_3 == 0u)
          avahi_client_set_errno(client, -24);

        else
        {
          reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
          if(reply == ((struct DBusMessage *)NULL))
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
            tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_5)
            avahi_client_set_errno(client, -22);

          else
          {
            return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
            if(return_value_dbus_message_get_args_6 == 0u)
              tmp_if_expr_8 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
              tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(path == ((char *)NULL) || tmp_if_expr_8)
              avahi_client_set_errno(client, -22);

            else
            {
              db->path=avahi_strdup(path);
              if(db->path == ((char *)NULL))
                avahi_client_set_errno(client, -24);

              else
              {
                if(!(db->static_browse_domains == ((struct AvahiStringList *)NULL)))
                {
                  if((signed int)btype == AVAHI_DOMAIN_BROWSER_BROWSE)
                  {
                    struct timeval tv = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
                    db->defer_timeout=client->poll_api->timeout_new(client->poll_api, &tv, defer_timeout_callback, (void *)db);
                    if(db->defer_timeout == ((struct AvahiTimeout *)NULL))
                      avahi_client_set_errno(client, -24);

                  }

                }

                dbus_message_unref(message);
                dbus_message_unref(reply);
                return db;
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_9;
  return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(db == ((struct AvahiDomainBrowser *)NULL)))
    avahi_domain_browser_free(db);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiDomainBrowser *)(void *)0;
}

// avahi_domain_equal
// file ../avahi-common/domain.h line 62
signed int avahi_domain_equal(const char *a, const char *b)
{
  /* assertion a */
  assert(a != ((const char *)NULL));
  /* assertion b */
  assert(b != ((const char *)NULL));
  if(a == b)
    return 1;

  else
  {
    do
    {
      char ca[64l];
      char cb[64l];
      char *r;
      r=avahi_unescape_label(&a, ca, sizeof(char [64l]) /*64ul*/ );
      /* assertion r */
      assert(r != ((char *)NULL));
      r=avahi_unescape_label(&b, cb, sizeof(char [64l]) /*64ul*/ );
      /* assertion r */
      assert(r != ((char *)NULL));
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(ca, cb);
      if(!(return_value_strcasecmp_1 == 0))
        return 0;

      if(*a == 0)
      {
        if(*b == 0)
          return 1;

      }

    }
    while((_Bool)1);
    return 1;
  }
}

// avahi_domain_hash
// file domain.c line 424
unsigned int avahi_domain_hash(const char *s)
{
  unsigned int hash = (unsigned int)0;
  signed int return_value_tolower_1;
  while(!(*s == 0))
  {
    char c[64l];
    char *p;
    char *r;
    r=avahi_unescape_label(&s, c, sizeof(char [64l]) /*64ul*/ );
    /* assertion r */
    assert(r != ((char *)NULL));
    p = c;
    for( ; !(*p == 0); p = p + 1l)
    {
      return_value_tolower_1=tolower((signed int)*p);
      hash = (unsigned int)31 * hash + (unsigned int)return_value_tolower_1;
    }
  }
  return hash;
}

// avahi_elapse_time
// file ../avahi-common/timeval.h line 50
struct timeval * avahi_elapse_time(struct timeval *tv, unsigned int msec, unsigned int jitter)
{
  /* assertion tv */
  assert(tv != ((struct timeval *)NULL));
  gettimeofday(tv, (struct timezone *)(void *)0);
  if(!(msec == 0u))
    avahi_timeval_add(tv, (signed long int)msec * (signed long int)1000);

  if(!(jitter == 0u))
  {
    signed long int now;
    signed int r;
    now=time((signed long int *)(void *)0);
    static union anonymous_25 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
    pthread_mutex_lock(&mutex);
    static signed int last_rand;
    static signed long int timestamp = (signed long int)0;
    if(now >= 10l + timestamp)
    {
      timestamp = now;
      last_rand=rand();
    }

    r = last_rand;
    pthread_mutex_unlock(&mutex);
    avahi_timeval_add(tv, (signed long int)(((double)jitter * 1000.0 * (double)r) / ((double)2147483647 + 1.0)));
  }

  return tv;
}

// avahi_entry_group_add_address
// file entrygroup.c line 721
signed int avahi_entry_group_add_address(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, const struct AvahiAddress *a)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *avahi_entry_group_add_address__1__client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  char s_address[40l];
  char *p_address = s_address;
  /* assertion name */
  assert(name != ((const char *)NULL));
  avahi_entry_group_add_address__1__client = group->client;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  char *return_value_avahi_address_snprint_4;
  unsigned int return_value_dbus_message_append_args_5;
  _Bool tmp_if_expr_7;
  unsigned int return_value_dbus_error_is_set_6;
  unsigned int return_value_dbus_message_get_args_8;
  _Bool tmp_if_expr_10;
  unsigned int return_value_dbus_error_is_set_9;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddAddress");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(avahi_entry_group_add_address__1__client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_avahi_address_snprint_4=avahi_address_snprint(s_address, sizeof(char [40l]) /*40ul*/ , a);
      if(return_value_avahi_address_snprint_4 == ((char *)NULL))
        r=avahi_client_set_errno(avahi_entry_group_add_address__1__client, -14);

      else
      {
        return_value_dbus_message_append_args_5=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &p_address, (signed int)0);
        if(return_value_dbus_message_append_args_5 == 0u)
          r=avahi_client_set_errno(group->client, -24);

        else
        {
          reply=dbus_connection_send_with_reply_and_block(avahi_entry_group_add_address__1__client->bus, message, -1, &error);
          if(reply == ((struct DBusMessage *)NULL))
            tmp_if_expr_7 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
            tmp_if_expr_7 = return_value_dbus_error_is_set_6 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_7)
            r=avahi_client_set_errno(avahi_entry_group_add_address__1__client, -22);

          else
          {
            return_value_dbus_message_get_args_8=dbus_message_get_args(reply, &error, (signed int)0);
            if(return_value_dbus_message_get_args_8 == 0u)
              tmp_if_expr_10 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
              tmp_if_expr_10 = return_value_dbus_error_is_set_9 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_10)
              r=avahi_client_set_errno(avahi_entry_group_add_address__1__client, -22);

            else
            {
              dbus_message_unref(message);
              dbus_message_unref(reply);
              return 0;
            }
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_11;
    return_value_dbus_error_is_set_11=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_11 == 0u))
    {
      r=avahi_client_set_dbus_error(avahi_entry_group_add_address__1__client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_add_record
// file entrygroup.c line 808
signed int avahi_entry_group_add_record(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, unsigned short int clazz, unsigned short int type, unsigned int ttl, const void *rdata, unsigned long int size)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *avahi_entry_group_add_record__1__client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion name */
  assert(name != ((const char *)NULL));
  avahi_entry_group_add_record__1__client = group->client;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  unsigned int return_value_dbus_message_append_args_4;
  _Bool tmp_if_expr_6;
  signed int return_value_append_rdata_5;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  unsigned int return_value_dbus_message_get_args_9;
  _Bool tmp_if_expr_11;
  unsigned int return_value_dbus_error_is_set_10;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddRecord");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(avahi_entry_group_add_record__1__client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args_4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)113, &clazz, (signed int)113, &type, (signed int)117, &ttl, (signed int)0);
      if(return_value_dbus_message_append_args_4 == 0u)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_append_rdata_5=append_rdata(message, rdata, size);
        tmp_if_expr_6 = return_value_append_rdata_5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(avahi_entry_group_add_record__1__client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
          tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          r=avahi_client_set_errno(avahi_entry_group_add_record__1__client, -22);

        else
        {
          return_value_dbus_message_get_args_9=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args_9 == 0u)
            tmp_if_expr_11 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
            tmp_if_expr_11 = return_value_dbus_error_is_set_10 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_11)
            r=avahi_client_set_errno(avahi_entry_group_add_record__1__client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_12;
    return_value_dbus_error_is_set_12=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_12 == 0u))
    {
      r=avahi_client_set_dbus_error(avahi_entry_group_add_record__1__client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_add_service
// file entrygroup.c line 496
signed int avahi_entry_group_add_service(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, ...)
{
  void **va;
  signed int r;
  struct AvahiStringList *txt;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  va = (void **)&port;
  txt=avahi_string_list_new_va(va);
  r=avahi_entry_group_add_service_strlst(group, interface, protocol, flags, name, type, domain, host, port, txt);
  avahi_string_list_free(txt);
  va = ((void **)NULL);
  return r;
}

// avahi_entry_group_add_service_strlst
// file entrygroup.c line 402
signed int avahi_entry_group_add_service_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, struct AvahiStringList *txt)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *avahi_entry_group_add_service_strlst__1__client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  avahi_entry_group_add_service_strlst__1__client = group->client;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  unsigned int return_value_dbus_message_append_args_4;
  _Bool tmp_if_expr_6;
  signed int return_value_append_string_list_5;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  unsigned int return_value_dbus_message_get_args_9;
  _Bool tmp_if_expr_11;
  unsigned int return_value_dbus_error_is_set_10;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    if(host == ((const char *)NULL))
      host = "";

    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddService");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(avahi_entry_group_add_service_strlst__1__client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args_4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)115, &host, (signed int)113, &port, (signed int)0);
      if(return_value_dbus_message_append_args_4 == 0u)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_append_string_list_5=append_string_list(message, txt);
        tmp_if_expr_6 = return_value_append_string_list_5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(avahi_entry_group_add_service_strlst__1__client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
          tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          r=avahi_client_set_errno(avahi_entry_group_add_service_strlst__1__client, -22);

        else
        {
          return_value_dbus_message_get_args_9=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args_9 == 0u)
            tmp_if_expr_11 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
            tmp_if_expr_11 = return_value_dbus_error_is_set_10 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_11)
            r=avahi_client_set_errno(avahi_entry_group_add_service_strlst__1__client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_12;
    return_value_dbus_error_is_set_12=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_12 == 0u))
    {
      r=avahi_client_set_dbus_error(avahi_entry_group_add_service_strlst__1__client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_add_service_subtype
// file entrygroup.c line 522
signed int avahi_entry_group_add_service_subtype(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, const char *type, const char *domain, const char *subtype)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *avahi_entry_group_add_service_subtype__1__client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  /* assertion subtype */
  assert(subtype != ((const char *)NULL));
  avahi_entry_group_add_service_subtype__1__client = group->client;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  unsigned int return_value_dbus_message_append_args_4;
  _Bool tmp_if_expr_6;
  unsigned int return_value_dbus_error_is_set_5;
  unsigned int return_value_dbus_message_get_args_7;
  _Bool tmp_if_expr_9;
  unsigned int return_value_dbus_error_is_set_8;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddServiceSubtype");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(avahi_entry_group_add_service_subtype__1__client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args_4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)115, &subtype, (signed int)0);
      if(return_value_dbus_message_append_args_4 == 0u)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(avahi_entry_group_add_service_subtype__1__client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_5=dbus_error_is_set(&error);
          tmp_if_expr_6 = return_value_dbus_error_is_set_5 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
          r=avahi_client_set_errno(avahi_entry_group_add_service_subtype__1__client, -22);

        else
        {
          return_value_dbus_message_get_args_7=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args_7 == 0u)
            tmp_if_expr_9 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_8=dbus_error_is_set(&error);
            tmp_if_expr_9 = return_value_dbus_error_is_set_8 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_9)
            r=avahi_client_set_errno(avahi_entry_group_add_service_subtype__1__client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_10;
    return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_10 == 0u))
    {
      r=avahi_client_set_dbus_error(avahi_entry_group_add_service_subtype__1__client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_commit
// file entrygroup.c line 253
signed int avahi_entry_group_commit(struct AvahiEntryGroup *group)
{
  signed int ret;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    ret=entry_group_simple_method_call(group, "Commit");
    if(!(ret >= 0))
      return ret;

    else
    {
      group->state_valid = 0;
      return ret;
    }
  }
}

// avahi_entry_group_free
// file publish.h line 60
signed int avahi_entry_group_free(struct AvahiEntryGroup *group)
{
  struct AvahiClient *avahi_entry_group_free__1__client = group->client;
  signed int r = 0;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  signed int return_value_avahi_client_is_connected_1;
  if(!(group->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(avahi_entry_group_free__1__client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      r=entry_group_simple_method_call(group, "Free");

  }

  do
  {
    struct AvahiEntryGroup **_head = &avahi_entry_group_free__1__client->groups;
    struct AvahiEntryGroup *_item = group;
    /* assertion _item */
    assert(_item != ((struct AvahiEntryGroup *)NULL));
    if(!(_item->groups_next == ((struct AvahiEntryGroup *)NULL)))
      _item->groups_next->groups_prev = _item->groups_prev;

    if(!(_item->groups_prev == ((struct AvahiEntryGroup *)NULL)))
      _item->groups_prev->groups_next = _item->groups_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->groups_next;
    }
    _item->groups_prev = (struct AvahiEntryGroup *)(void *)0;
    _item->groups_next = _item->groups_prev;
  }
  while((_Bool)0);
  avahi_free((void *)group->path);
  avahi_free((void *)group);
  return r;
}

// avahi_entry_group_get_client
// file entrygroup.c line 290
struct AvahiClient * avahi_entry_group_get_client(struct AvahiEntryGroup *group)
{
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  return group->client;
}

// avahi_entry_group_get_state
// file entrygroup.c line 281
signed int avahi_entry_group_get_state(struct AvahiEntryGroup *group)
{
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  if(!(group->state_valid == 0))
    return (signed int)group->state;

  else
  {
    signed int return_value_retrieve_state_1;
    return_value_retrieve_state_1=retrieve_state(group);
    return return_value_retrieve_state_1;
  }
}

// avahi_entry_group_is_empty
// file entrygroup.c line 296
signed int avahi_entry_group_is_empty(struct AvahiEntryGroup *group)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  signed int b;
  struct AvahiClient *avahi_entry_group_is_empty__1__client;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  avahi_entry_group_is_empty__1__client = group->client;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "IsEmpty");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(avahi_entry_group_is_empty__1__client, -24);

    else
    {
      reply=dbus_connection_send_with_reply_and_block(avahi_entry_group_is_empty__1__client->bus, message, -1, &error);
      if(reply == ((struct DBusMessage *)NULL))
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
        tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        r=avahi_client_set_errno(avahi_entry_group_is_empty__1__client, -22);

      else
      {
        return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)98, &b, (signed int)0);
        if(return_value_dbus_message_get_args_6 == 0u)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
          tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          r=avahi_client_set_errno(avahi_entry_group_is_empty__1__client, -22);

        else
        {
          dbus_message_unref(message);
          dbus_message_unref(reply);
          return (signed int)!(!(b != 0));
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_9;
    return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_9 == 0u))
    {
      r=avahi_client_set_dbus_error(avahi_entry_group_is_empty__1__client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_new
// file entrygroup.c line 101
struct AvahiEntryGroup * avahi_entry_group_new(struct AvahiClient *client, void (*callback)(struct AvahiEntryGroup *, enum anonymous_27, void *), void *userdata)
{
  struct AvahiEntryGroup *group = (struct AvahiEntryGroup *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int state;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  unsigned int return_value_dbus_message_get_args_5;
  _Bool tmp_if_expr_7;
  unsigned int return_value_dbus_error_is_set_6;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal_2=avahi_new_internal_link1((unsigned int)1, sizeof(struct AvahiEntryGroup) /*56ul*/ );
    group = (struct AvahiEntryGroup *)return_value_avahi_new_internal_2;
    if(group == ((struct AvahiEntryGroup *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      group->client = client;
      group->callback = callback;
      group->userdata = userdata;
      group->state_valid = 0;
      group->path = (char *)(void *)0;
      do
      {
        struct AvahiEntryGroup **_head = &client->groups;
        struct AvahiEntryGroup *_item = group;
        /* assertion _item */
        assert(_item != ((struct AvahiEntryGroup *)NULL));
        _item->groups_next = *_head;
        if(!(_item->groups_next == ((struct AvahiEntryGroup *)NULL)))
          _item->groups_next->groups_prev = _item;

        _item->groups_prev = (struct AvahiEntryGroup *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "EntryGroupNew");
      if(message == ((struct DBusMessage *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          avahi_client_set_errno(client, -22);

        else
        {
          return_value_dbus_message_get_args_5=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
          if(return_value_dbus_message_get_args_5 == 0u)
            tmp_if_expr_7 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
            tmp_if_expr_7 = return_value_dbus_error_is_set_6 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_7)
            avahi_client_set_errno(client, -22);

          else
          {
            group->path=avahi_strdup(path);
            if(group->path == ((char *)NULL))
              avahi_client_set_errno(client, -24);

            else
            {
              state=retrieve_state(group);
              if(!(state >= 0))
                avahi_client_set_errno(client, state);

              else
              {
                avahi_entry_group_set_state(group, (enum anonymous_27)state);
                dbus_message_unref(message);
                dbus_message_unref(reply);
                return group;
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_8;
  return_value_dbus_error_is_set_8=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_8 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(group == ((struct AvahiEntryGroup *)NULL)))
    avahi_entry_group_free(group);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiEntryGroup *)(void *)0;
}

// avahi_entry_group_reset
// file entrygroup.c line 267
signed int avahi_entry_group_reset(struct AvahiEntryGroup *group)
{
  signed int ret;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    ret=entry_group_simple_method_call(group, "Reset");
    if(!(ret >= 0))
      return ret;

    else
    {
      group->state_valid = 0;
      return ret;
    }
  }
}

// avahi_entry_group_set_state
// file internal.h line 157
void avahi_entry_group_set_state(struct AvahiEntryGroup *group, enum anonymous_27 state)
{
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  if(!(group->state_valid == 0))
  {
    if(group->state == state)
      goto __CPROVER_DUMP_L2;

  }

  group->state = state;
  group->state_valid = 1;
  if(!(group->callback == ((void (*)(struct AvahiEntryGroup *, enum anonymous_27, void *))NULL)))
    group->callback(group, state, group->userdata);


__CPROVER_DUMP_L2:
  ;
}

// avahi_entry_group_update_service_txt
// file entrygroup.c line 611
signed int avahi_entry_group_update_service_txt(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, const char *type, const char *domain, ...)
{
  void **va;
  signed int r;
  struct AvahiStringList *txt;
  va = (void **)&domain;
  txt=avahi_string_list_new_va(va);
  r=avahi_entry_group_update_service_txt_strlst(group, interface, protocol, flags, name, type, domain, txt);
  avahi_string_list_free(txt);
  va = ((void **)NULL);
  return r;
}

// avahi_entry_group_update_service_txt_strlst
// file entrygroup.c line 633
signed int avahi_entry_group_update_service_txt_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous flags, const char *name, const char *type, const char *domain, struct AvahiStringList *txt)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *avahi_entry_group_update_service_txt_strlst__1__client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  avahi_entry_group_update_service_txt_strlst__1__client = group->client;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  unsigned int return_value_dbus_message_append_args_4;
  _Bool tmp_if_expr_6;
  signed int return_value_append_string_list_5;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  unsigned int return_value_dbus_message_get_args_9;
  _Bool tmp_if_expr_11;
  unsigned int return_value_dbus_error_is_set_10;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "UpdateServiceTxt");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(avahi_entry_group_update_service_txt_strlst__1__client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args_4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)0);
      if(return_value_dbus_message_append_args_4 == 0u)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_append_string_list_5=append_string_list(message, txt);
        tmp_if_expr_6 = return_value_append_string_list_5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(avahi_entry_group_update_service_txt_strlst__1__client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
          tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          r=avahi_client_set_errno(avahi_entry_group_update_service_txt_strlst__1__client, -22);

        else
        {
          return_value_dbus_message_get_args_9=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args_9 == 0u)
            tmp_if_expr_11 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
            tmp_if_expr_11 = return_value_dbus_error_is_set_10 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_11)
            r=avahi_client_set_errno(avahi_entry_group_update_service_txt_strlst__1__client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_12;
    return_value_dbus_error_is_set_12=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_12 == 0u))
    {
      r=avahi_client_set_dbus_error(avahi_entry_group_update_service_txt_strlst__1__client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_error_dbus_to_number
// file ../avahi-common/dbus.h line 112
signed int avahi_error_dbus_to_number(const char *s)
{
  signed int e;
  struct error_map *m;
  /* assertion s */
  assert(s != ((const char *)NULL));
  e = -1;
  signed int return_value_strcmp_1;
  for( ; e >= -53; e = e - 1)
  {
    return_value_strcmp_1=strcmp(s, table[(signed long int)-e]);
    if(return_value_strcmp_1 == 0)
      return e;

  }
  m = error_map;
  signed int return_value_strcmp_2;
  for( ; !(m->dbus_error == ((const char *)NULL)); m = m + 1l)
  {
    return_value_strcmp_2=strcmp(m->dbus_error, s);
    if(return_value_strcmp_2 == 0)
      return m->avahi_error;

  }
  return -22;
}

// avahi_error_number_to_dbus
// file ../avahi-common/dbus.c line 133
const char * avahi_error_number_to_dbus(signed int error)
{
  /* assertion error > AVAHI_ERR_MAX */
  assert(error > -54);
  /* assertion error < 1 */
  assert(error < 1);
  return table[(signed long int)-error];
}

// avahi_escape_label
// file domain.c line 116
char * avahi_escape_label(const char *src, unsigned long int src_length, char **ret_name, unsigned long int *ret_size)
{
  char *r;
  /* assertion src */
  assert(src != ((const char *)NULL));
  /* assertion ret_name */
  assert(ret_name != ((char **)NULL));
  /* assertion *ret_name */
  assert(*ret_name != ((char *)NULL));
  /* assertion ret_size */
  assert(ret_size != ((unsigned long int *)NULL));
  /* assertion *ret_size > 0 */
  assert(*ret_size > (unsigned long int)0);
  r = *ret_name;
  _Bool tmp_if_expr_15;
  char *tmp_post_1;
  char *tmp_post_2;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_13;
  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_5;
  char *tmp_post_6;
  char *tmp_post_7;
  for( ; src_length >= 1ul; src = src + 1l)
  {
    if((signed int)*src == 46)
      tmp_if_expr_15 = (_Bool)1;

    else
      tmp_if_expr_15 = (signed int)*src == 92 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_15)
    {
      if(!(*ret_size >= 3ul))
        return (char *)(void *)0;

      tmp_post_1 = *ret_name;
      *ret_name = *ret_name + 1l;
      *tmp_post_1 = (char)92;
      tmp_post_2 = *ret_name;
      *ret_name = *ret_name + 1l;
      *tmp_post_2 = *src;
      *ret_size = *ret_size - (unsigned long int)2;
    }

    else
    {
      if((signed int)*src == 95)
        tmp_if_expr_8 = (_Bool)1;

      else
        tmp_if_expr_8 = (signed int)*src == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_8)
        tmp_if_expr_10 = (_Bool)1;

      else
      {
        if((signed int)*src >= 48)
          tmp_if_expr_9 = (signed int)*src <= 57 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_9 = (_Bool)0;
        tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_10)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        if((signed int)*src >= 97)
          tmp_if_expr_11 = (signed int)*src <= 122 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_11 = (_Bool)0;
        tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
        tmp_if_expr_14 = (_Bool)1;

      else
      {
        if((signed int)*src >= 65)
          tmp_if_expr_13 = (signed int)*src <= 90 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_13 = (_Bool)0;
        tmp_if_expr_14 = tmp_if_expr_13 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_14)
      {
        if(!(*ret_size >= 2ul))
          return (char *)(void *)0;

        tmp_post_3 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post_3 = *src;
        *ret_size = *ret_size - 1ul;
      }

      else
      {
        if(!(*ret_size >= 5ul))
          return (char *)(void *)0;

        tmp_post_4 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post_4 = (char)92;
        tmp_post_5 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post_5 = (char)(48 + (signed int)(char)((signed int)(unsigned char)*src / 100));
        tmp_post_6 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post_6 = (char)(48 + (signed int)(char)(((signed int)(unsigned char)*src / 10) % 10));
        tmp_post_7 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post_7 = (char)(48 + (signed int)(char)((signed int)(unsigned char)*src % 10));
        *ret_size = *ret_size - (unsigned long int)4;
      }
    }
    src_length = src_length - 1ul;
  }
  *(*ret_name) = (char)0;
  return r;
}

// avahi_free
// file ../avahi-common/malloc.h line 42
void avahi_free(void *p)
{
  if(!(p == NULL))
  {
    if(allocator == ((const struct AvahiAllocator *)NULL))
      free(p);

    else
    {
      /* assertion allocator->free */
      assert(allocator->free != ((void (*)(void *))NULL));
      allocator->free(p);
    }
  }

}

// avahi_get_type_from_subtype
// file domain.c line 306
const char * avahi_get_type_from_subtype(const char *t)
{
  char label[64l];
  const char *ret;
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  _Bool tmp_if_expr_2;
  if(return_value_strlen_1 >= 1014ul)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_10;
  signed int return_value_strcasecmp_12;
  if(tmp_if_expr_2)
    return (const char *)(void *)0;

  else
  {
    char *return_value_avahi_unescape_label_3;
    return_value_avahi_unescape_label_3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label_3 == ((char *)NULL))
      return (const char *)(void *)0;

    else
    {
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(label);
      if(!(return_value_strlen_4 >= 3ul))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        return (const char *)(void *)0;

      else
        if(*t == 0)
          return (const char *)(void *)0;

        else
        {
          char *return_value_avahi_unescape_label_6;
          return_value_avahi_unescape_label_6=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
          if(return_value_avahi_unescape_label_6 == ((char *)NULL))
            return (const char *)(void *)0;

          else
          {
            signed int return_value_strcasecmp_7;
            return_value_strcasecmp_7=strcasecmp(label, "_sub");
            if(!(return_value_strcasecmp_7 == 0))
              return (const char *)(void *)0;

            else
              if(*t == 0)
                return (const char *)(void *)0;

              else
              {
                ret = t;
                char *return_value_avahi_unescape_label_8;
                return_value_avahi_unescape_label_8=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
                if(return_value_avahi_unescape_label_8 == ((char *)NULL))
                  return (const char *)(void *)0;

                else
                {
                  unsigned long int return_value_strlen_9;
                  return_value_strlen_9=strlen(label);
                  if(!(return_value_strlen_9 >= 3ul))
                    tmp_if_expr_10 = (_Bool)1;

                  else
                    tmp_if_expr_10 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_10)
                    return (const char *)(void *)0;

                  else
                    if(*t == 0)
                      return (const char *)(void *)0;

                    else
                    {
                      char *return_value_avahi_unescape_label_11;
                      return_value_avahi_unescape_label_11=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
                      if(return_value_avahi_unescape_label_11 == ((char *)NULL))
                        return (const char *)(void *)0;

                      else
                      {
                        signed int return_value_strcasecmp_13;
                        return_value_strcasecmp_13=strcasecmp(label, "_tcp");
                        if(!(return_value_strcasecmp_13 == 0))
                        {
                          return_value_strcasecmp_12=strcasecmp(label, "_udp");
                          if(return_value_strcasecmp_12 == 0)
                            goto __CPROVER_DUMP_L18;

                          return (const char *)(void *)0;
                        }

                        else
                        {

                        __CPROVER_DUMP_L18:
                          ;
                          if(!(*t == 0))
                            return (const char *)(void *)0;

                          else
                            return ret;
                        }
                      }
                    }
                }
              }
          }
        }
    }
  }
}

// avahi_host_name_resolver_event
// file internal.h line 165
enum anonymous_28 avahi_host_name_resolver_event(struct AvahiClient *client, enum anonymous_6 event, struct DBusMessage *message)
{
  struct AvahiHostNameResolver *r = (struct AvahiHostNameResolver *)(void *)0;
  struct DBusError error;
  const char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  signed int interface;
  signed int protocol;
  signed int aprotocol;
  unsigned int flags;
  char *name;
  char *address;
  struct AvahiAddress a;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  struct AvahiAddress *return_value_avahi_address_parse_5;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  signed int return_value_avahi_error_dbus_to_number_9;
  if(!(path == ((const char *)NULL)))
  {
    r = client->host_name_resolvers;
    for( ; !(r == ((struct AvahiHostNameResolver *)NULL)); r = r->host_name_resolvers_next)
    {
      return_value_strcmp_1=strcmp(r->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(r == ((struct AvahiHostNameResolver *)NULL))
      goto fail;

    switch((signed int)event)
    {
      case AVAHI_RESOLVER_FOUND:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)105, &aprotocol, (signed int)115, &address, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        /* assertion address */
        assert(address != ((char *)NULL));
        return_value_avahi_address_parse_5=avahi_address_parse(address, (signed int)aprotocol, &a);
        if(return_value_avahi_address_parse_5 == ((struct AvahiAddress *)NULL))
        {
          fprintf(stderr, "Failed to parse address\n");
          goto fail;
        }

        r->callback(r, (signed int)interface, (signed int)protocol, (enum anonymous_6)AVAHI_RESOLVER_FOUND, name, &a, (enum anonymous_3)flags, r->userdata);
      }
      case AVAHI_RESOLVER_FAILURE:
      {
        return_value_dbus_message_get_args_6=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_6 == 0u)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
          tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_9=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(r->client, return_value_avahi_error_dbus_to_number_9);
        r->callback(r, r->interface, r->protocol, event, r->host_name, (const struct AvahiAddress *)(void *)0, (enum anonymous_3)0, r->userdata);
      }
    }
    return (enum anonymous_28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous_28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_host_name_resolver_free
// file lookup.h line 239
signed int avahi_host_name_resolver_free(struct AvahiHostNameResolver *r)
{
  signed int ret = 0;
  struct AvahiClient *avahi_host_name_resolver_free__1__client;
  /* assertion r */
  assert(r != ((struct AvahiHostNameResolver *)NULL));
  avahi_host_name_resolver_free__1__client = r->client;
  signed int return_value_avahi_client_is_connected_1;
  if(!(r->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(avahi_host_name_resolver_free__1__client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      ret=avahi_client_simple_method_call(avahi_host_name_resolver_free__1__client, r->path, "org.freedesktop.Avahi.HostNameResolver", "Free");

  }

  do
  {
    struct AvahiHostNameResolver **_head = &avahi_host_name_resolver_free__1__client->host_name_resolvers;
    struct AvahiHostNameResolver *_item = r;
    /* assertion _item */
    assert(_item != ((struct AvahiHostNameResolver *)NULL));
    if(!(_item->host_name_resolvers_next == ((struct AvahiHostNameResolver *)NULL)))
      _item->host_name_resolvers_next->host_name_resolvers_prev = _item->host_name_resolvers_prev;

    if(!(_item->host_name_resolvers_prev == ((struct AvahiHostNameResolver *)NULL)))
      _item->host_name_resolvers_prev->host_name_resolvers_next = _item->host_name_resolvers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->host_name_resolvers_next;
    }
    _item->host_name_resolvers_prev = (struct AvahiHostNameResolver *)(void *)0;
    _item->host_name_resolvers_next = _item->host_name_resolvers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)r->path);
  avahi_free((void *)r->host_name);
  avahi_free((void *)r);
  return ret;
}

// avahi_host_name_resolver_get_client
// file resolver.c line 558
struct AvahiClient * avahi_host_name_resolver_get_client(struct AvahiHostNameResolver *r)
{
  /* assertion r */
  assert(r != ((struct AvahiHostNameResolver *)NULL));
  return r->client;
}

// avahi_host_name_resolver_new
// file resolver.c line 424
struct AvahiHostNameResolver * avahi_host_name_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, signed int aprotocol, enum anonymous_1 flags, void (*callback)(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous_6, const char *, const struct AvahiAddress *, enum anonymous_3, void *), void *userdata)
{
  struct DBusError error;
  struct AvahiHostNameResolver *r = (struct AvahiHostNameResolver *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int i_interface;
  signed int i_protocol;
  signed int i_aprotocol;
  unsigned int u_flags;
  char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal_2=avahi_new_internal_link3((unsigned int)1, sizeof(struct AvahiHostNameResolver) /*64ul*/ );
    r = (struct AvahiHostNameResolver *)return_value_avahi_new_internal_2;
    if(r == ((struct AvahiHostNameResolver *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      r->client = client;
      r->callback = callback;
      r->userdata = userdata;
      r->path = (char *)(void *)0;
      r->interface = interface;
      r->protocol = protocol;
      r->host_name = (char *)(void *)0;
      do
      {
        struct AvahiHostNameResolver **_head = &client->host_name_resolvers;
        struct AvahiHostNameResolver *_item = r;
        /* assertion _item */
        assert(_item != ((struct AvahiHostNameResolver *)NULL));
        _item->host_name_resolvers_next = *_head;
        if(!(_item->host_name_resolvers_next == ((struct AvahiHostNameResolver *)NULL)))
          _item->host_name_resolvers_next->host_name_resolvers_prev = _item;

        _item->host_name_resolvers_prev = (struct AvahiHostNameResolver *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      r->host_name=avahi_strdup(name);
      if(r->host_name == ((char *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "HostNameResolverNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          i_aprotocol = (signed int)aprotocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &name, (signed int)105, &i_aprotocol, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args_3 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr_5 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
              tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_5)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args_6 == 0u)
                tmp_if_expr_8 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
                tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr_8)
                avahi_client_set_errno(client, -22);

              else
              {
                r->path=avahi_strdup(path);
                if(r->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return r;
                }
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_9;
  return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(r == ((struct AvahiHostNameResolver *)NULL)))
    avahi_host_name_resolver_free(r);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiHostNameResolver *)(void *)0;
}

// avahi_init_i18n
// file ../avahi-common/i18n.h line 51
void avahi_init_i18n(void)
{
  static signed int done = 0;
  if(done == 0)
  {
    bindtextdomain("avahi", "/usr/share/locale");
    bind_textdomain_codeset("avahi", "UTF-8");
    done = 1;
  }

}

// avahi_is_valid_domain_name
// file domain.c line 369
signed int avahi_is_valid_domain_name(const char *t)
{
  signed int is_first = 1;
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  if(return_value_strlen_1 >= 1014ul)
    return 0;

  else
  {
    do
    {
      char label[64l];
      char *return_value_avahi_unescape_label_2;
      return_value_avahi_unescape_label_2=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
      if(return_value_avahi_unescape_label_2 == ((char *)NULL))
        return 0;

      if(!(is_first == 0))
      {
        if((signed int)label[0l] == 0)
        {
          if((signed int)*t == 0)
            return 1;

        }

      }

      is_first = 0;
      if((signed int)label[0l] == 0)
        return 0;

    }
    while(!(*t == 0));
    return 1;
  }
}

// avahi_is_valid_fqdn
// file domain.c line 575
signed int avahi_is_valid_fqdn(const char *t)
{
  char label[64l];
  char normalized[1014l];
  const char *k = t;
  struct AvahiAddress a;
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  if(return_value_strlen_1 >= 1014ul)
    return 0;

  else
  {
    signed int return_value_avahi_is_valid_domain_name_2;
    return_value_avahi_is_valid_domain_name_2=avahi_is_valid_domain_name(t);
    if(return_value_avahi_is_valid_domain_name_2 == 0)
      return 0;

    else
    {
      char *return_value_avahi_unescape_label_3;
      return_value_avahi_unescape_label_3=avahi_unescape_label(&k, label, sizeof(char [64l]) /*64ul*/ );
      if(return_value_avahi_unescape_label_3 == ((char *)NULL))
        return 0;

      else
        if(k == ((const char *)NULL) || (signed int)label[0l] == 0)
          return 0;

        else
        {
          char *return_value_avahi_unescape_label_4;
          return_value_avahi_unescape_label_4=avahi_unescape_label(&k, label, sizeof(char [64l]) /*64ul*/ );
          if(return_value_avahi_unescape_label_4 == ((char *)NULL))
            return 0;

          else
            if(k == ((const char *)NULL) || (signed int)label[0l] == 0)
              return 0;

            else
            {
              char *return_value_avahi_normalize_name_5;
              return_value_avahi_normalize_name_5=avahi_normalize_name(t, normalized, sizeof(char [1014l]) /*1014ul*/ );
              if(return_value_avahi_normalize_name_5 == ((char *)NULL))
                return 0;

              else
              {
                struct AvahiAddress *return_value_avahi_address_parse_6;
                return_value_avahi_address_parse_6=avahi_address_parse(normalized, -1, &a);
                if(!(return_value_avahi_address_parse_6 == ((struct AvahiAddress *)NULL)))
                  return 0;

                else
                  return 1;
              }
            }
        }
    }
  }
}

// avahi_is_valid_host_name
// file domain.h line 103
signed int avahi_is_valid_host_name(const char *t)
{
  char label[64l];
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  _Bool tmp_if_expr_2;
  if(return_value_strlen_1 >= 1014ul)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    return 0;

  else
  {
    char *return_value_avahi_unescape_label_3;
    return_value_avahi_unescape_label_3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label_3 == ((char *)NULL))
      return 0;

    else
    {
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(label);
      if(!(return_value_strlen_4 >= 1ul))
        return 0;

      else
        if(!(*t == 0))
          return 0;

        else
          return 1;
    }
  }
}

// avahi_is_valid_service_name
// file domain.h line 100
signed int avahi_is_valid_service_name(const char *t)
{
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  _Bool tmp_if_expr_2;
  if(return_value_strlen_1 >= 64ul)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    return 0;

  else
    return 1;
}

// avahi_is_valid_service_subtype
// file domain.c line 363
signed int avahi_is_valid_service_subtype(const char *t)
{
  /* assertion t */
  assert(t != ((const char *)NULL));
  const char *return_value_avahi_get_type_from_subtype_1;
  return_value_avahi_get_type_from_subtype_1=avahi_get_type_from_subtype(t);
  return (signed int)!(!(return_value_avahi_get_type_from_subtype_1 != ((const char *)NULL)));
}

// avahi_is_valid_service_type_generic
// file domain.c line 254
signed int avahi_is_valid_service_type_generic(const char *t)
{
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  _Bool tmp_if_expr_2;
  if(return_value_strlen_1 >= 1014ul)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_2)
    return 0;

  else
  {
    do
    {
      char label[64l];
      char *return_value_avahi_unescape_label_3;
      return_value_avahi_unescape_label_3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
      if(return_value_avahi_unescape_label_3 == ((char *)NULL))
        return 0;

      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(label);
      if(!(return_value_strlen_4 >= 3ul))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        return 0;

    }
    while(!(*t == 0));
    return 1;
  }
}

// avahi_is_valid_service_type_strict
// file domain.c line 274
signed int avahi_is_valid_service_type_strict(const char *t)
{
  char label[64l];
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  _Bool tmp_if_expr_2;
  if(return_value_strlen_1 >= 1014ul)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  signed int return_value_strcasecmp_7;
  if(tmp_if_expr_2)
    return 0;

  else
  {
    char *return_value_avahi_unescape_label_3;
    return_value_avahi_unescape_label_3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label_3 == ((char *)NULL))
      return 0;

    else
    {
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(label);
      if(!(return_value_strlen_4 >= 3ul))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        return 0;

      else
        if(*t == 0)
          return 0;

        else
        {
          char *return_value_avahi_unescape_label_6;
          return_value_avahi_unescape_label_6=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
          if(return_value_avahi_unescape_label_6 == ((char *)NULL))
            return 0;

          else
          {
            signed int return_value_strcasecmp_8;
            return_value_strcasecmp_8=strcasecmp(label, "_tcp");
            if(!(return_value_strcasecmp_8 == 0))
            {
              return_value_strcasecmp_7=strcasecmp(label, "_udp");
              if(return_value_strcasecmp_7 == 0)
                goto __CPROVER_DUMP_L10;

              return 0;
            }

            else
            {

            __CPROVER_DUMP_L10:
              ;
              if(!(*t == 0))
                return 0;

              else
                return 1;
            }
          }
        }
    }
  }
}

// avahi_malloc
// file ../avahi-common/malloc.h line 36
void * avahi_malloc(unsigned long int size)
{
  void *return_value_xmalloc_1;
  if(!(size >= 1ul))
    return (void *)0;

  else
    if(allocator == ((const struct AvahiAllocator *)NULL))
    {
      return_value_xmalloc_1=xmalloc(size);
      return return_value_xmalloc_1;
    }

    else
    {
      /* assertion allocator->malloc */
      assert(allocator->malloc != ((void * (*)(unsigned long int))NULL));
      void *return_value;
      return_value=allocator->malloc(size);
      return return_value;
    }
}

// avahi_malloc0
// file malloc.c line 113
void * avahi_malloc0(unsigned long int size)
{
  void *p;
  void *return_value_xcalloc_1;
  void *return_value;
  if(!(size >= 1ul))
    return (void *)0;

  else
    if(allocator == ((const struct AvahiAllocator *)NULL))
    {
      return_value_xcalloc_1=xcalloc((unsigned long int)1, size);
      return return_value_xcalloc_1;
    }

    else
      if(!(allocator->calloc == ((void * (*)(unsigned long int, unsigned long int))NULL)))
      {
        return_value=allocator->calloc((unsigned long int)1, size);
        return return_value;
      }

      else
      {
        /* assertion allocator->malloc */
        assert(allocator->malloc != ((void * (*)(unsigned long int))NULL));
        p=allocator->malloc(size);
        if(!(p == NULL))
          memset(p, 0, size);

        return p;
      }
}

// avahi_memdup
// file malloc.c line 248
void * avahi_memdup(const void *s, unsigned long int l)
{
  void *p;
  /* assertion s */
  assert(s != NULL);
  p=avahi_malloc(l);
  if(p == NULL)
    return (void *)0;

  else
  {
    memcpy(p, s, l);
    return p;
  }
}

// avahi_new_internal
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal(unsigned int n, unsigned long int k)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n < (unsigned long int)0x7fffffff / k);
  void *return_value_avahi_malloc_1;
  return_value_avahi_malloc_1=avahi_malloc((unsigned long int)n * k);
  return return_value_avahi_malloc_1;
}

// avahi_new_internal_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link1(unsigned int n_link1, unsigned long int k_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link1 < (unsigned long int)0x7fffffff / k_link1);
  void *return_value_avahi_malloc_1_link1;
  return_value_avahi_malloc_1_link1=avahi_malloc((unsigned long int)n_link1 * k_link1);
  return return_value_avahi_malloc_1_link1;
}

// avahi_new_internal_link1_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link1(unsigned int n_link1_link1, unsigned long int k_link1_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link1_link1 < (unsigned long int)0x7fffffff / k_link1_link1);
  void *return_value_avahi_malloc_1_link1_link1;
  return_value_avahi_malloc_1_link1_link1=avahi_malloc((unsigned long int)n_link1_link1 * k_link1_link1);
  return return_value_avahi_malloc_1_link1_link1;
}

// avahi_new_internal_link1_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link2(unsigned int n_link1_link2, unsigned long int k_link1_link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link1_link2 < (unsigned long int)0x7fffffff / k_link1_link2);
  void *return_value_avahi_malloc_1_link1_link2;
  return_value_avahi_malloc_1_link1_link2=avahi_malloc((unsigned long int)n_link1_link2 * k_link1_link2);
  return return_value_avahi_malloc_1_link1_link2;
}

// avahi_new_internal_link2
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link2(unsigned int n_link2, unsigned long int k_link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link2 < (unsigned long int)0x7fffffff / k_link2);
  void *return_value_avahi_malloc_1_link2;
  return_value_avahi_malloc_1_link2=avahi_malloc((unsigned long int)n_link2 * k_link2);
  return return_value_avahi_malloc_1_link2;
}

// avahi_new_internal_link2_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link1(unsigned int n_link2_link1, unsigned long int k_link2_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link2_link1 < (unsigned long int)0x7fffffff / k_link2_link1);
  void *return_value_avahi_malloc_1_link2_link1;
  return_value_avahi_malloc_1_link2_link1=avahi_malloc((unsigned long int)n_link2_link1 * k_link2_link1);
  return return_value_avahi_malloc_1_link2_link1;
}

// avahi_new_internal_link2_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link2(unsigned int n_link2_link2, unsigned long int k_link2_link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link2_link2 < (unsigned long int)0x7fffffff / k_link2_link2);
  void *return_value_avahi_malloc_1_link2_link2;
  return_value_avahi_malloc_1_link2_link2=avahi_malloc((unsigned long int)n_link2_link2 * k_link2_link2);
  return return_value_avahi_malloc_1_link2_link2;
}

// avahi_new_internal_link3
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link3(unsigned int n_link3, unsigned long int k_link3)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link3 < (unsigned long int)0x7fffffff / k_link3);
  void *return_value_avahi_malloc_1_link3;
  return_value_avahi_malloc_1_link3=avahi_malloc((unsigned long int)n_link3 * k_link3);
  return return_value_avahi_malloc_1_link3;
}

// avahi_new_internal_link3_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link1(unsigned int n_link3_link1, unsigned long int k_link3_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link3_link1 < (unsigned long int)0x7fffffff / k_link3_link1);
  void *return_value_avahi_malloc_1_link3_link1;
  return_value_avahi_malloc_1_link3_link1=avahi_malloc((unsigned long int)n_link3_link1 * k_link3_link1);
  return return_value_avahi_malloc_1_link3_link1;
}

// avahi_new_internal_link3_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link2(unsigned int n_link3_link2, unsigned long int k_link3_link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link3_link2 < (unsigned long int)0x7fffffff / k_link3_link2);
  void *return_value_avahi_malloc_1_link3_link2;
  return_value_avahi_malloc_1_link3_link2=avahi_malloc((unsigned long int)n_link3_link2 * k_link3_link2);
  return return_value_avahi_malloc_1_link3_link2;
}

// avahi_new_internal_link4
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link4(unsigned int n_link4, unsigned long int k_link4)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link4 < (unsigned long int)0x7fffffff / k_link4);
  void *return_value_avahi_malloc_1_link4;
  return_value_avahi_malloc_1_link4=avahi_malloc((unsigned long int)n_link4 * k_link4);
  return return_value_avahi_malloc_1_link4;
}

// avahi_new_internal_link4_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link1(unsigned int n_link4_link1, unsigned long int k_link4_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link4_link1 < (unsigned long int)0x7fffffff / k_link4_link1);
  void *return_value_avahi_malloc_1_link4_link1;
  return_value_avahi_malloc_1_link4_link1=avahi_malloc((unsigned long int)n_link4_link1 * k_link4_link1);
  return return_value_avahi_malloc_1_link4_link1;
}

// avahi_new_internal_link4_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link2(unsigned int n_link4_link2, unsigned long int k_link4_link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link4_link2 < (unsigned long int)0x7fffffff / k_link4_link2);
  void *return_value_avahi_malloc_1_link4_link2;
  return_value_avahi_malloc_1_link4_link2=avahi_malloc((unsigned long int)n_link4_link2 * k_link4_link2);
  return return_value_avahi_malloc_1_link4_link2;
}

// avahi_new_internal_link5
// file malloc.h line 48
static inline void * avahi_new_internal_link5(unsigned int n_link5, unsigned long int k_link5)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link5 < (unsigned long int)0x7fffffff / k_link5);
  void *return_value_avahi_malloc_1_link5;
  return_value_avahi_malloc_1_link5=avahi_malloc((unsigned long int)n_link5 * k_link5);
  return return_value_avahi_malloc_1_link5;
}

// avahi_new_internal_link6
// file malloc.h line 48
static inline void * avahi_new_internal_link6(unsigned int n_link6, unsigned long int k_link6)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link6 < (unsigned long int)0x7fffffff / k_link6);
  void *return_value_avahi_malloc_1_link6;
  return_value_avahi_malloc_1_link6=avahi_malloc((unsigned long int)n_link6 * k_link6);
  return return_value_avahi_malloc_1_link6;
}

// avahi_normalize_name
// file ../avahi-common/domain.h line 50
char * avahi_normalize_name(const char *s, char *ret_s, unsigned long int size)
{
  signed int empty = 1;
  char *r;
  /* assertion s */
  assert(s != ((const char *)NULL));
  /* assertion ret_s */
  assert(ret_s != ((char *)NULL));
  /* assertion size > 0 */
  assert(size > (unsigned long int)0);
  r = ret_s;
  *ret_s = (char)0;
  char *tmp_post_2;
  while(!(*s == 0))
  {
    char label[64l];
    char *return_value_avahi_unescape_label_1;
    return_value_avahi_unescape_label_1=avahi_unescape_label(&s, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label_1 == ((char *)NULL))
      return (char *)(void *)0;

    if((signed int)label[0l] == 0)
    {
      if((signed int)*s == 0)
      {
        if(!(empty == 0))
          return ret_s;

      }

      return (char *)(void *)0;
    }

    if(empty == 0)
    {
      if(!(size >= 1ul))
        return (char *)(void *)0;

      tmp_post_2 = r;
      r = r + 1l;
      *tmp_post_2 = (char)46;
      size = size - 1ul;
    }

    else
      empty = 0;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(label);
    avahi_escape_label(label, return_value_strlen_3, &r, &size);
  }
  return ret_s;
}

// avahi_normalize_name_strdup
// file domain.c line 219
char * avahi_normalize_name_strdup(const char *s)
{
  char t[1014l];
  /* assertion s */
  assert(s != ((const char *)NULL));
  char *return_value_avahi_normalize_name_1;
  return_value_avahi_normalize_name_1=avahi_normalize_name(s, t, sizeof(char [1014l]) /*1014ul*/ );
  if(return_value_avahi_normalize_name_1 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *return_value_avahi_strdup_2;
    return_value_avahi_strdup_2=avahi_strdup(t);
    return return_value_avahi_strdup_2;
  }
}

// avahi_nss_support
// file check-nss.c line 31
signed int avahi_nss_support(void)
{
  signed int b = 0;
  static const char * const libs[4l] = { "libnss_mdns.so.2", "libnss_mdns4.so.2", "libnss_mdns6.so.2", (const char *)(void *)0 };
  const char * const *l = libs;
  for( ; !(*l == ((const char *)NULL)); l = l + 1l)
  {
    void *dl;
    dl=dlopen(*l, 0x00001);
    if(!(dl == NULL))
    {
      b = 1;
      dlclose(dl);
      break;
    }

  }
  return b;
}

// avahi_proto_to_af
// file address.c line 127
signed int avahi_proto_to_af(signed int proto)
{
  if(proto == 0)
    return 2;

  else
    if(proto == 1)
      return 10;

    else
    {
      /* assertion proto == AVAHI_PROTO_UNSPEC */
      assert(proto == -1);
      return 0;
    }
}

// avahi_proto_to_string
// file address.c line 147
const char * avahi_proto_to_string(signed int proto)
{
  if(proto == 0)
    return "IPv4";

  else
    if(proto == 1)
      return "IPv6";

    else
    {
      /* assertion proto == AVAHI_PROTO_UNSPEC */
      assert(proto == -1);
      return "UNSPEC";
    }
}

// avahi_realloc
// file malloc.c line 146
void * avahi_realloc(void *p, unsigned long int size)
{
  void *return_value_xrealloc_1;
  if(size == 0ul)
  {
    avahi_free(p);
    return (void *)0;
  }

  else
    if(allocator == ((const struct AvahiAllocator *)NULL))
    {
      return_value_xrealloc_1=xrealloc(p, size);
      return return_value_xrealloc_1;
    }

    else
    {
      /* assertion allocator->realloc */
      assert(allocator->realloc != ((void * (*)(void *, unsigned long int))NULL));
      void *return_value;
      return_value=allocator->realloc(p, size);
      return return_value;
    }
}

// avahi_record_browser_event
// file internal.h line 162
enum anonymous_28 avahi_record_browser_event(struct AvahiClient *client, enum anonymous_2 event, struct DBusMessage *message)
{
  struct AvahiRecordBrowser *b = (struct AvahiRecordBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *name;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  unsigned short int clazz;
  unsigned short int type;
  void *rdata = (void *)0;
  signed int rdata_size = 0;
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  signed int j;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  signed int return_value_dbus_message_iter_get_arg_type_5;
  _Bool tmp_if_expr_7;
  signed int return_value_dbus_message_iter_get_element_type_6;
  signed int return_value_dbus_message_iter_get_arg_type_8;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_9;
  _Bool tmp_if_expr_11;
  unsigned int return_value_dbus_error_is_set_10;
  signed int return_value_avahi_error_dbus_to_number_12;
  if(!(path == ((const char *)NULL)))
  {
    b = client->record_browsers;
    for( ; !(b == ((struct AvahiRecordBrowser *)NULL)); b = b->record_browsers_next)
    {
      return_value_strcmp_1=strcmp(b->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(b == ((struct AvahiRecordBrowser *)NULL))
      goto fail;

    interface = b->interface;
    protocol = b->protocol;
    clazz = b->clazz;
    type = b->type;
    name = b->name;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)113, &clazz, (signed int)113, &type, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        dbus_message_iter_init(message, &iter);
        j = 0;
        for( ; !(j >= 5); j = j + 1)
          dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type_5=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type_5 == 97))
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_dbus_message_iter_get_element_type_6=dbus_message_iter_get_element_type(&iter);
          tmp_if_expr_7 = return_value_dbus_message_iter_get_element_type_6 != (signed int)121 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
          goto fail;

        dbus_message_iter_recurse(&iter, &sub);
        dbus_message_iter_get_fixed_array(&sub, (void *)&rdata, &rdata_size);
        dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type_8=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type_8 == 117))
          goto fail;

        dbus_message_iter_get_basic(&iter, (void *)&flags);
        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args_9=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_9 == 0u)
          tmp_if_expr_11 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
          tmp_if_expr_11 = return_value_dbus_error_is_set_10 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_11)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_12=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(b->client, return_value_avahi_error_dbus_to_number_12);
      }
    }
    b->callback(b, (signed int)interface, (signed int)protocol, event, name, clazz, type, rdata, (unsigned long int)rdata_size, (enum anonymous_3)flags, b->userdata);
    return (enum anonymous_28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous_28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_record_browser_free
// file lookup.h line 308
signed int avahi_record_browser_free(struct AvahiRecordBrowser *b)
{
  struct AvahiClient *avahi_record_browser_free__1__client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiRecordBrowser *)NULL));
  avahi_record_browser_free__1__client = b->client;
  signed int return_value_avahi_client_is_connected_1;
  if(!(b->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(b->client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      r=avahi_client_simple_method_call(avahi_record_browser_free__1__client, b->path, "org.freedesktop.Avahi.RecordBrowser", "Free");

  }

  do
  {
    struct AvahiRecordBrowser **_head = &b->client->record_browsers;
    struct AvahiRecordBrowser *_item = b;
    /* assertion _item */
    assert(_item != ((struct AvahiRecordBrowser *)NULL));
    if(!(_item->record_browsers_next == ((struct AvahiRecordBrowser *)NULL)))
      _item->record_browsers_next->record_browsers_prev = _item->record_browsers_prev;

    if(!(_item->record_browsers_prev == ((struct AvahiRecordBrowser *)NULL)))
      _item->record_browsers_prev->record_browsers_next = _item->record_browsers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->record_browsers_next;
    }
    _item->record_browsers_prev = (struct AvahiRecordBrowser *)(void *)0;
    _item->record_browsers_next = _item->record_browsers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)b->path);
  avahi_free((void *)b->name);
  avahi_free((void *)b);
  return r;
}

// avahi_record_browser_get_client
// file browser.c line 903
struct AvahiClient * avahi_record_browser_get_client(struct AvahiRecordBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiRecordBrowser *)NULL));
  return b->client;
}

// avahi_record_browser_new
// file browser.c line 786
struct AvahiRecordBrowser * avahi_record_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, unsigned short int clazz, unsigned short int type, enum anonymous_1 flags, void (*callback)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous_2, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous_3, void *), void *userdata)
{
  struct AvahiRecordBrowser *b = (struct AvahiRecordBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_protocol;
  signed int i_interface;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous_2, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous_3, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal_2=avahi_new_internal_link2((unsigned int)1, sizeof(struct AvahiRecordBrowser) /*72ul*/ );
    b = (struct AvahiRecordBrowser *)return_value_avahi_new_internal_2;
    if(b == ((struct AvahiRecordBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      b->client = client;
      b->callback = callback;
      b->userdata = userdata;
      b->path = (char *)(void *)0;
      b->name = (char *)(void *)0;
      b->clazz = clazz;
      b->type = type;
      b->interface = interface;
      b->protocol = protocol;
      do
      {
        struct AvahiRecordBrowser **_head = &client->record_browsers;
        struct AvahiRecordBrowser *_item = b;
        /* assertion _item */
        assert(_item != ((struct AvahiRecordBrowser *)NULL));
        _item->record_browsers_next = *_head;
        if(!(_item->record_browsers_next == ((struct AvahiRecordBrowser *)NULL)))
          _item->record_browsers_next->record_browsers_prev = _item;

        _item->record_browsers_prev = (struct AvahiRecordBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      b->name=avahi_strdup(name);
      if(b->name == ((char *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "RecordBrowserNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &name, (signed int)113, &clazz, (signed int)113, &type, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args_3 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr_5 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
              tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_5)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args_6 == 0u)
                tmp_if_expr_8 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
                tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr_8)
                avahi_client_set_errno(client, -22);

              else
              {
                b->path=avahi_strdup(path);
                if(b->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return b;
                }
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_9;
  return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(b == ((struct AvahiRecordBrowser *)NULL)))
    avahi_record_browser_free(b);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiRecordBrowser *)(void *)0;
}

// avahi_reverse_lookup_name
// file address.c line 67
char * avahi_reverse_lookup_name(const struct AvahiAddress *a, char *ret_s, unsigned long int length)
{
  /* assertion ret_s */
  assert(ret_s != ((char *)NULL));
  /* assertion length > 0 */
  assert(length > (unsigned long int)0);
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  if(a->proto == 0)
  {
    unsigned int n;
    n=ntohl(a->data.ipv4.address);
    snprintf(ret_s, length, "%u.%u.%u.%u.in-addr.arpa", n & (unsigned int)0xFF, n >> 8 & (unsigned int)0xFF, n >> 16 & (unsigned int)0xFF, n >> 24);
  }

  else
  {
    /* assertion a->proto == AVAHI_PROTO_INET6 */
    assert(a->proto == 1);
    snprintf(ret_s, length, "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.ip6.arpa", (signed int)a->data.ipv6.address[(signed long int)15] & 0xF, (signed int)a->data.ipv6.address[(signed long int)15] >> 4, (signed int)a->data.ipv6.address[(signed long int)14] & 0xF, (signed int)a->data.ipv6.address[(signed long int)14] >> 4, (signed int)a->data.ipv6.address[(signed long int)13] & 0xF, (signed int)a->data.ipv6.address[(signed long int)13] >> 4, (signed int)a->data.ipv6.address[(signed long int)12] & 0xF, (signed int)a->data.ipv6.address[(signed long int)12] >> 4, (signed int)a->data.ipv6.address[(signed long int)11] & 0xF, (signed int)a->data.ipv6.address[(signed long int)11] >> 4, (signed int)a->data.ipv6.address[(signed long int)10] & 0xF, (signed int)a->data.ipv6.address[(signed long int)10] >> 4, (signed int)a->data.ipv6.address[(signed long int)9] & 0xF, (signed int)a->data.ipv6.address[(signed long int)9] >> 4, (signed int)a->data.ipv6.address[(signed long int)8] & 0xF, (signed int)a->data.ipv6.address[(signed long int)8] >> 4, (signed int)a->data.ipv6.address[(signed long int)7] & 0xF, (signed int)a->data.ipv6.address[(signed long int)7] >> 4, (signed int)a->data.ipv6.address[(signed long int)6] & 0xF, (signed int)a->data.ipv6.address[(signed long int)6] >> 4, (signed int)a->data.ipv6.address[(signed long int)5] & 0xF, (signed int)a->data.ipv6.address[(signed long int)5] >> 4, (signed int)a->data.ipv6.address[(signed long int)4] & 0xF, (signed int)a->data.ipv6.address[(signed long int)4] >> 4, (signed int)a->data.ipv6.address[(signed long int)3] & 0xF, (signed int)a->data.ipv6.address[(signed long int)3] >> 4, (signed int)a->data.ipv6.address[(signed long int)2] & 0xF, (signed int)a->data.ipv6.address[(signed long int)2] >> 4, (signed int)a->data.ipv6.address[(signed long int)1] & 0xF, (signed int)a->data.ipv6.address[(signed long int)1] >> 4, (signed int)a->data.ipv6.address[(signed long int)0] & 0xF, (signed int)a->data.ipv6.address[(signed long int)0] >> 4);
  }
  return ret_s;
}

// avahi_rlist_prepend
// file rlist.c line 29
struct AvahiRList * avahi_rlist_prepend(struct AvahiRList *r, void *data)
{
  struct AvahiRList *n;
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link4_link1((unsigned int)1, sizeof(struct AvahiRList) /*24ul*/ );
  n = (struct AvahiRList *)return_value_avahi_new_internal_1;
  if(n == ((struct AvahiRList *)NULL))
    return (struct AvahiRList *)(void *)0;

  else
  {
    n->data = data;
    do
    {
      struct AvahiRList **_head = &r;
      struct AvahiRList *_item = n;
      /* assertion _item */
      assert(_item != ((struct AvahiRList *)NULL));
      _item->rlist_next = *_head;
      if(!(_item->rlist_next == ((struct AvahiRList *)NULL)))
        _item->rlist_next->rlist_prev = _item;

      _item->rlist_prev = (struct AvahiRList *)(void *)0;
      *_head = _item;
    }
    while((_Bool)0);
    return r;
  }
}

// avahi_rlist_remove
// file rlist.c line 41
struct AvahiRList * avahi_rlist_remove(struct AvahiRList *r, void *data)
{
  struct AvahiRList *n = r;
  for( ; !(n == ((struct AvahiRList *)NULL)); n = n->rlist_next)
    if(n->data == data)
    {
      do
      {
        struct AvahiRList **_head = &r;
        struct AvahiRList *_item = n;
        /* assertion _item */
        assert(_item != ((struct AvahiRList *)NULL));
        if(!(_item->rlist_next == ((struct AvahiRList *)NULL)))
          _item->rlist_next->rlist_prev = _item->rlist_prev;

        if(!(_item->rlist_prev == ((struct AvahiRList *)NULL)))
          _item->rlist_prev->rlist_next = _item->rlist_next;

        else
        {
          /* assertion *_head == _item */
          assert(*_head == _item);
          *_head = _item->rlist_next;
        }
        _item->rlist_prev = (struct AvahiRList *)(void *)0;
        _item->rlist_next = _item->rlist_prev;
      }
      while((_Bool)0);
      avahi_free((void *)n);
      break;
    }

  return r;
}

// avahi_rlist_remove_by_link
// file rlist.c line 55
struct AvahiRList * avahi_rlist_remove_by_link(struct AvahiRList *r, struct AvahiRList *n)
{
  /* assertion n */
  assert(n != ((struct AvahiRList *)NULL));
  do
  {
    struct AvahiRList **_head = &r;
    struct AvahiRList *_item = n;
    /* assertion _item */
    assert(_item != ((struct AvahiRList *)NULL));
    if(!(_item->rlist_next == ((struct AvahiRList *)NULL)))
      _item->rlist_next->rlist_prev = _item->rlist_prev;

    if(!(_item->rlist_prev == ((struct AvahiRList *)NULL)))
      _item->rlist_prev->rlist_next = _item->rlist_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->rlist_next;
    }
    _item->rlist_prev = (struct AvahiRList *)(void *)0;
    _item->rlist_next = _item->rlist_prev;
  }
  while((_Bool)0);
  avahi_free((void *)n);
  return r;
}

// avahi_service_browser_event
// file internal.h line 161
enum anonymous_28 avahi_service_browser_event(struct AvahiClient *client, enum anonymous_2 event, struct DBusMessage *message)
{
  struct AvahiServiceBrowser *b = (struct AvahiServiceBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *name = (char *)(void *)0;
  char *type;
  char *domain;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_5;
  _Bool tmp_if_expr_7;
  unsigned int return_value_dbus_error_is_set_6;
  signed int return_value_avahi_error_dbus_to_number_8;
  if(!(path == ((const char *)NULL)))
  {
    b = client->service_browsers;
    for( ; !(b == ((struct AvahiServiceBrowser *)NULL)); b = b->service_browsers_next)
    {
      return_value_strcmp_1=strcmp(b->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(b == ((struct AvahiServiceBrowser *)NULL))
      goto fail;

    type = b->type;
    domain = b->domain;
    interface = b->interface;
    protocol = b->protocol;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args_5=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_5 == 0u)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
          tmp_if_expr_7 = return_value_dbus_error_is_set_6 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_8=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(b->client, return_value_avahi_error_dbus_to_number_8);
      }
    }
    b->callback(b, (signed int)interface, (signed int)protocol, event, name, type, domain, (enum anonymous_3)flags, b->userdata);
    return (enum anonymous_28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous_28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_service_browser_free
// file lookup.h line 117
signed int avahi_service_browser_free(struct AvahiServiceBrowser *b)
{
  struct AvahiClient *avahi_service_browser_free__1__client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiServiceBrowser *)NULL));
  avahi_service_browser_free__1__client = b->client;
  signed int return_value_avahi_client_is_connected_1;
  if(!(b->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(b->client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      r=avahi_client_simple_method_call(avahi_service_browser_free__1__client, b->path, "org.freedesktop.Avahi.ServiceBrowser", "Free");

  }

  do
  {
    struct AvahiServiceBrowser **_head = &b->client->service_browsers;
    struct AvahiServiceBrowser *_item = b;
    /* assertion _item */
    assert(_item != ((struct AvahiServiceBrowser *)NULL));
    if(!(_item->service_browsers_next == ((struct AvahiServiceBrowser *)NULL)))
      _item->service_browsers_next->service_browsers_prev = _item->service_browsers_prev;

    if(!(_item->service_browsers_prev == ((struct AvahiServiceBrowser *)NULL)))
      _item->service_browsers_prev->service_browsers_next = _item->service_browsers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->service_browsers_next;
    }
    _item->service_browsers_prev = (struct AvahiServiceBrowser *)(void *)0;
    _item->service_browsers_next = _item->service_browsers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)b->path);
  avahi_free((void *)b->type);
  avahi_free((void *)b->domain);
  avahi_free((void *)b);
  return r;
}

// avahi_service_browser_get_client
// file browser.c line 686
struct AvahiClient * avahi_service_browser_get_client(struct AvahiServiceBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiServiceBrowser *)NULL));
  return b->client;
}

// avahi_service_browser_new
// file browser.c line 564
struct AvahiServiceBrowser * avahi_service_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *type, const char *domain, enum anonymous_1 flags, void (*callback)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous_2, const char *, const char *, const char *, enum anonymous_3, void *), void *userdata)
{
  struct AvahiServiceBrowser *b = (struct AvahiServiceBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_protocol;
  signed int i_interface;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous_2, const char *, const char *, const char *, enum anonymous_3, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    return_value_avahi_new_internal_2=avahi_new_internal_link2((unsigned int)1, sizeof(struct AvahiServiceBrowser) /*72ul*/ );
    b = (struct AvahiServiceBrowser *)return_value_avahi_new_internal_2;
    if(b == ((struct AvahiServiceBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      b->client = client;
      b->callback = callback;
      b->userdata = userdata;
      b->path = (char *)(void *)0;
      b->domain = (char *)(void *)0;
      b->type = b->domain;
      b->interface = interface;
      b->protocol = protocol;
      do
      {
        struct AvahiServiceBrowser **_head = &client->service_browsers;
        struct AvahiServiceBrowser *_item = b;
        /* assertion _item */
        assert(_item != ((struct AvahiServiceBrowser *)NULL));
        _item->service_browsers_next = *_head;
        if(!(_item->service_browsers_next == ((struct AvahiServiceBrowser *)NULL)))
          _item->service_browsers_next->service_browsers_prev = _item;

        _item->service_browsers_prev = (struct AvahiServiceBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      b->type=avahi_strdup(type);
      if(b->type == ((char *)NULL))
        avahi_client_set_errno(client, -24);

      else
        if(!(domain == ((const char *)NULL)))
        {
          if(*domain == 0)
            goto __CPROVER_DUMP_L7;

          b->domain=avahi_strdup(domain);
          if(!(b->domain == ((char *)NULL)))
            goto __CPROVER_DUMP_L7;

          avahi_client_set_errno(client, -24);
        }

        else
        {

        __CPROVER_DUMP_L7:
          ;
          message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "ServiceBrowserNew");
          if(message == ((struct DBusMessage *)NULL))
            avahi_client_set_errno(client, -24);

          else
          {
            i_interface = (signed int)interface;
            i_protocol = (signed int)protocol;
            u_flags = (unsigned int)flags;
            return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &type, (signed int)115, &domain, (signed int)117, &u_flags, (signed int)0);
            if(return_value_dbus_message_append_args_3 == 0u)
              avahi_client_set_errno(client, -24);

            else
            {
              reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
              if(reply == ((struct DBusMessage *)NULL))
                tmp_if_expr_5 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
                tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_5)
                avahi_client_set_errno(client, -22);

              else
              {
                return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
                if(return_value_dbus_message_get_args_6 == 0u)
                  tmp_if_expr_8 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
                  tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(path == ((char *)NULL) || tmp_if_expr_8)
                  avahi_client_set_errno(client, -22);

                else
                {
                  b->path=avahi_strdup(path);
                  if(b->path == ((char *)NULL))
                    avahi_client_set_errno(client, -24);

                  else
                  {
                    dbus_message_unref(message);
                    dbus_message_unref(reply);
                    return b;
                  }
                }
              }
            }
          }
        }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_9;
  return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(b == ((struct AvahiServiceBrowser *)NULL)))
    avahi_service_browser_free(b);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiServiceBrowser *)(void *)0;
}

// avahi_service_name_join
// file domain.c line 440
signed int avahi_service_name_join(char *p, unsigned long int size, const char *name, const char *type, const char *domain)
{
  char escaped_name[256l];
  char normalized_type[1014l];
  char normalized_domain[1014l];
  /* assertion p */
  assert(p != ((char *)NULL));
  signed int return_value_avahi_is_valid_service_name_1;
  char *tmp_if_expr_7;
  if(!(name == ((const char *)NULL)))
  {
    return_value_avahi_is_valid_service_name_1=avahi_is_valid_service_name(name);
    if(!(return_value_avahi_is_valid_service_name_1 == 0))
      goto __CPROVER_DUMP_L1;

    return -10;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    signed int return_value_avahi_is_valid_service_type_generic_2;
    return_value_avahi_is_valid_service_type_generic_2=avahi_is_valid_service_type_generic(type);
    if(return_value_avahi_is_valid_service_type_generic_2 == 0)
      return -11;

    else
    {
      signed int return_value_avahi_is_valid_domain_name_3;
      return_value_avahi_is_valid_domain_name_3=avahi_is_valid_domain_name(domain);
      if(return_value_avahi_is_valid_domain_name_3 == 0)
        return -4;

      else
      {
        if(!(name == ((const char *)NULL)))
        {
          unsigned long int l = sizeof(char [256l]) /*256ul*/ ;
          char *e = escaped_name;
          char *r;
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(name);
          r=avahi_escape_label(name, return_value_strlen_4, &e, &l);
          /* assertion r */
          assert(r != ((char *)NULL));
        }

        char *return_value_avahi_normalize_name_5;
        return_value_avahi_normalize_name_5=avahi_normalize_name(type, normalized_type, sizeof(char [1014l]) /*1014ul*/ );
        if(return_value_avahi_normalize_name_5 == ((char *)NULL))
          return -11;

        else
        {
          char *return_value_avahi_normalize_name_6;
          return_value_avahi_normalize_name_6=avahi_normalize_name(domain, normalized_domain, sizeof(char [1014l]) /*1014ul*/ );
          if(return_value_avahi_normalize_name_6 == ((char *)NULL))
            return -4;

          else
          {
            if(!(name == ((const char *)NULL)))
              tmp_if_expr_7 = escaped_name;

            else
              tmp_if_expr_7 = "";
            snprintf(p, size, "%s%s%s.%s", tmp_if_expr_7, name != ((const char *)NULL) ? "." : "", (const void *)normalized_type, (const void *)normalized_domain);
            return 0;
          }
        }
      }
    }
  }
}

// avahi_service_name_split
// file domain.c line 496
signed int avahi_service_name_split(const char *p, char *name, unsigned long int name_size, char *type, unsigned long int type_size, char *domain, unsigned long int domain_size)
{
  /* #anon_enum_NAME=0_TYPE=1_DOMAIN=2 */
enum anonymous_24 { NAME=0, TYPE=1, DOMAIN=2 };

/* */
  ;
  enum anonymous_24 state;
  signed int type_empty = 1;
  signed int domain_empty = 1;
  /* assertion p */
  assert(p != ((const char *)NULL));
  /* assertion type */
  assert(type != ((char *)NULL));
  /* assertion type_size > 0 */
  assert(type_size > (unsigned long int)0);
  /* assertion domain */
  assert(domain != ((char *)NULL));
  /* assertion domain_size > 0 */
  assert(domain_size > (unsigned long int)0);
  if(!(name == ((char *)NULL)))
  {
    /* assertion name_size > 0 */
    assert(name_size > (unsigned long int)0);
    *name = (char)0;
    state = (enum anonymous_24)NAME;
  }

  else
    state = (enum anonymous_24)TYPE;
  *domain = (char)0;
  *type = *domain;
  char *tmp_post_2;
  char *tmp_post_5;
  unsigned long int return_value_strlen_6;
  char *return_value_avahi_escape_label_7;
  while(!(*p == 0))
  {
    char buf[64l];
    char *return_value_avahi_unescape_label_1;
    return_value_avahi_unescape_label_1=avahi_unescape_label(&p, buf, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label_1 == ((char *)NULL))
      return -1;

    switch((signed int)state)
    {
      case NAME:
      {
        strlcpy(name, buf, name_size);
        state = (enum anonymous_24)TYPE;
        break;
      }
      case TYPE:
      {
        if((signed int)buf[0l] == 95)
        {
          if(type_empty == 0)
          {
            if(type_size == 0ul)
              return -24;

            tmp_post_2 = type;
            type = type + 1l;
            *tmp_post_2 = (char)46;
            type_size = type_size - 1ul;
          }

          else
            type_empty = 0;
          unsigned long int return_value_strlen_3;
          return_value_strlen_3=strlen(buf);
          char *return_value_avahi_escape_label_4;
          return_value_avahi_escape_label_4=avahi_escape_label(buf, return_value_strlen_3, &type, &type_size);
          if(return_value_avahi_escape_label_4 == ((char *)NULL))
            return -24;

          break;
        }

        state = (enum anonymous_24)DOMAIN;
      }
      case DOMAIN:
      {
        if(domain_empty == 0)
        {
          if(domain_size == 0ul)
            return -24;

          tmp_post_5 = domain;
          domain = domain + 1l;
          *tmp_post_5 = (char)46;
          domain_size = domain_size - 1ul;
        }

        else
          domain_empty = 0;
        return_value_strlen_6=strlen(buf);
        return_value_avahi_escape_label_7=avahi_escape_label(buf, return_value_strlen_6, &domain, &domain_size);
        if(return_value_avahi_escape_label_7 == ((char *)NULL))
          return -24;

      }
    }
  }
  return 0;
}

// avahi_service_resolver_event
// file internal.h line 164
enum anonymous_28 avahi_service_resolver_event(struct AvahiClient *client, enum anonymous_6 event, struct DBusMessage *message)
{
  struct AvahiServiceResolver *r = (struct AvahiServiceResolver *)(void *)0;
  struct DBusError error;
  const char *path;
  struct AvahiStringList *strlst = (struct AvahiStringList *)(void *)0;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  signed int j;
  signed int interface;
  signed int protocol;
  signed int aprotocol;
  unsigned int flags;
  char *name;
  char *type;
  char *domain;
  char *host;
  char *address;
  unsigned short int port;
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  struct AvahiAddress a;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  signed int return_value_dbus_message_iter_get_arg_type_5;
  _Bool tmp_if_expr_7;
  signed int return_value_dbus_message_iter_get_element_type_6;
  signed int return_value_dbus_message_iter_get_arg_type_9;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_10;
  _Bool tmp_if_expr_12;
  unsigned int return_value_dbus_error_is_set_11;
  signed int return_value_avahi_error_dbus_to_number_13;
  if(!(path == ((const char *)NULL)))
  {
    r = client->service_resolvers;
    for( ; !(r == ((struct AvahiServiceResolver *)NULL)); r = r->service_resolvers_next)
    {
      return_value_strcmp_1=strcmp(r->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(r == ((struct AvahiServiceResolver *)NULL))
      goto fail;

    switch((signed int)event)
    {
      case AVAHI_RESOLVER_FOUND:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)115, &host, (signed int)105, &aprotocol, (signed int)115, &address, (signed int)113, &port, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        dbus_message_iter_init(message, &iter);
        j = 0;
        for( ; !(j >= 9); j = j + 1)
          dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type_5=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type_5 == 97))
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_dbus_message_iter_get_element_type_6=dbus_message_iter_get_element_type(&iter);
          tmp_if_expr_7 = return_value_dbus_message_iter_get_element_type_6 != (signed int)97 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          fprintf(stderr, "Error parsing service resolving message\n");
          goto fail;
        }

        strlst = (struct AvahiStringList *)(void *)0;
        dbus_message_iter_recurse(&iter, &sub);
        do
        {
          struct DBusMessageIter sub2;
          signed int at;
          const unsigned char *k;
          signed int n;
          at=dbus_message_iter_get_arg_type(&sub);
          if(at == 0)
            break;

          /* assertion at == ((int) 'a') */
          assert(at == (signed int)97);
          signed int return_value_dbus_message_iter_get_element_type_8;
          return_value_dbus_message_iter_get_element_type_8=dbus_message_iter_get_element_type(&sub);
          if(!(return_value_dbus_message_iter_get_element_type_8 == 121))
          {
            fprintf(stderr, "Error parsing service resolving message\n");
            goto fail;
          }

          dbus_message_iter_recurse(&sub, &sub2);
          k = (const unsigned char *)(void *)0;
          n = 0;
          dbus_message_iter_get_fixed_array(&sub2, (void *)&k, &n);
          if(n >= 1 && !(k == ((const unsigned char *)NULL)))
            strlst=avahi_string_list_add_arbitrary(strlst, k, (unsigned long int)n);

          dbus_message_iter_next(&sub);
        }
        while((_Bool)1);
        dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type_9=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type_9 == 117))
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        dbus_message_iter_get_basic(&iter, (void *)&flags);
        /* assertion address */
        assert(address != ((char *)NULL));
        if((signed int)*address == 0)
          address = (char *)(void *)0;

        else
          avahi_address_parse(address, (signed int)aprotocol, &a);
        r->callback(r, (signed int)interface, (signed int)protocol, (enum anonymous_6)AVAHI_RESOLVER_FOUND, name, type, domain, host, address != ((char *)NULL) ? &a : (struct AvahiAddress *)(void *)0, port, strlst, (enum anonymous_3)flags, r->userdata);
      }
      case AVAHI_RESOLVER_FAILURE:
      {
        return_value_dbus_message_get_args_10=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_10 == 0u)
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_11=dbus_error_is_set(&error);
          tmp_if_expr_12 = return_value_dbus_error_is_set_11 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_12)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_13=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(r->client, return_value_avahi_error_dbus_to_number_13);
        r->callback(r, r->interface, r->protocol, event, r->name, r->type, r->domain, (const char *)(void *)0, (const struct AvahiAddress *)(void *)0, (unsigned short int)0, (struct AvahiStringList *)(void *)0, (enum anonymous_3)0, r->userdata);
      }
    }
    return (enum anonymous_28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    avahi_string_list_free(strlst);
    return (enum anonymous_28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_service_resolver_free
// file lookup.h line 205
signed int avahi_service_resolver_free(struct AvahiServiceResolver *r)
{
  struct AvahiClient *avahi_service_resolver_free__1__client;
  signed int ret = 0;
  /* assertion r */
  assert(r != ((struct AvahiServiceResolver *)NULL));
  avahi_service_resolver_free__1__client = r->client;
  signed int return_value_avahi_client_is_connected_1;
  if(!(r->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(avahi_service_resolver_free__1__client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      ret=avahi_client_simple_method_call(avahi_service_resolver_free__1__client, r->path, "org.freedesktop.Avahi.ServiceResolver", "Free");

  }

  do
  {
    struct AvahiServiceResolver **_head = &avahi_service_resolver_free__1__client->service_resolvers;
    struct AvahiServiceResolver *_item = r;
    /* assertion _item */
    assert(_item != ((struct AvahiServiceResolver *)NULL));
    if(!(_item->service_resolvers_next == ((struct AvahiServiceResolver *)NULL)))
      _item->service_resolvers_next->service_resolvers_prev = _item->service_resolvers_prev;

    if(!(_item->service_resolvers_prev == ((struct AvahiServiceResolver *)NULL)))
      _item->service_resolvers_prev->service_resolvers_next = _item->service_resolvers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->service_resolvers_next;
    }
    _item->service_resolvers_prev = (struct AvahiServiceResolver *)(void *)0;
    _item->service_resolvers_next = _item->service_resolvers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)r->path);
  avahi_free((void *)r->name);
  avahi_free((void *)r->type);
  avahi_free((void *)r->domain);
  avahi_free((void *)r);
  return ret;
}

// avahi_service_resolver_get_client
// file resolver.c line 318
struct AvahiClient * avahi_service_resolver_get_client(struct AvahiServiceResolver *r)
{
  /* assertion r */
  assert(r != ((struct AvahiServiceResolver *)NULL));
  return r->client;
}

// avahi_service_resolver_new
// file resolver.c line 179
struct AvahiServiceResolver * avahi_service_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, const char *type, const char *domain, signed int aprotocol, enum anonymous_1 flags, void (*callback)(struct AvahiServiceResolver *, signed int, signed int, enum anonymous_6, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous_3, void *), void *userdata)
{
  struct DBusError error;
  struct AvahiServiceResolver *r = (struct AvahiServiceResolver *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int i_interface;
  signed int i_protocol;
  signed int i_aprotocol;
  unsigned int u_flags;
  char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  if(domain == ((const char *)NULL))
    domain = "";

  if(name == ((const char *)NULL))
    name = "";

  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal_2=avahi_new_internal_link3((unsigned int)1, sizeof(struct AvahiServiceResolver) /*80ul*/ );
    r = (struct AvahiServiceResolver *)return_value_avahi_new_internal_2;
    if(r == ((struct AvahiServiceResolver *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      r->client = client;
      r->callback = callback;
      r->userdata = userdata;
      r->path = (char *)(void *)0;
      r->domain = (char *)(void *)0;
      r->type = r->domain;
      r->name = r->type;
      r->interface = interface;
      r->protocol = protocol;
      do
      {
        struct AvahiServiceResolver **_head = &client->service_resolvers;
        struct AvahiServiceResolver *_item = r;
        /* assertion _item */
        assert(_item != ((struct AvahiServiceResolver *)NULL));
        _item->service_resolvers_next = *_head;
        if(!(_item->service_resolvers_next == ((struct AvahiServiceResolver *)NULL)))
          _item->service_resolvers_next->service_resolvers_prev = _item;

        _item->service_resolvers_prev = (struct AvahiServiceResolver *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      if(!(name == ((const char *)NULL)))
      {
        if(*name == 0)
          goto __CPROVER_DUMP_L7;

        r->name=avahi_strdup(name);
        if(!(r->name == ((char *)NULL)))
          goto __CPROVER_DUMP_L7;

        avahi_client_set_errno(client, -24);
      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        r->type=avahi_strdup(type);
        if(r->type == ((char *)NULL))
          avahi_client_set_errno(client, -24);

        else
          if(!(domain == ((const char *)NULL)))
          {
            if(*domain == 0)
              goto __CPROVER_DUMP_L9;

            r->domain=avahi_strdup(domain);
            if(!(r->domain == ((char *)NULL)))
              goto __CPROVER_DUMP_L9;

            avahi_client_set_errno(client, -24);
          }

          else
          {

          __CPROVER_DUMP_L9:
            ;
            message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "ServiceResolverNew");
            if(message == ((struct DBusMessage *)NULL))
              avahi_client_set_errno(client, -24);

            else
            {
              i_interface = (signed int)interface;
              i_protocol = (signed int)protocol;
              i_aprotocol = (signed int)aprotocol;
              u_flags = (unsigned int)flags;
              return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)105, &i_aprotocol, (signed int)117, &u_flags, (signed int)0);
              if(return_value_dbus_message_append_args_3 == 0u)
                avahi_client_set_errno(client, -24);

              else
              {
                reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
                if(reply == ((struct DBusMessage *)NULL))
                  tmp_if_expr_5 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
                  tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_5)
                  avahi_client_set_errno(client, -22);

                else
                {
                  return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
                  if(return_value_dbus_message_get_args_6 == 0u)
                    tmp_if_expr_8 = (_Bool)1;

                  else
                  {
                    return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
                    tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
                  }
                  if(path == ((char *)NULL) || tmp_if_expr_8)
                    avahi_client_set_errno(client, -22);

                  else
                  {
                    r->path=avahi_strdup(path);
                    if(r->path == ((char *)NULL))
                      avahi_client_set_errno(client, -24);

                    else
                    {
                      dbus_message_unref(message);
                      dbus_message_unref(reply);
                      return r;
                    }
                  }
                }
              }
            }
          }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_9;
  return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(r == ((struct AvahiServiceResolver *)NULL)))
    avahi_service_resolver_free(r);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiServiceResolver *)(void *)0;
}

// avahi_service_type_browser_event
// file internal.h line 160
enum anonymous_28 avahi_service_type_browser_event(struct AvahiClient *client, enum anonymous_2 event, struct DBusMessage *message)
{
  struct AvahiServiceTypeBrowser *b = (struct AvahiServiceTypeBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *domain;
  char *type = (char *)(void *)0;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_5;
  _Bool tmp_if_expr_7;
  unsigned int return_value_dbus_error_is_set_6;
  signed int return_value_avahi_error_dbus_to_number_8;
  if(!(path == ((const char *)NULL)))
  {
    b = client->service_type_browsers;
    for( ; !(b == ((struct AvahiServiceTypeBrowser *)NULL)); b = b->service_type_browsers_next)
    {
      return_value_strcmp_1=strcmp(b->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(b == ((struct AvahiServiceTypeBrowser *)NULL))
      goto fail;

    domain = b->domain;
    interface = b->interface;
    protocol = b->protocol;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &type, (signed int)115, &domain, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args_5=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_5 == 0u)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
          tmp_if_expr_7 = return_value_dbus_error_is_set_6 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_8=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(b->client, return_value_avahi_error_dbus_to_number_8);
      }
    }
    b->callback(b, (signed int)interface, (signed int)protocol, event, type, domain, (enum anonymous_3)flags, b->userdata);
    return (enum anonymous_28)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous_28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_service_type_browser_free
// file lookup.h line 150
signed int avahi_service_type_browser_free(struct AvahiServiceTypeBrowser *b)
{
  struct AvahiClient *avahi_service_type_browser_free__1__client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiServiceTypeBrowser *)NULL));
  avahi_service_type_browser_free__1__client = b->client;
  signed int return_value_avahi_client_is_connected_1;
  if(!(b->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(b->client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      r=avahi_client_simple_method_call(avahi_service_type_browser_free__1__client, b->path, "org.freedesktop.Avahi.ServiceTypeBrowser", "Free");

  }

  do
  {
    struct AvahiServiceTypeBrowser **_head = &b->client->service_type_browsers;
    struct AvahiServiceTypeBrowser *_item = b;
    /* assertion _item */
    assert(_item != ((struct AvahiServiceTypeBrowser *)NULL));
    if(!(_item->service_type_browsers_next == ((struct AvahiServiceTypeBrowser *)NULL)))
      _item->service_type_browsers_next->service_type_browsers_prev = _item->service_type_browsers_prev;

    if(!(_item->service_type_browsers_prev == ((struct AvahiServiceTypeBrowser *)NULL)))
      _item->service_type_browsers_prev->service_type_browsers_next = _item->service_type_browsers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->service_type_browsers_next;
    }
    _item->service_type_browsers_prev = (struct AvahiServiceTypeBrowser *)(void *)0;
    _item->service_type_browsers_next = _item->service_type_browsers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)b->path);
  avahi_free((void *)b->domain);
  avahi_free((void *)b);
  return r;
}

// avahi_service_type_browser_get_client
// file browser.c line 465
struct AvahiClient * avahi_service_type_browser_get_client(struct AvahiServiceTypeBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiServiceTypeBrowser *)NULL));
  return b->client;
}

// avahi_service_type_browser_new
// file browser.c line 350
struct AvahiServiceTypeBrowser * avahi_service_type_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous_1 flags, void (*callback)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous_2, const char *, const char *, enum anonymous_3, void *), void *userdata)
{
  struct AvahiServiceTypeBrowser *b = (struct AvahiServiceTypeBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous_2, const char *, const char *, enum anonymous_3, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    return_value_avahi_new_internal_2=avahi_new_internal_link2((unsigned int)1, sizeof(struct AvahiServiceTypeBrowser) /*64ul*/ );
    b = (struct AvahiServiceTypeBrowser *)return_value_avahi_new_internal_2;
    if(b == ((struct AvahiServiceTypeBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      b->client = client;
      b->callback = callback;
      b->userdata = userdata;
      b->path = (char *)(void *)0;
      b->domain = (char *)(void *)0;
      b->interface = interface;
      b->protocol = protocol;
      do
      {
        struct AvahiServiceTypeBrowser **_head = &client->service_type_browsers;
        struct AvahiServiceTypeBrowser *_item = b;
        /* assertion _item */
        assert(_item != ((struct AvahiServiceTypeBrowser *)NULL));
        _item->service_type_browsers_next = *_head;
        if(!(_item->service_type_browsers_next == ((struct AvahiServiceTypeBrowser *)NULL)))
          _item->service_type_browsers_next->service_type_browsers_prev = _item;

        _item->service_type_browsers_prev = (struct AvahiServiceTypeBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      if(!(*domain == 0))
      {
        b->domain=avahi_strdup(domain);
        if(!(b->domain == ((char *)NULL)))
          goto __CPROVER_DUMP_L6;

        avahi_client_set_errno(client, -24);
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "ServiceTypeBrowserNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &domain, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args_3 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr_5 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
              tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_5)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args_6 == 0u)
                tmp_if_expr_8 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
                tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr_8)
                avahi_client_set_errno(client, -22);

              else
              {
                b->path=avahi_strdup(path);
                if(b->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return b;
                }
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_9;
  return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(b == ((struct AvahiServiceTypeBrowser *)NULL)))
    avahi_service_type_browser_free(b);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiServiceTypeBrowser *)(void *)0;
}

// avahi_set_allocator
// file malloc.c line 196
void avahi_set_allocator(const struct AvahiAllocator *a)
{
  allocator = a;
}

// avahi_simple_poll_dispatch
// file simple-watch.c line 547
signed int avahi_simple_poll_dispatch(struct AvahiSimplePoll *s)
{
  struct AvahiTimeout *next_timeout;
  struct AvahiWatch *w;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  /* assertion s->state == STATE_RAN */
  assert((signed int)s->state == STATE_RAN);
  s->state = (enum anonymous_4)STATE_DISPATCHING;
  next_timeout=find_next_timeout(s);
  if(!(next_timeout == ((struct AvahiTimeout *)NULL)))
  {
    if(next_timeout->expiry.tv_sec == 0l)
    {
      if(next_timeout->expiry.tv_usec == 0l)
      {
        timeout_callback_link1(next_timeout);
        goto finish;
      }

    }

    signed long int return_value_avahi_age_1;
    return_value_avahi_age_1=avahi_age(&next_timeout->expiry);
    if(return_value_avahi_age_1 >= 0l)
    {
      timeout_callback_link1(next_timeout);
      goto finish;
    }

  }

  w = s->watches;
  for( ; !(w == ((struct AvahiWatch *)NULL)); w = w->watches_next)
    if(w->dead == 0)
    {
      /* assertion w->idx >= 0 */
      assert(w->idx >= 0);
      /* assertion w->idx < s->n_pollfds */
      assert(w->idx < s->n_pollfds);
      if(!((signed int)(s->pollfds + (signed long int)w->idx)->revents == 0))
      {
        w->callback(w, w->pollfd.fd, (enum anonymous_9)(s->pollfds + (signed long int)w->idx)->revents, w->userdata);
        break;
      }

    }


finish:
  ;
  s->state = (enum anonymous_4)STATE_DISPATCHED;
  return 0;
}

// avahi_simple_poll_free
// file ../avahi-common/simple-watch.h line 40
void avahi_simple_poll_free(struct AvahiSimplePoll *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  cleanup_timeouts(s, 1);
  cleanup_watches(s, 1);
  /* assertion s->n_watches == 0 */
  assert(s->n_watches == 0);
  avahi_free((void *)s->pollfds);
  if(s->wakeup_pipe[0l] >= 0)
    close(s->wakeup_pipe[(signed long int)0]);

  if(s->wakeup_pipe[1l] >= 0)
    close(s->wakeup_pipe[(signed long int)1]);

  avahi_free((void *)s);
}

// avahi_simple_poll_get
// file ../avahi-common/simple-watch.h line 45
const struct AvahiPoll * avahi_simple_poll_get(struct AvahiSimplePoll *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  return &s->api;
}

// avahi_simple_poll_iterate
// file simple-watch.c line 596
signed int avahi_simple_poll_iterate(struct AvahiSimplePoll *s, signed int timeout)
{
  signed int r;
  r=avahi_simple_poll_prepare(s, timeout);
  if(!(r == 0))
    return r;

  else
  {
    r=avahi_simple_poll_run(s);
    if(!(r == 0))
      return r;

    else
    {
      r=avahi_simple_poll_dispatch(s);
      if(!(r == 0))
        return r;

      else
        return 0;
    }
  }
}

// avahi_simple_poll_loop
// file simple-watch.c line 640
signed int avahi_simple_poll_loop(struct AvahiSimplePoll *s)
{
  signed int r;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  do
  {
    r=avahi_simple_poll_iterate(s, -1);
    if(!(r == 0))
    {
      if(r >= 0)
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        return_value___errno_location_1=__errno_location();
        tmp_if_expr_2 = *return_value___errno_location_1 != 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        return r;

    }

  }
  while((_Bool)1);
}

// avahi_simple_poll_new
// file ../avahi-common/simple-watch.h line 37
struct AvahiSimplePoll * avahi_simple_poll_new(void)
{
  struct AvahiSimplePoll *s;
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link2_link1((unsigned int)1, sizeof(struct AvahiSimplePoll) /*160ul*/ );
  s = (struct AvahiSimplePoll *)return_value_avahi_new_internal_1;
  if(s == ((struct AvahiSimplePoll *)NULL))
    return (struct AvahiSimplePoll *)(void *)0;

  else
  {
    signed int return_value_pipe_2;
    return_value_pipe_2=pipe(s->wakeup_pipe);
    if(!(return_value_pipe_2 >= 0))
    {
      avahi_free((void *)s);
      return (struct AvahiSimplePoll *)(void *)0;
    }

    else
    {
      set_nonblock_link1(s->wakeup_pipe[(signed long int)0]);
      set_nonblock_link1(s->wakeup_pipe[(signed long int)1]);
      s->api.userdata = (void *)s;
      s->api.watch_new = watch_new;
      s->api.watch_free = watch_free;
      s->api.watch_update = watch_update;
      s->api.watch_get_events = watch_get_events;
      s->api.timeout_new = timeout_new;
      s->api.timeout_free = timeout_free;
      s->api.timeout_update = timeout_update;
      s->pollfds = (struct pollfd *)(void *)0;
      s->n_pollfds = 0;
      s->max_pollfds = s->n_pollfds;
      s->rebuild_pollfds = 1;
      s->quit = 0;
      s->n_watches = 0;
      s->events_valid = 0;
      s->watch_req_cleanup = 0;
      s->timeout_req_cleanup = 0;
      s->prepared_timeout = 0;
      s->state = (enum anonymous_4)STATE_INIT;
      s->wakeup_issued = 0;
      avahi_simple_poll_set_func(s, (signed int (*)(struct pollfd *, unsigned int, signed int, void *))(void *)0, (void *)0);
      do
        s->watches = (struct AvahiWatch *)(void *)0;
      while((_Bool)0);
      do
        s->timeouts = (struct AvahiTimeout *)(void *)0;
      while((_Bool)0);
      return s;
    }
  }
}

// avahi_simple_poll_prepare
// file simple-watch.c line 450
signed int avahi_simple_poll_prepare(struct AvahiSimplePoll *s, signed int timeout)
{
  struct AvahiTimeout *next_timeout;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  _Bool tmp_if_expr_1;
  if((signed int)s->state == STATE_INIT)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)s->state == STATE_DISPATCHED ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)s->state == STATE_FAILURE ? (_Bool)1 : (_Bool)0;
  /* assertion s->state == STATE_INIT || s->state == STATE_DISPATCHED || s->state == STATE_FAILURE */
  assert(tmp_if_expr_2);
  s->state = (enum anonymous_4)STATE_PREPARING;
  clear_wakeup(s);
  if(!(s->watch_req_cleanup == 0))
    cleanup_watches(s, 0);

  if(!(s->timeout_req_cleanup == 0))
    cleanup_timeouts(s, 0);

  signed int return_value_rebuild_3;
  if(!(s->quit == 0))
  {
    s->state = (enum anonymous_4)STATE_QUIT;
    return 1;
  }

  else
    if(!(s->rebuild_pollfds == 0))
    {
      return_value_rebuild_3=rebuild(s);
      if(return_value_rebuild_3 >= 0)
        goto __CPROVER_DUMP_L8;

      s->state = (enum anonymous_4)STATE_FAILURE;
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      next_timeout=find_next_timeout(s);
      if(!(next_timeout == ((struct AvahiTimeout *)NULL)))
      {
        struct timeval now;
        signed int t;
        signed long int usec;
        if(next_timeout->expiry.tv_sec == 0l)
        {
          if(!(next_timeout->expiry.tv_usec == 0l))
            goto __CPROVER_DUMP_L9;

          timeout = 0;
        }

        else
        {

        __CPROVER_DUMP_L9:
          ;
          gettimeofday(&now, (struct timezone *)(void *)0);
          usec=avahi_timeval_diff(&next_timeout->expiry, &now);
          if(!(usec >= 1l))
            timeout = 0;

          else
          {
            t = (signed int)(usec / (signed long int)1000) + 1;
            if(!(t >= timeout) || !(timeout >= 0))
              timeout = t;

          }
        }
      }


    finish:
      ;
      s->prepared_timeout = timeout;
      s->state = (enum anonymous_4)STATE_PREPARED;
      return 0;
    }
}

// avahi_simple_poll_quit
// file ../avahi-common/simple-watch.h line 60
void avahi_simple_poll_quit(struct AvahiSimplePoll *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  s->quit = 1;
  avahi_simple_poll_wakeup(s);
}

// avahi_simple_poll_run
// file simple-watch.c line 518
signed int avahi_simple_poll_run(struct AvahiSimplePoll *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  _Bool tmp_if_expr_1;
  if((signed int)s->state == STATE_PREPARED)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)s->state == STATE_FAILURE ? (_Bool)1 : (_Bool)0;
  /* assertion s->state == STATE_PREPARED || s->state == STATE_FAILURE */
  assert(tmp_if_expr_1);
  s->state = (enum anonymous_4)STATE_RUNNING;
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  *return_value___errno_location_2 = 0;
  signed int return_value;
  return_value=s->poll_func(s->pollfds, (unsigned int)s->n_pollfds, s->prepared_timeout, s->poll_func_userdata);
  if(!(return_value >= 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    s->state = (enum anonymous_4)STATE_FAILURE;
    return -1;
  }

  s->events_valid = 1;
  s->state = (enum anonymous_4)STATE_RAN;
  return 0;
}

// avahi_simple_poll_set_func
// file simple-watch.c line 630
void avahi_simple_poll_set_func(struct AvahiSimplePoll *s, signed int (*func)(struct pollfd *, unsigned int, signed int, void *), void *userdata)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  s->poll_func = func != ((signed int (*)(struct pollfd *, unsigned int, signed int, void *))NULL) ? func : system_poll;
  s->poll_func_userdata = func != ((signed int (*)(struct pollfd *, unsigned int, signed int, void *))NULL) ? userdata : (void *)0;
  avahi_simple_poll_wakeup(s);
}

// avahi_simple_poll_wakeup
// file simple-watch.c line 97
void avahi_simple_poll_wakeup(struct AvahiSimplePoll *s)
{
  char c = (char)87;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  write(s->wakeup_pipe[(signed long int)1], (const void *)&c, sizeof(char) /*1ul*/ );
  s->wakeup_issued = 1;
}

// avahi_strdup
// file ../avahi-common/malloc.h line 66
char * avahi_strdup(const char *s)
{
  char *r;
  unsigned long int size;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    size=strlen(s);
    void *return_value_avahi_malloc_1;
    return_value_avahi_malloc_1=avahi_malloc(size + (unsigned long int)1);
    r = (char *)return_value_avahi_malloc_1;
    if(r == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      memcpy((void *)r, (const void *)s, size + (unsigned long int)1);
      return r;
    }
  }
}

// avahi_strdup_printf
// file malloc.c line 235
char * avahi_strdup_printf(const char *fmt, ...)
{
  char *s;
  void **ap;
  /* assertion fmt */
  assert(fmt != ((const char *)NULL));
  ap = (void **)&fmt;
  s=avahi_strdup_vprintf(fmt, ap);
  ap = ((void **)NULL);
  return s;
}

// avahi_strdup_vprintf
// file malloc.c line 200
char * avahi_strdup_vprintf(const char *fmt, void **ap)
{
  unsigned long int len = (unsigned long int)80;
  char *buf;
  /* assertion fmt */
  assert(fmt != ((const char *)NULL));
  void *return_value_avahi_malloc_1;
  return_value_avahi_malloc_1=avahi_malloc(len);
  buf = (char *)return_value_avahi_malloc_1;
  if(buf == ((char *)NULL))
    return (char *)(void *)0;

  else
    do
    {
      signed int n;
      char *nbuf;
      void **ap2 = (void **)ap;
      n=vsnprintf(buf, len, fmt, ap2);
      ap2 = ((void **)NULL);
      if(n >= 0 && !(n >= (signed int)len))
        return buf;

      if(n >= 0)
        len = (unsigned long int)(n + 1);

      else
        len = len * (unsigned long int)2;
      void *return_value_avahi_realloc_2;
      return_value_avahi_realloc_2=avahi_realloc((void *)buf, len);
      nbuf = (char *)return_value_avahi_realloc_2;
      if(nbuf == ((char *)NULL))
      {
        avahi_free((void *)buf);
        return (char *)(void *)0;
      }

      buf = nbuf;
    }
    while((_Bool)1);
}

// avahi_strerror
// file ../avahi-common/error.h line 103
const char * avahi_strerror(signed int error)
{
  const char * const msg[54l] = { "OK", "Operation failed", "Bad state", "Invalid host name", "Invalid domain name", "No suitable network protocol available",
    "Invalid DNS TTL", "Resource record key is pattern", "Local name collision", "Invalid record", "Invalid service name", "Invalid service type", "Invalid port number", "Invalid record key", "Invalid address", "Timeout reached", "Too many clients", "Too many objects", "Too many entries", "OS Error", "Access denied", "Invalid operation", "An unexpected D-Bus error occurred", "Daemon connection failed", "Memory exhausted", "The object passed in was not valid", "Daemon not running", "Invalid interface index", "Invalid protocol specification", "Invalid flags", "Not found", "Invalid configuration", "Version mismatch", "Invalid service subtype", "Invalid packet", "Invalid DNS return code", "DNS failure: FORMERR", "DNS failure: SERVFAIL", "DNS failure: NXDOMAIN", "DNS failure: NOTIMP", "DNS failure: REFUSED", "DNS failure: YXDOMAIN", "DNS failure: YXRRSET", "DNS failure: NXRRSET", "DNS failure: NOTAUTH", "DNS failure: NOTZONE", "Invalid RDATA", "Invalid DNS type", "Invalid DNS class", "Not supported", "Not permitted", "Invalid argument", "Is empty", "The requested operation is invalid because redundant" };
  avahi_init_i18n();
  char *return_value_dgettext_1;
  if(-error >= 54 || !(-error >= 0))
  {
    return_value_dgettext_1=dgettext("avahi", "Invalid Error Code");
    return return_value_dgettext_1;
  }

  else
  {
    char *return_value_dgettext_2;
    return_value_dgettext_2=dgettext("avahi", msg[(signed long int)-error]);
    return return_value_dgettext_2;
  }
}

// avahi_string_list_add
// file ../avahi-common/strlst.h line 73
struct AvahiStringList * avahi_string_list_add(struct AvahiStringList *l, const char *text)
{
  /* assertion text */
  assert(text != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(text);
  struct AvahiStringList *return_value_avahi_string_list_add_arbitrary_2;
  return_value_avahi_string_list_add_arbitrary_2=avahi_string_list_add_arbitrary(l, (const unsigned char *)text, return_value_strlen_1);
  return return_value_avahi_string_list_add_arbitrary_2;
}

// avahi_string_list_add_anonymous
// file strlst.c line 34
struct AvahiStringList * avahi_string_list_add_anonymous(struct AvahiStringList *l, unsigned long int size)
{
  struct AvahiStringList *n;
  void *return_value_avahi_malloc_1;
  return_value_avahi_malloc_1=avahi_malloc(sizeof(struct AvahiStringList) /*24ul*/  + size);
  n = (struct AvahiStringList *)return_value_avahi_malloc_1;
  if(n == ((struct AvahiStringList *)NULL))
    return (struct AvahiStringList *)(void *)0;

  else
  {
    n->next = l;
    n->size = size;
    n->text[(signed long int)size] = (unsigned char)0;
    return n;
  }
}

// avahi_string_list_add_arbitrary
// file ../avahi-common/strlst.h line 85
struct AvahiStringList * avahi_string_list_add_arbitrary(struct AvahiStringList *l, const unsigned char *text, unsigned long int size)
{
  struct AvahiStringList *n;
  /* assertion size == 0 || text */
  assert(size == (unsigned long int)0 || text != ((const unsigned char *)NULL));
  n=avahi_string_list_add_anonymous(l, size);
  if(n == ((struct AvahiStringList *)NULL))
    return (struct AvahiStringList *)(void *)0;

  else
  {
    if(size >= 1ul)
      memcpy((void *)n->text, (const void *)text, size);

    return n;
  }
}

// avahi_string_list_add_many
// file strlst.c line 255
struct AvahiStringList * avahi_string_list_add_many(struct AvahiStringList *r, ...)
{
  void **va = (void **)&r;
  r=avahi_string_list_add_many_va(r, va);
  va = ((void **)NULL);
  return r;
}

// avahi_string_list_add_many_va
// file strlst.c line 265
struct AvahiStringList * avahi_string_list_add_many_va(struct AvahiStringList *r, __builtin_va_list va)
{
  const char *txt;
  do
  {
    txt=va_arg(va, __typeof__(txt));
    if(txt == ((const char *)NULL))
      break;

    r=avahi_string_list_add(r, txt);
  }
  while((_Bool)1);
  return r;
}

// avahi_string_list_add_pair
// file strlst.c line 395
struct AvahiStringList * avahi_string_list_add_pair(struct AvahiStringList *l, const char *key, const char *value)
{
  /* assertion key */
  assert(key != ((const char *)NULL));
  struct AvahiStringList *return_value_avahi_string_list_add_printf_1;
  struct AvahiStringList *return_value_avahi_string_list_add_2;
  if(!(value == ((const char *)NULL)))
  {
    return_value_avahi_string_list_add_printf_1=avahi_string_list_add_printf(l, "%s=%s", key, value);
    return return_value_avahi_string_list_add_printf_1;
  }

  else
  {
    return_value_avahi_string_list_add_2=avahi_string_list_add(l, key);
    return return_value_avahi_string_list_add_2;
  }
}

// avahi_string_list_add_pair_arbitrary
// file strlst.c line 404
struct AvahiStringList * avahi_string_list_add_pair_arbitrary(struct AvahiStringList *l, const char *key, const unsigned char *value, unsigned long int size)
{
  unsigned long int n;
  /* assertion key */
  assert(key != ((const char *)NULL));
  struct AvahiStringList *return_value_avahi_string_list_add_1;
  if(value == ((const unsigned char *)NULL))
  {
    return_value_avahi_string_list_add_1=avahi_string_list_add(l, key);
    return return_value_avahi_string_list_add_1;
  }

  else
  {
    n=strlen(key);
    l=avahi_string_list_add_anonymous(l, n + (unsigned long int)1 + size);
    if(l == ((struct AvahiStringList *)NULL))
      return (struct AvahiStringList *)(void *)0;

    else
    {
      memcpy((void *)l->text, (const void *)key, n);
      l->text[(signed long int)n] = (unsigned char)61;
      memcpy((void *)(l->text + (signed long int)n + (signed long int)1), (const void *)value, size);
      return l;
    }
  }
}

// avahi_string_list_add_printf
// file strlst.c line 366
struct AvahiStringList * avahi_string_list_add_printf(struct AvahiStringList *l, const char *format, ...)
{
  void **va;
  /* assertion format */
  assert(format != ((const char *)NULL));
  va = (void **)&format;
  l=avahi_string_list_add_vprintf(l, format, va);
  va = ((void **)NULL);
  return l;
}

// avahi_string_list_add_vprintf
// file strlst.c line 326
struct AvahiStringList * avahi_string_list_add_vprintf(struct AvahiStringList *l, const char *format, void **va)
{
  unsigned long int len = (unsigned long int)80;
  struct AvahiStringList *r;
  /* assertion format */
  assert(format != ((const char *)NULL));
  void *return_value_avahi_malloc_1;
  return_value_avahi_malloc_1=avahi_malloc(sizeof(struct AvahiStringList) /*24ul*/  + len);
  r = (struct AvahiStringList *)return_value_avahi_malloc_1;
  if(r == ((struct AvahiStringList *)NULL))
    return (struct AvahiStringList *)(void *)0;

  else
  {
    do
    {
      signed int n;
      struct AvahiStringList *nr;
      void **va2 = (void **)va;
      n=vsnprintf((char *)r->text, len, format, va2);
      va2 = ((void **)NULL);
      if(n >= 0 && !(n >= (signed int)len))
        break;

      if(n >= 0)
        len = (unsigned long int)(n + 1);

      else
        len = len * (unsigned long int)2;
      void *return_value_avahi_realloc_2;
      return_value_avahi_realloc_2=avahi_realloc((void *)r, sizeof(struct AvahiStringList) /*24ul*/  + len);
      nr = (struct AvahiStringList *)return_value_avahi_realloc_2;
      if(nr == ((struct AvahiStringList *)NULL))
      {
        avahi_free((void *)r);
        return (struct AvahiStringList *)(void *)0;
      }

      r = nr;
    }
    while((_Bool)1);
    r->next = l;
    r->size=strlen((char *)r->text);
    return r;
  }
}

// avahi_string_list_copy
// file strlst.c line 293
struct AvahiStringList * avahi_string_list_copy(const struct AvahiStringList *l)
{
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  for( ; !(l == ((const struct AvahiStringList *)NULL)); l = l->next)
  {
    r=avahi_string_list_add_arbitrary(r, l->text, l->size);
    if(r == ((struct AvahiStringList *)NULL))
    {
      avahi_string_list_free(r);
      return (struct AvahiStringList *)(void *)0;
    }

  }
  struct AvahiStringList *return_value_avahi_string_list_reverse_1;
  return_value_avahi_string_list_reverse_1=avahi_string_list_reverse(r);
  return return_value_avahi_string_list_reverse_1;
}

// avahi_string_list_equal
// file strlst.c line 235
signed int avahi_string_list_equal(const struct AvahiStringList *a, const struct AvahiStringList *b)
{
  signed int return_value_memcmp_1;
  while((_Bool)1)
  {
    if(a == ((const struct AvahiStringList *)NULL) && b == ((const struct AvahiStringList *)NULL))
      return 1;

    if(a == ((const struct AvahiStringList *)NULL) || b == ((const struct AvahiStringList *)NULL))
      return 0;

    if(!(a->size == b->size))
      return 0;

    if(!(a->size == 0ul))
    {
      return_value_memcmp_1=memcmp((const void *)a->text, (const void *)b->text, a->size);
      if(!(return_value_memcmp_1 == 0))
        return 0;

    }

    a = a->next;
    b = b->next;
  }
}

// avahi_string_list_find
// file strlst.c line 378
struct AvahiStringList * avahi_string_list_find(struct AvahiStringList *l, const char *key)
{
  unsigned long int n;
  /* assertion key */
  assert(key != ((const char *)NULL));
  n=strlen(key);
  for( ; !(l == ((struct AvahiStringList *)NULL)); l = l->next)
  {
    signed int return_value_strcasecmp_1;
    return_value_strcasecmp_1=strcasecmp((char *)l->text, key);
    if(return_value_strcasecmp_1 == 0)
      return l;

    signed int return_value_strncasecmp_2;
    return_value_strncasecmp_2=strncasecmp((char *)l->text, key, n);
    if(return_value_strncasecmp_2 == 0)
    {
      if((signed int)l->text[(signed long int)n] == 61)
        return l;

    }

  }
  return (struct AvahiStringList *)(void *)0;
}

// avahi_string_list_free
// file ../avahi-common/strlst.h line 64
void avahi_string_list_free(struct AvahiStringList *l)
{
  struct AvahiStringList *n;
  for( ; !(l == ((struct AvahiStringList *)NULL)); l = n)
  {
    n = l->next;
    avahi_free((void *)l);
  }
}

// avahi_string_list_get_next
// file strlst.c line 469
struct AvahiStringList * avahi_string_list_get_next(struct AvahiStringList *l)
{
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  return l->next;
}

// avahi_string_list_get_pair
// file strlst.c line 423
signed int avahi_string_list_get_pair(struct AvahiStringList *l, char **key, char **value, unsigned long int *size)
{
  char *e;
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  void *return_value_memchr_2;
  return_value_memchr_2=memchr((const void *)l->text, 61, l->size);
  e = (char *)return_value_memchr_2;
  if(e == ((char *)NULL))
  {
    if(!(key == ((char **)NULL)))
    {
      *key=avahi_strdup((char *)l->text);
      if(*key == ((char *)NULL))
        return -1;

    }

    if(!(value == ((char **)NULL)))
      *value = (char *)(void *)0;

    if(!(size == ((unsigned long int *)NULL)))
      *size = (unsigned long int)0;

  }

  else
  {
    unsigned long int n;
    if(!(key == ((char **)NULL)))
    {
      *key=avahi_strndup((char *)l->text, (unsigned long int)(e - (char *)l->text));
      if(*key == ((char *)NULL))
        return -1;

    }

    e = e + 1l;
    n = l->size - (unsigned long int)(e - (char *)l->text);
    if(!(value == ((char **)NULL)))
    {
      void *return_value_avahi_memdup_1;
      return_value_avahi_memdup_1=avahi_memdup((const void *)e, n + (unsigned long int)1);
      *value = (char *)return_value_avahi_memdup_1;
      if(*value == ((char *)NULL))
      {
        if(!(key == ((char **)NULL)))
          avahi_free((void *)*key);

        return -1;
      }

      (*value)[(signed long int)n] = (char)0;
    }

    if(!(size == ((unsigned long int *)NULL)))
      *size = n;

  }
  return 0;
}

// avahi_string_list_get_service_cookie
// file strlst.c line 484
unsigned int avahi_string_list_get_service_cookie(struct AvahiStringList *l)
{
  struct AvahiStringList *f;
  char *value = (char *)(void *)0;
  char *end = (char *)(void *)0;
  unsigned int ret;
  f=avahi_string_list_find(l, "org.freedesktop.Avahi.cookie");
  if(f == ((struct AvahiStringList *)NULL))
    return (unsigned int)0;

  else
  {
    signed int return_value_avahi_string_list_get_pair_1;
    return_value_avahi_string_list_get_pair_1=avahi_string_list_get_pair(f, (char **)(void *)0, &value, (unsigned long int *)(void *)0);
    if(value == ((char *)NULL) || !(return_value_avahi_string_list_get_pair_1 >= 0))
      return (unsigned int)0;

    else
    {
      signed long long int return_value_strtoll_2;
      return_value_strtoll_2=strtoll(value, &end, 0);
      ret = (unsigned int)return_value_strtoll_2;
      if(!(*value == 0))
      {
        if(end == ((char *)NULL))
          goto __CPROVER_DUMP_L3;

        if((signed int)*end == 0)
          goto __CPROVER_DUMP_L3;

        avahi_free((void *)value);
        return (unsigned int)0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        avahi_free((void *)value);
        return ret;
      }
    }
  }
}

// avahi_string_list_get_size
// file strlst.c line 479
unsigned long int avahi_string_list_get_size(struct AvahiStringList *l)
{
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  return l->size;
}

// avahi_string_list_get_text
// file strlst.c line 474
unsigned char * avahi_string_list_get_text(struct AvahiStringList *l)
{
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  return l->text;
}

// avahi_string_list_length
// file strlst.c line 317
unsigned int avahi_string_list_length(const struct AvahiStringList *l)
{
  unsigned int n = (unsigned int)0;
  for( ; !(l == ((const struct AvahiStringList *)NULL)); l = l->next)
    n = n + 1u;
  return n;
}

// avahi_string_list_new
// file strlst.c line 274
struct AvahiStringList * avahi_string_list_new(const char *txt, ...)
{
  void **va;
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  if(!(txt == ((const char *)NULL)))
  {
    r=avahi_string_list_add(r, txt);
    va = (void **)&txt;
    r=avahi_string_list_add_many_va(r, va);
    va = ((void **)NULL);
  }

  return r;
}

// avahi_string_list_new_from_array
// file strlst.c line 305
struct AvahiStringList * avahi_string_list_new_from_array(const char **array, signed int length)
{
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  signed int i;
  /* assertion array */
  assert(array != ((const char **)NULL));
  i = 0;
  signed int tmp_if_expr_1;
  do
  {
    if(length >= 0)
      tmp_if_expr_1 = (signed int)(i < length);

    else
      tmp_if_expr_1 = (signed int)!(!(array[(signed long int)i] != ((const char *)NULL)));
    if(tmp_if_expr_1 == 0)
      break;

    r=avahi_string_list_add(r, array[(signed long int)i]);
    i = i + 1;
  }
  while((_Bool)1);
  return r;
}

// avahi_string_list_new_va
// file ../avahi-common/strlst.h line 55
struct AvahiStringList * avahi_string_list_new_va(void **va)
{
  struct AvahiStringList *return_value_avahi_string_list_add_many_va_1;
  return_value_avahi_string_list_add_many_va_1=avahi_string_list_add_many_va((struct AvahiStringList *)(void *)0, va);
  return return_value_avahi_string_list_add_many_va_1;
}

// avahi_string_list_parse
// file strlst.c line 69
signed int avahi_string_list_parse(const void *data, unsigned long int size, struct AvahiStringList **ret)
{
  const unsigned char *c;
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  /* assertion data */
  assert(data != NULL);
  /* assertion ret */
  assert(ret != ((struct AvahiStringList **)NULL));
  c = (const unsigned char *)data;
  const unsigned char *tmp_post_1;
  while(size >= 1ul)
  {
    unsigned long int k;
    tmp_post_1 = c;
    c = c + 1l;
    k = (unsigned long int)*tmp_post_1;
    size = size - 1ul;
    if(!(size >= k))
      goto fail;

    if(k >= 1ul)
    {
      struct AvahiStringList *n;
      n=avahi_string_list_add_arbitrary(r, c, k);
      if(n == ((struct AvahiStringList *)NULL))
        goto fail;

      r = n;
    }

    c = c + (signed long int)k;
    size = size - k;
  }
  *ret = r;
  return 0;

fail:
  ;
  avahi_string_list_free(r);
  return -1;
}

// avahi_string_list_reverse
// file ../avahi-common/strlst.h line 130
struct AvahiStringList * avahi_string_list_reverse(struct AvahiStringList *l)
{
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  struct AvahiStringList *n;
  for( ; !(l == ((struct AvahiStringList *)NULL)); l = n)
  {
    n = l->next;
    l->next = r;
    r = l;
  }
  return r;
}

// avahi_string_list_serialize
// file strlst.c line 168
unsigned long int avahi_string_list_serialize(struct AvahiStringList *l, void *data, unsigned long int size)
{
  unsigned long int used = (unsigned long int)0;
  unsigned char *tmp_post_1;
  if(!(data == NULL))
  {
    struct AvahiStringList *avahi_string_list_serialize__1__1__n;
    unsigned char *c;
    l=avahi_string_list_reverse(l);
    c = (unsigned char *)data;
    avahi_string_list_serialize__1__1__n = l;
    for( ; size >= 2ul && !(avahi_string_list_serialize__1__1__n == ((struct AvahiStringList *)NULL)); avahi_string_list_serialize__1__1__n = avahi_string_list_serialize__1__1__n->next)
    {
      unsigned long int k = avahi_string_list_serialize__1__1__n->size;
      if(!(k == 0ul))
      {
        if(k >= 256ul)
          k = (unsigned long int)255;

        if(!(size + 18446744073709551615ul >= k))
          k = size - (unsigned long int)1;

        tmp_post_1 = c;
        c = c + 1l;
        *tmp_post_1 = (unsigned char)k;
        memcpy((void *)c, (const void *)avahi_string_list_serialize__1__1__n->text, k);
        c = c + (signed long int)k;
        used = used + (unsigned long int)1 + k;
        size = size - ((unsigned long int)1 + k);
      }

    }
    l=avahi_string_list_reverse(l);
    if(used == 0ul && size >= 1ul)
    {
      *((unsigned char *)data) = (unsigned char)0;
      used = (unsigned long int)1;
    }

  }

  else
  {
    struct AvahiStringList *n = l;
    for( ; !(n == ((struct AvahiStringList *)NULL)); n = n->next)
    {
      unsigned long int avahi_string_list_serialize__1__2__1__1__k = n->size;
      if(!(avahi_string_list_serialize__1__2__1__1__k == 0ul))
      {
        if(avahi_string_list_serialize__1__2__1__1__k >= 256ul)
          avahi_string_list_serialize__1__2__1__1__k = (unsigned long int)255;

        used = used + (unsigned long int)1 + avahi_string_list_serialize__1__2__1__1__k;
      }

    }
    if(used == 0ul)
      used = (unsigned long int)1;

  }
  return used;
}

// avahi_string_list_to_string
// file strlst.c line 131
char * avahi_string_list_to_string(struct AvahiStringList *l)
{
  struct AvahiStringList *n;
  unsigned long int s = (unsigned long int)0;
  char *t;
  char *e;
  n = l;
  for( ; !(n == ((struct AvahiStringList *)NULL)); n = n->next)
  {
    if(!(n == l))
      s = s + 1ul;

    s = s + n->size + (unsigned long int)2;
  }
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link1_link1((unsigned int)(s + (unsigned long int)1), sizeof(char) /*1ul*/ );
  e = (char *)return_value_avahi_new_internal_1;
  t = e;
  char *tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  if(t == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    l=avahi_string_list_reverse(l);
    n = l;
    for( ; !(n == ((struct AvahiStringList *)NULL)); n = n->next)
    {
      if(!(n == l))
      {
        tmp_post_2 = e;
        e = e + 1l;
        *tmp_post_2 = (char)32;
      }

      tmp_post_3 = e;
      e = e + 1l;
      *tmp_post_3 = (char)34;
      strncpy(e, (char *)n->text, n->size);
      e[(signed long int)n->size] = (char)0;
      e=strchr(e, 0);
      tmp_post_4 = e;
      e = e + 1l;
      *tmp_post_4 = (char)34;
      /* assertion e */
      assert(e != ((char *)NULL));
    }
    l=avahi_string_list_reverse(l);
    *e = (char)0;
    return t;
  }
}

// avahi_strndup
// file malloc.c line 175
char * avahi_strndup(const char *s, unsigned long int max)
{
  char *r;
  unsigned long int size;
  const char *p;
  _Bool tmp_if_expr_1;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    p = s;
    size = (unsigned long int)0;
    do
    {
      if(!(size >= max))
        tmp_if_expr_1 = *p != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      p = p + 1l;
      size = size + 1ul;
    }
    while((_Bool)1);
    void *return_value_avahi_new_internal_2;
    return_value_avahi_new_internal_2=avahi_new_internal_link5((unsigned int)(size + (unsigned long int)1), sizeof(char) /*1ul*/ );
    r = (char *)return_value_avahi_new_internal_2;
    if(r == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      memcpy((void *)r, (const void *)s, size);
      r[(signed long int)size] = (char)0;
      return r;
    }
  }
}

// avahi_threaded_poll_free
// file thread-watch.c line 107
void avahi_threaded_poll_free(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  _Bool tmp_if_expr_3;
  unsigned long int return_value_pthread_self_1;
  signed int return_value_pthread_equal_2;
  if(p->thread_running == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_pthread_self_1=pthread_self();
    return_value_pthread_equal_2=pthread_equal(return_value_pthread_self_1, p->thread_id);
    tmp_if_expr_3 = !(return_value_pthread_equal_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  /* assertion !p->thread_running || !pthread_equal(pthread_self(), p->thread_id) */
  assert(tmp_if_expr_3);
  if(!(p->thread_running == 0))
    avahi_threaded_poll_stop(p);

  if(!(p->simple_poll == ((struct AvahiSimplePoll *)NULL)))
    avahi_simple_poll_free(p->simple_poll);

  pthread_mutex_destroy(&p->mutex);
  avahi_free((void *)p);
}

// avahi_threaded_poll_get
// file thread-watch.c line 123
const struct AvahiPoll * avahi_threaded_poll_get(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  const struct AvahiPoll *return_value_avahi_simple_poll_get_1;
  return_value_avahi_simple_poll_get_1=avahi_simple_poll_get(p->simple_poll);
  return return_value_avahi_simple_poll_get_1;
}

// avahi_threaded_poll_lock
// file thread-watch.c line 170
void avahi_threaded_poll_lock(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  _Bool tmp_if_expr_3;
  unsigned long int return_value_pthread_self_1;
  signed int return_value_pthread_equal_2;
  if(p->thread_running == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_pthread_self_1=pthread_self();
    return_value_pthread_equal_2=pthread_equal(return_value_pthread_self_1, p->thread_id);
    tmp_if_expr_3 = !(return_value_pthread_equal_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  /* assertion !p->thread_running || !pthread_equal(pthread_self(), p->thread_id) */
  assert(tmp_if_expr_3);
  pthread_mutex_lock(&p->mutex);
}

// avahi_threaded_poll_new
// file thread-watch.c line 77
struct AvahiThreadedPoll * avahi_threaded_poll_new(void)
{
  struct AvahiThreadedPoll *p;
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link3_link1((unsigned int)1, sizeof(struct AvahiThreadedPoll) /*64ul*/ );
  p = (struct AvahiThreadedPoll *)return_value_avahi_new_internal_1;
  if(!(p == ((struct AvahiThreadedPoll *)NULL)))
  {
    p->simple_poll=avahi_simple_poll_new();
    if(p->simple_poll == ((struct AvahiSimplePoll *)NULL))
      goto fail;

    pthread_mutex_init(&p->mutex, (const union anonymous_26 *)(void *)0);
    avahi_simple_poll_set_func(p->simple_poll, poll_func, (void *)&p->mutex);
    p->thread_running = 0;
    return p;
  }

  else
  {

  fail:
    ;
    if(!(p == ((struct AvahiThreadedPoll *)NULL)))
    {
      if(!(p->simple_poll == ((struct AvahiSimplePoll *)NULL)))
      {
        avahi_simple_poll_free(p->simple_poll);
        pthread_mutex_destroy(&p->mutex);
      }

      avahi_free((void *)p);
    }

    return (struct AvahiThreadedPoll *)(void *)0;
  }
}

// avahi_threaded_poll_quit
// file thread-watch.c line 161
void avahi_threaded_poll_quit(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  signed int return_value_pthread_equal_2;
  return_value_pthread_equal_2=pthread_equal(return_value_pthread_self_1, p->thread_id);
  /* assertion pthread_equal(pthread_self(), p->thread_id) */
  assert(return_value_pthread_equal_2 != 0);
  avahi_simple_poll_quit(p->simple_poll);
}

// avahi_threaded_poll_start
// file thread-watch.c line 129
signed int avahi_threaded_poll_start(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  /* assertion !p->thread_running */
  assert(!(p->thread_running != 0));
  signed int return_value_pthread_create_1;
  return_value_pthread_create_1=pthread_create(&p->thread_id, (const union pthread_attr_t *)(void *)0, thread, (void *)p);
  if(!(return_value_pthread_create_1 >= 0))
    return -1;

  else
  {
    p->thread_running = 1;
    return 0;
  }
}

// avahi_threaded_poll_stop
// file thread-watch.c line 142
signed int avahi_threaded_poll_stop(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  if(p->thread_running == 0)
    return -1;

  else
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    signed int return_value_pthread_equal_2;
    return_value_pthread_equal_2=pthread_equal(return_value_pthread_self_1, p->thread_id);
    /* assertion !pthread_equal(pthread_self(), p->thread_id) */
    assert(!(return_value_pthread_equal_2 != 0));
    pthread_mutex_lock(&p->mutex);
    avahi_simple_poll_quit(p->simple_poll);
    pthread_mutex_unlock(&p->mutex);
    pthread_join(p->thread_id, (void **)(void *)0);
    p->thread_running = 0;
    return p->retval;
  }
}

// avahi_threaded_poll_unlock
// file thread-watch.c line 179
void avahi_threaded_poll_unlock(struct AvahiThreadedPoll *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll *)NULL));
  _Bool tmp_if_expr_3;
  unsigned long int return_value_pthread_self_1;
  signed int return_value_pthread_equal_2;
  if(p->thread_running == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_pthread_self_1=pthread_self();
    return_value_pthread_equal_2=pthread_equal(return_value_pthread_self_1, p->thread_id);
    tmp_if_expr_3 = !(return_value_pthread_equal_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  /* assertion !p->thread_running || !pthread_equal(pthread_self(), p->thread_id) */
  assert(tmp_if_expr_3);
  pthread_mutex_unlock(&p->mutex);
}

// avahi_timeval_add
// file timeval.c line 59
struct timeval * avahi_timeval_add(struct timeval *a, signed long int usec)
{
  signed long int u;
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  u = usec + a->tv_usec;
  if(!(u >= 0l))
  {
    a->tv_usec = (signed long int)((signed long int)1000000 + u % (signed long int)1000000);
    a->tv_sec = a->tv_sec + (signed long int)((signed long int)-1 + u / (signed long int)1000000);
  }

  else
  {
    a->tv_usec = (signed long int)(u % (signed long int)1000000);
    a->tv_sec = a->tv_sec + (signed long int)(u / (signed long int)1000000);
  }
  return a;
}

// avahi_timeval_compare
// file timeval.c line 30
signed int avahi_timeval_compare(struct timeval *a, struct timeval *b)
{
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  /* assertion b */
  assert(b != ((struct timeval *)NULL));
  if(!(a->tv_sec >= b->tv_sec))
    return -1;

  else
    if(!(b->tv_sec >= a->tv_sec))
      return 1;

    else
      if(!(a->tv_usec >= b->tv_usec))
        return -1;

      else
        if(!(b->tv_usec >= a->tv_usec))
          return 1;

        else
          return 0;
}

// avahi_timeval_diff
// file timeval.c line 49
signed long int avahi_timeval_diff(struct timeval *a, struct timeval *b)
{
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  /* assertion b */
  assert(b != ((struct timeval *)NULL));
  signed int return_value_avahi_timeval_compare_2;
  return_value_avahi_timeval_compare_2=avahi_timeval_compare(a, b);
  signed long int return_value_avahi_timeval_diff_1;
  if(!(return_value_avahi_timeval_compare_2 >= 0))
  {
    return_value_avahi_timeval_diff_1=avahi_timeval_diff(b, a);
    return -return_value_avahi_timeval_diff_1;
  }

  else
    return (((signed long int)a->tv_sec - b->tv_sec) * (signed long int)1000000 + a->tv_usec) - b->tv_usec;
}

// avahi_unescape_label
// file domain.c line 41
char * avahi_unescape_label(const char **name, char *dest, unsigned long int size)
{
  unsigned int i = (unsigned int)0;
  char *d;
  /* assertion dest */
  assert(dest != ((char *)NULL));
  /* assertion size > 0 */
  assert(size > (unsigned long int)0);
  /* assertion name */
  assert(name != ((const char **)NULL));
  d = dest;
  _Bool tmp_if_expr_8;
  char *tmp_post_1;
  const char *tmp_post_2;
  const unsigned short int **return_value___ctype_b_loc_7;
  _Bool tmp_if_expr_5;
  const unsigned short int **return_value___ctype_b_loc_4;
  char *tmp_post_6;
  char *tmp_post_9;
  const char *tmp_post_10;
  while((_Bool)1)
  {
    if((unsigned long int)i >= size)
      return (char *)(void *)0;

    if((signed int)*(*name) == 46)
    {
      *name = *name + 1l;
      break;
    }

    if((signed int)*(*name) == 0)
      break;

    if((signed int)*(*name) == 92)
    {
      *name = *name + 1l;
      if((signed int)*(*name) == 0)
        return (char *)(void *)0;

      else
      {
        if((signed int)*(*name) == 92)
          tmp_if_expr_8 = (_Bool)1;

        else
          tmp_if_expr_8 = (signed int)*(*name) == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_8)
        {
          tmp_post_1 = d;
          d = d + 1l;
          tmp_post_2 = *name;
          *name = *name + 1l;
          *tmp_post_1 = *tmp_post_2;
          i = i + 1u;
        }

        else
        {
          return_value___ctype_b_loc_7=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)*(*name)]) == 0))
          {
            signed int n;
            const unsigned short int **return_value___ctype_b_loc_3;
            return_value___ctype_b_loc_3=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)(*name)[1l]]) == 0)
              tmp_if_expr_5 = (_Bool)1;

            else
            {
              return_value___ctype_b_loc_4=__ctype_b_loc();
              tmp_if_expr_5 = !(((signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(*name)[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_5)
              return (char *)(void *)0;

            n = (signed int)(unsigned char)((signed int)*(*name) - 48) * 100 + (signed int)(unsigned char)((signed int)(*name)[(signed long int)1] - 48) * 10 + (signed int)(unsigned char)((signed int)(*name)[(signed long int)2] - 48);
            if(n == 0 || n >= 256)
              return (char *)(void *)0;

            tmp_post_6 = d;
            d = d + 1l;
            *tmp_post_6 = (char)n;
            i = i + 1u;
            *name = *name + (signed long int)3;
          }

          else
            return (char *)(void *)0;
        }
      }
    }

    else
    {
      tmp_post_9 = d;
      d = d + 1l;
      tmp_post_10 = *name;
      *name = *name + 1l;
      *tmp_post_9 = *tmp_post_10;
      i = i + 1u;
    }
  }
  /* assertion i < size */
  assert((unsigned long int)i < size);
  *d = (char)0;
  const char *return_value_avahi_utf8_valid_11;
  return_value_avahi_utf8_valid_11=avahi_utf8_valid(dest);
  if(return_value_avahi_utf8_valid_11 == ((const char *)NULL))
    return (char *)(void *)0;

  else
    return dest;
}

// avahi_utf8_valid
// file utf8.h line 29
const char * avahi_utf8_valid(const char *str)
{
  unsigned int val = (unsigned int)0;
  unsigned int min = (unsigned int)0;
  const char *p = str;
  for( ; !(*p == 0); p = p + 1l)
  {
    if((signed int)*((const unsigned char *)p) >= 128)
    {
      if((0xe0 & (signed int)*((const unsigned char *)p)) == 0xc0)
      {
        if((0x1e & (signed int)*((const unsigned char *)p)) == 0)
          goto error;

        p = p + 1l;
        if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
          goto error;

      }

      else
      {
        if((0xf0 & (signed int)*((const unsigned char *)p)) == 0xe0)
        {
          min = (unsigned int)(1 << 11);
          val = (unsigned int)((signed int)*((const unsigned char *)p) & 0x0f);
          goto TWO_REMAINING;
        }

        else
          if((0xf8 & (signed int)*((const unsigned char *)p)) == 0xf0)
          {
            min = (unsigned int)(1 << 16);
            val = (unsigned int)((signed int)*((const unsigned char *)p) & 0x07);
          }

          else
            goto error;
        p = p + 1l;
        do
        {
          if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
            goto error;

          val = val << 6;
          val = val | (unsigned int)((signed int)*((const unsigned char *)p) & 0x3f);
        }
        while((_Bool)0);

      TWO_REMAINING:
        ;
        p = p + 1l;
        do
        {
          if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
            goto error;

          val = val << 6;
          val = val | (unsigned int)((signed int)*((const unsigned char *)p) & 0x3f);
        }
        while((_Bool)0);
        p = p + 1l;
        do
        {
          if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
            goto error;

          val = val << 6;
          val = val | (unsigned int)((signed int)*((const unsigned char *)p) & 0x3f);
        }
        while((_Bool)0);
        if(!(val >= min))
          goto error;

        if((65534u & val) == 65534u || (0xFFFFF800 & val) == 55296u || val >= 1114112u || !(val >= 65008u) && val >= 64976u)
          goto error;

      }
      goto __CPROVER_DUMP_L13;

    error:
      ;
      return (const char *)(void *)0;
    }


  __CPROVER_DUMP_L13:
    ;
  }
  return str;
}

// avahi_xdg_config_open
// file xdg-config.h line 25
struct _IO_FILE * avahi_xdg_config_open(const char *filename)
{
  struct _IO_FILE *f;
  const char *e;
  const char *d;
  char fn[4096l];
  char *p = (char *)(void *)0;
  char buf[2048l];
  char *s = (char *)(void *)0;
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  e=getenv("XDG_CONFIG_HOME");
  _Bool tmp_if_expr_1;
  if(!(e == ((const char *)NULL)))
    tmp_if_expr_1 = *e != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    p = fn;
    snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", e, filename);
  }

  else
  {
    e=getenv("HOME");
    if(!(e == ((const char *)NULL)))
    {
      if(!(*e == 0))
      {
        p = fn;
        snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s/.config/%s", e, filename);
      }

    }

  }
  signed int *return_value___errno_location_2;
  if(!(p == ((char *)NULL)))
  {
    f=fopen(p, "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
      return f;

    else
    {
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 2))
        return (struct _IO_FILE *)(void *)0;

    }
  }

  d=getenv("XDG_CONFIG_DIRS");
  _Bool tmp_if_expr_3;
  if(d == ((const char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = !(*d != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
    d = "/etc/xdg";

  snprintf(buf, sizeof(char [2048l]) /*2048ul*/ , "%s", d);
  e=strtok_r(buf, ":", &s);
  while(!(e == ((const char *)NULL)))
  {
    snprintf(fn, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", e, filename);
    f=fopen(fn, "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
      return f;

    e=strtok_r((char *)(void *)0, ":", &s);
  }
  return (struct _IO_FILE *)(void *)0;
}

// check_version
// file client.c line 351
static signed int check_version(struct AvahiClient *client, signed int *ret_error)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  unsigned int version;
  signed int e = -24;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  dbus_error_init(&error);
  message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetAPIVersion");
  _Bool tmp_if_expr_14;
  unsigned int return_value_dbus_error_is_set_13;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  _Bool tmp_if_expr_12;
  unsigned int return_value_dbus_error_is_set_11;
  if(!(message == ((struct DBusMessage *)NULL)))
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr_14 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_13=dbus_error_is_set(&error);
      tmp_if_expr_14 = return_value_dbus_error_is_set_13 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_14)
    {
      char *version_str;
      unsigned int return_value_dbus_error_is_set_1;
      return_value_dbus_error_is_set_1=dbus_error_is_set(&error);
      if(return_value_dbus_error_is_set_1 == 0u)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_strcmp_2=strcmp(error.name, "org.freedesktop.DBus.Error.UnknownMethod");
        tmp_if_expr_3 = return_value_strcmp_2 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        goto fail;

      dbus_message_unref(message);
      if(!(reply == ((struct DBusMessage *)NULL)))
        dbus_message_unref(reply);

      dbus_error_free(&error);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetVersionString");
      if(message == ((struct DBusMessage *)NULL))
        goto fail;

      reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
      if(reply == ((struct DBusMessage *)NULL))
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
        tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        goto fail;

      unsigned int return_value_dbus_message_get_args_6;
      return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)115, &version_str, (signed int)0);
      if(return_value_dbus_message_get_args_6 == 0u)
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
        tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8)
        goto fail;

      signed int return_value_strcmp_9;
      return_value_strcmp_9=strcmp(version_str, "avahi 0.6");
      version = (unsigned int)(return_value_strcmp_9 == 0 ? 0x0201 : 0x0000);
    }

    else
    {
      unsigned int return_value_dbus_message_get_args_10;
      return_value_dbus_message_get_args_10=dbus_message_get_args(reply, &error, (signed int)117, &version, (signed int)0);
      if(return_value_dbus_message_get_args_10 == 0u)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_11=dbus_error_is_set(&error);
        tmp_if_expr_12 = return_value_dbus_error_is_set_11 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
        goto fail;

    }
    if(!((65280u & version) == 512u) || !((255u & version) >= 1u))
    {
      e = -32;
      goto fail;
    }

    dbus_message_unref(message);
    dbus_message_unref(reply);
    return 0;
  }

  else
  {

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_15;
    return_value_dbus_error_is_set_15=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_15 == 0u))
    {
      e=avahi_error_dbus_to_number(error.name);
      dbus_error_free(&error);
    }

    if(!(ret_error == ((signed int *)NULL)))
      *ret_error = e;

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return e;
  }
}

// cleanup_timeouts
// file simple-watch.c line 304
static void cleanup_timeouts(struct AvahiSimplePoll *s, signed int all)
{
  struct AvahiTimeout *t;
  struct AvahiTimeout *next;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  t = s->timeouts;
  _Bool tmp_if_expr_1;
  for( ; !(t == ((struct AvahiTimeout *)NULL)); t = next)
  {
    next = t->timeouts_next;
    if(!(all == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = t->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      destroy_timeout(t);

  }
  s->timeout_req_cleanup = 0;
}

// cleanup_timeouts_link1
// file simple-watch.c line 304
static void cleanup_timeouts_link1(struct AvahiSimplePoll *s_link1, signed int all_link1)
{
  struct AvahiTimeout *t_link1;
  struct AvahiTimeout *next_link1;
  /* assertion s */
  assert(s_link1 != ((struct AvahiSimplePoll *)NULL));
  t_link1 = s_link1->timeouts;
  _Bool tmp_if_expr_1_link1;
  for( ; !(t_link1 == ((struct AvahiTimeout *)NULL)); t_link1 = next_link1)
  {
    next_link1 = t_link1->timeouts_next;
    if(!(all_link1 == 0))
      tmp_if_expr_1_link1 = (_Bool)1;

    else
      tmp_if_expr_1_link1 = t_link1->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link1)
      destroy_timeout_link1(t_link1);

  }
  s_link1->timeout_req_cleanup = 0;
}

// cleanup_watches
// file simple-watch.c line 230
static void cleanup_watches(struct AvahiSimplePoll *s, signed int all)
{
  struct AvahiWatch *w;
  struct AvahiWatch *next;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  w = s->watches;
  _Bool tmp_if_expr_1;
  for( ; !(w == ((struct AvahiWatch *)NULL)); w = next)
  {
    next = w->watches_next;
    if(!(all == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = w->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      destroy_watch(w);

  }
  s->timeout_req_cleanup = 0;
}

// cleanup_watches_link1
// file simple-watch.c line 230
static void cleanup_watches_link1(struct AvahiSimplePoll *s_link1, signed int all_link1)
{
  struct AvahiWatch *w_link1;
  struct AvahiWatch *next_link1;
  /* assertion s */
  assert(s_link1 != ((struct AvahiSimplePoll *)NULL));
  w_link1 = s_link1->watches;
  _Bool tmp_if_expr_1_link1;
  for( ; !(w_link1 == ((struct AvahiWatch *)NULL)); w_link1 = next_link1)
  {
    next_link1 = w_link1->watches_next;
    if(!(all_link1 == 0))
      tmp_if_expr_1_link1 = (_Bool)1;

    else
      tmp_if_expr_1_link1 = w_link1->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link1)
      destroy_watch_link1(w_link1);

  }
  s_link1->timeout_req_cleanup = 0;
}

// clear_wakeup
// file simple-watch.c line 105
static void clear_wakeup(struct AvahiSimplePoll *s)
{
  char c[10l];
  signed long int return_value_read_1;
  if(!(s->wakeup_issued == 0))
  {
    s->wakeup_issued = 0;
    do
    {
      return_value_read_1=read(s->wakeup_pipe[(signed long int)0], (void *)&c, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read_1 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// clear_wakeup_link1
// file simple-watch.c line 105
static void clear_wakeup_link1(struct AvahiSimplePoll *s_link1)
{
  char c_link1[10l];
  signed long int return_value_read_1_link1;
  if(!(s_link1->wakeup_issued == 0))
  {
    s_link1->wakeup_issued = 0;
    do
    {
      return_value_read_1_link1=read(s_link1->wakeup_pipe[(signed long int)0], (void *)&c_link1, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read_1_link1 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// client_callback
// file avahi-set-host-name.c line 56
static void client_callback(struct AvahiClient *c, enum anonymous_7 state, void *userdata)
{
  char *return_value_dgettext_1;
  signed int return_value_avahi_client_errno_2;
  const char *return_value_avahi_strerror_3;
  switch((signed int)state)
  {
    case AVAHI_CLIENT_FAILURE:
    {
      return_value_dgettext_1=dgettext("avahi", "Client failure, exiting: %s\n");
      return_value_avahi_client_errno_2=avahi_client_errno(c);
      return_value_avahi_strerror_3=avahi_strerror(return_value_avahi_client_errno_2);
      fprintf(stderr, return_value_dgettext_1, return_value_avahi_strerror_3);
      avahi_simple_poll_quit(simple_poll);
      break;
    }
    case AVAHI_CLIENT_S_REGISTERING:

    case AVAHI_CLIENT_S_RUNNING:

    case AVAHI_CLIENT_S_COLLISION:

    case AVAHI_CLIENT_CONNECTING:
      ;
    default:
      ;
  }
}

// client_set_state
// file client.c line 58
static void client_set_state(struct AvahiClient *client, enum anonymous_7 state)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  if(!(client->state == state))
  {
    client->state = state;
    switch((signed int)client->state)
    {
      case AVAHI_CLIENT_FAILURE:
        if(!(client->bus == ((struct DBusConnection *)NULL)))
        {
          dbus_connection_close(client->bus);
          dbus_connection_unref(client->bus);
          client->bus = (struct DBusConnection *)(void *)0;
        }

      case AVAHI_CLIENT_S_COLLISION:

      case AVAHI_CLIENT_S_REGISTERING:
      {
        avahi_free((void *)client->host_name);
        avahi_free((void *)client->host_name_fqdn);
        avahi_free((void *)client->domain_name);
        client->host_name = (char *)(void *)0;
        client->host_name_fqdn = (char *)(void *)0;
        client->domain_name = (char *)(void *)0;
      }
      case AVAHI_CLIENT_S_RUNNING:

      case AVAHI_CLIENT_CONNECTING:

      default:
        if(!(client->callback == ((void (*)(struct AvahiClient *, enum anonymous_7, void *))NULL)))
          client->callback(client, state, client->userdata);

    }
  }

}

// close_pipe_fds
// file sigint.c line 58
static void close_pipe_fds(void)
{
  if(pipe_fds[0l] >= 0)
    close(pipe_fds[(signed long int)0]);

  if(pipe_fds[1l] >= 0)
    close(pipe_fds[(signed long int)1]);

  pipe_fds[(signed long int)1] = -1;
  pipe_fds[(signed long int)0] = pipe_fds[(signed long int)1];
}

// connection_data_ref
// file ../avahi-common/dbus-watch-glue.c line 68
static struct anonymous_11 * connection_data_ref(struct anonymous_11 *d)
{
  /* assertion d */
  assert(d != ((struct anonymous_11 *)NULL));
  /* assertion d->ref >= 1 */
  assert(d->ref >= 1);
  d->ref = d->ref + 1;
  return d;
}

// connection_data_unref
// file ../avahi-common/dbus-watch-glue.c line 76
static void connection_data_unref(struct anonymous_11 *d)
{
  /* assertion d */
  assert(d != ((struct anonymous_11 *)NULL));
  /* assertion d->ref >= 1 */
  assert(d->ref >= 1);
  d->ref = d->ref - 1;
  if(!(d->ref >= 1))
  {
    d->poll_api->timeout_free(d->dispatch_timeout);
    avahi_free((void *)d);
  }

}

// defer_timeout_callback
// file browser.c line 83
static void defer_timeout_callback(struct AvahiTimeout *t, void *userdata)
{
  struct AvahiDomainBrowser *db = (struct AvahiDomainBrowser *)userdata;
  struct AvahiStringList *l;
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  db->client->poll_api->timeout_free(db->defer_timeout);
  db->defer_timeout = (struct AvahiTimeout *)(void *)0;
  domain_browser_ref(db);
  l = db->static_browse_domains;
  if(!(l == ((struct AvahiStringList *)NULL)))
  {
    if(db->ref >= 2)
    {
      db->callback(db, -1, -1, (enum anonymous_2)AVAHI_BROWSER_NEW, (char *)l->text, (enum anonymous_3)AVAHI_LOOKUP_RESULT_STATIC, db->userdata);
      l = l->next;
    }

  }

  avahi_domain_browser_free(db);
}

// destroy_timeout
// file simple-watch.c line 296
static void destroy_timeout(struct AvahiTimeout *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  do
  {
    struct AvahiTimeout **_head = &t->simple_poll->timeouts;
    struct AvahiTimeout *_item = t;
    /* assertion _item */
    assert(_item != ((struct AvahiTimeout *)NULL));
    if(!(_item->timeouts_next == ((struct AvahiTimeout *)NULL)))
      _item->timeouts_next->timeouts_prev = _item->timeouts_prev;

    if(!(_item->timeouts_prev == ((struct AvahiTimeout *)NULL)))
      _item->timeouts_prev->timeouts_next = _item->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->timeouts_next;
    }
    _item->timeouts_prev = (struct AvahiTimeout *)(void *)0;
    _item->timeouts_next = _item->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t);
}

// destroy_timeout_link1
// file simple-watch.c line 296
static void destroy_timeout_link1(struct AvahiTimeout *t_link1)
{
  /* assertion t */
  assert(t_link1 != ((struct AvahiTimeout *)NULL));
  do
  {
    struct AvahiTimeout **_head_link1 = &t_link1->simple_poll->timeouts;
    struct AvahiTimeout *_item_link1 = t_link1;
    /* assertion _item */
    assert(_item_link1 != ((struct AvahiTimeout *)NULL));
    if(!(_item_link1->timeouts_next == ((struct AvahiTimeout *)NULL)))
      _item_link1->timeouts_next->timeouts_prev = _item_link1->timeouts_prev;

    if(!(_item_link1->timeouts_prev == ((struct AvahiTimeout *)NULL)))
      _item_link1->timeouts_prev->timeouts_next = _item_link1->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head_link1 == _item_link1);
      *_head_link1 = _item_link1->timeouts_next;
    }
    _item_link1->timeouts_prev = (struct AvahiTimeout *)(void *)0;
    _item_link1->timeouts_next = _item_link1->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t_link1);
}

// destroy_watch
// file simple-watch.c line 218
static void destroy_watch(struct AvahiWatch *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch *)NULL));
  remove_pollfd(w);
  do
  {
    struct AvahiWatch **_head = &w->simple_poll->watches;
    struct AvahiWatch *_item = w;
    /* assertion _item */
    assert(_item != ((struct AvahiWatch *)NULL));
    if(!(_item->watches_next == ((struct AvahiWatch *)NULL)))
      _item->watches_next->watches_prev = _item->watches_prev;

    if(!(_item->watches_prev == ((struct AvahiWatch *)NULL)))
      _item->watches_prev->watches_next = _item->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->watches_next;
    }
    _item->watches_prev = (struct AvahiWatch *)(void *)0;
    _item->watches_next = _item->watches_prev;
  }
  while((_Bool)0);
  if(w->dead == 0)
    w->simple_poll->n_watches = w->simple_poll->n_watches - 1;

  avahi_free((void *)w);
}

// destroy_watch_link1
// file simple-watch.c line 218
static void destroy_watch_link1(struct AvahiWatch *w_link1)
{
  /* assertion w */
  assert(w_link1 != ((struct AvahiWatch *)NULL));
  remove_pollfd_link1(w_link1);
  do
  {
    struct AvahiWatch **_head_link1 = &w_link1->simple_poll->watches;
    struct AvahiWatch *_item_link1 = w_link1;
    /* assertion _item */
    assert(_item_link1 != ((struct AvahiWatch *)NULL));
    if(!(_item_link1->watches_next == ((struct AvahiWatch *)NULL)))
      _item_link1->watches_next->watches_prev = _item_link1->watches_prev;

    if(!(_item_link1->watches_prev == ((struct AvahiWatch *)NULL)))
      _item_link1->watches_prev->watches_next = _item_link1->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head_link1 == _item_link1);
      *_head_link1 = _item_link1->watches_next;
    }
    _item_link1->watches_prev = (struct AvahiWatch *)(void *)0;
    _item_link1->watches_next = _item_link1->watches_prev;
  }
  while((_Bool)0);
  if(w_link1->dead == 0)
    w_link1->simple_poll->n_watches = w_link1->simple_poll->n_watches - 1;

  avahi_free((void *)w_link1);
}

// dispatch_status
// file ../avahi-common/dbus-watch-glue.c line 310
static void dispatch_status(struct DBusConnection *connection, enum anonymous_10 new_status, void *userdata)
{
  struct anonymous_11 *d = (struct anonymous_11 *)userdata;
  if((signed int)new_status == DBUS_DISPATCH_DATA_REMAINS)
    request_dispatch(d, 1);

}

// dispatch_timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 97
static void dispatch_timeout_callback(struct AvahiTimeout *t, void *userdata)
{
  struct anonymous_11 *d = (struct anonymous_11 *)userdata;
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous_11 *)NULL));
  connection_data_ref(d);
  dbus_connection_ref(d->connection);
  enum anonymous_10 return_value_dbus_connection_dispatch_1;
  return_value_dbus_connection_dispatch_1=dbus_connection_dispatch(d->connection);
  if((signed int)return_value_dbus_connection_dispatch_1 == DBUS_DISPATCH_DATA_REMAINS)
    request_dispatch(d, 1);

  else
    request_dispatch(d, 0);
  dbus_connection_unref(d->connection);
  connection_data_unref(d);
}

// domain_browser_ref
// file browser.c line 77
static void domain_browser_ref(struct AvahiDomainBrowser *db)
{
  /* assertion db */
  assert(db != ((struct AvahiDomainBrowser *)NULL));
  /* assertion db->ref >= 1 */
  assert(db->ref >= 1);
  db->ref = db->ref + 1;
}

// drop_incomplete_utf8
// file alternative.c line 34
static void drop_incomplete_utf8(char *c)
{
  char *e;
  char *return_value_strchr_1;
  return_value_strchr_1=strchr(c, 0);
  e = return_value_strchr_1 - (signed long int)1;
  while(e >= c)
  {
    const char *return_value_avahi_utf8_valid_2;
    return_value_avahi_utf8_valid_2=avahi_utf8_valid(c);
    if(!(return_value_avahi_utf8_valid_2 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e & 128) != 0);
    *e = (char)0;
    e = e - 1l;
  }
}

// drop_incomplete_utf8_link1
// file alternative.c line 34
static void drop_incomplete_utf8_link1(char *c_link1)
{
  char *e_link1;
  char *return_value_strchr_1_link1;
  return_value_strchr_1_link1=strchr(c_link1, 0);
  e_link1 = return_value_strchr_1_link1 - (signed long int)1;
  while(e_link1 >= c_link1)
  {
    const char *return_value_avahi_utf8_valid_2_link1;
    return_value_avahi_utf8_valid_2_link1=avahi_utf8_valid(c_link1);
    if(!(return_value_avahi_utf8_valid_2_link1 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e_link1 & 128) != 0);
    *e_link1 = (char)0;
    e_link1 = e_link1 - 1l;
  }
}

// entry_group_simple_method_call
// file entrygroup.c line 188
static signed int entry_group_simple_method_call(struct AvahiEntryGroup *group, const char *method)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  struct AvahiClient *entry_group_simple_method_call__1__client;
  dbus_error_init(&error);
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  entry_group_simple_method_call__1__client = group->client;
  message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", method);
  _Bool tmp_if_expr_2;
  unsigned int return_value_dbus_error_is_set_1;
  unsigned int return_value_dbus_message_get_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  if(message == ((struct DBusMessage *)NULL))
    r=avahi_client_set_errno(entry_group_simple_method_call__1__client, -24);

  else
  {
    reply=dbus_connection_send_with_reply_and_block(entry_group_simple_method_call__1__client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_1=dbus_error_is_set(&error);
      tmp_if_expr_2 = return_value_dbus_error_is_set_1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      r=avahi_client_set_errno(entry_group_simple_method_call__1__client, -22);

    else
    {
      return_value_dbus_message_get_args_3=dbus_message_get_args(reply, &error, (signed int)0);
      if(return_value_dbus_message_get_args_3 == 0u)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
        tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        r=avahi_client_set_errno(entry_group_simple_method_call__1__client, -22);

      else
      {
        dbus_message_unref(message);
        dbus_message_unref(reply);
        return 0;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_6;
  return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_6 == 0u))
  {
    r=avahi_client_set_dbus_error(entry_group_simple_method_call__1__client, &error);
    dbus_error_free(&error);
  }

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return r;
}

// filter_func
// file client.c line 103
static enum anonymous_28 filter_func(struct DBusConnection *bus, struct DBusMessage *message, void *userdata)
{
  struct AvahiClient *filter_func__1__client = (struct AvahiClient *)userdata;
  struct DBusError error;
  /* assertion bus */
  assert(bus != ((struct DBusConnection *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  unsigned int return_value_dbus_message_is_signal_75;
  return_value_dbus_message_is_signal_75=dbus_message_is_signal(message, "org.freedesktop.DBus.Local", "Disconnected");
  unsigned int return_value_dbus_message_is_signal_74;
  unsigned int return_value_dbus_message_is_signal_73;
  _Bool tmp_if_expr_3;
  unsigned int return_value_dbus_error_is_set_2;
  _Bool tmp_if_expr_6;
  signed int return_value_avahi_client_is_connected_5;
  _Bool tmp_if_expr_4;
  signed int return_value_avahi_client_is_connected_72;
  unsigned int return_value_dbus_message_is_signal_71;
  _Bool tmp_if_expr_10;
  unsigned int return_value_dbus_error_is_set_9;
  unsigned int return_value_dbus_message_is_signal_70;
  signed int return_value_strcmp_11;
  _Bool tmp_if_expr_14;
  unsigned int return_value_dbus_error_is_set_13;
  unsigned int return_value_dbus_message_is_signal_69;
  enum anonymous_28 return_value_avahi_domain_browser_event_15;
  unsigned int return_value_dbus_message_is_signal_68;
  enum anonymous_28 return_value_avahi_domain_browser_event_16;
  unsigned int return_value_dbus_message_is_signal_67;
  enum anonymous_28 return_value_avahi_domain_browser_event_17;
  unsigned int return_value_dbus_message_is_signal_66;
  enum anonymous_28 return_value_avahi_domain_browser_event_18;
  unsigned int return_value_dbus_message_is_signal_65;
  enum anonymous_28 return_value_avahi_domain_browser_event_19;
  unsigned int return_value_dbus_message_is_signal_64;
  enum anonymous_28 return_value_avahi_service_type_browser_event_20;
  unsigned int return_value_dbus_message_is_signal_63;
  enum anonymous_28 return_value_avahi_service_type_browser_event_21;
  unsigned int return_value_dbus_message_is_signal_62;
  enum anonymous_28 return_value_avahi_service_type_browser_event_22;
  unsigned int return_value_dbus_message_is_signal_61;
  enum anonymous_28 return_value_avahi_service_type_browser_event_23;
  unsigned int return_value_dbus_message_is_signal_60;
  enum anonymous_28 return_value_avahi_service_type_browser_event_24;
  unsigned int return_value_dbus_message_is_signal_59;
  enum anonymous_28 return_value_avahi_service_browser_event_25;
  unsigned int return_value_dbus_message_is_signal_58;
  enum anonymous_28 return_value_avahi_service_browser_event_26;
  unsigned int return_value_dbus_message_is_signal_57;
  enum anonymous_28 return_value_avahi_service_browser_event_27;
  unsigned int return_value_dbus_message_is_signal_56;
  enum anonymous_28 return_value_avahi_service_browser_event_28;
  unsigned int return_value_dbus_message_is_signal_55;
  enum anonymous_28 return_value_avahi_service_browser_event_29;
  unsigned int return_value_dbus_message_is_signal_54;
  enum anonymous_28 return_value_avahi_service_resolver_event_30;
  unsigned int return_value_dbus_message_is_signal_53;
  enum anonymous_28 return_value_avahi_service_resolver_event_31;
  unsigned int return_value_dbus_message_is_signal_52;
  enum anonymous_28 return_value_avahi_host_name_resolver_event_32;
  unsigned int return_value_dbus_message_is_signal_51;
  enum anonymous_28 return_value_avahi_host_name_resolver_event_33;
  unsigned int return_value_dbus_message_is_signal_50;
  enum anonymous_28 return_value_avahi_address_resolver_event_34;
  unsigned int return_value_dbus_message_is_signal_49;
  enum anonymous_28 return_value_avahi_address_resolver_event_35;
  unsigned int return_value_dbus_message_is_signal_48;
  enum anonymous_28 return_value_avahi_record_browser_event_36;
  unsigned int return_value_dbus_message_is_signal_47;
  enum anonymous_28 return_value_avahi_record_browser_event_37;
  unsigned int return_value_dbus_message_is_signal_46;
  enum anonymous_28 return_value_avahi_record_browser_event_38;
  unsigned int return_value_dbus_message_is_signal_45;
  enum anonymous_28 return_value_avahi_record_browser_event_39;
  unsigned int return_value_dbus_message_is_signal_44;
  enum anonymous_28 return_value_avahi_record_browser_event_40;
  if(!(return_value_dbus_message_is_signal_75 == 0u))
  {
    avahi_client_set_errno(filter_func__1__client, -23);
    goto fail;
  }

  else
  {
    return_value_dbus_message_is_signal_74=dbus_message_is_signal(message, "org.freedesktop.DBus", "NameAcquired");
    if(return_value_dbus_message_is_signal_74 == 0u)
    {
      return_value_dbus_message_is_signal_73=dbus_message_is_signal(message, "org.freedesktop.DBus", "NameOwnerChanged");
      if(!(return_value_dbus_message_is_signal_73 == 0u))
      {
        char *name;
        char *old;
        char *new;
        unsigned int return_value_dbus_message_get_args_1;
        return_value_dbus_message_get_args_1=dbus_message_get_args(message, &error, (signed int)115, &name, (signed int)115, &old, (signed int)115, &new, (signed int)0);
        if(return_value_dbus_message_get_args_1 == 0u)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_2=dbus_error_is_set(&error);
          tmp_if_expr_3 = return_value_dbus_error_is_set_2 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          fprintf(stderr, "WARNING: Failed to parse NameOwnerChanged signal: %s\n", error.message);
          avahi_client_set_errno(filter_func__1__client, -22);
          goto fail;
        }

        signed int return_value_strcmp_7;
        return_value_strcmp_7=strcmp(name, "org.freedesktop.Avahi");
        if(return_value_strcmp_7 == 0)
        {
          if(!(*old == 0))
          {
            return_value_avahi_client_is_connected_5=avahi_client_is_connected(filter_func__1__client);
            tmp_if_expr_6 = return_value_avahi_client_is_connected_5 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_6 = (_Bool)0;
          if(tmp_if_expr_6)
          {
            avahi_client_set_errno(filter_func__1__client, -23);
            goto fail;
          }

          else
            if((signed int)filter_func__1__client->state == AVAHI_CLIENT_CONNECTING)
            {
              if(old == ((char *)NULL))
                tmp_if_expr_4 = (_Bool)1;

              else
                tmp_if_expr_4 = (signed int)*old == 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_4)
              {
                signed int ret;
                ret=init_server(filter_func__1__client, (signed int *)(void *)0);
                if(!(ret >= 0))
                {
                  avahi_client_set_errno(filter_func__1__client, ret);
                  goto fail;
                }

              }

            }

        }

      }

      else
      {
        return_value_avahi_client_is_connected_72=avahi_client_is_connected(filter_func__1__client);
        if(!(return_value_avahi_client_is_connected_72 == 0))
        {
          return_value_dbus_message_is_signal_71=dbus_message_is_signal(message, "org.freedesktop.Avahi.Server", "StateChanged");
          if(!(return_value_dbus_message_is_signal_71 == 0u))
          {
            signed int state;
            char *e = (char *)(void *)0;
            signed int c;
            unsigned int return_value_dbus_message_get_args_8;
            return_value_dbus_message_get_args_8=dbus_message_get_args(message, &error, (signed int)105, &state, (signed int)115, &e, (signed int)0);
            if(return_value_dbus_message_get_args_8 == 0u)
              tmp_if_expr_10 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
              tmp_if_expr_10 = return_value_dbus_error_is_set_9 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_10)
            {
              fprintf(stderr, "WARNING: Failed to parse Server.StateChanged signal: %s\n", error.message);
              avahi_client_set_errno(filter_func__1__client, -22);
              goto fail;
            }

            c=avahi_error_dbus_to_number(e);
            if(!(c == 0))
              avahi_client_set_errno(filter_func__1__client, c);

            client_set_state(filter_func__1__client, (enum anonymous_7)state);
          }

          else
          {
            return_value_dbus_message_is_signal_70=dbus_message_is_signal(message, "org.freedesktop.Avahi.EntryGroup", "StateChanged");
            if(!(return_value_dbus_message_is_signal_70 == 0u))
            {
              const char *path;
              struct AvahiEntryGroup *g;
              path=dbus_message_get_path(message);
              g = filter_func__1__client->groups;
              for( ; !(g == ((struct AvahiEntryGroup *)NULL)); g = g->groups_next)
              {
                return_value_strcmp_11=strcmp(g->path, path);
                if(return_value_strcmp_11 == 0)
                  break;

              }
              if(!(g == ((struct AvahiEntryGroup *)NULL)))
              {
                signed int filter_func__1__6__2__state;
                char *filter_func__1__6__2__e;
                signed int filter_func__1__6__2__c;
                unsigned int return_value_dbus_message_get_args_12;
                return_value_dbus_message_get_args_12=dbus_message_get_args(message, &error, (signed int)105, &filter_func__1__6__2__state, (signed int)115, &filter_func__1__6__2__e, (signed int)0);
                if(return_value_dbus_message_get_args_12 == 0u)
                  tmp_if_expr_14 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set_13=dbus_error_is_set(&error);
                  tmp_if_expr_14 = return_value_dbus_error_is_set_13 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_14)
                {
                  fprintf(stderr, "WARNING: Failed to parse EntryGroup.StateChanged signal: %s\n", error.message);
                  avahi_client_set_errno(filter_func__1__client, -22);
                  goto fail;
                }

                filter_func__1__6__2__c=avahi_error_dbus_to_number(filter_func__1__6__2__e);
                if(!(filter_func__1__6__2__c == 0))
                  avahi_client_set_errno(filter_func__1__client, filter_func__1__6__2__c);

                avahi_entry_group_set_state(g, (enum anonymous_27)filter_func__1__6__2__state);
              }

            }

            else
            {
              return_value_dbus_message_is_signal_69=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "ItemNew");
              if(!(return_value_dbus_message_is_signal_69 == 0u))
              {
                return_value_avahi_domain_browser_event_15=avahi_domain_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_NEW, message);
                return return_value_avahi_domain_browser_event_15;
              }

              else
              {
                return_value_dbus_message_is_signal_68=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "ItemRemove");
                if(!(return_value_dbus_message_is_signal_68 == 0u))
                {
                  return_value_avahi_domain_browser_event_16=avahi_domain_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_REMOVE, message);
                  return return_value_avahi_domain_browser_event_16;
                }

                else
                {
                  return_value_dbus_message_is_signal_67=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "CacheExhausted");
                  if(!(return_value_dbus_message_is_signal_67 == 0u))
                  {
                    return_value_avahi_domain_browser_event_17=avahi_domain_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                    return return_value_avahi_domain_browser_event_17;
                  }

                  else
                  {
                    return_value_dbus_message_is_signal_66=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "AllForNow");
                    if(!(return_value_dbus_message_is_signal_66 == 0u))
                    {
                      return_value_avahi_domain_browser_event_18=avahi_domain_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_ALL_FOR_NOW, message);
                      return return_value_avahi_domain_browser_event_18;
                    }

                    else
                    {
                      return_value_dbus_message_is_signal_65=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "Failure");
                      if(!(return_value_dbus_message_is_signal_65 == 0u))
                      {
                        return_value_avahi_domain_browser_event_19=avahi_domain_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_FAILURE, message);
                        return return_value_avahi_domain_browser_event_19;
                      }

                      else
                      {
                        return_value_dbus_message_is_signal_64=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "ItemNew");
                        if(!(return_value_dbus_message_is_signal_64 == 0u))
                        {
                          return_value_avahi_service_type_browser_event_20=avahi_service_type_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_NEW, message);
                          return return_value_avahi_service_type_browser_event_20;
                        }

                        else
                        {
                          return_value_dbus_message_is_signal_63=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "ItemRemove");
                          if(!(return_value_dbus_message_is_signal_63 == 0u))
                          {
                            return_value_avahi_service_type_browser_event_21=avahi_service_type_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_REMOVE, message);
                            return return_value_avahi_service_type_browser_event_21;
                          }

                          else
                          {
                            return_value_dbus_message_is_signal_62=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "CacheExhausted");
                            if(!(return_value_dbus_message_is_signal_62 == 0u))
                            {
                              return_value_avahi_service_type_browser_event_22=avahi_service_type_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                              return return_value_avahi_service_type_browser_event_22;
                            }

                            else
                            {
                              return_value_dbus_message_is_signal_61=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "AllForNow");
                              if(!(return_value_dbus_message_is_signal_61 == 0u))
                              {
                                return_value_avahi_service_type_browser_event_23=avahi_service_type_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_ALL_FOR_NOW, message);
                                return return_value_avahi_service_type_browser_event_23;
                              }

                              else
                              {
                                return_value_dbus_message_is_signal_60=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "Failure");
                                if(!(return_value_dbus_message_is_signal_60 == 0u))
                                {
                                  return_value_avahi_service_type_browser_event_24=avahi_service_type_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_FAILURE, message);
                                  return return_value_avahi_service_type_browser_event_24;
                                }

                                else
                                {
                                  return_value_dbus_message_is_signal_59=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "ItemNew");
                                  if(!(return_value_dbus_message_is_signal_59 == 0u))
                                  {
                                    return_value_avahi_service_browser_event_25=avahi_service_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_NEW, message);
                                    return return_value_avahi_service_browser_event_25;
                                  }

                                  else
                                  {
                                    return_value_dbus_message_is_signal_58=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "ItemRemove");
                                    if(!(return_value_dbus_message_is_signal_58 == 0u))
                                    {
                                      return_value_avahi_service_browser_event_26=avahi_service_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_REMOVE, message);
                                      return return_value_avahi_service_browser_event_26;
                                    }

                                    else
                                    {
                                      return_value_dbus_message_is_signal_57=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "CacheExhausted");
                                      if(!(return_value_dbus_message_is_signal_57 == 0u))
                                      {
                                        return_value_avahi_service_browser_event_27=avahi_service_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                                        return return_value_avahi_service_browser_event_27;
                                      }

                                      else
                                      {
                                        return_value_dbus_message_is_signal_56=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "AllForNow");
                                        if(!(return_value_dbus_message_is_signal_56 == 0u))
                                        {
                                          return_value_avahi_service_browser_event_28=avahi_service_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_ALL_FOR_NOW, message);
                                          return return_value_avahi_service_browser_event_28;
                                        }

                                        else
                                        {
                                          return_value_dbus_message_is_signal_55=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "Failure");
                                          if(!(return_value_dbus_message_is_signal_55 == 0u))
                                          {
                                            return_value_avahi_service_browser_event_29=avahi_service_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_FAILURE, message);
                                            return return_value_avahi_service_browser_event_29;
                                          }

                                          else
                                          {
                                            return_value_dbus_message_is_signal_54=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceResolver", "Found");
                                            if(!(return_value_dbus_message_is_signal_54 == 0u))
                                            {
                                              return_value_avahi_service_resolver_event_30=avahi_service_resolver_event(filter_func__1__client, (enum anonymous_6)AVAHI_RESOLVER_FOUND, message);
                                              return return_value_avahi_service_resolver_event_30;
                                            }

                                            else
                                            {
                                              return_value_dbus_message_is_signal_53=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceResolver", "Failure");
                                              if(!(return_value_dbus_message_is_signal_53 == 0u))
                                              {
                                                return_value_avahi_service_resolver_event_31=avahi_service_resolver_event(filter_func__1__client, (enum anonymous_6)AVAHI_RESOLVER_FAILURE, message);
                                                return return_value_avahi_service_resolver_event_31;
                                              }

                                              else
                                              {
                                                return_value_dbus_message_is_signal_52=dbus_message_is_signal(message, "org.freedesktop.Avahi.HostNameResolver", "Found");
                                                if(!(return_value_dbus_message_is_signal_52 == 0u))
                                                {
                                                  return_value_avahi_host_name_resolver_event_32=avahi_host_name_resolver_event(filter_func__1__client, (enum anonymous_6)AVAHI_RESOLVER_FOUND, message);
                                                  return return_value_avahi_host_name_resolver_event_32;
                                                }

                                                else
                                                {
                                                  return_value_dbus_message_is_signal_51=dbus_message_is_signal(message, "org.freedesktop.Avahi.HostNameResolver", "Failure");
                                                  if(!(return_value_dbus_message_is_signal_51 == 0u))
                                                  {
                                                    return_value_avahi_host_name_resolver_event_33=avahi_host_name_resolver_event(filter_func__1__client, (enum anonymous_6)AVAHI_RESOLVER_FAILURE, message);
                                                    return return_value_avahi_host_name_resolver_event_33;
                                                  }

                                                  else
                                                  {
                                                    return_value_dbus_message_is_signal_50=dbus_message_is_signal(message, "org.freedesktop.Avahi.AddressResolver", "Found");
                                                    if(!(return_value_dbus_message_is_signal_50 == 0u))
                                                    {
                                                      return_value_avahi_address_resolver_event_34=avahi_address_resolver_event(filter_func__1__client, (enum anonymous_6)AVAHI_RESOLVER_FOUND, message);
                                                      return return_value_avahi_address_resolver_event_34;
                                                    }

                                                    else
                                                    {
                                                      return_value_dbus_message_is_signal_49=dbus_message_is_signal(message, "org.freedesktop.Avahi.AddressResolver", "Failure");
                                                      if(!(return_value_dbus_message_is_signal_49 == 0u))
                                                      {
                                                        return_value_avahi_address_resolver_event_35=avahi_address_resolver_event(filter_func__1__client, (enum anonymous_6)AVAHI_RESOLVER_FAILURE, message);
                                                        return return_value_avahi_address_resolver_event_35;
                                                      }

                                                      else
                                                      {
                                                        return_value_dbus_message_is_signal_48=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "ItemNew");
                                                        if(!(return_value_dbus_message_is_signal_48 == 0u))
                                                        {
                                                          return_value_avahi_record_browser_event_36=avahi_record_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_NEW, message);
                                                          return return_value_avahi_record_browser_event_36;
                                                        }

                                                        else
                                                        {
                                                          return_value_dbus_message_is_signal_47=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "ItemRemove");
                                                          if(!(return_value_dbus_message_is_signal_47 == 0u))
                                                          {
                                                            return_value_avahi_record_browser_event_37=avahi_record_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_REMOVE, message);
                                                            return return_value_avahi_record_browser_event_37;
                                                          }

                                                          else
                                                          {
                                                            return_value_dbus_message_is_signal_46=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "CacheExhausted");
                                                            if(!(return_value_dbus_message_is_signal_46 == 0u))
                                                            {
                                                              return_value_avahi_record_browser_event_38=avahi_record_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                                                              return return_value_avahi_record_browser_event_38;
                                                            }

                                                            else
                                                            {
                                                              return_value_dbus_message_is_signal_45=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "AllForNow");
                                                              if(!(return_value_dbus_message_is_signal_45 == 0u))
                                                              {
                                                                return_value_avahi_record_browser_event_39=avahi_record_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_ALL_FOR_NOW, message);
                                                                return return_value_avahi_record_browser_event_39;
                                                              }

                                                              else
                                                              {
                                                                return_value_dbus_message_is_signal_44=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "Failure");
                                                                if(!(return_value_dbus_message_is_signal_44 == 0u))
                                                                {
                                                                  return_value_avahi_record_browser_event_40=avahi_record_browser_event(filter_func__1__client, (enum anonymous_2)AVAHI_BROWSER_FAILURE, message);
                                                                  return return_value_avahi_record_browser_event_40;
                                                                }

                                                                else
                                                                {
                                                                  const char *return_value_dbus_message_get_interface_41;
                                                                  return_value_dbus_message_get_interface_41=dbus_message_get_interface(message);
                                                                  const char *return_value_dbus_message_get_path_42;
                                                                  return_value_dbus_message_get_path_42=dbus_message_get_path(message);
                                                                  const char *return_value_dbus_message_get_member_43;
                                                                  return_value_dbus_message_get_member_43=dbus_message_get_member(message);
                                                                  fprintf(stderr, "WARNING: Unhandled message: interface=%s, path=%s, member=%s\n", return_value_dbus_message_get_interface_41, return_value_dbus_message_get_path_42, return_value_dbus_message_get_member_43);
                                                                  return (enum anonymous_28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

      }
    }

  }
  return (enum anonymous_28)DBUS_HANDLER_RESULT_HANDLED;

fail:
  ;
  unsigned int return_value_dbus_error_is_set_77;
  return_value_dbus_error_is_set_77=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_77 == 0u))
  {
    signed int return_value_avahi_error_dbus_to_number_76;
    return_value_avahi_error_dbus_to_number_76=avahi_error_dbus_to_number(error.name);
    avahi_client_set_errno(filter_func__1__client, return_value_avahi_error_dbus_to_number_76);
    dbus_error_free(&error);
  }

  client_set_state(filter_func__1__client, (enum anonymous_7)AVAHI_CLIENT_FAILURE);
  return (enum anonymous_28)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}

// find_next_timeout
// file simple-watch.c line 425
static struct AvahiTimeout * find_next_timeout(struct AvahiSimplePoll *s)
{
  struct AvahiTimeout *t;
  struct AvahiTimeout *n = (struct AvahiTimeout *)(void *)0;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  t = s->timeouts;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_timeval_compare_2;
  for( ; !(t == ((struct AvahiTimeout *)NULL)); t = t->timeouts_next)
  {
    if(!(t->dead == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = !(t->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1)
    {
      if(n == ((struct AvahiTimeout *)NULL))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare_2=avahi_timeval_compare(&t->expiry, &n->expiry);
        tmp_if_expr_3 = return_value_avahi_timeval_compare_2 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        n = t;

    }

  }
  return n;
}

// find_next_timeout_link1
// file simple-watch.c line 425
static struct AvahiTimeout * find_next_timeout_link1(struct AvahiSimplePoll *s_link1)
{
  struct AvahiTimeout *t_link1;
  struct AvahiTimeout *n_link1 = (struct AvahiTimeout *)(void *)0;
  /* assertion s */
  assert(s_link1 != ((struct AvahiSimplePoll *)NULL));
  t_link1 = s_link1->timeouts;
  _Bool tmp_if_expr_1_link1;
  _Bool tmp_if_expr_3_link1;
  signed int return_value_avahi_timeval_compare_2_link1;
  for( ; !(t_link1 == ((struct AvahiTimeout *)NULL)); t_link1 = t_link1->timeouts_next)
  {
    if(!(t_link1->dead == 0))
      tmp_if_expr_1_link1 = (_Bool)1;

    else
      tmp_if_expr_1_link1 = !(t_link1->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1_link1)
    {
      if(n_link1 == ((struct AvahiTimeout *)NULL))
        tmp_if_expr_3_link1 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare_2_link1=avahi_timeval_compare(&t_link1->expiry, &n_link1->expiry);
        tmp_if_expr_3_link1 = return_value_avahi_timeval_compare_2_link1 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3_link1)
        n_link1 = t_link1;

    }

  }
  return n_link1;
}

// get_server_state
// file client.c line 305
static signed int get_server_state(struct AvahiClient *client, signed int *ret_error)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int state;
  signed int e = -24;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  dbus_error_init(&error);
  message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetState");
  _Bool tmp_if_expr_2;
  unsigned int return_value_dbus_error_is_set_1;
  unsigned int return_value_dbus_message_get_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  if(!(message == ((struct DBusMessage *)NULL)))
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_1=dbus_error_is_set(&error);
      tmp_if_expr_2 = return_value_dbus_error_is_set_1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      goto fail;

    return_value_dbus_message_get_args_3=dbus_message_get_args(reply, &error, (signed int)105, &state, (signed int)0);
    if(return_value_dbus_message_get_args_3 == 0u)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
      tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      goto fail;

    client_set_state(client, (enum anonymous_7)state);
    dbus_message_unref(message);
    dbus_message_unref(reply);
    return 0;
  }

  else
  {

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_6;
    return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_6 == 0u))
    {
      e=avahi_error_dbus_to_number(error.name);
      dbus_error_free(&error);
    }

    if(!(ret_error == ((signed int *)NULL)))
      *ret_error = e;

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return e;
  }
}

// handler
// file sigint.c line 54
static void handler(signed int s)
{
  write(pipe_fds[(signed long int)1], (const void *)&s, sizeof(signed int) /*4ul*/ );
}

// help
// file avahi-set-host-name.c line 71
static void help(struct _IO_FILE *f, const char *argv0)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("avahi", "%s [options] <new host name>\n\n    -h --help            Show this help\n    -V --version         Show version\n    -v --verbose         Enable verbose mode\n");
  fprintf(f, return_value_dgettext_1, argv0);
}

// init_server
// file client.c line 431
static signed int init_server(struct AvahiClient *client, signed int *ret_error)
{
  signed int r;
  r=check_version(client, ret_error);
  if(!(r >= 0))
    return r;

  else
  {
    r=get_server_state(client, ret_error);
    if(!(r >= 0))
      return r;

    else
      return 0;
  }
}

// main
// file avahi-set-host-name.c line 122
signed int main(signed int argc, char **argv)
{
  signed int ret = 1;
  signed int error;
  struct Config config;
  const char *argv0;
  avahi_init_i18n();
  setlocale(6, "");
  argv0=strrchr(argv[(signed long int)0], 47);
  if(!(argv0 == ((const char *)NULL)))
    argv0 = argv0 + 1l;

  else
    argv0 = argv[(signed long int)0];
  signed int return_value_parse_command_line_1;
  return_value_parse_command_line_1=parse_command_line(&config, argc, argv);
  signed int return_value_sigint_install_3;
  const struct AvahiPoll *return_value_avahi_simple_poll_get_6;
  signed int return_value_avahi_client_set_host_name_17;
  if(return_value_parse_command_line_1 >= 0)
    switch((signed int)config.command)
    {
      case COMMAND_HELP:
      {
        help(stdout, argv0);
        ret = 0;
        break;
      }
      case COMMAND_VERSION:
      {
        printf("%s 0.6.32-rc\n", argv0);
        ret = 0;
        break;
      }
      case COMMAND_UNSPEC:
      {
        simple_poll=avahi_simple_poll_new();
        if(simple_poll == ((struct AvahiSimplePoll *)NULL))
        {
          char *return_value_dgettext_2;
          return_value_dgettext_2=dgettext("avahi", "Failed to create simple poll object.\n");
          fprintf(stderr, return_value_dgettext_2);
          break;
        }

        return_value_sigint_install_3=sigint_install(simple_poll);
        if(!(return_value_sigint_install_3 >= 0))
          break;

        return_value_avahi_simple_poll_get_6=avahi_simple_poll_get(simple_poll);
        client=avahi_client_new(return_value_avahi_simple_poll_get_6, (enum anonymous_8)0, client_callback, (void *)0, &error);
        if(client == ((struct AvahiClient *)NULL))
        {
          char *return_value_dgettext_4;
          return_value_dgettext_4=dgettext("avahi", "Failed to create client object: %s\n");
          const char *return_value_avahi_strerror_5;
          return_value_avahi_strerror_5=avahi_strerror(error);
          fprintf(stderr, return_value_dgettext_4, return_value_avahi_strerror_5);
          break;
        }

        if(!(config.verbose == 0))
        {
          const char *version;
          const char *hn;
          version=avahi_client_get_version_string(client);
          if(version == ((const char *)NULL))
          {
            char *return_value_dgettext_7;
            return_value_dgettext_7=dgettext("avahi", "Failed to query version string: %s\n");
            signed int return_value_avahi_client_errno_8;
            return_value_avahi_client_errno_8=avahi_client_errno(client);
            const char *return_value_avahi_strerror_9;
            return_value_avahi_strerror_9=avahi_strerror(return_value_avahi_client_errno_8);
            fprintf(stderr, return_value_dgettext_7, return_value_avahi_strerror_9);
            break;
          }

          hn=avahi_client_get_host_name_fqdn(client);
          if(hn == ((const char *)NULL))
          {
            char *return_value_dgettext_10;
            return_value_dgettext_10=dgettext("avahi", "Failed to query host name: %s\n");
            signed int return_value_avahi_client_errno_11;
            return_value_avahi_client_errno_11=avahi_client_errno(client);
            const char *return_value_avahi_strerror_12;
            return_value_avahi_strerror_12=avahi_strerror(return_value_avahi_client_errno_11);
            fprintf(stderr, return_value_dgettext_10, return_value_avahi_strerror_12);
            break;
          }

          char *return_value_dgettext_13;
          return_value_dgettext_13=dgettext("avahi", "Server version: %s; Host name: %s\n");
          fprintf(stderr, return_value_dgettext_13, version, hn);
        }

        return_value_avahi_client_set_host_name_17=avahi_client_set_host_name(client, argv[(signed long int)optind]);
        if(!(return_value_avahi_client_set_host_name_17 >= 0))
        {
          char *return_value_dgettext_14;
          return_value_dgettext_14=dgettext("avahi", "Failed to create host name resolver: %s\n");
          signed int return_value_avahi_client_errno_15;
          return_value_avahi_client_errno_15=avahi_client_errno(client);
          const char *return_value_avahi_strerror_16;
          return_value_avahi_strerror_16=avahi_strerror(return_value_avahi_client_errno_15);
          fprintf(stderr, return_value_dgettext_14, return_value_avahi_strerror_16);
          break;
        }

        if(!(config.verbose == 0))
        {
          const char *main__1__1__5__hn;
          main__1__1__5__hn=avahi_client_get_host_name_fqdn(client);
          if(main__1__1__5__hn == ((const char *)NULL))
          {
            char *return_value_dgettext_18;
            return_value_dgettext_18=dgettext("avahi", "Failed to query host name: %s\n");
            signed int return_value_avahi_client_errno_19;
            return_value_avahi_client_errno_19=avahi_client_errno(client);
            const char *return_value_avahi_strerror_20;
            return_value_avahi_strerror_20=avahi_strerror(return_value_avahi_client_errno_19);
            fprintf(stderr, return_value_dgettext_18, return_value_avahi_strerror_20);
            break;
          }

          char *return_value_dgettext_21;
          return_value_dgettext_21=dgettext("avahi", "Host name successfully changed to %s\n");
          fprintf(stderr, return_value_dgettext_21, main__1__1__5__hn);
        }

        ret = 0;
      }
    }


fail:
  ;
  if(!(client == ((struct AvahiClient *)NULL)))
    avahi_client_free(client);

  sigint_uninstall();
  if(!(simple_poll == ((struct AvahiSimplePoll *)NULL)))
    avahi_simple_poll_free(simple_poll);

  return ret;
}

// oom
// file malloc.c line 44
static void oom(void)
{
  static const char msg[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n = msg;
  unsigned long int return_value_strlen_1;
  do
  {
    return_value_strlen_1=strlen(n);
    if(!(return_value_strlen_1 >= 1ul))
      break;

    signed long int r;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(n);
    r=write(2, (const void *)n, return_value_strlen_2);
    if(!(r >= 0l))
      break;

    n = n + r;
  }
  while((_Bool)1);
  abort();
}

// oom_link1
// file malloc.c line 44
static void oom_link1(void)
{
  static const char msg_link1[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n_link1 = msg_link1;
  unsigned long int return_value_strlen_1_link1;
  do
  {
    return_value_strlen_1_link1=strlen(n_link1);
    if(!(return_value_strlen_1_link1 >= 1ul))
      break;

    signed long int r_link1;
    unsigned long int return_value_strlen_2_link1;
    return_value_strlen_2_link1=strlen(n_link1);
    r_link1=write(2, (const void *)n_link1, return_value_strlen_2_link1);
    if(!(r_link1 >= 0l))
      break;

    n_link1 = n_link1 + r_link1;
  }
  while((_Bool)1);
  abort();
}

// parse_command_line
// file avahi-set-host-name.c line 80
static signed int parse_command_line(struct Config *c, signed int argc, char **argv)
{
  signed int o;
  /* assertion c */
  assert(c != ((struct Config *)NULL));
  c->command = (enum anonymous_5)COMMAND_UNSPEC;
  c->verbose = 0;
  do
  {
    static struct option long_options[4l] = { { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="version", .has_arg=0, .flag=(signed int *)(void *)0, .val=86 },
    { .name="verbose", .has_arg=0, .flag=(signed int *)(void *)0, .val=118 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
    o=getopt_long(argc, argv, "hVv", long_options, (signed int *)(void *)0);
    if(!(o >= 0))
      break;

    switch(o)
    {
      case 104:
      {
        c->command = (enum anonymous_5)COMMAND_HELP;
        break;
      }
      case 86:
      {
        c->command = (enum anonymous_5)COMMAND_VERSION;
        break;
      }
      case 118:
      {
        c->verbose = 1;
        break;
      }
      default:
        return -1;
    }
  }
  while((_Bool)1);
  if((signed int)c->command == COMMAND_UNSPEC)
  {
    if(!(optind == argc + -1))
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("avahi", "Invalid number of arguments, expecting exactly one.\n");
      fprintf(stderr, return_value_dgettext_1);
      return -1;
    }

  }

  return 0;
}

// parse_domain_file
// file browser.c line 58
static void parse_domain_file(struct AvahiDomainBrowser *b)
{
  struct _IO_FILE *f;
  char buf[1014l];
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  f=avahi_xdg_config_open("avahi/browse-domains");
  char *return_value_fgets_1;
  if(!(f == ((struct _IO_FILE *)NULL)))
    do
    {
      return_value_fgets_1=fgets(buf, (signed int)(sizeof(char [1014l]) /*1014ul*/  - (unsigned long int)1), f);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      char domain[1014l];
      unsigned long int return_value_strcspn_2;
      return_value_strcspn_2=strcspn(buf, "\n\r");
      buf[(signed long int)return_value_strcspn_2] = (char)0;
      char *return_value_avahi_normalize_name_3;
      return_value_avahi_normalize_name_3=avahi_normalize_name(buf, domain, sizeof(char [1014l]) /*1014ul*/ );
      if(!(return_value_avahi_normalize_name_3 == ((char *)NULL)))
        b->static_browse_domains=avahi_string_list_add(b->static_browse_domains, domain);

    }
    while((_Bool)1);

}

// parse_environment
// file browser.c line 41
static void parse_environment(struct AvahiDomainBrowser *b)
{
  char buf[3042l];
  char *e;
  char *t;
  char *p;
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  e=getenv("AVAHI_BROWSE_DOMAINS");
  if(!(e == ((char *)NULL)))
  {
    snprintf(buf, sizeof(char [3042l]) /*3042ul*/ , "%s", e);
    t=strtok_r(buf, ":", &p);
    while(!(t == ((char *)NULL)))
    {
      char domain[1014l];
      char *return_value_avahi_normalize_name_1;
      return_value_avahi_normalize_name_1=avahi_normalize_name(t, domain, sizeof(char [1014l]) /*1014ul*/ );
      if(!(return_value_avahi_normalize_name_1 == ((char *)NULL)))
        b->static_browse_domains=avahi_string_list_add(b->static_browse_domains, domain);

      t=strtok_r((char *)(void *)0, ":", &p);
    }
  }

}

// poll_func
// file thread-watch.c line 48
static signed int poll_func(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata)
{
  union anonymous_25 *mutex = (union anonymous_25 *)userdata;
  signed int r;
  pthread_mutex_unlock(mutex);
  r=poll(ufds, (unsigned long int)nfds, timeout);
  pthread_mutex_lock(mutex);
  return r;
}

// poll_func_link1
// file thread-watch.c line 48
static signed int poll_func_link1(struct pollfd *ufds_link1, unsigned int nfds_link1, signed int timeout_link1, void *userdata_link1)
{
  union anonymous_25 *mutex_link1 = (union anonymous_25 *)userdata_link1;
  signed int r_link1;
  pthread_mutex_unlock(mutex_link1);
  r_link1=poll(ufds_link1, (unsigned long int)nfds_link1, timeout_link1);
  pthread_mutex_lock(mutex_link1);
  return r_link1;
}

// rebuild
// file simple-watch.c line 385
static signed int rebuild(struct AvahiSimplePoll *s)
{
  struct AvahiWatch *w;
  signed int idx;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  if(!(s->max_pollfds >= 1 + s->n_watches))
  {
    struct pollfd *n;
    s->max_pollfds = s->n_watches + 10;
    void *return_value_avahi_realloc_1;
    return_value_avahi_realloc_1=avahi_realloc((void *)s->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s->max_pollfds);
    n = (struct pollfd *)return_value_avahi_realloc_1;
    if(n == ((struct pollfd *)NULL))
      return -1;

    s->pollfds = n;
  }

  (s->pollfds + (signed long int)0)->fd = s->wakeup_pipe[(signed long int)0];
  (s->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx = 1;
  w = s->watches;
  signed int tmp_post_2;
  for( ; !(w == ((struct AvahiWatch *)NULL)); w = w->watches_next)
    if(w->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w->idx < s->max_pollfds);
      tmp_post_2 = idx;
      idx = idx + 1;
      w->idx = tmp_post_2;
      s->pollfds[(signed long int)w->idx] = w->pollfd;
    }

  s->n_pollfds = idx;
  s->events_valid = 0;
  s->rebuild_pollfds = 0;
  return 0;
}

// rebuild_link1
// file simple-watch.c line 385
static signed int rebuild_link1(struct AvahiSimplePoll *s_link1)
{
  struct AvahiWatch *w_link1;
  signed int idx_link1;
  /* assertion s */
  assert(s_link1 != ((struct AvahiSimplePoll *)NULL));
  if(!(s_link1->max_pollfds >= 1 + s_link1->n_watches))
  {
    struct pollfd *n_link1;
    s_link1->max_pollfds = s_link1->n_watches + 10;
    void *return_value_avahi_realloc_1_link1;
    return_value_avahi_realloc_1_link1=avahi_realloc((void *)s_link1->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s_link1->max_pollfds);
    n_link1 = (struct pollfd *)return_value_avahi_realloc_1_link1;
    if(n_link1 == ((struct pollfd *)NULL))
      return -1;

    s_link1->pollfds = n_link1;
  }

  (s_link1->pollfds + (signed long int)0)->fd = s_link1->wakeup_pipe[(signed long int)0];
  (s_link1->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s_link1->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx_link1 = 1;
  w_link1 = s_link1->watches;
  signed int tmp_post_2_link1;
  for( ; !(w_link1 == ((struct AvahiWatch *)NULL)); w_link1 = w_link1->watches_next)
    if(w_link1->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w_link1->idx < s_link1->max_pollfds);
      tmp_post_2_link1 = idx_link1;
      idx_link1 = idx_link1 + 1;
      w_link1->idx = tmp_post_2_link1;
      s_link1->pollfds[(signed long int)w_link1->idx] = w_link1->pollfd;
    }

  s_link1->n_pollfds = idx_link1;
  s_link1->events_valid = 0;
  s_link1->rebuild_pollfds = 0;
  return 0;
}

// remove_pollfd
// file simple-watch.c line 194
static void remove_pollfd(struct AvahiWatch *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch *)NULL));
  if(!(w->idx == -1))
    w->simple_poll->rebuild_pollfds = 1;

}

// remove_pollfd_link1
// file simple-watch.c line 194
static void remove_pollfd_link1(struct AvahiWatch *w_link1)
{
  /* assertion w */
  assert(w_link1 != ((struct AvahiWatch *)NULL));
  if(!(w_link1->idx == -1))
    w_link1->simple_poll->rebuild_pollfds = 1;

}

// remove_timeout
// file ../avahi-common/dbus-watch-glue.c line 286
static void remove_timeout(struct DBusTimeout *dbus_timeout, void *userdata)
{
  struct anonymous_11 *d = (struct anonymous_11 *)userdata;
  struct TimeoutData *timeout;
  /* assertion dbus_timeout */
  assert(dbus_timeout != ((struct DBusTimeout *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous_11 *)NULL));
  void *return_value_dbus_timeout_get_data_1;
  return_value_dbus_timeout_get_data_1=dbus_timeout_get_data(dbus_timeout);
  timeout = (struct TimeoutData *)return_value_dbus_timeout_get_data_1;
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  d->poll_api->timeout_free(timeout->avahi_timeout);
  timeout->avahi_timeout = (struct AvahiTimeout *)(void *)0;
}

// remove_watch
// file ../avahi-common/dbus-watch-glue.c line 174
static void remove_watch(struct DBusWatch *dbus_watch, void *userdata)
{
  struct anonymous_11 *d = (struct anonymous_11 *)userdata;
  struct AvahiWatch *avahi_watch;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous_11 *)NULL));
  void *return_value_dbus_watch_get_data_1;
  return_value_dbus_watch_get_data_1=dbus_watch_get_data(dbus_watch);
  avahi_watch = (struct AvahiWatch *)return_value_dbus_watch_get_data_1;
  if(!(avahi_watch == ((struct AvahiWatch *)NULL)))
  {
    d->poll_api->watch_free(avahi_watch);
    dbus_watch_set_data(dbus_watch, (void *)0, (void (*)(void *))(void *)0);
  }

}

// request_dispatch
// file ../avahi-common/dbus-watch-glue.c line 86
static void request_dispatch(struct anonymous_11 *d, signed int enable)
{
  /* assertion d */
  assert(d != ((struct anonymous_11 *)NULL));
  if(!(enable == 0))
  {
    enum anonymous_10 return_value_dbus_connection_get_dispatch_status_1;
    return_value_dbus_connection_get_dispatch_status_1=dbus_connection_get_dispatch_status(d->connection);
    /* assertion dbus_connection_get_dispatch_status(d->connection) == DBUS_DISPATCH_DATA_REMAINS */
    assert((signed int)return_value_dbus_connection_get_dispatch_status_1 == DBUS_DISPATCH_DATA_REMAINS);
    static struct timeval tv = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
    d->poll_api->timeout_update(d->dispatch_timeout, &tv);
  }

  else
    d->poll_api->timeout_update(d->dispatch_timeout, (struct timeval *)(void *)0);
}

// retrieve_state
// file entrygroup.c line 52
static signed int retrieve_state(struct AvahiEntryGroup *group)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  signed int state;
  struct AvahiClient *retrieve_state__1__client;
  dbus_error_init(&error);
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  retrieve_state__1__client = group->client;
  message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "GetState");
  _Bool tmp_if_expr_2;
  unsigned int return_value_dbus_error_is_set_1;
  unsigned int return_value_dbus_message_get_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  if(message == ((struct DBusMessage *)NULL))
    r=avahi_client_set_errno(retrieve_state__1__client, -24);

  else
  {
    reply=dbus_connection_send_with_reply_and_block(retrieve_state__1__client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_1=dbus_error_is_set(&error);
      tmp_if_expr_2 = return_value_dbus_error_is_set_1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      r=avahi_client_set_errno(retrieve_state__1__client, -22);

    else
    {
      return_value_dbus_message_get_args_3=dbus_message_get_args(reply, &error, (signed int)105, &state, (signed int)0);
      if(return_value_dbus_message_get_args_3 == 0u)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
        tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        r=avahi_client_set_errno(retrieve_state__1__client, -22);

      else
      {
        dbus_message_unref(message);
        dbus_message_unref(reply);
        return state;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_6;
  return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_6 == 0u))
  {
    r=avahi_client_set_dbus_error(retrieve_state__1__client, &error);
    dbus_error_free(&error);
  }

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return r;
}

// set_nonblock
// file sigint.c line 40
static signed int set_nonblock(signed int fd)
{
  signed int n;
  /* assertion fd >= 0 */
  assert(fd >= 0);
  n=fcntl(fd, 3);
  if(!(n >= 0))
    return -1;

  else
    if(!((04000 & n) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl_1;
      return_value_fcntl_1=fcntl(fd, 4, n | 04000);
      return return_value_fcntl_1;
    }
}

// set_nonblock_link1
// file simple-watch.c line 118
static signed int set_nonblock_link1(signed int fd_link1)
{
  signed int n_link1;
  /* assertion fd >= 0 */
  assert(fd_link1 >= 0);
  n_link1=fcntl(fd_link1, 3);
  if(!(n_link1 >= 0))
    return -1;

  else
    if(!((04000 & n_link1) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl_1_link1;
      return_value_fcntl_1_link1=fcntl(fd_link1, 4, n_link1 | 04000);
      return return_value_fcntl_1_link1;
    }
}

// set_nonblock_link2
// file simple-watch.c line 118
static signed int set_nonblock_link2(signed int fd_link2)
{
  signed int n_link2;
  /* assertion fd >= 0 */
  assert(fd_link2 >= 0);
  n_link2=fcntl(fd_link2, 3);
  if(!(n_link2 >= 0))
    return -1;

  else
    if(!((04000 & n_link2) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl_1_link2;
      return_value_fcntl_1_link2=fcntl(fd_link2, 4, n_link2 | 04000);
      return return_value_fcntl_1_link2;
    }
}

// sigint_install
// file sigint.h line 25
signed int sigint_install(struct AvahiSimplePoll *spoll)
{
  struct sigaction sa;
  const struct AvahiPoll *p;
  /* assertion spoll */
  assert(spoll != ((struct AvahiSimplePoll *)NULL));
  /* assertion !simple_poll */
  assert(!(simple_poll_link1 != ((struct AvahiSimplePoll *)NULL)));
  _Bool tmp_if_expr_1;
  if(pipe_fds[0l] == -1)
    tmp_if_expr_1 = pipe_fds[(signed long int)1] == -1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  /* assertion pipe_fds[0] == -1 && pipe_fds[1] == -1 */
  assert(tmp_if_expr_1);
  signed int return_value_pipe_4;
  return_value_pipe_4=pipe(pipe_fds);
  if(!(return_value_pipe_4 >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    fprintf(stderr, "pipe() failed: %s\n", return_value_strerror_3);
    return -1;
  }

  set_nonblock(pipe_fds[(signed long int)0]);
  set_nonblock(pipe_fds[(signed long int)1]);
  memset((void *)&sa, 0, sizeof(struct sigaction) /*152ul*/ );
  sa.__sigaction_handler.sa_handler = handler;
  sa.sa_flags = 0x10000000;
  signed int return_value_sigaction_7;
  return_value_sigaction_7=sigaction(2, &sa, &old_sigint_sa);
  if(!(return_value_sigaction_7 >= 0))
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    char *return_value_strerror_6;
    return_value_strerror_6=strerror(*return_value___errno_location_5);
    fprintf(stderr, "sigaction() failed: %s\n", return_value_strerror_6);
    close_pipe_fds();
    return -1;
  }

  signed int return_value_sigaction_10;
  return_value_sigaction_10=sigaction(15, &sa, &old_sigterm_sa);
  if(!(return_value_sigaction_10 >= 0))
  {
    sigaction(2, &old_sigint_sa, (struct sigaction *)(void *)0);
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    char *return_value_strerror_9;
    return_value_strerror_9=strerror(*return_value___errno_location_8);
    fprintf(stderr, "sigaction() failed: %s\n", return_value_strerror_9);
    close_pipe_fds();
    return -1;
  }

  p=avahi_simple_poll_get(spoll);
  watch=p->watch_new(p, pipe_fds[(signed long int)0], (enum anonymous_9)AVAHI_WATCH_IN, watch_callback, (void *)0);
  /* assertion watch */
  assert(watch != ((struct AvahiWatch *)NULL));
  simple_poll_link1 = spoll;
  return 0;
}

// sigint_uninstall
// file sigint.h line 26
void sigint_uninstall(void)
{
  if(!(simple_poll_link1 == ((struct AvahiSimplePoll *)NULL)))
  {
    sigaction(15, &old_sigterm_sa, (struct sigaction *)(void *)0);
    sigaction(2, &old_sigint_sa, (struct sigaction *)(void *)0);
    close_pipe_fds();
    if(!(watch == ((struct AvahiWatch *)NULL)))
    {
      const struct AvahiPoll *p;
      /* assertion simple_poll */
      assert(simple_poll_link1 != ((struct AvahiSimplePoll *)NULL));
      p=avahi_simple_poll_get(simple_poll_link1);
      p->watch_free(watch);
      watch = (struct AvahiWatch *)(void *)0;
    }

    simple_poll_link1 = (struct AvahiSimplePoll *)(void *)0;
  }

}

// strlcpy
// file domain.c line 482
static unsigned long int strlcpy(char *dest, const char *src, unsigned long int n)
{
  /* assertion dest */
  assert(dest != ((char *)NULL));
  /* assertion src */
  assert(src != ((const char *)NULL));
  if(n >= 1ul)
  {
    strncpy(dest, src, n - (unsigned long int)1);
    dest[(signed long int)(n - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(src);
  return return_value_strlen_1;
}

// strlcpy_link1
// file domain.c line 482
static unsigned long int strlcpy_link1(char *dest_link1, const char *src_link1, unsigned long int n_link1)
{
  /* assertion dest */
  assert(dest_link1 != ((char *)NULL));
  /* assertion src */
  assert(src_link1 != ((const char *)NULL));
  if(n_link1 >= 1ul)
  {
    strncpy(dest_link1, src_link1, n_link1 - (unsigned long int)1);
    dest_link1[(signed long int)(n_link1 - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen_1_link1;
  return_value_strlen_1_link1=strlen(src_link1);
  return return_value_strlen_1_link1;
}

// system_poll
// file simple-watch.c line 626
static signed int system_poll(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata)
{
  signed int return_value_poll_1;
  return_value_poll_1=poll(ufds, (unsigned long int)nfds, timeout);
  return return_value_poll_1;
}

// system_poll_link1
// file simple-watch.c line 626
static signed int system_poll_link1(struct pollfd *ufds_link1, unsigned int nfds_link1, signed int timeout_link1, void *userdata_link1)
{
  signed int return_value_poll_1_link1;
  return_value_poll_1_link1=poll(ufds_link1, (unsigned long int)nfds_link1, timeout_link1);
  return return_value_poll_1_link1;
}

// thread
// file thread-watch.c line 62
static void * thread(void *userdata)
{
  struct AvahiThreadedPoll *p = (struct AvahiThreadedPoll *)userdata;
  struct anonymous_15 mask;
  sigfillset(&mask);
  pthread_sigmask(0, &mask, (struct anonymous_15 *)(void *)0);
  pthread_mutex_lock(&p->mutex);
  p->retval=avahi_simple_poll_loop(p->simple_poll);
  pthread_mutex_unlock(&p->mutex);
  return (void *)0;
}

// thread_link1
// file thread-watch.c line 62
static void * thread_link1(void *userdata_link1)
{
  struct AvahiThreadedPoll *p_link1 = (struct AvahiThreadedPoll *)userdata_link1;
  struct anonymous_15 mask_link1;
  sigfillset(&mask_link1);
  pthread_sigmask(0, &mask_link1, (struct anonymous_15 *)(void *)0);
  pthread_mutex_lock(&p_link1->mutex);
  p_link1->retval=avahi_simple_poll_loop(p_link1->simple_poll);
  pthread_mutex_unlock(&p_link1->mutex);
  return (void *)0;
}

// timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 237
static void timeout_callback(struct AvahiTimeout *avahi_timeout, void *userdata)
{
  struct TimeoutData *timeout = (struct TimeoutData *)userdata;
  /* assertion avahi_timeout */
  assert(avahi_timeout != ((struct AvahiTimeout *)NULL));
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  timeout_data_ref(timeout);
  dbus_timeout_handle(timeout->dbus_timeout);
  if(!(timeout->avahi_timeout == ((struct AvahiTimeout *)NULL)))
    update_timeout(timeout);

  timeout_data_unref(timeout);
}

// timeout_callback_link1
// file simple-watch.c line 441
static void timeout_callback_link1(struct AvahiTimeout *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  /* assertion t->enabled */
  assert(t->enabled != 0);
  t->enabled = 0;
  t->callback(t, t->userdata);
}

// timeout_callback_link2
// file simple-watch.c line 441
static void timeout_callback_link2(struct AvahiTimeout *t_link1)
{
  /* assertion t */
  assert(t_link1 != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t_link1->dead != 0));
  /* assertion t->enabled */
  assert(t_link1->enabled != 0);
  t_link1->enabled = 0;
  t_link1->callback(t_link1, t_link1->userdata);
}

// timeout_data_ref
// file ../avahi-common/dbus-watch-glue.c line 203
static struct TimeoutData * timeout_data_ref(struct TimeoutData *t)
{
  /* assertion t */
  assert(t != ((struct TimeoutData *)NULL));
  /* assertion t->ref >= 1 */
  assert(t->ref >= 1);
  t->ref = t->ref + 1;
  return t;
}

// timeout_data_unref
// file ../avahi-common/dbus-watch-glue.c line 211
static void timeout_data_unref(struct TimeoutData *t)
{
  /* assertion t */
  assert(t != ((struct TimeoutData *)NULL));
  /* assertion t->ref >= 1 */
  assert(t->ref >= 1);
  t->ref = t->ref - 1;
  if(!(t->ref >= 1))
  {
    if(!(t->avahi_timeout == ((struct AvahiTimeout *)NULL)))
      t->poll_api->timeout_free(t->avahi_timeout);

    avahi_free((void *)t);
  }

}

// timeout_free
// file simple-watch.c line 284
static void timeout_free(struct AvahiTimeout *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  avahi_simple_poll_wakeup(t->simple_poll);
  t->dead = 1;
  t->simple_poll->timeout_req_cleanup = 1;
}

// timeout_free_link1
// file simple-watch.c line 284
static void timeout_free_link1(struct AvahiTimeout *t_link1)
{
  /* assertion t */
  assert(t_link1 != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t_link1->dead != 0));
  avahi_simple_poll_wakeup(t_link1->simple_poll);
  t_link1->dead = 1;
  t_link1->simple_poll->timeout_req_cleanup = 1;
}

// timeout_new
// file simple-watch.c line 244
static struct AvahiTimeout * timeout_new(const struct AvahiPoll *api, struct timeval *tv, void (*callback)(struct AvahiTimeout *, void *), void *userdata)
{
  struct AvahiTimeout *t;
  struct AvahiSimplePoll *s;
  /* assertion api */
  assert(api != ((const struct AvahiPoll *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiTimeout *, void *))NULL));
  s = (struct AvahiSimplePoll *)api->userdata;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link2_link1((unsigned int)1, sizeof(struct AvahiTimeout) /*64ul*/ );
  t = (struct AvahiTimeout *)return_value_avahi_new_internal_1;
  if(t == ((struct AvahiTimeout *)NULL))
    return (struct AvahiTimeout *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s);
    t->simple_poll = s;
    t->dead = 0;
    t->enabled = (signed int)!(!(tv != ((struct timeval *)NULL)));
    if(!(t->enabled == 0))
      t->expiry = *tv;

    t->callback = callback;
    t->userdata = userdata;
    do
    {
      struct AvahiTimeout **_head = &s->timeouts;
      struct AvahiTimeout *_item = t;
      /* assertion _item */
      assert(_item != ((struct AvahiTimeout *)NULL));
      _item->timeouts_next = *_head;
      if(!(_item->timeouts_next == ((struct AvahiTimeout *)NULL)))
        _item->timeouts_next->timeouts_prev = _item;

      _item->timeouts_prev = (struct AvahiTimeout *)(void *)0;
      *_head = _item;
    }
    while((_Bool)0);
    return t;
  }
}

// timeout_new_link1
// file simple-watch.c line 244
static struct AvahiTimeout * timeout_new_link1(const struct AvahiPoll *api_link1, struct timeval *tv_link1, void (*callback_link1)(struct AvahiTimeout *, void *), void *userdata_link1)
{
  struct AvahiTimeout *t_link1;
  struct AvahiSimplePoll *s_link1;
  /* assertion api */
  assert(api_link1 != ((const struct AvahiPoll *)NULL));
  /* assertion callback */
  assert(callback_link1 != ((void (*)(struct AvahiTimeout *, void *))NULL));
  s_link1 = (struct AvahiSimplePoll *)api_link1->userdata;
  /* assertion s */
  assert(s_link1 != ((struct AvahiSimplePoll *)NULL));
  void *return_value_avahi_new_internal_1_link1;
  return_value_avahi_new_internal_1_link1=avahi_new_internal_link2_link2((unsigned int)1, sizeof(struct AvahiTimeout) /*64ul*/ );
  t_link1 = (struct AvahiTimeout *)return_value_avahi_new_internal_1_link1;
  if(t_link1 == ((struct AvahiTimeout *)NULL))
    return (struct AvahiTimeout *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s_link1);
    t_link1->simple_poll = s_link1;
    t_link1->dead = 0;
    t_link1->enabled = (signed int)!(!(tv_link1 != ((struct timeval *)NULL)));
    if(!(t_link1->enabled == 0))
      t_link1->expiry = *tv_link1;

    t_link1->callback = callback_link1;
    t_link1->userdata = userdata_link1;
    do
    {
      struct AvahiTimeout **_head_link1 = &s_link1->timeouts;
      struct AvahiTimeout *_item_link1 = t_link1;
      /* assertion _item */
      assert(_item_link1 != ((struct AvahiTimeout *)NULL));
      _item_link1->timeouts_next = *_head_link1;
      if(!(_item_link1->timeouts_next == ((struct AvahiTimeout *)NULL)))
        _item_link1->timeouts_next->timeouts_prev = _item_link1;

      _item_link1->timeouts_prev = (struct AvahiTimeout *)(void *)0;
      *_head_link1 = _item_link1;
    }
    while((_Bool)0);
    return t_link1;
  }
}

// timeout_toggled
// file ../avahi-common/dbus-watch-glue.c line 300
static void timeout_toggled(struct DBusTimeout *dbus_timeout, void *userdata)
{
  struct TimeoutData *timeout;
  /* assertion dbus_timeout */
  assert(dbus_timeout != ((struct DBusTimeout *)NULL));
  void *return_value_dbus_timeout_get_data_1;
  return_value_dbus_timeout_get_data_1=dbus_timeout_get_data(dbus_timeout);
  timeout = (struct TimeoutData *)return_value_dbus_timeout_get_data_1;
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  update_timeout(timeout);
}

// timeout_update
// file simple-watch.c line 273
static void timeout_update(struct AvahiTimeout *t, struct timeval *tv)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  avahi_simple_poll_wakeup(t->simple_poll);
  t->enabled = (signed int)!(!(tv != ((struct timeval *)NULL)));
  if(!(t->enabled == 0))
    t->expiry = *tv;

}

// timeout_update_link1
// file simple-watch.c line 273
static void timeout_update_link1(struct AvahiTimeout *t_link1, struct timeval *tv_link1)
{
  /* assertion t */
  assert(t_link1 != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t_link1->dead != 0));
  avahi_simple_poll_wakeup(t_link1->simple_poll);
  t_link1->enabled = (signed int)!(!(tv_link1 != ((struct timeval *)NULL)));
  if(!(t_link1->enabled == 0))
    t_link1->expiry = *tv_link1;

}

// translate_avahi_to_dbus
// file ../avahi-common/dbus-watch-glue.c line 46
static unsigned int translate_avahi_to_dbus(enum anonymous_9 e)
{
  unsigned int f = (unsigned int)0;
  if(!((AVAHI_WATCH_IN & (signed int)e) == 0))
    f = f | (unsigned int)1;

  if(!((AVAHI_WATCH_OUT & (signed int)e) == 0))
    f = f | (unsigned int)2;

  if(!((AVAHI_WATCH_ERR & (signed int)e) == 0))
    f = f | (unsigned int)4;

  if(!((AVAHI_WATCH_HUP & (signed int)e) == 0))
    f = f | (unsigned int)8;

  return f;
}

// translate_dbus_to_avahi
// file ../avahi-common/dbus-watch-glue.c line 31
static enum anonymous_9 translate_dbus_to_avahi(unsigned int f)
{
  enum anonymous_9 e = (enum anonymous_9)0;
  if(!((1u & f) == 0u))
    e = e | (enum anonymous_9)AVAHI_WATCH_IN;

  if(!((2u & f) == 0u))
    e = e | (enum anonymous_9)AVAHI_WATCH_OUT;

  if(!((4u & f) == 0u))
    e = e | (enum anonymous_9)AVAHI_WATCH_ERR;

  if(!((8u & f) == 0u))
    e = e | (enum anonymous_9)AVAHI_WATCH_HUP;

  return e;
}

// update_timeout
// file ../avahi-common/dbus-watch-glue.c line 223
static void update_timeout(struct TimeoutData *timeout)
{
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  /* assertion timeout->ref >= 1 */
  assert(timeout->ref >= 1);
  unsigned int return_value_dbus_timeout_get_enabled_2;
  return_value_dbus_timeout_get_enabled_2=dbus_timeout_get_enabled(timeout->dbus_timeout);
  if(!(return_value_dbus_timeout_get_enabled_2 == 0u))
  {
    struct timeval tv;
    signed int return_value_dbus_timeout_get_interval_1;
    return_value_dbus_timeout_get_interval_1=dbus_timeout_get_interval(timeout->dbus_timeout);
    avahi_elapse_time(&tv, (unsigned int)return_value_dbus_timeout_get_interval_1, (unsigned int)0);
    timeout->poll_api->timeout_update(timeout->avahi_timeout, &tv);
  }

  else
    timeout->poll_api->timeout_update(timeout->avahi_timeout, (struct timeval *)(void *)0);
}

// update_watch
// file ../avahi-common/dbus-watch-glue.c line 125
static unsigned int update_watch(const struct AvahiPoll *poll_api, struct DBusWatch *dbus_watch)
{
  struct AvahiWatch *avahi_watch;
  unsigned int b;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  void *return_value_dbus_watch_get_data_1;
  return_value_dbus_watch_get_data_1=dbus_watch_get_data(dbus_watch);
  avahi_watch = (struct AvahiWatch *)return_value_dbus_watch_get_data_1;
  b=dbus_watch_get_enabled(dbus_watch);
  if(avahi_watch == ((struct AvahiWatch *)NULL) && !(b == 0u))
  {
    signed int return_value_dbus_watch_get_unix_fd_2;
    return_value_dbus_watch_get_unix_fd_2=dbus_watch_get_unix_fd(dbus_watch);
    unsigned int return_value_dbus_watch_get_flags_3;
    return_value_dbus_watch_get_flags_3=dbus_watch_get_flags(dbus_watch);
    enum anonymous_9 return_value_translate_dbus_to_avahi_4;
    return_value_translate_dbus_to_avahi_4=translate_dbus_to_avahi(return_value_dbus_watch_get_flags_3);
    avahi_watch=poll_api->watch_new(poll_api, return_value_dbus_watch_get_unix_fd_2, return_value_translate_dbus_to_avahi_4, watch_callback_link1, (void *)dbus_watch);
    if(avahi_watch == ((struct AvahiWatch *)NULL))
      return (unsigned int)0;

    dbus_watch_set_data(dbus_watch, (void *)avahi_watch, (void (*)(void *))(void *)0);
  }

  else
    if(b == 0u && !(avahi_watch == ((struct AvahiWatch *)NULL)))
    {
      poll_api->watch_free(avahi_watch);
      dbus_watch_set_data(dbus_watch, (void *)0, (void (*)(void *))(void *)0);
    }

    else
      if(!(avahi_watch == ((struct AvahiWatch *)NULL)))
      {
        unsigned int return_value_dbus_watch_get_flags_5;
        return_value_dbus_watch_get_flags_5=dbus_watch_get_flags(dbus_watch);
        poll_api->watch_update(avahi_watch, (enum anonymous_9)return_value_dbus_watch_get_flags_5);
      }

  return (unsigned int)1;
}

// watch_callback
// file sigint.c line 67
static void watch_callback(struct AvahiWatch *w, signed int fd, enum anonymous_9 event, void *userdata)
{
  signed int s;
  signed long int l;
  /* assertion w */
  assert(w != ((struct AvahiWatch *)NULL));
  /* assertion fd == pipe_fds[0] */
  assert(fd == pipe_fds[(signed long int)0]);
  /* assertion event == AVAHI_WATCH_IN */
  assert((signed int)event == AVAHI_WATCH_IN);
  l=read(fd, (void *)&s, sizeof(signed int) /*4ul*/ );
  /* assertion l == sizeof(s) */
  assert((unsigned long int)l == sizeof(signed int) /*4ul*/ );
  fprintf(stderr, "Got %s, quitting.\n", s == 2 ? "SIGINT" : "SIGTERM");
  avahi_simple_poll_quit(simple_poll_link1);
}

// watch_callback_link1
// file ../avahi-common/dbus-watch-glue.c line 115
static void watch_callback_link1(struct AvahiWatch *avahi_watch, signed int fd_link1, enum anonymous_9 events, void *userdata_link1)
{
  struct DBusWatch *dbus_watch = (struct DBusWatch *)userdata_link1;
  /* assertion avahi_watch */
  assert(avahi_watch != ((struct AvahiWatch *)NULL));
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  unsigned int return_value_translate_avahi_to_dbus_1;
  return_value_translate_avahi_to_dbus_1=translate_avahi_to_dbus(events);
  dbus_watch_handle(dbus_watch, return_value_translate_avahi_to_dbus_1);
}

// watch_free
// file simple-watch.c line 203
static void watch_free(struct AvahiWatch *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w->dead != 0));
  avahi_simple_poll_wakeup(w->simple_poll);
  remove_pollfd(w);
  w->dead = 1;
  w->simple_poll->n_watches = w->simple_poll->n_watches - 1;
  w->simple_poll->watch_req_cleanup = 1;
}

// watch_free_link1
// file simple-watch.c line 203
static void watch_free_link1(struct AvahiWatch *w_link1)
{
  /* assertion w */
  assert(w_link1 != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w_link1->dead != 0));
  avahi_simple_poll_wakeup(w_link1->simple_poll);
  remove_pollfd_link1(w_link1);
  w_link1->dead = 1;
  w_link1->simple_poll->n_watches = w_link1->simple_poll->n_watches - 1;
  w_link1->simple_poll->watch_req_cleanup = 1;
}

// watch_get_events
// file simple-watch.c line 184
static enum anonymous_9 watch_get_events(struct AvahiWatch *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w->dead != 0));
  if(!(w->idx == -1))
  {
    if(w->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous_9)(w->simple_poll->pollfds + (signed long int)w->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous_9)0;
  }
}

// watch_get_events_link1
// file simple-watch.c line 184
static enum anonymous_9 watch_get_events_link1(struct AvahiWatch *w_link1)
{
  /* assertion w */
  assert(w_link1 != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w_link1->dead != 0));
  if(!(w_link1->idx == -1))
  {
    if(w_link1->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous_9)(w_link1->simple_poll->pollfds + (signed long int)w_link1->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous_9)0;
  }
}

// watch_new
// file simple-watch.c line 132
static struct AvahiWatch * watch_new(const struct AvahiPoll *api, signed int fd, enum anonymous_9 event, void (*callback)(struct AvahiWatch *, signed int, enum anonymous_9, void *), void *userdata)
{
  struct AvahiWatch *w;
  struct AvahiSimplePoll *s;
  /* assertion api */
  assert(api != ((const struct AvahiPoll *)NULL));
  /* assertion fd >= 0 */
  assert(fd >= 0);
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiWatch *, signed int, enum anonymous_9, void *))NULL));
  s = (struct AvahiSimplePoll *)api->userdata;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll *)NULL));
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link2_link1((unsigned int)1, sizeof(struct AvahiWatch) /*56ul*/ );
  w = (struct AvahiWatch *)return_value_avahi_new_internal_1;
  if(w == ((struct AvahiWatch *)NULL))
    return (struct AvahiWatch *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s);
    w->simple_poll = s;
    w->dead = 0;
    w->pollfd.fd = fd;
    w->pollfd.events = (signed short int)event;
    w->pollfd.revents = (signed short int)0;
    w->callback = callback;
    w->userdata = userdata;
    w->idx = -1;
    s->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch **_head = &s->watches;
      struct AvahiWatch *_item = w;
      /* assertion _item */
      assert(_item != ((struct AvahiWatch *)NULL));
      _item->watches_next = *_head;
      if(!(_item->watches_next == ((struct AvahiWatch *)NULL)))
        _item->watches_next->watches_prev = _item;

      _item->watches_prev = (struct AvahiWatch *)(void *)0;
      *_head = _item;
    }
    while((_Bool)0);
    s->n_watches = s->n_watches + 1;
    return w;
  }
}

// watch_new_link1
// file simple-watch.c line 132
static struct AvahiWatch * watch_new_link1(const struct AvahiPoll *api_link1, signed int fd_link1, enum anonymous_9 event_link1, void (*callback_link1)(struct AvahiWatch *, signed int, enum anonymous_9, void *), void *userdata_link1)
{
  struct AvahiWatch *w_link1;
  struct AvahiSimplePoll *s_link1;
  /* assertion api */
  assert(api_link1 != ((const struct AvahiPoll *)NULL));
  /* assertion fd >= 0 */
  assert(fd_link1 >= 0);
  /* assertion callback */
  assert(callback_link1 != ((void (*)(struct AvahiWatch *, signed int, enum anonymous_9, void *))NULL));
  s_link1 = (struct AvahiSimplePoll *)api_link1->userdata;
  /* assertion s */
  assert(s_link1 != ((struct AvahiSimplePoll *)NULL));
  void *return_value_avahi_new_internal_1_link1;
  return_value_avahi_new_internal_1_link1=avahi_new_internal_link2_link2((unsigned int)1, sizeof(struct AvahiWatch) /*56ul*/ );
  w_link1 = (struct AvahiWatch *)return_value_avahi_new_internal_1_link1;
  if(w_link1 == ((struct AvahiWatch *)NULL))
    return (struct AvahiWatch *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s_link1);
    w_link1->simple_poll = s_link1;
    w_link1->dead = 0;
    w_link1->pollfd.fd = fd_link1;
    w_link1->pollfd.events = (signed short int)event_link1;
    w_link1->pollfd.revents = (signed short int)0;
    w_link1->callback = callback_link1;
    w_link1->userdata = userdata_link1;
    w_link1->idx = -1;
    s_link1->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch **_head_link1 = &s_link1->watches;
      struct AvahiWatch *_item_link1 = w_link1;
      /* assertion _item */
      assert(_item_link1 != ((struct AvahiWatch *)NULL));
      _item_link1->watches_next = *_head_link1;
      if(!(_item_link1->watches_next == ((struct AvahiWatch *)NULL)))
        _item_link1->watches_next->watches_prev = _item_link1;

      _item_link1->watches_prev = (struct AvahiWatch *)(void *)0;
      *_head_link1 = _item_link1;
    }
    while((_Bool)0);
    s_link1->n_watches = s_link1->n_watches + 1;
    return w_link1;
  }
}

// watch_toggled
// file ../avahi-common/dbus-watch-glue.c line 187
static void watch_toggled(struct DBusWatch *dbus_watch, void *userdata)
{
  struct anonymous_11 *d = (struct anonymous_11 *)userdata;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous_11 *)NULL));
  update_watch(d->poll_api, dbus_watch);
}

// watch_update
// file simple-watch.c line 168
static void watch_update(struct AvahiWatch *w, enum anonymous_9 events)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w->dead != 0));
  avahi_simple_poll_wakeup(w->simple_poll);
  w->pollfd.events = (signed short int)events;
  if(!(w->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w->simple_poll != ((struct AvahiSimplePoll *)NULL));
    w->simple_poll->pollfds[(signed long int)w->idx] = w->pollfd;
  }

  else
    w->simple_poll->rebuild_pollfds = 1;
}

// watch_update_link1
// file simple-watch.c line 168
static void watch_update_link1(struct AvahiWatch *w_link1, enum anonymous_9 events_link1)
{
  /* assertion w */
  assert(w_link1 != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w_link1->dead != 0));
  avahi_simple_poll_wakeup(w_link1->simple_poll);
  w_link1->pollfd.events = (signed short int)events_link1;
  if(!(w_link1->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w_link1->simple_poll != ((struct AvahiSimplePoll *)NULL));
    w_link1->simple_poll->pollfds[(signed long int)w_link1->idx] = w_link1->pollfd;
  }

  else
    w_link1->simple_poll->rebuild_pollfds = 1;
}

// xcalloc
// file malloc.c line 89
static void * xcalloc(unsigned long int nmemb, unsigned long int size)
{
  void *p;
  if(nmemb == 0ul || size == 0ul)
    return (void *)0;

  else
  {
    p=calloc(nmemb, size);
    if(p == NULL)
      oom();

    return p;
  }
}

// xcalloc_link1
// file malloc.c line 89
static void * xcalloc_link1(unsigned long int nmemb_link1, unsigned long int size_link1)
{
  void *p_link1;
  if(nmemb_link1 == 0ul || size_link1 == 0ul)
    return (void *)0;

  else
  {
    p_link1=calloc(nmemb_link1, size_link1);
    if(p_link1 == NULL)
      oom_link1();

    return p_link1;
  }
}

// xmalloc
// file malloc.c line 62
static void * xmalloc(unsigned long int size)
{
  void *p;
  if(size == 0ul)
    return (void *)0;

  else
  {
    p=malloc(size);
    if(p == NULL)
      oom();

    return p;
  }
}

// xmalloc_link1
// file malloc.c line 62
static void * xmalloc_link1(unsigned long int size_link1)
{
  void *p_link1;
  if(size_link1 == 0ul)
    return (void *)0;

  else
  {
    p_link1=malloc(size_link1);
    if(p_link1 == NULL)
      oom_link1();

    return p_link1;
  }
}

// xrealloc
// file malloc.c line 75
static void * xrealloc(void *p, unsigned long int size)
{
  if(size == 0ul)
  {
    free(p);
    return (void *)0;
  }

  else
  {
    p=realloc(p, size);
    if(p == NULL)
      oom();

    return p;
  }
}

// xrealloc_link1
// file malloc.c line 75
static void * xrealloc_link1(void *p_link1, unsigned long int size_link1)
{
  if(size_link1 == 0ul)
  {
    free(p_link1);
    return (void *)0;
  }

  else
  {
    p_link1=realloc(p_link1, size_link1);
    if(p_link1 == NULL)
      oom_link1();

    return p_link1;
  }
}

