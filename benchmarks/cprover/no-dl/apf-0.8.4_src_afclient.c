// tag-#anon#ST[*{S8}_S8_'artries'||S32'tries'||U32'_pad0'||*{S8}_S8_'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'_pad1'|]
// file ar_options_struct.h line 28
struct anonymous_3;

// tag-#anon#ST[*{S8}_S8_'keysFile'||*{S8}_S8_'certificateFile'||*{S8}_S8_'storeFile'||*{S8}_S8_'dateFormat'||S32'realmsNumber'||S8'ignorePublicKeys'||U24'_pad0'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'serverName'||*{S8}_S8_'managePort'||*{S8}_S8_'hostName'||*{S8}_S8_'realmName'||*{S8}_S8_'sKeepAliveTimeout'||*{S8}_S8_'realmId'||*{S8}_S8_'localName'||*{S8}_S8_'localPort'||*{S8}_S8_'localDestinationName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'clientMode'||S32'keepAliveTimeout'||S8'ipFamily'||S8'realmType'||S8'tunnelType'||U8'_pad0'||SYM#tag-timeval#'keepAlive'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'masterSslFd'||*{SYM#tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]#_'httpProxyOptions'||*{SYM#tag-#anon#ST[*{S8}_S8_'artries'||S32'tries'||U32'_pad0'||*{S8}_S8_'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'_pad1'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'artries'||S32'tries'||U32'_pad0'||*{S8}_S8_'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'_pad1'|]#_'arOptions'||*{SYM#tag-portlist#}_SYM#tag-portlist#_'destinationPorts'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#}_SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#_'userModule'||*{SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#}_SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#_'serviceModule'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'serverName'||*{S8}_S8_'managePort'||*{S8}_S8_'hostName'||*{S8}_S8_'realmName'||*{S8}_S8_'sKeepAliveTimeout'||*{S8}_S8_'realmId'||*{S8}_S8_'localName'||*{S8}_S8_'localPort'||*{S8}_S8_'localDestinationName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'clientMode'||S32'keepAliveTimeout'||S8'ipFamily'||S8'realmType'||S8'tunnelType'||U8'_pad0'||SYM#tag-timeval#'keepAlive'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'masterSslFd'||*{SYM#tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]#_'httpProxyOptions'||*{SYM#tag-#anon#ST[*{S8}_S8_'artries'||S32'tries'||U32'_pad0'||*{S8}_S8_'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'_pad1'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'artries'||S32'tries'||U32'_pad0'||*{S8}_S8_'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'_pad1'|]#_'arOptions'||*{SYM#tag-portlist#}_SYM#tag-portlist#_'destinationPorts'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#}_SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#_'userModule'||*{SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#}_SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#_'serviceModule'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'serverName'||*{S8}_S8_'managePort'||*{S8}_S8_'hostName'||*{S8}_S8_'realmName'||*{S8}_S8_'sKeepAliveTimeout'||*{S8}_S8_'realmId'||*{S8}_S8_'localName'||*{S8}_S8_'localPort'||*{S8}_S8_'localDestinationName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'clientMode'||S32'keepAliveTimeout'||S8'ipFamily'||S8'realmType'||S8'tunnelType'||U8'_pad0'||SYM#tag-timeval#'keepAlive'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'masterSslFd'||*{SYM#tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]#_'httpProxyOptions'||*{SYM#tag-#anon#ST[*{S8}_S8_'artries'||S32'tries'||U32'_pad0'||*{S8}_S8_'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'_pad1'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'artries'||S32'tries'||U32'_pad0'||*{S8}_S8_'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'_pad1'|]#_'arOptions'||*{SYM#tag-portlist#}_SYM#tag-portlist#_'destinationPorts'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#}_SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#_'userModule'||*{SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#}_SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#_'serviceModule'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'serverName'||*{S8}_S8_'managePort'||*{S8}_S8_'hostName'||*{S8}_S8_'realmName'||*{S8}_S8_'sKeepAliveTimeout'||*{S8}_S8_'realmId'||*{S8}_S8_'localName'||*{S8}_S8_'localPort'||*{S8}_S8_'localDestinationName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'clientMode'||S32'keepAliveTimeout'||S8'ipFamily'||S8'realmType'||S8'tunnelType'||U8'_pad0'||SYM#tag-timeval#'keepAlive'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'masterSslFd'||*{SYM#tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]#_'httpProxyOptions'||*{SYM#tag-#anon#ST[*{S8}_S8_'artries'||S32'tries'||U32'_pad0'||*{S8}_S8_'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'_pad1'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'artries'||S32'tries'||U32'_pad0'||*{S8}_S8_'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'_pad1'|]#_'arOptions'||*{SYM#tag-portlist#}_SYM#tag-portlist#_'destinationPorts'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#}_SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#_'userModule'||*{SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#}_SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#_'serviceModule'|]#__'realmsTable'|]
// file client_configuration_struct.h line 27
struct anonymous_4;

// tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]
// file usr_cli_struct.h line 25
struct anonymous_1;

// tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]
// file http_proxy_options_struct.h line 31
struct anonymous;

// tag-#anon#ST[*{S8}_S8_'serverName'||*{S8}_S8_'managePort'||*{S8}_S8_'hostName'||*{S8}_S8_'realmName'||*{S8}_S8_'sKeepAliveTimeout'||*{S8}_S8_'realmId'||*{S8}_S8_'localName'||*{S8}_S8_'localPort'||*{S8}_S8_'localDestinationName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'clientMode'||S32'keepAliveTimeout'||S8'ipFamily'||S8'realmType'||S8'tunnelType'||U8'_pad0'||SYM#tag-timeval#'keepAlive'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'masterSslFd'||*{SYM#tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]#_'httpProxyOptions'||*{SYM#tag-#anon#ST[*{S8}_S8_'artries'||S32'tries'||U32'_pad0'||*{S8}_S8_'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'_pad1'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'artries'||S32'tries'||U32'_pad0'||*{S8}_S8_'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'_pad1'|]#_'arOptions'||*{SYM#tag-portlist#}_SYM#tag-portlist#_'destinationPorts'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#}_SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#_'userModule'||*{SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#}_SYM#tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]#_'serviceModule'|]
// file client_realm_struct.h line 42
struct anonymous_5;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_31;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_29;

// tag-#anon#ST[ARR128{U8}_U8_'cert_verify_md'||ARR128{U8}_U8_'finish_md'||S32'finish_md_len'||ARR128{U8}_U8_'peer_finish_md'||S32'peer_finish_md_len'||U64'message_size'||S32'message_type'||U32'_pad0'||*{cSYM#tag-ssl_cipher_st#}_cSYM#tag-ssl_cipher_st#_'new_cipher'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ecdh'||S32'next_state'||S32'reuse_message'||S32'cert_req'||S32'ctype_num'||ARR9{S8}_S8_'ctype'||U56'_pad1'||*{SYM#tag-stack_st_X509_NAME#}_SYM#tag-stack_st_X509_NAME#_'ca_names'||S32'use_rsa_tmp'||S32'key_block_length'||*{U8}_U8_'key_block'||*{cSYM#tag-evp_cipher_st#}_cSYM#tag-evp_cipher_st#_'new_sym_enc'||*{cSYM#tag-env_md_st#}_cSYM#tag-env_md_st#_'new_hash'||S32'new_mac_pkey_type'||S32'new_mac_secret_size'||*{cSYM#tag-ssl_comp_st#}_cSYM#tag-ssl_comp_st#_'new_compression'||S32'cert_request'||U32'_pad2'|]
// file /usr/include/openssl/ssl3.h line 553
struct anonymous_21;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_11;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_18;

// tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]
// file header_buffer_struct.h line 24
struct anonymous_2;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 140
struct anonymous_23;

// tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]
// file ssl_fd_struct.h line 27
struct anonymous_0;

// tag-#anon#ST[S32'sess_connect'||S32'sess_connect_renegotiate'||S32'sess_connect_good'||S32'sess_accept'||S32'sess_accept_renegotiate'||S32'sess_accept_good'||S32'sess_miss'||S32'sess_timeout'||S32'sess_cache_full'||S32'sess_hit'||S32'sess_cb_hit'|]
// file /usr/include/openssl/ssl.h line 964
struct anonymous_8;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_25;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_28;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_27;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_33;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_26;

// tag-#anon#ST[S32'sockfd'||U32'_pad0'||*{S8}_S8_'host'||*{S8}_S8_'serv'||*{SYM#tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'proxyname'||*{S8}_S8_'proxyport'||*{S8}_S8_'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'_pad0'|]#_'hpo'||S8'type'||U56'_pad1'||*{SYM#tag-ssl_ctx_st#}_SYM#tag-ssl_ctx_st#_'ctx'|]
// file http_proxy_client.c line 32
struct anonymous_19;

// tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]
// file user_stats_struct.h line 27
struct anonymous_14;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_30;

// tag-#anon#ST[S8'loaded'||U56'_pad0'||*{S8}_S8_'fileName'||*{V}_V_'handle'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'info'||*{S32(*{S8}_S8_|*{S8}_S8_)->S32}_S32(*{S8}_S8_|*{S8}_S8_)->S32_'allow'||*{S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32}_S32(*{S8}_S8_|*{U8}_U8_|*{S32}_S32_)->S32_'filter'|]
// file module_struct.h line 28
struct anonymous_6;

// tag-#anon#ST[S8'read_state'||ARR4{S8}_S8_'readed_length'||S8'state'||ARR10{S8}_S8_'id'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'postFd'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'getFd'||S32'sent_ptr'||S32'sockfd'||ARR9000{S8}_S8_'buf'||ARR9000{S8}_S8_'tmpbuf'||S8'tmpstate'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'tmpFd'||S8'type'||U24'_pad1'||SYM#tag-#anon#ST[S8'type'||ARR10{S8}_S8_'id'||U8'_pad0'||S32'ptr'||S32'length'||S32'allreaded'|]#'tmpheader'||S32'ptr'||S32'length'||S32'curreceived'||S32'toreceive'||S32'received'|]
// file http_proxy_functions.h line 52
struct anonymous_16;

// tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]
// file connect_user_struct.h line 30
struct anonymous_7;

// tag-#anon#ST[S8'type'||ARR10{S8}_S8_'id'||U8'_pad0'||S32'ptr'||S32'length'||S32'allreaded'|]
// file http_proxy_functions.h line 44
struct anonymous_15;

// tag-#anon#ST[U32'conn_id_length'||U32'cert_type'||U32'cert_length'||U32'csl'||U32'clear'||U32'enc'||ARR32{U8}_U8_'ccl'||U32'cipher_spec_length'||U32'session_id_length'||U32'clen'||U32'rlen'|]
// file /usr/include/openssl/ssl2.h line 203
struct anonymous_20;

// tag-#anon#UN[*{S8}_S8_'ptr'||*{SYM#tag-rsa_st#}_SYM#tag-rsa_st#_'rsa'||*{SYM#tag-dsa_st#}_SYM#tag-dsa_st#_'dsa'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous_13;

// tag-#anon#UN[*{S8}_S8_'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'asn1_string'||*{SYM#tag-asn1_object_st#}_SYM#tag-asn1_object_st#_'object'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'integer'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'enumerated'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bit_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'octet_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'printablestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'t61string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'ia5string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bmpstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'universalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utctime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalizedtime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'visiblestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utf8string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'set'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'sequence'||*{SYM#tag-ASN1_VALUE_st#}_SYM#tag-ASN1_VALUE_st#_'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous_12;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_17;

// tag-#anon#UN[*{V(S32|S32|*{V}_V_)->V}_V(S32|S32|*{V}_V_)->V_'cb_1'||*{S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32}_S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32_'cb_2'|]
// file /usr/include/openssl/bn.h line 351
union anonymous_10;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_9;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_32;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 138
union anonymous_24;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_22;

// tag-ASN1_ENCODING_st
// file /usr/include/openssl/asn1.h line 257
struct ASN1_ENCODING_st;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-AUTHORITY_KEYID_st
// file /usr/include/openssl/ossl_typ.h line 186
struct AUTHORITY_KEYID_st;

// tag-DSA_SIG_st
// file /usr/include/openssl/dsa.h line 124
struct DSA_SIG_st;

// tag-ISSUING_DIST_POINT_st
// file /usr/include/openssl/ossl_typ.h line 188
struct ISSUING_DIST_POINT_st;

// tag-NAME_CONSTRAINTS_st
// file /usr/include/openssl/ossl_typ.h line 189
struct NAME_CONSTRAINTS_st;

// tag-X509_POLICY_CACHE_st
// file /usr/include/openssl/ossl_typ.h line 184
struct X509_POLICY_CACHE_st;

// tag-X509_POLICY_TREE_st
// file /usr/include/openssl/ossl_typ.h line 183
struct X509_POLICY_TREE_st;

// tag-X509_VERIFY_PARAM_ID_st
// file /usr/include/openssl/x509_vfy.h line 159
struct X509_VERIFY_PARAM_ID_st;

// tag-X509_VERIFY_PARAM_st
// file /usr/include/openssl/x509_vfy.h line 167
struct X509_VERIFY_PARAM_st;

// tag-X509_algor_st
// file /usr/include/openssl/ossl_typ.h line 155
struct X509_algor_st;

// tag-X509_crl_info_st
// file /usr/include/openssl/x509.h line 441
struct X509_crl_info_st;

// tag-X509_crl_st
// file /usr/include/openssl/ossl_typ.h line 156
struct X509_crl_st;

// tag-X509_name_entry_st
// file /usr/include/openssl/x509.h line 168
struct X509_name_entry_st;

// tag-X509_name_st
// file /usr/include/openssl/ossl_typ.h line 159
struct X509_name_st;

// tag-X509_pubkey_st
// file /usr/include/openssl/ossl_typ.h line 160
struct X509_pubkey_st;

// tag-X509_req_info_st
// file /usr/include/openssl/x509.h line 226
struct X509_req_info_st;

// tag-X509_req_st
// file /usr/include/openssl/x509.h line 235
struct X509_req_st;

// tag-X509_val_st
// file /usr/include/openssl/x509.h line 152
struct X509_val_st;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_pqueue
// file /usr/include/openssl/pqueue.h line 70
struct _pqueue;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-alnode
// file audit_list_node_struct.h line 26
struct alnode;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-auditlist
// file audit_list_struct.h line 26
struct auditlist;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-blnode
// file buf_list_node_struct.h line 24
struct blnode;

// tag-bn_blinding_st
// file /usr/include/openssl/ossl_typ.h line 122
struct bn_blinding_st;

// tag-bn_gencb_st
// file /usr/include/openssl/ossl_typ.h line 125
struct bn_gencb_st;

// tag-bn_mont_ctx_st
// file /usr/include/openssl/ossl_typ.h line 123
struct bn_mont_ctx_st;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-buflist
// file buf_list_struct.h line 26
struct buflist;

// tag-cert_st
// file /usr/include/openssl/ssl.h line 1035
struct cert_st;

// tag-comp_ctx_st
// file /usr/include/openssl/comp.h line 11
struct comp_ctx_st;

// tag-comp_method_st
// file /usr/include/openssl/comp.h line 13
struct comp_method_st;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-dh_method
// file /usr/include/openssl/ossl_typ.h line 141
struct dh_method;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dsa_method
// file /usr/include/openssl/ossl_typ.h line 144
struct dsa_method;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-dtls1_bitmap_st
// file /usr/include/openssl/dtls1.h line 128
struct dtls1_bitmap_st;

// tag-dtls1_retransmit_state
// file /usr/include/openssl/dtls1.h line 135
struct dtls1_retransmit_state;

// tag-dtls1_state_st
// file /usr/include/openssl/ssl.h line 1493
struct dtls1_state_st;

// tag-dtls1_timeout_st
// file /usr/include/openssl/dtls1.h line 162
struct dtls1_timeout_st;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-entry
// file first_run.c line 40
struct entry;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-hm_header_st
// file /usr/include/openssl/dtls1.h line 147
struct hm_header_st;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-lhash_st_SSL_SESSION
// file /usr/include/openssl/ssl.h line 923
struct lhash_st_SSL_SESSION;

// tag-llnode
// file logging.h line 54
struct llnode;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-plnode
// file port_list_node_struct.h line 24
struct plnode;

// tag-portlist
// file port_list_struct.h line 26
struct portlist;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-record_pqueue_st
// file /usr/include/openssl/dtls1.h line 171
struct record_pqueue_st;

// tag-rsa_meth_st
// file /usr/include/openssl/ossl_typ.h line 147
struct rsa_meth_st;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-sess_cert_st
// file /usr/include/openssl/ssl.h line 531
struct sess_cert_st;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-srp_ctx_st
// file /usr/include/openssl/ssl.h line 849
struct srp_ctx_st;

// tag-srtp_protection_profile_st
// file /usr/include/openssl/ssl.h line 383
struct srtp_protection_profile_st;

// tag-ssl2_state_st
// file /usr/include/openssl/ssl.h line 1491
struct ssl2_state_st;

// tag-ssl3_buf_freelist_st
// file /usr/include/openssl/ssl.h line 1114
struct ssl3_buf_freelist_st;

// tag-ssl3_buffer_st
// file /usr/include/openssl/ssl3.h line 438
struct ssl3_buffer_st;

// tag-ssl3_enc_method
// file /usr/include/openssl/ssl.h line 466
struct ssl3_enc_method;

// tag-ssl3_record_st
// file /usr/include/openssl/ssl3.h line 403
struct ssl3_record_st;

// tag-ssl3_state_st
// file /usr/include/openssl/ssl.h line 1492
struct ssl3_state_st;

// tag-ssl_cipher_st
// file /usr/include/openssl/ssl.h line 375
struct ssl_cipher_st;

// tag-ssl_comp_st
// file /usr/include/openssl/ssl.h line 908
struct ssl_comp_st;

// tag-ssl_ctx_st
// file /usr/include/openssl/ossl_typ.h line 179
struct ssl_ctx_st;

// tag-ssl_method_st
// file /usr/include/openssl/ssl.h line 374
struct ssl_method_st;

// tag-ssl_session_st
// file /usr/include/openssl/ssl.h line 376
struct ssl_session_st;

// tag-ssl_st
// file /usr/include/openssl/ossl_typ.h line 178
struct ssl_st;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_ASN1_OBJECT
// file /usr/include/openssl/asn1.h line 793
struct stack_st_ASN1_OBJECT;

// tag-stack_st_DIST_POINT
// file /usr/include/openssl/x509.h line 288
struct stack_st_DIST_POINT;

// tag-stack_st_GENERAL_NAME
// file /usr/include/openssl/x509.h line 289
struct stack_st_GENERAL_NAME;

// tag-stack_st_GENERAL_NAMES
// file /usr/include/openssl/x509.h line 471
struct stack_st_GENERAL_NAMES;

// tag-stack_st_OCSP_RESPID
// file /usr/include/openssl/ssl.h line 1610
struct stack_st_OCSP_RESPID;

// tag-stack_st_SRTP_PROTECTION_PROFILE
// file /usr/include/openssl/ssl.h line 388
struct stack_st_SRTP_PROTECTION_PROFILE;

// tag-stack_st_SSL_CIPHER
// file /usr/include/openssl/ssl.h line 380
struct stack_st_SSL_CIPHER;

// tag-stack_st_SSL_COMP
// file /usr/include/openssl/ssl.h line 922
struct stack_st_SSL_COMP;

// tag-stack_st_X509
// file /usr/include/openssl/x509.h line 301
struct stack_st_X509;

// tag-stack_st_X509_ALGOR
// file /usr/include/openssl/asn1.h line 162
struct stack_st_X509_ALGOR;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stack_st_X509_CRL
// file /usr/include/openssl/x509.h line 476
struct stack_st_X509_CRL;

// tag-stack_st_X509_EXTENSION
// file /usr/include/openssl/x509.h line 202
struct stack_st_X509_EXTENSION;

// tag-stack_st_X509_LOOKUP
// file /usr/include/openssl/x509_vfy.h line 136
struct stack_st_X509_LOOKUP;

// tag-stack_st_X509_NAME
// file /usr/include/openssl/x509.h line 192
struct stack_st_X509_NAME;

// tag-stack_st_X509_NAME_ENTRY
// file /usr/include/openssl/x509.h line 175
struct stack_st_X509_NAME_ENTRY;

// tag-stack_st_X509_OBJECT
// file /usr/include/openssl/x509_vfy.h line 137
struct stack_st_X509_OBJECT;

// tag-stack_st_X509_REVOKED
// file /usr/include/openssl/x509.h line 438
struct stack_st_X509_REVOKED;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tls_session_ticket_ext_st
// file /usr/include/openssl/ssl.h line 373
struct tls_session_ticket_ext_st;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-x509_cert_aux_st
// file /usr/include/openssl/x509.h line 262
struct x509_cert_aux_st;

// tag-x509_cinf_st
// file /usr/include/openssl/x509.h line 242
struct x509_cinf_st;

// tag-x509_crl_method_st
// file /usr/include/openssl/ossl_typ.h line 157
struct x509_crl_method_st;

// tag-x509_st
// file /usr/include/openssl/ossl_typ.h line 154
struct x509_st;

// tag-x509_store_ctx_st
// file /usr/include/openssl/ossl_typ.h line 162
struct x509_store_ctx_st;

// tag-x509_store_st
// file /usr/include/openssl/ossl_typ.h line 161
struct x509_store_st;

#ifndef NULL
#define NULL ((void*)0)
#endif

// ASN1_INTEGER_set
// file /usr/include/openssl/asn1.h line 927
signed int ASN1_INTEGER_set(struct asn1_string_st *, signed long int);
// ArOptions_evaluate_values
// file ar_options_struct.h line 57
void ArOptions_evaluate_values(struct anonymous_3 *ao);
// ArOptions_free
// file ar_options_struct.h line 41
void ArOptions_free(struct anonymous_3 **ao);
// ArOptions_get_arDelay
// file ar_options_struct.h line 52
signed int ArOptions_get_arDelay(struct anonymous_3 *ao);
// ArOptions_get_arPremature
// file ar_options_struct.h line 55
char ArOptions_get_arPremature(struct anonymous_3 *ao);
// ArOptions_get_arQuit
// file ar_options_struct.h line 54
char ArOptions_get_arQuit(struct anonymous_3 *ao);
// ArOptions_get_arStart
// file ar_options_struct.h line 53
char ArOptions_get_arStart(struct anonymous_3 *ao);
// ArOptions_get_arTries
// file ar_options_struct.h line 51
signed int ArOptions_get_arTries(struct anonymous_3 *ao);
// ArOptions_new
// file ar_options_struct.h line 39
struct anonymous_3 * ArOptions_new();
// ArOptions_set_arDelay
// file ar_options_struct.c line 126
void ArOptions_set_arDelay(struct anonymous_3 *ao, signed int delay);
// ArOptions_set_arPremature
// file ar_options_struct.h line 49
void ArOptions_set_arPremature(struct anonymous_3 *ao, char premature);
// ArOptions_set_arQuit
// file ar_options_struct.h line 48
void ArOptions_set_arQuit(struct anonymous_3 *ao, char quit);
// ArOptions_set_arStart
// file ar_options_struct.h line 47
void ArOptions_set_arStart(struct anonymous_3 *ao, char start);
// ArOptions_set_arTries
// file ar_options_struct.c line 91
void ArOptions_set_arTries(struct anonymous_3 *ao, signed int tries);
// ArOptions_set_s_arDelay
// file ar_options_struct.h line 46
void ArOptions_set_s_arDelay(struct anonymous_3 *ao, char *delay);
// ArOptions_set_s_arTries
// file ar_options_struct.h line 44
void ArOptions_set_s_arTries(struct anonymous_3 *ao, char *tries);
// AuditListNode_free
// file audit_list_node_struct.c line 81
void AuditListNode_free(struct alnode **aln);
// AuditListNode_get_connectTime
// file audit_list_node_struct.c line 258
signed long int AuditListNode_get_connectTime(struct alnode *aln);
// AuditListNode_get_connectTimep
// file audit_list_node_struct.c line 309
signed long int * AuditListNode_get_connectTimep(struct alnode *aln);
// AuditListNode_get_duration
// file audit_list_node_struct.c line 275
signed long int AuditListNode_get_duration(struct alnode *aln);
// AuditListNode_get_nameBuf
// file audit_list_node_struct.c line 224
char * AuditListNode_get_nameBuf(struct alnode *aln);
// AuditListNode_get_nextNode
// file audit_list_node_struct.c line 292
struct alnode * AuditListNode_get_nextNode(struct alnode *aln);
// AuditListNode_get_portBuf
// file audit_list_node_struct.c line 241
char * AuditListNode_get_portBuf(struct alnode *aln);
// AuditListNode_get_userId
// file audit_list_node_struct.c line 207
signed int AuditListNode_get_userId(struct alnode *aln);
// AuditListNode_new
// file audit_list_node_struct.c line 36
struct alnode * AuditListNode_new();
// AuditListNode_new_entry
// file audit_list_node_struct.c line 58
struct alnode * AuditListNode_new_entry(signed int userId, char *nameBuf, char *portBuf, signed long int connectTime, signed long int duration);
// AuditListNode_set_connectTime
// file audit_list_node_struct.c line 156
void AuditListNode_set_connectTime(struct alnode *aln, signed long int connectTime);
// AuditListNode_set_duration
// file audit_list_node_struct.c line 173
void AuditListNode_set_duration(struct alnode *aln, signed long int duration);
// AuditListNode_set_nameBuf
// file audit_list_node_struct.c line 120
void AuditListNode_set_nameBuf(struct alnode *aln, char *nameBuf);
// AuditListNode_set_nextNode
// file audit_list_node_struct.c line 190
void AuditListNode_set_nextNode(struct alnode *aln, struct alnode *nextNode);
// AuditListNode_set_portBuf
// file audit_list_node_struct.c line 138
void AuditListNode_set_portBuf(struct alnode *aln, char *portBuf);
// AuditListNode_set_userId
// file audit_list_node_struct.c line 103
void AuditListNode_set_userId(struct alnode *aln, signed int userId);
// AuditList_clear
// file audit_list_struct.c line 143
void AuditList_clear(struct auditlist *al);
// AuditList_delete_first
// file audit_list_struct.c line 120
void AuditList_delete_first(struct auditlist *al);
// AuditList_free
// file audit_list_struct.c line 53
void AuditList_free(struct auditlist **al);
// AuditList_get_first
// file audit_list_struct.c line 104
struct alnode * AuditList_get_first(struct auditlist *al);
// AuditList_insert_back
// file audit_list_struct.c line 76
void AuditList_insert_back(struct auditlist *al, struct alnode *aln);
// AuditList_new
// file audit_list_struct.c line 36
struct auditlist * AuditList_new();
// BN_bn2bin
// file /usr/include/openssl/bn.h line 442
signed int BN_bn2bin(const struct bignum_st *, unsigned char *);
// BN_num_bits
// file /usr/include/openssl/bn.h line 434
signed int BN_num_bits(const struct bignum_st *);
// BufListNode_free
// file buf_list_node_struct.c line 76
void BufListNode_free(struct blnode **bln);
// BufListNode_get_actPtr
// file buf_list_node_struct.h line 42
signed int BufListNode_get_actPtr(struct blnode *bln);
// BufListNode_get_message
// file buf_list_node_struct.c line 221
unsigned char * BufListNode_get_message(struct blnode *bln);
// BufListNode_get_msgLen
// file buf_list_node_struct.c line 204
signed int BufListNode_get_msgLen(struct blnode *bln);
// BufListNode_get_nextNode
// file buf_list_node_struct.c line 238
struct blnode * BufListNode_get_nextNode(struct blnode *bln);
// BufListNode_new
// file buf_list_node_struct.c line 36
struct blnode * BufListNode_new();
// BufListNode_new_message
// file buf_list_node_struct.h line 33
struct blnode * BufListNode_new_message(signed int actPtr, signed int msgLen, unsigned char *message);
// BufListNode_readMessage
// file buf_list_node_struct.h line 47
unsigned char * BufListNode_readMessage(struct blnode *bln);
// BufListNode_readMessageLength
// file buf_list_node_struct.h line 48
signed int BufListNode_readMessageLength(struct blnode *bln);
// BufListNode_set_actPtr
// file buf_list_node_struct.h line 37
void BufListNode_set_actPtr(struct blnode *bln, signed int actPtr);
// BufListNode_set_message
// file buf_list_node_struct.c line 137
void BufListNode_set_message(struct blnode *bln, unsigned char *message, signed int msgLen);
// BufListNode_set_msgLen
// file buf_list_node_struct.c line 119
void BufListNode_set_msgLen(struct blnode *bln, signed int msgLen);
// BufListNode_set_nextNode
// file buf_list_node_struct.c line 170
void BufListNode_set_nextNode(struct blnode *bln, struct blnode *nextNode);
// BufList_clear
// file buf_list_struct.h line 39
void BufList_clear(struct buflist *bl);
// BufList_delete_first
// file buf_list_struct.h line 38
void BufList_delete_first(struct buflist *bl);
// BufList_free
// file buf_list_struct.c line 53
void BufList_free(struct buflist **bl);
// BufList_get_first
// file buf_list_struct.h line 37
struct blnode * BufList_get_first(struct buflist *bl);
// BufList_insert_back
// file buf_list_struct.h line 36
void BufList_insert_back(struct buflist *bl, struct blnode *bln);
// BufList_new
// file buf_list_struct.c line 36
struct buflist * BufList_new();
// ClientConfiguration_free
// file client_configuration_struct.c line 54
void ClientConfiguration_free(struct anonymous_4 **cc);
// ClientConfiguration_get_certificateFile
// file client_configuration_struct.h line 51
char * ClientConfiguration_get_certificateFile(struct anonymous_4 *cc);
// ClientConfiguration_get_dateFormat
// file client_configuration_struct.h line 53
char * ClientConfiguration_get_dateFormat(struct anonymous_4 *cc);
// ClientConfiguration_get_ignorePublicKeys
// file client_configuration_struct.h line 56
char ClientConfiguration_get_ignorePublicKeys(struct anonymous_4 *cc);
// ClientConfiguration_get_keysFile
// file client_configuration_struct.h line 50
char * ClientConfiguration_get_keysFile(struct anonymous_4 *cc);
// ClientConfiguration_get_realmsNumber
// file client_configuration_struct.h line 54
signed int ClientConfiguration_get_realmsNumber(struct anonymous_4 *cc);
// ClientConfiguration_get_realmsTable
// file client_configuration_struct.h line 55
struct anonymous_5 ** ClientConfiguration_get_realmsTable(struct anonymous_4 *cc);
// ClientConfiguration_get_storeFile
// file client_configuration_struct.h line 52
char * ClientConfiguration_get_storeFile(struct anonymous_4 *cc);
// ClientConfiguration_new
// file client_configuration_struct.h line 38
struct anonymous_4 * ClientConfiguration_new();
// ClientConfiguration_set_certificateFile
// file client_configuration_struct.h line 43
void ClientConfiguration_set_certificateFile(struct anonymous_4 *cc, char *certificateFile);
// ClientConfiguration_set_dateFormat
// file client_configuration_struct.h line 45
void ClientConfiguration_set_dateFormat(struct anonymous_4 *cc, char *dateFormat);
// ClientConfiguration_set_ignorePublicKeys
// file client_configuration_struct.h line 48
void ClientConfiguration_set_ignorePublicKeys(struct anonymous_4 *cc, char ignorePublicKeys);
// ClientConfiguration_set_keysFile
// file client_configuration_struct.h line 42
void ClientConfiguration_set_keysFile(struct anonymous_4 *cc, char *keysFile);
// ClientConfiguration_set_realmsNumber
// file client_configuration_struct.h line 46
void ClientConfiguration_set_realmsNumber(struct anonymous_4 *cc, signed int realmsNumber);
// ClientConfiguration_set_realmsTable
// file client_configuration_struct.h line 47
void ClientConfiguration_set_realmsTable(struct anonymous_4 *cc, struct anonymous_5 **realmsTable);
// ClientConfiguration_set_storeFile
// file client_configuration_struct.h line 44
void ClientConfiguration_set_storeFile(struct anonymous_4 *cc, char *storeFile);
// ClientRealm_closeUsersConnections
// file client_realm_struct.h line 141
void ClientRealm_closeUsersConnections(struct anonymous_5 *cr);
// ClientRealm_decrease_connectedUsers
// file client_realm_struct.c line 1106
void ClientRealm_decrease_connectedUsers(struct anonymous_5 *cr);
// ClientRealm_enable_multi
// file client_realm_struct.h line 144
void ClientRealm_enable_multi(struct anonymous_5 *cr);
// ClientRealm_free
// file client_realm_struct.h line 77
void ClientRealm_free(struct anonymous_5 **cr);
// ClientRealm_get_addressLength
// file client_realm_struct.c line 953
unsigned int ClientRealm_get_addressLength(struct anonymous_5 *cr);
// ClientRealm_get_arOptions
// file client_realm_struct.h line 131
struct anonymous_3 * ClientRealm_get_arOptions(struct anonymous_5 *cr);
// ClientRealm_get_clientAddress
// file client_realm_struct.h line 128
struct sockaddr * ClientRealm_get_clientAddress(struct anonymous_5 *cr);
// ClientRealm_get_clientMode
// file client_realm_struct.h line 122
signed int ClientRealm_get_clientMode(struct anonymous_5 *cr);
// ClientRealm_get_connectedUsers
// file client_realm_struct.c line 816
signed int ClientRealm_get_connectedUsers(struct anonymous_5 *cr);
// ClientRealm_get_destinationPorts
// file client_realm_struct.h line 132
struct portlist * ClientRealm_get_destinationPorts(struct anonymous_5 *cr);
// ClientRealm_get_hostName
// file client_realm_struct.h line 111
char * ClientRealm_get_hostName(struct anonymous_5 *cr);
// ClientRealm_get_httpProxyOptions
// file client_realm_struct.h line 130
struct anonymous * ClientRealm_get_httpProxyOptions(struct anonymous_5 *cr);
// ClientRealm_get_ipFamily
// file client_realm_struct.h line 123
char ClientRealm_get_ipFamily(struct anonymous_5 *cr);
// ClientRealm_get_keepAlive
// file client_realm_struct.c line 935
struct timeval ClientRealm_get_keepAlive(struct anonymous_5 *cr);
// ClientRealm_get_keepAlivePointer
// file client_realm_struct.h line 142
struct timeval * ClientRealm_get_keepAlivePointer(struct anonymous_5 *cr);
// ClientRealm_get_keepAliveTimeout
// file client_realm_struct.h line 121
signed int ClientRealm_get_keepAliveTimeout(struct anonymous_5 *cr);
// ClientRealm_get_localDestinationName
// file client_realm_struct.h line 117
char * ClientRealm_get_localDestinationName(struct anonymous_5 *cr);
// ClientRealm_get_localName
// file client_realm_struct.h line 115
char * ClientRealm_get_localName(struct anonymous_5 *cr);
// ClientRealm_get_localPort
// file client_realm_struct.h line 116
char * ClientRealm_get_localPort(struct anonymous_5 *cr);
// ClientRealm_get_managePort
// file client_realm_struct.h line 110
char * ClientRealm_get_managePort(struct anonymous_5 *cr);
// ClientRealm_get_masterSslFd
// file client_realm_struct.h line 129
struct anonymous_0 * ClientRealm_get_masterSslFd(struct anonymous_5 *cr);
// ClientRealm_get_password
// file client_realm_struct.h line 118
unsigned char * ClientRealm_get_password(struct anonymous_5 *cr);
// ClientRealm_get_realmId
// file client_realm_struct.h line 114
char * ClientRealm_get_realmId(struct anonymous_5 *cr);
// ClientRealm_get_realmName
// file client_realm_struct.c line 711
char * ClientRealm_get_realmName(struct anonymous_5 *cr);
// ClientRealm_get_realmType
// file client_realm_struct.h line 124
char ClientRealm_get_realmType(struct anonymous_5 *cr);
// ClientRealm_get_sKeepAliveTimeout
// file client_realm_struct.h line 113
char * ClientRealm_get_sKeepAliveTimeout(struct anonymous_5 *cr);
// ClientRealm_get_serverName
// file client_realm_struct.h line 109
char * ClientRealm_get_serverName(struct anonymous_5 *cr);
// ClientRealm_get_serviceModule
// file client_realm_struct.h line 136
struct anonymous_6 * ClientRealm_get_serviceModule(struct anonymous_5 *cr);
// ClientRealm_get_tunnelType
// file client_realm_struct.h line 125
char ClientRealm_get_tunnelType(struct anonymous_5 *cr);
// ClientRealm_get_userModule
// file client_realm_struct.h line 135
struct anonymous_6 * ClientRealm_get_userModule(struct anonymous_5 *cr);
// ClientRealm_get_usersLimit
// file client_realm_struct.h line 120
signed int ClientRealm_get_usersLimit(struct anonymous_5 *cr);
// ClientRealm_get_usersTable
// file client_realm_struct.h line 133
struct anonymous_7 ** ClientRealm_get_usersTable(struct anonymous_5 *cr);
// ClientRealm_increase_connectedUsers
// file client_realm_struct.c line 1090
void ClientRealm_increase_connectedUsers(struct anonymous_5 *cr);
// ClientRealm_new
// file client_realm_struct.h line 75
struct anonymous_5 * ClientRealm_new();
// ClientRealm_send_realmId
// file client_realm_struct.h line 143
void ClientRealm_send_realmId(struct anonymous_5 *cr, unsigned char *buff);
// ClientRealm_set_addressLength
// file client_realm_struct.h line 97
void ClientRealm_set_addressLength(struct anonymous_5 *cr, unsigned int addressLength);
// ClientRealm_set_arOptions
// file client_realm_struct.h line 101
void ClientRealm_set_arOptions(struct anonymous_5 *cr, struct anonymous_3 *arOptions);
// ClientRealm_set_clientAddress
// file client_realm_struct.h line 98
void ClientRealm_set_clientAddress(struct anonymous_5 *cr, struct sockaddr *clientAddress);
// ClientRealm_set_clientMode
// file client_realm_struct.h line 92
void ClientRealm_set_clientMode(struct anonymous_5 *cr, signed int clientMode);
// ClientRealm_set_connectedUsers
// file client_realm_struct.c line 323
void ClientRealm_set_connectedUsers(struct anonymous_5 *cr, signed int connectedUsers);
// ClientRealm_set_destinationPorts
// file client_realm_struct.h line 102
void ClientRealm_set_destinationPorts(struct anonymous_5 *cr, struct portlist *destinationPorts);
// ClientRealm_set_hostName
// file client_realm_struct.h line 81
void ClientRealm_set_hostName(struct anonymous_5 *cr, char *hostName);
// ClientRealm_set_httpProxyOptions
// file client_realm_struct.h line 100
void ClientRealm_set_httpProxyOptions(struct anonymous_5 *cr, struct anonymous *httpProxyOptions);
// ClientRealm_set_ipFamily
// file client_realm_struct.h line 93
void ClientRealm_set_ipFamily(struct anonymous_5 *cr, char ipFamily);
// ClientRealm_set_keepAlive
// file client_realm_struct.h line 96
void ClientRealm_set_keepAlive(struct anonymous_5 *cr, struct timeval keepAlive);
// ClientRealm_set_keepAliveTimeout
// file client_realm_struct.h line 91
void ClientRealm_set_keepAliveTimeout(struct anonymous_5 *cr, signed int keepAliveTimeout);
// ClientRealm_set_localDestinationName
// file client_realm_struct.h line 87
void ClientRealm_set_localDestinationName(struct anonymous_5 *cr, char *localDestinationName);
// ClientRealm_set_localName
// file client_realm_struct.h line 85
void ClientRealm_set_localName(struct anonymous_5 *cr, char *localName);
// ClientRealm_set_localPort
// file client_realm_struct.h line 86
void ClientRealm_set_localPort(struct anonymous_5 *cr, char *localPort);
// ClientRealm_set_managePort
// file client_realm_struct.h line 80
void ClientRealm_set_managePort(struct anonymous_5 *cr, char *managePort);
// ClientRealm_set_masterSslFd
// file client_realm_struct.c line 497
void ClientRealm_set_masterSslFd(struct anonymous_5 *cr, struct anonymous_0 *masterSslFd);
// ClientRealm_set_password
// file client_realm_struct.h line 88
void ClientRealm_set_password(struct anonymous_5 *cr, unsigned char *password);
// ClientRealm_set_realmId
// file client_realm_struct.h line 84
void ClientRealm_set_realmId(struct anonymous_5 *cr, char *realmId);
// ClientRealm_set_realmName
// file client_realm_struct.c line 221
void ClientRealm_set_realmName(struct anonymous_5 *cr, char *realmName);
// ClientRealm_set_realmType
// file client_realm_struct.h line 94
void ClientRealm_set_realmType(struct anonymous_5 *cr, char realmType);
// ClientRealm_set_sKeepAliveTimeout
// file client_realm_struct.h line 83
void ClientRealm_set_sKeepAliveTimeout(struct anonymous_5 *cr, char *sKeepAliveTimeout);
// ClientRealm_set_serverName
// file client_realm_struct.h line 79
void ClientRealm_set_serverName(struct anonymous_5 *cr, char *serverName);
// ClientRealm_set_serviceModule
// file client_realm_struct.h line 106
void ClientRealm_set_serviceModule(struct anonymous_5 *cr, struct anonymous_6 *serviceModule);
// ClientRealm_set_tunnelType
// file client_realm_struct.h line 95
void ClientRealm_set_tunnelType(struct anonymous_5 *cr, char tunnelType);
// ClientRealm_set_userModule
// file client_realm_struct.h line 105
void ClientRealm_set_userModule(struct anonymous_5 *cr, struct anonymous_6 *userModule);
// ClientRealm_set_usersLimit
// file client_realm_struct.h line 90
void ClientRealm_set_usersLimit(struct anonymous_5 *cr, signed int usersLimit);
// ClientRealm_set_usersTable
// file client_realm_struct.h line 103
void ClientRealm_set_usersTable(struct anonymous_5 *cr, struct anonymous_7 **usersTable);
// ConnectUser_free
// file connect_user_struct.h line 45
void ConnectUser_free(struct anonymous_7 **cu);
// ConnectUser_get_bufList
// file connect_user_struct.h line 64
struct buflist * ConnectUser_get_bufList(struct anonymous_7 *cu);
// ConnectUser_get_connFd
// file connect_user_struct.h line 58
signed int ConnectUser_get_connFd(struct anonymous_7 *cu);
// ConnectUser_get_connectTime
// file connect_user_struct.c line 323
signed long int ConnectUser_get_connectTime(struct anonymous_7 *cu);
// ConnectUser_get_nameBuf
// file connect_user_struct.h line 62
char * ConnectUser_get_nameBuf(struct anonymous_7 *cu);
// ConnectUser_get_portBuf
// file connect_user_struct.h line 63
char * ConnectUser_get_portBuf(struct anonymous_7 *cu);
// ConnectUser_get_state
// file connect_user_struct.h line 57
char ConnectUser_get_state(struct anonymous_7 *cu);
// ConnectUser_get_stats
// file connect_user_struct.c line 391
struct anonymous_14 * ConnectUser_get_stats(struct anonymous_7 *cu);
// ConnectUser_get_userId
// file connect_user_struct.c line 306
signed int ConnectUser_get_userId(struct anonymous_7 *cu);
// ConnectUser_get_whatClient
// file connect_user_struct.c line 289
signed int ConnectUser_get_whatClient(struct anonymous_7 *cu);
// ConnectUser_new
// file connect_user_struct.h line 43
struct anonymous_7 * ConnectUser_new();
// ConnectUser_set_bufList
// file connect_user_struct.c line 215
void ConnectUser_set_bufList(struct anonymous_7 *cu, struct buflist *bufList);
// ConnectUser_set_connFd
// file connect_user_struct.h line 48
void ConnectUser_set_connFd(struct anonymous_7 *cu, signed int connFd);
// ConnectUser_set_connectTime
// file connect_user_struct.c line 162
void ConnectUser_set_connectTime(struct anonymous_7 *cu, signed long int connectTime);
// ConnectUser_set_nameBuf
// file connect_user_struct.h line 52
void ConnectUser_set_nameBuf(struct anonymous_7 *cu, char *nameBuf);
// ConnectUser_set_portBuf
// file connect_user_struct.h line 53
void ConnectUser_set_portBuf(struct anonymous_7 *cu, char *portBuf);
// ConnectUser_set_state
// file connect_user_struct.h line 47
void ConnectUser_set_state(struct anonymous_7 *cu, char state);
// ConnectUser_set_stats
// file connect_user_struct.c line 235
void ConnectUser_set_stats(struct anonymous_7 *cu, struct anonymous_14 *stats);
// ConnectUser_set_userId
// file connect_user_struct.c line 145
void ConnectUser_set_userId(struct anonymous_7 *cu, signed int userId);
// ConnectUser_set_whatClient
// file connect_user_struct.c line 128
void ConnectUser_set_whatClient(struct anonymous_7 *cu, signed int whatClient);
// ERR_error_string
// file /usr/include/openssl/err.h line 334
char * ERR_error_string(unsigned long int, char *);
// ERR_get_error
// file /usr/include/openssl/err.h line 321
unsigned long int ERR_get_error(void);
// EVP_DigestFinal
// file /usr/include/openssl/evp.h line 603
signed int EVP_DigestFinal(struct env_md_ctx_st *, unsigned char *, unsigned int *);
// EVP_DigestInit
// file /usr/include/openssl/evp.h line 602
signed int EVP_DigestInit(struct env_md_ctx_st *, const struct env_md_st *);
// EVP_DigestUpdate
// file /usr/include/openssl/evp.h line 595
signed int EVP_DigestUpdate(struct env_md_ctx_st *, const void *, unsigned long int);
// EVP_PKEY_free
// file /usr/include/openssl/evp.h line 981
void EVP_PKEY_free(struct evp_pkey_st *);
// EVP_PKEY_new
// file /usr/include/openssl/evp.h line 980
struct evp_pkey_st * EVP_PKEY_new(void);
// EVP_PKEY_set1_RSA
// file /usr/include/openssl/evp.h line 961
signed int EVP_PKEY_set1_RSA(struct evp_pkey_st *, struct rsa_st *);
// EVP_md5
// file /usr/include/openssl/evp.h line 716
const struct env_md_st * EVP_md5(void);
// EVP_sha1
// file /usr/include/openssl/evp.h line 720
const struct env_md_st * EVP_sha1(void);
// HeaderBuffer_free
// file header_buffer_struct.c line 53
void HeaderBuffer_free(struct anonymous_2 **hb);
// HeaderBuffer_new
// file header_buffer_struct.c line 36
struct anonymous_2 * HeaderBuffer_new();
// HeaderBuffer_restore
// file header_buffer_struct.c line 119
void HeaderBuffer_restore(struct anonymous_2 *hb, unsigned char *buff);
// HeaderBuffer_store
// file header_buffer_struct.c line 93
void HeaderBuffer_store(struct anonymous_2 *hb, unsigned char *buff, signed int n);
// HeaderBuffer_to_read
// file header_buffer_struct.c line 75
signed int HeaderBuffer_to_read(struct anonymous_2 *hb);
// HttpProxyOptions_free
// file http_proxy_options_struct.h line 42
void HttpProxyOptions_free(struct anonymous **hpo);
// HttpProxyOptions_get_proxyauth_cred
// file http_proxy_options_struct.h line 51
char * HttpProxyOptions_get_proxyauth_cred(struct anonymous *hpo);
// HttpProxyOptions_get_proxyauth_type
// file http_proxy_options_struct.h line 52
char HttpProxyOptions_get_proxyauth_type(struct anonymous *hpo);
// HttpProxyOptions_get_proxyname
// file http_proxy_options_struct.h line 49
char * HttpProxyOptions_get_proxyname(struct anonymous *hpo);
// HttpProxyOptions_get_proxyport
// file http_proxy_options_struct.h line 50
char * HttpProxyOptions_get_proxyport(struct anonymous *hpo);
// HttpProxyOptions_is_https
// file http_proxy_options_struct.h line 55
char HttpProxyOptions_is_https(struct anonymous *hpo);
// HttpProxyOptions_new
// file http_proxy_options_struct.h line 40
struct anonymous * HttpProxyOptions_new();
// HttpProxyOptions_set_proxyauth_cred
// file http_proxy_options_struct.h line 46
void HttpProxyOptions_set_proxyauth_cred(struct anonymous *hpo, char *proxyauth_cred);
// HttpProxyOptions_set_proxyauth_type
// file http_proxy_options_struct.h line 47
void HttpProxyOptions_set_proxyauth_type(struct anonymous *hpo, char proxyauth_type);
// HttpProxyOptions_set_proxyname
// file http_proxy_options_struct.h line 44
void HttpProxyOptions_set_proxyname(struct anonymous *hpo, char *proxyname);
// HttpProxyOptions_set_proxyport
// file http_proxy_options_struct.h line 45
void HttpProxyOptions_set_proxyport(struct anonymous *hpo, char *proxyport);
// HttpProxyOptions_use_https
// file http_proxy_options_struct.h line 54
void HttpProxyOptions_use_https(struct anonymous *hpo);
// Module_free
// file module_struct.c line 56
void Module_free(struct anonymous_6 **m);
// Module_function_allow
// file module_struct.h line 50
signed int Module_function_allow(struct anonymous_6 *m, char *host, char *port);
// Module_function_filter
// file module_struct.h line 51
signed int Module_function_filter(struct anonymous_6 *m, char *host, unsigned char *message, signed int *messageLength);
// Module_function_info
// file module_struct.h line 49
char * Module_function_info(struct anonymous_6 *m);
// Module_get_fileName
// file module_struct.h line 44
char * Module_get_fileName(struct anonymous_6 *m);
// Module_isModuleLoaded
// file module_struct.h line 48
signed int Module_isModuleLoaded(struct anonymous_6 *m);
// Module_loadModule
// file module_struct.h line 46
signed int Module_loadModule(struct anonymous_6 *m);
// Module_new
// file module_struct.h line 38
struct anonymous_6 * Module_new();
// Module_releaseModule
// file module_struct.h line 47
signed int Module_releaseModule(struct anonymous_6 *m);
// Module_set_fileName
// file module_struct.h line 42
void Module_set_fileName(struct anonymous_6 *m, char *fileName);
// OBJ_txt2nid
// file /usr/include/openssl/objects.h line 1014
signed int OBJ_txt2nid(const char *);
// PEM_read_RSAPrivateKey
// file /usr/include/openssl/pem.h line 462
struct rsa_st * PEM_read_RSAPrivateKey(struct _IO_FILE *, struct rsa_st **, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_write_RSAPrivateKey
// file /usr/include/openssl/pem.h line 462
signed int PEM_write_RSAPrivateKey(struct _IO_FILE *, struct rsa_st *, const struct evp_cipher_st *, unsigned char *, signed int, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_write_X509
// file /usr/include/openssl/pem.h line 451
signed int PEM_write_X509(struct _IO_FILE *, struct x509_st *);
// PortListNode_free
// file port_list_node_struct.c line 56
void PortListNode_free(struct plnode **pln);
// PortListNode_get_nextNode
// file port_list_node_struct.c line 133
struct plnode * PortListNode_get_nextNode(struct plnode *pln);
// PortListNode_get_portName
// file port_list_node_struct.h line 37
char * PortListNode_get_portName(struct plnode *pln);
// PortListNode_new
// file port_list_node_struct.h line 30
struct plnode * PortListNode_new(char *portName);
// PortListNode_set_nextNode
// file port_list_node_struct.c line 99
void PortListNode_set_nextNode(struct plnode *pln, struct plnode *nextNode);
// PortListNode_set_portName
// file port_list_node_struct.c line 82
void PortListNode_set_portName(struct plnode *pln, char *portName);
// PortList_clear
// file port_list_struct.c line 149
void PortList_clear(struct portlist *pl);
// PortList_free
// file port_list_struct.h line 35
void PortList_free(struct portlist **pl);
// PortList_get_nth
// file port_list_struct.h line 38
struct plnode * PortList_get_nth(struct portlist *pl, signed int n);
// PortList_get_size
// file port_list_struct.h line 39
signed int PortList_get_size(struct portlist *pl);
// PortList_insert_back
// file port_list_struct.h line 37
void PortList_insert_back(struct portlist *pl, struct plnode *pln);
// PortList_new
// file port_list_struct.h line 33
struct portlist * PortList_new();
// RSA_check_key
// file /usr/include/openssl/rsa.h line 333
signed int RSA_check_key(const struct rsa_st *);
// RSA_generate_key
// file /usr/include/openssl/rsa.h line 326
struct rsa_st * RSA_generate_key(signed int, unsigned long int, void (*)(signed int, signed int, void *), void *);
// SSL_CIPHER_get_name
// file /usr/include/openssl/ssl.h line 2145
const char * SSL_CIPHER_get_name(const struct ssl_cipher_st *);
// SSL_CIPHER_get_version
// file /usr/include/openssl/ssl.h line 2144
char * SSL_CIPHER_get_version(const struct ssl_cipher_st *);
// SSL_CTX_new
// file /usr/include/openssl/ssl.h line 2131
struct ssl_ctx_st * SSL_CTX_new(const struct ssl_method_st *);
// SSL_CTX_set_cipher_list
// file /usr/include/openssl/ssl.h line 2130
signed int SSL_CTX_set_cipher_list(struct ssl_ctx_st *, const char *);
// SSL_CTX_use_RSAPrivateKey_file
// file /usr/include/openssl/ssl.h line 2198
signed int SSL_CTX_use_RSAPrivateKey_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_CTX_use_certificate_file
// file /usr/include/openssl/ssl.h line 2200
signed int SSL_CTX_use_certificate_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_accept
// file /usr/include/openssl/ssl.h line 2332
signed int SSL_accept(struct ssl_st *);
// SSL_clear
// file /usr/include/openssl/ssl.h line 2138
signed int SSL_clear(struct ssl_st *);
// SSL_connect
// file /usr/include/openssl/ssl.h line 2333
signed int SSL_connect(struct ssl_st *);
// SSL_free
// file /usr/include/openssl/ssl.h line 2331
void SSL_free(struct ssl_st *);
// SSL_get_current_cipher
// file /usr/include/openssl/ssl.h line 2142
const struct ssl_cipher_st * SSL_get_current_cipher(const struct ssl_st *);
// SSL_get_error
// file /usr/include/openssl/ssl.h line 2342
signed int SSL_get_error(const struct ssl_st *, signed int);
// SSL_get_peer_certificate
// file /usr/include/openssl/ssl.h line 2253
struct x509_st * SSL_get_peer_certificate(const struct ssl_st *);
// SSL_library_init
// file /usr/include/openssl/ssl.h line 2419
signed int SSL_library_init(void);
// SSL_load_error_strings
// file /usr/include/openssl/ssl.h line 2216
void SSL_load_error_strings(void);
// SSL_new
// file /usr/include/openssl/ssl.h line 2291
struct ssl_st * SSL_new(struct ssl_ctx_st *);
// SSL_read
// file /usr/include/openssl/ssl.h line 2334
signed int SSL_read(struct ssl_st *, void *, signed int);
// SSL_readn
// file network.c line 483
signed int SSL_readn(struct ssl_st *fd, unsigned char *buf, signed int amount);
// SSL_set_fd
// file /usr/include/openssl/ssl.h line 2156
signed int SSL_set_fd(struct ssl_st *, signed int);
// SSL_write
// file /usr/include/openssl/ssl.h line 2336
signed int SSL_write(struct ssl_st *, const void *, signed int);
// SSL_writen
// file network.c line 454
signed int SSL_writen(struct ssl_st *fd, unsigned char *buf, signed int amount);
// SSLv3_client_method
// file /usr/include/openssl/ssl.h line 2357
const struct ssl_method_st * SSLv3_client_method(void);
// SslFd_free
// file ssl_fd_struct.c line 54
void SslFd_free(struct anonymous_0 **sf);
// SslFd_get_fd
// file ssl_fd_struct.h line 41
signed int SslFd_get_fd(struct anonymous_0 *sf);
// SslFd_get_message
// file ssl_fd_struct.h line 45
signed int SslFd_get_message(char type, struct anonymous_0 *sf, unsigned char *buf, signed int amount);
// SslFd_get_ssl
// file ssl_fd_struct.h line 42
struct ssl_st * SslFd_get_ssl(struct anonymous_0 *sf);
// SslFd_new
// file ssl_fd_struct.h line 33
struct anonymous_0 * SslFd_new();
// SslFd_send_message
// file ssl_fd_struct.h line 44
signed int SslFd_send_message(char type, struct anonymous_0 *sf, unsigned char *buf, signed int amount);
// SslFd_set_fd
// file ssl_fd_struct.h line 37
void SslFd_set_fd(struct anonymous_0 *sf, signed int fd);
// SslFd_set_ssl
// file ssl_fd_struct.h line 38
void SslFd_set_ssl(struct anonymous_0 *sf, struct ssl_st *ssl);
// SslFd_set_ssl_general
// file ssl_fd_struct.c line 98
void SslFd_set_ssl_general(struct anonymous_0 *sf, struct ssl_st *ssl, signed int free);
// SslFd_set_ssl_nf
// file ssl_fd_struct.c line 132
void SslFd_set_ssl_nf(struct anonymous_0 *sf, struct ssl_st *ssl);
// SslFd_swap_content
// file ssl_fd_struct.c line 315
void SslFd_swap_content(struct anonymous_0 *sf1, struct anonymous_0 *sf2);
// UserStats_add_download
// file user_stats_struct.c line 178
void UserStats_add_download(struct anonymous_14 *us, signed int bytes);
// UserStats_add_upload
// file user_stats_struct.c line 231
void UserStats_add_upload(struct anonymous_14 *us, signed int bytes);
// UserStats_clear
// file user_stats_struct.c line 376
void UserStats_clear(struct anonymous_14 *us);
// UserStats_free
// file user_stats_struct.h line 42
void UserStats_free(struct anonymous_14 **us);
// UserStats_get_downloadSpeed
// file user_stats_struct.c line 283
double UserStats_get_downloadSpeed(struct anonymous_14 *us);
// UserStats_get_lastActivity
// file user_stats_struct.c line 126
signed long int UserStats_get_lastActivity(struct anonymous_14 *us);
// UserStats_get_totalDownloadedBytes
// file user_stats_struct.c line 143
signed int UserStats_get_totalDownloadedBytes(struct anonymous_14 *us);
// UserStats_get_totalUploadedBytes
// file user_stats_struct.c line 160
signed int UserStats_get_totalUploadedBytes(struct anonymous_14 *us);
// UserStats_get_uploadSpeed
// file user_stats_struct.c line 330
double UserStats_get_uploadSpeed(struct anonymous_14 *us);
// UserStats_new
// file user_stats_struct.h line 40
struct anonymous_14 * UserStats_new();
// UserStats_set_lastActivity
// file user_stats_struct.c line 75
void UserStats_set_lastActivity(struct anonymous_14 *us, signed long int lastActivity);
// UserStats_set_totalDownloadedBytes
// file user_stats_struct.c line 92
void UserStats_set_totalDownloadedBytes(struct anonymous_14 *us, signed int totalDownloadedBytes);
// UserStats_set_totalUploadedBytes
// file user_stats_struct.c line 109
void UserStats_set_totalUploadedBytes(struct anonymous_14 *us, signed int totalUploadedBytes);
// UsrCli_free
// file usr_cli_struct.c line 54
void UsrCli_free(struct anonymous_1 **uc);
// UsrCli_get_listenFd
// file usr_cli_struct.c line 224
signed int UsrCli_get_listenFd(struct anonymous_1 *uc);
// UsrCli_get_listenHostName
// file usr_cli_struct.c line 258
char * UsrCli_get_listenHostName(struct anonymous_1 *uc);
// UsrCli_get_listenPortName
// file usr_cli_struct.c line 190
char * UsrCli_get_listenPortName(struct anonymous_1 *uc);
// UsrCli_get_manageFd
// file usr_cli_struct.c line 241
signed int UsrCli_get_manageFd(struct anonymous_1 *uc);
// UsrCli_get_manageHostName
// file usr_cli_struct.c line 275
char * UsrCli_get_manageHostName(struct anonymous_1 *uc);
// UsrCli_get_managePortName
// file usr_cli_struct.c line 207
char * UsrCli_get_managePortName(struct anonymous_1 *uc);
// UsrCli_get_number
// file usr_cli_struct.c line 292
signed int UsrCli_get_number(struct anonymous_1 *uc);
// UsrCli_new
// file usr_cli_struct.c line 37
struct anonymous_1 * UsrCli_new();
// UsrCli_set_listenFd
// file usr_cli_struct.c line 139
void UsrCli_set_listenFd(struct anonymous_1 *uc, signed int listenFd);
// UsrCli_set_listenPortName
// file usr_cli_struct.c line 83
void UsrCli_set_listenPortName(struct anonymous_1 *uc, char *listenPortName);
// UsrCli_set_manageFd
// file usr_cli_struct.c line 156
void UsrCli_set_manageFd(struct anonymous_1 *uc, signed int manageFd);
// UsrCli_set_managePortName
// file usr_cli_struct.c line 111
void UsrCli_set_managePortName(struct anonymous_1 *uc, char *managePortName);
// UsrCli_set_number
// file usr_cli_struct.c line 173
void UsrCli_set_number(struct anonymous_1 *uc, signed int number);
// X509_NAME_ENTRY_create_by_NID
// file /usr/include/openssl/x509.h line 1036
struct X509_name_entry_st * X509_NAME_ENTRY_create_by_NID(struct X509_name_entry_st **, signed int, signed int, unsigned char *, signed int);
// X509_NAME_add_entry
// file /usr/include/openssl/x509.h line 1024
signed int X509_NAME_add_entry(struct X509_name_st *, struct X509_name_entry_st *, signed int, signed int);
// X509_NAME_new
// file /usr/include/openssl/x509.h line 817
struct X509_name_st * X509_NAME_new(void);
// X509_REQ_free
// file /usr/include/openssl/x509.h line 807
void X509_REQ_free(struct X509_req_st *);
// X509_REQ_new
// file /usr/include/openssl/x509.h line 807
struct X509_req_st * X509_REQ_new(void);
// X509_REQ_set_pubkey
// file /usr/include/openssl/x509.h line 917
signed int X509_REQ_set_pubkey(struct X509_req_st *, struct evp_pkey_st *);
// X509_REQ_set_subject_name
// file /usr/include/openssl/x509.h line 916
signed int X509_REQ_set_subject_name(struct X509_req_st *, struct X509_name_st *);
// X509_REQ_sign
// file /usr/include/openssl/x509.h line 650
signed int X509_REQ_sign(struct X509_req_st *, struct evp_pkey_st *, const struct env_md_st *);
// X509_REQ_to_X509
// file /usr/include/openssl/x509.h line 779
struct x509_st * X509_REQ_to_X509(struct X509_req_st *, signed int, struct evp_pkey_st *);
// X509_free
// file /usr/include/openssl/x509.h line 823
void X509_free(struct x509_st *);
// X509_get_pubkey
// file /usr/include/openssl/x509.h line 911
struct evp_pkey_st * X509_get_pubkey(struct x509_st *);
// X509_get_serialNumber
// file /usr/include/openssl/x509.h line 903
struct asn1_string_st * X509_get_serialNumber(struct x509_st *);
// X509_set_version
// file /usr/include/openssl/x509.h line 901
signed int X509_set_version(struct x509_st *, signed long int);
// X509_sign
// file /usr/include/openssl/x509.h line 647
signed int X509_sign(struct x509_st *, struct evp_pkey_st *, const struct env_md_st *);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 401
extern signed int __xstat(signed int, const char *, struct stat *);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// add_public_key
// file ssl_routines.h line 31
void add_public_key(char *filename, char *hostname, char *keyhash);
// addlogtarget
// file logging.h line 69
void addlogtarget(char *cmdline);
// addtocg
// file stats.c line 61
void addtocg(signed int amount);
// aflog
// file logging.h line 73
void aflog(char type, char importance, const char *form, ...);
// alarm
// file /usr/include/unistd.h line 432
extern unsigned int alarm(unsigned int);
// b64_ntop
// file base64.h line 37
signed int b64_ntop(const unsigned char *src, unsigned long int srclength, char *target, unsigned long int targsize);
// b64_pton
// file base64.c line 132
signed int b64_pton(const char *src, unsigned char *target, unsigned long int targsize);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// broadcast_condition
// file thread_management.h line 31
void broadcast_condition(void);
// bzero
// file /usr/include/strings.h line 50
extern void bzero(void *, unsigned long int);
// callback
// file first_run.c line 63
static void callback(signed int i, signed int j, void *k);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_long
// file server_check.c line 99
signed int check_long(char *text, signed long int *number);
// check_public_key
// file ssl_routines.h line 29
signed int check_public_key(char *filename, char *hostname, char *keyhash);
// check_value
// file server_check.h line 24
signed int check_value(char *what, char *info);
// check_value_liberal
// file server_check.c line 67
signed int check_value_liberal(char *what, char *info);
// checklogtarget
// file logging.c line 175
signed int checklogtarget(struct llnode *target);
// checkmsgti
// file logging.c line 119
signed int checkmsgti(struct llnode *target, char *tab);
// clean_return
// file http_proxy_client.c line 48
static void clean_return(signed int sockfd);
// clear_fd
// file http_proxy_functions.c line 261
void clear_fd(signed int *fd, struct anonymous_11 *set);
// clear_sslFd
// file http_proxy_functions.c line 362
void clear_sslFd(struct anonymous_0 *sf, struct anonymous_11 *set);
// client_admin
// file client_remoteadmin.h line 35
signed int client_admin(char type, struct anonymous_0 *master, unsigned char *buff, signed int connectfd, char *id);
// client_long_usage
// file usage.h line 27
void client_long_usage(char *info);
// client_reverse_udp
// file client_reverse_udp.h line 39
void client_reverse_udp(struct anonymous_5 *cr, unsigned char *buff, signed int buflength);
// client_short_usage
// file usage.h line 26
void client_short_usage(char *info);
// client_sig_alrm
// file client_signals.h line 25
void client_sig_alrm(signed int signo);
// client_sig_int
// file client_signals.h line 24
void client_sig_int(signed int signo);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_connections
// file client_shutdown.c line 27
void close_connections(signed int usernum, struct anonymous_7 ***contable);
// close_fd
// file http_proxy_functions.c line 248
void close_fd(signed int *fd);
// compress
// file /usr/include/zlib.h line 1160
extern signed int compress(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// cparsefile
// file file.h line 38
struct anonymous_4 * cparsefile(char *name, signed int *status);
// create_apf_dir
// file first_run.h line 24
signed int create_apf_dir(char type);
// create_publickey_store
// file first_run.h line 25
signed int create_publickey_store(char **storefile);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// datum
// file logging.c line 85
char * datum(void);
// delete_user
// file http_proxy_functions.c line 77
void delete_user(struct anonymous_16 *cnts, signed int i, struct anonymous_11 *allset);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// end_critical_section
// file thread_management.h line 29
void end_critical_section(void);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// generate_certificate
// file first_run.c line 250
signed int generate_certificate(char **cerfile, char *keyfile);
// generate_rsa_key
// file first_run.h line 26
signed int generate_rsa_key(char **keyfile);
// get_cer_filename
// file first_run.c line 400
char * get_cer_filename();
// get_key_filename
// file first_run.c line 388
char * get_key_filename();
// get_ssl_error
// file make_ssl_handshake.h line 29
signed int get_ssl_error(struct anonymous_0 *sf, char *info, signed int result);
// get_store_filename
// file first_run.c line 376
char * get_store_filename();
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getcg
// file stats.h line 35
signed long int getcg(void);
// getdateformat
// file logging.c line 55
char * getdateformat();
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getloglisthead
// file logging.c line 104
struct llnode * getloglisthead();
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// http_proxy_client
// file http_proxy_client.c line 63
void * http_proxy_client(void *vptr);
// http_read
// file http_proxy_functions.c line 402
signed int http_read(char https, struct anonymous_0 *sf, unsigned char *buf, signed int amount);
// http_write
// file http_proxy_functions.c line 381
signed int http_write(char https, struct anonymous_0 *sf, unsigned char *buf, signed int amount);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// initialize_client_reverse_udp
// file client_reverse_udp.h line 38
signed int initialize_client_reverse_udp(struct anonymous_5 *cr);
// initialize_client_stage1
// file client_initialization.h line 36
signed int initialize_client_stage1(struct anonymous_5 *cr, struct ssl_ctx_st *ctx, unsigned char *buff, char wanttoexit, char ignorePublicKeys);
// initialize_client_stage2
// file client_initialization.h line 38
signed int initialize_client_stage2(struct anonymous_5 *cr, unsigned char *buff, char wanttoexit);
// initialize_client_stage3
// file client_initialization.h line 39
signed int initialize_client_stage3(struct anonymous_5 *cr, signed int *buflength, struct anonymous_11 *allset, struct anonymous_11 *wset, signed int *maxfdp1, char wanttoexit);
// initialize_http_proxy_client
// file http_proxy_client.c line 531
signed int initialize_http_proxy_client(signed int *sockfd, struct anonymous_5 *cr, struct ssl_ctx_st *ctx);
// initializelogging
// file logging.h line 71
void initializelogging(char verl, char *dateformat);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// ip_connect
// file network.h line 40
signed int ip_connect(signed int *sockfd, const char *host, const char *serv, const char type, const char *lhost, const char *lserv);
// ip_listen
// file network.h line 39
signed int ip_listen(signed int *sockfd, const char *host, const char *serv, unsigned int *addrlenp, const char type);
// is_this_a_mainthread
// file thread_management.c line 50
signed int is_this_a_mainthread(void);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localdate
// file logging.c line 68
char * localdate(signed long int *sec);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// loginit
// file logging.c line 334
signed int loginit(char verl, char *dateformat);
// make_ssl_accept
// file make_ssl_handshake.c line 55
signed int make_ssl_accept(struct anonymous_0 *sf);
// make_ssl_initialize
// file make_ssl_handshake.c line 37
void make_ssl_initialize(struct anonymous_0 *sf);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 321
extern signed int mkdir(const char *, unsigned int);
// myrand
// file http_proxy_functions.c line 42
signed int myrand(signed int down, signed int up);
// mysleep
// file http_proxy_functions.h line 75
void mysleep(double time);
// parse_header
// file http_proxy_functions.c line 105
signed int parse_header(struct anonymous_0 *sf, char *tab, struct anonymous_15 *hdr, char https);
// parse_line
// file file.c line 45
signed int parse_line(char *buff, char *tab1, char *tab2);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 992
extern signed int pthread_cond_broadcast(union anonymous_24 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 1000
extern signed int pthread_cond_wait(union anonymous_24 *, union anonymous_22 *);
// pthread_create
// file /usr/include/pthread.h line 244
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 253
extern void pthread_exit(void *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_lock(union anonymous_22 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 784
extern signed int pthread_mutex_unlock(union anonymous_22 *);
// pthread_self
// file /usr/include/pthread.h line 286
extern unsigned long int pthread_self(void);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_message
// file http_proxy_functions.c line 281
signed int read_message(signed int fd, signed int length, struct anonymous_16 *client, char *tab, signed int ptr);
// readn
// file network.c line 542
signed int readn(signed int fd, unsigned char *buf, signed int amount);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int,  struct sockaddr *, unsigned int *);
// remember_mainthread
// file thread_management.h line 26
void remember_mainthread(void);
// resetcg
// file stats.c line 84
void resetcg(void);
// rindex
// file /usr/include/string.h line 517
extern char * rindex(const char *, signed int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_11 *, struct anonymous_11 *, struct anonymous_11 *, struct timeval *);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int,  struct sockaddr *, unsigned int);
// server_long_usage
// file usage.c line 52
void server_long_usage(char *info);
// server_short_usage
// file usage.c line 36
void server_short_usage(char *info);
// set_fd
// file http_proxy_functions.c line 235
void set_fd(signed int fd, signed int *maxfdp1, struct anonymous_11 *allset);
// setdateformat
// file logging.c line 41
void setdateformat(char *dateformat);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_18 *);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sock_ntop
// file network.c line 350
char * sock_ntop(struct sockaddr *sa, unsigned int salen, char *namebuf, char *portbuf, char type);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// start_critical_section
// file thread_management.h line 28
void start_critical_section(void);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 453
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// string_cp
// file string_functions.h line 24
char * string_cp(char **dest, char *src);
// strlen
// file /usr/include/string.h line 399
extern unsigned long int strlen(const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeperiod
// file stats.c line 35
char * timeperiod(signed long int period);
// timeval_compare
// file timeval_functions.c line 56
signed int timeval_compare(struct timeval *first, struct timeval *second);
// timeval_create
// file timeval_functions.c line 37
struct timeval timeval_create(signed long int tv_sec, signed long int tv_usec);
// timeval_lq_zero
// file timeval_functions.c line 121
signed int timeval_lq_zero(struct timeval *timer);
// timeval_subtract
// file timeval_functions.c line 94
signed int timeval_subtract(struct timeval *first, struct timeval *second);
// uncompress
// file /usr/include/zlib.h line 1197
extern signed int uncompress(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// wait_for_condition
// file thread_management.h line 30
void wait_for_condition(void);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writen
// file network.c line 513
signed int writen(signed int fd, unsigned char *buf, signed int amount);

struct anonymous_3
{
  // artries
  char *artries;
  // tries
  signed int tries;
  // ardelay
  char *ardelay;
  // delay
  signed int delay;
  // start
  char start;
  // quit
  char quit;
  // premature
  char premature;
};

struct anonymous_4
{
  // keysFile
  char *keysFile;
  // certificateFile
  char *certificateFile;
  // storeFile
  char *storeFile;
  // dateFormat
  char *dateFormat;
  // realmsNumber
  signed int realmsNumber;
  // ignorePublicKeys
  char ignorePublicKeys;
  // realmsTable
  struct anonymous_5 **realmsTable;
};

struct anonymous_1
{
  // listenHostName
  char *listenHostName;
  // manageHostName
  char *manageHostName;
  // listenPortName
  char *listenPortName;
  // managePortName
  char *managePortName;
  // listenFd
  signed int listenFd;
  // manageFd
  signed int manageFd;
  // number
  signed int number;
};

struct anonymous
{
  // proxyname
  char *proxyname;
  // proxyport
  char *proxyport;
  // proxyauth_cred
  char *proxyauth_cred;
  // proxyauth_type
  char proxyauth_type;
  // useHttps
  char useHttps;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct anonymous_5
{
  // serverName
  char *serverName;
  // managePort
  char *managePort;
  // hostName
  char *hostName;
  // realmName
  char *realmName;
  // sKeepAliveTimeout
  char *sKeepAliveTimeout;
  // realmId
  char *realmId;
  // localName
  char *localName;
  // localPort
  char *localPort;
  // localDestinationName
  char *localDestinationName;
  // password
  unsigned char password[4l];
  // connectedUsers
  signed int connectedUsers;
  // usersLimit
  signed int usersLimit;
  // clientMode
  signed int clientMode;
  // keepAliveTimeout
  signed int keepAliveTimeout;
  // ipFamily
  char ipFamily;
  // realmType
  char realmType;
  // tunnelType
  char tunnelType;
  // keepAlive
  struct timeval keepAlive;
  // addressLength
  unsigned int addressLength;
  // clientAddress
  struct sockaddr *clientAddress;
  // masterSslFd
  struct anonymous_0 *masterSslFd;
  // httpProxyOptions
  struct anonymous *httpProxyOptions;
  // arOptions
  struct anonymous_3 *arOptions;
  // destinationPorts
  struct portlist *destinationPorts;
  // usersTable
  struct anonymous_7 **usersTable;
  // userModule
  struct anonymous_6 *userModule;
  // serviceModule
  struct anonymous_6 *serviceModule;
};

struct anonymous_31
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_29
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_21
{
  // cert_verify_md
  unsigned char cert_verify_md[128l];
  // finish_md
  unsigned char finish_md[128l];
  // finish_md_len
  signed int finish_md_len;
  // peer_finish_md
  unsigned char peer_finish_md[128l];
  // peer_finish_md_len
  signed int peer_finish_md_len;
  // message_size
  unsigned long int message_size;
  // message_type
  signed int message_type;
  // new_cipher
  const struct ssl_cipher_st *new_cipher;
  // dh
  struct dh_st *dh;
  // ecdh
  struct ec_key_st *ecdh;
  // next_state
  signed int next_state;
  // reuse_message
  signed int reuse_message;
  // cert_req
  signed int cert_req;
  // ctype_num
  signed int ctype_num;
  // ctype
  char ctype[9l];
  // ca_names
  struct stack_st_X509_NAME *ca_names;
  // use_rsa_tmp
  signed int use_rsa_tmp;
  // key_block_length
  signed int key_block_length;
  // key_block
  unsigned char *key_block;
  // new_sym_enc
  const struct evp_cipher_st *new_sym_enc;
  // new_hash
  const struct env_md_st *new_hash;
  // new_mac_pkey_type
  signed int new_mac_pkey_type;
  // new_mac_secret_size
  signed int new_mac_secret_size;
  // new_compression
  const struct ssl_comp_st *new_compression;
  // cert_request
  signed int cert_request;
};

struct anonymous_11
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_18
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_2
{
  // tab
  unsigned char tab[5l];
  // readed
  signed int readed;
};

struct anonymous_23
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_0
{
  // fd
  signed int fd;
  // ssl
  struct ssl_st *ssl;
};

struct anonymous_8
{
  // sess_connect
  signed int sess_connect;
  // sess_connect_renegotiate
  signed int sess_connect_renegotiate;
  // sess_connect_good
  signed int sess_connect_good;
  // sess_accept
  signed int sess_accept;
  // sess_accept_renegotiate
  signed int sess_accept_renegotiate;
  // sess_accept_good
  signed int sess_accept_good;
  // sess_miss
  signed int sess_miss;
  // sess_timeout
  signed int sess_timeout;
  // sess_cache_full
  signed int sess_cache_full;
  // sess_hit
  signed int sess_hit;
  // sess_cb_hit
  signed int sess_cb_hit;
};

struct anonymous_25
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_28
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_27
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_26
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_30
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_32
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_25 _kill;
  // _timer
  struct anonymous_26 _timer;
  // _rt
  struct anonymous_27 _rt;
  // _sigchld
  struct anonymous_28 _sigchld;
  // _sigfault
  struct anonymous_29 _sigfault;
  // _sigpoll
  struct anonymous_30 _sigpoll;
  // _sigsys
  struct anonymous_31 _sigsys;
};

struct anonymous_33
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_32 _sifields;
};

struct anonymous_19
{
  // sockfd
  signed int sockfd;
  // host
  char *host;
  // serv
  char *serv;
  // hpo
  struct anonymous *hpo;
  // type
  char type;
  // ctx
  struct ssl_ctx_st *ctx;
};

struct anonymous_14
{
  // lastActivity
  signed long int lastActivity;
  // lastUSQChange
  signed long int lastUSQChange;
  // lastDSQChange
  signed long int lastDSQChange;
  // totalDownloadedBytes
  signed int totalDownloadedBytes;
  // totalUploadedBytes
  signed int totalUploadedBytes;
  // uploadSQP
  signed int uploadSQP;
  // uploadSpeedQueue
  signed int uploadSpeedQueue[3l];
  // downloadSQP
  signed int downloadSQP;
  // downloadSpeedQueue
  signed int downloadSpeedQueue[3l];
};

struct anonymous_6
{
  // loaded
  char loaded;
  // fileName
  char *fileName;
  // handle
  void *handle;
  // info
  char * (*info)(void);
  // allow
  signed int (*allow)(char *, char *);
  // filter
  signed int (*filter)(char *, unsigned char *, signed int *);
};

struct anonymous_15
{
  // type
  char type;
  // id
  char id[10l];
  // ptr
  signed int ptr;
  // length
  signed int length;
  // allreaded
  signed int allreaded;
};

struct anonymous_16
{
  // read_state
  char read_state;
  // readed_length
  char readed_length[4l];
  // state
  char state;
  // id
  char id[10l];
  // postFd
  struct anonymous_0 *postFd;
  // getFd
  struct anonymous_0 *getFd;
  // sent_ptr
  signed int sent_ptr;
  // sockfd
  signed int sockfd;
  // buf
  char buf[9000l];
  // tmpbuf
  char tmpbuf[9000l];
  // tmpstate
  char tmpstate;
  // tmpFd
  struct anonymous_0 *tmpFd;
  // type
  char type;
  // tmpheader
  struct anonymous_15 tmpheader;
  // ptr
  signed int ptr;
  // length
  signed int length;
  // curreceived
  signed int curreceived;
  // toreceive
  signed int toreceive;
  // received
  signed int received;
};

struct anonymous_7
{
  // state
  char state;
  // connFd
  signed int connFd;
  // whatClient
  signed int whatClient;
  // userId
  signed int userId;
  // connectTime
  signed long int connectTime;
  // nameBuf
  char nameBuf[128l];
  // portBuf
  char portBuf[7l];
  // bufList
  struct buflist *bufList;
  // stats
  struct anonymous_14 *stats;
};

struct anonymous_20
{
  // conn_id_length
  unsigned int conn_id_length;
  // cert_type
  unsigned int cert_type;
  // cert_length
  unsigned int cert_length;
  // csl
  unsigned int csl;
  // clear
  unsigned int clear;
  // enc
  unsigned int enc;
  // ccl
  unsigned char ccl[32l];
  // cipher_spec_length
  unsigned int cipher_spec_length;
  // session_id_length
  unsigned int session_id_length;
  // clen
  unsigned int clen;
  // rlen
  unsigned int rlen;
};

union anonymous_13
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous_12
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous_17
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_33 *, void *);
};

union anonymous_10
{
  // cb_1
  void (*cb_1)(signed int, signed int, void *);
  // cb_2
  signed int (*cb_2)(signed int, signed int, struct bn_gencb_st *);
};

union anonymous_9
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_24
{
  // __data
  struct anonymous_23 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_22
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ASN1_ENCODING_st
{
  // enc
  unsigned char *enc;
  // len
  signed long int len;
  // modified
  signed int modified;
};

struct DSA_SIG_st
{
  // r
  struct bignum_st *r;
  // s
  struct bignum_st *s;
};

struct X509_VERIFY_PARAM_st
{
  // name
  char *name;
  // check_time
  signed long int check_time;
  // inh_flags
  unsigned long int inh_flags;
  // flags
  unsigned long int flags;
  // purpose
  signed int purpose;
  // trust
  signed int trust;
  // depth
  signed int depth;
  // policies
  struct stack_st_ASN1_OBJECT *policies;
  // id
  struct X509_VERIFY_PARAM_ID_st *id;
};

struct X509_algor_st
{
  // algorithm
  struct asn1_object_st *algorithm;
  // parameter
  struct asn1_type_st *parameter;
};

struct X509_crl_info_st
{
  // version
  struct asn1_string_st *version;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // issuer
  struct X509_name_st *issuer;
  // lastUpdate
  struct asn1_string_st *lastUpdate;
  // nextUpdate
  struct asn1_string_st *nextUpdate;
  // revoked
  struct stack_st_X509_REVOKED *revoked;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct X509_crl_st
{
  // crl
  struct X509_crl_info_st *crl;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
  // flags
  signed int flags;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // idp
  struct ISSUING_DIST_POINT_st *idp;
  // idp_flags
  signed int idp_flags;
  // idp_reasons
  signed int idp_reasons;
  // crl_number
  struct asn1_string_st *crl_number;
  // base_crl_number
  struct asn1_string_st *base_crl_number;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // issuers
  struct stack_st_GENERAL_NAMES *issuers;
  // meth
  const struct x509_crl_method_st *meth;
  // meth_data
  void *meth_data;
};

struct X509_name_entry_st
{
  // object
  struct asn1_object_st *object;
  // value
  struct asn1_string_st *value;
  // set
  signed int set;
  // size
  signed int size;
};

struct X509_name_st
{
  // entries
  struct stack_st_X509_NAME_ENTRY *entries;
  // modified
  signed int modified;
  // bytes
  struct buf_mem_st *bytes;
  // canon_enc
  unsigned char *canon_enc;
  // canon_enclen
  signed int canon_enclen;
};

struct X509_pubkey_st
{
  // algor
  struct X509_algor_st *algor;
  // public_key
  struct asn1_string_st *public_key;
  // pkey
  struct evp_pkey_st *pkey;
};

struct X509_req_info_st
{
  // enc
  struct ASN1_ENCODING_st enc;
  // version
  struct asn1_string_st *version;
  // subject
  struct X509_name_st *subject;
  // pubkey
  struct X509_pubkey_st *pubkey;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct X509_req_st
{
  // req_info
  struct X509_req_info_st *req_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
};

struct X509_val_st
{
  // notBefore
  struct asn1_string_st *notBefore;
  // notAfter
  struct asn1_string_st *notAfter;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct alnode
{
  // userId
  signed int userId;
  // nameBuf
  char nameBuf[128l];
  // portBuf
  char portBuf[7l];
  // connectTime
  signed long int connectTime;
  // duration
  signed long int duration;
  // nextNode
  struct alnode *nextNode;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous_12 value;
};

struct auditlist
{
  // head
  struct alnode *head;
  // tail
  struct alnode *tail;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct blnode
{
  // actPtr
  signed int actPtr;
  // msgLen
  signed int msgLen;
  // message
  unsigned char *message;
  // nextNode
  struct blnode *nextNode;
};

struct bn_gencb_st
{
  // ver
  unsigned int ver;
  // arg
  void *arg;
  // cb
  union anonymous_10 cb;
};

struct bn_mont_ctx_st
{
  // ri
  signed int ri;
  // RR
  struct bignum_st RR;
  // N
  struct bignum_st N;
  // Ni
  struct bignum_st Ni;
  // n0
  unsigned long int n0[2l];
  // flags
  signed int flags;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct buflist
{
  // head
  struct blnode *head;
  // tail
  struct blnode *tail;
};

struct comp_ctx_st
{
  // meth
  struct comp_method_st *meth;
  // compress_in
  unsigned long int compress_in;
  // compress_out
  unsigned long int compress_out;
  // expand_in
  unsigned long int expand_in;
  // expand_out
  unsigned long int expand_out;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct comp_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // init
  signed int (*init)(struct comp_ctx_st *);
  // finish
  void (*finish)(struct comp_ctx_st *);
  // compress
  signed int (*compress)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // expand
  signed int (*expand)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // ctrl
  signed long int (*ctrl)(void);
  // callback_ctrl
  signed long int (*callback_ctrl)(void);
};

struct dh_method
{
  // name
  const char *name;
  // generate_key
  signed int (*generate_key)(struct dh_st *);
  // compute_key
  signed int (*compute_key)(unsigned char *, const struct bignum_st *, struct dh_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(const struct dh_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dh_st *);
  // finish
  signed int (*finish)(struct dh_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // generate_params
  signed int (*generate_params)(struct dh_st *, signed int, signed int, struct bn_gencb_st *);
};

struct dh_st
{
  // pad
  signed int pad;
  // version
  signed int version;
  // p
  struct bignum_st *p;
  // g
  struct bignum_st *g;
  // length
  signed long int length;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // q
  struct bignum_st *q;
  // j
  struct bignum_st *j;
  // seed
  unsigned char *seed;
  // seedlen
  signed int seedlen;
  // counter
  struct bignum_st *counter;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dh_method *meth;
  // engine
  struct engine_st *engine;
};

struct dsa_method
{
  // name
  const char *name;
  // dsa_do_sign
  struct DSA_SIG_st * (*dsa_do_sign)(const unsigned char *, signed int, struct dsa_st *);
  // dsa_sign_setup
  signed int (*dsa_sign_setup)(struct dsa_st *, struct bignum_ctx *, struct bignum_st **, struct bignum_st **);
  // dsa_do_verify
  signed int (*dsa_do_verify)(const unsigned char *, signed int, struct DSA_SIG_st *, struct dsa_st *);
  // dsa_mod_exp
  signed int (*dsa_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dsa_st *);
  // finish
  signed int (*finish)(struct dsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // dsa_paramgen
  signed int (*dsa_paramgen)(struct dsa_st *, signed int, const unsigned char *, signed int, signed int *, unsigned long int *, struct bn_gencb_st *);
  // dsa_keygen
  signed int (*dsa_keygen)(struct dsa_st *);
};

struct dsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // write_params
  signed int write_params;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // g
  struct bignum_st *g;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // kinv
  struct bignum_st *kinv;
  // r
  struct bignum_st *r;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dsa_method *meth;
  // engine
  struct engine_st *engine;
};

struct dtls1_bitmap_st
{
  // map
  unsigned long int map;
  // max_seq_num
  unsigned char max_seq_num[8l];
};

struct dtls1_retransmit_state
{
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // session
  struct ssl_session_st *session;
  // epoch
  unsigned short int epoch;
};

struct record_pqueue_st
{
  // epoch
  unsigned short int epoch;
  // q
  struct _pqueue *q;
};

struct hm_header_st
{
  // type
  unsigned char type;
  // msg_len
  unsigned long int msg_len;
  // seq
  unsigned short int seq;
  // frag_off
  unsigned long int frag_off;
  // frag_len
  unsigned long int frag_len;
  // is_ccs
  unsigned int is_ccs;
  // saved_retransmit_state
  struct dtls1_retransmit_state saved_retransmit_state;
};

struct dtls1_timeout_st
{
  // read_timeouts
  unsigned int read_timeouts;
  // write_timeouts
  unsigned int write_timeouts;
  // num_alerts
  unsigned int num_alerts;
};

struct dtls1_state_st
{
  // send_cookie
  unsigned int send_cookie;
  // cookie
  unsigned char cookie[256l];
  // rcvd_cookie
  unsigned char rcvd_cookie[256l];
  // cookie_len
  unsigned int cookie_len;
  // r_epoch
  unsigned short int r_epoch;
  // w_epoch
  unsigned short int w_epoch;
  // bitmap
  struct dtls1_bitmap_st bitmap;
  // next_bitmap
  struct dtls1_bitmap_st next_bitmap;
  // handshake_write_seq
  unsigned short int handshake_write_seq;
  // next_handshake_write_seq
  unsigned short int next_handshake_write_seq;
  // handshake_read_seq
  unsigned short int handshake_read_seq;
  // last_write_sequence
  unsigned char last_write_sequence[8l];
  // unprocessed_rcds
  struct record_pqueue_st unprocessed_rcds;
  // processed_rcds
  struct record_pqueue_st processed_rcds;
  // buffered_messages
  struct _pqueue *buffered_messages;
  // sent_messages
  struct _pqueue *sent_messages;
  // buffered_app_data
  struct record_pqueue_st buffered_app_data;
  // listen
  unsigned int listen;
  // link_mtu
  unsigned int link_mtu;
  // mtu
  unsigned int mtu;
  // w_msg_hdr
  struct hm_header_st w_msg_hdr;
  // r_msg_hdr
  struct hm_header_st r_msg_hdr;
  // timeout
  struct dtls1_timeout_st timeout;
  // next_timeout
  struct timeval next_timeout;
  // timeout_duration
  unsigned short int timeout_duration;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[12l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // retransmitting
  unsigned int retransmitting;
  // change_cipher_spec_ok
  unsigned int change_cipher_spec_ok;
};

struct entry
{
  // key
  char *key;
  // value
  unsigned char *value;
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous_13 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_9 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct lhash_st_SSL_SESSION
{
  // dummy
  signed int dummy;
};

struct llnode
{
  // cmdline
  char *cmdline;
  // msgtype
  char msgtype;
  // importance
  char importance;
  // logfd
  struct _IO_FILE *logfd;
  // next
  struct llnode *next;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct plnode
{
  // portName
  char *portName;
  // nextNode
  struct plnode *nextNode;
};

struct portlist
{
  // size
  signed int size;
  // head
  struct plnode *head;
  // tail
  struct plnode *tail;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rsa_meth_st
{
  // name
  const char *name;
  // rsa_pub_enc
  signed int (*rsa_pub_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_pub_dec
  signed int (*rsa_pub_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_enc
  signed int (*rsa_priv_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_dec
  signed int (*rsa_priv_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_mod_exp
  signed int (*rsa_mod_exp)(struct bignum_st *, const struct bignum_st *, struct rsa_st *, struct bignum_ctx *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct rsa_st *);
  // finish
  signed int (*finish)(struct rsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // rsa_sign
  signed int (*rsa_sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, const struct rsa_st *);
  // rsa_verify
  signed int (*rsa_verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, const struct rsa_st *);
  // rsa_keygen
  signed int (*rsa_keygen)(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
};

struct rsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // meth
  const struct rsa_meth_st *meth;
  // engine
  struct engine_st *engine;
  // n
  struct bignum_st *n;
  // e
  struct bignum_st *e;
  // d
  struct bignum_st *d;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // dmp1
  struct bignum_st *dmp1;
  // dmq1
  struct bignum_st *dmq1;
  // iqmp
  struct bignum_st *iqmp;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
  // flags
  signed int flags;
  // _method_mod_n
  struct bn_mont_ctx_st *_method_mod_n;
  // _method_mod_p
  struct bn_mont_ctx_st *_method_mod_p;
  // _method_mod_q
  struct bn_mont_ctx_st *_method_mod_q;
  // bignum_data
  char *bignum_data;
  // blinding
  struct bn_blinding_st *blinding;
  // mt_blinding
  struct bn_blinding_st *mt_blinding;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_17 __sigaction_handler;
  // sa_mask
  struct anonymous_18 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct srp_ctx_st
{
  // SRP_cb_arg
  void *SRP_cb_arg;
  // TLS_ext_srp_username_callback
  signed int (*TLS_ext_srp_username_callback)(struct ssl_st *, signed int *, void *);
  // SRP_verify_param_callback
  signed int (*SRP_verify_param_callback)(struct ssl_st *, void *);
  // SRP_give_srp_client_pwd_callback
  char * (*SRP_give_srp_client_pwd_callback)(struct ssl_st *, void *);
  // login
  char *login;
  // N
  struct bignum_st *N;
  // g
  struct bignum_st *g;
  // s
  struct bignum_st *s;
  // B
  struct bignum_st *B;
  // A
  struct bignum_st *A;
  // a
  struct bignum_st *a;
  // b
  struct bignum_st *b;
  // v
  struct bignum_st *v;
  // info
  char *info;
  // strength
  signed int strength;
  // srp_Mask
  unsigned long int srp_Mask;
};

struct srtp_protection_profile_st
{
  // name
  const char *name;
  // id
  unsigned long int id;
};

struct ssl2_state_st
{
  // three_byte_header
  signed int three_byte_header;
  // clear_text
  signed int clear_text;
  // escape
  signed int escape;
  // ssl2_rollback
  signed int ssl2_rollback;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_buf
  const unsigned char *wpend_buf;
  // wpend_off
  signed int wpend_off;
  // wpend_len
  signed int wpend_len;
  // wpend_ret
  signed int wpend_ret;
  // rbuf_left
  signed int rbuf_left;
  // rbuf_offs
  signed int rbuf_offs;
  // rbuf
  unsigned char *rbuf;
  // wbuf
  unsigned char *wbuf;
  // write_ptr
  unsigned char *write_ptr;
  // padding
  unsigned int padding;
  // rlength
  unsigned int rlength;
  // ract_data_length
  signed int ract_data_length;
  // wlength
  unsigned int wlength;
  // wact_data_length
  signed int wact_data_length;
  // ract_data
  unsigned char *ract_data;
  // wact_data
  unsigned char *wact_data;
  // mac_data
  unsigned char *mac_data;
  // read_key
  unsigned char *read_key;
  // write_key
  unsigned char *write_key;
  // challenge_length
  unsigned int challenge_length;
  // challenge
  unsigned char challenge[32l];
  // conn_id_length
  unsigned int conn_id_length;
  // conn_id
  unsigned char conn_id[16l];
  // key_material_length
  unsigned int key_material_length;
  // key_material
  unsigned char key_material[48l];
  // read_sequence
  unsigned long int read_sequence;
  // write_sequence
  unsigned long int write_sequence;
  // tmp
  struct anonymous_20 tmp;
};

struct ssl3_buffer_st
{
  // buf
  unsigned char *buf;
  // len
  unsigned long int len;
  // offset
  signed int offset;
  // left
  signed int left;
};

struct ssl3_record_st
{
  // type
  signed int type;
  // length
  unsigned int length;
  // off
  unsigned int off;
  // data
  unsigned char *data;
  // input
  unsigned char *input;
  // comp
  unsigned char *comp;
  // epoch
  unsigned long int epoch;
  // seq_num
  unsigned char seq_num[8l];
};

struct ssl3_state_st
{
  // flags
  signed long int flags;
  // delay_buf_pop_ret
  signed int delay_buf_pop_ret;
  // read_sequence
  unsigned char read_sequence[8l];
  // read_mac_secret_size
  signed int read_mac_secret_size;
  // read_mac_secret
  unsigned char read_mac_secret[64l];
  // write_sequence
  unsigned char write_sequence[8l];
  // write_mac_secret_size
  signed int write_mac_secret_size;
  // write_mac_secret
  unsigned char write_mac_secret[64l];
  // server_random
  unsigned char server_random[32l];
  // client_random
  unsigned char client_random[32l];
  // need_empty_fragments
  signed int need_empty_fragments;
  // empty_fragment_done
  signed int empty_fragment_done;
  // init_extra
  signed int init_extra;
  // rbuf
  struct ssl3_buffer_st rbuf;
  // wbuf
  struct ssl3_buffer_st wbuf;
  // rrec
  struct ssl3_record_st rrec;
  // wrec
  struct ssl3_record_st wrec;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[4l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_type
  signed int wpend_type;
  // wpend_ret
  signed int wpend_ret;
  // wpend_buf
  const unsigned char *wpend_buf;
  // handshake_buffer
  struct bio_st *handshake_buffer;
  // handshake_dgst
  struct env_md_ctx_st **handshake_dgst;
  // change_cipher_spec
  signed int change_cipher_spec;
  // warn_alert
  signed int warn_alert;
  // fatal_alert
  signed int fatal_alert;
  // alert_dispatch
  signed int alert_dispatch;
  // send_alert
  unsigned char send_alert[2l];
  // renegotiate
  signed int renegotiate;
  // total_renegotiations
  signed int total_renegotiations;
  // num_renegotiations
  signed int num_renegotiations;
  // in_read_app_data
  signed int in_read_app_data;
  // client_opaque_prf_input
  void *client_opaque_prf_input;
  // client_opaque_prf_input_len
  unsigned long int client_opaque_prf_input_len;
  // server_opaque_prf_input
  void *server_opaque_prf_input;
  // server_opaque_prf_input_len
  unsigned long int server_opaque_prf_input_len;
  // tmp
  struct anonymous_21 tmp;
  // previous_client_finished
  unsigned char previous_client_finished[64l];
  // previous_client_finished_len
  unsigned char previous_client_finished_len;
  // previous_server_finished
  unsigned char previous_server_finished[64l];
  // previous_server_finished_len
  unsigned char previous_server_finished_len;
  // send_connection_binding
  signed int send_connection_binding;
  // next_proto_neg_seen
  signed int next_proto_neg_seen;
  // is_probably_safari
  char is_probably_safari;
  // alpn_selected
  unsigned char *alpn_selected;
  // alpn_selected_len
  unsigned int alpn_selected_len;
};

struct ssl_cipher_st
{
  // valid
  signed int valid;
  // name
  const char *name;
  // id
  unsigned long int id;
  // algorithm_mkey
  unsigned long int algorithm_mkey;
  // algorithm_auth
  unsigned long int algorithm_auth;
  // algorithm_enc
  unsigned long int algorithm_enc;
  // algorithm_mac
  unsigned long int algorithm_mac;
  // algorithm_ssl
  unsigned long int algorithm_ssl;
  // algo_strength
  unsigned long int algo_strength;
  // algorithm2
  unsigned long int algorithm2;
  // strength_bits
  signed int strength_bits;
  // alg_bits
  signed int alg_bits;
};

struct ssl_comp_st
{
  // id
  signed int id;
  // name
  const char *name;
  // method
  struct comp_method_st *method;
};

struct ssl_ctx_st
{
  // method
  const struct ssl_method_st *method;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // cert_store
  struct x509_store_st *cert_store;
  // sessions
  struct lhash_st_SSL_SESSION *sessions;
  // session_cache_size
  unsigned long int session_cache_size;
  // session_cache_head
  struct ssl_session_st *session_cache_head;
  // session_cache_tail
  struct ssl_session_st *session_cache_tail;
  // session_cache_mode
  signed int session_cache_mode;
  // session_timeout
  signed long int session_timeout;
  // new_session_cb
  signed int (*new_session_cb)(struct ssl_st *, struct ssl_session_st *);
  // remove_session_cb
  void (*remove_session_cb)(struct ssl_ctx_st *, struct ssl_session_st *);
  // get_session_cb
  struct ssl_session_st * (*get_session_cb)(struct ssl_st *, unsigned char *, signed int, signed int *);
  // stats
  struct anonymous_8 stats;
  // references
  signed int references;
  // app_verify_callback
  signed int (*app_verify_callback)(struct x509_store_ctx_st *, void *);
  // app_verify_arg
  void *app_verify_arg;
  // default_passwd_callback
  signed int (*default_passwd_callback)(char *, signed int, signed int, void *);
  // default_passwd_callback_userdata
  void *default_passwd_callback_userdata;
  // client_cert_cb
  signed int (*client_cert_cb)(struct ssl_st *, struct x509_st **, struct evp_pkey_st **);
  // app_gen_cookie_cb
  signed int (*app_gen_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int *);
  // app_verify_cookie_cb
  signed int (*app_verify_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // rsa_md5
  const struct env_md_st *rsa_md5;
  // md5
  const struct env_md_st *md5;
  // sha1
  const struct env_md_st *sha1;
  // extra_certs
  struct stack_st_X509 *extra_certs;
  // comp_methods
  struct stack_st_SSL_COMP *comp_methods;
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // cert
  struct cert_st *cert;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // verify_mode
  signed int verify_mode;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // default_verify_callback
  signed int (*default_verify_callback)(signed int, struct x509_store_ctx_st *);
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // param
  struct X509_VERIFY_PARAM_st *param;
  // quiet_shutdown
  signed int quiet_shutdown;
  // max_send_fragment
  unsigned int max_send_fragment;
  // client_cert_engine
  struct engine_st *client_cert_engine;
  // tlsext_servername_callback
  signed int (*tlsext_servername_callback)(struct ssl_st *, signed int *, void *);
  // tlsext_servername_arg
  void *tlsext_servername_arg;
  // tlsext_tick_key_name
  unsigned char tlsext_tick_key_name[16l];
  // tlsext_tick_hmac_key
  unsigned char tlsext_tick_hmac_key[16l];
  // tlsext_tick_aes_key
  unsigned char tlsext_tick_aes_key[16l];
  // tlsext_ticket_key_cb
  signed int (*tlsext_ticket_key_cb)(struct ssl_st *, unsigned char *, unsigned char *, struct evp_cipher_ctx_st *, struct hmac_ctx_st *, signed int);
  // tlsext_status_cb
  signed int (*tlsext_status_cb)(struct ssl_st *, void *);
  // tlsext_status_arg
  void *tlsext_status_arg;
  // tlsext_opaque_prf_input_callback
  signed int (*tlsext_opaque_prf_input_callback)(struct ssl_st *, void *, unsigned long int, void *);
  // tlsext_opaque_prf_input_callback_arg
  void *tlsext_opaque_prf_input_callback_arg;
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // freelist_max_len
  unsigned int freelist_max_len;
  // wbuf_freelist
  struct ssl3_buf_freelist_st *wbuf_freelist;
  // rbuf_freelist
  struct ssl3_buf_freelist_st *rbuf_freelist;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // next_protos_advertised_cb
  signed int (*next_protos_advertised_cb)(struct ssl_st *, const unsigned char **, unsigned int *, void *);
  // next_protos_advertised_cb_arg
  void *next_protos_advertised_cb_arg;
  // next_proto_select_cb
  signed int (*next_proto_select_cb)(struct ssl_st *, unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // next_proto_select_cb_arg
  void *next_proto_select_cb_arg;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // alpn_select_cb
  signed int (*alpn_select_cb)(struct ssl_st *, const unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // alpn_select_cb_arg
  void *alpn_select_cb_arg;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
};

struct ssl_method_st
{
  // version
  signed int version;
  // ssl_new
  signed int (*ssl_new)(struct ssl_st *);
  // ssl_clear
  void (*ssl_clear)(struct ssl_st *);
  // ssl_free
  void (*ssl_free)(struct ssl_st *);
  // ssl_accept
  signed int (*ssl_accept)(struct ssl_st *);
  // ssl_connect
  signed int (*ssl_connect)(struct ssl_st *);
  // ssl_read
  signed int (*ssl_read)(struct ssl_st *, void *, signed int);
  // ssl_peek
  signed int (*ssl_peek)(struct ssl_st *, void *, signed int);
  // ssl_write
  signed int (*ssl_write)(struct ssl_st *, const void *, signed int);
  // ssl_shutdown
  signed int (*ssl_shutdown)(struct ssl_st *);
  // ssl_renegotiate
  signed int (*ssl_renegotiate)(struct ssl_st *);
  // ssl_renegotiate_check
  signed int (*ssl_renegotiate_check)(struct ssl_st *);
  // ssl_get_message
  signed long int (*ssl_get_message)(struct ssl_st *, signed int, signed int, signed int, signed long int, signed int *);
  // ssl_read_bytes
  signed int (*ssl_read_bytes)(struct ssl_st *, signed int, unsigned char *, signed int, signed int);
  // ssl_write_bytes
  signed int (*ssl_write_bytes)(struct ssl_st *, signed int, const void *, signed int);
  // ssl_dispatch_alert
  signed int (*ssl_dispatch_alert)(struct ssl_st *);
  // ssl_ctrl
  signed long int (*ssl_ctrl)(struct ssl_st *, signed int, signed long int, void *);
  // ssl_ctx_ctrl
  signed long int (*ssl_ctx_ctrl)(struct ssl_ctx_st *, signed int, signed long int, void *);
  // get_cipher_by_char
  const struct ssl_cipher_st * (*get_cipher_by_char)(const unsigned char *);
  // put_cipher_by_char
  signed int (*put_cipher_by_char)(const struct ssl_cipher_st *, unsigned char *);
  // ssl_pending
  signed int (*ssl_pending)(const struct ssl_st *);
  // num_ciphers
  signed int (*num_ciphers)(void);
  // get_cipher
  const struct ssl_cipher_st * (*get_cipher)(unsigned int);
  // get_ssl_method
  struct ssl_method_st * (*get_ssl_method)(signed int);
  // get_timeout
  signed long int (*get_timeout)(void);
  // ssl3_enc
  struct ssl3_enc_method *ssl3_enc;
  // ssl_version
  signed int (*ssl_version)(void);
  // ssl_callback_ctrl
  signed long int (*ssl_callback_ctrl)(struct ssl_st *, signed int, void (*)(void));
  // ssl_ctx_callback_ctrl
  signed long int (*ssl_ctx_callback_ctrl)(struct ssl_ctx_st *, signed int, void (*)(void));
};

struct ssl_session_st
{
  // ssl_version
  signed int ssl_version;
  // key_arg_length
  unsigned int key_arg_length;
  // key_arg
  unsigned char key_arg[8l];
  // master_key_length
  signed int master_key_length;
  // master_key
  unsigned char master_key[48l];
  // session_id_length
  unsigned int session_id_length;
  // session_id
  unsigned char session_id[32l];
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_identity
  char *psk_identity;
  // not_resumable
  signed int not_resumable;
  // sess_cert
  struct sess_cert_st *sess_cert;
  // peer
  struct x509_st *peer;
  // verify_result
  signed long int verify_result;
  // references
  signed int references;
  // timeout
  signed long int timeout;
  // time
  signed long int time;
  // compress_meth
  unsigned int compress_meth;
  // cipher
  const struct ssl_cipher_st *cipher;
  // cipher_id
  unsigned long int cipher_id;
  // ciphers
  struct stack_st_SSL_CIPHER *ciphers;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // prev
  struct ssl_session_st *prev;
  // next
  struct ssl_session_st *next;
  // tlsext_hostname
  char *tlsext_hostname;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_tick
  unsigned char *tlsext_tick;
  // tlsext_ticklen
  unsigned long int tlsext_ticklen;
  // tlsext_tick_lifetime_hint
  signed long int tlsext_tick_lifetime_hint;
  // srp_username
  char *srp_username;
};

struct ssl_st
{
  // version
  signed int version;
  // type
  signed int type;
  // method
  const struct ssl_method_st *method;
  // rbio
  struct bio_st *rbio;
  // wbio
  struct bio_st *wbio;
  // bbio
  struct bio_st *bbio;
  // rwstate
  signed int rwstate;
  // in_handshake
  signed int in_handshake;
  // handshake_func
  signed int (*handshake_func)(struct ssl_st *);
  // server
  signed int server;
  // new_session
  signed int new_session;
  // quiet_shutdown
  signed int quiet_shutdown;
  // shutdown
  signed int shutdown;
  // state
  signed int state;
  // rstate
  signed int rstate;
  // init_buf
  struct buf_mem_st *init_buf;
  // init_msg
  void *init_msg;
  // init_num
  signed int init_num;
  // init_off
  signed int init_off;
  // packet
  unsigned char *packet;
  // packet_length
  unsigned int packet_length;
  // s2
  struct ssl2_state_st *s2;
  // s3
  struct ssl3_state_st *s3;
  // d1
  struct dtls1_state_st *d1;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // hit
  signed int hit;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // mac_flags
  signed int mac_flags;
  // enc_read_ctx
  struct evp_cipher_ctx_st *enc_read_ctx;
  // read_hash
  struct env_md_ctx_st *read_hash;
  // expand
  struct comp_ctx_st *expand;
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // cert
  struct cert_st *cert;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // session
  struct ssl_session_st *session;
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // verify_mode
  signed int verify_mode;
  // verify_callback
  signed int (*verify_callback)(signed int, struct x509_store_ctx_st *);
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // error
  signed int error;
  // error_code
  signed int error_code;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // ctx
  struct ssl_ctx_st *ctx;
  // debug
  signed int debug;
  // verify_result
  signed long int verify_result;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // references
  signed int references;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // first_packet
  signed int first_packet;
  // client_version
  signed int client_version;
  // max_send_fragment
  unsigned int max_send_fragment;
  // tlsext_debug_cb
  void (*tlsext_debug_cb)(struct ssl_st *, signed int, signed int, unsigned char *, signed int, void *);
  // tlsext_debug_arg
  void *tlsext_debug_arg;
  // tlsext_hostname
  char *tlsext_hostname;
  // servername_done
  signed int servername_done;
  // tlsext_status_type
  signed int tlsext_status_type;
  // tlsext_status_expected
  signed int tlsext_status_expected;
  // tlsext_ocsp_ids
  struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  // tlsext_ocsp_exts
  struct stack_st_X509_EXTENSION *tlsext_ocsp_exts;
  // tlsext_ocsp_resp
  unsigned char *tlsext_ocsp_resp;
  // tlsext_ocsp_resplen
  signed int tlsext_ocsp_resplen;
  // tlsext_ticket_expected
  signed int tlsext_ticket_expected;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_opaque_prf_input
  void *tlsext_opaque_prf_input;
  // tlsext_opaque_prf_input_len
  unsigned long int tlsext_opaque_prf_input_len;
  // tlsext_session_ticket
  struct tls_session_ticket_ext_st *tlsext_session_ticket;
  // tls_session_ticket_ext_cb
  signed int (*tls_session_ticket_ext_cb)(struct ssl_st *, const unsigned char *, signed int, void *);
  // tls_session_ticket_ext_cb_arg
  void *tls_session_ticket_ext_cb_arg;
  // tls_session_secret_cb
  signed int (*tls_session_secret_cb)(struct ssl_st *, void *, signed int *, struct stack_st_SSL_CIPHER *, struct ssl_cipher_st **, void *);
  // tls_session_secret_cb_arg
  void *tls_session_secret_cb_arg;
  // initial_ctx
  struct ssl_ctx_st *initial_ctx;
  // next_proto_negotiated
  unsigned char *next_proto_negotiated;
  // next_proto_negotiated_len
  unsigned char next_proto_negotiated_len;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // srtp_profile
  struct srtp_protection_profile_st *srtp_profile;
  // tlsext_heartbeat
  unsigned int tlsext_heartbeat;
  // tlsext_hb_pending
  unsigned int tlsext_hb_pending;
  // tlsext_hb_seq
  unsigned int tlsext_hb_seq;
  // renegotiate
  signed int renegotiate;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_ASN1_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_SRTP_PROTECTION_PROFILE
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_CIPHER
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_COMP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ALGOR
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ATTRIBUTE
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_CRL
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_EXTENSION
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_LOOKUP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME_ENTRY
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_REVOKED
{
  // stack
  struct stack_st stack;
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tls_session_ticket_ext_st
{
  // length
  unsigned short int length;
  // data
  void *data;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct x509_cert_aux_st
{
  // trust
  struct stack_st_ASN1_OBJECT *trust;
  // reject
  struct stack_st_ASN1_OBJECT *reject;
  // alias
  struct asn1_string_st *alias;
  // keyid
  struct asn1_string_st *keyid;
  // other
  struct stack_st_X509_ALGOR *other;
};

struct x509_cinf_st
{
  // version
  struct asn1_string_st *version;
  // serialNumber
  struct asn1_string_st *serialNumber;
  // signature
  struct X509_algor_st *signature;
  // issuer
  struct X509_name_st *issuer;
  // validity
  struct X509_val_st *validity;
  // subject
  struct X509_name_st *subject;
  // key
  struct X509_pubkey_st *key;
  // issuerUID
  struct asn1_string_st *issuerUID;
  // subjectUID
  struct asn1_string_st *subjectUID;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct x509_st
{
  // cert_info
  struct x509_cinf_st *cert_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // valid
  signed int valid;
  // references
  signed int references;
  // name
  char *name;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // ex_pathlen
  signed long int ex_pathlen;
  // ex_pcpathlen
  signed long int ex_pcpathlen;
  // ex_flags
  unsigned long int ex_flags;
  // ex_kusage
  unsigned long int ex_kusage;
  // ex_xkusage
  unsigned long int ex_xkusage;
  // ex_nscert
  unsigned long int ex_nscert;
  // skid
  struct asn1_string_st *skid;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // policy_cache
  struct X509_POLICY_CACHE_st *policy_cache;
  // crldp
  struct stack_st_DIST_POINT *crldp;
  // altname
  struct stack_st_GENERAL_NAME *altname;
  // nc
  struct NAME_CONSTRAINTS_st *nc;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // aux
  struct x509_cert_aux_st *aux;
};

struct x509_store_ctx_st
{
  // ctx
  struct x509_store_st *ctx;
  // current_method
  signed int current_method;
  // cert
  struct x509_st *cert;
  // untrusted
  struct stack_st_X509 *untrusted;
  // crls
  struct stack_st_X509_CRL *crls;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // other_ctx
  void *other_ctx;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // check_policy
  signed int (*check_policy)(struct x509_store_ctx_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // valid
  signed int valid;
  // last_untrusted
  signed int last_untrusted;
  // chain
  struct stack_st_X509 *chain;
  // tree
  struct X509_POLICY_TREE_st *tree;
  // explicit_policy
  signed int explicit_policy;
  // error_depth
  signed int error_depth;
  // error
  signed int error;
  // current_cert
  struct x509_st *current_cert;
  // current_issuer
  struct x509_st *current_issuer;
  // current_crl
  struct X509_crl_st *current_crl;
  // current_crl_score
  signed int current_crl_score;
  // current_reasons
  unsigned int current_reasons;
  // parent
  struct x509_store_ctx_st *parent;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct x509_store_st
{
  // cache
  signed int cache;
  // objs
  struct stack_st_X509_OBJECT *objs;
  // get_cert_methods
  struct stack_st_X509_LOOKUP *get_cert_methods;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
};


// Base64
// file base64.c line 67
static const char Base64[65l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', 0 };
// Pad64
// file base64.c line 68
static const char Pad64 = (const char)61;
// cconfig
// file afclient.c line 72
struct anonymous_4 *cconfig;
// compressgained
// file stats.c line 25
static signed long int compressgained;
// entries
// file first_run.c line 47
static struct entry entries[6l] = { { .key="countryName", .value=(unsigned char *)"PL" },
    { .key="stateOrProvinceName", .value=(unsigned char *)"War-Maz" },
    { .key="localityName", .value=(unsigned char *)"Olsztyn" },
    { .key="organizationName", .value=(unsigned char *)"gray-world.net" },
    { .key="organizationalUnitName", .value=(unsigned char *)"APF team" },
    { .key="commonName", .value=(unsigned char *)"Jeremian <jeremian [at] poczta [dot] fm>" } };
// format
// file logging.c line 32
static char format[51l] = { '%', 'Y', '-', '%', 'm', '-', '%', 'd', ' ', '%', 'H', ':', '%', 'M', ':', '%', 'S', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// head
// file logging.c line 30
static struct llnode *head = (struct llnode *)(void *)0;
// home_dir
// file first_run.c line 35
static char *home_dir = (char *)(void *)0;
// home_dir_cer
// file first_run.c line 38
static char *home_dir_cer = (char *)(void *)0;
// home_dir_key
// file first_run.c line 37
static char *home_dir_key = (char *)(void *)0;
// home_dir_store
// file first_run.c line 36
static char *home_dir_store = (char *)(void *)0;
// isseed
// file http_proxy_functions.c line 28
static char isseed;
// long_options
// file afclient.c line 25
static struct option long_options[38l] = { { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name="udpmode", .has_arg=0, .flag=((signed int *)NULL), .val=117 },
    { .name="reverseudp", .has_arg=0, .flag=((signed int *)NULL), .val=85 },
    { .name="servername", .has_arg=1, .flag=((signed int *)NULL), .val=110 },
    { .name="manageport", .has_arg=1, .flag=((signed int *)NULL), .val=109 },
    { .name="hostname", .has_arg=1, .flag=((signed int *)NULL), .val=100 },
    { .name="portnum", .has_arg=1, .flag=((signed int *)NULL), .val=112 },
    { .name="verbose", .has_arg=0, .flag=((signed int *)NULL), .val=118 },
    { .name="keyfile", .has_arg=1, .flag=((signed int *)NULL), .val=107 },
    { .name="cerfile", .has_arg=1, .flag=((signed int *)NULL), .val=99 },
    { .name="storefile", .has_arg=1, .flag=((signed int *)NULL), .val=115 },
    { .name="cfgfile", .has_arg=1, .flag=((signed int *)NULL), .val=102 },
    { .name="log", .has_arg=1, .flag=((signed int *)NULL), .val=111 },
    { .name="pass", .has_arg=1, .flag=((signed int *)NULL), .val=301 },
    { .name="ignorepkeys", .has_arg=0, .flag=((signed int *)NULL), .val=302 },
    { .name="ipv4", .has_arg=0, .flag=((signed int *)NULL), .val=52 },
    { .name="ipv6", .has_arg=0, .flag=((signed int *)NULL), .val=54 },
    { .name="load", .has_arg=1, .flag=((signed int *)NULL), .val=108 },
    { .name="Load", .has_arg=1, .flag=((signed int *)NULL), .val=76 },
    { .name="id", .has_arg=1, .flag=((signed int *)NULL), .val=105 },
    { .name="dateformat", .has_arg=1, .flag=((signed int *)NULL), .val=68 },
    { .name="remoteadmin", .has_arg=0, .flag=((signed int *)NULL), .val=114 },
    { .name="use-https", .has_arg=0, .flag=((signed int *)NULL), .val=83 },
    { .name="proxyname", .has_arg=1, .flag=((signed int *)NULL), .val=80 },
    { .name="proxyport", .has_arg=1, .flag=((signed int *)NULL), .val=88 },
    { .name="pa-t-basic", .has_arg=0, .flag=((signed int *)NULL), .val=66 },
    { .name="pa-cred", .has_arg=1, .flag=((signed int *)NULL), .val=67 },
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=86 },
    { .name="keep-alive", .has_arg=1, .flag=((signed int *)NULL), .val=75 },
    { .name="ar-tries", .has_arg=1, .flag=((signed int *)NULL), .val=65 },
    { .name="ar-delay", .has_arg=1, .flag=((signed int *)NULL), .val=84 },
    { .name="ar-start", .has_arg=0, .flag=((signed int *)NULL), .val=305 },
    { .name="ar-quit", .has_arg=0, .flag=((signed int *)NULL), .val=306 },
    { .name="noar", .has_arg=0, .flag=((signed int *)NULL), .val=307 },
    { .name="localname", .has_arg=1, .flag=((signed int *)NULL), .val=311 },
    { .name="localport", .has_arg=1, .flag=((signed int *)NULL), .val=312 },
    { .name="localdesname", .has_arg=1, .flag=((signed int *)NULL), .val=313 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// maincond
// file thread_management.c line 29
static union anonymous_24 maincond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// mainmutex
// file thread_management.c line 28
static union anonymous_22 mainmutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// mainthread
// file thread_management.c line 27
static unsigned long int mainthread;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// verlev
// file logging.c line 31
static char verlev;

// ArOptions_evaluate_values
// file ar_options_struct.h line 57
void ArOptions_evaluate_values(struct anonymous_3 *ao)
{
  if(!(ao == ((struct anonymous_3 *)NULL)))
  {
    if(!(ao->artries == ((char *)NULL)))
      ao->tries=check_value_liberal(ao->artries, "Invalid ar-tries value");

    if(!(ao->ardelay == ((char *)NULL)))
      ao->delay=check_value(ao->ardelay, "Invalid ar-delay value");

  }

}

// ArOptions_free
// file ar_options_struct.h line 41
void ArOptions_free(struct anonymous_3 **ao)
{
  if(!(ao == ((struct anonymous_3 **)NULL)))
  {
    if(!(*ao == ((struct anonymous_3 *)NULL)))
    {
      if(!((*ao)->artries == ((char *)NULL)))
      {
        free((void *)(*ao)->artries);
        (*ao)->artries = (char *)(void *)0;
      }

      if(!((*ao)->ardelay == ((char *)NULL)))
      {
        free((void *)(*ao)->ardelay);
        (*ao)->ardelay = (char *)(void *)0;
      }

      free((void *)*ao);
      *ao = (struct anonymous_3 *)(void *)0;
    }

  }

}

// ArOptions_get_arDelay
// file ar_options_struct.h line 52
signed int ArOptions_get_arDelay(struct anonymous_3 *ao)
{
  if(ao == ((struct anonymous_3 *)NULL))
    return 0;

  else
    return ao->delay;
}

// ArOptions_get_arPremature
// file ar_options_struct.h line 55
char ArOptions_get_arPremature(struct anonymous_3 *ao)
{
  if(ao == ((struct anonymous_3 *)NULL))
    return (char)0;

  else
    return ao->premature;
}

// ArOptions_get_arQuit
// file ar_options_struct.h line 54
char ArOptions_get_arQuit(struct anonymous_3 *ao)
{
  if(ao == ((struct anonymous_3 *)NULL))
    return (char)0;

  else
    return ao->quit;
}

// ArOptions_get_arStart
// file ar_options_struct.h line 53
char ArOptions_get_arStart(struct anonymous_3 *ao)
{
  if(ao == ((struct anonymous_3 *)NULL))
    return (char)0;

  else
    return ao->start;
}

// ArOptions_get_arTries
// file ar_options_struct.h line 51
signed int ArOptions_get_arTries(struct anonymous_3 *ao)
{
  if(ao == ((struct anonymous_3 *)NULL))
    return 0;

  else
    return ao->tries;
}

// ArOptions_new
// file ar_options_struct.h line 39
struct anonymous_3 * ArOptions_new()
{
  struct anonymous_3 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_3) /*32ul*/ );
  tmp = (struct anonymous_3 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_3 *)NULL))
    return (struct anonymous_3 *)(void *)0;

  else
  {
    tmp->premature = (char)1;
    tmp->delay = 5;
    tmp->tries = -1;
    return tmp;
  }
}

// ArOptions_set_arDelay
// file ar_options_struct.c line 126
void ArOptions_set_arDelay(struct anonymous_3 *ao, signed int delay)
{
  if(!(ao == ((struct anonymous_3 *)NULL)))
    ao->delay = delay;

}

// ArOptions_set_arPremature
// file ar_options_struct.h line 49
void ArOptions_set_arPremature(struct anonymous_3 *ao, char premature)
{
  if(!(ao == ((struct anonymous_3 *)NULL)))
    ao->premature = premature;

}

// ArOptions_set_arQuit
// file ar_options_struct.h line 48
void ArOptions_set_arQuit(struct anonymous_3 *ao, char quit)
{
  if(!(ao == ((struct anonymous_3 *)NULL)))
    ao->quit = quit;

}

// ArOptions_set_arStart
// file ar_options_struct.h line 47
void ArOptions_set_arStart(struct anonymous_3 *ao, char start)
{
  if(!(ao == ((struct anonymous_3 *)NULL)))
    ao->start = start;

}

// ArOptions_set_arTries
// file ar_options_struct.c line 91
void ArOptions_set_arTries(struct anonymous_3 *ao, signed int tries)
{
  if(!(ao == ((struct anonymous_3 *)NULL)))
    ao->tries = tries;

}

// ArOptions_set_s_arDelay
// file ar_options_struct.h line 46
void ArOptions_set_s_arDelay(struct anonymous_3 *ao, char *delay)
{
  if(!(ao == ((struct anonymous_3 *)NULL)))
    string_cp(&ao->ardelay, delay);

}

// ArOptions_set_s_arTries
// file ar_options_struct.h line 44
void ArOptions_set_s_arTries(struct anonymous_3 *ao, char *tries)
{
  if(!(ao == ((struct anonymous_3 *)NULL)))
    string_cp(&ao->artries, tries);

}

// AuditListNode_free
// file audit_list_node_struct.c line 81
void AuditListNode_free(struct alnode **aln)
{
  if(!(aln == ((struct alnode **)NULL)))
  {
    if(!(*aln == ((struct alnode *)NULL)))
    {
      free((void *)*aln);
      *aln = (struct alnode *)(void *)0;
    }

  }

}

// AuditListNode_get_connectTime
// file audit_list_node_struct.c line 258
signed long int AuditListNode_get_connectTime(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (signed long int)0;

  else
    return aln->connectTime;
}

// AuditListNode_get_connectTimep
// file audit_list_node_struct.c line 309
signed long int * AuditListNode_get_connectTimep(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return ((signed long int *)NULL);

  else
    return &aln->connectTime;
}

// AuditListNode_get_duration
// file audit_list_node_struct.c line 275
signed long int AuditListNode_get_duration(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (signed long int)0;

  else
    return aln->duration;
}

// AuditListNode_get_nameBuf
// file audit_list_node_struct.c line 224
char * AuditListNode_get_nameBuf(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (char *)(void *)0;

  else
    return aln->nameBuf;
}

// AuditListNode_get_nextNode
// file audit_list_node_struct.c line 292
struct alnode * AuditListNode_get_nextNode(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (struct alnode *)(void *)0;

  else
    return aln->nextNode;
}

// AuditListNode_get_portBuf
// file audit_list_node_struct.c line 241
char * AuditListNode_get_portBuf(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (char *)(void *)0;

  else
    return aln->portBuf;
}

// AuditListNode_get_userId
// file audit_list_node_struct.c line 207
signed int AuditListNode_get_userId(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return -1;

  else
    return aln->userId;
}

// AuditListNode_new
// file audit_list_node_struct.c line 36
struct alnode * AuditListNode_new()
{
  struct alnode *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct alnode) /*168ul*/ );
  tmp = (struct alnode *)return_value_calloc_1;
  if(tmp == ((struct alnode *)NULL))
    return (struct alnode *)(void *)0;

  else
    return tmp;
}

// AuditListNode_new_entry
// file audit_list_node_struct.c line 58
struct alnode * AuditListNode_new_entry(signed int userId, char *nameBuf, char *portBuf, signed long int connectTime, signed long int duration)
{
  struct alnode *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct alnode) /*168ul*/ );
  tmp = (struct alnode *)return_value_calloc_1;
  if(tmp == ((struct alnode *)NULL))
    return (struct alnode *)(void *)0;

  else
  {
    AuditListNode_set_userId(tmp, userId);
    AuditListNode_set_nameBuf(tmp, nameBuf);
    AuditListNode_set_portBuf(tmp, portBuf);
    AuditListNode_set_connectTime(tmp, connectTime);
    AuditListNode_set_duration(tmp, duration);
    return tmp;
  }
}

// AuditListNode_set_connectTime
// file audit_list_node_struct.c line 156
void AuditListNode_set_connectTime(struct alnode *aln, signed long int connectTime)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->connectTime = connectTime;

}

// AuditListNode_set_duration
// file audit_list_node_struct.c line 173
void AuditListNode_set_duration(struct alnode *aln, signed long int duration)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->duration = duration;

}

// AuditListNode_set_nameBuf
// file audit_list_node_struct.c line 120
void AuditListNode_set_nameBuf(struct alnode *aln, char *nameBuf)
{
  if(!(aln == ((struct alnode *)NULL)))
  {
    memset((void *)aln->nameBuf, 0, (unsigned long int)7);
    __builtin_strncpy(aln->nameBuf, nameBuf, (unsigned long int)6);
  }

}

// AuditListNode_set_nextNode
// file audit_list_node_struct.c line 190
void AuditListNode_set_nextNode(struct alnode *aln, struct alnode *nextNode)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->nextNode = nextNode;

}

// AuditListNode_set_portBuf
// file audit_list_node_struct.c line 138
void AuditListNode_set_portBuf(struct alnode *aln, char *portBuf)
{
  if(!(aln == ((struct alnode *)NULL)))
  {
    memset((void *)aln->portBuf, 0, (unsigned long int)7);
    __builtin_strncpy(aln->portBuf, portBuf, (unsigned long int)6);
  }

}

// AuditListNode_set_userId
// file audit_list_node_struct.c line 103
void AuditListNode_set_userId(struct alnode *aln, signed int userId)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->userId = userId;

}

// AuditList_clear
// file audit_list_struct.c line 143
void AuditList_clear(struct auditlist *al)
{
  struct alnode *return_value_AuditList_get_first_1;
  if(!(al == ((struct auditlist *)NULL)))
    do
    {
      return_value_AuditList_get_first_1=AuditList_get_first(al);
      if(return_value_AuditList_get_first_1 == ((struct alnode *)NULL))
        break;

      AuditList_delete_first(al);
    }
    while((_Bool)1);

}

// AuditList_delete_first
// file audit_list_struct.c line 120
void AuditList_delete_first(struct auditlist *al)
{
  struct alnode *tmp;
  tmp=AuditList_get_first(al);
  if(!(tmp == ((struct alnode *)NULL)))
  {
    if(tmp == al->tail)
    {
      al->tail = (struct alnode *)(void *)0;
      al->head = al->tail;
    }

    else
      al->head=AuditListNode_get_nextNode(tmp);
    AuditListNode_free(&tmp);
  }

}

// AuditList_free
// file audit_list_struct.c line 53
void AuditList_free(struct auditlist **al)
{
  if(!(al == ((struct auditlist **)NULL)))
  {
    if(!(*al == ((struct auditlist *)NULL)))
    {
      AuditList_clear(*al);
      free((void *)*al);
      *al = (struct auditlist *)(void *)0;
    }

  }

}

// AuditList_get_first
// file audit_list_struct.c line 104
struct alnode * AuditList_get_first(struct auditlist *al)
{
  if(al == ((struct auditlist *)NULL))
    return (struct alnode *)(void *)0;

  else
    return al->head;
}

// AuditList_insert_back
// file audit_list_struct.c line 76
void AuditList_insert_back(struct auditlist *al, struct alnode *aln)
{
  if(!(al == ((struct auditlist *)NULL)))
  {
    if(!(aln == ((struct alnode *)NULL)))
    {
      if(!(al->tail == ((struct alnode *)NULL)))
        al->tail->nextNode = aln;

      else
        al->head = aln;
      al->tail = aln;
      aln->nextNode = (struct alnode *)(void *)0;
    }

  }

}

// AuditList_new
// file audit_list_struct.c line 36
struct auditlist * AuditList_new()
{
  struct auditlist *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct auditlist) /*16ul*/ );
  tmp = (struct auditlist *)return_value_calloc_1;
  if(tmp == ((struct auditlist *)NULL))
    return (struct auditlist *)(void *)0;

  else
    return tmp;
}

// BufListNode_free
// file buf_list_node_struct.c line 76
void BufListNode_free(struct blnode **bln)
{
  if(!(bln == ((struct blnode **)NULL)))
  {
    if(!(*bln == ((struct blnode *)NULL)))
    {
      if(!((*bln)->message == ((unsigned char *)NULL)))
      {
        free((void *)(*bln)->message);
        (*bln)->message = (unsigned char *)(void *)0;
      }

      free((void *)*bln);
      *bln = (struct blnode *)(void *)0;
    }

  }

}

// BufListNode_get_actPtr
// file buf_list_node_struct.h line 42
signed int BufListNode_get_actPtr(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return -1;

  else
    return bln->actPtr;
}

// BufListNode_get_message
// file buf_list_node_struct.c line 221
unsigned char * BufListNode_get_message(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return (unsigned char *)(void *)0;

  else
    return bln->message;
}

// BufListNode_get_msgLen
// file buf_list_node_struct.c line 204
signed int BufListNode_get_msgLen(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return -1;

  else
    return bln->msgLen;
}

// BufListNode_get_nextNode
// file buf_list_node_struct.c line 238
struct blnode * BufListNode_get_nextNode(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return (struct blnode *)(void *)0;

  else
    return bln->nextNode;
}

// BufListNode_new
// file buf_list_node_struct.c line 36
struct blnode * BufListNode_new()
{
  struct blnode *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct blnode) /*24ul*/ );
  tmp = (struct blnode *)return_value_calloc_1;
  if(tmp == ((struct blnode *)NULL))
    return (struct blnode *)(void *)0;

  else
    return tmp;
}

// BufListNode_new_message
// file buf_list_node_struct.h line 33
struct blnode * BufListNode_new_message(signed int actPtr, signed int msgLen, unsigned char *message)
{
  struct blnode *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct blnode) /*24ul*/ );
  tmp = (struct blnode *)return_value_calloc_1;
  if(tmp == ((struct blnode *)NULL))
    return (struct blnode *)(void *)0;

  else
  {
    BufListNode_set_message(tmp, message, msgLen);
    BufListNode_set_actPtr(tmp, actPtr);
    return tmp;
  }
}

// BufListNode_readMessage
// file buf_list_node_struct.h line 47
unsigned char * BufListNode_readMessage(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    signed int return_value_BufListNode_get_actPtr_1;
    return_value_BufListNode_get_actPtr_1=BufListNode_get_actPtr(bln);
    return &bln->message[(signed long int)return_value_BufListNode_get_actPtr_1];
  }
}

// BufListNode_readMessageLength
// file buf_list_node_struct.h line 48
signed int BufListNode_readMessageLength(struct blnode *bln)
{
  signed int tmp = 0;
  if(bln == ((struct blnode *)NULL))
    return -1;

  else
  {
    unsigned char *return_value_BufListNode_get_message_1;
    return_value_BufListNode_get_message_1=BufListNode_get_message(bln);
    if(return_value_BufListNode_get_message_1 == ((unsigned char *)NULL))
      return -1;

    else
    {
      signed int return_value_BufListNode_get_msgLen_2;
      return_value_BufListNode_get_msgLen_2=BufListNode_get_msgLen(bln);
      signed int return_value_BufListNode_get_actPtr_3;
      return_value_BufListNode_get_actPtr_3=BufListNode_get_actPtr(bln);
      tmp = return_value_BufListNode_get_msgLen_2 - return_value_BufListNode_get_actPtr_3;
      if(!(tmp >= 0))
        return 0;

      else
        return tmp;
    }
  }
}

// BufListNode_set_actPtr
// file buf_list_node_struct.h line 37
void BufListNode_set_actPtr(struct blnode *bln, signed int actPtr)
{
  if(!(bln == ((struct blnode *)NULL)))
    bln->actPtr = actPtr;

}

// BufListNode_set_message
// file buf_list_node_struct.c line 137
void BufListNode_set_message(struct blnode *bln, unsigned char *message, signed int msgLen)
{
  if(!(bln == ((struct blnode *)NULL)))
  {
    if(!(bln->message == ((unsigned char *)NULL)))
    {
      free((void *)bln->message);
      bln->message = (unsigned char *)(void *)0;
    }

    BufListNode_set_actPtr(bln, 0);
    BufListNode_set_msgLen(bln, 0);
    if(!(message == ((unsigned char *)NULL)))
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)1, (unsigned long int)msgLen);
      bln->message = (unsigned char *)return_value_calloc_1;
      if(!(bln->message == ((unsigned char *)NULL)))
      {
        memcpy((void *)bln->message, (const void *)message, (unsigned long int)msgLen);
        BufListNode_set_msgLen(bln, msgLen);
      }

    }

  }

}

// BufListNode_set_msgLen
// file buf_list_node_struct.c line 119
void BufListNode_set_msgLen(struct blnode *bln, signed int msgLen)
{
  if(!(bln == ((struct blnode *)NULL)))
    bln->msgLen = msgLen;

}

// BufListNode_set_nextNode
// file buf_list_node_struct.c line 170
void BufListNode_set_nextNode(struct blnode *bln, struct blnode *nextNode)
{
  if(!(bln == ((struct blnode *)NULL)))
    bln->nextNode = nextNode;

}

// BufList_clear
// file buf_list_struct.h line 39
void BufList_clear(struct buflist *bl)
{
  struct blnode *return_value_BufList_get_first_1;
  if(!(bl == ((struct buflist *)NULL)))
    do
    {
      return_value_BufList_get_first_1=BufList_get_first(bl);
      if(return_value_BufList_get_first_1 == ((struct blnode *)NULL))
        break;

      BufList_delete_first(bl);
    }
    while((_Bool)1);

}

// BufList_delete_first
// file buf_list_struct.h line 38
void BufList_delete_first(struct buflist *bl)
{
  struct blnode *tmp;
  tmp=BufList_get_first(bl);
  if(!(tmp == ((struct blnode *)NULL)))
  {
    if(tmp == bl->tail)
    {
      bl->tail = (struct blnode *)(void *)0;
      bl->head = bl->tail;
    }

    else
      bl->head=BufListNode_get_nextNode(tmp);
    BufListNode_free(&tmp);
  }

}

// BufList_free
// file buf_list_struct.c line 53
void BufList_free(struct buflist **bl)
{
  if(!(bl == ((struct buflist **)NULL)))
  {
    if(!(*bl == ((struct buflist *)NULL)))
    {
      BufList_clear(*bl);
      free((void *)*bl);
      *bl = (struct buflist *)(void *)0;
    }

  }

}

// BufList_get_first
// file buf_list_struct.h line 37
struct blnode * BufList_get_first(struct buflist *bl)
{
  if(bl == ((struct buflist *)NULL))
    return (struct blnode *)(void *)0;

  else
    return bl->head;
}

// BufList_insert_back
// file buf_list_struct.h line 36
void BufList_insert_back(struct buflist *bl, struct blnode *bln)
{
  if(!(bl == ((struct buflist *)NULL)))
  {
    if(!(bln == ((struct blnode *)NULL)))
    {
      if(!(bl->tail == ((struct blnode *)NULL)))
        bl->tail->nextNode = bln;

      else
        bl->head = bln;
      bl->tail = bln;
      bln->nextNode = (struct blnode *)(void *)0;
    }

  }

}

// BufList_new
// file buf_list_struct.c line 36
struct buflist * BufList_new()
{
  struct buflist *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct buflist) /*16ul*/ );
  tmp = (struct buflist *)return_value_calloc_1;
  if(tmp == ((struct buflist *)NULL))
    return (struct buflist *)(void *)0;

  else
    return tmp;
}

// ClientConfiguration_free
// file client_configuration_struct.c line 54
void ClientConfiguration_free(struct anonymous_4 **cc)
{
  signed int i;
  if(!(cc == ((struct anonymous_4 **)NULL)))
  {
    if(!(*cc == ((struct anonymous_4 *)NULL)))
    {
      if(!((*cc)->keysFile == ((char *)NULL)))
      {
        free((void *)(*cc)->keysFile);
        (*cc)->keysFile = (char *)(void *)0;
      }

      if(!((*cc)->certificateFile == ((char *)NULL)))
      {
        free((void *)(*cc)->certificateFile);
        (*cc)->certificateFile = (char *)(void *)0;
      }

      if(!((*cc)->storeFile == ((char *)NULL)))
      {
        free((void *)(*cc)->storeFile);
        (*cc)->storeFile = (char *)(void *)0;
      }

      if(!((*cc)->realmsTable == ((struct anonymous_5 **)NULL)))
      {
        i = 0;
        for( ; !(i >= (*cc)->realmsNumber); i = i + 1)
          if(!((*cc)->realmsTable[(signed long int)i] == ((struct anonymous_5 *)NULL)))
            ClientRealm_free(&(*cc)->realmsTable[(signed long int)i]);

        free((void *)(*cc)->realmsTable);
        (*cc)->realmsTable = (struct anonymous_5 **)(void *)0;
      }

      free((void *)*cc);
      *cc = (struct anonymous_4 *)(void *)0;
    }

  }

}

// ClientConfiguration_get_certificateFile
// file client_configuration_struct.h line 51
char * ClientConfiguration_get_certificateFile(struct anonymous_4 *cc)
{
  if(cc == ((struct anonymous_4 *)NULL))
    return (char *)(void *)0;

  else
    return cc->certificateFile;
}

// ClientConfiguration_get_dateFormat
// file client_configuration_struct.h line 53
char * ClientConfiguration_get_dateFormat(struct anonymous_4 *cc)
{
  if(cc == ((struct anonymous_4 *)NULL))
    return (char *)(void *)0;

  else
    return cc->dateFormat;
}

// ClientConfiguration_get_ignorePublicKeys
// file client_configuration_struct.h line 56
char ClientConfiguration_get_ignorePublicKeys(struct anonymous_4 *cc)
{
  if(cc == ((struct anonymous_4 *)NULL))
    return (char)0;

  else
    return cc->ignorePublicKeys;
}

// ClientConfiguration_get_keysFile
// file client_configuration_struct.h line 50
char * ClientConfiguration_get_keysFile(struct anonymous_4 *cc)
{
  if(cc == ((struct anonymous_4 *)NULL))
    return (char *)(void *)0;

  else
    return cc->keysFile;
}

// ClientConfiguration_get_realmsNumber
// file client_configuration_struct.h line 54
signed int ClientConfiguration_get_realmsNumber(struct anonymous_4 *cc)
{
  if(cc == ((struct anonymous_4 *)NULL))
    return -1;

  else
    return cc->realmsNumber;
}

// ClientConfiguration_get_realmsTable
// file client_configuration_struct.h line 55
struct anonymous_5 ** ClientConfiguration_get_realmsTable(struct anonymous_4 *cc)
{
  if(cc == ((struct anonymous_4 *)NULL))
    return (struct anonymous_5 **)(void *)0;

  else
    return cc->realmsTable;
}

// ClientConfiguration_get_storeFile
// file client_configuration_struct.h line 52
char * ClientConfiguration_get_storeFile(struct anonymous_4 *cc)
{
  if(cc == ((struct anonymous_4 *)NULL))
    return (char *)(void *)0;

  else
    return cc->storeFile;
}

// ClientConfiguration_new
// file client_configuration_struct.h line 38
struct anonymous_4 * ClientConfiguration_new()
{
  struct anonymous_4 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_4) /*48ul*/ );
  tmp = (struct anonymous_4 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_4 *)NULL))
    return (struct anonymous_4 *)(void *)0;

  else
    return tmp;
}

// ClientConfiguration_set_certificateFile
// file client_configuration_struct.h line 43
void ClientConfiguration_set_certificateFile(struct anonymous_4 *cc, char *certificateFile)
{
  if(!(cc == ((struct anonymous_4 *)NULL)))
    string_cp(&cc->certificateFile, certificateFile);

}

// ClientConfiguration_set_dateFormat
// file client_configuration_struct.h line 45
void ClientConfiguration_set_dateFormat(struct anonymous_4 *cc, char *dateFormat)
{
  if(!(cc == ((struct anonymous_4 *)NULL)))
    string_cp(&cc->dateFormat, dateFormat);

}

// ClientConfiguration_set_ignorePublicKeys
// file client_configuration_struct.h line 48
void ClientConfiguration_set_ignorePublicKeys(struct anonymous_4 *cc, char ignorePublicKeys)
{
  if(!(cc == ((struct anonymous_4 *)NULL)))
    cc->ignorePublicKeys = ignorePublicKeys;

}

// ClientConfiguration_set_keysFile
// file client_configuration_struct.h line 42
void ClientConfiguration_set_keysFile(struct anonymous_4 *cc, char *keysFile)
{
  if(!(cc == ((struct anonymous_4 *)NULL)))
    string_cp(&cc->keysFile, keysFile);

}

// ClientConfiguration_set_realmsNumber
// file client_configuration_struct.h line 46
void ClientConfiguration_set_realmsNumber(struct anonymous_4 *cc, signed int realmsNumber)
{
  if(!(cc == ((struct anonymous_4 *)NULL)))
    cc->realmsNumber = realmsNumber;

}

// ClientConfiguration_set_realmsTable
// file client_configuration_struct.h line 47
void ClientConfiguration_set_realmsTable(struct anonymous_4 *cc, struct anonymous_5 **realmsTable)
{
  signed int i;
  if(!(cc == ((struct anonymous_4 *)NULL)))
  {
    if(!(cc->realmsTable == ((struct anonymous_5 **)NULL)))
    {
      i = 0;
      for( ; !(i >= cc->realmsNumber); i = i + 1)
        if(!(cc->realmsTable[(signed long int)i] == ((struct anonymous_5 *)NULL)))
          ClientRealm_free(&cc->realmsTable[(signed long int)i]);

      free((void *)cc->realmsTable);
      cc->realmsTable = (struct anonymous_5 **)(void *)0;
    }

    cc->realmsTable = realmsTable;
  }

}

// ClientConfiguration_set_storeFile
// file client_configuration_struct.h line 44
void ClientConfiguration_set_storeFile(struct anonymous_4 *cc, char *storeFile)
{
  if(!(cc == ((struct anonymous_4 *)NULL)))
    string_cp(&cc->storeFile, storeFile);

}

// ClientRealm_closeUsersConnections
// file client_realm_struct.h line 141
void ClientRealm_closeUsersConnections(struct anonymous_5 *cr)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    signed int return_value_ClientRealm_get_usersLimit_1;
    return_value_ClientRealm_get_usersLimit_1=ClientRealm_get_usersLimit(cr);
    close_connections(return_value_ClientRealm_get_usersLimit_1, &cr->usersTable);
  }

}

// ClientRealm_decrease_connectedUsers
// file client_realm_struct.c line 1106
void ClientRealm_decrease_connectedUsers(struct anonymous_5 *cr)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    signed int return_value_ClientRealm_get_connectedUsers_1;
    return_value_ClientRealm_get_connectedUsers_1=ClientRealm_get_connectedUsers(cr);
    ClientRealm_set_connectedUsers(cr, return_value_ClientRealm_get_connectedUsers_1 - 1);
  }

}

// ClientRealm_enable_multi
// file client_realm_struct.h line 144
void ClientRealm_enable_multi(struct anonymous_5 *cr)
{
  unsigned char buff[5l];
  struct portlist *return_value_ClientRealm_get_destinationPorts_5;
  signed int return_value_PortList_get_size_6;
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    char return_value_ClientRealm_get_realmType_7;
    return_value_ClientRealm_get_realmType_7=ClientRealm_get_realmType(cr);
    if(!((64 & (signed int)return_value_ClientRealm_get_realmType_7) == 0))
    {
      return_value_ClientRealm_get_destinationPorts_5=ClientRealm_get_destinationPorts(cr);
      return_value_PortList_get_size_6=PortList_get_size(return_value_ClientRealm_get_destinationPorts_5);
      if(return_value_PortList_get_size_6 >= 2)
      {
        buff[(signed long int)0] = (unsigned char)18;
        struct portlist *return_value_ClientRealm_get_destinationPorts_1;
        return_value_ClientRealm_get_destinationPorts_1=ClientRealm_get_destinationPorts(cr);
        signed int return_value_PortList_get_size_2;
        return_value_PortList_get_size_2=PortList_get_size(return_value_ClientRealm_get_destinationPorts_1);
        buff[(signed long int)1] = (unsigned char)return_value_PortList_get_size_2;
        buff[(signed long int)4] = (unsigned char)0;
        buff[(signed long int)3] = buff[(signed long int)4];
        buff[(signed long int)2] = buff[(signed long int)3];
        char return_value_ClientRealm_get_realmType_3;
        return_value_ClientRealm_get_realmType_3=ClientRealm_get_realmType(cr);
        struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_4;
        return_value_ClientRealm_get_masterSslFd_4=ClientRealm_get_masterSslFd(cr);
        SslFd_send_message(return_value_ClientRealm_get_realmType_3, return_value_ClientRealm_get_masterSslFd_4, buff, 5);
        aflog((char)2, (char)8, "ENABLED: MULTI (multiple tunnels managed by one afclient)");
      }

    }

  }

}

// ClientRealm_free
// file client_realm_struct.h line 77
void ClientRealm_free(struct anonymous_5 **cr)
{
  if(!(cr == ((struct anonymous_5 **)NULL)))
  {
    if(!(*cr == ((struct anonymous_5 *)NULL)))
    {
      ClientRealm_set_serverName(*cr, (char *)(void *)0);
      ClientRealm_set_managePort(*cr, (char *)(void *)0);
      ClientRealm_set_hostName(*cr, (char *)(void *)0);
      ClientRealm_set_realmName(*cr, (char *)(void *)0);
      ClientRealm_set_sKeepAliveTimeout(*cr, (char *)(void *)0);
      ClientRealm_set_realmId(*cr, (char *)(void *)0);
      ClientRealm_set_localName(*cr, (char *)(void *)0);
      ClientRealm_set_localPort(*cr, (char *)(void *)0);
      ClientRealm_set_localDestinationName(*cr, (char *)(void *)0);
      ClientRealm_set_clientAddress(*cr, (struct sockaddr *)(void *)0);
      ClientRealm_set_masterSslFd(*cr, (struct anonymous_0 *)(void *)0);
      ClientRealm_set_httpProxyOptions(*cr, (struct anonymous *)(void *)0);
      ClientRealm_set_arOptions(*cr, (struct anonymous_3 *)(void *)0);
      ClientRealm_set_destinationPorts(*cr, (struct portlist *)(void *)0);
      ClientRealm_set_usersTable(*cr, (struct anonymous_7 **)(void *)0);
      ClientRealm_set_userModule(*cr, (struct anonymous_6 *)(void *)0);
      ClientRealm_set_serviceModule(*cr, (struct anonymous_6 *)(void *)0);
      free((void *)*cr);
      *cr = (struct anonymous_5 *)(void *)0;
    }

  }

}

// ClientRealm_get_addressLength
// file client_realm_struct.c line 953
unsigned int ClientRealm_get_addressLength(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (unsigned int)0;

  else
    return cr->addressLength;
}

// ClientRealm_get_arOptions
// file client_realm_struct.h line 131
struct anonymous_3 * ClientRealm_get_arOptions(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (struct anonymous_3 *)(void *)0;

  else
    return cr->arOptions;
}

// ClientRealm_get_clientAddress
// file client_realm_struct.h line 128
struct sockaddr * ClientRealm_get_clientAddress(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (struct sockaddr *)(void *)0;

  else
    return cr->clientAddress;
}

// ClientRealm_get_clientMode
// file client_realm_struct.h line 122
signed int ClientRealm_get_clientMode(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return 0;

  else
    return cr->clientMode;
}

// ClientRealm_get_connectedUsers
// file client_realm_struct.c line 816
signed int ClientRealm_get_connectedUsers(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return -1;

  else
    return cr->connectedUsers;
}

// ClientRealm_get_destinationPorts
// file client_realm_struct.h line 132
struct portlist * ClientRealm_get_destinationPorts(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (struct portlist *)(void *)0;

  else
    return cr->destinationPorts;
}

// ClientRealm_get_hostName
// file client_realm_struct.h line 111
char * ClientRealm_get_hostName(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->hostName;
}

// ClientRealm_get_httpProxyOptions
// file client_realm_struct.h line 130
struct anonymous * ClientRealm_get_httpProxyOptions(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (struct anonymous *)(void *)0;

  else
    return cr->httpProxyOptions;
}

// ClientRealm_get_ipFamily
// file client_realm_struct.h line 123
char ClientRealm_get_ipFamily(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (char)0;

  else
    return cr->ipFamily;
}

// ClientRealm_get_keepAlive
// file client_realm_struct.c line 935
struct timeval ClientRealm_get_keepAlive(struct anonymous_5 *cr)
{
  struct timeval tmp = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
  if(cr == ((struct anonymous_5 *)NULL))
    return tmp;

  else
    return cr->keepAlive;
}

// ClientRealm_get_keepAlivePointer
// file client_realm_struct.h line 142
struct timeval * ClientRealm_get_keepAlivePointer(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (struct timeval *)(void *)0;

  else
    return &cr->keepAlive;
}

// ClientRealm_get_keepAliveTimeout
// file client_realm_struct.h line 121
signed int ClientRealm_get_keepAliveTimeout(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return 0;

  else
    return cr->keepAliveTimeout;
}

// ClientRealm_get_localDestinationName
// file client_realm_struct.h line 117
char * ClientRealm_get_localDestinationName(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->localDestinationName;
}

// ClientRealm_get_localName
// file client_realm_struct.h line 115
char * ClientRealm_get_localName(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->localName;
}

// ClientRealm_get_localPort
// file client_realm_struct.h line 116
char * ClientRealm_get_localPort(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->localPort;
}

// ClientRealm_get_managePort
// file client_realm_struct.h line 110
char * ClientRealm_get_managePort(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->managePort;
}

// ClientRealm_get_masterSslFd
// file client_realm_struct.h line 129
struct anonymous_0 * ClientRealm_get_masterSslFd(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (struct anonymous_0 *)(void *)0;

  else
    return cr->masterSslFd;
}

// ClientRealm_get_password
// file client_realm_struct.h line 118
unsigned char * ClientRealm_get_password(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (unsigned char *)(void *)0;

  else
    return cr->password;
}

// ClientRealm_get_realmId
// file client_realm_struct.h line 114
char * ClientRealm_get_realmId(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->realmId;
}

// ClientRealm_get_realmName
// file client_realm_struct.c line 711
char * ClientRealm_get_realmName(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->realmName;
}

// ClientRealm_get_realmType
// file client_realm_struct.h line 124
char ClientRealm_get_realmType(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (char)0;

  else
    return cr->realmType;
}

// ClientRealm_get_sKeepAliveTimeout
// file client_realm_struct.h line 113
char * ClientRealm_get_sKeepAliveTimeout(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->sKeepAliveTimeout;
}

// ClientRealm_get_serverName
// file client_realm_struct.h line 109
char * ClientRealm_get_serverName(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->serverName;
}

// ClientRealm_get_serviceModule
// file client_realm_struct.h line 136
struct anonymous_6 * ClientRealm_get_serviceModule(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (struct anonymous_6 *)(void *)0;

  else
    return cr->serviceModule;
}

// ClientRealm_get_tunnelType
// file client_realm_struct.h line 125
char ClientRealm_get_tunnelType(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (char)0;

  else
    return cr->tunnelType;
}

// ClientRealm_get_userModule
// file client_realm_struct.h line 135
struct anonymous_6 * ClientRealm_get_userModule(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (struct anonymous_6 *)(void *)0;

  else
    return cr->userModule;
}

// ClientRealm_get_usersLimit
// file client_realm_struct.h line 120
signed int ClientRealm_get_usersLimit(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return -1;

  else
    return cr->usersLimit;
}

// ClientRealm_get_usersTable
// file client_realm_struct.h line 133
struct anonymous_7 ** ClientRealm_get_usersTable(struct anonymous_5 *cr)
{
  if(cr == ((struct anonymous_5 *)NULL))
    return (struct anonymous_7 **)(void *)0;

  else
    return cr->usersTable;
}

// ClientRealm_increase_connectedUsers
// file client_realm_struct.c line 1090
void ClientRealm_increase_connectedUsers(struct anonymous_5 *cr)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    signed int return_value_ClientRealm_get_connectedUsers_1;
    return_value_ClientRealm_get_connectedUsers_1=ClientRealm_get_connectedUsers(cr);
    ClientRealm_set_connectedUsers(cr, return_value_ClientRealm_get_connectedUsers_1 + 1);
  }

}

// ClientRealm_new
// file client_realm_struct.h line 75
struct anonymous_5 * ClientRealm_new()
{
  struct anonymous_5 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_5) /*184ul*/ );
  tmp = (struct anonymous_5 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_5 *)NULL))
    return (struct anonymous_5 *)(void *)0;

  else
  {
    tmp->password[(signed long int)0] = (unsigned char)1;
    tmp->password[(signed long int)1] = (unsigned char)2;
    tmp->password[(signed long int)2] = (unsigned char)3;
    tmp->password[(signed long int)3] = (unsigned char)4;
    tmp->masterSslFd=SslFd_new();
    if(tmp->masterSslFd == ((struct anonymous_0 *)NULL))
    {
      ClientRealm_free(&tmp);
      return (struct anonymous_5 *)(void *)0;
    }

    else
    {
      tmp->arOptions=ArOptions_new();
      if(tmp->arOptions == ((struct anonymous_3 *)NULL))
      {
        ClientRealm_free(&tmp);
        return (struct anonymous_5 *)(void *)0;
      }

      else
      {
        tmp->httpProxyOptions=HttpProxyOptions_new();
        if(tmp->httpProxyOptions == ((struct anonymous *)NULL))
        {
          ClientRealm_free(&tmp);
          return (struct anonymous_5 *)(void *)0;
        }

        else
        {
          tmp->userModule=Module_new();
          if(tmp->userModule == ((struct anonymous_6 *)NULL))
          {
            ClientRealm_free(&tmp);
            return (struct anonymous_5 *)(void *)0;
          }

          else
          {
            tmp->serviceModule=Module_new();
            if(tmp->serviceModule == ((struct anonymous_6 *)NULL))
            {
              ClientRealm_free(&tmp);
              return (struct anonymous_5 *)(void *)0;
            }

            else
              return tmp;
          }
        }
      }
    }
  }
}

// ClientRealm_send_realmId
// file client_realm_struct.h line 143
void ClientRealm_send_realmId(struct anonymous_5 *cr, unsigned char *buff)
{
  signed int n;
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    if(!(buff == ((unsigned char *)NULL)))
    {
      char *return_value_ClientRealm_get_realmId_7;
      return_value_ClientRealm_get_realmId_7=ClientRealm_get_realmId(cr);
      if(!(return_value_ClientRealm_get_realmId_7 == ((char *)NULL)))
      {
        buff[(signed long int)0] = (unsigned char)8;
        buff[(signed long int)2] = (unsigned char)0;
        buff[(signed long int)1] = buff[(signed long int)2];
        char *return_value_ClientRealm_get_realmId_1;
        return_value_ClientRealm_get_realmId_1=ClientRealm_get_realmId(cr);
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(return_value_ClientRealm_get_realmId_1);
        n = (signed int)return_value_strlen_2;
        char *return_value_ClientRealm_get_realmId_3;
        return_value_ClientRealm_get_realmId_3=ClientRealm_get_realmId(cr);
        memcpy((void *)&buff[(signed long int)5], (const void *)return_value_ClientRealm_get_realmId_3, (unsigned long int)n);
        buff[(signed long int)3] = (unsigned char)(n >> 8);
        buff[(signed long int)4] = (unsigned char)n;
        char return_value_ClientRealm_get_realmType_4;
        return_value_ClientRealm_get_realmType_4=ClientRealm_get_realmType(cr);
        struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_5;
        return_value_ClientRealm_get_masterSslFd_5=ClientRealm_get_masterSslFd(cr);
        SslFd_send_message(return_value_ClientRealm_get_realmType_4, return_value_ClientRealm_get_masterSslFd_5, buff, n + 5);
        char *return_value_ClientRealm_get_realmId_6;
        return_value_ClientRealm_get_realmId_6=ClientRealm_get_realmId(cr);
        aflog((char)2, (char)8, "ID SENT: %s", return_value_ClientRealm_get_realmId_6);
      }

    }

  }

}

// ClientRealm_set_addressLength
// file client_realm_struct.h line 97
void ClientRealm_set_addressLength(struct anonymous_5 *cr, unsigned int addressLength)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    cr->addressLength = addressLength;

}

// ClientRealm_set_arOptions
// file client_realm_struct.h line 101
void ClientRealm_set_arOptions(struct anonymous_5 *cr, struct anonymous_3 *arOptions)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    if(!(cr->arOptions == ((struct anonymous_3 *)NULL)))
      ArOptions_free(&cr->arOptions);

    cr->arOptions = arOptions;
  }

}

// ClientRealm_set_clientAddress
// file client_realm_struct.h line 98
void ClientRealm_set_clientAddress(struct anonymous_5 *cr, struct sockaddr *clientAddress)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    if(!(cr->clientAddress == ((struct sockaddr *)NULL)))
    {
      free((void *)cr->clientAddress);
      cr->clientAddress = (struct sockaddr *)(void *)0;
    }

    cr->clientAddress = clientAddress;
  }

}

// ClientRealm_set_clientMode
// file client_realm_struct.h line 92
void ClientRealm_set_clientMode(struct anonymous_5 *cr, signed int clientMode)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    cr->clientMode = clientMode;

}

// ClientRealm_set_connectedUsers
// file client_realm_struct.c line 323
void ClientRealm_set_connectedUsers(struct anonymous_5 *cr, signed int connectedUsers)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    cr->connectedUsers = connectedUsers;

}

// ClientRealm_set_destinationPorts
// file client_realm_struct.h line 102
void ClientRealm_set_destinationPorts(struct anonymous_5 *cr, struct portlist *destinationPorts)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    if(!(cr->destinationPorts == ((struct portlist *)NULL)))
      PortList_free(&cr->destinationPorts);

    cr->destinationPorts = destinationPorts;
  }

}

// ClientRealm_set_hostName
// file client_realm_struct.h line 81
void ClientRealm_set_hostName(struct anonymous_5 *cr, char *hostName)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    string_cp(&cr->hostName, hostName);

}

// ClientRealm_set_httpProxyOptions
// file client_realm_struct.h line 100
void ClientRealm_set_httpProxyOptions(struct anonymous_5 *cr, struct anonymous *httpProxyOptions)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    if(!(cr->httpProxyOptions == ((struct anonymous *)NULL)))
      HttpProxyOptions_free(&cr->httpProxyOptions);

    cr->httpProxyOptions = httpProxyOptions;
  }

}

// ClientRealm_set_ipFamily
// file client_realm_struct.h line 93
void ClientRealm_set_ipFamily(struct anonymous_5 *cr, char ipFamily)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    cr->ipFamily = ipFamily;

}

// ClientRealm_set_keepAlive
// file client_realm_struct.h line 96
void ClientRealm_set_keepAlive(struct anonymous_5 *cr, struct timeval keepAlive)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    cr->keepAlive = keepAlive;

}

// ClientRealm_set_keepAliveTimeout
// file client_realm_struct.h line 91
void ClientRealm_set_keepAliveTimeout(struct anonymous_5 *cr, signed int keepAliveTimeout)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    cr->keepAliveTimeout = keepAliveTimeout;

}

// ClientRealm_set_localDestinationName
// file client_realm_struct.h line 87
void ClientRealm_set_localDestinationName(struct anonymous_5 *cr, char *localDestinationName)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    string_cp(&cr->localDestinationName, localDestinationName);

}

// ClientRealm_set_localName
// file client_realm_struct.h line 85
void ClientRealm_set_localName(struct anonymous_5 *cr, char *localName)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    string_cp(&cr->localName, localName);

}

// ClientRealm_set_localPort
// file client_realm_struct.h line 86
void ClientRealm_set_localPort(struct anonymous_5 *cr, char *localPort)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    string_cp(&cr->localPort, localPort);

}

// ClientRealm_set_managePort
// file client_realm_struct.h line 80
void ClientRealm_set_managePort(struct anonymous_5 *cr, char *managePort)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    string_cp(&cr->managePort, managePort);

}

// ClientRealm_set_masterSslFd
// file client_realm_struct.c line 497
void ClientRealm_set_masterSslFd(struct anonymous_5 *cr, struct anonymous_0 *masterSslFd)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    if(!(cr->masterSslFd == ((struct anonymous_0 *)NULL)))
      SslFd_free(&cr->masterSslFd);

    cr->masterSslFd = masterSslFd;
  }

}

// ClientRealm_set_password
// file client_realm_struct.h line 88
void ClientRealm_set_password(struct anonymous_5 *cr, unsigned char *password)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    memcpy((void *)cr->password, (const void *)password, (unsigned long int)4);

}

// ClientRealm_set_realmId
// file client_realm_struct.h line 84
void ClientRealm_set_realmId(struct anonymous_5 *cr, char *realmId)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    string_cp(&cr->realmId, realmId);

}

// ClientRealm_set_realmName
// file client_realm_struct.c line 221
void ClientRealm_set_realmName(struct anonymous_5 *cr, char *realmName)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    string_cp(&cr->realmName, realmName);

}

// ClientRealm_set_realmType
// file client_realm_struct.h line 94
void ClientRealm_set_realmType(struct anonymous_5 *cr, char realmType)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    cr->realmType = realmType;

}

// ClientRealm_set_sKeepAliveTimeout
// file client_realm_struct.h line 83
void ClientRealm_set_sKeepAliveTimeout(struct anonymous_5 *cr, char *sKeepAliveTimeout)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    string_cp(&cr->sKeepAliveTimeout, sKeepAliveTimeout);

}

// ClientRealm_set_serverName
// file client_realm_struct.h line 79
void ClientRealm_set_serverName(struct anonymous_5 *cr, char *serverName)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    string_cp(&cr->serverName, serverName);

}

// ClientRealm_set_serviceModule
// file client_realm_struct.h line 106
void ClientRealm_set_serviceModule(struct anonymous_5 *cr, struct anonymous_6 *serviceModule)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    if(!(cr->serviceModule == ((struct anonymous_6 *)NULL)))
      Module_free(&cr->serviceModule);

    cr->serviceModule = serviceModule;
  }

}

// ClientRealm_set_tunnelType
// file client_realm_struct.h line 95
void ClientRealm_set_tunnelType(struct anonymous_5 *cr, char tunnelType)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    cr->tunnelType = tunnelType;

}

// ClientRealm_set_userModule
// file client_realm_struct.h line 105
void ClientRealm_set_userModule(struct anonymous_5 *cr, struct anonymous_6 *userModule)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    if(!(cr->userModule == ((struct anonymous_6 *)NULL)))
      Module_free(&cr->userModule);

    cr->userModule = userModule;
  }

}

// ClientRealm_set_usersLimit
// file client_realm_struct.h line 90
void ClientRealm_set_usersLimit(struct anonymous_5 *cr, signed int usersLimit)
{
  if(!(cr == ((struct anonymous_5 *)NULL)))
    cr->usersLimit = usersLimit;

}

// ClientRealm_set_usersTable
// file client_realm_struct.h line 103
void ClientRealm_set_usersTable(struct anonymous_5 *cr, struct anonymous_7 **usersTable)
{
  signed int i;
  if(!(cr == ((struct anonymous_5 *)NULL)))
  {
    if(!(cr->usersTable == ((struct anonymous_7 **)NULL)))
    {
      i = 0;
      for( ; !(i >= cr->usersLimit); i = i + 1)
        if(!(cr->usersTable[(signed long int)i] == ((struct anonymous_7 *)NULL)))
          ConnectUser_free(&cr->usersTable[(signed long int)i]);

      free((void *)cr->usersTable);
      cr->usersTable = (struct anonymous_7 **)(void *)0;
    }

    cr->usersTable = usersTable;
  }

}

// ConnectUser_free
// file connect_user_struct.h line 45
void ConnectUser_free(struct anonymous_7 **cu)
{
  struct buflist *bftmp;
  struct anonymous_14 *ustmp;
  if(!(cu == ((struct anonymous_7 **)NULL)))
  {
    if(!(*cu == ((struct anonymous_7 *)NULL)))
    {
      bftmp=ConnectUser_get_bufList(*cu);
      ustmp=ConnectUser_get_stats(*cu);
      BufList_free(&bftmp);
      UserStats_free(&ustmp);
      free((void *)*cu);
      *cu = (struct anonymous_7 *)(void *)0;
    }

  }

}

// ConnectUser_get_bufList
// file connect_user_struct.h line 64
struct buflist * ConnectUser_get_bufList(struct anonymous_7 *cu)
{
  if(cu == ((struct anonymous_7 *)NULL))
    return (struct buflist *)(void *)0;

  else
    return cu->bufList;
}

// ConnectUser_get_connFd
// file connect_user_struct.h line 58
signed int ConnectUser_get_connFd(struct anonymous_7 *cu)
{
  if(cu == ((struct anonymous_7 *)NULL))
    return -1;

  else
    return cu->connFd;
}

// ConnectUser_get_connectTime
// file connect_user_struct.c line 323
signed long int ConnectUser_get_connectTime(struct anonymous_7 *cu)
{
  if(cu == ((struct anonymous_7 *)NULL))
    return (signed long int)0;

  else
    return cu->connectTime;
}

// ConnectUser_get_nameBuf
// file connect_user_struct.h line 62
char * ConnectUser_get_nameBuf(struct anonymous_7 *cu)
{
  if(cu == ((struct anonymous_7 *)NULL))
    return (char *)(void *)0;

  else
    return cu->nameBuf;
}

// ConnectUser_get_portBuf
// file connect_user_struct.h line 63
char * ConnectUser_get_portBuf(struct anonymous_7 *cu)
{
  if(cu == ((struct anonymous_7 *)NULL))
    return (char *)(void *)0;

  else
    return cu->portBuf;
}

// ConnectUser_get_state
// file connect_user_struct.h line 57
char ConnectUser_get_state(struct anonymous_7 *cu)
{
  if(cu == ((struct anonymous_7 *)NULL))
    return (char)0;

  else
    return cu->state;
}

// ConnectUser_get_stats
// file connect_user_struct.c line 391
struct anonymous_14 * ConnectUser_get_stats(struct anonymous_7 *cu)
{
  if(cu == ((struct anonymous_7 *)NULL))
    return (struct anonymous_14 *)(void *)0;

  else
    return cu->stats;
}

// ConnectUser_get_userId
// file connect_user_struct.c line 306
signed int ConnectUser_get_userId(struct anonymous_7 *cu)
{
  if(cu == ((struct anonymous_7 *)NULL))
    return -1;

  else
    return cu->userId;
}

// ConnectUser_get_whatClient
// file connect_user_struct.c line 289
signed int ConnectUser_get_whatClient(struct anonymous_7 *cu)
{
  if(cu == ((struct anonymous_7 *)NULL))
    return -1;

  else
    return cu->whatClient;
}

// ConnectUser_new
// file connect_user_struct.h line 43
struct anonymous_7 * ConnectUser_new()
{
  struct anonymous_7 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_7) /*176ul*/ );
  tmp = (struct anonymous_7 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_7 *)NULL))
    return (struct anonymous_7 *)(void *)0;

  else
  {
    tmp->bufList=BufList_new();
    if(tmp->bufList == ((struct buflist *)NULL))
    {
      ConnectUser_free(&tmp);
      return (struct anonymous_7 *)(void *)0;
    }

    else
    {
      tmp->stats=UserStats_new();
      if(tmp->stats == ((struct anonymous_14 *)NULL))
      {
        ConnectUser_free(&tmp);
        return (struct anonymous_7 *)(void *)0;
      }

      else
        return tmp;
    }
  }
}

// ConnectUser_set_bufList
// file connect_user_struct.c line 215
void ConnectUser_set_bufList(struct anonymous_7 *cu, struct buflist *bufList)
{
  struct buflist *bftmp;
  if(!(cu == ((struct anonymous_7 *)NULL)))
  {
    bftmp=ConnectUser_get_bufList(cu);
    BufList_free(&bftmp);
    cu->bufList = bufList;
  }

}

// ConnectUser_set_connFd
// file connect_user_struct.h line 48
void ConnectUser_set_connFd(struct anonymous_7 *cu, signed int connFd)
{
  if(!(cu == ((struct anonymous_7 *)NULL)))
    cu->connFd = connFd;

}

// ConnectUser_set_connectTime
// file connect_user_struct.c line 162
void ConnectUser_set_connectTime(struct anonymous_7 *cu, signed long int connectTime)
{
  if(!(cu == ((struct anonymous_7 *)NULL)))
    cu->connectTime = connectTime;

}

// ConnectUser_set_nameBuf
// file connect_user_struct.h line 52
void ConnectUser_set_nameBuf(struct anonymous_7 *cu, char *nameBuf)
{
  if(!(cu == ((struct anonymous_7 *)NULL)))
  {
    memset((void *)cu->nameBuf, 0, (unsigned long int)128);
    __builtin_strncpy(cu->nameBuf, nameBuf, (unsigned long int)127);
  }

}

// ConnectUser_set_portBuf
// file connect_user_struct.h line 53
void ConnectUser_set_portBuf(struct anonymous_7 *cu, char *portBuf)
{
  if(!(cu == ((struct anonymous_7 *)NULL)))
  {
    memset((void *)cu->portBuf, 0, (unsigned long int)7);
    __builtin_strncpy(cu->portBuf, portBuf, (unsigned long int)6);
  }

}

// ConnectUser_set_state
// file connect_user_struct.h line 47
void ConnectUser_set_state(struct anonymous_7 *cu, char state)
{
  if(!(cu == ((struct anonymous_7 *)NULL)))
    cu->state = state;

}

// ConnectUser_set_stats
// file connect_user_struct.c line 235
void ConnectUser_set_stats(struct anonymous_7 *cu, struct anonymous_14 *stats)
{
  struct anonymous_14 *ustmp;
  if(!(cu == ((struct anonymous_7 *)NULL)))
  {
    ustmp=ConnectUser_get_stats(cu);
    UserStats_free(&ustmp);
    cu->stats = stats;
  }

}

// ConnectUser_set_userId
// file connect_user_struct.c line 145
void ConnectUser_set_userId(struct anonymous_7 *cu, signed int userId)
{
  if(!(cu == ((struct anonymous_7 *)NULL)))
    cu->userId = userId;

}

// ConnectUser_set_whatClient
// file connect_user_struct.c line 128
void ConnectUser_set_whatClient(struct anonymous_7 *cu, signed int whatClient)
{
  if(!(cu == ((struct anonymous_7 *)NULL)))
    cu->whatClient = whatClient;

}

// HeaderBuffer_free
// file header_buffer_struct.c line 53
void HeaderBuffer_free(struct anonymous_2 **hb)
{
  if(!(hb == ((struct anonymous_2 **)NULL)))
  {
    if(!(*hb == ((struct anonymous_2 *)NULL)))
    {
      free((void *)*hb);
      *hb = (struct anonymous_2 *)(void *)0;
    }

  }

}

// HeaderBuffer_new
// file header_buffer_struct.c line 36
struct anonymous_2 * HeaderBuffer_new()
{
  struct anonymous_2 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_2) /*12ul*/ );
  tmp = (struct anonymous_2 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_2 *)NULL))
    return (struct anonymous_2 *)(void *)0;

  else
    return tmp;
}

// HeaderBuffer_restore
// file header_buffer_struct.c line 119
void HeaderBuffer_restore(struct anonymous_2 *hb, unsigned char *buff)
{
  if(!(hb == ((struct anonymous_2 *)NULL)))
  {
    memcpy((void *)buff, (const void *)hb->tab, (unsigned long int)5);
    hb->readed = 0;
  }

}

// HeaderBuffer_store
// file header_buffer_struct.c line 93
void HeaderBuffer_store(struct anonymous_2 *hb, unsigned char *buff, signed int n)
{
  if(!(hb == ((struct anonymous_2 *)NULL)))
  {
    if(!(hb->readed + n >= 6))
    {
      if(n >= 1)
      {
        memcpy((void *)&hb->tab[(signed long int)hb->readed], (const void *)buff, (unsigned long int)n);
        hb->readed = hb->readed + n;
      }

    }

  }

}

// HeaderBuffer_to_read
// file header_buffer_struct.c line 75
signed int HeaderBuffer_to_read(struct anonymous_2 *hb)
{
  if(hb == ((struct anonymous_2 *)NULL))
    return -1;

  else
    return 5 - hb->readed;
}

// HttpProxyOptions_free
// file http_proxy_options_struct.h line 42
void HttpProxyOptions_free(struct anonymous **hpo)
{
  if(!(hpo == ((struct anonymous **)NULL)))
  {
    if(!(*hpo == ((struct anonymous *)NULL)))
    {
      if(!((*hpo)->proxyname == ((char *)NULL)))
      {
        free((void *)(*hpo)->proxyname);
        (*hpo)->proxyname = (char *)(void *)0;
      }

      if(!((*hpo)->proxyport == ((char *)NULL)))
      {
        free((void *)(*hpo)->proxyport);
        (*hpo)->proxyport = (char *)(void *)0;
      }

      if(!((*hpo)->proxyauth_cred == ((char *)NULL)))
      {
        free((void *)(*hpo)->proxyauth_cred);
        (*hpo)->proxyauth_cred = (char *)(void *)0;
      }

      free((void *)*hpo);
      *hpo = (struct anonymous *)(void *)0;
    }

  }

}

// HttpProxyOptions_get_proxyauth_cred
// file http_proxy_options_struct.h line 51
char * HttpProxyOptions_get_proxyauth_cred(struct anonymous *hpo)
{
  if(hpo == ((struct anonymous *)NULL))
    return (char *)(void *)0;

  else
    return hpo->proxyauth_cred;
}

// HttpProxyOptions_get_proxyauth_type
// file http_proxy_options_struct.h line 52
char HttpProxyOptions_get_proxyauth_type(struct anonymous *hpo)
{
  if(hpo == ((struct anonymous *)NULL))
    return (char)-1;

  else
    return hpo->proxyauth_type;
}

// HttpProxyOptions_get_proxyname
// file http_proxy_options_struct.h line 49
char * HttpProxyOptions_get_proxyname(struct anonymous *hpo)
{
  if(hpo == ((struct anonymous *)NULL))
    return (char *)(void *)0;

  else
    return hpo->proxyname;
}

// HttpProxyOptions_get_proxyport
// file http_proxy_options_struct.h line 50
char * HttpProxyOptions_get_proxyport(struct anonymous *hpo)
{
  if(hpo == ((struct anonymous *)NULL))
    return (char *)(void *)0;

  else
    return hpo->proxyport;
}

// HttpProxyOptions_is_https
// file http_proxy_options_struct.h line 55
char HttpProxyOptions_is_https(struct anonymous *hpo)
{
  if(hpo == ((struct anonymous *)NULL))
    return (char)0;

  else
    return hpo->useHttps;
}

// HttpProxyOptions_new
// file http_proxy_options_struct.h line 40
struct anonymous * HttpProxyOptions_new()
{
  struct anonymous *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous) /*32ul*/ );
  tmp = (struct anonymous *)return_value_calloc_1;
  if(tmp == ((struct anonymous *)NULL))
    return (struct anonymous *)(void *)0;

  else
  {
    tmp->proxyauth_type = (char)0;
    return tmp;
  }
}

// HttpProxyOptions_set_proxyauth_cred
// file http_proxy_options_struct.h line 46
void HttpProxyOptions_set_proxyauth_cred(struct anonymous *hpo, char *proxyauth_cred)
{
  if(!(hpo == ((struct anonymous *)NULL)))
    string_cp(&hpo->proxyauth_cred, proxyauth_cred);

}

// HttpProxyOptions_set_proxyauth_type
// file http_proxy_options_struct.h line 47
void HttpProxyOptions_set_proxyauth_type(struct anonymous *hpo, char proxyauth_type)
{
  if(!(hpo == ((struct anonymous *)NULL)))
  {
    if(!((signed int)hpo->proxyauth_type == 0))
      hpo->proxyauth_type = (char)-1;

    else
      hpo->proxyauth_type = proxyauth_type;
  }

}

// HttpProxyOptions_set_proxyname
// file http_proxy_options_struct.h line 44
void HttpProxyOptions_set_proxyname(struct anonymous *hpo, char *proxyname)
{
  if(!(hpo == ((struct anonymous *)NULL)))
    string_cp(&hpo->proxyname, proxyname);

}

// HttpProxyOptions_set_proxyport
// file http_proxy_options_struct.h line 45
void HttpProxyOptions_set_proxyport(struct anonymous *hpo, char *proxyport)
{
  if(!(hpo == ((struct anonymous *)NULL)))
    string_cp(&hpo->proxyport, proxyport);

}

// HttpProxyOptions_use_https
// file http_proxy_options_struct.h line 54
void HttpProxyOptions_use_https(struct anonymous *hpo)
{
  if(!(hpo == ((struct anonymous *)NULL)))
    hpo->useHttps = (char)1;

}

// Module_free
// file module_struct.c line 56
void Module_free(struct anonymous_6 **m)
{
  if(!(m == ((struct anonymous_6 **)NULL)))
  {
    if(!(*m == ((struct anonymous_6 *)NULL)))
    {
      Module_releaseModule(*m);
      if(!((*m)->fileName == ((char *)NULL)))
      {
        free((void *)(*m)->fileName);
        (*m)->fileName = (char *)(void *)0;
      }

      free((void *)*m);
      *m = (struct anonymous_6 *)(void *)0;
    }

  }

}

// Module_function_allow
// file module_struct.h line 50
signed int Module_function_allow(struct anonymous_6 *m, char *host, char *port)
{
  signed int return_value_Module_isModuleLoaded_1;
  return_value_Module_isModuleLoaded_1=Module_isModuleLoaded(m);
  if(return_value_Module_isModuleLoaded_1 == 0)
    return 0;

  else
  {
    signed int return_value;
    return_value=m->allow(host, port);
    return return_value;
  }
}

// Module_function_filter
// file module_struct.h line 51
signed int Module_function_filter(struct anonymous_6 *m, char *host, unsigned char *message, signed int *messageLength)
{
  signed int return_value_Module_isModuleLoaded_1;
  return_value_Module_isModuleLoaded_1=Module_isModuleLoaded(m);
  if(return_value_Module_isModuleLoaded_1 == 0)
    return 0;

  else
  {
    signed int return_value;
    return_value=m->filter(host, message, messageLength);
    return return_value;
  }
}

// Module_function_info
// file module_struct.h line 49
char * Module_function_info(struct anonymous_6 *m)
{
  signed int return_value_Module_isModuleLoaded_1;
  return_value_Module_isModuleLoaded_1=Module_isModuleLoaded(m);
  if(return_value_Module_isModuleLoaded_1 == 0)
    return (char *)(void *)0;

  else
  {
    char *return_value;
    return_value=m->info();
    return return_value;
  }
}

// Module_get_fileName
// file module_struct.h line 44
char * Module_get_fileName(struct anonymous_6 *m)
{
  if(m == ((struct anonymous_6 *)NULL))
    return (char *)(void *)0;

  else
    return m->fileName;
}

// Module_isModuleLoaded
// file module_struct.h line 48
signed int Module_isModuleLoaded(struct anonymous_6 *m)
{
  if(m == ((struct anonymous_6 *)NULL))
    return 0;

  else
    return (signed int)m->loaded;
}

// Module_loadModule
// file module_struct.h line 46
signed int Module_loadModule(struct anonymous_6 *m)
{
  char *return_value_Module_get_fileName_3;
  return_value_Module_get_fileName_3=Module_get_fileName(m);
  if(!(return_value_Module_get_fileName_3 == ((char *)NULL)))
  {
    char *return_value_Module_get_fileName_1;
    return_value_Module_get_fileName_1=Module_get_fileName(m);
    m->handle=dlopen(return_value_Module_get_fileName_1, 0x00002);
    if(m->handle == NULL)
      return 1;

    dlerror();
    *((void **)&m->info)=dlsym(m->handle, "info");
    *((void **)&m->allow)=dlsym(m->handle, "allow");
    *((void **)&m->filter)=dlsym(m->handle, "filter");
    char *return_value_dlerror_2;
    return_value_dlerror_2=dlerror();
    if(!(return_value_dlerror_2 == ((char *)NULL)))
      return 2;

    m->loaded = (char)1;
  }

  return 0;
}

// Module_new
// file module_struct.h line 38
struct anonymous_6 * Module_new()
{
  struct anonymous_6 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_6) /*48ul*/ );
  tmp = (struct anonymous_6 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_6 *)NULL))
    return (struct anonymous_6 *)(void *)0;

  else
    return tmp;
}

// Module_releaseModule
// file module_struct.h line 47
signed int Module_releaseModule(struct anonymous_6 *m)
{
  signed int return_value_Module_isModuleLoaded_2;
  return_value_Module_isModuleLoaded_2=Module_isModuleLoaded(m);
  if(!(return_value_Module_isModuleLoaded_2 == 0))
  {
    m->loaded = (char)0;
    m->info = (char * (*)(void))(void *)0;
    m->allow = (signed int (*)(char *, char *))(void *)0;
    m->filter = (signed int (*)(char *, unsigned char *, signed int *))(void *)0;
    signed int return_value_dlclose_1;
    return_value_dlclose_1=dlclose(m->handle);
    return return_value_dlclose_1;
  }

  return 0;
}

// Module_set_fileName
// file module_struct.h line 42
void Module_set_fileName(struct anonymous_6 *m, char *fileName)
{
  if(!(m == ((struct anonymous_6 *)NULL)))
    string_cp(&m->fileName, fileName);

}

// PortListNode_free
// file port_list_node_struct.c line 56
void PortListNode_free(struct plnode **pln)
{
  if(!(pln == ((struct plnode **)NULL)))
  {
    if(!(*pln == ((struct plnode *)NULL)))
    {
      if(!((*pln)->portName == ((char *)NULL)))
      {
        free((void *)(*pln)->portName);
        (*pln)->portName = (char *)(void *)0;
      }

      free((void *)*pln);
      *pln = (struct plnode *)(void *)0;
    }

  }

}

// PortListNode_get_nextNode
// file port_list_node_struct.c line 133
struct plnode * PortListNode_get_nextNode(struct plnode *pln)
{
  if(pln == ((struct plnode *)NULL))
    return (struct plnode *)(void *)0;

  else
    return pln->nextNode;
}

// PortListNode_get_portName
// file port_list_node_struct.h line 37
char * PortListNode_get_portName(struct plnode *pln)
{
  if(pln == ((struct plnode *)NULL))
    return (char *)(void *)0;

  else
    return pln->portName;
}

// PortListNode_new
// file port_list_node_struct.h line 30
struct plnode * PortListNode_new(char *portName)
{
  struct plnode *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct plnode) /*16ul*/ );
  tmp = (struct plnode *)return_value_calloc_1;
  if(tmp == ((struct plnode *)NULL))
    return (struct plnode *)(void *)0;

  else
  {
    PortListNode_set_portName(tmp, portName);
    return tmp;
  }
}

// PortListNode_set_nextNode
// file port_list_node_struct.c line 99
void PortListNode_set_nextNode(struct plnode *pln, struct plnode *nextNode)
{
  if(!(pln == ((struct plnode *)NULL)))
    pln->nextNode = nextNode;

}

// PortListNode_set_portName
// file port_list_node_struct.c line 82
void PortListNode_set_portName(struct plnode *pln, char *portName)
{
  if(!(pln == ((struct plnode *)NULL)))
    string_cp(&pln->portName, portName);

}

// PortList_clear
// file port_list_struct.c line 149
void PortList_clear(struct portlist *pl)
{
  struct plnode *tmp;
  if(!(pl == ((struct portlist *)NULL)))
  {
    while(!(pl->head == ((struct plnode *)NULL)))
    {
      tmp = pl->head;
      if(tmp == pl->tail)
      {
        pl->tail = (struct plnode *)(void *)0;
        pl->head = pl->tail;
      }

      else
        pl->head=PortListNode_get_nextNode(pl->head);
      PortListNode_free(&tmp);
    }
    pl->size = 0;
  }

}

// PortList_free
// file port_list_struct.h line 35
void PortList_free(struct portlist **pl)
{
  if(!(pl == ((struct portlist **)NULL)))
  {
    if(!(*pl == ((struct portlist *)NULL)))
    {
      PortList_clear(*pl);
      free((void *)*pl);
      *pl = (struct portlist *)(void *)0;
    }

  }

}

// PortList_get_nth
// file port_list_struct.h line 38
struct plnode * PortList_get_nth(struct portlist *pl, signed int n)
{
  struct plnode *tmp;
  if(pl == ((struct portlist *)NULL))
    return (struct plnode *)(void *)0;

  else
  {
    tmp = pl->head;
    while(!(tmp == ((struct plnode *)NULL)))
    {
      if(!(n >= 1))
        return tmp;

      n = n - 1;
      tmp=PortListNode_get_nextNode(tmp);
    }
    return (struct plnode *)(void *)0;
  }
}

// PortList_get_size
// file port_list_struct.h line 39
signed int PortList_get_size(struct portlist *pl)
{
  if(pl == ((struct portlist *)NULL))
    return -1;

  else
    return pl->size;
}

// PortList_insert_back
// file port_list_struct.h line 37
void PortList_insert_back(struct portlist *pl, struct plnode *pln)
{
  if(!(pl == ((struct portlist *)NULL)))
  {
    if(!(pln == ((struct plnode *)NULL)))
    {
      if(!(pl->tail == ((struct plnode *)NULL)))
        pl->tail->nextNode = pln;

      else
        pl->head = pln;
      pl->tail = pln;
      pln->nextNode = (struct plnode *)(void *)0;
      pl->size = pl->size + 1;
    }

  }

}

// PortList_new
// file port_list_struct.h line 33
struct portlist * PortList_new()
{
  struct portlist *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct portlist) /*24ul*/ );
  tmp = (struct portlist *)return_value_calloc_1;
  if(tmp == ((struct portlist *)NULL))
    return (struct portlist *)(void *)0;

  else
    return tmp;
}

// SSL_readn
// file network.c line 483
signed int SSL_readn(struct ssl_st *fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    n=SSL_read(fd, (void *)(buf + (signed long int)sent), amount - sent);
    if(!(n == -1))
      sent = sent + n;

    if(n == 0)
      return 0;

    if(n == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(!(*return_value___errno_location_1 == 11))
        return 0;

    }

  }
  return amount;
}

// SSL_writen
// file network.c line 454
signed int SSL_writen(struct ssl_st *fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    n=SSL_write(fd, (const void *)(buf + (signed long int)sent), amount - sent);
    if(!(n == -1))
      sent = sent + n;

    if(n == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(!(*return_value___errno_location_1 == 11))
        return 0;

    }

  }
  return amount;
}

// SslFd_free
// file ssl_fd_struct.c line 54
void SslFd_free(struct anonymous_0 **sf)
{
  if(!(sf == ((struct anonymous_0 **)NULL)))
  {
    if(!(*sf == ((struct anonymous_0 *)NULL)))
    {
      if(!((*sf)->ssl == ((struct ssl_st *)NULL)))
      {
        SSL_free((*sf)->ssl);
        (*sf)->ssl = (struct ssl_st *)(void *)0;
      }

      free((void *)*sf);
      *sf = (struct anonymous_0 *)(void *)0;
    }

  }

}

// SslFd_get_fd
// file ssl_fd_struct.h line 41
signed int SslFd_get_fd(struct anonymous_0 *sf)
{
  if(sf == ((struct anonymous_0 *)NULL))
    return -1;

  else
    return sf->fd;
}

// SslFd_get_message
// file ssl_fd_struct.h line 45
signed int SslFd_get_message(char type, struct anonymous_0 *sf, unsigned char *buf, signed int amount)
{
  signed int length;
  unsigned long int elen;
  if(sf == ((struct anonymous_0 *)NULL) || buf == ((unsigned char *)NULL))
    return -1;

  else
  {
    aflog((char)16, (char)2, "get_message: ssl:%s zlib:%s length:%d", ((signed int)type & 4) != 0 ? "yes" : "no", ((signed int)type & 8) != 0 ? "yes" : "no", amount);
    if(!(amount >= 0))
    {
      if(!((4 & (signed int)type) == 0))
      {
        signed int return_value_SSL_read_1;
        return_value_SSL_read_1=SSL_read(sf->ssl, (void *)buf, -amount);
        return return_value_SSL_read_1;
      }

      else
      {
        signed long int return_value_read_2;
        return_value_read_2=read(sf->fd, (void *)buf, (unsigned long int)-amount);
        return (signed int)return_value_read_2;
      }
    }

    if(!((8 & (signed int)type) == 0))
    {
      static unsigned char bufor[9000l];
      if(!((4 & (signed int)type) == 0))
        length=SSL_readn(sf->ssl, bufor, amount & 0xBFFF);

      else
        length=readn(sf->fd, bufor, amount & 0xBFFF);
      if(!(length >= 1))
        return length;

      elen = (unsigned long int)8096;
      if(!((0x4000 & amount) == 0))
        uncompress(buf, &elen, bufor, (unsigned long int)length);

      else
      {
        memcpy((void *)buf, (const void *)bufor, (unsigned long int)length);
        elen = (unsigned long int)length;
      }
      return (signed int)elen;
    }

    else
      if(!((4 & (signed int)type) == 0))
      {
        signed int return_value_SSL_readn_3;
        return_value_SSL_readn_3=SSL_readn(sf->ssl, buf, amount);
        return return_value_SSL_readn_3;
      }

      else
      {
        signed int return_value_readn_4;
        return_value_readn_4=readn(sf->fd, buf, amount);
        return return_value_readn_4;
      }
  }
}

// SslFd_get_ssl
// file ssl_fd_struct.h line 42
struct ssl_st * SslFd_get_ssl(struct anonymous_0 *sf)
{
  if(sf == ((struct anonymous_0 *)NULL))
    return (struct ssl_st *)(void *)0;

  else
    return sf->ssl;
}

// SslFd_new
// file ssl_fd_struct.h line 33
struct anonymous_0 * SslFd_new()
{
  struct anonymous_0 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_0) /*16ul*/ );
  tmp = (struct anonymous_0 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_0 *)NULL))
    return (struct anonymous_0 *)(void *)0;

  else
    return tmp;
}

// SslFd_send_message
// file ssl_fd_struct.h line 44
signed int SslFd_send_message(char type, struct anonymous_0 *sf, unsigned char *buf, signed int amount)
{
  unsigned long int clen;
  signed int length;
  if(sf == ((struct anonymous_0 *)NULL) || buf == ((unsigned char *)NULL))
    return -1;

  else
  {
    aflog((char)16, (char)2, "send_message: ssl:%s zlib:%s length:%d", ((signed int)type & 4) != 0 ? "yes" : "no", ((signed int)type & 8) != 0 ? "yes" : "no", amount);
    clen = (unsigned long int)8995;
    length = amount - 5;
    if(!((8 & (signed int)type) == 0))
    {
      static unsigned char buffer[9000l];
      memcpy((void *)buffer, (const void *)buf, (unsigned long int)5);
      if(amount >= 6)
      {
        compress(&buffer[(signed long int)5], &clen, &buf[(signed long int)5], (unsigned long int)length);
        if(!(clen >= (unsigned long int)length))
        {
          length = (signed int)clen;
          length = length | 0x4000;
          buffer[(signed long int)3] = (unsigned char)(length >> 8);
          buffer[(signed long int)4] = (unsigned char)length;
          addtocg((signed int)((unsigned long int)(amount - 5) - clen));
        }

      }

      if(!((4 & (signed int)type) == 0))
      {
        if(!((0x4000 & length) == 0))
        {
          signed int return_value_SSL_writen_1;
          return_value_SSL_writen_1=SSL_writen(sf->ssl, buffer, (signed int)(clen + (unsigned long int)5));
          return return_value_SSL_writen_1;
        }

        else
        {
          signed int return_value_SSL_writen_2;
          return_value_SSL_writen_2=SSL_writen(sf->ssl, buf, amount);
          return return_value_SSL_writen_2;
        }
      }

      else
        if(!((0x4000 & length) == 0))
        {
          signed int return_value_writen_3;
          return_value_writen_3=writen(sf->fd, buffer, (signed int)(clen + (unsigned long int)5));
          return return_value_writen_3;
        }

        else
        {
          signed int return_value_writen_4;
          return_value_writen_4=writen(sf->fd, buf, amount);
          return return_value_writen_4;
        }
    }

    else
      if(!((4 & (signed int)type) == 0))
      {
        signed int return_value_SSL_writen_5;
        return_value_SSL_writen_5=SSL_writen(sf->ssl, buf, amount);
        return return_value_SSL_writen_5;
      }

      else
      {
        signed int return_value_writen_6;
        return_value_writen_6=writen(sf->fd, buf, amount);
        return return_value_writen_6;
      }
  }
}

// SslFd_set_fd
// file ssl_fd_struct.h line 37
void SslFd_set_fd(struct anonymous_0 *sf, signed int fd)
{
  if(!(sf == ((struct anonymous_0 *)NULL)))
    sf->fd = fd;

}

// SslFd_set_ssl
// file ssl_fd_struct.h line 38
void SslFd_set_ssl(struct anonymous_0 *sf, struct ssl_st *ssl)
{
  SslFd_set_ssl_general(sf, ssl, 1);
}

// SslFd_set_ssl_general
// file ssl_fd_struct.c line 98
void SslFd_set_ssl_general(struct anonymous_0 *sf, struct ssl_st *ssl, signed int free)
{
  if(!(sf == ((struct anonymous_0 *)NULL)))
  {
    if(!(free == 0))
    {
      if(!(sf->ssl == ((struct ssl_st *)NULL)))
        SSL_free(sf->ssl);

    }

    sf->ssl = ssl;
  }

}

// SslFd_set_ssl_nf
// file ssl_fd_struct.c line 132
void SslFd_set_ssl_nf(struct anonymous_0 *sf, struct ssl_st *ssl)
{
  SslFd_set_ssl_general(sf, ssl, 0);
}

// SslFd_swap_content
// file ssl_fd_struct.c line 315
void SslFd_swap_content(struct anonymous_0 *sf1, struct anonymous_0 *sf2)
{
  signed int tmpfd;
  struct ssl_st *tmpssl;
  tmpfd=SslFd_get_fd(sf1);
  tmpssl=SslFd_get_ssl(sf2);
  signed int return_value_SslFd_get_fd_1;
  return_value_SslFd_get_fd_1=SslFd_get_fd(sf2);
  SslFd_set_fd(sf1, return_value_SslFd_get_fd_1);
  struct ssl_st *return_value_SslFd_get_ssl_2;
  return_value_SslFd_get_ssl_2=SslFd_get_ssl(sf2);
  SslFd_set_ssl(sf1, return_value_SslFd_get_ssl_2);
  SslFd_set_fd(sf2, tmpfd);
  SslFd_set_ssl(sf2, tmpssl);
}

// UserStats_add_download
// file user_stats_struct.c line 178
void UserStats_add_download(struct anonymous_14 *us, signed int bytes)
{
  signed long int now;
  if(!(us == ((struct anonymous_14 *)NULL)))
  {
    time(&now);
    switch(now - us->lastDSQChange)
    {
      case (signed long int)0:
      {
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = us->downloadSpeedQueue[(signed long int)us->downloadSQP] + bytes;
        break;
      }
      case (signed long int)2:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = bytes;
        break;
      }
      default:
      {
        us->downloadSpeedQueue[(signed long int)2] = 0;
        us->downloadSpeedQueue[(signed long int)1] = us->downloadSpeedQueue[(signed long int)2];
        us->downloadSpeedQueue[(signed long int)0] = us->downloadSpeedQueue[(signed long int)1];
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = bytes;
      }
    }
    us->totalDownloadedBytes = us->totalDownloadedBytes + bytes;
    us->lastActivity = now;
    us->lastDSQChange = now;
  }

}

// UserStats_add_upload
// file user_stats_struct.c line 231
void UserStats_add_upload(struct anonymous_14 *us, signed int bytes)
{
  signed long int now;
  if(!(us == ((struct anonymous_14 *)NULL)))
  {
    time(&now);
    switch(now - us->lastUSQChange)
    {
      case (signed long int)0:
      {
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = us->uploadSpeedQueue[(signed long int)us->uploadSQP] + bytes;
        break;
      }
      case (signed long int)2:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = bytes;
        break;
      }
      default:
      {
        us->uploadSpeedQueue[(signed long int)2] = 0;
        us->uploadSpeedQueue[(signed long int)1] = us->uploadSpeedQueue[(signed long int)2];
        us->uploadSpeedQueue[(signed long int)0] = us->uploadSpeedQueue[(signed long int)1];
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = bytes;
      }
    }
    us->totalUploadedBytes = us->totalUploadedBytes + bytes;
    us->lastActivity = now;
    us->lastUSQChange = now;
  }

}

// UserStats_clear
// file user_stats_struct.c line 376
void UserStats_clear(struct anonymous_14 *us)
{
  if(!(us == ((struct anonymous_14 *)NULL)))
  {
    us->lastActivity = (signed long int)0;
    us->lastUSQChange = (signed long int)0;
    us->lastDSQChange = (signed long int)0;
    us->totalDownloadedBytes = 0;
    us->totalUploadedBytes = 0;
    us->uploadSQP = 0;
    us->uploadSpeedQueue[(signed long int)2] = 0;
    us->uploadSpeedQueue[(signed long int)1] = us->uploadSpeedQueue[(signed long int)2];
    us->uploadSpeedQueue[(signed long int)0] = us->uploadSpeedQueue[(signed long int)1];
    us->downloadSQP = 0;
    us->downloadSpeedQueue[(signed long int)2] = 0;
    us->downloadSpeedQueue[(signed long int)1] = us->downloadSpeedQueue[(signed long int)2];
    us->downloadSpeedQueue[(signed long int)0] = us->downloadSpeedQueue[(signed long int)1];
  }

}

// UserStats_free
// file user_stats_struct.h line 42
void UserStats_free(struct anonymous_14 **us)
{
  if(!(us == ((struct anonymous_14 **)NULL)))
  {
    if(!(*us == ((struct anonymous_14 *)NULL)))
    {
      free((void *)*us);
      *us = (struct anonymous_14 *)(void *)0;
    }

  }

}

// UserStats_get_downloadSpeed
// file user_stats_struct.c line 283
double UserStats_get_downloadSpeed(struct anonymous_14 *us)
{
  signed long int now;
  if(us == ((struct anonymous_14 *)NULL))
    return 0.0;

  else
  {
    time(&now);
    switch(now - us->lastDSQChange)
    {
      case (signed long int)0:
        break;
      case (signed long int)2:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = 0;
        break;
      }
      default:
      {
        us->downloadSpeedQueue[(signed long int)2] = 0;
        us->downloadSpeedQueue[(signed long int)1] = us->downloadSpeedQueue[(signed long int)2];
        us->downloadSpeedQueue[(signed long int)0] = us->downloadSpeedQueue[(signed long int)1];
      }
    }
    us->lastDSQChange = now;
    return (double)(us->downloadSpeedQueue[(signed long int)0] + us->downloadSpeedQueue[(signed long int)1] + us->downloadSpeedQueue[(signed long int)2]) / 3.0;
  }
}

// UserStats_get_lastActivity
// file user_stats_struct.c line 126
signed long int UserStats_get_lastActivity(struct anonymous_14 *us)
{
  if(us == ((struct anonymous_14 *)NULL))
    return (signed long int)0;

  else
    return us->lastActivity;
}

// UserStats_get_totalDownloadedBytes
// file user_stats_struct.c line 143
signed int UserStats_get_totalDownloadedBytes(struct anonymous_14 *us)
{
  if(us == ((struct anonymous_14 *)NULL))
    return 0;

  else
    return us->totalDownloadedBytes;
}

// UserStats_get_totalUploadedBytes
// file user_stats_struct.c line 160
signed int UserStats_get_totalUploadedBytes(struct anonymous_14 *us)
{
  if(us == ((struct anonymous_14 *)NULL))
    return 0;

  else
    return us->totalUploadedBytes;
}

// UserStats_get_uploadSpeed
// file user_stats_struct.c line 330
double UserStats_get_uploadSpeed(struct anonymous_14 *us)
{
  signed long int now;
  if(us == ((struct anonymous_14 *)NULL))
    return 0.0;

  else
  {
    time(&now);
    switch(now - us->lastUSQChange)
    {
      case (signed long int)0:
        break;
      case (signed long int)2:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = 0;
        break;
      }
      default:
      {
        us->uploadSpeedQueue[(signed long int)2] = 0;
        us->uploadSpeedQueue[(signed long int)1] = us->uploadSpeedQueue[(signed long int)2];
        us->uploadSpeedQueue[(signed long int)0] = us->uploadSpeedQueue[(signed long int)1];
      }
    }
    us->lastUSQChange = now;
    return (double)(us->uploadSpeedQueue[(signed long int)0] + us->uploadSpeedQueue[(signed long int)1] + us->uploadSpeedQueue[(signed long int)2]) / 3.0;
  }
}

// UserStats_new
// file user_stats_struct.h line 40
struct anonymous_14 * UserStats_new()
{
  struct anonymous_14 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_14) /*64ul*/ );
  tmp = (struct anonymous_14 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_14 *)NULL))
    return (struct anonymous_14 *)(void *)0;

  else
    return tmp;
}

// UserStats_set_lastActivity
// file user_stats_struct.c line 75
void UserStats_set_lastActivity(struct anonymous_14 *us, signed long int lastActivity)
{
  if(!(us == ((struct anonymous_14 *)NULL)))
    us->lastActivity = lastActivity;

}

// UserStats_set_totalDownloadedBytes
// file user_stats_struct.c line 92
void UserStats_set_totalDownloadedBytes(struct anonymous_14 *us, signed int totalDownloadedBytes)
{
  if(!(us == ((struct anonymous_14 *)NULL)))
    us->totalDownloadedBytes = totalDownloadedBytes;

}

// UserStats_set_totalUploadedBytes
// file user_stats_struct.c line 109
void UserStats_set_totalUploadedBytes(struct anonymous_14 *us, signed int totalUploadedBytes)
{
  if(!(us == ((struct anonymous_14 *)NULL)))
    us->totalUploadedBytes = totalUploadedBytes;

}

// UsrCli_free
// file usr_cli_struct.c line 54
void UsrCli_free(struct anonymous_1 **uc)
{
  if(!(uc == ((struct anonymous_1 **)NULL)))
  {
    if(!(*uc == ((struct anonymous_1 *)NULL)))
    {
      if(!((*uc)->listenPortName == ((char *)NULL)))
      {
        free((void *)(*uc)->listenPortName);
        (*uc)->listenPortName = (char *)(void *)0;
      }

      if(!((*uc)->managePortName == ((char *)NULL)))
      {
        free((void *)(*uc)->managePortName);
        (*uc)->managePortName = (char *)(void *)0;
      }

      free((void *)*uc);
      *uc = (struct anonymous_1 *)(void *)0;
    }

  }

}

// UsrCli_get_listenFd
// file usr_cli_struct.c line 224
signed int UsrCli_get_listenFd(struct anonymous_1 *uc)
{
  if(uc == ((struct anonymous_1 *)NULL))
    return -1;

  else
    return uc->listenFd;
}

// UsrCli_get_listenHostName
// file usr_cli_struct.c line 258
char * UsrCli_get_listenHostName(struct anonymous_1 *uc)
{
  if(uc == ((struct anonymous_1 *)NULL))
    return (char *)(void *)0;

  else
    return uc->listenHostName;
}

// UsrCli_get_listenPortName
// file usr_cli_struct.c line 190
char * UsrCli_get_listenPortName(struct anonymous_1 *uc)
{
  if(uc == ((struct anonymous_1 *)NULL))
    return (char *)(void *)0;

  else
    return uc->listenPortName;
}

// UsrCli_get_manageFd
// file usr_cli_struct.c line 241
signed int UsrCli_get_manageFd(struct anonymous_1 *uc)
{
  if(uc == ((struct anonymous_1 *)NULL))
    return -1;

  else
    return uc->manageFd;
}

// UsrCli_get_manageHostName
// file usr_cli_struct.c line 275
char * UsrCli_get_manageHostName(struct anonymous_1 *uc)
{
  if(uc == ((struct anonymous_1 *)NULL))
    return (char *)(void *)0;

  else
    return uc->manageHostName;
}

// UsrCli_get_managePortName
// file usr_cli_struct.c line 207
char * UsrCli_get_managePortName(struct anonymous_1 *uc)
{
  if(uc == ((struct anonymous_1 *)NULL))
    return (char *)(void *)0;

  else
    return uc->managePortName;
}

// UsrCli_get_number
// file usr_cli_struct.c line 292
signed int UsrCli_get_number(struct anonymous_1 *uc)
{
  if(uc == ((struct anonymous_1 *)NULL))
    return -1;

  else
    return uc->number;
}

// UsrCli_new
// file usr_cli_struct.c line 37
struct anonymous_1 * UsrCli_new()
{
  struct anonymous_1 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_1) /*48ul*/ );
  tmp = (struct anonymous_1 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_1 *)NULL))
    return (struct anonymous_1 *)(void *)0;

  else
    return tmp;
}

// UsrCli_set_listenFd
// file usr_cli_struct.c line 139
void UsrCli_set_listenFd(struct anonymous_1 *uc, signed int listenFd)
{
  if(!(uc == ((struct anonymous_1 *)NULL)))
    uc->listenFd = listenFd;

}

// UsrCli_set_listenPortName
// file usr_cli_struct.c line 83
void UsrCli_set_listenPortName(struct anonymous_1 *uc, char *listenPortName)
{
  char *tmp;
  if(!(uc == ((struct anonymous_1 *)NULL)))
  {
    tmp=rindex(listenPortName, 58);
    if(!(tmp == ((char *)NULL)))
    {
      *tmp = (char)0;
      tmp = tmp + 1l;
      string_cp(&uc->listenHostName, listenPortName);
      string_cp(&uc->listenPortName, tmp);
    }

    else
      string_cp(&uc->listenPortName, listenPortName);
  }

}

// UsrCli_set_manageFd
// file usr_cli_struct.c line 156
void UsrCli_set_manageFd(struct anonymous_1 *uc, signed int manageFd)
{
  if(!(uc == ((struct anonymous_1 *)NULL)))
    uc->manageFd = manageFd;

}

// UsrCli_set_managePortName
// file usr_cli_struct.c line 111
void UsrCli_set_managePortName(struct anonymous_1 *uc, char *managePortName)
{
  char *tmp;
  if(!(uc == ((struct anonymous_1 *)NULL)))
  {
    tmp=rindex(managePortName, 58);
    if(!(tmp == ((char *)NULL)))
    {
      *tmp = (char)0;
      tmp = tmp + 1l;
      string_cp(&uc->manageHostName, managePortName);
      string_cp(&uc->managePortName, tmp);
    }

    else
      string_cp(&uc->managePortName, managePortName);
  }

}

// UsrCli_set_number
// file usr_cli_struct.c line 173
void UsrCli_set_number(struct anonymous_1 *uc, signed int number)
{
  if(!(uc == ((struct anonymous_1 *)NULL)))
    uc->number = number;

}

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1)
{
  signed long int return_value___builtin_bswap32_1_link1;
  return_value___builtin_bswap32_1_link1=__builtin_bswap32((signed long int)__bsx_link1);
  return (unsigned int)return_value___builtin_bswap32_1_link1;
}

// add_public_key
// file ssl_routines.h line 31
void add_public_key(char *filename, char *hostname, char *keyhash)
{
  struct _IO_FILE *storefile;
  storefile=fopen(filename, "a");
  if(!(storefile == ((struct _IO_FILE *)NULL)))
  {
    fprintf(storefile, "%s %s\n", hostname, keyhash);
    fclose(storefile);
  }

}

// addlogtarget
// file logging.h line 69
void addlogtarget(char *cmdline)
{
  struct llnode *newnode;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct llnode) /*32ul*/ );
  newnode = (struct llnode *)return_value_calloc_1;
  newnode->cmdline = cmdline;
  newnode->next = head;
  head = newnode;
}

// addtocg
// file stats.c line 61
void addtocg(signed int amount)
{
  compressgained = compressgained + (signed long int)amount;
}

// aflog
// file logging.h line 73
void aflog(char type, char importance, const char *form, ...)
{
  struct llnode *ptr;
  void **ap;
  if(!(((signed int)importance & (signed int)verlev) == 0))
  {
    if(!((signed int)format[0l] == 0))
    {
      char *return_value_datum_1;
      return_value_datum_1=datum();
      printf("[%s] ", return_value_datum_1);
    }

    ap = (void **)&form;
    vfprintf(stdout, form, ap);
    ap = ((void **)NULL);
    printf("\n");
  }

  ptr = head;
  for( ; !(ptr == ((struct llnode *)NULL)); ptr = ptr->next)
    if(!(((signed int)ptr->msgtype & (signed int)type) == 0))
    {
      if(!(((signed int)ptr->importance & (signed int)importance) == 0))
      {
        if(!((signed int)format[0l] == 0))
        {
          char *return_value_datum_2;
          return_value_datum_2=datum();
          fprintf(ptr->logfd, "[%s] ", return_value_datum_2);
        }

        ap = (void **)&form;
        vfprintf(ptr->logfd, form, ap);
        ap = ((void **)NULL);
        fprintf(ptr->logfd, "\n");
        fflush(ptr->logfd);
      }

    }

}

// b64_ntop
// file base64.h line 37
signed int b64_ntop(const unsigned char *src, unsigned long int srclength, char *target, unsigned long int targsize)
{
  unsigned long int datalength = (unsigned long int)0;
  unsigned char input[3l];
  unsigned char output[4l];
  unsigned long int i;
  const unsigned char *tmp_post_1;
  const unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  unsigned long int tmp_post_4;
  unsigned long int tmp_post_5;
  unsigned long int tmp_post_6;
  unsigned long int tmp_post_7;
  for( ; srclength >= 3ul; target[(signed long int)tmp_post_7] = Base64[(signed long int)output[(signed long int)3]])
  {
    tmp_post_1 = src;
    src = src + 1l;
    input[(signed long int)0] = *tmp_post_1;
    tmp_post_2 = src;
    src = src + 1l;
    input[(signed long int)1] = *tmp_post_2;
    tmp_post_3 = src;
    src = src + 1l;
    input[(signed long int)2] = *tmp_post_3;
    srclength = srclength - (unsigned long int)3;
    output[(signed long int)0] = (unsigned char)((signed int)input[(signed long int)0] >> 2);
    output[(signed long int)1] = (unsigned char)((((signed int)input[(signed long int)0] & 0x03) << 4) + ((signed int)input[(signed long int)1] >> 4));
    output[(signed long int)2] = (unsigned char)((((signed int)input[(signed long int)1] & 0x0f) << 2) + ((signed int)input[(signed long int)2] >> 6));
    output[(signed long int)3] = (unsigned char)((signed int)input[(signed long int)2] & 0x3f);
    if((signed int)output[0l] >= 64)
      return -1;

    if((signed int)output[1l] >= 64)
      return -1;

    if((signed int)output[2l] >= 64)
      return -1;

    if((signed int)output[3l] >= 64)
      return -1;

    if(!(targsize >= 4ul + datalength))
      return -1;

    tmp_post_4 = datalength;
    datalength = datalength + 1ul;
    target[(signed long int)tmp_post_4] = Base64[(signed long int)output[(signed long int)0]];
    tmp_post_5 = datalength;
    datalength = datalength + 1ul;
    target[(signed long int)tmp_post_5] = Base64[(signed long int)output[(signed long int)1]];
    tmp_post_6 = datalength;
    datalength = datalength + 1ul;
    target[(signed long int)tmp_post_6] = Base64[(signed long int)output[(signed long int)2]];
    tmp_post_7 = datalength;
    datalength = datalength + 1ul;
  }
  const unsigned char *tmp_post_8;
  unsigned long int tmp_post_9;
  unsigned long int tmp_post_10;
  unsigned long int tmp_post_11;
  unsigned long int tmp_post_12;
  unsigned long int tmp_post_13;
  if(!(srclength == 0ul))
  {
    input[(signed long int)2] = (unsigned char)0;
    input[(signed long int)1] = input[(signed long int)2];
    input[(signed long int)0] = input[(signed long int)1];
    i = (unsigned long int)0;
    for( ; !(i >= srclength); i = i + 1ul)
    {
      tmp_post_8 = src;
      src = src + 1l;
      input[(signed long int)i] = *tmp_post_8;
    }
    output[(signed long int)0] = (unsigned char)((signed int)input[(signed long int)0] >> 2);
    output[(signed long int)1] = (unsigned char)((((signed int)input[(signed long int)0] & 0x03) << 4) + ((signed int)input[(signed long int)1] >> 4));
    output[(signed long int)2] = (unsigned char)((((signed int)input[(signed long int)1] & 0x0f) << 2) + ((signed int)input[(signed long int)2] >> 6));
    if((signed int)output[0l] >= 64)
      return -1;

    if((signed int)output[1l] >= 64)
      return -1;

    if((signed int)output[2l] >= 64)
      return -1;

    if(!(targsize >= 4ul + datalength))
      return -1;

    tmp_post_9 = datalength;
    datalength = datalength + 1ul;
    target[(signed long int)tmp_post_9] = Base64[(signed long int)output[(signed long int)0]];
    tmp_post_10 = datalength;
    datalength = datalength + 1ul;
    target[(signed long int)tmp_post_10] = Base64[(signed long int)output[(signed long int)1]];
    if(srclength == 1ul)
    {
      tmp_post_11 = datalength;
      datalength = datalength + 1ul;
      target[(signed long int)tmp_post_11] = Pad64;
    }

    else
    {
      tmp_post_12 = datalength;
      datalength = datalength + 1ul;
      target[(signed long int)tmp_post_12] = Base64[(signed long int)output[(signed long int)2]];
    }
    tmp_post_13 = datalength;
    datalength = datalength + 1ul;
    target[(signed long int)tmp_post_13] = Pad64;
  }

  if(datalength >= targsize)
    return -1;

  else
  {
    target[(signed long int)datalength] = (char)0;
    return (signed int)datalength;
  }
}

// b64_pton
// file base64.c line 132
signed int b64_pton(const char *src, unsigned char *target, unsigned long int targsize)
{
  signed int tarindex;
  signed int state;
  signed int ch;
  char *pos;
  state = 0;
  tarindex = 0;
  const char *tmp_post_1;
  do
  {
    tmp_post_1 = src;
    src = src + 1l;
    ch = (signed int)*tmp_post_1;
    if(ch == 0)
      break;

    const unsigned short int **return_value___ctype_b_loc_2;
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)ch]) == 0)
    {
      if(ch == (signed int)Pad64)
        break;

      char *return_value___builtin_strchr_3;
      return_value___builtin_strchr_3=__builtin_strchr(Base64, ch);
      pos = return_value___builtin_strchr_3;
      if(pos == ((char *)NULL))
        return -1;

      switch(state)
      {
        case 0:
        {
          if(!(target == ((unsigned char *)NULL)))
          {
            if((unsigned long int)tarindex >= targsize)
              return -1;

            target[(signed long int)tarindex] = (unsigned char)(pos - Base64 << 2);
          }

          state = 1;
          break;
        }
        case 1:
        {
          if(!(target == ((unsigned char *)NULL)))
          {
            if(1ul + (unsigned long int)tarindex >= targsize)
              return -1;

            target[(signed long int)tarindex] = target[(signed long int)tarindex] | (unsigned char)(pos - Base64 >> 4);
            target[(signed long int)(tarindex + 1)] = (unsigned char)((pos - Base64 & (signed long int)0x0f) << 4);
          }

          tarindex = tarindex + 1;
          state = 2;
          break;
        }
        case 2:
        {
          if(!(target == ((unsigned char *)NULL)))
          {
            if(1ul + (unsigned long int)tarindex >= targsize)
              return -1;

            target[(signed long int)tarindex] = target[(signed long int)tarindex] | (unsigned char)(pos - Base64 >> 2);
            target[(signed long int)(tarindex + 1)] = (unsigned char)((pos - Base64 & (signed long int)0x03) << 6);
          }

          tarindex = tarindex + 1;
          state = 3;
          break;
        }
        case 3:
        {
          if(!(target == ((unsigned char *)NULL)))
          {
            if((unsigned long int)tarindex >= targsize)
              return -1;

            target[(signed long int)tarindex] = target[(signed long int)tarindex] | (unsigned char)(pos - Base64);
          }

          tarindex = tarindex + 1;
          state = 0;
          break;
        }
        default:
          abort();
      }
    }

  }
  while((_Bool)1);
  const char *tmp_post_4;
  const unsigned short int **return_value___ctype_b_loc_6;
  const char *tmp_post_5;
  const char *tmp_post_7;
  const unsigned short int **return_value___ctype_b_loc_9;
  const char *tmp_post_8;
  if(ch == (signed int)Pad64)
  {
    tmp_post_4 = src;
    src = src + 1l;
    ch = (signed int)*tmp_post_4;
    switch(state)
    {
      case 0:

      case 1:
        return -1;
      case 2:
      {
        (void)(void *)0;
        for( ; !(ch == 0); ch = (signed int)*tmp_post_5)
        {
          return_value___ctype_b_loc_6=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)(unsigned char)ch]) == 0)
            break;

          tmp_post_5 = src;
          src = src + 1l;
        }
        if(!(ch == (signed int)Pad64))
          return -1;

        tmp_post_7 = src;
        src = src + 1l;
        ch = (signed int)*tmp_post_7;
      }
      case 3:
      {
        (void)(void *)0;
        for( ; !(ch == 0); ch = (signed int)*tmp_post_8)
        {
          return_value___ctype_b_loc_9=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_9)[(signed long int)(signed int)(unsigned char)ch]) == 0)
            return -1;

          tmp_post_8 = src;
          src = src + 1l;
        }
        if(!(target == ((unsigned char *)NULL)))
        {
          if(!((signed int)target[(signed long int)tarindex] == 0))
            return -1;

        }

      }
      default:
        ;
    }
  }

  else
    if(!(state == 0))
      return -1;

  return tarindex;
}

// broadcast_condition
// file thread_management.h line 31
void broadcast_condition(void)
{
  pthread_cond_broadcast(&maincond);
}

// callback
// file first_run.c line 63
static void callback(signed int i, signed int j, void *k)
{
  if(k == NULL)
  {
    printf("%d", i);
    fflush(stdout);
  }

}

// check_long
// file server_check.c line 99
signed int check_long(char *text, signed long int *number)
{
  char *tmp;
  *number=strtol(text, &tmp, 10);
  _Bool tmp_if_expr_1;
  if(*number == 0x7fffffffffffffffL)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = *number == -0x7fffffffffffffffL - 1L ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    return 1;

  else
  {
    if(!((signed int)*text == 0))
      tmp_if_expr_2 = (signed int)*tmp == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      return 0;

    else
      return 2;
  }
}

// check_public_key
// file ssl_routines.h line 29
signed int check_public_key(char *filename, char *hostname, char *keyhash)
{
  struct _IO_FILE *storefile;
  char buff[256l];
  signed int lspaceind;
  signed int i;
  memset((void *)buff, 0, (unsigned long int)256);
  storefile=fopen(filename, "r");
  char *return_value_fgets_1;
  signed int tmp_statement_expression_6;
  signed int tmp_statement_expression_4;
  if(storefile == ((struct _IO_FILE *)NULL))
    return 2;

  else
  {
    do
    {
      return_value_fgets_1=fgets(buff, 256, storefile);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      lspaceind = -1;
      i = 0;
      for( ; !(i >= 256); i = i + 1)
      {
        if((signed int)buff[(signed long int)i] == 0)
          break;

        if((signed int)buff[(signed long int)i] == 32)
          lspaceind = i;

      }
      if(!(lspaceind == -1))
      {
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(buff);
        if((signed int)buff[-1l + (signed long int)return_value_strlen_3] == 10)
        {
          unsigned long int return_value_strlen_2;
          return_value_strlen_2=strlen(buff);
          buff[(signed long int)(return_value_strlen_2 - (unsigned long int)1)] = (char)0;
        }

        buff[(signed long int)lspaceind] = (char)0;
        unsigned long int check_public_key__1__2__4____s1_len;
        unsigned long int check_public_key__1__2__4____s2_len;
        signed int return_value___builtin_strcmp_7;
        return_value___builtin_strcmp_7=__builtin_strcmp(buff, hostname);
        tmp_statement_expression_6 = return_value___builtin_strcmp_7;
        if(tmp_statement_expression_6 == 0)
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_5;
          return_value___builtin_strcmp_5=__builtin_strcmp(&buff[(signed long int)(lspaceind + 1)], keyhash);
          tmp_statement_expression_4 = return_value___builtin_strcmp_5;
          if(tmp_statement_expression_4 == 0)
            return 1;

          else
            return 0;
        }

      }

    }
    while((_Bool)1);
    return 2;
  }
}

// check_value
// file server_check.h line 24
signed int check_value(char *what, char *info)
{
  signed long int tmp;
  signed int return_value_check_value_liberal_1;
  return_value_check_value_liberal_1=check_value_liberal(what, info);
  tmp = (signed long int)return_value_check_value_liberal_1;
  if(!(tmp >= 1l))
  {
    aflog((char)4, (char)1, "%s: %d\n", info, tmp);
    exit(1);
  }

  return (signed int)tmp;
}

// check_value_liberal
// file server_check.c line 67
signed int check_value_liberal(char *what, char *info)
{
  char *znak;
  signed long int tmp;
  tmp=strtol(what, &znak, 10);
  if(tmp >= 2147483647l)
  {
    aflog((char)4, (char)1, "%s: %s\n", info, what);
    exit(1);
  }

  _Bool tmp_if_expr_1;
  if((signed int)*what == 0)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*znak != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    aflog((char)4, (char)1, "%s: %s\n", info, what);
    exit(1);
  }

  return (signed int)tmp;
}

// checklogtarget
// file logging.c line 175
signed int checklogtarget(struct llnode *target)
{
  char *ptr;
  char desc[100l];
  char type = (char)0;
  char tab[100l];
  signed int tmpfd;
  signed int state;
  signed int i;
  _Bool tmp_if_expr_1;
  if(target == ((struct llnode *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = target->cmdline == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_statement_expression_4;
  signed int tmp_statement_expression_2;
  if(tmp_if_expr_1)
    return 1;

  else
  {
    state = 0;
    memset((void *)tab, 0, (unsigned long int)100);
    i = 0;
    ptr = target->cmdline;
    for( ; !((signed int)*ptr == 0); ptr = ptr + 1l)
      switch(state)
      {
        case 0:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp_5;
            return_value___builtin_strcmp_5=__builtin_strcmp(tab, "file");
            tmp_statement_expression_4 = return_value___builtin_strcmp_5;
            if(tmp_statement_expression_4 == 0)
              type = (char)1;

            else
            {
              unsigned long int checklogtarget__1__2__1__1__1__3____s1_len;
              unsigned long int checklogtarget__1__2__1__1__1__3____s2_len;
              signed int return_value___builtin_strcmp_3;
              return_value___builtin_strcmp_3=__builtin_strcmp(tab, "sock");
              tmp_statement_expression_2 = return_value___builtin_strcmp_3;
              if(tmp_statement_expression_2 == 0)
                type = (char)2;

              else
                return 2;
            }
            state = 1;
            memset((void *)tab, 0, (unsigned long int)100);
            memset((void *)desc, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 2;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
          break;
        }
        case 1:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            switch((signed int)type)
            {
              case 1:
              {
                target->logfd=fopen(tab, "a");
                if(target->logfd == ((struct _IO_FILE *)NULL))
                  return 4;

                state = 3;
                break;
              }
              case 2:
              {
                __builtin_strncpy(desc, tab, (unsigned long int)99);
                state = 2;
                break;
              }
              default:
                return 2;
            }
            memset((void *)tab, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 3;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
          break;
        }
        case 2:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            signed int return_value_ip_connect_6;
            return_value_ip_connect_6=ip_connect(&tmpfd, desc, tab, (const char)1, (const char *)(void *)0, (const char *)(void *)0);
            if(!(return_value_ip_connect_6 == 0))
              return 5;

            target->logfd=fdopen(tmpfd, "a");
            if(target->logfd == ((struct _IO_FILE *)NULL))
              return 4;

            state = 3;
            memset((void *)tab, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 3;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
          break;
        }
        case 3:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            signed int return_value_checkmsgti_7;
            return_value_checkmsgti_7=checkmsgti(target, tab);
            if(!(return_value_checkmsgti_7 == 0))
              return 6;

            memset((void *)tab, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 6;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
        }
      }
    if(!(i == 0))
    {
      if(state == 3)
      {
        tab[(signed long int)i] = (char)0;
        signed int return_value_checkmsgti_8;
        return_value_checkmsgti_8=checkmsgti(target, tab);
        if(!(return_value_checkmsgti_8 == 0))
          return 6;

        goto __CPROVER_DUMP_L32;
      }

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L32:
      ;
      return 0;
    }
  }
}

// checkmsgti
// file logging.c line 119
signed int checkmsgti(struct llnode *target, char *tab)
{
  signed int tmp_statement_expression_25;
  unsigned long int checkmsgti__1__1____s1_len;
  unsigned long int checkmsgti__1__1____s2_len;
  signed int return_value___builtin_strcmp_26;
  return_value___builtin_strcmp_26=__builtin_strcmp(tab, "LOG_T_ALL");
  tmp_statement_expression_25 = return_value___builtin_strcmp_26;
  signed int tmp_statement_expression_23;
  signed int tmp_statement_expression_21;
  signed int tmp_statement_expression_19;
  signed int tmp_statement_expression_17;
  signed int tmp_statement_expression_15;
  signed int tmp_statement_expression_13;
  signed int tmp_statement_expression_11;
  signed int tmp_statement_expression_9;
  signed int tmp_statement_expression_7;
  signed int tmp_statement_expression_5;
  signed int tmp_statement_expression_3;
  signed int tmp_statement_expression_1;
  if(tmp_statement_expression_25 == 0)
    target->msgtype = target->msgtype | (char)(1 | 2 | 4 | 8 | 16);

  else
  {
    unsigned long int checkmsgti__1__3____s1_len;
    unsigned long int checkmsgti__1__3____s2_len;
    signed int return_value___builtin_strcmp_24;
    return_value___builtin_strcmp_24=__builtin_strcmp(tab, "LOG_T_USER");
    tmp_statement_expression_23 = return_value___builtin_strcmp_24;
    if(tmp_statement_expression_23 == 0)
      target->msgtype = target->msgtype | (char)1;

    else
    {
      unsigned long int checkmsgti__1__5____s1_len;
      unsigned long int checkmsgti__1__5____s2_len;
      signed int return_value___builtin_strcmp_22;
      return_value___builtin_strcmp_22=__builtin_strcmp(tab, "LOG_T_CLIENT");
      tmp_statement_expression_21 = return_value___builtin_strcmp_22;
      if(tmp_statement_expression_21 == 0)
        target->msgtype = target->msgtype | (char)2;

      else
      {
        unsigned long int checkmsgti__1__7____s1_len;
        unsigned long int checkmsgti__1__7____s2_len;
        signed int return_value___builtin_strcmp_20;
        return_value___builtin_strcmp_20=__builtin_strcmp(tab, "LOG_T_INIT");
        tmp_statement_expression_19 = return_value___builtin_strcmp_20;
        if(tmp_statement_expression_19 == 0)
          target->msgtype = target->msgtype | (char)4;

        else
        {
          unsigned long int checkmsgti__1__9____s1_len;
          unsigned long int checkmsgti__1__9____s2_len;
          signed int return_value___builtin_strcmp_18;
          return_value___builtin_strcmp_18=__builtin_strcmp(tab, "LOG_T_MANAGE");
          tmp_statement_expression_17 = return_value___builtin_strcmp_18;
          if(tmp_statement_expression_17 == 0)
            target->msgtype = target->msgtype | (char)8;

          else
          {
            unsigned long int checkmsgti__1__11____s1_len;
            unsigned long int checkmsgti__1__11____s2_len;
            signed int return_value___builtin_strcmp_16;
            return_value___builtin_strcmp_16=__builtin_strcmp(tab, "LOG_T_MAIN");
            tmp_statement_expression_15 = return_value___builtin_strcmp_16;
            if(tmp_statement_expression_15 == 0)
              target->msgtype = target->msgtype | (char)16;

            else
            {
              unsigned long int checkmsgti__1__13____s1_len;
              unsigned long int checkmsgti__1__13____s2_len;
              signed int return_value___builtin_strcmp_14;
              return_value___builtin_strcmp_14=__builtin_strcmp(tab, "LOG_I_ALL");
              tmp_statement_expression_13 = return_value___builtin_strcmp_14;
              if(tmp_statement_expression_13 == 0)
                target->importance = target->importance | (char)(1 | 2 | 4 | 8 | 16 | 32 | 64);

              else
              {
                unsigned long int checkmsgti__1__15____s1_len;
                unsigned long int checkmsgti__1__15____s2_len;
                signed int return_value___builtin_strcmp_12;
                return_value___builtin_strcmp_12=__builtin_strcmp(tab, "LOG_I_CRIT");
                tmp_statement_expression_11 = return_value___builtin_strcmp_12;
                if(tmp_statement_expression_11 == 0)
                  target->importance = target->importance | (char)1;

                else
                {
                  unsigned long int checkmsgti__1__17____s1_len;
                  unsigned long int checkmsgti__1__17____s2_len;
                  signed int return_value___builtin_strcmp_10;
                  return_value___builtin_strcmp_10=__builtin_strcmp(tab, "LOG_I_DEBUG");
                  tmp_statement_expression_9 = return_value___builtin_strcmp_10;
                  if(tmp_statement_expression_9 == 0)
                    target->importance = target->importance | (char)2;

                  else
                  {
                    unsigned long int checkmsgti__1__19____s1_len;
                    unsigned long int checkmsgti__1__19____s2_len;
                    signed int return_value___builtin_strcmp_8;
                    return_value___builtin_strcmp_8=__builtin_strcmp(tab, "LOG_I_INFO");
                    tmp_statement_expression_7 = return_value___builtin_strcmp_8;
                    if(tmp_statement_expression_7 == 0)
                      target->importance = target->importance | (char)8;

                    else
                    {
                      unsigned long int __s1_len;
                      unsigned long int __s2_len;
                      signed int return_value___builtin_strcmp_6;
                      return_value___builtin_strcmp_6=__builtin_strcmp(tab, "LOG_I_NOTICE");
                      tmp_statement_expression_5 = return_value___builtin_strcmp_6;
                      if(tmp_statement_expression_5 == 0)
                        target->importance = target->importance | (char)16;

                      else
                      {
                        unsigned long int checkmsgti__1__23____s1_len;
                        unsigned long int checkmsgti__1__23____s2_len;
                        signed int return_value___builtin_strcmp_4;
                        return_value___builtin_strcmp_4=__builtin_strcmp(tab, "LOG_I_WARNING");
                        tmp_statement_expression_3 = return_value___builtin_strcmp_4;
                        if(tmp_statement_expression_3 == 0)
                          target->importance = target->importance | (char)32;

                        else
                        {
                          unsigned long int checkmsgti__1__25____s1_len;
                          unsigned long int checkmsgti__1__25____s2_len;
                          signed int return_value___builtin_strcmp_2;
                          return_value___builtin_strcmp_2=__builtin_strcmp(tab, "LOG_I_ERR");
                          tmp_statement_expression_1 = return_value___builtin_strcmp_2;
                          if(tmp_statement_expression_1 == 0)
                            target->importance = target->importance | (char)64;

                          else
                            return 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

// clean_return
// file http_proxy_client.c line 48
static void clean_return(signed int sockfd)
{
  aflog((char)16, (char)2, "http proxy: clean_return");
  close(sockfd);
  pthread_exit((void *)0);
}

// clear_fd
// file http_proxy_functions.c line 261
void clear_fd(signed int *fd, struct anonymous_11 *set)
{
  set->__fds_bits[(signed long int)(*fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->__fds_bits[(signed long int)(*fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << *fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  close_fd(fd);
}

// clear_sslFd
// file http_proxy_functions.c line 362
void clear_sslFd(struct anonymous_0 *sf, struct anonymous_11 *set)
{
  clear_fd(&sf->fd, set);
  struct ssl_st *return_value_SslFd_get_ssl_2;
  return_value_SslFd_get_ssl_2=SslFd_get_ssl(sf);
  if(!(return_value_SslFd_get_ssl_2 == ((struct ssl_st *)NULL)))
  {
    struct ssl_st *return_value_SslFd_get_ssl_1;
    return_value_SslFd_get_ssl_1=SslFd_get_ssl(sf);
    SSL_clear(return_value_SslFd_get_ssl_1);
  }

}

// client_admin
// file client_remoteadmin.h line 35
signed int client_admin(char type, struct anonymous_0 *master, unsigned char *buff, signed int connectfd, char *id)
{
  struct anonymous_11 rset;
  struct anonymous_11 allset;
  signed int maxfdp1;
  signed int n;
  signed int length;
  signed int infd;
  struct _IO_FILE *outfp;
  struct _IO_FILE *infp;
  buff[(signed long int)0] = (unsigned char)14;
  SslFd_send_message(type, master, buff, 5);
  buff[(signed long int)0] = (unsigned char)0;
  SslFd_get_message(type, master, buff, -5);
  signed int tmp_if_expr_5;
  signed int return_value_SslFd_get_fd_4;
  signed long int return_value_getcg_8;
  signed long int return_value_getcg_9;
  if((signed int)*buff == 0)
  {
    aflog((char)4, (char)1, "Wrong password");
    return 1;
  }

  else
    if((signed int)*buff == 12)
    {
      aflog((char)4, (char)1, "Server is full");
      return 1;
    }

    else
      if(!((signed int)*buff == 14))
      {
        aflog((char)4, (char)1, "Incompatible server type or server full");
        return 1;
      }

      else
      {
        aflog((char)16, (char)8, "CLIENT STARTED mode: remote administration");
        if(connectfd >= 1)
        {
          outfp=fdopen(connectfd, "w");
          if(outfp == ((struct _IO_FILE *)NULL))
          {
            aflog((char)4, (char)1, "Error in opening file descriptor for writing");
            return 1;
          }

          infd = connectfd;
        }

        else
        {
          infd = 0;
          outfp = stdout;
        }
        infp=fdopen(infd, "r");
        if(infp == ((struct _IO_FILE *)NULL))
        {
          aflog((char)4, (char)1, "Error in opening file descriptor for reading");
          return 1;
        }

        else
        {
          length = (signed int)buff[(signed long int)3];
          length = length << 8;
          length = length + (signed int)buff[(signed long int)4];
          n=SslFd_get_message(type, master, buff, length);
          buff[(signed long int)n] = (unsigned char)0;
          fprintf(outfp, "%s\n", (char *)buff);
          fflush(outfp);
          do
          {
            signed int __d0;
            signed int __d1;
            asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_11) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&allset)->__fds_bits[(signed long int)0]) : "memory");
          }
          while((_Bool)0);
          signed int return_value_SslFd_get_fd_1;
          return_value_SslFd_get_fd_1=SslFd_get_fd(master);
          signed int return_value_SslFd_get_fd_2;
          return_value_SslFd_get_fd_2=SslFd_get_fd(master);
          (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd_1 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd_1 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_SslFd_get_fd_2 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
          (&allset)->__fds_bits[(signed long int)(infd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(infd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << infd % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
          signed int return_value_SslFd_get_fd_3;
          return_value_SslFd_get_fd_3=SslFd_get_fd(master);
          if(!(return_value_SslFd_get_fd_3 >= infd))
            tmp_if_expr_5 = infd + 1;

          else
          {
            return_value_SslFd_get_fd_4=SslFd_get_fd(master);
            tmp_if_expr_5 = return_value_SslFd_get_fd_4 + 1;
          }
          maxfdp1 = tmp_if_expr_5;
          if(!(id == ((char *)NULL)))
          {
            buff[(signed long int)0] = (unsigned char)8;
            buff[(signed long int)2] = (unsigned char)0;
            buff[(signed long int)1] = buff[(signed long int)2];
            unsigned long int return_value_strlen_6;
            return_value_strlen_6=strlen(id);
            n = (signed int)return_value_strlen_6;
            memcpy((void *)&buff[(signed long int)5], (const void *)id, (unsigned long int)n);
            buff[(signed long int)3] = (unsigned char)(n >> 8);
            buff[(signed long int)4] = (unsigned char)n;
            SslFd_send_message(type, master, buff, n + 5);
            aflog((char)8, (char)8, "ID SENT: %s", id);
          }

          while((_Bool)1)
          {
            rset = allset;
            select(maxfdp1, &rset, (struct anonymous_11 *)(void *)0, (struct anonymous_11 *)(void *)0, (struct timeval *)(void *)0);
            signed int return_value_SslFd_get_fd_10;
            return_value_SslFd_get_fd_10=SslFd_get_fd(master);
            signed int return_value_SslFd_get_fd_11;
            return_value_SslFd_get_fd_11=SslFd_get_fd(master);
            if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd_10 / 8)] & 1l << return_value_SslFd_get_fd_11 % 8) == 0l))
            {
              aflog((char)8, (char)2, "masterfd: FD_ISSET");
              n=SslFd_get_message(type, master, buff, 5);
              if(!(n == 5))
              {
                aflog((char)8, (char)64, "FATAL ERROR! (%d)", n);
                if(n == -1)
                {
                  if(!((4 & (signed int)type) == 0))
                  {
                    get_ssl_error(master, "FE", n);
                    continue;
                  }

                }

                if(!(n == 0))
                  return 1;

              }

              if(n == 0)
              {
                aflog((char)8, (char)1, "SERVER: premature quit --> exiting...");
                return 1;
              }

              if((signed int)*buff == 4)
              {
                signed long int return_value_getcg_7;
                return_value_getcg_7=getcg();
                aflog((char)8, (char)1, "SERVER: CLOSED -> exiting... cg: %ld bytes", return_value_getcg_7);
                return 0;
              }

              if(!((signed int)*buff == 15))
              {
                aflog((char)8, (char)1, "SERVER: wrong message --> exiting");
                return 1;
              }

              length = (signed int)buff[(signed long int)3];
              length = length << 8;
              length = length + (signed int)buff[(signed long int)4];
              switch((signed int)buff[(signed long int)1])
              {
                case 3:
                  aflog((char)8, (char)8, "SERVER: cmd successful");
                case 5:
                  if((signed int)buff[1l] == 5)
                    aflog((char)8, (char)8, "SERVER: cmd failed");

                case 0:
                {
                  if((signed int)buff[1l] == 0)
                    aflog((char)8, (char)32, "SERVER: unknown cmd");

                  n=SslFd_get_message(type, master, buff, length);
                  buff[(signed long int)n] = (unsigned char)0;
                  fprintf(outfp, "%s", (char *)buff);
                  fflush(outfp);
                  break;
                }
                case 6:
                {
                  return_value_getcg_8=getcg();
                  aflog((char)8, (char)64, "SERVER: kicked us -> exiting... cg: %ld bytes", return_value_getcg_8);
                  return 1;
                }
                default:
                {
                  return_value_getcg_9=getcg();
                  aflog((char)8, (char)64, "SERVER: unrecognized message -> exiting... cg: %ld bytes", return_value_getcg_9);
                  return 1;
                }
              }
            }

            if(!((rset.__fds_bits[(signed long int)(infd / 8)] & 1l << infd % 8) == 0l))
            {
              aflog((char)8, (char)2, "infd: FD_ISSET");
              char *return_value_fgets_13;
              return_value_fgets_13=fgets((char *)&buff[(signed long int)5], 8091, infp);
              if(return_value_fgets_13 == ((char *)NULL))
              {
                signed long int return_value_getcg_12;
                return_value_getcg_12=getcg();
                aflog((char)8, (char)16, "CLIENT CLOSED cg: %ld bytes", return_value_getcg_12);
                return 0;
              }

              unsigned long int return_value_strlen_14;
              return_value_strlen_14=strlen((char *)&buff[(signed long int)5]);
              n = (signed int)return_value_strlen_14;
              if(n >= 1)
              {
                if((signed int)buff[(signed long int)(4 + n)] == 10)
                  n = n - 1;

              }

              buff[(signed long int)0] = (unsigned char)15;
              buff[(signed long int)1] = (unsigned char)1;
              buff[(signed long int)2] = (unsigned char)0;
              buff[(signed long int)3] = (unsigned char)(n >> 8);
              buff[(signed long int)4] = (unsigned char)n;
              SslFd_send_message(type, master, buff, n + 5);
            }

          }
        }
      }
}

// client_long_usage
// file usage.h line 27
void client_long_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf(" Basic options:\n\n");
  printf("  -n, --servername    - where the second part of the active\n");
  printf("                        port forwarder is running (required)\n");
  printf("  -m, --manageport    - manage port number - server must be\n");
  printf("                        listening on it (default: 50126)\n");
  printf("  -d, --hostname      - the name of this host/remote host - the final\n");
  printf("                        destination of the packets (default: the name\n");
  printf("                        returned by hostname function)\n");
  printf("  -p, --portnum       - the port we are forwarding connection to (required)\n");
  printf("  --localname         - local machine name for connection with afserver\n");
  printf("                        (used to bind socket to different interfaces)\n");
  printf("  --localport         - local port name for connection with afserver\n");
  printf("                        (used to bind socket to different addressees)\n");
  printf("  --localdesname      - local machine name for connections with destination\n");
  printf("                        application (used to bind socket to different interfaces)\n");
  printf("  -V, --version       - display version number\n");
  printf("  -h, --help          - prints this help\n\n");
  printf(" Authorization:\n\n");
  printf("  -i, --id            - sends the id string to afserver\n");
  printf("  --pass              - set the password used for client identification\n");
  printf("                        (default: no password)\n");
  printf("  --ignorepkeys       - ignore invalid server's public keys\n\n");
  printf(" Configuration:\n\n");
  printf("  -k, --keyfile       - the name of the file with RSA key (default: client.rsa)\n");
  printf("  -c, --cerfile       - the name of the file with certificate\n");
  printf("                        (default: no certificate used)\n");
  printf("  -f, --cfgfile       - the name of the file with the configuration for the\n");
  printf("                        active forwarder (client)\n");
  printf("  -s, --storefile     - the name of the file with stored public keys\n");
  printf("                        (default: known_hosts)\n");
  printf("  -D, --dateformat    - format of the date printed in logs (see 'man strftime'\n");
  printf("                        for details) (default: %%Y-%%m-%%d %%H:%%M:%%S)\n");
  printf("  -K, --keep-alive N  - send keepalive packets every N seconds\n");
  printf("                        (default: not send keepalive packets)\n\n");
  printf(" Auto-reconnection:\n\n");
  printf("  --ar-start          - enable auto-reconnection when afserver is not\n");
  printf("                        reachable on start (default: disabled)\n");
  printf("  --ar-quit           - enable auto-reconnection after normal afserver quit\n");
  printf("                        (default: disabled)\n");
  printf("  --noar              - disable auto-reconnection after premature afserver\n");
  printf("                        quit (default: enabled)\n");
  printf("  -A, --ar-tries N    - try N times to reconnect (default: unlimited)\n");
  printf("  -T, --ar-delay N    - wait N seconds between reconnect tries (default: 5)\n\n");
  printf(" Modes:\n\n");
  printf("  -u, --udpmode       - udp mode - client will use udp protocol to\n");
  printf("                        communicate with the hostname:portnum\n");
  printf("  -U, --reverseudp    - reverse udp forwarding. Udp packets will be forwarded\n");
  printf("                        from hostname:portnum to the server name:manageport\n");
  printf("  -r, --remoteadmin   - remote administration mode. (using '-p #port' will\n");
  printf("                        force afclient to use port rather than stdin-stdout)\n\n");
  printf(" Logging:\n\n");
  printf("  -o, --log           - log choosen information to file/socket\n");
  printf("  -v, --verbose       - to be verbose - program won't enter the daemon mode\n");
  printf("                        (use several times for greater effect)\n\n");
  printf(" IP family:\n\n");
  printf("  -4, --ipv4          - use ipv4 only\n");
  printf("  -6, --ipv6          - use ipv6 only\n\n");
  printf(" Modules:\n\n");
  printf("  -l, --load          - load a module for user's packets filtering\n");
  printf("  -L, --Load          - load a module for service's packets filtering\n\n");
  printf(" HTTP/HTTPS PROXY:\n\n");
  printf("  -S, --use-https     - use https proxy instead of http proxy\n");
  printf("  -P, --proxyname     - the name of the machine with proxy server\n");
  printf("  -X, --proxyport     - the port used by proxy server (default: 8080)\n");
  printf("  -C, --pa-cred  U:P  - the user (U) and password (P) used in proxy\n");
  printf("                        authorization\n");
  printf("  -B, --pa-t-basic    - the Basic type of proxy authorization (default)\n\n");
  exit(0);
}

// client_reverse_udp
// file client_reverse_udp.h line 39
void client_reverse_udp(struct anonymous_5 *cr, unsigned char *buff, signed int buflength)
{
  unsigned int len;
  unsigned int addrlen;
  signed int maxfdp1;
  signed int temp;
  signed int n;
  signed int length;
  signed int notsent;
  struct sockaddr *cliaddr;
  struct anonymous_11 rset;
  struct anonymous_11 allset;
  char *return_value_ClientRealm_get_hostName_8;
  return_value_ClientRealm_get_hostName_8=ClientRealm_get_hostName(cr);
  struct portlist *return_value_ClientRealm_get_destinationPorts_9;
  return_value_ClientRealm_get_destinationPorts_9=ClientRealm_get_destinationPorts(cr);
  struct plnode *return_value_PortList_get_nth_10;
  return_value_PortList_get_nth_10=PortList_get_nth(return_value_ClientRealm_get_destinationPorts_9, 0);
  char *return_value_PortListNode_get_portName_11;
  return_value_PortListNode_get_portName_11=PortListNode_get_portName(return_value_PortList_get_nth_10);
  char return_value_ClientRealm_get_ipFamily_12;
  return_value_ClientRealm_get_ipFamily_12=ClientRealm_get_ipFamily(cr);
  signed int return_value_ip_listen_13;
  return_value_ip_listen_13=ip_listen(&temp, return_value_ClientRealm_get_hostName_8, return_value_PortListNode_get_portName_11, &addrlen, (const char)((signed int)return_value_ClientRealm_get_ipFamily_12 & 0xfe));
  char *tmp_if_expr_3;
  char return_value_ClientRealm_get_ipFamily_2;
  if(!(return_value_ip_listen_13 == 0))
  {
    char return_value_ClientRealm_get_ipFamily_1;
    return_value_ClientRealm_get_ipFamily_1=ClientRealm_get_ipFamily(cr);
    if(!((0x02 & (signed int)return_value_ClientRealm_get_ipFamily_1) == 0))
      tmp_if_expr_3 = "ipv4";

    else
    {
      return_value_ClientRealm_get_ipFamily_2=ClientRealm_get_ipFamily(cr);
      tmp_if_expr_3 = ((signed int)return_value_ClientRealm_get_ipFamily_2 & 0x04) != 0 ? "ipv6" : "unspec";
    }
    char *return_value_ClientRealm_get_hostName_4;
    return_value_ClientRealm_get_hostName_4=ClientRealm_get_hostName(cr);
    struct portlist *return_value_ClientRealm_get_destinationPorts_5;
    return_value_ClientRealm_get_destinationPorts_5=ClientRealm_get_destinationPorts(cr);
    struct plnode *return_value_PortList_get_nth_6;
    return_value_PortList_get_nth_6=PortList_get_nth(return_value_ClientRealm_get_destinationPorts_5, 0);
    char *return_value_PortListNode_get_portName_7;
    return_value_PortListNode_get_portName_7=PortListNode_get_portName(return_value_PortList_get_nth_6);
    aflog((char)4, (char)2, "udp_listen_%s error for %s, %s", tmp_if_expr_3, return_value_ClientRealm_get_hostName_4, return_value_PortListNode_get_portName_7);
    exit(1);
  }

  struct anonymous_7 **return_value_ClientRealm_get_usersTable_14;
  return_value_ClientRealm_get_usersTable_14=ClientRealm_get_usersTable(cr);
  ConnectUser_set_connFd(return_value_ClientRealm_get_usersTable_14[(signed long int)0], temp);
  void *return_value_malloc_15;
  return_value_malloc_15=malloc((unsigned long int)addrlen);
  cliaddr = (struct sockaddr *)return_value_malloc_15;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_11) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&allset)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_16;
  return_value_ClientRealm_get_masterSslFd_16=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd_17;
  return_value_SslFd_get_fd_17=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_16);
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_18;
  return_value_ClientRealm_get_masterSslFd_18=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd_19;
  return_value_SslFd_get_fd_19=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_18);
  (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd_17 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd_17 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_SslFd_get_fd_19 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_20;
  return_value_ClientRealm_get_masterSslFd_20=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd_21;
  return_value_SslFd_get_fd_21=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_20);
  maxfdp1 = return_value_SslFd_get_fd_21 + 1;
  struct anonymous_7 **return_value_ClientRealm_get_usersTable_22;
  return_value_ClientRealm_get_usersTable_22=ClientRealm_get_usersTable(cr);
  signed int return_value_ConnectUser_get_connFd_23;
  return_value_ConnectUser_get_connFd_23=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable_22[(signed long int)0]);
  signed int tmp_if_expr_26;
  struct anonymous_7 **return_value_ClientRealm_get_usersTable_24;
  signed int return_value_ConnectUser_get_connFd_25;
  if(!(1 + return_value_ConnectUser_get_connFd_23 >= maxfdp1))
    tmp_if_expr_26 = maxfdp1;

  else
  {
    return_value_ClientRealm_get_usersTable_24=ClientRealm_get_usersTable(cr);
    return_value_ConnectUser_get_connFd_25=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable_24[(signed long int)0]);
    tmp_if_expr_26 = return_value_ConnectUser_get_connFd_25 + 1;
  }
  maxfdp1 = tmp_if_expr_26;
  struct anonymous_7 **return_value_ClientRealm_get_usersTable_27;
  return_value_ClientRealm_get_usersTable_27=ClientRealm_get_usersTable(cr);
  signed int return_value_ConnectUser_get_connFd_28;
  return_value_ConnectUser_get_connFd_28=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable_27[(signed long int)0]);
  struct anonymous_7 **return_value_ClientRealm_get_usersTable_29;
  return_value_ClientRealm_get_usersTable_29=ClientRealm_get_usersTable(cr);
  signed int return_value_ConnectUser_get_connFd_30;
  return_value_ConnectUser_get_connFd_30=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable_29[(signed long int)0]);
  (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_28 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_28 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd_30 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  aflog((char)2, (char)8, "CLIENT STARTED mode: udp reverse");
  _Bool tmp_if_expr_49;
  _Bool tmp_if_expr_50;
  do
  {
    len = (unsigned int)4;
    struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_31;
    return_value_ClientRealm_get_masterSslFd_31=ClientRealm_get_masterSslFd(cr);
    signed int return_value_SslFd_get_fd_32;
    return_value_SslFd_get_fd_32=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_31);
    signed int return_value_getsockopt_33;
    return_value_getsockopt_33=getsockopt(return_value_SslFd_get_fd_32, 1, 7, (void *)&temp, &len);
    if(!(return_value_getsockopt_33 == -1))
    {
      if(!(temp == buflength))
      {
        buflength = temp;
        aflog((char)2, (char)32, "Send buffer size changed...");
      }

    }

    len = addrlen;
    rset = allset;
    aflog((char)16, (char)2, "select");
    select(maxfdp1, &rset, (struct anonymous_11 *)(void *)0, (struct anonymous_11 *)(void *)0, (struct timeval *)(void *)0);
    aflog((char)16, (char)2, "after select...");
    struct anonymous_7 **return_value_ClientRealm_get_usersTable_43;
    return_value_ClientRealm_get_usersTable_43=ClientRealm_get_usersTable(cr);
    signed int return_value_ConnectUser_get_connFd_44;
    return_value_ConnectUser_get_connFd_44=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable_43[(signed long int)0]);
    struct anonymous_7 **return_value_ClientRealm_get_usersTable_45;
    return_value_ClientRealm_get_usersTable_45=ClientRealm_get_usersTable(cr);
    signed int return_value_ConnectUser_get_connFd_46;
    return_value_ConnectUser_get_connFd_46=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable_45[(signed long int)0]);
    if(!((rset.__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_44 / 8)] & 1l << return_value_ConnectUser_get_connFd_46 % 8) == 0l))
    {
      struct anonymous_7 **return_value_ClientRealm_get_usersTable_34;
      return_value_ClientRealm_get_usersTable_34=ClientRealm_get_usersTable(cr);
      signed int return_value_ConnectUser_get_connFd_35;
      return_value_ConnectUser_get_connFd_35=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable_34[(signed long int)0]);
      signed long int return_value_recvfrom_36;
      return_value_recvfrom_36=recvfrom(return_value_ConnectUser_get_connFd_35, (void *)&buff[(signed long int)5], (unsigned long int)8091, 0, cliaddr, &len);
      n = (signed int)return_value_recvfrom_36;
      aflog((char)16, (char)4, "SIOCOUTQ is defined");
      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_37;
      return_value_ClientRealm_get_masterSslFd_37=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd_38;
      return_value_SslFd_get_fd_38=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_37);
      signed int return_value_ioctl_39;
      return_value_ioctl_39=ioctl(return_value_SslFd_get_fd_38, (unsigned long int)0x5411, &notsent);
      if(!(return_value_ioctl_39 == 0))
      {
        aflog((char)2, (char)1, "ioctl error -> exiting...");
        exit(1);
      }

      if(5 + n + notsent >= buflength)
        aflog((char)2, (char)8, "drop: size:%d, buf:%d, w:%d/%d", n, buflength, notsent, buflength);

      else
        if(n >= 1)
        {
          char *return_value_sock_ntop_40;
          return_value_sock_ntop_40=sock_ntop(cliaddr, len, (char *)(void *)0, (char *)(void *)0, (char)0);
          aflog((char)2, (char)8, "Sending %d bytes to service (w:%d/%d) (FROM:%s)", n, notsent, buflength, return_value_sock_ntop_40);
          buff[(signed long int)0] = (unsigned char)3;
          buff[(signed long int)1] = (unsigned char)8;
          buff[(signed long int)2] = (unsigned char)3;
          buff[(signed long int)3] = (unsigned char)(n >> 8);
          buff[(signed long int)4] = (unsigned char)n;
          struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_41;
          return_value_ClientRealm_get_masterSslFd_41=ClientRealm_get_masterSslFd(cr);
          signed int return_value_SslFd_get_fd_42;
          return_value_SslFd_get_fd_42=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_41);
          writen(return_value_SslFd_get_fd_42, buff, n + 5);
        }

    }

    struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_56;
    return_value_ClientRealm_get_masterSslFd_56=ClientRealm_get_masterSslFd(cr);
    signed int return_value_SslFd_get_fd_57;
    return_value_SslFd_get_fd_57=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_56);
    struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_58;
    return_value_ClientRealm_get_masterSslFd_58=ClientRealm_get_masterSslFd(cr);
    signed int return_value_SslFd_get_fd_59;
    return_value_SslFd_get_fd_59=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_58);
    if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd_57 / 8)] & 1l << return_value_SslFd_get_fd_59 % 8) == 0l))
    {
      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_47;
      return_value_ClientRealm_get_masterSslFd_47=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd_48;
      return_value_SslFd_get_fd_48=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_47);
      n=readn(return_value_SslFd_get_fd_48, buff, 5);
      if(n == 5)
      {
        if(!((signed int)*buff == 3))
          tmp_if_expr_49 = (_Bool)1;

        else
          tmp_if_expr_49 = (signed int)buff[(signed long int)1] != 8 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_49)
          tmp_if_expr_50 = (_Bool)1;

        else
          tmp_if_expr_50 = (signed int)buff[(signed long int)2] != 3 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_50)
        {
          aflog((char)2, (char)1, "Incompatible server type (not udp?) or data corruption -> exiting...");
          exit(1);
        }

        length = (signed int)buff[(signed long int)3];
        length = length << 8;
        length = length + (signed int)buff[(signed long int)4];
        struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_51;
        return_value_ClientRealm_get_masterSslFd_51=ClientRealm_get_masterSslFd(cr);
        signed int return_value_SslFd_get_fd_52;
        return_value_SslFd_get_fd_52=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_51);
        n=readn(return_value_SslFd_get_fd_52, buff, length);
      }

      else
        n = 0;
      if(n == 0)
      {
        aflog((char)2, (char)1, "premature quit of the server -> exiting...");
        exit(1);
      }

      char *return_value_sock_ntop_53;
      return_value_sock_ntop_53=sock_ntop(cliaddr, addrlen, (char *)(void *)0, (char *)(void *)0, (char)0);
      aflog((char)2, (char)8, "Sending %d bytes to user (TO:%s)", n, return_value_sock_ntop_53);
      struct anonymous_7 **return_value_ClientRealm_get_usersTable_54;
      return_value_ClientRealm_get_usersTable_54=ClientRealm_get_usersTable(cr);
      signed int return_value_ConnectUser_get_connFd_55;
      return_value_ConnectUser_get_connFd_55=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable_54[(signed long int)0]);
      sendto(return_value_ConnectUser_get_connFd_55, (const void *)buff, (unsigned long int)n, 0, cliaddr, addrlen);
    }

  }
  while((_Bool)1);
  exit(0);
}

// client_short_usage
// file usage.h line 26
void client_short_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf("Try `afclient --help' for more information.\n");
  exit(1);
}

// client_sig_alrm
// file client_signals.h line 25
void client_sig_alrm(signed int signo)
{
  aflog((char)16, (char)2, "Received SIGALRM");
}

// client_sig_int
// file client_signals.h line 24
void client_sig_int(signed int signo)
{
  signed int return_value_is_this_a_mainthread_1;
  return_value_is_this_a_mainthread_1=is_this_a_mainthread();
  if(!(return_value_is_this_a_mainthread_1 == 0))
  {
    signed long int return_value_getcg_2;
    return_value_getcg_2=getcg();
    aflog((char)16, (char)16, "CLIENT CLOSED cg: %ld bytes", return_value_getcg_2);
    exit(0);
  }

}

// close_connections
// file client_shutdown.c line 27
void close_connections(signed int usernum, struct anonymous_7 ***contable)
{
  signed int i;
  _Bool tmp_if_expr_4;
  char return_value_ConnectUser_get_state_3;
  if(!(contable == ((struct anonymous_7 ***)NULL)))
  {
    if(!(*contable == ((struct anonymous_7 **)NULL)))
    {
      i = 0;
      for( ; !(i >= usernum); i = i + 1)
      {
        char return_value_ConnectUser_get_state_2;
        return_value_ConnectUser_get_state_2=ConnectUser_get_state((*contable)[(signed long int)i]);
        if((signed int)return_value_ConnectUser_get_state_2 == 7)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_ConnectUser_get_state_3=ConnectUser_get_state((*contable)[(signed long int)i]);
          tmp_if_expr_4 = (signed int)return_value_ConnectUser_get_state_3 == 11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          signed int return_value_ConnectUser_get_connFd_1;
          return_value_ConnectUser_get_connFd_1=ConnectUser_get_connFd((*contable)[(signed long int)i]);
          close(return_value_ConnectUser_get_connFd_1);
        }

        ConnectUser_free(&(*contable)[(signed long int)i]);
      }
      free((void *)*contable);
      *contable = (struct anonymous_7 **)(void *)0;
    }

  }

}

// close_fd
// file http_proxy_functions.c line 248
void close_fd(signed int *fd)
{
  close(*fd);
}

// cparsefile
// file file.h line 38
struct anonymous_4 * cparsefile(char *name, signed int *status)
{
  struct anonymous_4 *cfg;
  struct _IO_FILE *file = (struct _IO_FILE *)(void *)0;
  signed int state;
  signed int i;
  signed int n;
  signed int temp;
  char buff[256l];
  char helpbuf1[256l];
  char helpbuf2[256l];
  char *tmpbuf;
  unsigned char pass[4l] = { (unsigned char)1, (unsigned char)2, (unsigned char)3, (unsigned char)4 };
  *status = 1;
  memset((void *)buff, 0, (unsigned long int)256);
  cfg=ClientConfiguration_new();
  if(cfg == ((struct anonymous_4 *)NULL))
  {
    printf("Can't allocate memory for client configuration... exiting\n");
    exit(1);
  }

  state = 1;
  file=fopen(name, "r");
  signed int return_value_ClientConfiguration_get_realmsNumber_4;
  char *return_value_fgets_10;
  signed int tmp_statement_expression_83;
  signed int tmp_statement_expression_81;
  signed int tmp_statement_expression_79;
  signed int tmp_statement_expression_77;
  signed int tmp_statement_expression_72;
  _Bool tmp_if_expr_76;
  signed int tmp_statement_expression_74;
  signed int tmp_statement_expression_67;
  _Bool tmp_if_expr_71;
  signed int tmp_statement_expression_69;
  signed int tmp_statement_expression_62;
  _Bool tmp_if_expr_66;
  signed int tmp_statement_expression_64;
  signed int tmp_statement_expression_57;
  _Bool tmp_if_expr_61;
  signed int tmp_statement_expression_59;
  signed int tmp_statement_expression_52;
  _Bool tmp_if_expr_56;
  signed int tmp_statement_expression_54;
  signed int tmp_statement_expression_50;
  signed int tmp_statement_expression_48;
  signed int tmp_statement_expression_46;
  signed int tmp_statement_expression_196;
  _Bool tmp_if_expr_200;
  signed int tmp_statement_expression_198;
  signed int tmp_statement_expression_188;
  _Bool tmp_if_expr_192;
  signed int tmp_statement_expression_190;
  _Bool tmp_if_expr_195;
  signed int tmp_statement_expression_193;
  signed int tmp_statement_expression_183;
  _Bool tmp_if_expr_187;
  signed int tmp_statement_expression_185;
  signed int tmp_statement_expression_178;
  _Bool tmp_if_expr_182;
  signed int tmp_statement_expression_180;
  signed int tmp_statement_expression_173;
  _Bool tmp_if_expr_177;
  signed int tmp_statement_expression_175;
  signed int tmp_statement_expression_168;
  _Bool tmp_if_expr_172;
  signed int tmp_statement_expression_170;
  signed int tmp_statement_expression_163;
  _Bool tmp_if_expr_167;
  signed int tmp_statement_expression_165;
  signed int tmp_statement_expression_158;
  _Bool tmp_if_expr_162;
  signed int tmp_statement_expression_160;
  signed int tmp_statement_expression_153;
  _Bool tmp_if_expr_157;
  signed int tmp_statement_expression_155;
  signed int tmp_statement_expression_151;
  signed int tmp_statement_expression_149;
  signed int tmp_statement_expression_147;
  signed int tmp_statement_expression_142;
  _Bool tmp_if_expr_146;
  signed int tmp_statement_expression_144;
  signed int tmp_statement_expression_140;
  signed int tmp_statement_expression_135;
  _Bool tmp_if_expr_139;
  signed int tmp_statement_expression_137;
  signed int tmp_statement_expression_130;
  _Bool tmp_if_expr_134;
  signed int tmp_statement_expression_132;
  signed int tmp_statement_expression_125;
  _Bool tmp_if_expr_129;
  signed int tmp_statement_expression_127;
  signed int tmp_statement_expression_120;
  _Bool tmp_if_expr_124;
  signed int tmp_statement_expression_122;
  signed int tmp_statement_expression_115;
  _Bool tmp_if_expr_119;
  signed int tmp_statement_expression_117;
  signed int tmp_statement_expression_110;
  _Bool tmp_if_expr_114;
  signed int tmp_statement_expression_112;
  if(file == ((struct _IO_FILE *)NULL))
    return cfg;

  else
  {
    ClientConfiguration_set_realmsNumber(cfg, 1);
    signed int return_value_ClientConfiguration_get_realmsNumber_1;
    return_value_ClientConfiguration_get_realmsNumber_1=ClientConfiguration_get_realmsNumber(cfg);
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)return_value_ClientConfiguration_get_realmsNumber_1, sizeof(struct anonymous_5 *) /*8ul*/ );
    ClientConfiguration_set_realmsTable(cfg, (struct anonymous_5 **)return_value_calloc_2);
    struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_3;
    return_value_ClientConfiguration_get_realmsTable_3=ClientConfiguration_get_realmsTable(cfg);
    if(return_value_ClientConfiguration_get_realmsTable_3 == ((struct anonymous_5 **)NULL))
    {
      printf("Can't allocate memory for ClientRealm* table... exiting\n");
      exit(1);
    }

    i = 0;
    do
    {
      return_value_ClientConfiguration_get_realmsNumber_4=ClientConfiguration_get_realmsNumber(cfg);
      if(i >= return_value_ClientConfiguration_get_realmsNumber_4)
        break;

      struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_5;
      return_value_ClientConfiguration_get_realmsTable_5=ClientConfiguration_get_realmsTable(cfg);
      return_value_ClientConfiguration_get_realmsTable_5[(signed long int)i]=ClientRealm_new();
      struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_6;
      return_value_ClientConfiguration_get_realmsTable_6=ClientConfiguration_get_realmsTable(cfg);
      if(return_value_ClientConfiguration_get_realmsTable_6[(signed long int)i] == ((struct anonymous_5 *)NULL))
      {
        printf("Problem with allocating memory for ClientRealm structure... exiting");
        exit(1);
      }

      struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_7;
      return_value_ClientConfiguration_get_realmsTable_7=ClientConfiguration_get_realmsTable(cfg);
      ClientRealm_set_password(return_value_ClientConfiguration_get_realmsTable_7[(signed long int)i], pass);
      struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_8;
      return_value_ClientConfiguration_get_realmsTable_8=ClientConfiguration_get_realmsTable(cfg);
      struct portlist *return_value_PortList_new_9;
      return_value_PortList_new_9=PortList_new();
      ClientRealm_set_destinationPorts(return_value_ClientConfiguration_get_realmsTable_8[(signed long int)i], return_value_PortList_new_9);
      i = i + 1;
    }
    while((_Bool)1);
    *status = 0;
    do
    {
      return_value_fgets_10=fgets(buff, 256, file);
      if(return_value_fgets_10 == ((char *)NULL))
        break;

      *status = *status + 1;
      state=parse_line(buff, helpbuf1, helpbuf2);
      if((signed int)helpbuf1[0l] == 35)
        memset((void *)buff, 0, (unsigned long int)256);

      else
      {
        if(state == 1)
        {
          unsigned long int cparsefile__1__5__2__1____s1_len;
          unsigned long int cparsefile__1__5__2__1____s2_len;
          signed int return_value___builtin_strcmp_84;
          return_value___builtin_strcmp_84=__builtin_strcmp(helpbuf1, "ignorepkeys");
          tmp_statement_expression_83 = return_value___builtin_strcmp_84;
          if(tmp_statement_expression_83 == 0)
            ClientConfiguration_set_ignorePublicKeys(cfg, (char)1);

          else
          {
            unsigned long int cparsefile__1__5__2__3____s1_len;
            unsigned long int cparsefile__1__5__2__3____s2_len;
            signed int return_value___builtin_strcmp_82;
            return_value___builtin_strcmp_82=__builtin_strcmp(helpbuf1, "ar-start");
            tmp_statement_expression_81 = return_value___builtin_strcmp_82;
            if(tmp_statement_expression_81 == 0)
            {
              struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_11;
              return_value_ClientConfiguration_get_realmsTable_11=ClientConfiguration_get_realmsTable(cfg);
              struct anonymous_3 *return_value_ClientRealm_get_arOptions_12;
              return_value_ClientRealm_get_arOptions_12=ClientRealm_get_arOptions(return_value_ClientConfiguration_get_realmsTable_11[(signed long int)0]);
              ArOptions_set_arStart(return_value_ClientRealm_get_arOptions_12, (char)1);
            }

            else
            {
              unsigned long int cparsefile__1__5__2__5____s1_len;
              unsigned long int cparsefile__1__5__2__5____s2_len;
              signed int return_value___builtin_strcmp_80;
              return_value___builtin_strcmp_80=__builtin_strcmp(helpbuf1, "ar-quit");
              tmp_statement_expression_79 = return_value___builtin_strcmp_80;
              if(tmp_statement_expression_79 == 0)
              {
                struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_13;
                return_value_ClientConfiguration_get_realmsTable_13=ClientConfiguration_get_realmsTable(cfg);
                struct anonymous_3 *return_value_ClientRealm_get_arOptions_14;
                return_value_ClientRealm_get_arOptions_14=ClientRealm_get_arOptions(return_value_ClientConfiguration_get_realmsTable_13[(signed long int)0]);
                ArOptions_set_arQuit(return_value_ClientRealm_get_arOptions_14, (char)1);
              }

              else
              {
                unsigned long int cparsefile__1__5__2__7____s1_len;
                unsigned long int cparsefile__1__5__2__7____s2_len;
                signed int return_value___builtin_strcmp_78;
                return_value___builtin_strcmp_78=__builtin_strcmp(helpbuf1, "noar");
                tmp_statement_expression_77 = return_value___builtin_strcmp_78;
                if(tmp_statement_expression_77 == 0)
                {
                  struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_15;
                  return_value_ClientConfiguration_get_realmsTable_15=ClientConfiguration_get_realmsTable(cfg);
                  struct anonymous_3 *return_value_ClientRealm_get_arOptions_16;
                  return_value_ClientRealm_get_arOptions_16=ClientRealm_get_arOptions(return_value_ClientConfiguration_get_realmsTable_15[(signed long int)0]);
                  ArOptions_set_arPremature(return_value_ClientRealm_get_arOptions_16, (char)0);
                }

                else
                {
                  unsigned long int cparsefile__1__5__2__9____s1_len;
                  unsigned long int cparsefile__1__5__2__9____s2_len;
                  signed int return_value___builtin_strcmp_73;
                  return_value___builtin_strcmp_73=__builtin_strcmp(helpbuf1, "u");
                  tmp_statement_expression_72 = return_value___builtin_strcmp_73;
                  if(tmp_statement_expression_72 == 0)
                    tmp_if_expr_76 = (_Bool)1;

                  else
                  {
                    unsigned long int cparsefile__1__5__2__10____s1_len;
                    unsigned long int cparsefile__1__5__2__10____s2_len;
                    signed int return_value___builtin_strcmp_75;
                    return_value___builtin_strcmp_75=__builtin_strcmp(helpbuf1, "udpmode");
                    tmp_statement_expression_74 = return_value___builtin_strcmp_75;
                    tmp_if_expr_76 = tmp_statement_expression_74 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_76)
                  {
                    struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_19;
                    return_value_ClientConfiguration_get_realmsTable_19=ClientConfiguration_get_realmsTable(cfg);
                    signed int return_value_ClientRealm_get_clientMode_20;
                    return_value_ClientRealm_get_clientMode_20=ClientRealm_get_clientMode(return_value_ClientConfiguration_get_realmsTable_19[(signed long int)0]);
                    if(return_value_ClientRealm_get_clientMode_20 == 0)
                    {
                      struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_17;
                      return_value_ClientConfiguration_get_realmsTable_17=ClientConfiguration_get_realmsTable(cfg);
                      ClientRealm_set_clientMode(return_value_ClientConfiguration_get_realmsTable_17[(signed long int)0], 1);
                    }

                    else
                    {
                      struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_18;
                      return_value_ClientConfiguration_get_realmsTable_18=ClientConfiguration_get_realmsTable(cfg);
                      ClientRealm_set_clientMode(return_value_ClientConfiguration_get_realmsTable_18[(signed long int)0], -1);
                    }
                  }

                  else
                  {
                    unsigned long int cparsefile__1__5__2__12____s1_len;
                    unsigned long int cparsefile__1__5__2__12____s2_len;
                    signed int return_value___builtin_strcmp_68;
                    return_value___builtin_strcmp_68=__builtin_strcmp(helpbuf1, "U");
                    tmp_statement_expression_67 = return_value___builtin_strcmp_68;
                    if(tmp_statement_expression_67 == 0)
                      tmp_if_expr_71 = (_Bool)1;

                    else
                    {
                      unsigned long int cparsefile__1__5__2__13____s1_len;
                      unsigned long int cparsefile__1__5__2__13____s2_len;
                      signed int return_value___builtin_strcmp_70;
                      return_value___builtin_strcmp_70=__builtin_strcmp(helpbuf1, "reverseudp");
                      tmp_statement_expression_69 = return_value___builtin_strcmp_70;
                      tmp_if_expr_71 = tmp_statement_expression_69 == 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr_71)
                    {
                      struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_23;
                      return_value_ClientConfiguration_get_realmsTable_23=ClientConfiguration_get_realmsTable(cfg);
                      signed int return_value_ClientRealm_get_clientMode_24;
                      return_value_ClientRealm_get_clientMode_24=ClientRealm_get_clientMode(return_value_ClientConfiguration_get_realmsTable_23[(signed long int)0]);
                      if(return_value_ClientRealm_get_clientMode_24 == 0)
                      {
                        struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_21;
                        return_value_ClientConfiguration_get_realmsTable_21=ClientConfiguration_get_realmsTable(cfg);
                        ClientRealm_set_clientMode(return_value_ClientConfiguration_get_realmsTable_21[(signed long int)0], 3);
                      }

                      else
                      {
                        struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_22;
                        return_value_ClientConfiguration_get_realmsTable_22=ClientConfiguration_get_realmsTable(cfg);
                        ClientRealm_set_clientMode(return_value_ClientConfiguration_get_realmsTable_22[(signed long int)0], -1);
                      }
                    }

                    else
                    {
                      unsigned long int cparsefile__1__5__2__15____s1_len;
                      unsigned long int cparsefile__1__5__2__15____s2_len;
                      signed int return_value___builtin_strcmp_63;
                      return_value___builtin_strcmp_63=__builtin_strcmp(helpbuf1, "r");
                      tmp_statement_expression_62 = return_value___builtin_strcmp_63;
                      if(tmp_statement_expression_62 == 0)
                        tmp_if_expr_66 = (_Bool)1;

                      else
                      {
                        unsigned long int cparsefile__1__5__2__16____s1_len;
                        unsigned long int cparsefile__1__5__2__16____s2_len;
                        signed int return_value___builtin_strcmp_65;
                        return_value___builtin_strcmp_65=__builtin_strcmp(helpbuf1, "remoteadmin");
                        tmp_statement_expression_64 = return_value___builtin_strcmp_65;
                        tmp_if_expr_66 = tmp_statement_expression_64 == 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr_66)
                      {
                        struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_27;
                        return_value_ClientConfiguration_get_realmsTable_27=ClientConfiguration_get_realmsTable(cfg);
                        signed int return_value_ClientRealm_get_clientMode_28;
                        return_value_ClientRealm_get_clientMode_28=ClientRealm_get_clientMode(return_value_ClientConfiguration_get_realmsTable_27[(signed long int)0]);
                        if(return_value_ClientRealm_get_clientMode_28 == 0)
                        {
                          struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_25;
                          return_value_ClientConfiguration_get_realmsTable_25=ClientConfiguration_get_realmsTable(cfg);
                          ClientRealm_set_clientMode(return_value_ClientConfiguration_get_realmsTable_25[(signed long int)0], 2);
                        }

                        else
                        {
                          struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_26;
                          return_value_ClientConfiguration_get_realmsTable_26=ClientConfiguration_get_realmsTable(cfg);
                          ClientRealm_set_clientMode(return_value_ClientConfiguration_get_realmsTable_26[(signed long int)0], -1);
                        }
                      }

                      else
                      {
                        unsigned long int __s1_len;
                        unsigned long int __s2_len;
                        signed int return_value___builtin_strcmp_58;
                        return_value___builtin_strcmp_58=__builtin_strcmp(helpbuf1, "S");
                        tmp_statement_expression_57 = return_value___builtin_strcmp_58;
                        if(tmp_statement_expression_57 == 0)
                          tmp_if_expr_61 = (_Bool)1;

                        else
                        {
                          unsigned long int cparsefile__1__5__2__19____s1_len;
                          unsigned long int cparsefile__1__5__2__19____s2_len;
                          signed int return_value___builtin_strcmp_60;
                          return_value___builtin_strcmp_60=__builtin_strcmp(helpbuf1, "use-https");
                          tmp_statement_expression_59 = return_value___builtin_strcmp_60;
                          tmp_if_expr_61 = tmp_statement_expression_59 == 0 ? (_Bool)1 : (_Bool)0;
                        }
                        if(tmp_if_expr_61)
                        {
                          struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_29;
                          return_value_ClientConfiguration_get_realmsTable_29=ClientConfiguration_get_realmsTable(cfg);
                          struct anonymous *return_value_ClientRealm_get_httpProxyOptions_30;
                          return_value_ClientRealm_get_httpProxyOptions_30=ClientRealm_get_httpProxyOptions(return_value_ClientConfiguration_get_realmsTable_29[(signed long int)0]);
                          HttpProxyOptions_use_https(return_value_ClientRealm_get_httpProxyOptions_30);
                        }

                        else
                        {
                          unsigned long int cparsefile__1__5__2__21____s1_len;
                          unsigned long int cparsefile__1__5__2__21____s2_len;
                          signed int return_value___builtin_strcmp_53;
                          return_value___builtin_strcmp_53=__builtin_strcmp(helpbuf1, "B");
                          tmp_statement_expression_52 = return_value___builtin_strcmp_53;
                          if(tmp_statement_expression_52 == 0)
                            tmp_if_expr_56 = (_Bool)1;

                          else
                          {
                            unsigned long int cparsefile__1__5__2__22____s1_len;
                            unsigned long int cparsefile__1__5__2__22____s2_len;
                            signed int return_value___builtin_strcmp_55;
                            return_value___builtin_strcmp_55=__builtin_strcmp(helpbuf1, "pa-t-basic");
                            tmp_statement_expression_54 = return_value___builtin_strcmp_55;
                            tmp_if_expr_56 = tmp_statement_expression_54 == 0 ? (_Bool)1 : (_Bool)0;
                          }
                          if(tmp_if_expr_56)
                          {
                            struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_31;
                            return_value_ClientConfiguration_get_realmsTable_31=ClientConfiguration_get_realmsTable(cfg);
                            struct anonymous *return_value_ClientRealm_get_httpProxyOptions_32;
                            return_value_ClientRealm_get_httpProxyOptions_32=ClientRealm_get_httpProxyOptions(return_value_ClientConfiguration_get_realmsTable_31[(signed long int)0]);
                            HttpProxyOptions_set_proxyauth_type(return_value_ClientRealm_get_httpProxyOptions_32, (char)1);
                          }

                          else
                          {
                            unsigned long int cparsefile__1__5__2__24____s1_len;
                            unsigned long int cparsefile__1__5__2__24____s2_len;
                            signed int return_value___builtin_strcmp_51;
                            return_value___builtin_strcmp_51=__builtin_strcmp(helpbuf1, "enableproxy");
                            tmp_statement_expression_50 = return_value___builtin_strcmp_51;
                            if(tmp_statement_expression_50 == 0)
                            {
                              struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_34;
                              return_value_ClientConfiguration_get_realmsTable_34=ClientConfiguration_get_realmsTable(cfg);
                              char return_value_ClientRealm_get_tunnelType_35;
                              return_value_ClientRealm_get_tunnelType_35=ClientRealm_get_tunnelType(return_value_ClientConfiguration_get_realmsTable_34[(signed long int)0]);
                              if((signed int)return_value_ClientRealm_get_tunnelType_35 == 0)
                              {
                                struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_33;
                                return_value_ClientConfiguration_get_realmsTable_33=ClientConfiguration_get_realmsTable(cfg);
                                ClientRealm_set_tunnelType(return_value_ClientConfiguration_get_realmsTable_33[(signed long int)0], (char)1);
                              }

                              else
                                return cfg;
                            }

                            else
                            {
                              unsigned long int cparsefile__1__5__2__26____s1_len;
                              unsigned long int cparsefile__1__5__2__26____s2_len;
                              signed int return_value___builtin_strcmp_49;
                              return_value___builtin_strcmp_49=__builtin_strcmp(helpbuf1, "ipv4");
                              tmp_statement_expression_48 = return_value___builtin_strcmp_49;
                              if(tmp_statement_expression_48 == 0)
                              {
                                struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_39;
                                return_value_ClientConfiguration_get_realmsTable_39=ClientConfiguration_get_realmsTable(cfg);
                                char return_value_ClientRealm_get_realmType_40;
                                return_value_ClientRealm_get_realmType_40=ClientRealm_get_realmType(return_value_ClientConfiguration_get_realmsTable_39[(signed long int)0]);
                                if((48 & (signed int)return_value_ClientRealm_get_realmType_40) == 0)
                                {
                                  struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_36;
                                  return_value_ClientConfiguration_get_realmsTable_36=ClientConfiguration_get_realmsTable(cfg);
                                  char return_value_ClientRealm_get_realmType_37;
                                  return_value_ClientRealm_get_realmType_37=ClientRealm_get_realmType(return_value_ClientConfiguration_get_realmsTable_36[(signed long int)0]);
                                  temp = (signed int)return_value_ClientRealm_get_realmType_37;
                                  temp = temp | 16;
                                  struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_38;
                                  return_value_ClientConfiguration_get_realmsTable_38=ClientConfiguration_get_realmsTable(cfg);
                                  ClientRealm_set_realmType(return_value_ClientConfiguration_get_realmsTable_38[(signed long int)0], (char)temp);
                                }

                                else
                                  return cfg;
                              }

                              else
                              {
                                unsigned long int cparsefile__1__5__2__28____s1_len;
                                unsigned long int cparsefile__1__5__2__28____s2_len;
                                signed int return_value___builtin_strcmp_47;
                                return_value___builtin_strcmp_47=__builtin_strcmp(helpbuf1, "ipv6");
                                tmp_statement_expression_46 = return_value___builtin_strcmp_47;
                                if(tmp_statement_expression_46 == 0)
                                {
                                  struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_44;
                                  return_value_ClientConfiguration_get_realmsTable_44=ClientConfiguration_get_realmsTable(cfg);
                                  char return_value_ClientRealm_get_realmType_45;
                                  return_value_ClientRealm_get_realmType_45=ClientRealm_get_realmType(return_value_ClientConfiguration_get_realmsTable_44[(signed long int)0]);
                                  if((48 & (signed int)return_value_ClientRealm_get_realmType_45) == 0)
                                  {
                                    struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_41;
                                    return_value_ClientConfiguration_get_realmsTable_41=ClientConfiguration_get_realmsTable(cfg);
                                    char return_value_ClientRealm_get_realmType_42;
                                    return_value_ClientRealm_get_realmType_42=ClientRealm_get_realmType(return_value_ClientConfiguration_get_realmsTable_41[(signed long int)0]);
                                    temp = (signed int)return_value_ClientRealm_get_realmType_42;
                                    temp = temp | 32;
                                    struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_43;
                                    return_value_ClientConfiguration_get_realmsTable_43=ClientConfiguration_get_realmsTable(cfg);
                                    ClientRealm_set_realmType(return_value_ClientConfiguration_get_realmsTable_43[(signed long int)0], (char)temp);
                                  }

                                  else
                                    return cfg;
                                }

                                else
                                  return cfg;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        else
          if(state == 2)
          {
            unsigned long int cparsefile__1__5__3__1____s1_len;
            unsigned long int cparsefile__1__5__3__1____s2_len;
            signed int return_value___builtin_strcmp_197;
            return_value___builtin_strcmp_197=__builtin_strcmp(helpbuf1, "k");
            tmp_statement_expression_196 = return_value___builtin_strcmp_197;
            if(tmp_statement_expression_196 == 0)
              tmp_if_expr_200 = (_Bool)1;

            else
            {
              unsigned long int cparsefile__1__5__3__2____s1_len;
              unsigned long int cparsefile__1__5__3__2____s2_len;
              signed int return_value___builtin_strcmp_199;
              return_value___builtin_strcmp_199=__builtin_strcmp(helpbuf1, "keyfile");
              tmp_statement_expression_198 = return_value___builtin_strcmp_199;
              tmp_if_expr_200 = tmp_statement_expression_198 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_200)
              ClientConfiguration_set_keysFile(cfg, helpbuf2);

            else
            {
              unsigned long int cparsefile__1__5__3__4____s1_len;
              unsigned long int cparsefile__1__5__3__4____s2_len;
              signed int return_value___builtin_strcmp_189;
              return_value___builtin_strcmp_189=__builtin_strcmp(helpbuf1, "c");
              tmp_statement_expression_188 = return_value___builtin_strcmp_189;
              if(tmp_statement_expression_188 == 0)
                tmp_if_expr_192 = (_Bool)1;

              else
              {
                unsigned long int cparsefile__1__5__3__5____s1_len;
                unsigned long int cparsefile__1__5__3__5____s2_len;
                signed int return_value___builtin_strcmp_191;
                return_value___builtin_strcmp_191=__builtin_strcmp(helpbuf1, "certificate");
                tmp_statement_expression_190 = return_value___builtin_strcmp_191;
                tmp_if_expr_192 = tmp_statement_expression_190 == 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_192)
                tmp_if_expr_195 = (_Bool)1;

              else
              {
                unsigned long int cparsefile__1__5__3__6____s1_len;
                unsigned long int cparsefile__1__5__3__6____s2_len;
                signed int return_value___builtin_strcmp_194;
                return_value___builtin_strcmp_194=__builtin_strcmp(helpbuf1, "cerfile");
                tmp_statement_expression_193 = return_value___builtin_strcmp_194;
                tmp_if_expr_195 = tmp_statement_expression_193 == 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_195)
                ClientConfiguration_set_certificateFile(cfg, helpbuf2);

              else
              {
                unsigned long int cparsefile__1__5__3__8____s1_len;
                unsigned long int cparsefile__1__5__3__8____s2_len;
                signed int return_value___builtin_strcmp_184;
                return_value___builtin_strcmp_184=__builtin_strcmp(helpbuf1, "s");
                tmp_statement_expression_183 = return_value___builtin_strcmp_184;
                if(tmp_statement_expression_183 == 0)
                  tmp_if_expr_187 = (_Bool)1;

                else
                {
                  unsigned long int cparsefile__1__5__3__9____s1_len;
                  unsigned long int cparsefile__1__5__3__9____s2_len;
                  signed int return_value___builtin_strcmp_186;
                  return_value___builtin_strcmp_186=__builtin_strcmp(helpbuf1, "storefile");
                  tmp_statement_expression_185 = return_value___builtin_strcmp_186;
                  tmp_if_expr_187 = tmp_statement_expression_185 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_187)
                  ClientConfiguration_set_storeFile(cfg, helpbuf2);

                else
                {
                  unsigned long int cparsefile__1__5__3__11____s1_len;
                  unsigned long int cparsefile__1__5__3__11____s2_len;
                  signed int return_value___builtin_strcmp_179;
                  return_value___builtin_strcmp_179=__builtin_strcmp(helpbuf1, "o");
                  tmp_statement_expression_178 = return_value___builtin_strcmp_179;
                  if(tmp_statement_expression_178 == 0)
                    tmp_if_expr_182 = (_Bool)1;

                  else
                  {
                    unsigned long int cparsefile__1__5__3__12____s1_len;
                    unsigned long int cparsefile__1__5__3__12____s2_len;
                    signed int return_value___builtin_strcmp_181;
                    return_value___builtin_strcmp_181=__builtin_strcmp(helpbuf1, "log");
                    tmp_statement_expression_180 = return_value___builtin_strcmp_181;
                    tmp_if_expr_182 = tmp_statement_expression_180 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_182)
                  {
                    unsigned long int return_value_strlen_85;
                    return_value_strlen_85=strlen(helpbuf2);
                    void *return_value_calloc_86;
                    return_value_calloc_86=calloc(return_value_strlen_85 + (unsigned long int)1, sizeof(char) /*1ul*/ );
                    tmpbuf = (char *)return_value_calloc_86;
                    strcpy(tmpbuf, helpbuf2);
                    addlogtarget(tmpbuf);
                  }

                  else
                  {
                    unsigned long int cparsefile__1__5__3__14____s1_len;
                    unsigned long int cparsefile__1__5__3__14____s2_len;
                    signed int return_value___builtin_strcmp_174;
                    return_value___builtin_strcmp_174=__builtin_strcmp(helpbuf1, "D");
                    tmp_statement_expression_173 = return_value___builtin_strcmp_174;
                    if(tmp_statement_expression_173 == 0)
                      tmp_if_expr_177 = (_Bool)1;

                    else
                    {
                      unsigned long int cparsefile__1__5__3__15____s1_len;
                      unsigned long int cparsefile__1__5__3__15____s2_len;
                      signed int return_value___builtin_strcmp_176;
                      return_value___builtin_strcmp_176=__builtin_strcmp(helpbuf1, "dateformat");
                      tmp_statement_expression_175 = return_value___builtin_strcmp_176;
                      tmp_if_expr_177 = tmp_statement_expression_175 == 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr_177)
                      ClientConfiguration_set_dateFormat(cfg, helpbuf2);

                    else
                    {
                      unsigned long int cparsefile__1__5__3__17____s1_len;
                      unsigned long int cparsefile__1__5__3__17____s2_len;
                      signed int return_value___builtin_strcmp_169;
                      return_value___builtin_strcmp_169=__builtin_strcmp(helpbuf1, "n");
                      tmp_statement_expression_168 = return_value___builtin_strcmp_169;
                      if(tmp_statement_expression_168 == 0)
                        tmp_if_expr_172 = (_Bool)1;

                      else
                      {
                        unsigned long int cparsefile__1__5__3__18____s1_len;
                        unsigned long int cparsefile__1__5__3__18____s2_len;
                        signed int return_value___builtin_strcmp_171;
                        return_value___builtin_strcmp_171=__builtin_strcmp(helpbuf1, "servername");
                        tmp_statement_expression_170 = return_value___builtin_strcmp_171;
                        tmp_if_expr_172 = tmp_statement_expression_170 == 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr_172)
                      {
                        struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_87;
                        return_value_ClientConfiguration_get_realmsTable_87=ClientConfiguration_get_realmsTable(cfg);
                        ClientRealm_set_serverName(return_value_ClientConfiguration_get_realmsTable_87[(signed long int)0], helpbuf2);
                      }

                      else
                      {
                        unsigned long int cparsefile__1__5__3__20____s1_len;
                        unsigned long int cparsefile__1__5__3__20____s2_len;
                        signed int return_value___builtin_strcmp_164;
                        return_value___builtin_strcmp_164=__builtin_strcmp(helpbuf1, "m");
                        tmp_statement_expression_163 = return_value___builtin_strcmp_164;
                        if(tmp_statement_expression_163 == 0)
                          tmp_if_expr_167 = (_Bool)1;

                        else
                        {
                          unsigned long int cparsefile__1__5__3__21____s1_len;
                          unsigned long int cparsefile__1__5__3__21____s2_len;
                          signed int return_value___builtin_strcmp_166;
                          return_value___builtin_strcmp_166=__builtin_strcmp(helpbuf1, "manageport");
                          tmp_statement_expression_165 = return_value___builtin_strcmp_166;
                          tmp_if_expr_167 = tmp_statement_expression_165 == 0 ? (_Bool)1 : (_Bool)0;
                        }
                        if(tmp_if_expr_167)
                        {
                          struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_88;
                          return_value_ClientConfiguration_get_realmsTable_88=ClientConfiguration_get_realmsTable(cfg);
                          ClientRealm_set_managePort(return_value_ClientConfiguration_get_realmsTable_88[(signed long int)0], helpbuf2);
                        }

                        else
                        {
                          unsigned long int cparsefile__1__5__3__23____s1_len;
                          unsigned long int cparsefile__1__5__3__23____s2_len;
                          signed int return_value___builtin_strcmp_159;
                          return_value___builtin_strcmp_159=__builtin_strcmp(helpbuf1, "d");
                          tmp_statement_expression_158 = return_value___builtin_strcmp_159;
                          if(tmp_statement_expression_158 == 0)
                            tmp_if_expr_162 = (_Bool)1;

                          else
                          {
                            unsigned long int cparsefile__1__5__3__24____s1_len;
                            unsigned long int cparsefile__1__5__3__24____s2_len;
                            signed int return_value___builtin_strcmp_161;
                            return_value___builtin_strcmp_161=__builtin_strcmp(helpbuf1, "hostname");
                            tmp_statement_expression_160 = return_value___builtin_strcmp_161;
                            tmp_if_expr_162 = tmp_statement_expression_160 == 0 ? (_Bool)1 : (_Bool)0;
                          }
                          if(tmp_if_expr_162)
                          {
                            struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_89;
                            return_value_ClientConfiguration_get_realmsTable_89=ClientConfiguration_get_realmsTable(cfg);
                            ClientRealm_set_hostName(return_value_ClientConfiguration_get_realmsTable_89[(signed long int)0], helpbuf2);
                          }

                          else
                          {
                            unsigned long int cparsefile__1__5__3__26____s1_len;
                            unsigned long int cparsefile__1__5__3__26____s2_len;
                            signed int return_value___builtin_strcmp_154;
                            return_value___builtin_strcmp_154=__builtin_strcmp(helpbuf1, "p");
                            tmp_statement_expression_153 = return_value___builtin_strcmp_154;
                            if(tmp_statement_expression_153 == 0)
                              tmp_if_expr_157 = (_Bool)1;

                            else
                            {
                              unsigned long int cparsefile__1__5__3__27____s1_len;
                              unsigned long int cparsefile__1__5__3__27____s2_len;
                              signed int return_value___builtin_strcmp_156;
                              return_value___builtin_strcmp_156=__builtin_strcmp(helpbuf1, "portnum");
                              tmp_statement_expression_155 = return_value___builtin_strcmp_156;
                              tmp_if_expr_157 = tmp_statement_expression_155 == 0 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr_157)
                            {
                              struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_90;
                              return_value_ClientConfiguration_get_realmsTable_90=ClientConfiguration_get_realmsTable(cfg);
                              struct portlist *return_value_ClientRealm_get_destinationPorts_91;
                              return_value_ClientRealm_get_destinationPorts_91=ClientRealm_get_destinationPorts(return_value_ClientConfiguration_get_realmsTable_90[(signed long int)0]);
                              struct plnode *return_value_PortListNode_new_92;
                              return_value_PortListNode_new_92=PortListNode_new(helpbuf2);
                              PortList_insert_back(return_value_ClientRealm_get_destinationPorts_91, return_value_PortListNode_new_92);
                            }

                            else
                            {
                              unsigned long int cparsefile__1__5__3__29____s1_len;
                              unsigned long int cparsefile__1__5__3__29____s2_len;
                              signed int return_value___builtin_strcmp_152;
                              return_value___builtin_strcmp_152=__builtin_strcmp(helpbuf1, "localname");
                              tmp_statement_expression_151 = return_value___builtin_strcmp_152;
                              if(tmp_statement_expression_151 == 0)
                              {
                                struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_93;
                                return_value_ClientConfiguration_get_realmsTable_93=ClientConfiguration_get_realmsTable(cfg);
                                ClientRealm_set_localName(return_value_ClientConfiguration_get_realmsTable_93[(signed long int)0], helpbuf2);
                              }

                              else
                              {
                                unsigned long int cparsefile__1__5__3__31____s1_len;
                                unsigned long int cparsefile__1__5__3__31____s2_len;
                                signed int return_value___builtin_strcmp_150;
                                return_value___builtin_strcmp_150=__builtin_strcmp(helpbuf1, "localport");
                                tmp_statement_expression_149 = return_value___builtin_strcmp_150;
                                if(tmp_statement_expression_149 == 0)
                                {
                                  struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_94;
                                  return_value_ClientConfiguration_get_realmsTable_94=ClientConfiguration_get_realmsTable(cfg);
                                  ClientRealm_set_localPort(return_value_ClientConfiguration_get_realmsTable_94[(signed long int)0], helpbuf2);
                                }

                                else
                                {
                                  unsigned long int cparsefile__1__5__3__33____s1_len;
                                  unsigned long int cparsefile__1__5__3__33____s2_len;
                                  signed int return_value___builtin_strcmp_148;
                                  return_value___builtin_strcmp_148=__builtin_strcmp(helpbuf1, "localdesname");
                                  tmp_statement_expression_147 = return_value___builtin_strcmp_148;
                                  if(tmp_statement_expression_147 == 0)
                                  {
                                    struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_95;
                                    return_value_ClientConfiguration_get_realmsTable_95=ClientConfiguration_get_realmsTable(cfg);
                                    ClientRealm_set_localDestinationName(return_value_ClientConfiguration_get_realmsTable_95[(signed long int)0], helpbuf2);
                                  }

                                  else
                                  {
                                    unsigned long int cparsefile__1__5__3__35____s1_len;
                                    unsigned long int cparsefile__1__5__3__35____s2_len;
                                    signed int return_value___builtin_strcmp_143;
                                    return_value___builtin_strcmp_143=__builtin_strcmp(helpbuf1, "i");
                                    tmp_statement_expression_142 = return_value___builtin_strcmp_143;
                                    if(tmp_statement_expression_142 == 0)
                                      tmp_if_expr_146 = (_Bool)1;

                                    else
                                    {
                                      unsigned long int cparsefile__1__5__3__36____s1_len;
                                      unsigned long int cparsefile__1__5__3__36____s2_len;
                                      signed int return_value___builtin_strcmp_145;
                                      return_value___builtin_strcmp_145=__builtin_strcmp(helpbuf1, "id");
                                      tmp_statement_expression_144 = return_value___builtin_strcmp_145;
                                      tmp_if_expr_146 = tmp_statement_expression_144 == 0 ? (_Bool)1 : (_Bool)0;
                                    }
                                    if(tmp_if_expr_146)
                                    {
                                      struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_96;
                                      return_value_ClientConfiguration_get_realmsTable_96=ClientConfiguration_get_realmsTable(cfg);
                                      ClientRealm_set_realmId(return_value_ClientConfiguration_get_realmsTable_96[(signed long int)0], helpbuf2);
                                    }

                                    else
                                    {
                                      unsigned long int cparsefile__1__5__3__38____s1_len;
                                      unsigned long int cparsefile__1__5__3__38____s2_len;
                                      signed int return_value___builtin_strcmp_141;
                                      return_value___builtin_strcmp_141=__builtin_strcmp(helpbuf1, "pass");
                                      tmp_statement_expression_140 = return_value___builtin_strcmp_141;
                                      if(tmp_statement_expression_140 == 0)
                                      {
                                        unsigned long int return_value_strlen_97;
                                        return_value_strlen_97=strlen(helpbuf2);
                                        n = (signed int)return_value_strlen_97;
                                        memset((void *)pass, 0, (unsigned long int)4);
                                        i = 0;
                                        for( ; !(i >= n); i = i + 1)
                                          pass[(signed long int)(i % 4)] = pass[(signed long int)(i % 4)] + (unsigned char)helpbuf2[(signed long int)i];
                                        struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_98;
                                        return_value_ClientConfiguration_get_realmsTable_98=ClientConfiguration_get_realmsTable(cfg);
                                        ClientRealm_set_password(return_value_ClientConfiguration_get_realmsTable_98[(signed long int)0], pass);
                                      }

                                      else
                                      {
                                        unsigned long int cparsefile__1__5__3__40____s1_len;
                                        unsigned long int cparsefile__1__5__3__40____s2_len;
                                        signed int return_value___builtin_strcmp_136;
                                        return_value___builtin_strcmp_136=__builtin_strcmp(helpbuf1, "K");
                                        tmp_statement_expression_135 = return_value___builtin_strcmp_136;
                                        if(tmp_statement_expression_135 == 0)
                                          tmp_if_expr_139 = (_Bool)1;

                                        else
                                        {
                                          unsigned long int cparsefile__1__5__3__41____s1_len;
                                          unsigned long int cparsefile__1__5__3__41____s2_len;
                                          signed int return_value___builtin_strcmp_138;
                                          return_value___builtin_strcmp_138=__builtin_strcmp(helpbuf1, "keep-alive");
                                          tmp_statement_expression_137 = return_value___builtin_strcmp_138;
                                          tmp_if_expr_139 = tmp_statement_expression_137 == 0 ? (_Bool)1 : (_Bool)0;
                                        }
                                        if(tmp_if_expr_139)
                                        {
                                          struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_99;
                                          return_value_ClientConfiguration_get_realmsTable_99=ClientConfiguration_get_realmsTable(cfg);
                                          ClientRealm_set_sKeepAliveTimeout(return_value_ClientConfiguration_get_realmsTable_99[(signed long int)0], helpbuf2);
                                        }

                                        else
                                        {
                                          unsigned long int cparsefile__1__5__3__43____s1_len;
                                          unsigned long int cparsefile__1__5__3__43____s2_len;
                                          signed int return_value___builtin_strcmp_131;
                                          return_value___builtin_strcmp_131=__builtin_strcmp(helpbuf1, "A");
                                          tmp_statement_expression_130 = return_value___builtin_strcmp_131;
                                          if(tmp_statement_expression_130 == 0)
                                            tmp_if_expr_134 = (_Bool)1;

                                          else
                                          {
                                            unsigned long int cparsefile__1__5__3__44____s1_len;
                                            unsigned long int cparsefile__1__5__3__44____s2_len;
                                            signed int return_value___builtin_strcmp_133;
                                            return_value___builtin_strcmp_133=__builtin_strcmp(helpbuf1, "ar-tries");
                                            tmp_statement_expression_132 = return_value___builtin_strcmp_133;
                                            tmp_if_expr_134 = tmp_statement_expression_132 == 0 ? (_Bool)1 : (_Bool)0;
                                          }
                                          if(tmp_if_expr_134)
                                          {
                                            struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_100;
                                            return_value_ClientConfiguration_get_realmsTable_100=ClientConfiguration_get_realmsTable(cfg);
                                            struct anonymous_3 *return_value_ClientRealm_get_arOptions_101;
                                            return_value_ClientRealm_get_arOptions_101=ClientRealm_get_arOptions(return_value_ClientConfiguration_get_realmsTable_100[(signed long int)0]);
                                            ArOptions_set_s_arTries(return_value_ClientRealm_get_arOptions_101, helpbuf2);
                                          }

                                          else
                                          {
                                            unsigned long int cparsefile__1__5__3__46____s1_len;
                                            unsigned long int cparsefile__1__5__3__46____s2_len;
                                            signed int return_value___builtin_strcmp_126;
                                            return_value___builtin_strcmp_126=__builtin_strcmp(helpbuf1, "T");
                                            tmp_statement_expression_125 = return_value___builtin_strcmp_126;
                                            if(tmp_statement_expression_125 == 0)
                                              tmp_if_expr_129 = (_Bool)1;

                                            else
                                            {
                                              unsigned long int cparsefile__1__5__3__47____s1_len;
                                              unsigned long int cparsefile__1__5__3__47____s2_len;
                                              signed int return_value___builtin_strcmp_128;
                                              return_value___builtin_strcmp_128=__builtin_strcmp(helpbuf1, "ar-delay");
                                              tmp_statement_expression_127 = return_value___builtin_strcmp_128;
                                              tmp_if_expr_129 = tmp_statement_expression_127 == 0 ? (_Bool)1 : (_Bool)0;
                                            }
                                            if(tmp_if_expr_129)
                                            {
                                              struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_102;
                                              return_value_ClientConfiguration_get_realmsTable_102=ClientConfiguration_get_realmsTable(cfg);
                                              struct anonymous_3 *return_value_ClientRealm_get_arOptions_103;
                                              return_value_ClientRealm_get_arOptions_103=ClientRealm_get_arOptions(return_value_ClientConfiguration_get_realmsTable_102[(signed long int)0]);
                                              ArOptions_set_s_arDelay(return_value_ClientRealm_get_arOptions_103, helpbuf2);
                                            }

                                            else
                                            {
                                              unsigned long int cparsefile__1__5__3__49____s1_len;
                                              unsigned long int cparsefile__1__5__3__49____s2_len;
                                              signed int return_value___builtin_strcmp_121;
                                              return_value___builtin_strcmp_121=__builtin_strcmp(helpbuf1, "P");
                                              tmp_statement_expression_120 = return_value___builtin_strcmp_121;
                                              if(tmp_statement_expression_120 == 0)
                                                tmp_if_expr_124 = (_Bool)1;

                                              else
                                              {
                                                unsigned long int cparsefile__1__5__3__50____s1_len;
                                                unsigned long int cparsefile__1__5__3__50____s2_len;
                                                signed int return_value___builtin_strcmp_123;
                                                return_value___builtin_strcmp_123=__builtin_strcmp(helpbuf1, "proxyname");
                                                tmp_statement_expression_122 = return_value___builtin_strcmp_123;
                                                tmp_if_expr_124 = tmp_statement_expression_122 == 0 ? (_Bool)1 : (_Bool)0;
                                              }
                                              if(tmp_if_expr_124)
                                              {
                                                struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_104;
                                                return_value_ClientConfiguration_get_realmsTable_104=ClientConfiguration_get_realmsTable(cfg);
                                                struct anonymous *return_value_ClientRealm_get_httpProxyOptions_105;
                                                return_value_ClientRealm_get_httpProxyOptions_105=ClientRealm_get_httpProxyOptions(return_value_ClientConfiguration_get_realmsTable_104[(signed long int)0]);
                                                HttpProxyOptions_set_proxyname(return_value_ClientRealm_get_httpProxyOptions_105, helpbuf2);
                                              }

                                              else
                                              {
                                                unsigned long int cparsefile__1__5__3__52____s1_len;
                                                unsigned long int cparsefile__1__5__3__52____s2_len;
                                                signed int return_value___builtin_strcmp_116;
                                                return_value___builtin_strcmp_116=__builtin_strcmp(helpbuf1, "X");
                                                tmp_statement_expression_115 = return_value___builtin_strcmp_116;
                                                if(tmp_statement_expression_115 == 0)
                                                  tmp_if_expr_119 = (_Bool)1;

                                                else
                                                {
                                                  unsigned long int cparsefile__1__5__3__53____s1_len;
                                                  unsigned long int cparsefile__1__5__3__53____s2_len;
                                                  signed int return_value___builtin_strcmp_118;
                                                  return_value___builtin_strcmp_118=__builtin_strcmp(helpbuf1, "proxyport");
                                                  tmp_statement_expression_117 = return_value___builtin_strcmp_118;
                                                  tmp_if_expr_119 = tmp_statement_expression_117 == 0 ? (_Bool)1 : (_Bool)0;
                                                }
                                                if(tmp_if_expr_119)
                                                {
                                                  struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_106;
                                                  return_value_ClientConfiguration_get_realmsTable_106=ClientConfiguration_get_realmsTable(cfg);
                                                  struct anonymous *return_value_ClientRealm_get_httpProxyOptions_107;
                                                  return_value_ClientRealm_get_httpProxyOptions_107=ClientRealm_get_httpProxyOptions(return_value_ClientConfiguration_get_realmsTable_106[(signed long int)0]);
                                                  HttpProxyOptions_set_proxyport(return_value_ClientRealm_get_httpProxyOptions_107, helpbuf2);
                                                }

                                                else
                                                {
                                                  unsigned long int cparsefile__1__5__3__55____s1_len;
                                                  unsigned long int cparsefile__1__5__3__55____s2_len;
                                                  signed int return_value___builtin_strcmp_111;
                                                  return_value___builtin_strcmp_111=__builtin_strcmp(helpbuf1, "C");
                                                  tmp_statement_expression_110 = return_value___builtin_strcmp_111;
                                                  if(tmp_statement_expression_110 == 0)
                                                    tmp_if_expr_114 = (_Bool)1;

                                                  else
                                                  {
                                                    unsigned long int cparsefile__1__5__3__56____s1_len;
                                                    unsigned long int cparsefile__1__5__3__56____s2_len;
                                                    signed int return_value___builtin_strcmp_113;
                                                    return_value___builtin_strcmp_113=__builtin_strcmp(helpbuf1, "pa-cred");
                                                    tmp_statement_expression_112 = return_value___builtin_strcmp_113;
                                                    tmp_if_expr_114 = tmp_statement_expression_112 == 0 ? (_Bool)1 : (_Bool)0;
                                                  }
                                                  if(tmp_if_expr_114)
                                                  {
                                                    struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_108;
                                                    return_value_ClientConfiguration_get_realmsTable_108=ClientConfiguration_get_realmsTable(cfg);
                                                    struct anonymous *return_value_ClientRealm_get_httpProxyOptions_109;
                                                    return_value_ClientRealm_get_httpProxyOptions_109=ClientRealm_get_httpProxyOptions(return_value_ClientConfiguration_get_realmsTable_108[(signed long int)0]);
                                                    HttpProxyOptions_set_proxyauth_cred(return_value_ClientRealm_get_httpProxyOptions_109, helpbuf2);
                                                  }

                                                  else
                                                    return cfg;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

        memset((void *)buff, 0, (unsigned long int)256);
      }
    }
    while((_Bool)1);
    fclose(file);
    *status = 0;
    return cfg;
  }
}

// create_apf_dir
// file first_run.h line 24
signed int create_apf_dir(char type)
{
  signed int length;
  struct stat buf;
  struct passwd *user;
  unsigned int return_value_getuid_1;
  return_value_getuid_1=getuid();
  user=getpwuid(return_value_getuid_1);
  if((signed int)type == 0)
  {
    if(user == ((struct passwd *)NULL))
      return 1;

    if(user->pw_dir == ((char *)NULL))
      return 2;

    if(!(home_dir == ((char *)NULL)))
    {
      free((void *)home_dir);
      home_dir = (char *)(void *)0;
    }

    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(user->pw_dir);
    length = (signed int)return_value_strlen_2;
    void *return_value_calloc_3;
    return_value_calloc_3=calloc((unsigned long int)1, (unsigned long int)(length + 6));
    home_dir = (char *)return_value_calloc_3;
    if(home_dir == ((char *)NULL))
      return 3;

    strcpy(home_dir, user->pw_dir);
    if((signed int)home_dir[(signed long int)length] == 47)
      strcpy(&home_dir[(signed long int)length], ".apf");

    else
      strcpy(&home_dir[(signed long int)length], "/.apf");
    signed int return_value_stat_5;
    return_value_stat_5=stat(home_dir, &buf);
    if(!(return_value_stat_5 == 0))
    {
      signed int return_value_mkdir_4;
      return_value_mkdir_4=mkdir(home_dir, (unsigned int)0700);
      if(!(return_value_mkdir_4 == 0))
        return 4;

    }

  }

  else
  {
    if(!(home_dir == ((char *)NULL)))
    {
      free((void *)home_dir);
      home_dir = (char *)(void *)0;
    }

    void *return_value_calloc_6;
    return_value_calloc_6=calloc((unsigned long int)1, (unsigned long int)4);
    home_dir = (char *)return_value_calloc_6;
    if(home_dir == ((char *)NULL))
      return 3;

    strcpy(home_dir, "apf");
    signed int return_value_stat_8;
    return_value_stat_8=stat(home_dir, &buf);
    if(!(return_value_stat_8 == 0))
    {
      signed int return_value_mkdir_7;
      return_value_mkdir_7=mkdir(home_dir, (unsigned int)0700);
      if(!(return_value_mkdir_7 == 0))
        return 4;

    }

  }
  return 0;
}

// create_publickey_store
// file first_run.h line 25
signed int create_publickey_store(char **storefile)
{
  signed int store_length;
  signed int home_length;
  struct stat buf;
  struct _IO_FILE *store_file;
  signed int return_value_stat_1;
  return_value_stat_1=stat(*storefile, &buf);
  if(return_value_stat_1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(*storefile);
    store_length = (signed int)return_value_strlen_2;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(home_dir);
    home_length = (signed int)return_value_strlen_3;
    if(!(home_dir_store == ((char *)NULL)))
    {
      free((void *)home_dir_store);
      home_dir_store = (char *)(void *)0;
    }

    void *return_value_calloc_4;
    return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)(home_length + store_length + 2));
    home_dir_store = (char *)return_value_calloc_4;
    if(home_dir_store == ((char *)NULL))
      return 1;

    else
    {
      strcpy(home_dir_store, home_dir);
      home_dir_store[(signed long int)home_length] = (char)47;
      strcpy(&home_dir_store[(signed long int)(home_length + 1)], *storefile);
      *storefile = home_dir_store;
      store_file=fopen(home_dir_store, "a");
      if(store_file == ((struct _IO_FILE *)NULL))
        return 1;

      else
      {
        fclose(store_file);
        signed int return_value_stat_5;
        return_value_stat_5=stat(home_dir_store, &buf);
        if(return_value_stat_5 == 0)
          return 0;

        else
          return 2;
      }
    }
  }
}

// datum
// file logging.c line 85
char * datum(void)
{
  signed long int sec;
  struct tm *tm;
  time(&sec);
  tm=localtime(&sec);
  static char timedat[31l];
  memset((void *)timedat, 0, (unsigned long int)31);
  strftime(timedat, (unsigned long int)30, format, tm);
  return timedat;
}

// delete_user
// file http_proxy_functions.c line 77
void delete_user(struct anonymous_16 *cnts, signed int i, struct anonymous_11 *allset)
{
  aflog((char)16, (char)2, "http proxy: delete_user(%d)", i);
  clear_fd(&(cnts + (signed long int)i)->sockfd, allset);
  if((1 & (signed int)(cnts + (signed long int)i)->state) == 0)
    clear_sslFd((cnts + (signed long int)i)->postFd, allset);

  if((signed int)(cnts + (signed long int)i)->type == 0)
  {
    if((2 & (signed int)(cnts + (signed long int)i)->state) == 0)
      clear_sslFd((cnts + (signed long int)i)->getFd, allset);

  }

  (cnts + (signed long int)i)->state = (char)0;
  (cnts + (signed long int)i)->length = 0;
  (cnts + (signed long int)i)->ptr = (cnts + (signed long int)i)->length;
  (cnts + (signed long int)i)->sent_ptr = (cnts + (signed long int)i)->ptr;
  (cnts + (signed long int)i)->type = (char)0;
}

// end_critical_section
// file thread_management.h line 29
void end_critical_section(void)
{
  pthread_mutex_unlock(&mainmutex);
}

// generate_certificate
// file first_run.c line 250
signed int generate_certificate(char **cerfile, char *keyfile)
{
  signed int cer_length;
  signed int home_length;
  signed int i;
  struct stat buf;
  struct x509_st *cert;
  struct X509_req_st *req;
  struct X509_name_st *subj;
  struct rsa_st *rsa_key;
  struct evp_pkey_st *pkey;
  const struct env_md_st *digest;
  struct _IO_FILE *fp;
  signed int return_value_stat_1;
  return_value_stat_1=stat(*cerfile, &buf);
  if(return_value_stat_1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(*cerfile);
    cer_length = (signed int)return_value_strlen_2;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(home_dir);
    home_length = (signed int)return_value_strlen_3;
    if(!(home_dir_cer == ((char *)NULL)))
    {
      free((void *)home_dir_cer);
      home_dir_cer = (char *)(void *)0;
    }

    void *return_value_calloc_4;
    return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)(home_length + cer_length + 2));
    home_dir_cer = (char *)return_value_calloc_4;
    if(home_dir_cer == ((char *)NULL))
      return 1;

    else
    {
      strcpy(home_dir_cer, home_dir);
      home_dir_cer[(signed long int)home_length] = (char)47;
      strcpy(&home_dir_cer[(signed long int)(home_length + 1)], *cerfile);
      *cerfile = home_dir_cer;
      signed int return_value_stat_5;
      return_value_stat_5=stat(home_dir_cer, &buf);
      if(return_value_stat_5 == 0)
        return 0;

      else
      {
        printf("generating self signed certificate\n");
        fp=fopen(keyfile, "r");
        if(fp == ((struct _IO_FILE *)NULL))
          return 2;

        else
        {
          rsa_key=PEM_read_RSAPrivateKey(fp, (struct rsa_st **)(void *)0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
          fclose(fp);
          if(rsa_key == ((struct rsa_st *)NULL))
            return 3;

          else
          {
            pkey=EVP_PKEY_new();
            if(pkey == ((struct evp_pkey_st *)NULL))
              return 4;

            else
            {
              signed int return_value_EVP_PKEY_set1_RSA_6;
              return_value_EVP_PKEY_set1_RSA_6=EVP_PKEY_set1_RSA(pkey, rsa_key);
              if(return_value_EVP_PKEY_set1_RSA_6 == 0)
                return 5;

              else
              {
                req=X509_REQ_new();
                if(req == ((struct X509_req_st *)NULL))
                  return 6;

                else
                {
                  X509_REQ_set_pubkey(req, pkey);
                  subj=X509_NAME_new();
                  if(subj == ((struct X509_name_st *)NULL))
                    return 7;

                  else
                  {
                    i = 0;
                    for( ; !(i >= 6); i = i + 1)
                    {
                      signed int nid;
                      struct X509_name_entry_st *ent;
                      nid=OBJ_txt2nid(entries[(signed long int)i].key);
                      if(nid == 0)
                        return 8;

                      ent=X509_NAME_ENTRY_create_by_NID((struct X509_name_entry_st **)(void *)0, nid, 0x1000 | 1, entries[(signed long int)i].value, -1);
                      if(ent == ((struct X509_name_entry_st *)NULL))
                        return 9;

                      signed int return_value_X509_NAME_add_entry_7;
                      return_value_X509_NAME_add_entry_7=X509_NAME_add_entry(subj, ent, -1, 0);
                      if(return_value_X509_NAME_add_entry_7 == 0)
                        return 10;

                    }
                    signed int return_value_X509_REQ_set_subject_name_8;
                    return_value_X509_REQ_set_subject_name_8=X509_REQ_set_subject_name(req, subj);
                    if(return_value_X509_REQ_set_subject_name_8 == 0)
                      return 11;

                    else
                    {
                      digest=EVP_sha1();
                      signed int return_value_X509_REQ_sign_9;
                      return_value_X509_REQ_sign_9=X509_REQ_sign(req, pkey, digest);
                      if(return_value_X509_REQ_sign_9 == 0)
                        return 12;

                      else
                      {
                        cert=X509_REQ_to_X509(req, 1000, pkey);
                        signed int return_value_X509_set_version_10;
                        return_value_X509_set_version_10=X509_set_version(cert, 2L);
                        if(return_value_X509_set_version_10 == 0)
                          return 13;

                        else
                        {
                          struct asn1_string_st *return_value_X509_get_serialNumber_11;
                          return_value_X509_get_serialNumber_11=X509_get_serialNumber(cert);
                          ASN1_INTEGER_set(return_value_X509_get_serialNumber_11, (signed long int)1);
                          if(cert == ((struct x509_st *)NULL))
                            return 14;

                          else
                          {
                            signed int return_value_X509_sign_12;
                            return_value_X509_sign_12=X509_sign(cert, pkey, digest);
                            if(return_value_X509_sign_12 == 0)
                              return 15;

                            else
                            {
                              fp=fopen(home_dir_cer, "w");
                              if(fp == ((struct _IO_FILE *)NULL))
                                return 16;

                              else
                              {
                                PEM_write_X509(fp, cert);
                                fclose(fp);
                                EVP_PKEY_free(pkey);
                                X509_REQ_free(req);
                                X509_free(cert);
                                return 0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// generate_rsa_key
// file first_run.h line 26
signed int generate_rsa_key(char **keyfile)
{
  signed int key_length;
  signed int home_length;
  struct rsa_st *rsa_key;
  struct _IO_FILE *rsa_file;
  struct stat buf;
  signed int return_value_stat_1;
  return_value_stat_1=stat(*keyfile, &buf);
  if(return_value_stat_1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(*keyfile);
    key_length = (signed int)return_value_strlen_2;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(home_dir);
    home_length = (signed int)return_value_strlen_3;
    if(!(home_dir_key == ((char *)NULL)))
    {
      free((void *)home_dir_key);
      home_dir_key = (char *)(void *)0;
    }

    void *return_value_calloc_4;
    return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)(home_length + key_length + 2));
    home_dir_key = (char *)return_value_calloc_4;
    if(home_dir_key == ((char *)NULL))
      return 1;

    else
    {
      strcpy(home_dir_key, home_dir);
      home_dir_key[(signed long int)home_length] = (char)47;
      strcpy(&home_dir_key[(signed long int)(home_length + 1)], *keyfile);
      *keyfile = home_dir_key;
      signed int return_value_stat_5;
      return_value_stat_5=stat(home_dir_key, &buf);
      if(return_value_stat_5 == 0)
        return 0;

      else
      {
        printf("generating rsa key: 2048 bits\n");
        rsa_key=RSA_generate_key(2048, (unsigned long int)65537, callback, (void *)0);
        signed int return_value_RSA_check_key_6;
        return_value_RSA_check_key_6=RSA_check_key(rsa_key);
        if(return_value_RSA_check_key_6 == 1)
          printf("   OK!\n");

        else
        {
          printf("   FAILED!\n");
          return 1;
        }
        rsa_file=fopen(home_dir_key, "a");
        PEM_write_RSAPrivateKey(rsa_file, rsa_key, (const struct evp_cipher_st *)(void *)0, (unsigned char *)(void *)0, 0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
        fclose(rsa_file);
        return 0;
      }
    }
  }
}

// get_cer_filename
// file first_run.c line 400
char * get_cer_filename()
{
  return home_dir_cer;
}

// get_key_filename
// file first_run.c line 388
char * get_key_filename()
{
  return home_dir_key;
}

// get_ssl_error
// file make_ssl_handshake.h line 29
signed int get_ssl_error(struct anonymous_0 *sf, char *info, signed int result)
{
  signed int merror;
  char err_buff[200l];
  struct ssl_st *return_value_SslFd_get_ssl_1;
  return_value_SslFd_get_ssl_1=SslFd_get_ssl(sf);
  merror=SSL_get_error(return_value_SslFd_get_ssl_1, result);
  unsigned long int return_value_ERR_get_error_2;
  char *return_value_ERR_error_string_3;
  switch(merror)
  {
    case 0:
    {
      aflog((char)16, (char)32, "%s(%d): none", info, result);
      break;
    }
    case 6:
    {
      aflog((char)16, (char)32, "%s(%d): zero", info, result);
      break;
    }
    case 2:
    {
      aflog((char)16, (char)32, "%s(%d): w_read", info, result);
      break;
    }
    case 3:
    {
      aflog((char)16, (char)32, "%s(%d): w_write", info, result);
      break;
    }
    case 7:
    {
      aflog((char)16, (char)32, "%s(%d): w_connect", info, result);
      break;
    }
    case 4:
    {
      aflog((char)16, (char)32, "%s(%d): w_x509_lookup", info, result);
      break;
    }
    case 5:
    {
      aflog((char)16, (char)32, "%s(%d): syscall", info, result);
      break;
    }
    case 1:
    {
      SSL_load_error_strings();
      return_value_ERR_get_error_2=ERR_get_error();
      return_value_ERR_error_string_3=ERR_error_string(return_value_ERR_get_error_2, err_buff);
      aflog((char)16, (char)32, "%s(%d): ssl:%s", info, result, return_value_ERR_error_string_3);
      break;
    }
    default:
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      aflog((char)16, (char)32, "%s(%d): unrecognized error (%d)", info, result, *return_value___errno_location_4);
    }
  }
  if(merror == 2 || merror == 3)
    return 1;

  else
    return 2;
}

// get_store_filename
// file first_run.c line 376
char * get_store_filename()
{
  return home_dir_store;
}

// getcg
// file stats.h line 35
signed long int getcg(void)
{
  return compressgained;
}

// getdateformat
// file logging.c line 55
char * getdateformat()
{
  return format;
}

// getloglisthead
// file logging.c line 104
struct llnode * getloglisthead()
{
  return head;
}

// http_proxy_client
// file http_proxy_client.c line 63
void * http_proxy_client(void *vptr)
{
  char tab[9000l];
  struct anonymous_16 conn;
  struct anonymous_15 hdr;
  signed int j;
  signed int n;
  signed int maxfdp1;
  struct anonymous_11 rset;
  struct anonymous_11 allset;
  struct timeval tv;
  signed int timeout = 5;
  signed int tmp;
  char *host;
  char *serv;
  char *proxyname;
  char *proxyport;
  char *credentials;
  char *name = "";
  char b64cred[100l];
  char type;
  char authtype;
  char https;
  struct ssl_ctx_st *ctx;
  struct anonymous_19 *proxy_argptr;
  start_critical_section();
  proxy_argptr = (struct anonymous_19 *)vptr;
  host = proxy_argptr->host;
  serv = proxy_argptr->serv;
  proxyname=HttpProxyOptions_get_proxyname(proxy_argptr->hpo);
  proxyport=HttpProxyOptions_get_proxyport(proxy_argptr->hpo);
  credentials=HttpProxyOptions_get_proxyauth_cred(proxy_argptr->hpo);
  type = proxy_argptr->type;
  authtype=HttpProxyOptions_get_proxyauth_type(proxy_argptr->hpo);
  conn.sockfd = proxy_argptr->sockfd;
  https=HttpProxyOptions_is_https(proxy_argptr->hpo);
  ctx = proxy_argptr->ctx;
  broadcast_condition();
  end_critical_section();
  conn.postFd=SslFd_new();
  conn.getFd=SslFd_new();
  conn.tmpFd=SslFd_new();
  if(conn.getFd == ((struct anonymous_0 *)NULL) || conn.postFd == ((struct anonymous_0 *)NULL) || conn.tmpFd == ((struct anonymous_0 *)NULL))
  {
    aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
    exit(1);
  }

  _Bool tmp_if_expr_6;
  struct ssl_st *return_value_SslFd_get_ssl_5;
  _Bool tmp_if_expr_8;
  struct ssl_st *return_value_SslFd_get_ssl_7;
  if(!(https == 0))
  {
    name = "s";
    struct ssl_st *return_value_SSL_new_1;
    return_value_SSL_new_1=SSL_new(ctx);
    SslFd_set_ssl(conn.postFd, return_value_SSL_new_1);
    struct ssl_st *return_value_SSL_new_2;
    return_value_SSL_new_2=SSL_new(ctx);
    SslFd_set_ssl(conn.getFd, return_value_SSL_new_2);
    struct ssl_st *return_value_SSL_new_3;
    return_value_SSL_new_3=SSL_new(ctx);
    SslFd_set_ssl(conn.tmpFd, return_value_SSL_new_3);
    struct ssl_st *return_value_SslFd_get_ssl_4;
    return_value_SslFd_get_ssl_4=SslFd_get_ssl(conn.postFd);
    if(return_value_SslFd_get_ssl_4 == ((struct ssl_st *)NULL))
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_SslFd_get_ssl_5=SslFd_get_ssl(conn.getFd);
      tmp_if_expr_6 = return_value_SslFd_get_ssl_5 == (struct ssl_st *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      tmp_if_expr_8 = (_Bool)1;

    else
    {
      return_value_SslFd_get_ssl_7=SslFd_get_ssl(conn.tmpFd);
      tmp_if_expr_8 = return_value_SslFd_get_ssl_7 == (struct ssl_st *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_8)
    {
      aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
      exit(1);
    }

  }

  if((signed int)authtype == -1)
  {
    aflog((char)16, (char)32, "Wrong type of proxy authorizaton --> switching to no authorization");
    credentials = (char *)(void *)0;
  }

  if(!(credentials == ((char *)NULL)))
  {
    unsigned long int return_value_strlen_9;
    return_value_strlen_9=strlen(credentials);
    signed int return_value_b64_ntop_10;
    return_value_b64_ntop_10=b64_ntop((unsigned char *)credentials, return_value_strlen_9, b64cred, (unsigned long int)100);
    if(return_value_b64_ntop_10 == -1)
    {
      aflog((char)16, (char)64, "Cannot encode credentials for proxy authorization");
      b64cred[(signed long int)0] = (char)0;
    }

    else
      if((signed int)authtype == 0)
        authtype = (char)1;

  }

  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_11) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&allset)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  tv.tv_usec = (signed long int)0;
  tv.tv_sec = (signed long int)timeout;
  memset((void *)conn.id, 0, (unsigned long int)10);
  j = 0;
  for( ; !(j >= 9); j = j + 1)
  {
    signed int return_value_myrand_11;
    return_value_myrand_11=myrand(65, 90);
    conn.id[(signed long int)j] = (char)return_value_myrand_11;
  }
  conn.id[(signed long int)9] = (char)0;
  aflog((char)16, (char)2, "http%s proxy: connecting (postfd)...", name);
  signed int return_value_ip_connect_12;
  return_value_ip_connect_12=ip_connect(&tmp, proxyname, proxyport, type, (const char *)(void *)0, (const char *)(void *)0);
  if(!(return_value_ip_connect_12 == 0))
    clean_return(conn.sockfd);

  SslFd_set_fd(conn.postFd, tmp);
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl_13;
    return_value_SslFd_get_ssl_13=SslFd_get_ssl(conn.postFd);
    signed int return_value_SslFd_get_fd_14;
    return_value_SslFd_get_fd_14=SslFd_get_fd(conn.postFd);
    signed int return_value_SSL_set_fd_15;
    return_value_SSL_set_fd_15=SSL_set_fd(return_value_SslFd_get_ssl_13, return_value_SslFd_get_fd_14);
    if(!(return_value_SSL_set_fd_15 == 1))
    {
      aflog((char)4, (char)1, "https proxy: Problem with initializing ssl");
      clean_return(conn.sockfd);
    }

    struct ssl_st *return_value_SslFd_get_ssl_16;
    return_value_SslFd_get_ssl_16=SslFd_get_ssl(conn.postFd);
    signed int return_value_SSL_connect_17;
    return_value_SSL_connect_17=SSL_connect(return_value_SslFd_get_ssl_16);
    if(!(return_value_SSL_connect_17 == 1))
    {
      aflog((char)4, (char)1, "https proxy: SSL_connect has failed");
      clean_return(conn.sockfd);
    }

  }

  memset((void *)tab, 0, (unsigned long int)9000);
  if((signed int)authtype == 1)
  {
    sprintf(tab, "POST http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nContent-Length: 90000\r\nConnection: close\r\nProxy-Authorization: Basic %s\r\n\r\n", host, serv, (const void *)conn.id, host, serv, (const void *)b64cred);
    goto __CPROVER_DUMP_L20;
  }

  sprintf(tab, "POST http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nContent-Length: 90000\r\nConnection: close\r\n\r\n", host, serv, (const void *)conn.id, host, serv);

__CPROVER_DUMP_L20:
  ;
  unsigned long int return_value_strlen_18;
  return_value_strlen_18=strlen(tab);
  j = (signed int)return_value_strlen_18;
  aflog((char)16, (char)2, "http%s proxy: writing POST request...", name);
  signed int return_value_http_write_19;
  return_value_http_write_19=http_write(https, conn.postFd, (unsigned char *)tab, j);
  if(!(return_value_http_write_19 >= 1))
    clean_return(conn.sockfd);

  aflog((char)16, (char)2, "http%s proxy: connecting (getfd)...", name);
  signed int return_value_ip_connect_20;
  return_value_ip_connect_20=ip_connect(&tmp, proxyname, proxyport, type, (const char *)(void *)0, (const char *)(void *)0);
  if(!(return_value_ip_connect_20 == 0))
    clean_return(conn.sockfd);

  SslFd_set_fd(conn.getFd, tmp);
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl_21;
    return_value_SslFd_get_ssl_21=SslFd_get_ssl(conn.getFd);
    signed int return_value_SslFd_get_fd_22;
    return_value_SslFd_get_fd_22=SslFd_get_fd(conn.getFd);
    signed int return_value_SSL_set_fd_23;
    return_value_SSL_set_fd_23=SSL_set_fd(return_value_SslFd_get_ssl_21, return_value_SslFd_get_fd_22);
    if(!(return_value_SSL_set_fd_23 == 1))
    {
      aflog((char)4, (char)1, "https proxy: Problem with initializing ssl");
      clean_return(conn.sockfd);
    }

    struct ssl_st *return_value_SslFd_get_ssl_24;
    return_value_SslFd_get_ssl_24=SslFd_get_ssl(conn.getFd);
    signed int return_value_SSL_connect_25;
    return_value_SSL_connect_25=SSL_connect(return_value_SslFd_get_ssl_24);
    if(!(return_value_SSL_connect_25 == 1))
    {
      aflog((char)4, (char)1, "https proxy: SSL_connect has failed");
      clean_return(conn.sockfd);
    }

  }

  memset((void *)tab, 0, (unsigned long int)9000);
  if((signed int)authtype == 1)
  {
    sprintf(tab, "GET http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nConnection: close\r\nProxy-Authorization: Basic %s\r\n\r\n", host, serv, (const void *)conn.id, host, serv, (const void *)b64cred);
    goto __CPROVER_DUMP_L28;
  }

  sprintf(tab, "GET http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nConnection: close\r\n\r\n", host, serv, (const void *)conn.id, host, serv);

__CPROVER_DUMP_L28:
  ;
  unsigned long int return_value_strlen_26;
  return_value_strlen_26=strlen(tab);
  j = (signed int)return_value_strlen_26;
  aflog((char)16, (char)2, "http%s proxy: writing GET request...", name);
  signed int return_value_http_write_27;
  return_value_http_write_27=http_write(https, conn.getFd, (unsigned char *)tab, j);
  if(!(return_value_http_write_27 >= 1))
    clean_return(conn.sockfd);

  set_fd(conn.sockfd, &maxfdp1, &allset);
  signed int return_value_SslFd_get_fd_28;
  return_value_SslFd_get_fd_28=SslFd_get_fd(conn.postFd);
  set_fd(return_value_SslFd_get_fd_28, &maxfdp1, &allset);
  signed int return_value_SslFd_get_fd_29;
  return_value_SslFd_get_fd_29=SslFd_get_fd(conn.getFd);
  set_fd(return_value_SslFd_get_fd_29, &maxfdp1, &allset);
  conn.state = (char)4;
  memset((void *)tab, 0, (unsigned long int)9000);
  aflog((char)16, (char)2, "http%s proxy: parsing header from getfd", name);
  signed int return_value_parse_header_30;
  return_value_parse_header_30=parse_header(conn.getFd, tab, &hdr, https);
  if(!(return_value_parse_header_30 == 0))
    clean_return(conn.sockfd);

  aflog((char)16, (char)2, "http%s proxy: checking hdr.type", name);
  if(!((signed int)hdr.type == 2))
    clean_return(conn.sockfd);

  if(!(hdr.length == 0))
  {
    conn.received = conn.received + hdr.length;
    aflog((char)16, (char)2, "http%s proxy: reading message...", name);
    signed int return_value_read_message_31;
    return_value_read_message_31=read_message(conn.sockfd, hdr.length, &conn, tab, hdr.ptr);
    if(!(return_value_read_message_31 == 0))
      clean_return(conn.sockfd);

  }

  while((_Bool)1)
  {
    if((signed int)conn.state == 4)
    {
      if((allset.__fds_bits[(signed long int)(conn.sockfd / 8)] & 1l << conn.sockfd % 8) == 0l)
        (&allset)->__fds_bits[(signed long int)(conn.sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(conn.sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << conn.sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ );

    }

    rset = allset;
    signed int return_value_select_41;
    return_value_select_41=select(maxfdp1, &rset, (struct anonymous_11 *)(void *)0, (struct anonymous_11 *)(void *)0, &tv);
    if(return_value_select_41 == 0)
    {
      aflog((char)16, (char)4, "http%s proxy: timeout", name);
      tv.tv_sec = (signed long int)timeout;
      if(1 + conn.sent_ptr >= 90000)
      {
        if((signed int)conn.state == 0)
          continue;

        aflog((char)16, (char)4, "http%s proxy: send T", name);
        http_write(https, conn.postFd, (unsigned char *)"T", 1);
        conn.sent_ptr = 0;
        clear_sslFd(conn.postFd, &allset);
        aflog((char)16, (char)2, "http%s proxy: connecting (postfd)...", name);
        signed int return_value_ip_connect_32;
        return_value_ip_connect_32=ip_connect(&tmp, proxyname, proxyport, type, (const char *)(void *)0, (const char *)(void *)0);
        if(!(return_value_ip_connect_32 == 0))
          clean_return(conn.sockfd);

        SslFd_set_fd(conn.postFd, tmp);
        if(!(https == 0))
        {
          struct ssl_st *return_value_SslFd_get_ssl_33;
          return_value_SslFd_get_ssl_33=SslFd_get_ssl(conn.postFd);
          signed int return_value_SslFd_get_fd_34;
          return_value_SslFd_get_fd_34=SslFd_get_fd(conn.postFd);
          signed int return_value_SSL_set_fd_35;
          return_value_SSL_set_fd_35=SSL_set_fd(return_value_SslFd_get_ssl_33, return_value_SslFd_get_fd_34);
          if(!(return_value_SSL_set_fd_35 == 1))
          {
            aflog((char)4, (char)1, "https proxy: Problem with initializing ssl");
            clean_return(conn.sockfd);
          }

          struct ssl_st *return_value_SslFd_get_ssl_36;
          return_value_SslFd_get_ssl_36=SslFd_get_ssl(conn.postFd);
          signed int return_value_SSL_connect_37;
          return_value_SSL_connect_37=SSL_connect(return_value_SslFd_get_ssl_36);
          if(!(return_value_SSL_connect_37 == 1))
          {
            aflog((char)4, (char)1, "https proxy: SSL_connect has failed");
            clean_return(conn.sockfd);
          }

        }

        memset((void *)tab, 0, (unsigned long int)9000);
        if((signed int)authtype == 1)
        {
          sprintf(tab, "POST http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nContent-Length: 90000\r\nConnection: close\r\nProxy-Authorization: Basic %s\r\n\r\n", host, serv, (const void *)conn.id, host, serv, (const void *)b64cred);
          goto __CPROVER_DUMP_L41;
        }

        sprintf(tab, "POST http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nContent-Length: 90000\r\nConnection: close\r\n\r\n", host, serv, (const void *)conn.id, host, serv);

      __CPROVER_DUMP_L41:
        ;
        unsigned long int return_value_strlen_38;
        return_value_strlen_38=strlen(tab);
        j = (signed int)return_value_strlen_38;
        aflog((char)16, (char)2, "http%s proxy: writing POST request...", name);
        signed int return_value_http_write_39;
        return_value_http_write_39=http_write(https, conn.postFd, (unsigned char *)tab, j);
        if(!(return_value_http_write_39 >= 1))
          clean_return(conn.sockfd);

        conn.sent_ptr = 0;
        conn.ptr = 0;
        conn.length = 0;
        conn.state = (char)0;
        signed int return_value_SslFd_get_fd_40;
        return_value_SslFd_get_fd_40=SslFd_get_fd(conn.postFd);
        set_fd(return_value_SslFd_get_fd_40, &maxfdp1, &allset);
      }

      else
      {
        aflog((char)16, (char)4, "http%s proxy: send T", name);
        http_write(https, conn.postFd, (unsigned char *)"T", 1);
        conn.sent_ptr = conn.sent_ptr + 1;
      }
    }

    else
    {
      if(!((rset.__fds_bits[(signed long int)(conn.sockfd / 8)] & 1l << conn.sockfd % 8) == 0l))
      {
        aflog((char)16, (char)4, "http%s proxy: FD_ISSET(conn.sockfd)", name);
        signed long int return_value_read_42;
        return_value_read_42=read(conn.sockfd, (void *)(conn.buf + (signed long int)5), (unsigned long int)8995);
        n = (signed int)return_value_read_42;
        if(!(n >= 1))
        {
          aflog((char)16, (char)2, "http%s proxy: send Q", name);
          http_write(https, conn.postFd, (unsigned char *)"Q", 1);
          clean_return(conn.sockfd);
        }

        if((signed int)conn.state == 0 && conn.sent_ptr >= 70001)
          (&allset)->__fds_bits[(signed long int)(conn.sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(conn.sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << conn.sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

        conn.buf[(signed long int)0] = (char)77;
        unsigned int return_value___bswap_32_43;
        return_value___bswap_32_43=__bswap_32_link1((unsigned int)n);
        tmp = (signed int)return_value___bswap_32_43;
        memcpy((void *)&conn.buf[(signed long int)1], (const void *)&tmp, (unsigned long int)4);
        if(5 + conn.sent_ptr + n >= 90000)
        {
          aflog((char)16, (char)2, "http%s proxy: send message", name);
          http_write(https, conn.postFd, (unsigned char *)conn.buf, 90000 - conn.sent_ptr);
          conn.ptr = 90000 - conn.sent_ptr;
          conn.length = (5 + n) - conn.ptr;
          conn.sent_ptr = 0;
          clear_sslFd(conn.postFd, &allset);
          aflog((char)16, (char)2, "http%s proxy: connecting (postfd)...", name);
          signed int return_value_ip_connect_44;
          return_value_ip_connect_44=ip_connect(&tmp, proxyname, proxyport, type, (const char *)(void *)0, (const char *)(void *)0);
          if(!(return_value_ip_connect_44 == 0))
            clean_return(conn.sockfd);

          SslFd_set_fd(conn.postFd, tmp);
          if(!(https == 0))
          {
            struct ssl_st *return_value_SslFd_get_ssl_45;
            return_value_SslFd_get_ssl_45=SslFd_get_ssl(conn.postFd);
            signed int return_value_SslFd_get_fd_46;
            return_value_SslFd_get_fd_46=SslFd_get_fd(conn.postFd);
            signed int return_value_SSL_set_fd_47;
            return_value_SSL_set_fd_47=SSL_set_fd(return_value_SslFd_get_ssl_45, return_value_SslFd_get_fd_46);
            if(!(return_value_SSL_set_fd_47 == 1))
            {
              aflog((char)4, (char)1, "https proxy: Problem with initializing ssl");
              clean_return(conn.sockfd);
            }

            struct ssl_st *return_value_SslFd_get_ssl_48;
            return_value_SslFd_get_ssl_48=SslFd_get_ssl(conn.postFd);
            signed int return_value_SSL_connect_49;
            return_value_SSL_connect_49=SSL_connect(return_value_SslFd_get_ssl_48);
            if(!(return_value_SSL_connect_49 == 1))
            {
              aflog((char)4, (char)1, "https proxy: SSL_connect has failed");
              clean_return(conn.sockfd);
            }

          }

          memset((void *)tab, 0, (unsigned long int)9000);
          if((signed int)authtype == 1)
          {
            sprintf(tab, "POST http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nContent-Length: 90000\r\nConnection: close\r\nProxy-Authorization: Basic %s\r\n\r\n", host, serv, (const void *)conn.id, host, serv, (const void *)b64cred);
            goto __CPROVER_DUMP_L54;
          }

          sprintf(tab, "POST http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nContent-Length: 90000\r\nConnection: close\r\n\r\n", host, serv, (const void *)conn.id, host, serv);

        __CPROVER_DUMP_L54:
          ;
          unsigned long int return_value_strlen_50;
          return_value_strlen_50=strlen(tab);
          j = (signed int)return_value_strlen_50;
          aflog((char)16, (char)2, "http%s proxy: writing POST request...", name);
          signed int return_value_http_write_51;
          return_value_http_write_51=http_write(https, conn.postFd, (unsigned char *)tab, j);
          if(!(return_value_http_write_51 >= 1))
            clean_return(conn.sockfd);

          if(conn.length >= 1)
          {
            aflog((char)16, (char)2, "http%s proxy: writing old data...", name);
            signed int return_value_http_write_52;
            return_value_http_write_52=http_write(https, conn.postFd, (unsigned char *)(conn.buf + (signed long int)conn.ptr), conn.length);
            if(!(return_value_http_write_52 >= 1))
              clean_return(conn.sockfd);

          }

          conn.sent_ptr = conn.length;
          conn.ptr = 0;
          conn.length = 0;
          conn.state = (char)0;
          signed int return_value_SslFd_get_fd_53;
          return_value_SslFd_get_fd_53=SslFd_get_fd(conn.postFd);
          set_fd(return_value_SslFd_get_fd_53, &maxfdp1, &allset);
        }

        else
        {
          aflog((char)16, (char)2, "http%s proxy: send message", name);
          http_write(https, conn.postFd, (unsigned char *)conn.buf, 5 + n);
          conn.sent_ptr = conn.sent_ptr + 5 + n;
        }
      }

      signed int return_value_SslFd_get_fd_66;
      return_value_SslFd_get_fd_66=SslFd_get_fd(conn.getFd);
      signed int return_value_SslFd_get_fd_67;
      return_value_SslFd_get_fd_67=SslFd_get_fd(conn.getFd);
      if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd_66 / 8)] & 1l << return_value_SslFd_get_fd_67 % 8) == 0l))
      {
        aflog((char)16, (char)4, "http%s proxy: FD_ISSET(conn.getfd)", name);
        n=http_read(https, conn.getFd, (unsigned char *)tab, 9000);
        conn.received = conn.received + n;
        if(n == 0)
        {
          conn.received = 0;
          clear_sslFd(conn.getFd, &allset);
          aflog((char)16, (char)2, "http%s proxy: connecting (getfd)...", name);
          signed int return_value_ip_connect_54;
          return_value_ip_connect_54=ip_connect(&tmp, proxyname, proxyport, type, (const char *)(void *)0, (const char *)(void *)0);
          if(!(return_value_ip_connect_54 == 0))
            clean_return(conn.sockfd);

          SslFd_set_fd(conn.getFd, tmp);
          if(!(https == 0))
          {
            struct ssl_st *return_value_SslFd_get_ssl_55;
            return_value_SslFd_get_ssl_55=SslFd_get_ssl(conn.getFd);
            signed int return_value_SslFd_get_fd_56;
            return_value_SslFd_get_fd_56=SslFd_get_fd(conn.getFd);
            signed int return_value_SSL_set_fd_57;
            return_value_SSL_set_fd_57=SSL_set_fd(return_value_SslFd_get_ssl_55, return_value_SslFd_get_fd_56);
            if(!(return_value_SSL_set_fd_57 == 1))
            {
              aflog((char)4, (char)1, "https proxy: Problem with initializing ssl");
              clean_return(conn.sockfd);
            }

            struct ssl_st *return_value_SslFd_get_ssl_58;
            return_value_SslFd_get_ssl_58=SslFd_get_ssl(conn.getFd);
            signed int return_value_SSL_connect_59;
            return_value_SSL_connect_59=SSL_connect(return_value_SslFd_get_ssl_58);
            if(!(return_value_SSL_connect_59 == 1))
            {
              aflog((char)4, (char)1, "https proxy: SSL_connect has failed");
              clean_return(conn.sockfd);
            }

          }

          memset((void *)tab, 0, (unsigned long int)9000);
          if((signed int)authtype == 1)
          {
            sprintf(tab, "GET http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nConnection: close\r\nProxy-Authorization: Basic %s\r\n\r\n", host, serv, (const void *)conn.id, host, serv, (const void *)b64cred);
            goto __CPROVER_DUMP_L67;
          }

          sprintf(tab, "GET http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nConnection: close\r\n\r\n", host, serv, (const void *)conn.id, host, serv);

        __CPROVER_DUMP_L67:
          ;
          unsigned long int return_value_strlen_60;
          return_value_strlen_60=strlen(tab);
          j = (signed int)return_value_strlen_60;
          aflog((char)16, (char)2, "http%s proxy: writing GET request...", name);
          signed int return_value_http_write_61;
          return_value_http_write_61=http_write(https, conn.getFd, (unsigned char *)tab, j);
          if(!(return_value_http_write_61 >= 1))
            clean_return(conn.sockfd);

          memset((void *)tab, 0, (unsigned long int)9000);
          aflog((char)16, (char)2, "http%s proxy: parsing header from getfd", name);
          signed int return_value_parse_header_62;
          return_value_parse_header_62=parse_header(conn.getFd, tab, &hdr, https);
          if(!(return_value_parse_header_62 == 0))
            clean_return(conn.sockfd);

          aflog((char)16, (char)2, "http%s proxy: checking hdr.type", name);
          if(!((signed int)hdr.type == 2))
            clean_return(conn.sockfd);

          signed int return_value_SslFd_get_fd_63;
          return_value_SslFd_get_fd_63=SslFd_get_fd(conn.getFd);
          set_fd(return_value_SslFd_get_fd_63, &maxfdp1, &allset);
          if(!(hdr.length == 0))
          {
            conn.received = conn.received + hdr.length;
            aflog((char)16, (char)2, "http%s proxy: reading message...", name);
            signed int return_value_read_message_64;
            return_value_read_message_64=read_message(conn.sockfd, hdr.length, &conn, tab, hdr.ptr);
            if(!(return_value_read_message_64 == 0))
              clean_return(conn.sockfd);

          }

        }

        else
        {
          signed int return_value_read_message_65;
          return_value_read_message_65=read_message(conn.sockfd, n, &conn, tab, 0);
          if(!(return_value_read_message_65 == 0))
            clean_return(conn.sockfd);

        }
      }

      signed int return_value_SslFd_get_fd_68;
      return_value_SslFd_get_fd_68=SslFd_get_fd(conn.postFd);
      signed int return_value_SslFd_get_fd_69;
      return_value_SslFd_get_fd_69=SslFd_get_fd(conn.postFd);
      if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd_68 / 8)] & 1l << return_value_SslFd_get_fd_69 % 8) == 0l))
      {
        aflog((char)16, (char)4, "http%s proxy: FD_ISSET(conn.postfd) --> clean_return", name);
        clear_sslFd(conn.postFd, &allset);
        clean_return(conn.sockfd);
      }

    }
  }
  clean_return(conn.sockfd);
}

// http_read
// file http_proxy_functions.c line 402
signed int http_read(char https, struct anonymous_0 *sf, unsigned char *buf, signed int amount)
{
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl_1;
    return_value_SslFd_get_ssl_1=SslFd_get_ssl(sf);
    signed int return_value_SSL_read_2;
    return_value_SSL_read_2=SSL_read(return_value_SslFd_get_ssl_1, (void *)buf, amount);
    return return_value_SSL_read_2;
  }

  else
  {
    signed int return_value_SslFd_get_fd_3;
    return_value_SslFd_get_fd_3=SslFd_get_fd(sf);
    signed long int return_value_read_4;
    return_value_read_4=read(return_value_SslFd_get_fd_3, (void *)buf, (unsigned long int)amount);
    return (signed int)return_value_read_4;
  }
}

// http_write
// file http_proxy_functions.c line 381
signed int http_write(char https, struct anonymous_0 *sf, unsigned char *buf, signed int amount)
{
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl_1;
    return_value_SslFd_get_ssl_1=SslFd_get_ssl(sf);
    signed int return_value_SSL_writen_2;
    return_value_SSL_writen_2=SSL_writen(return_value_SslFd_get_ssl_1, buf, amount);
    return return_value_SSL_writen_2;
  }

  else
  {
    signed int return_value_SslFd_get_fd_3;
    return_value_SslFd_get_fd_3=SslFd_get_fd(sf);
    signed int return_value_writen_4;
    return_value_writen_4=writen(return_value_SslFd_get_fd_3, buf, amount);
    return return_value_writen_4;
  }
}

// initialize_client_reverse_udp
// file client_reverse_udp.h line 38
signed int initialize_client_reverse_udp(struct anonymous_5 *cr)
{
  signed int tmp;
  signed int wanttoexit;
  struct anonymous_3 *return_value_ClientRealm_get_arOptions_1;
  return_value_ClientRealm_get_arOptions_1=ClientRealm_get_arOptions(cr);
  char return_value_ArOptions_get_arStart_2;
  return_value_ArOptions_get_arStart_2=ArOptions_get_arStart(return_value_ClientRealm_get_arOptions_1);
  wanttoexit = (signed int)return_value_ArOptions_get_arStart_2 == 1 ? 0 : 1;
  ClientRealm_set_usersLimit(cr, 1);
  char *return_value_ClientRealm_get_serverName_8;
  return_value_ClientRealm_get_serverName_8=ClientRealm_get_serverName(cr);
  char *return_value_ClientRealm_get_managePort_9;
  return_value_ClientRealm_get_managePort_9=ClientRealm_get_managePort(cr);
  char return_value_ClientRealm_get_ipFamily_10;
  return_value_ClientRealm_get_ipFamily_10=ClientRealm_get_ipFamily(cr);
  signed int return_value_ip_connect_11;
  return_value_ip_connect_11=ip_connect(&tmp, return_value_ClientRealm_get_serverName_8, return_value_ClientRealm_get_managePort_9, return_value_ClientRealm_get_ipFamily_10, (const char *)(void *)0, (const char *)(void *)0);
  char *tmp_if_expr_5;
  char return_value_ClientRealm_get_ipFamily_4;
  if(!(return_value_ip_connect_11 == 0))
  {
    char return_value_ClientRealm_get_ipFamily_3;
    return_value_ClientRealm_get_ipFamily_3=ClientRealm_get_ipFamily(cr);
    if(!((0x02 & (signed int)return_value_ClientRealm_get_ipFamily_3) == 0))
      tmp_if_expr_5 = "ipv4";

    else
    {
      return_value_ClientRealm_get_ipFamily_4=ClientRealm_get_ipFamily(cr);
      tmp_if_expr_5 = ((signed int)return_value_ClientRealm_get_ipFamily_4 & 0x04) != 0 ? "ipv6" : "unspec";
    }
    char *return_value_ClientRealm_get_serverName_6;
    return_value_ClientRealm_get_serverName_6=ClientRealm_get_serverName(cr);
    char *return_value_ClientRealm_get_managePort_7;
    return_value_ClientRealm_get_managePort_7=ClientRealm_get_managePort(cr);
    aflog((char)4, (char)1, "tcp_connect_%s error for %s, %s", tmp_if_expr_5, return_value_ClientRealm_get_serverName_6, return_value_ClientRealm_get_managePort_7);
    if(!(wanttoexit == 0))
      exit(1);

    else
      return 1;
  }

  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_12;
  return_value_ClientRealm_get_masterSslFd_12=ClientRealm_get_masterSslFd(cr);
  SslFd_set_fd(return_value_ClientRealm_get_masterSslFd_12, tmp);
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_13;
  return_value_ClientRealm_get_masterSslFd_13=ClientRealm_get_masterSslFd(cr);
  SslFd_set_ssl(return_value_ClientRealm_get_masterSslFd_13, (struct ssl_st *)(void *)0);
  return 0;
}

// initialize_client_stage1
// file client_initialization.h line 36
signed int initialize_client_stage1(struct anonymous_5 *cr, struct ssl_ctx_st *ctx, unsigned char *buff, char wanttoexit, char ignorePublicKeys)
{
  signed int n;
  signed int nlen;
  signed int elen;
  signed int len;
  signed int tmp;
  unsigned int olen;
  struct x509_st *server_cert;
  const struct env_md_st *md;
  struct evp_pkey_st *pkey;
  struct env_md_ctx_st md_ctx;
  unsigned char *encoded = (unsigned char *)(void *)0;
  char b64_encoded[100l];
  unsigned char *key_buf = (unsigned char *)(void *)0;
  char return_value_ClientRealm_get_tunnelType_1;
  return_value_ClientRealm_get_tunnelType_1=ClientRealm_get_tunnelType(cr);
  char *return_value_ClientRealm_get_serverName_7;
  char *return_value_ClientRealm_get_managePort_8;
  char return_value_ClientRealm_get_ipFamily_9;
  char *return_value_ClientRealm_get_localName_10;
  char *return_value_ClientRealm_get_localPort_11;
  signed int return_value_ip_connect_12;
  char *tmp_if_expr_4;
  char return_value_ClientRealm_get_ipFamily_3;
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_13;
  signed int return_value_initialize_http_proxy_client_23;
  char *tmp_if_expr_16;
  char return_value_ClientRealm_get_ipFamily_15;
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_24;
  switch((signed int)return_value_ClientRealm_get_tunnelType_1)
  {
    case 0:
    {
      return_value_ClientRealm_get_serverName_7=ClientRealm_get_serverName(cr);
      return_value_ClientRealm_get_managePort_8=ClientRealm_get_managePort(cr);
      return_value_ClientRealm_get_ipFamily_9=ClientRealm_get_ipFamily(cr);
      return_value_ClientRealm_get_localName_10=ClientRealm_get_localName(cr);
      return_value_ClientRealm_get_localPort_11=ClientRealm_get_localPort(cr);
      return_value_ip_connect_12=ip_connect(&tmp, return_value_ClientRealm_get_serverName_7, return_value_ClientRealm_get_managePort_8, return_value_ClientRealm_get_ipFamily_9, return_value_ClientRealm_get_localName_10, return_value_ClientRealm_get_localPort_11);
      if(!(return_value_ip_connect_12 == 0))
      {
        char return_value_ClientRealm_get_ipFamily_2;
        return_value_ClientRealm_get_ipFamily_2=ClientRealm_get_ipFamily(cr);
        if(!((0x02 & (signed int)return_value_ClientRealm_get_ipFamily_2) == 0))
          tmp_if_expr_4 = "ipv4";

        else
        {
          return_value_ClientRealm_get_ipFamily_3=ClientRealm_get_ipFamily(cr);
          tmp_if_expr_4 = ((signed int)return_value_ClientRealm_get_ipFamily_3 & 0x04) != 0 ? "ipv6" : "unspec";
        }
        char *return_value_ClientRealm_get_serverName_5;
        return_value_ClientRealm_get_serverName_5=ClientRealm_get_serverName(cr);
        char *return_value_ClientRealm_get_managePort_6;
        return_value_ClientRealm_get_managePort_6=ClientRealm_get_managePort(cr);
        aflog((char)4, (char)1, "tcp_connect_%s error for %s, %s", tmp_if_expr_4, return_value_ClientRealm_get_serverName_5, return_value_ClientRealm_get_managePort_6);
        if(!(wanttoexit == 0))
          exit(1);

        else
          return 1;
      }

      return_value_ClientRealm_get_masterSslFd_13=ClientRealm_get_masterSslFd(cr);
      SslFd_set_fd(return_value_ClientRealm_get_masterSslFd_13, tmp);
      break;
    }
    case 1:
    {
      return_value_initialize_http_proxy_client_23=initialize_http_proxy_client(&tmp, cr, ctx);
      if(!(return_value_initialize_http_proxy_client_23 == 0))
      {
        char return_value_ClientRealm_get_ipFamily_14;
        return_value_ClientRealm_get_ipFamily_14=ClientRealm_get_ipFamily(cr);
        if(!((0x02 & (signed int)return_value_ClientRealm_get_ipFamily_14) == 0))
          tmp_if_expr_16 = "ipv4";

        else
        {
          return_value_ClientRealm_get_ipFamily_15=ClientRealm_get_ipFamily(cr);
          tmp_if_expr_16 = ((signed int)return_value_ClientRealm_get_ipFamily_15 & 0x04) != 0 ? "ipv6" : "unspec";
        }
        char *return_value_ClientRealm_get_serverName_17;
        return_value_ClientRealm_get_serverName_17=ClientRealm_get_serverName(cr);
        char *return_value_ClientRealm_get_managePort_18;
        return_value_ClientRealm_get_managePort_18=ClientRealm_get_managePort(cr);
        struct anonymous *return_value_ClientRealm_get_httpProxyOptions_19;
        return_value_ClientRealm_get_httpProxyOptions_19=ClientRealm_get_httpProxyOptions(cr);
        char *return_value_HttpProxyOptions_get_proxyname_20;
        return_value_HttpProxyOptions_get_proxyname_20=HttpProxyOptions_get_proxyname(return_value_ClientRealm_get_httpProxyOptions_19);
        struct anonymous *return_value_ClientRealm_get_httpProxyOptions_21;
        return_value_ClientRealm_get_httpProxyOptions_21=ClientRealm_get_httpProxyOptions(cr);
        char *return_value_HttpProxyOptions_get_proxyport_22;
        return_value_HttpProxyOptions_get_proxyport_22=HttpProxyOptions_get_proxyport(return_value_ClientRealm_get_httpProxyOptions_21);
        aflog((char)4, (char)1, "http_proxy_connect_%s error for %s, %s (proxy: %s, %s)", tmp_if_expr_16, return_value_ClientRealm_get_serverName_17, return_value_ClientRealm_get_managePort_18, return_value_HttpProxyOptions_get_proxyname_20, return_value_HttpProxyOptions_get_proxyport_22);
        if(!(wanttoexit == 0))
          exit(1);

        else
          return 1;
      }

      return_value_ClientRealm_get_masterSslFd_24=ClientRealm_get_masterSslFd(cr);
      SslFd_set_fd(return_value_ClientRealm_get_masterSslFd_24, tmp);
      break;
    }
    default:
    {
      aflog((char)4, (char)1, "Unknown tunnel type");
      if(!(wanttoexit == 0))
        exit(1);

      else
        return 1;
    }
  }
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_25;
  return_value_ClientRealm_get_masterSslFd_25=ClientRealm_get_masterSslFd(cr);
  struct ssl_st *return_value_SSL_new_26;
  return_value_SSL_new_26=SSL_new(ctx);
  SslFd_set_ssl(return_value_ClientRealm_get_masterSslFd_25, return_value_SSL_new_26);
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_29;
  return_value_ClientRealm_get_masterSslFd_29=ClientRealm_get_masterSslFd(cr);
  struct ssl_st *return_value_SslFd_get_ssl_30;
  return_value_SslFd_get_ssl_30=SslFd_get_ssl(return_value_ClientRealm_get_masterSslFd_29);
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_31;
  return_value_ClientRealm_get_masterSslFd_31=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd_32;
  return_value_SslFd_get_fd_32=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_31);
  signed int return_value_SSL_set_fd_33;
  return_value_SSL_set_fd_33=SSL_set_fd(return_value_SslFd_get_ssl_30, return_value_SslFd_get_fd_32);
  if(!(return_value_SSL_set_fd_33 == 1))
  {
    aflog((char)4, (char)1, "Problem with initializing ssl... exiting");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_27;
      return_value_ClientRealm_get_masterSslFd_27=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd_28;
      return_value_SslFd_get_fd_28=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_27);
      close(return_value_SslFd_get_fd_28);
      return 2;
    }
  }

  alarm((unsigned int)60);
  aflog((char)4, (char)8, "Trying SSL_connect");
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_52;
  return_value_ClientRealm_get_masterSslFd_52=ClientRealm_get_masterSslFd(cr);
  struct ssl_st *return_value_SslFd_get_ssl_53;
  return_value_SslFd_get_ssl_53=SslFd_get_ssl(return_value_ClientRealm_get_masterSslFd_52);
  n=SSL_connect(return_value_SslFd_get_ssl_53);
  char *return_value_get_store_filename_44;
  char *return_value_ClientRealm_get_serverName_45;
  if(n == 1)
  {
    struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_34;
    return_value_ClientRealm_get_masterSslFd_34=ClientRealm_get_masterSslFd(cr);
    struct ssl_st *return_value_SslFd_get_ssl_35;
    return_value_SslFd_get_ssl_35=SslFd_get_ssl(return_value_ClientRealm_get_masterSslFd_34);
    server_cert=SSL_get_peer_certificate(return_value_SslFd_get_ssl_35);
    if(server_cert == ((struct x509_st *)NULL))
    {
      aflog((char)16, (char)1, "Server did not present a certificate... exiting");
      exit(1);
    }

    pkey=X509_get_pubkey(server_cert);
    if(pkey == ((struct evp_pkey_st *)NULL))
    {
      aflog((char)16, (char)1, "Server's public key is invalid... exiting");
      exit(1);
    }

    signed int return_value_BN_num_bits_36;
    return_value_BN_num_bits_36=BN_num_bits(pkey->pkey.rsa->n);
    nlen = (return_value_BN_num_bits_36 + 7) / 8;
    signed int return_value_BN_num_bits_37;
    return_value_BN_num_bits_37=BN_num_bits(pkey->pkey.rsa->e);
    elen = (return_value_BN_num_bits_37 + 7) / 8;
    len = nlen + elen;
    void *return_value_malloc_38;
    return_value_malloc_38=malloc((unsigned long int)len);
    key_buf = (unsigned char *)return_value_malloc_38;
    if(key_buf == ((unsigned char *)NULL))
    {
      aflog((char)16, (char)1, "Cannot allocate memory for server's public key checking... exiting");
      exit(1);
    }

    BN_bn2bin(pkey->pkey.rsa->n, key_buf);
    BN_bn2bin(pkey->pkey.rsa->e, key_buf + (signed long int)nlen);
    md=EVP_md5();
    EVP_DigestInit(&md_ctx, md);
    EVP_DigestUpdate(&md_ctx, (const void *)key_buf, (unsigned long int)len);
    void *return_value_calloc_39;
    return_value_calloc_39=calloc((unsigned long int)1, (unsigned long int)(64 + 1));
    encoded = (unsigned char *)return_value_calloc_39;
    if(encoded == ((unsigned char *)NULL))
    {
      aflog((char)16, (char)1, "Cannot allocate memory for server's public key checking... exiting");
      exit(1);
    }

    EVP_DigestFinal(&md_ctx, encoded, &olen);
    signed int return_value_b64_ntop_40;
    return_value_b64_ntop_40=b64_ntop(encoded, (unsigned long int)olen, b64_encoded, (unsigned long int)100);
    if(return_value_b64_ntop_40 == -1)
    {
      aflog((char)16, (char)1, "Problem with base64 encoding... exiting");
      exit(1);
    }

    char *return_value_get_store_filename_41;
    return_value_get_store_filename_41=get_store_filename();
    char *return_value_ClientRealm_get_serverName_42;
    return_value_ClientRealm_get_serverName_42=ClientRealm_get_serverName(cr);
    signed int return_value_check_public_key_43;
    return_value_check_public_key_43=check_public_key(return_value_get_store_filename_41, return_value_ClientRealm_get_serverName_42, b64_encoded);
    switch(return_value_check_public_key_43)
    {
      case 1:
        break;
      case 2:
      {
        aflog((char)16, (char)32, "WARNING: implicitly added new server's public key to the list of known hosts");
        return_value_get_store_filename_44=get_store_filename();
        return_value_ClientRealm_get_serverName_45=ClientRealm_get_serverName(cr);
        add_public_key(return_value_get_store_filename_44, return_value_ClientRealm_get_serverName_45, b64_encoded);
        break;
      }
      default:
        if(!(ignorePublicKeys == 0))
          aflog((char)16, (char)32, "WARNING: Invalid server's public key... ignoring");

        else
        {
          aflog((char)16, (char)1, "Invalid server's public key... exiting");
          char *return_value_get_store_filename_46;
          return_value_get_store_filename_46=get_store_filename();
          aflog((char)16, (char)1, "Please delete conflicting entry in %s or use '--ignorepkeys' option", return_value_get_store_filename_46);
          exit(1);
        }
    }
    memset((void *)key_buf, 0, (unsigned long int)len);
    free((void *)key_buf);
    free((void *)encoded);
    aflog((char)4, (char)8, "SSL_connect successful");
  }

  else
  {
    alarm((unsigned int)0);
    struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_47;
    return_value_ClientRealm_get_masterSslFd_47=ClientRealm_get_masterSslFd(cr);
    struct ssl_st *return_value_SslFd_get_ssl_48;
    return_value_SslFd_get_ssl_48=SslFd_get_ssl(return_value_ClientRealm_get_masterSslFd_47);
    signed int return_value_SSL_get_error_49;
    return_value_SSL_get_error_49=SSL_get_error(return_value_SslFd_get_ssl_48, n);
    aflog((char)4, (char)1, "SSL_connect has failed (%d | %d)... exiting", n, return_value_SSL_get_error_49);
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_50;
      return_value_ClientRealm_get_masterSslFd_50=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd_51;
      return_value_SslFd_get_fd_51=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_50);
      close(return_value_SslFd_get_fd_51);
      return 3;
    }
  }
  alarm((unsigned int)0);
  buff[(signed long int)0] = (unsigned char)8;
  unsigned char *return_value_ClientRealm_get_password_54;
  return_value_ClientRealm_get_password_54=ClientRealm_get_password(cr);
  buff[(signed long int)1] = return_value_ClientRealm_get_password_54[(signed long int)0];
  unsigned char *return_value_ClientRealm_get_password_55;
  return_value_ClientRealm_get_password_55=ClientRealm_get_password(cr);
  buff[(signed long int)2] = return_value_ClientRealm_get_password_55[(signed long int)1];
  unsigned char *return_value_ClientRealm_get_password_56;
  return_value_ClientRealm_get_password_56=ClientRealm_get_password(cr);
  buff[(signed long int)3] = return_value_ClientRealm_get_password_56[(signed long int)2];
  unsigned char *return_value_ClientRealm_get_password_57;
  return_value_ClientRealm_get_password_57=ClientRealm_get_password(cr);
  buff[(signed long int)4] = return_value_ClientRealm_get_password_57[(signed long int)3];
  return 0;
}

// initialize_client_stage2
// file client_initialization.h line 38
signed int initialize_client_stage2(struct anonymous_5 *cr, unsigned char *buff, char wanttoexit)
{
  char return_value_ClientRealm_get_realmType_1;
  return_value_ClientRealm_get_realmType_1=ClientRealm_get_realmType(cr);
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_2;
  return_value_ClientRealm_get_masterSslFd_2=ClientRealm_get_masterSslFd(cr);
  SslFd_send_message((char)((signed int)return_value_ClientRealm_get_realmType_1 | 4 | 8), return_value_ClientRealm_get_masterSslFd_2, buff, 5);
  buff[(signed long int)0] = (unsigned char)0;
  char return_value_ClientRealm_get_realmType_3;
  return_value_ClientRealm_get_realmType_3=ClientRealm_get_realmType(cr);
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_4;
  return_value_ClientRealm_get_masterSslFd_4=ClientRealm_get_masterSslFd(cr);
  SslFd_get_message((char)((signed int)return_value_ClientRealm_get_realmType_3 | 4 | 8), return_value_ClientRealm_get_masterSslFd_4, buff, -5);
  if((signed int)*buff == 0)
  {
    aflog((char)4, (char)1, "Connection with afserver failed");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_5;
      return_value_ClientRealm_get_masterSslFd_5=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd_6;
      return_value_SslFd_get_fd_6=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_5);
      close(return_value_SslFd_get_fd_6);
      return 1;
    }
  }

  if((signed int)*buff == 13)
  {
    aflog((char)4, (char)64, "Wrong password");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_7;
      return_value_ClientRealm_get_masterSslFd_7=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd_8;
      return_value_SslFd_get_fd_8=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_7);
      close(return_value_SslFd_get_fd_8);
      return 1;
    }
  }

  if((signed int)*buff == 12)
  {
    aflog((char)4, (char)64, "Server is full");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_9;
      return_value_ClientRealm_get_masterSslFd_9=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd_10;
      return_value_SslFd_get_fd_10=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_9);
      close(return_value_SslFd_get_fd_10);
      return 1;
    }
  }

  if(!((signed int)*buff == 8))
  {
    aflog((char)4, (char)64, "Incompatible server type or server full");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_11;
      return_value_ClientRealm_get_masterSslFd_11=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd_12;
      return_value_SslFd_get_fd_12=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_11);
      close(return_value_SslFd_get_fd_12);
      return 1;
    }
  }

  ClientRealm_set_realmType(cr, (char)buff[(signed long int)3]);
  ClientRealm_set_usersLimit(cr, (signed int)buff[(signed long int)1] * 256 + (signed int)buff[(signed long int)2]);
  return 0;
}

// initialize_client_stage3
// file client_initialization.h line 39
signed int initialize_client_stage3(struct anonymous_5 *cr, signed int *buflength, struct anonymous_11 *allset, struct anonymous_11 *wset, signed int *maxfdp1, char wanttoexit)
{
  signed int i;
  unsigned int len;
  struct anonymous_7 **usersTable;
  signed int return_value_ClientRealm_get_usersLimit_1;
  return_value_ClientRealm_get_usersLimit_1=ClientRealm_get_usersLimit(cr);
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)return_value_ClientRealm_get_usersLimit_1, sizeof(struct anonymous_7 *) /*8ul*/ );
  usersTable = (struct anonymous_7 **)return_value_calloc_2;
  if(usersTable == ((struct anonymous_7 **)NULL))
  {
    aflog((char)4, (char)1, "Calloc error - unable to successfully communicate with server");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_3;
      return_value_ClientRealm_get_masterSslFd_3=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd_4;
      return_value_SslFd_get_fd_4=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_3);
      close(return_value_SslFd_get_fd_4);
      return 1;
    }
  }

  ClientRealm_set_usersTable(cr, usersTable);
  i = 0;
  signed int return_value_ClientRealm_get_usersLimit_5;
  do
  {
    return_value_ClientRealm_get_usersLimit_5=ClientRealm_get_usersLimit(cr);
    if(i >= return_value_ClientRealm_get_usersLimit_5)
      break;

    usersTable[(signed long int)i]=ConnectUser_new();
    if(usersTable[(signed long int)i] == ((struct anonymous_7 *)NULL))
    {
      aflog((char)4, (char)1, "Calloc error - unable to successfully communicate with server");
      if(!(wanttoexit == 0))
        exit(1);

      else
      {
        struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_6;
        return_value_ClientRealm_get_masterSslFd_6=ClientRealm_get_masterSslFd(cr);
        signed int return_value_SslFd_get_fd_7;
        return_value_SslFd_get_fd_7=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_6);
        close(return_value_SslFd_get_fd_7);
        return 1;
      }
    }

    i = i + 1;
  }
  while((_Bool)1);
  len = (unsigned int)4;
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_10;
  return_value_ClientRealm_get_masterSslFd_10=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd_11;
  return_value_SslFd_get_fd_11=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_10);
  signed int return_value_getsockopt_12;
  return_value_getsockopt_12=getsockopt(return_value_SslFd_get_fd_11, 1, 7, (void *)buflength, &len);
  if(return_value_getsockopt_12 == -1)
  {
    aflog((char)4, (char)1, "Can't get socket send buffer size - exiting...");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_8;
      return_value_ClientRealm_get_masterSslFd_8=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd_9;
      return_value_SslFd_get_fd_9=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_8);
      close(return_value_SslFd_get_fd_9);
      return 2;
    }
  }

  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_11) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&allset->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  do
  {
    signed int initialize_client_stage3__1__5____d0;
    signed int initialize_client_stage3__1__5____d1;
    asm("cld; rep; stosq" : "=c"(initialize_client_stage3__1__5____d0), "=D"(initialize_client_stage3__1__5____d1) : "a"(0), "0"(sizeof(struct anonymous_11) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&wset->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_13;
  return_value_ClientRealm_get_masterSslFd_13=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd_14;
  return_value_SslFd_get_fd_14=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_13);
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_15;
  return_value_ClientRealm_get_masterSslFd_15=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd_16;
  return_value_SslFd_get_fd_16=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_15);
  allset->__fds_bits[(signed long int)(return_value_SslFd_get_fd_14 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = allset->__fds_bits[(signed long int)(return_value_SslFd_get_fd_14 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_SslFd_get_fd_16 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_17;
  return_value_ClientRealm_get_masterSslFd_17=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd_18;
  return_value_SslFd_get_fd_18=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_17);
  *maxfdp1 = return_value_SslFd_get_fd_18 + 1;
  return 0;
}

// initialize_http_proxy_client
// file http_proxy_client.c line 531
signed int initialize_http_proxy_client(signed int *sockfd, struct anonymous_5 *cr, struct ssl_ctx_st *ctx)
{
  signed int retval;
  signed int sockets[2l];
  unsigned long int proxy_thread;
  signed int return_value_socketpair_1;
  return_value_socketpair_1=socketpair(1, 1, 0, sockets);
  if(!(return_value_socketpair_1 == 0))
    return 1;

  else
  {
    *sockfd = sockets[(signed long int)0];
    struct anonymous *return_value_ClientRealm_get_httpProxyOptions_2;
    return_value_ClientRealm_get_httpProxyOptions_2=ClientRealm_get_httpProxyOptions(cr);
    char *return_value_HttpProxyOptions_get_proxyname_3;
    return_value_HttpProxyOptions_get_proxyname_3=HttpProxyOptions_get_proxyname(return_value_ClientRealm_get_httpProxyOptions_2);
    if(return_value_HttpProxyOptions_get_proxyname_3 == ((char *)NULL))
      return 1;

    else
    {
      start_critical_section();
      static struct anonymous_19 arg;
      arg.host=ClientRealm_get_serverName(cr);
      arg.serv=ClientRealm_get_managePort(cr);
      arg.hpo=ClientRealm_get_httpProxyOptions(cr);
      arg.type=ClientRealm_get_ipFamily(cr);
      arg.sockfd = sockets[(signed long int)1];
      arg.ctx = ctx;
      retval=pthread_create(&proxy_thread, (const union pthread_attr_t *)(void *)0, http_proxy_client, (void *)&arg);
      wait_for_condition();
      end_critical_section();
      return retval;
    }
  }
}

// initializelogging
// file logging.h line 71
void initializelogging(char verl, char *dateformat)
{
  signed int k;
  k=loginit(verl, dateformat);
  if(!(k == 0))
  {
    switch(k)
    {
      case 1:
      {
        printf("Wrong format of the logcmd\n");
        break;
      }
      case 2:
      {
        printf("Unknown type of the logging target\n");
        break;
      }
      case 3:
      {
        printf("Wrong description of the logging target (name too long)\n");
        break;
      }
      case 4:
      {
        printf("Can't open file to log to\n");
        break;
      }
      case 5:
      {
        printf("Can't connect to target host\n");
        break;
      }
      case 6:
        printf("Wrong msgtype/importance description\n");
    }
    exit(1);
  }

}

// ip_connect
// file network.h line 40
signed int ip_connect(signed int *sockfd, const char *host, const char *serv, const char type, const char *lhost, const char *lserv)
{
  const signed int on = 1;
  signed int n;
  signed int bindFailed;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ressave;
  struct addrinfo lhints;
  struct addrinfo *lres;
  struct addrinfo *lressave = (struct addrinfo *)(void *)0;
  aflog((char)4, (char)4, "ip_connect: host=[%s] serv=[%s], type=[%d], lhost=[%s], lserv=[%s]", host, serv, type, lhost, lserv);
  bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
  if(!((0x02 & (signed int)type) == 0))
    hints.ai_family = 2;

  else
    if(!((0x04 & (signed int)type) == 0))
      hints.ai_family = 10;

    else
      hints.ai_family = 0;
  if(!((0x01 & (signed int)type) == 0))
    hints.ai_socktype = 1;

  else
    hints.ai_socktype = 2;
  lhints = hints;
  if(!(lhost == ((const char *)NULL)) || !(lserv == ((const char *)NULL)))
  {
    n=getaddrinfo(lhost, lserv, &lhints, &lres);
    if(!(n == 0))
      return n;

    lressave = lres;
  }

  n=getaddrinfo(host, serv, &hints, &res);
  if(!(n == 0))
    return n;

  else
  {
    ressave = res;
    do
    {
      *sockfd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if(*sockfd >= 0)
      {
        if(!((0x01 & (signed int)type) == 0))
          setsockopt(*sockfd, 1, 9, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );

        bindFailed = 0;
        if(!(lhost == ((const char *)NULL)) || !(lserv == ((const char *)NULL)))
        {
          bindFailed = 1;
          lres = lressave;
          do
          {
            signed int return_value_bind_1;
            return_value_bind_1=bind(*sockfd, lres->ai_addr, lres->ai_addrlen);
            if(return_value_bind_1 == 0)
            {
              bindFailed = 0;
              break;
            }

            lres = lres->ai_next;
          }
          while(!(lres == ((struct addrinfo *)NULL)));
        }

        if(bindFailed == 1)
          close(*sockfd);

        else
        {
          signed int return_value_connect_2;
          return_value_connect_2=connect(*sockfd, res->ai_addr, res->ai_addrlen);
          if(return_value_connect_2 == 0)
            break;

          close(*sockfd);
        }
      }

      res = res->ai_next;
    }
    while(!(res == ((struct addrinfo *)NULL)));
    if(res == ((struct addrinfo *)NULL))
      return 1;

    else
    {
      if(!(lhost == ((const char *)NULL)) || !(lserv == ((const char *)NULL)))
        freeaddrinfo(lressave);

      freeaddrinfo(ressave);
      return 0;
    }
  }
}

// ip_listen
// file network.h line 39
signed int ip_listen(signed int *sockfd, const char *host, const char *serv, unsigned int *addrlenp, const char type)
{
  const signed int on = 1;
  signed int n;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ressave;
  aflog((char)4, (char)4, "ip_listen: host=[%s] serv=[%s], type=[%d]", host, serv, type);
  bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_flags = 0x0001;
  if(!((0x02 & (signed int)type) == 0))
    hints.ai_family = 2;

  else
    if(!((0x04 & (signed int)type) == 0))
      hints.ai_family = 10;

    else
      hints.ai_family = 0;
  if(!((0x01 & (signed int)type) == 0))
    hints.ai_socktype = 1;

  else
    hints.ai_socktype = 2;
  n=getaddrinfo(host, serv, &hints, &res);
  if(!(n == 0))
    return n;

  else
  {
    ressave = res;
    do
    {
      *sockfd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if(*sockfd >= 0)
      {
        if(!((0x01 & (signed int)type) == 0))
        {
          setsockopt(*sockfd, 1, 2, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );
          setsockopt(*sockfd, 1, 9, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );
        }

        signed int return_value_bind_1;
        return_value_bind_1=bind(*sockfd, res->ai_addr, res->ai_addrlen);
        if(return_value_bind_1 == 0)
          break;

        close(*sockfd);
      }

      res = res->ai_next;
    }
    while(!(res == ((struct addrinfo *)NULL)));
    if(res == ((struct addrinfo *)NULL))
      return 1;

    else
    {
      if(!((0x01 & (signed int)type) == 0))
        listen(*sockfd, 1);

      if(!(addrlenp == ((unsigned int *)NULL)))
        *addrlenp = res->ai_addrlen;

      freeaddrinfo(ressave);
      return 0;
    }
  }
}

// is_this_a_mainthread
// file thread_management.c line 50
signed int is_this_a_mainthread(void)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  if(return_value_pthread_self_1 == mainthread)
    return 1;

  else
    return 0;
}

// localdate
// file logging.c line 68
char * localdate(signed long int *sec)
{
  struct tm *tm;
  tm=localtime(sec);
  static char localdat[31l];
  memset((void *)localdat, 0, (unsigned long int)31);
  strftime(localdat, (unsigned long int)30, format, tm);
  return localdat;
}

// loginit
// file logging.c line 334
signed int loginit(char verl, char *dateformat)
{
  struct llnode *ptr;
  signed int n;
  verlev = (char)0;
  if(!(verl == 0))
    switch((signed int)verl)
    {
      case 1:
      {
        verlev = (char)(16 | 1);
        break;
      }
      case 2:
      {
        verlev = (char)(8 | 16 | 1);
        break;
      }
      case 3:
      {
        verlev = (char)(8 | 16 | 32 | 1);
        break;
      }
      case 4:
      {
        verlev = (char)(8 | 16 | 32 | 64 | 1);
        break;
      }
      case 5:
      {
        verlev = (char)(8 | 16 | 32 | 64 | 1 | 2);
        break;
      }
      default:
        verlev = (char)(1 | 2 | 4 | 8 | 16 | 32 | 64);
    }

  setdateformat(dateformat);
  ptr = head;
  for( ; !(ptr == ((struct llnode *)NULL)); ptr = ptr->next)
  {
    n=checklogtarget(ptr);
    if(!(n == 0))
      return n;

  }
  return 0;
}

// main
// file afclient.c line 75
signed int main(signed int argc, char **argv)
{
  signed int i;
  signed int n;
  signed int numofcon;
  signed int length;
  signed int buflength;
  signed int temp;
  signed int temp2 = 0;
  signed int notsent;
  unsigned int aLength;
  struct anonymous_7 **usersTable = (struct anonymous_7 **)(void *)0;
  unsigned char buff[9000l];
  char hostname[100l];
  signed int maxfdp1;
  unsigned int addressLength;
  struct sockaddr *clientAddress;
  struct anonymous_11 rset;
  struct anonymous_11 allset;
  struct anonymous_11 wset;
  struct anonymous_11 tmpset;
  struct timeval keepAlive;
  char verbose = (char)0;
  struct anonymous *hpo;
  hpo=HttpProxyOptions_new();
  char hpoUsed = (char)0;
  struct anonymous_3 *ao;
  ao=ArOptions_new();
  struct anonymous_5 *pointer;
  char aoUsed = (char)0;
  char passwordWasSet = (char)0;
  char *realmId = (char *)(void *)0;
  char *serverName = (char *)(void *)0;
  char *managePort = (char *)(void *)0;
  char *hostName = (char *)(void *)0;
  struct portlist *destinationPorts;
  destinationPorts=PortList_new();
  char *localName = (char *)(void *)0;
  char *localPort = (char *)(void *)0;
  char *localDestinationName = (char *)(void *)0;
  char *keys = (char *)(void *)0;
  char *certif = (char *)(void *)0;
  char *store = (char *)(void *)0;
  char *dateformat = (char *)(void *)0;
  char *kaTimeout = (char *)(void *)0;
  char *filenam = (char *)(void *)0;
  char ipFamily = (char)0;
  unsigned char password[4l] = { (unsigned char)1, (unsigned char)2, (unsigned char)3, (unsigned char)4 };
  char udpMode = (char)0;
  char reverseMode = (char)0;
  char remoteMode = (char)0;
  char realmType = (char)0;
  char ignorePublicKeys = (char)0;
  struct sigaction act;
  struct anonymous_6 *moduleA;
  moduleA=Module_new();
  struct anonymous_6 *moduleB;
  moduleB=Module_new();
  struct ssl_method_st *method;
  struct ssl_ctx_st *ctx = (struct ssl_ctx_st *)(void *)0;
  if(hpo == ((struct anonymous *)NULL))
  {
    printf("Problems with memory allocation... exiting\n");
    exit(1);
  }

  if(ao == ((struct anonymous_3 *)NULL))
  {
    printf("Problems with memory allocation... exiting\n");
    exit(1);
  }

  if(moduleA == ((struct anonymous_6 *)NULL) || moduleB == ((struct anonymous_6 *)NULL))
  {
    printf("Problems with memory allocation... exiting\n");
    exit(1);
  }

  sigfillset(&act.sa_mask);
  act.sa_flags = 0;
  act.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sigaction(13, &act, (struct sigaction *)(void *)0);
  act.__sigaction_handler.sa_handler = client_sig_int;
  sigaction(2, &act, (struct sigaction *)(void *)0);
  sigaction(15, &act, (struct sigaction *)(void *)0);
  act.__sigaction_handler.sa_handler = client_sig_alrm;
  sigaction(14, &act, (struct sigaction *)(void *)0);
  remember_mainthread();
  struct plnode *return_value_PortListNode_new_1;
  unsigned long int return_value_strlen_2;
  do
  {
    n=getopt_long(argc, argv, "l:L:SP:X:BC:46huUn:m:d:p:vk:c:s:o:i:D:rP:X:VK:A:T:f:", long_options, ((signed int *)NULL));
    if(n == -1)
      break;

    switch(n)
    {
      case 104:
      {
        client_long_usage("Active port forwarder (client) v0.8.4");
        break;
      }
      case 110:
      {
        serverName = optarg;
        break;
      }
      case 83:
      {
        HttpProxyOptions_use_https(hpo);
        hpoUsed = (char)1;
        break;
      }
      case 80:
      {
        HttpProxyOptions_set_proxyname(hpo, optarg);
        hpoUsed = (char)1;
        break;
      }
      case 88:
      {
        HttpProxyOptions_set_proxyport(hpo, optarg);
        hpoUsed = (char)1;
        break;
      }
      case 66:
      {
        HttpProxyOptions_set_proxyauth_type(hpo, (char)1);
        hpoUsed = (char)1;
        break;
      }
      case 67:
      {
        HttpProxyOptions_set_proxyauth_cred(hpo, optarg);
        hpoUsed = (char)1;
        break;
      }
      case 105:
      {
        realmId = optarg;
        break;
      }
      case 109:
      {
        managePort = optarg;
        break;
      }
      case 100:
      {
        hostName = optarg;
        break;
      }
      case 112:
      {
        return_value_PortListNode_new_1=PortListNode_new(optarg);
        PortList_insert_back(destinationPorts, return_value_PortListNode_new_1);
        break;
      }
      case 118:
      {
        verbose = verbose + 1;
        break;
      }
      case 117:
      {
        udpMode = (char)1;
        break;
      }
      case 85:
      {
        reverseMode = (char)1;
        break;
      }
      case 107:
      {
        keys = optarg;
        break;
      }
      case 99:
      {
        certif = optarg;
        break;
      }
      case 115:
      {
        store = optarg;
        break;
      }
      case 102:
      {
        filenam = optarg;
        break;
      }
      case 111:
      {
        addlogtarget(optarg);
        break;
      }
      case 301:
      {
        return_value_strlen_2=strlen(optarg);
        n = (signed int)return_value_strlen_2;
        memset((void *)password, 0, (unsigned long int)4);
        i = 0;
        for( ; !(i >= n); i = i + 1)
          password[(signed long int)(i % 4)] = password[(signed long int)(i % 4)] + (unsigned char)optarg[(signed long int)i];
        passwordWasSet = (char)1;
        break;
      }
      case 302:
      {
        ignorePublicKeys = (char)1;
        break;
      }
      case 305:
      {
        ArOptions_set_arStart(ao, (char)1);
        aoUsed = (char)1;
        break;
      }
      case 306:
      {
        ArOptions_set_arQuit(ao, (char)1);
        aoUsed = (char)1;
        break;
      }
      case 307:
      {
        ArOptions_set_arPremature(ao, (char)0);
        aoUsed = (char)1;
        break;
      }
      case 311:
      {
        localName = optarg;
        break;
      }
      case 312:
      {
        localPort = optarg;
        break;
      }
      case 313:
      {
        localDestinationName = optarg;
        break;
      }
      case 52:
      {
        if(!((signed int)ipFamily == 0))
          ipFamily = (char)-1;

        else
          ipFamily = (char)4;
        break;
      }
      case 54:
      {
        if(!((signed int)ipFamily == 0))
          ipFamily = (char)-1;

        else
          ipFamily = (char)6;
        break;
      }
      case 108:
      {
        Module_set_fileName(moduleA, optarg);
        break;
      }
      case 76:
      {
        Module_set_fileName(moduleB, optarg);
        break;
      }
      case 68:
      {
        dateformat = optarg;
        break;
      }
      case 114:
      {
        remoteMode = (char)1;
        break;
      }
      case 86:
      {
        printf("%s\n", (const void *)"Active port forwarder (client) v0.8.4");
        exit(0);
        break;
      }
      case 75:
      {
        kaTimeout = optarg;
        break;
      }
      case 65:
      {
        ArOptions_set_s_arTries(ao, optarg);
        aoUsed = (char)1;
        break;
      }
      case 84:
      {
        ArOptions_set_s_arDelay(ao, optarg);
        aoUsed = (char)1;
        break;
      }
      case 63:
        client_short_usage("");
    }
  }
  while((_Bool)1);
  if(!(optind >= argc))
    client_short_usage("Unrecognized non-option elements");

  _Bool tmp_if_expr_9;
  struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_8;
  _Bool tmp_if_expr_11;
  struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_10;
  char *return_value_ClientRealm_get_serverName_12;
  char *return_value_ClientRealm_get_managePort_13;
  char *return_value_ClientRealm_get_hostName_14;
  struct portlist *return_value_ClientRealm_get_destinationPorts_15;
  signed int return_value_PortList_get_size_16;
  char *return_value_ClientRealm_get_realmId_18;
  char *return_value_ClientRealm_get_localName_19;
  char *return_value_ClientRealm_get_localPort_20;
  char *return_value_ClientRealm_get_sKeepAliveTimeout_22;
  if(!(filenam == ((char *)NULL)))
  {
    cconfig=cparsefile(filenam, &n);
    if(!(n == 0))
    {
      printf("parsing failed! line:%d\n", n);
      exit(1);
    }

    else
    {
      if(keys == ((char *)NULL))
      {
        char *return_value_ClientConfiguration_get_keysFile_3;
        return_value_ClientConfiguration_get_keysFile_3=ClientConfiguration_get_keysFile(cconfig);
        if(return_value_ClientConfiguration_get_keysFile_3 == ((char *)NULL))
          ClientConfiguration_set_keysFile(cconfig, "client.rsa");

      }

      else
        ClientConfiguration_set_keysFile(cconfig, keys);
      if(!(certif == ((char *)NULL)))
        ClientConfiguration_set_certificateFile(cconfig, certif);

      if(store == ((char *)NULL))
      {
        char *return_value_ClientConfiguration_get_storeFile_4;
        return_value_ClientConfiguration_get_storeFile_4=ClientConfiguration_get_storeFile(cconfig);
        if(return_value_ClientConfiguration_get_storeFile_4 == ((char *)NULL))
          ClientConfiguration_set_storeFile(cconfig, "known_hosts");

      }

      else
        ClientConfiguration_set_storeFile(cconfig, store);
      if(!(dateformat == ((char *)NULL)))
        ClientConfiguration_set_dateFormat(cconfig, dateformat);

      if(!(ignorePublicKeys == 0))
        ClientConfiguration_set_ignorePublicKeys(cconfig, ignorePublicKeys);

      char *return_value_ClientConfiguration_get_dateFormat_5;
      return_value_ClientConfiguration_get_dateFormat_5=ClientConfiguration_get_dateFormat(cconfig);
      initializelogging(verbose, return_value_ClientConfiguration_get_dateFormat_5);
      signed int return_value_ClientConfiguration_get_realmsNumber_6;
      return_value_ClientConfiguration_get_realmsNumber_6=ClientConfiguration_get_realmsNumber(cconfig);
      aflog((char)4, (char)8, "client's cfg file OK! (readed realms: %d)", return_value_ClientConfiguration_get_realmsNumber_6);
      signed int return_value_ClientConfiguration_get_realmsNumber_7;
      return_value_ClientConfiguration_get_realmsNumber_7=ClientConfiguration_get_realmsNumber(cconfig);
      if(return_value_ClientConfiguration_get_realmsNumber_7 == 0)
        tmp_if_expr_9 = (_Bool)1;

      else
      {
        return_value_ClientConfiguration_get_realmsTable_8=ClientConfiguration_get_realmsTable(cconfig);
        tmp_if_expr_9 = return_value_ClientConfiguration_get_realmsTable_8 == (struct anonymous_5 **)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_9)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        return_value_ClientConfiguration_get_realmsTable_10=ClientConfiguration_get_realmsTable(cconfig);
        pointer = return_value_ClientConfiguration_get_realmsTable_10[(signed long int)0];
        tmp_if_expr_11 = pointer == (struct anonymous_5 *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
      {
        aflog((char)4, (char)1, "Working without sense is really without sense...");
        exit(1);
      }

      if(!(hpoUsed == 0))
        ClientRealm_set_httpProxyOptions(pointer, hpo);

      else
        HttpProxyOptions_free(&hpo);
      if(!(aoUsed == 0))
        ClientRealm_set_arOptions(pointer, ao);

      else
        ArOptions_free(&ao);
      if(!(serverName == ((char *)NULL)))
      {
        return_value_ClientRealm_get_serverName_12=ClientRealm_get_serverName(pointer);
        if(return_value_ClientRealm_get_serverName_12 == ((char *)NULL))
          ClientRealm_set_serverName(pointer, serverName);

      }

      if(!(managePort == ((char *)NULL)))
      {
        return_value_ClientRealm_get_managePort_13=ClientRealm_get_managePort(pointer);
        if(return_value_ClientRealm_get_managePort_13 == ((char *)NULL))
          ClientRealm_set_managePort(pointer, managePort);

      }

      if(!(hostName == ((char *)NULL)))
      {
        return_value_ClientRealm_get_hostName_14=ClientRealm_get_hostName(pointer);
        if(return_value_ClientRealm_get_hostName_14 == ((char *)NULL))
          ClientRealm_set_hostName(pointer, hostName);

      }

      signed int return_value_PortList_get_size_17;
      return_value_PortList_get_size_17=PortList_get_size(destinationPorts);
      if(!(return_value_PortList_get_size_17 == 0))
      {
        return_value_ClientRealm_get_destinationPorts_15=ClientRealm_get_destinationPorts(pointer);
        return_value_PortList_get_size_16=PortList_get_size(return_value_ClientRealm_get_destinationPorts_15);
        if(return_value_PortList_get_size_16 == 0)
          ClientRealm_set_destinationPorts(pointer, destinationPorts);

      }

      if(!(realmId == ((char *)NULL)))
      {
        return_value_ClientRealm_get_realmId_18=ClientRealm_get_realmId(pointer);
        if(return_value_ClientRealm_get_realmId_18 == ((char *)NULL))
          ClientRealm_set_realmId(pointer, realmId);

      }

      if(!(localName == ((char *)NULL)))
      {
        return_value_ClientRealm_get_localName_19=ClientRealm_get_localName(pointer);
        if(return_value_ClientRealm_get_localName_19 == ((char *)NULL))
          ClientRealm_set_localName(pointer, localName);

      }

      if(!(localPort == ((char *)NULL)))
      {
        return_value_ClientRealm_get_localPort_20=ClientRealm_get_localPort(pointer);
        if(return_value_ClientRealm_get_localPort_20 == ((char *)NULL))
          ClientRealm_set_localPort(pointer, localPort);

      }

      char *return_value_ClientRealm_get_localDestinationName_21;
      return_value_ClientRealm_get_localDestinationName_21=ClientRealm_get_localDestinationName(pointer);
      if(return_value_ClientRealm_get_localDestinationName_21 == ((char *)NULL) && !(localDestinationName == ((char *)NULL)))
        ClientRealm_set_localDestinationName(pointer, localDestinationName);

      if(!(kaTimeout == ((char *)NULL)))
      {
        return_value_ClientRealm_get_sKeepAliveTimeout_22=ClientRealm_get_sKeepAliveTimeout(pointer);
        if(return_value_ClientRealm_get_sKeepAliveTimeout_22 == ((char *)NULL))
          ClientRealm_set_sKeepAliveTimeout(pointer, kaTimeout);

      }

      if(!(reverseMode == 0))
        aflog((char)4, (char)32, "Warning: reverseudp will be ignored");

      if(!(udpMode == 0))
        aflog((char)4, (char)32, "Warning: udpmode will be ignored");

      if(!(remoteMode == 0))
        aflog((char)4, (char)32, "Warning: remoteadmin will be ignored");

      if(!(passwordWasSet == 0))
        aflog((char)4, (char)32, "Warning: pass will be ignored");

      char *return_value_Module_get_fileName_23;
      return_value_Module_get_fileName_23=Module_get_fileName(moduleA);
      if(!(return_value_Module_get_fileName_23 == ((char *)NULL)))
        aflog((char)4, (char)32, "Warning: load will be ignored");

      char *return_value_Module_get_fileName_24;
      return_value_Module_get_fileName_24=Module_get_fileName(moduleB);
      if(!(return_value_Module_get_fileName_24 == ((char *)NULL)))
        aflog((char)4, (char)32, "Warning: Load will be ignored");

    }
  }

  else
  {
    cconfig=ClientConfiguration_new();
    if(cconfig == ((struct anonymous_4 *)NULL))
    {
      printf("Can't allocate memory for client configuration... exiting\n");
      exit(1);
    }

    ClientConfiguration_set_keysFile(cconfig, keys);
    ClientConfiguration_set_certificateFile(cconfig, certif);
    ClientConfiguration_set_storeFile(cconfig, store);
    ClientConfiguration_set_dateFormat(cconfig, dateformat);
    ClientConfiguration_set_realmsNumber(cconfig, 1);
    ClientConfiguration_set_ignorePublicKeys(cconfig, ignorePublicKeys);
    char *return_value_ClientConfiguration_get_dateFormat_25;
    return_value_ClientConfiguration_get_dateFormat_25=ClientConfiguration_get_dateFormat(cconfig);
    initializelogging(verbose, return_value_ClientConfiguration_get_dateFormat_25);
    char *return_value_ClientConfiguration_get_keysFile_26;
    return_value_ClientConfiguration_get_keysFile_26=ClientConfiguration_get_keysFile(cconfig);
    if(return_value_ClientConfiguration_get_keysFile_26 == ((char *)NULL))
      ClientConfiguration_set_keysFile(cconfig, "client.rsa");

    char *return_value_ClientConfiguration_get_storeFile_27;
    return_value_ClientConfiguration_get_storeFile_27=ClientConfiguration_get_storeFile(cconfig);
    if(return_value_ClientConfiguration_get_storeFile_27 == ((char *)NULL))
      ClientConfiguration_set_storeFile(cconfig, "known_hosts");

    signed int return_value_ClientConfiguration_get_realmsNumber_28;
    return_value_ClientConfiguration_get_realmsNumber_28=ClientConfiguration_get_realmsNumber(cconfig);
    void *return_value_calloc_29;
    return_value_calloc_29=calloc((unsigned long int)return_value_ClientConfiguration_get_realmsNumber_28, sizeof(struct anonymous_5 *) /*8ul*/ );
    ClientConfiguration_set_realmsTable(cconfig, (struct anonymous_5 **)return_value_calloc_29);
    struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_30;
    return_value_ClientConfiguration_get_realmsTable_30=ClientConfiguration_get_realmsTable(cconfig);
    if(return_value_ClientConfiguration_get_realmsTable_30 == ((struct anonymous_5 **)NULL))
    {
      aflog((char)4, (char)1, "Can't allocate memory for ClientRealm* table... exiting");
      exit(1);
    }

    pointer=ClientRealm_new();
    if(pointer == ((struct anonymous_5 *)NULL))
    {
      aflog((char)4, (char)1, "Can't allocate memory for ClientRealm structure... exiting");
      exit(1);
    }

    struct anonymous_5 **return_value_ClientConfiguration_get_realmsTable_31;
    return_value_ClientConfiguration_get_realmsTable_31=ClientConfiguration_get_realmsTable(cconfig);
    return_value_ClientConfiguration_get_realmsTable_31[(signed long int)0] = pointer;
    ClientRealm_set_serverName(pointer, serverName);
    ClientRealm_set_managePort(pointer, managePort);
    ClientRealm_set_hostName(pointer, hostName);
    ClientRealm_set_destinationPorts(pointer, destinationPorts);
    ClientRealm_set_realmId(pointer, realmId);
    ClientRealm_set_httpProxyOptions(pointer, hpo);
    ClientRealm_set_arOptions(pointer, ao);
    ClientRealm_set_password(pointer, password);
    ClientRealm_set_localName(pointer, localName);
    ClientRealm_set_localPort(pointer, localPort);
    ClientRealm_set_localDestinationName(pointer, localDestinationName);
    ClientRealm_set_realmId(pointer, realmId);
    ClientRealm_set_sKeepAliveTimeout(pointer, kaTimeout);
    ClientRealm_set_userModule(pointer, moduleA);
    ClientRealm_set_serviceModule(pointer, moduleB);
    if(!(reverseMode == 0))
    {
      signed int return_value_ClientRealm_get_clientMode_32;
      return_value_ClientRealm_get_clientMode_32=ClientRealm_get_clientMode(pointer);
      if(return_value_ClientRealm_get_clientMode_32 == 0)
        ClientRealm_set_clientMode(pointer, 3);

      else
        ClientRealm_set_clientMode(pointer, -1);
    }

    if(!(udpMode == 0))
    {
      signed int return_value_ClientRealm_get_clientMode_33;
      return_value_ClientRealm_get_clientMode_33=ClientRealm_get_clientMode(pointer);
      if(return_value_ClientRealm_get_clientMode_33 == 0)
        ClientRealm_set_clientMode(pointer, 1);

      else
        ClientRealm_set_clientMode(pointer, -1);
    }

    if(!(remoteMode == 0))
    {
      signed int return_value_ClientRealm_get_clientMode_34;
      return_value_ClientRealm_get_clientMode_34=ClientRealm_get_clientMode(pointer);
      if(return_value_ClientRealm_get_clientMode_34 == 0)
        ClientRealm_set_clientMode(pointer, 2);

      else
        ClientRealm_set_clientMode(pointer, -1);
    }

  }
  char *return_value_ClientRealm_get_serverName_35;
  return_value_ClientRealm_get_serverName_35=ClientRealm_get_serverName(pointer);
  if(return_value_ClientRealm_get_serverName_35 == ((char *)NULL))
    client_short_usage("Name of the server is required");

  signed int return_value_ClientRealm_get_clientMode_36;
  return_value_ClientRealm_get_clientMode_36=ClientRealm_get_clientMode(pointer);
  if(return_value_ClientRealm_get_clientMode_36 == -1)
  {
    aflog((char)4, (char)1, "Conflicting/unknown client modes... exiting");
    exit(1);
  }

  char *return_value_ClientRealm_get_managePort_38;
  return_value_ClientRealm_get_managePort_38=ClientRealm_get_managePort(pointer);
  if(return_value_ClientRealm_get_managePort_38 == ((char *)NULL))
  {
    ClientRealm_set_managePort(pointer, "50126");
    signed int return_value_ClientRealm_get_clientMode_37;
    return_value_ClientRealm_get_clientMode_37=ClientRealm_get_clientMode(pointer);
    if(return_value_ClientRealm_get_clientMode_37 == 3)
      client_short_usage("Port on the server is required in reverse mode");

  }

  struct anonymous *return_value_ClientRealm_get_httpProxyOptions_40;
  return_value_ClientRealm_get_httpProxyOptions_40=ClientRealm_get_httpProxyOptions(pointer);
  char *return_value_HttpProxyOptions_get_proxyname_41;
  return_value_HttpProxyOptions_get_proxyname_41=HttpProxyOptions_get_proxyname(return_value_ClientRealm_get_httpProxyOptions_40);
  _Bool tmp_if_expr_44;
  struct anonymous *return_value_ClientRealm_get_httpProxyOptions_42;
  char *return_value_HttpProxyOptions_get_proxyport_43;
  if(!(return_value_HttpProxyOptions_get_proxyname_41 == ((char *)NULL)))
    tmp_if_expr_44 = (_Bool)1;

  else
  {
    return_value_ClientRealm_get_httpProxyOptions_42=ClientRealm_get_httpProxyOptions(pointer);
    return_value_HttpProxyOptions_get_proxyport_43=HttpProxyOptions_get_proxyport(return_value_ClientRealm_get_httpProxyOptions_42);
    tmp_if_expr_44 = return_value_HttpProxyOptions_get_proxyport_43 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_44)
  {
    char return_value_ClientRealm_get_tunnelType_39;
    return_value_ClientRealm_get_tunnelType_39=ClientRealm_get_tunnelType(pointer);
    if((signed int)return_value_ClientRealm_get_tunnelType_39 == 0)
      ClientRealm_set_tunnelType(pointer, (char)1);

    else
      ClientRealm_set_tunnelType(pointer, (char)-1);
  }

  char return_value_ClientRealm_get_tunnelType_48;
  return_value_ClientRealm_get_tunnelType_48=ClientRealm_get_tunnelType(pointer);
  if((signed int)return_value_ClientRealm_get_tunnelType_48 == 1)
  {
    struct anonymous *return_value_ClientRealm_get_httpProxyOptions_46;
    return_value_ClientRealm_get_httpProxyOptions_46=ClientRealm_get_httpProxyOptions(pointer);
    char *return_value_HttpProxyOptions_get_proxyport_47;
    return_value_HttpProxyOptions_get_proxyport_47=HttpProxyOptions_get_proxyport(return_value_ClientRealm_get_httpProxyOptions_46);
    if(return_value_HttpProxyOptions_get_proxyport_47 == ((char *)NULL))
    {
      struct anonymous *return_value_ClientRealm_get_httpProxyOptions_45;
      return_value_ClientRealm_get_httpProxyOptions_45=ClientRealm_get_httpProxyOptions(pointer);
      HttpProxyOptions_set_proxyport(return_value_ClientRealm_get_httpProxyOptions_45, "8080");
    }

  }

  signed int return_value_ClientRealm_get_clientMode_51;
  return_value_ClientRealm_get_clientMode_51=ClientRealm_get_clientMode(pointer);
  signed int return_value_ClientRealm_get_clientMode_50;
  char *return_value_ClientRealm_get_hostName_49;
  if(!(return_value_ClientRealm_get_clientMode_51 == 3))
  {
    return_value_ClientRealm_get_clientMode_50=ClientRealm_get_clientMode(pointer);
    if(!(return_value_ClientRealm_get_clientMode_50 == 2))
    {
      return_value_ClientRealm_get_hostName_49=ClientRealm_get_hostName(pointer);
      if(return_value_ClientRealm_get_hostName_49 == ((char *)NULL))
      {
        gethostname(hostname, (unsigned long int)100);
        ClientRealm_set_hostName(pointer, hostname);
      }

    }

  }

  signed int return_value_ClientRealm_get_clientMode_54;
  return_value_ClientRealm_get_clientMode_54=ClientRealm_get_clientMode(pointer);
  struct portlist *return_value_ClientRealm_get_destinationPorts_52;
  signed int return_value_PortList_get_size_53;
  if(!(return_value_ClientRealm_get_clientMode_54 == 2))
  {
    return_value_ClientRealm_get_destinationPorts_52=ClientRealm_get_destinationPorts(pointer);
    return_value_PortList_get_size_53=PortList_get_size(return_value_ClientRealm_get_destinationPorts_52);
    if(return_value_PortList_get_size_53 == 0)
      client_short_usage("Destination port number is required");

  }

  char *return_value_ClientRealm_get_sKeepAliveTimeout_58;
  return_value_ClientRealm_get_sKeepAliveTimeout_58=ClientRealm_get_sKeepAliveTimeout(pointer);
  if(!(return_value_ClientRealm_get_sKeepAliveTimeout_58 == ((char *)NULL)))
  {
    char *return_value_ClientRealm_get_sKeepAliveTimeout_55;
    return_value_ClientRealm_get_sKeepAliveTimeout_55=ClientRealm_get_sKeepAliveTimeout(pointer);
    signed int return_value_check_value_56;
    return_value_check_value_56=check_value(return_value_ClientRealm_get_sKeepAliveTimeout_55, "Invalid timeout value");
    ClientRealm_set_keepAliveTimeout(pointer, return_value_check_value_56);
    signed int return_value_ClientRealm_get_keepAliveTimeout_57;
    return_value_ClientRealm_get_keepAliveTimeout_57=ClientRealm_get_keepAliveTimeout(pointer);
    keepAlive.tv_sec = (signed long int)return_value_ClientRealm_get_keepAliveTimeout_57;
    keepAlive.tv_usec = (signed long int)0;
    ClientRealm_set_keepAlive(pointer, keepAlive);
  }

  struct anonymous_3 *return_value_ClientRealm_get_arOptions_59;
  return_value_ClientRealm_get_arOptions_59=ClientRealm_get_arOptions(pointer);
  ArOptions_evaluate_values(return_value_ClientRealm_get_arOptions_59);
  if(!(ignorePublicKeys == 0))
    ClientConfiguration_set_ignorePublicKeys(cconfig, ignorePublicKeys);

  struct anonymous_6 *return_value_ClientRealm_get_userModule_62;
  return_value_ClientRealm_get_userModule_62=ClientRealm_get_userModule(pointer);
  signed int return_value_Module_loadModule_63;
  return_value_Module_loadModule_63=Module_loadModule(return_value_ClientRealm_get_userModule_62);
  if(!(return_value_Module_loadModule_63 == 0))
  {
    struct anonymous_6 *return_value_ClientRealm_get_userModule_60;
    return_value_ClientRealm_get_userModule_60=ClientRealm_get_userModule(pointer);
    char *return_value_Module_get_fileName_61;
    return_value_Module_get_fileName_61=Module_get_fileName(return_value_ClientRealm_get_userModule_60);
    aflog((char)4, (char)1, "Loading a module %s failed!", return_value_Module_get_fileName_61);
    exit(1);
  }

  struct anonymous_6 *return_value_ClientRealm_get_serviceModule_66;
  return_value_ClientRealm_get_serviceModule_66=ClientRealm_get_serviceModule(pointer);
  signed int return_value_Module_loadModule_67;
  return_value_Module_loadModule_67=Module_loadModule(return_value_ClientRealm_get_serviceModule_66);
  if(!(return_value_Module_loadModule_67 == 0))
  {
    struct anonymous_6 *return_value_ClientRealm_get_serviceModule_64;
    return_value_ClientRealm_get_serviceModule_64=ClientRealm_get_serviceModule(pointer);
    char *return_value_Module_get_fileName_65;
    return_value_Module_get_fileName_65=Module_get_fileName(return_value_ClientRealm_get_serviceModule_64);
    aflog((char)4, (char)1, "Loading a module %s failed!", return_value_Module_get_fileName_65);
    exit(1);
  }

  realmType = (char)0;
  realmType = realmType | (char)4;
  realmType = realmType | (char)8;
  char return_value_ClientRealm_get_ipFamily_68;
  if(!((signed int)ipFamily == 0))
  {
    return_value_ClientRealm_get_ipFamily_68=ClientRealm_get_ipFamily(pointer);
    if(!((signed int)return_value_ClientRealm_get_ipFamily_68 >= 1))
      ClientRealm_set_ipFamily(pointer, ipFamily);

  }

  char return_value_ClientRealm_get_ipFamily_71;
  return_value_ClientRealm_get_ipFamily_71=ClientRealm_get_ipFamily(pointer);
  char return_value_ClientRealm_get_ipFamily_70;
  char return_value_ClientRealm_get_ipFamily_69;
  if((signed int)return_value_ClientRealm_get_ipFamily_71 == -1)
  {
    aflog((char)4, (char)1, "Conflicting types of ip protocol family... exiting");
    exit(1);
  }

  else
  {
    return_value_ClientRealm_get_ipFamily_70=ClientRealm_get_ipFamily(pointer);
    if((signed int)return_value_ClientRealm_get_ipFamily_70 == 4)
      realmType = realmType | (char)16;

    else
    {
      return_value_ClientRealm_get_ipFamily_69=ClientRealm_get_ipFamily(pointer);
      if((signed int)return_value_ClientRealm_get_ipFamily_69 == 6)
        realmType = realmType | (char)32;

    }
  }
  ipFamily = (char)0x01;
  if(!((16 & (signed int)realmType) == 0))
    ipFamily = ipFamily | (char)0x02;

  else
    if(!((32 & (signed int)realmType) == 0))
      ipFamily = ipFamily | (char)0x04;

  ClientRealm_set_ipFamily(pointer, ipFamily);
  ClientRealm_set_realmType(pointer, realmType);
  signed int return_value_ClientRealm_get_clientMode_94;
  return_value_ClientRealm_get_clientMode_94=ClientRealm_get_clientMode(pointer);
  char *tmp_if_expr_78;
  char return_value_ClientRealm_get_ipFamily_77;
  if(!(return_value_ClientRealm_get_clientMode_94 == 3))
  {
    SSL_library_init();
    method=SSLv3_client_method();
    ctx=SSL_CTX_new(method);
    signed int return_value_SSL_CTX_set_cipher_list_72;
    return_value_SSL_CTX_set_cipher_list_72=SSL_CTX_set_cipher_list(ctx, "ALL:@STRENGTH");
    if(return_value_SSL_CTX_set_cipher_list_72 == 0)
    {
      aflog((char)4, (char)1, "Setting cipher list failed... exiting");
      exit(1);
    }

    temp2=create_apf_dir((char)0);
    if(!(temp2 == 0))
    {
      aflog((char)4, (char)32, "Warning: Creating ~/.apf directory failed (%d)", temp2);
      temp2=create_apf_dir((char)1);
      if(!(temp2 == 0))
        aflog((char)4, (char)32, "Warning: Creating ./apf directory failed (%d)", temp2);

    }

    store=ClientConfiguration_get_storeFile(cconfig);
    temp2=create_publickey_store(&store);
    if(!(temp2 == 0))
      aflog((char)4, (char)32, "Warning: Something bad happened when creating public key store... (%d)", temp2);

    ClientConfiguration_set_storeFile(cconfig, store);
    keys=ClientConfiguration_get_keysFile(cconfig);
    temp2=generate_rsa_key(&keys);
    if(!(temp2 == 0))
      aflog((char)4, (char)32, "Warning: Something bad happened when generating rsa keys... (%d)", temp2);

    ClientConfiguration_set_keysFile(cconfig, keys);
    signed int return_value_SSL_CTX_use_RSAPrivateKey_file_73;
    return_value_SSL_CTX_use_RSAPrivateKey_file_73=SSL_CTX_use_RSAPrivateKey_file(ctx, keys, 1);
    if(!(return_value_SSL_CTX_use_RSAPrivateKey_file_73 == 1))
    {
      aflog((char)4, (char)1, "Setting rsa key failed (%s)... exiting", keys);
      exit(1);
    }

    certif=ClientConfiguration_get_certificateFile(cconfig);
    if(!(certif == ((char *)NULL)))
    {
      signed int return_value_SSL_CTX_use_certificate_file_74;
      return_value_SSL_CTX_use_certificate_file_74=SSL_CTX_use_certificate_file(ctx, certif, 1);
      if(!(return_value_SSL_CTX_use_certificate_file_74 == 1))
      {
        aflog((char)4, (char)1, "Setting certificate failed (%s)... exiting", certif);
        exit(1);
      }

    }

    signed int return_value_ClientRealm_get_clientMode_75;
    return_value_ClientRealm_get_clientMode_75=ClientRealm_get_clientMode(pointer);
    if(!(return_value_ClientRealm_get_clientMode_75 == 2))
    {
      if(verbose == 0)
        daemon(0, 0);

    }

    signed int return_value_ClientRealm_get_clientMode_93;
    return_value_ClientRealm_get_clientMode_93=ClientRealm_get_clientMode(pointer);
    if(return_value_ClientRealm_get_clientMode_93 == 2)
    {
      temp2 = -1;
      struct portlist *return_value_ClientRealm_get_destinationPorts_91;
      return_value_ClientRealm_get_destinationPorts_91=ClientRealm_get_destinationPorts(pointer);
      signed int return_value_PortList_get_size_92;
      return_value_PortList_get_size_92=PortList_get_size(return_value_ClientRealm_get_destinationPorts_91);
      if(return_value_PortList_get_size_92 >= 1)
      {
        char *return_value_ClientRealm_get_serverName_83;
        return_value_ClientRealm_get_serverName_83=ClientRealm_get_serverName(pointer);
        struct portlist *return_value_ClientRealm_get_destinationPorts_84;
        return_value_ClientRealm_get_destinationPorts_84=ClientRealm_get_destinationPorts(pointer);
        struct plnode *return_value_PortList_get_nth_85;
        return_value_PortList_get_nth_85=PortList_get_nth(return_value_ClientRealm_get_destinationPorts_84, 0);
        char *return_value_PortListNode_get_portName_86;
        return_value_PortListNode_get_portName_86=PortListNode_get_portName(return_value_PortList_get_nth_85);
        char return_value_ClientRealm_get_ipFamily_87;
        return_value_ClientRealm_get_ipFamily_87=ClientRealm_get_ipFamily(pointer);
        signed int return_value_ip_listen_88;
        return_value_ip_listen_88=ip_listen(&n, return_value_ClientRealm_get_serverName_83, return_value_PortListNode_get_portName_86, &addressLength, return_value_ClientRealm_get_ipFamily_87);
        if(!(return_value_ip_listen_88 == 0))
        {
          char return_value_ClientRealm_get_ipFamily_76;
          return_value_ClientRealm_get_ipFamily_76=ClientRealm_get_ipFamily(pointer);
          if(!((0x02 & (signed int)return_value_ClientRealm_get_ipFamily_76) == 0))
            tmp_if_expr_78 = "ipv4";

          else
          {
            return_value_ClientRealm_get_ipFamily_77=ClientRealm_get_ipFamily(pointer);
            tmp_if_expr_78 = ((signed int)return_value_ClientRealm_get_ipFamily_77 & 0x04) != 0 ? "ipv6" : "unspec";
          }
          char *return_value_ClientRealm_get_serverName_79;
          return_value_ClientRealm_get_serverName_79=ClientRealm_get_serverName(pointer);
          struct portlist *return_value_ClientRealm_get_destinationPorts_80;
          return_value_ClientRealm_get_destinationPorts_80=ClientRealm_get_destinationPorts(pointer);
          struct plnode *return_value_PortList_get_nth_81;
          return_value_PortList_get_nth_81=PortList_get_nth(return_value_ClientRealm_get_destinationPorts_80, 0);
          char *return_value_PortListNode_get_portName_82;
          return_value_PortListNode_get_portName_82=PortListNode_get_portName(return_value_PortList_get_nth_81);
          aflog((char)4, (char)1, "tcp_listen_%s error for %s, %s", tmp_if_expr_78, return_value_ClientRealm_get_serverName_79, return_value_PortListNode_get_portName_82);
          exit(1);
        }

        void *return_value_malloc_89;
        return_value_malloc_89=malloc((unsigned long int)addressLength);
        clientAddress = (struct sockaddr *)return_value_malloc_89;
        if(clientAddress == ((struct sockaddr *)NULL))
        {
          aflog((char)4, (char)1, "Can't allocate memory for sockaddr structure... exiting");
          exit(1);
        }

        ClientRealm_set_addressLength(pointer, addressLength);
        ClientRealm_set_clientAddress(pointer, clientAddress);
        struct sockaddr *return_value_ClientRealm_get_clientAddress_90;
        return_value_ClientRealm_get_clientAddress_90=ClientRealm_get_clientAddress(pointer);
        temp2=accept(n, return_value_ClientRealm_get_clientAddress_90, &addressLength);
      }

    }

  }

  struct anonymous_3 *return_value_ClientRealm_get_arOptions_95;
  return_value_ClientRealm_get_arOptions_95=ClientRealm_get_arOptions(pointer);
  i=ArOptions_get_arTries(return_value_ClientRealm_get_arOptions_95);
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_96;
  return_value_ClientRealm_get_masterSslFd_96=ClientRealm_get_masterSslFd(pointer);
  SslFd_set_fd(return_value_ClientRealm_get_masterSslFd_96, -1);
  signed int return_value_ClientRealm_get_clientMode_110;
  signed int return_value_ClientRealm_get_clientMode_119;
  do
  {
    temp = 0;
    struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_99;
    return_value_ClientRealm_get_masterSslFd_99=ClientRealm_get_masterSslFd(pointer);
    signed int return_value_SslFd_get_fd_100;
    return_value_SslFd_get_fd_100=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_99);
    if(!(return_value_SslFd_get_fd_100 == -1))
    {
      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_97;
      return_value_ClientRealm_get_masterSslFd_97=ClientRealm_get_masterSslFd(pointer);
      signed int return_value_SslFd_get_fd_98;
      return_value_SslFd_get_fd_98=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_97);
      close(return_value_SslFd_get_fd_98);
    }

    ClientRealm_closeUsersConnections(pointer);
    struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_101;
    return_value_ClientRealm_get_masterSslFd_101=ClientRealm_get_masterSslFd(pointer);
    SslFd_set_ssl(return_value_ClientRealm_get_masterSslFd_101, (struct ssl_st *)(void *)0);
    signed int return_value_ClientRealm_get_clientMode_115;
    return_value_ClientRealm_get_clientMode_115=ClientRealm_get_clientMode(pointer);
    if(!(return_value_ClientRealm_get_clientMode_115 == 3))
    {
      if(temp == 0)
      {
        struct anonymous_3 *return_value_ClientRealm_get_arOptions_102;
        return_value_ClientRealm_get_arOptions_102=ClientRealm_get_arOptions(pointer);
        char return_value_ArOptions_get_arStart_103;
        return_value_ArOptions_get_arStart_103=ArOptions_get_arStart(return_value_ClientRealm_get_arOptions_102);
        char return_value_ClientConfiguration_get_ignorePublicKeys_104;
        return_value_ClientConfiguration_get_ignorePublicKeys_104=ClientConfiguration_get_ignorePublicKeys(cconfig);
        signed int return_value_initialize_client_stage1_105;
        return_value_initialize_client_stage1_105=initialize_client_stage1(pointer, ctx, buff, (char)((signed int)return_value_ArOptions_get_arStart_103 == 1 ? 0 : 1), return_value_ClientConfiguration_get_ignorePublicKeys_104);
        if(!(return_value_initialize_client_stage1_105 == 0))
          temp = 1;

      }

      if(temp == 0)
      {
        return_value_ClientRealm_get_clientMode_110=ClientRealm_get_clientMode(pointer);
        if(return_value_ClientRealm_get_clientMode_110 == 2)
        {
          char return_value_ClientRealm_get_realmType_106;
          return_value_ClientRealm_get_realmType_106=ClientRealm_get_realmType(pointer);
          struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_107;
          return_value_ClientRealm_get_masterSslFd_107=ClientRealm_get_masterSslFd(pointer);
          char *return_value_ClientRealm_get_realmId_108;
          return_value_ClientRealm_get_realmId_108=ClientRealm_get_realmId(pointer);
          signed int return_value_client_admin_109;
          return_value_client_admin_109=client_admin(return_value_ClientRealm_get_realmType_106, return_value_ClientRealm_get_masterSslFd_107, buff, temp2, return_value_ClientRealm_get_realmId_108);
          return return_value_client_admin_109;
        }

      }

      if(temp == 0)
      {
        realmType=ClientRealm_get_realmType(pointer);
        struct anonymous_3 *return_value_ClientRealm_get_arOptions_111;
        return_value_ClientRealm_get_arOptions_111=ClientRealm_get_arOptions(pointer);
        char return_value_ArOptions_get_arStart_112;
        return_value_ArOptions_get_arStart_112=ArOptions_get_arStart(return_value_ClientRealm_get_arOptions_111);
        signed int return_value_initialize_client_stage2_113;
        return_value_initialize_client_stage2_113=initialize_client_stage2(pointer, buff, (char)((signed int)return_value_ArOptions_get_arStart_112 == 1 ? 0 : 1));
        if(!(return_value_initialize_client_stage2_113 == 0))
          temp = 1;

      }

    }

    else
    {
      signed int return_value_initialize_client_reverse_udp_114;
      return_value_initialize_client_reverse_udp_114=initialize_client_reverse_udp(pointer);
      if(!(return_value_initialize_client_reverse_udp_114 == 0))
        temp = 1;

    }
    if(temp == 0)
    {
      struct anonymous_3 *return_value_ClientRealm_get_arOptions_116;
      return_value_ClientRealm_get_arOptions_116=ClientRealm_get_arOptions(pointer);
      char return_value_ArOptions_get_arStart_117;
      return_value_ArOptions_get_arStart_117=ArOptions_get_arStart(return_value_ClientRealm_get_arOptions_116);
      signed int return_value_initialize_client_stage3_118;
      return_value_initialize_client_stage3_118=initialize_client_stage3(pointer, &buflength, &allset, &wset, &maxfdp1, (char)((signed int)return_value_ArOptions_get_arStart_117 == 1 ? 0 : 1));
      if(!(return_value_initialize_client_stage3_118 == 0))
        temp = 1;

    }

    if(temp == 0)
    {
      return_value_ClientRealm_get_clientMode_119=ClientRealm_get_clientMode(pointer);
      if(return_value_ClientRealm_get_clientMode_119 == 3)
        client_reverse_udp(pointer, buff, buflength);

    }

    if(i >= 1)
      i = i - 1;

    if(temp == 1 && !(i == 0))
    {
      aflog((char)4, (char)8, "Trying to reconnect...");
      struct anonymous_3 *return_value_ClientRealm_get_arOptions_120;
      return_value_ClientRealm_get_arOptions_120=ClientRealm_get_arOptions(pointer);
      signed int return_value_ArOptions_get_arDelay_121;
      return_value_ArOptions_get_arDelay_121=ArOptions_get_arDelay(return_value_ClientRealm_get_arOptions_120);
      mysleep((double)return_value_ArOptions_get_arDelay_121);
      ClientRealm_set_realmType(pointer, realmType);
    }

    if(temp == 0)
      break;

  }
  while(!(i == 0));
  signed int return_value_ClientRealm_get_clientMode_122;
  return_value_ClientRealm_get_clientMode_122=ClientRealm_get_clientMode(pointer);
  aflog((char)2, (char)8, "CLIENT STARTED mode: %s", return_value_ClientRealm_get_clientMode_122 == 1 ? "udp" : "tcp");
  char return_value_ClientRealm_get_realmType_123;
  return_value_ClientRealm_get_realmType_123=ClientRealm_get_realmType(pointer);
  char return_value_ClientRealm_get_realmType_124;
  return_value_ClientRealm_get_realmType_124=ClientRealm_get_realmType(pointer);
  char return_value_ClientRealm_get_realmType_125;
  return_value_ClientRealm_get_realmType_125=ClientRealm_get_realmType(pointer);
  _Bool tmp_if_expr_127;
  char return_value_ClientRealm_get_realmType_126;
  if(!((1 & (signed int)return_value_ClientRealm_get_realmType_125) == 0))
  {
    return_value_ClientRealm_get_realmType_126=ClientRealm_get_realmType(pointer);
    tmp_if_expr_127 = !(((signed int)return_value_ClientRealm_get_realmType_126 & 2) != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_127 = (_Bool)0;
  aflog((char)2, (char)8, "SERVER SSL: %s, ZLIB: %s, MODE: %s", ((signed int)return_value_ClientRealm_get_realmType_123 & 4) != 0 ? "yes" : "no", ((signed int)return_value_ClientRealm_get_realmType_124 & 8) != 0 ? "yes" : "no", tmp_if_expr_127 ? "tcp" : "udp");
  char return_value_ClientRealm_get_realmType_128;
  return_value_ClientRealm_get_realmType_128=ClientRealm_get_realmType(pointer);
  aflog((char)2, (char)8, "SERVER MULTI: %s", ((signed int)return_value_ClientRealm_get_realmType_128 & 64) != 0 ? "yes" : "no");
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_129;
  return_value_ClientRealm_get_masterSslFd_129=ClientRealm_get_masterSslFd(pointer);
  struct ssl_st *return_value_SslFd_get_ssl_130;
  return_value_SslFd_get_ssl_130=SslFd_get_ssl(return_value_ClientRealm_get_masterSslFd_129);
  const struct ssl_cipher_st *return_value_SSL_get_current_cipher_131;
  return_value_SSL_get_current_cipher_131=SSL_get_current_cipher(return_value_SslFd_get_ssl_130);
  const char *return_value_SSL_CIPHER_get_name_132;
  return_value_SSL_CIPHER_get_name_132=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher_131);
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_133;
  return_value_ClientRealm_get_masterSslFd_133=ClientRealm_get_masterSslFd(pointer);
  struct ssl_st *return_value_SslFd_get_ssl_134;
  return_value_SslFd_get_ssl_134=SslFd_get_ssl(return_value_ClientRealm_get_masterSslFd_133);
  const struct ssl_cipher_st *return_value_SSL_get_current_cipher_135;
  return_value_SSL_get_current_cipher_135=SSL_get_current_cipher(return_value_SslFd_get_ssl_134);
  char *return_value_SSL_CIPHER_get_version_136;
  return_value_SSL_CIPHER_get_version_136=SSL_CIPHER_get_version(return_value_SSL_get_current_cipher_135);
  aflog((char)2, (char)16, "CIPHER: %s VER: %s", return_value_SSL_CIPHER_get_name_132, return_value_SSL_CIPHER_get_version_136);
  struct anonymous_6 *return_value_ClientRealm_get_userModule_141;
  return_value_ClientRealm_get_userModule_141=ClientRealm_get_userModule(pointer);
  signed int return_value_Module_isModuleLoaded_142;
  return_value_Module_isModuleLoaded_142=Module_isModuleLoaded(return_value_ClientRealm_get_userModule_141);
  if(!(return_value_Module_isModuleLoaded_142 == 0))
  {
    struct anonymous_6 *return_value_ClientRealm_get_userModule_137;
    return_value_ClientRealm_get_userModule_137=ClientRealm_get_userModule(pointer);
    char *return_value_Module_get_fileName_138;
    return_value_Module_get_fileName_138=Module_get_fileName(return_value_ClientRealm_get_userModule_137);
    struct anonymous_6 *return_value_ClientRealm_get_userModule_139;
    return_value_ClientRealm_get_userModule_139=ClientRealm_get_userModule(pointer);
    char *return_value_Module_function_info_140;
    return_value_Module_function_info_140=Module_function_info(return_value_ClientRealm_get_userModule_139);
    aflog((char)2, (char)8, "LOADED MODULE: %s INFO: %s", return_value_Module_get_fileName_138, return_value_Module_function_info_140);
  }

  struct anonymous_6 *return_value_ClientRealm_get_serviceModule_147;
  return_value_ClientRealm_get_serviceModule_147=ClientRealm_get_serviceModule(pointer);
  signed int return_value_Module_isModuleLoaded_148;
  return_value_Module_isModuleLoaded_148=Module_isModuleLoaded(return_value_ClientRealm_get_serviceModule_147);
  if(!(return_value_Module_isModuleLoaded_148 == 0))
  {
    struct anonymous_6 *return_value_ClientRealm_get_serviceModule_143;
    return_value_ClientRealm_get_serviceModule_143=ClientRealm_get_serviceModule(pointer);
    char *return_value_Module_get_fileName_144;
    return_value_Module_get_fileName_144=Module_get_fileName(return_value_ClientRealm_get_serviceModule_143);
    struct anonymous_6 *return_value_ClientRealm_get_serviceModule_145;
    return_value_ClientRealm_get_serviceModule_145=ClientRealm_get_serviceModule(pointer);
    char *return_value_Module_function_info_146;
    return_value_Module_function_info_146=Module_function_info(return_value_ClientRealm_get_serviceModule_145);
    aflog((char)2, (char)8, "LOADED MODULE (ser): %s INFO: %s", return_value_Module_get_fileName_144, return_value_Module_function_info_146);
  }

  ClientRealm_send_realmId(pointer, buff);
  ClientRealm_enable_multi(pointer);
  signed int return_value_ClientRealm_get_usersLimit_155;
  _Bool tmp_if_expr_212;
  char return_value_ConnectUser_get_state_211;
  _Bool tmp_if_expr_214;
  char return_value_ConnectUser_get_state_213;
  signed int return_value_ConnectUser_get_connFd_174;
  signed int return_value_ConnectUser_get_connFd_175;
  signed int return_value_ConnectUser_get_connFd_176;
  signed int return_value_ConnectUser_get_connFd_177;
  signed int return_value_ConnectUser_get_connFd_178;
  signed int return_value_ConnectUser_get_connFd_179;
  struct buflist *return_value_ConnectUser_get_bufList_180;
  char return_value_ClientRealm_get_realmType_181;
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_182;
  struct anonymous_6 *return_value_ClientRealm_get_serviceModule_188;
  char *return_value_Module_get_fileName_189;
  struct anonymous_6 *return_value_ClientRealm_get_serviceModule_190;
  char *return_value_Module_function_info_191;
  struct anonymous_6 *return_value_ClientRealm_get_serviceModule_192;
  signed int return_value_ClientRealm_get_clientMode_207;
  signed int return_value_ClientRealm_get_usersLimit_215;
  _Bool tmp_if_expr_259;
  char return_value_ConnectUser_get_state_258;
  _Bool tmp_if_expr_254;
  signed int *return_value___errno_location_253;
  signed int return_value_ClientRealm_get_usersLimit_288;
  char return_value_ConnectUser_get_state_286;
  char return_value_ConnectUser_get_state_285;
  signed int return_value_ClientRealm_get_usersLimit_330;
  struct anonymous_6 *return_value_ClientRealm_get_userModule_295;
  char *return_value_ConnectUser_get_nameBuf_296;
  char *return_value_ConnectUser_get_portBuf_297;
  signed int return_value_Module_function_allow_298;
  char return_value_ClientRealm_get_realmType_302;
  signed int tmp_if_expr_326;
  signed int return_value_ConnectUser_get_connFd_325;
  char return_value_ClientRealm_get_realmType_331;
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_332;
  signed int return_value_ClientRealm_get_usersLimit_390;
  signed int return_value_ConnectUser_get_connFd_340;
  signed int return_value_ConnectUser_get_connFd_341;
  signed int return_value_ConnectUser_get_connFd_342;
  signed int return_value_ConnectUser_get_connFd_343;
  signed int return_value_ConnectUser_get_connFd_344;
  signed int return_value_ConnectUser_get_connFd_345;
  struct buflist *return_value_ConnectUser_get_bufList_346;
  char return_value_ClientRealm_get_realmType_347;
  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_348;
  struct anonymous_6 *return_value_ClientRealm_get_userModule_354;
  char *return_value_Module_get_fileName_355;
  struct anonymous_6 *return_value_ClientRealm_get_userModule_356;
  char *return_value_Module_function_info_357;
  struct anonymous_6 *return_value_ClientRealm_get_userModule_358;
  _Bool tmp_if_expr_385;
  signed int *return_value___errno_location_384;
  char return_value_ConnectUser_get_state_388;
  struct anonymous_3 *return_value_ClientRealm_get_arOptions_391;
  struct anonymous_3 *return_value_ClientRealm_get_arOptions_392;
  char return_value_ArOptions_get_arQuit_393;
  char return_value_ConnectUser_get_state_406;
  _Bool tmp_if_expr_408;
  char return_value_ConnectUser_get_state_407;
  char return_value_ConnectUser_get_state_411;
  _Bool tmp_if_expr_413;
  char return_value_ConnectUser_get_state_412;
  signed long int return_value_getcg_414;
  do
  {
    rset = allset;
    tmpset = wset;
    aflog((char)16, (char)4, "select");
    char *return_value_ClientRealm_get_sKeepAliveTimeout_154;
    return_value_ClientRealm_get_sKeepAliveTimeout_154=ClientRealm_get_sKeepAliveTimeout(pointer);
    if(!(return_value_ClientRealm_get_sKeepAliveTimeout_154 == ((char *)NULL)))
    {
      struct timeval *return_value_ClientRealm_get_keepAlivePointer_152;
      return_value_ClientRealm_get_keepAlivePointer_152=ClientRealm_get_keepAlivePointer(pointer);
      signed int return_value_select_153;
      return_value_select_153=select(maxfdp1, &rset, &tmpset, (struct anonymous_11 *)(void *)0, return_value_ClientRealm_get_keepAlivePointer_152);
      if(return_value_select_153 == 0)
      {
        aflog((char)2, (char)2, "timeout: sending keep-alive packet");
        buff[(signed long int)0] = (unsigned char)16;
        char return_value_ClientRealm_get_realmType_149;
        return_value_ClientRealm_get_realmType_149=ClientRealm_get_realmType(pointer);
        struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_150;
        return_value_ClientRealm_get_masterSslFd_150=ClientRealm_get_masterSslFd(pointer);
        SslFd_send_message(return_value_ClientRealm_get_realmType_149, return_value_ClientRealm_get_masterSslFd_150, buff, 5);
        signed int return_value_ClientRealm_get_keepAliveTimeout_151;
        return_value_ClientRealm_get_keepAliveTimeout_151=ClientRealm_get_keepAliveTimeout(pointer);
        keepAlive.tv_sec = (signed long int)return_value_ClientRealm_get_keepAliveTimeout_151;
        keepAlive.tv_usec = (signed long int)0;
        ClientRealm_set_keepAlive(pointer, keepAlive);
      }

    }

    else
      select(maxfdp1, &rset, &tmpset, (struct anonymous_11 *)(void *)0, (struct timeval *)(void *)0);
    aflog((char)16, (char)4, "after select...");
    usersTable=ClientRealm_get_usersTable(pointer);
    i = 0;
    do
    {
      return_value_ClientRealm_get_usersLimit_155=ClientRealm_get_usersLimit(pointer);
      if(i >= return_value_ClientRealm_get_usersLimit_155)
        break;

      char return_value_ConnectUser_get_state_210;
      return_value_ConnectUser_get_state_210=ConnectUser_get_state(usersTable[(signed long int)i]);
      if((signed int)return_value_ConnectUser_get_state_210 == 7)
        tmp_if_expr_212 = (_Bool)1;

      else
      {
        return_value_ConnectUser_get_state_211=ConnectUser_get_state(usersTable[(signed long int)i]);
        tmp_if_expr_212 = (signed int)return_value_ConnectUser_get_state_211 == 11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_212)
        tmp_if_expr_214 = (_Bool)1;

      else
      {
        return_value_ConnectUser_get_state_213=ConnectUser_get_state(usersTable[(signed long int)i]);
        tmp_if_expr_214 = (signed int)return_value_ConnectUser_get_state_213 == 19 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_214)
      {
        signed int return_value_ConnectUser_get_connFd_208;
        return_value_ConnectUser_get_connFd_208=ConnectUser_get_connFd(usersTable[(signed long int)i]);
        signed int return_value_ConnectUser_get_connFd_209;
        return_value_ConnectUser_get_connFd_209=ConnectUser_get_connFd(usersTable[(signed long int)i]);
        if(!((rset.__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_208 / 8)] & 1l << return_value_ConnectUser_get_connFd_209 % 8) == 0l))
        {
          aflog((char)1, (char)4, "user[%d]: FD_ISSET", i);
          signed int return_value_ConnectUser_get_connFd_156;
          return_value_ConnectUser_get_connFd_156=ConnectUser_get_connFd(usersTable[(signed long int)i]);
          signed long int return_value_read_157;
          return_value_read_157=read(return_value_ConnectUser_get_connFd_156, (void *)&buff[(signed long int)5], (unsigned long int)8091);
          n = (signed int)return_value_read_157;
          if(n == -1)
          {
            signed int *return_value___errno_location_158;
            return_value___errno_location_158=__errno_location();
            if(*return_value___errno_location_158 == 11)
              goto __CPROVER_DUMP_L190;

            signed int *return_value___errno_location_159;
            return_value___errno_location_159=__errno_location();
            aflog((char)1, (char)64, "error (%d): while reading from service", *return_value___errno_location_159);
            n = 0;
          }

          struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_160;
          return_value_ClientRealm_get_masterSslFd_160=ClientRealm_get_masterSslFd(pointer);
          signed int return_value_SslFd_get_fd_161;
          return_value_SslFd_get_fd_161=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_160);
          signed int return_value_ioctl_162;
          return_value_ioctl_162=ioctl(return_value_SslFd_get_fd_161, (unsigned long int)0x5411, &notsent);
          if(!(return_value_ioctl_162 == 0))
          {
            aflog((char)1, (char)1, "ioctl error -> exiting...");
            exit(1);
          }

          signed int return_value_ClientRealm_get_clientMode_166;
          return_value_ClientRealm_get_clientMode_166=ClientRealm_get_clientMode(pointer);
          if(return_value_ClientRealm_get_clientMode_166 == 1)
          {
            aLength = (unsigned int)4;
            struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_163;
            return_value_ClientRealm_get_masterSslFd_163=ClientRealm_get_masterSslFd(pointer);
            signed int return_value_SslFd_get_fd_164;
            return_value_SslFd_get_fd_164=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_163);
            signed int return_value_getsockopt_165;
            return_value_getsockopt_165=getsockopt(return_value_SslFd_get_fd_164, 1, 7, (void *)&temp2, &aLength);
            if(!(return_value_getsockopt_165 == -1))
            {
              if(!(temp2 == buflength))
              {
                buflength = temp2;
                aflog((char)1, (char)32, "Send buffer size changed...");
              }

            }

            if(5 + n + notsent >= buflength)
            {
              aflog((char)1, (char)32, "user[%d]: DROP size:%d, buf:%d, w:%d/%d", i, n + 5, buflength, notsent, buflength);
              goto __CPROVER_DUMP_L190;
            }

          }

          if(!(n == 0))
          {
            struct anonymous_6 *return_value_ClientRealm_get_serviceModule_193;
            return_value_ClientRealm_get_serviceModule_193=ClientRealm_get_serviceModule(pointer);
            signed int return_value_Module_isModuleLoaded_194;
            return_value_Module_isModuleLoaded_194=Module_isModuleLoaded(return_value_ClientRealm_get_serviceModule_193);
            if(!(return_value_Module_isModuleLoaded_194 == 0))
            {
              struct anonymous_6 *return_value_ClientRealm_get_serviceModule_167;
              return_value_ClientRealm_get_serviceModule_167=ClientRealm_get_serviceModule(pointer);
              char *return_value_ConnectUser_get_nameBuf_168;
              return_value_ConnectUser_get_nameBuf_168=ConnectUser_get_nameBuf(usersTable[(signed long int)i]);
              temp2=Module_function_filter(return_value_ClientRealm_get_serviceModule_167, return_value_ConnectUser_get_nameBuf_168, &buff[(signed long int)5], &n);
              switch(temp2)
              {
                case 1:

                case 4:
                {
                  aflog((char)1, (char)32, "user[%d] (by ser): PACKET IGNORED BY MODULE", i);
                  if(temp2 == 4)
                  {
                    struct anonymous_6 *return_value_ClientRealm_get_serviceModule_169;
                    return_value_ClientRealm_get_serviceModule_169=ClientRealm_get_serviceModule(pointer);
                    char *return_value_Module_get_fileName_170;
                    return_value_Module_get_fileName_170=Module_get_fileName(return_value_ClientRealm_get_serviceModule_169);
                    struct anonymous_6 *return_value_ClientRealm_get_serviceModule_171;
                    return_value_ClientRealm_get_serviceModule_171=ClientRealm_get_serviceModule(pointer);
                    char *return_value_Module_function_info_172;
                    return_value_Module_function_info_172=Module_function_info(return_value_ClientRealm_get_serviceModule_171);
                    aflog((char)16, (char)8, "RELEASED MODULE (ser): %s INFO: %s", return_value_Module_get_fileName_170, return_value_Module_function_info_172);
                    struct anonymous_6 *return_value_ClientRealm_get_serviceModule_173;
                    return_value_ClientRealm_get_serviceModule_173=ClientRealm_get_serviceModule(pointer);
                    Module_releaseModule(return_value_ClientRealm_get_serviceModule_173);
                  }

                  goto __CPROVER_DUMP_L190;
                }
                case 2:

                case 5:
                {
                  aflog((char)1, (char)16, "user[%d] (by ser): DROPPED BY MODULE", i);
                  return_value_ConnectUser_get_connFd_174=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  close(return_value_ConnectUser_get_connFd_174);
                  return_value_ConnectUser_get_connFd_175=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", i, return_value_ConnectUser_get_connFd_175);
                  return_value_ConnectUser_get_connFd_176=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  return_value_ConnectUser_get_connFd_177=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_176 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_176 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_177 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  return_value_ConnectUser_get_connFd_178=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  return_value_ConnectUser_get_connFd_179=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_178 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_178 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_179 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  ConnectUser_set_state(usersTable[(signed long int)i], (char)5);
                  return_value_ConnectUser_get_bufList_180=ConnectUser_get_bufList(usersTable[(signed long int)i]);
                  BufList_clear(return_value_ConnectUser_get_bufList_180);
                  buff[(signed long int)0] = (unsigned char)1;
                  buff[(signed long int)1] = (unsigned char)(i >> 8);
                  buff[(signed long int)2] = (unsigned char)i;
                  return_value_ClientRealm_get_realmType_181=ClientRealm_get_realmType(pointer);
                  return_value_ClientRealm_get_masterSslFd_182=ClientRealm_get_masterSslFd(pointer);
                  SslFd_send_message(return_value_ClientRealm_get_realmType_181, return_value_ClientRealm_get_masterSslFd_182, buff, 5);
                  if(temp2 == 5)
                  {
                    struct anonymous_6 *return_value_ClientRealm_get_serviceModule_183;
                    return_value_ClientRealm_get_serviceModule_183=ClientRealm_get_serviceModule(pointer);
                    char *return_value_Module_get_fileName_184;
                    return_value_Module_get_fileName_184=Module_get_fileName(return_value_ClientRealm_get_serviceModule_183);
                    struct anonymous_6 *return_value_ClientRealm_get_serviceModule_185;
                    return_value_ClientRealm_get_serviceModule_185=ClientRealm_get_serviceModule(pointer);
                    char *return_value_Module_function_info_186;
                    return_value_Module_function_info_186=Module_function_info(return_value_ClientRealm_get_serviceModule_185);
                    aflog((char)16, (char)8, "RELEASED MODULE (ser): %s INFO: %s", return_value_Module_get_fileName_184, return_value_Module_function_info_186);
                    struct anonymous_6 *return_value_ClientRealm_get_serviceModule_187;
                    return_value_ClientRealm_get_serviceModule_187=ClientRealm_get_serviceModule(pointer);
                    Module_releaseModule(return_value_ClientRealm_get_serviceModule_187);
                  }

                  goto __CPROVER_DUMP_L190;
                }
                case 3:
                {
                  return_value_ClientRealm_get_serviceModule_188=ClientRealm_get_serviceModule(pointer);
                  return_value_Module_get_fileName_189=Module_get_fileName(return_value_ClientRealm_get_serviceModule_188);
                  return_value_ClientRealm_get_serviceModule_190=ClientRealm_get_serviceModule(pointer);
                  return_value_Module_function_info_191=Module_function_info(return_value_ClientRealm_get_serviceModule_190);
                  aflog((char)16, (char)8, "RELEASED MODULE (ser): %s INFO: %s", return_value_Module_get_fileName_189, return_value_Module_function_info_191);
                  return_value_ClientRealm_get_serviceModule_192=ClientRealm_get_serviceModule(pointer);
                  Module_releaseModule(return_value_ClientRealm_get_serviceModule_192);
                }
                default:
                  ;
              }
            }

            buff[(signed long int)0] = (unsigned char)3;
            buff[(signed long int)1] = (unsigned char)(i >> 8);
            buff[(signed long int)2] = (unsigned char)i;
            buff[(signed long int)3] = (unsigned char)(n >> 8);
            buff[(signed long int)4] = (unsigned char)n;
            aflog((char)1, (char)2, "user[%d]: TO msglen: %d [%d/%d]", i, n, notsent, buflength);
            char return_value_ClientRealm_get_realmType_195;
            return_value_ClientRealm_get_realmType_195=ClientRealm_get_realmType(pointer);
            struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_196;
            return_value_ClientRealm_get_masterSslFd_196=ClientRealm_get_masterSslFd(pointer);
            SslFd_send_message(return_value_ClientRealm_get_realmType_195, return_value_ClientRealm_get_masterSslFd_196, buff, n + 5);
          }

          else
          {
            return_value_ClientRealm_get_clientMode_207=ClientRealm_get_clientMode(pointer);
            if(!(return_value_ClientRealm_get_clientMode_207 == 1))
            {
              aflog((char)1, (char)8, "user[%d]: CLOSING", i);
              signed int return_value_ConnectUser_get_connFd_197;
              return_value_ConnectUser_get_connFd_197=ConnectUser_get_connFd(usersTable[(signed long int)i]);
              close(return_value_ConnectUser_get_connFd_197);
              signed int return_value_ConnectUser_get_connFd_198;
              return_value_ConnectUser_get_connFd_198=ConnectUser_get_connFd(usersTable[(signed long int)i]);
              aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", i, return_value_ConnectUser_get_connFd_198);
              signed int return_value_ConnectUser_get_connFd_199;
              return_value_ConnectUser_get_connFd_199=ConnectUser_get_connFd(usersTable[(signed long int)i]);
              signed int return_value_ConnectUser_get_connFd_200;
              return_value_ConnectUser_get_connFd_200=ConnectUser_get_connFd(usersTable[(signed long int)i]);
              (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_199 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_199 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_200 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
              signed int return_value_ConnectUser_get_connFd_201;
              return_value_ConnectUser_get_connFd_201=ConnectUser_get_connFd(usersTable[(signed long int)i]);
              signed int return_value_ConnectUser_get_connFd_202;
              return_value_ConnectUser_get_connFd_202=ConnectUser_get_connFd(usersTable[(signed long int)i]);
              (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_201 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_201 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_202 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
              char return_value_ConnectUser_get_state_203;
              return_value_ConnectUser_get_state_203=ConnectUser_get_state(usersTable[(signed long int)i]);
              if((signed int)return_value_ConnectUser_get_state_203 == 19)
                ConnectUser_set_state(usersTable[(signed long int)i], (char)0);

              else
                ConnectUser_set_state(usersTable[(signed long int)i], (char)5);
              struct buflist *return_value_ConnectUser_get_bufList_204;
              return_value_ConnectUser_get_bufList_204=ConnectUser_get_bufList(usersTable[(signed long int)i]);
              BufList_clear(return_value_ConnectUser_get_bufList_204);
              buff[(signed long int)0] = (unsigned char)1;
              buff[(signed long int)1] = (unsigned char)(i >> 8);
              buff[(signed long int)2] = (unsigned char)i;
              char return_value_ClientRealm_get_realmType_205;
              return_value_ClientRealm_get_realmType_205=ClientRealm_get_realmType(pointer);
              struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_206;
              return_value_ClientRealm_get_masterSslFd_206=ClientRealm_get_masterSslFd(pointer);
              SslFd_send_message(return_value_ClientRealm_get_realmType_205, return_value_ClientRealm_get_masterSslFd_206, buff, 5);
            }

          }
        }

      }


    __CPROVER_DUMP_L190:
      ;
      i = i + 1;
    }
    while((_Bool)1);
    i = 0;
    do
    {
      return_value_ClientRealm_get_usersLimit_215=ClientRealm_get_usersLimit(pointer);
      if(i >= return_value_ClientRealm_get_usersLimit_215)
        break;

      char return_value_ConnectUser_get_state_257;
      return_value_ConnectUser_get_state_257=ConnectUser_get_state(usersTable[(signed long int)i]);
      if((signed int)return_value_ConnectUser_get_state_257 == 11)
        tmp_if_expr_259 = (_Bool)1;

      else
      {
        return_value_ConnectUser_get_state_258=ConnectUser_get_state(usersTable[(signed long int)i]);
        tmp_if_expr_259 = (signed int)return_value_ConnectUser_get_state_258 == 19 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_259)
      {
        signed int return_value_ConnectUser_get_connFd_255;
        return_value_ConnectUser_get_connFd_255=ConnectUser_get_connFd(usersTable[(signed long int)i]);
        signed int return_value_ConnectUser_get_connFd_256;
        return_value_ConnectUser_get_connFd_256=ConnectUser_get_connFd(usersTable[(signed long int)i]);
        if(!((tmpset.__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_255 / 8)] & 1l << return_value_ConnectUser_get_connFd_256 % 8) == 0l))
        {
          aflog((char)1, (char)4, "user[%d]: FD_ISSET - WRITE", i);
          struct buflist *return_value_ConnectUser_get_bufList_216;
          return_value_ConnectUser_get_bufList_216=ConnectUser_get_bufList(usersTable[(signed long int)i]);
          struct blnode *return_value_BufList_get_first_217;
          return_value_BufList_get_first_217=BufList_get_first(return_value_ConnectUser_get_bufList_216);
          n=BufListNode_readMessageLength(return_value_BufList_get_first_217);
          signed int return_value_ConnectUser_get_connFd_218;
          return_value_ConnectUser_get_connFd_218=ConnectUser_get_connFd(usersTable[(signed long int)i]);
          struct buflist *return_value_ConnectUser_get_bufList_219;
          return_value_ConnectUser_get_bufList_219=ConnectUser_get_bufList(usersTable[(signed long int)i]);
          struct blnode *return_value_BufList_get_first_220;
          return_value_BufList_get_first_220=BufList_get_first(return_value_ConnectUser_get_bufList_219);
          unsigned char *return_value_BufListNode_readMessage_221;
          return_value_BufListNode_readMessage_221=BufListNode_readMessage(return_value_BufList_get_first_220);
          signed long int return_value_write_222;
          return_value_write_222=write(return_value_ConnectUser_get_connFd_218, (const void *)return_value_BufListNode_readMessage_221, (unsigned long int)n);
          temp2 = (signed int)return_value_write_222;
          if(temp2 >= 1 && !(temp2 == n))
          {
            struct buflist *return_value_ConnectUser_get_bufList_223;
            return_value_ConnectUser_get_bufList_223=ConnectUser_get_bufList(usersTable[(signed long int)i]);
            struct blnode *return_value_BufList_get_first_224;
            return_value_BufList_get_first_224=BufList_get_first(return_value_ConnectUser_get_bufList_223);
            struct buflist *return_value_ConnectUser_get_bufList_225;
            return_value_ConnectUser_get_bufList_225=ConnectUser_get_bufList(usersTable[(signed long int)i]);
            struct blnode *return_value_BufList_get_first_226;
            return_value_BufList_get_first_226=BufList_get_first(return_value_ConnectUser_get_bufList_225);
            signed int return_value_BufListNode_get_actPtr_227;
            return_value_BufListNode_get_actPtr_227=BufListNode_get_actPtr(return_value_BufList_get_first_226);
            BufListNode_set_actPtr(return_value_BufList_get_first_224, return_value_BufListNode_get_actPtr_227 + temp2);
          }

          else
          {
            if(temp2 == -1)
            {
              return_value___errno_location_253=__errno_location();
              tmp_if_expr_254 = *return_value___errno_location_253 == 11 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_254 = (_Bool)0;
            if(tmp_if_expr_254)
              aflog((char)1, (char)2, "user[%d]: Couldn't write?", i);

            else
              if(temp2 == -1)
              {
                signed int return_value_ConnectUser_get_connFd_228;
                return_value_ConnectUser_get_connFd_228=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                close(return_value_ConnectUser_get_connFd_228);
                signed int return_value_ConnectUser_get_connFd_229;
                return_value_ConnectUser_get_connFd_229=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", i, return_value_ConnectUser_get_connFd_229);
                signed int return_value_ConnectUser_get_connFd_230;
                return_value_ConnectUser_get_connFd_230=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                signed int return_value_ConnectUser_get_connFd_231;
                return_value_ConnectUser_get_connFd_231=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_230 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_230 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_231 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                signed int return_value_ConnectUser_get_connFd_232;
                return_value_ConnectUser_get_connFd_232=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                signed int return_value_ConnectUser_get_connFd_233;
                return_value_ConnectUser_get_connFd_233=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_232 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_232 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_233 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                char return_value_ConnectUser_get_state_234;
                return_value_ConnectUser_get_state_234=ConnectUser_get_state(usersTable[(signed long int)i]);
                if((signed int)return_value_ConnectUser_get_state_234 == 19)
                  ConnectUser_set_state(usersTable[(signed long int)i], (char)0);

                else
                  ConnectUser_set_state(usersTable[(signed long int)i], (char)5);
                buff[(signed long int)0] = (unsigned char)1;
                buff[(signed long int)1] = (unsigned char)(i >> 8);
                buff[(signed long int)2] = (unsigned char)i;
                char return_value_ClientRealm_get_realmType_235;
                return_value_ClientRealm_get_realmType_235=ClientRealm_get_realmType(pointer);
                struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_236;
                return_value_ClientRealm_get_masterSslFd_236=ClientRealm_get_masterSslFd(pointer);
                SslFd_send_message(return_value_ClientRealm_get_realmType_235, return_value_ClientRealm_get_masterSslFd_236, buff, 5);
              }

              else
              {
                struct buflist *return_value_ConnectUser_get_bufList_237;
                return_value_ConnectUser_get_bufList_237=ConnectUser_get_bufList(usersTable[(signed long int)i]);
                BufList_delete_first(return_value_ConnectUser_get_bufList_237);
                struct buflist *return_value_ConnectUser_get_bufList_251;
                return_value_ConnectUser_get_bufList_251=ConnectUser_get_bufList(usersTable[(signed long int)i]);
                struct blnode *return_value_BufList_get_first_252;
                return_value_BufList_get_first_252=BufList_get_first(return_value_ConnectUser_get_bufList_251);
                if(return_value_BufList_get_first_252 == ((struct blnode *)NULL))
                {
                  signed int return_value_ConnectUser_get_connFd_238;
                  return_value_ConnectUser_get_connFd_238=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  signed int return_value_ConnectUser_get_connFd_239;
                  return_value_ConnectUser_get_connFd_239=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_238 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_238 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_239 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  buff[(signed long int)0] = (unsigned char)10;
                  buff[(signed long int)1] = (unsigned char)(i >> 8);
                  buff[(signed long int)2] = (unsigned char)i;
                  aflog((char)1, (char)4, "FROM user[%d]: BUFFERING MESSAGE ENDED", i);
                  char return_value_ClientRealm_get_realmType_240;
                  return_value_ClientRealm_get_realmType_240=ClientRealm_get_realmType(pointer);
                  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_241;
                  return_value_ClientRealm_get_masterSslFd_241=ClientRealm_get_masterSslFd(pointer);
                  SslFd_send_message(return_value_ClientRealm_get_realmType_240, return_value_ClientRealm_get_masterSslFd_241, buff, 5);
                  char return_value_ConnectUser_get_state_250;
                  return_value_ConnectUser_get_state_250=ConnectUser_get_state(usersTable[(signed long int)i]);
                  if((signed int)return_value_ConnectUser_get_state_250 == 19)
                  {
                    signed int return_value_ConnectUser_get_connFd_242;
                    return_value_ConnectUser_get_connFd_242=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                    close(return_value_ConnectUser_get_connFd_242);
                    signed int return_value_ConnectUser_get_connFd_243;
                    return_value_ConnectUser_get_connFd_243=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                    aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", i, return_value_ConnectUser_get_connFd_243);
                    signed int return_value_ConnectUser_get_connFd_244;
                    return_value_ConnectUser_get_connFd_244=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                    signed int return_value_ConnectUser_get_connFd_245;
                    return_value_ConnectUser_get_connFd_245=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                    (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_244 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_244 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_245 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                    signed int return_value_ConnectUser_get_connFd_246;
                    return_value_ConnectUser_get_connFd_246=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                    signed int return_value_ConnectUser_get_connFd_247;
                    return_value_ConnectUser_get_connFd_247=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                    (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_246 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_246 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_247 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                    ConnectUser_set_state(usersTable[(signed long int)i], (char)0);
                    buff[(signed long int)0] = (unsigned char)1;
                    buff[(signed long int)1] = (unsigned char)(i >> 8);
                    buff[(signed long int)2] = (unsigned char)i;
                    char return_value_ClientRealm_get_realmType_248;
                    return_value_ClientRealm_get_realmType_248=ClientRealm_get_realmType(pointer);
                    struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_249;
                    return_value_ClientRealm_get_masterSslFd_249=ClientRealm_get_masterSslFd(pointer);
                    SslFd_send_message(return_value_ClientRealm_get_realmType_248, return_value_ClientRealm_get_masterSslFd_249, buff, 5);
                  }

                  else
                    ConnectUser_set_state(usersTable[(signed long int)i], (char)7);
                }

              }
          }
        }

      }

      i = i + 1;
    }
    while((_Bool)1);
    struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_415;
    return_value_ClientRealm_get_masterSslFd_415=ClientRealm_get_masterSslFd(pointer);
    signed int return_value_SslFd_get_fd_416;
    return_value_SslFd_get_fd_416=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_415);
    struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_417;
    return_value_ClientRealm_get_masterSslFd_417=ClientRealm_get_masterSslFd(pointer);
    signed int return_value_SslFd_get_fd_418;
    return_value_SslFd_get_fd_418=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_417);
    if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd_416 / 8)] & 1l << return_value_SslFd_get_fd_418 % 8) == 0l))
    {
      aflog((char)2, (char)4, "masterfd: FD_ISSET");
      char return_value_ClientRealm_get_realmType_260;
      return_value_ClientRealm_get_realmType_260=ClientRealm_get_realmType(pointer);
      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_261;
      return_value_ClientRealm_get_masterSslFd_261=ClientRealm_get_masterSslFd(pointer);
      n=SslFd_get_message(return_value_ClientRealm_get_realmType_260, return_value_ClientRealm_get_masterSslFd_261, buff, 5);
      if(!(n == 5))
      {
        aflog((char)2, (char)64, "FATAL ERROR! (%d)", n);
        if(n == -1)
        {
          char return_value_ClientRealm_get_realmType_263;
          return_value_ClientRealm_get_realmType_263=ClientRealm_get_realmType(pointer);
          if(!((4 & (signed int)return_value_ClientRealm_get_realmType_263) == 0))
          {
            struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_262;
            return_value_ClientRealm_get_masterSslFd_262=ClientRealm_get_masterSslFd(pointer);
            get_ssl_error(return_value_ClientRealm_get_masterSslFd_262, "FE", n);
            continue;
          }

        }

        if(!(n == 0))
          exit(1);

      }

      if(n == 0)
      {
        struct anonymous_3 *return_value_ClientRealm_get_arOptions_264;
        return_value_ClientRealm_get_arOptions_264=ClientRealm_get_arOptions(pointer);
        i=ArOptions_get_arTries(return_value_ClientRealm_get_arOptions_264);
        struct anonymous_3 *return_value_ClientRealm_get_arOptions_265;
        return_value_ClientRealm_get_arOptions_265=ClientRealm_get_arOptions(pointer);
        char return_value_ArOptions_get_arPremature_266;
        return_value_ArOptions_get_arPremature_266=ArOptions_get_arPremature(return_value_ClientRealm_get_arOptions_265);
        if((signed int)return_value_ArOptions_get_arPremature_266 == 0)
          i = 0;

        if(!(i == 0))
          aflog((char)2, (char)64, "SERVER: premature quit -> auto-reconnect enabled");

        while(!(i == 0))
        {
          ClientRealm_closeUsersConnections(pointer);
          struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_267;
          return_value_ClientRealm_get_masterSslFd_267=ClientRealm_get_masterSslFd(pointer);
          signed int return_value_SslFd_get_fd_268;
          return_value_SslFd_get_fd_268=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_267);
          close(return_value_SslFd_get_fd_268);
          struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_269;
          return_value_ClientRealm_get_masterSslFd_269=ClientRealm_get_masterSslFd(pointer);
          SslFd_set_ssl(return_value_ClientRealm_get_masterSslFd_269, (struct ssl_st *)(void *)0);
          struct anonymous_3 *return_value_ClientRealm_get_arOptions_270;
          return_value_ClientRealm_get_arOptions_270=ClientRealm_get_arOptions(pointer);
          signed int return_value_ArOptions_get_arDelay_271;
          return_value_ArOptions_get_arDelay_271=ArOptions_get_arDelay(return_value_ClientRealm_get_arOptions_270);
          mysleep((double)return_value_ArOptions_get_arDelay_271);
          aflog((char)2, (char)8, "Trying to reconnect...");
          temp2 = 0;
          if(temp2 == 0)
          {
            char return_value_ClientConfiguration_get_ignorePublicKeys_272;
            return_value_ClientConfiguration_get_ignorePublicKeys_272=ClientConfiguration_get_ignorePublicKeys(cconfig);
            signed int return_value_initialize_client_stage1_273;
            return_value_initialize_client_stage1_273=initialize_client_stage1(pointer, ctx, buff, (char)0, return_value_ClientConfiguration_get_ignorePublicKeys_272);
            if(!(return_value_initialize_client_stage1_273 == 0))
              temp2 = 1;

          }

          if(temp2 == 0)
          {
            signed int return_value_initialize_client_stage2_274;
            return_value_initialize_client_stage2_274=initialize_client_stage2(pointer, buff, (char)0);
            if(!(return_value_initialize_client_stage2_274 == 0))
              temp2 = 1;

          }

          if(temp2 == 0)
          {
            signed int return_value_initialize_client_stage3_275;
            return_value_initialize_client_stage3_275=initialize_client_stage3(pointer, &buflength, &allset, &wset, &maxfdp1, (char)0);
            if(!(return_value_initialize_client_stage3_275 == 0))
              temp2 = 1;

          }

          if(temp2 == 0)
          {
            n = 1;
            aflog((char)2, (char)8, "Reconnected successfully...");
            usersTable=ClientRealm_get_usersTable(pointer);
            ClientRealm_send_realmId(pointer, buff);
            ClientRealm_enable_multi(pointer);
            break;
          }

          if(i >= 1)
            i = i - 1;

        }
        if(n == 0)
        {
          aflog((char)2, (char)1, "SERVER: premature quit -> exiting...");
          exit(1);
        }

        continue;
      }

      numofcon = (signed int)buff[(signed long int)1];
      numofcon = numofcon << 8;
      numofcon = numofcon + (signed int)buff[(signed long int)2];
      length = (signed int)buff[(signed long int)3];
      length = length << 8;
      length = length + (signed int)buff[(signed long int)4];
      switch((signed int)buff[(signed long int)0])
      {
        case 1:
        {
          aflog((char)1, (char)4, "user[%d]: AF_S_CONCLOSED", numofcon);
          if(numofcon >= 0)
          {
            return_value_ClientRealm_get_usersLimit_288=ClientRealm_get_usersLimit(pointer);
            if(return_value_ClientRealm_get_usersLimit_288 >= numofcon)
            {
              char return_value_ConnectUser_get_state_287;
              return_value_ConnectUser_get_state_287=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
              if((signed int)return_value_ConnectUser_get_state_287 == 5)
              {
                ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)0);
                aflog((char)1, (char)8, "user[%d]: CLOSE CONFIRMED", numofcon);
              }

              else
              {
                return_value_ConnectUser_get_state_286=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
                if((signed int)return_value_ConnectUser_get_state_286 == 7)
                {
                  aflog((char)1, (char)8, "user[%d]: CLOSED", numofcon);
                  signed int return_value_ConnectUser_get_connFd_276;
                  return_value_ConnectUser_get_connFd_276=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  close(return_value_ConnectUser_get_connFd_276);
                  signed int return_value_ConnectUser_get_connFd_277;
                  return_value_ConnectUser_get_connFd_277=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", numofcon, return_value_ConnectUser_get_connFd_277);
                  signed int return_value_ConnectUser_get_connFd_278;
                  return_value_ConnectUser_get_connFd_278=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  signed int return_value_ConnectUser_get_connFd_279;
                  return_value_ConnectUser_get_connFd_279=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_278 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_278 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_279 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  signed int return_value_ConnectUser_get_connFd_280;
                  return_value_ConnectUser_get_connFd_280=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  signed int return_value_ConnectUser_get_connFd_281;
                  return_value_ConnectUser_get_connFd_281=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_280 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_280 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_281 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)0);
                  struct buflist *return_value_ConnectUser_get_bufList_282;
                  return_value_ConnectUser_get_bufList_282=ConnectUser_get_bufList(usersTable[(signed long int)numofcon]);
                  BufList_clear(return_value_ConnectUser_get_bufList_282);
                  buff[(signed long int)0] = (unsigned char)1;
                  buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                  buff[(signed long int)2] = (unsigned char)numofcon;
                  char return_value_ClientRealm_get_realmType_283;
                  return_value_ClientRealm_get_realmType_283=ClientRealm_get_realmType(pointer);
                  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_284;
                  return_value_ClientRealm_get_masterSslFd_284=ClientRealm_get_masterSslFd(pointer);
                  SslFd_send_message(return_value_ClientRealm_get_realmType_283, return_value_ClientRealm_get_masterSslFd_284, buff, 5);
                }

                else
                {
                  return_value_ConnectUser_get_state_285=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
                  if((signed int)return_value_ConnectUser_get_state_285 == 11)
                  {
                    ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)19);
                    aflog((char)1, (char)8, "user[%d]: CLOSING...", numofcon);
                  }

                }
              }
            }

          }

          break;
        }
        case 2:
        {
          aflog((char)1, (char)4, "user[%d]: AF_S_CONOPEN", numofcon);
          if(numofcon >= 0)
          {
            return_value_ClientRealm_get_usersLimit_330=ClientRealm_get_usersLimit(pointer);
            if(return_value_ClientRealm_get_usersLimit_330 >= numofcon)
            {
              char return_value_ConnectUser_get_state_329;
              return_value_ConnectUser_get_state_329=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
              if((signed int)return_value_ConnectUser_get_state_329 == 0)
              {
                char return_value_ClientRealm_get_realmType_289;
                return_value_ClientRealm_get_realmType_289=ClientRealm_get_realmType(pointer);
                struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_290;
                return_value_ClientRealm_get_masterSslFd_290=ClientRealm_get_masterSslFd(pointer);
                n=SslFd_get_message(return_value_ClientRealm_get_realmType_289, return_value_ClientRealm_get_masterSslFd_290, buff, length);
                ConnectUser_set_nameBuf(usersTable[(signed long int)numofcon], (char *)buff);
                ConnectUser_set_portBuf(usersTable[(signed long int)numofcon], (char *)&buff[(signed long int)128]);
                aflog((char)1, (char)8, "user[%d]: OPENING", numofcon);
                char *return_value_ConnectUser_get_nameBuf_291;
                return_value_ConnectUser_get_nameBuf_291=ConnectUser_get_nameBuf(usersTable[(signed long int)numofcon]);
                char *return_value_ConnectUser_get_portBuf_292;
                return_value_ConnectUser_get_portBuf_292=ConnectUser_get_portBuf(usersTable[(signed long int)numofcon]);
                aflog((char)1, (char)8, "user[%d]: IP:%s PORT:%s", numofcon, return_value_ConnectUser_get_nameBuf_291, return_value_ConnectUser_get_portBuf_292);
                struct anonymous_6 *return_value_ClientRealm_get_userModule_299;
                return_value_ClientRealm_get_userModule_299=ClientRealm_get_userModule(pointer);
                signed int return_value_Module_isModuleLoaded_300;
                return_value_Module_isModuleLoaded_300=Module_isModuleLoaded(return_value_ClientRealm_get_userModule_299);
                if(!(return_value_Module_isModuleLoaded_300 == 0))
                {
                  return_value_ClientRealm_get_userModule_295=ClientRealm_get_userModule(pointer);
                  return_value_ConnectUser_get_nameBuf_296=ConnectUser_get_nameBuf(usersTable[(signed long int)numofcon]);
                  return_value_ConnectUser_get_portBuf_297=ConnectUser_get_portBuf(usersTable[(signed long int)numofcon]);
                  return_value_Module_function_allow_298=Module_function_allow(return_value_ClientRealm_get_userModule_295, return_value_ConnectUser_get_nameBuf_296, return_value_ConnectUser_get_portBuf_297);
                  if(!(return_value_Module_function_allow_298 == 0))
                  {
                    aflog((char)1, (char)32, "user[%d]: IT'S NOT ALLOWED - DROPPING", numofcon);
                    buff[(signed long int)0] = (unsigned char)12;
                    buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                    buff[(signed long int)2] = (unsigned char)numofcon;
                    char return_value_ClientRealm_get_realmType_293;
                    return_value_ClientRealm_get_realmType_293=ClientRealm_get_realmType(pointer);
                    struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_294;
                    return_value_ClientRealm_get_masterSslFd_294=ClientRealm_get_masterSslFd(pointer);
                    SslFd_send_message(return_value_ClientRealm_get_realmType_293, return_value_ClientRealm_get_masterSslFd_294, buff, 5);
                    goto __CPROVER_DUMP_L286;
                  }

                }

                signed int return_value_ClientRealm_get_clientMode_301;
                return_value_ClientRealm_get_clientMode_301=ClientRealm_get_clientMode(pointer);
                if(return_value_ClientRealm_get_clientMode_301 == 1)
                  ipFamily = (char)0;

                else
                  ipFamily = (char)0x01;
                char return_value_ClientRealm_get_realmType_303;
                return_value_ClientRealm_get_realmType_303=ClientRealm_get_realmType(pointer);
                if(!((16 & (signed int)return_value_ClientRealm_get_realmType_303) == 0))
                  ipFamily = ipFamily | (char)0x02;

                else
                {
                  return_value_ClientRealm_get_realmType_302=ClientRealm_get_realmType(pointer);
                  if(!((32 & (signed int)return_value_ClientRealm_get_realmType_302) == 0))
                    ipFamily = ipFamily | (char)0x04;

                }
                temp2 = 0;
                if(n == 136)
                {
                  struct portlist *return_value_ClientRealm_get_destinationPorts_306;
                  return_value_ClientRealm_get_destinationPorts_306=ClientRealm_get_destinationPorts(pointer);
                  signed int return_value_PortList_get_size_307;
                  return_value_PortList_get_size_307=PortList_get_size(return_value_ClientRealm_get_destinationPorts_306);
                  if(return_value_PortList_get_size_307 == 1)
                    temp2 = 0;

                  else
                  {
                    struct portlist *return_value_ClientRealm_get_destinationPorts_304;
                    return_value_ClientRealm_get_destinationPorts_304=ClientRealm_get_destinationPorts(pointer);
                    signed int return_value_PortList_get_size_305;
                    return_value_PortList_get_size_305=PortList_get_size(return_value_ClientRealm_get_destinationPorts_304);
                    temp2 = (signed int)buff[(signed long int)135] % return_value_PortList_get_size_305;
                  }
                }

                char *return_value_ClientRealm_get_hostName_314;
                return_value_ClientRealm_get_hostName_314=ClientRealm_get_hostName(pointer);
                struct portlist *return_value_ClientRealm_get_destinationPorts_315;
                return_value_ClientRealm_get_destinationPorts_315=ClientRealm_get_destinationPorts(pointer);
                struct plnode *return_value_PortList_get_nth_316;
                return_value_PortList_get_nth_316=PortList_get_nth(return_value_ClientRealm_get_destinationPorts_315, temp2);
                char *return_value_PortListNode_get_portName_317;
                return_value_PortListNode_get_portName_317=PortListNode_get_portName(return_value_PortList_get_nth_316);
                char *return_value_ClientRealm_get_localDestinationName_318;
                return_value_ClientRealm_get_localDestinationName_318=ClientRealm_get_localDestinationName(pointer);
                signed int return_value_ip_connect_319;
                return_value_ip_connect_319=ip_connect(&temp, return_value_ClientRealm_get_hostName_314, return_value_PortListNode_get_portName_317, ipFamily, return_value_ClientRealm_get_localDestinationName_318, (const char *)(void *)0);
                if(!(return_value_ip_connect_319 == 0))
                {
                  char *return_value_ClientRealm_get_hostName_308;
                  return_value_ClientRealm_get_hostName_308=ClientRealm_get_hostName(pointer);
                  struct portlist *return_value_ClientRealm_get_destinationPorts_309;
                  return_value_ClientRealm_get_destinationPorts_309=ClientRealm_get_destinationPorts(pointer);
                  struct plnode *return_value_PortList_get_nth_310;
                  return_value_PortList_get_nth_310=PortList_get_nth(return_value_ClientRealm_get_destinationPorts_309, temp2);
                  char *return_value_PortListNode_get_portName_311;
                  return_value_PortListNode_get_portName_311=PortListNode_get_portName(return_value_PortList_get_nth_310);
                  aflog((char)1, (char)32, "user[%d]: CAN'T CONNECT to %s:%s - DROPPING", numofcon, return_value_ClientRealm_get_hostName_308, return_value_PortListNode_get_portName_311);
                  buff[(signed long int)0] = (unsigned char)12;
                  buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                  buff[(signed long int)2] = (unsigned char)numofcon;
                  char return_value_ClientRealm_get_realmType_312;
                  return_value_ClientRealm_get_realmType_312=ClientRealm_get_realmType(pointer);
                  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_313;
                  return_value_ClientRealm_get_masterSslFd_313=ClientRealm_get_masterSslFd(pointer);
                  SslFd_send_message(return_value_ClientRealm_get_realmType_312, return_value_ClientRealm_get_masterSslFd_313, buff, 5);
                  goto __CPROVER_DUMP_L286;
                }

                ConnectUser_set_connFd(usersTable[(signed long int)numofcon], temp);
                aflog((char)1, (char)4, "user[%d]: Setting connFd: %d", numofcon, temp);
                signed int return_value_ConnectUser_get_connFd_320;
                return_value_ConnectUser_get_connFd_320=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                temp2=fcntl(return_value_ConnectUser_get_connFd_320, 3, 0);
                signed int return_value_ConnectUser_get_connFd_321;
                return_value_ConnectUser_get_connFd_321=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                fcntl(return_value_ConnectUser_get_connFd_321, 4, temp2 | 04000);
                signed int return_value_ConnectUser_get_connFd_322;
                return_value_ConnectUser_get_connFd_322=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                signed int return_value_ConnectUser_get_connFd_323;
                return_value_ConnectUser_get_connFd_323=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_322 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_322 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd_323 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                signed int return_value_ConnectUser_get_connFd_324;
                return_value_ConnectUser_get_connFd_324=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                if(!(1 + return_value_ConnectUser_get_connFd_324 >= maxfdp1))
                  tmp_if_expr_326 = maxfdp1;

                else
                {
                  return_value_ConnectUser_get_connFd_325=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  tmp_if_expr_326 = return_value_ConnectUser_get_connFd_325 + 1;
                }
                maxfdp1 = tmp_if_expr_326;
                buff[(signed long int)0] = (unsigned char)2;
                buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                buff[(signed long int)2] = (unsigned char)numofcon;
                char return_value_ClientRealm_get_realmType_327;
                return_value_ClientRealm_get_realmType_327=ClientRealm_get_realmType(pointer);
                struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_328;
                return_value_ClientRealm_get_masterSslFd_328=ClientRealm_get_masterSslFd(pointer);
                SslFd_send_message(return_value_ClientRealm_get_realmType_327, return_value_ClientRealm_get_masterSslFd_328, buff, 5);
                ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)7);
              }

            }

          }

          break;
        }
        case 3:
        {
          aflog((char)1, (char)4, "user[%d]: AF_S_MESSAGE", numofcon);
          aflog((char)1, (char)2, "user[%d]: FROM msglen: %d", numofcon, length);
          return_value_ClientRealm_get_realmType_331=ClientRealm_get_realmType(pointer);
          return_value_ClientRealm_get_masterSslFd_332=ClientRealm_get_masterSslFd(pointer);
          n=SslFd_get_message(return_value_ClientRealm_get_realmType_331, return_value_ClientRealm_get_masterSslFd_332, buff, length);
          if(numofcon >= 0)
          {
            return_value_ClientRealm_get_usersLimit_390=ClientRealm_get_usersLimit(pointer);
            if(return_value_ClientRealm_get_usersLimit_390 >= numofcon)
            {
              char return_value_ConnectUser_get_state_389;
              return_value_ConnectUser_get_state_389=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
              if((signed int)return_value_ConnectUser_get_state_389 == 7)
              {
                struct anonymous_6 *return_value_ClientRealm_get_userModule_359;
                return_value_ClientRealm_get_userModule_359=ClientRealm_get_userModule(pointer);
                signed int return_value_Module_isModuleLoaded_360;
                return_value_Module_isModuleLoaded_360=Module_isModuleLoaded(return_value_ClientRealm_get_userModule_359);
                if(!(return_value_Module_isModuleLoaded_360 == 0))
                {
                  struct anonymous_6 *return_value_ClientRealm_get_userModule_333;
                  return_value_ClientRealm_get_userModule_333=ClientRealm_get_userModule(pointer);
                  char *return_value_ConnectUser_get_nameBuf_334;
                  return_value_ConnectUser_get_nameBuf_334=ConnectUser_get_nameBuf(usersTable[(signed long int)numofcon]);
                  temp2=Module_function_filter(return_value_ClientRealm_get_userModule_333, return_value_ConnectUser_get_nameBuf_334, buff, &n);
                  switch(temp2)
                  {
                    case 1:

                    case 4:
                    {
                      aflog((char)1, (char)32, "user[%d]: PACKET IGNORED BY MODULE", numofcon);
                      if(temp2 == 4)
                      {
                        struct anonymous_6 *return_value_ClientRealm_get_userModule_335;
                        return_value_ClientRealm_get_userModule_335=ClientRealm_get_userModule(pointer);
                        char *return_value_Module_get_fileName_336;
                        return_value_Module_get_fileName_336=Module_get_fileName(return_value_ClientRealm_get_userModule_335);
                        struct anonymous_6 *return_value_ClientRealm_get_userModule_337;
                        return_value_ClientRealm_get_userModule_337=ClientRealm_get_userModule(pointer);
                        char *return_value_Module_function_info_338;
                        return_value_Module_function_info_338=Module_function_info(return_value_ClientRealm_get_userModule_337);
                        aflog((char)16, (char)8, "RELEASED MODULE: %s INFO: %s", return_value_Module_get_fileName_336, return_value_Module_function_info_338);
                        struct anonymous_6 *return_value_ClientRealm_get_userModule_339;
                        return_value_ClientRealm_get_userModule_339=ClientRealm_get_userModule(pointer);
                        Module_releaseModule(return_value_ClientRealm_get_userModule_339);
                      }

                      goto __CPROVER_DUMP_L286;
                    }
                    case 2:

                    case 5:
                    {
                      aflog((char)1, (char)16, "user[%d]: DROPPED BY MODULE", numofcon);
                      return_value_ConnectUser_get_connFd_340=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      close(return_value_ConnectUser_get_connFd_340);
                      return_value_ConnectUser_get_connFd_341=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", numofcon, return_value_ConnectUser_get_connFd_341);
                      return_value_ConnectUser_get_connFd_342=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      return_value_ConnectUser_get_connFd_343=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_342 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_342 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_343 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                      return_value_ConnectUser_get_connFd_344=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      return_value_ConnectUser_get_connFd_345=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_344 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_344 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_345 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                      ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)5);
                      return_value_ConnectUser_get_bufList_346=ConnectUser_get_bufList(usersTable[(signed long int)numofcon]);
                      BufList_clear(return_value_ConnectUser_get_bufList_346);
                      buff[(signed long int)0] = (unsigned char)1;
                      buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                      buff[(signed long int)2] = (unsigned char)numofcon;
                      return_value_ClientRealm_get_realmType_347=ClientRealm_get_realmType(pointer);
                      return_value_ClientRealm_get_masterSslFd_348=ClientRealm_get_masterSslFd(pointer);
                      SslFd_send_message(return_value_ClientRealm_get_realmType_347, return_value_ClientRealm_get_masterSslFd_348, buff, 5);
                      if(temp2 == 5)
                      {
                        struct anonymous_6 *return_value_ClientRealm_get_userModule_349;
                        return_value_ClientRealm_get_userModule_349=ClientRealm_get_userModule(pointer);
                        char *return_value_Module_get_fileName_350;
                        return_value_Module_get_fileName_350=Module_get_fileName(return_value_ClientRealm_get_userModule_349);
                        struct anonymous_6 *return_value_ClientRealm_get_userModule_351;
                        return_value_ClientRealm_get_userModule_351=ClientRealm_get_userModule(pointer);
                        char *return_value_Module_function_info_352;
                        return_value_Module_function_info_352=Module_function_info(return_value_ClientRealm_get_userModule_351);
                        aflog((char)16, (char)8, "RELEASED MODULE: %s INFO: %s", return_value_Module_get_fileName_350, return_value_Module_function_info_352);
                        struct anonymous_6 *return_value_ClientRealm_get_userModule_353;
                        return_value_ClientRealm_get_userModule_353=ClientRealm_get_userModule(pointer);
                        Module_releaseModule(return_value_ClientRealm_get_userModule_353);
                      }

                      goto __CPROVER_DUMP_L286;
                    }
                    case 3:
                    {
                      return_value_ClientRealm_get_userModule_354=ClientRealm_get_userModule(pointer);
                      return_value_Module_get_fileName_355=Module_get_fileName(return_value_ClientRealm_get_userModule_354);
                      return_value_ClientRealm_get_userModule_356=ClientRealm_get_userModule(pointer);
                      return_value_Module_function_info_357=Module_function_info(return_value_ClientRealm_get_userModule_356);
                      aflog((char)16, (char)8, "RELEASED MODULE: %s INFO: %s", return_value_Module_get_fileName_355, return_value_Module_function_info_357);
                      return_value_ClientRealm_get_userModule_358=ClientRealm_get_userModule(pointer);
                      Module_releaseModule(return_value_ClientRealm_get_userModule_358);
                    }
                    default:
                      ;
                  }
                }

                aflog((char)1, (char)2, "user[%d]: FROM msglen: %d SENT", numofcon, n);
                signed int return_value_ConnectUser_get_connFd_361;
                return_value_ConnectUser_get_connFd_361=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                signed long int return_value_write_362;
                return_value_write_362=write(return_value_ConnectUser_get_connFd_361, (const void *)buff, (unsigned long int)n);
                temp2 = (signed int)return_value_write_362;
                if(temp2 >= 1 && !(temp2 == n))
                {
                  struct buflist *return_value_ConnectUser_get_bufList_363;
                  return_value_ConnectUser_get_bufList_363=ConnectUser_get_bufList(usersTable[(signed long int)numofcon]);
                  struct blnode *return_value_BufListNode_new_message_364;
                  return_value_BufListNode_new_message_364=BufListNode_new_message(temp2, n, buff);
                  BufList_insert_back(return_value_ConnectUser_get_bufList_363, return_value_BufListNode_new_message_364);
                  ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)11);
                  signed int return_value_ConnectUser_get_connFd_365;
                  return_value_ConnectUser_get_connFd_365=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  signed int return_value_ConnectUser_get_connFd_366;
                  return_value_ConnectUser_get_connFd_366=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_365 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_365 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd_366 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                  buff[(signed long int)0] = (unsigned char)9;
                  buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                  buff[(signed long int)2] = (unsigned char)numofcon;
                  aflog((char)1, (char)4, "FROM user[%d]: BUFFERING MESSAGE STARTED", numofcon);
                  char return_value_ClientRealm_get_realmType_367;
                  return_value_ClientRealm_get_realmType_367=ClientRealm_get_realmType(pointer);
                  struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_368;
                  return_value_ClientRealm_get_masterSslFd_368=ClientRealm_get_masterSslFd(pointer);
                  SslFd_send_message(return_value_ClientRealm_get_realmType_367, return_value_ClientRealm_get_masterSslFd_368, buff, 5);
                }

                else
                {
                  if(temp2 == -1)
                  {
                    return_value___errno_location_384=__errno_location();
                    tmp_if_expr_385 = *return_value___errno_location_384 == 11 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_385 = (_Bool)0;
                  if(tmp_if_expr_385)
                  {
                    struct buflist *return_value_ConnectUser_get_bufList_369;
                    return_value_ConnectUser_get_bufList_369=ConnectUser_get_bufList(usersTable[(signed long int)numofcon]);
                    struct blnode *return_value_BufListNode_new_message_370;
                    return_value_BufListNode_new_message_370=BufListNode_new_message(0, n, buff);
                    BufList_insert_back(return_value_ConnectUser_get_bufList_369, return_value_BufListNode_new_message_370);
                    ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)11);
                    signed int return_value_ConnectUser_get_connFd_371;
                    return_value_ConnectUser_get_connFd_371=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                    signed int return_value_ConnectUser_get_connFd_372;
                    return_value_ConnectUser_get_connFd_372=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                    (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_371 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_371 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd_372 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                    buff[(signed long int)0] = (unsigned char)9;
                    buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                    buff[(signed long int)2] = (unsigned char)numofcon;
                    aflog((char)1, (char)4, "FROM user[%d]: BUFFERING MESSAGE STARTED", numofcon);
                    char return_value_ClientRealm_get_realmType_373;
                    return_value_ClientRealm_get_realmType_373=ClientRealm_get_realmType(pointer);
                    struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_374;
                    return_value_ClientRealm_get_masterSslFd_374=ClientRealm_get_masterSslFd(pointer);
                    SslFd_send_message(return_value_ClientRealm_get_realmType_373, return_value_ClientRealm_get_masterSslFd_374, buff, 5);
                  }

                  else
                    if(temp2 == -1)
                    {
                      signed int return_value_ConnectUser_get_connFd_375;
                      return_value_ConnectUser_get_connFd_375=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      close(return_value_ConnectUser_get_connFd_375);
                      signed int return_value_ConnectUser_get_connFd_376;
                      return_value_ConnectUser_get_connFd_376=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", numofcon, return_value_ConnectUser_get_connFd_376);
                      signed int return_value_ConnectUser_get_connFd_377;
                      return_value_ConnectUser_get_connFd_377=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      signed int return_value_ConnectUser_get_connFd_378;
                      return_value_ConnectUser_get_connFd_378=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_377 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_377 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_378 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                      signed int return_value_ConnectUser_get_connFd_379;
                      return_value_ConnectUser_get_connFd_379=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      signed int return_value_ConnectUser_get_connFd_380;
                      return_value_ConnectUser_get_connFd_380=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_379 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_379 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_380 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                      ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)5);
                      struct buflist *return_value_ConnectUser_get_bufList_381;
                      return_value_ConnectUser_get_bufList_381=ConnectUser_get_bufList(usersTable[(signed long int)numofcon]);
                      BufList_clear(return_value_ConnectUser_get_bufList_381);
                      buff[(signed long int)0] = (unsigned char)1;
                      buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                      buff[(signed long int)2] = (unsigned char)numofcon;
                      char return_value_ClientRealm_get_realmType_382;
                      return_value_ClientRealm_get_realmType_382=ClientRealm_get_realmType(pointer);
                      struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_383;
                      return_value_ClientRealm_get_masterSslFd_383=ClientRealm_get_masterSslFd(pointer);
                      SslFd_send_message(return_value_ClientRealm_get_realmType_382, return_value_ClientRealm_get_masterSslFd_383, buff, 5);
                    }

                }
              }

              else
              {
                return_value_ConnectUser_get_state_388=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
                if((signed int)return_value_ConnectUser_get_state_388 == 11)
                {
                  aflog((char)1, (char)4, "FROM user[%d]: BUFFERING MESSAGE", numofcon);
                  struct buflist *return_value_ConnectUser_get_bufList_386;
                  return_value_ConnectUser_get_bufList_386=ConnectUser_get_bufList(usersTable[(signed long int)numofcon]);
                  struct blnode *return_value_BufListNode_new_message_387;
                  return_value_BufListNode_new_message_387=BufListNode_new_message(0, n, buff);
                  BufList_insert_back(return_value_ConnectUser_get_bufList_386, return_value_BufListNode_new_message_387);
                }

              }
            }

          }

          break;
        }
        case 4:
        {
          n = 0;
          return_value_ClientRealm_get_arOptions_391=ClientRealm_get_arOptions(pointer);
          i=ArOptions_get_arTries(return_value_ClientRealm_get_arOptions_391);
          return_value_ClientRealm_get_arOptions_392=ClientRealm_get_arOptions(pointer);
          return_value_ArOptions_get_arQuit_393=ArOptions_get_arQuit(return_value_ClientRealm_get_arOptions_392);
          if((signed int)return_value_ArOptions_get_arQuit_393 == 0)
            i = 0;

          if(!(i == 0))
            aflog((char)2, (char)64, "SERVER: CLOSED -> auto-reconnect enabled");

          while(!(i == 0))
          {
            ClientRealm_closeUsersConnections(pointer);
            struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_394;
            return_value_ClientRealm_get_masterSslFd_394=ClientRealm_get_masterSslFd(pointer);
            signed int return_value_SslFd_get_fd_395;
            return_value_SslFd_get_fd_395=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd_394);
            close(return_value_SslFd_get_fd_395);
            struct anonymous_0 *return_value_ClientRealm_get_masterSslFd_396;
            return_value_ClientRealm_get_masterSslFd_396=ClientRealm_get_masterSslFd(pointer);
            SslFd_set_ssl(return_value_ClientRealm_get_masterSslFd_396, (struct ssl_st *)(void *)0);
            struct anonymous_3 *return_value_ClientRealm_get_arOptions_397;
            return_value_ClientRealm_get_arOptions_397=ClientRealm_get_arOptions(pointer);
            signed int return_value_ArOptions_get_arDelay_398;
            return_value_ArOptions_get_arDelay_398=ArOptions_get_arDelay(return_value_ClientRealm_get_arOptions_397);
            mysleep((double)return_value_ArOptions_get_arDelay_398);
            aflog((char)2, (char)8, "Trying to reconnect...");
            temp2 = 0;
            if(temp2 == 0)
            {
              char return_value_ClientConfiguration_get_ignorePublicKeys_399;
              return_value_ClientConfiguration_get_ignorePublicKeys_399=ClientConfiguration_get_ignorePublicKeys(cconfig);
              signed int return_value_initialize_client_stage1_400;
              return_value_initialize_client_stage1_400=initialize_client_stage1(pointer, ctx, buff, (char)0, return_value_ClientConfiguration_get_ignorePublicKeys_399);
              if(!(return_value_initialize_client_stage1_400 == 0))
                temp2 = 1;

            }

            if(temp2 == 0)
            {
              signed int return_value_initialize_client_stage2_401;
              return_value_initialize_client_stage2_401=initialize_client_stage2(pointer, buff, (char)0);
              if(!(return_value_initialize_client_stage2_401 == 0))
                temp2 = 1;

            }

            if(temp2 == 0)
            {
              signed int return_value_initialize_client_stage3_402;
              return_value_initialize_client_stage3_402=initialize_client_stage3(pointer, &buflength, &allset, &wset, &maxfdp1, (char)0);
              if(!(return_value_initialize_client_stage3_402 == 0))
                temp2 = 1;

            }

            if(temp2 == 0)
            {
              n = 1;
              aflog((char)2, (char)8, "Reconnected successfully...");
              usersTable=ClientRealm_get_usersTable(pointer);
              ClientRealm_send_realmId(pointer, buff);
              ClientRealm_enable_multi(pointer);
              break;
            }

            if(i >= 1)
              i = i - 1;

          }
          if(n == 0)
          {
            signed long int return_value_getcg_403;
            return_value_getcg_403=getcg();
            aflog((char)2, (char)8, "SERVER: CLOSED -> exiting... cg: %ld bytes", return_value_getcg_403);
            exit(1);
          }

          break;
        }
        case 9:
        {
          return_value_ConnectUser_get_state_406=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
          if((signed int)return_value_ConnectUser_get_state_406 == 7)
            tmp_if_expr_408 = (_Bool)1;

          else
          {
            return_value_ConnectUser_get_state_407=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
            tmp_if_expr_408 = (signed int)return_value_ConnectUser_get_state_407 == 11 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_408)
          {
            aflog((char)1, (char)2, "user[%d]: AF_S_DONT_SEND", numofcon);
            signed int return_value_ConnectUser_get_connFd_404;
            return_value_ConnectUser_get_connFd_404=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
            signed int return_value_ConnectUser_get_connFd_405;
            return_value_ConnectUser_get_connFd_405=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
            (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_404 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_404 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_405 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
          }

          else
            aflog((char)1, (char)2, "user[%d]: AF_S_DONT_SEND - ignored", numofcon);
          break;
        }
        case 10:
        {
          return_value_ConnectUser_get_state_411=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
          if((signed int)return_value_ConnectUser_get_state_411 == 7)
            tmp_if_expr_413 = (_Bool)1;

          else
          {
            return_value_ConnectUser_get_state_412=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
            tmp_if_expr_413 = (signed int)return_value_ConnectUser_get_state_412 == 11 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_413)
          {
            aflog((char)1, (char)2, "user[%d]: AF_S_CAN_SEND", numofcon);
            signed int return_value_ConnectUser_get_connFd_409;
            return_value_ConnectUser_get_connFd_409=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
            signed int return_value_ConnectUser_get_connFd_410;
            return_value_ConnectUser_get_connFd_410=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
            (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_409 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_409 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd_410 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
          }

          else
            aflog((char)1, (char)2, "user[%d]: AF_S_CAN_SEND - ignored", numofcon);
          break;
        }
        default:
        {
          return_value_getcg_414=getcg();
          aflog((char)2, (char)64, "SERVER: unrecognized message -> exiting... cg: %ld bytes", return_value_getcg_414);
          exit(1);
        }
      }
    }


  __CPROVER_DUMP_L286:
    ;
  }
  while((_Bool)1);
}

// make_ssl_accept
// file make_ssl_handshake.c line 55
signed int make_ssl_accept(struct anonymous_0 *sf)
{
  signed int result;
  struct ssl_st *return_value_SslFd_get_ssl_2;
  return_value_SslFd_get_ssl_2=SslFd_get_ssl(sf);
  result=SSL_accept(return_value_SslFd_get_ssl_2);
  if(!(result == 1))
  {
    signed int return_value_get_ssl_error_1;
    return_value_get_ssl_error_1=get_ssl_error(sf, "SSL_accept has failed", result);
    return return_value_get_ssl_error_1;
  }

  return 0;
}

// make_ssl_initialize
// file make_ssl_handshake.c line 37
void make_ssl_initialize(struct anonymous_0 *sf)
{
  struct ssl_st *return_value_SslFd_get_ssl_1;
  return_value_SslFd_get_ssl_1=SslFd_get_ssl(sf);
  signed int return_value_SslFd_get_fd_2;
  return_value_SslFd_get_fd_2=SslFd_get_fd(sf);
  signed int return_value_SSL_set_fd_3;
  return_value_SSL_set_fd_3=SSL_set_fd(return_value_SslFd_get_ssl_1, return_value_SslFd_get_fd_2);
  if(!(return_value_SSL_set_fd_3 == 1))
  {
    aflog((char)4, (char)1, "Problem with initializing ssl... exiting");
    exit(1);
  }

}

// myrand
// file http_proxy_functions.c line 42
signed int myrand(signed int down, signed int up)
{
  struct timeval tv;
  if(isseed == 0)
  {
    gettimeofday(&tv, ((struct timezone *)NULL));
    srand((unsigned int)tv.tv_sec);
    isseed = (char)1;
  }

  signed int return_value_rand_1;
  return_value_rand_1=rand();
  return down + return_value_rand_1 % ((up - down) + 1);
}

// mysleep
// file http_proxy_functions.h line 75
void mysleep(double time)
{
  struct timeval tv;
  tv.tv_sec = (signed long int)(signed int)time;
  tv.tv_usec = (signed long int)((signed int)(time * (double)1000000) % 1000000);
  select(0, (struct anonymous_11 *)(void *)0, (struct anonymous_11 *)(void *)0, (struct anonymous_11 *)(void *)0, &tv);
}

// parse_header
// file http_proxy_functions.c line 105
signed int parse_header(struct anonymous_0 *sf, char *tab, struct anonymous_15 *hdr, char https)
{
  signed int n;
  signed int i;
  signed int j;
  signed int state = 0;
  char tmpt[100l];
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl_1;
    return_value_SslFd_get_ssl_1=SslFd_get_ssl(sf);
    n=SSL_read(return_value_SslFd_get_ssl_1, (void *)tab, 9000);
  }

  else
  {
    signed int return_value_SslFd_get_fd_2;
    return_value_SslFd_get_fd_2=SslFd_get_fd(sf);
    signed long int return_value_read_3;
    return_value_read_3=read(return_value_SslFd_get_fd_2, (void *)tab, (unsigned long int)9000);
    n = (signed int)return_value_read_3;
  }
  hdr->allreaded = n;
  j = 0;
  i = j;
  memset((void *)tmpt, 0, (unsigned long int)100);
  hdr->ptr = 0;
  hdr->length = 0;
  _Bool tmp_if_expr_13;
  signed int tmp_statement_expression_4;
  signed int tmp_statement_expression_6;
  signed int tmp_statement_expression_8;
  _Bool tmp_if_expr_12;
  signed int tmp_statement_expression_10;
  signed int tmp_statement_expression_14;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_19;
  signed int tmp_statement_expression_17;
  for( ; !(i >= n); i = i + 1)
  {
    if(j == 99)
      return 1;

    switch(state)
    {
      case 0:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
          tmp_if_expr_13 = (signed int)tab[(signed long int)i] != 9 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_13 = (_Bool)0;
        if(tmp_if_expr_13)
        {
          tmpt[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }

        else
        {
          tmpt[(signed long int)j] = (char)0;
          unsigned long int parse_header__1__3__1__2__1____s1_len;
          unsigned long int parse_header__1__3__1__2__1____s2_len;
          signed int return_value___builtin_strcmp_5;
          return_value___builtin_strcmp_5=__builtin_strcmp(tmpt, "GET");
          tmp_statement_expression_4 = return_value___builtin_strcmp_5;
          if(tmp_statement_expression_4 == 0)
          {
            hdr->type = (char)0;
            state = 1;
            break;
          }

          unsigned long int parse_header__1__3__1__2__3____s1_len;
          unsigned long int parse_header__1__3__1__2__3____s2_len;
          signed int return_value___builtin_strcmp_7;
          return_value___builtin_strcmp_7=__builtin_strcmp(tmpt, "POST");
          tmp_statement_expression_6 = return_value___builtin_strcmp_7;
          if(tmp_statement_expression_6 == 0)
          {
            hdr->type = (char)1;
            state = 1;
            break;
          }

          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_9;
          return_value___builtin_strcmp_9=__builtin_strcmp(tmpt, "HTTP/1.0");
          tmp_statement_expression_8 = return_value___builtin_strcmp_9;
          if(tmp_statement_expression_8 == 0)
            tmp_if_expr_12 = (_Bool)1;

          else
          {
            unsigned long int parse_header__1__3__1__2__6____s1_len;
            unsigned long int parse_header__1__3__1__2__6____s2_len;
            signed int return_value___builtin_strcmp_11;
            return_value___builtin_strcmp_11=__builtin_strcmp(tmpt, "HTTP/1.1");
            tmp_statement_expression_10 = return_value___builtin_strcmp_11;
            tmp_if_expr_12 = tmp_statement_expression_10 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_12)
          {
            hdr->type = (char)2;
            state = 6;
            break;
          }

          return 1;
        }
        break;
      }
      case 1:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
        {
          if(!((signed int)tab[(signed long int)i] == 9))
          {
            tmpt[(signed long int)0] = tab[(signed long int)i];
            j = 1;
            state = 2;
          }

        }

        break;
      }
      case 2:
      {
        if(!((signed int)tab[(signed long int)i] == 61))
        {
          tmpt[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }

        else
        {
          tmpt[(signed long int)j] = (char)0;
          unsigned long int parse_header__1__3__1__5__1____s1_len;
          unsigned long int parse_header__1__3__1__5__1____s2_len;
          signed int return_value___builtin_strcmp_15;
          return_value___builtin_strcmp_15=__builtin_strcmp(tmpt, "/yahpt.html?id");
          tmp_statement_expression_14 = return_value___builtin_strcmp_15;
          if(!(tmp_statement_expression_14 == 0))
            return 1;

          j = 0;
          state = 3;
        }
        break;
      }
      case 3:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
          tmp_if_expr_16 = (signed int)tab[(signed long int)i] != 9 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_16 = (_Bool)0;
        if(tmp_if_expr_16)
        {
          if(j == 9)
            return 1;

          hdr->id[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }

        else
        {
          if(!(j == 9))
            return 1;

          hdr->id[(signed long int)j] = (char)0;
          state = 4;
        }
        break;
      }
      case 4:
      {
        if((signed int)tab[(signed long int)i] == 10)
          state = 5;

        break;
      }
      case 5:
      {
        if((signed int)tab[(signed long int)i] == 10)
        {
          hdr->ptr = i + 1;
          hdr->length = n - hdr->ptr;
          return 0;
        }

        if(!((signed int)tab[(signed long int)i] == 13))
          state = 4;

        break;
      }
      case 6:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
        {
          if(!((signed int)tab[(signed long int)i] == 9))
          {
            tmpt[(signed long int)0] = tab[(signed long int)i];
            j = 1;
            state = 7;
          }

        }

        break;
      }
      case 7:
      {
        if((signed int)tab[(signed long int)i] == 32)
          tmp_if_expr_19 = (_Bool)1;

        else
          tmp_if_expr_19 = (signed int)tab[(signed long int)i] == 9 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_19)
        {
          tmpt[(signed long int)j] = (char)0;
          unsigned long int parse_header__1__3__1__11__1____s1_len;
          unsigned long int parse_header__1__3__1__11__1____s2_len;
          signed int return_value___builtin_strcmp_18;
          return_value___builtin_strcmp_18=__builtin_strcmp(tmpt, "200");
          tmp_statement_expression_17 = return_value___builtin_strcmp_18;
          if(!(tmp_statement_expression_17 == 0))
            return 1;

          state = 4;
        }

        else
        {
          tmpt[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }
      }
    }
  }
  return 1;
}

// parse_line
// file file.c line 45
signed int parse_line(char *buff, char *tab1, char *tab2)
{
  signed int state;
  signed int i;
  signed int j;
  signed int lastDot;
  j = 0;
  i = j;
  state = i;
  lastDot = -1;
  _Bool tmp_if_expr_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  const unsigned short int **return_value___ctype_b_loc_4;
  const unsigned short int **return_value___ctype_b_loc_5;
  for( ; !((signed int)buff[(signed long int)i] == 0); i = i + 1)
  {
    if((signed int)buff[(signed long int)i] == 35)
    {
      if(i >= 1)
        tmp_if_expr_1 = (signed int)buff[(signed long int)(i - 1)] == 92 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        j = j - 1;

      else
        break;
    }

    switch(state)
    {
      case 0:
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
        {
          tab1[(signed long int)j] = buff[(signed long int)i];
          j = 1;
          state = 1;
        }

        break;
      }
      case 1:
      {
        return_value___ctype_b_loc_3=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)buff[(signed long int)i]]) == 0))
        {
          tab1[(signed long int)j] = (char)0;
          state = 2;
          j = 0;
        }

        else
        {
          tab1[(signed long int)j] = buff[(signed long int)i];
          j = j + 1;
        }
        break;
      }
      case 2:
      {
        return_value___ctype_b_loc_4=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
        {
          if(!((signed int)buff[(signed long int)i] == 46))
          {
            tab2[(signed long int)j] = buff[(signed long int)i];
            j = 1;
          }

          state = 3;
        }

        break;
      }
      case 3:
      {
        if((signed int)buff[(signed long int)i] == 46)
          lastDot = j;

        else
        {
          return_value___ctype_b_loc_5=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
            lastDot = -1;

          else
            if(lastDot == -1)
              lastDot = j;

        }
        tab2[(signed long int)j] = buff[(signed long int)i];
        j = j + 1;
      }
    }
  }
  if(!(lastDot == -1))
    tab2[(signed long int)lastDot] = (char)0;

  if(state == 3)
    return 2;

  else
    if(state == 0)
      return 0;

    else
      return 1;
}

// read_message
// file http_proxy_functions.c line 281
signed int read_message(signed int fd, signed int length, struct anonymous_16 *client, char *tab, signed int ptr)
{
  signed int j = 0;
  signed int tmp = 0;
  while(!(j >= length))
    if(!(client->toreceive >= client->curreceived + length + -j))
    {
      if(client->toreceive + -client->curreceived >= 1)
      {
        writen(fd, (unsigned char *)(tab + (signed long int)ptr + (signed long int)j), client->toreceive - client->curreceived);
        j = j + (client->toreceive - client->curreceived);
        client->curreceived = client->curreceived + (client->toreceive - client->curreceived);
      }

      if((signed int)client->read_state == 0)
        switch((signed int)tab[(signed long int)(ptr + j)])
        {
          case 77:
          {
            if(length >= 5 + j)
            {
              memcpy((void *)&tmp, (const void *)&tab[(signed long int)(ptr + j + 1)], (unsigned long int)4);
              unsigned int return_value___bswap_32_1;
              return_value___bswap_32_1=__bswap_32((unsigned int)tmp);
              client->toreceive = (signed int)return_value___bswap_32_1;
              client->curreceived = 0;
              j = j + 5;
            }

            else
              if(!(1 + j >= length))
              {
                memcpy((void *)client->readed_length, (const void *)&tab[(signed long int)(ptr + j + 1)], (unsigned long int)((length - j) - 1));
                client->read_state = (char)(length - j);
                j = j + (length - j);
              }

              else
              {
                j = j + 1;
                client->read_state = (char)1;
              }
            break;
          }
          case 84:
          {
            j = j + 1;
            break;
          }
          case 65:
          {
            j = j + 1;
            if((signed int)client->state == 0)
              client->state = (char)4;

            break;
          }
          default:
            return 1;
        }

      else
        if(length >= 5 + j + -((signed int)client->read_state))
        {
          memcpy((void *)&client->readed_length[(signed long int)((signed int)client->read_state - 1)], (const void *)&tab[(signed long int)(ptr + j)], (unsigned long int)(5 - (signed int)client->read_state));
          memcpy((void *)&tmp, (const void *)client->readed_length, (unsigned long int)4);
          unsigned int return_value___bswap_32_2;
          return_value___bswap_32_2=__bswap_32((unsigned int)tmp);
          client->toreceive = (signed int)return_value___bswap_32_2;
          client->curreceived = 0;
          j = j + (5 - (signed int)client->read_state);
          client->read_state = (char)0;
        }

        else
        {
          memcpy((void *)&client->readed_length[(signed long int)((signed int)client->read_state - 1)], (const void *)&tab[(signed long int)(ptr + j)], (unsigned long int)(length - j));
          client->read_state = client->read_state + (char)(length - j);
          j = j + (length - j);
        }
    }

    else
      if(length + -j >= 1)
      {
        client->curreceived = client->curreceived + (length - j);
        writen(fd, (unsigned char *)(tab + (signed long int)ptr + (signed long int)j), length - j);
        j = j + (length - j);
      }

  return 0;
}

// readn
// file network.c line 542
signed int readn(signed int fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    signed long int return_value_read_1;
    return_value_read_1=read(fd, (void *)(buf + (signed long int)sent), (unsigned long int)(amount - sent));
    n = (signed int)return_value_read_1;
    if(!(n == -1))
      sent = sent + n;

    if(n == 0)
      return 0;

    if(n == -1)
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 11))
        return 0;

    }

  }
  return amount;
}

// remember_mainthread
// file thread_management.h line 26
void remember_mainthread(void)
{
  mainthread=pthread_self();
}

// resetcg
// file stats.c line 84
void resetcg(void)
{
  compressgained = (signed long int)0;
}

// server_long_usage
// file usage.c line 52
void server_long_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf(" Basic options:\n\n");
  printf("  -n, --hostname      - it's used when creating listening sockets\n");
  printf("                        (default: '')\n");
  printf("  -l, --listenport    - listening [host:]port - users connect to it\n");
  printf("                        (default: 50127)\n");
  printf("  -m, --manageport    - manage [host:]port - afclient connects to it\n");
  printf("                        (default: 50126)\n");
  printf("  -V, --version       - display version number\n");
  printf("  -h, --help          - prints this help\n\n");
  printf(" Authorization:\n\n");
  printf("  --pass              - set the password used for client identification\n");
  printf("                        (default: no password)\n\n");
  printf(" Configuration:\n\n");
  printf("  -c, --cerfile       - the name of the file with certificate\n");
  printf("                        (default: server-cert.pem)\n");
  printf("  -A, --cacerfile     - the name of the file with CA certificates\n");
  printf("                        (if used, require clients to have valid certificates)\n");
  printf("  -d, --cerdepth      - the maximum depth of valid certificate-chains\n");
  printf("  -k, --keyfile       - the name of the file with RSA key (default: server.rsa)\n");
  printf("  -f, --cfgfile       - the name of the file with the configuration for the\n");
  printf("                        active forwarder (server)\n");
  printf("  -D, --dateformat    - format of the date printed in logs (see 'man strftime'\n");
  printf("                        for details) (default: %%Y-%%m-%%d %%H:%%M:%%S)\n");
  printf("  -t, --timeout       - the timeout value for the client's connection\n");
  printf("                        (default: 5)\n");
  printf("  --maxidle           - the maximum idle time for the client's connection\n");
  printf("                        (default: disabled)\n");
  printf("  -u, --users         - the amount of users allowed to use this server\n");
  printf("                        (default: 5)\n");
  printf("  -C, --clients       - the number of allowed clients to use this server\n");
  printf("                        (default: 1)\n");
  printf("  -r, --realm         - set the realm name (default: none)\n");
  printf("  -R, --raclients     - the number of allowed clients in remote administration\n");
  printf("                        mode to use this server (default: 1)\n");
  printf("  -U, --usrpcli       - the number of allowed users per client (default: _users)\n");
  printf("  -M, --climode       - strategy used to connect users with clients (default: 1)\n");
  printf("                      Available strategies:\n");
  printf("                        1. fill first client before go to next\n\n");
  printf("  -p, --proto         - type of server (tcp|udp) - what protocol it will be\n");
  printf("                        operating for (default: tcp)\n");
  printf("  -b, --baseport      - listenports are temporary and differ for each client\n");
  printf("  -a, --audit         - additional information about connections are logged\n");
  printf("  --nossl             - ssl is not used to transfer data (but it's still used\n");
  printf("                        to establish a connection) (default: ssl is used)\n");
  printf("  --nozlib            - zlib is not used to compress data (default: zlib is\n");
  printf("                        used)\n");
  printf("  --dnslookups        - try to obtain dns names of the computers rather than\n");
  printf("                        their numeric IP\n\n");
  printf(" Logging:\n\n");
  printf("  -o, --log           - log choosen information to file/socket\n");
  printf("  -v, --verbose       - to be verbose - program won't enter the daemon mode\n");
  printf("                        (use several times for greater effect)\n\n");
  printf(" IP family:\n\n");
  printf("  -4, --ipv4          - use ipv4 only\n");
  printf("  -6, --ipv6          - use ipv6 only\n\n");
  printf(" HTTP PROXY:\n\n");
  printf("  -P, --enableproxy   - enable http proxy mode\n\n");
  exit(0);
}

// server_short_usage
// file usage.c line 36
void server_short_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf("Try `afserver --help' for more information.\n");
  exit(1);
}

// set_fd
// file http_proxy_functions.c line 235
void set_fd(signed int fd, signed int *maxfdp1, struct anonymous_11 *allset)
{
  allset->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = allset->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  signed int tmp_if_expr_1;
  if(!(fd >= *maxfdp1))
    tmp_if_expr_1 = *maxfdp1;

  else
    tmp_if_expr_1 = fd + 1;
  *maxfdp1 = tmp_if_expr_1;
}

// setdateformat
// file logging.c line 41
void setdateformat(char *dateformat)
{
  if(!(dateformat == ((char *)NULL)))
    __builtin_strncpy(format, dateformat, (unsigned long int)50);

}

// sock_ntop
// file network.c line 350
char * sock_ntop(struct sockaddr *sa, unsigned int salen, char *namebuf, char *portbuf, char type)
{
  char portstr[7l];
  struct sockaddr_in *sin;
  unsigned short int tmp_statement_expression_5;
  unsigned short int tmp_statement_expression_3;
  unsigned short int tmp_statement_expression_4;
  struct sockaddr_in6 *sin6;
  unsigned short int tmp_statement_expression_10;
  unsigned short int tmp_statement_expression_8;
  unsigned short int tmp_statement_expression_9;
  switch((signed int)sa->sa_family)
  {    static char str[136l];
    case 2:
    {
      sin = (struct sockaddr_in *)sa;
      if(!(type == 0))
      {
        signed int return_value_getnameinfo_1;
        return_value_getnameinfo_1=getnameinfo(sa, salen, str, (unsigned int)128, (char *)(void *)0, (unsigned int)0, 0);
        if(!(return_value_getnameinfo_1 == 0))
          return (char *)(void *)0;

      }

      else
      {
        const char *return_value_inet_ntop_2;
        return_value_inet_ntop_2=inet_ntop(2, (void *)&sin->sin_addr, str, (unsigned int)sizeof(char [136l]) /*136ul*/ );
        if(return_value_inet_ntop_2 == ((const char *)NULL))
          return (char *)(void *)0;

      }
      if(!(namebuf == ((char *)NULL)))
        memcpy((void *)namebuf, (const void *)str, (unsigned long int)128);

      unsigned short int sock_ntop__1__1__1__4____v;
      unsigned short int sock_ntop__1__1__1__4____x = (unsigned short int)sin->sin_port;
      asm("rorw _8, %w0" : "=r"(sock_ntop__1__1__1__4____v) : "0"(sock_ntop__1__1__1__4____x) : "cc");
      tmp_statement_expression_5 = sock_ntop__1__1__1__4____v;
      if(!((signed int)tmp_statement_expression_5 == 0))
      {
        unsigned short int sock_ntop__1__1__1__5__1____v;
        unsigned short int sock_ntop__1__1__1__5__1____x = (unsigned short int)sin->sin_port;
        asm("rorw _8, %w0" : "=r"(sock_ntop__1__1__1__5__1____v) : "0"(sock_ntop__1__1__1__5__1____x) : "cc");
        tmp_statement_expression_3 = sock_ntop__1__1__1__5__1____v;
        snprintf(portstr, sizeof(char [7l]) /*7ul*/ , ".%d", tmp_statement_expression_3);
        if(!(portbuf == ((char *)NULL)))
        {
          unsigned short int sock_ntop__1__1__1__5__2__1____v;
          unsigned short int sock_ntop__1__1__1__5__2__1____x = (unsigned short int)sin->sin_port;
          asm("rorw _8, %w0" : "=r"(sock_ntop__1__1__1__5__2__1____v) : "0"(sock_ntop__1__1__1__5__2__1____x) : "cc");
          tmp_statement_expression_4 = sock_ntop__1__1__1__5__2__1____v;
          snprintf(portbuf, (unsigned long int)7, "%d", tmp_statement_expression_4);
        }

        strcat(str, portstr);
      }

      return str;
    }
    case 10:
    {
      sin6 = (struct sockaddr_in6 *)sa;
      if(!(type == 0))
      {
        signed int return_value_getnameinfo_6;
        return_value_getnameinfo_6=getnameinfo(sa, salen, str, (unsigned int)128, (char *)(void *)0, (unsigned int)0, 0);
        if(!(return_value_getnameinfo_6 == 0))
          return (char *)(void *)0;

      }

      else
      {
        const char *return_value_inet_ntop_7;
        return_value_inet_ntop_7=inet_ntop(10, (const void *)&sin6->sin6_addr, str, (unsigned int)sizeof(char [136l]) /*136ul*/ );
        if(return_value_inet_ntop_7 == ((const char *)NULL))
          return (char *)(void *)0;

      }
      if(!(namebuf == ((char *)NULL)))
        memcpy((void *)namebuf, (const void *)str, (unsigned long int)128);

      unsigned short int __v;
      unsigned short int __x = (unsigned short int)sin6->sin6_port;
      asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression_10 = __v;
      if(!((signed int)tmp_statement_expression_10 == 0))
      {
        unsigned short int sock_ntop__1__1__2__5__1____v;
        unsigned short int sock_ntop__1__1__2__5__1____x = (unsigned short int)sin6->sin6_port;
        asm("rorw _8, %w0" : "=r"(sock_ntop__1__1__2__5__1____v) : "0"(sock_ntop__1__1__2__5__1____x) : "cc");
        tmp_statement_expression_8 = sock_ntop__1__1__2__5__1____v;
        snprintf(portstr, sizeof(char [7l]) /*7ul*/ , ".%d", tmp_statement_expression_8);
        if(!(portbuf == ((char *)NULL)))
        {
          unsigned short int sock_ntop__1__1__2__5__2__1____v;
          unsigned short int sock_ntop__1__1__2__5__2__1____x = (unsigned short int)sin6->sin6_port;
          asm("rorw _8, %w0" : "=r"(sock_ntop__1__1__2__5__2__1____v) : "0"(sock_ntop__1__1__2__5__2__1____x) : "cc");
          tmp_statement_expression_9 = sock_ntop__1__1__2__5__2__1____v;
          snprintf(portbuf, (unsigned long int)7, "%d", tmp_statement_expression_9);
        }

        strcat(str, portstr);
      }

      return str;
    }
    default:
    {
      snprintf(str, sizeof(char [136l]) /*136ul*/ , "sock_ntop: unknown AF_xxx: %d, len %d", sa->sa_family, salen);
      return str;
    }
  }
  return (char *)(void *)0;
}

// start_critical_section
// file thread_management.h line 28
void start_critical_section(void)
{
  pthread_mutex_lock(&mainmutex);
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 453
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat_1;
  return_value___xstat_1=__xstat(1, __path, __statbuf);
  return return_value___xstat_1;
}

// string_cp
// file string_functions.h line 24
char * string_cp(char **dest, char *src)
{
  char *tmp;
  signed int len = 0;
  if(!(dest == ((char **)NULL)))
  {
    if(!(*dest == ((char *)NULL)))
    {
      if(*dest == src)
        return *dest;

      free((void *)*dest);
      *dest = (char *)(void *)0;
    }

  }

  if(src == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(src);
    len = (signed int)return_value_strlen_1;
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)1, (unsigned long int)(len + 1));
    tmp = (char *)return_value_calloc_2;
    if(tmp == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      __builtin_strncpy(tmp, src, (unsigned long int)len);
      if(!(dest == ((char **)NULL)))
        *dest = tmp;

      return tmp;
    }
  }
}

// timeperiod
// file stats.c line 35
char * timeperiod(signed long int period)
{
  signed int hours;
  signed int minutes;
  signed int seconds;
  static char timeper[41l];
  memset((void *)timeper, 0, (unsigned long int)41);
  hours = (signed int)(period / (signed long int)3600);
  minutes = (signed int)((period / (signed long int)60) % (signed long int)60);
  seconds = (signed int)(period % (signed long int)60);
  if(!(hours == 0))
    sprintf(timeper, "%d:%02d:%02d", hours, minutes, seconds);

  else
    sprintf(timeper, "%d:%02d", minutes, seconds);
  return timeper;
}

// timeval_compare
// file timeval_functions.c line 56
signed int timeval_compare(struct timeval *first, struct timeval *second)
{
  if(first == ((struct timeval *)NULL))
  {
    if(second == ((struct timeval *)NULL))
      return 0;

    return -1;
  }

  else
    if(second == ((struct timeval *)NULL))
      return 1;

    else
      if(!(first->tv_sec >= second->tv_sec))
        return -1;

      else
        if(!(second->tv_sec >= first->tv_sec))
          return 1;

        else
          if(!(first->tv_usec >= second->tv_usec))
            return -1;

          else
            if(!(second->tv_usec >= first->tv_usec))
              return 1;

            else
              return 0;
}

// timeval_create
// file timeval_functions.c line 37
struct timeval timeval_create(signed long int tv_sec, signed long int tv_usec)
{
  struct timeval tmp;
  tmp.tv_sec = tv_sec;
  tmp.tv_usec = tv_usec;
  return tmp;
}

// timeval_lq_zero
// file timeval_functions.c line 121
signed int timeval_lq_zero(struct timeval *timer)
{
  if(timer == ((struct timeval *)NULL))
    return 0;

  else
    if(!(timer->tv_sec >= 0l))
      return 1;

    else
      if(timer->tv_sec == 0l)
      {
        if(!(timer->tv_usec == 0l))
          goto __CPROVER_DUMP_L3;

        return 1;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        return 0;
      }
}

// timeval_subtract
// file timeval_functions.c line 94
signed int timeval_subtract(struct timeval *first, struct timeval *second)
{
  if(first == ((struct timeval *)NULL) || second == ((struct timeval *)NULL))
    return 1;

  else
  {
    if(!(first->tv_usec >= second->tv_usec))
    {
      first->tv_sec = first->tv_sec - (signed long int)1;
      first->tv_usec = ((signed long int)1000000 - second->tv_usec) + first->tv_usec;
    }

    else
      first->tv_usec = first->tv_usec - second->tv_usec;
    first->tv_sec = first->tv_sec - second->tv_sec;
    return 0;
  }
}

// wait_for_condition
// file thread_management.h line 30
void wait_for_condition(void)
{
  pthread_cond_wait(&maincond, &mainmutex);
}

// writen
// file network.c line 513
signed int writen(signed int fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    signed long int return_value_write_1;
    return_value_write_1=write(fd, (const void *)(buf + (signed long int)sent), (unsigned long int)(amount - sent));
    n = (signed int)return_value_write_1;
    if(!(n == -1))
      sent = sent + n;

    if(n == -1)
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 11))
        return 0;

    }

  }
  return amount;
}

