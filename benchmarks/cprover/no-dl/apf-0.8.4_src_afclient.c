// tag-#anon#ST[*{S8}$S8$'artries'||S32'tries'||U32'$pad0'||*{S8}$S8$'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'$pad1'|]
// file ar_options_struct.h line 28
struct anonymous$3;

// tag-#anon#ST[*{S8}$S8$'keysFile'||*{S8}$S8$'certificateFile'||*{S8}$S8$'storeFile'||*{S8}$S8$'dateFormat'||S32'realmsNumber'||S8'ignorePublicKeys'||U24'$pad0'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'serverName'||*{S8}$S8$'managePort'||*{S8}$S8$'hostName'||*{S8}$S8$'realmName'||*{S8}$S8$'sKeepAliveTimeout'||*{S8}$S8$'realmId'||*{S8}$S8$'localName'||*{S8}$S8$'localPort'||*{S8}$S8$'localDestinationName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'clientMode'||S32'keepAliveTimeout'||S8'ipFamily'||S8'realmType'||S8'tunnelType'||U8'$pad0'||SYM#tag-timeval#'keepAlive'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'masterSslFd'||*{SYM#tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]#$'httpProxyOptions'||*{SYM#tag-#anon#ST[*{S8}$S8$'artries'||S32'tries'||U32'$pad0'||*{S8}$S8$'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'$pad1'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'artries'||S32'tries'||U32'$pad0'||*{S8}$S8$'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'$pad1'|]#$'arOptions'||*{SYM#tag-portlist#}$SYM#tag-portlist#$'destinationPorts'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#}$SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#$'userModule'||*{SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#}$SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#$'serviceModule'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'serverName'||*{S8}$S8$'managePort'||*{S8}$S8$'hostName'||*{S8}$S8$'realmName'||*{S8}$S8$'sKeepAliveTimeout'||*{S8}$S8$'realmId'||*{S8}$S8$'localName'||*{S8}$S8$'localPort'||*{S8}$S8$'localDestinationName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'clientMode'||S32'keepAliveTimeout'||S8'ipFamily'||S8'realmType'||S8'tunnelType'||U8'$pad0'||SYM#tag-timeval#'keepAlive'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'masterSslFd'||*{SYM#tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]#$'httpProxyOptions'||*{SYM#tag-#anon#ST[*{S8}$S8$'artries'||S32'tries'||U32'$pad0'||*{S8}$S8$'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'$pad1'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'artries'||S32'tries'||U32'$pad0'||*{S8}$S8$'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'$pad1'|]#$'arOptions'||*{SYM#tag-portlist#}$SYM#tag-portlist#$'destinationPorts'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#}$SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#$'userModule'||*{SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#}$SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#$'serviceModule'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'serverName'||*{S8}$S8$'managePort'||*{S8}$S8$'hostName'||*{S8}$S8$'realmName'||*{S8}$S8$'sKeepAliveTimeout'||*{S8}$S8$'realmId'||*{S8}$S8$'localName'||*{S8}$S8$'localPort'||*{S8}$S8$'localDestinationName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'clientMode'||S32'keepAliveTimeout'||S8'ipFamily'||S8'realmType'||S8'tunnelType'||U8'$pad0'||SYM#tag-timeval#'keepAlive'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'masterSslFd'||*{SYM#tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]#$'httpProxyOptions'||*{SYM#tag-#anon#ST[*{S8}$S8$'artries'||S32'tries'||U32'$pad0'||*{S8}$S8$'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'$pad1'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'artries'||S32'tries'||U32'$pad0'||*{S8}$S8$'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'$pad1'|]#$'arOptions'||*{SYM#tag-portlist#}$SYM#tag-portlist#$'destinationPorts'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#}$SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#$'userModule'||*{SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#}$SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#$'serviceModule'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'serverName'||*{S8}$S8$'managePort'||*{S8}$S8$'hostName'||*{S8}$S8$'realmName'||*{S8}$S8$'sKeepAliveTimeout'||*{S8}$S8$'realmId'||*{S8}$S8$'localName'||*{S8}$S8$'localPort'||*{S8}$S8$'localDestinationName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'clientMode'||S32'keepAliveTimeout'||S8'ipFamily'||S8'realmType'||S8'tunnelType'||U8'$pad0'||SYM#tag-timeval#'keepAlive'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'masterSslFd'||*{SYM#tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]#$'httpProxyOptions'||*{SYM#tag-#anon#ST[*{S8}$S8$'artries'||S32'tries'||U32'$pad0'||*{S8}$S8$'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'$pad1'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'artries'||S32'tries'||U32'$pad0'||*{S8}$S8$'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'$pad1'|]#$'arOptions'||*{SYM#tag-portlist#}$SYM#tag-portlist#$'destinationPorts'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#}$SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#$'userModule'||*{SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#}$SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#$'serviceModule'|]#$$'realmsTable'|]
// file client_configuration_struct.h line 27
struct anonymous$4;

// tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]
// file usr_cli_struct.h line 25
struct anonymous$1;

// tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]
// file http_proxy_options_struct.h line 31
struct anonymous;

// tag-#anon#ST[*{S8}$S8$'serverName'||*{S8}$S8$'managePort'||*{S8}$S8$'hostName'||*{S8}$S8$'realmName'||*{S8}$S8$'sKeepAliveTimeout'||*{S8}$S8$'realmId'||*{S8}$S8$'localName'||*{S8}$S8$'localPort'||*{S8}$S8$'localDestinationName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'clientMode'||S32'keepAliveTimeout'||S8'ipFamily'||S8'realmType'||S8'tunnelType'||U8'$pad0'||SYM#tag-timeval#'keepAlive'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'masterSslFd'||*{SYM#tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]#$'httpProxyOptions'||*{SYM#tag-#anon#ST[*{S8}$S8$'artries'||S32'tries'||U32'$pad0'||*{S8}$S8$'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'$pad1'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'artries'||S32'tries'||U32'$pad0'||*{S8}$S8$'ardelay'||S32'delay'||S8'start'||S8'quit'||S8'premature'||U8'$pad1'|]#$'arOptions'||*{SYM#tag-portlist#}$SYM#tag-portlist#$'destinationPorts'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#}$SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#$'userModule'||*{SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#}$SYM#tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]#$'serviceModule'|]
// file client_realm_struct.h line 42
struct anonymous$5;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$31;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$29;

// tag-#anon#ST[ARR128{U8}$U8$'cert_verify_md'||ARR128{U8}$U8$'finish_md'||S32'finish_md_len'||ARR128{U8}$U8$'peer_finish_md'||S32'peer_finish_md_len'||U64'message_size'||S32'message_type'||U32'$pad0'||*{cSYM#tag-ssl_cipher_st#}$cSYM#tag-ssl_cipher_st#$'new_cipher'||*{SYM#tag-dh_st#}$SYM#tag-dh_st#$'dh'||*{SYM#tag-ec_key_st#}$SYM#tag-ec_key_st#$'ecdh'||S32'next_state'||S32'reuse_message'||S32'cert_req'||S32'ctype_num'||ARR9{S8}$S8$'ctype'||U56'$pad1'||*{SYM#tag-stack_st_X509_NAME#}$SYM#tag-stack_st_X509_NAME#$'ca_names'||S32'use_rsa_tmp'||S32'key_block_length'||*{U8}$U8$'key_block'||*{cSYM#tag-evp_cipher_st#}$cSYM#tag-evp_cipher_st#$'new_sym_enc'||*{cSYM#tag-env_md_st#}$cSYM#tag-env_md_st#$'new_hash'||S32'new_mac_pkey_type'||S32'new_mac_secret_size'||*{cSYM#tag-ssl_comp_st#}$cSYM#tag-ssl_comp_st#$'new_compression'||S32'cert_request'||U32'$pad2'|]
// file /usr/include/openssl/ssl3.h line 553
struct anonymous$21;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$11;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$18;

// tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]
// file header_buffer_struct.h line 24
struct anonymous$2;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 140
struct anonymous$23;

// tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]
// file ssl_fd_struct.h line 27
struct anonymous$0;

// tag-#anon#ST[S32'sess_connect'||S32'sess_connect_renegotiate'||S32'sess_connect_good'||S32'sess_accept'||S32'sess_accept_renegotiate'||S32'sess_accept_good'||S32'sess_miss'||S32'sess_timeout'||S32'sess_cache_full'||S32'sess_hit'||S32'sess_cb_hit'|]
// file /usr/include/openssl/ssl.h line 964
struct anonymous$8;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$25;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$28;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$27;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$33;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$26;

// tag-#anon#ST[S32'sockfd'||U32'$pad0'||*{S8}$S8$'host'||*{S8}$S8$'serv'||*{SYM#tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'proxyname'||*{S8}$S8$'proxyport'||*{S8}$S8$'proxyauth_cred'||S8'proxyauth_type'||S8'useHttps'||U48'$pad0'|]#$'hpo'||S8'type'||U56'$pad1'||*{SYM#tag-ssl_ctx_st#}$SYM#tag-ssl_ctx_st#$'ctx'|]
// file http_proxy_client.c line 32
struct anonymous$19;

// tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]
// file user_stats_struct.h line 27
struct anonymous$14;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$30;

// tag-#anon#ST[S8'loaded'||U56'$pad0'||*{S8}$S8$'fileName'||*{V}$V$'handle'||*{*{S8}$S8$()->*{S8}$S8$}$*{S8}$S8$()->*{S8}$S8$$'info'||*{S32(*{S8}$S8$|*{S8}$S8$)->S32}$S32(*{S8}$S8$|*{S8}$S8$)->S32$'allow'||*{S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32}$S32(*{S8}$S8$|*{U8}$U8$|*{S32}$S32$)->S32$'filter'|]
// file module_struct.h line 28
struct anonymous$6;

// tag-#anon#ST[S8'read_state'||ARR4{S8}$S8$'readed_length'||S8'state'||ARR10{S8}$S8$'id'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'postFd'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'getFd'||S32'sent_ptr'||S32'sockfd'||ARR9000{S8}$S8$'buf'||ARR9000{S8}$S8$'tmpbuf'||S8'tmpstate'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'tmpFd'||S8'type'||U24'$pad1'||SYM#tag-#anon#ST[S8'type'||ARR10{S8}$S8$'id'||U8'$pad0'||S32'ptr'||S32'length'||S32'allreaded'|]#'tmpheader'||S32'ptr'||S32'length'||S32'curreceived'||S32'toreceive'||S32'received'|]
// file http_proxy_functions.h line 52
struct anonymous$16;

// tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]
// file connect_user_struct.h line 30
struct anonymous$7;

// tag-#anon#ST[S8'type'||ARR10{S8}$S8$'id'||U8'$pad0'||S32'ptr'||S32'length'||S32'allreaded'|]
// file http_proxy_functions.h line 44
struct anonymous$15;

// tag-#anon#ST[U32'conn_id_length'||U32'cert_type'||U32'cert_length'||U32'csl'||U32'clear'||U32'enc'||ARR32{U8}$U8$'ccl'||U32'cipher_spec_length'||U32'session_id_length'||U32'clen'||U32'rlen'|]
// file /usr/include/openssl/ssl2.h line 203
struct anonymous$20;

// tag-#anon#UN[*{S8}$S8$'ptr'||*{SYM#tag-rsa_st#}$SYM#tag-rsa_st#$'rsa'||*{SYM#tag-dsa_st#}$SYM#tag-dsa_st#$'dsa'||*{SYM#tag-dh_st#}$SYM#tag-dh_st#$'dh'||*{SYM#tag-ec_key_st#}$SYM#tag-ec_key_st#$'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous$13;

// tag-#anon#UN[*{S8}$S8$'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'asn1_string'||*{SYM#tag-asn1_object_st#}$SYM#tag-asn1_object_st#$'object'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'integer'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'enumerated'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'bit_string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'octet_string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'printablestring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'t61string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'ia5string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'generalstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'bmpstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'universalstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'utctime'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'generalizedtime'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'visiblestring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'utf8string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'set'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'sequence'||*{SYM#tag-ASN1_VALUE_st#}$SYM#tag-ASN1_VALUE_st#$'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous$12;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$17;

// tag-#anon#UN[*{V(S32|S32|*{V}$V$)->V}$V(S32|S32|*{V}$V$)->V$'cb_1'||*{S32(S32|S32|*{SYM#tag-bn_gencb_st#}$SYM#tag-bn_gencb_st#$)->S32}$S32(S32|S32|*{SYM#tag-bn_gencb_st#}$SYM#tag-bn_gencb_st#$)->S32$'cb_2'|]
// file /usr/include/openssl/bn.h line 351
union anonymous$10;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$9;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$32;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 138
union anonymous$24;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$22;

// tag-ASN1_ENCODING_st
// file /usr/include/openssl/asn1.h line 257
struct ASN1_ENCODING_st;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-AUTHORITY_KEYID_st
// file /usr/include/openssl/ossl_typ.h line 186
struct AUTHORITY_KEYID_st;

// tag-DSA_SIG_st
// file /usr/include/openssl/dsa.h line 124
struct DSA_SIG_st;

// tag-ISSUING_DIST_POINT_st
// file /usr/include/openssl/ossl_typ.h line 188
struct ISSUING_DIST_POINT_st;

// tag-NAME_CONSTRAINTS_st
// file /usr/include/openssl/ossl_typ.h line 189
struct NAME_CONSTRAINTS_st;

// tag-X509_POLICY_CACHE_st
// file /usr/include/openssl/ossl_typ.h line 184
struct X509_POLICY_CACHE_st;

// tag-X509_POLICY_TREE_st
// file /usr/include/openssl/ossl_typ.h line 183
struct X509_POLICY_TREE_st;

// tag-X509_VERIFY_PARAM_ID_st
// file /usr/include/openssl/x509_vfy.h line 159
struct X509_VERIFY_PARAM_ID_st;

// tag-X509_VERIFY_PARAM_st
// file /usr/include/openssl/x509_vfy.h line 167
struct X509_VERIFY_PARAM_st;

// tag-X509_algor_st
// file /usr/include/openssl/ossl_typ.h line 155
struct X509_algor_st;

// tag-X509_crl_info_st
// file /usr/include/openssl/x509.h line 441
struct X509_crl_info_st;

// tag-X509_crl_st
// file /usr/include/openssl/ossl_typ.h line 156
struct X509_crl_st;

// tag-X509_name_entry_st
// file /usr/include/openssl/x509.h line 168
struct X509_name_entry_st;

// tag-X509_name_st
// file /usr/include/openssl/ossl_typ.h line 159
struct X509_name_st;

// tag-X509_pubkey_st
// file /usr/include/openssl/ossl_typ.h line 160
struct X509_pubkey_st;

// tag-X509_req_info_st
// file /usr/include/openssl/x509.h line 226
struct X509_req_info_st;

// tag-X509_req_st
// file /usr/include/openssl/x509.h line 235
struct X509_req_st;

// tag-X509_val_st
// file /usr/include/openssl/x509.h line 152
struct X509_val_st;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_pqueue
// file /usr/include/openssl/pqueue.h line 70
struct _pqueue;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-alnode
// file audit_list_node_struct.h line 26
struct alnode;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-auditlist
// file audit_list_struct.h line 26
struct auditlist;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-blnode
// file buf_list_node_struct.h line 24
struct blnode;

// tag-bn_blinding_st
// file /usr/include/openssl/ossl_typ.h line 122
struct bn_blinding_st;

// tag-bn_gencb_st
// file /usr/include/openssl/ossl_typ.h line 125
struct bn_gencb_st;

// tag-bn_mont_ctx_st
// file /usr/include/openssl/ossl_typ.h line 123
struct bn_mont_ctx_st;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-buflist
// file buf_list_struct.h line 26
struct buflist;

// tag-cert_st
// file /usr/include/openssl/ssl.h line 1035
struct cert_st;

// tag-comp_ctx_st
// file /usr/include/openssl/comp.h line 11
struct comp_ctx_st;

// tag-comp_method_st
// file /usr/include/openssl/comp.h line 13
struct comp_method_st;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-dh_method
// file /usr/include/openssl/ossl_typ.h line 141
struct dh_method;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dsa_method
// file /usr/include/openssl/ossl_typ.h line 144
struct dsa_method;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-dtls1_bitmap_st
// file /usr/include/openssl/dtls1.h line 128
struct dtls1_bitmap_st;

// tag-dtls1_retransmit_state
// file /usr/include/openssl/dtls1.h line 135
struct dtls1_retransmit_state;

// tag-dtls1_state_st
// file /usr/include/openssl/ssl.h line 1493
struct dtls1_state_st;

// tag-dtls1_timeout_st
// file /usr/include/openssl/dtls1.h line 162
struct dtls1_timeout_st;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-entry
// file first_run.c line 40
struct entry;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-hm_header_st
// file /usr/include/openssl/dtls1.h line 147
struct hm_header_st;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-lhash_st_SSL_SESSION
// file /usr/include/openssl/ssl.h line 923
struct lhash_st_SSL_SESSION;

// tag-llnode
// file logging.h line 54
struct llnode;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-plnode
// file port_list_node_struct.h line 24
struct plnode;

// tag-portlist
// file port_list_struct.h line 26
struct portlist;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-record_pqueue_st
// file /usr/include/openssl/dtls1.h line 171
struct record_pqueue_st;

// tag-rsa_meth_st
// file /usr/include/openssl/ossl_typ.h line 147
struct rsa_meth_st;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-sess_cert_st
// file /usr/include/openssl/ssl.h line 531
struct sess_cert_st;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-srp_ctx_st
// file /usr/include/openssl/ssl.h line 849
struct srp_ctx_st;

// tag-srtp_protection_profile_st
// file /usr/include/openssl/ssl.h line 383
struct srtp_protection_profile_st;

// tag-ssl2_state_st
// file /usr/include/openssl/ssl.h line 1491
struct ssl2_state_st;

// tag-ssl3_buf_freelist_st
// file /usr/include/openssl/ssl.h line 1114
struct ssl3_buf_freelist_st;

// tag-ssl3_buffer_st
// file /usr/include/openssl/ssl3.h line 438
struct ssl3_buffer_st;

// tag-ssl3_enc_method
// file /usr/include/openssl/ssl.h line 466
struct ssl3_enc_method;

// tag-ssl3_record_st
// file /usr/include/openssl/ssl3.h line 403
struct ssl3_record_st;

// tag-ssl3_state_st
// file /usr/include/openssl/ssl.h line 1492
struct ssl3_state_st;

// tag-ssl_cipher_st
// file /usr/include/openssl/ssl.h line 375
struct ssl_cipher_st;

// tag-ssl_comp_st
// file /usr/include/openssl/ssl.h line 908
struct ssl_comp_st;

// tag-ssl_ctx_st
// file /usr/include/openssl/ossl_typ.h line 179
struct ssl_ctx_st;

// tag-ssl_method_st
// file /usr/include/openssl/ssl.h line 374
struct ssl_method_st;

// tag-ssl_session_st
// file /usr/include/openssl/ssl.h line 376
struct ssl_session_st;

// tag-ssl_st
// file /usr/include/openssl/ossl_typ.h line 178
struct ssl_st;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_ASN1_OBJECT
// file /usr/include/openssl/asn1.h line 793
struct stack_st_ASN1_OBJECT;

// tag-stack_st_DIST_POINT
// file /usr/include/openssl/x509.h line 288
struct stack_st_DIST_POINT;

// tag-stack_st_GENERAL_NAME
// file /usr/include/openssl/x509.h line 289
struct stack_st_GENERAL_NAME;

// tag-stack_st_GENERAL_NAMES
// file /usr/include/openssl/x509.h line 471
struct stack_st_GENERAL_NAMES;

// tag-stack_st_OCSP_RESPID
// file /usr/include/openssl/ssl.h line 1610
struct stack_st_OCSP_RESPID;

// tag-stack_st_SRTP_PROTECTION_PROFILE
// file /usr/include/openssl/ssl.h line 388
struct stack_st_SRTP_PROTECTION_PROFILE;

// tag-stack_st_SSL_CIPHER
// file /usr/include/openssl/ssl.h line 380
struct stack_st_SSL_CIPHER;

// tag-stack_st_SSL_COMP
// file /usr/include/openssl/ssl.h line 922
struct stack_st_SSL_COMP;

// tag-stack_st_X509
// file /usr/include/openssl/x509.h line 301
struct stack_st_X509;

// tag-stack_st_X509_ALGOR
// file /usr/include/openssl/asn1.h line 162
struct stack_st_X509_ALGOR;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stack_st_X509_CRL
// file /usr/include/openssl/x509.h line 476
struct stack_st_X509_CRL;

// tag-stack_st_X509_EXTENSION
// file /usr/include/openssl/x509.h line 202
struct stack_st_X509_EXTENSION;

// tag-stack_st_X509_LOOKUP
// file /usr/include/openssl/x509_vfy.h line 136
struct stack_st_X509_LOOKUP;

// tag-stack_st_X509_NAME
// file /usr/include/openssl/x509.h line 192
struct stack_st_X509_NAME;

// tag-stack_st_X509_NAME_ENTRY
// file /usr/include/openssl/x509.h line 175
struct stack_st_X509_NAME_ENTRY;

// tag-stack_st_X509_OBJECT
// file /usr/include/openssl/x509_vfy.h line 137
struct stack_st_X509_OBJECT;

// tag-stack_st_X509_REVOKED
// file /usr/include/openssl/x509.h line 438
struct stack_st_X509_REVOKED;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tls_session_ticket_ext_st
// file /usr/include/openssl/ssl.h line 373
struct tls_session_ticket_ext_st;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-x509_cert_aux_st
// file /usr/include/openssl/x509.h line 262
struct x509_cert_aux_st;

// tag-x509_cinf_st
// file /usr/include/openssl/x509.h line 242
struct x509_cinf_st;

// tag-x509_crl_method_st
// file /usr/include/openssl/ossl_typ.h line 157
struct x509_crl_method_st;

// tag-x509_st
// file /usr/include/openssl/ossl_typ.h line 154
struct x509_st;

// tag-x509_store_ctx_st
// file /usr/include/openssl/ossl_typ.h line 162
struct x509_store_ctx_st;

// tag-x509_store_st
// file /usr/include/openssl/ossl_typ.h line 161
struct x509_store_st;

#ifndef NULL
#define NULL ((void*)0)
#endif

// ASN1_INTEGER_set
// file /usr/include/openssl/asn1.h line 927
signed int ASN1_INTEGER_set(struct asn1_string_st *, signed long int);
// ArOptions_evaluate_values
// file ar_options_struct.h line 57
void ArOptions_evaluate_values(struct anonymous$3 *ao);
// ArOptions_free
// file ar_options_struct.h line 41
void ArOptions_free(struct anonymous$3 **ao);
// ArOptions_get_arDelay
// file ar_options_struct.h line 52
signed int ArOptions_get_arDelay(struct anonymous$3 *ao);
// ArOptions_get_arPremature
// file ar_options_struct.h line 55
char ArOptions_get_arPremature(struct anonymous$3 *ao);
// ArOptions_get_arQuit
// file ar_options_struct.h line 54
char ArOptions_get_arQuit(struct anonymous$3 *ao);
// ArOptions_get_arStart
// file ar_options_struct.h line 53
char ArOptions_get_arStart(struct anonymous$3 *ao);
// ArOptions_get_arTries
// file ar_options_struct.h line 51
signed int ArOptions_get_arTries(struct anonymous$3 *ao);
// ArOptions_new
// file ar_options_struct.h line 39
struct anonymous$3 * ArOptions_new();
// ArOptions_set_arDelay
// file ar_options_struct.c line 126
void ArOptions_set_arDelay(struct anonymous$3 *ao, signed int delay);
// ArOptions_set_arPremature
// file ar_options_struct.h line 49
void ArOptions_set_arPremature(struct anonymous$3 *ao, char premature);
// ArOptions_set_arQuit
// file ar_options_struct.h line 48
void ArOptions_set_arQuit(struct anonymous$3 *ao, char quit);
// ArOptions_set_arStart
// file ar_options_struct.h line 47
void ArOptions_set_arStart(struct anonymous$3 *ao, char start);
// ArOptions_set_arTries
// file ar_options_struct.c line 91
void ArOptions_set_arTries(struct anonymous$3 *ao, signed int tries);
// ArOptions_set_s_arDelay
// file ar_options_struct.h line 46
void ArOptions_set_s_arDelay(struct anonymous$3 *ao, char *delay);
// ArOptions_set_s_arTries
// file ar_options_struct.h line 44
void ArOptions_set_s_arTries(struct anonymous$3 *ao, char *tries);
// AuditListNode_free
// file audit_list_node_struct.c line 81
void AuditListNode_free(struct alnode **aln);
// AuditListNode_get_connectTime
// file audit_list_node_struct.c line 258
signed long int AuditListNode_get_connectTime(struct alnode *aln);
// AuditListNode_get_connectTimep
// file audit_list_node_struct.c line 309
signed long int * AuditListNode_get_connectTimep(struct alnode *aln);
// AuditListNode_get_duration
// file audit_list_node_struct.c line 275
signed long int AuditListNode_get_duration(struct alnode *aln);
// AuditListNode_get_nameBuf
// file audit_list_node_struct.c line 224
char * AuditListNode_get_nameBuf(struct alnode *aln);
// AuditListNode_get_nextNode
// file audit_list_node_struct.c line 292
struct alnode * AuditListNode_get_nextNode(struct alnode *aln);
// AuditListNode_get_portBuf
// file audit_list_node_struct.c line 241
char * AuditListNode_get_portBuf(struct alnode *aln);
// AuditListNode_get_userId
// file audit_list_node_struct.c line 207
signed int AuditListNode_get_userId(struct alnode *aln);
// AuditListNode_new
// file audit_list_node_struct.c line 36
struct alnode * AuditListNode_new();
// AuditListNode_new_entry
// file audit_list_node_struct.c line 58
struct alnode * AuditListNode_new_entry(signed int userId, char *nameBuf, char *portBuf, signed long int connectTime, signed long int duration);
// AuditListNode_set_connectTime
// file audit_list_node_struct.c line 156
void AuditListNode_set_connectTime(struct alnode *aln, signed long int connectTime);
// AuditListNode_set_duration
// file audit_list_node_struct.c line 173
void AuditListNode_set_duration(struct alnode *aln, signed long int duration);
// AuditListNode_set_nameBuf
// file audit_list_node_struct.c line 120
void AuditListNode_set_nameBuf(struct alnode *aln, char *nameBuf);
// AuditListNode_set_nextNode
// file audit_list_node_struct.c line 190
void AuditListNode_set_nextNode(struct alnode *aln, struct alnode *nextNode);
// AuditListNode_set_portBuf
// file audit_list_node_struct.c line 138
void AuditListNode_set_portBuf(struct alnode *aln, char *portBuf);
// AuditListNode_set_userId
// file audit_list_node_struct.c line 103
void AuditListNode_set_userId(struct alnode *aln, signed int userId);
// AuditList_clear
// file audit_list_struct.c line 143
void AuditList_clear(struct auditlist *al);
// AuditList_delete_first
// file audit_list_struct.c line 120
void AuditList_delete_first(struct auditlist *al);
// AuditList_free
// file audit_list_struct.c line 53
void AuditList_free(struct auditlist **al);
// AuditList_get_first
// file audit_list_struct.c line 104
struct alnode * AuditList_get_first(struct auditlist *al);
// AuditList_insert_back
// file audit_list_struct.c line 76
void AuditList_insert_back(struct auditlist *al, struct alnode *aln);
// AuditList_new
// file audit_list_struct.c line 36
struct auditlist * AuditList_new();
// BN_bn2bin
// file /usr/include/openssl/bn.h line 442
signed int BN_bn2bin(const struct bignum_st *, unsigned char *);
// BN_num_bits
// file /usr/include/openssl/bn.h line 434
signed int BN_num_bits(const struct bignum_st *);
// BufListNode_free
// file buf_list_node_struct.c line 76
void BufListNode_free(struct blnode **bln);
// BufListNode_get_actPtr
// file buf_list_node_struct.h line 42
signed int BufListNode_get_actPtr(struct blnode *bln);
// BufListNode_get_message
// file buf_list_node_struct.c line 221
unsigned char * BufListNode_get_message(struct blnode *bln);
// BufListNode_get_msgLen
// file buf_list_node_struct.c line 204
signed int BufListNode_get_msgLen(struct blnode *bln);
// BufListNode_get_nextNode
// file buf_list_node_struct.c line 238
struct blnode * BufListNode_get_nextNode(struct blnode *bln);
// BufListNode_new
// file buf_list_node_struct.c line 36
struct blnode * BufListNode_new();
// BufListNode_new_message
// file buf_list_node_struct.h line 33
struct blnode * BufListNode_new_message(signed int actPtr, signed int msgLen, unsigned char *message);
// BufListNode_readMessage
// file buf_list_node_struct.h line 47
unsigned char * BufListNode_readMessage(struct blnode *bln);
// BufListNode_readMessageLength
// file buf_list_node_struct.h line 48
signed int BufListNode_readMessageLength(struct blnode *bln);
// BufListNode_set_actPtr
// file buf_list_node_struct.h line 37
void BufListNode_set_actPtr(struct blnode *bln, signed int actPtr);
// BufListNode_set_message
// file buf_list_node_struct.c line 137
void BufListNode_set_message(struct blnode *bln, unsigned char *message, signed int msgLen);
// BufListNode_set_msgLen
// file buf_list_node_struct.c line 119
void BufListNode_set_msgLen(struct blnode *bln, signed int msgLen);
// BufListNode_set_nextNode
// file buf_list_node_struct.c line 170
void BufListNode_set_nextNode(struct blnode *bln, struct blnode *nextNode);
// BufList_clear
// file buf_list_struct.h line 39
void BufList_clear(struct buflist *bl);
// BufList_delete_first
// file buf_list_struct.h line 38
void BufList_delete_first(struct buflist *bl);
// BufList_free
// file buf_list_struct.c line 53
void BufList_free(struct buflist **bl);
// BufList_get_first
// file buf_list_struct.h line 37
struct blnode * BufList_get_first(struct buflist *bl);
// BufList_insert_back
// file buf_list_struct.h line 36
void BufList_insert_back(struct buflist *bl, struct blnode *bln);
// BufList_new
// file buf_list_struct.c line 36
struct buflist * BufList_new();
// ClientConfiguration_free
// file client_configuration_struct.c line 54
void ClientConfiguration_free(struct anonymous$4 **cc);
// ClientConfiguration_get_certificateFile
// file client_configuration_struct.h line 51
char * ClientConfiguration_get_certificateFile(struct anonymous$4 *cc);
// ClientConfiguration_get_dateFormat
// file client_configuration_struct.h line 53
char * ClientConfiguration_get_dateFormat(struct anonymous$4 *cc);
// ClientConfiguration_get_ignorePublicKeys
// file client_configuration_struct.h line 56
char ClientConfiguration_get_ignorePublicKeys(struct anonymous$4 *cc);
// ClientConfiguration_get_keysFile
// file client_configuration_struct.h line 50
char * ClientConfiguration_get_keysFile(struct anonymous$4 *cc);
// ClientConfiguration_get_realmsNumber
// file client_configuration_struct.h line 54
signed int ClientConfiguration_get_realmsNumber(struct anonymous$4 *cc);
// ClientConfiguration_get_realmsTable
// file client_configuration_struct.h line 55
struct anonymous$5 ** ClientConfiguration_get_realmsTable(struct anonymous$4 *cc);
// ClientConfiguration_get_storeFile
// file client_configuration_struct.h line 52
char * ClientConfiguration_get_storeFile(struct anonymous$4 *cc);
// ClientConfiguration_new
// file client_configuration_struct.h line 38
struct anonymous$4 * ClientConfiguration_new();
// ClientConfiguration_set_certificateFile
// file client_configuration_struct.h line 43
void ClientConfiguration_set_certificateFile(struct anonymous$4 *cc, char *certificateFile);
// ClientConfiguration_set_dateFormat
// file client_configuration_struct.h line 45
void ClientConfiguration_set_dateFormat(struct anonymous$4 *cc, char *dateFormat);
// ClientConfiguration_set_ignorePublicKeys
// file client_configuration_struct.h line 48
void ClientConfiguration_set_ignorePublicKeys(struct anonymous$4 *cc, char ignorePublicKeys);
// ClientConfiguration_set_keysFile
// file client_configuration_struct.h line 42
void ClientConfiguration_set_keysFile(struct anonymous$4 *cc, char *keysFile);
// ClientConfiguration_set_realmsNumber
// file client_configuration_struct.h line 46
void ClientConfiguration_set_realmsNumber(struct anonymous$4 *cc, signed int realmsNumber);
// ClientConfiguration_set_realmsTable
// file client_configuration_struct.h line 47
void ClientConfiguration_set_realmsTable(struct anonymous$4 *cc, struct anonymous$5 **realmsTable);
// ClientConfiguration_set_storeFile
// file client_configuration_struct.h line 44
void ClientConfiguration_set_storeFile(struct anonymous$4 *cc, char *storeFile);
// ClientRealm_closeUsersConnections
// file client_realm_struct.h line 141
void ClientRealm_closeUsersConnections(struct anonymous$5 *cr);
// ClientRealm_decrease_connectedUsers
// file client_realm_struct.c line 1106
void ClientRealm_decrease_connectedUsers(struct anonymous$5 *cr);
// ClientRealm_enable_multi
// file client_realm_struct.h line 144
void ClientRealm_enable_multi(struct anonymous$5 *cr);
// ClientRealm_free
// file client_realm_struct.h line 77
void ClientRealm_free(struct anonymous$5 **cr);
// ClientRealm_get_addressLength
// file client_realm_struct.c line 953
unsigned int ClientRealm_get_addressLength(struct anonymous$5 *cr);
// ClientRealm_get_arOptions
// file client_realm_struct.h line 131
struct anonymous$3 * ClientRealm_get_arOptions(struct anonymous$5 *cr);
// ClientRealm_get_clientAddress
// file client_realm_struct.h line 128
struct sockaddr * ClientRealm_get_clientAddress(struct anonymous$5 *cr);
// ClientRealm_get_clientMode
// file client_realm_struct.h line 122
signed int ClientRealm_get_clientMode(struct anonymous$5 *cr);
// ClientRealm_get_connectedUsers
// file client_realm_struct.c line 816
signed int ClientRealm_get_connectedUsers(struct anonymous$5 *cr);
// ClientRealm_get_destinationPorts
// file client_realm_struct.h line 132
struct portlist * ClientRealm_get_destinationPorts(struct anonymous$5 *cr);
// ClientRealm_get_hostName
// file client_realm_struct.h line 111
char * ClientRealm_get_hostName(struct anonymous$5 *cr);
// ClientRealm_get_httpProxyOptions
// file client_realm_struct.h line 130
struct anonymous * ClientRealm_get_httpProxyOptions(struct anonymous$5 *cr);
// ClientRealm_get_ipFamily
// file client_realm_struct.h line 123
char ClientRealm_get_ipFamily(struct anonymous$5 *cr);
// ClientRealm_get_keepAlive
// file client_realm_struct.c line 935
struct timeval ClientRealm_get_keepAlive(struct anonymous$5 *cr);
// ClientRealm_get_keepAlivePointer
// file client_realm_struct.h line 142
struct timeval * ClientRealm_get_keepAlivePointer(struct anonymous$5 *cr);
// ClientRealm_get_keepAliveTimeout
// file client_realm_struct.h line 121
signed int ClientRealm_get_keepAliveTimeout(struct anonymous$5 *cr);
// ClientRealm_get_localDestinationName
// file client_realm_struct.h line 117
char * ClientRealm_get_localDestinationName(struct anonymous$5 *cr);
// ClientRealm_get_localName
// file client_realm_struct.h line 115
char * ClientRealm_get_localName(struct anonymous$5 *cr);
// ClientRealm_get_localPort
// file client_realm_struct.h line 116
char * ClientRealm_get_localPort(struct anonymous$5 *cr);
// ClientRealm_get_managePort
// file client_realm_struct.h line 110
char * ClientRealm_get_managePort(struct anonymous$5 *cr);
// ClientRealm_get_masterSslFd
// file client_realm_struct.h line 129
struct anonymous$0 * ClientRealm_get_masterSslFd(struct anonymous$5 *cr);
// ClientRealm_get_password
// file client_realm_struct.h line 118
unsigned char * ClientRealm_get_password(struct anonymous$5 *cr);
// ClientRealm_get_realmId
// file client_realm_struct.h line 114
char * ClientRealm_get_realmId(struct anonymous$5 *cr);
// ClientRealm_get_realmName
// file client_realm_struct.c line 711
char * ClientRealm_get_realmName(struct anonymous$5 *cr);
// ClientRealm_get_realmType
// file client_realm_struct.h line 124
char ClientRealm_get_realmType(struct anonymous$5 *cr);
// ClientRealm_get_sKeepAliveTimeout
// file client_realm_struct.h line 113
char * ClientRealm_get_sKeepAliveTimeout(struct anonymous$5 *cr);
// ClientRealm_get_serverName
// file client_realm_struct.h line 109
char * ClientRealm_get_serverName(struct anonymous$5 *cr);
// ClientRealm_get_serviceModule
// file client_realm_struct.h line 136
struct anonymous$6 * ClientRealm_get_serviceModule(struct anonymous$5 *cr);
// ClientRealm_get_tunnelType
// file client_realm_struct.h line 125
char ClientRealm_get_tunnelType(struct anonymous$5 *cr);
// ClientRealm_get_userModule
// file client_realm_struct.h line 135
struct anonymous$6 * ClientRealm_get_userModule(struct anonymous$5 *cr);
// ClientRealm_get_usersLimit
// file client_realm_struct.h line 120
signed int ClientRealm_get_usersLimit(struct anonymous$5 *cr);
// ClientRealm_get_usersTable
// file client_realm_struct.h line 133
struct anonymous$7 ** ClientRealm_get_usersTable(struct anonymous$5 *cr);
// ClientRealm_increase_connectedUsers
// file client_realm_struct.c line 1090
void ClientRealm_increase_connectedUsers(struct anonymous$5 *cr);
// ClientRealm_new
// file client_realm_struct.h line 75
struct anonymous$5 * ClientRealm_new();
// ClientRealm_send_realmId
// file client_realm_struct.h line 143
void ClientRealm_send_realmId(struct anonymous$5 *cr, unsigned char *buff);
// ClientRealm_set_addressLength
// file client_realm_struct.h line 97
void ClientRealm_set_addressLength(struct anonymous$5 *cr, unsigned int addressLength);
// ClientRealm_set_arOptions
// file client_realm_struct.h line 101
void ClientRealm_set_arOptions(struct anonymous$5 *cr, struct anonymous$3 *arOptions);
// ClientRealm_set_clientAddress
// file client_realm_struct.h line 98
void ClientRealm_set_clientAddress(struct anonymous$5 *cr, struct sockaddr *clientAddress);
// ClientRealm_set_clientMode
// file client_realm_struct.h line 92
void ClientRealm_set_clientMode(struct anonymous$5 *cr, signed int clientMode);
// ClientRealm_set_connectedUsers
// file client_realm_struct.c line 323
void ClientRealm_set_connectedUsers(struct anonymous$5 *cr, signed int connectedUsers);
// ClientRealm_set_destinationPorts
// file client_realm_struct.h line 102
void ClientRealm_set_destinationPorts(struct anonymous$5 *cr, struct portlist *destinationPorts);
// ClientRealm_set_hostName
// file client_realm_struct.h line 81
void ClientRealm_set_hostName(struct anonymous$5 *cr, char *hostName);
// ClientRealm_set_httpProxyOptions
// file client_realm_struct.h line 100
void ClientRealm_set_httpProxyOptions(struct anonymous$5 *cr, struct anonymous *httpProxyOptions);
// ClientRealm_set_ipFamily
// file client_realm_struct.h line 93
void ClientRealm_set_ipFamily(struct anonymous$5 *cr, char ipFamily);
// ClientRealm_set_keepAlive
// file client_realm_struct.h line 96
void ClientRealm_set_keepAlive(struct anonymous$5 *cr, struct timeval keepAlive);
// ClientRealm_set_keepAliveTimeout
// file client_realm_struct.h line 91
void ClientRealm_set_keepAliveTimeout(struct anonymous$5 *cr, signed int keepAliveTimeout);
// ClientRealm_set_localDestinationName
// file client_realm_struct.h line 87
void ClientRealm_set_localDestinationName(struct anonymous$5 *cr, char *localDestinationName);
// ClientRealm_set_localName
// file client_realm_struct.h line 85
void ClientRealm_set_localName(struct anonymous$5 *cr, char *localName);
// ClientRealm_set_localPort
// file client_realm_struct.h line 86
void ClientRealm_set_localPort(struct anonymous$5 *cr, char *localPort);
// ClientRealm_set_managePort
// file client_realm_struct.h line 80
void ClientRealm_set_managePort(struct anonymous$5 *cr, char *managePort);
// ClientRealm_set_masterSslFd
// file client_realm_struct.c line 497
void ClientRealm_set_masterSslFd(struct anonymous$5 *cr, struct anonymous$0 *masterSslFd);
// ClientRealm_set_password
// file client_realm_struct.h line 88
void ClientRealm_set_password(struct anonymous$5 *cr, unsigned char *password);
// ClientRealm_set_realmId
// file client_realm_struct.h line 84
void ClientRealm_set_realmId(struct anonymous$5 *cr, char *realmId);
// ClientRealm_set_realmName
// file client_realm_struct.c line 221
void ClientRealm_set_realmName(struct anonymous$5 *cr, char *realmName);
// ClientRealm_set_realmType
// file client_realm_struct.h line 94
void ClientRealm_set_realmType(struct anonymous$5 *cr, char realmType);
// ClientRealm_set_sKeepAliveTimeout
// file client_realm_struct.h line 83
void ClientRealm_set_sKeepAliveTimeout(struct anonymous$5 *cr, char *sKeepAliveTimeout);
// ClientRealm_set_serverName
// file client_realm_struct.h line 79
void ClientRealm_set_serverName(struct anonymous$5 *cr, char *serverName);
// ClientRealm_set_serviceModule
// file client_realm_struct.h line 106
void ClientRealm_set_serviceModule(struct anonymous$5 *cr, struct anonymous$6 *serviceModule);
// ClientRealm_set_tunnelType
// file client_realm_struct.h line 95
void ClientRealm_set_tunnelType(struct anonymous$5 *cr, char tunnelType);
// ClientRealm_set_userModule
// file client_realm_struct.h line 105
void ClientRealm_set_userModule(struct anonymous$5 *cr, struct anonymous$6 *userModule);
// ClientRealm_set_usersLimit
// file client_realm_struct.h line 90
void ClientRealm_set_usersLimit(struct anonymous$5 *cr, signed int usersLimit);
// ClientRealm_set_usersTable
// file client_realm_struct.h line 103
void ClientRealm_set_usersTable(struct anonymous$5 *cr, struct anonymous$7 **usersTable);
// ConnectUser_free
// file connect_user_struct.h line 45
void ConnectUser_free(struct anonymous$7 **cu);
// ConnectUser_get_bufList
// file connect_user_struct.h line 64
struct buflist * ConnectUser_get_bufList(struct anonymous$7 *cu);
// ConnectUser_get_connFd
// file connect_user_struct.h line 58
signed int ConnectUser_get_connFd(struct anonymous$7 *cu);
// ConnectUser_get_connectTime
// file connect_user_struct.c line 323
signed long int ConnectUser_get_connectTime(struct anonymous$7 *cu);
// ConnectUser_get_nameBuf
// file connect_user_struct.h line 62
char * ConnectUser_get_nameBuf(struct anonymous$7 *cu);
// ConnectUser_get_portBuf
// file connect_user_struct.h line 63
char * ConnectUser_get_portBuf(struct anonymous$7 *cu);
// ConnectUser_get_state
// file connect_user_struct.h line 57
char ConnectUser_get_state(struct anonymous$7 *cu);
// ConnectUser_get_stats
// file connect_user_struct.c line 391
struct anonymous$14 * ConnectUser_get_stats(struct anonymous$7 *cu);
// ConnectUser_get_userId
// file connect_user_struct.c line 306
signed int ConnectUser_get_userId(struct anonymous$7 *cu);
// ConnectUser_get_whatClient
// file connect_user_struct.c line 289
signed int ConnectUser_get_whatClient(struct anonymous$7 *cu);
// ConnectUser_new
// file connect_user_struct.h line 43
struct anonymous$7 * ConnectUser_new();
// ConnectUser_set_bufList
// file connect_user_struct.c line 215
void ConnectUser_set_bufList(struct anonymous$7 *cu, struct buflist *bufList);
// ConnectUser_set_connFd
// file connect_user_struct.h line 48
void ConnectUser_set_connFd(struct anonymous$7 *cu, signed int connFd);
// ConnectUser_set_connectTime
// file connect_user_struct.c line 162
void ConnectUser_set_connectTime(struct anonymous$7 *cu, signed long int connectTime);
// ConnectUser_set_nameBuf
// file connect_user_struct.h line 52
void ConnectUser_set_nameBuf(struct anonymous$7 *cu, char *nameBuf);
// ConnectUser_set_portBuf
// file connect_user_struct.h line 53
void ConnectUser_set_portBuf(struct anonymous$7 *cu, char *portBuf);
// ConnectUser_set_state
// file connect_user_struct.h line 47
void ConnectUser_set_state(struct anonymous$7 *cu, char state);
// ConnectUser_set_stats
// file connect_user_struct.c line 235
void ConnectUser_set_stats(struct anonymous$7 *cu, struct anonymous$14 *stats);
// ConnectUser_set_userId
// file connect_user_struct.c line 145
void ConnectUser_set_userId(struct anonymous$7 *cu, signed int userId);
// ConnectUser_set_whatClient
// file connect_user_struct.c line 128
void ConnectUser_set_whatClient(struct anonymous$7 *cu, signed int whatClient);
// ERR_error_string
// file /usr/include/openssl/err.h line 334
char * ERR_error_string(unsigned long int, char *);
// ERR_get_error
// file /usr/include/openssl/err.h line 321
unsigned long int ERR_get_error(void);
// EVP_DigestFinal
// file /usr/include/openssl/evp.h line 603
signed int EVP_DigestFinal(struct env_md_ctx_st *, unsigned char *, unsigned int *);
// EVP_DigestInit
// file /usr/include/openssl/evp.h line 602
signed int EVP_DigestInit(struct env_md_ctx_st *, const struct env_md_st *);
// EVP_DigestUpdate
// file /usr/include/openssl/evp.h line 595
signed int EVP_DigestUpdate(struct env_md_ctx_st *, const void *, unsigned long int);
// EVP_PKEY_free
// file /usr/include/openssl/evp.h line 981
void EVP_PKEY_free(struct evp_pkey_st *);
// EVP_PKEY_new
// file /usr/include/openssl/evp.h line 980
struct evp_pkey_st * EVP_PKEY_new(void);
// EVP_PKEY_set1_RSA
// file /usr/include/openssl/evp.h line 961
signed int EVP_PKEY_set1_RSA(struct evp_pkey_st *, struct rsa_st *);
// EVP_md5
// file /usr/include/openssl/evp.h line 716
const struct env_md_st * EVP_md5(void);
// EVP_sha1
// file /usr/include/openssl/evp.h line 720
const struct env_md_st * EVP_sha1(void);
// HeaderBuffer_free
// file header_buffer_struct.c line 53
void HeaderBuffer_free(struct anonymous$2 **hb);
// HeaderBuffer_new
// file header_buffer_struct.c line 36
struct anonymous$2 * HeaderBuffer_new();
// HeaderBuffer_restore
// file header_buffer_struct.c line 119
void HeaderBuffer_restore(struct anonymous$2 *hb, unsigned char *buff);
// HeaderBuffer_store
// file header_buffer_struct.c line 93
void HeaderBuffer_store(struct anonymous$2 *hb, unsigned char *buff, signed int n);
// HeaderBuffer_to_read
// file header_buffer_struct.c line 75
signed int HeaderBuffer_to_read(struct anonymous$2 *hb);
// HttpProxyOptions_free
// file http_proxy_options_struct.h line 42
void HttpProxyOptions_free(struct anonymous **hpo);
// HttpProxyOptions_get_proxyauth_cred
// file http_proxy_options_struct.h line 51
char * HttpProxyOptions_get_proxyauth_cred(struct anonymous *hpo);
// HttpProxyOptions_get_proxyauth_type
// file http_proxy_options_struct.h line 52
char HttpProxyOptions_get_proxyauth_type(struct anonymous *hpo);
// HttpProxyOptions_get_proxyname
// file http_proxy_options_struct.h line 49
char * HttpProxyOptions_get_proxyname(struct anonymous *hpo);
// HttpProxyOptions_get_proxyport
// file http_proxy_options_struct.h line 50
char * HttpProxyOptions_get_proxyport(struct anonymous *hpo);
// HttpProxyOptions_is_https
// file http_proxy_options_struct.h line 55
char HttpProxyOptions_is_https(struct anonymous *hpo);
// HttpProxyOptions_new
// file http_proxy_options_struct.h line 40
struct anonymous * HttpProxyOptions_new();
// HttpProxyOptions_set_proxyauth_cred
// file http_proxy_options_struct.h line 46
void HttpProxyOptions_set_proxyauth_cred(struct anonymous *hpo, char *proxyauth_cred);
// HttpProxyOptions_set_proxyauth_type
// file http_proxy_options_struct.h line 47
void HttpProxyOptions_set_proxyauth_type(struct anonymous *hpo, char proxyauth_type);
// HttpProxyOptions_set_proxyname
// file http_proxy_options_struct.h line 44
void HttpProxyOptions_set_proxyname(struct anonymous *hpo, char *proxyname);
// HttpProxyOptions_set_proxyport
// file http_proxy_options_struct.h line 45
void HttpProxyOptions_set_proxyport(struct anonymous *hpo, char *proxyport);
// HttpProxyOptions_use_https
// file http_proxy_options_struct.h line 54
void HttpProxyOptions_use_https(struct anonymous *hpo);
// Module_free
// file module_struct.c line 56
void Module_free(struct anonymous$6 **m);
// Module_function_allow
// file module_struct.h line 50
signed int Module_function_allow(struct anonymous$6 *m, char *host, char *port);
// Module_function_filter
// file module_struct.h line 51
signed int Module_function_filter(struct anonymous$6 *m, char *host, unsigned char *message, signed int *messageLength);
// Module_function_info
// file module_struct.h line 49
char * Module_function_info(struct anonymous$6 *m);
// Module_get_fileName
// file module_struct.h line 44
char * Module_get_fileName(struct anonymous$6 *m);
// Module_isModuleLoaded
// file module_struct.h line 48
signed int Module_isModuleLoaded(struct anonymous$6 *m);
// Module_loadModule
// file module_struct.h line 46
signed int Module_loadModule(struct anonymous$6 *m);
// Module_new
// file module_struct.h line 38
struct anonymous$6 * Module_new();
// Module_releaseModule
// file module_struct.h line 47
signed int Module_releaseModule(struct anonymous$6 *m);
// Module_set_fileName
// file module_struct.h line 42
void Module_set_fileName(struct anonymous$6 *m, char *fileName);
// OBJ_txt2nid
// file /usr/include/openssl/objects.h line 1014
signed int OBJ_txt2nid(const char *);
// PEM_read_RSAPrivateKey
// file /usr/include/openssl/pem.h line 462
struct rsa_st * PEM_read_RSAPrivateKey(struct _IO_FILE *, struct rsa_st **, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_write_RSAPrivateKey
// file /usr/include/openssl/pem.h line 462
signed int PEM_write_RSAPrivateKey(struct _IO_FILE *, struct rsa_st *, const struct evp_cipher_st *, unsigned char *, signed int, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_write_X509
// file /usr/include/openssl/pem.h line 451
signed int PEM_write_X509(struct _IO_FILE *, struct x509_st *);
// PortListNode_free
// file port_list_node_struct.c line 56
void PortListNode_free(struct plnode **pln);
// PortListNode_get_nextNode
// file port_list_node_struct.c line 133
struct plnode * PortListNode_get_nextNode(struct plnode *pln);
// PortListNode_get_portName
// file port_list_node_struct.h line 37
char * PortListNode_get_portName(struct plnode *pln);
// PortListNode_new
// file port_list_node_struct.h line 30
struct plnode * PortListNode_new(char *portName);
// PortListNode_set_nextNode
// file port_list_node_struct.c line 99
void PortListNode_set_nextNode(struct plnode *pln, struct plnode *nextNode);
// PortListNode_set_portName
// file port_list_node_struct.c line 82
void PortListNode_set_portName(struct plnode *pln, char *portName);
// PortList_clear
// file port_list_struct.c line 149
void PortList_clear(struct portlist *pl);
// PortList_free
// file port_list_struct.h line 35
void PortList_free(struct portlist **pl);
// PortList_get_nth
// file port_list_struct.h line 38
struct plnode * PortList_get_nth(struct portlist *pl, signed int n);
// PortList_get_size
// file port_list_struct.h line 39
signed int PortList_get_size(struct portlist *pl);
// PortList_insert_back
// file port_list_struct.h line 37
void PortList_insert_back(struct portlist *pl, struct plnode *pln);
// PortList_new
// file port_list_struct.h line 33
struct portlist * PortList_new();
// RSA_check_key
// file /usr/include/openssl/rsa.h line 333
signed int RSA_check_key(const struct rsa_st *);
// RSA_generate_key
// file /usr/include/openssl/rsa.h line 326
struct rsa_st * RSA_generate_key(signed int, unsigned long int, void (*)(signed int, signed int, void *), void *);
// SSL_CIPHER_get_name
// file /usr/include/openssl/ssl.h line 2145
const char * SSL_CIPHER_get_name(const struct ssl_cipher_st *);
// SSL_CIPHER_get_version
// file /usr/include/openssl/ssl.h line 2144
char * SSL_CIPHER_get_version(const struct ssl_cipher_st *);
// SSL_CTX_new
// file /usr/include/openssl/ssl.h line 2131
struct ssl_ctx_st * SSL_CTX_new(const struct ssl_method_st *);
// SSL_CTX_set_cipher_list
// file /usr/include/openssl/ssl.h line 2130
signed int SSL_CTX_set_cipher_list(struct ssl_ctx_st *, const char *);
// SSL_CTX_use_RSAPrivateKey_file
// file /usr/include/openssl/ssl.h line 2198
signed int SSL_CTX_use_RSAPrivateKey_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_CTX_use_certificate_file
// file /usr/include/openssl/ssl.h line 2200
signed int SSL_CTX_use_certificate_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_accept
// file /usr/include/openssl/ssl.h line 2332
signed int SSL_accept(struct ssl_st *);
// SSL_clear
// file /usr/include/openssl/ssl.h line 2138
signed int SSL_clear(struct ssl_st *);
// SSL_connect
// file /usr/include/openssl/ssl.h line 2333
signed int SSL_connect(struct ssl_st *);
// SSL_free
// file /usr/include/openssl/ssl.h line 2331
void SSL_free(struct ssl_st *);
// SSL_get_current_cipher
// file /usr/include/openssl/ssl.h line 2142
const struct ssl_cipher_st * SSL_get_current_cipher(const struct ssl_st *);
// SSL_get_error
// file /usr/include/openssl/ssl.h line 2342
signed int SSL_get_error(const struct ssl_st *, signed int);
// SSL_get_peer_certificate
// file /usr/include/openssl/ssl.h line 2253
struct x509_st * SSL_get_peer_certificate(const struct ssl_st *);
// SSL_library_init
// file /usr/include/openssl/ssl.h line 2419
signed int SSL_library_init(void);
// SSL_load_error_strings
// file /usr/include/openssl/ssl.h line 2216
void SSL_load_error_strings(void);
// SSL_new
// file /usr/include/openssl/ssl.h line 2291
struct ssl_st * SSL_new(struct ssl_ctx_st *);
// SSL_read
// file /usr/include/openssl/ssl.h line 2334
signed int SSL_read(struct ssl_st *, void *, signed int);
// SSL_readn
// file network.c line 483
signed int SSL_readn(struct ssl_st *fd, unsigned char *buf, signed int amount);
// SSL_set_fd
// file /usr/include/openssl/ssl.h line 2156
signed int SSL_set_fd(struct ssl_st *, signed int);
// SSL_write
// file /usr/include/openssl/ssl.h line 2336
signed int SSL_write(struct ssl_st *, const void *, signed int);
// SSL_writen
// file network.c line 454
signed int SSL_writen(struct ssl_st *fd, unsigned char *buf, signed int amount);
// SSLv3_client_method
// file /usr/include/openssl/ssl.h line 2357
const struct ssl_method_st * SSLv3_client_method(void);
// SslFd_free
// file ssl_fd_struct.c line 54
void SslFd_free(struct anonymous$0 **sf);
// SslFd_get_fd
// file ssl_fd_struct.h line 41
signed int SslFd_get_fd(struct anonymous$0 *sf);
// SslFd_get_message
// file ssl_fd_struct.h line 45
signed int SslFd_get_message(char type, struct anonymous$0 *sf, unsigned char *buf, signed int amount);
// SslFd_get_ssl
// file ssl_fd_struct.h line 42
struct ssl_st * SslFd_get_ssl(struct anonymous$0 *sf);
// SslFd_new
// file ssl_fd_struct.h line 33
struct anonymous$0 * SslFd_new();
// SslFd_send_message
// file ssl_fd_struct.h line 44
signed int SslFd_send_message(char type, struct anonymous$0 *sf, unsigned char *buf, signed int amount);
// SslFd_set_fd
// file ssl_fd_struct.h line 37
void SslFd_set_fd(struct anonymous$0 *sf, signed int fd);
// SslFd_set_ssl
// file ssl_fd_struct.h line 38
void SslFd_set_ssl(struct anonymous$0 *sf, struct ssl_st *ssl);
// SslFd_set_ssl_general
// file ssl_fd_struct.c line 98
void SslFd_set_ssl_general(struct anonymous$0 *sf, struct ssl_st *ssl, signed int free);
// SslFd_set_ssl_nf
// file ssl_fd_struct.c line 132
void SslFd_set_ssl_nf(struct anonymous$0 *sf, struct ssl_st *ssl);
// SslFd_swap_content
// file ssl_fd_struct.c line 315
void SslFd_swap_content(struct anonymous$0 *sf1, struct anonymous$0 *sf2);
// UserStats_add_download
// file user_stats_struct.c line 178
void UserStats_add_download(struct anonymous$14 *us, signed int bytes);
// UserStats_add_upload
// file user_stats_struct.c line 231
void UserStats_add_upload(struct anonymous$14 *us, signed int bytes);
// UserStats_clear
// file user_stats_struct.c line 376
void UserStats_clear(struct anonymous$14 *us);
// UserStats_free
// file user_stats_struct.h line 42
void UserStats_free(struct anonymous$14 **us);
// UserStats_get_downloadSpeed
// file user_stats_struct.c line 283
double UserStats_get_downloadSpeed(struct anonymous$14 *us);
// UserStats_get_lastActivity
// file user_stats_struct.c line 126
signed long int UserStats_get_lastActivity(struct anonymous$14 *us);
// UserStats_get_totalDownloadedBytes
// file user_stats_struct.c line 143
signed int UserStats_get_totalDownloadedBytes(struct anonymous$14 *us);
// UserStats_get_totalUploadedBytes
// file user_stats_struct.c line 160
signed int UserStats_get_totalUploadedBytes(struct anonymous$14 *us);
// UserStats_get_uploadSpeed
// file user_stats_struct.c line 330
double UserStats_get_uploadSpeed(struct anonymous$14 *us);
// UserStats_new
// file user_stats_struct.h line 40
struct anonymous$14 * UserStats_new();
// UserStats_set_lastActivity
// file user_stats_struct.c line 75
void UserStats_set_lastActivity(struct anonymous$14 *us, signed long int lastActivity);
// UserStats_set_totalDownloadedBytes
// file user_stats_struct.c line 92
void UserStats_set_totalDownloadedBytes(struct anonymous$14 *us, signed int totalDownloadedBytes);
// UserStats_set_totalUploadedBytes
// file user_stats_struct.c line 109
void UserStats_set_totalUploadedBytes(struct anonymous$14 *us, signed int totalUploadedBytes);
// UsrCli_free
// file usr_cli_struct.c line 54
void UsrCli_free(struct anonymous$1 **uc);
// UsrCli_get_listenFd
// file usr_cli_struct.c line 224
signed int UsrCli_get_listenFd(struct anonymous$1 *uc);
// UsrCli_get_listenHostName
// file usr_cli_struct.c line 258
char * UsrCli_get_listenHostName(struct anonymous$1 *uc);
// UsrCli_get_listenPortName
// file usr_cli_struct.c line 190
char * UsrCli_get_listenPortName(struct anonymous$1 *uc);
// UsrCli_get_manageFd
// file usr_cli_struct.c line 241
signed int UsrCli_get_manageFd(struct anonymous$1 *uc);
// UsrCli_get_manageHostName
// file usr_cli_struct.c line 275
char * UsrCli_get_manageHostName(struct anonymous$1 *uc);
// UsrCli_get_managePortName
// file usr_cli_struct.c line 207
char * UsrCli_get_managePortName(struct anonymous$1 *uc);
// UsrCli_get_number
// file usr_cli_struct.c line 292
signed int UsrCli_get_number(struct anonymous$1 *uc);
// UsrCli_new
// file usr_cli_struct.c line 37
struct anonymous$1 * UsrCli_new();
// UsrCli_set_listenFd
// file usr_cli_struct.c line 139
void UsrCli_set_listenFd(struct anonymous$1 *uc, signed int listenFd);
// UsrCli_set_listenPortName
// file usr_cli_struct.c line 83
void UsrCli_set_listenPortName(struct anonymous$1 *uc, char *listenPortName);
// UsrCli_set_manageFd
// file usr_cli_struct.c line 156
void UsrCli_set_manageFd(struct anonymous$1 *uc, signed int manageFd);
// UsrCli_set_managePortName
// file usr_cli_struct.c line 111
void UsrCli_set_managePortName(struct anonymous$1 *uc, char *managePortName);
// UsrCli_set_number
// file usr_cli_struct.c line 173
void UsrCli_set_number(struct anonymous$1 *uc, signed int number);
// X509_NAME_ENTRY_create_by_NID
// file /usr/include/openssl/x509.h line 1036
struct X509_name_entry_st * X509_NAME_ENTRY_create_by_NID(struct X509_name_entry_st **, signed int, signed int, unsigned char *, signed int);
// X509_NAME_add_entry
// file /usr/include/openssl/x509.h line 1024
signed int X509_NAME_add_entry(struct X509_name_st *, struct X509_name_entry_st *, signed int, signed int);
// X509_NAME_new
// file /usr/include/openssl/x509.h line 817
struct X509_name_st * X509_NAME_new(void);
// X509_REQ_free
// file /usr/include/openssl/x509.h line 807
void X509_REQ_free(struct X509_req_st *);
// X509_REQ_new
// file /usr/include/openssl/x509.h line 807
struct X509_req_st * X509_REQ_new(void);
// X509_REQ_set_pubkey
// file /usr/include/openssl/x509.h line 917
signed int X509_REQ_set_pubkey(struct X509_req_st *, struct evp_pkey_st *);
// X509_REQ_set_subject_name
// file /usr/include/openssl/x509.h line 916
signed int X509_REQ_set_subject_name(struct X509_req_st *, struct X509_name_st *);
// X509_REQ_sign
// file /usr/include/openssl/x509.h line 650
signed int X509_REQ_sign(struct X509_req_st *, struct evp_pkey_st *, const struct env_md_st *);
// X509_REQ_to_X509
// file /usr/include/openssl/x509.h line 779
struct x509_st * X509_REQ_to_X509(struct X509_req_st *, signed int, struct evp_pkey_st *);
// X509_free
// file /usr/include/openssl/x509.h line 823
void X509_free(struct x509_st *);
// X509_get_pubkey
// file /usr/include/openssl/x509.h line 911
struct evp_pkey_st * X509_get_pubkey(struct x509_st *);
// X509_get_serialNumber
// file /usr/include/openssl/x509.h line 903
struct asn1_string_st * X509_get_serialNumber(struct x509_st *);
// X509_set_version
// file /usr/include/openssl/x509.h line 901
signed int X509_set_version(struct x509_st *, signed long int);
// X509_sign
// file /usr/include/openssl/x509.h line 647
signed int X509_sign(struct x509_st *, struct evp_pkey_st *, const struct env_md_st *);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_32$link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32$link1(unsigned int __bsx$link1);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 401
extern signed int __xstat(signed int, const char *, struct stat *);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// add_public_key
// file ssl_routines.h line 31
void add_public_key(char *filename, char *hostname, char *keyhash);
// addlogtarget
// file logging.h line 69
void addlogtarget(char *cmdline);
// addtocg
// file stats.c line 61
void addtocg(signed int amount);
// aflog
// file logging.h line 73
void aflog(char type, char importance, const char *form, ...);
// alarm
// file /usr/include/unistd.h line 432
extern unsigned int alarm(unsigned int);
// b64_ntop
// file base64.h line 37
signed int b64_ntop(const unsigned char *src, unsigned long int srclength, char *target, unsigned long int targsize);
// b64_pton
// file base64.c line 132
signed int b64_pton(const char *src, unsigned char *target, unsigned long int targsize);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// broadcast_condition
// file thread_management.h line 31
void broadcast_condition(void);
// bzero
// file /usr/include/strings.h line 50
extern void bzero(void *, unsigned long int);
// callback
// file first_run.c line 63
static void callback(signed int i, signed int j, void *k);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_long
// file server_check.c line 99
signed int check_long(char *text, signed long int *number);
// check_public_key
// file ssl_routines.h line 29
signed int check_public_key(char *filename, char *hostname, char *keyhash);
// check_value
// file server_check.h line 24
signed int check_value(char *what, char *info);
// check_value_liberal
// file server_check.c line 67
signed int check_value_liberal(char *what, char *info);
// checklogtarget
// file logging.c line 175
signed int checklogtarget(struct llnode *target);
// checkmsgti
// file logging.c line 119
signed int checkmsgti(struct llnode *target, char *tab);
// clean_return
// file http_proxy_client.c line 48
static void clean_return(signed int sockfd);
// clear_fd
// file http_proxy_functions.c line 261
void clear_fd(signed int *fd, struct anonymous$11 *set);
// clear_sslFd
// file http_proxy_functions.c line 362
void clear_sslFd(struct anonymous$0 *sf, struct anonymous$11 *set);
// client_admin
// file client_remoteadmin.h line 35
signed int client_admin(char type, struct anonymous$0 *master, unsigned char *buff, signed int connectfd, char *id);
// client_long_usage
// file usage.h line 27
void client_long_usage(char *info);
// client_reverse_udp
// file client_reverse_udp.h line 39
void client_reverse_udp(struct anonymous$5 *cr, unsigned char *buff, signed int buflength);
// client_short_usage
// file usage.h line 26
void client_short_usage(char *info);
// client_sig_alrm
// file client_signals.h line 25
void client_sig_alrm(signed int signo);
// client_sig_int
// file client_signals.h line 24
void client_sig_int(signed int signo);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_connections
// file client_shutdown.c line 27
void close_connections(signed int usernum, struct anonymous$7 ***contable);
// close_fd
// file http_proxy_functions.c line 248
void close_fd(signed int *fd);
// compress
// file /usr/include/zlib.h line 1160
extern signed int compress(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// cparsefile
// file file.h line 38
struct anonymous$4 * cparsefile(char *name, signed int *status);
// create_apf_dir
// file first_run.h line 24
signed int create_apf_dir(char type);
// create_publickey_store
// file first_run.h line 25
signed int create_publickey_store(char **storefile);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// datum
// file logging.c line 85
char * datum(void);
// delete_user
// file http_proxy_functions.c line 77
void delete_user(struct anonymous$16 *cnts, signed int i, struct anonymous$11 *allset);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// end_critical_section
// file thread_management.h line 29
void end_critical_section(void);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// generate_certificate
// file first_run.c line 250
signed int generate_certificate(char **cerfile, char *keyfile);
// generate_rsa_key
// file first_run.h line 26
signed int generate_rsa_key(char **keyfile);
// get_cer_filename
// file first_run.c line 400
char * get_cer_filename();
// get_key_filename
// file first_run.c line 388
char * get_key_filename();
// get_ssl_error
// file make_ssl_handshake.h line 29
signed int get_ssl_error(struct anonymous$0 *sf, char *info, signed int result);
// get_store_filename
// file first_run.c line 376
char * get_store_filename();
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getcg
// file stats.h line 35
signed long int getcg(void);
// getdateformat
// file logging.c line 55
char * getdateformat();
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getloglisthead
// file logging.c line 104
struct llnode * getloglisthead();
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// http_proxy_client
// file http_proxy_client.c line 63
void * http_proxy_client(void *vptr);
// http_read
// file http_proxy_functions.c line 402
signed int http_read(char https, struct anonymous$0 *sf, unsigned char *buf, signed int amount);
// http_write
// file http_proxy_functions.c line 381
signed int http_write(char https, struct anonymous$0 *sf, unsigned char *buf, signed int amount);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// initialize_client_reverse_udp
// file client_reverse_udp.h line 38
signed int initialize_client_reverse_udp(struct anonymous$5 *cr);
// initialize_client_stage1
// file client_initialization.h line 36
signed int initialize_client_stage1(struct anonymous$5 *cr, struct ssl_ctx_st *ctx, unsigned char *buff, char wanttoexit, char ignorePublicKeys);
// initialize_client_stage2
// file client_initialization.h line 38
signed int initialize_client_stage2(struct anonymous$5 *cr, unsigned char *buff, char wanttoexit);
// initialize_client_stage3
// file client_initialization.h line 39
signed int initialize_client_stage3(struct anonymous$5 *cr, signed int *buflength, struct anonymous$11 *allset, struct anonymous$11 *wset, signed int *maxfdp1, char wanttoexit);
// initialize_http_proxy_client
// file http_proxy_client.c line 531
signed int initialize_http_proxy_client(signed int *sockfd, struct anonymous$5 *cr, struct ssl_ctx_st *ctx);
// initializelogging
// file logging.h line 71
void initializelogging(char verl, char *dateformat);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// ip_connect
// file network.h line 40
signed int ip_connect(signed int *sockfd, const char *host, const char *serv, const char type, const char *lhost, const char *lserv);
// ip_listen
// file network.h line 39
signed int ip_listen(signed int *sockfd, const char *host, const char *serv, unsigned int *addrlenp, const char type);
// is_this_a_mainthread
// file thread_management.c line 50
signed int is_this_a_mainthread(void);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localdate
// file logging.c line 68
char * localdate(signed long int *sec);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// loginit
// file logging.c line 334
signed int loginit(char verl, char *dateformat);
// make_ssl_accept
// file make_ssl_handshake.c line 55
signed int make_ssl_accept(struct anonymous$0 *sf);
// make_ssl_initialize
// file make_ssl_handshake.c line 37
void make_ssl_initialize(struct anonymous$0 *sf);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 321
extern signed int mkdir(const char *, unsigned int);
// myrand
// file http_proxy_functions.c line 42
signed int myrand(signed int down, signed int up);
// mysleep
// file http_proxy_functions.h line 75
void mysleep(double time);
// parse_header
// file http_proxy_functions.c line 105
signed int parse_header(struct anonymous$0 *sf, char *tab, struct anonymous$15 *hdr, char https);
// parse_line
// file file.c line 45
signed int parse_line(char *buff, char *tab1, char *tab2);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 992
extern signed int pthread_cond_broadcast(union anonymous$24 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 1000
extern signed int pthread_cond_wait(union anonymous$24 *, union anonymous$22 *);
// pthread_create
// file /usr/include/pthread.h line 244
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 253
extern void pthread_exit(void *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_lock(union anonymous$22 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 784
extern signed int pthread_mutex_unlock(union anonymous$22 *);
// pthread_self
// file /usr/include/pthread.h line 286
extern unsigned long int pthread_self(void);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_message
// file http_proxy_functions.c line 281
signed int read_message(signed int fd, signed int length, struct anonymous$16 *client, char *tab, signed int ptr);
// readn
// file network.c line 542
signed int readn(signed int fd, unsigned char *buf, signed int amount);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, struct sockaddr *, unsigned int *);
// remember_mainthread
// file thread_management.h line 26
void remember_mainthread(void);
// resetcg
// file stats.c line 84
void resetcg(void);
// rindex
// file /usr/include/string.h line 517
extern char * rindex(const char *, signed int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$11 *, struct anonymous$11 *, struct anonymous$11 *, struct timeval *);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, struct sockaddr *, unsigned int);
// server_long_usage
// file usage.c line 52
void server_long_usage(char *info);
// server_short_usage
// file usage.c line 36
void server_short_usage(char *info);
// set_fd
// file http_proxy_functions.c line 235
void set_fd(signed int fd, signed int *maxfdp1, struct anonymous$11 *allset);
// setdateformat
// file logging.c line 41
void setdateformat(char *dateformat);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous$18 *);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sock_ntop
// file network.c line 350
char * sock_ntop(struct sockaddr *sa, unsigned int salen, char *namebuf, char *portbuf, char type);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// start_critical_section
// file thread_management.h line 28
void start_critical_section(void);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 453
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// string_cp
// file string_functions.h line 24
char * string_cp(char **dest, char *src);
// strlen
// file /usr/include/string.h line 399
extern unsigned long int strlen(const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeperiod
// file stats.c line 35
char * timeperiod(signed long int period);
// timeval_compare
// file timeval_functions.c line 56
signed int timeval_compare(struct timeval *first, struct timeval *second);
// timeval_create
// file timeval_functions.c line 37
struct timeval timeval_create(signed long int tv_sec, signed long int tv_usec);
// timeval_lq_zero
// file timeval_functions.c line 121
signed int timeval_lq_zero(struct timeval *timer);
// timeval_subtract
// file timeval_functions.c line 94
signed int timeval_subtract(struct timeval *first, struct timeval *second);
// uncompress
// file /usr/include/zlib.h line 1197
extern signed int uncompress(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// wait_for_condition
// file thread_management.h line 30
void wait_for_condition(void);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writen
// file network.c line 513
signed int writen(signed int fd, unsigned char *buf, signed int amount);

struct anonymous$3
{
  // artries
  char *artries;
  // tries
  signed int tries;
  // ardelay
  char *ardelay;
  // delay
  signed int delay;
  // start
  char start;
  // quit
  char quit;
  // premature
  char premature;
};

struct anonymous$4
{
  // keysFile
  char *keysFile;
  // certificateFile
  char *certificateFile;
  // storeFile
  char *storeFile;
  // dateFormat
  char *dateFormat;
  // realmsNumber
  signed int realmsNumber;
  // ignorePublicKeys
  char ignorePublicKeys;
  // realmsTable
  struct anonymous$5 **realmsTable;
};

struct anonymous$1
{
  // listenHostName
  char *listenHostName;
  // manageHostName
  char *manageHostName;
  // listenPortName
  char *listenPortName;
  // managePortName
  char *managePortName;
  // listenFd
  signed int listenFd;
  // manageFd
  signed int manageFd;
  // number
  signed int number;
};

struct anonymous
{
  // proxyname
  char *proxyname;
  // proxyport
  char *proxyport;
  // proxyauth_cred
  char *proxyauth_cred;
  // proxyauth_type
  char proxyauth_type;
  // useHttps
  char useHttps;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct anonymous$5
{
  // serverName
  char *serverName;
  // managePort
  char *managePort;
  // hostName
  char *hostName;
  // realmName
  char *realmName;
  // sKeepAliveTimeout
  char *sKeepAliveTimeout;
  // realmId
  char *realmId;
  // localName
  char *localName;
  // localPort
  char *localPort;
  // localDestinationName
  char *localDestinationName;
  // password
  unsigned char password[4l];
  // connectedUsers
  signed int connectedUsers;
  // usersLimit
  signed int usersLimit;
  // clientMode
  signed int clientMode;
  // keepAliveTimeout
  signed int keepAliveTimeout;
  // ipFamily
  char ipFamily;
  // realmType
  char realmType;
  // tunnelType
  char tunnelType;
  // keepAlive
  struct timeval keepAlive;
  // addressLength
  unsigned int addressLength;
  // clientAddress
  struct sockaddr *clientAddress;
  // masterSslFd
  struct anonymous$0 *masterSslFd;
  // httpProxyOptions
  struct anonymous *httpProxyOptions;
  // arOptions
  struct anonymous$3 *arOptions;
  // destinationPorts
  struct portlist *destinationPorts;
  // usersTable
  struct anonymous$7 **usersTable;
  // userModule
  struct anonymous$6 *userModule;
  // serviceModule
  struct anonymous$6 *serviceModule;
};

struct anonymous$31
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$29
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$21
{
  // cert_verify_md
  unsigned char cert_verify_md[128l];
  // finish_md
  unsigned char finish_md[128l];
  // finish_md_len
  signed int finish_md_len;
  // peer_finish_md
  unsigned char peer_finish_md[128l];
  // peer_finish_md_len
  signed int peer_finish_md_len;
  // message_size
  unsigned long int message_size;
  // message_type
  signed int message_type;
  // new_cipher
  const struct ssl_cipher_st *new_cipher;
  // dh
  struct dh_st *dh;
  // ecdh
  struct ec_key_st *ecdh;
  // next_state
  signed int next_state;
  // reuse_message
  signed int reuse_message;
  // cert_req
  signed int cert_req;
  // ctype_num
  signed int ctype_num;
  // ctype
  char ctype[9l];
  // ca_names
  struct stack_st_X509_NAME *ca_names;
  // use_rsa_tmp
  signed int use_rsa_tmp;
  // key_block_length
  signed int key_block_length;
  // key_block
  unsigned char *key_block;
  // new_sym_enc
  const struct evp_cipher_st *new_sym_enc;
  // new_hash
  const struct env_md_st *new_hash;
  // new_mac_pkey_type
  signed int new_mac_pkey_type;
  // new_mac_secret_size
  signed int new_mac_secret_size;
  // new_compression
  const struct ssl_comp_st *new_compression;
  // cert_request
  signed int cert_request;
};

struct anonymous$11
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$18
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$2
{
  // tab
  unsigned char tab[5l];
  // readed
  signed int readed;
};

struct anonymous$23
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$0
{
  // fd
  signed int fd;
  // ssl
  struct ssl_st *ssl;
};

struct anonymous$8
{
  // sess_connect
  signed int sess_connect;
  // sess_connect_renegotiate
  signed int sess_connect_renegotiate;
  // sess_connect_good
  signed int sess_connect_good;
  // sess_accept
  signed int sess_accept;
  // sess_accept_renegotiate
  signed int sess_accept_renegotiate;
  // sess_accept_good
  signed int sess_accept_good;
  // sess_miss
  signed int sess_miss;
  // sess_timeout
  signed int sess_timeout;
  // sess_cache_full
  signed int sess_cache_full;
  // sess_hit
  signed int sess_hit;
  // sess_cb_hit
  signed int sess_cb_hit;
};

struct anonymous$25
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$28
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$27
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$26
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$30
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$32
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$25 _kill;
  // _timer
  struct anonymous$26 _timer;
  // _rt
  struct anonymous$27 _rt;
  // _sigchld
  struct anonymous$28 _sigchld;
  // _sigfault
  struct anonymous$29 _sigfault;
  // _sigpoll
  struct anonymous$30 _sigpoll;
  // _sigsys
  struct anonymous$31 _sigsys;
};

struct anonymous$33
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$32 _sifields;
};

struct anonymous$19
{
  // sockfd
  signed int sockfd;
  // host
  char *host;
  // serv
  char *serv;
  // hpo
  struct anonymous *hpo;
  // type
  char type;
  // ctx
  struct ssl_ctx_st *ctx;
};

struct anonymous$14
{
  // lastActivity
  signed long int lastActivity;
  // lastUSQChange
  signed long int lastUSQChange;
  // lastDSQChange
  signed long int lastDSQChange;
  // totalDownloadedBytes
  signed int totalDownloadedBytes;
  // totalUploadedBytes
  signed int totalUploadedBytes;
  // uploadSQP
  signed int uploadSQP;
  // uploadSpeedQueue
  signed int uploadSpeedQueue[3l];
  // downloadSQP
  signed int downloadSQP;
  // downloadSpeedQueue
  signed int downloadSpeedQueue[3l];
};

struct anonymous$6
{
  // loaded
  char loaded;
  // fileName
  char *fileName;
  // handle
  void *handle;
  // info
  char * (*info)(void);
  // allow
  signed int (*allow)(char *, char *);
  // filter
  signed int (*filter)(char *, unsigned char *, signed int *);
};

struct anonymous$15
{
  // type
  char type;
  // id
  char id[10l];
  // ptr
  signed int ptr;
  // length
  signed int length;
  // allreaded
  signed int allreaded;
};

struct anonymous$16
{
  // read_state
  char read_state;
  // readed_length
  char readed_length[4l];
  // state
  char state;
  // id
  char id[10l];
  // postFd
  struct anonymous$0 *postFd;
  // getFd
  struct anonymous$0 *getFd;
  // sent_ptr
  signed int sent_ptr;
  // sockfd
  signed int sockfd;
  // buf
  char buf[9000l];
  // tmpbuf
  char tmpbuf[9000l];
  // tmpstate
  char tmpstate;
  // tmpFd
  struct anonymous$0 *tmpFd;
  // type
  char type;
  // tmpheader
  struct anonymous$15 tmpheader;
  // ptr
  signed int ptr;
  // length
  signed int length;
  // curreceived
  signed int curreceived;
  // toreceive
  signed int toreceive;
  // received
  signed int received;
};

struct anonymous$7
{
  // state
  char state;
  // connFd
  signed int connFd;
  // whatClient
  signed int whatClient;
  // userId
  signed int userId;
  // connectTime
  signed long int connectTime;
  // nameBuf
  char nameBuf[128l];
  // portBuf
  char portBuf[7l];
  // bufList
  struct buflist *bufList;
  // stats
  struct anonymous$14 *stats;
};

struct anonymous$20
{
  // conn_id_length
  unsigned int conn_id_length;
  // cert_type
  unsigned int cert_type;
  // cert_length
  unsigned int cert_length;
  // csl
  unsigned int csl;
  // clear
  unsigned int clear;
  // enc
  unsigned int enc;
  // ccl
  unsigned char ccl[32l];
  // cipher_spec_length
  unsigned int cipher_spec_length;
  // session_id_length
  unsigned int session_id_length;
  // clen
  unsigned int clen;
  // rlen
  unsigned int rlen;
};

union anonymous$13
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous$12
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous$17
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$33 *, void *);
};

union anonymous$10
{
  // cb_1
  void (*cb_1)(signed int, signed int, void *);
  // cb_2
  signed int (*cb_2)(signed int, signed int, struct bn_gencb_st *);
};

union anonymous$9
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$24
{
  // __data
  struct anonymous$23 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$22
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ASN1_ENCODING_st
{
  // enc
  unsigned char *enc;
  // len
  signed long int len;
  // modified
  signed int modified;
};

struct DSA_SIG_st
{
  // r
  struct bignum_st *r;
  // s
  struct bignum_st *s;
};

struct X509_VERIFY_PARAM_st
{
  // name
  char *name;
  // check_time
  signed long int check_time;
  // inh_flags
  unsigned long int inh_flags;
  // flags
  unsigned long int flags;
  // purpose
  signed int purpose;
  // trust
  signed int trust;
  // depth
  signed int depth;
  // policies
  struct stack_st_ASN1_OBJECT *policies;
  // id
  struct X509_VERIFY_PARAM_ID_st *id;
};

struct X509_algor_st
{
  // algorithm
  struct asn1_object_st *algorithm;
  // parameter
  struct asn1_type_st *parameter;
};

struct X509_crl_info_st
{
  // version
  struct asn1_string_st *version;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // issuer
  struct X509_name_st *issuer;
  // lastUpdate
  struct asn1_string_st *lastUpdate;
  // nextUpdate
  struct asn1_string_st *nextUpdate;
  // revoked
  struct stack_st_X509_REVOKED *revoked;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct X509_crl_st
{
  // crl
  struct X509_crl_info_st *crl;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
  // flags
  signed int flags;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // idp
  struct ISSUING_DIST_POINT_st *idp;
  // idp_flags
  signed int idp_flags;
  // idp_reasons
  signed int idp_reasons;
  // crl_number
  struct asn1_string_st *crl_number;
  // base_crl_number
  struct asn1_string_st *base_crl_number;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // issuers
  struct stack_st_GENERAL_NAMES *issuers;
  // meth
  const struct x509_crl_method_st *meth;
  // meth_data
  void *meth_data;
};

struct X509_name_entry_st
{
  // object
  struct asn1_object_st *object;
  // value
  struct asn1_string_st *value;
  // set
  signed int set;
  // size
  signed int size;
};

struct X509_name_st
{
  // entries
  struct stack_st_X509_NAME_ENTRY *entries;
  // modified
  signed int modified;
  // bytes
  struct buf_mem_st *bytes;
  // canon_enc
  unsigned char *canon_enc;
  // canon_enclen
  signed int canon_enclen;
};

struct X509_pubkey_st
{
  // algor
  struct X509_algor_st *algor;
  // public_key
  struct asn1_string_st *public_key;
  // pkey
  struct evp_pkey_st *pkey;
};

struct X509_req_info_st
{
  // enc
  struct ASN1_ENCODING_st enc;
  // version
  struct asn1_string_st *version;
  // subject
  struct X509_name_st *subject;
  // pubkey
  struct X509_pubkey_st *pubkey;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct X509_req_st
{
  // req_info
  struct X509_req_info_st *req_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
};

struct X509_val_st
{
  // notBefore
  struct asn1_string_st *notBefore;
  // notAfter
  struct asn1_string_st *notAfter;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct alnode
{
  // userId
  signed int userId;
  // nameBuf
  char nameBuf[128l];
  // portBuf
  char portBuf[7l];
  // connectTime
  signed long int connectTime;
  // duration
  signed long int duration;
  // nextNode
  struct alnode *nextNode;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous$12 value;
};

struct auditlist
{
  // head
  struct alnode *head;
  // tail
  struct alnode *tail;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct blnode
{
  // actPtr
  signed int actPtr;
  // msgLen
  signed int msgLen;
  // message
  unsigned char *message;
  // nextNode
  struct blnode *nextNode;
};

struct bn_gencb_st
{
  // ver
  unsigned int ver;
  // arg
  void *arg;
  // cb
  union anonymous$10 cb;
};

struct bn_mont_ctx_st
{
  // ri
  signed int ri;
  // RR
  struct bignum_st RR;
  // N
  struct bignum_st N;
  // Ni
  struct bignum_st Ni;
  // n0
  unsigned long int n0[2l];
  // flags
  signed int flags;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct buflist
{
  // head
  struct blnode *head;
  // tail
  struct blnode *tail;
};

struct comp_ctx_st
{
  // meth
  struct comp_method_st *meth;
  // compress_in
  unsigned long int compress_in;
  // compress_out
  unsigned long int compress_out;
  // expand_in
  unsigned long int expand_in;
  // expand_out
  unsigned long int expand_out;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct comp_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // init
  signed int (*init)(struct comp_ctx_st *);
  // finish
  void (*finish)(struct comp_ctx_st *);
  // compress
  signed int (*compress)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // expand
  signed int (*expand)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // ctrl
  signed long int (*ctrl)(void);
  // callback_ctrl
  signed long int (*callback_ctrl)(void);
};

struct dh_method
{
  // name
  const char *name;
  // generate_key
  signed int (*generate_key)(struct dh_st *);
  // compute_key
  signed int (*compute_key)(unsigned char *, const struct bignum_st *, struct dh_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(const struct dh_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dh_st *);
  // finish
  signed int (*finish)(struct dh_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // generate_params
  signed int (*generate_params)(struct dh_st *, signed int, signed int, struct bn_gencb_st *);
};

struct dh_st
{
  // pad
  signed int pad;
  // version
  signed int version;
  // p
  struct bignum_st *p;
  // g
  struct bignum_st *g;
  // length
  signed long int length;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // q
  struct bignum_st *q;
  // j
  struct bignum_st *j;
  // seed
  unsigned char *seed;
  // seedlen
  signed int seedlen;
  // counter
  struct bignum_st *counter;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dh_method *meth;
  // engine
  struct engine_st *engine;
};

struct dsa_method
{
  // name
  const char *name;
  // dsa_do_sign
  struct DSA_SIG_st * (*dsa_do_sign)(const unsigned char *, signed int, struct dsa_st *);
  // dsa_sign_setup
  signed int (*dsa_sign_setup)(struct dsa_st *, struct bignum_ctx *, struct bignum_st **, struct bignum_st **);
  // dsa_do_verify
  signed int (*dsa_do_verify)(const unsigned char *, signed int, struct DSA_SIG_st *, struct dsa_st *);
  // dsa_mod_exp
  signed int (*dsa_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dsa_st *);
  // finish
  signed int (*finish)(struct dsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // dsa_paramgen
  signed int (*dsa_paramgen)(struct dsa_st *, signed int, const unsigned char *, signed int, signed int *, unsigned long int *, struct bn_gencb_st *);
  // dsa_keygen
  signed int (*dsa_keygen)(struct dsa_st *);
};

struct dsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // write_params
  signed int write_params;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // g
  struct bignum_st *g;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // kinv
  struct bignum_st *kinv;
  // r
  struct bignum_st *r;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dsa_method *meth;
  // engine
  struct engine_st *engine;
};

struct dtls1_bitmap_st
{
  // map
  unsigned long int map;
  // max_seq_num
  unsigned char max_seq_num[8l];
};

struct dtls1_retransmit_state
{
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // session
  struct ssl_session_st *session;
  // epoch
  unsigned short int epoch;
};

struct record_pqueue_st
{
  // epoch
  unsigned short int epoch;
  // q
  struct _pqueue *q;
};

struct hm_header_st
{
  // type
  unsigned char type;
  // msg_len
  unsigned long int msg_len;
  // seq
  unsigned short int seq;
  // frag_off
  unsigned long int frag_off;
  // frag_len
  unsigned long int frag_len;
  // is_ccs
  unsigned int is_ccs;
  // saved_retransmit_state
  struct dtls1_retransmit_state saved_retransmit_state;
};

struct dtls1_timeout_st
{
  // read_timeouts
  unsigned int read_timeouts;
  // write_timeouts
  unsigned int write_timeouts;
  // num_alerts
  unsigned int num_alerts;
};

struct dtls1_state_st
{
  // send_cookie
  unsigned int send_cookie;
  // cookie
  unsigned char cookie[256l];
  // rcvd_cookie
  unsigned char rcvd_cookie[256l];
  // cookie_len
  unsigned int cookie_len;
  // r_epoch
  unsigned short int r_epoch;
  // w_epoch
  unsigned short int w_epoch;
  // bitmap
  struct dtls1_bitmap_st bitmap;
  // next_bitmap
  struct dtls1_bitmap_st next_bitmap;
  // handshake_write_seq
  unsigned short int handshake_write_seq;
  // next_handshake_write_seq
  unsigned short int next_handshake_write_seq;
  // handshake_read_seq
  unsigned short int handshake_read_seq;
  // last_write_sequence
  unsigned char last_write_sequence[8l];
  // unprocessed_rcds
  struct record_pqueue_st unprocessed_rcds;
  // processed_rcds
  struct record_pqueue_st processed_rcds;
  // buffered_messages
  struct _pqueue *buffered_messages;
  // sent_messages
  struct _pqueue *sent_messages;
  // buffered_app_data
  struct record_pqueue_st buffered_app_data;
  // listen
  unsigned int listen;
  // link_mtu
  unsigned int link_mtu;
  // mtu
  unsigned int mtu;
  // w_msg_hdr
  struct hm_header_st w_msg_hdr;
  // r_msg_hdr
  struct hm_header_st r_msg_hdr;
  // timeout
  struct dtls1_timeout_st timeout;
  // next_timeout
  struct timeval next_timeout;
  // timeout_duration
  unsigned short int timeout_duration;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[12l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // retransmitting
  unsigned int retransmitting;
  // change_cipher_spec_ok
  unsigned int change_cipher_spec_ok;
};

struct entry
{
  // key
  char *key;
  // value
  unsigned char *value;
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous$13 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct in6_addr
{
  // __in6_u
  union anonymous$9 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct lhash_st_SSL_SESSION
{
  // dummy
  signed int dummy;
};

struct llnode
{
  // cmdline
  char *cmdline;
  // msgtype
  char msgtype;
  // importance
  char importance;
  // logfd
  struct _IO_FILE *logfd;
  // next
  struct llnode *next;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct plnode
{
  // portName
  char *portName;
  // nextNode
  struct plnode *nextNode;
};

struct portlist
{
  // size
  signed int size;
  // head
  struct plnode *head;
  // tail
  struct plnode *tail;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rsa_meth_st
{
  // name
  const char *name;
  // rsa_pub_enc
  signed int (*rsa_pub_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_pub_dec
  signed int (*rsa_pub_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_enc
  signed int (*rsa_priv_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_dec
  signed int (*rsa_priv_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_mod_exp
  signed int (*rsa_mod_exp)(struct bignum_st *, const struct bignum_st *, struct rsa_st *, struct bignum_ctx *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct rsa_st *);
  // finish
  signed int (*finish)(struct rsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // rsa_sign
  signed int (*rsa_sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, const struct rsa_st *);
  // rsa_verify
  signed int (*rsa_verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, const struct rsa_st *);
  // rsa_keygen
  signed int (*rsa_keygen)(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
};

struct rsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // meth
  const struct rsa_meth_st *meth;
  // engine
  struct engine_st *engine;
  // n
  struct bignum_st *n;
  // e
  struct bignum_st *e;
  // d
  struct bignum_st *d;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // dmp1
  struct bignum_st *dmp1;
  // dmq1
  struct bignum_st *dmq1;
  // iqmp
  struct bignum_st *iqmp;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
  // flags
  signed int flags;
  // _method_mod_n
  struct bn_mont_ctx_st *_method_mod_n;
  // _method_mod_p
  struct bn_mont_ctx_st *_method_mod_p;
  // _method_mod_q
  struct bn_mont_ctx_st *_method_mod_q;
  // bignum_data
  char *bignum_data;
  // blinding
  struct bn_blinding_st *blinding;
  // mt_blinding
  struct bn_blinding_st *mt_blinding;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$17 __sigaction_handler;
  // sa_mask
  struct anonymous$18 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct srp_ctx_st
{
  // SRP_cb_arg
  void *SRP_cb_arg;
  // TLS_ext_srp_username_callback
  signed int (*TLS_ext_srp_username_callback)(struct ssl_st *, signed int *, void *);
  // SRP_verify_param_callback
  signed int (*SRP_verify_param_callback)(struct ssl_st *, void *);
  // SRP_give_srp_client_pwd_callback
  char * (*SRP_give_srp_client_pwd_callback)(struct ssl_st *, void *);
  // login
  char *login;
  // N
  struct bignum_st *N;
  // g
  struct bignum_st *g;
  // s
  struct bignum_st *s;
  // B
  struct bignum_st *B;
  // A
  struct bignum_st *A;
  // a
  struct bignum_st *a;
  // b
  struct bignum_st *b;
  // v
  struct bignum_st *v;
  // info
  char *info;
  // strength
  signed int strength;
  // srp_Mask
  unsigned long int srp_Mask;
};

struct srtp_protection_profile_st
{
  // name
  const char *name;
  // id
  unsigned long int id;
};

struct ssl2_state_st
{
  // three_byte_header
  signed int three_byte_header;
  // clear_text
  signed int clear_text;
  // escape
  signed int escape;
  // ssl2_rollback
  signed int ssl2_rollback;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_buf
  const unsigned char *wpend_buf;
  // wpend_off
  signed int wpend_off;
  // wpend_len
  signed int wpend_len;
  // wpend_ret
  signed int wpend_ret;
  // rbuf_left
  signed int rbuf_left;
  // rbuf_offs
  signed int rbuf_offs;
  // rbuf
  unsigned char *rbuf;
  // wbuf
  unsigned char *wbuf;
  // write_ptr
  unsigned char *write_ptr;
  // padding
  unsigned int padding;
  // rlength
  unsigned int rlength;
  // ract_data_length
  signed int ract_data_length;
  // wlength
  unsigned int wlength;
  // wact_data_length
  signed int wact_data_length;
  // ract_data
  unsigned char *ract_data;
  // wact_data
  unsigned char *wact_data;
  // mac_data
  unsigned char *mac_data;
  // read_key
  unsigned char *read_key;
  // write_key
  unsigned char *write_key;
  // challenge_length
  unsigned int challenge_length;
  // challenge
  unsigned char challenge[32l];
  // conn_id_length
  unsigned int conn_id_length;
  // conn_id
  unsigned char conn_id[16l];
  // key_material_length
  unsigned int key_material_length;
  // key_material
  unsigned char key_material[48l];
  // read_sequence
  unsigned long int read_sequence;
  // write_sequence
  unsigned long int write_sequence;
  // tmp
  struct anonymous$20 tmp;
};

struct ssl3_buffer_st
{
  // buf
  unsigned char *buf;
  // len
  unsigned long int len;
  // offset
  signed int offset;
  // left
  signed int left;
};

struct ssl3_record_st
{
  // type
  signed int type;
  // length
  unsigned int length;
  // off
  unsigned int off;
  // data
  unsigned char *data;
  // input
  unsigned char *input;
  // comp
  unsigned char *comp;
  // epoch
  unsigned long int epoch;
  // seq_num
  unsigned char seq_num[8l];
};

struct ssl3_state_st
{
  // flags
  signed long int flags;
  // delay_buf_pop_ret
  signed int delay_buf_pop_ret;
  // read_sequence
  unsigned char read_sequence[8l];
  // read_mac_secret_size
  signed int read_mac_secret_size;
  // read_mac_secret
  unsigned char read_mac_secret[64l];
  // write_sequence
  unsigned char write_sequence[8l];
  // write_mac_secret_size
  signed int write_mac_secret_size;
  // write_mac_secret
  unsigned char write_mac_secret[64l];
  // server_random
  unsigned char server_random[32l];
  // client_random
  unsigned char client_random[32l];
  // need_empty_fragments
  signed int need_empty_fragments;
  // empty_fragment_done
  signed int empty_fragment_done;
  // init_extra
  signed int init_extra;
  // rbuf
  struct ssl3_buffer_st rbuf;
  // wbuf
  struct ssl3_buffer_st wbuf;
  // rrec
  struct ssl3_record_st rrec;
  // wrec
  struct ssl3_record_st wrec;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[4l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_type
  signed int wpend_type;
  // wpend_ret
  signed int wpend_ret;
  // wpend_buf
  const unsigned char *wpend_buf;
  // handshake_buffer
  struct bio_st *handshake_buffer;
  // handshake_dgst
  struct env_md_ctx_st **handshake_dgst;
  // change_cipher_spec
  signed int change_cipher_spec;
  // warn_alert
  signed int warn_alert;
  // fatal_alert
  signed int fatal_alert;
  // alert_dispatch
  signed int alert_dispatch;
  // send_alert
  unsigned char send_alert[2l];
  // renegotiate
  signed int renegotiate;
  // total_renegotiations
  signed int total_renegotiations;
  // num_renegotiations
  signed int num_renegotiations;
  // in_read_app_data
  signed int in_read_app_data;
  // client_opaque_prf_input
  void *client_opaque_prf_input;
  // client_opaque_prf_input_len
  unsigned long int client_opaque_prf_input_len;
  // server_opaque_prf_input
  void *server_opaque_prf_input;
  // server_opaque_prf_input_len
  unsigned long int server_opaque_prf_input_len;
  // tmp
  struct anonymous$21 tmp;
  // previous_client_finished
  unsigned char previous_client_finished[64l];
  // previous_client_finished_len
  unsigned char previous_client_finished_len;
  // previous_server_finished
  unsigned char previous_server_finished[64l];
  // previous_server_finished_len
  unsigned char previous_server_finished_len;
  // send_connection_binding
  signed int send_connection_binding;
  // next_proto_neg_seen
  signed int next_proto_neg_seen;
  // is_probably_safari
  char is_probably_safari;
  // alpn_selected
  unsigned char *alpn_selected;
  // alpn_selected_len
  unsigned int alpn_selected_len;
};

struct ssl_cipher_st
{
  // valid
  signed int valid;
  // name
  const char *name;
  // id
  unsigned long int id;
  // algorithm_mkey
  unsigned long int algorithm_mkey;
  // algorithm_auth
  unsigned long int algorithm_auth;
  // algorithm_enc
  unsigned long int algorithm_enc;
  // algorithm_mac
  unsigned long int algorithm_mac;
  // algorithm_ssl
  unsigned long int algorithm_ssl;
  // algo_strength
  unsigned long int algo_strength;
  // algorithm2
  unsigned long int algorithm2;
  // strength_bits
  signed int strength_bits;
  // alg_bits
  signed int alg_bits;
};

struct ssl_comp_st
{
  // id
  signed int id;
  // name
  const char *name;
  // method
  struct comp_method_st *method;
};

struct ssl_ctx_st
{
  // method
  const struct ssl_method_st *method;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // cert_store
  struct x509_store_st *cert_store;
  // sessions
  struct lhash_st_SSL_SESSION *sessions;
  // session_cache_size
  unsigned long int session_cache_size;
  // session_cache_head
  struct ssl_session_st *session_cache_head;
  // session_cache_tail
  struct ssl_session_st *session_cache_tail;
  // session_cache_mode
  signed int session_cache_mode;
  // session_timeout
  signed long int session_timeout;
  // new_session_cb
  signed int (*new_session_cb)(struct ssl_st *, struct ssl_session_st *);
  // remove_session_cb
  void (*remove_session_cb)(struct ssl_ctx_st *, struct ssl_session_st *);
  // get_session_cb
  struct ssl_session_st * (*get_session_cb)(struct ssl_st *, unsigned char *, signed int, signed int *);
  // stats
  struct anonymous$8 stats;
  // references
  signed int references;
  // app_verify_callback
  signed int (*app_verify_callback)(struct x509_store_ctx_st *, void *);
  // app_verify_arg
  void *app_verify_arg;
  // default_passwd_callback
  signed int (*default_passwd_callback)(char *, signed int, signed int, void *);
  // default_passwd_callback_userdata
  void *default_passwd_callback_userdata;
  // client_cert_cb
  signed int (*client_cert_cb)(struct ssl_st *, struct x509_st **, struct evp_pkey_st **);
  // app_gen_cookie_cb
  signed int (*app_gen_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int *);
  // app_verify_cookie_cb
  signed int (*app_verify_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // rsa_md5
  const struct env_md_st *rsa_md5;
  // md5
  const struct env_md_st *md5;
  // sha1
  const struct env_md_st *sha1;
  // extra_certs
  struct stack_st_X509 *extra_certs;
  // comp_methods
  struct stack_st_SSL_COMP *comp_methods;
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // cert
  struct cert_st *cert;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // verify_mode
  signed int verify_mode;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // default_verify_callback
  signed int (*default_verify_callback)(signed int, struct x509_store_ctx_st *);
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // param
  struct X509_VERIFY_PARAM_st *param;
  // quiet_shutdown
  signed int quiet_shutdown;
  // max_send_fragment
  unsigned int max_send_fragment;
  // client_cert_engine
  struct engine_st *client_cert_engine;
  // tlsext_servername_callback
  signed int (*tlsext_servername_callback)(struct ssl_st *, signed int *, void *);
  // tlsext_servername_arg
  void *tlsext_servername_arg;
  // tlsext_tick_key_name
  unsigned char tlsext_tick_key_name[16l];
  // tlsext_tick_hmac_key
  unsigned char tlsext_tick_hmac_key[16l];
  // tlsext_tick_aes_key
  unsigned char tlsext_tick_aes_key[16l];
  // tlsext_ticket_key_cb
  signed int (*tlsext_ticket_key_cb)(struct ssl_st *, unsigned char *, unsigned char *, struct evp_cipher_ctx_st *, struct hmac_ctx_st *, signed int);
  // tlsext_status_cb
  signed int (*tlsext_status_cb)(struct ssl_st *, void *);
  // tlsext_status_arg
  void *tlsext_status_arg;
  // tlsext_opaque_prf_input_callback
  signed int (*tlsext_opaque_prf_input_callback)(struct ssl_st *, void *, unsigned long int, void *);
  // tlsext_opaque_prf_input_callback_arg
  void *tlsext_opaque_prf_input_callback_arg;
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // freelist_max_len
  unsigned int freelist_max_len;
  // wbuf_freelist
  struct ssl3_buf_freelist_st *wbuf_freelist;
  // rbuf_freelist
  struct ssl3_buf_freelist_st *rbuf_freelist;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // next_protos_advertised_cb
  signed int (*next_protos_advertised_cb)(struct ssl_st *, const unsigned char **, unsigned int *, void *);
  // next_protos_advertised_cb_arg
  void *next_protos_advertised_cb_arg;
  // next_proto_select_cb
  signed int (*next_proto_select_cb)(struct ssl_st *, unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // next_proto_select_cb_arg
  void *next_proto_select_cb_arg;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // alpn_select_cb
  signed int (*alpn_select_cb)(struct ssl_st *, const unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // alpn_select_cb_arg
  void *alpn_select_cb_arg;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
};

struct ssl_method_st
{
  // version
  signed int version;
  // ssl_new
  signed int (*ssl_new)(struct ssl_st *);
  // ssl_clear
  void (*ssl_clear)(struct ssl_st *);
  // ssl_free
  void (*ssl_free)(struct ssl_st *);
  // ssl_accept
  signed int (*ssl_accept)(struct ssl_st *);
  // ssl_connect
  signed int (*ssl_connect)(struct ssl_st *);
  // ssl_read
  signed int (*ssl_read)(struct ssl_st *, void *, signed int);
  // ssl_peek
  signed int (*ssl_peek)(struct ssl_st *, void *, signed int);
  // ssl_write
  signed int (*ssl_write)(struct ssl_st *, const void *, signed int);
  // ssl_shutdown
  signed int (*ssl_shutdown)(struct ssl_st *);
  // ssl_renegotiate
  signed int (*ssl_renegotiate)(struct ssl_st *);
  // ssl_renegotiate_check
  signed int (*ssl_renegotiate_check)(struct ssl_st *);
  // ssl_get_message
  signed long int (*ssl_get_message)(struct ssl_st *, signed int, signed int, signed int, signed long int, signed int *);
  // ssl_read_bytes
  signed int (*ssl_read_bytes)(struct ssl_st *, signed int, unsigned char *, signed int, signed int);
  // ssl_write_bytes
  signed int (*ssl_write_bytes)(struct ssl_st *, signed int, const void *, signed int);
  // ssl_dispatch_alert
  signed int (*ssl_dispatch_alert)(struct ssl_st *);
  // ssl_ctrl
  signed long int (*ssl_ctrl)(struct ssl_st *, signed int, signed long int, void *);
  // ssl_ctx_ctrl
  signed long int (*ssl_ctx_ctrl)(struct ssl_ctx_st *, signed int, signed long int, void *);
  // get_cipher_by_char
  const struct ssl_cipher_st * (*get_cipher_by_char)(const unsigned char *);
  // put_cipher_by_char
  signed int (*put_cipher_by_char)(const struct ssl_cipher_st *, unsigned char *);
  // ssl_pending
  signed int (*ssl_pending)(const struct ssl_st *);
  // num_ciphers
  signed int (*num_ciphers)(void);
  // get_cipher
  const struct ssl_cipher_st * (*get_cipher)(unsigned int);
  // get_ssl_method
  struct ssl_method_st * (*get_ssl_method)(signed int);
  // get_timeout
  signed long int (*get_timeout)(void);
  // ssl3_enc
  struct ssl3_enc_method *ssl3_enc;
  // ssl_version
  signed int (*ssl_version)(void);
  // ssl_callback_ctrl
  signed long int (*ssl_callback_ctrl)(struct ssl_st *, signed int, void (*)(void));
  // ssl_ctx_callback_ctrl
  signed long int (*ssl_ctx_callback_ctrl)(struct ssl_ctx_st *, signed int, void (*)(void));
};

struct ssl_session_st
{
  // ssl_version
  signed int ssl_version;
  // key_arg_length
  unsigned int key_arg_length;
  // key_arg
  unsigned char key_arg[8l];
  // master_key_length
  signed int master_key_length;
  // master_key
  unsigned char master_key[48l];
  // session_id_length
  unsigned int session_id_length;
  // session_id
  unsigned char session_id[32l];
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_identity
  char *psk_identity;
  // not_resumable
  signed int not_resumable;
  // sess_cert
  struct sess_cert_st *sess_cert;
  // peer
  struct x509_st *peer;
  // verify_result
  signed long int verify_result;
  // references
  signed int references;
  // timeout
  signed long int timeout;
  // time
  signed long int time;
  // compress_meth
  unsigned int compress_meth;
  // cipher
  const struct ssl_cipher_st *cipher;
  // cipher_id
  unsigned long int cipher_id;
  // ciphers
  struct stack_st_SSL_CIPHER *ciphers;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // prev
  struct ssl_session_st *prev;
  // next
  struct ssl_session_st *next;
  // tlsext_hostname
  char *tlsext_hostname;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_tick
  unsigned char *tlsext_tick;
  // tlsext_ticklen
  unsigned long int tlsext_ticklen;
  // tlsext_tick_lifetime_hint
  signed long int tlsext_tick_lifetime_hint;
  // srp_username
  char *srp_username;
};

struct ssl_st
{
  // version
  signed int version;
  // type
  signed int type;
  // method
  const struct ssl_method_st *method;
  // rbio
  struct bio_st *rbio;
  // wbio
  struct bio_st *wbio;
  // bbio
  struct bio_st *bbio;
  // rwstate
  signed int rwstate;
  // in_handshake
  signed int in_handshake;
  // handshake_func
  signed int (*handshake_func)(struct ssl_st *);
  // server
  signed int server;
  // new_session
  signed int new_session;
  // quiet_shutdown
  signed int quiet_shutdown;
  // shutdown
  signed int shutdown;
  // state
  signed int state;
  // rstate
  signed int rstate;
  // init_buf
  struct buf_mem_st *init_buf;
  // init_msg
  void *init_msg;
  // init_num
  signed int init_num;
  // init_off
  signed int init_off;
  // packet
  unsigned char *packet;
  // packet_length
  unsigned int packet_length;
  // s2
  struct ssl2_state_st *s2;
  // s3
  struct ssl3_state_st *s3;
  // d1
  struct dtls1_state_st *d1;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // hit
  signed int hit;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // mac_flags
  signed int mac_flags;
  // enc_read_ctx
  struct evp_cipher_ctx_st *enc_read_ctx;
  // read_hash
  struct env_md_ctx_st *read_hash;
  // expand
  struct comp_ctx_st *expand;
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // cert
  struct cert_st *cert;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // session
  struct ssl_session_st *session;
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // verify_mode
  signed int verify_mode;
  // verify_callback
  signed int (*verify_callback)(signed int, struct x509_store_ctx_st *);
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // error
  signed int error;
  // error_code
  signed int error_code;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // ctx
  struct ssl_ctx_st *ctx;
  // debug
  signed int debug;
  // verify_result
  signed long int verify_result;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // references
  signed int references;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // first_packet
  signed int first_packet;
  // client_version
  signed int client_version;
  // max_send_fragment
  unsigned int max_send_fragment;
  // tlsext_debug_cb
  void (*tlsext_debug_cb)(struct ssl_st *, signed int, signed int, unsigned char *, signed int, void *);
  // tlsext_debug_arg
  void *tlsext_debug_arg;
  // tlsext_hostname
  char *tlsext_hostname;
  // servername_done
  signed int servername_done;
  // tlsext_status_type
  signed int tlsext_status_type;
  // tlsext_status_expected
  signed int tlsext_status_expected;
  // tlsext_ocsp_ids
  struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  // tlsext_ocsp_exts
  struct stack_st_X509_EXTENSION *tlsext_ocsp_exts;
  // tlsext_ocsp_resp
  unsigned char *tlsext_ocsp_resp;
  // tlsext_ocsp_resplen
  signed int tlsext_ocsp_resplen;
  // tlsext_ticket_expected
  signed int tlsext_ticket_expected;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_opaque_prf_input
  void *tlsext_opaque_prf_input;
  // tlsext_opaque_prf_input_len
  unsigned long int tlsext_opaque_prf_input_len;
  // tlsext_session_ticket
  struct tls_session_ticket_ext_st *tlsext_session_ticket;
  // tls_session_ticket_ext_cb
  signed int (*tls_session_ticket_ext_cb)(struct ssl_st *, const unsigned char *, signed int, void *);
  // tls_session_ticket_ext_cb_arg
  void *tls_session_ticket_ext_cb_arg;
  // tls_session_secret_cb
  signed int (*tls_session_secret_cb)(struct ssl_st *, void *, signed int *, struct stack_st_SSL_CIPHER *, struct ssl_cipher_st **, void *);
  // tls_session_secret_cb_arg
  void *tls_session_secret_cb_arg;
  // initial_ctx
  struct ssl_ctx_st *initial_ctx;
  // next_proto_negotiated
  unsigned char *next_proto_negotiated;
  // next_proto_negotiated_len
  unsigned char next_proto_negotiated_len;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // srtp_profile
  struct srtp_protection_profile_st *srtp_profile;
  // tlsext_heartbeat
  unsigned int tlsext_heartbeat;
  // tlsext_hb_pending
  unsigned int tlsext_hb_pending;
  // tlsext_hb_seq
  unsigned int tlsext_hb_seq;
  // renegotiate
  signed int renegotiate;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_ASN1_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_SRTP_PROTECTION_PROFILE
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_CIPHER
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_COMP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ALGOR
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ATTRIBUTE
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_CRL
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_EXTENSION
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_LOOKUP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME_ENTRY
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_REVOKED
{
  // stack
  struct stack_st stack;
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tls_session_ticket_ext_st
{
  // length
  unsigned short int length;
  // data
  void *data;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct x509_cert_aux_st
{
  // trust
  struct stack_st_ASN1_OBJECT *trust;
  // reject
  struct stack_st_ASN1_OBJECT *reject;
  // alias
  struct asn1_string_st *alias;
  // keyid
  struct asn1_string_st *keyid;
  // other
  struct stack_st_X509_ALGOR *other;
};

struct x509_cinf_st
{
  // version
  struct asn1_string_st *version;
  // serialNumber
  struct asn1_string_st *serialNumber;
  // signature
  struct X509_algor_st *signature;
  // issuer
  struct X509_name_st *issuer;
  // validity
  struct X509_val_st *validity;
  // subject
  struct X509_name_st *subject;
  // key
  struct X509_pubkey_st *key;
  // issuerUID
  struct asn1_string_st *issuerUID;
  // subjectUID
  struct asn1_string_st *subjectUID;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct x509_st
{
  // cert_info
  struct x509_cinf_st *cert_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // valid
  signed int valid;
  // references
  signed int references;
  // name
  char *name;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // ex_pathlen
  signed long int ex_pathlen;
  // ex_pcpathlen
  signed long int ex_pcpathlen;
  // ex_flags
  unsigned long int ex_flags;
  // ex_kusage
  unsigned long int ex_kusage;
  // ex_xkusage
  unsigned long int ex_xkusage;
  // ex_nscert
  unsigned long int ex_nscert;
  // skid
  struct asn1_string_st *skid;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // policy_cache
  struct X509_POLICY_CACHE_st *policy_cache;
  // crldp
  struct stack_st_DIST_POINT *crldp;
  // altname
  struct stack_st_GENERAL_NAME *altname;
  // nc
  struct NAME_CONSTRAINTS_st *nc;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // aux
  struct x509_cert_aux_st *aux;
};

struct x509_store_ctx_st
{
  // ctx
  struct x509_store_st *ctx;
  // current_method
  signed int current_method;
  // cert
  struct x509_st *cert;
  // untrusted
  struct stack_st_X509 *untrusted;
  // crls
  struct stack_st_X509_CRL *crls;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // other_ctx
  void *other_ctx;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // check_policy
  signed int (*check_policy)(struct x509_store_ctx_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // valid
  signed int valid;
  // last_untrusted
  signed int last_untrusted;
  // chain
  struct stack_st_X509 *chain;
  // tree
  struct X509_POLICY_TREE_st *tree;
  // explicit_policy
  signed int explicit_policy;
  // error_depth
  signed int error_depth;
  // error
  signed int error;
  // current_cert
  struct x509_st *current_cert;
  // current_issuer
  struct x509_st *current_issuer;
  // current_crl
  struct X509_crl_st *current_crl;
  // current_crl_score
  signed int current_crl_score;
  // current_reasons
  unsigned int current_reasons;
  // parent
  struct x509_store_ctx_st *parent;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct x509_store_st
{
  // cache
  signed int cache;
  // objs
  struct stack_st_X509_OBJECT *objs;
  // get_cert_methods
  struct stack_st_X509_LOOKUP *get_cert_methods;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
};


// Base64
// file base64.c line 67
static const char Base64[65l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', 0 };
// Pad64
// file base64.c line 68
static const char Pad64 = (const char)61;
// cconfig
// file afclient.c line 72
struct anonymous$4 *cconfig;
// compressgained
// file stats.c line 25
static signed long int compressgained;
// entries
// file first_run.c line 47
static struct entry entries[6l] = { { .key="countryName", .value=(unsigned char *)"PL" },
    { .key="stateOrProvinceName", .value=(unsigned char *)"War-Maz" },
    { .key="localityName", .value=(unsigned char *)"Olsztyn" },
    { .key="organizationName", .value=(unsigned char *)"gray-world.net" },
    { .key="organizationalUnitName", .value=(unsigned char *)"APF team" },
    { .key="commonName", .value=(unsigned char *)"Jeremian <jeremian [at] poczta [dot] fm>" } };
// format
// file logging.c line 32
static char format[51l] = { '%', 'Y', '-', '%', 'm', '-', '%', 'd', ' ', '%', 'H', ':', '%', 'M', ':', '%', 'S', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// head
// file logging.c line 30
static struct llnode *head = (struct llnode *)(void *)0;
// home_dir
// file first_run.c line 35
static char *home_dir = (char *)(void *)0;
// home_dir_cer
// file first_run.c line 38
static char *home_dir_cer = (char *)(void *)0;
// home_dir_key
// file first_run.c line 37
static char *home_dir_key = (char *)(void *)0;
// home_dir_store
// file first_run.c line 36
static char *home_dir_store = (char *)(void *)0;
// isseed
// file http_proxy_functions.c line 28
static char isseed;
// long_options
// file afclient.c line 25
static struct option long_options[38l] = { { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name="udpmode", .has_arg=0, .flag=((signed int *)NULL), .val=117 },
    { .name="reverseudp", .has_arg=0, .flag=((signed int *)NULL), .val=85 },
    { .name="servername", .has_arg=1, .flag=((signed int *)NULL), .val=110 },
    { .name="manageport", .has_arg=1, .flag=((signed int *)NULL), .val=109 },
    { .name="hostname", .has_arg=1, .flag=((signed int *)NULL), .val=100 },
    { .name="portnum", .has_arg=1, .flag=((signed int *)NULL), .val=112 },
    { .name="verbose", .has_arg=0, .flag=((signed int *)NULL), .val=118 },
    { .name="keyfile", .has_arg=1, .flag=((signed int *)NULL), .val=107 },
    { .name="cerfile", .has_arg=1, .flag=((signed int *)NULL), .val=99 },
    { .name="storefile", .has_arg=1, .flag=((signed int *)NULL), .val=115 },
    { .name="cfgfile", .has_arg=1, .flag=((signed int *)NULL), .val=102 },
    { .name="log", .has_arg=1, .flag=((signed int *)NULL), .val=111 },
    { .name="pass", .has_arg=1, .flag=((signed int *)NULL), .val=301 },
    { .name="ignorepkeys", .has_arg=0, .flag=((signed int *)NULL), .val=302 },
    { .name="ipv4", .has_arg=0, .flag=((signed int *)NULL), .val=52 },
    { .name="ipv6", .has_arg=0, .flag=((signed int *)NULL), .val=54 },
    { .name="load", .has_arg=1, .flag=((signed int *)NULL), .val=108 },
    { .name="Load", .has_arg=1, .flag=((signed int *)NULL), .val=76 },
    { .name="id", .has_arg=1, .flag=((signed int *)NULL), .val=105 },
    { .name="dateformat", .has_arg=1, .flag=((signed int *)NULL), .val=68 },
    { .name="remoteadmin", .has_arg=0, .flag=((signed int *)NULL), .val=114 },
    { .name="use-https", .has_arg=0, .flag=((signed int *)NULL), .val=83 },
    { .name="proxyname", .has_arg=1, .flag=((signed int *)NULL), .val=80 },
    { .name="proxyport", .has_arg=1, .flag=((signed int *)NULL), .val=88 },
    { .name="pa-t-basic", .has_arg=0, .flag=((signed int *)NULL), .val=66 },
    { .name="pa-cred", .has_arg=1, .flag=((signed int *)NULL), .val=67 },
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=86 },
    { .name="keep-alive", .has_arg=1, .flag=((signed int *)NULL), .val=75 },
    { .name="ar-tries", .has_arg=1, .flag=((signed int *)NULL), .val=65 },
    { .name="ar-delay", .has_arg=1, .flag=((signed int *)NULL), .val=84 },
    { .name="ar-start", .has_arg=0, .flag=((signed int *)NULL), .val=305 },
    { .name="ar-quit", .has_arg=0, .flag=((signed int *)NULL), .val=306 },
    { .name="noar", .has_arg=0, .flag=((signed int *)NULL), .val=307 },
    { .name="localname", .has_arg=1, .flag=((signed int *)NULL), .val=311 },
    { .name="localport", .has_arg=1, .flag=((signed int *)NULL), .val=312 },
    { .name="localdesname", .has_arg=1, .flag=((signed int *)NULL), .val=313 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// maincond
// file thread_management.c line 29
static union anonymous$24 maincond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// mainmutex
// file thread_management.c line 28
static union anonymous$22 mainmutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// mainthread
// file thread_management.c line 27
static unsigned long int mainthread;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// verlev
// file logging.c line 31
static char verlev;

// ArOptions_evaluate_values
// file ar_options_struct.h line 57
void ArOptions_evaluate_values(struct anonymous$3 *ao)
{
  if(!(ao == ((struct anonymous$3 *)NULL)))
  {
    if(!(ao->artries == ((char *)NULL)))
      ao->tries=check_value_liberal(ao->artries, "Invalid ar-tries value");

    if(!(ao->ardelay == ((char *)NULL)))
      ao->delay=check_value(ao->ardelay, "Invalid ar-delay value");

  }

}

// ArOptions_free
// file ar_options_struct.h line 41
void ArOptions_free(struct anonymous$3 **ao)
{
  if(!(ao == ((struct anonymous$3 **)NULL)))
  {
    if(!(*ao == ((struct anonymous$3 *)NULL)))
    {
      if(!((*ao)->artries == ((char *)NULL)))
      {
        free((void *)(*ao)->artries);
        (*ao)->artries = (char *)(void *)0;
      }

      if(!((*ao)->ardelay == ((char *)NULL)))
      {
        free((void *)(*ao)->ardelay);
        (*ao)->ardelay = (char *)(void *)0;
      }

      free((void *)*ao);
      *ao = (struct anonymous$3 *)(void *)0;
    }

  }

}

// ArOptions_get_arDelay
// file ar_options_struct.h line 52
signed int ArOptions_get_arDelay(struct anonymous$3 *ao)
{
  if(ao == ((struct anonymous$3 *)NULL))
    return 0;

  else
    return ao->delay;
}

// ArOptions_get_arPremature
// file ar_options_struct.h line 55
char ArOptions_get_arPremature(struct anonymous$3 *ao)
{
  if(ao == ((struct anonymous$3 *)NULL))
    return (char)0;

  else
    return ao->premature;
}

// ArOptions_get_arQuit
// file ar_options_struct.h line 54
char ArOptions_get_arQuit(struct anonymous$3 *ao)
{
  if(ao == ((struct anonymous$3 *)NULL))
    return (char)0;

  else
    return ao->quit;
}

// ArOptions_get_arStart
// file ar_options_struct.h line 53
char ArOptions_get_arStart(struct anonymous$3 *ao)
{
  if(ao == ((struct anonymous$3 *)NULL))
    return (char)0;

  else
    return ao->start;
}

// ArOptions_get_arTries
// file ar_options_struct.h line 51
signed int ArOptions_get_arTries(struct anonymous$3 *ao)
{
  if(ao == ((struct anonymous$3 *)NULL))
    return 0;

  else
    return ao->tries;
}

// ArOptions_new
// file ar_options_struct.h line 39
struct anonymous$3 * ArOptions_new()
{
  struct anonymous$3 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$3) /*32ul*/ );
  tmp = (struct anonymous$3 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$3 *)NULL))
    return (struct anonymous$3 *)(void *)0;

  else
  {
    tmp->premature = (char)1;
    tmp->delay = 5;
    tmp->tries = -1;
    return tmp;
  }
}

// ArOptions_set_arDelay
// file ar_options_struct.c line 126
void ArOptions_set_arDelay(struct anonymous$3 *ao, signed int delay)
{
  if(!(ao == ((struct anonymous$3 *)NULL)))
    ao->delay = delay;

}

// ArOptions_set_arPremature
// file ar_options_struct.h line 49
void ArOptions_set_arPremature(struct anonymous$3 *ao, char premature)
{
  if(!(ao == ((struct anonymous$3 *)NULL)))
    ao->premature = premature;

}

// ArOptions_set_arQuit
// file ar_options_struct.h line 48
void ArOptions_set_arQuit(struct anonymous$3 *ao, char quit)
{
  if(!(ao == ((struct anonymous$3 *)NULL)))
    ao->quit = quit;

}

// ArOptions_set_arStart
// file ar_options_struct.h line 47
void ArOptions_set_arStart(struct anonymous$3 *ao, char start)
{
  if(!(ao == ((struct anonymous$3 *)NULL)))
    ao->start = start;

}

// ArOptions_set_arTries
// file ar_options_struct.c line 91
void ArOptions_set_arTries(struct anonymous$3 *ao, signed int tries)
{
  if(!(ao == ((struct anonymous$3 *)NULL)))
    ao->tries = tries;

}

// ArOptions_set_s_arDelay
// file ar_options_struct.h line 46
void ArOptions_set_s_arDelay(struct anonymous$3 *ao, char *delay)
{
  if(!(ao == ((struct anonymous$3 *)NULL)))
    string_cp(&ao->ardelay, delay);

}

// ArOptions_set_s_arTries
// file ar_options_struct.h line 44
void ArOptions_set_s_arTries(struct anonymous$3 *ao, char *tries)
{
  if(!(ao == ((struct anonymous$3 *)NULL)))
    string_cp(&ao->artries, tries);

}

// AuditListNode_free
// file audit_list_node_struct.c line 81
void AuditListNode_free(struct alnode **aln)
{
  if(!(aln == ((struct alnode **)NULL)))
  {
    if(!(*aln == ((struct alnode *)NULL)))
    {
      free((void *)*aln);
      *aln = (struct alnode *)(void *)0;
    }

  }

}

// AuditListNode_get_connectTime
// file audit_list_node_struct.c line 258
signed long int AuditListNode_get_connectTime(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (signed long int)0;

  else
    return aln->connectTime;
}

// AuditListNode_get_connectTimep
// file audit_list_node_struct.c line 309
signed long int * AuditListNode_get_connectTimep(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return ((signed long int *)NULL);

  else
    return &aln->connectTime;
}

// AuditListNode_get_duration
// file audit_list_node_struct.c line 275
signed long int AuditListNode_get_duration(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (signed long int)0;

  else
    return aln->duration;
}

// AuditListNode_get_nameBuf
// file audit_list_node_struct.c line 224
char * AuditListNode_get_nameBuf(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (char *)(void *)0;

  else
    return aln->nameBuf;
}

// AuditListNode_get_nextNode
// file audit_list_node_struct.c line 292
struct alnode * AuditListNode_get_nextNode(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (struct alnode *)(void *)0;

  else
    return aln->nextNode;
}

// AuditListNode_get_portBuf
// file audit_list_node_struct.c line 241
char * AuditListNode_get_portBuf(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (char *)(void *)0;

  else
    return aln->portBuf;
}

// AuditListNode_get_userId
// file audit_list_node_struct.c line 207
signed int AuditListNode_get_userId(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return -1;

  else
    return aln->userId;
}

// AuditListNode_new
// file audit_list_node_struct.c line 36
struct alnode * AuditListNode_new()
{
  struct alnode *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct alnode) /*168ul*/ );
  tmp = (struct alnode *)return_value_calloc$1;
  if(tmp == ((struct alnode *)NULL))
    return (struct alnode *)(void *)0;

  else
    return tmp;
}

// AuditListNode_new_entry
// file audit_list_node_struct.c line 58
struct alnode * AuditListNode_new_entry(signed int userId, char *nameBuf, char *portBuf, signed long int connectTime, signed long int duration)
{
  struct alnode *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct alnode) /*168ul*/ );
  tmp = (struct alnode *)return_value_calloc$1;
  if(tmp == ((struct alnode *)NULL))
    return (struct alnode *)(void *)0;

  else
  {
    AuditListNode_set_userId(tmp, userId);
    AuditListNode_set_nameBuf(tmp, nameBuf);
    AuditListNode_set_portBuf(tmp, portBuf);
    AuditListNode_set_connectTime(tmp, connectTime);
    AuditListNode_set_duration(tmp, duration);
    return tmp;
  }
}

// AuditListNode_set_connectTime
// file audit_list_node_struct.c line 156
void AuditListNode_set_connectTime(struct alnode *aln, signed long int connectTime)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->connectTime = connectTime;

}

// AuditListNode_set_duration
// file audit_list_node_struct.c line 173
void AuditListNode_set_duration(struct alnode *aln, signed long int duration)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->duration = duration;

}

// AuditListNode_set_nameBuf
// file audit_list_node_struct.c line 120
void AuditListNode_set_nameBuf(struct alnode *aln, char *nameBuf)
{
  if(!(aln == ((struct alnode *)NULL)))
  {
    memset((void *)aln->nameBuf, 0, (unsigned long int)7);
    __builtin_strncpy(aln->nameBuf, nameBuf, (unsigned long int)6);
  }

}

// AuditListNode_set_nextNode
// file audit_list_node_struct.c line 190
void AuditListNode_set_nextNode(struct alnode *aln, struct alnode *nextNode)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->nextNode = nextNode;

}

// AuditListNode_set_portBuf
// file audit_list_node_struct.c line 138
void AuditListNode_set_portBuf(struct alnode *aln, char *portBuf)
{
  if(!(aln == ((struct alnode *)NULL)))
  {
    memset((void *)aln->portBuf, 0, (unsigned long int)7);
    __builtin_strncpy(aln->portBuf, portBuf, (unsigned long int)6);
  }

}

// AuditListNode_set_userId
// file audit_list_node_struct.c line 103
void AuditListNode_set_userId(struct alnode *aln, signed int userId)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->userId = userId;

}

// AuditList_clear
// file audit_list_struct.c line 143
void AuditList_clear(struct auditlist *al)
{
  struct alnode *return_value_AuditList_get_first$1;
  if(!(al == ((struct auditlist *)NULL)))
    do
    {
      return_value_AuditList_get_first$1=AuditList_get_first(al);
      if(return_value_AuditList_get_first$1 == ((struct alnode *)NULL))
        break;

      AuditList_delete_first(al);
    }
    while((_Bool)1);

}

// AuditList_delete_first
// file audit_list_struct.c line 120
void AuditList_delete_first(struct auditlist *al)
{
  struct alnode *tmp;
  tmp=AuditList_get_first(al);
  if(!(tmp == ((struct alnode *)NULL)))
  {
    if(tmp == al->tail)
    {
      al->tail = (struct alnode *)(void *)0;
      al->head = al->tail;
    }

    else
      al->head=AuditListNode_get_nextNode(tmp);
    AuditListNode_free(&tmp);
  }

}

// AuditList_free
// file audit_list_struct.c line 53
void AuditList_free(struct auditlist **al)
{
  if(!(al == ((struct auditlist **)NULL)))
  {
    if(!(*al == ((struct auditlist *)NULL)))
    {
      AuditList_clear(*al);
      free((void *)*al);
      *al = (struct auditlist *)(void *)0;
    }

  }

}

// AuditList_get_first
// file audit_list_struct.c line 104
struct alnode * AuditList_get_first(struct auditlist *al)
{
  if(al == ((struct auditlist *)NULL))
    return (struct alnode *)(void *)0;

  else
    return al->head;
}

// AuditList_insert_back
// file audit_list_struct.c line 76
void AuditList_insert_back(struct auditlist *al, struct alnode *aln)
{
  if(!(al == ((struct auditlist *)NULL)))
  {
    if(!(aln == ((struct alnode *)NULL)))
    {
      if(!(al->tail == ((struct alnode *)NULL)))
        al->tail->nextNode = aln;

      else
        al->head = aln;
      al->tail = aln;
      aln->nextNode = (struct alnode *)(void *)0;
    }

  }

}

// AuditList_new
// file audit_list_struct.c line 36
struct auditlist * AuditList_new()
{
  struct auditlist *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct auditlist) /*16ul*/ );
  tmp = (struct auditlist *)return_value_calloc$1;
  if(tmp == ((struct auditlist *)NULL))
    return (struct auditlist *)(void *)0;

  else
    return tmp;
}

// BufListNode_free
// file buf_list_node_struct.c line 76
void BufListNode_free(struct blnode **bln)
{
  if(!(bln == ((struct blnode **)NULL)))
  {
    if(!(*bln == ((struct blnode *)NULL)))
    {
      if(!((*bln)->message == ((unsigned char *)NULL)))
      {
        free((void *)(*bln)->message);
        (*bln)->message = (unsigned char *)(void *)0;
      }

      free((void *)*bln);
      *bln = (struct blnode *)(void *)0;
    }

  }

}

// BufListNode_get_actPtr
// file buf_list_node_struct.h line 42
signed int BufListNode_get_actPtr(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return -1;

  else
    return bln->actPtr;
}

// BufListNode_get_message
// file buf_list_node_struct.c line 221
unsigned char * BufListNode_get_message(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return (unsigned char *)(void *)0;

  else
    return bln->message;
}

// BufListNode_get_msgLen
// file buf_list_node_struct.c line 204
signed int BufListNode_get_msgLen(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return -1;

  else
    return bln->msgLen;
}

// BufListNode_get_nextNode
// file buf_list_node_struct.c line 238
struct blnode * BufListNode_get_nextNode(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return (struct blnode *)(void *)0;

  else
    return bln->nextNode;
}

// BufListNode_new
// file buf_list_node_struct.c line 36
struct blnode * BufListNode_new()
{
  struct blnode *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct blnode) /*24ul*/ );
  tmp = (struct blnode *)return_value_calloc$1;
  if(tmp == ((struct blnode *)NULL))
    return (struct blnode *)(void *)0;

  else
    return tmp;
}

// BufListNode_new_message
// file buf_list_node_struct.h line 33
struct blnode * BufListNode_new_message(signed int actPtr, signed int msgLen, unsigned char *message)
{
  struct blnode *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct blnode) /*24ul*/ );
  tmp = (struct blnode *)return_value_calloc$1;
  if(tmp == ((struct blnode *)NULL))
    return (struct blnode *)(void *)0;

  else
  {
    BufListNode_set_message(tmp, message, msgLen);
    BufListNode_set_actPtr(tmp, actPtr);
    return tmp;
  }
}

// BufListNode_readMessage
// file buf_list_node_struct.h line 47
unsigned char * BufListNode_readMessage(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    signed int return_value_BufListNode_get_actPtr$1;
    return_value_BufListNode_get_actPtr$1=BufListNode_get_actPtr(bln);
    return &bln->message[(signed long int)return_value_BufListNode_get_actPtr$1];
  }
}

// BufListNode_readMessageLength
// file buf_list_node_struct.h line 48
signed int BufListNode_readMessageLength(struct blnode *bln)
{
  signed int tmp = 0;
  if(bln == ((struct blnode *)NULL))
    return -1;

  else
  {
    unsigned char *return_value_BufListNode_get_message$1;
    return_value_BufListNode_get_message$1=BufListNode_get_message(bln);
    if(return_value_BufListNode_get_message$1 == ((unsigned char *)NULL))
      return -1;

    else
    {
      signed int return_value_BufListNode_get_msgLen$2;
      return_value_BufListNode_get_msgLen$2=BufListNode_get_msgLen(bln);
      signed int return_value_BufListNode_get_actPtr$3;
      return_value_BufListNode_get_actPtr$3=BufListNode_get_actPtr(bln);
      tmp = return_value_BufListNode_get_msgLen$2 - return_value_BufListNode_get_actPtr$3;
      if(!(tmp >= 0))
        return 0;

      else
        return tmp;
    }
  }
}

// BufListNode_set_actPtr
// file buf_list_node_struct.h line 37
void BufListNode_set_actPtr(struct blnode *bln, signed int actPtr)
{
  if(!(bln == ((struct blnode *)NULL)))
    bln->actPtr = actPtr;

}

// BufListNode_set_message
// file buf_list_node_struct.c line 137
void BufListNode_set_message(struct blnode *bln, unsigned char *message, signed int msgLen)
{
  if(!(bln == ((struct blnode *)NULL)))
  {
    if(!(bln->message == ((unsigned char *)NULL)))
    {
      free((void *)bln->message);
      bln->message = (unsigned char *)(void *)0;
    }

    BufListNode_set_actPtr(bln, 0);
    BufListNode_set_msgLen(bln, 0);
    if(!(message == ((unsigned char *)NULL)))
    {
      void *return_value_calloc$1;
      return_value_calloc$1=calloc((unsigned long int)1, (unsigned long int)msgLen);
      bln->message = (unsigned char *)return_value_calloc$1;
      if(!(bln->message == ((unsigned char *)NULL)))
      {
        memcpy((void *)bln->message, (const void *)message, (unsigned long int)msgLen);
        BufListNode_set_msgLen(bln, msgLen);
      }

    }

  }

}

// BufListNode_set_msgLen
// file buf_list_node_struct.c line 119
void BufListNode_set_msgLen(struct blnode *bln, signed int msgLen)
{
  if(!(bln == ((struct blnode *)NULL)))
    bln->msgLen = msgLen;

}

// BufListNode_set_nextNode
// file buf_list_node_struct.c line 170
void BufListNode_set_nextNode(struct blnode *bln, struct blnode *nextNode)
{
  if(!(bln == ((struct blnode *)NULL)))
    bln->nextNode = nextNode;

}

// BufList_clear
// file buf_list_struct.h line 39
void BufList_clear(struct buflist *bl)
{
  struct blnode *return_value_BufList_get_first$1;
  if(!(bl == ((struct buflist *)NULL)))
    do
    {
      return_value_BufList_get_first$1=BufList_get_first(bl);
      if(return_value_BufList_get_first$1 == ((struct blnode *)NULL))
        break;

      BufList_delete_first(bl);
    }
    while((_Bool)1);

}

// BufList_delete_first
// file buf_list_struct.h line 38
void BufList_delete_first(struct buflist *bl)
{
  struct blnode *tmp;
  tmp=BufList_get_first(bl);
  if(!(tmp == ((struct blnode *)NULL)))
  {
    if(tmp == bl->tail)
    {
      bl->tail = (struct blnode *)(void *)0;
      bl->head = bl->tail;
    }

    else
      bl->head=BufListNode_get_nextNode(tmp);
    BufListNode_free(&tmp);
  }

}

// BufList_free
// file buf_list_struct.c line 53
void BufList_free(struct buflist **bl)
{
  if(!(bl == ((struct buflist **)NULL)))
  {
    if(!(*bl == ((struct buflist *)NULL)))
    {
      BufList_clear(*bl);
      free((void *)*bl);
      *bl = (struct buflist *)(void *)0;
    }

  }

}

// BufList_get_first
// file buf_list_struct.h line 37
struct blnode * BufList_get_first(struct buflist *bl)
{
  if(bl == ((struct buflist *)NULL))
    return (struct blnode *)(void *)0;

  else
    return bl->head;
}

// BufList_insert_back
// file buf_list_struct.h line 36
void BufList_insert_back(struct buflist *bl, struct blnode *bln)
{
  if(!(bl == ((struct buflist *)NULL)))
  {
    if(!(bln == ((struct blnode *)NULL)))
    {
      if(!(bl->tail == ((struct blnode *)NULL)))
        bl->tail->nextNode = bln;

      else
        bl->head = bln;
      bl->tail = bln;
      bln->nextNode = (struct blnode *)(void *)0;
    }

  }

}

// BufList_new
// file buf_list_struct.c line 36
struct buflist * BufList_new()
{
  struct buflist *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct buflist) /*16ul*/ );
  tmp = (struct buflist *)return_value_calloc$1;
  if(tmp == ((struct buflist *)NULL))
    return (struct buflist *)(void *)0;

  else
    return tmp;
}

// ClientConfiguration_free
// file client_configuration_struct.c line 54
void ClientConfiguration_free(struct anonymous$4 **cc)
{
  signed int i;
  if(!(cc == ((struct anonymous$4 **)NULL)))
  {
    if(!(*cc == ((struct anonymous$4 *)NULL)))
    {
      if(!((*cc)->keysFile == ((char *)NULL)))
      {
        free((void *)(*cc)->keysFile);
        (*cc)->keysFile = (char *)(void *)0;
      }

      if(!((*cc)->certificateFile == ((char *)NULL)))
      {
        free((void *)(*cc)->certificateFile);
        (*cc)->certificateFile = (char *)(void *)0;
      }

      if(!((*cc)->storeFile == ((char *)NULL)))
      {
        free((void *)(*cc)->storeFile);
        (*cc)->storeFile = (char *)(void *)0;
      }

      if(!((*cc)->realmsTable == ((struct anonymous$5 **)NULL)))
      {
        i = 0;
        for( ; !(i >= (*cc)->realmsNumber); i = i + 1)
          if(!((*cc)->realmsTable[(signed long int)i] == ((struct anonymous$5 *)NULL)))
            ClientRealm_free(&(*cc)->realmsTable[(signed long int)i]);

        free((void *)(*cc)->realmsTable);
        (*cc)->realmsTable = (struct anonymous$5 **)(void *)0;
      }

      free((void *)*cc);
      *cc = (struct anonymous$4 *)(void *)0;
    }

  }

}

// ClientConfiguration_get_certificateFile
// file client_configuration_struct.h line 51
char * ClientConfiguration_get_certificateFile(struct anonymous$4 *cc)
{
  if(cc == ((struct anonymous$4 *)NULL))
    return (char *)(void *)0;

  else
    return cc->certificateFile;
}

// ClientConfiguration_get_dateFormat
// file client_configuration_struct.h line 53
char * ClientConfiguration_get_dateFormat(struct anonymous$4 *cc)
{
  if(cc == ((struct anonymous$4 *)NULL))
    return (char *)(void *)0;

  else
    return cc->dateFormat;
}

// ClientConfiguration_get_ignorePublicKeys
// file client_configuration_struct.h line 56
char ClientConfiguration_get_ignorePublicKeys(struct anonymous$4 *cc)
{
  if(cc == ((struct anonymous$4 *)NULL))
    return (char)0;

  else
    return cc->ignorePublicKeys;
}

// ClientConfiguration_get_keysFile
// file client_configuration_struct.h line 50
char * ClientConfiguration_get_keysFile(struct anonymous$4 *cc)
{
  if(cc == ((struct anonymous$4 *)NULL))
    return (char *)(void *)0;

  else
    return cc->keysFile;
}

// ClientConfiguration_get_realmsNumber
// file client_configuration_struct.h line 54
signed int ClientConfiguration_get_realmsNumber(struct anonymous$4 *cc)
{
  if(cc == ((struct anonymous$4 *)NULL))
    return -1;

  else
    return cc->realmsNumber;
}

// ClientConfiguration_get_realmsTable
// file client_configuration_struct.h line 55
struct anonymous$5 ** ClientConfiguration_get_realmsTable(struct anonymous$4 *cc)
{
  if(cc == ((struct anonymous$4 *)NULL))
    return (struct anonymous$5 **)(void *)0;

  else
    return cc->realmsTable;
}

// ClientConfiguration_get_storeFile
// file client_configuration_struct.h line 52
char * ClientConfiguration_get_storeFile(struct anonymous$4 *cc)
{
  if(cc == ((struct anonymous$4 *)NULL))
    return (char *)(void *)0;

  else
    return cc->storeFile;
}

// ClientConfiguration_new
// file client_configuration_struct.h line 38
struct anonymous$4 * ClientConfiguration_new()
{
  struct anonymous$4 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$4) /*48ul*/ );
  tmp = (struct anonymous$4 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$4 *)NULL))
    return (struct anonymous$4 *)(void *)0;

  else
    return tmp;
}

// ClientConfiguration_set_certificateFile
// file client_configuration_struct.h line 43
void ClientConfiguration_set_certificateFile(struct anonymous$4 *cc, char *certificateFile)
{
  if(!(cc == ((struct anonymous$4 *)NULL)))
    string_cp(&cc->certificateFile, certificateFile);

}

// ClientConfiguration_set_dateFormat
// file client_configuration_struct.h line 45
void ClientConfiguration_set_dateFormat(struct anonymous$4 *cc, char *dateFormat)
{
  if(!(cc == ((struct anonymous$4 *)NULL)))
    string_cp(&cc->dateFormat, dateFormat);

}

// ClientConfiguration_set_ignorePublicKeys
// file client_configuration_struct.h line 48
void ClientConfiguration_set_ignorePublicKeys(struct anonymous$4 *cc, char ignorePublicKeys)
{
  if(!(cc == ((struct anonymous$4 *)NULL)))
    cc->ignorePublicKeys = ignorePublicKeys;

}

// ClientConfiguration_set_keysFile
// file client_configuration_struct.h line 42
void ClientConfiguration_set_keysFile(struct anonymous$4 *cc, char *keysFile)
{
  if(!(cc == ((struct anonymous$4 *)NULL)))
    string_cp(&cc->keysFile, keysFile);

}

// ClientConfiguration_set_realmsNumber
// file client_configuration_struct.h line 46
void ClientConfiguration_set_realmsNumber(struct anonymous$4 *cc, signed int realmsNumber)
{
  if(!(cc == ((struct anonymous$4 *)NULL)))
    cc->realmsNumber = realmsNumber;

}

// ClientConfiguration_set_realmsTable
// file client_configuration_struct.h line 47
void ClientConfiguration_set_realmsTable(struct anonymous$4 *cc, struct anonymous$5 **realmsTable)
{
  signed int i;
  if(!(cc == ((struct anonymous$4 *)NULL)))
  {
    if(!(cc->realmsTable == ((struct anonymous$5 **)NULL)))
    {
      i = 0;
      for( ; !(i >= cc->realmsNumber); i = i + 1)
        if(!(cc->realmsTable[(signed long int)i] == ((struct anonymous$5 *)NULL)))
          ClientRealm_free(&cc->realmsTable[(signed long int)i]);

      free((void *)cc->realmsTable);
      cc->realmsTable = (struct anonymous$5 **)(void *)0;
    }

    cc->realmsTable = realmsTable;
  }

}

// ClientConfiguration_set_storeFile
// file client_configuration_struct.h line 44
void ClientConfiguration_set_storeFile(struct anonymous$4 *cc, char *storeFile)
{
  if(!(cc == ((struct anonymous$4 *)NULL)))
    string_cp(&cc->storeFile, storeFile);

}

// ClientRealm_closeUsersConnections
// file client_realm_struct.h line 141
void ClientRealm_closeUsersConnections(struct anonymous$5 *cr)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    signed int return_value_ClientRealm_get_usersLimit$1;
    return_value_ClientRealm_get_usersLimit$1=ClientRealm_get_usersLimit(cr);
    close_connections(return_value_ClientRealm_get_usersLimit$1, &cr->usersTable);
  }

}

// ClientRealm_decrease_connectedUsers
// file client_realm_struct.c line 1106
void ClientRealm_decrease_connectedUsers(struct anonymous$5 *cr)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    signed int return_value_ClientRealm_get_connectedUsers$1;
    return_value_ClientRealm_get_connectedUsers$1=ClientRealm_get_connectedUsers(cr);
    ClientRealm_set_connectedUsers(cr, return_value_ClientRealm_get_connectedUsers$1 - 1);
  }

}

// ClientRealm_enable_multi
// file client_realm_struct.h line 144
void ClientRealm_enable_multi(struct anonymous$5 *cr)
{
  unsigned char buff[5l];
  struct portlist *return_value_ClientRealm_get_destinationPorts$5;
  signed int return_value_PortList_get_size$6;
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    char return_value_ClientRealm_get_realmType$7;
    return_value_ClientRealm_get_realmType$7=ClientRealm_get_realmType(cr);
    if(!((64 & (signed int)return_value_ClientRealm_get_realmType$7) == 0))
    {
      return_value_ClientRealm_get_destinationPorts$5=ClientRealm_get_destinationPorts(cr);
      return_value_PortList_get_size$6=PortList_get_size(return_value_ClientRealm_get_destinationPorts$5);
      if(return_value_PortList_get_size$6 >= 2)
      {
        buff[(signed long int)0] = (unsigned char)18;
        struct portlist *return_value_ClientRealm_get_destinationPorts$1;
        return_value_ClientRealm_get_destinationPorts$1=ClientRealm_get_destinationPorts(cr);
        signed int return_value_PortList_get_size$2;
        return_value_PortList_get_size$2=PortList_get_size(return_value_ClientRealm_get_destinationPorts$1);
        buff[(signed long int)1] = (unsigned char)return_value_PortList_get_size$2;
        buff[(signed long int)4] = (unsigned char)0;
        buff[(signed long int)3] = buff[(signed long int)4];
        buff[(signed long int)2] = buff[(signed long int)3];
        char return_value_ClientRealm_get_realmType$3;
        return_value_ClientRealm_get_realmType$3=ClientRealm_get_realmType(cr);
        struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$4;
        return_value_ClientRealm_get_masterSslFd$4=ClientRealm_get_masterSslFd(cr);
        SslFd_send_message(return_value_ClientRealm_get_realmType$3, return_value_ClientRealm_get_masterSslFd$4, buff, 5);
        aflog((char)2, (char)8, "ENABLED: MULTI (multiple tunnels managed by one afclient)");
      }

    }

  }

}

// ClientRealm_free
// file client_realm_struct.h line 77
void ClientRealm_free(struct anonymous$5 **cr)
{
  if(!(cr == ((struct anonymous$5 **)NULL)))
  {
    if(!(*cr == ((struct anonymous$5 *)NULL)))
    {
      ClientRealm_set_serverName(*cr, (char *)(void *)0);
      ClientRealm_set_managePort(*cr, (char *)(void *)0);
      ClientRealm_set_hostName(*cr, (char *)(void *)0);
      ClientRealm_set_realmName(*cr, (char *)(void *)0);
      ClientRealm_set_sKeepAliveTimeout(*cr, (char *)(void *)0);
      ClientRealm_set_realmId(*cr, (char *)(void *)0);
      ClientRealm_set_localName(*cr, (char *)(void *)0);
      ClientRealm_set_localPort(*cr, (char *)(void *)0);
      ClientRealm_set_localDestinationName(*cr, (char *)(void *)0);
      ClientRealm_set_clientAddress(*cr, (struct sockaddr *)(void *)0);
      ClientRealm_set_masterSslFd(*cr, (struct anonymous$0 *)(void *)0);
      ClientRealm_set_httpProxyOptions(*cr, (struct anonymous *)(void *)0);
      ClientRealm_set_arOptions(*cr, (struct anonymous$3 *)(void *)0);
      ClientRealm_set_destinationPorts(*cr, (struct portlist *)(void *)0);
      ClientRealm_set_usersTable(*cr, (struct anonymous$7 **)(void *)0);
      ClientRealm_set_userModule(*cr, (struct anonymous$6 *)(void *)0);
      ClientRealm_set_serviceModule(*cr, (struct anonymous$6 *)(void *)0);
      free((void *)*cr);
      *cr = (struct anonymous$5 *)(void *)0;
    }

  }

}

// ClientRealm_get_addressLength
// file client_realm_struct.c line 953
unsigned int ClientRealm_get_addressLength(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (unsigned int)0;

  else
    return cr->addressLength;
}

// ClientRealm_get_arOptions
// file client_realm_struct.h line 131
struct anonymous$3 * ClientRealm_get_arOptions(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (struct anonymous$3 *)(void *)0;

  else
    return cr->arOptions;
}

// ClientRealm_get_clientAddress
// file client_realm_struct.h line 128
struct sockaddr * ClientRealm_get_clientAddress(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (struct sockaddr *)(void *)0;

  else
    return cr->clientAddress;
}

// ClientRealm_get_clientMode
// file client_realm_struct.h line 122
signed int ClientRealm_get_clientMode(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return 0;

  else
    return cr->clientMode;
}

// ClientRealm_get_connectedUsers
// file client_realm_struct.c line 816
signed int ClientRealm_get_connectedUsers(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return -1;

  else
    return cr->connectedUsers;
}

// ClientRealm_get_destinationPorts
// file client_realm_struct.h line 132
struct portlist * ClientRealm_get_destinationPorts(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (struct portlist *)(void *)0;

  else
    return cr->destinationPorts;
}

// ClientRealm_get_hostName
// file client_realm_struct.h line 111
char * ClientRealm_get_hostName(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->hostName;
}

// ClientRealm_get_httpProxyOptions
// file client_realm_struct.h line 130
struct anonymous * ClientRealm_get_httpProxyOptions(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (struct anonymous *)(void *)0;

  else
    return cr->httpProxyOptions;
}

// ClientRealm_get_ipFamily
// file client_realm_struct.h line 123
char ClientRealm_get_ipFamily(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (char)0;

  else
    return cr->ipFamily;
}

// ClientRealm_get_keepAlive
// file client_realm_struct.c line 935
struct timeval ClientRealm_get_keepAlive(struct anonymous$5 *cr)
{
  struct timeval tmp = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
  if(cr == ((struct anonymous$5 *)NULL))
    return tmp;

  else
    return cr->keepAlive;
}

// ClientRealm_get_keepAlivePointer
// file client_realm_struct.h line 142
struct timeval * ClientRealm_get_keepAlivePointer(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (struct timeval *)(void *)0;

  else
    return &cr->keepAlive;
}

// ClientRealm_get_keepAliveTimeout
// file client_realm_struct.h line 121
signed int ClientRealm_get_keepAliveTimeout(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return 0;

  else
    return cr->keepAliveTimeout;
}

// ClientRealm_get_localDestinationName
// file client_realm_struct.h line 117
char * ClientRealm_get_localDestinationName(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->localDestinationName;
}

// ClientRealm_get_localName
// file client_realm_struct.h line 115
char * ClientRealm_get_localName(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->localName;
}

// ClientRealm_get_localPort
// file client_realm_struct.h line 116
char * ClientRealm_get_localPort(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->localPort;
}

// ClientRealm_get_managePort
// file client_realm_struct.h line 110
char * ClientRealm_get_managePort(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->managePort;
}

// ClientRealm_get_masterSslFd
// file client_realm_struct.h line 129
struct anonymous$0 * ClientRealm_get_masterSslFd(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (struct anonymous$0 *)(void *)0;

  else
    return cr->masterSslFd;
}

// ClientRealm_get_password
// file client_realm_struct.h line 118
unsigned char * ClientRealm_get_password(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (unsigned char *)(void *)0;

  else
    return cr->password;
}

// ClientRealm_get_realmId
// file client_realm_struct.h line 114
char * ClientRealm_get_realmId(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->realmId;
}

// ClientRealm_get_realmName
// file client_realm_struct.c line 711
char * ClientRealm_get_realmName(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->realmName;
}

// ClientRealm_get_realmType
// file client_realm_struct.h line 124
char ClientRealm_get_realmType(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (char)0;

  else
    return cr->realmType;
}

// ClientRealm_get_sKeepAliveTimeout
// file client_realm_struct.h line 113
char * ClientRealm_get_sKeepAliveTimeout(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->sKeepAliveTimeout;
}

// ClientRealm_get_serverName
// file client_realm_struct.h line 109
char * ClientRealm_get_serverName(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return cr->serverName;
}

// ClientRealm_get_serviceModule
// file client_realm_struct.h line 136
struct anonymous$6 * ClientRealm_get_serviceModule(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (struct anonymous$6 *)(void *)0;

  else
    return cr->serviceModule;
}

// ClientRealm_get_tunnelType
// file client_realm_struct.h line 125
char ClientRealm_get_tunnelType(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (char)0;

  else
    return cr->tunnelType;
}

// ClientRealm_get_userModule
// file client_realm_struct.h line 135
struct anonymous$6 * ClientRealm_get_userModule(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (struct anonymous$6 *)(void *)0;

  else
    return cr->userModule;
}

// ClientRealm_get_usersLimit
// file client_realm_struct.h line 120
signed int ClientRealm_get_usersLimit(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return -1;

  else
    return cr->usersLimit;
}

// ClientRealm_get_usersTable
// file client_realm_struct.h line 133
struct anonymous$7 ** ClientRealm_get_usersTable(struct anonymous$5 *cr)
{
  if(cr == ((struct anonymous$5 *)NULL))
    return (struct anonymous$7 **)(void *)0;

  else
    return cr->usersTable;
}

// ClientRealm_increase_connectedUsers
// file client_realm_struct.c line 1090
void ClientRealm_increase_connectedUsers(struct anonymous$5 *cr)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    signed int return_value_ClientRealm_get_connectedUsers$1;
    return_value_ClientRealm_get_connectedUsers$1=ClientRealm_get_connectedUsers(cr);
    ClientRealm_set_connectedUsers(cr, return_value_ClientRealm_get_connectedUsers$1 + 1);
  }

}

// ClientRealm_new
// file client_realm_struct.h line 75
struct anonymous$5 * ClientRealm_new()
{
  struct anonymous$5 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$5) /*184ul*/ );
  tmp = (struct anonymous$5 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$5 *)NULL))
    return (struct anonymous$5 *)(void *)0;

  else
  {
    tmp->password[(signed long int)0] = (unsigned char)1;
    tmp->password[(signed long int)1] = (unsigned char)2;
    tmp->password[(signed long int)2] = (unsigned char)3;
    tmp->password[(signed long int)3] = (unsigned char)4;
    tmp->masterSslFd=SslFd_new();
    if(tmp->masterSslFd == ((struct anonymous$0 *)NULL))
    {
      ClientRealm_free(&tmp);
      return (struct anonymous$5 *)(void *)0;
    }

    else
    {
      tmp->arOptions=ArOptions_new();
      if(tmp->arOptions == ((struct anonymous$3 *)NULL))
      {
        ClientRealm_free(&tmp);
        return (struct anonymous$5 *)(void *)0;
      }

      else
      {
        tmp->httpProxyOptions=HttpProxyOptions_new();
        if(tmp->httpProxyOptions == ((struct anonymous *)NULL))
        {
          ClientRealm_free(&tmp);
          return (struct anonymous$5 *)(void *)0;
        }

        else
        {
          tmp->userModule=Module_new();
          if(tmp->userModule == ((struct anonymous$6 *)NULL))
          {
            ClientRealm_free(&tmp);
            return (struct anonymous$5 *)(void *)0;
          }

          else
          {
            tmp->serviceModule=Module_new();
            if(tmp->serviceModule == ((struct anonymous$6 *)NULL))
            {
              ClientRealm_free(&tmp);
              return (struct anonymous$5 *)(void *)0;
            }

            else
              return tmp;
          }
        }
      }
    }
  }
}

// ClientRealm_send_realmId
// file client_realm_struct.h line 143
void ClientRealm_send_realmId(struct anonymous$5 *cr, unsigned char *buff)
{
  signed int n;
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    if(!(buff == ((unsigned char *)NULL)))
    {
      char *return_value_ClientRealm_get_realmId$7;
      return_value_ClientRealm_get_realmId$7=ClientRealm_get_realmId(cr);
      if(!(return_value_ClientRealm_get_realmId$7 == ((char *)NULL)))
      {
        buff[(signed long int)0] = (unsigned char)8;
        buff[(signed long int)2] = (unsigned char)0;
        buff[(signed long int)1] = buff[(signed long int)2];
        char *return_value_ClientRealm_get_realmId$1;
        return_value_ClientRealm_get_realmId$1=ClientRealm_get_realmId(cr);
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(return_value_ClientRealm_get_realmId$1);
        n = (signed int)return_value_strlen$2;
        char *return_value_ClientRealm_get_realmId$3;
        return_value_ClientRealm_get_realmId$3=ClientRealm_get_realmId(cr);
        memcpy((void *)&buff[(signed long int)5], (const void *)return_value_ClientRealm_get_realmId$3, (unsigned long int)n);
        buff[(signed long int)3] = (unsigned char)(n >> 8);
        buff[(signed long int)4] = (unsigned char)n;
        char return_value_ClientRealm_get_realmType$4;
        return_value_ClientRealm_get_realmType$4=ClientRealm_get_realmType(cr);
        struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$5;
        return_value_ClientRealm_get_masterSslFd$5=ClientRealm_get_masterSslFd(cr);
        SslFd_send_message(return_value_ClientRealm_get_realmType$4, return_value_ClientRealm_get_masterSslFd$5, buff, n + 5);
        char *return_value_ClientRealm_get_realmId$6;
        return_value_ClientRealm_get_realmId$6=ClientRealm_get_realmId(cr);
        aflog((char)2, (char)8, "ID SENT: %s", return_value_ClientRealm_get_realmId$6);
      }

    }

  }

}

// ClientRealm_set_addressLength
// file client_realm_struct.h line 97
void ClientRealm_set_addressLength(struct anonymous$5 *cr, unsigned int addressLength)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    cr->addressLength = addressLength;

}

// ClientRealm_set_arOptions
// file client_realm_struct.h line 101
void ClientRealm_set_arOptions(struct anonymous$5 *cr, struct anonymous$3 *arOptions)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    if(!(cr->arOptions == ((struct anonymous$3 *)NULL)))
      ArOptions_free(&cr->arOptions);

    cr->arOptions = arOptions;
  }

}

// ClientRealm_set_clientAddress
// file client_realm_struct.h line 98
void ClientRealm_set_clientAddress(struct anonymous$5 *cr, struct sockaddr *clientAddress)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    if(!(cr->clientAddress == ((struct sockaddr *)NULL)))
    {
      free((void *)cr->clientAddress);
      cr->clientAddress = (struct sockaddr *)(void *)0;
    }

    cr->clientAddress = clientAddress;
  }

}

// ClientRealm_set_clientMode
// file client_realm_struct.h line 92
void ClientRealm_set_clientMode(struct anonymous$5 *cr, signed int clientMode)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    cr->clientMode = clientMode;

}

// ClientRealm_set_connectedUsers
// file client_realm_struct.c line 323
void ClientRealm_set_connectedUsers(struct anonymous$5 *cr, signed int connectedUsers)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    cr->connectedUsers = connectedUsers;

}

// ClientRealm_set_destinationPorts
// file client_realm_struct.h line 102
void ClientRealm_set_destinationPorts(struct anonymous$5 *cr, struct portlist *destinationPorts)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    if(!(cr->destinationPorts == ((struct portlist *)NULL)))
      PortList_free(&cr->destinationPorts);

    cr->destinationPorts = destinationPorts;
  }

}

// ClientRealm_set_hostName
// file client_realm_struct.h line 81
void ClientRealm_set_hostName(struct anonymous$5 *cr, char *hostName)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    string_cp(&cr->hostName, hostName);

}

// ClientRealm_set_httpProxyOptions
// file client_realm_struct.h line 100
void ClientRealm_set_httpProxyOptions(struct anonymous$5 *cr, struct anonymous *httpProxyOptions)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    if(!(cr->httpProxyOptions == ((struct anonymous *)NULL)))
      HttpProxyOptions_free(&cr->httpProxyOptions);

    cr->httpProxyOptions = httpProxyOptions;
  }

}

// ClientRealm_set_ipFamily
// file client_realm_struct.h line 93
void ClientRealm_set_ipFamily(struct anonymous$5 *cr, char ipFamily)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    cr->ipFamily = ipFamily;

}

// ClientRealm_set_keepAlive
// file client_realm_struct.h line 96
void ClientRealm_set_keepAlive(struct anonymous$5 *cr, struct timeval keepAlive)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    cr->keepAlive = keepAlive;

}

// ClientRealm_set_keepAliveTimeout
// file client_realm_struct.h line 91
void ClientRealm_set_keepAliveTimeout(struct anonymous$5 *cr, signed int keepAliveTimeout)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    cr->keepAliveTimeout = keepAliveTimeout;

}

// ClientRealm_set_localDestinationName
// file client_realm_struct.h line 87
void ClientRealm_set_localDestinationName(struct anonymous$5 *cr, char *localDestinationName)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    string_cp(&cr->localDestinationName, localDestinationName);

}

// ClientRealm_set_localName
// file client_realm_struct.h line 85
void ClientRealm_set_localName(struct anonymous$5 *cr, char *localName)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    string_cp(&cr->localName, localName);

}

// ClientRealm_set_localPort
// file client_realm_struct.h line 86
void ClientRealm_set_localPort(struct anonymous$5 *cr, char *localPort)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    string_cp(&cr->localPort, localPort);

}

// ClientRealm_set_managePort
// file client_realm_struct.h line 80
void ClientRealm_set_managePort(struct anonymous$5 *cr, char *managePort)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    string_cp(&cr->managePort, managePort);

}

// ClientRealm_set_masterSslFd
// file client_realm_struct.c line 497
void ClientRealm_set_masterSslFd(struct anonymous$5 *cr, struct anonymous$0 *masterSslFd)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    if(!(cr->masterSslFd == ((struct anonymous$0 *)NULL)))
      SslFd_free(&cr->masterSslFd);

    cr->masterSslFd = masterSslFd;
  }

}

// ClientRealm_set_password
// file client_realm_struct.h line 88
void ClientRealm_set_password(struct anonymous$5 *cr, unsigned char *password)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    memcpy((void *)cr->password, (const void *)password, (unsigned long int)4);

}

// ClientRealm_set_realmId
// file client_realm_struct.h line 84
void ClientRealm_set_realmId(struct anonymous$5 *cr, char *realmId)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    string_cp(&cr->realmId, realmId);

}

// ClientRealm_set_realmName
// file client_realm_struct.c line 221
void ClientRealm_set_realmName(struct anonymous$5 *cr, char *realmName)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    string_cp(&cr->realmName, realmName);

}

// ClientRealm_set_realmType
// file client_realm_struct.h line 94
void ClientRealm_set_realmType(struct anonymous$5 *cr, char realmType)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    cr->realmType = realmType;

}

// ClientRealm_set_sKeepAliveTimeout
// file client_realm_struct.h line 83
void ClientRealm_set_sKeepAliveTimeout(struct anonymous$5 *cr, char *sKeepAliveTimeout)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    string_cp(&cr->sKeepAliveTimeout, sKeepAliveTimeout);

}

// ClientRealm_set_serverName
// file client_realm_struct.h line 79
void ClientRealm_set_serverName(struct anonymous$5 *cr, char *serverName)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    string_cp(&cr->serverName, serverName);

}

// ClientRealm_set_serviceModule
// file client_realm_struct.h line 106
void ClientRealm_set_serviceModule(struct anonymous$5 *cr, struct anonymous$6 *serviceModule)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    if(!(cr->serviceModule == ((struct anonymous$6 *)NULL)))
      Module_free(&cr->serviceModule);

    cr->serviceModule = serviceModule;
  }

}

// ClientRealm_set_tunnelType
// file client_realm_struct.h line 95
void ClientRealm_set_tunnelType(struct anonymous$5 *cr, char tunnelType)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    cr->tunnelType = tunnelType;

}

// ClientRealm_set_userModule
// file client_realm_struct.h line 105
void ClientRealm_set_userModule(struct anonymous$5 *cr, struct anonymous$6 *userModule)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    if(!(cr->userModule == ((struct anonymous$6 *)NULL)))
      Module_free(&cr->userModule);

    cr->userModule = userModule;
  }

}

// ClientRealm_set_usersLimit
// file client_realm_struct.h line 90
void ClientRealm_set_usersLimit(struct anonymous$5 *cr, signed int usersLimit)
{
  if(!(cr == ((struct anonymous$5 *)NULL)))
    cr->usersLimit = usersLimit;

}

// ClientRealm_set_usersTable
// file client_realm_struct.h line 103
void ClientRealm_set_usersTable(struct anonymous$5 *cr, struct anonymous$7 **usersTable)
{
  signed int i;
  if(!(cr == ((struct anonymous$5 *)NULL)))
  {
    if(!(cr->usersTable == ((struct anonymous$7 **)NULL)))
    {
      i = 0;
      for( ; !(i >= cr->usersLimit); i = i + 1)
        if(!(cr->usersTable[(signed long int)i] == ((struct anonymous$7 *)NULL)))
          ConnectUser_free(&cr->usersTable[(signed long int)i]);

      free((void *)cr->usersTable);
      cr->usersTable = (struct anonymous$7 **)(void *)0;
    }

    cr->usersTable = usersTable;
  }

}

// ConnectUser_free
// file connect_user_struct.h line 45
void ConnectUser_free(struct anonymous$7 **cu)
{
  struct buflist *bftmp;
  struct anonymous$14 *ustmp;
  if(!(cu == ((struct anonymous$7 **)NULL)))
  {
    if(!(*cu == ((struct anonymous$7 *)NULL)))
    {
      bftmp=ConnectUser_get_bufList(*cu);
      ustmp=ConnectUser_get_stats(*cu);
      BufList_free(&bftmp);
      UserStats_free(&ustmp);
      free((void *)*cu);
      *cu = (struct anonymous$7 *)(void *)0;
    }

  }

}

// ConnectUser_get_bufList
// file connect_user_struct.h line 64
struct buflist * ConnectUser_get_bufList(struct anonymous$7 *cu)
{
  if(cu == ((struct anonymous$7 *)NULL))
    return (struct buflist *)(void *)0;

  else
    return cu->bufList;
}

// ConnectUser_get_connFd
// file connect_user_struct.h line 58
signed int ConnectUser_get_connFd(struct anonymous$7 *cu)
{
  if(cu == ((struct anonymous$7 *)NULL))
    return -1;

  else
    return cu->connFd;
}

// ConnectUser_get_connectTime
// file connect_user_struct.c line 323
signed long int ConnectUser_get_connectTime(struct anonymous$7 *cu)
{
  if(cu == ((struct anonymous$7 *)NULL))
    return (signed long int)0;

  else
    return cu->connectTime;
}

// ConnectUser_get_nameBuf
// file connect_user_struct.h line 62
char * ConnectUser_get_nameBuf(struct anonymous$7 *cu)
{
  if(cu == ((struct anonymous$7 *)NULL))
    return (char *)(void *)0;

  else
    return cu->nameBuf;
}

// ConnectUser_get_portBuf
// file connect_user_struct.h line 63
char * ConnectUser_get_portBuf(struct anonymous$7 *cu)
{
  if(cu == ((struct anonymous$7 *)NULL))
    return (char *)(void *)0;

  else
    return cu->portBuf;
}

// ConnectUser_get_state
// file connect_user_struct.h line 57
char ConnectUser_get_state(struct anonymous$7 *cu)
{
  if(cu == ((struct anonymous$7 *)NULL))
    return (char)0;

  else
    return cu->state;
}

// ConnectUser_get_stats
// file connect_user_struct.c line 391
struct anonymous$14 * ConnectUser_get_stats(struct anonymous$7 *cu)
{
  if(cu == ((struct anonymous$7 *)NULL))
    return (struct anonymous$14 *)(void *)0;

  else
    return cu->stats;
}

// ConnectUser_get_userId
// file connect_user_struct.c line 306
signed int ConnectUser_get_userId(struct anonymous$7 *cu)
{
  if(cu == ((struct anonymous$7 *)NULL))
    return -1;

  else
    return cu->userId;
}

// ConnectUser_get_whatClient
// file connect_user_struct.c line 289
signed int ConnectUser_get_whatClient(struct anonymous$7 *cu)
{
  if(cu == ((struct anonymous$7 *)NULL))
    return -1;

  else
    return cu->whatClient;
}

// ConnectUser_new
// file connect_user_struct.h line 43
struct anonymous$7 * ConnectUser_new()
{
  struct anonymous$7 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$7) /*176ul*/ );
  tmp = (struct anonymous$7 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$7 *)NULL))
    return (struct anonymous$7 *)(void *)0;

  else
  {
    tmp->bufList=BufList_new();
    if(tmp->bufList == ((struct buflist *)NULL))
    {
      ConnectUser_free(&tmp);
      return (struct anonymous$7 *)(void *)0;
    }

    else
    {
      tmp->stats=UserStats_new();
      if(tmp->stats == ((struct anonymous$14 *)NULL))
      {
        ConnectUser_free(&tmp);
        return (struct anonymous$7 *)(void *)0;
      }

      else
        return tmp;
    }
  }
}

// ConnectUser_set_bufList
// file connect_user_struct.c line 215
void ConnectUser_set_bufList(struct anonymous$7 *cu, struct buflist *bufList)
{
  struct buflist *bftmp;
  if(!(cu == ((struct anonymous$7 *)NULL)))
  {
    bftmp=ConnectUser_get_bufList(cu);
    BufList_free(&bftmp);
    cu->bufList = bufList;
  }

}

// ConnectUser_set_connFd
// file connect_user_struct.h line 48
void ConnectUser_set_connFd(struct anonymous$7 *cu, signed int connFd)
{
  if(!(cu == ((struct anonymous$7 *)NULL)))
    cu->connFd = connFd;

}

// ConnectUser_set_connectTime
// file connect_user_struct.c line 162
void ConnectUser_set_connectTime(struct anonymous$7 *cu, signed long int connectTime)
{
  if(!(cu == ((struct anonymous$7 *)NULL)))
    cu->connectTime = connectTime;

}

// ConnectUser_set_nameBuf
// file connect_user_struct.h line 52
void ConnectUser_set_nameBuf(struct anonymous$7 *cu, char *nameBuf)
{
  if(!(cu == ((struct anonymous$7 *)NULL)))
  {
    memset((void *)cu->nameBuf, 0, (unsigned long int)128);
    __builtin_strncpy(cu->nameBuf, nameBuf, (unsigned long int)127);
  }

}

// ConnectUser_set_portBuf
// file connect_user_struct.h line 53
void ConnectUser_set_portBuf(struct anonymous$7 *cu, char *portBuf)
{
  if(!(cu == ((struct anonymous$7 *)NULL)))
  {
    memset((void *)cu->portBuf, 0, (unsigned long int)7);
    __builtin_strncpy(cu->portBuf, portBuf, (unsigned long int)6);
  }

}

// ConnectUser_set_state
// file connect_user_struct.h line 47
void ConnectUser_set_state(struct anonymous$7 *cu, char state)
{
  if(!(cu == ((struct anonymous$7 *)NULL)))
    cu->state = state;

}

// ConnectUser_set_stats
// file connect_user_struct.c line 235
void ConnectUser_set_stats(struct anonymous$7 *cu, struct anonymous$14 *stats)
{
  struct anonymous$14 *ustmp;
  if(!(cu == ((struct anonymous$7 *)NULL)))
  {
    ustmp=ConnectUser_get_stats(cu);
    UserStats_free(&ustmp);
    cu->stats = stats;
  }

}

// ConnectUser_set_userId
// file connect_user_struct.c line 145
void ConnectUser_set_userId(struct anonymous$7 *cu, signed int userId)
{
  if(!(cu == ((struct anonymous$7 *)NULL)))
    cu->userId = userId;

}

// ConnectUser_set_whatClient
// file connect_user_struct.c line 128
void ConnectUser_set_whatClient(struct anonymous$7 *cu, signed int whatClient)
{
  if(!(cu == ((struct anonymous$7 *)NULL)))
    cu->whatClient = whatClient;

}

// HeaderBuffer_free
// file header_buffer_struct.c line 53
void HeaderBuffer_free(struct anonymous$2 **hb)
{
  if(!(hb == ((struct anonymous$2 **)NULL)))
  {
    if(!(*hb == ((struct anonymous$2 *)NULL)))
    {
      free((void *)*hb);
      *hb = (struct anonymous$2 *)(void *)0;
    }

  }

}

// HeaderBuffer_new
// file header_buffer_struct.c line 36
struct anonymous$2 * HeaderBuffer_new()
{
  struct anonymous$2 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$2) /*12ul*/ );
  tmp = (struct anonymous$2 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$2 *)NULL))
    return (struct anonymous$2 *)(void *)0;

  else
    return tmp;
}

// HeaderBuffer_restore
// file header_buffer_struct.c line 119
void HeaderBuffer_restore(struct anonymous$2 *hb, unsigned char *buff)
{
  if(!(hb == ((struct anonymous$2 *)NULL)))
  {
    memcpy((void *)buff, (const void *)hb->tab, (unsigned long int)5);
    hb->readed = 0;
  }

}

// HeaderBuffer_store
// file header_buffer_struct.c line 93
void HeaderBuffer_store(struct anonymous$2 *hb, unsigned char *buff, signed int n)
{
  if(!(hb == ((struct anonymous$2 *)NULL)))
  {
    if(!(hb->readed + n >= 6))
    {
      if(n >= 1)
      {
        memcpy((void *)&hb->tab[(signed long int)hb->readed], (const void *)buff, (unsigned long int)n);
        hb->readed = hb->readed + n;
      }

    }

  }

}

// HeaderBuffer_to_read
// file header_buffer_struct.c line 75
signed int HeaderBuffer_to_read(struct anonymous$2 *hb)
{
  if(hb == ((struct anonymous$2 *)NULL))
    return -1;

  else
    return 5 - hb->readed;
}

// HttpProxyOptions_free
// file http_proxy_options_struct.h line 42
void HttpProxyOptions_free(struct anonymous **hpo)
{
  if(!(hpo == ((struct anonymous **)NULL)))
  {
    if(!(*hpo == ((struct anonymous *)NULL)))
    {
      if(!((*hpo)->proxyname == ((char *)NULL)))
      {
        free((void *)(*hpo)->proxyname);
        (*hpo)->proxyname = (char *)(void *)0;
      }

      if(!((*hpo)->proxyport == ((char *)NULL)))
      {
        free((void *)(*hpo)->proxyport);
        (*hpo)->proxyport = (char *)(void *)0;
      }

      if(!((*hpo)->proxyauth_cred == ((char *)NULL)))
      {
        free((void *)(*hpo)->proxyauth_cred);
        (*hpo)->proxyauth_cred = (char *)(void *)0;
      }

      free((void *)*hpo);
      *hpo = (struct anonymous *)(void *)0;
    }

  }

}

// HttpProxyOptions_get_proxyauth_cred
// file http_proxy_options_struct.h line 51
char * HttpProxyOptions_get_proxyauth_cred(struct anonymous *hpo)
{
  if(hpo == ((struct anonymous *)NULL))
    return (char *)(void *)0;

  else
    return hpo->proxyauth_cred;
}

// HttpProxyOptions_get_proxyauth_type
// file http_proxy_options_struct.h line 52
char HttpProxyOptions_get_proxyauth_type(struct anonymous *hpo)
{
  if(hpo == ((struct anonymous *)NULL))
    return (char)-1;

  else
    return hpo->proxyauth_type;
}

// HttpProxyOptions_get_proxyname
// file http_proxy_options_struct.h line 49
char * HttpProxyOptions_get_proxyname(struct anonymous *hpo)
{
  if(hpo == ((struct anonymous *)NULL))
    return (char *)(void *)0;

  else
    return hpo->proxyname;
}

// HttpProxyOptions_get_proxyport
// file http_proxy_options_struct.h line 50
char * HttpProxyOptions_get_proxyport(struct anonymous *hpo)
{
  if(hpo == ((struct anonymous *)NULL))
    return (char *)(void *)0;

  else
    return hpo->proxyport;
}

// HttpProxyOptions_is_https
// file http_proxy_options_struct.h line 55
char HttpProxyOptions_is_https(struct anonymous *hpo)
{
  if(hpo == ((struct anonymous *)NULL))
    return (char)0;

  else
    return hpo->useHttps;
}

// HttpProxyOptions_new
// file http_proxy_options_struct.h line 40
struct anonymous * HttpProxyOptions_new()
{
  struct anonymous *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous) /*32ul*/ );
  tmp = (struct anonymous *)return_value_calloc$1;
  if(tmp == ((struct anonymous *)NULL))
    return (struct anonymous *)(void *)0;

  else
  {
    tmp->proxyauth_type = (char)0;
    return tmp;
  }
}

// HttpProxyOptions_set_proxyauth_cred
// file http_proxy_options_struct.h line 46
void HttpProxyOptions_set_proxyauth_cred(struct anonymous *hpo, char *proxyauth_cred)
{
  if(!(hpo == ((struct anonymous *)NULL)))
    string_cp(&hpo->proxyauth_cred, proxyauth_cred);

}

// HttpProxyOptions_set_proxyauth_type
// file http_proxy_options_struct.h line 47
void HttpProxyOptions_set_proxyauth_type(struct anonymous *hpo, char proxyauth_type)
{
  if(!(hpo == ((struct anonymous *)NULL)))
  {
    if(!((signed int)hpo->proxyauth_type == 0))
      hpo->proxyauth_type = (char)-1;

    else
      hpo->proxyauth_type = proxyauth_type;
  }

}

// HttpProxyOptions_set_proxyname
// file http_proxy_options_struct.h line 44
void HttpProxyOptions_set_proxyname(struct anonymous *hpo, char *proxyname)
{
  if(!(hpo == ((struct anonymous *)NULL)))
    string_cp(&hpo->proxyname, proxyname);

}

// HttpProxyOptions_set_proxyport
// file http_proxy_options_struct.h line 45
void HttpProxyOptions_set_proxyport(struct anonymous *hpo, char *proxyport)
{
  if(!(hpo == ((struct anonymous *)NULL)))
    string_cp(&hpo->proxyport, proxyport);

}

// HttpProxyOptions_use_https
// file http_proxy_options_struct.h line 54
void HttpProxyOptions_use_https(struct anonymous *hpo)
{
  if(!(hpo == ((struct anonymous *)NULL)))
    hpo->useHttps = (char)1;

}

// Module_free
// file module_struct.c line 56
void Module_free(struct anonymous$6 **m)
{
  if(!(m == ((struct anonymous$6 **)NULL)))
  {
    if(!(*m == ((struct anonymous$6 *)NULL)))
    {
      Module_releaseModule(*m);
      if(!((*m)->fileName == ((char *)NULL)))
      {
        free((void *)(*m)->fileName);
        (*m)->fileName = (char *)(void *)0;
      }

      free((void *)*m);
      *m = (struct anonymous$6 *)(void *)0;
    }

  }

}

// Module_function_allow
// file module_struct.h line 50
signed int Module_function_allow(struct anonymous$6 *m, char *host, char *port)
{
  signed int return_value_Module_isModuleLoaded$1;
  return_value_Module_isModuleLoaded$1=Module_isModuleLoaded(m);
  if(return_value_Module_isModuleLoaded$1 == 0)
    return 0;

  else
  {
    signed int return_value;
    return_value=m->allow(host, port);
    return return_value;
  }
}

// Module_function_filter
// file module_struct.h line 51
signed int Module_function_filter(struct anonymous$6 *m, char *host, unsigned char *message, signed int *messageLength)
{
  signed int return_value_Module_isModuleLoaded$1;
  return_value_Module_isModuleLoaded$1=Module_isModuleLoaded(m);
  if(return_value_Module_isModuleLoaded$1 == 0)
    return 0;

  else
  {
    signed int return_value;
    return_value=m->filter(host, message, messageLength);
    return return_value;
  }
}

// Module_function_info
// file module_struct.h line 49
char * Module_function_info(struct anonymous$6 *m)
{
  signed int return_value_Module_isModuleLoaded$1;
  return_value_Module_isModuleLoaded$1=Module_isModuleLoaded(m);
  if(return_value_Module_isModuleLoaded$1 == 0)
    return (char *)(void *)0;

  else
  {
    char *return_value;
    return_value=m->info();
    return return_value;
  }
}

// Module_get_fileName
// file module_struct.h line 44
char * Module_get_fileName(struct anonymous$6 *m)
{
  if(m == ((struct anonymous$6 *)NULL))
    return (char *)(void *)0;

  else
    return m->fileName;
}

// Module_isModuleLoaded
// file module_struct.h line 48
signed int Module_isModuleLoaded(struct anonymous$6 *m)
{
  if(m == ((struct anonymous$6 *)NULL))
    return 0;

  else
    return (signed int)m->loaded;
}

// Module_loadModule
// file module_struct.h line 46
signed int Module_loadModule(struct anonymous$6 *m)
{
  char *return_value_Module_get_fileName$3;
  return_value_Module_get_fileName$3=Module_get_fileName(m);
  if(!(return_value_Module_get_fileName$3 == ((char *)NULL)))
  {
    char *return_value_Module_get_fileName$1;
    return_value_Module_get_fileName$1=Module_get_fileName(m);
    m->handle=dlopen(return_value_Module_get_fileName$1, 0x00002);
    if(m->handle == NULL)
      return 1;

    dlerror();
    *((void **)&m->info)=dlsym(m->handle, "info");
    *((void **)&m->allow)=dlsym(m->handle, "allow");
    *((void **)&m->filter)=dlsym(m->handle, "filter");
    char *return_value_dlerror$2;
    return_value_dlerror$2=dlerror();
    if(!(return_value_dlerror$2 == ((char *)NULL)))
      return 2;

    m->loaded = (char)1;
  }

  return 0;
}

// Module_new
// file module_struct.h line 38
struct anonymous$6 * Module_new()
{
  struct anonymous$6 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$6) /*48ul*/ );
  tmp = (struct anonymous$6 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$6 *)NULL))
    return (struct anonymous$6 *)(void *)0;

  else
    return tmp;
}

// Module_releaseModule
// file module_struct.h line 47
signed int Module_releaseModule(struct anonymous$6 *m)
{
  signed int return_value_Module_isModuleLoaded$2;
  return_value_Module_isModuleLoaded$2=Module_isModuleLoaded(m);
  if(!(return_value_Module_isModuleLoaded$2 == 0))
  {
    m->loaded = (char)0;
    m->info = (char * (*)(void))(void *)0;
    m->allow = (signed int (*)(char *, char *))(void *)0;
    m->filter = (signed int (*)(char *, unsigned char *, signed int *))(void *)0;
    signed int return_value_dlclose$1;
    return_value_dlclose$1=dlclose(m->handle);
    return return_value_dlclose$1;
  }

  return 0;
}

// Module_set_fileName
// file module_struct.h line 42
void Module_set_fileName(struct anonymous$6 *m, char *fileName)
{
  if(!(m == ((struct anonymous$6 *)NULL)))
    string_cp(&m->fileName, fileName);

}

// PortListNode_free
// file port_list_node_struct.c line 56
void PortListNode_free(struct plnode **pln)
{
  if(!(pln == ((struct plnode **)NULL)))
  {
    if(!(*pln == ((struct plnode *)NULL)))
    {
      if(!((*pln)->portName == ((char *)NULL)))
      {
        free((void *)(*pln)->portName);
        (*pln)->portName = (char *)(void *)0;
      }

      free((void *)*pln);
      *pln = (struct plnode *)(void *)0;
    }

  }

}

// PortListNode_get_nextNode
// file port_list_node_struct.c line 133
struct plnode * PortListNode_get_nextNode(struct plnode *pln)
{
  if(pln == ((struct plnode *)NULL))
    return (struct plnode *)(void *)0;

  else
    return pln->nextNode;
}

// PortListNode_get_portName
// file port_list_node_struct.h line 37
char * PortListNode_get_portName(struct plnode *pln)
{
  if(pln == ((struct plnode *)NULL))
    return (char *)(void *)0;

  else
    return pln->portName;
}

// PortListNode_new
// file port_list_node_struct.h line 30
struct plnode * PortListNode_new(char *portName)
{
  struct plnode *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct plnode) /*16ul*/ );
  tmp = (struct plnode *)return_value_calloc$1;
  if(tmp == ((struct plnode *)NULL))
    return (struct plnode *)(void *)0;

  else
  {
    PortListNode_set_portName(tmp, portName);
    return tmp;
  }
}

// PortListNode_set_nextNode
// file port_list_node_struct.c line 99
void PortListNode_set_nextNode(struct plnode *pln, struct plnode *nextNode)
{
  if(!(pln == ((struct plnode *)NULL)))
    pln->nextNode = nextNode;

}

// PortListNode_set_portName
// file port_list_node_struct.c line 82
void PortListNode_set_portName(struct plnode *pln, char *portName)
{
  if(!(pln == ((struct plnode *)NULL)))
    string_cp(&pln->portName, portName);

}

// PortList_clear
// file port_list_struct.c line 149
void PortList_clear(struct portlist *pl)
{
  struct plnode *tmp;
  if(!(pl == ((struct portlist *)NULL)))
  {
    while(!(pl->head == ((struct plnode *)NULL)))
    {
      tmp = pl->head;
      if(tmp == pl->tail)
      {
        pl->tail = (struct plnode *)(void *)0;
        pl->head = pl->tail;
      }

      else
        pl->head=PortListNode_get_nextNode(pl->head);
      PortListNode_free(&tmp);
    }
    pl->size = 0;
  }

}

// PortList_free
// file port_list_struct.h line 35
void PortList_free(struct portlist **pl)
{
  if(!(pl == ((struct portlist **)NULL)))
  {
    if(!(*pl == ((struct portlist *)NULL)))
    {
      PortList_clear(*pl);
      free((void *)*pl);
      *pl = (struct portlist *)(void *)0;
    }

  }

}

// PortList_get_nth
// file port_list_struct.h line 38
struct plnode * PortList_get_nth(struct portlist *pl, signed int n)
{
  struct plnode *tmp;
  if(pl == ((struct portlist *)NULL))
    return (struct plnode *)(void *)0;

  else
  {
    tmp = pl->head;
    while(!(tmp == ((struct plnode *)NULL)))
    {
      if(!(n >= 1))
        return tmp;

      n = n - 1;
      tmp=PortListNode_get_nextNode(tmp);
    }
    return (struct plnode *)(void *)0;
  }
}

// PortList_get_size
// file port_list_struct.h line 39
signed int PortList_get_size(struct portlist *pl)
{
  if(pl == ((struct portlist *)NULL))
    return -1;

  else
    return pl->size;
}

// PortList_insert_back
// file port_list_struct.h line 37
void PortList_insert_back(struct portlist *pl, struct plnode *pln)
{
  if(!(pl == ((struct portlist *)NULL)))
  {
    if(!(pln == ((struct plnode *)NULL)))
    {
      if(!(pl->tail == ((struct plnode *)NULL)))
        pl->tail->nextNode = pln;

      else
        pl->head = pln;
      pl->tail = pln;
      pln->nextNode = (struct plnode *)(void *)0;
      pl->size = pl->size + 1;
    }

  }

}

// PortList_new
// file port_list_struct.h line 33
struct portlist * PortList_new()
{
  struct portlist *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct portlist) /*24ul*/ );
  tmp = (struct portlist *)return_value_calloc$1;
  if(tmp == ((struct portlist *)NULL))
    return (struct portlist *)(void *)0;

  else
    return tmp;
}

// SSL_readn
// file network.c line 483
signed int SSL_readn(struct ssl_st *fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    n=SSL_read(fd, (void *)(buf + (signed long int)sent), amount - sent);
    if(!(n == -1))
      sent = sent + n;

    if(n == 0)
      return 0;

    if(n == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(!(*return_value___errno_location$1 == 11))
        return 0;

    }

  }
  return amount;
}

// SSL_writen
// file network.c line 454
signed int SSL_writen(struct ssl_st *fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    n=SSL_write(fd, (const void *)(buf + (signed long int)sent), amount - sent);
    if(!(n == -1))
      sent = sent + n;

    if(n == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(!(*return_value___errno_location$1 == 11))
        return 0;

    }

  }
  return amount;
}

// SslFd_free
// file ssl_fd_struct.c line 54
void SslFd_free(struct anonymous$0 **sf)
{
  if(!(sf == ((struct anonymous$0 **)NULL)))
  {
    if(!(*sf == ((struct anonymous$0 *)NULL)))
    {
      if(!((*sf)->ssl == ((struct ssl_st *)NULL)))
      {
        SSL_free((*sf)->ssl);
        (*sf)->ssl = (struct ssl_st *)(void *)0;
      }

      free((void *)*sf);
      *sf = (struct anonymous$0 *)(void *)0;
    }

  }

}

// SslFd_get_fd
// file ssl_fd_struct.h line 41
signed int SslFd_get_fd(struct anonymous$0 *sf)
{
  if(sf == ((struct anonymous$0 *)NULL))
    return -1;

  else
    return sf->fd;
}

// SslFd_get_message
// file ssl_fd_struct.h line 45
signed int SslFd_get_message(char type, struct anonymous$0 *sf, unsigned char *buf, signed int amount)
{
  signed int length;
  unsigned long int elen;
  if(sf == ((struct anonymous$0 *)NULL) || buf == ((unsigned char *)NULL))
    return -1;

  else
  {
    aflog((char)16, (char)2, "get_message: ssl:%s zlib:%s length:%d", ((signed int)type & 4) != 0 ? "yes" : "no", ((signed int)type & 8) != 0 ? "yes" : "no", amount);
    if(!(amount >= 0))
    {
      if(!((4 & (signed int)type) == 0))
      {
        signed int return_value_SSL_read$1;
        return_value_SSL_read$1=SSL_read(sf->ssl, (void *)buf, -amount);
        return return_value_SSL_read$1;
      }

      else
      {
        signed long int return_value_read$2;
        return_value_read$2=read(sf->fd, (void *)buf, (unsigned long int)-amount);
        return (signed int)return_value_read$2;
      }
    }

    if(!((8 & (signed int)type) == 0))
    {
      static unsigned char bufor[9000l];
      if(!((4 & (signed int)type) == 0))
        length=SSL_readn(sf->ssl, bufor, amount & 0xBFFF);

      else
        length=readn(sf->fd, bufor, amount & 0xBFFF);
      if(!(length >= 1))
        return length;

      elen = (unsigned long int)8096;
      if(!((0x4000 & amount) == 0))
        uncompress(buf, &elen, bufor, (unsigned long int)length);

      else
      {
        memcpy((void *)buf, (const void *)bufor, (unsigned long int)length);
        elen = (unsigned long int)length;
      }
      return (signed int)elen;
    }

    else
      if(!((4 & (signed int)type) == 0))
      {
        signed int return_value_SSL_readn$3;
        return_value_SSL_readn$3=SSL_readn(sf->ssl, buf, amount);
        return return_value_SSL_readn$3;
      }

      else
      {
        signed int return_value_readn$4;
        return_value_readn$4=readn(sf->fd, buf, amount);
        return return_value_readn$4;
      }
  }
}

// SslFd_get_ssl
// file ssl_fd_struct.h line 42
struct ssl_st * SslFd_get_ssl(struct anonymous$0 *sf)
{
  if(sf == ((struct anonymous$0 *)NULL))
    return (struct ssl_st *)(void *)0;

  else
    return sf->ssl;
}

// SslFd_new
// file ssl_fd_struct.h line 33
struct anonymous$0 * SslFd_new()
{
  struct anonymous$0 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$0) /*16ul*/ );
  tmp = (struct anonymous$0 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$0 *)NULL))
    return (struct anonymous$0 *)(void *)0;

  else
    return tmp;
}

// SslFd_send_message
// file ssl_fd_struct.h line 44
signed int SslFd_send_message(char type, struct anonymous$0 *sf, unsigned char *buf, signed int amount)
{
  unsigned long int clen;
  signed int length;
  if(sf == ((struct anonymous$0 *)NULL) || buf == ((unsigned char *)NULL))
    return -1;

  else
  {
    aflog((char)16, (char)2, "send_message: ssl:%s zlib:%s length:%d", ((signed int)type & 4) != 0 ? "yes" : "no", ((signed int)type & 8) != 0 ? "yes" : "no", amount);
    clen = (unsigned long int)8995;
    length = amount - 5;
    if(!((8 & (signed int)type) == 0))
    {
      static unsigned char buffer[9000l];
      memcpy((void *)buffer, (const void *)buf, (unsigned long int)5);
      if(amount >= 6)
      {
        compress(&buffer[(signed long int)5], &clen, &buf[(signed long int)5], (unsigned long int)length);
        if(!(clen >= (unsigned long int)length))
        {
          length = (signed int)clen;
          length = length | 0x4000;
          buffer[(signed long int)3] = (unsigned char)(length >> 8);
          buffer[(signed long int)4] = (unsigned char)length;
          addtocg((signed int)((unsigned long int)(amount - 5) - clen));
        }

      }

      if(!((4 & (signed int)type) == 0))
      {
        if(!((0x4000 & length) == 0))
        {
          signed int return_value_SSL_writen$1;
          return_value_SSL_writen$1=SSL_writen(sf->ssl, buffer, (signed int)(clen + (unsigned long int)5));
          return return_value_SSL_writen$1;
        }

        else
        {
          signed int return_value_SSL_writen$2;
          return_value_SSL_writen$2=SSL_writen(sf->ssl, buf, amount);
          return return_value_SSL_writen$2;
        }
      }

      else
        if(!((0x4000 & length) == 0))
        {
          signed int return_value_writen$3;
          return_value_writen$3=writen(sf->fd, buffer, (signed int)(clen + (unsigned long int)5));
          return return_value_writen$3;
        }

        else
        {
          signed int return_value_writen$4;
          return_value_writen$4=writen(sf->fd, buf, amount);
          return return_value_writen$4;
        }
    }

    else
      if(!((4 & (signed int)type) == 0))
      {
        signed int return_value_SSL_writen$5;
        return_value_SSL_writen$5=SSL_writen(sf->ssl, buf, amount);
        return return_value_SSL_writen$5;
      }

      else
      {
        signed int return_value_writen$6;
        return_value_writen$6=writen(sf->fd, buf, amount);
        return return_value_writen$6;
      }
  }
}

// SslFd_set_fd
// file ssl_fd_struct.h line 37
void SslFd_set_fd(struct anonymous$0 *sf, signed int fd)
{
  if(!(sf == ((struct anonymous$0 *)NULL)))
    sf->fd = fd;

}

// SslFd_set_ssl
// file ssl_fd_struct.h line 38
void SslFd_set_ssl(struct anonymous$0 *sf, struct ssl_st *ssl)
{
  SslFd_set_ssl_general(sf, ssl, 1);
}

// SslFd_set_ssl_general
// file ssl_fd_struct.c line 98
void SslFd_set_ssl_general(struct anonymous$0 *sf, struct ssl_st *ssl, signed int free)
{
  if(!(sf == ((struct anonymous$0 *)NULL)))
  {
    if(!(free == 0))
    {
      if(!(sf->ssl == ((struct ssl_st *)NULL)))
        SSL_free(sf->ssl);

    }

    sf->ssl = ssl;
  }

}

// SslFd_set_ssl_nf
// file ssl_fd_struct.c line 132
void SslFd_set_ssl_nf(struct anonymous$0 *sf, struct ssl_st *ssl)
{
  SslFd_set_ssl_general(sf, ssl, 0);
}

// SslFd_swap_content
// file ssl_fd_struct.c line 315
void SslFd_swap_content(struct anonymous$0 *sf1, struct anonymous$0 *sf2)
{
  signed int tmpfd;
  struct ssl_st *tmpssl;
  tmpfd=SslFd_get_fd(sf1);
  tmpssl=SslFd_get_ssl(sf2);
  signed int return_value_SslFd_get_fd$1;
  return_value_SslFd_get_fd$1=SslFd_get_fd(sf2);
  SslFd_set_fd(sf1, return_value_SslFd_get_fd$1);
  struct ssl_st *return_value_SslFd_get_ssl$2;
  return_value_SslFd_get_ssl$2=SslFd_get_ssl(sf2);
  SslFd_set_ssl(sf1, return_value_SslFd_get_ssl$2);
  SslFd_set_fd(sf2, tmpfd);
  SslFd_set_ssl(sf2, tmpssl);
}

// UserStats_add_download
// file user_stats_struct.c line 178
void UserStats_add_download(struct anonymous$14 *us, signed int bytes)
{
  signed long int now;
  if(!(us == ((struct anonymous$14 *)NULL)))
  {
    time(&now);
    switch(now - us->lastDSQChange)
    {
      case (signed long int)0:
      {
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = us->downloadSpeedQueue[(signed long int)us->downloadSQP] + bytes;
        break;
      }
      case (signed long int)2:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = bytes;
        break;
      }
      default:
      {
        us->downloadSpeedQueue[(signed long int)2] = 0;
        us->downloadSpeedQueue[(signed long int)1] = us->downloadSpeedQueue[(signed long int)2];
        us->downloadSpeedQueue[(signed long int)0] = us->downloadSpeedQueue[(signed long int)1];
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = bytes;
      }
    }
    us->totalDownloadedBytes = us->totalDownloadedBytes + bytes;
    us->lastActivity = now;
    us->lastDSQChange = now;
  }

}

// UserStats_add_upload
// file user_stats_struct.c line 231
void UserStats_add_upload(struct anonymous$14 *us, signed int bytes)
{
  signed long int now;
  if(!(us == ((struct anonymous$14 *)NULL)))
  {
    time(&now);
    switch(now - us->lastUSQChange)
    {
      case (signed long int)0:
      {
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = us->uploadSpeedQueue[(signed long int)us->uploadSQP] + bytes;
        break;
      }
      case (signed long int)2:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = bytes;
        break;
      }
      default:
      {
        us->uploadSpeedQueue[(signed long int)2] = 0;
        us->uploadSpeedQueue[(signed long int)1] = us->uploadSpeedQueue[(signed long int)2];
        us->uploadSpeedQueue[(signed long int)0] = us->uploadSpeedQueue[(signed long int)1];
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = bytes;
      }
    }
    us->totalUploadedBytes = us->totalUploadedBytes + bytes;
    us->lastActivity = now;
    us->lastUSQChange = now;
  }

}

// UserStats_clear
// file user_stats_struct.c line 376
void UserStats_clear(struct anonymous$14 *us)
{
  if(!(us == ((struct anonymous$14 *)NULL)))
  {
    us->lastActivity = (signed long int)0;
    us->lastUSQChange = (signed long int)0;
    us->lastDSQChange = (signed long int)0;
    us->totalDownloadedBytes = 0;
    us->totalUploadedBytes = 0;
    us->uploadSQP = 0;
    us->uploadSpeedQueue[(signed long int)2] = 0;
    us->uploadSpeedQueue[(signed long int)1] = us->uploadSpeedQueue[(signed long int)2];
    us->uploadSpeedQueue[(signed long int)0] = us->uploadSpeedQueue[(signed long int)1];
    us->downloadSQP = 0;
    us->downloadSpeedQueue[(signed long int)2] = 0;
    us->downloadSpeedQueue[(signed long int)1] = us->downloadSpeedQueue[(signed long int)2];
    us->downloadSpeedQueue[(signed long int)0] = us->downloadSpeedQueue[(signed long int)1];
  }

}

// UserStats_free
// file user_stats_struct.h line 42
void UserStats_free(struct anonymous$14 **us)
{
  if(!(us == ((struct anonymous$14 **)NULL)))
  {
    if(!(*us == ((struct anonymous$14 *)NULL)))
    {
      free((void *)*us);
      *us = (struct anonymous$14 *)(void *)0;
    }

  }

}

// UserStats_get_downloadSpeed
// file user_stats_struct.c line 283
double UserStats_get_downloadSpeed(struct anonymous$14 *us)
{
  signed long int now;
  if(us == ((struct anonymous$14 *)NULL))
    return 0.0;

  else
  {
    time(&now);
    switch(now - us->lastDSQChange)
    {
      case (signed long int)0:
        break;
      case (signed long int)2:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = 0;
        break;
      }
      default:
      {
        us->downloadSpeedQueue[(signed long int)2] = 0;
        us->downloadSpeedQueue[(signed long int)1] = us->downloadSpeedQueue[(signed long int)2];
        us->downloadSpeedQueue[(signed long int)0] = us->downloadSpeedQueue[(signed long int)1];
      }
    }
    us->lastDSQChange = now;
    return (double)(us->downloadSpeedQueue[(signed long int)0] + us->downloadSpeedQueue[(signed long int)1] + us->downloadSpeedQueue[(signed long int)2]) / 3.0;
  }
}

// UserStats_get_lastActivity
// file user_stats_struct.c line 126
signed long int UserStats_get_lastActivity(struct anonymous$14 *us)
{
  if(us == ((struct anonymous$14 *)NULL))
    return (signed long int)0;

  else
    return us->lastActivity;
}

// UserStats_get_totalDownloadedBytes
// file user_stats_struct.c line 143
signed int UserStats_get_totalDownloadedBytes(struct anonymous$14 *us)
{
  if(us == ((struct anonymous$14 *)NULL))
    return 0;

  else
    return us->totalDownloadedBytes;
}

// UserStats_get_totalUploadedBytes
// file user_stats_struct.c line 160
signed int UserStats_get_totalUploadedBytes(struct anonymous$14 *us)
{
  if(us == ((struct anonymous$14 *)NULL))
    return 0;

  else
    return us->totalUploadedBytes;
}

// UserStats_get_uploadSpeed
// file user_stats_struct.c line 330
double UserStats_get_uploadSpeed(struct anonymous$14 *us)
{
  signed long int now;
  if(us == ((struct anonymous$14 *)NULL))
    return 0.0;

  else
  {
    time(&now);
    switch(now - us->lastUSQChange)
    {
      case (signed long int)0:
        break;
      case (signed long int)2:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = 0;
        break;
      }
      default:
      {
        us->uploadSpeedQueue[(signed long int)2] = 0;
        us->uploadSpeedQueue[(signed long int)1] = us->uploadSpeedQueue[(signed long int)2];
        us->uploadSpeedQueue[(signed long int)0] = us->uploadSpeedQueue[(signed long int)1];
      }
    }
    us->lastUSQChange = now;
    return (double)(us->uploadSpeedQueue[(signed long int)0] + us->uploadSpeedQueue[(signed long int)1] + us->uploadSpeedQueue[(signed long int)2]) / 3.0;
  }
}

// UserStats_new
// file user_stats_struct.h line 40
struct anonymous$14 * UserStats_new()
{
  struct anonymous$14 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$14) /*64ul*/ );
  tmp = (struct anonymous$14 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$14 *)NULL))
    return (struct anonymous$14 *)(void *)0;

  else
    return tmp;
}

// UserStats_set_lastActivity
// file user_stats_struct.c line 75
void UserStats_set_lastActivity(struct anonymous$14 *us, signed long int lastActivity)
{
  if(!(us == ((struct anonymous$14 *)NULL)))
    us->lastActivity = lastActivity;

}

// UserStats_set_totalDownloadedBytes
// file user_stats_struct.c line 92
void UserStats_set_totalDownloadedBytes(struct anonymous$14 *us, signed int totalDownloadedBytes)
{
  if(!(us == ((struct anonymous$14 *)NULL)))
    us->totalDownloadedBytes = totalDownloadedBytes;

}

// UserStats_set_totalUploadedBytes
// file user_stats_struct.c line 109
void UserStats_set_totalUploadedBytes(struct anonymous$14 *us, signed int totalUploadedBytes)
{
  if(!(us == ((struct anonymous$14 *)NULL)))
    us->totalUploadedBytes = totalUploadedBytes;

}

// UsrCli_free
// file usr_cli_struct.c line 54
void UsrCli_free(struct anonymous$1 **uc)
{
  if(!(uc == ((struct anonymous$1 **)NULL)))
  {
    if(!(*uc == ((struct anonymous$1 *)NULL)))
    {
      if(!((*uc)->listenPortName == ((char *)NULL)))
      {
        free((void *)(*uc)->listenPortName);
        (*uc)->listenPortName = (char *)(void *)0;
      }

      if(!((*uc)->managePortName == ((char *)NULL)))
      {
        free((void *)(*uc)->managePortName);
        (*uc)->managePortName = (char *)(void *)0;
      }

      free((void *)*uc);
      *uc = (struct anonymous$1 *)(void *)0;
    }

  }

}

// UsrCli_get_listenFd
// file usr_cli_struct.c line 224
signed int UsrCli_get_listenFd(struct anonymous$1 *uc)
{
  if(uc == ((struct anonymous$1 *)NULL))
    return -1;

  else
    return uc->listenFd;
}

// UsrCli_get_listenHostName
// file usr_cli_struct.c line 258
char * UsrCli_get_listenHostName(struct anonymous$1 *uc)
{
  if(uc == ((struct anonymous$1 *)NULL))
    return (char *)(void *)0;

  else
    return uc->listenHostName;
}

// UsrCli_get_listenPortName
// file usr_cli_struct.c line 190
char * UsrCli_get_listenPortName(struct anonymous$1 *uc)
{
  if(uc == ((struct anonymous$1 *)NULL))
    return (char *)(void *)0;

  else
    return uc->listenPortName;
}

// UsrCli_get_manageFd
// file usr_cli_struct.c line 241
signed int UsrCli_get_manageFd(struct anonymous$1 *uc)
{
  if(uc == ((struct anonymous$1 *)NULL))
    return -1;

  else
    return uc->manageFd;
}

// UsrCli_get_manageHostName
// file usr_cli_struct.c line 275
char * UsrCli_get_manageHostName(struct anonymous$1 *uc)
{
  if(uc == ((struct anonymous$1 *)NULL))
    return (char *)(void *)0;

  else
    return uc->manageHostName;
}

// UsrCli_get_managePortName
// file usr_cli_struct.c line 207
char * UsrCli_get_managePortName(struct anonymous$1 *uc)
{
  if(uc == ((struct anonymous$1 *)NULL))
    return (char *)(void *)0;

  else
    return uc->managePortName;
}

// UsrCli_get_number
// file usr_cli_struct.c line 292
signed int UsrCli_get_number(struct anonymous$1 *uc)
{
  if(uc == ((struct anonymous$1 *)NULL))
    return -1;

  else
    return uc->number;
}

// UsrCli_new
// file usr_cli_struct.c line 37
struct anonymous$1 * UsrCli_new()
{
  struct anonymous$1 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$1) /*48ul*/ );
  tmp = (struct anonymous$1 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$1 *)NULL))
    return (struct anonymous$1 *)(void *)0;

  else
    return tmp;
}

// UsrCli_set_listenFd
// file usr_cli_struct.c line 139
void UsrCli_set_listenFd(struct anonymous$1 *uc, signed int listenFd)
{
  if(!(uc == ((struct anonymous$1 *)NULL)))
    uc->listenFd = listenFd;

}

// UsrCli_set_listenPortName
// file usr_cli_struct.c line 83
void UsrCli_set_listenPortName(struct anonymous$1 *uc, char *listenPortName)
{
  char *tmp;
  if(!(uc == ((struct anonymous$1 *)NULL)))
  {
    tmp=rindex(listenPortName, 58);
    if(!(tmp == ((char *)NULL)))
    {
      *tmp = (char)0;
      tmp = tmp + 1l;
      string_cp(&uc->listenHostName, listenPortName);
      string_cp(&uc->listenPortName, tmp);
    }

    else
      string_cp(&uc->listenPortName, listenPortName);
  }

}

// UsrCli_set_manageFd
// file usr_cli_struct.c line 156
void UsrCli_set_manageFd(struct anonymous$1 *uc, signed int manageFd)
{
  if(!(uc == ((struct anonymous$1 *)NULL)))
    uc->manageFd = manageFd;

}

// UsrCli_set_managePortName
// file usr_cli_struct.c line 111
void UsrCli_set_managePortName(struct anonymous$1 *uc, char *managePortName)
{
  char *tmp;
  if(!(uc == ((struct anonymous$1 *)NULL)))
  {
    tmp=rindex(managePortName, 58);
    if(!(tmp == ((char *)NULL)))
    {
      *tmp = (char)0;
      tmp = tmp + 1l;
      string_cp(&uc->manageHostName, managePortName);
      string_cp(&uc->managePortName, tmp);
    }

    else
      string_cp(&uc->managePortName, managePortName);
  }

}

// UsrCli_set_number
// file usr_cli_struct.c line 173
void UsrCli_set_number(struct anonymous$1 *uc, signed int number)
{
  if(!(uc == ((struct anonymous$1 *)NULL)))
    uc->number = number;

}

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32$1;
  return_value___builtin_bswap32$1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32$1;
}

// __bswap_32$link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32$link1(unsigned int __bsx$link1)
{
  signed long int return_value___builtin_bswap32$1$link1;
  return_value___builtin_bswap32$1$link1=__builtin_bswap32((signed long int)__bsx$link1);
  return (unsigned int)return_value___builtin_bswap32$1$link1;
}

// add_public_key
// file ssl_routines.h line 31
void add_public_key(char *filename, char *hostname, char *keyhash)
{
  struct _IO_FILE *storefile;
  storefile=fopen(filename, "a");
  if(!(storefile == ((struct _IO_FILE *)NULL)))
  {
    fprintf(storefile, "%s %s\n", hostname, keyhash);
    fclose(storefile);
  }

}

// addlogtarget
// file logging.h line 69
void addlogtarget(char *cmdline)
{
  struct llnode *newnode;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct llnode) /*32ul*/ );
  newnode = (struct llnode *)return_value_calloc$1;
  newnode->cmdline = cmdline;
  newnode->next = head;
  head = newnode;
}

// addtocg
// file stats.c line 61
void addtocg(signed int amount)
{
  compressgained = compressgained + (signed long int)amount;
}

// aflog
// file logging.h line 73
void aflog(char type, char importance, const char *form, ...)
{
  struct llnode *ptr;
  void **ap;
  if(!(((signed int)importance & (signed int)verlev) == 0))
  {
    if(!((signed int)format[0l] == 0))
    {
      char *return_value_datum$1;
      return_value_datum$1=datum();
      printf("[%s] ", return_value_datum$1);
    }

    ap = (void **)&form;
    vfprintf(stdout, form, ap);
    ap = ((void **)NULL);
    printf("\n");
  }

  ptr = head;
  for( ; !(ptr == ((struct llnode *)NULL)); ptr = ptr->next)
    if(!(((signed int)ptr->msgtype & (signed int)type) == 0))
    {
      if(!(((signed int)ptr->importance & (signed int)importance) == 0))
      {
        if(!((signed int)format[0l] == 0))
        {
          char *return_value_datum$2;
          return_value_datum$2=datum();
          fprintf(ptr->logfd, "[%s] ", return_value_datum$2);
        }

        ap = (void **)&form;
        vfprintf(ptr->logfd, form, ap);
        ap = ((void **)NULL);
        fprintf(ptr->logfd, "\n");
        fflush(ptr->logfd);
      }

    }

}

// b64_ntop
// file base64.h line 37
signed int b64_ntop(const unsigned char *src, unsigned long int srclength, char *target, unsigned long int targsize)
{
  unsigned long int datalength = (unsigned long int)0;
  unsigned char input[3l];
  unsigned char output[4l];
  unsigned long int i;
  const unsigned char *tmp_post$1;
  const unsigned char *tmp_post$2;
  const unsigned char *tmp_post$3;
  unsigned long int tmp_post$4;
  unsigned long int tmp_post$5;
  unsigned long int tmp_post$6;
  unsigned long int tmp_post$7;
  for( ; srclength >= 3ul; target[(signed long int)tmp_post$7] = Base64[(signed long int)output[(signed long int)3]])
  {
    tmp_post$1 = src;
    src = src + 1l;
    input[(signed long int)0] = *tmp_post$1;
    tmp_post$2 = src;
    src = src + 1l;
    input[(signed long int)1] = *tmp_post$2;
    tmp_post$3 = src;
    src = src + 1l;
    input[(signed long int)2] = *tmp_post$3;
    srclength = srclength - (unsigned long int)3;
    output[(signed long int)0] = (unsigned char)((signed int)input[(signed long int)0] >> 2);
    output[(signed long int)1] = (unsigned char)((((signed int)input[(signed long int)0] & 0x03) << 4) + ((signed int)input[(signed long int)1] >> 4));
    output[(signed long int)2] = (unsigned char)((((signed int)input[(signed long int)1] & 0x0f) << 2) + ((signed int)input[(signed long int)2] >> 6));
    output[(signed long int)3] = (unsigned char)((signed int)input[(signed long int)2] & 0x3f);
    if((signed int)output[0l] >= 64)
      return -1;

    if((signed int)output[1l] >= 64)
      return -1;

    if((signed int)output[2l] >= 64)
      return -1;

    if((signed int)output[3l] >= 64)
      return -1;

    if(!(targsize >= 4ul + datalength))
      return -1;

    tmp_post$4 = datalength;
    datalength = datalength + 1ul;
    target[(signed long int)tmp_post$4] = Base64[(signed long int)output[(signed long int)0]];
    tmp_post$5 = datalength;
    datalength = datalength + 1ul;
    target[(signed long int)tmp_post$5] = Base64[(signed long int)output[(signed long int)1]];
    tmp_post$6 = datalength;
    datalength = datalength + 1ul;
    target[(signed long int)tmp_post$6] = Base64[(signed long int)output[(signed long int)2]];
    tmp_post$7 = datalength;
    datalength = datalength + 1ul;
  }
  const unsigned char *tmp_post$8;
  unsigned long int tmp_post$9;
  unsigned long int tmp_post$10;
  unsigned long int tmp_post$11;
  unsigned long int tmp_post$12;
  unsigned long int tmp_post$13;
  if(!(srclength == 0ul))
  {
    input[(signed long int)2] = (unsigned char)0;
    input[(signed long int)1] = input[(signed long int)2];
    input[(signed long int)0] = input[(signed long int)1];
    i = (unsigned long int)0;
    for( ; !(i >= srclength); i = i + 1ul)
    {
      tmp_post$8 = src;
      src = src + 1l;
      input[(signed long int)i] = *tmp_post$8;
    }
    output[(signed long int)0] = (unsigned char)((signed int)input[(signed long int)0] >> 2);
    output[(signed long int)1] = (unsigned char)((((signed int)input[(signed long int)0] & 0x03) << 4) + ((signed int)input[(signed long int)1] >> 4));
    output[(signed long int)2] = (unsigned char)((((signed int)input[(signed long int)1] & 0x0f) << 2) + ((signed int)input[(signed long int)2] >> 6));
    if((signed int)output[0l] >= 64)
      return -1;

    if((signed int)output[1l] >= 64)
      return -1;

    if((signed int)output[2l] >= 64)
      return -1;

    if(!(targsize >= 4ul + datalength))
      return -1;

    tmp_post$9 = datalength;
    datalength = datalength + 1ul;
    target[(signed long int)tmp_post$9] = Base64[(signed long int)output[(signed long int)0]];
    tmp_post$10 = datalength;
    datalength = datalength + 1ul;
    target[(signed long int)tmp_post$10] = Base64[(signed long int)output[(signed long int)1]];
    if(srclength == 1ul)
    {
      tmp_post$11 = datalength;
      datalength = datalength + 1ul;
      target[(signed long int)tmp_post$11] = Pad64;
    }

    else
    {
      tmp_post$12 = datalength;
      datalength = datalength + 1ul;
      target[(signed long int)tmp_post$12] = Base64[(signed long int)output[(signed long int)2]];
    }
    tmp_post$13 = datalength;
    datalength = datalength + 1ul;
    target[(signed long int)tmp_post$13] = Pad64;
  }

  if(datalength >= targsize)
    return -1;

  else
  {
    target[(signed long int)datalength] = (char)0;
    return (signed int)datalength;
  }
}

// b64_pton
// file base64.c line 132
signed int b64_pton(const char *src, unsigned char *target, unsigned long int targsize)
{
  signed int tarindex;
  signed int state;
  signed int ch;
  char *pos;
  state = 0;
  tarindex = 0;
  const char *tmp_post$1;
  do
  {
    tmp_post$1 = src;
    src = src + 1l;
    ch = (signed int)*tmp_post$1;
    if(ch == 0)
      break;

    const unsigned short int **return_value___ctype_b_loc$2;
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)(unsigned char)ch]) == 0)
    {
      if(ch == (signed int)Pad64)
        break;

      char *return_value___builtin_strchr$3;
      return_value___builtin_strchr$3=__builtin_strchr(Base64, ch);
      pos = return_value___builtin_strchr$3;
      if(pos == ((char *)NULL))
        return -1;

      switch(state)
      {
        case 0:
        {
          if(!(target == ((unsigned char *)NULL)))
          {
            if((unsigned long int)tarindex >= targsize)
              return -1;

            target[(signed long int)tarindex] = (unsigned char)(pos - Base64 << 2);
          }

          state = 1;
          break;
        }
        case 1:
        {
          if(!(target == ((unsigned char *)NULL)))
          {
            if(1ul + (unsigned long int)tarindex >= targsize)
              return -1;

            target[(signed long int)tarindex] = target[(signed long int)tarindex] | (unsigned char)(pos - Base64 >> 4);
            target[(signed long int)(tarindex + 1)] = (unsigned char)((pos - Base64 & (signed long int)0x0f) << 4);
          }

          tarindex = tarindex + 1;
          state = 2;
          break;
        }
        case 2:
        {
          if(!(target == ((unsigned char *)NULL)))
          {
            if(1ul + (unsigned long int)tarindex >= targsize)
              return -1;

            target[(signed long int)tarindex] = target[(signed long int)tarindex] | (unsigned char)(pos - Base64 >> 2);
            target[(signed long int)(tarindex + 1)] = (unsigned char)((pos - Base64 & (signed long int)0x03) << 6);
          }

          tarindex = tarindex + 1;
          state = 3;
          break;
        }
        case 3:
        {
          if(!(target == ((unsigned char *)NULL)))
          {
            if((unsigned long int)tarindex >= targsize)
              return -1;

            target[(signed long int)tarindex] = target[(signed long int)tarindex] | (unsigned char)(pos - Base64);
          }

          tarindex = tarindex + 1;
          state = 0;
          break;
        }
        default:
          abort();
      }
    }

  }
  while((_Bool)1);
  const char *tmp_post$4;
  const unsigned short int **return_value___ctype_b_loc$6;
  const char *tmp_post$5;
  const char *tmp_post$7;
  const unsigned short int **return_value___ctype_b_loc$9;
  const char *tmp_post$8;
  if(ch == (signed int)Pad64)
  {
    tmp_post$4 = src;
    src = src + 1l;
    ch = (signed int)*tmp_post$4;
    switch(state)
    {
      case 0:

      case 1:
        return -1;
      case 2:
      {
        (void)(void *)0;
        for( ; !(ch == 0); ch = (signed int)*tmp_post$5)
        {
          return_value___ctype_b_loc$6=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)(unsigned char)ch]) == 0)
            break;

          tmp_post$5 = src;
          src = src + 1l;
        }
        if(!(ch == (signed int)Pad64))
          return -1;

        tmp_post$7 = src;
        src = src + 1l;
        ch = (signed int)*tmp_post$7;
      }
      case 3:
      {
        (void)(void *)0;
        for( ; !(ch == 0); ch = (signed int)*tmp_post$8)
        {
          return_value___ctype_b_loc$9=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)(unsigned char)ch]) == 0)
            return -1;

          tmp_post$8 = src;
          src = src + 1l;
        }
        if(!(target == ((unsigned char *)NULL)))
        {
          if(!((signed int)target[(signed long int)tarindex] == 0))
            return -1;

        }

      }
      default:
        ;
    }
  }

  else
    if(!(state == 0))
      return -1;

  return tarindex;
}

// broadcast_condition
// file thread_management.h line 31
void broadcast_condition(void)
{
  pthread_cond_broadcast(&maincond);
}

// callback
// file first_run.c line 63
static void callback(signed int i, signed int j, void *k)
{
  if(k == NULL)
  {
    printf("%d", i);
    fflush(stdout);
  }

}

// check_long
// file server_check.c line 99
signed int check_long(char *text, signed long int *number)
{
  char *tmp;
  *number=strtol(text, &tmp, 10);
  _Bool tmp_if_expr$1;
  if(*number == 0x7fffffffffffffffL)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = *number == -0x7fffffffffffffffL - 1L ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    return 1;

  else
  {
    if(!((signed int)*text == 0))
      tmp_if_expr$2 = (signed int)*tmp == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      return 0;

    else
      return 2;
  }
}

// check_public_key
// file ssl_routines.h line 29
signed int check_public_key(char *filename, char *hostname, char *keyhash)
{
  struct _IO_FILE *storefile;
  char buff[256l];
  signed int lspaceind;
  signed int i;
  memset((void *)buff, 0, (unsigned long int)256);
  storefile=fopen(filename, "r");
  char *return_value_fgets$1;
  signed int tmp_statement_expression$6;
  signed int tmp_statement_expression$4;
  if(storefile == ((struct _IO_FILE *)NULL))
    return 2;

  else
  {
    do
    {
      return_value_fgets$1=fgets(buff, 256, storefile);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      lspaceind = -1;
      i = 0;
      for( ; !(i >= 256); i = i + 1)
      {
        if((signed int)buff[(signed long int)i] == 0)
          break;

        if((signed int)buff[(signed long int)i] == 32)
          lspaceind = i;

      }
      if(!(lspaceind == -1))
      {
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(buff);
        if((signed int)buff[-1l + (signed long int)return_value_strlen$3] == 10)
        {
          unsigned long int return_value_strlen$2;
          return_value_strlen$2=strlen(buff);
          buff[(signed long int)(return_value_strlen$2 - (unsigned long int)1)] = (char)0;
        }

        buff[(signed long int)lspaceind] = (char)0;
        unsigned long int check_public_key$$1$$2$$4$$__s1_len;
        unsigned long int check_public_key$$1$$2$$4$$__s2_len;
        signed int return_value___builtin_strcmp$7;
        return_value___builtin_strcmp$7=__builtin_strcmp(buff, hostname);
        tmp_statement_expression$6 = return_value___builtin_strcmp$7;
        if(tmp_statement_expression$6 == 0)
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp$5;
          return_value___builtin_strcmp$5=__builtin_strcmp(&buff[(signed long int)(lspaceind + 1)], keyhash);
          tmp_statement_expression$4 = return_value___builtin_strcmp$5;
          if(tmp_statement_expression$4 == 0)
            return 1;

          else
            return 0;
        }

      }

    }
    while((_Bool)1);
    return 2;
  }
}

// check_value
// file server_check.h line 24
signed int check_value(char *what, char *info)
{
  signed long int tmp;
  signed int return_value_check_value_liberal$1;
  return_value_check_value_liberal$1=check_value_liberal(what, info);
  tmp = (signed long int)return_value_check_value_liberal$1;
  if(!(tmp >= 1l))
  {
    aflog((char)4, (char)1, "%s: %d\n", info, tmp);
    exit(1);
  }

  return (signed int)tmp;
}

// check_value_liberal
// file server_check.c line 67
signed int check_value_liberal(char *what, char *info)
{
  char *znak;
  signed long int tmp;
  tmp=strtol(what, &znak, 10);
  if(tmp >= 2147483647l)
  {
    aflog((char)4, (char)1, "%s: %s\n", info, what);
    exit(1);
  }

  _Bool tmp_if_expr$1;
  if((signed int)*what == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*znak != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    aflog((char)4, (char)1, "%s: %s\n", info, what);
    exit(1);
  }

  return (signed int)tmp;
}

// checklogtarget
// file logging.c line 175
signed int checklogtarget(struct llnode *target)
{
  char *ptr;
  char desc[100l];
  char type = (char)0;
  char tab[100l];
  signed int tmpfd;
  signed int state;
  signed int i;
  _Bool tmp_if_expr$1;
  if(target == ((struct llnode *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = target->cmdline == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_statement_expression$4;
  signed int tmp_statement_expression$2;
  if(tmp_if_expr$1)
    return 1;

  else
  {
    state = 0;
    memset((void *)tab, 0, (unsigned long int)100);
    i = 0;
    ptr = target->cmdline;
    for( ; !((signed int)*ptr == 0); ptr = ptr + 1l)
      switch(state)
      {
        case 0:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$5;
            return_value___builtin_strcmp$5=__builtin_strcmp(tab, "file");
            tmp_statement_expression$4 = return_value___builtin_strcmp$5;
            if(tmp_statement_expression$4 == 0)
              type = (char)1;

            else
            {
              unsigned long int checklogtarget$$1$$2$$1$$1$$1$$3$$__s1_len;
              unsigned long int checklogtarget$$1$$2$$1$$1$$1$$3$$__s2_len;
              signed int return_value___builtin_strcmp$3;
              return_value___builtin_strcmp$3=__builtin_strcmp(tab, "sock");
              tmp_statement_expression$2 = return_value___builtin_strcmp$3;
              if(tmp_statement_expression$2 == 0)
                type = (char)2;

              else
                return 2;
            }
            state = 1;
            memset((void *)tab, 0, (unsigned long int)100);
            memset((void *)desc, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 2;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
          break;
        }
        case 1:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            switch((signed int)type)
            {
              case 1:
              {
                target->logfd=fopen(tab, "a");
                if(target->logfd == ((struct _IO_FILE *)NULL))
                  return 4;

                state = 3;
                break;
              }
              case 2:
              {
                __builtin_strncpy(desc, tab, (unsigned long int)99);
                state = 2;
                break;
              }
              default:
                return 2;
            }
            memset((void *)tab, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 3;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
          break;
        }
        case 2:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            signed int return_value_ip_connect$6;
            return_value_ip_connect$6=ip_connect(&tmpfd, desc, tab, (const char)1, (const char *)(void *)0, (const char *)(void *)0);
            if(!(return_value_ip_connect$6 == 0))
              return 5;

            target->logfd=fdopen(tmpfd, "a");
            if(target->logfd == ((struct _IO_FILE *)NULL))
              return 4;

            state = 3;
            memset((void *)tab, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 3;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
          break;
        }
        case 3:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            signed int return_value_checkmsgti$7;
            return_value_checkmsgti$7=checkmsgti(target, tab);
            if(!(return_value_checkmsgti$7 == 0))
              return 6;

            memset((void *)tab, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 6;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
        }
      }
    if(!(i == 0))
    {
      if(state == 3)
      {
        tab[(signed long int)i] = (char)0;
        signed int return_value_checkmsgti$8;
        return_value_checkmsgti$8=checkmsgti(target, tab);
        if(!(return_value_checkmsgti$8 == 0))
          return 6;

        goto __CPROVER_DUMP_L32;
      }

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L32:
      ;
      return 0;
    }
  }
}

// checkmsgti
// file logging.c line 119
signed int checkmsgti(struct llnode *target, char *tab)
{
  signed int tmp_statement_expression$25;
  unsigned long int checkmsgti$$1$$1$$__s1_len;
  unsigned long int checkmsgti$$1$$1$$__s2_len;
  signed int return_value___builtin_strcmp$26;
  return_value___builtin_strcmp$26=__builtin_strcmp(tab, "LOG_T_ALL");
  tmp_statement_expression$25 = return_value___builtin_strcmp$26;
  signed int tmp_statement_expression$23;
  signed int tmp_statement_expression$21;
  signed int tmp_statement_expression$19;
  signed int tmp_statement_expression$17;
  signed int tmp_statement_expression$15;
  signed int tmp_statement_expression$13;
  signed int tmp_statement_expression$11;
  signed int tmp_statement_expression$9;
  signed int tmp_statement_expression$7;
  signed int tmp_statement_expression$5;
  signed int tmp_statement_expression$3;
  signed int tmp_statement_expression$1;
  if(tmp_statement_expression$25 == 0)
    target->msgtype = target->msgtype | (char)(1 | 2 | 4 | 8 | 16);

  else
  {
    unsigned long int checkmsgti$$1$$3$$__s1_len;
    unsigned long int checkmsgti$$1$$3$$__s2_len;
    signed int return_value___builtin_strcmp$24;
    return_value___builtin_strcmp$24=__builtin_strcmp(tab, "LOG_T_USER");
    tmp_statement_expression$23 = return_value___builtin_strcmp$24;
    if(tmp_statement_expression$23 == 0)
      target->msgtype = target->msgtype | (char)1;

    else
    {
      unsigned long int checkmsgti$$1$$5$$__s1_len;
      unsigned long int checkmsgti$$1$$5$$__s2_len;
      signed int return_value___builtin_strcmp$22;
      return_value___builtin_strcmp$22=__builtin_strcmp(tab, "LOG_T_CLIENT");
      tmp_statement_expression$21 = return_value___builtin_strcmp$22;
      if(tmp_statement_expression$21 == 0)
        target->msgtype = target->msgtype | (char)2;

      else
      {
        unsigned long int checkmsgti$$1$$7$$__s1_len;
        unsigned long int checkmsgti$$1$$7$$__s2_len;
        signed int return_value___builtin_strcmp$20;
        return_value___builtin_strcmp$20=__builtin_strcmp(tab, "LOG_T_INIT");
        tmp_statement_expression$19 = return_value___builtin_strcmp$20;
        if(tmp_statement_expression$19 == 0)
          target->msgtype = target->msgtype | (char)4;

        else
        {
          unsigned long int checkmsgti$$1$$9$$__s1_len;
          unsigned long int checkmsgti$$1$$9$$__s2_len;
          signed int return_value___builtin_strcmp$18;
          return_value___builtin_strcmp$18=__builtin_strcmp(tab, "LOG_T_MANAGE");
          tmp_statement_expression$17 = return_value___builtin_strcmp$18;
          if(tmp_statement_expression$17 == 0)
            target->msgtype = target->msgtype | (char)8;

          else
          {
            unsigned long int checkmsgti$$1$$11$$__s1_len;
            unsigned long int checkmsgti$$1$$11$$__s2_len;
            signed int return_value___builtin_strcmp$16;
            return_value___builtin_strcmp$16=__builtin_strcmp(tab, "LOG_T_MAIN");
            tmp_statement_expression$15 = return_value___builtin_strcmp$16;
            if(tmp_statement_expression$15 == 0)
              target->msgtype = target->msgtype | (char)16;

            else
            {
              unsigned long int checkmsgti$$1$$13$$__s1_len;
              unsigned long int checkmsgti$$1$$13$$__s2_len;
              signed int return_value___builtin_strcmp$14;
              return_value___builtin_strcmp$14=__builtin_strcmp(tab, "LOG_I_ALL");
              tmp_statement_expression$13 = return_value___builtin_strcmp$14;
              if(tmp_statement_expression$13 == 0)
                target->importance = target->importance | (char)(1 | 2 | 4 | 8 | 16 | 32 | 64);

              else
              {
                unsigned long int checkmsgti$$1$$15$$__s1_len;
                unsigned long int checkmsgti$$1$$15$$__s2_len;
                signed int return_value___builtin_strcmp$12;
                return_value___builtin_strcmp$12=__builtin_strcmp(tab, "LOG_I_CRIT");
                tmp_statement_expression$11 = return_value___builtin_strcmp$12;
                if(tmp_statement_expression$11 == 0)
                  target->importance = target->importance | (char)1;

                else
                {
                  unsigned long int checkmsgti$$1$$17$$__s1_len;
                  unsigned long int checkmsgti$$1$$17$$__s2_len;
                  signed int return_value___builtin_strcmp$10;
                  return_value___builtin_strcmp$10=__builtin_strcmp(tab, "LOG_I_DEBUG");
                  tmp_statement_expression$9 = return_value___builtin_strcmp$10;
                  if(tmp_statement_expression$9 == 0)
                    target->importance = target->importance | (char)2;

                  else
                  {
                    unsigned long int checkmsgti$$1$$19$$__s1_len;
                    unsigned long int checkmsgti$$1$$19$$__s2_len;
                    signed int return_value___builtin_strcmp$8;
                    return_value___builtin_strcmp$8=__builtin_strcmp(tab, "LOG_I_INFO");
                    tmp_statement_expression$7 = return_value___builtin_strcmp$8;
                    if(tmp_statement_expression$7 == 0)
                      target->importance = target->importance | (char)8;

                    else
                    {
                      unsigned long int __s1_len;
                      unsigned long int __s2_len;
                      signed int return_value___builtin_strcmp$6;
                      return_value___builtin_strcmp$6=__builtin_strcmp(tab, "LOG_I_NOTICE");
                      tmp_statement_expression$5 = return_value___builtin_strcmp$6;
                      if(tmp_statement_expression$5 == 0)
                        target->importance = target->importance | (char)16;

                      else
                      {
                        unsigned long int checkmsgti$$1$$23$$__s1_len;
                        unsigned long int checkmsgti$$1$$23$$__s2_len;
                        signed int return_value___builtin_strcmp$4;
                        return_value___builtin_strcmp$4=__builtin_strcmp(tab, "LOG_I_WARNING");
                        tmp_statement_expression$3 = return_value___builtin_strcmp$4;
                        if(tmp_statement_expression$3 == 0)
                          target->importance = target->importance | (char)32;

                        else
                        {
                          unsigned long int checkmsgti$$1$$25$$__s1_len;
                          unsigned long int checkmsgti$$1$$25$$__s2_len;
                          signed int return_value___builtin_strcmp$2;
                          return_value___builtin_strcmp$2=__builtin_strcmp(tab, "LOG_I_ERR");
                          tmp_statement_expression$1 = return_value___builtin_strcmp$2;
                          if(tmp_statement_expression$1 == 0)
                            target->importance = target->importance | (char)64;

                          else
                            return 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

// clean_return
// file http_proxy_client.c line 48
static void clean_return(signed int sockfd)
{
  aflog((char)16, (char)2, "http proxy: clean_return");
  close(sockfd);
  pthread_exit((void *)0);
}

// clear_fd
// file http_proxy_functions.c line 261
void clear_fd(signed int *fd, struct anonymous$11 *set)
{
  set->__fds_bits[(signed long int)(*fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->__fds_bits[(signed long int)(*fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << *fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  close_fd(fd);
}

// clear_sslFd
// file http_proxy_functions.c line 362
void clear_sslFd(struct anonymous$0 *sf, struct anonymous$11 *set)
{
  clear_fd(&sf->fd, set);
  struct ssl_st *return_value_SslFd_get_ssl$2;
  return_value_SslFd_get_ssl$2=SslFd_get_ssl(sf);
  if(!(return_value_SslFd_get_ssl$2 == ((struct ssl_st *)NULL)))
  {
    struct ssl_st *return_value_SslFd_get_ssl$1;
    return_value_SslFd_get_ssl$1=SslFd_get_ssl(sf);
    SSL_clear(return_value_SslFd_get_ssl$1);
  }

}

// client_admin
// file client_remoteadmin.h line 35
signed int client_admin(char type, struct anonymous$0 *master, unsigned char *buff, signed int connectfd, char *id)
{
  struct anonymous$11 rset;
  struct anonymous$11 allset;
  signed int maxfdp1;
  signed int n;
  signed int length;
  signed int infd;
  struct _IO_FILE *outfp;
  struct _IO_FILE *infp;
  buff[(signed long int)0] = (unsigned char)14;
  SslFd_send_message(type, master, buff, 5);
  buff[(signed long int)0] = (unsigned char)0;
  SslFd_get_message(type, master, buff, -5);
  signed int tmp_if_expr$5;
  signed int return_value_SslFd_get_fd$4;
  signed long int return_value_getcg$8;
  signed long int return_value_getcg$9;
  if((signed int)*buff == 0)
  {
    aflog((char)4, (char)1, "Wrong password");
    return 1;
  }

  else
    if((signed int)*buff == 12)
    {
      aflog((char)4, (char)1, "Server is full");
      return 1;
    }

    else
      if(!((signed int)*buff == 14))
      {
        aflog((char)4, (char)1, "Incompatible server type or server full");
        return 1;
      }

      else
      {
        aflog((char)16, (char)8, "CLIENT STARTED mode: remote administration");
        if(connectfd >= 1)
        {
          outfp=fdopen(connectfd, "w");
          if(outfp == ((struct _IO_FILE *)NULL))
          {
            aflog((char)4, (char)1, "Error in opening file descriptor for writing");
            return 1;
          }

          infd = connectfd;
        }

        else
        {
          infd = 0;
          outfp = stdout;
        }
        infp=fdopen(infd, "r");
        if(infp == ((struct _IO_FILE *)NULL))
        {
          aflog((char)4, (char)1, "Error in opening file descriptor for reading");
          return 1;
        }

        else
        {
          length = (signed int)buff[(signed long int)3];
          length = length << 8;
          length = length + (signed int)buff[(signed long int)4];
          n=SslFd_get_message(type, master, buff, length);
          buff[(signed long int)n] = (unsigned char)0;
          fprintf(outfp, "%s\n", (char *)buff);
          fflush(outfp);
          do
          {
            signed int __d0;
            signed int __d1;
            asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$11) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&allset)->__fds_bits[(signed long int)0]) : "memory");
          }
          while((_Bool)0);
          signed int return_value_SslFd_get_fd$1;
          return_value_SslFd_get_fd$1=SslFd_get_fd(master);
          signed int return_value_SslFd_get_fd$2;
          return_value_SslFd_get_fd$2=SslFd_get_fd(master);
          (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd$1 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd$1 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_SslFd_get_fd$2 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
          (&allset)->__fds_bits[(signed long int)(infd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(infd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << infd % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
          signed int return_value_SslFd_get_fd$3;
          return_value_SslFd_get_fd$3=SslFd_get_fd(master);
          if(!(return_value_SslFd_get_fd$3 >= infd))
            tmp_if_expr$5 = infd + 1;

          else
          {
            return_value_SslFd_get_fd$4=SslFd_get_fd(master);
            tmp_if_expr$5 = return_value_SslFd_get_fd$4 + 1;
          }
          maxfdp1 = tmp_if_expr$5;
          if(!(id == ((char *)NULL)))
          {
            buff[(signed long int)0] = (unsigned char)8;
            buff[(signed long int)2] = (unsigned char)0;
            buff[(signed long int)1] = buff[(signed long int)2];
            unsigned long int return_value_strlen$6;
            return_value_strlen$6=strlen(id);
            n = (signed int)return_value_strlen$6;
            memcpy((void *)&buff[(signed long int)5], (const void *)id, (unsigned long int)n);
            buff[(signed long int)3] = (unsigned char)(n >> 8);
            buff[(signed long int)4] = (unsigned char)n;
            SslFd_send_message(type, master, buff, n + 5);
            aflog((char)8, (char)8, "ID SENT: %s", id);
          }

          while((_Bool)1)
          {
            rset = allset;
            select(maxfdp1, &rset, (struct anonymous$11 *)(void *)0, (struct anonymous$11 *)(void *)0, (struct timeval *)(void *)0);
            signed int return_value_SslFd_get_fd$10;
            return_value_SslFd_get_fd$10=SslFd_get_fd(master);
            signed int return_value_SslFd_get_fd$11;
            return_value_SslFd_get_fd$11=SslFd_get_fd(master);
            if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd$10 / 8)] & 1l << return_value_SslFd_get_fd$11 % 8) == 0l))
            {
              aflog((char)8, (char)2, "masterfd: FD_ISSET");
              n=SslFd_get_message(type, master, buff, 5);
              if(!(n == 5))
              {
                aflog((char)8, (char)64, "FATAL ERROR! (%d)", n);
                if(n == -1)
                {
                  if(!((4 & (signed int)type) == 0))
                  {
                    get_ssl_error(master, "FE", n);
                    continue;
                  }

                }

                if(!(n == 0))
                  return 1;

              }

              if(n == 0)
              {
                aflog((char)8, (char)1, "SERVER: premature quit --> exiting...");
                return 1;
              }

              if((signed int)*buff == 4)
              {
                signed long int return_value_getcg$7;
                return_value_getcg$7=getcg();
                aflog((char)8, (char)1, "SERVER: CLOSED -> exiting... cg: %ld bytes", return_value_getcg$7);
                return 0;
              }

              if(!((signed int)*buff == 15))
              {
                aflog((char)8, (char)1, "SERVER: wrong message --> exiting");
                return 1;
              }

              length = (signed int)buff[(signed long int)3];
              length = length << 8;
              length = length + (signed int)buff[(signed long int)4];
              switch((signed int)buff[(signed long int)1])
              {
                case 3:
                  aflog((char)8, (char)8, "SERVER: cmd successful");
                case 5:
                  if((signed int)buff[1l] == 5)
                    aflog((char)8, (char)8, "SERVER: cmd failed");

                case 0:
                {
                  if((signed int)buff[1l] == 0)
                    aflog((char)8, (char)32, "SERVER: unknown cmd");

                  n=SslFd_get_message(type, master, buff, length);
                  buff[(signed long int)n] = (unsigned char)0;
                  fprintf(outfp, "%s", (char *)buff);
                  fflush(outfp);
                  break;
                }
                case 6:
                {
                  return_value_getcg$8=getcg();
                  aflog((char)8, (char)64, "SERVER: kicked us -> exiting... cg: %ld bytes", return_value_getcg$8);
                  return 1;
                }
                default:
                {
                  return_value_getcg$9=getcg();
                  aflog((char)8, (char)64, "SERVER: unrecognized message -> exiting... cg: %ld bytes", return_value_getcg$9);
                  return 1;
                }
              }
            }

            if(!((rset.__fds_bits[(signed long int)(infd / 8)] & 1l << infd % 8) == 0l))
            {
              aflog((char)8, (char)2, "infd: FD_ISSET");
              char *return_value_fgets$13;
              return_value_fgets$13=fgets((char *)&buff[(signed long int)5], 8091, infp);
              if(return_value_fgets$13 == ((char *)NULL))
              {
                signed long int return_value_getcg$12;
                return_value_getcg$12=getcg();
                aflog((char)8, (char)16, "CLIENT CLOSED cg: %ld bytes", return_value_getcg$12);
                return 0;
              }

              unsigned long int return_value_strlen$14;
              return_value_strlen$14=strlen((char *)&buff[(signed long int)5]);
              n = (signed int)return_value_strlen$14;
              if(n >= 1)
              {
                if((signed int)buff[(signed long int)(4 + n)] == 10)
                  n = n - 1;

              }

              buff[(signed long int)0] = (unsigned char)15;
              buff[(signed long int)1] = (unsigned char)1;
              buff[(signed long int)2] = (unsigned char)0;
              buff[(signed long int)3] = (unsigned char)(n >> 8);
              buff[(signed long int)4] = (unsigned char)n;
              SslFd_send_message(type, master, buff, n + 5);
            }

          }
        }
      }
}

// client_long_usage
// file usage.h line 27
void client_long_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf(" Basic options:\n\n");
  printf("  -n, --servername    - where the second part of the active\n");
  printf("                        port forwarder is running (required)\n");
  printf("  -m, --manageport    - manage port number - server must be\n");
  printf("                        listening on it (default: 50126)\n");
  printf("  -d, --hostname      - the name of this host/remote host - the final\n");
  printf("                        destination of the packets (default: the name\n");
  printf("                        returned by hostname function)\n");
  printf("  -p, --portnum       - the port we are forwarding connection to (required)\n");
  printf("  --localname         - local machine name for connection with afserver\n");
  printf("                        (used to bind socket to different interfaces)\n");
  printf("  --localport         - local port name for connection with afserver\n");
  printf("                        (used to bind socket to different addressees)\n");
  printf("  --localdesname      - local machine name for connections with destination\n");
  printf("                        application (used to bind socket to different interfaces)\n");
  printf("  -V, --version       - display version number\n");
  printf("  -h, --help          - prints this help\n\n");
  printf(" Authorization:\n\n");
  printf("  -i, --id            - sends the id string to afserver\n");
  printf("  --pass              - set the password used for client identification\n");
  printf("                        (default: no password)\n");
  printf("  --ignorepkeys       - ignore invalid server's public keys\n\n");
  printf(" Configuration:\n\n");
  printf("  -k, --keyfile       - the name of the file with RSA key (default: client.rsa)\n");
  printf("  -c, --cerfile       - the name of the file with certificate\n");
  printf("                        (default: no certificate used)\n");
  printf("  -f, --cfgfile       - the name of the file with the configuration for the\n");
  printf("                        active forwarder (client)\n");
  printf("  -s, --storefile     - the name of the file with stored public keys\n");
  printf("                        (default: known_hosts)\n");
  printf("  -D, --dateformat    - format of the date printed in logs (see 'man strftime'\n");
  printf("                        for details) (default: %%Y-%%m-%%d %%H:%%M:%%S)\n");
  printf("  -K, --keep-alive N  - send keepalive packets every N seconds\n");
  printf("                        (default: not send keepalive packets)\n\n");
  printf(" Auto-reconnection:\n\n");
  printf("  --ar-start          - enable auto-reconnection when afserver is not\n");
  printf("                        reachable on start (default: disabled)\n");
  printf("  --ar-quit           - enable auto-reconnection after normal afserver quit\n");
  printf("                        (default: disabled)\n");
  printf("  --noar              - disable auto-reconnection after premature afserver\n");
  printf("                        quit (default: enabled)\n");
  printf("  -A, --ar-tries N    - try N times to reconnect (default: unlimited)\n");
  printf("  -T, --ar-delay N    - wait N seconds between reconnect tries (default: 5)\n\n");
  printf(" Modes:\n\n");
  printf("  -u, --udpmode       - udp mode - client will use udp protocol to\n");
  printf("                        communicate with the hostname:portnum\n");
  printf("  -U, --reverseudp    - reverse udp forwarding. Udp packets will be forwarded\n");
  printf("                        from hostname:portnum to the server name:manageport\n");
  printf("  -r, --remoteadmin   - remote administration mode. (using '-p #port' will\n");
  printf("                        force afclient to use port rather than stdin-stdout)\n\n");
  printf(" Logging:\n\n");
  printf("  -o, --log           - log choosen information to file/socket\n");
  printf("  -v, --verbose       - to be verbose - program won't enter the daemon mode\n");
  printf("                        (use several times for greater effect)\n\n");
  printf(" IP family:\n\n");
  printf("  -4, --ipv4          - use ipv4 only\n");
  printf("  -6, --ipv6          - use ipv6 only\n\n");
  printf(" Modules:\n\n");
  printf("  -l, --load          - load a module for user's packets filtering\n");
  printf("  -L, --Load          - load a module for service's packets filtering\n\n");
  printf(" HTTP/HTTPS PROXY:\n\n");
  printf("  -S, --use-https     - use https proxy instead of http proxy\n");
  printf("  -P, --proxyname     - the name of the machine with proxy server\n");
  printf("  -X, --proxyport     - the port used by proxy server (default: 8080)\n");
  printf("  -C, --pa-cred  U:P  - the user (U) and password (P) used in proxy\n");
  printf("                        authorization\n");
  printf("  -B, --pa-t-basic    - the Basic type of proxy authorization (default)\n\n");
  exit(0);
}

// client_reverse_udp
// file client_reverse_udp.h line 39
void client_reverse_udp(struct anonymous$5 *cr, unsigned char *buff, signed int buflength)
{
  unsigned int len;
  unsigned int addrlen;
  signed int maxfdp1;
  signed int temp;
  signed int n;
  signed int length;
  signed int notsent;
  struct sockaddr *cliaddr;
  struct anonymous$11 rset;
  struct anonymous$11 allset;
  char *return_value_ClientRealm_get_hostName$8;
  return_value_ClientRealm_get_hostName$8=ClientRealm_get_hostName(cr);
  struct portlist *return_value_ClientRealm_get_destinationPorts$9;
  return_value_ClientRealm_get_destinationPorts$9=ClientRealm_get_destinationPorts(cr);
  struct plnode *return_value_PortList_get_nth$10;
  return_value_PortList_get_nth$10=PortList_get_nth(return_value_ClientRealm_get_destinationPorts$9, 0);
  char *return_value_PortListNode_get_portName$11;
  return_value_PortListNode_get_portName$11=PortListNode_get_portName(return_value_PortList_get_nth$10);
  char return_value_ClientRealm_get_ipFamily$12;
  return_value_ClientRealm_get_ipFamily$12=ClientRealm_get_ipFamily(cr);
  signed int return_value_ip_listen$13;
  return_value_ip_listen$13=ip_listen(&temp, return_value_ClientRealm_get_hostName$8, return_value_PortListNode_get_portName$11, &addrlen, (const char)((signed int)return_value_ClientRealm_get_ipFamily$12 & 0xfe));
  char *tmp_if_expr$3;
  char return_value_ClientRealm_get_ipFamily$2;
  if(!(return_value_ip_listen$13 == 0))
  {
    char return_value_ClientRealm_get_ipFamily$1;
    return_value_ClientRealm_get_ipFamily$1=ClientRealm_get_ipFamily(cr);
    if(!((0x02 & (signed int)return_value_ClientRealm_get_ipFamily$1) == 0))
      tmp_if_expr$3 = "ipv4";

    else
    {
      return_value_ClientRealm_get_ipFamily$2=ClientRealm_get_ipFamily(cr);
      tmp_if_expr$3 = ((signed int)return_value_ClientRealm_get_ipFamily$2 & 0x04) != 0 ? "ipv6" : "unspec";
    }
    char *return_value_ClientRealm_get_hostName$4;
    return_value_ClientRealm_get_hostName$4=ClientRealm_get_hostName(cr);
    struct portlist *return_value_ClientRealm_get_destinationPorts$5;
    return_value_ClientRealm_get_destinationPorts$5=ClientRealm_get_destinationPorts(cr);
    struct plnode *return_value_PortList_get_nth$6;
    return_value_PortList_get_nth$6=PortList_get_nth(return_value_ClientRealm_get_destinationPorts$5, 0);
    char *return_value_PortListNode_get_portName$7;
    return_value_PortListNode_get_portName$7=PortListNode_get_portName(return_value_PortList_get_nth$6);
    aflog((char)4, (char)2, "udp_listen_%s error for %s, %s", tmp_if_expr$3, return_value_ClientRealm_get_hostName$4, return_value_PortListNode_get_portName$7);
    exit(1);
  }

  struct anonymous$7 **return_value_ClientRealm_get_usersTable$14;
  return_value_ClientRealm_get_usersTable$14=ClientRealm_get_usersTable(cr);
  ConnectUser_set_connFd(return_value_ClientRealm_get_usersTable$14[(signed long int)0], temp);
  void *return_value_malloc$15;
  return_value_malloc$15=malloc((unsigned long int)addrlen);
  cliaddr = (struct sockaddr *)return_value_malloc$15;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$11) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&allset)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$16;
  return_value_ClientRealm_get_masterSslFd$16=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd$17;
  return_value_SslFd_get_fd$17=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$16);
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$18;
  return_value_ClientRealm_get_masterSslFd$18=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd$19;
  return_value_SslFd_get_fd$19=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$18);
  (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd$17 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd$17 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_SslFd_get_fd$19 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$20;
  return_value_ClientRealm_get_masterSslFd$20=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd$21;
  return_value_SslFd_get_fd$21=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$20);
  maxfdp1 = return_value_SslFd_get_fd$21 + 1;
  struct anonymous$7 **return_value_ClientRealm_get_usersTable$22;
  return_value_ClientRealm_get_usersTable$22=ClientRealm_get_usersTable(cr);
  signed int return_value_ConnectUser_get_connFd$23;
  return_value_ConnectUser_get_connFd$23=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable$22[(signed long int)0]);
  signed int tmp_if_expr$26;
  struct anonymous$7 **return_value_ClientRealm_get_usersTable$24;
  signed int return_value_ConnectUser_get_connFd$25;
  if(!(1 + return_value_ConnectUser_get_connFd$23 >= maxfdp1))
    tmp_if_expr$26 = maxfdp1;

  else
  {
    return_value_ClientRealm_get_usersTable$24=ClientRealm_get_usersTable(cr);
    return_value_ConnectUser_get_connFd$25=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable$24[(signed long int)0]);
    tmp_if_expr$26 = return_value_ConnectUser_get_connFd$25 + 1;
  }
  maxfdp1 = tmp_if_expr$26;
  struct anonymous$7 **return_value_ClientRealm_get_usersTable$27;
  return_value_ClientRealm_get_usersTable$27=ClientRealm_get_usersTable(cr);
  signed int return_value_ConnectUser_get_connFd$28;
  return_value_ConnectUser_get_connFd$28=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable$27[(signed long int)0]);
  struct anonymous$7 **return_value_ClientRealm_get_usersTable$29;
  return_value_ClientRealm_get_usersTable$29=ClientRealm_get_usersTable(cr);
  signed int return_value_ConnectUser_get_connFd$30;
  return_value_ConnectUser_get_connFd$30=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable$29[(signed long int)0]);
  (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$28 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$28 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd$30 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  aflog((char)2, (char)8, "CLIENT STARTED mode: udp reverse");
  _Bool tmp_if_expr$49;
  _Bool tmp_if_expr$50;
  do
  {
    len = (unsigned int)4;
    struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$31;
    return_value_ClientRealm_get_masterSslFd$31=ClientRealm_get_masterSslFd(cr);
    signed int return_value_SslFd_get_fd$32;
    return_value_SslFd_get_fd$32=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$31);
    signed int return_value_getsockopt$33;
    return_value_getsockopt$33=getsockopt(return_value_SslFd_get_fd$32, 1, 7, (void *)&temp, &len);
    if(!(return_value_getsockopt$33 == -1))
    {
      if(!(temp == buflength))
      {
        buflength = temp;
        aflog((char)2, (char)32, "Send buffer size changed...");
      }

    }

    len = addrlen;
    rset = allset;
    aflog((char)16, (char)2, "select");
    select(maxfdp1, &rset, (struct anonymous$11 *)(void *)0, (struct anonymous$11 *)(void *)0, (struct timeval *)(void *)0);
    aflog((char)16, (char)2, "after select...");
    struct anonymous$7 **return_value_ClientRealm_get_usersTable$43;
    return_value_ClientRealm_get_usersTable$43=ClientRealm_get_usersTable(cr);
    signed int return_value_ConnectUser_get_connFd$44;
    return_value_ConnectUser_get_connFd$44=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable$43[(signed long int)0]);
    struct anonymous$7 **return_value_ClientRealm_get_usersTable$45;
    return_value_ClientRealm_get_usersTable$45=ClientRealm_get_usersTable(cr);
    signed int return_value_ConnectUser_get_connFd$46;
    return_value_ConnectUser_get_connFd$46=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable$45[(signed long int)0]);
    if(!((rset.__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$44 / 8)] & 1l << return_value_ConnectUser_get_connFd$46 % 8) == 0l))
    {
      struct anonymous$7 **return_value_ClientRealm_get_usersTable$34;
      return_value_ClientRealm_get_usersTable$34=ClientRealm_get_usersTable(cr);
      signed int return_value_ConnectUser_get_connFd$35;
      return_value_ConnectUser_get_connFd$35=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable$34[(signed long int)0]);
      signed long int return_value_recvfrom$36;
      return_value_recvfrom$36=recvfrom(return_value_ConnectUser_get_connFd$35, (void *)&buff[(signed long int)5], (unsigned long int)8091, 0, cliaddr, &len);
      n = (signed int)return_value_recvfrom$36;
      aflog((char)16, (char)4, "SIOCOUTQ is defined");
      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$37;
      return_value_ClientRealm_get_masterSslFd$37=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd$38;
      return_value_SslFd_get_fd$38=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$37);
      signed int return_value_ioctl$39;
      return_value_ioctl$39=ioctl(return_value_SslFd_get_fd$38, (unsigned long int)0x5411, &notsent);
      if(!(return_value_ioctl$39 == 0))
      {
        aflog((char)2, (char)1, "ioctl error -> exiting...");
        exit(1);
      }

      if(5 + n + notsent >= buflength)
        aflog((char)2, (char)8, "drop: size:%d, buf:%d, w:%d/%d", n, buflength, notsent, buflength);

      else
        if(n >= 1)
        {
          char *return_value_sock_ntop$40;
          return_value_sock_ntop$40=sock_ntop(cliaddr, len, (char *)(void *)0, (char *)(void *)0, (char)0);
          aflog((char)2, (char)8, "Sending %d bytes to service (w:%d/%d) (FROM:%s)", n, notsent, buflength, return_value_sock_ntop$40);
          buff[(signed long int)0] = (unsigned char)3;
          buff[(signed long int)1] = (unsigned char)8;
          buff[(signed long int)2] = (unsigned char)3;
          buff[(signed long int)3] = (unsigned char)(n >> 8);
          buff[(signed long int)4] = (unsigned char)n;
          struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$41;
          return_value_ClientRealm_get_masterSslFd$41=ClientRealm_get_masterSslFd(cr);
          signed int return_value_SslFd_get_fd$42;
          return_value_SslFd_get_fd$42=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$41);
          writen(return_value_SslFd_get_fd$42, buff, n + 5);
        }

    }

    struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$56;
    return_value_ClientRealm_get_masterSslFd$56=ClientRealm_get_masterSslFd(cr);
    signed int return_value_SslFd_get_fd$57;
    return_value_SslFd_get_fd$57=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$56);
    struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$58;
    return_value_ClientRealm_get_masterSslFd$58=ClientRealm_get_masterSslFd(cr);
    signed int return_value_SslFd_get_fd$59;
    return_value_SslFd_get_fd$59=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$58);
    if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd$57 / 8)] & 1l << return_value_SslFd_get_fd$59 % 8) == 0l))
    {
      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$47;
      return_value_ClientRealm_get_masterSslFd$47=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd$48;
      return_value_SslFd_get_fd$48=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$47);
      n=readn(return_value_SslFd_get_fd$48, buff, 5);
      if(n == 5)
      {
        if(!((signed int)*buff == 3))
          tmp_if_expr$49 = (_Bool)1;

        else
          tmp_if_expr$49 = (signed int)buff[(signed long int)1] != 8 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$49)
          tmp_if_expr$50 = (_Bool)1;

        else
          tmp_if_expr$50 = (signed int)buff[(signed long int)2] != 3 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$50)
        {
          aflog((char)2, (char)1, "Incompatible server type (not udp?) or data corruption -> exiting...");
          exit(1);
        }

        length = (signed int)buff[(signed long int)3];
        length = length << 8;
        length = length + (signed int)buff[(signed long int)4];
        struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$51;
        return_value_ClientRealm_get_masterSslFd$51=ClientRealm_get_masterSslFd(cr);
        signed int return_value_SslFd_get_fd$52;
        return_value_SslFd_get_fd$52=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$51);
        n=readn(return_value_SslFd_get_fd$52, buff, length);
      }

      else
        n = 0;
      if(n == 0)
      {
        aflog((char)2, (char)1, "premature quit of the server -> exiting...");
        exit(1);
      }

      char *return_value_sock_ntop$53;
      return_value_sock_ntop$53=sock_ntop(cliaddr, addrlen, (char *)(void *)0, (char *)(void *)0, (char)0);
      aflog((char)2, (char)8, "Sending %d bytes to user (TO:%s)", n, return_value_sock_ntop$53);
      struct anonymous$7 **return_value_ClientRealm_get_usersTable$54;
      return_value_ClientRealm_get_usersTable$54=ClientRealm_get_usersTable(cr);
      signed int return_value_ConnectUser_get_connFd$55;
      return_value_ConnectUser_get_connFd$55=ConnectUser_get_connFd(return_value_ClientRealm_get_usersTable$54[(signed long int)0]);
      sendto(return_value_ConnectUser_get_connFd$55, (const void *)buff, (unsigned long int)n, 0, cliaddr, addrlen);
    }

  }
  while((_Bool)1);
  exit(0);
}

// client_short_usage
// file usage.h line 26
void client_short_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf("Try `afclient --help' for more information.\n");
  exit(1);
}

// client_sig_alrm
// file client_signals.h line 25
void client_sig_alrm(signed int signo)
{
  aflog((char)16, (char)2, "Received SIGALRM");
}

// client_sig_int
// file client_signals.h line 24
void client_sig_int(signed int signo)
{
  signed int return_value_is_this_a_mainthread$1;
  return_value_is_this_a_mainthread$1=is_this_a_mainthread();
  if(!(return_value_is_this_a_mainthread$1 == 0))
  {
    signed long int return_value_getcg$2;
    return_value_getcg$2=getcg();
    aflog((char)16, (char)16, "CLIENT CLOSED cg: %ld bytes", return_value_getcg$2);
    exit(0);
  }

}

// close_connections
// file client_shutdown.c line 27
void close_connections(signed int usernum, struct anonymous$7 ***contable)
{
  signed int i;
  _Bool tmp_if_expr$4;
  char return_value_ConnectUser_get_state$3;
  if(!(contable == ((struct anonymous$7 ***)NULL)))
  {
    if(!(*contable == ((struct anonymous$7 **)NULL)))
    {
      i = 0;
      for( ; !(i >= usernum); i = i + 1)
      {
        char return_value_ConnectUser_get_state$2;
        return_value_ConnectUser_get_state$2=ConnectUser_get_state((*contable)[(signed long int)i]);
        if((signed int)return_value_ConnectUser_get_state$2 == 7)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_ConnectUser_get_state$3=ConnectUser_get_state((*contable)[(signed long int)i]);
          tmp_if_expr$4 = (signed int)return_value_ConnectUser_get_state$3 == 11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          signed int return_value_ConnectUser_get_connFd$1;
          return_value_ConnectUser_get_connFd$1=ConnectUser_get_connFd((*contable)[(signed long int)i]);
          close(return_value_ConnectUser_get_connFd$1);
        }

        ConnectUser_free(&(*contable)[(signed long int)i]);
      }
      free((void *)*contable);
      *contable = (struct anonymous$7 **)(void *)0;
    }

  }

}

// close_fd
// file http_proxy_functions.c line 248
void close_fd(signed int *fd)
{
  close(*fd);
}

// cparsefile
// file file.h line 38
struct anonymous$4 * cparsefile(char *name, signed int *status)
{
  struct anonymous$4 *cfg;
  struct _IO_FILE *file = (struct _IO_FILE *)(void *)0;
  signed int state;
  signed int i;
  signed int n;
  signed int temp;
  char buff[256l];
  char helpbuf1[256l];
  char helpbuf2[256l];
  char *tmpbuf;
  unsigned char pass[4l] = { (unsigned char)1, (unsigned char)2, (unsigned char)3, (unsigned char)4 };
  *status = 1;
  memset((void *)buff, 0, (unsigned long int)256);
  cfg=ClientConfiguration_new();
  if(cfg == ((struct anonymous$4 *)NULL))
  {
    printf("Can't allocate memory for client configuration... exiting\n");
    exit(1);
  }

  state = 1;
  file=fopen(name, "r");
  signed int return_value_ClientConfiguration_get_realmsNumber$4;
  char *return_value_fgets$10;
  signed int tmp_statement_expression$83;
  signed int tmp_statement_expression$81;
  signed int tmp_statement_expression$79;
  signed int tmp_statement_expression$77;
  signed int tmp_statement_expression$72;
  _Bool tmp_if_expr$76;
  signed int tmp_statement_expression$74;
  signed int tmp_statement_expression$67;
  _Bool tmp_if_expr$71;
  signed int tmp_statement_expression$69;
  signed int tmp_statement_expression$62;
  _Bool tmp_if_expr$66;
  signed int tmp_statement_expression$64;
  signed int tmp_statement_expression$57;
  _Bool tmp_if_expr$61;
  signed int tmp_statement_expression$59;
  signed int tmp_statement_expression$52;
  _Bool tmp_if_expr$56;
  signed int tmp_statement_expression$54;
  signed int tmp_statement_expression$50;
  signed int tmp_statement_expression$48;
  signed int tmp_statement_expression$46;
  signed int tmp_statement_expression$196;
  _Bool tmp_if_expr$200;
  signed int tmp_statement_expression$198;
  signed int tmp_statement_expression$188;
  _Bool tmp_if_expr$192;
  signed int tmp_statement_expression$190;
  _Bool tmp_if_expr$195;
  signed int tmp_statement_expression$193;
  signed int tmp_statement_expression$183;
  _Bool tmp_if_expr$187;
  signed int tmp_statement_expression$185;
  signed int tmp_statement_expression$178;
  _Bool tmp_if_expr$182;
  signed int tmp_statement_expression$180;
  signed int tmp_statement_expression$173;
  _Bool tmp_if_expr$177;
  signed int tmp_statement_expression$175;
  signed int tmp_statement_expression$168;
  _Bool tmp_if_expr$172;
  signed int tmp_statement_expression$170;
  signed int tmp_statement_expression$163;
  _Bool tmp_if_expr$167;
  signed int tmp_statement_expression$165;
  signed int tmp_statement_expression$158;
  _Bool tmp_if_expr$162;
  signed int tmp_statement_expression$160;
  signed int tmp_statement_expression$153;
  _Bool tmp_if_expr$157;
  signed int tmp_statement_expression$155;
  signed int tmp_statement_expression$151;
  signed int tmp_statement_expression$149;
  signed int tmp_statement_expression$147;
  signed int tmp_statement_expression$142;
  _Bool tmp_if_expr$146;
  signed int tmp_statement_expression$144;
  signed int tmp_statement_expression$140;
  signed int tmp_statement_expression$135;
  _Bool tmp_if_expr$139;
  signed int tmp_statement_expression$137;
  signed int tmp_statement_expression$130;
  _Bool tmp_if_expr$134;
  signed int tmp_statement_expression$132;
  signed int tmp_statement_expression$125;
  _Bool tmp_if_expr$129;
  signed int tmp_statement_expression$127;
  signed int tmp_statement_expression$120;
  _Bool tmp_if_expr$124;
  signed int tmp_statement_expression$122;
  signed int tmp_statement_expression$115;
  _Bool tmp_if_expr$119;
  signed int tmp_statement_expression$117;
  signed int tmp_statement_expression$110;
  _Bool tmp_if_expr$114;
  signed int tmp_statement_expression$112;
  if(file == ((struct _IO_FILE *)NULL))
    return cfg;

  else
  {
    ClientConfiguration_set_realmsNumber(cfg, 1);
    signed int return_value_ClientConfiguration_get_realmsNumber$1;
    return_value_ClientConfiguration_get_realmsNumber$1=ClientConfiguration_get_realmsNumber(cfg);
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)return_value_ClientConfiguration_get_realmsNumber$1, sizeof(struct anonymous$5 *) /*8ul*/ );
    ClientConfiguration_set_realmsTable(cfg, (struct anonymous$5 **)return_value_calloc$2);
    struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$3;
    return_value_ClientConfiguration_get_realmsTable$3=ClientConfiguration_get_realmsTable(cfg);
    if(return_value_ClientConfiguration_get_realmsTable$3 == ((struct anonymous$5 **)NULL))
    {
      printf("Can't allocate memory for ClientRealm* table... exiting\n");
      exit(1);
    }

    i = 0;
    do
    {
      return_value_ClientConfiguration_get_realmsNumber$4=ClientConfiguration_get_realmsNumber(cfg);
      if(i >= return_value_ClientConfiguration_get_realmsNumber$4)
        break;

      struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$5;
      return_value_ClientConfiguration_get_realmsTable$5=ClientConfiguration_get_realmsTable(cfg);
      return_value_ClientConfiguration_get_realmsTable$5[(signed long int)i]=ClientRealm_new();
      struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$6;
      return_value_ClientConfiguration_get_realmsTable$6=ClientConfiguration_get_realmsTable(cfg);
      if(return_value_ClientConfiguration_get_realmsTable$6[(signed long int)i] == ((struct anonymous$5 *)NULL))
      {
        printf("Problem with allocating memory for ClientRealm structure... exiting");
        exit(1);
      }

      struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$7;
      return_value_ClientConfiguration_get_realmsTable$7=ClientConfiguration_get_realmsTable(cfg);
      ClientRealm_set_password(return_value_ClientConfiguration_get_realmsTable$7[(signed long int)i], pass);
      struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$8;
      return_value_ClientConfiguration_get_realmsTable$8=ClientConfiguration_get_realmsTable(cfg);
      struct portlist *return_value_PortList_new$9;
      return_value_PortList_new$9=PortList_new();
      ClientRealm_set_destinationPorts(return_value_ClientConfiguration_get_realmsTable$8[(signed long int)i], return_value_PortList_new$9);
      i = i + 1;
    }
    while((_Bool)1);
    *status = 0;
    do
    {
      return_value_fgets$10=fgets(buff, 256, file);
      if(return_value_fgets$10 == ((char *)NULL))
        break;

      *status = *status + 1;
      state=parse_line(buff, helpbuf1, helpbuf2);
      if((signed int)helpbuf1[0l] == 35)
        memset((void *)buff, 0, (unsigned long int)256);

      else
      {
        if(state == 1)
        {
          unsigned long int cparsefile$$1$$5$$2$$1$$__s1_len;
          unsigned long int cparsefile$$1$$5$$2$$1$$__s2_len;
          signed int return_value___builtin_strcmp$84;
          return_value___builtin_strcmp$84=__builtin_strcmp(helpbuf1, "ignorepkeys");
          tmp_statement_expression$83 = return_value___builtin_strcmp$84;
          if(tmp_statement_expression$83 == 0)
            ClientConfiguration_set_ignorePublicKeys(cfg, (char)1);

          else
          {
            unsigned long int cparsefile$$1$$5$$2$$3$$__s1_len;
            unsigned long int cparsefile$$1$$5$$2$$3$$__s2_len;
            signed int return_value___builtin_strcmp$82;
            return_value___builtin_strcmp$82=__builtin_strcmp(helpbuf1, "ar-start");
            tmp_statement_expression$81 = return_value___builtin_strcmp$82;
            if(tmp_statement_expression$81 == 0)
            {
              struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$11;
              return_value_ClientConfiguration_get_realmsTable$11=ClientConfiguration_get_realmsTable(cfg);
              struct anonymous$3 *return_value_ClientRealm_get_arOptions$12;
              return_value_ClientRealm_get_arOptions$12=ClientRealm_get_arOptions(return_value_ClientConfiguration_get_realmsTable$11[(signed long int)0]);
              ArOptions_set_arStart(return_value_ClientRealm_get_arOptions$12, (char)1);
            }

            else
            {
              unsigned long int cparsefile$$1$$5$$2$$5$$__s1_len;
              unsigned long int cparsefile$$1$$5$$2$$5$$__s2_len;
              signed int return_value___builtin_strcmp$80;
              return_value___builtin_strcmp$80=__builtin_strcmp(helpbuf1, "ar-quit");
              tmp_statement_expression$79 = return_value___builtin_strcmp$80;
              if(tmp_statement_expression$79 == 0)
              {
                struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$13;
                return_value_ClientConfiguration_get_realmsTable$13=ClientConfiguration_get_realmsTable(cfg);
                struct anonymous$3 *return_value_ClientRealm_get_arOptions$14;
                return_value_ClientRealm_get_arOptions$14=ClientRealm_get_arOptions(return_value_ClientConfiguration_get_realmsTable$13[(signed long int)0]);
                ArOptions_set_arQuit(return_value_ClientRealm_get_arOptions$14, (char)1);
              }

              else
              {
                unsigned long int cparsefile$$1$$5$$2$$7$$__s1_len;
                unsigned long int cparsefile$$1$$5$$2$$7$$__s2_len;
                signed int return_value___builtin_strcmp$78;
                return_value___builtin_strcmp$78=__builtin_strcmp(helpbuf1, "noar");
                tmp_statement_expression$77 = return_value___builtin_strcmp$78;
                if(tmp_statement_expression$77 == 0)
                {
                  struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$15;
                  return_value_ClientConfiguration_get_realmsTable$15=ClientConfiguration_get_realmsTable(cfg);
                  struct anonymous$3 *return_value_ClientRealm_get_arOptions$16;
                  return_value_ClientRealm_get_arOptions$16=ClientRealm_get_arOptions(return_value_ClientConfiguration_get_realmsTable$15[(signed long int)0]);
                  ArOptions_set_arPremature(return_value_ClientRealm_get_arOptions$16, (char)0);
                }

                else
                {
                  unsigned long int cparsefile$$1$$5$$2$$9$$__s1_len;
                  unsigned long int cparsefile$$1$$5$$2$$9$$__s2_len;
                  signed int return_value___builtin_strcmp$73;
                  return_value___builtin_strcmp$73=__builtin_strcmp(helpbuf1, "u");
                  tmp_statement_expression$72 = return_value___builtin_strcmp$73;
                  if(tmp_statement_expression$72 == 0)
                    tmp_if_expr$76 = (_Bool)1;

                  else
                  {
                    unsigned long int cparsefile$$1$$5$$2$$10$$__s1_len;
                    unsigned long int cparsefile$$1$$5$$2$$10$$__s2_len;
                    signed int return_value___builtin_strcmp$75;
                    return_value___builtin_strcmp$75=__builtin_strcmp(helpbuf1, "udpmode");
                    tmp_statement_expression$74 = return_value___builtin_strcmp$75;
                    tmp_if_expr$76 = tmp_statement_expression$74 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$76)
                  {
                    struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$19;
                    return_value_ClientConfiguration_get_realmsTable$19=ClientConfiguration_get_realmsTable(cfg);
                    signed int return_value_ClientRealm_get_clientMode$20;
                    return_value_ClientRealm_get_clientMode$20=ClientRealm_get_clientMode(return_value_ClientConfiguration_get_realmsTable$19[(signed long int)0]);
                    if(return_value_ClientRealm_get_clientMode$20 == 0)
                    {
                      struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$17;
                      return_value_ClientConfiguration_get_realmsTable$17=ClientConfiguration_get_realmsTable(cfg);
                      ClientRealm_set_clientMode(return_value_ClientConfiguration_get_realmsTable$17[(signed long int)0], 1);
                    }

                    else
                    {
                      struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$18;
                      return_value_ClientConfiguration_get_realmsTable$18=ClientConfiguration_get_realmsTable(cfg);
                      ClientRealm_set_clientMode(return_value_ClientConfiguration_get_realmsTable$18[(signed long int)0], -1);
                    }
                  }

                  else
                  {
                    unsigned long int cparsefile$$1$$5$$2$$12$$__s1_len;
                    unsigned long int cparsefile$$1$$5$$2$$12$$__s2_len;
                    signed int return_value___builtin_strcmp$68;
                    return_value___builtin_strcmp$68=__builtin_strcmp(helpbuf1, "U");
                    tmp_statement_expression$67 = return_value___builtin_strcmp$68;
                    if(tmp_statement_expression$67 == 0)
                      tmp_if_expr$71 = (_Bool)1;

                    else
                    {
                      unsigned long int cparsefile$$1$$5$$2$$13$$__s1_len;
                      unsigned long int cparsefile$$1$$5$$2$$13$$__s2_len;
                      signed int return_value___builtin_strcmp$70;
                      return_value___builtin_strcmp$70=__builtin_strcmp(helpbuf1, "reverseudp");
                      tmp_statement_expression$69 = return_value___builtin_strcmp$70;
                      tmp_if_expr$71 = tmp_statement_expression$69 == 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr$71)
                    {
                      struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$23;
                      return_value_ClientConfiguration_get_realmsTable$23=ClientConfiguration_get_realmsTable(cfg);
                      signed int return_value_ClientRealm_get_clientMode$24;
                      return_value_ClientRealm_get_clientMode$24=ClientRealm_get_clientMode(return_value_ClientConfiguration_get_realmsTable$23[(signed long int)0]);
                      if(return_value_ClientRealm_get_clientMode$24 == 0)
                      {
                        struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$21;
                        return_value_ClientConfiguration_get_realmsTable$21=ClientConfiguration_get_realmsTable(cfg);
                        ClientRealm_set_clientMode(return_value_ClientConfiguration_get_realmsTable$21[(signed long int)0], 3);
                      }

                      else
                      {
                        struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$22;
                        return_value_ClientConfiguration_get_realmsTable$22=ClientConfiguration_get_realmsTable(cfg);
                        ClientRealm_set_clientMode(return_value_ClientConfiguration_get_realmsTable$22[(signed long int)0], -1);
                      }
                    }

                    else
                    {
                      unsigned long int cparsefile$$1$$5$$2$$15$$__s1_len;
                      unsigned long int cparsefile$$1$$5$$2$$15$$__s2_len;
                      signed int return_value___builtin_strcmp$63;
                      return_value___builtin_strcmp$63=__builtin_strcmp(helpbuf1, "r");
                      tmp_statement_expression$62 = return_value___builtin_strcmp$63;
                      if(tmp_statement_expression$62 == 0)
                        tmp_if_expr$66 = (_Bool)1;

                      else
                      {
                        unsigned long int cparsefile$$1$$5$$2$$16$$__s1_len;
                        unsigned long int cparsefile$$1$$5$$2$$16$$__s2_len;
                        signed int return_value___builtin_strcmp$65;
                        return_value___builtin_strcmp$65=__builtin_strcmp(helpbuf1, "remoteadmin");
                        tmp_statement_expression$64 = return_value___builtin_strcmp$65;
                        tmp_if_expr$66 = tmp_statement_expression$64 == 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr$66)
                      {
                        struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$27;
                        return_value_ClientConfiguration_get_realmsTable$27=ClientConfiguration_get_realmsTable(cfg);
                        signed int return_value_ClientRealm_get_clientMode$28;
                        return_value_ClientRealm_get_clientMode$28=ClientRealm_get_clientMode(return_value_ClientConfiguration_get_realmsTable$27[(signed long int)0]);
                        if(return_value_ClientRealm_get_clientMode$28 == 0)
                        {
                          struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$25;
                          return_value_ClientConfiguration_get_realmsTable$25=ClientConfiguration_get_realmsTable(cfg);
                          ClientRealm_set_clientMode(return_value_ClientConfiguration_get_realmsTable$25[(signed long int)0], 2);
                        }

                        else
                        {
                          struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$26;
                          return_value_ClientConfiguration_get_realmsTable$26=ClientConfiguration_get_realmsTable(cfg);
                          ClientRealm_set_clientMode(return_value_ClientConfiguration_get_realmsTable$26[(signed long int)0], -1);
                        }
                      }

                      else
                      {
                        unsigned long int __s1_len;
                        unsigned long int __s2_len;
                        signed int return_value___builtin_strcmp$58;
                        return_value___builtin_strcmp$58=__builtin_strcmp(helpbuf1, "S");
                        tmp_statement_expression$57 = return_value___builtin_strcmp$58;
                        if(tmp_statement_expression$57 == 0)
                          tmp_if_expr$61 = (_Bool)1;

                        else
                        {
                          unsigned long int cparsefile$$1$$5$$2$$19$$__s1_len;
                          unsigned long int cparsefile$$1$$5$$2$$19$$__s2_len;
                          signed int return_value___builtin_strcmp$60;
                          return_value___builtin_strcmp$60=__builtin_strcmp(helpbuf1, "use-https");
                          tmp_statement_expression$59 = return_value___builtin_strcmp$60;
                          tmp_if_expr$61 = tmp_statement_expression$59 == 0 ? (_Bool)1 : (_Bool)0;
                        }
                        if(tmp_if_expr$61)
                        {
                          struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$29;
                          return_value_ClientConfiguration_get_realmsTable$29=ClientConfiguration_get_realmsTable(cfg);
                          struct anonymous *return_value_ClientRealm_get_httpProxyOptions$30;
                          return_value_ClientRealm_get_httpProxyOptions$30=ClientRealm_get_httpProxyOptions(return_value_ClientConfiguration_get_realmsTable$29[(signed long int)0]);
                          HttpProxyOptions_use_https(return_value_ClientRealm_get_httpProxyOptions$30);
                        }

                        else
                        {
                          unsigned long int cparsefile$$1$$5$$2$$21$$__s1_len;
                          unsigned long int cparsefile$$1$$5$$2$$21$$__s2_len;
                          signed int return_value___builtin_strcmp$53;
                          return_value___builtin_strcmp$53=__builtin_strcmp(helpbuf1, "B");
                          tmp_statement_expression$52 = return_value___builtin_strcmp$53;
                          if(tmp_statement_expression$52 == 0)
                            tmp_if_expr$56 = (_Bool)1;

                          else
                          {
                            unsigned long int cparsefile$$1$$5$$2$$22$$__s1_len;
                            unsigned long int cparsefile$$1$$5$$2$$22$$__s2_len;
                            signed int return_value___builtin_strcmp$55;
                            return_value___builtin_strcmp$55=__builtin_strcmp(helpbuf1, "pa-t-basic");
                            tmp_statement_expression$54 = return_value___builtin_strcmp$55;
                            tmp_if_expr$56 = tmp_statement_expression$54 == 0 ? (_Bool)1 : (_Bool)0;
                          }
                          if(tmp_if_expr$56)
                          {
                            struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$31;
                            return_value_ClientConfiguration_get_realmsTable$31=ClientConfiguration_get_realmsTable(cfg);
                            struct anonymous *return_value_ClientRealm_get_httpProxyOptions$32;
                            return_value_ClientRealm_get_httpProxyOptions$32=ClientRealm_get_httpProxyOptions(return_value_ClientConfiguration_get_realmsTable$31[(signed long int)0]);
                            HttpProxyOptions_set_proxyauth_type(return_value_ClientRealm_get_httpProxyOptions$32, (char)1);
                          }

                          else
                          {
                            unsigned long int cparsefile$$1$$5$$2$$24$$__s1_len;
                            unsigned long int cparsefile$$1$$5$$2$$24$$__s2_len;
                            signed int return_value___builtin_strcmp$51;
                            return_value___builtin_strcmp$51=__builtin_strcmp(helpbuf1, "enableproxy");
                            tmp_statement_expression$50 = return_value___builtin_strcmp$51;
                            if(tmp_statement_expression$50 == 0)
                            {
                              struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$34;
                              return_value_ClientConfiguration_get_realmsTable$34=ClientConfiguration_get_realmsTable(cfg);
                              char return_value_ClientRealm_get_tunnelType$35;
                              return_value_ClientRealm_get_tunnelType$35=ClientRealm_get_tunnelType(return_value_ClientConfiguration_get_realmsTable$34[(signed long int)0]);
                              if((signed int)return_value_ClientRealm_get_tunnelType$35 == 0)
                              {
                                struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$33;
                                return_value_ClientConfiguration_get_realmsTable$33=ClientConfiguration_get_realmsTable(cfg);
                                ClientRealm_set_tunnelType(return_value_ClientConfiguration_get_realmsTable$33[(signed long int)0], (char)1);
                              }

                              else
                                return cfg;
                            }

                            else
                            {
                              unsigned long int cparsefile$$1$$5$$2$$26$$__s1_len;
                              unsigned long int cparsefile$$1$$5$$2$$26$$__s2_len;
                              signed int return_value___builtin_strcmp$49;
                              return_value___builtin_strcmp$49=__builtin_strcmp(helpbuf1, "ipv4");
                              tmp_statement_expression$48 = return_value___builtin_strcmp$49;
                              if(tmp_statement_expression$48 == 0)
                              {
                                struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$39;
                                return_value_ClientConfiguration_get_realmsTable$39=ClientConfiguration_get_realmsTable(cfg);
                                char return_value_ClientRealm_get_realmType$40;
                                return_value_ClientRealm_get_realmType$40=ClientRealm_get_realmType(return_value_ClientConfiguration_get_realmsTable$39[(signed long int)0]);
                                if((48 & (signed int)return_value_ClientRealm_get_realmType$40) == 0)
                                {
                                  struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$36;
                                  return_value_ClientConfiguration_get_realmsTable$36=ClientConfiguration_get_realmsTable(cfg);
                                  char return_value_ClientRealm_get_realmType$37;
                                  return_value_ClientRealm_get_realmType$37=ClientRealm_get_realmType(return_value_ClientConfiguration_get_realmsTable$36[(signed long int)0]);
                                  temp = (signed int)return_value_ClientRealm_get_realmType$37;
                                  temp = temp | 16;
                                  struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$38;
                                  return_value_ClientConfiguration_get_realmsTable$38=ClientConfiguration_get_realmsTable(cfg);
                                  ClientRealm_set_realmType(return_value_ClientConfiguration_get_realmsTable$38[(signed long int)0], (char)temp);
                                }

                                else
                                  return cfg;
                              }

                              else
                              {
                                unsigned long int cparsefile$$1$$5$$2$$28$$__s1_len;
                                unsigned long int cparsefile$$1$$5$$2$$28$$__s2_len;
                                signed int return_value___builtin_strcmp$47;
                                return_value___builtin_strcmp$47=__builtin_strcmp(helpbuf1, "ipv6");
                                tmp_statement_expression$46 = return_value___builtin_strcmp$47;
                                if(tmp_statement_expression$46 == 0)
                                {
                                  struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$44;
                                  return_value_ClientConfiguration_get_realmsTable$44=ClientConfiguration_get_realmsTable(cfg);
                                  char return_value_ClientRealm_get_realmType$45;
                                  return_value_ClientRealm_get_realmType$45=ClientRealm_get_realmType(return_value_ClientConfiguration_get_realmsTable$44[(signed long int)0]);
                                  if((48 & (signed int)return_value_ClientRealm_get_realmType$45) == 0)
                                  {
                                    struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$41;
                                    return_value_ClientConfiguration_get_realmsTable$41=ClientConfiguration_get_realmsTable(cfg);
                                    char return_value_ClientRealm_get_realmType$42;
                                    return_value_ClientRealm_get_realmType$42=ClientRealm_get_realmType(return_value_ClientConfiguration_get_realmsTable$41[(signed long int)0]);
                                    temp = (signed int)return_value_ClientRealm_get_realmType$42;
                                    temp = temp | 32;
                                    struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$43;
                                    return_value_ClientConfiguration_get_realmsTable$43=ClientConfiguration_get_realmsTable(cfg);
                                    ClientRealm_set_realmType(return_value_ClientConfiguration_get_realmsTable$43[(signed long int)0], (char)temp);
                                  }

                                  else
                                    return cfg;
                                }

                                else
                                  return cfg;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        else
          if(state == 2)
          {
            unsigned long int cparsefile$$1$$5$$3$$1$$__s1_len;
            unsigned long int cparsefile$$1$$5$$3$$1$$__s2_len;
            signed int return_value___builtin_strcmp$197;
            return_value___builtin_strcmp$197=__builtin_strcmp(helpbuf1, "k");
            tmp_statement_expression$196 = return_value___builtin_strcmp$197;
            if(tmp_statement_expression$196 == 0)
              tmp_if_expr$200 = (_Bool)1;

            else
            {
              unsigned long int cparsefile$$1$$5$$3$$2$$__s1_len;
              unsigned long int cparsefile$$1$$5$$3$$2$$__s2_len;
              signed int return_value___builtin_strcmp$199;
              return_value___builtin_strcmp$199=__builtin_strcmp(helpbuf1, "keyfile");
              tmp_statement_expression$198 = return_value___builtin_strcmp$199;
              tmp_if_expr$200 = tmp_statement_expression$198 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$200)
              ClientConfiguration_set_keysFile(cfg, helpbuf2);

            else
            {
              unsigned long int cparsefile$$1$$5$$3$$4$$__s1_len;
              unsigned long int cparsefile$$1$$5$$3$$4$$__s2_len;
              signed int return_value___builtin_strcmp$189;
              return_value___builtin_strcmp$189=__builtin_strcmp(helpbuf1, "c");
              tmp_statement_expression$188 = return_value___builtin_strcmp$189;
              if(tmp_statement_expression$188 == 0)
                tmp_if_expr$192 = (_Bool)1;

              else
              {
                unsigned long int cparsefile$$1$$5$$3$$5$$__s1_len;
                unsigned long int cparsefile$$1$$5$$3$$5$$__s2_len;
                signed int return_value___builtin_strcmp$191;
                return_value___builtin_strcmp$191=__builtin_strcmp(helpbuf1, "certificate");
                tmp_statement_expression$190 = return_value___builtin_strcmp$191;
                tmp_if_expr$192 = tmp_statement_expression$190 == 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$192)
                tmp_if_expr$195 = (_Bool)1;

              else
              {
                unsigned long int cparsefile$$1$$5$$3$$6$$__s1_len;
                unsigned long int cparsefile$$1$$5$$3$$6$$__s2_len;
                signed int return_value___builtin_strcmp$194;
                return_value___builtin_strcmp$194=__builtin_strcmp(helpbuf1, "cerfile");
                tmp_statement_expression$193 = return_value___builtin_strcmp$194;
                tmp_if_expr$195 = tmp_statement_expression$193 == 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$195)
                ClientConfiguration_set_certificateFile(cfg, helpbuf2);

              else
              {
                unsigned long int cparsefile$$1$$5$$3$$8$$__s1_len;
                unsigned long int cparsefile$$1$$5$$3$$8$$__s2_len;
                signed int return_value___builtin_strcmp$184;
                return_value___builtin_strcmp$184=__builtin_strcmp(helpbuf1, "s");
                tmp_statement_expression$183 = return_value___builtin_strcmp$184;
                if(tmp_statement_expression$183 == 0)
                  tmp_if_expr$187 = (_Bool)1;

                else
                {
                  unsigned long int cparsefile$$1$$5$$3$$9$$__s1_len;
                  unsigned long int cparsefile$$1$$5$$3$$9$$__s2_len;
                  signed int return_value___builtin_strcmp$186;
                  return_value___builtin_strcmp$186=__builtin_strcmp(helpbuf1, "storefile");
                  tmp_statement_expression$185 = return_value___builtin_strcmp$186;
                  tmp_if_expr$187 = tmp_statement_expression$185 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$187)
                  ClientConfiguration_set_storeFile(cfg, helpbuf2);

                else
                {
                  unsigned long int cparsefile$$1$$5$$3$$11$$__s1_len;
                  unsigned long int cparsefile$$1$$5$$3$$11$$__s2_len;
                  signed int return_value___builtin_strcmp$179;
                  return_value___builtin_strcmp$179=__builtin_strcmp(helpbuf1, "o");
                  tmp_statement_expression$178 = return_value___builtin_strcmp$179;
                  if(tmp_statement_expression$178 == 0)
                    tmp_if_expr$182 = (_Bool)1;

                  else
                  {
                    unsigned long int cparsefile$$1$$5$$3$$12$$__s1_len;
                    unsigned long int cparsefile$$1$$5$$3$$12$$__s2_len;
                    signed int return_value___builtin_strcmp$181;
                    return_value___builtin_strcmp$181=__builtin_strcmp(helpbuf1, "log");
                    tmp_statement_expression$180 = return_value___builtin_strcmp$181;
                    tmp_if_expr$182 = tmp_statement_expression$180 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$182)
                  {
                    unsigned long int return_value_strlen$85;
                    return_value_strlen$85=strlen(helpbuf2);
                    void *return_value_calloc$86;
                    return_value_calloc$86=calloc(return_value_strlen$85 + (unsigned long int)1, sizeof(char) /*1ul*/ );
                    tmpbuf = (char *)return_value_calloc$86;
                    strcpy(tmpbuf, helpbuf2);
                    addlogtarget(tmpbuf);
                  }

                  else
                  {
                    unsigned long int cparsefile$$1$$5$$3$$14$$__s1_len;
                    unsigned long int cparsefile$$1$$5$$3$$14$$__s2_len;
                    signed int return_value___builtin_strcmp$174;
                    return_value___builtin_strcmp$174=__builtin_strcmp(helpbuf1, "D");
                    tmp_statement_expression$173 = return_value___builtin_strcmp$174;
                    if(tmp_statement_expression$173 == 0)
                      tmp_if_expr$177 = (_Bool)1;

                    else
                    {
                      unsigned long int cparsefile$$1$$5$$3$$15$$__s1_len;
                      unsigned long int cparsefile$$1$$5$$3$$15$$__s2_len;
                      signed int return_value___builtin_strcmp$176;
                      return_value___builtin_strcmp$176=__builtin_strcmp(helpbuf1, "dateformat");
                      tmp_statement_expression$175 = return_value___builtin_strcmp$176;
                      tmp_if_expr$177 = tmp_statement_expression$175 == 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr$177)
                      ClientConfiguration_set_dateFormat(cfg, helpbuf2);

                    else
                    {
                      unsigned long int cparsefile$$1$$5$$3$$17$$__s1_len;
                      unsigned long int cparsefile$$1$$5$$3$$17$$__s2_len;
                      signed int return_value___builtin_strcmp$169;
                      return_value___builtin_strcmp$169=__builtin_strcmp(helpbuf1, "n");
                      tmp_statement_expression$168 = return_value___builtin_strcmp$169;
                      if(tmp_statement_expression$168 == 0)
                        tmp_if_expr$172 = (_Bool)1;

                      else
                      {
                        unsigned long int cparsefile$$1$$5$$3$$18$$__s1_len;
                        unsigned long int cparsefile$$1$$5$$3$$18$$__s2_len;
                        signed int return_value___builtin_strcmp$171;
                        return_value___builtin_strcmp$171=__builtin_strcmp(helpbuf1, "servername");
                        tmp_statement_expression$170 = return_value___builtin_strcmp$171;
                        tmp_if_expr$172 = tmp_statement_expression$170 == 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr$172)
                      {
                        struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$87;
                        return_value_ClientConfiguration_get_realmsTable$87=ClientConfiguration_get_realmsTable(cfg);
                        ClientRealm_set_serverName(return_value_ClientConfiguration_get_realmsTable$87[(signed long int)0], helpbuf2);
                      }

                      else
                      {
                        unsigned long int cparsefile$$1$$5$$3$$20$$__s1_len;
                        unsigned long int cparsefile$$1$$5$$3$$20$$__s2_len;
                        signed int return_value___builtin_strcmp$164;
                        return_value___builtin_strcmp$164=__builtin_strcmp(helpbuf1, "m");
                        tmp_statement_expression$163 = return_value___builtin_strcmp$164;
                        if(tmp_statement_expression$163 == 0)
                          tmp_if_expr$167 = (_Bool)1;

                        else
                        {
                          unsigned long int cparsefile$$1$$5$$3$$21$$__s1_len;
                          unsigned long int cparsefile$$1$$5$$3$$21$$__s2_len;
                          signed int return_value___builtin_strcmp$166;
                          return_value___builtin_strcmp$166=__builtin_strcmp(helpbuf1, "manageport");
                          tmp_statement_expression$165 = return_value___builtin_strcmp$166;
                          tmp_if_expr$167 = tmp_statement_expression$165 == 0 ? (_Bool)1 : (_Bool)0;
                        }
                        if(tmp_if_expr$167)
                        {
                          struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$88;
                          return_value_ClientConfiguration_get_realmsTable$88=ClientConfiguration_get_realmsTable(cfg);
                          ClientRealm_set_managePort(return_value_ClientConfiguration_get_realmsTable$88[(signed long int)0], helpbuf2);
                        }

                        else
                        {
                          unsigned long int cparsefile$$1$$5$$3$$23$$__s1_len;
                          unsigned long int cparsefile$$1$$5$$3$$23$$__s2_len;
                          signed int return_value___builtin_strcmp$159;
                          return_value___builtin_strcmp$159=__builtin_strcmp(helpbuf1, "d");
                          tmp_statement_expression$158 = return_value___builtin_strcmp$159;
                          if(tmp_statement_expression$158 == 0)
                            tmp_if_expr$162 = (_Bool)1;

                          else
                          {
                            unsigned long int cparsefile$$1$$5$$3$$24$$__s1_len;
                            unsigned long int cparsefile$$1$$5$$3$$24$$__s2_len;
                            signed int return_value___builtin_strcmp$161;
                            return_value___builtin_strcmp$161=__builtin_strcmp(helpbuf1, "hostname");
                            tmp_statement_expression$160 = return_value___builtin_strcmp$161;
                            tmp_if_expr$162 = tmp_statement_expression$160 == 0 ? (_Bool)1 : (_Bool)0;
                          }
                          if(tmp_if_expr$162)
                          {
                            struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$89;
                            return_value_ClientConfiguration_get_realmsTable$89=ClientConfiguration_get_realmsTable(cfg);
                            ClientRealm_set_hostName(return_value_ClientConfiguration_get_realmsTable$89[(signed long int)0], helpbuf2);
                          }

                          else
                          {
                            unsigned long int cparsefile$$1$$5$$3$$26$$__s1_len;
                            unsigned long int cparsefile$$1$$5$$3$$26$$__s2_len;
                            signed int return_value___builtin_strcmp$154;
                            return_value___builtin_strcmp$154=__builtin_strcmp(helpbuf1, "p");
                            tmp_statement_expression$153 = return_value___builtin_strcmp$154;
                            if(tmp_statement_expression$153 == 0)
                              tmp_if_expr$157 = (_Bool)1;

                            else
                            {
                              unsigned long int cparsefile$$1$$5$$3$$27$$__s1_len;
                              unsigned long int cparsefile$$1$$5$$3$$27$$__s2_len;
                              signed int return_value___builtin_strcmp$156;
                              return_value___builtin_strcmp$156=__builtin_strcmp(helpbuf1, "portnum");
                              tmp_statement_expression$155 = return_value___builtin_strcmp$156;
                              tmp_if_expr$157 = tmp_statement_expression$155 == 0 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr$157)
                            {
                              struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$90;
                              return_value_ClientConfiguration_get_realmsTable$90=ClientConfiguration_get_realmsTable(cfg);
                              struct portlist *return_value_ClientRealm_get_destinationPorts$91;
                              return_value_ClientRealm_get_destinationPorts$91=ClientRealm_get_destinationPorts(return_value_ClientConfiguration_get_realmsTable$90[(signed long int)0]);
                              struct plnode *return_value_PortListNode_new$92;
                              return_value_PortListNode_new$92=PortListNode_new(helpbuf2);
                              PortList_insert_back(return_value_ClientRealm_get_destinationPorts$91, return_value_PortListNode_new$92);
                            }

                            else
                            {
                              unsigned long int cparsefile$$1$$5$$3$$29$$__s1_len;
                              unsigned long int cparsefile$$1$$5$$3$$29$$__s2_len;
                              signed int return_value___builtin_strcmp$152;
                              return_value___builtin_strcmp$152=__builtin_strcmp(helpbuf1, "localname");
                              tmp_statement_expression$151 = return_value___builtin_strcmp$152;
                              if(tmp_statement_expression$151 == 0)
                              {
                                struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$93;
                                return_value_ClientConfiguration_get_realmsTable$93=ClientConfiguration_get_realmsTable(cfg);
                                ClientRealm_set_localName(return_value_ClientConfiguration_get_realmsTable$93[(signed long int)0], helpbuf2);
                              }

                              else
                              {
                                unsigned long int cparsefile$$1$$5$$3$$31$$__s1_len;
                                unsigned long int cparsefile$$1$$5$$3$$31$$__s2_len;
                                signed int return_value___builtin_strcmp$150;
                                return_value___builtin_strcmp$150=__builtin_strcmp(helpbuf1, "localport");
                                tmp_statement_expression$149 = return_value___builtin_strcmp$150;
                                if(tmp_statement_expression$149 == 0)
                                {
                                  struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$94;
                                  return_value_ClientConfiguration_get_realmsTable$94=ClientConfiguration_get_realmsTable(cfg);
                                  ClientRealm_set_localPort(return_value_ClientConfiguration_get_realmsTable$94[(signed long int)0], helpbuf2);
                                }

                                else
                                {
                                  unsigned long int cparsefile$$1$$5$$3$$33$$__s1_len;
                                  unsigned long int cparsefile$$1$$5$$3$$33$$__s2_len;
                                  signed int return_value___builtin_strcmp$148;
                                  return_value___builtin_strcmp$148=__builtin_strcmp(helpbuf1, "localdesname");
                                  tmp_statement_expression$147 = return_value___builtin_strcmp$148;
                                  if(tmp_statement_expression$147 == 0)
                                  {
                                    struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$95;
                                    return_value_ClientConfiguration_get_realmsTable$95=ClientConfiguration_get_realmsTable(cfg);
                                    ClientRealm_set_localDestinationName(return_value_ClientConfiguration_get_realmsTable$95[(signed long int)0], helpbuf2);
                                  }

                                  else
                                  {
                                    unsigned long int cparsefile$$1$$5$$3$$35$$__s1_len;
                                    unsigned long int cparsefile$$1$$5$$3$$35$$__s2_len;
                                    signed int return_value___builtin_strcmp$143;
                                    return_value___builtin_strcmp$143=__builtin_strcmp(helpbuf1, "i");
                                    tmp_statement_expression$142 = return_value___builtin_strcmp$143;
                                    if(tmp_statement_expression$142 == 0)
                                      tmp_if_expr$146 = (_Bool)1;

                                    else
                                    {
                                      unsigned long int cparsefile$$1$$5$$3$$36$$__s1_len;
                                      unsigned long int cparsefile$$1$$5$$3$$36$$__s2_len;
                                      signed int return_value___builtin_strcmp$145;
                                      return_value___builtin_strcmp$145=__builtin_strcmp(helpbuf1, "id");
                                      tmp_statement_expression$144 = return_value___builtin_strcmp$145;
                                      tmp_if_expr$146 = tmp_statement_expression$144 == 0 ? (_Bool)1 : (_Bool)0;
                                    }
                                    if(tmp_if_expr$146)
                                    {
                                      struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$96;
                                      return_value_ClientConfiguration_get_realmsTable$96=ClientConfiguration_get_realmsTable(cfg);
                                      ClientRealm_set_realmId(return_value_ClientConfiguration_get_realmsTable$96[(signed long int)0], helpbuf2);
                                    }

                                    else
                                    {
                                      unsigned long int cparsefile$$1$$5$$3$$38$$__s1_len;
                                      unsigned long int cparsefile$$1$$5$$3$$38$$__s2_len;
                                      signed int return_value___builtin_strcmp$141;
                                      return_value___builtin_strcmp$141=__builtin_strcmp(helpbuf1, "pass");
                                      tmp_statement_expression$140 = return_value___builtin_strcmp$141;
                                      if(tmp_statement_expression$140 == 0)
                                      {
                                        unsigned long int return_value_strlen$97;
                                        return_value_strlen$97=strlen(helpbuf2);
                                        n = (signed int)return_value_strlen$97;
                                        memset((void *)pass, 0, (unsigned long int)4);
                                        i = 0;
                                        for( ; !(i >= n); i = i + 1)
                                          pass[(signed long int)(i % 4)] = pass[(signed long int)(i % 4)] + (unsigned char)helpbuf2[(signed long int)i];
                                        struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$98;
                                        return_value_ClientConfiguration_get_realmsTable$98=ClientConfiguration_get_realmsTable(cfg);
                                        ClientRealm_set_password(return_value_ClientConfiguration_get_realmsTable$98[(signed long int)0], pass);
                                      }

                                      else
                                      {
                                        unsigned long int cparsefile$$1$$5$$3$$40$$__s1_len;
                                        unsigned long int cparsefile$$1$$5$$3$$40$$__s2_len;
                                        signed int return_value___builtin_strcmp$136;
                                        return_value___builtin_strcmp$136=__builtin_strcmp(helpbuf1, "K");
                                        tmp_statement_expression$135 = return_value___builtin_strcmp$136;
                                        if(tmp_statement_expression$135 == 0)
                                          tmp_if_expr$139 = (_Bool)1;

                                        else
                                        {
                                          unsigned long int cparsefile$$1$$5$$3$$41$$__s1_len;
                                          unsigned long int cparsefile$$1$$5$$3$$41$$__s2_len;
                                          signed int return_value___builtin_strcmp$138;
                                          return_value___builtin_strcmp$138=__builtin_strcmp(helpbuf1, "keep-alive");
                                          tmp_statement_expression$137 = return_value___builtin_strcmp$138;
                                          tmp_if_expr$139 = tmp_statement_expression$137 == 0 ? (_Bool)1 : (_Bool)0;
                                        }
                                        if(tmp_if_expr$139)
                                        {
                                          struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$99;
                                          return_value_ClientConfiguration_get_realmsTable$99=ClientConfiguration_get_realmsTable(cfg);
                                          ClientRealm_set_sKeepAliveTimeout(return_value_ClientConfiguration_get_realmsTable$99[(signed long int)0], helpbuf2);
                                        }

                                        else
                                        {
                                          unsigned long int cparsefile$$1$$5$$3$$43$$__s1_len;
                                          unsigned long int cparsefile$$1$$5$$3$$43$$__s2_len;
                                          signed int return_value___builtin_strcmp$131;
                                          return_value___builtin_strcmp$131=__builtin_strcmp(helpbuf1, "A");
                                          tmp_statement_expression$130 = return_value___builtin_strcmp$131;
                                          if(tmp_statement_expression$130 == 0)
                                            tmp_if_expr$134 = (_Bool)1;

                                          else
                                          {
                                            unsigned long int cparsefile$$1$$5$$3$$44$$__s1_len;
                                            unsigned long int cparsefile$$1$$5$$3$$44$$__s2_len;
                                            signed int return_value___builtin_strcmp$133;
                                            return_value___builtin_strcmp$133=__builtin_strcmp(helpbuf1, "ar-tries");
                                            tmp_statement_expression$132 = return_value___builtin_strcmp$133;
                                            tmp_if_expr$134 = tmp_statement_expression$132 == 0 ? (_Bool)1 : (_Bool)0;
                                          }
                                          if(tmp_if_expr$134)
                                          {
                                            struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$100;
                                            return_value_ClientConfiguration_get_realmsTable$100=ClientConfiguration_get_realmsTable(cfg);
                                            struct anonymous$3 *return_value_ClientRealm_get_arOptions$101;
                                            return_value_ClientRealm_get_arOptions$101=ClientRealm_get_arOptions(return_value_ClientConfiguration_get_realmsTable$100[(signed long int)0]);
                                            ArOptions_set_s_arTries(return_value_ClientRealm_get_arOptions$101, helpbuf2);
                                          }

                                          else
                                          {
                                            unsigned long int cparsefile$$1$$5$$3$$46$$__s1_len;
                                            unsigned long int cparsefile$$1$$5$$3$$46$$__s2_len;
                                            signed int return_value___builtin_strcmp$126;
                                            return_value___builtin_strcmp$126=__builtin_strcmp(helpbuf1, "T");
                                            tmp_statement_expression$125 = return_value___builtin_strcmp$126;
                                            if(tmp_statement_expression$125 == 0)
                                              tmp_if_expr$129 = (_Bool)1;

                                            else
                                            {
                                              unsigned long int cparsefile$$1$$5$$3$$47$$__s1_len;
                                              unsigned long int cparsefile$$1$$5$$3$$47$$__s2_len;
                                              signed int return_value___builtin_strcmp$128;
                                              return_value___builtin_strcmp$128=__builtin_strcmp(helpbuf1, "ar-delay");
                                              tmp_statement_expression$127 = return_value___builtin_strcmp$128;
                                              tmp_if_expr$129 = tmp_statement_expression$127 == 0 ? (_Bool)1 : (_Bool)0;
                                            }
                                            if(tmp_if_expr$129)
                                            {
                                              struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$102;
                                              return_value_ClientConfiguration_get_realmsTable$102=ClientConfiguration_get_realmsTable(cfg);
                                              struct anonymous$3 *return_value_ClientRealm_get_arOptions$103;
                                              return_value_ClientRealm_get_arOptions$103=ClientRealm_get_arOptions(return_value_ClientConfiguration_get_realmsTable$102[(signed long int)0]);
                                              ArOptions_set_s_arDelay(return_value_ClientRealm_get_arOptions$103, helpbuf2);
                                            }

                                            else
                                            {
                                              unsigned long int cparsefile$$1$$5$$3$$49$$__s1_len;
                                              unsigned long int cparsefile$$1$$5$$3$$49$$__s2_len;
                                              signed int return_value___builtin_strcmp$121;
                                              return_value___builtin_strcmp$121=__builtin_strcmp(helpbuf1, "P");
                                              tmp_statement_expression$120 = return_value___builtin_strcmp$121;
                                              if(tmp_statement_expression$120 == 0)
                                                tmp_if_expr$124 = (_Bool)1;

                                              else
                                              {
                                                unsigned long int cparsefile$$1$$5$$3$$50$$__s1_len;
                                                unsigned long int cparsefile$$1$$5$$3$$50$$__s2_len;
                                                signed int return_value___builtin_strcmp$123;
                                                return_value___builtin_strcmp$123=__builtin_strcmp(helpbuf1, "proxyname");
                                                tmp_statement_expression$122 = return_value___builtin_strcmp$123;
                                                tmp_if_expr$124 = tmp_statement_expression$122 == 0 ? (_Bool)1 : (_Bool)0;
                                              }
                                              if(tmp_if_expr$124)
                                              {
                                                struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$104;
                                                return_value_ClientConfiguration_get_realmsTable$104=ClientConfiguration_get_realmsTable(cfg);
                                                struct anonymous *return_value_ClientRealm_get_httpProxyOptions$105;
                                                return_value_ClientRealm_get_httpProxyOptions$105=ClientRealm_get_httpProxyOptions(return_value_ClientConfiguration_get_realmsTable$104[(signed long int)0]);
                                                HttpProxyOptions_set_proxyname(return_value_ClientRealm_get_httpProxyOptions$105, helpbuf2);
                                              }

                                              else
                                              {
                                                unsigned long int cparsefile$$1$$5$$3$$52$$__s1_len;
                                                unsigned long int cparsefile$$1$$5$$3$$52$$__s2_len;
                                                signed int return_value___builtin_strcmp$116;
                                                return_value___builtin_strcmp$116=__builtin_strcmp(helpbuf1, "X");
                                                tmp_statement_expression$115 = return_value___builtin_strcmp$116;
                                                if(tmp_statement_expression$115 == 0)
                                                  tmp_if_expr$119 = (_Bool)1;

                                                else
                                                {
                                                  unsigned long int cparsefile$$1$$5$$3$$53$$__s1_len;
                                                  unsigned long int cparsefile$$1$$5$$3$$53$$__s2_len;
                                                  signed int return_value___builtin_strcmp$118;
                                                  return_value___builtin_strcmp$118=__builtin_strcmp(helpbuf1, "proxyport");
                                                  tmp_statement_expression$117 = return_value___builtin_strcmp$118;
                                                  tmp_if_expr$119 = tmp_statement_expression$117 == 0 ? (_Bool)1 : (_Bool)0;
                                                }
                                                if(tmp_if_expr$119)
                                                {
                                                  struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$106;
                                                  return_value_ClientConfiguration_get_realmsTable$106=ClientConfiguration_get_realmsTable(cfg);
                                                  struct anonymous *return_value_ClientRealm_get_httpProxyOptions$107;
                                                  return_value_ClientRealm_get_httpProxyOptions$107=ClientRealm_get_httpProxyOptions(return_value_ClientConfiguration_get_realmsTable$106[(signed long int)0]);
                                                  HttpProxyOptions_set_proxyport(return_value_ClientRealm_get_httpProxyOptions$107, helpbuf2);
                                                }

                                                else
                                                {
                                                  unsigned long int cparsefile$$1$$5$$3$$55$$__s1_len;
                                                  unsigned long int cparsefile$$1$$5$$3$$55$$__s2_len;
                                                  signed int return_value___builtin_strcmp$111;
                                                  return_value___builtin_strcmp$111=__builtin_strcmp(helpbuf1, "C");
                                                  tmp_statement_expression$110 = return_value___builtin_strcmp$111;
                                                  if(tmp_statement_expression$110 == 0)
                                                    tmp_if_expr$114 = (_Bool)1;

                                                  else
                                                  {
                                                    unsigned long int cparsefile$$1$$5$$3$$56$$__s1_len;
                                                    unsigned long int cparsefile$$1$$5$$3$$56$$__s2_len;
                                                    signed int return_value___builtin_strcmp$113;
                                                    return_value___builtin_strcmp$113=__builtin_strcmp(helpbuf1, "pa-cred");
                                                    tmp_statement_expression$112 = return_value___builtin_strcmp$113;
                                                    tmp_if_expr$114 = tmp_statement_expression$112 == 0 ? (_Bool)1 : (_Bool)0;
                                                  }
                                                  if(tmp_if_expr$114)
                                                  {
                                                    struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$108;
                                                    return_value_ClientConfiguration_get_realmsTable$108=ClientConfiguration_get_realmsTable(cfg);
                                                    struct anonymous *return_value_ClientRealm_get_httpProxyOptions$109;
                                                    return_value_ClientRealm_get_httpProxyOptions$109=ClientRealm_get_httpProxyOptions(return_value_ClientConfiguration_get_realmsTable$108[(signed long int)0]);
                                                    HttpProxyOptions_set_proxyauth_cred(return_value_ClientRealm_get_httpProxyOptions$109, helpbuf2);
                                                  }

                                                  else
                                                    return cfg;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

        memset((void *)buff, 0, (unsigned long int)256);
      }
    }
    while((_Bool)1);
    fclose(file);
    *status = 0;
    return cfg;
  }
}

// create_apf_dir
// file first_run.h line 24
signed int create_apf_dir(char type)
{
  signed int length;
  struct stat buf;
  struct passwd *user;
  unsigned int return_value_getuid$1;
  return_value_getuid$1=getuid();
  user=getpwuid(return_value_getuid$1);
  if((signed int)type == 0)
  {
    if(user == ((struct passwd *)NULL))
      return 1;

    if(user->pw_dir == ((char *)NULL))
      return 2;

    if(!(home_dir == ((char *)NULL)))
    {
      free((void *)home_dir);
      home_dir = (char *)(void *)0;
    }

    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(user->pw_dir);
    length = (signed int)return_value_strlen$2;
    void *return_value_calloc$3;
    return_value_calloc$3=calloc((unsigned long int)1, (unsigned long int)(length + 6));
    home_dir = (char *)return_value_calloc$3;
    if(home_dir == ((char *)NULL))
      return 3;

    strcpy(home_dir, user->pw_dir);
    if((signed int)home_dir[(signed long int)length] == 47)
      strcpy(&home_dir[(signed long int)length], ".apf");

    else
      strcpy(&home_dir[(signed long int)length], "/.apf");
    signed int return_value_stat$5;
    return_value_stat$5=stat(home_dir, &buf);
    if(!(return_value_stat$5 == 0))
    {
      signed int return_value_mkdir$4;
      return_value_mkdir$4=mkdir(home_dir, (unsigned int)0700);
      if(!(return_value_mkdir$4 == 0))
        return 4;

    }

  }

  else
  {
    if(!(home_dir == ((char *)NULL)))
    {
      free((void *)home_dir);
      home_dir = (char *)(void *)0;
    }

    void *return_value_calloc$6;
    return_value_calloc$6=calloc((unsigned long int)1, (unsigned long int)4);
    home_dir = (char *)return_value_calloc$6;
    if(home_dir == ((char *)NULL))
      return 3;

    strcpy(home_dir, "apf");
    signed int return_value_stat$8;
    return_value_stat$8=stat(home_dir, &buf);
    if(!(return_value_stat$8 == 0))
    {
      signed int return_value_mkdir$7;
      return_value_mkdir$7=mkdir(home_dir, (unsigned int)0700);
      if(!(return_value_mkdir$7 == 0))
        return 4;

    }

  }
  return 0;
}

// create_publickey_store
// file first_run.h line 25
signed int create_publickey_store(char **storefile)
{
  signed int store_length;
  signed int home_length;
  struct stat buf;
  struct _IO_FILE *store_file;
  signed int return_value_stat$1;
  return_value_stat$1=stat(*storefile, &buf);
  if(return_value_stat$1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(*storefile);
    store_length = (signed int)return_value_strlen$2;
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(home_dir);
    home_length = (signed int)return_value_strlen$3;
    if(!(home_dir_store == ((char *)NULL)))
    {
      free((void *)home_dir_store);
      home_dir_store = (char *)(void *)0;
    }

    void *return_value_calloc$4;
    return_value_calloc$4=calloc((unsigned long int)1, (unsigned long int)(home_length + store_length + 2));
    home_dir_store = (char *)return_value_calloc$4;
    if(home_dir_store == ((char *)NULL))
      return 1;

    else
    {
      strcpy(home_dir_store, home_dir);
      home_dir_store[(signed long int)home_length] = (char)47;
      strcpy(&home_dir_store[(signed long int)(home_length + 1)], *storefile);
      *storefile = home_dir_store;
      store_file=fopen(home_dir_store, "a");
      if(store_file == ((struct _IO_FILE *)NULL))
        return 1;

      else
      {
        fclose(store_file);
        signed int return_value_stat$5;
        return_value_stat$5=stat(home_dir_store, &buf);
        if(return_value_stat$5 == 0)
          return 0;

        else
          return 2;
      }
    }
  }
}

// datum
// file logging.c line 85
char * datum(void)
{
  signed long int sec;
  struct tm *tm;
  time(&sec);
  tm=localtime(&sec);
  static char timedat[31l];
  memset((void *)timedat, 0, (unsigned long int)31);
  strftime(timedat, (unsigned long int)30, format, tm);
  return timedat;
}

// delete_user
// file http_proxy_functions.c line 77
void delete_user(struct anonymous$16 *cnts, signed int i, struct anonymous$11 *allset)
{
  aflog((char)16, (char)2, "http proxy: delete_user(%d)", i);
  clear_fd(&(cnts + (signed long int)i)->sockfd, allset);
  if((1 & (signed int)(cnts + (signed long int)i)->state) == 0)
    clear_sslFd((cnts + (signed long int)i)->postFd, allset);

  if((signed int)(cnts + (signed long int)i)->type == 0)
  {
    if((2 & (signed int)(cnts + (signed long int)i)->state) == 0)
      clear_sslFd((cnts + (signed long int)i)->getFd, allset);

  }

  (cnts + (signed long int)i)->state = (char)0;
  (cnts + (signed long int)i)->length = 0;
  (cnts + (signed long int)i)->ptr = (cnts + (signed long int)i)->length;
  (cnts + (signed long int)i)->sent_ptr = (cnts + (signed long int)i)->ptr;
  (cnts + (signed long int)i)->type = (char)0;
}

// end_critical_section
// file thread_management.h line 29
void end_critical_section(void)
{
  pthread_mutex_unlock(&mainmutex);
}

// generate_certificate
// file first_run.c line 250
signed int generate_certificate(char **cerfile, char *keyfile)
{
  signed int cer_length;
  signed int home_length;
  signed int i;
  struct stat buf;
  struct x509_st *cert;
  struct X509_req_st *req;
  struct X509_name_st *subj;
  struct rsa_st *rsa_key;
  struct evp_pkey_st *pkey;
  const struct env_md_st *digest;
  struct _IO_FILE *fp;
  signed int return_value_stat$1;
  return_value_stat$1=stat(*cerfile, &buf);
  if(return_value_stat$1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(*cerfile);
    cer_length = (signed int)return_value_strlen$2;
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(home_dir);
    home_length = (signed int)return_value_strlen$3;
    if(!(home_dir_cer == ((char *)NULL)))
    {
      free((void *)home_dir_cer);
      home_dir_cer = (char *)(void *)0;
    }

    void *return_value_calloc$4;
    return_value_calloc$4=calloc((unsigned long int)1, (unsigned long int)(home_length + cer_length + 2));
    home_dir_cer = (char *)return_value_calloc$4;
    if(home_dir_cer == ((char *)NULL))
      return 1;

    else
    {
      strcpy(home_dir_cer, home_dir);
      home_dir_cer[(signed long int)home_length] = (char)47;
      strcpy(&home_dir_cer[(signed long int)(home_length + 1)], *cerfile);
      *cerfile = home_dir_cer;
      signed int return_value_stat$5;
      return_value_stat$5=stat(home_dir_cer, &buf);
      if(return_value_stat$5 == 0)
        return 0;

      else
      {
        printf("generating self signed certificate\n");
        fp=fopen(keyfile, "r");
        if(fp == ((struct _IO_FILE *)NULL))
          return 2;

        else
        {
          rsa_key=PEM_read_RSAPrivateKey(fp, (struct rsa_st **)(void *)0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
          fclose(fp);
          if(rsa_key == ((struct rsa_st *)NULL))
            return 3;

          else
          {
            pkey=EVP_PKEY_new();
            if(pkey == ((struct evp_pkey_st *)NULL))
              return 4;

            else
            {
              signed int return_value_EVP_PKEY_set1_RSA$6;
              return_value_EVP_PKEY_set1_RSA$6=EVP_PKEY_set1_RSA(pkey, rsa_key);
              if(return_value_EVP_PKEY_set1_RSA$6 == 0)
                return 5;

              else
              {
                req=X509_REQ_new();
                if(req == ((struct X509_req_st *)NULL))
                  return 6;

                else
                {
                  X509_REQ_set_pubkey(req, pkey);
                  subj=X509_NAME_new();
                  if(subj == ((struct X509_name_st *)NULL))
                    return 7;

                  else
                  {
                    i = 0;
                    for( ; !(i >= 6); i = i + 1)
                    {
                      signed int nid;
                      struct X509_name_entry_st *ent;
                      nid=OBJ_txt2nid(entries[(signed long int)i].key);
                      if(nid == 0)
                        return 8;

                      ent=X509_NAME_ENTRY_create_by_NID((struct X509_name_entry_st **)(void *)0, nid, 0x1000 | 1, entries[(signed long int)i].value, -1);
                      if(ent == ((struct X509_name_entry_st *)NULL))
                        return 9;

                      signed int return_value_X509_NAME_add_entry$7;
                      return_value_X509_NAME_add_entry$7=X509_NAME_add_entry(subj, ent, -1, 0);
                      if(return_value_X509_NAME_add_entry$7 == 0)
                        return 10;

                    }
                    signed int return_value_X509_REQ_set_subject_name$8;
                    return_value_X509_REQ_set_subject_name$8=X509_REQ_set_subject_name(req, subj);
                    if(return_value_X509_REQ_set_subject_name$8 == 0)
                      return 11;

                    else
                    {
                      digest=EVP_sha1();
                      signed int return_value_X509_REQ_sign$9;
                      return_value_X509_REQ_sign$9=X509_REQ_sign(req, pkey, digest);
                      if(return_value_X509_REQ_sign$9 == 0)
                        return 12;

                      else
                      {
                        cert=X509_REQ_to_X509(req, 1000, pkey);
                        signed int return_value_X509_set_version$10;
                        return_value_X509_set_version$10=X509_set_version(cert, 2L);
                        if(return_value_X509_set_version$10 == 0)
                          return 13;

                        else
                        {
                          struct asn1_string_st *return_value_X509_get_serialNumber$11;
                          return_value_X509_get_serialNumber$11=X509_get_serialNumber(cert);
                          ASN1_INTEGER_set(return_value_X509_get_serialNumber$11, (signed long int)1);
                          if(cert == ((struct x509_st *)NULL))
                            return 14;

                          else
                          {
                            signed int return_value_X509_sign$12;
                            return_value_X509_sign$12=X509_sign(cert, pkey, digest);
                            if(return_value_X509_sign$12 == 0)
                              return 15;

                            else
                            {
                              fp=fopen(home_dir_cer, "w");
                              if(fp == ((struct _IO_FILE *)NULL))
                                return 16;

                              else
                              {
                                PEM_write_X509(fp, cert);
                                fclose(fp);
                                EVP_PKEY_free(pkey);
                                X509_REQ_free(req);
                                X509_free(cert);
                                return 0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// generate_rsa_key
// file first_run.h line 26
signed int generate_rsa_key(char **keyfile)
{
  signed int key_length;
  signed int home_length;
  struct rsa_st *rsa_key;
  struct _IO_FILE *rsa_file;
  struct stat buf;
  signed int return_value_stat$1;
  return_value_stat$1=stat(*keyfile, &buf);
  if(return_value_stat$1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(*keyfile);
    key_length = (signed int)return_value_strlen$2;
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(home_dir);
    home_length = (signed int)return_value_strlen$3;
    if(!(home_dir_key == ((char *)NULL)))
    {
      free((void *)home_dir_key);
      home_dir_key = (char *)(void *)0;
    }

    void *return_value_calloc$4;
    return_value_calloc$4=calloc((unsigned long int)1, (unsigned long int)(home_length + key_length + 2));
    home_dir_key = (char *)return_value_calloc$4;
    if(home_dir_key == ((char *)NULL))
      return 1;

    else
    {
      strcpy(home_dir_key, home_dir);
      home_dir_key[(signed long int)home_length] = (char)47;
      strcpy(&home_dir_key[(signed long int)(home_length + 1)], *keyfile);
      *keyfile = home_dir_key;
      signed int return_value_stat$5;
      return_value_stat$5=stat(home_dir_key, &buf);
      if(return_value_stat$5 == 0)
        return 0;

      else
      {
        printf("generating rsa key: 2048 bits\n");
        rsa_key=RSA_generate_key(2048, (unsigned long int)65537, callback, (void *)0);
        signed int return_value_RSA_check_key$6;
        return_value_RSA_check_key$6=RSA_check_key(rsa_key);
        if(return_value_RSA_check_key$6 == 1)
          printf("   OK!\n");

        else
        {
          printf("   FAILED!\n");
          return 1;
        }
        rsa_file=fopen(home_dir_key, "a");
        PEM_write_RSAPrivateKey(rsa_file, rsa_key, (const struct evp_cipher_st *)(void *)0, (unsigned char *)(void *)0, 0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
        fclose(rsa_file);
        return 0;
      }
    }
  }
}

// get_cer_filename
// file first_run.c line 400
char * get_cer_filename()
{
  return home_dir_cer;
}

// get_key_filename
// file first_run.c line 388
char * get_key_filename()
{
  return home_dir_key;
}

// get_ssl_error
// file make_ssl_handshake.h line 29
signed int get_ssl_error(struct anonymous$0 *sf, char *info, signed int result)
{
  signed int merror;
  char err_buff[200l];
  struct ssl_st *return_value_SslFd_get_ssl$1;
  return_value_SslFd_get_ssl$1=SslFd_get_ssl(sf);
  merror=SSL_get_error(return_value_SslFd_get_ssl$1, result);
  unsigned long int return_value_ERR_get_error$2;
  char *return_value_ERR_error_string$3;
  switch(merror)
  {
    case 0:
    {
      aflog((char)16, (char)32, "%s(%d): none", info, result);
      break;
    }
    case 6:
    {
      aflog((char)16, (char)32, "%s(%d): zero", info, result);
      break;
    }
    case 2:
    {
      aflog((char)16, (char)32, "%s(%d): w_read", info, result);
      break;
    }
    case 3:
    {
      aflog((char)16, (char)32, "%s(%d): w_write", info, result);
      break;
    }
    case 7:
    {
      aflog((char)16, (char)32, "%s(%d): w_connect", info, result);
      break;
    }
    case 4:
    {
      aflog((char)16, (char)32, "%s(%d): w_x509_lookup", info, result);
      break;
    }
    case 5:
    {
      aflog((char)16, (char)32, "%s(%d): syscall", info, result);
      break;
    }
    case 1:
    {
      SSL_load_error_strings();
      return_value_ERR_get_error$2=ERR_get_error();
      return_value_ERR_error_string$3=ERR_error_string(return_value_ERR_get_error$2, err_buff);
      aflog((char)16, (char)32, "%s(%d): ssl:%s", info, result, return_value_ERR_error_string$3);
      break;
    }
    default:
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      aflog((char)16, (char)32, "%s(%d): unrecognized error (%d)", info, result, *return_value___errno_location$4);
    }
  }
  if(merror == 2 || merror == 3)
    return 1;

  else
    return 2;
}

// get_store_filename
// file first_run.c line 376
char * get_store_filename()
{
  return home_dir_store;
}

// getcg
// file stats.h line 35
signed long int getcg(void)
{
  return compressgained;
}

// getdateformat
// file logging.c line 55
char * getdateformat()
{
  return format;
}

// getloglisthead
// file logging.c line 104
struct llnode * getloglisthead()
{
  return head;
}

// http_proxy_client
// file http_proxy_client.c line 63
void * http_proxy_client(void *vptr)
{
  char tab[9000l];
  struct anonymous$16 conn;
  struct anonymous$15 hdr;
  signed int j;
  signed int n;
  signed int maxfdp1;
  struct anonymous$11 rset;
  struct anonymous$11 allset;
  struct timeval tv;
  signed int timeout = 5;
  signed int tmp;
  char *host;
  char *serv;
  char *proxyname;
  char *proxyport;
  char *credentials;
  char *name = "";
  char b64cred[100l];
  char type;
  char authtype;
  char https;
  struct ssl_ctx_st *ctx;
  struct anonymous$19 *proxy_argptr;
  start_critical_section();
  proxy_argptr = (struct anonymous$19 *)vptr;
  host = proxy_argptr->host;
  serv = proxy_argptr->serv;
  proxyname=HttpProxyOptions_get_proxyname(proxy_argptr->hpo);
  proxyport=HttpProxyOptions_get_proxyport(proxy_argptr->hpo);
  credentials=HttpProxyOptions_get_proxyauth_cred(proxy_argptr->hpo);
  type = proxy_argptr->type;
  authtype=HttpProxyOptions_get_proxyauth_type(proxy_argptr->hpo);
  conn.sockfd = proxy_argptr->sockfd;
  https=HttpProxyOptions_is_https(proxy_argptr->hpo);
  ctx = proxy_argptr->ctx;
  broadcast_condition();
  end_critical_section();
  conn.postFd=SslFd_new();
  conn.getFd=SslFd_new();
  conn.tmpFd=SslFd_new();
  if(conn.getFd == ((struct anonymous$0 *)NULL) || conn.postFd == ((struct anonymous$0 *)NULL) || conn.tmpFd == ((struct anonymous$0 *)NULL))
  {
    aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
    exit(1);
  }

  _Bool tmp_if_expr$6;
  struct ssl_st *return_value_SslFd_get_ssl$5;
  _Bool tmp_if_expr$8;
  struct ssl_st *return_value_SslFd_get_ssl$7;
  if(!(https == 0))
  {
    name = "s";
    struct ssl_st *return_value_SSL_new$1;
    return_value_SSL_new$1=SSL_new(ctx);
    SslFd_set_ssl(conn.postFd, return_value_SSL_new$1);
    struct ssl_st *return_value_SSL_new$2;
    return_value_SSL_new$2=SSL_new(ctx);
    SslFd_set_ssl(conn.getFd, return_value_SSL_new$2);
    struct ssl_st *return_value_SSL_new$3;
    return_value_SSL_new$3=SSL_new(ctx);
    SslFd_set_ssl(conn.tmpFd, return_value_SSL_new$3);
    struct ssl_st *return_value_SslFd_get_ssl$4;
    return_value_SslFd_get_ssl$4=SslFd_get_ssl(conn.postFd);
    if(return_value_SslFd_get_ssl$4 == ((struct ssl_st *)NULL))
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value_SslFd_get_ssl$5=SslFd_get_ssl(conn.getFd);
      tmp_if_expr$6 = return_value_SslFd_get_ssl$5 == (struct ssl_st *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
      tmp_if_expr$8 = (_Bool)1;

    else
    {
      return_value_SslFd_get_ssl$7=SslFd_get_ssl(conn.tmpFd);
      tmp_if_expr$8 = return_value_SslFd_get_ssl$7 == (struct ssl_st *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$8)
    {
      aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
      exit(1);
    }

  }

  if((signed int)authtype == -1)
  {
    aflog((char)16, (char)32, "Wrong type of proxy authorizaton --> switching to no authorization");
    credentials = (char *)(void *)0;
  }

  if(!(credentials == ((char *)NULL)))
  {
    unsigned long int return_value_strlen$9;
    return_value_strlen$9=strlen(credentials);
    signed int return_value_b64_ntop$10;
    return_value_b64_ntop$10=b64_ntop((unsigned char *)credentials, return_value_strlen$9, b64cred, (unsigned long int)100);
    if(return_value_b64_ntop$10 == -1)
    {
      aflog((char)16, (char)64, "Cannot encode credentials for proxy authorization");
      b64cred[(signed long int)0] = (char)0;
    }

    else
      if((signed int)authtype == 0)
        authtype = (char)1;

  }

  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$11) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&allset)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  tv.tv_usec = (signed long int)0;
  tv.tv_sec = (signed long int)timeout;
  memset((void *)conn.id, 0, (unsigned long int)10);
  j = 0;
  for( ; !(j >= 9); j = j + 1)
  {
    signed int return_value_myrand$11;
    return_value_myrand$11=myrand(65, 90);
    conn.id[(signed long int)j] = (char)return_value_myrand$11;
  }
  conn.id[(signed long int)9] = (char)0;
  aflog((char)16, (char)2, "http%s proxy: connecting (postfd)...", name);
  signed int return_value_ip_connect$12;
  return_value_ip_connect$12=ip_connect(&tmp, proxyname, proxyport, type, (const char *)(void *)0, (const char *)(void *)0);
  if(!(return_value_ip_connect$12 == 0))
    clean_return(conn.sockfd);

  SslFd_set_fd(conn.postFd, tmp);
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl$13;
    return_value_SslFd_get_ssl$13=SslFd_get_ssl(conn.postFd);
    signed int return_value_SslFd_get_fd$14;
    return_value_SslFd_get_fd$14=SslFd_get_fd(conn.postFd);
    signed int return_value_SSL_set_fd$15;
    return_value_SSL_set_fd$15=SSL_set_fd(return_value_SslFd_get_ssl$13, return_value_SslFd_get_fd$14);
    if(!(return_value_SSL_set_fd$15 == 1))
    {
      aflog((char)4, (char)1, "https proxy: Problem with initializing ssl");
      clean_return(conn.sockfd);
    }

    struct ssl_st *return_value_SslFd_get_ssl$16;
    return_value_SslFd_get_ssl$16=SslFd_get_ssl(conn.postFd);
    signed int return_value_SSL_connect$17;
    return_value_SSL_connect$17=SSL_connect(return_value_SslFd_get_ssl$16);
    if(!(return_value_SSL_connect$17 == 1))
    {
      aflog((char)4, (char)1, "https proxy: SSL_connect has failed");
      clean_return(conn.sockfd);
    }

  }

  memset((void *)tab, 0, (unsigned long int)9000);
  if((signed int)authtype == 1)
  {
    sprintf(tab, "POST http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nContent-Length: 90000\r\nConnection: close\r\nProxy-Authorization: Basic %s\r\n\r\n", host, serv, (const void *)conn.id, host, serv, (const void *)b64cred);
    goto __CPROVER_DUMP_L20;
  }

  sprintf(tab, "POST http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nContent-Length: 90000\r\nConnection: close\r\n\r\n", host, serv, (const void *)conn.id, host, serv);

__CPROVER_DUMP_L20:
  ;
  unsigned long int return_value_strlen$18;
  return_value_strlen$18=strlen(tab);
  j = (signed int)return_value_strlen$18;
  aflog((char)16, (char)2, "http%s proxy: writing POST request...", name);
  signed int return_value_http_write$19;
  return_value_http_write$19=http_write(https, conn.postFd, (unsigned char *)tab, j);
  if(!(return_value_http_write$19 >= 1))
    clean_return(conn.sockfd);

  aflog((char)16, (char)2, "http%s proxy: connecting (getfd)...", name);
  signed int return_value_ip_connect$20;
  return_value_ip_connect$20=ip_connect(&tmp, proxyname, proxyport, type, (const char *)(void *)0, (const char *)(void *)0);
  if(!(return_value_ip_connect$20 == 0))
    clean_return(conn.sockfd);

  SslFd_set_fd(conn.getFd, tmp);
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl$21;
    return_value_SslFd_get_ssl$21=SslFd_get_ssl(conn.getFd);
    signed int return_value_SslFd_get_fd$22;
    return_value_SslFd_get_fd$22=SslFd_get_fd(conn.getFd);
    signed int return_value_SSL_set_fd$23;
    return_value_SSL_set_fd$23=SSL_set_fd(return_value_SslFd_get_ssl$21, return_value_SslFd_get_fd$22);
    if(!(return_value_SSL_set_fd$23 == 1))
    {
      aflog((char)4, (char)1, "https proxy: Problem with initializing ssl");
      clean_return(conn.sockfd);
    }

    struct ssl_st *return_value_SslFd_get_ssl$24;
    return_value_SslFd_get_ssl$24=SslFd_get_ssl(conn.getFd);
    signed int return_value_SSL_connect$25;
    return_value_SSL_connect$25=SSL_connect(return_value_SslFd_get_ssl$24);
    if(!(return_value_SSL_connect$25 == 1))
    {
      aflog((char)4, (char)1, "https proxy: SSL_connect has failed");
      clean_return(conn.sockfd);
    }

  }

  memset((void *)tab, 0, (unsigned long int)9000);
  if((signed int)authtype == 1)
  {
    sprintf(tab, "GET http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nConnection: close\r\nProxy-Authorization: Basic %s\r\n\r\n", host, serv, (const void *)conn.id, host, serv, (const void *)b64cred);
    goto __CPROVER_DUMP_L28;
  }

  sprintf(tab, "GET http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nConnection: close\r\n\r\n", host, serv, (const void *)conn.id, host, serv);

__CPROVER_DUMP_L28:
  ;
  unsigned long int return_value_strlen$26;
  return_value_strlen$26=strlen(tab);
  j = (signed int)return_value_strlen$26;
  aflog((char)16, (char)2, "http%s proxy: writing GET request...", name);
  signed int return_value_http_write$27;
  return_value_http_write$27=http_write(https, conn.getFd, (unsigned char *)tab, j);
  if(!(return_value_http_write$27 >= 1))
    clean_return(conn.sockfd);

  set_fd(conn.sockfd, &maxfdp1, &allset);
  signed int return_value_SslFd_get_fd$28;
  return_value_SslFd_get_fd$28=SslFd_get_fd(conn.postFd);
  set_fd(return_value_SslFd_get_fd$28, &maxfdp1, &allset);
  signed int return_value_SslFd_get_fd$29;
  return_value_SslFd_get_fd$29=SslFd_get_fd(conn.getFd);
  set_fd(return_value_SslFd_get_fd$29, &maxfdp1, &allset);
  conn.state = (char)4;
  memset((void *)tab, 0, (unsigned long int)9000);
  aflog((char)16, (char)2, "http%s proxy: parsing header from getfd", name);
  signed int return_value_parse_header$30;
  return_value_parse_header$30=parse_header(conn.getFd, tab, &hdr, https);
  if(!(return_value_parse_header$30 == 0))
    clean_return(conn.sockfd);

  aflog((char)16, (char)2, "http%s proxy: checking hdr.type", name);
  if(!((signed int)hdr.type == 2))
    clean_return(conn.sockfd);

  if(!(hdr.length == 0))
  {
    conn.received = conn.received + hdr.length;
    aflog((char)16, (char)2, "http%s proxy: reading message...", name);
    signed int return_value_read_message$31;
    return_value_read_message$31=read_message(conn.sockfd, hdr.length, &conn, tab, hdr.ptr);
    if(!(return_value_read_message$31 == 0))
      clean_return(conn.sockfd);

  }

  while((_Bool)1)
  {
    if((signed int)conn.state == 4)
    {
      if((allset.__fds_bits[(signed long int)(conn.sockfd / 8)] & 1l << conn.sockfd % 8) == 0l)
        (&allset)->__fds_bits[(signed long int)(conn.sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(conn.sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << conn.sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ );

    }

    rset = allset;
    signed int return_value_select$41;
    return_value_select$41=select(maxfdp1, &rset, (struct anonymous$11 *)(void *)0, (struct anonymous$11 *)(void *)0, &tv);
    if(return_value_select$41 == 0)
    {
      aflog((char)16, (char)4, "http%s proxy: timeout", name);
      tv.tv_sec = (signed long int)timeout;
      if(1 + conn.sent_ptr >= 90000)
      {
        if((signed int)conn.state == 0)
          continue;

        aflog((char)16, (char)4, "http%s proxy: send T", name);
        http_write(https, conn.postFd, (unsigned char *)"T", 1);
        conn.sent_ptr = 0;
        clear_sslFd(conn.postFd, &allset);
        aflog((char)16, (char)2, "http%s proxy: connecting (postfd)...", name);
        signed int return_value_ip_connect$32;
        return_value_ip_connect$32=ip_connect(&tmp, proxyname, proxyport, type, (const char *)(void *)0, (const char *)(void *)0);
        if(!(return_value_ip_connect$32 == 0))
          clean_return(conn.sockfd);

        SslFd_set_fd(conn.postFd, tmp);
        if(!(https == 0))
        {
          struct ssl_st *return_value_SslFd_get_ssl$33;
          return_value_SslFd_get_ssl$33=SslFd_get_ssl(conn.postFd);
          signed int return_value_SslFd_get_fd$34;
          return_value_SslFd_get_fd$34=SslFd_get_fd(conn.postFd);
          signed int return_value_SSL_set_fd$35;
          return_value_SSL_set_fd$35=SSL_set_fd(return_value_SslFd_get_ssl$33, return_value_SslFd_get_fd$34);
          if(!(return_value_SSL_set_fd$35 == 1))
          {
            aflog((char)4, (char)1, "https proxy: Problem with initializing ssl");
            clean_return(conn.sockfd);
          }

          struct ssl_st *return_value_SslFd_get_ssl$36;
          return_value_SslFd_get_ssl$36=SslFd_get_ssl(conn.postFd);
          signed int return_value_SSL_connect$37;
          return_value_SSL_connect$37=SSL_connect(return_value_SslFd_get_ssl$36);
          if(!(return_value_SSL_connect$37 == 1))
          {
            aflog((char)4, (char)1, "https proxy: SSL_connect has failed");
            clean_return(conn.sockfd);
          }

        }

        memset((void *)tab, 0, (unsigned long int)9000);
        if((signed int)authtype == 1)
        {
          sprintf(tab, "POST http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nContent-Length: 90000\r\nConnection: close\r\nProxy-Authorization: Basic %s\r\n\r\n", host, serv, (const void *)conn.id, host, serv, (const void *)b64cred);
          goto __CPROVER_DUMP_L41;
        }

        sprintf(tab, "POST http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nContent-Length: 90000\r\nConnection: close\r\n\r\n", host, serv, (const void *)conn.id, host, serv);

      __CPROVER_DUMP_L41:
        ;
        unsigned long int return_value_strlen$38;
        return_value_strlen$38=strlen(tab);
        j = (signed int)return_value_strlen$38;
        aflog((char)16, (char)2, "http%s proxy: writing POST request...", name);
        signed int return_value_http_write$39;
        return_value_http_write$39=http_write(https, conn.postFd, (unsigned char *)tab, j);
        if(!(return_value_http_write$39 >= 1))
          clean_return(conn.sockfd);

        conn.sent_ptr = 0;
        conn.ptr = 0;
        conn.length = 0;
        conn.state = (char)0;
        signed int return_value_SslFd_get_fd$40;
        return_value_SslFd_get_fd$40=SslFd_get_fd(conn.postFd);
        set_fd(return_value_SslFd_get_fd$40, &maxfdp1, &allset);
      }

      else
      {
        aflog((char)16, (char)4, "http%s proxy: send T", name);
        http_write(https, conn.postFd, (unsigned char *)"T", 1);
        conn.sent_ptr = conn.sent_ptr + 1;
      }
    }

    else
    {
      if(!((rset.__fds_bits[(signed long int)(conn.sockfd / 8)] & 1l << conn.sockfd % 8) == 0l))
      {
        aflog((char)16, (char)4, "http%s proxy: FD_ISSET(conn.sockfd)", name);
        signed long int return_value_read$42;
        return_value_read$42=read(conn.sockfd, (void *)(conn.buf + (signed long int)5), (unsigned long int)8995);
        n = (signed int)return_value_read$42;
        if(!(n >= 1))
        {
          aflog((char)16, (char)2, "http%s proxy: send Q", name);
          http_write(https, conn.postFd, (unsigned char *)"Q", 1);
          clean_return(conn.sockfd);
        }

        if((signed int)conn.state == 0 && conn.sent_ptr >= 70001)
          (&allset)->__fds_bits[(signed long int)(conn.sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(conn.sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << conn.sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

        conn.buf[(signed long int)0] = (char)77;
        unsigned int return_value___bswap_32$43;
        return_value___bswap_32$43=__bswap_32$link1((unsigned int)n);
        tmp = (signed int)return_value___bswap_32$43;
        memcpy((void *)&conn.buf[(signed long int)1], (const void *)&tmp, (unsigned long int)4);
        if(5 + conn.sent_ptr + n >= 90000)
        {
          aflog((char)16, (char)2, "http%s proxy: send message", name);
          http_write(https, conn.postFd, (unsigned char *)conn.buf, 90000 - conn.sent_ptr);
          conn.ptr = 90000 - conn.sent_ptr;
          conn.length = (5 + n) - conn.ptr;
          conn.sent_ptr = 0;
          clear_sslFd(conn.postFd, &allset);
          aflog((char)16, (char)2, "http%s proxy: connecting (postfd)...", name);
          signed int return_value_ip_connect$44;
          return_value_ip_connect$44=ip_connect(&tmp, proxyname, proxyport, type, (const char *)(void *)0, (const char *)(void *)0);
          if(!(return_value_ip_connect$44 == 0))
            clean_return(conn.sockfd);

          SslFd_set_fd(conn.postFd, tmp);
          if(!(https == 0))
          {
            struct ssl_st *return_value_SslFd_get_ssl$45;
            return_value_SslFd_get_ssl$45=SslFd_get_ssl(conn.postFd);
            signed int return_value_SslFd_get_fd$46;
            return_value_SslFd_get_fd$46=SslFd_get_fd(conn.postFd);
            signed int return_value_SSL_set_fd$47;
            return_value_SSL_set_fd$47=SSL_set_fd(return_value_SslFd_get_ssl$45, return_value_SslFd_get_fd$46);
            if(!(return_value_SSL_set_fd$47 == 1))
            {
              aflog((char)4, (char)1, "https proxy: Problem with initializing ssl");
              clean_return(conn.sockfd);
            }

            struct ssl_st *return_value_SslFd_get_ssl$48;
            return_value_SslFd_get_ssl$48=SslFd_get_ssl(conn.postFd);
            signed int return_value_SSL_connect$49;
            return_value_SSL_connect$49=SSL_connect(return_value_SslFd_get_ssl$48);
            if(!(return_value_SSL_connect$49 == 1))
            {
              aflog((char)4, (char)1, "https proxy: SSL_connect has failed");
              clean_return(conn.sockfd);
            }

          }

          memset((void *)tab, 0, (unsigned long int)9000);
          if((signed int)authtype == 1)
          {
            sprintf(tab, "POST http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nContent-Length: 90000\r\nConnection: close\r\nProxy-Authorization: Basic %s\r\n\r\n", host, serv, (const void *)conn.id, host, serv, (const void *)b64cred);
            goto __CPROVER_DUMP_L54;
          }

          sprintf(tab, "POST http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nContent-Length: 90000\r\nConnection: close\r\n\r\n", host, serv, (const void *)conn.id, host, serv);

        __CPROVER_DUMP_L54:
          ;
          unsigned long int return_value_strlen$50;
          return_value_strlen$50=strlen(tab);
          j = (signed int)return_value_strlen$50;
          aflog((char)16, (char)2, "http%s proxy: writing POST request...", name);
          signed int return_value_http_write$51;
          return_value_http_write$51=http_write(https, conn.postFd, (unsigned char *)tab, j);
          if(!(return_value_http_write$51 >= 1))
            clean_return(conn.sockfd);

          if(conn.length >= 1)
          {
            aflog((char)16, (char)2, "http%s proxy: writing old data...", name);
            signed int return_value_http_write$52;
            return_value_http_write$52=http_write(https, conn.postFd, (unsigned char *)(conn.buf + (signed long int)conn.ptr), conn.length);
            if(!(return_value_http_write$52 >= 1))
              clean_return(conn.sockfd);

          }

          conn.sent_ptr = conn.length;
          conn.ptr = 0;
          conn.length = 0;
          conn.state = (char)0;
          signed int return_value_SslFd_get_fd$53;
          return_value_SslFd_get_fd$53=SslFd_get_fd(conn.postFd);
          set_fd(return_value_SslFd_get_fd$53, &maxfdp1, &allset);
        }

        else
        {
          aflog((char)16, (char)2, "http%s proxy: send message", name);
          http_write(https, conn.postFd, (unsigned char *)conn.buf, 5 + n);
          conn.sent_ptr = conn.sent_ptr + 5 + n;
        }
      }

      signed int return_value_SslFd_get_fd$66;
      return_value_SslFd_get_fd$66=SslFd_get_fd(conn.getFd);
      signed int return_value_SslFd_get_fd$67;
      return_value_SslFd_get_fd$67=SslFd_get_fd(conn.getFd);
      if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd$66 / 8)] & 1l << return_value_SslFd_get_fd$67 % 8) == 0l))
      {
        aflog((char)16, (char)4, "http%s proxy: FD_ISSET(conn.getfd)", name);
        n=http_read(https, conn.getFd, (unsigned char *)tab, 9000);
        conn.received = conn.received + n;
        if(n == 0)
        {
          conn.received = 0;
          clear_sslFd(conn.getFd, &allset);
          aflog((char)16, (char)2, "http%s proxy: connecting (getfd)...", name);
          signed int return_value_ip_connect$54;
          return_value_ip_connect$54=ip_connect(&tmp, proxyname, proxyport, type, (const char *)(void *)0, (const char *)(void *)0);
          if(!(return_value_ip_connect$54 == 0))
            clean_return(conn.sockfd);

          SslFd_set_fd(conn.getFd, tmp);
          if(!(https == 0))
          {
            struct ssl_st *return_value_SslFd_get_ssl$55;
            return_value_SslFd_get_ssl$55=SslFd_get_ssl(conn.getFd);
            signed int return_value_SslFd_get_fd$56;
            return_value_SslFd_get_fd$56=SslFd_get_fd(conn.getFd);
            signed int return_value_SSL_set_fd$57;
            return_value_SSL_set_fd$57=SSL_set_fd(return_value_SslFd_get_ssl$55, return_value_SslFd_get_fd$56);
            if(!(return_value_SSL_set_fd$57 == 1))
            {
              aflog((char)4, (char)1, "https proxy: Problem with initializing ssl");
              clean_return(conn.sockfd);
            }

            struct ssl_st *return_value_SslFd_get_ssl$58;
            return_value_SslFd_get_ssl$58=SslFd_get_ssl(conn.getFd);
            signed int return_value_SSL_connect$59;
            return_value_SSL_connect$59=SSL_connect(return_value_SslFd_get_ssl$58);
            if(!(return_value_SSL_connect$59 == 1))
            {
              aflog((char)4, (char)1, "https proxy: SSL_connect has failed");
              clean_return(conn.sockfd);
            }

          }

          memset((void *)tab, 0, (unsigned long int)9000);
          if((signed int)authtype == 1)
          {
            sprintf(tab, "GET http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nConnection: close\r\nProxy-Authorization: Basic %s\r\n\r\n", host, serv, (const void *)conn.id, host, serv, (const void *)b64cred);
            goto __CPROVER_DUMP_L67;
          }

          sprintf(tab, "GET http://%s:%s/yahpt.html?id=%s HTTP/1.1\r\nHost: %s:%s\r\nConnection: close\r\n\r\n", host, serv, (const void *)conn.id, host, serv);

        __CPROVER_DUMP_L67:
          ;
          unsigned long int return_value_strlen$60;
          return_value_strlen$60=strlen(tab);
          j = (signed int)return_value_strlen$60;
          aflog((char)16, (char)2, "http%s proxy: writing GET request...", name);
          signed int return_value_http_write$61;
          return_value_http_write$61=http_write(https, conn.getFd, (unsigned char *)tab, j);
          if(!(return_value_http_write$61 >= 1))
            clean_return(conn.sockfd);

          memset((void *)tab, 0, (unsigned long int)9000);
          aflog((char)16, (char)2, "http%s proxy: parsing header from getfd", name);
          signed int return_value_parse_header$62;
          return_value_parse_header$62=parse_header(conn.getFd, tab, &hdr, https);
          if(!(return_value_parse_header$62 == 0))
            clean_return(conn.sockfd);

          aflog((char)16, (char)2, "http%s proxy: checking hdr.type", name);
          if(!((signed int)hdr.type == 2))
            clean_return(conn.sockfd);

          signed int return_value_SslFd_get_fd$63;
          return_value_SslFd_get_fd$63=SslFd_get_fd(conn.getFd);
          set_fd(return_value_SslFd_get_fd$63, &maxfdp1, &allset);
          if(!(hdr.length == 0))
          {
            conn.received = conn.received + hdr.length;
            aflog((char)16, (char)2, "http%s proxy: reading message...", name);
            signed int return_value_read_message$64;
            return_value_read_message$64=read_message(conn.sockfd, hdr.length, &conn, tab, hdr.ptr);
            if(!(return_value_read_message$64 == 0))
              clean_return(conn.sockfd);

          }

        }

        else
        {
          signed int return_value_read_message$65;
          return_value_read_message$65=read_message(conn.sockfd, n, &conn, tab, 0);
          if(!(return_value_read_message$65 == 0))
            clean_return(conn.sockfd);

        }
      }

      signed int return_value_SslFd_get_fd$68;
      return_value_SslFd_get_fd$68=SslFd_get_fd(conn.postFd);
      signed int return_value_SslFd_get_fd$69;
      return_value_SslFd_get_fd$69=SslFd_get_fd(conn.postFd);
      if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd$68 / 8)] & 1l << return_value_SslFd_get_fd$69 % 8) == 0l))
      {
        aflog((char)16, (char)4, "http%s proxy: FD_ISSET(conn.postfd) --> clean_return", name);
        clear_sslFd(conn.postFd, &allset);
        clean_return(conn.sockfd);
      }

    }
  }
  clean_return(conn.sockfd);
}

// http_read
// file http_proxy_functions.c line 402
signed int http_read(char https, struct anonymous$0 *sf, unsigned char *buf, signed int amount)
{
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl$1;
    return_value_SslFd_get_ssl$1=SslFd_get_ssl(sf);
    signed int return_value_SSL_read$2;
    return_value_SSL_read$2=SSL_read(return_value_SslFd_get_ssl$1, (void *)buf, amount);
    return return_value_SSL_read$2;
  }

  else
  {
    signed int return_value_SslFd_get_fd$3;
    return_value_SslFd_get_fd$3=SslFd_get_fd(sf);
    signed long int return_value_read$4;
    return_value_read$4=read(return_value_SslFd_get_fd$3, (void *)buf, (unsigned long int)amount);
    return (signed int)return_value_read$4;
  }
}

// http_write
// file http_proxy_functions.c line 381
signed int http_write(char https, struct anonymous$0 *sf, unsigned char *buf, signed int amount)
{
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl$1;
    return_value_SslFd_get_ssl$1=SslFd_get_ssl(sf);
    signed int return_value_SSL_writen$2;
    return_value_SSL_writen$2=SSL_writen(return_value_SslFd_get_ssl$1, buf, amount);
    return return_value_SSL_writen$2;
  }

  else
  {
    signed int return_value_SslFd_get_fd$3;
    return_value_SslFd_get_fd$3=SslFd_get_fd(sf);
    signed int return_value_writen$4;
    return_value_writen$4=writen(return_value_SslFd_get_fd$3, buf, amount);
    return return_value_writen$4;
  }
}

// initialize_client_reverse_udp
// file client_reverse_udp.h line 38
signed int initialize_client_reverse_udp(struct anonymous$5 *cr)
{
  signed int tmp;
  signed int wanttoexit;
  struct anonymous$3 *return_value_ClientRealm_get_arOptions$1;
  return_value_ClientRealm_get_arOptions$1=ClientRealm_get_arOptions(cr);
  char return_value_ArOptions_get_arStart$2;
  return_value_ArOptions_get_arStart$2=ArOptions_get_arStart(return_value_ClientRealm_get_arOptions$1);
  wanttoexit = (signed int)return_value_ArOptions_get_arStart$2 == 1 ? 0 : 1;
  ClientRealm_set_usersLimit(cr, 1);
  char *return_value_ClientRealm_get_serverName$8;
  return_value_ClientRealm_get_serverName$8=ClientRealm_get_serverName(cr);
  char *return_value_ClientRealm_get_managePort$9;
  return_value_ClientRealm_get_managePort$9=ClientRealm_get_managePort(cr);
  char return_value_ClientRealm_get_ipFamily$10;
  return_value_ClientRealm_get_ipFamily$10=ClientRealm_get_ipFamily(cr);
  signed int return_value_ip_connect$11;
  return_value_ip_connect$11=ip_connect(&tmp, return_value_ClientRealm_get_serverName$8, return_value_ClientRealm_get_managePort$9, return_value_ClientRealm_get_ipFamily$10, (const char *)(void *)0, (const char *)(void *)0);
  char *tmp_if_expr$5;
  char return_value_ClientRealm_get_ipFamily$4;
  if(!(return_value_ip_connect$11 == 0))
  {
    char return_value_ClientRealm_get_ipFamily$3;
    return_value_ClientRealm_get_ipFamily$3=ClientRealm_get_ipFamily(cr);
    if(!((0x02 & (signed int)return_value_ClientRealm_get_ipFamily$3) == 0))
      tmp_if_expr$5 = "ipv4";

    else
    {
      return_value_ClientRealm_get_ipFamily$4=ClientRealm_get_ipFamily(cr);
      tmp_if_expr$5 = ((signed int)return_value_ClientRealm_get_ipFamily$4 & 0x04) != 0 ? "ipv6" : "unspec";
    }
    char *return_value_ClientRealm_get_serverName$6;
    return_value_ClientRealm_get_serverName$6=ClientRealm_get_serverName(cr);
    char *return_value_ClientRealm_get_managePort$7;
    return_value_ClientRealm_get_managePort$7=ClientRealm_get_managePort(cr);
    aflog((char)4, (char)1, "tcp_connect_%s error for %s, %s", tmp_if_expr$5, return_value_ClientRealm_get_serverName$6, return_value_ClientRealm_get_managePort$7);
    if(!(wanttoexit == 0))
      exit(1);

    else
      return 1;
  }

  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$12;
  return_value_ClientRealm_get_masterSslFd$12=ClientRealm_get_masterSslFd(cr);
  SslFd_set_fd(return_value_ClientRealm_get_masterSslFd$12, tmp);
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$13;
  return_value_ClientRealm_get_masterSslFd$13=ClientRealm_get_masterSslFd(cr);
  SslFd_set_ssl(return_value_ClientRealm_get_masterSslFd$13, (struct ssl_st *)(void *)0);
  return 0;
}

// initialize_client_stage1
// file client_initialization.h line 36
signed int initialize_client_stage1(struct anonymous$5 *cr, struct ssl_ctx_st *ctx, unsigned char *buff, char wanttoexit, char ignorePublicKeys)
{
  signed int n;
  signed int nlen;
  signed int elen;
  signed int len;
  signed int tmp;
  unsigned int olen;
  struct x509_st *server_cert;
  const struct env_md_st *md;
  struct evp_pkey_st *pkey;
  struct env_md_ctx_st md_ctx;
  unsigned char *encoded = (unsigned char *)(void *)0;
  char b64_encoded[100l];
  unsigned char *key_buf = (unsigned char *)(void *)0;
  char return_value_ClientRealm_get_tunnelType$1;
  return_value_ClientRealm_get_tunnelType$1=ClientRealm_get_tunnelType(cr);
  char *return_value_ClientRealm_get_serverName$7;
  char *return_value_ClientRealm_get_managePort$8;
  char return_value_ClientRealm_get_ipFamily$9;
  char *return_value_ClientRealm_get_localName$10;
  char *return_value_ClientRealm_get_localPort$11;
  signed int return_value_ip_connect$12;
  char *tmp_if_expr$4;
  char return_value_ClientRealm_get_ipFamily$3;
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$13;
  signed int return_value_initialize_http_proxy_client$23;
  char *tmp_if_expr$16;
  char return_value_ClientRealm_get_ipFamily$15;
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$24;
  switch((signed int)return_value_ClientRealm_get_tunnelType$1)
  {
    case 0:
    {
      return_value_ClientRealm_get_serverName$7=ClientRealm_get_serverName(cr);
      return_value_ClientRealm_get_managePort$8=ClientRealm_get_managePort(cr);
      return_value_ClientRealm_get_ipFamily$9=ClientRealm_get_ipFamily(cr);
      return_value_ClientRealm_get_localName$10=ClientRealm_get_localName(cr);
      return_value_ClientRealm_get_localPort$11=ClientRealm_get_localPort(cr);
      return_value_ip_connect$12=ip_connect(&tmp, return_value_ClientRealm_get_serverName$7, return_value_ClientRealm_get_managePort$8, return_value_ClientRealm_get_ipFamily$9, return_value_ClientRealm_get_localName$10, return_value_ClientRealm_get_localPort$11);
      if(!(return_value_ip_connect$12 == 0))
      {
        char return_value_ClientRealm_get_ipFamily$2;
        return_value_ClientRealm_get_ipFamily$2=ClientRealm_get_ipFamily(cr);
        if(!((0x02 & (signed int)return_value_ClientRealm_get_ipFamily$2) == 0))
          tmp_if_expr$4 = "ipv4";

        else
        {
          return_value_ClientRealm_get_ipFamily$3=ClientRealm_get_ipFamily(cr);
          tmp_if_expr$4 = ((signed int)return_value_ClientRealm_get_ipFamily$3 & 0x04) != 0 ? "ipv6" : "unspec";
        }
        char *return_value_ClientRealm_get_serverName$5;
        return_value_ClientRealm_get_serverName$5=ClientRealm_get_serverName(cr);
        char *return_value_ClientRealm_get_managePort$6;
        return_value_ClientRealm_get_managePort$6=ClientRealm_get_managePort(cr);
        aflog((char)4, (char)1, "tcp_connect_%s error for %s, %s", tmp_if_expr$4, return_value_ClientRealm_get_serverName$5, return_value_ClientRealm_get_managePort$6);
        if(!(wanttoexit == 0))
          exit(1);

        else
          return 1;
      }

      return_value_ClientRealm_get_masterSslFd$13=ClientRealm_get_masterSslFd(cr);
      SslFd_set_fd(return_value_ClientRealm_get_masterSslFd$13, tmp);
      break;
    }
    case 1:
    {
      return_value_initialize_http_proxy_client$23=initialize_http_proxy_client(&tmp, cr, ctx);
      if(!(return_value_initialize_http_proxy_client$23 == 0))
      {
        char return_value_ClientRealm_get_ipFamily$14;
        return_value_ClientRealm_get_ipFamily$14=ClientRealm_get_ipFamily(cr);
        if(!((0x02 & (signed int)return_value_ClientRealm_get_ipFamily$14) == 0))
          tmp_if_expr$16 = "ipv4";

        else
        {
          return_value_ClientRealm_get_ipFamily$15=ClientRealm_get_ipFamily(cr);
          tmp_if_expr$16 = ((signed int)return_value_ClientRealm_get_ipFamily$15 & 0x04) != 0 ? "ipv6" : "unspec";
        }
        char *return_value_ClientRealm_get_serverName$17;
        return_value_ClientRealm_get_serverName$17=ClientRealm_get_serverName(cr);
        char *return_value_ClientRealm_get_managePort$18;
        return_value_ClientRealm_get_managePort$18=ClientRealm_get_managePort(cr);
        struct anonymous *return_value_ClientRealm_get_httpProxyOptions$19;
        return_value_ClientRealm_get_httpProxyOptions$19=ClientRealm_get_httpProxyOptions(cr);
        char *return_value_HttpProxyOptions_get_proxyname$20;
        return_value_HttpProxyOptions_get_proxyname$20=HttpProxyOptions_get_proxyname(return_value_ClientRealm_get_httpProxyOptions$19);
        struct anonymous *return_value_ClientRealm_get_httpProxyOptions$21;
        return_value_ClientRealm_get_httpProxyOptions$21=ClientRealm_get_httpProxyOptions(cr);
        char *return_value_HttpProxyOptions_get_proxyport$22;
        return_value_HttpProxyOptions_get_proxyport$22=HttpProxyOptions_get_proxyport(return_value_ClientRealm_get_httpProxyOptions$21);
        aflog((char)4, (char)1, "http_proxy_connect_%s error for %s, %s (proxy: %s, %s)", tmp_if_expr$16, return_value_ClientRealm_get_serverName$17, return_value_ClientRealm_get_managePort$18, return_value_HttpProxyOptions_get_proxyname$20, return_value_HttpProxyOptions_get_proxyport$22);
        if(!(wanttoexit == 0))
          exit(1);

        else
          return 1;
      }

      return_value_ClientRealm_get_masterSslFd$24=ClientRealm_get_masterSslFd(cr);
      SslFd_set_fd(return_value_ClientRealm_get_masterSslFd$24, tmp);
      break;
    }
    default:
    {
      aflog((char)4, (char)1, "Unknown tunnel type");
      if(!(wanttoexit == 0))
        exit(1);

      else
        return 1;
    }
  }
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$25;
  return_value_ClientRealm_get_masterSslFd$25=ClientRealm_get_masterSslFd(cr);
  struct ssl_st *return_value_SSL_new$26;
  return_value_SSL_new$26=SSL_new(ctx);
  SslFd_set_ssl(return_value_ClientRealm_get_masterSslFd$25, return_value_SSL_new$26);
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$29;
  return_value_ClientRealm_get_masterSslFd$29=ClientRealm_get_masterSslFd(cr);
  struct ssl_st *return_value_SslFd_get_ssl$30;
  return_value_SslFd_get_ssl$30=SslFd_get_ssl(return_value_ClientRealm_get_masterSslFd$29);
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$31;
  return_value_ClientRealm_get_masterSslFd$31=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd$32;
  return_value_SslFd_get_fd$32=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$31);
  signed int return_value_SSL_set_fd$33;
  return_value_SSL_set_fd$33=SSL_set_fd(return_value_SslFd_get_ssl$30, return_value_SslFd_get_fd$32);
  if(!(return_value_SSL_set_fd$33 == 1))
  {
    aflog((char)4, (char)1, "Problem with initializing ssl... exiting");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$27;
      return_value_ClientRealm_get_masterSslFd$27=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd$28;
      return_value_SslFd_get_fd$28=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$27);
      close(return_value_SslFd_get_fd$28);
      return 2;
    }
  }

  alarm((unsigned int)60);
  aflog((char)4, (char)8, "Trying SSL_connect");
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$52;
  return_value_ClientRealm_get_masterSslFd$52=ClientRealm_get_masterSslFd(cr);
  struct ssl_st *return_value_SslFd_get_ssl$53;
  return_value_SslFd_get_ssl$53=SslFd_get_ssl(return_value_ClientRealm_get_masterSslFd$52);
  n=SSL_connect(return_value_SslFd_get_ssl$53);
  char *return_value_get_store_filename$44;
  char *return_value_ClientRealm_get_serverName$45;
  if(n == 1)
  {
    struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$34;
    return_value_ClientRealm_get_masterSslFd$34=ClientRealm_get_masterSslFd(cr);
    struct ssl_st *return_value_SslFd_get_ssl$35;
    return_value_SslFd_get_ssl$35=SslFd_get_ssl(return_value_ClientRealm_get_masterSslFd$34);
    server_cert=SSL_get_peer_certificate(return_value_SslFd_get_ssl$35);
    if(server_cert == ((struct x509_st *)NULL))
    {
      aflog((char)16, (char)1, "Server did not present a certificate... exiting");
      exit(1);
    }

    pkey=X509_get_pubkey(server_cert);
    if(pkey == ((struct evp_pkey_st *)NULL))
    {
      aflog((char)16, (char)1, "Server's public key is invalid... exiting");
      exit(1);
    }

    signed int return_value_BN_num_bits$36;
    return_value_BN_num_bits$36=BN_num_bits(pkey->pkey.rsa->n);
    nlen = (return_value_BN_num_bits$36 + 7) / 8;
    signed int return_value_BN_num_bits$37;
    return_value_BN_num_bits$37=BN_num_bits(pkey->pkey.rsa->e);
    elen = (return_value_BN_num_bits$37 + 7) / 8;
    len = nlen + elen;
    void *return_value_malloc$38;
    return_value_malloc$38=malloc((unsigned long int)len);
    key_buf = (unsigned char *)return_value_malloc$38;
    if(key_buf == ((unsigned char *)NULL))
    {
      aflog((char)16, (char)1, "Cannot allocate memory for server's public key checking... exiting");
      exit(1);
    }

    BN_bn2bin(pkey->pkey.rsa->n, key_buf);
    BN_bn2bin(pkey->pkey.rsa->e, key_buf + (signed long int)nlen);
    md=EVP_md5();
    EVP_DigestInit(&md_ctx, md);
    EVP_DigestUpdate(&md_ctx, (const void *)key_buf, (unsigned long int)len);
    void *return_value_calloc$39;
    return_value_calloc$39=calloc((unsigned long int)1, (unsigned long int)(64 + 1));
    encoded = (unsigned char *)return_value_calloc$39;
    if(encoded == ((unsigned char *)NULL))
    {
      aflog((char)16, (char)1, "Cannot allocate memory for server's public key checking... exiting");
      exit(1);
    }

    EVP_DigestFinal(&md_ctx, encoded, &olen);
    signed int return_value_b64_ntop$40;
    return_value_b64_ntop$40=b64_ntop(encoded, (unsigned long int)olen, b64_encoded, (unsigned long int)100);
    if(return_value_b64_ntop$40 == -1)
    {
      aflog((char)16, (char)1, "Problem with base64 encoding... exiting");
      exit(1);
    }

    char *return_value_get_store_filename$41;
    return_value_get_store_filename$41=get_store_filename();
    char *return_value_ClientRealm_get_serverName$42;
    return_value_ClientRealm_get_serverName$42=ClientRealm_get_serverName(cr);
    signed int return_value_check_public_key$43;
    return_value_check_public_key$43=check_public_key(return_value_get_store_filename$41, return_value_ClientRealm_get_serverName$42, b64_encoded);
    switch(return_value_check_public_key$43)
    {
      case 1:
        break;
      case 2:
      {
        aflog((char)16, (char)32, "WARNING: implicitly added new server's public key to the list of known hosts");
        return_value_get_store_filename$44=get_store_filename();
        return_value_ClientRealm_get_serverName$45=ClientRealm_get_serverName(cr);
        add_public_key(return_value_get_store_filename$44, return_value_ClientRealm_get_serverName$45, b64_encoded);
        break;
      }
      default:
        if(!(ignorePublicKeys == 0))
          aflog((char)16, (char)32, "WARNING: Invalid server's public key... ignoring");

        else
        {
          aflog((char)16, (char)1, "Invalid server's public key... exiting");
          char *return_value_get_store_filename$46;
          return_value_get_store_filename$46=get_store_filename();
          aflog((char)16, (char)1, "Please delete conflicting entry in %s or use '--ignorepkeys' option", return_value_get_store_filename$46);
          exit(1);
        }
    }
    memset((void *)key_buf, 0, (unsigned long int)len);
    free((void *)key_buf);
    free((void *)encoded);
    aflog((char)4, (char)8, "SSL_connect successful");
  }

  else
  {
    alarm((unsigned int)0);
    struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$47;
    return_value_ClientRealm_get_masterSslFd$47=ClientRealm_get_masterSslFd(cr);
    struct ssl_st *return_value_SslFd_get_ssl$48;
    return_value_SslFd_get_ssl$48=SslFd_get_ssl(return_value_ClientRealm_get_masterSslFd$47);
    signed int return_value_SSL_get_error$49;
    return_value_SSL_get_error$49=SSL_get_error(return_value_SslFd_get_ssl$48, n);
    aflog((char)4, (char)1, "SSL_connect has failed (%d | %d)... exiting", n, return_value_SSL_get_error$49);
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$50;
      return_value_ClientRealm_get_masterSslFd$50=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd$51;
      return_value_SslFd_get_fd$51=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$50);
      close(return_value_SslFd_get_fd$51);
      return 3;
    }
  }
  alarm((unsigned int)0);
  buff[(signed long int)0] = (unsigned char)8;
  unsigned char *return_value_ClientRealm_get_password$54;
  return_value_ClientRealm_get_password$54=ClientRealm_get_password(cr);
  buff[(signed long int)1] = return_value_ClientRealm_get_password$54[(signed long int)0];
  unsigned char *return_value_ClientRealm_get_password$55;
  return_value_ClientRealm_get_password$55=ClientRealm_get_password(cr);
  buff[(signed long int)2] = return_value_ClientRealm_get_password$55[(signed long int)1];
  unsigned char *return_value_ClientRealm_get_password$56;
  return_value_ClientRealm_get_password$56=ClientRealm_get_password(cr);
  buff[(signed long int)3] = return_value_ClientRealm_get_password$56[(signed long int)2];
  unsigned char *return_value_ClientRealm_get_password$57;
  return_value_ClientRealm_get_password$57=ClientRealm_get_password(cr);
  buff[(signed long int)4] = return_value_ClientRealm_get_password$57[(signed long int)3];
  return 0;
}

// initialize_client_stage2
// file client_initialization.h line 38
signed int initialize_client_stage2(struct anonymous$5 *cr, unsigned char *buff, char wanttoexit)
{
  char return_value_ClientRealm_get_realmType$1;
  return_value_ClientRealm_get_realmType$1=ClientRealm_get_realmType(cr);
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$2;
  return_value_ClientRealm_get_masterSslFd$2=ClientRealm_get_masterSslFd(cr);
  SslFd_send_message((char)((signed int)return_value_ClientRealm_get_realmType$1 | 4 | 8), return_value_ClientRealm_get_masterSslFd$2, buff, 5);
  buff[(signed long int)0] = (unsigned char)0;
  char return_value_ClientRealm_get_realmType$3;
  return_value_ClientRealm_get_realmType$3=ClientRealm_get_realmType(cr);
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$4;
  return_value_ClientRealm_get_masterSslFd$4=ClientRealm_get_masterSslFd(cr);
  SslFd_get_message((char)((signed int)return_value_ClientRealm_get_realmType$3 | 4 | 8), return_value_ClientRealm_get_masterSslFd$4, buff, -5);
  if((signed int)*buff == 0)
  {
    aflog((char)4, (char)1, "Connection with afserver failed");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$5;
      return_value_ClientRealm_get_masterSslFd$5=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd$6;
      return_value_SslFd_get_fd$6=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$5);
      close(return_value_SslFd_get_fd$6);
      return 1;
    }
  }

  if((signed int)*buff == 13)
  {
    aflog((char)4, (char)64, "Wrong password");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$7;
      return_value_ClientRealm_get_masterSslFd$7=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd$8;
      return_value_SslFd_get_fd$8=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$7);
      close(return_value_SslFd_get_fd$8);
      return 1;
    }
  }

  if((signed int)*buff == 12)
  {
    aflog((char)4, (char)64, "Server is full");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$9;
      return_value_ClientRealm_get_masterSslFd$9=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd$10;
      return_value_SslFd_get_fd$10=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$9);
      close(return_value_SslFd_get_fd$10);
      return 1;
    }
  }

  if(!((signed int)*buff == 8))
  {
    aflog((char)4, (char)64, "Incompatible server type or server full");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$11;
      return_value_ClientRealm_get_masterSslFd$11=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd$12;
      return_value_SslFd_get_fd$12=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$11);
      close(return_value_SslFd_get_fd$12);
      return 1;
    }
  }

  ClientRealm_set_realmType(cr, (char)buff[(signed long int)3]);
  ClientRealm_set_usersLimit(cr, (signed int)buff[(signed long int)1] * 256 + (signed int)buff[(signed long int)2]);
  return 0;
}

// initialize_client_stage3
// file client_initialization.h line 39
signed int initialize_client_stage3(struct anonymous$5 *cr, signed int *buflength, struct anonymous$11 *allset, struct anonymous$11 *wset, signed int *maxfdp1, char wanttoexit)
{
  signed int i;
  unsigned int len;
  struct anonymous$7 **usersTable;
  signed int return_value_ClientRealm_get_usersLimit$1;
  return_value_ClientRealm_get_usersLimit$1=ClientRealm_get_usersLimit(cr);
  void *return_value_calloc$2;
  return_value_calloc$2=calloc((unsigned long int)return_value_ClientRealm_get_usersLimit$1, sizeof(struct anonymous$7 *) /*8ul*/ );
  usersTable = (struct anonymous$7 **)return_value_calloc$2;
  if(usersTable == ((struct anonymous$7 **)NULL))
  {
    aflog((char)4, (char)1, "Calloc error - unable to successfully communicate with server");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$3;
      return_value_ClientRealm_get_masterSslFd$3=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd$4;
      return_value_SslFd_get_fd$4=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$3);
      close(return_value_SslFd_get_fd$4);
      return 1;
    }
  }

  ClientRealm_set_usersTable(cr, usersTable);
  i = 0;
  signed int return_value_ClientRealm_get_usersLimit$5;
  do
  {
    return_value_ClientRealm_get_usersLimit$5=ClientRealm_get_usersLimit(cr);
    if(i >= return_value_ClientRealm_get_usersLimit$5)
      break;

    usersTable[(signed long int)i]=ConnectUser_new();
    if(usersTable[(signed long int)i] == ((struct anonymous$7 *)NULL))
    {
      aflog((char)4, (char)1, "Calloc error - unable to successfully communicate with server");
      if(!(wanttoexit == 0))
        exit(1);

      else
      {
        struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$6;
        return_value_ClientRealm_get_masterSslFd$6=ClientRealm_get_masterSslFd(cr);
        signed int return_value_SslFd_get_fd$7;
        return_value_SslFd_get_fd$7=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$6);
        close(return_value_SslFd_get_fd$7);
        return 1;
      }
    }

    i = i + 1;
  }
  while((_Bool)1);
  len = (unsigned int)4;
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$10;
  return_value_ClientRealm_get_masterSslFd$10=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd$11;
  return_value_SslFd_get_fd$11=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$10);
  signed int return_value_getsockopt$12;
  return_value_getsockopt$12=getsockopt(return_value_SslFd_get_fd$11, 1, 7, (void *)buflength, &len);
  if(return_value_getsockopt$12 == -1)
  {
    aflog((char)4, (char)1, "Can't get socket send buffer size - exiting...");
    if(!(wanttoexit == 0))
      exit(1);

    else
    {
      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$8;
      return_value_ClientRealm_get_masterSslFd$8=ClientRealm_get_masterSslFd(cr);
      signed int return_value_SslFd_get_fd$9;
      return_value_SslFd_get_fd$9=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$8);
      close(return_value_SslFd_get_fd$9);
      return 2;
    }
  }

  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$11) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&allset->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  do
  {
    signed int initialize_client_stage3$$1$$5$$__d0;
    signed int initialize_client_stage3$$1$$5$$__d1;
    asm("cld; rep; stosq" : "=c"(initialize_client_stage3$$1$$5$$__d0), "=D"(initialize_client_stage3$$1$$5$$__d1) : "a"(0), "0"(sizeof(struct anonymous$11) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&wset->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$13;
  return_value_ClientRealm_get_masterSslFd$13=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd$14;
  return_value_SslFd_get_fd$14=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$13);
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$15;
  return_value_ClientRealm_get_masterSslFd$15=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd$16;
  return_value_SslFd_get_fd$16=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$15);
  allset->__fds_bits[(signed long int)(return_value_SslFd_get_fd$14 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = allset->__fds_bits[(signed long int)(return_value_SslFd_get_fd$14 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_SslFd_get_fd$16 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$17;
  return_value_ClientRealm_get_masterSslFd$17=ClientRealm_get_masterSslFd(cr);
  signed int return_value_SslFd_get_fd$18;
  return_value_SslFd_get_fd$18=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$17);
  *maxfdp1 = return_value_SslFd_get_fd$18 + 1;
  return 0;
}

// initialize_http_proxy_client
// file http_proxy_client.c line 531
signed int initialize_http_proxy_client(signed int *sockfd, struct anonymous$5 *cr, struct ssl_ctx_st *ctx)
{
  signed int retval;
  signed int sockets[2l];
  unsigned long int proxy_thread;
  signed int return_value_socketpair$1;
  return_value_socketpair$1=socketpair(1, 1, 0, sockets);
  if(!(return_value_socketpair$1 == 0))
    return 1;

  else
  {
    *sockfd = sockets[(signed long int)0];
    struct anonymous *return_value_ClientRealm_get_httpProxyOptions$2;
    return_value_ClientRealm_get_httpProxyOptions$2=ClientRealm_get_httpProxyOptions(cr);
    char *return_value_HttpProxyOptions_get_proxyname$3;
    return_value_HttpProxyOptions_get_proxyname$3=HttpProxyOptions_get_proxyname(return_value_ClientRealm_get_httpProxyOptions$2);
    if(return_value_HttpProxyOptions_get_proxyname$3 == ((char *)NULL))
      return 1;

    else
    {
      start_critical_section();
      static struct anonymous$19 arg;
      arg.host=ClientRealm_get_serverName(cr);
      arg.serv=ClientRealm_get_managePort(cr);
      arg.hpo=ClientRealm_get_httpProxyOptions(cr);
      arg.type=ClientRealm_get_ipFamily(cr);
      arg.sockfd = sockets[(signed long int)1];
      arg.ctx = ctx;
      retval=pthread_create(&proxy_thread, (const union pthread_attr_t *)(void *)0, http_proxy_client, (void *)&arg);
      wait_for_condition();
      end_critical_section();
      return retval;
    }
  }
}

// initializelogging
// file logging.h line 71
void initializelogging(char verl, char *dateformat)
{
  signed int k;
  k=loginit(verl, dateformat);
  if(!(k == 0))
  {
    switch(k)
    {
      case 1:
      {
        printf("Wrong format of the logcmd\n");
        break;
      }
      case 2:
      {
        printf("Unknown type of the logging target\n");
        break;
      }
      case 3:
      {
        printf("Wrong description of the logging target (name too long)\n");
        break;
      }
      case 4:
      {
        printf("Can't open file to log to\n");
        break;
      }
      case 5:
      {
        printf("Can't connect to target host\n");
        break;
      }
      case 6:
        printf("Wrong msgtype/importance description\n");
    }
    exit(1);
  }

}

// ip_connect
// file network.h line 40
signed int ip_connect(signed int *sockfd, const char *host, const char *serv, const char type, const char *lhost, const char *lserv)
{
  const signed int on = 1;
  signed int n;
  signed int bindFailed;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ressave;
  struct addrinfo lhints;
  struct addrinfo *lres;
  struct addrinfo *lressave = (struct addrinfo *)(void *)0;
  aflog((char)4, (char)4, "ip_connect: host=[%s] serv=[%s], type=[%d], lhost=[%s], lserv=[%s]", host, serv, type, lhost, lserv);
  bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
  if(!((0x02 & (signed int)type) == 0))
    hints.ai_family = 2;

  else
    if(!((0x04 & (signed int)type) == 0))
      hints.ai_family = 10;

    else
      hints.ai_family = 0;
  if(!((0x01 & (signed int)type) == 0))
    hints.ai_socktype = 1;

  else
    hints.ai_socktype = 2;
  lhints = hints;
  if(!(lhost == ((const char *)NULL)) || !(lserv == ((const char *)NULL)))
  {
    n=getaddrinfo(lhost, lserv, &lhints, &lres);
    if(!(n == 0))
      return n;

    lressave = lres;
  }

  n=getaddrinfo(host, serv, &hints, &res);
  if(!(n == 0))
    return n;

  else
  {
    ressave = res;
    do
    {
      *sockfd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if(*sockfd >= 0)
      {
        if(!((0x01 & (signed int)type) == 0))
          setsockopt(*sockfd, 1, 9, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );

        bindFailed = 0;
        if(!(lhost == ((const char *)NULL)) || !(lserv == ((const char *)NULL)))
        {
          bindFailed = 1;
          lres = lressave;
          do
          {
            signed int return_value_bind$1;
            return_value_bind$1=bind(*sockfd, lres->ai_addr, lres->ai_addrlen);
            if(return_value_bind$1 == 0)
            {
              bindFailed = 0;
              break;
            }

            lres = lres->ai_next;
          }
          while(!(lres == ((struct addrinfo *)NULL)));
        }

        if(bindFailed == 1)
          close(*sockfd);

        else
        {
          signed int return_value_connect$2;
          return_value_connect$2=connect(*sockfd, res->ai_addr, res->ai_addrlen);
          if(return_value_connect$2 == 0)
            break;

          close(*sockfd);
        }
      }

      res = res->ai_next;
    }
    while(!(res == ((struct addrinfo *)NULL)));
    if(res == ((struct addrinfo *)NULL))
      return 1;

    else
    {
      if(!(lhost == ((const char *)NULL)) || !(lserv == ((const char *)NULL)))
        freeaddrinfo(lressave);

      freeaddrinfo(ressave);
      return 0;
    }
  }
}

// ip_listen
// file network.h line 39
signed int ip_listen(signed int *sockfd, const char *host, const char *serv, unsigned int *addrlenp, const char type)
{
  const signed int on = 1;
  signed int n;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ressave;
  aflog((char)4, (char)4, "ip_listen: host=[%s] serv=[%s], type=[%d]", host, serv, type);
  bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_flags = 0x0001;
  if(!((0x02 & (signed int)type) == 0))
    hints.ai_family = 2;

  else
    if(!((0x04 & (signed int)type) == 0))
      hints.ai_family = 10;

    else
      hints.ai_family = 0;
  if(!((0x01 & (signed int)type) == 0))
    hints.ai_socktype = 1;

  else
    hints.ai_socktype = 2;
  n=getaddrinfo(host, serv, &hints, &res);
  if(!(n == 0))
    return n;

  else
  {
    ressave = res;
    do
    {
      *sockfd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if(*sockfd >= 0)
      {
        if(!((0x01 & (signed int)type) == 0))
        {
          setsockopt(*sockfd, 1, 2, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );
          setsockopt(*sockfd, 1, 9, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );
        }

        signed int return_value_bind$1;
        return_value_bind$1=bind(*sockfd, res->ai_addr, res->ai_addrlen);
        if(return_value_bind$1 == 0)
          break;

        close(*sockfd);
      }

      res = res->ai_next;
    }
    while(!(res == ((struct addrinfo *)NULL)));
    if(res == ((struct addrinfo *)NULL))
      return 1;

    else
    {
      if(!((0x01 & (signed int)type) == 0))
        listen(*sockfd, 1);

      if(!(addrlenp == ((unsigned int *)NULL)))
        *addrlenp = res->ai_addrlen;

      freeaddrinfo(ressave);
      return 0;
    }
  }
}

// is_this_a_mainthread
// file thread_management.c line 50
signed int is_this_a_mainthread(void)
{
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  if(return_value_pthread_self$1 == mainthread)
    return 1;

  else
    return 0;
}

// localdate
// file logging.c line 68
char * localdate(signed long int *sec)
{
  struct tm *tm;
  tm=localtime(sec);
  static char localdat[31l];
  memset((void *)localdat, 0, (unsigned long int)31);
  strftime(localdat, (unsigned long int)30, format, tm);
  return localdat;
}

// loginit
// file logging.c line 334
signed int loginit(char verl, char *dateformat)
{
  struct llnode *ptr;
  signed int n;
  verlev = (char)0;
  if(!(verl == 0))
    switch((signed int)verl)
    {
      case 1:
      {
        verlev = (char)(16 | 1);
        break;
      }
      case 2:
      {
        verlev = (char)(8 | 16 | 1);
        break;
      }
      case 3:
      {
        verlev = (char)(8 | 16 | 32 | 1);
        break;
      }
      case 4:
      {
        verlev = (char)(8 | 16 | 32 | 64 | 1);
        break;
      }
      case 5:
      {
        verlev = (char)(8 | 16 | 32 | 64 | 1 | 2);
        break;
      }
      default:
        verlev = (char)(1 | 2 | 4 | 8 | 16 | 32 | 64);
    }

  setdateformat(dateformat);
  ptr = head;
  for( ; !(ptr == ((struct llnode *)NULL)); ptr = ptr->next)
  {
    n=checklogtarget(ptr);
    if(!(n == 0))
      return n;

  }
  return 0;
}

// main
// file afclient.c line 75
signed int main(signed int argc, char **argv)
{
  signed int i;
  signed int n;
  signed int numofcon;
  signed int length;
  signed int buflength;
  signed int temp;
  signed int temp2 = 0;
  signed int notsent;
  unsigned int aLength;
  struct anonymous$7 **usersTable = (struct anonymous$7 **)(void *)0;
  unsigned char buff[9000l];
  char hostname[100l];
  signed int maxfdp1;
  unsigned int addressLength;
  struct sockaddr *clientAddress;
  struct anonymous$11 rset;
  struct anonymous$11 allset;
  struct anonymous$11 wset;
  struct anonymous$11 tmpset;
  struct timeval keepAlive;
  char verbose = (char)0;
  struct anonymous *hpo;
  hpo=HttpProxyOptions_new();
  char hpoUsed = (char)0;
  struct anonymous$3 *ao;
  ao=ArOptions_new();
  struct anonymous$5 *pointer;
  char aoUsed = (char)0;
  char passwordWasSet = (char)0;
  char *realmId = (char *)(void *)0;
  char *serverName = (char *)(void *)0;
  char *managePort = (char *)(void *)0;
  char *hostName = (char *)(void *)0;
  struct portlist *destinationPorts;
  destinationPorts=PortList_new();
  char *localName = (char *)(void *)0;
  char *localPort = (char *)(void *)0;
  char *localDestinationName = (char *)(void *)0;
  char *keys = (char *)(void *)0;
  char *certif = (char *)(void *)0;
  char *store = (char *)(void *)0;
  char *dateformat = (char *)(void *)0;
  char *kaTimeout = (char *)(void *)0;
  char *filenam = (char *)(void *)0;
  char ipFamily = (char)0;
  unsigned char password[4l] = { (unsigned char)1, (unsigned char)2, (unsigned char)3, (unsigned char)4 };
  char udpMode = (char)0;
  char reverseMode = (char)0;
  char remoteMode = (char)0;
  char realmType = (char)0;
  char ignorePublicKeys = (char)0;
  struct sigaction act;
  struct anonymous$6 *moduleA;
  moduleA=Module_new();
  struct anonymous$6 *moduleB;
  moduleB=Module_new();
  struct ssl_method_st *method;
  struct ssl_ctx_st *ctx = (struct ssl_ctx_st *)(void *)0;
  if(hpo == ((struct anonymous *)NULL))
  {
    printf("Problems with memory allocation... exiting\n");
    exit(1);
  }

  if(ao == ((struct anonymous$3 *)NULL))
  {
    printf("Problems with memory allocation... exiting\n");
    exit(1);
  }

  if(moduleA == ((struct anonymous$6 *)NULL) || moduleB == ((struct anonymous$6 *)NULL))
  {
    printf("Problems with memory allocation... exiting\n");
    exit(1);
  }

  sigfillset(&act.sa_mask);
  act.sa_flags = 0;
  act.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sigaction(13, &act, (struct sigaction *)(void *)0);
  act.__sigaction_handler.sa_handler = client_sig_int;
  sigaction(2, &act, (struct sigaction *)(void *)0);
  sigaction(15, &act, (struct sigaction *)(void *)0);
  act.__sigaction_handler.sa_handler = client_sig_alrm;
  sigaction(14, &act, (struct sigaction *)(void *)0);
  remember_mainthread();
  struct plnode *return_value_PortListNode_new$1;
  unsigned long int return_value_strlen$2;
  do
  {
    n=getopt_long(argc, argv, "l:L:SP:X:BC:46huUn:m:d:p:vk:c:s:o:i:D:rP:X:VK:A:T:f:", long_options, ((signed int *)NULL));
    if(n == -1)
      break;

    switch(n)
    {
      case 104:
      {
        client_long_usage("Active port forwarder (client) v0.8.4");
        break;
      }
      case 110:
      {
        serverName = optarg;
        break;
      }
      case 83:
      {
        HttpProxyOptions_use_https(hpo);
        hpoUsed = (char)1;
        break;
      }
      case 80:
      {
        HttpProxyOptions_set_proxyname(hpo, optarg);
        hpoUsed = (char)1;
        break;
      }
      case 88:
      {
        HttpProxyOptions_set_proxyport(hpo, optarg);
        hpoUsed = (char)1;
        break;
      }
      case 66:
      {
        HttpProxyOptions_set_proxyauth_type(hpo, (char)1);
        hpoUsed = (char)1;
        break;
      }
      case 67:
      {
        HttpProxyOptions_set_proxyauth_cred(hpo, optarg);
        hpoUsed = (char)1;
        break;
      }
      case 105:
      {
        realmId = optarg;
        break;
      }
      case 109:
      {
        managePort = optarg;
        break;
      }
      case 100:
      {
        hostName = optarg;
        break;
      }
      case 112:
      {
        return_value_PortListNode_new$1=PortListNode_new(optarg);
        PortList_insert_back(destinationPorts, return_value_PortListNode_new$1);
        break;
      }
      case 118:
      {
        verbose = verbose + 1;
        break;
      }
      case 117:
      {
        udpMode = (char)1;
        break;
      }
      case 85:
      {
        reverseMode = (char)1;
        break;
      }
      case 107:
      {
        keys = optarg;
        break;
      }
      case 99:
      {
        certif = optarg;
        break;
      }
      case 115:
      {
        store = optarg;
        break;
      }
      case 102:
      {
        filenam = optarg;
        break;
      }
      case 111:
      {
        addlogtarget(optarg);
        break;
      }
      case 301:
      {
        return_value_strlen$2=strlen(optarg);
        n = (signed int)return_value_strlen$2;
        memset((void *)password, 0, (unsigned long int)4);
        i = 0;
        for( ; !(i >= n); i = i + 1)
          password[(signed long int)(i % 4)] = password[(signed long int)(i % 4)] + (unsigned char)optarg[(signed long int)i];
        passwordWasSet = (char)1;
        break;
      }
      case 302:
      {
        ignorePublicKeys = (char)1;
        break;
      }
      case 305:
      {
        ArOptions_set_arStart(ao, (char)1);
        aoUsed = (char)1;
        break;
      }
      case 306:
      {
        ArOptions_set_arQuit(ao, (char)1);
        aoUsed = (char)1;
        break;
      }
      case 307:
      {
        ArOptions_set_arPremature(ao, (char)0);
        aoUsed = (char)1;
        break;
      }
      case 311:
      {
        localName = optarg;
        break;
      }
      case 312:
      {
        localPort = optarg;
        break;
      }
      case 313:
      {
        localDestinationName = optarg;
        break;
      }
      case 52:
      {
        if(!((signed int)ipFamily == 0))
          ipFamily = (char)-1;

        else
          ipFamily = (char)4;
        break;
      }
      case 54:
      {
        if(!((signed int)ipFamily == 0))
          ipFamily = (char)-1;

        else
          ipFamily = (char)6;
        break;
      }
      case 108:
      {
        Module_set_fileName(moduleA, optarg);
        break;
      }
      case 76:
      {
        Module_set_fileName(moduleB, optarg);
        break;
      }
      case 68:
      {
        dateformat = optarg;
        break;
      }
      case 114:
      {
        remoteMode = (char)1;
        break;
      }
      case 86:
      {
        printf("%s\n", (const void *)"Active port forwarder (client) v0.8.4");
        exit(0);
        break;
      }
      case 75:
      {
        kaTimeout = optarg;
        break;
      }
      case 65:
      {
        ArOptions_set_s_arTries(ao, optarg);
        aoUsed = (char)1;
        break;
      }
      case 84:
      {
        ArOptions_set_s_arDelay(ao, optarg);
        aoUsed = (char)1;
        break;
      }
      case 63:
        client_short_usage("");
    }
  }
  while((_Bool)1);
  if(!(optind >= argc))
    client_short_usage("Unrecognized non-option elements");

  _Bool tmp_if_expr$9;
  struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$8;
  _Bool tmp_if_expr$11;
  struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$10;
  char *return_value_ClientRealm_get_serverName$12;
  char *return_value_ClientRealm_get_managePort$13;
  char *return_value_ClientRealm_get_hostName$14;
  struct portlist *return_value_ClientRealm_get_destinationPorts$15;
  signed int return_value_PortList_get_size$16;
  char *return_value_ClientRealm_get_realmId$18;
  char *return_value_ClientRealm_get_localName$19;
  char *return_value_ClientRealm_get_localPort$20;
  char *return_value_ClientRealm_get_sKeepAliveTimeout$22;
  if(!(filenam == ((char *)NULL)))
  {
    cconfig=cparsefile(filenam, &n);
    if(!(n == 0))
    {
      printf("parsing failed! line:%d\n", n);
      exit(1);
    }

    else
    {
      if(keys == ((char *)NULL))
      {
        char *return_value_ClientConfiguration_get_keysFile$3;
        return_value_ClientConfiguration_get_keysFile$3=ClientConfiguration_get_keysFile(cconfig);
        if(return_value_ClientConfiguration_get_keysFile$3 == ((char *)NULL))
          ClientConfiguration_set_keysFile(cconfig, "client.rsa");

      }

      else
        ClientConfiguration_set_keysFile(cconfig, keys);
      if(!(certif == ((char *)NULL)))
        ClientConfiguration_set_certificateFile(cconfig, certif);

      if(store == ((char *)NULL))
      {
        char *return_value_ClientConfiguration_get_storeFile$4;
        return_value_ClientConfiguration_get_storeFile$4=ClientConfiguration_get_storeFile(cconfig);
        if(return_value_ClientConfiguration_get_storeFile$4 == ((char *)NULL))
          ClientConfiguration_set_storeFile(cconfig, "known_hosts");

      }

      else
        ClientConfiguration_set_storeFile(cconfig, store);
      if(!(dateformat == ((char *)NULL)))
        ClientConfiguration_set_dateFormat(cconfig, dateformat);

      if(!(ignorePublicKeys == 0))
        ClientConfiguration_set_ignorePublicKeys(cconfig, ignorePublicKeys);

      char *return_value_ClientConfiguration_get_dateFormat$5;
      return_value_ClientConfiguration_get_dateFormat$5=ClientConfiguration_get_dateFormat(cconfig);
      initializelogging(verbose, return_value_ClientConfiguration_get_dateFormat$5);
      signed int return_value_ClientConfiguration_get_realmsNumber$6;
      return_value_ClientConfiguration_get_realmsNumber$6=ClientConfiguration_get_realmsNumber(cconfig);
      aflog((char)4, (char)8, "client's cfg file OK! (readed realms: %d)", return_value_ClientConfiguration_get_realmsNumber$6);
      signed int return_value_ClientConfiguration_get_realmsNumber$7;
      return_value_ClientConfiguration_get_realmsNumber$7=ClientConfiguration_get_realmsNumber(cconfig);
      if(return_value_ClientConfiguration_get_realmsNumber$7 == 0)
        tmp_if_expr$9 = (_Bool)1;

      else
      {
        return_value_ClientConfiguration_get_realmsTable$8=ClientConfiguration_get_realmsTable(cconfig);
        tmp_if_expr$9 = return_value_ClientConfiguration_get_realmsTable$8 == (struct anonymous$5 **)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$9)
        tmp_if_expr$11 = (_Bool)1;

      else
      {
        return_value_ClientConfiguration_get_realmsTable$10=ClientConfiguration_get_realmsTable(cconfig);
        pointer = return_value_ClientConfiguration_get_realmsTable$10[(signed long int)0];
        tmp_if_expr$11 = pointer == (struct anonymous$5 *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$11)
      {
        aflog((char)4, (char)1, "Working without sense is really without sense...");
        exit(1);
      }

      if(!(hpoUsed == 0))
        ClientRealm_set_httpProxyOptions(pointer, hpo);

      else
        HttpProxyOptions_free(&hpo);
      if(!(aoUsed == 0))
        ClientRealm_set_arOptions(pointer, ao);

      else
        ArOptions_free(&ao);
      if(!(serverName == ((char *)NULL)))
      {
        return_value_ClientRealm_get_serverName$12=ClientRealm_get_serverName(pointer);
        if(return_value_ClientRealm_get_serverName$12 == ((char *)NULL))
          ClientRealm_set_serverName(pointer, serverName);

      }

      if(!(managePort == ((char *)NULL)))
      {
        return_value_ClientRealm_get_managePort$13=ClientRealm_get_managePort(pointer);
        if(return_value_ClientRealm_get_managePort$13 == ((char *)NULL))
          ClientRealm_set_managePort(pointer, managePort);

      }

      if(!(hostName == ((char *)NULL)))
      {
        return_value_ClientRealm_get_hostName$14=ClientRealm_get_hostName(pointer);
        if(return_value_ClientRealm_get_hostName$14 == ((char *)NULL))
          ClientRealm_set_hostName(pointer, hostName);

      }

      signed int return_value_PortList_get_size$17;
      return_value_PortList_get_size$17=PortList_get_size(destinationPorts);
      if(!(return_value_PortList_get_size$17 == 0))
      {
        return_value_ClientRealm_get_destinationPorts$15=ClientRealm_get_destinationPorts(pointer);
        return_value_PortList_get_size$16=PortList_get_size(return_value_ClientRealm_get_destinationPorts$15);
        if(return_value_PortList_get_size$16 == 0)
          ClientRealm_set_destinationPorts(pointer, destinationPorts);

      }

      if(!(realmId == ((char *)NULL)))
      {
        return_value_ClientRealm_get_realmId$18=ClientRealm_get_realmId(pointer);
        if(return_value_ClientRealm_get_realmId$18 == ((char *)NULL))
          ClientRealm_set_realmId(pointer, realmId);

      }

      if(!(localName == ((char *)NULL)))
      {
        return_value_ClientRealm_get_localName$19=ClientRealm_get_localName(pointer);
        if(return_value_ClientRealm_get_localName$19 == ((char *)NULL))
          ClientRealm_set_localName(pointer, localName);

      }

      if(!(localPort == ((char *)NULL)))
      {
        return_value_ClientRealm_get_localPort$20=ClientRealm_get_localPort(pointer);
        if(return_value_ClientRealm_get_localPort$20 == ((char *)NULL))
          ClientRealm_set_localPort(pointer, localPort);

      }

      char *return_value_ClientRealm_get_localDestinationName$21;
      return_value_ClientRealm_get_localDestinationName$21=ClientRealm_get_localDestinationName(pointer);
      if(return_value_ClientRealm_get_localDestinationName$21 == ((char *)NULL) && !(localDestinationName == ((char *)NULL)))
        ClientRealm_set_localDestinationName(pointer, localDestinationName);

      if(!(kaTimeout == ((char *)NULL)))
      {
        return_value_ClientRealm_get_sKeepAliveTimeout$22=ClientRealm_get_sKeepAliveTimeout(pointer);
        if(return_value_ClientRealm_get_sKeepAliveTimeout$22 == ((char *)NULL))
          ClientRealm_set_sKeepAliveTimeout(pointer, kaTimeout);

      }

      if(!(reverseMode == 0))
        aflog((char)4, (char)32, "Warning: reverseudp will be ignored");

      if(!(udpMode == 0))
        aflog((char)4, (char)32, "Warning: udpmode will be ignored");

      if(!(remoteMode == 0))
        aflog((char)4, (char)32, "Warning: remoteadmin will be ignored");

      if(!(passwordWasSet == 0))
        aflog((char)4, (char)32, "Warning: pass will be ignored");

      char *return_value_Module_get_fileName$23;
      return_value_Module_get_fileName$23=Module_get_fileName(moduleA);
      if(!(return_value_Module_get_fileName$23 == ((char *)NULL)))
        aflog((char)4, (char)32, "Warning: load will be ignored");

      char *return_value_Module_get_fileName$24;
      return_value_Module_get_fileName$24=Module_get_fileName(moduleB);
      if(!(return_value_Module_get_fileName$24 == ((char *)NULL)))
        aflog((char)4, (char)32, "Warning: Load will be ignored");

    }
  }

  else
  {
    cconfig=ClientConfiguration_new();
    if(cconfig == ((struct anonymous$4 *)NULL))
    {
      printf("Can't allocate memory for client configuration... exiting\n");
      exit(1);
    }

    ClientConfiguration_set_keysFile(cconfig, keys);
    ClientConfiguration_set_certificateFile(cconfig, certif);
    ClientConfiguration_set_storeFile(cconfig, store);
    ClientConfiguration_set_dateFormat(cconfig, dateformat);
    ClientConfiguration_set_realmsNumber(cconfig, 1);
    ClientConfiguration_set_ignorePublicKeys(cconfig, ignorePublicKeys);
    char *return_value_ClientConfiguration_get_dateFormat$25;
    return_value_ClientConfiguration_get_dateFormat$25=ClientConfiguration_get_dateFormat(cconfig);
    initializelogging(verbose, return_value_ClientConfiguration_get_dateFormat$25);
    char *return_value_ClientConfiguration_get_keysFile$26;
    return_value_ClientConfiguration_get_keysFile$26=ClientConfiguration_get_keysFile(cconfig);
    if(return_value_ClientConfiguration_get_keysFile$26 == ((char *)NULL))
      ClientConfiguration_set_keysFile(cconfig, "client.rsa");

    char *return_value_ClientConfiguration_get_storeFile$27;
    return_value_ClientConfiguration_get_storeFile$27=ClientConfiguration_get_storeFile(cconfig);
    if(return_value_ClientConfiguration_get_storeFile$27 == ((char *)NULL))
      ClientConfiguration_set_storeFile(cconfig, "known_hosts");

    signed int return_value_ClientConfiguration_get_realmsNumber$28;
    return_value_ClientConfiguration_get_realmsNumber$28=ClientConfiguration_get_realmsNumber(cconfig);
    void *return_value_calloc$29;
    return_value_calloc$29=calloc((unsigned long int)return_value_ClientConfiguration_get_realmsNumber$28, sizeof(struct anonymous$5 *) /*8ul*/ );
    ClientConfiguration_set_realmsTable(cconfig, (struct anonymous$5 **)return_value_calloc$29);
    struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$30;
    return_value_ClientConfiguration_get_realmsTable$30=ClientConfiguration_get_realmsTable(cconfig);
    if(return_value_ClientConfiguration_get_realmsTable$30 == ((struct anonymous$5 **)NULL))
    {
      aflog((char)4, (char)1, "Can't allocate memory for ClientRealm* table... exiting");
      exit(1);
    }

    pointer=ClientRealm_new();
    if(pointer == ((struct anonymous$5 *)NULL))
    {
      aflog((char)4, (char)1, "Can't allocate memory for ClientRealm structure... exiting");
      exit(1);
    }

    struct anonymous$5 **return_value_ClientConfiguration_get_realmsTable$31;
    return_value_ClientConfiguration_get_realmsTable$31=ClientConfiguration_get_realmsTable(cconfig);
    return_value_ClientConfiguration_get_realmsTable$31[(signed long int)0] = pointer;
    ClientRealm_set_serverName(pointer, serverName);
    ClientRealm_set_managePort(pointer, managePort);
    ClientRealm_set_hostName(pointer, hostName);
    ClientRealm_set_destinationPorts(pointer, destinationPorts);
    ClientRealm_set_realmId(pointer, realmId);
    ClientRealm_set_httpProxyOptions(pointer, hpo);
    ClientRealm_set_arOptions(pointer, ao);
    ClientRealm_set_password(pointer, password);
    ClientRealm_set_localName(pointer, localName);
    ClientRealm_set_localPort(pointer, localPort);
    ClientRealm_set_localDestinationName(pointer, localDestinationName);
    ClientRealm_set_realmId(pointer, realmId);
    ClientRealm_set_sKeepAliveTimeout(pointer, kaTimeout);
    ClientRealm_set_userModule(pointer, moduleA);
    ClientRealm_set_serviceModule(pointer, moduleB);
    if(!(reverseMode == 0))
    {
      signed int return_value_ClientRealm_get_clientMode$32;
      return_value_ClientRealm_get_clientMode$32=ClientRealm_get_clientMode(pointer);
      if(return_value_ClientRealm_get_clientMode$32 == 0)
        ClientRealm_set_clientMode(pointer, 3);

      else
        ClientRealm_set_clientMode(pointer, -1);
    }

    if(!(udpMode == 0))
    {
      signed int return_value_ClientRealm_get_clientMode$33;
      return_value_ClientRealm_get_clientMode$33=ClientRealm_get_clientMode(pointer);
      if(return_value_ClientRealm_get_clientMode$33 == 0)
        ClientRealm_set_clientMode(pointer, 1);

      else
        ClientRealm_set_clientMode(pointer, -1);
    }

    if(!(remoteMode == 0))
    {
      signed int return_value_ClientRealm_get_clientMode$34;
      return_value_ClientRealm_get_clientMode$34=ClientRealm_get_clientMode(pointer);
      if(return_value_ClientRealm_get_clientMode$34 == 0)
        ClientRealm_set_clientMode(pointer, 2);

      else
        ClientRealm_set_clientMode(pointer, -1);
    }

  }
  char *return_value_ClientRealm_get_serverName$35;
  return_value_ClientRealm_get_serverName$35=ClientRealm_get_serverName(pointer);
  if(return_value_ClientRealm_get_serverName$35 == ((char *)NULL))
    client_short_usage("Name of the server is required");

  signed int return_value_ClientRealm_get_clientMode$36;
  return_value_ClientRealm_get_clientMode$36=ClientRealm_get_clientMode(pointer);
  if(return_value_ClientRealm_get_clientMode$36 == -1)
  {
    aflog((char)4, (char)1, "Conflicting/unknown client modes... exiting");
    exit(1);
  }

  char *return_value_ClientRealm_get_managePort$38;
  return_value_ClientRealm_get_managePort$38=ClientRealm_get_managePort(pointer);
  if(return_value_ClientRealm_get_managePort$38 == ((char *)NULL))
  {
    ClientRealm_set_managePort(pointer, "50126");
    signed int return_value_ClientRealm_get_clientMode$37;
    return_value_ClientRealm_get_clientMode$37=ClientRealm_get_clientMode(pointer);
    if(return_value_ClientRealm_get_clientMode$37 == 3)
      client_short_usage("Port on the server is required in reverse mode");

  }

  struct anonymous *return_value_ClientRealm_get_httpProxyOptions$40;
  return_value_ClientRealm_get_httpProxyOptions$40=ClientRealm_get_httpProxyOptions(pointer);
  char *return_value_HttpProxyOptions_get_proxyname$41;
  return_value_HttpProxyOptions_get_proxyname$41=HttpProxyOptions_get_proxyname(return_value_ClientRealm_get_httpProxyOptions$40);
  _Bool tmp_if_expr$44;
  struct anonymous *return_value_ClientRealm_get_httpProxyOptions$42;
  char *return_value_HttpProxyOptions_get_proxyport$43;
  if(!(return_value_HttpProxyOptions_get_proxyname$41 == ((char *)NULL)))
    tmp_if_expr$44 = (_Bool)1;

  else
  {
    return_value_ClientRealm_get_httpProxyOptions$42=ClientRealm_get_httpProxyOptions(pointer);
    return_value_HttpProxyOptions_get_proxyport$43=HttpProxyOptions_get_proxyport(return_value_ClientRealm_get_httpProxyOptions$42);
    tmp_if_expr$44 = return_value_HttpProxyOptions_get_proxyport$43 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$44)
  {
    char return_value_ClientRealm_get_tunnelType$39;
    return_value_ClientRealm_get_tunnelType$39=ClientRealm_get_tunnelType(pointer);
    if((signed int)return_value_ClientRealm_get_tunnelType$39 == 0)
      ClientRealm_set_tunnelType(pointer, (char)1);

    else
      ClientRealm_set_tunnelType(pointer, (char)-1);
  }

  char return_value_ClientRealm_get_tunnelType$48;
  return_value_ClientRealm_get_tunnelType$48=ClientRealm_get_tunnelType(pointer);
  if((signed int)return_value_ClientRealm_get_tunnelType$48 == 1)
  {
    struct anonymous *return_value_ClientRealm_get_httpProxyOptions$46;
    return_value_ClientRealm_get_httpProxyOptions$46=ClientRealm_get_httpProxyOptions(pointer);
    char *return_value_HttpProxyOptions_get_proxyport$47;
    return_value_HttpProxyOptions_get_proxyport$47=HttpProxyOptions_get_proxyport(return_value_ClientRealm_get_httpProxyOptions$46);
    if(return_value_HttpProxyOptions_get_proxyport$47 == ((char *)NULL))
    {
      struct anonymous *return_value_ClientRealm_get_httpProxyOptions$45;
      return_value_ClientRealm_get_httpProxyOptions$45=ClientRealm_get_httpProxyOptions(pointer);
      HttpProxyOptions_set_proxyport(return_value_ClientRealm_get_httpProxyOptions$45, "8080");
    }

  }

  signed int return_value_ClientRealm_get_clientMode$51;
  return_value_ClientRealm_get_clientMode$51=ClientRealm_get_clientMode(pointer);
  signed int return_value_ClientRealm_get_clientMode$50;
  char *return_value_ClientRealm_get_hostName$49;
  if(!(return_value_ClientRealm_get_clientMode$51 == 3))
  {
    return_value_ClientRealm_get_clientMode$50=ClientRealm_get_clientMode(pointer);
    if(!(return_value_ClientRealm_get_clientMode$50 == 2))
    {
      return_value_ClientRealm_get_hostName$49=ClientRealm_get_hostName(pointer);
      if(return_value_ClientRealm_get_hostName$49 == ((char *)NULL))
      {
        gethostname(hostname, (unsigned long int)100);
        ClientRealm_set_hostName(pointer, hostname);
      }

    }

  }

  signed int return_value_ClientRealm_get_clientMode$54;
  return_value_ClientRealm_get_clientMode$54=ClientRealm_get_clientMode(pointer);
  struct portlist *return_value_ClientRealm_get_destinationPorts$52;
  signed int return_value_PortList_get_size$53;
  if(!(return_value_ClientRealm_get_clientMode$54 == 2))
  {
    return_value_ClientRealm_get_destinationPorts$52=ClientRealm_get_destinationPorts(pointer);
    return_value_PortList_get_size$53=PortList_get_size(return_value_ClientRealm_get_destinationPorts$52);
    if(return_value_PortList_get_size$53 == 0)
      client_short_usage("Destination port number is required");

  }

  char *return_value_ClientRealm_get_sKeepAliveTimeout$58;
  return_value_ClientRealm_get_sKeepAliveTimeout$58=ClientRealm_get_sKeepAliveTimeout(pointer);
  if(!(return_value_ClientRealm_get_sKeepAliveTimeout$58 == ((char *)NULL)))
  {
    char *return_value_ClientRealm_get_sKeepAliveTimeout$55;
    return_value_ClientRealm_get_sKeepAliveTimeout$55=ClientRealm_get_sKeepAliveTimeout(pointer);
    signed int return_value_check_value$56;
    return_value_check_value$56=check_value(return_value_ClientRealm_get_sKeepAliveTimeout$55, "Invalid timeout value");
    ClientRealm_set_keepAliveTimeout(pointer, return_value_check_value$56);
    signed int return_value_ClientRealm_get_keepAliveTimeout$57;
    return_value_ClientRealm_get_keepAliveTimeout$57=ClientRealm_get_keepAliveTimeout(pointer);
    keepAlive.tv_sec = (signed long int)return_value_ClientRealm_get_keepAliveTimeout$57;
    keepAlive.tv_usec = (signed long int)0;
    ClientRealm_set_keepAlive(pointer, keepAlive);
  }

  struct anonymous$3 *return_value_ClientRealm_get_arOptions$59;
  return_value_ClientRealm_get_arOptions$59=ClientRealm_get_arOptions(pointer);
  ArOptions_evaluate_values(return_value_ClientRealm_get_arOptions$59);
  if(!(ignorePublicKeys == 0))
    ClientConfiguration_set_ignorePublicKeys(cconfig, ignorePublicKeys);

  struct anonymous$6 *return_value_ClientRealm_get_userModule$62;
  return_value_ClientRealm_get_userModule$62=ClientRealm_get_userModule(pointer);
  signed int return_value_Module_loadModule$63;
  return_value_Module_loadModule$63=Module_loadModule(return_value_ClientRealm_get_userModule$62);
  if(!(return_value_Module_loadModule$63 == 0))
  {
    struct anonymous$6 *return_value_ClientRealm_get_userModule$60;
    return_value_ClientRealm_get_userModule$60=ClientRealm_get_userModule(pointer);
    char *return_value_Module_get_fileName$61;
    return_value_Module_get_fileName$61=Module_get_fileName(return_value_ClientRealm_get_userModule$60);
    aflog((char)4, (char)1, "Loading a module %s failed!", return_value_Module_get_fileName$61);
    exit(1);
  }

  struct anonymous$6 *return_value_ClientRealm_get_serviceModule$66;
  return_value_ClientRealm_get_serviceModule$66=ClientRealm_get_serviceModule(pointer);
  signed int return_value_Module_loadModule$67;
  return_value_Module_loadModule$67=Module_loadModule(return_value_ClientRealm_get_serviceModule$66);
  if(!(return_value_Module_loadModule$67 == 0))
  {
    struct anonymous$6 *return_value_ClientRealm_get_serviceModule$64;
    return_value_ClientRealm_get_serviceModule$64=ClientRealm_get_serviceModule(pointer);
    char *return_value_Module_get_fileName$65;
    return_value_Module_get_fileName$65=Module_get_fileName(return_value_ClientRealm_get_serviceModule$64);
    aflog((char)4, (char)1, "Loading a module %s failed!", return_value_Module_get_fileName$65);
    exit(1);
  }

  realmType = (char)0;
  realmType = realmType | (char)4;
  realmType = realmType | (char)8;
  char return_value_ClientRealm_get_ipFamily$68;
  if(!((signed int)ipFamily == 0))
  {
    return_value_ClientRealm_get_ipFamily$68=ClientRealm_get_ipFamily(pointer);
    if(!((signed int)return_value_ClientRealm_get_ipFamily$68 >= 1))
      ClientRealm_set_ipFamily(pointer, ipFamily);

  }

  char return_value_ClientRealm_get_ipFamily$71;
  return_value_ClientRealm_get_ipFamily$71=ClientRealm_get_ipFamily(pointer);
  char return_value_ClientRealm_get_ipFamily$70;
  char return_value_ClientRealm_get_ipFamily$69;
  if((signed int)return_value_ClientRealm_get_ipFamily$71 == -1)
  {
    aflog((char)4, (char)1, "Conflicting types of ip protocol family... exiting");
    exit(1);
  }

  else
  {
    return_value_ClientRealm_get_ipFamily$70=ClientRealm_get_ipFamily(pointer);
    if((signed int)return_value_ClientRealm_get_ipFamily$70 == 4)
      realmType = realmType | (char)16;

    else
    {
      return_value_ClientRealm_get_ipFamily$69=ClientRealm_get_ipFamily(pointer);
      if((signed int)return_value_ClientRealm_get_ipFamily$69 == 6)
        realmType = realmType | (char)32;

    }
  }
  ipFamily = (char)0x01;
  if(!((16 & (signed int)realmType) == 0))
    ipFamily = ipFamily | (char)0x02;

  else
    if(!((32 & (signed int)realmType) == 0))
      ipFamily = ipFamily | (char)0x04;

  ClientRealm_set_ipFamily(pointer, ipFamily);
  ClientRealm_set_realmType(pointer, realmType);
  signed int return_value_ClientRealm_get_clientMode$94;
  return_value_ClientRealm_get_clientMode$94=ClientRealm_get_clientMode(pointer);
  char *tmp_if_expr$78;
  char return_value_ClientRealm_get_ipFamily$77;
  if(!(return_value_ClientRealm_get_clientMode$94 == 3))
  {
    SSL_library_init();
    method=SSLv3_client_method();
    ctx=SSL_CTX_new(method);
    signed int return_value_SSL_CTX_set_cipher_list$72;
    return_value_SSL_CTX_set_cipher_list$72=SSL_CTX_set_cipher_list(ctx, "ALL:@STRENGTH");
    if(return_value_SSL_CTX_set_cipher_list$72 == 0)
    {
      aflog((char)4, (char)1, "Setting cipher list failed... exiting");
      exit(1);
    }

    temp2=create_apf_dir((char)0);
    if(!(temp2 == 0))
    {
      aflog((char)4, (char)32, "Warning: Creating ~/.apf directory failed (%d)", temp2);
      temp2=create_apf_dir((char)1);
      if(!(temp2 == 0))
        aflog((char)4, (char)32, "Warning: Creating ./apf directory failed (%d)", temp2);

    }

    store=ClientConfiguration_get_storeFile(cconfig);
    temp2=create_publickey_store(&store);
    if(!(temp2 == 0))
      aflog((char)4, (char)32, "Warning: Something bad happened when creating public key store... (%d)", temp2);

    ClientConfiguration_set_storeFile(cconfig, store);
    keys=ClientConfiguration_get_keysFile(cconfig);
    temp2=generate_rsa_key(&keys);
    if(!(temp2 == 0))
      aflog((char)4, (char)32, "Warning: Something bad happened when generating rsa keys... (%d)", temp2);

    ClientConfiguration_set_keysFile(cconfig, keys);
    signed int return_value_SSL_CTX_use_RSAPrivateKey_file$73;
    return_value_SSL_CTX_use_RSAPrivateKey_file$73=SSL_CTX_use_RSAPrivateKey_file(ctx, keys, 1);
    if(!(return_value_SSL_CTX_use_RSAPrivateKey_file$73 == 1))
    {
      aflog((char)4, (char)1, "Setting rsa key failed (%s)... exiting", keys);
      exit(1);
    }

    certif=ClientConfiguration_get_certificateFile(cconfig);
    if(!(certif == ((char *)NULL)))
    {
      signed int return_value_SSL_CTX_use_certificate_file$74;
      return_value_SSL_CTX_use_certificate_file$74=SSL_CTX_use_certificate_file(ctx, certif, 1);
      if(!(return_value_SSL_CTX_use_certificate_file$74 == 1))
      {
        aflog((char)4, (char)1, "Setting certificate failed (%s)... exiting", certif);
        exit(1);
      }

    }

    signed int return_value_ClientRealm_get_clientMode$75;
    return_value_ClientRealm_get_clientMode$75=ClientRealm_get_clientMode(pointer);
    if(!(return_value_ClientRealm_get_clientMode$75 == 2))
    {
      if(verbose == 0)
        daemon(0, 0);

    }

    signed int return_value_ClientRealm_get_clientMode$93;
    return_value_ClientRealm_get_clientMode$93=ClientRealm_get_clientMode(pointer);
    if(return_value_ClientRealm_get_clientMode$93 == 2)
    {
      temp2 = -1;
      struct portlist *return_value_ClientRealm_get_destinationPorts$91;
      return_value_ClientRealm_get_destinationPorts$91=ClientRealm_get_destinationPorts(pointer);
      signed int return_value_PortList_get_size$92;
      return_value_PortList_get_size$92=PortList_get_size(return_value_ClientRealm_get_destinationPorts$91);
      if(return_value_PortList_get_size$92 >= 1)
      {
        char *return_value_ClientRealm_get_serverName$83;
        return_value_ClientRealm_get_serverName$83=ClientRealm_get_serverName(pointer);
        struct portlist *return_value_ClientRealm_get_destinationPorts$84;
        return_value_ClientRealm_get_destinationPorts$84=ClientRealm_get_destinationPorts(pointer);
        struct plnode *return_value_PortList_get_nth$85;
        return_value_PortList_get_nth$85=PortList_get_nth(return_value_ClientRealm_get_destinationPorts$84, 0);
        char *return_value_PortListNode_get_portName$86;
        return_value_PortListNode_get_portName$86=PortListNode_get_portName(return_value_PortList_get_nth$85);
        char return_value_ClientRealm_get_ipFamily$87;
        return_value_ClientRealm_get_ipFamily$87=ClientRealm_get_ipFamily(pointer);
        signed int return_value_ip_listen$88;
        return_value_ip_listen$88=ip_listen(&n, return_value_ClientRealm_get_serverName$83, return_value_PortListNode_get_portName$86, &addressLength, return_value_ClientRealm_get_ipFamily$87);
        if(!(return_value_ip_listen$88 == 0))
        {
          char return_value_ClientRealm_get_ipFamily$76;
          return_value_ClientRealm_get_ipFamily$76=ClientRealm_get_ipFamily(pointer);
          if(!((0x02 & (signed int)return_value_ClientRealm_get_ipFamily$76) == 0))
            tmp_if_expr$78 = "ipv4";

          else
          {
            return_value_ClientRealm_get_ipFamily$77=ClientRealm_get_ipFamily(pointer);
            tmp_if_expr$78 = ((signed int)return_value_ClientRealm_get_ipFamily$77 & 0x04) != 0 ? "ipv6" : "unspec";
          }
          char *return_value_ClientRealm_get_serverName$79;
          return_value_ClientRealm_get_serverName$79=ClientRealm_get_serverName(pointer);
          struct portlist *return_value_ClientRealm_get_destinationPorts$80;
          return_value_ClientRealm_get_destinationPorts$80=ClientRealm_get_destinationPorts(pointer);
          struct plnode *return_value_PortList_get_nth$81;
          return_value_PortList_get_nth$81=PortList_get_nth(return_value_ClientRealm_get_destinationPorts$80, 0);
          char *return_value_PortListNode_get_portName$82;
          return_value_PortListNode_get_portName$82=PortListNode_get_portName(return_value_PortList_get_nth$81);
          aflog((char)4, (char)1, "tcp_listen_%s error for %s, %s", tmp_if_expr$78, return_value_ClientRealm_get_serverName$79, return_value_PortListNode_get_portName$82);
          exit(1);
        }

        void *return_value_malloc$89;
        return_value_malloc$89=malloc((unsigned long int)addressLength);
        clientAddress = (struct sockaddr *)return_value_malloc$89;
        if(clientAddress == ((struct sockaddr *)NULL))
        {
          aflog((char)4, (char)1, "Can't allocate memory for sockaddr structure... exiting");
          exit(1);
        }

        ClientRealm_set_addressLength(pointer, addressLength);
        ClientRealm_set_clientAddress(pointer, clientAddress);
        struct sockaddr *return_value_ClientRealm_get_clientAddress$90;
        return_value_ClientRealm_get_clientAddress$90=ClientRealm_get_clientAddress(pointer);
        temp2=accept(n, return_value_ClientRealm_get_clientAddress$90, &addressLength);
      }

    }

  }

  struct anonymous$3 *return_value_ClientRealm_get_arOptions$95;
  return_value_ClientRealm_get_arOptions$95=ClientRealm_get_arOptions(pointer);
  i=ArOptions_get_arTries(return_value_ClientRealm_get_arOptions$95);
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$96;
  return_value_ClientRealm_get_masterSslFd$96=ClientRealm_get_masterSslFd(pointer);
  SslFd_set_fd(return_value_ClientRealm_get_masterSslFd$96, -1);
  signed int return_value_ClientRealm_get_clientMode$110;
  signed int return_value_ClientRealm_get_clientMode$119;
  do
  {
    temp = 0;
    struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$99;
    return_value_ClientRealm_get_masterSslFd$99=ClientRealm_get_masterSslFd(pointer);
    signed int return_value_SslFd_get_fd$100;
    return_value_SslFd_get_fd$100=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$99);
    if(!(return_value_SslFd_get_fd$100 == -1))
    {
      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$97;
      return_value_ClientRealm_get_masterSslFd$97=ClientRealm_get_masterSslFd(pointer);
      signed int return_value_SslFd_get_fd$98;
      return_value_SslFd_get_fd$98=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$97);
      close(return_value_SslFd_get_fd$98);
    }

    ClientRealm_closeUsersConnections(pointer);
    struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$101;
    return_value_ClientRealm_get_masterSslFd$101=ClientRealm_get_masterSslFd(pointer);
    SslFd_set_ssl(return_value_ClientRealm_get_masterSslFd$101, (struct ssl_st *)(void *)0);
    signed int return_value_ClientRealm_get_clientMode$115;
    return_value_ClientRealm_get_clientMode$115=ClientRealm_get_clientMode(pointer);
    if(!(return_value_ClientRealm_get_clientMode$115 == 3))
    {
      if(temp == 0)
      {
        struct anonymous$3 *return_value_ClientRealm_get_arOptions$102;
        return_value_ClientRealm_get_arOptions$102=ClientRealm_get_arOptions(pointer);
        char return_value_ArOptions_get_arStart$103;
        return_value_ArOptions_get_arStart$103=ArOptions_get_arStart(return_value_ClientRealm_get_arOptions$102);
        char return_value_ClientConfiguration_get_ignorePublicKeys$104;
        return_value_ClientConfiguration_get_ignorePublicKeys$104=ClientConfiguration_get_ignorePublicKeys(cconfig);
        signed int return_value_initialize_client_stage1$105;
        return_value_initialize_client_stage1$105=initialize_client_stage1(pointer, ctx, buff, (char)((signed int)return_value_ArOptions_get_arStart$103 == 1 ? 0 : 1), return_value_ClientConfiguration_get_ignorePublicKeys$104);
        if(!(return_value_initialize_client_stage1$105 == 0))
          temp = 1;

      }

      if(temp == 0)
      {
        return_value_ClientRealm_get_clientMode$110=ClientRealm_get_clientMode(pointer);
        if(return_value_ClientRealm_get_clientMode$110 == 2)
        {
          char return_value_ClientRealm_get_realmType$106;
          return_value_ClientRealm_get_realmType$106=ClientRealm_get_realmType(pointer);
          struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$107;
          return_value_ClientRealm_get_masterSslFd$107=ClientRealm_get_masterSslFd(pointer);
          char *return_value_ClientRealm_get_realmId$108;
          return_value_ClientRealm_get_realmId$108=ClientRealm_get_realmId(pointer);
          signed int return_value_client_admin$109;
          return_value_client_admin$109=client_admin(return_value_ClientRealm_get_realmType$106, return_value_ClientRealm_get_masterSslFd$107, buff, temp2, return_value_ClientRealm_get_realmId$108);
          return return_value_client_admin$109;
        }

      }

      if(temp == 0)
      {
        realmType=ClientRealm_get_realmType(pointer);
        struct anonymous$3 *return_value_ClientRealm_get_arOptions$111;
        return_value_ClientRealm_get_arOptions$111=ClientRealm_get_arOptions(pointer);
        char return_value_ArOptions_get_arStart$112;
        return_value_ArOptions_get_arStart$112=ArOptions_get_arStart(return_value_ClientRealm_get_arOptions$111);
        signed int return_value_initialize_client_stage2$113;
        return_value_initialize_client_stage2$113=initialize_client_stage2(pointer, buff, (char)((signed int)return_value_ArOptions_get_arStart$112 == 1 ? 0 : 1));
        if(!(return_value_initialize_client_stage2$113 == 0))
          temp = 1;

      }

    }

    else
    {
      signed int return_value_initialize_client_reverse_udp$114;
      return_value_initialize_client_reverse_udp$114=initialize_client_reverse_udp(pointer);
      if(!(return_value_initialize_client_reverse_udp$114 == 0))
        temp = 1;

    }
    if(temp == 0)
    {
      struct anonymous$3 *return_value_ClientRealm_get_arOptions$116;
      return_value_ClientRealm_get_arOptions$116=ClientRealm_get_arOptions(pointer);
      char return_value_ArOptions_get_arStart$117;
      return_value_ArOptions_get_arStart$117=ArOptions_get_arStart(return_value_ClientRealm_get_arOptions$116);
      signed int return_value_initialize_client_stage3$118;
      return_value_initialize_client_stage3$118=initialize_client_stage3(pointer, &buflength, &allset, &wset, &maxfdp1, (char)((signed int)return_value_ArOptions_get_arStart$117 == 1 ? 0 : 1));
      if(!(return_value_initialize_client_stage3$118 == 0))
        temp = 1;

    }

    if(temp == 0)
    {
      return_value_ClientRealm_get_clientMode$119=ClientRealm_get_clientMode(pointer);
      if(return_value_ClientRealm_get_clientMode$119 == 3)
        client_reverse_udp(pointer, buff, buflength);

    }

    if(i >= 1)
      i = i - 1;

    if(temp == 1 && !(i == 0))
    {
      aflog((char)4, (char)8, "Trying to reconnect...");
      struct anonymous$3 *return_value_ClientRealm_get_arOptions$120;
      return_value_ClientRealm_get_arOptions$120=ClientRealm_get_arOptions(pointer);
      signed int return_value_ArOptions_get_arDelay$121;
      return_value_ArOptions_get_arDelay$121=ArOptions_get_arDelay(return_value_ClientRealm_get_arOptions$120);
      mysleep((double)return_value_ArOptions_get_arDelay$121);
      ClientRealm_set_realmType(pointer, realmType);
    }

    if(temp == 0)
      break;

  }
  while(!(i == 0));
  signed int return_value_ClientRealm_get_clientMode$122;
  return_value_ClientRealm_get_clientMode$122=ClientRealm_get_clientMode(pointer);
  aflog((char)2, (char)8, "CLIENT STARTED mode: %s", return_value_ClientRealm_get_clientMode$122 == 1 ? "udp" : "tcp");
  char return_value_ClientRealm_get_realmType$123;
  return_value_ClientRealm_get_realmType$123=ClientRealm_get_realmType(pointer);
  char return_value_ClientRealm_get_realmType$124;
  return_value_ClientRealm_get_realmType$124=ClientRealm_get_realmType(pointer);
  char return_value_ClientRealm_get_realmType$125;
  return_value_ClientRealm_get_realmType$125=ClientRealm_get_realmType(pointer);
  _Bool tmp_if_expr$127;
  char return_value_ClientRealm_get_realmType$126;
  if(!((1 & (signed int)return_value_ClientRealm_get_realmType$125) == 0))
  {
    return_value_ClientRealm_get_realmType$126=ClientRealm_get_realmType(pointer);
    tmp_if_expr$127 = !(((signed int)return_value_ClientRealm_get_realmType$126 & 2) != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$127 = (_Bool)0;
  aflog((char)2, (char)8, "SERVER SSL: %s, ZLIB: %s, MODE: %s", ((signed int)return_value_ClientRealm_get_realmType$123 & 4) != 0 ? "yes" : "no", ((signed int)return_value_ClientRealm_get_realmType$124 & 8) != 0 ? "yes" : "no", tmp_if_expr$127 ? "tcp" : "udp");
  char return_value_ClientRealm_get_realmType$128;
  return_value_ClientRealm_get_realmType$128=ClientRealm_get_realmType(pointer);
  aflog((char)2, (char)8, "SERVER MULTI: %s", ((signed int)return_value_ClientRealm_get_realmType$128 & 64) != 0 ? "yes" : "no");
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$129;
  return_value_ClientRealm_get_masterSslFd$129=ClientRealm_get_masterSslFd(pointer);
  struct ssl_st *return_value_SslFd_get_ssl$130;
  return_value_SslFd_get_ssl$130=SslFd_get_ssl(return_value_ClientRealm_get_masterSslFd$129);
  const struct ssl_cipher_st *return_value_SSL_get_current_cipher$131;
  return_value_SSL_get_current_cipher$131=SSL_get_current_cipher(return_value_SslFd_get_ssl$130);
  const char *return_value_SSL_CIPHER_get_name$132;
  return_value_SSL_CIPHER_get_name$132=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher$131);
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$133;
  return_value_ClientRealm_get_masterSslFd$133=ClientRealm_get_masterSslFd(pointer);
  struct ssl_st *return_value_SslFd_get_ssl$134;
  return_value_SslFd_get_ssl$134=SslFd_get_ssl(return_value_ClientRealm_get_masterSslFd$133);
  const struct ssl_cipher_st *return_value_SSL_get_current_cipher$135;
  return_value_SSL_get_current_cipher$135=SSL_get_current_cipher(return_value_SslFd_get_ssl$134);
  char *return_value_SSL_CIPHER_get_version$136;
  return_value_SSL_CIPHER_get_version$136=SSL_CIPHER_get_version(return_value_SSL_get_current_cipher$135);
  aflog((char)2, (char)16, "CIPHER: %s VER: %s", return_value_SSL_CIPHER_get_name$132, return_value_SSL_CIPHER_get_version$136);
  struct anonymous$6 *return_value_ClientRealm_get_userModule$141;
  return_value_ClientRealm_get_userModule$141=ClientRealm_get_userModule(pointer);
  signed int return_value_Module_isModuleLoaded$142;
  return_value_Module_isModuleLoaded$142=Module_isModuleLoaded(return_value_ClientRealm_get_userModule$141);
  if(!(return_value_Module_isModuleLoaded$142 == 0))
  {
    struct anonymous$6 *return_value_ClientRealm_get_userModule$137;
    return_value_ClientRealm_get_userModule$137=ClientRealm_get_userModule(pointer);
    char *return_value_Module_get_fileName$138;
    return_value_Module_get_fileName$138=Module_get_fileName(return_value_ClientRealm_get_userModule$137);
    struct anonymous$6 *return_value_ClientRealm_get_userModule$139;
    return_value_ClientRealm_get_userModule$139=ClientRealm_get_userModule(pointer);
    char *return_value_Module_function_info$140;
    return_value_Module_function_info$140=Module_function_info(return_value_ClientRealm_get_userModule$139);
    aflog((char)2, (char)8, "LOADED MODULE: %s INFO: %s", return_value_Module_get_fileName$138, return_value_Module_function_info$140);
  }

  struct anonymous$6 *return_value_ClientRealm_get_serviceModule$147;
  return_value_ClientRealm_get_serviceModule$147=ClientRealm_get_serviceModule(pointer);
  signed int return_value_Module_isModuleLoaded$148;
  return_value_Module_isModuleLoaded$148=Module_isModuleLoaded(return_value_ClientRealm_get_serviceModule$147);
  if(!(return_value_Module_isModuleLoaded$148 == 0))
  {
    struct anonymous$6 *return_value_ClientRealm_get_serviceModule$143;
    return_value_ClientRealm_get_serviceModule$143=ClientRealm_get_serviceModule(pointer);
    char *return_value_Module_get_fileName$144;
    return_value_Module_get_fileName$144=Module_get_fileName(return_value_ClientRealm_get_serviceModule$143);
    struct anonymous$6 *return_value_ClientRealm_get_serviceModule$145;
    return_value_ClientRealm_get_serviceModule$145=ClientRealm_get_serviceModule(pointer);
    char *return_value_Module_function_info$146;
    return_value_Module_function_info$146=Module_function_info(return_value_ClientRealm_get_serviceModule$145);
    aflog((char)2, (char)8, "LOADED MODULE (ser): %s INFO: %s", return_value_Module_get_fileName$144, return_value_Module_function_info$146);
  }

  ClientRealm_send_realmId(pointer, buff);
  ClientRealm_enable_multi(pointer);
  signed int return_value_ClientRealm_get_usersLimit$155;
  _Bool tmp_if_expr$212;
  char return_value_ConnectUser_get_state$211;
  _Bool tmp_if_expr$214;
  char return_value_ConnectUser_get_state$213;
  signed int return_value_ConnectUser_get_connFd$174;
  signed int return_value_ConnectUser_get_connFd$175;
  signed int return_value_ConnectUser_get_connFd$176;
  signed int return_value_ConnectUser_get_connFd$177;
  signed int return_value_ConnectUser_get_connFd$178;
  signed int return_value_ConnectUser_get_connFd$179;
  struct buflist *return_value_ConnectUser_get_bufList$180;
  char return_value_ClientRealm_get_realmType$181;
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$182;
  struct anonymous$6 *return_value_ClientRealm_get_serviceModule$188;
  char *return_value_Module_get_fileName$189;
  struct anonymous$6 *return_value_ClientRealm_get_serviceModule$190;
  char *return_value_Module_function_info$191;
  struct anonymous$6 *return_value_ClientRealm_get_serviceModule$192;
  signed int return_value_ClientRealm_get_clientMode$207;
  signed int return_value_ClientRealm_get_usersLimit$215;
  _Bool tmp_if_expr$259;
  char return_value_ConnectUser_get_state$258;
  _Bool tmp_if_expr$254;
  signed int *return_value___errno_location$253;
  signed int return_value_ClientRealm_get_usersLimit$288;
  char return_value_ConnectUser_get_state$286;
  char return_value_ConnectUser_get_state$285;
  signed int return_value_ClientRealm_get_usersLimit$330;
  struct anonymous$6 *return_value_ClientRealm_get_userModule$295;
  char *return_value_ConnectUser_get_nameBuf$296;
  char *return_value_ConnectUser_get_portBuf$297;
  signed int return_value_Module_function_allow$298;
  char return_value_ClientRealm_get_realmType$302;
  signed int tmp_if_expr$326;
  signed int return_value_ConnectUser_get_connFd$325;
  char return_value_ClientRealm_get_realmType$331;
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$332;
  signed int return_value_ClientRealm_get_usersLimit$390;
  signed int return_value_ConnectUser_get_connFd$340;
  signed int return_value_ConnectUser_get_connFd$341;
  signed int return_value_ConnectUser_get_connFd$342;
  signed int return_value_ConnectUser_get_connFd$343;
  signed int return_value_ConnectUser_get_connFd$344;
  signed int return_value_ConnectUser_get_connFd$345;
  struct buflist *return_value_ConnectUser_get_bufList$346;
  char return_value_ClientRealm_get_realmType$347;
  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$348;
  struct anonymous$6 *return_value_ClientRealm_get_userModule$354;
  char *return_value_Module_get_fileName$355;
  struct anonymous$6 *return_value_ClientRealm_get_userModule$356;
  char *return_value_Module_function_info$357;
  struct anonymous$6 *return_value_ClientRealm_get_userModule$358;
  _Bool tmp_if_expr$385;
  signed int *return_value___errno_location$384;
  char return_value_ConnectUser_get_state$388;
  struct anonymous$3 *return_value_ClientRealm_get_arOptions$391;
  struct anonymous$3 *return_value_ClientRealm_get_arOptions$392;
  char return_value_ArOptions_get_arQuit$393;
  char return_value_ConnectUser_get_state$406;
  _Bool tmp_if_expr$408;
  char return_value_ConnectUser_get_state$407;
  char return_value_ConnectUser_get_state$411;
  _Bool tmp_if_expr$413;
  char return_value_ConnectUser_get_state$412;
  signed long int return_value_getcg$414;
  do
  {
    rset = allset;
    tmpset = wset;
    aflog((char)16, (char)4, "select");
    char *return_value_ClientRealm_get_sKeepAliveTimeout$154;
    return_value_ClientRealm_get_sKeepAliveTimeout$154=ClientRealm_get_sKeepAliveTimeout(pointer);
    if(!(return_value_ClientRealm_get_sKeepAliveTimeout$154 == ((char *)NULL)))
    {
      struct timeval *return_value_ClientRealm_get_keepAlivePointer$152;
      return_value_ClientRealm_get_keepAlivePointer$152=ClientRealm_get_keepAlivePointer(pointer);
      signed int return_value_select$153;
      return_value_select$153=select(maxfdp1, &rset, &tmpset, (struct anonymous$11 *)(void *)0, return_value_ClientRealm_get_keepAlivePointer$152);
      if(return_value_select$153 == 0)
      {
        aflog((char)2, (char)2, "timeout: sending keep-alive packet");
        buff[(signed long int)0] = (unsigned char)16;
        char return_value_ClientRealm_get_realmType$149;
        return_value_ClientRealm_get_realmType$149=ClientRealm_get_realmType(pointer);
        struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$150;
        return_value_ClientRealm_get_masterSslFd$150=ClientRealm_get_masterSslFd(pointer);
        SslFd_send_message(return_value_ClientRealm_get_realmType$149, return_value_ClientRealm_get_masterSslFd$150, buff, 5);
        signed int return_value_ClientRealm_get_keepAliveTimeout$151;
        return_value_ClientRealm_get_keepAliveTimeout$151=ClientRealm_get_keepAliveTimeout(pointer);
        keepAlive.tv_sec = (signed long int)return_value_ClientRealm_get_keepAliveTimeout$151;
        keepAlive.tv_usec = (signed long int)0;
        ClientRealm_set_keepAlive(pointer, keepAlive);
      }

    }

    else
      select(maxfdp1, &rset, &tmpset, (struct anonymous$11 *)(void *)0, (struct timeval *)(void *)0);
    aflog((char)16, (char)4, "after select...");
    usersTable=ClientRealm_get_usersTable(pointer);
    i = 0;
    do
    {
      return_value_ClientRealm_get_usersLimit$155=ClientRealm_get_usersLimit(pointer);
      if(i >= return_value_ClientRealm_get_usersLimit$155)
        break;

      char return_value_ConnectUser_get_state$210;
      return_value_ConnectUser_get_state$210=ConnectUser_get_state(usersTable[(signed long int)i]);
      if((signed int)return_value_ConnectUser_get_state$210 == 7)
        tmp_if_expr$212 = (_Bool)1;

      else
      {
        return_value_ConnectUser_get_state$211=ConnectUser_get_state(usersTable[(signed long int)i]);
        tmp_if_expr$212 = (signed int)return_value_ConnectUser_get_state$211 == 11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$212)
        tmp_if_expr$214 = (_Bool)1;

      else
      {
        return_value_ConnectUser_get_state$213=ConnectUser_get_state(usersTable[(signed long int)i]);
        tmp_if_expr$214 = (signed int)return_value_ConnectUser_get_state$213 == 19 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$214)
      {
        signed int return_value_ConnectUser_get_connFd$208;
        return_value_ConnectUser_get_connFd$208=ConnectUser_get_connFd(usersTable[(signed long int)i]);
        signed int return_value_ConnectUser_get_connFd$209;
        return_value_ConnectUser_get_connFd$209=ConnectUser_get_connFd(usersTable[(signed long int)i]);
        if(!((rset.__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$208 / 8)] & 1l << return_value_ConnectUser_get_connFd$209 % 8) == 0l))
        {
          aflog((char)1, (char)4, "user[%d]: FD_ISSET", i);
          signed int return_value_ConnectUser_get_connFd$156;
          return_value_ConnectUser_get_connFd$156=ConnectUser_get_connFd(usersTable[(signed long int)i]);
          signed long int return_value_read$157;
          return_value_read$157=read(return_value_ConnectUser_get_connFd$156, (void *)&buff[(signed long int)5], (unsigned long int)8091);
          n = (signed int)return_value_read$157;
          if(n == -1)
          {
            signed int *return_value___errno_location$158;
            return_value___errno_location$158=__errno_location();
            if(*return_value___errno_location$158 == 11)
              goto __CPROVER_DUMP_L190;

            signed int *return_value___errno_location$159;
            return_value___errno_location$159=__errno_location();
            aflog((char)1, (char)64, "error (%d): while reading from service", *return_value___errno_location$159);
            n = 0;
          }

          struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$160;
          return_value_ClientRealm_get_masterSslFd$160=ClientRealm_get_masterSslFd(pointer);
          signed int return_value_SslFd_get_fd$161;
          return_value_SslFd_get_fd$161=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$160);
          signed int return_value_ioctl$162;
          return_value_ioctl$162=ioctl(return_value_SslFd_get_fd$161, (unsigned long int)0x5411, &notsent);
          if(!(return_value_ioctl$162 == 0))
          {
            aflog((char)1, (char)1, "ioctl error -> exiting...");
            exit(1);
          }

          signed int return_value_ClientRealm_get_clientMode$166;
          return_value_ClientRealm_get_clientMode$166=ClientRealm_get_clientMode(pointer);
          if(return_value_ClientRealm_get_clientMode$166 == 1)
          {
            aLength = (unsigned int)4;
            struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$163;
            return_value_ClientRealm_get_masterSslFd$163=ClientRealm_get_masterSslFd(pointer);
            signed int return_value_SslFd_get_fd$164;
            return_value_SslFd_get_fd$164=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$163);
            signed int return_value_getsockopt$165;
            return_value_getsockopt$165=getsockopt(return_value_SslFd_get_fd$164, 1, 7, (void *)&temp2, &aLength);
            if(!(return_value_getsockopt$165 == -1))
            {
              if(!(temp2 == buflength))
              {
                buflength = temp2;
                aflog((char)1, (char)32, "Send buffer size changed...");
              }

            }

            if(5 + n + notsent >= buflength)
            {
              aflog((char)1, (char)32, "user[%d]: DROP size:%d, buf:%d, w:%d/%d", i, n + 5, buflength, notsent, buflength);
              goto __CPROVER_DUMP_L190;
            }

          }

          if(!(n == 0))
          {
            struct anonymous$6 *return_value_ClientRealm_get_serviceModule$193;
            return_value_ClientRealm_get_serviceModule$193=ClientRealm_get_serviceModule(pointer);
            signed int return_value_Module_isModuleLoaded$194;
            return_value_Module_isModuleLoaded$194=Module_isModuleLoaded(return_value_ClientRealm_get_serviceModule$193);
            if(!(return_value_Module_isModuleLoaded$194 == 0))
            {
              struct anonymous$6 *return_value_ClientRealm_get_serviceModule$167;
              return_value_ClientRealm_get_serviceModule$167=ClientRealm_get_serviceModule(pointer);
              char *return_value_ConnectUser_get_nameBuf$168;
              return_value_ConnectUser_get_nameBuf$168=ConnectUser_get_nameBuf(usersTable[(signed long int)i]);
              temp2=Module_function_filter(return_value_ClientRealm_get_serviceModule$167, return_value_ConnectUser_get_nameBuf$168, &buff[(signed long int)5], &n);
              switch(temp2)
              {
                case 1:

                case 4:
                {
                  aflog((char)1, (char)32, "user[%d] (by ser): PACKET IGNORED BY MODULE", i);
                  if(temp2 == 4)
                  {
                    struct anonymous$6 *return_value_ClientRealm_get_serviceModule$169;
                    return_value_ClientRealm_get_serviceModule$169=ClientRealm_get_serviceModule(pointer);
                    char *return_value_Module_get_fileName$170;
                    return_value_Module_get_fileName$170=Module_get_fileName(return_value_ClientRealm_get_serviceModule$169);
                    struct anonymous$6 *return_value_ClientRealm_get_serviceModule$171;
                    return_value_ClientRealm_get_serviceModule$171=ClientRealm_get_serviceModule(pointer);
                    char *return_value_Module_function_info$172;
                    return_value_Module_function_info$172=Module_function_info(return_value_ClientRealm_get_serviceModule$171);
                    aflog((char)16, (char)8, "RELEASED MODULE (ser): %s INFO: %s", return_value_Module_get_fileName$170, return_value_Module_function_info$172);
                    struct anonymous$6 *return_value_ClientRealm_get_serviceModule$173;
                    return_value_ClientRealm_get_serviceModule$173=ClientRealm_get_serviceModule(pointer);
                    Module_releaseModule(return_value_ClientRealm_get_serviceModule$173);
                  }

                  goto __CPROVER_DUMP_L190;
                }
                case 2:

                case 5:
                {
                  aflog((char)1, (char)16, "user[%d] (by ser): DROPPED BY MODULE", i);
                  return_value_ConnectUser_get_connFd$174=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  close(return_value_ConnectUser_get_connFd$174);
                  return_value_ConnectUser_get_connFd$175=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", i, return_value_ConnectUser_get_connFd$175);
                  return_value_ConnectUser_get_connFd$176=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  return_value_ConnectUser_get_connFd$177=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$176 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$176 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$177 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  return_value_ConnectUser_get_connFd$178=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  return_value_ConnectUser_get_connFd$179=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$178 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$178 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$179 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  ConnectUser_set_state(usersTable[(signed long int)i], (char)5);
                  return_value_ConnectUser_get_bufList$180=ConnectUser_get_bufList(usersTable[(signed long int)i]);
                  BufList_clear(return_value_ConnectUser_get_bufList$180);
                  buff[(signed long int)0] = (unsigned char)1;
                  buff[(signed long int)1] = (unsigned char)(i >> 8);
                  buff[(signed long int)2] = (unsigned char)i;
                  return_value_ClientRealm_get_realmType$181=ClientRealm_get_realmType(pointer);
                  return_value_ClientRealm_get_masterSslFd$182=ClientRealm_get_masterSslFd(pointer);
                  SslFd_send_message(return_value_ClientRealm_get_realmType$181, return_value_ClientRealm_get_masterSslFd$182, buff, 5);
                  if(temp2 == 5)
                  {
                    struct anonymous$6 *return_value_ClientRealm_get_serviceModule$183;
                    return_value_ClientRealm_get_serviceModule$183=ClientRealm_get_serviceModule(pointer);
                    char *return_value_Module_get_fileName$184;
                    return_value_Module_get_fileName$184=Module_get_fileName(return_value_ClientRealm_get_serviceModule$183);
                    struct anonymous$6 *return_value_ClientRealm_get_serviceModule$185;
                    return_value_ClientRealm_get_serviceModule$185=ClientRealm_get_serviceModule(pointer);
                    char *return_value_Module_function_info$186;
                    return_value_Module_function_info$186=Module_function_info(return_value_ClientRealm_get_serviceModule$185);
                    aflog((char)16, (char)8, "RELEASED MODULE (ser): %s INFO: %s", return_value_Module_get_fileName$184, return_value_Module_function_info$186);
                    struct anonymous$6 *return_value_ClientRealm_get_serviceModule$187;
                    return_value_ClientRealm_get_serviceModule$187=ClientRealm_get_serviceModule(pointer);
                    Module_releaseModule(return_value_ClientRealm_get_serviceModule$187);
                  }

                  goto __CPROVER_DUMP_L190;
                }
                case 3:
                {
                  return_value_ClientRealm_get_serviceModule$188=ClientRealm_get_serviceModule(pointer);
                  return_value_Module_get_fileName$189=Module_get_fileName(return_value_ClientRealm_get_serviceModule$188);
                  return_value_ClientRealm_get_serviceModule$190=ClientRealm_get_serviceModule(pointer);
                  return_value_Module_function_info$191=Module_function_info(return_value_ClientRealm_get_serviceModule$190);
                  aflog((char)16, (char)8, "RELEASED MODULE (ser): %s INFO: %s", return_value_Module_get_fileName$189, return_value_Module_function_info$191);
                  return_value_ClientRealm_get_serviceModule$192=ClientRealm_get_serviceModule(pointer);
                  Module_releaseModule(return_value_ClientRealm_get_serviceModule$192);
                }
                default:
                  ;
              }
            }

            buff[(signed long int)0] = (unsigned char)3;
            buff[(signed long int)1] = (unsigned char)(i >> 8);
            buff[(signed long int)2] = (unsigned char)i;
            buff[(signed long int)3] = (unsigned char)(n >> 8);
            buff[(signed long int)4] = (unsigned char)n;
            aflog((char)1, (char)2, "user[%d]: TO msglen: %d [%d/%d]", i, n, notsent, buflength);
            char return_value_ClientRealm_get_realmType$195;
            return_value_ClientRealm_get_realmType$195=ClientRealm_get_realmType(pointer);
            struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$196;
            return_value_ClientRealm_get_masterSslFd$196=ClientRealm_get_masterSslFd(pointer);
            SslFd_send_message(return_value_ClientRealm_get_realmType$195, return_value_ClientRealm_get_masterSslFd$196, buff, n + 5);
          }

          else
          {
            return_value_ClientRealm_get_clientMode$207=ClientRealm_get_clientMode(pointer);
            if(!(return_value_ClientRealm_get_clientMode$207 == 1))
            {
              aflog((char)1, (char)8, "user[%d]: CLOSING", i);
              signed int return_value_ConnectUser_get_connFd$197;
              return_value_ConnectUser_get_connFd$197=ConnectUser_get_connFd(usersTable[(signed long int)i]);
              close(return_value_ConnectUser_get_connFd$197);
              signed int return_value_ConnectUser_get_connFd$198;
              return_value_ConnectUser_get_connFd$198=ConnectUser_get_connFd(usersTable[(signed long int)i]);
              aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", i, return_value_ConnectUser_get_connFd$198);
              signed int return_value_ConnectUser_get_connFd$199;
              return_value_ConnectUser_get_connFd$199=ConnectUser_get_connFd(usersTable[(signed long int)i]);
              signed int return_value_ConnectUser_get_connFd$200;
              return_value_ConnectUser_get_connFd$200=ConnectUser_get_connFd(usersTable[(signed long int)i]);
              (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$199 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$199 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$200 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
              signed int return_value_ConnectUser_get_connFd$201;
              return_value_ConnectUser_get_connFd$201=ConnectUser_get_connFd(usersTable[(signed long int)i]);
              signed int return_value_ConnectUser_get_connFd$202;
              return_value_ConnectUser_get_connFd$202=ConnectUser_get_connFd(usersTable[(signed long int)i]);
              (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$201 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$201 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$202 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
              char return_value_ConnectUser_get_state$203;
              return_value_ConnectUser_get_state$203=ConnectUser_get_state(usersTable[(signed long int)i]);
              if((signed int)return_value_ConnectUser_get_state$203 == 19)
                ConnectUser_set_state(usersTable[(signed long int)i], (char)0);

              else
                ConnectUser_set_state(usersTable[(signed long int)i], (char)5);
              struct buflist *return_value_ConnectUser_get_bufList$204;
              return_value_ConnectUser_get_bufList$204=ConnectUser_get_bufList(usersTable[(signed long int)i]);
              BufList_clear(return_value_ConnectUser_get_bufList$204);
              buff[(signed long int)0] = (unsigned char)1;
              buff[(signed long int)1] = (unsigned char)(i >> 8);
              buff[(signed long int)2] = (unsigned char)i;
              char return_value_ClientRealm_get_realmType$205;
              return_value_ClientRealm_get_realmType$205=ClientRealm_get_realmType(pointer);
              struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$206;
              return_value_ClientRealm_get_masterSslFd$206=ClientRealm_get_masterSslFd(pointer);
              SslFd_send_message(return_value_ClientRealm_get_realmType$205, return_value_ClientRealm_get_masterSslFd$206, buff, 5);
            }

          }
        }

      }


    __CPROVER_DUMP_L190:
      ;
      i = i + 1;
    }
    while((_Bool)1);
    i = 0;
    do
    {
      return_value_ClientRealm_get_usersLimit$215=ClientRealm_get_usersLimit(pointer);
      if(i >= return_value_ClientRealm_get_usersLimit$215)
        break;

      char return_value_ConnectUser_get_state$257;
      return_value_ConnectUser_get_state$257=ConnectUser_get_state(usersTable[(signed long int)i]);
      if((signed int)return_value_ConnectUser_get_state$257 == 11)
        tmp_if_expr$259 = (_Bool)1;

      else
      {
        return_value_ConnectUser_get_state$258=ConnectUser_get_state(usersTable[(signed long int)i]);
        tmp_if_expr$259 = (signed int)return_value_ConnectUser_get_state$258 == 19 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$259)
      {
        signed int return_value_ConnectUser_get_connFd$255;
        return_value_ConnectUser_get_connFd$255=ConnectUser_get_connFd(usersTable[(signed long int)i]);
        signed int return_value_ConnectUser_get_connFd$256;
        return_value_ConnectUser_get_connFd$256=ConnectUser_get_connFd(usersTable[(signed long int)i]);
        if(!((tmpset.__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$255 / 8)] & 1l << return_value_ConnectUser_get_connFd$256 % 8) == 0l))
        {
          aflog((char)1, (char)4, "user[%d]: FD_ISSET - WRITE", i);
          struct buflist *return_value_ConnectUser_get_bufList$216;
          return_value_ConnectUser_get_bufList$216=ConnectUser_get_bufList(usersTable[(signed long int)i]);
          struct blnode *return_value_BufList_get_first$217;
          return_value_BufList_get_first$217=BufList_get_first(return_value_ConnectUser_get_bufList$216);
          n=BufListNode_readMessageLength(return_value_BufList_get_first$217);
          signed int return_value_ConnectUser_get_connFd$218;
          return_value_ConnectUser_get_connFd$218=ConnectUser_get_connFd(usersTable[(signed long int)i]);
          struct buflist *return_value_ConnectUser_get_bufList$219;
          return_value_ConnectUser_get_bufList$219=ConnectUser_get_bufList(usersTable[(signed long int)i]);
          struct blnode *return_value_BufList_get_first$220;
          return_value_BufList_get_first$220=BufList_get_first(return_value_ConnectUser_get_bufList$219);
          unsigned char *return_value_BufListNode_readMessage$221;
          return_value_BufListNode_readMessage$221=BufListNode_readMessage(return_value_BufList_get_first$220);
          signed long int return_value_write$222;
          return_value_write$222=write(return_value_ConnectUser_get_connFd$218, (const void *)return_value_BufListNode_readMessage$221, (unsigned long int)n);
          temp2 = (signed int)return_value_write$222;
          if(temp2 >= 1 && !(temp2 == n))
          {
            struct buflist *return_value_ConnectUser_get_bufList$223;
            return_value_ConnectUser_get_bufList$223=ConnectUser_get_bufList(usersTable[(signed long int)i]);
            struct blnode *return_value_BufList_get_first$224;
            return_value_BufList_get_first$224=BufList_get_first(return_value_ConnectUser_get_bufList$223);
            struct buflist *return_value_ConnectUser_get_bufList$225;
            return_value_ConnectUser_get_bufList$225=ConnectUser_get_bufList(usersTable[(signed long int)i]);
            struct blnode *return_value_BufList_get_first$226;
            return_value_BufList_get_first$226=BufList_get_first(return_value_ConnectUser_get_bufList$225);
            signed int return_value_BufListNode_get_actPtr$227;
            return_value_BufListNode_get_actPtr$227=BufListNode_get_actPtr(return_value_BufList_get_first$226);
            BufListNode_set_actPtr(return_value_BufList_get_first$224, return_value_BufListNode_get_actPtr$227 + temp2);
          }

          else
          {
            if(temp2 == -1)
            {
              return_value___errno_location$253=__errno_location();
              tmp_if_expr$254 = *return_value___errno_location$253 == 11 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$254 = (_Bool)0;
            if(tmp_if_expr$254)
              aflog((char)1, (char)2, "user[%d]: Couldn't write?", i);

            else
              if(temp2 == -1)
              {
                signed int return_value_ConnectUser_get_connFd$228;
                return_value_ConnectUser_get_connFd$228=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                close(return_value_ConnectUser_get_connFd$228);
                signed int return_value_ConnectUser_get_connFd$229;
                return_value_ConnectUser_get_connFd$229=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", i, return_value_ConnectUser_get_connFd$229);
                signed int return_value_ConnectUser_get_connFd$230;
                return_value_ConnectUser_get_connFd$230=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                signed int return_value_ConnectUser_get_connFd$231;
                return_value_ConnectUser_get_connFd$231=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$230 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$230 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$231 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                signed int return_value_ConnectUser_get_connFd$232;
                return_value_ConnectUser_get_connFd$232=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                signed int return_value_ConnectUser_get_connFd$233;
                return_value_ConnectUser_get_connFd$233=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$232 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$232 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$233 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                char return_value_ConnectUser_get_state$234;
                return_value_ConnectUser_get_state$234=ConnectUser_get_state(usersTable[(signed long int)i]);
                if((signed int)return_value_ConnectUser_get_state$234 == 19)
                  ConnectUser_set_state(usersTable[(signed long int)i], (char)0);

                else
                  ConnectUser_set_state(usersTable[(signed long int)i], (char)5);
                buff[(signed long int)0] = (unsigned char)1;
                buff[(signed long int)1] = (unsigned char)(i >> 8);
                buff[(signed long int)2] = (unsigned char)i;
                char return_value_ClientRealm_get_realmType$235;
                return_value_ClientRealm_get_realmType$235=ClientRealm_get_realmType(pointer);
                struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$236;
                return_value_ClientRealm_get_masterSslFd$236=ClientRealm_get_masterSslFd(pointer);
                SslFd_send_message(return_value_ClientRealm_get_realmType$235, return_value_ClientRealm_get_masterSslFd$236, buff, 5);
              }

              else
              {
                struct buflist *return_value_ConnectUser_get_bufList$237;
                return_value_ConnectUser_get_bufList$237=ConnectUser_get_bufList(usersTable[(signed long int)i]);
                BufList_delete_first(return_value_ConnectUser_get_bufList$237);
                struct buflist *return_value_ConnectUser_get_bufList$251;
                return_value_ConnectUser_get_bufList$251=ConnectUser_get_bufList(usersTable[(signed long int)i]);
                struct blnode *return_value_BufList_get_first$252;
                return_value_BufList_get_first$252=BufList_get_first(return_value_ConnectUser_get_bufList$251);
                if(return_value_BufList_get_first$252 == ((struct blnode *)NULL))
                {
                  signed int return_value_ConnectUser_get_connFd$238;
                  return_value_ConnectUser_get_connFd$238=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  signed int return_value_ConnectUser_get_connFd$239;
                  return_value_ConnectUser_get_connFd$239=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                  (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$238 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$238 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$239 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  buff[(signed long int)0] = (unsigned char)10;
                  buff[(signed long int)1] = (unsigned char)(i >> 8);
                  buff[(signed long int)2] = (unsigned char)i;
                  aflog((char)1, (char)4, "FROM user[%d]: BUFFERING MESSAGE ENDED", i);
                  char return_value_ClientRealm_get_realmType$240;
                  return_value_ClientRealm_get_realmType$240=ClientRealm_get_realmType(pointer);
                  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$241;
                  return_value_ClientRealm_get_masterSslFd$241=ClientRealm_get_masterSslFd(pointer);
                  SslFd_send_message(return_value_ClientRealm_get_realmType$240, return_value_ClientRealm_get_masterSslFd$241, buff, 5);
                  char return_value_ConnectUser_get_state$250;
                  return_value_ConnectUser_get_state$250=ConnectUser_get_state(usersTable[(signed long int)i]);
                  if((signed int)return_value_ConnectUser_get_state$250 == 19)
                  {
                    signed int return_value_ConnectUser_get_connFd$242;
                    return_value_ConnectUser_get_connFd$242=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                    close(return_value_ConnectUser_get_connFd$242);
                    signed int return_value_ConnectUser_get_connFd$243;
                    return_value_ConnectUser_get_connFd$243=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                    aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", i, return_value_ConnectUser_get_connFd$243);
                    signed int return_value_ConnectUser_get_connFd$244;
                    return_value_ConnectUser_get_connFd$244=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                    signed int return_value_ConnectUser_get_connFd$245;
                    return_value_ConnectUser_get_connFd$245=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                    (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$244 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$244 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$245 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                    signed int return_value_ConnectUser_get_connFd$246;
                    return_value_ConnectUser_get_connFd$246=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                    signed int return_value_ConnectUser_get_connFd$247;
                    return_value_ConnectUser_get_connFd$247=ConnectUser_get_connFd(usersTable[(signed long int)i]);
                    (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$246 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$246 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$247 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                    ConnectUser_set_state(usersTable[(signed long int)i], (char)0);
                    buff[(signed long int)0] = (unsigned char)1;
                    buff[(signed long int)1] = (unsigned char)(i >> 8);
                    buff[(signed long int)2] = (unsigned char)i;
                    char return_value_ClientRealm_get_realmType$248;
                    return_value_ClientRealm_get_realmType$248=ClientRealm_get_realmType(pointer);
                    struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$249;
                    return_value_ClientRealm_get_masterSslFd$249=ClientRealm_get_masterSslFd(pointer);
                    SslFd_send_message(return_value_ClientRealm_get_realmType$248, return_value_ClientRealm_get_masterSslFd$249, buff, 5);
                  }

                  else
                    ConnectUser_set_state(usersTable[(signed long int)i], (char)7);
                }

              }
          }
        }

      }

      i = i + 1;
    }
    while((_Bool)1);
    struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$415;
    return_value_ClientRealm_get_masterSslFd$415=ClientRealm_get_masterSslFd(pointer);
    signed int return_value_SslFd_get_fd$416;
    return_value_SslFd_get_fd$416=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$415);
    struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$417;
    return_value_ClientRealm_get_masterSslFd$417=ClientRealm_get_masterSslFd(pointer);
    signed int return_value_SslFd_get_fd$418;
    return_value_SslFd_get_fd$418=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$417);
    if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd$416 / 8)] & 1l << return_value_SslFd_get_fd$418 % 8) == 0l))
    {
      aflog((char)2, (char)4, "masterfd: FD_ISSET");
      char return_value_ClientRealm_get_realmType$260;
      return_value_ClientRealm_get_realmType$260=ClientRealm_get_realmType(pointer);
      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$261;
      return_value_ClientRealm_get_masterSslFd$261=ClientRealm_get_masterSslFd(pointer);
      n=SslFd_get_message(return_value_ClientRealm_get_realmType$260, return_value_ClientRealm_get_masterSslFd$261, buff, 5);
      if(!(n == 5))
      {
        aflog((char)2, (char)64, "FATAL ERROR! (%d)", n);
        if(n == -1)
        {
          char return_value_ClientRealm_get_realmType$263;
          return_value_ClientRealm_get_realmType$263=ClientRealm_get_realmType(pointer);
          if(!((4 & (signed int)return_value_ClientRealm_get_realmType$263) == 0))
          {
            struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$262;
            return_value_ClientRealm_get_masterSslFd$262=ClientRealm_get_masterSslFd(pointer);
            get_ssl_error(return_value_ClientRealm_get_masterSslFd$262, "FE", n);
            continue;
          }

        }

        if(!(n == 0))
          exit(1);

      }

      if(n == 0)
      {
        struct anonymous$3 *return_value_ClientRealm_get_arOptions$264;
        return_value_ClientRealm_get_arOptions$264=ClientRealm_get_arOptions(pointer);
        i=ArOptions_get_arTries(return_value_ClientRealm_get_arOptions$264);
        struct anonymous$3 *return_value_ClientRealm_get_arOptions$265;
        return_value_ClientRealm_get_arOptions$265=ClientRealm_get_arOptions(pointer);
        char return_value_ArOptions_get_arPremature$266;
        return_value_ArOptions_get_arPremature$266=ArOptions_get_arPremature(return_value_ClientRealm_get_arOptions$265);
        if((signed int)return_value_ArOptions_get_arPremature$266 == 0)
          i = 0;

        if(!(i == 0))
          aflog((char)2, (char)64, "SERVER: premature quit -> auto-reconnect enabled");

        while(!(i == 0))
        {
          ClientRealm_closeUsersConnections(pointer);
          struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$267;
          return_value_ClientRealm_get_masterSslFd$267=ClientRealm_get_masterSslFd(pointer);
          signed int return_value_SslFd_get_fd$268;
          return_value_SslFd_get_fd$268=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$267);
          close(return_value_SslFd_get_fd$268);
          struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$269;
          return_value_ClientRealm_get_masterSslFd$269=ClientRealm_get_masterSslFd(pointer);
          SslFd_set_ssl(return_value_ClientRealm_get_masterSslFd$269, (struct ssl_st *)(void *)0);
          struct anonymous$3 *return_value_ClientRealm_get_arOptions$270;
          return_value_ClientRealm_get_arOptions$270=ClientRealm_get_arOptions(pointer);
          signed int return_value_ArOptions_get_arDelay$271;
          return_value_ArOptions_get_arDelay$271=ArOptions_get_arDelay(return_value_ClientRealm_get_arOptions$270);
          mysleep((double)return_value_ArOptions_get_arDelay$271);
          aflog((char)2, (char)8, "Trying to reconnect...");
          temp2 = 0;
          if(temp2 == 0)
          {
            char return_value_ClientConfiguration_get_ignorePublicKeys$272;
            return_value_ClientConfiguration_get_ignorePublicKeys$272=ClientConfiguration_get_ignorePublicKeys(cconfig);
            signed int return_value_initialize_client_stage1$273;
            return_value_initialize_client_stage1$273=initialize_client_stage1(pointer, ctx, buff, (char)0, return_value_ClientConfiguration_get_ignorePublicKeys$272);
            if(!(return_value_initialize_client_stage1$273 == 0))
              temp2 = 1;

          }

          if(temp2 == 0)
          {
            signed int return_value_initialize_client_stage2$274;
            return_value_initialize_client_stage2$274=initialize_client_stage2(pointer, buff, (char)0);
            if(!(return_value_initialize_client_stage2$274 == 0))
              temp2 = 1;

          }

          if(temp2 == 0)
          {
            signed int return_value_initialize_client_stage3$275;
            return_value_initialize_client_stage3$275=initialize_client_stage3(pointer, &buflength, &allset, &wset, &maxfdp1, (char)0);
            if(!(return_value_initialize_client_stage3$275 == 0))
              temp2 = 1;

          }

          if(temp2 == 0)
          {
            n = 1;
            aflog((char)2, (char)8, "Reconnected successfully...");
            usersTable=ClientRealm_get_usersTable(pointer);
            ClientRealm_send_realmId(pointer, buff);
            ClientRealm_enable_multi(pointer);
            break;
          }

          if(i >= 1)
            i = i - 1;

        }
        if(n == 0)
        {
          aflog((char)2, (char)1, "SERVER: premature quit -> exiting...");
          exit(1);
        }

        continue;
      }

      numofcon = (signed int)buff[(signed long int)1];
      numofcon = numofcon << 8;
      numofcon = numofcon + (signed int)buff[(signed long int)2];
      length = (signed int)buff[(signed long int)3];
      length = length << 8;
      length = length + (signed int)buff[(signed long int)4];
      switch((signed int)buff[(signed long int)0])
      {
        case 1:
        {
          aflog((char)1, (char)4, "user[%d]: AF_S_CONCLOSED", numofcon);
          if(numofcon >= 0)
          {
            return_value_ClientRealm_get_usersLimit$288=ClientRealm_get_usersLimit(pointer);
            if(return_value_ClientRealm_get_usersLimit$288 >= numofcon)
            {
              char return_value_ConnectUser_get_state$287;
              return_value_ConnectUser_get_state$287=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
              if((signed int)return_value_ConnectUser_get_state$287 == 5)
              {
                ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)0);
                aflog((char)1, (char)8, "user[%d]: CLOSE CONFIRMED", numofcon);
              }

              else
              {
                return_value_ConnectUser_get_state$286=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
                if((signed int)return_value_ConnectUser_get_state$286 == 7)
                {
                  aflog((char)1, (char)8, "user[%d]: CLOSED", numofcon);
                  signed int return_value_ConnectUser_get_connFd$276;
                  return_value_ConnectUser_get_connFd$276=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  close(return_value_ConnectUser_get_connFd$276);
                  signed int return_value_ConnectUser_get_connFd$277;
                  return_value_ConnectUser_get_connFd$277=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", numofcon, return_value_ConnectUser_get_connFd$277);
                  signed int return_value_ConnectUser_get_connFd$278;
                  return_value_ConnectUser_get_connFd$278=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  signed int return_value_ConnectUser_get_connFd$279;
                  return_value_ConnectUser_get_connFd$279=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$278 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$278 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$279 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  signed int return_value_ConnectUser_get_connFd$280;
                  return_value_ConnectUser_get_connFd$280=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  signed int return_value_ConnectUser_get_connFd$281;
                  return_value_ConnectUser_get_connFd$281=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$280 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$280 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$281 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)0);
                  struct buflist *return_value_ConnectUser_get_bufList$282;
                  return_value_ConnectUser_get_bufList$282=ConnectUser_get_bufList(usersTable[(signed long int)numofcon]);
                  BufList_clear(return_value_ConnectUser_get_bufList$282);
                  buff[(signed long int)0] = (unsigned char)1;
                  buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                  buff[(signed long int)2] = (unsigned char)numofcon;
                  char return_value_ClientRealm_get_realmType$283;
                  return_value_ClientRealm_get_realmType$283=ClientRealm_get_realmType(pointer);
                  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$284;
                  return_value_ClientRealm_get_masterSslFd$284=ClientRealm_get_masterSslFd(pointer);
                  SslFd_send_message(return_value_ClientRealm_get_realmType$283, return_value_ClientRealm_get_masterSslFd$284, buff, 5);
                }

                else
                {
                  return_value_ConnectUser_get_state$285=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
                  if((signed int)return_value_ConnectUser_get_state$285 == 11)
                  {
                    ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)19);
                    aflog((char)1, (char)8, "user[%d]: CLOSING...", numofcon);
                  }

                }
              }
            }

          }

          break;
        }
        case 2:
        {
          aflog((char)1, (char)4, "user[%d]: AF_S_CONOPEN", numofcon);
          if(numofcon >= 0)
          {
            return_value_ClientRealm_get_usersLimit$330=ClientRealm_get_usersLimit(pointer);
            if(return_value_ClientRealm_get_usersLimit$330 >= numofcon)
            {
              char return_value_ConnectUser_get_state$329;
              return_value_ConnectUser_get_state$329=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
              if((signed int)return_value_ConnectUser_get_state$329 == 0)
              {
                char return_value_ClientRealm_get_realmType$289;
                return_value_ClientRealm_get_realmType$289=ClientRealm_get_realmType(pointer);
                struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$290;
                return_value_ClientRealm_get_masterSslFd$290=ClientRealm_get_masterSslFd(pointer);
                n=SslFd_get_message(return_value_ClientRealm_get_realmType$289, return_value_ClientRealm_get_masterSslFd$290, buff, length);
                ConnectUser_set_nameBuf(usersTable[(signed long int)numofcon], (char *)buff);
                ConnectUser_set_portBuf(usersTable[(signed long int)numofcon], (char *)&buff[(signed long int)128]);
                aflog((char)1, (char)8, "user[%d]: OPENING", numofcon);
                char *return_value_ConnectUser_get_nameBuf$291;
                return_value_ConnectUser_get_nameBuf$291=ConnectUser_get_nameBuf(usersTable[(signed long int)numofcon]);
                char *return_value_ConnectUser_get_portBuf$292;
                return_value_ConnectUser_get_portBuf$292=ConnectUser_get_portBuf(usersTable[(signed long int)numofcon]);
                aflog((char)1, (char)8, "user[%d]: IP:%s PORT:%s", numofcon, return_value_ConnectUser_get_nameBuf$291, return_value_ConnectUser_get_portBuf$292);
                struct anonymous$6 *return_value_ClientRealm_get_userModule$299;
                return_value_ClientRealm_get_userModule$299=ClientRealm_get_userModule(pointer);
                signed int return_value_Module_isModuleLoaded$300;
                return_value_Module_isModuleLoaded$300=Module_isModuleLoaded(return_value_ClientRealm_get_userModule$299);
                if(!(return_value_Module_isModuleLoaded$300 == 0))
                {
                  return_value_ClientRealm_get_userModule$295=ClientRealm_get_userModule(pointer);
                  return_value_ConnectUser_get_nameBuf$296=ConnectUser_get_nameBuf(usersTable[(signed long int)numofcon]);
                  return_value_ConnectUser_get_portBuf$297=ConnectUser_get_portBuf(usersTable[(signed long int)numofcon]);
                  return_value_Module_function_allow$298=Module_function_allow(return_value_ClientRealm_get_userModule$295, return_value_ConnectUser_get_nameBuf$296, return_value_ConnectUser_get_portBuf$297);
                  if(!(return_value_Module_function_allow$298 == 0))
                  {
                    aflog((char)1, (char)32, "user[%d]: IT'S NOT ALLOWED - DROPPING", numofcon);
                    buff[(signed long int)0] = (unsigned char)12;
                    buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                    buff[(signed long int)2] = (unsigned char)numofcon;
                    char return_value_ClientRealm_get_realmType$293;
                    return_value_ClientRealm_get_realmType$293=ClientRealm_get_realmType(pointer);
                    struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$294;
                    return_value_ClientRealm_get_masterSslFd$294=ClientRealm_get_masterSslFd(pointer);
                    SslFd_send_message(return_value_ClientRealm_get_realmType$293, return_value_ClientRealm_get_masterSslFd$294, buff, 5);
                    goto __CPROVER_DUMP_L286;
                  }

                }

                signed int return_value_ClientRealm_get_clientMode$301;
                return_value_ClientRealm_get_clientMode$301=ClientRealm_get_clientMode(pointer);
                if(return_value_ClientRealm_get_clientMode$301 == 1)
                  ipFamily = (char)0;

                else
                  ipFamily = (char)0x01;
                char return_value_ClientRealm_get_realmType$303;
                return_value_ClientRealm_get_realmType$303=ClientRealm_get_realmType(pointer);
                if(!((16 & (signed int)return_value_ClientRealm_get_realmType$303) == 0))
                  ipFamily = ipFamily | (char)0x02;

                else
                {
                  return_value_ClientRealm_get_realmType$302=ClientRealm_get_realmType(pointer);
                  if(!((32 & (signed int)return_value_ClientRealm_get_realmType$302) == 0))
                    ipFamily = ipFamily | (char)0x04;

                }
                temp2 = 0;
                if(n == 136)
                {
                  struct portlist *return_value_ClientRealm_get_destinationPorts$306;
                  return_value_ClientRealm_get_destinationPorts$306=ClientRealm_get_destinationPorts(pointer);
                  signed int return_value_PortList_get_size$307;
                  return_value_PortList_get_size$307=PortList_get_size(return_value_ClientRealm_get_destinationPorts$306);
                  if(return_value_PortList_get_size$307 == 1)
                    temp2 = 0;

                  else
                  {
                    struct portlist *return_value_ClientRealm_get_destinationPorts$304;
                    return_value_ClientRealm_get_destinationPorts$304=ClientRealm_get_destinationPorts(pointer);
                    signed int return_value_PortList_get_size$305;
                    return_value_PortList_get_size$305=PortList_get_size(return_value_ClientRealm_get_destinationPorts$304);
                    temp2 = (signed int)buff[(signed long int)135] % return_value_PortList_get_size$305;
                  }
                }

                char *return_value_ClientRealm_get_hostName$314;
                return_value_ClientRealm_get_hostName$314=ClientRealm_get_hostName(pointer);
                struct portlist *return_value_ClientRealm_get_destinationPorts$315;
                return_value_ClientRealm_get_destinationPorts$315=ClientRealm_get_destinationPorts(pointer);
                struct plnode *return_value_PortList_get_nth$316;
                return_value_PortList_get_nth$316=PortList_get_nth(return_value_ClientRealm_get_destinationPorts$315, temp2);
                char *return_value_PortListNode_get_portName$317;
                return_value_PortListNode_get_portName$317=PortListNode_get_portName(return_value_PortList_get_nth$316);
                char *return_value_ClientRealm_get_localDestinationName$318;
                return_value_ClientRealm_get_localDestinationName$318=ClientRealm_get_localDestinationName(pointer);
                signed int return_value_ip_connect$319;
                return_value_ip_connect$319=ip_connect(&temp, return_value_ClientRealm_get_hostName$314, return_value_PortListNode_get_portName$317, ipFamily, return_value_ClientRealm_get_localDestinationName$318, (const char *)(void *)0);
                if(!(return_value_ip_connect$319 == 0))
                {
                  char *return_value_ClientRealm_get_hostName$308;
                  return_value_ClientRealm_get_hostName$308=ClientRealm_get_hostName(pointer);
                  struct portlist *return_value_ClientRealm_get_destinationPorts$309;
                  return_value_ClientRealm_get_destinationPorts$309=ClientRealm_get_destinationPorts(pointer);
                  struct plnode *return_value_PortList_get_nth$310;
                  return_value_PortList_get_nth$310=PortList_get_nth(return_value_ClientRealm_get_destinationPorts$309, temp2);
                  char *return_value_PortListNode_get_portName$311;
                  return_value_PortListNode_get_portName$311=PortListNode_get_portName(return_value_PortList_get_nth$310);
                  aflog((char)1, (char)32, "user[%d]: CAN'T CONNECT to %s:%s - DROPPING", numofcon, return_value_ClientRealm_get_hostName$308, return_value_PortListNode_get_portName$311);
                  buff[(signed long int)0] = (unsigned char)12;
                  buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                  buff[(signed long int)2] = (unsigned char)numofcon;
                  char return_value_ClientRealm_get_realmType$312;
                  return_value_ClientRealm_get_realmType$312=ClientRealm_get_realmType(pointer);
                  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$313;
                  return_value_ClientRealm_get_masterSslFd$313=ClientRealm_get_masterSslFd(pointer);
                  SslFd_send_message(return_value_ClientRealm_get_realmType$312, return_value_ClientRealm_get_masterSslFd$313, buff, 5);
                  goto __CPROVER_DUMP_L286;
                }

                ConnectUser_set_connFd(usersTable[(signed long int)numofcon], temp);
                aflog((char)1, (char)4, "user[%d]: Setting connFd: %d", numofcon, temp);
                signed int return_value_ConnectUser_get_connFd$320;
                return_value_ConnectUser_get_connFd$320=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                temp2=fcntl(return_value_ConnectUser_get_connFd$320, 3, 0);
                signed int return_value_ConnectUser_get_connFd$321;
                return_value_ConnectUser_get_connFd$321=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                fcntl(return_value_ConnectUser_get_connFd$321, 4, temp2 | 04000);
                signed int return_value_ConnectUser_get_connFd$322;
                return_value_ConnectUser_get_connFd$322=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                signed int return_value_ConnectUser_get_connFd$323;
                return_value_ConnectUser_get_connFd$323=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$322 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$322 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd$323 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                signed int return_value_ConnectUser_get_connFd$324;
                return_value_ConnectUser_get_connFd$324=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                if(!(1 + return_value_ConnectUser_get_connFd$324 >= maxfdp1))
                  tmp_if_expr$326 = maxfdp1;

                else
                {
                  return_value_ConnectUser_get_connFd$325=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  tmp_if_expr$326 = return_value_ConnectUser_get_connFd$325 + 1;
                }
                maxfdp1 = tmp_if_expr$326;
                buff[(signed long int)0] = (unsigned char)2;
                buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                buff[(signed long int)2] = (unsigned char)numofcon;
                char return_value_ClientRealm_get_realmType$327;
                return_value_ClientRealm_get_realmType$327=ClientRealm_get_realmType(pointer);
                struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$328;
                return_value_ClientRealm_get_masterSslFd$328=ClientRealm_get_masterSslFd(pointer);
                SslFd_send_message(return_value_ClientRealm_get_realmType$327, return_value_ClientRealm_get_masterSslFd$328, buff, 5);
                ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)7);
              }

            }

          }

          break;
        }
        case 3:
        {
          aflog((char)1, (char)4, "user[%d]: AF_S_MESSAGE", numofcon);
          aflog((char)1, (char)2, "user[%d]: FROM msglen: %d", numofcon, length);
          return_value_ClientRealm_get_realmType$331=ClientRealm_get_realmType(pointer);
          return_value_ClientRealm_get_masterSslFd$332=ClientRealm_get_masterSslFd(pointer);
          n=SslFd_get_message(return_value_ClientRealm_get_realmType$331, return_value_ClientRealm_get_masterSslFd$332, buff, length);
          if(numofcon >= 0)
          {
            return_value_ClientRealm_get_usersLimit$390=ClientRealm_get_usersLimit(pointer);
            if(return_value_ClientRealm_get_usersLimit$390 >= numofcon)
            {
              char return_value_ConnectUser_get_state$389;
              return_value_ConnectUser_get_state$389=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
              if((signed int)return_value_ConnectUser_get_state$389 == 7)
              {
                struct anonymous$6 *return_value_ClientRealm_get_userModule$359;
                return_value_ClientRealm_get_userModule$359=ClientRealm_get_userModule(pointer);
                signed int return_value_Module_isModuleLoaded$360;
                return_value_Module_isModuleLoaded$360=Module_isModuleLoaded(return_value_ClientRealm_get_userModule$359);
                if(!(return_value_Module_isModuleLoaded$360 == 0))
                {
                  struct anonymous$6 *return_value_ClientRealm_get_userModule$333;
                  return_value_ClientRealm_get_userModule$333=ClientRealm_get_userModule(pointer);
                  char *return_value_ConnectUser_get_nameBuf$334;
                  return_value_ConnectUser_get_nameBuf$334=ConnectUser_get_nameBuf(usersTable[(signed long int)numofcon]);
                  temp2=Module_function_filter(return_value_ClientRealm_get_userModule$333, return_value_ConnectUser_get_nameBuf$334, buff, &n);
                  switch(temp2)
                  {
                    case 1:

                    case 4:
                    {
                      aflog((char)1, (char)32, "user[%d]: PACKET IGNORED BY MODULE", numofcon);
                      if(temp2 == 4)
                      {
                        struct anonymous$6 *return_value_ClientRealm_get_userModule$335;
                        return_value_ClientRealm_get_userModule$335=ClientRealm_get_userModule(pointer);
                        char *return_value_Module_get_fileName$336;
                        return_value_Module_get_fileName$336=Module_get_fileName(return_value_ClientRealm_get_userModule$335);
                        struct anonymous$6 *return_value_ClientRealm_get_userModule$337;
                        return_value_ClientRealm_get_userModule$337=ClientRealm_get_userModule(pointer);
                        char *return_value_Module_function_info$338;
                        return_value_Module_function_info$338=Module_function_info(return_value_ClientRealm_get_userModule$337);
                        aflog((char)16, (char)8, "RELEASED MODULE: %s INFO: %s", return_value_Module_get_fileName$336, return_value_Module_function_info$338);
                        struct anonymous$6 *return_value_ClientRealm_get_userModule$339;
                        return_value_ClientRealm_get_userModule$339=ClientRealm_get_userModule(pointer);
                        Module_releaseModule(return_value_ClientRealm_get_userModule$339);
                      }

                      goto __CPROVER_DUMP_L286;
                    }
                    case 2:

                    case 5:
                    {
                      aflog((char)1, (char)16, "user[%d]: DROPPED BY MODULE", numofcon);
                      return_value_ConnectUser_get_connFd$340=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      close(return_value_ConnectUser_get_connFd$340);
                      return_value_ConnectUser_get_connFd$341=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", numofcon, return_value_ConnectUser_get_connFd$341);
                      return_value_ConnectUser_get_connFd$342=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      return_value_ConnectUser_get_connFd$343=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$342 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$342 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$343 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                      return_value_ConnectUser_get_connFd$344=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      return_value_ConnectUser_get_connFd$345=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$344 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$344 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$345 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                      ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)5);
                      return_value_ConnectUser_get_bufList$346=ConnectUser_get_bufList(usersTable[(signed long int)numofcon]);
                      BufList_clear(return_value_ConnectUser_get_bufList$346);
                      buff[(signed long int)0] = (unsigned char)1;
                      buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                      buff[(signed long int)2] = (unsigned char)numofcon;
                      return_value_ClientRealm_get_realmType$347=ClientRealm_get_realmType(pointer);
                      return_value_ClientRealm_get_masterSslFd$348=ClientRealm_get_masterSslFd(pointer);
                      SslFd_send_message(return_value_ClientRealm_get_realmType$347, return_value_ClientRealm_get_masterSslFd$348, buff, 5);
                      if(temp2 == 5)
                      {
                        struct anonymous$6 *return_value_ClientRealm_get_userModule$349;
                        return_value_ClientRealm_get_userModule$349=ClientRealm_get_userModule(pointer);
                        char *return_value_Module_get_fileName$350;
                        return_value_Module_get_fileName$350=Module_get_fileName(return_value_ClientRealm_get_userModule$349);
                        struct anonymous$6 *return_value_ClientRealm_get_userModule$351;
                        return_value_ClientRealm_get_userModule$351=ClientRealm_get_userModule(pointer);
                        char *return_value_Module_function_info$352;
                        return_value_Module_function_info$352=Module_function_info(return_value_ClientRealm_get_userModule$351);
                        aflog((char)16, (char)8, "RELEASED MODULE: %s INFO: %s", return_value_Module_get_fileName$350, return_value_Module_function_info$352);
                        struct anonymous$6 *return_value_ClientRealm_get_userModule$353;
                        return_value_ClientRealm_get_userModule$353=ClientRealm_get_userModule(pointer);
                        Module_releaseModule(return_value_ClientRealm_get_userModule$353);
                      }

                      goto __CPROVER_DUMP_L286;
                    }
                    case 3:
                    {
                      return_value_ClientRealm_get_userModule$354=ClientRealm_get_userModule(pointer);
                      return_value_Module_get_fileName$355=Module_get_fileName(return_value_ClientRealm_get_userModule$354);
                      return_value_ClientRealm_get_userModule$356=ClientRealm_get_userModule(pointer);
                      return_value_Module_function_info$357=Module_function_info(return_value_ClientRealm_get_userModule$356);
                      aflog((char)16, (char)8, "RELEASED MODULE: %s INFO: %s", return_value_Module_get_fileName$355, return_value_Module_function_info$357);
                      return_value_ClientRealm_get_userModule$358=ClientRealm_get_userModule(pointer);
                      Module_releaseModule(return_value_ClientRealm_get_userModule$358);
                    }
                    default:
                      ;
                  }
                }

                aflog((char)1, (char)2, "user[%d]: FROM msglen: %d SENT", numofcon, n);
                signed int return_value_ConnectUser_get_connFd$361;
                return_value_ConnectUser_get_connFd$361=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                signed long int return_value_write$362;
                return_value_write$362=write(return_value_ConnectUser_get_connFd$361, (const void *)buff, (unsigned long int)n);
                temp2 = (signed int)return_value_write$362;
                if(temp2 >= 1 && !(temp2 == n))
                {
                  struct buflist *return_value_ConnectUser_get_bufList$363;
                  return_value_ConnectUser_get_bufList$363=ConnectUser_get_bufList(usersTable[(signed long int)numofcon]);
                  struct blnode *return_value_BufListNode_new_message$364;
                  return_value_BufListNode_new_message$364=BufListNode_new_message(temp2, n, buff);
                  BufList_insert_back(return_value_ConnectUser_get_bufList$363, return_value_BufListNode_new_message$364);
                  ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)11);
                  signed int return_value_ConnectUser_get_connFd$365;
                  return_value_ConnectUser_get_connFd$365=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  signed int return_value_ConnectUser_get_connFd$366;
                  return_value_ConnectUser_get_connFd$366=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                  (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$365 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$365 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd$366 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                  buff[(signed long int)0] = (unsigned char)9;
                  buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                  buff[(signed long int)2] = (unsigned char)numofcon;
                  aflog((char)1, (char)4, "FROM user[%d]: BUFFERING MESSAGE STARTED", numofcon);
                  char return_value_ClientRealm_get_realmType$367;
                  return_value_ClientRealm_get_realmType$367=ClientRealm_get_realmType(pointer);
                  struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$368;
                  return_value_ClientRealm_get_masterSslFd$368=ClientRealm_get_masterSslFd(pointer);
                  SslFd_send_message(return_value_ClientRealm_get_realmType$367, return_value_ClientRealm_get_masterSslFd$368, buff, 5);
                }

                else
                {
                  if(temp2 == -1)
                  {
                    return_value___errno_location$384=__errno_location();
                    tmp_if_expr$385 = *return_value___errno_location$384 == 11 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr$385 = (_Bool)0;
                  if(tmp_if_expr$385)
                  {
                    struct buflist *return_value_ConnectUser_get_bufList$369;
                    return_value_ConnectUser_get_bufList$369=ConnectUser_get_bufList(usersTable[(signed long int)numofcon]);
                    struct blnode *return_value_BufListNode_new_message$370;
                    return_value_BufListNode_new_message$370=BufListNode_new_message(0, n, buff);
                    BufList_insert_back(return_value_ConnectUser_get_bufList$369, return_value_BufListNode_new_message$370);
                    ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)11);
                    signed int return_value_ConnectUser_get_connFd$371;
                    return_value_ConnectUser_get_connFd$371=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                    signed int return_value_ConnectUser_get_connFd$372;
                    return_value_ConnectUser_get_connFd$372=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                    (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$371 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$371 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd$372 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                    buff[(signed long int)0] = (unsigned char)9;
                    buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                    buff[(signed long int)2] = (unsigned char)numofcon;
                    aflog((char)1, (char)4, "FROM user[%d]: BUFFERING MESSAGE STARTED", numofcon);
                    char return_value_ClientRealm_get_realmType$373;
                    return_value_ClientRealm_get_realmType$373=ClientRealm_get_realmType(pointer);
                    struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$374;
                    return_value_ClientRealm_get_masterSslFd$374=ClientRealm_get_masterSslFd(pointer);
                    SslFd_send_message(return_value_ClientRealm_get_realmType$373, return_value_ClientRealm_get_masterSslFd$374, buff, 5);
                  }

                  else
                    if(temp2 == -1)
                    {
                      signed int return_value_ConnectUser_get_connFd$375;
                      return_value_ConnectUser_get_connFd$375=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      close(return_value_ConnectUser_get_connFd$375);
                      signed int return_value_ConnectUser_get_connFd$376;
                      return_value_ConnectUser_get_connFd$376=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      aflog((char)1, (char)4, "user[%d]: Closing connFd: %d", numofcon, return_value_ConnectUser_get_connFd$376);
                      signed int return_value_ConnectUser_get_connFd$377;
                      return_value_ConnectUser_get_connFd$377=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      signed int return_value_ConnectUser_get_connFd$378;
                      return_value_ConnectUser_get_connFd$378=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$377 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$377 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$378 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                      signed int return_value_ConnectUser_get_connFd$379;
                      return_value_ConnectUser_get_connFd$379=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      signed int return_value_ConnectUser_get_connFd$380;
                      return_value_ConnectUser_get_connFd$380=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
                      (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$379 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$379 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$380 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                      ConnectUser_set_state(usersTable[(signed long int)numofcon], (char)5);
                      struct buflist *return_value_ConnectUser_get_bufList$381;
                      return_value_ConnectUser_get_bufList$381=ConnectUser_get_bufList(usersTable[(signed long int)numofcon]);
                      BufList_clear(return_value_ConnectUser_get_bufList$381);
                      buff[(signed long int)0] = (unsigned char)1;
                      buff[(signed long int)1] = (unsigned char)(numofcon >> 8);
                      buff[(signed long int)2] = (unsigned char)numofcon;
                      char return_value_ClientRealm_get_realmType$382;
                      return_value_ClientRealm_get_realmType$382=ClientRealm_get_realmType(pointer);
                      struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$383;
                      return_value_ClientRealm_get_masterSslFd$383=ClientRealm_get_masterSslFd(pointer);
                      SslFd_send_message(return_value_ClientRealm_get_realmType$382, return_value_ClientRealm_get_masterSslFd$383, buff, 5);
                    }

                }
              }

              else
              {
                return_value_ConnectUser_get_state$388=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
                if((signed int)return_value_ConnectUser_get_state$388 == 11)
                {
                  aflog((char)1, (char)4, "FROM user[%d]: BUFFERING MESSAGE", numofcon);
                  struct buflist *return_value_ConnectUser_get_bufList$386;
                  return_value_ConnectUser_get_bufList$386=ConnectUser_get_bufList(usersTable[(signed long int)numofcon]);
                  struct blnode *return_value_BufListNode_new_message$387;
                  return_value_BufListNode_new_message$387=BufListNode_new_message(0, n, buff);
                  BufList_insert_back(return_value_ConnectUser_get_bufList$386, return_value_BufListNode_new_message$387);
                }

              }
            }

          }

          break;
        }
        case 4:
        {
          n = 0;
          return_value_ClientRealm_get_arOptions$391=ClientRealm_get_arOptions(pointer);
          i=ArOptions_get_arTries(return_value_ClientRealm_get_arOptions$391);
          return_value_ClientRealm_get_arOptions$392=ClientRealm_get_arOptions(pointer);
          return_value_ArOptions_get_arQuit$393=ArOptions_get_arQuit(return_value_ClientRealm_get_arOptions$392);
          if((signed int)return_value_ArOptions_get_arQuit$393 == 0)
            i = 0;

          if(!(i == 0))
            aflog((char)2, (char)64, "SERVER: CLOSED -> auto-reconnect enabled");

          while(!(i == 0))
          {
            ClientRealm_closeUsersConnections(pointer);
            struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$394;
            return_value_ClientRealm_get_masterSslFd$394=ClientRealm_get_masterSslFd(pointer);
            signed int return_value_SslFd_get_fd$395;
            return_value_SslFd_get_fd$395=SslFd_get_fd(return_value_ClientRealm_get_masterSslFd$394);
            close(return_value_SslFd_get_fd$395);
            struct anonymous$0 *return_value_ClientRealm_get_masterSslFd$396;
            return_value_ClientRealm_get_masterSslFd$396=ClientRealm_get_masterSslFd(pointer);
            SslFd_set_ssl(return_value_ClientRealm_get_masterSslFd$396, (struct ssl_st *)(void *)0);
            struct anonymous$3 *return_value_ClientRealm_get_arOptions$397;
            return_value_ClientRealm_get_arOptions$397=ClientRealm_get_arOptions(pointer);
            signed int return_value_ArOptions_get_arDelay$398;
            return_value_ArOptions_get_arDelay$398=ArOptions_get_arDelay(return_value_ClientRealm_get_arOptions$397);
            mysleep((double)return_value_ArOptions_get_arDelay$398);
            aflog((char)2, (char)8, "Trying to reconnect...");
            temp2 = 0;
            if(temp2 == 0)
            {
              char return_value_ClientConfiguration_get_ignorePublicKeys$399;
              return_value_ClientConfiguration_get_ignorePublicKeys$399=ClientConfiguration_get_ignorePublicKeys(cconfig);
              signed int return_value_initialize_client_stage1$400;
              return_value_initialize_client_stage1$400=initialize_client_stage1(pointer, ctx, buff, (char)0, return_value_ClientConfiguration_get_ignorePublicKeys$399);
              if(!(return_value_initialize_client_stage1$400 == 0))
                temp2 = 1;

            }

            if(temp2 == 0)
            {
              signed int return_value_initialize_client_stage2$401;
              return_value_initialize_client_stage2$401=initialize_client_stage2(pointer, buff, (char)0);
              if(!(return_value_initialize_client_stage2$401 == 0))
                temp2 = 1;

            }

            if(temp2 == 0)
            {
              signed int return_value_initialize_client_stage3$402;
              return_value_initialize_client_stage3$402=initialize_client_stage3(pointer, &buflength, &allset, &wset, &maxfdp1, (char)0);
              if(!(return_value_initialize_client_stage3$402 == 0))
                temp2 = 1;

            }

            if(temp2 == 0)
            {
              n = 1;
              aflog((char)2, (char)8, "Reconnected successfully...");
              usersTable=ClientRealm_get_usersTable(pointer);
              ClientRealm_send_realmId(pointer, buff);
              ClientRealm_enable_multi(pointer);
              break;
            }

            if(i >= 1)
              i = i - 1;

          }
          if(n == 0)
          {
            signed long int return_value_getcg$403;
            return_value_getcg$403=getcg();
            aflog((char)2, (char)8, "SERVER: CLOSED -> exiting... cg: %ld bytes", return_value_getcg$403);
            exit(1);
          }

          break;
        }
        case 9:
        {
          return_value_ConnectUser_get_state$406=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
          if((signed int)return_value_ConnectUser_get_state$406 == 7)
            tmp_if_expr$408 = (_Bool)1;

          else
          {
            return_value_ConnectUser_get_state$407=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
            tmp_if_expr$408 = (signed int)return_value_ConnectUser_get_state$407 == 11 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$408)
          {
            aflog((char)1, (char)2, "user[%d]: AF_S_DONT_SEND", numofcon);
            signed int return_value_ConnectUser_get_connFd$404;
            return_value_ConnectUser_get_connFd$404=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
            signed int return_value_ConnectUser_get_connFd$405;
            return_value_ConnectUser_get_connFd$405=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
            (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$404 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$404 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$405 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
          }

          else
            aflog((char)1, (char)2, "user[%d]: AF_S_DONT_SEND - ignored", numofcon);
          break;
        }
        case 10:
        {
          return_value_ConnectUser_get_state$411=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
          if((signed int)return_value_ConnectUser_get_state$411 == 7)
            tmp_if_expr$413 = (_Bool)1;

          else
          {
            return_value_ConnectUser_get_state$412=ConnectUser_get_state(usersTable[(signed long int)numofcon]);
            tmp_if_expr$413 = (signed int)return_value_ConnectUser_get_state$412 == 11 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$413)
          {
            aflog((char)1, (char)2, "user[%d]: AF_S_CAN_SEND", numofcon);
            signed int return_value_ConnectUser_get_connFd$409;
            return_value_ConnectUser_get_connFd$409=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
            signed int return_value_ConnectUser_get_connFd$410;
            return_value_ConnectUser_get_connFd$410=ConnectUser_get_connFd(usersTable[(signed long int)numofcon]);
            (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$409 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$409 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd$410 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
          }

          else
            aflog((char)1, (char)2, "user[%d]: AF_S_CAN_SEND - ignored", numofcon);
          break;
        }
        default:
        {
          return_value_getcg$414=getcg();
          aflog((char)2, (char)64, "SERVER: unrecognized message -> exiting... cg: %ld bytes", return_value_getcg$414);
          exit(1);
        }
      }
    }


  __CPROVER_DUMP_L286:
    ;
  }
  while((_Bool)1);
}

// make_ssl_accept
// file make_ssl_handshake.c line 55
signed int make_ssl_accept(struct anonymous$0 *sf)
{
  signed int result;
  struct ssl_st *return_value_SslFd_get_ssl$2;
  return_value_SslFd_get_ssl$2=SslFd_get_ssl(sf);
  result=SSL_accept(return_value_SslFd_get_ssl$2);
  if(!(result == 1))
  {
    signed int return_value_get_ssl_error$1;
    return_value_get_ssl_error$1=get_ssl_error(sf, "SSL_accept has failed", result);
    return return_value_get_ssl_error$1;
  }

  return 0;
}

// make_ssl_initialize
// file make_ssl_handshake.c line 37
void make_ssl_initialize(struct anonymous$0 *sf)
{
  struct ssl_st *return_value_SslFd_get_ssl$1;
  return_value_SslFd_get_ssl$1=SslFd_get_ssl(sf);
  signed int return_value_SslFd_get_fd$2;
  return_value_SslFd_get_fd$2=SslFd_get_fd(sf);
  signed int return_value_SSL_set_fd$3;
  return_value_SSL_set_fd$3=SSL_set_fd(return_value_SslFd_get_ssl$1, return_value_SslFd_get_fd$2);
  if(!(return_value_SSL_set_fd$3 == 1))
  {
    aflog((char)4, (char)1, "Problem with initializing ssl... exiting");
    exit(1);
  }

}

// myrand
// file http_proxy_functions.c line 42
signed int myrand(signed int down, signed int up)
{
  struct timeval tv;
  if(isseed == 0)
  {
    gettimeofday(&tv, ((struct timezone *)NULL));
    srand((unsigned int)tv.tv_sec);
    isseed = (char)1;
  }

  signed int return_value_rand$1;
  return_value_rand$1=rand();
  return down + return_value_rand$1 % ((up - down) + 1);
}

// mysleep
// file http_proxy_functions.h line 75
void mysleep(double time)
{
  struct timeval tv;
  tv.tv_sec = (signed long int)(signed int)time;
  tv.tv_usec = (signed long int)((signed int)(time * (double)1000000) % 1000000);
  select(0, (struct anonymous$11 *)(void *)0, (struct anonymous$11 *)(void *)0, (struct anonymous$11 *)(void *)0, &tv);
}

// parse_header
// file http_proxy_functions.c line 105
signed int parse_header(struct anonymous$0 *sf, char *tab, struct anonymous$15 *hdr, char https)
{
  signed int n;
  signed int i;
  signed int j;
  signed int state = 0;
  char tmpt[100l];
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl$1;
    return_value_SslFd_get_ssl$1=SslFd_get_ssl(sf);
    n=SSL_read(return_value_SslFd_get_ssl$1, (void *)tab, 9000);
  }

  else
  {
    signed int return_value_SslFd_get_fd$2;
    return_value_SslFd_get_fd$2=SslFd_get_fd(sf);
    signed long int return_value_read$3;
    return_value_read$3=read(return_value_SslFd_get_fd$2, (void *)tab, (unsigned long int)9000);
    n = (signed int)return_value_read$3;
  }
  hdr->allreaded = n;
  j = 0;
  i = j;
  memset((void *)tmpt, 0, (unsigned long int)100);
  hdr->ptr = 0;
  hdr->length = 0;
  _Bool tmp_if_expr$13;
  signed int tmp_statement_expression$4;
  signed int tmp_statement_expression$6;
  signed int tmp_statement_expression$8;
  _Bool tmp_if_expr$12;
  signed int tmp_statement_expression$10;
  signed int tmp_statement_expression$14;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$19;
  signed int tmp_statement_expression$17;
  for( ; !(i >= n); i = i + 1)
  {
    if(j == 99)
      return 1;

    switch(state)
    {
      case 0:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
          tmp_if_expr$13 = (signed int)tab[(signed long int)i] != 9 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$13 = (_Bool)0;
        if(tmp_if_expr$13)
        {
          tmpt[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }

        else
        {
          tmpt[(signed long int)j] = (char)0;
          unsigned long int parse_header$$1$$3$$1$$2$$1$$__s1_len;
          unsigned long int parse_header$$1$$3$$1$$2$$1$$__s2_len;
          signed int return_value___builtin_strcmp$5;
          return_value___builtin_strcmp$5=__builtin_strcmp(tmpt, "GET");
          tmp_statement_expression$4 = return_value___builtin_strcmp$5;
          if(tmp_statement_expression$4 == 0)
          {
            hdr->type = (char)0;
            state = 1;
            break;
          }

          unsigned long int parse_header$$1$$3$$1$$2$$3$$__s1_len;
          unsigned long int parse_header$$1$$3$$1$$2$$3$$__s2_len;
          signed int return_value___builtin_strcmp$7;
          return_value___builtin_strcmp$7=__builtin_strcmp(tmpt, "POST");
          tmp_statement_expression$6 = return_value___builtin_strcmp$7;
          if(tmp_statement_expression$6 == 0)
          {
            hdr->type = (char)1;
            state = 1;
            break;
          }

          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp$9;
          return_value___builtin_strcmp$9=__builtin_strcmp(tmpt, "HTTP/1.0");
          tmp_statement_expression$8 = return_value___builtin_strcmp$9;
          if(tmp_statement_expression$8 == 0)
            tmp_if_expr$12 = (_Bool)1;

          else
          {
            unsigned long int parse_header$$1$$3$$1$$2$$6$$__s1_len;
            unsigned long int parse_header$$1$$3$$1$$2$$6$$__s2_len;
            signed int return_value___builtin_strcmp$11;
            return_value___builtin_strcmp$11=__builtin_strcmp(tmpt, "HTTP/1.1");
            tmp_statement_expression$10 = return_value___builtin_strcmp$11;
            tmp_if_expr$12 = tmp_statement_expression$10 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$12)
          {
            hdr->type = (char)2;
            state = 6;
            break;
          }

          return 1;
        }
        break;
      }
      case 1:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
        {
          if(!((signed int)tab[(signed long int)i] == 9))
          {
            tmpt[(signed long int)0] = tab[(signed long int)i];
            j = 1;
            state = 2;
          }

        }

        break;
      }
      case 2:
      {
        if(!((signed int)tab[(signed long int)i] == 61))
        {
          tmpt[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }

        else
        {
          tmpt[(signed long int)j] = (char)0;
          unsigned long int parse_header$$1$$3$$1$$5$$1$$__s1_len;
          unsigned long int parse_header$$1$$3$$1$$5$$1$$__s2_len;
          signed int return_value___builtin_strcmp$15;
          return_value___builtin_strcmp$15=__builtin_strcmp(tmpt, "/yahpt.html?id");
          tmp_statement_expression$14 = return_value___builtin_strcmp$15;
          if(!(tmp_statement_expression$14 == 0))
            return 1;

          j = 0;
          state = 3;
        }
        break;
      }
      case 3:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
          tmp_if_expr$16 = (signed int)tab[(signed long int)i] != 9 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$16 = (_Bool)0;
        if(tmp_if_expr$16)
        {
          if(j == 9)
            return 1;

          hdr->id[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }

        else
        {
          if(!(j == 9))
            return 1;

          hdr->id[(signed long int)j] = (char)0;
          state = 4;
        }
        break;
      }
      case 4:
      {
        if((signed int)tab[(signed long int)i] == 10)
          state = 5;

        break;
      }
      case 5:
      {
        if((signed int)tab[(signed long int)i] == 10)
        {
          hdr->ptr = i + 1;
          hdr->length = n - hdr->ptr;
          return 0;
        }

        if(!((signed int)tab[(signed long int)i] == 13))
          state = 4;

        break;
      }
      case 6:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
        {
          if(!((signed int)tab[(signed long int)i] == 9))
          {
            tmpt[(signed long int)0] = tab[(signed long int)i];
            j = 1;
            state = 7;
          }

        }

        break;
      }
      case 7:
      {
        if((signed int)tab[(signed long int)i] == 32)
          tmp_if_expr$19 = (_Bool)1;

        else
          tmp_if_expr$19 = (signed int)tab[(signed long int)i] == 9 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$19)
        {
          tmpt[(signed long int)j] = (char)0;
          unsigned long int parse_header$$1$$3$$1$$11$$1$$__s1_len;
          unsigned long int parse_header$$1$$3$$1$$11$$1$$__s2_len;
          signed int return_value___builtin_strcmp$18;
          return_value___builtin_strcmp$18=__builtin_strcmp(tmpt, "200");
          tmp_statement_expression$17 = return_value___builtin_strcmp$18;
          if(!(tmp_statement_expression$17 == 0))
            return 1;

          state = 4;
        }

        else
        {
          tmpt[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }
      }
    }
  }
  return 1;
}

// parse_line
// file file.c line 45
signed int parse_line(char *buff, char *tab1, char *tab2)
{
  signed int state;
  signed int i;
  signed int j;
  signed int lastDot;
  j = 0;
  i = j;
  state = i;
  lastDot = -1;
  _Bool tmp_if_expr$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  const unsigned short int **return_value___ctype_b_loc$5;
  for( ; !((signed int)buff[(signed long int)i] == 0); i = i + 1)
  {
    if((signed int)buff[(signed long int)i] == 35)
    {
      if(i >= 1)
        tmp_if_expr$1 = (signed int)buff[(signed long int)(i - 1)] == 92 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        j = j - 1;

      else
        break;
    }

    switch(state)
    {
      case 0:
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
        {
          tab1[(signed long int)j] = buff[(signed long int)i];
          j = 1;
          state = 1;
        }

        break;
      }
      case 1:
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)buff[(signed long int)i]]) == 0))
        {
          tab1[(signed long int)j] = (char)0;
          state = 2;
          j = 0;
        }

        else
        {
          tab1[(signed long int)j] = buff[(signed long int)i];
          j = j + 1;
        }
        break;
      }
      case 2:
      {
        return_value___ctype_b_loc$4=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
        {
          if(!((signed int)buff[(signed long int)i] == 46))
          {
            tab2[(signed long int)j] = buff[(signed long int)i];
            j = 1;
          }

          state = 3;
        }

        break;
      }
      case 3:
      {
        if((signed int)buff[(signed long int)i] == 46)
          lastDot = j;

        else
        {
          return_value___ctype_b_loc$5=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
            lastDot = -1;

          else
            if(lastDot == -1)
              lastDot = j;

        }
        tab2[(signed long int)j] = buff[(signed long int)i];
        j = j + 1;
      }
    }
  }
  if(!(lastDot == -1))
    tab2[(signed long int)lastDot] = (char)0;

  if(state == 3)
    return 2;

  else
    if(state == 0)
      return 0;

    else
      return 1;
}

// read_message
// file http_proxy_functions.c line 281
signed int read_message(signed int fd, signed int length, struct anonymous$16 *client, char *tab, signed int ptr)
{
  signed int j = 0;
  signed int tmp = 0;
  while(!(j >= length))
    if(!(client->toreceive >= client->curreceived + length + -j))
    {
      if(client->toreceive + -client->curreceived >= 1)
      {
        writen(fd, (unsigned char *)(tab + (signed long int)ptr + (signed long int)j), client->toreceive - client->curreceived);
        j = j + (client->toreceive - client->curreceived);
        client->curreceived = client->curreceived + (client->toreceive - client->curreceived);
      }

      if((signed int)client->read_state == 0)
        switch((signed int)tab[(signed long int)(ptr + j)])
        {
          case 77:
          {
            if(length >= 5 + j)
            {
              memcpy((void *)&tmp, (const void *)&tab[(signed long int)(ptr + j + 1)], (unsigned long int)4);
              unsigned int return_value___bswap_32$1;
              return_value___bswap_32$1=__bswap_32((unsigned int)tmp);
              client->toreceive = (signed int)return_value___bswap_32$1;
              client->curreceived = 0;
              j = j + 5;
            }

            else
              if(!(1 + j >= length))
              {
                memcpy((void *)client->readed_length, (const void *)&tab[(signed long int)(ptr + j + 1)], (unsigned long int)((length - j) - 1));
                client->read_state = (char)(length - j);
                j = j + (length - j);
              }

              else
              {
                j = j + 1;
                client->read_state = (char)1;
              }
            break;
          }
          case 84:
          {
            j = j + 1;
            break;
          }
          case 65:
          {
            j = j + 1;
            if((signed int)client->state == 0)
              client->state = (char)4;

            break;
          }
          default:
            return 1;
        }

      else
        if(length >= 5 + j + -((signed int)client->read_state))
        {
          memcpy((void *)&client->readed_length[(signed long int)((signed int)client->read_state - 1)], (const void *)&tab[(signed long int)(ptr + j)], (unsigned long int)(5 - (signed int)client->read_state));
          memcpy((void *)&tmp, (const void *)client->readed_length, (unsigned long int)4);
          unsigned int return_value___bswap_32$2;
          return_value___bswap_32$2=__bswap_32((unsigned int)tmp);
          client->toreceive = (signed int)return_value___bswap_32$2;
          client->curreceived = 0;
          j = j + (5 - (signed int)client->read_state);
          client->read_state = (char)0;
        }

        else
        {
          memcpy((void *)&client->readed_length[(signed long int)((signed int)client->read_state - 1)], (const void *)&tab[(signed long int)(ptr + j)], (unsigned long int)(length - j));
          client->read_state = client->read_state + (char)(length - j);
          j = j + (length - j);
        }
    }

    else
      if(length + -j >= 1)
      {
        client->curreceived = client->curreceived + (length - j);
        writen(fd, (unsigned char *)(tab + (signed long int)ptr + (signed long int)j), length - j);
        j = j + (length - j);
      }

  return 0;
}

// readn
// file network.c line 542
signed int readn(signed int fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)(buf + (signed long int)sent), (unsigned long int)(amount - sent));
    n = (signed int)return_value_read$1;
    if(!(n == -1))
      sent = sent + n;

    if(n == 0)
      return 0;

    if(n == -1)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 11))
        return 0;

    }

  }
  return amount;
}

// remember_mainthread
// file thread_management.h line 26
void remember_mainthread(void)
{
  mainthread=pthread_self();
}

// resetcg
// file stats.c line 84
void resetcg(void)
{
  compressgained = (signed long int)0;
}

// server_long_usage
// file usage.c line 52
void server_long_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf(" Basic options:\n\n");
  printf("  -n, --hostname      - it's used when creating listening sockets\n");
  printf("                        (default: '')\n");
  printf("  -l, --listenport    - listening [host:]port - users connect to it\n");
  printf("                        (default: 50127)\n");
  printf("  -m, --manageport    - manage [host:]port - afclient connects to it\n");
  printf("                        (default: 50126)\n");
  printf("  -V, --version       - display version number\n");
  printf("  -h, --help          - prints this help\n\n");
  printf(" Authorization:\n\n");
  printf("  --pass              - set the password used for client identification\n");
  printf("                        (default: no password)\n\n");
  printf(" Configuration:\n\n");
  printf("  -c, --cerfile       - the name of the file with certificate\n");
  printf("                        (default: server-cert.pem)\n");
  printf("  -A, --cacerfile     - the name of the file with CA certificates\n");
  printf("                        (if used, require clients to have valid certificates)\n");
  printf("  -d, --cerdepth      - the maximum depth of valid certificate-chains\n");
  printf("  -k, --keyfile       - the name of the file with RSA key (default: server.rsa)\n");
  printf("  -f, --cfgfile       - the name of the file with the configuration for the\n");
  printf("                        active forwarder (server)\n");
  printf("  -D, --dateformat    - format of the date printed in logs (see 'man strftime'\n");
  printf("                        for details) (default: %%Y-%%m-%%d %%H:%%M:%%S)\n");
  printf("  -t, --timeout       - the timeout value for the client's connection\n");
  printf("                        (default: 5)\n");
  printf("  --maxidle           - the maximum idle time for the client's connection\n");
  printf("                        (default: disabled)\n");
  printf("  -u, --users         - the amount of users allowed to use this server\n");
  printf("                        (default: 5)\n");
  printf("  -C, --clients       - the number of allowed clients to use this server\n");
  printf("                        (default: 1)\n");
  printf("  -r, --realm         - set the realm name (default: none)\n");
  printf("  -R, --raclients     - the number of allowed clients in remote administration\n");
  printf("                        mode to use this server (default: 1)\n");
  printf("  -U, --usrpcli       - the number of allowed users per client (default: $users)\n");
  printf("  -M, --climode       - strategy used to connect users with clients (default: 1)\n");
  printf("                      Available strategies:\n");
  printf("                        1. fill first client before go to next\n\n");
  printf("  -p, --proto         - type of server (tcp|udp) - what protocol it will be\n");
  printf("                        operating for (default: tcp)\n");
  printf("  -b, --baseport      - listenports are temporary and differ for each client\n");
  printf("  -a, --audit         - additional information about connections are logged\n");
  printf("  --nossl             - ssl is not used to transfer data (but it's still used\n");
  printf("                        to establish a connection) (default: ssl is used)\n");
  printf("  --nozlib            - zlib is not used to compress data (default: zlib is\n");
  printf("                        used)\n");
  printf("  --dnslookups        - try to obtain dns names of the computers rather than\n");
  printf("                        their numeric IP\n\n");
  printf(" Logging:\n\n");
  printf("  -o, --log           - log choosen information to file/socket\n");
  printf("  -v, --verbose       - to be verbose - program won't enter the daemon mode\n");
  printf("                        (use several times for greater effect)\n\n");
  printf(" IP family:\n\n");
  printf("  -4, --ipv4          - use ipv4 only\n");
  printf("  -6, --ipv6          - use ipv6 only\n\n");
  printf(" HTTP PROXY:\n\n");
  printf("  -P, --enableproxy   - enable http proxy mode\n\n");
  exit(0);
}

// server_short_usage
// file usage.c line 36
void server_short_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf("Try `afserver --help' for more information.\n");
  exit(1);
}

// set_fd
// file http_proxy_functions.c line 235
void set_fd(signed int fd, signed int *maxfdp1, struct anonymous$11 *allset)
{
  allset->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = allset->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  signed int tmp_if_expr$1;
  if(!(fd >= *maxfdp1))
    tmp_if_expr$1 = *maxfdp1;

  else
    tmp_if_expr$1 = fd + 1;
  *maxfdp1 = tmp_if_expr$1;
}

// setdateformat
// file logging.c line 41
void setdateformat(char *dateformat)
{
  if(!(dateformat == ((char *)NULL)))
    __builtin_strncpy(format, dateformat, (unsigned long int)50);

}

// sock_ntop
// file network.c line 350
char * sock_ntop(struct sockaddr *sa, unsigned int salen, char *namebuf, char *portbuf, char type)
{
  char portstr[7l];
  struct sockaddr_in *sin;
  unsigned short int tmp_statement_expression$5;
  unsigned short int tmp_statement_expression$3;
  unsigned short int tmp_statement_expression$4;
  struct sockaddr_in6 *sin6;
  unsigned short int tmp_statement_expression$10;
  unsigned short int tmp_statement_expression$8;
  unsigned short int tmp_statement_expression$9;
  switch((signed int)sa->sa_family)
  {    static char str[136l];
    case 2:
    {
      sin = (struct sockaddr_in *)sa;
      if(!(type == 0))
      {
        signed int return_value_getnameinfo$1;
        return_value_getnameinfo$1=getnameinfo(sa, salen, str, (unsigned int)128, (char *)(void *)0, (unsigned int)0, 0);
        if(!(return_value_getnameinfo$1 == 0))
          return (char *)(void *)0;

      }

      else
      {
        const char *return_value_inet_ntop$2;
        return_value_inet_ntop$2=inet_ntop(2, (void *)&sin->sin_addr, str, (unsigned int)sizeof(char [136l]) /*136ul*/ );
        if(return_value_inet_ntop$2 == ((const char *)NULL))
          return (char *)(void *)0;

      }
      if(!(namebuf == ((char *)NULL)))
        memcpy((void *)namebuf, (const void *)str, (unsigned long int)128);

      unsigned short int sock_ntop$$1$$1$$1$$4$$__v;
      unsigned short int sock_ntop$$1$$1$$1$$4$$__x = (unsigned short int)sin->sin_port;
      asm("rorw $8, %w0" : "=r"(sock_ntop$$1$$1$$1$$4$$__v) : "0"(sock_ntop$$1$$1$$1$$4$$__x) : "cc");
      tmp_statement_expression$5 = sock_ntop$$1$$1$$1$$4$$__v;
      if(!((signed int)tmp_statement_expression$5 == 0))
      {
        unsigned short int sock_ntop$$1$$1$$1$$5$$1$$__v;
        unsigned short int sock_ntop$$1$$1$$1$$5$$1$$__x = (unsigned short int)sin->sin_port;
        asm("rorw $8, %w0" : "=r"(sock_ntop$$1$$1$$1$$5$$1$$__v) : "0"(sock_ntop$$1$$1$$1$$5$$1$$__x) : "cc");
        tmp_statement_expression$3 = sock_ntop$$1$$1$$1$$5$$1$$__v;
        snprintf(portstr, sizeof(char [7l]) /*7ul*/ , ".%d", tmp_statement_expression$3);
        if(!(portbuf == ((char *)NULL)))
        {
          unsigned short int sock_ntop$$1$$1$$1$$5$$2$$1$$__v;
          unsigned short int sock_ntop$$1$$1$$1$$5$$2$$1$$__x = (unsigned short int)sin->sin_port;
          asm("rorw $8, %w0" : "=r"(sock_ntop$$1$$1$$1$$5$$2$$1$$__v) : "0"(sock_ntop$$1$$1$$1$$5$$2$$1$$__x) : "cc");
          tmp_statement_expression$4 = sock_ntop$$1$$1$$1$$5$$2$$1$$__v;
          snprintf(portbuf, (unsigned long int)7, "%d", tmp_statement_expression$4);
        }

        strcat(str, portstr);
      }

      return str;
    }
    case 10:
    {
      sin6 = (struct sockaddr_in6 *)sa;
      if(!(type == 0))
      {
        signed int return_value_getnameinfo$6;
        return_value_getnameinfo$6=getnameinfo(sa, salen, str, (unsigned int)128, (char *)(void *)0, (unsigned int)0, 0);
        if(!(return_value_getnameinfo$6 == 0))
          return (char *)(void *)0;

      }

      else
      {
        const char *return_value_inet_ntop$7;
        return_value_inet_ntop$7=inet_ntop(10, (const void *)&sin6->sin6_addr, str, (unsigned int)sizeof(char [136l]) /*136ul*/ );
        if(return_value_inet_ntop$7 == ((const char *)NULL))
          return (char *)(void *)0;

      }
      if(!(namebuf == ((char *)NULL)))
        memcpy((void *)namebuf, (const void *)str, (unsigned long int)128);

      unsigned short int __v;
      unsigned short int __x = (unsigned short int)sin6->sin6_port;
      asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression$10 = __v;
      if(!((signed int)tmp_statement_expression$10 == 0))
      {
        unsigned short int sock_ntop$$1$$1$$2$$5$$1$$__v;
        unsigned short int sock_ntop$$1$$1$$2$$5$$1$$__x = (unsigned short int)sin6->sin6_port;
        asm("rorw $8, %w0" : "=r"(sock_ntop$$1$$1$$2$$5$$1$$__v) : "0"(sock_ntop$$1$$1$$2$$5$$1$$__x) : "cc");
        tmp_statement_expression$8 = sock_ntop$$1$$1$$2$$5$$1$$__v;
        snprintf(portstr, sizeof(char [7l]) /*7ul*/ , ".%d", tmp_statement_expression$8);
        if(!(portbuf == ((char *)NULL)))
        {
          unsigned short int sock_ntop$$1$$1$$2$$5$$2$$1$$__v;
          unsigned short int sock_ntop$$1$$1$$2$$5$$2$$1$$__x = (unsigned short int)sin6->sin6_port;
          asm("rorw $8, %w0" : "=r"(sock_ntop$$1$$1$$2$$5$$2$$1$$__v) : "0"(sock_ntop$$1$$1$$2$$5$$2$$1$$__x) : "cc");
          tmp_statement_expression$9 = sock_ntop$$1$$1$$2$$5$$2$$1$$__v;
          snprintf(portbuf, (unsigned long int)7, "%d", tmp_statement_expression$9);
        }

        strcat(str, portstr);
      }

      return str;
    }
    default:
    {
      snprintf(str, sizeof(char [136l]) /*136ul*/ , "sock_ntop: unknown AF_xxx: %d, len %d", sa->sa_family, salen);
      return str;
    }
  }
  return (char *)(void *)0;
}

// start_critical_section
// file thread_management.h line 28
void start_critical_section(void)
{
  pthread_mutex_lock(&mainmutex);
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 453
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// string_cp
// file string_functions.h line 24
char * string_cp(char **dest, char *src)
{
  char *tmp;
  signed int len = 0;
  if(!(dest == ((char **)NULL)))
  {
    if(!(*dest == ((char *)NULL)))
    {
      if(*dest == src)
        return *dest;

      free((void *)*dest);
      *dest = (char *)(void *)0;
    }

  }

  if(src == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(src);
    len = (signed int)return_value_strlen$1;
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)1, (unsigned long int)(len + 1));
    tmp = (char *)return_value_calloc$2;
    if(tmp == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      __builtin_strncpy(tmp, src, (unsigned long int)len);
      if(!(dest == ((char **)NULL)))
        *dest = tmp;

      return tmp;
    }
  }
}

// timeperiod
// file stats.c line 35
char * timeperiod(signed long int period)
{
  signed int hours;
  signed int minutes;
  signed int seconds;
  static char timeper[41l];
  memset((void *)timeper, 0, (unsigned long int)41);
  hours = (signed int)(period / (signed long int)3600);
  minutes = (signed int)((period / (signed long int)60) % (signed long int)60);
  seconds = (signed int)(period % (signed long int)60);
  if(!(hours == 0))
    sprintf(timeper, "%d:%02d:%02d", hours, minutes, seconds);

  else
    sprintf(timeper, "%d:%02d", minutes, seconds);
  return timeper;
}

// timeval_compare
// file timeval_functions.c line 56
signed int timeval_compare(struct timeval *first, struct timeval *second)
{
  if(first == ((struct timeval *)NULL))
  {
    if(second == ((struct timeval *)NULL))
      return 0;

    return -1;
  }

  else
    if(second == ((struct timeval *)NULL))
      return 1;

    else
      if(!(first->tv_sec >= second->tv_sec))
        return -1;

      else
        if(!(second->tv_sec >= first->tv_sec))
          return 1;

        else
          if(!(first->tv_usec >= second->tv_usec))
            return -1;

          else
            if(!(second->tv_usec >= first->tv_usec))
              return 1;

            else
              return 0;
}

// timeval_create
// file timeval_functions.c line 37
struct timeval timeval_create(signed long int tv_sec, signed long int tv_usec)
{
  struct timeval tmp;
  tmp.tv_sec = tv_sec;
  tmp.tv_usec = tv_usec;
  return tmp;
}

// timeval_lq_zero
// file timeval_functions.c line 121
signed int timeval_lq_zero(struct timeval *timer)
{
  if(timer == ((struct timeval *)NULL))
    return 0;

  else
    if(!(timer->tv_sec >= 0l))
      return 1;

    else
      if(timer->tv_sec == 0l)
      {
        if(!(timer->tv_usec == 0l))
          goto __CPROVER_DUMP_L3;

        return 1;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        return 0;
      }
}

// timeval_subtract
// file timeval_functions.c line 94
signed int timeval_subtract(struct timeval *first, struct timeval *second)
{
  if(first == ((struct timeval *)NULL) || second == ((struct timeval *)NULL))
    return 1;

  else
  {
    if(!(first->tv_usec >= second->tv_usec))
    {
      first->tv_sec = first->tv_sec - (signed long int)1;
      first->tv_usec = ((signed long int)1000000 - second->tv_usec) + first->tv_usec;
    }

    else
      first->tv_usec = first->tv_usec - second->tv_usec;
    first->tv_sec = first->tv_sec - second->tv_sec;
    return 0;
  }
}

// wait_for_condition
// file thread_management.h line 30
void wait_for_condition(void)
{
  pthread_cond_wait(&maincond, &mainmutex);
}

// writen
// file network.c line 513
signed int writen(signed int fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    signed long int return_value_write$1;
    return_value_write$1=write(fd, (const void *)(buf + (signed long int)sent), (unsigned long int)(amount - sent));
    n = (signed int)return_value_write$1;
    if(!(n == -1))
      sent = sent + n;

    if(n == -1)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 11))
        return 0;

    }

  }
  return amount;
}

