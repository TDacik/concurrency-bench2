// #anon_enum_JCS_UNKNOWN=0_JCS_GRAYSCALE=1_JCS_RGB=2_JCS_YCbCr=3_JCS_CMYK=4_JCS_YCCK=5_JCS_EXT_RGB=6_JCS_EXT_RGBX=7_JCS_EXT_BGR=8_JCS_EXT_BGRX=9_JCS_EXT_XBGR=10_JCS_EXT_XRGB=11_JCS_EXT_RGBA=12_JCS_EXT_BGRA=13_JCS_EXT_ABGR=14_JCS_EXT_ARGB=15_JCS_RGB565=16
// file /usr/include/jpeglib.h line 215
enum anonymous { JCS_UNKNOWN=0, JCS_GRAYSCALE=1, JCS_RGB=2, JCS_YCbCr=3, JCS_CMYK=4, JCS_YCCK=5, JCS_EXT_RGB=6, JCS_EXT_RGBX=7, JCS_EXT_BGR=8, JCS_EXT_BGRX=9, JCS_EXT_XBGR=10, JCS_EXT_XRGB=11, JCS_EXT_RGBA=12, JCS_EXT_BGRA=13, JCS_EXT_ABGR=14, JCS_EXT_ARGB=15, JCS_RGB565=16 };

// #anon_enum_JDCT_ISLOW=0_JDCT_IFAST=1_JDCT_FLOAT=2
// file /usr/include/jpeglib.h line 244
enum anonymous_4 { JDCT_ISLOW=0, JDCT_IFAST=1, JDCT_FLOAT=2 };

// #anon_enum_VBI_BLACK=0_VBI_RED=1_VBI_GREEN=2_VBI_YELLOW=3_VBI_BLUE=4_VBI_MAGENTA=5_VBI_CYAN=6_VBI_WHITE=7
// file /usr/include/libzvbi.h line 761
enum anonymous_11 { VBI_BLACK=0, VBI_RED=1, VBI_GREEN=2, VBI_YELLOW=3, VBI_BLUE=4, VBI_MAGENTA=5, VBI_CYAN=6, VBI_WHITE=7 };

// #anon_enum_VBI_TRANSPARENT_SPACE=0_VBI_TRANSPARENT_FULL=1_VBI_SEMI_TRANSPARENT=2_VBI_OPAQUE=3
// file /usr/include/libzvbi.h line 775
enum anonymous_12 { VBI_TRANSPARENT_SPACE=0, VBI_TRANSPARENT_FULL=1, VBI_SEMI_TRANSPARENT=2, VBI_OPAQUE=3 };

// tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_23;

// tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_21;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_30;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_16;

// tag-#anon#ST[ARR16{U64}_U64_'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_32;

// tag-#anon#ST[ARR17{U8}_U8_'bits'|ARR256{U8}_U8_'huffval'|U24'_pad0'|S32'sent_table']
// file /usr/include/jpeglib.h line 101
struct anonymous_2;

// tag-#anon#ST[ARR64{U16}_U16_'quantval'|S32'sent_table']
// file /usr/include/jpeglib.h line 84
struct anonymous_1;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_33;

// tag-#anon#ST[S32'component_id'|S32'component_index'|S32'h_samp_factor'|S32'v_samp_factor'|S32'quant_tbl_no'|S32'dc_tbl_no'|S32'ac_tbl_no'|U32'width_in_blocks'|U32'height_in_blocks'|S32'DCT_scaled_size'|U32'downsampled_width'|U32'downsampled_height'|S32'component_needed'|S32'MCU_width'|S32'MCU_height'|S32'MCU_blocks'|S32'MCU_sample_width'|S32'last_col_width'|S32'last_row_height'|U32'_pad0'|*{SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'|S32'sent_table']#}_SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'|S32'sent_table']#_'quant_table'|*{V}_V_'dct_table']
// file /usr/include/jpeglib.h line 117
struct anonymous_0;

// tag-#anon#ST[S32'comps_in_scan'|ARR4{S32}_S32_'component_index'|S32'Ss'|S32'Se'|S32'Ah'|S32'Al']
// file /usr/include/jpeglib.h line 190
struct anonymous_3;

// tag-#anon#ST[S32'pgno'|S32'subno']
// file /usr/include/libzvbi.h line 832
struct anonymous_14;

// tag-#anon#ST[S32'si_pid'|U32'si_uid']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_17;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_20;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_19;

// tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_25;

// tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_18;

// tag-#anon#ST[S32'y0'|S32'y1'|S32'roll']
// file /usr/include/libzvbi.h line 819
struct anonymous_13;

// tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_22;

// tag-#anon#ST[S64'ts']
// file ./libng/grab-ng.h line 183
struct anonymous_6;

// tag-#anon#ST[S64'ts'|S32'seq'|S32'twice']
// file ./libng/grab-ng.h line 142
struct anonymous_27;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'|*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}_SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}_SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#_|*{V}_V_)->V_'sa_sigaction']
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_31;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'|ARR8{U16}_U16_'__u6_addr16'|ARR4{U32}_U32_'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous_15;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_24;

// tag-#anon#UN[ARR4{S8}_S8_'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_9;

// tag-#anon#UN[ARR8{S32}_S32_'i'|ARR80{S8}_S8_'s']
// file /usr/include/jpeglib.h line 736
union anonymous_5;

// tag-#anon#UN[S32'value'|SYM#tag-snd_seq_timestamp#'time'|U32'position'|SYM#tag-snd_seq_queue_skew#'skew'|ARR2{U32}_U32_'d32'|ARR8{U8}_U8_'d8']
// file /usr/include/alsa/seq_event.h line 284
union anonymous_28;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_7;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_8;

// tag-#anon#UN[SYM#tag-snd_seq_ev_note#'note'|SYM#tag-snd_seq_ev_ctrl#'control'|SYM#tag-snd_seq_ev_raw8#'raw8'|SYM#tag-snd_seq_ev_raw32#'raw32'|SYM#tag-snd_seq_ev_ext#'ext'|SYM#tag-snd_seq_ev_queue_control#'queue'|SYM#tag-snd_seq_timestamp#'time'|SYM#tag-snd_seq_addr#'addr'|SYM#tag-snd_seq_connect#'connect'|SYM#tag-snd_seq_result#'result'|U128'_pad']
// file /usr/include/alsa/seq_event.h line 307
union anonymous_29;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_26;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_10;

// tag-CFG_ENTRIES
// file common/parseconfig.c line 11
struct CFG_ENTRIES;

// tag-CFG_SECTIONS
// file common/parseconfig.c line 18
struct CFG_SECTIONS;

// tag-CHANLIST
// file ./common/frequencies.h line 82
struct CHANLIST;

// tag-CHANLISTS
// file ./common/frequencies.h line 87
struct CHANLISTS;

// tag-CHANNEL
// file ./common/channel.h line 11
struct CHANNEL;

// tag-CHUNKHDR
// file libng/writefile.c line 201
struct CHUNKHDR;

// tag-COMMANDS
// file common/commands.c line 109
struct COMMANDS;

// tag-DEVS
// file console/fbtools.c line 56
struct DEVS;

// tag-FIFO
// file common/capture.h line 6
struct FIFO;

// tag-JOYTAB
// file common/joystick.c line 26
struct JOYTAB;

// tag-KEYTAB
// file console/fbtv.c line 161
struct KEYTAB;

// tag-LAUNCH
// file common/channel.h line 82
struct LAUNCH;

// tag-OVERLAY_CLIP
// file ./libng/grab-ng.h line 122
struct OVERLAY_CLIP;

// tag-STRTAB
// file ./libng/grab-ng.h line 117
struct STRTAB;

// tag-WAVEHDR
// file libng/writefile.c line 207
struct WAVEHDR;

// tag-WEBCAM
// file common/webcam.c line 22
struct WEBCAM;

// tag-_FSXCharInfo
// file console/fs.h line 1
struct _FSXCharInfo;

// tag-_FSXFontInfoHeader
// file console/fs.h line 10
struct _FSXFontInfoHeader;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_WidgetRec
// file /usr/include/X11/Intrinsic.h line 107
struct _WidgetRec;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__jmp_buf_tag
// file /usr/include/setjmp.h line 34
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_snd_seq
// file /usr/include/alsa/seq.h line 47
struct _snd_seq;

// tag-_snd_seq_port_subscribe
// file /usr/include/alsa/seq.h line 317
struct _snd_seq_port_subscribe;

// tag-_win_st
// file /usr/include/curses.h line 372
struct _win_st;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-bus_type
// file common/get_media_devices.h line 63
enum bus_type { MEDIA_BUS_UNKNOWN=0, MEDIA_BUS_VIRTUAL=1, MEDIA_BUS_PCI=2, MEDIA_BUS_USB=3 };

// tag-device_type
// file ./common/get_media_devices.h line 32
enum device_type { UNKNOWN=65535, NONE=65534, MEDIA_V4L_VIDEO=0, MEDIA_V4L_VBI=1, MEDIA_V4L_RADIO=2, MEDIA_V4L_SUBDEV=3, MEDIA_DVB_VIDEO=100, MEDIA_DVB_AUDIO=101, MEDIA_DVB_SEC=102, MEDIA_DVB_FRONTEND=103, MEDIA_DVB_DEMUX=104, MEDIA_DVB_DVR=105, MEDIA_DVB_CA=106, MEDIA_DVB_NET=107, MEDIA_DVB_OSD=108, MEDIA_SND_CARD=200, MEDIA_SND_CAP=201, MEDIA_SND_OUT=202, MEDIA_SND_CONTROL=203, MEDIA_SND_HW=204, MEDIA_SND_TIMER=205, MEDIA_SND_SEQ=206 };

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-event_entry
// file ./common/event.h line 3
struct event_entry;

// tag-fb_bitfield
// file /usr/include/linux/fb.h line 185
struct fb_bitfield;

// tag-fb_cmap
// file /usr/include/linux/fb.h line 278
struct fb_cmap;

// tag-fb_con2fbmap
// file /usr/include/linux/fb.h line 287
struct fb_con2fbmap;

// tag-fb_fix_screeninfo
// file /usr/include/linux/fb.h line 154
struct fb_fix_screeninfo;

// tag-fb_var_screeninfo
// file /usr/include/linux/fb.h line 238
struct fb_var_screeninfo;

// tag-files_handle
// file libng/writefile.c line 280
struct files_handle;

// tag-fs_font
// file console/fs.h line 21
struct fs_font;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-jpeg_c_coef_controller
// file /usr/include/jpeglib.h line 457
struct jpeg_c_coef_controller;

// tag-jpeg_c_main_controller
// file /usr/include/jpeglib.h line 455
struct jpeg_c_main_controller;

// tag-jpeg_c_prep_controller
// file /usr/include/jpeglib.h line 456
struct jpeg_c_prep_controller;

// tag-jpeg_color_converter
// file /usr/include/jpeglib.h line 459
struct jpeg_color_converter;

// tag-jpeg_common_struct
// file /usr/include/jpeglib.h line 280
struct jpeg_common_struct;

// tag-jpeg_comp_master
// file /usr/include/jpeglib.h line 454
struct jpeg_comp_master;

// tag-jpeg_compress_struct
// file /usr/include/jpeglib.h line 289
struct jpeg_compress_struct;

// tag-jpeg_destination_mgr
// file /usr/include/jpeglib.h line 299
struct jpeg_destination_mgr;

// tag-jpeg_downsampler
// file /usr/include/jpeglib.h line 460
struct jpeg_downsampler;

// tag-jpeg_entropy_encoder
// file /usr/include/jpeglib.h line 462
struct jpeg_entropy_encoder;

// tag-jpeg_error_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_error_mgr;

// tag-jpeg_forward_dct
// file /usr/include/jpeglib.h line 461
struct jpeg_forward_dct;

// tag-jpeg_marker_writer
// file /usr/include/jpeglib.h line 458
struct jpeg_marker_writer;

// tag-jpeg_memory_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_memory_mgr;

// tag-jpeg_progress_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_progress_mgr;

// tag-js_event
// file /usr/include/linux/joystick.h line 47
struct js_event;

// tag-jvirt_barray_control
// file /usr/include/jpeglib.h line 828
struct jvirt_barray_control;

// tag-jvirt_sarray_control
// file /usr/include/jpeglib.h line 827
struct jvirt_sarray_control;

// tag-ldat
// file /usr/include/curses.h line 419
struct ldat;

// tag-lirc_code
// file /usr/include/lirc/lirc_client.h line 47
struct lirc_code;

// tag-lirc_config
// file /usr/include/lirc/lirc_client.h line 53
struct lirc_config;

// tag-lirc_config_entry
// file /usr/include/lirc/lirc_client.h line 55
struct lirc_config_entry;

// tag-lirc_list
// file /usr/include/lirc/lirc_client.h line 42
struct lirc_list;

// tag-list_head
// file ./libng/list.h line 15
struct list_head;

// tag-media_device_entry
// file common/get_media_devices.c line 43
struct media_device_entry;

// tag-media_devices
// file common/get_media_devices.c line 60
struct media_devices;

// tag-midi_handle
// file ./common/midictrl.h line 9
struct midi_handle;

// tag-movie_handle
// file common/capture.h line 27
struct movie_handle;

// tag-ng_attribute
// file ./libng/grab-ng.h line 243
struct ng_attribute;

// tag-ng_audio_buf
// file ./libng/grab-ng.h line 177
struct ng_audio_buf;

// tag-ng_audio_conv
// file libng/grab-ng.h line 387
struct ng_audio_conv;

// tag-ng_audio_fmt
// file ./libng/grab-ng.h line 172
struct ng_audio_fmt;

// tag-ng_convert_handle
// file ./libng/grab-ng.h line 364
struct ng_convert_handle;

// tag-ng_convthread_handle
// file common/capture.c line 122
struct ng_convthread_handle;

// tag-ng_device_config
// file ./libng/devices.h line 2
struct ng_device_config;

// tag-ng_devinfo
// file libng/grab-ng.h line 275
struct ng_devinfo;

// tag-ng_dsp_driver
// file ./libng/grab-ng.h line 321
struct ng_dsp_driver;

// tag-ng_filter
// file ./libng/grab-ng.h line 402
struct ng_filter;

// tag-ng_format_list
// file ./libng/grab-ng.h line 194
struct ng_format_list;

// tag-ng_mix_driver
// file libng/grab-ng.h line 335
struct ng_mix_driver;

// tag-ng_reader
// file libng/grab-ng.h line 220
struct ng_reader;

// tag-ng_vid_driver
// file ./libng/grab-ng.h line 284
struct ng_vid_driver;

// tag-ng_video_buf
// file ./libng/grab-ng.h line 136
struct ng_video_buf;

// tag-ng_video_conv
// file ./libng/grab-ng.h line 350
struct ng_video_conv;

// tag-ng_video_fmt
// file ./libng/grab-ng.h line 129
struct ng_video_fmt;

// tag-ng_writer
// file ./libng/grab-ng.h line 203
struct ng_writer;

// tag-pdat
// file /usr/include/curses.h line 459
struct pdat;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-raw_handle
// file libng/writefile.c line 392
struct raw_handle;

// tag-raw_priv
// file libng/writefile.c line 388
struct raw_priv;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-snd_seq_addr
// file /usr/include/alsa/seq_event.h line 178
struct snd_seq_addr;

// tag-snd_seq_connect
// file /usr/include/alsa/seq_event.h line 184
struct snd_seq_connect;

// tag-snd_seq_ev_ctrl
// file /usr/include/alsa/seq_event.h line 239
struct snd_seq_ev_ctrl;

// tag-snd_seq_ev_ext
// file /usr/include/alsa/seq_event.h line 257
struct snd_seq_ev_ext;

// tag-snd_seq_ev_note
// file /usr/include/alsa/seq_event.h line 230
struct snd_seq_ev_note;

// tag-snd_seq_ev_queue_control
// file /usr/include/alsa/seq_event.h line 281
struct snd_seq_ev_queue_control;

// tag-snd_seq_ev_raw32
// file /usr/include/alsa/seq_event.h line 252
struct snd_seq_ev_raw32;

// tag-snd_seq_ev_raw8
// file /usr/include/alsa/seq_event.h line 247
struct snd_seq_ev_raw8;

// tag-snd_seq_event
// file /usr/include/alsa/seq_event.h line 296
struct snd_seq_event;

// tag-snd_seq_queue_skew
// file /usr/include/alsa/seq_event.h line 275
struct snd_seq_queue_skew;

// tag-snd_seq_real_time
// file /usr/include/alsa/seq_event.h line 191
struct snd_seq_real_time;

// tag-snd_seq_result
// file /usr/include/alsa/seq_event.h line 269
struct snd_seq_result;

// tag-snd_seq_timestamp
// file /usr/include/alsa/seq_event.h line 200
union snd_seq_timestamp;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-vbi_char
// file /usr/include/libzvbi.h line 788
struct vbi_char;

// tag-vbi_decoder
// file /usr/include/libzvbi.h line 39
struct vbi_decoder;

// tag-vbi_font_descr
// file /usr/include/libzvbi.h line 805
struct vbi_font_descr;

// tag-vbi_page
// file /usr/include/libzvbi.h line 807
struct vbi_page;

// tag-vbi_rect
// file common/vbi-data.h line 21
struct vbi_rect;

// tag-vt_mode
// file /usr/include/linux/vt.h line 19
struct vt_mode;

// tag-vt_stat
// file /usr/include/linux/vt.h line 32
struct vt_stat;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __list_add
// file libng/list.h line 34
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);
// __sigsetjmp
// file /usr/include/setjmp.h line 59
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// add_attrs
// file ./common/commands.h line 74
void add_attrs(struct ng_attribute *new);
// add_channel
// file common/channel.c line 186
struct CHANNEL * add_channel(char *name);
// add_dvb_class
// file common/get_media_devices.c line 275
static signed int add_dvb_class(struct media_device_entry *md);
// add_snd_class
// file common/get_media_devices.c line 232
static signed int add_snd_class(struct media_device_entry *md);
// add_v4l_class
// file common/get_media_devices.c line 218
static signed int add_v4l_class(struct media_device_entry *md);
// alphasort
// file /usr/include/dirent.h line 329
extern signed int alphasort(struct dirent **, struct dirent **);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// attr_handler
// file common/commands.c line 833
static signed int attr_handler(char *name, signed int argc, char **argv);
// attr_init
// file ./common/commands.h line 68
void attr_init(void);
// attr_notify_object
//
void attr_notify_object(struct ng_attribute *, signed int);
// audio_init
// file ./common/commands.h line 69
void audio_init(void);
// audio_off
// file ./common/commands.h line 71
void audio_off(void);
// audio_on
// file ./common/commands.h line 70
void audio_on(void);
// bgr24_to_bgr32
// file libng/color_packed.c line 39
static void bgr24_to_bgr32(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr24_to_lut2
// file libng/color_lut.c line 43
static void bgr24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr24_to_lut4
// file libng/color_lut.c line 109
static void bgr24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr24_to_rgb32
// file libng/color_packed.c line 54
static void bgr24_to_rgb32(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr32_to_lut2
// file libng/color_lut.c line 69
static void bgr32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr32_to_lut4
// file libng/color_lut.c line 135
static void bgr32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// byteswap_short
// file libng/color_packed.c line 102
static void byteswap_short(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// calc_frequencies
// file common/channel.c line 299
void calc_frequencies(void);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// capture_get_hook_object
//
void capture_get_hook_object(void);
// capture_handler
// file common/commands.c line 778
static signed int capture_handler(char *name, signed int argc, char **argv);
// capture_rel_hook_object
//
void capture_rel_hook_object(void);
// cbreak
// file /usr/include/curses.h line 601
extern signed int cbreak(void);
// cf2freq
// file common/channel.c line 159
signed int cf2freq(char *name, signed int fine);
// cfg_find_section
// file common/parseconfig.c line 61
static struct CFG_ENTRIES * cfg_find_section(struct CFG_SECTIONS *c, char *name);
// cfg_get_float
// file common/parseconfig.c line 245
float cfg_get_float(char *sec, char *ent);
// cfg_get_int
// file common/parseconfig.h line 8
signed int cfg_get_int(char *sec, char *ent);
// cfg_get_signed_int
// file common/parseconfig.h line 9
signed int cfg_get_signed_int(char *sec, char *ent);
// cfg_get_str
// file common/parseconfig.h line 7
char * cfg_get_str(char *sec, char *ent);
// cfg_init_entries
// file common/parseconfig.c line 46
static struct CFG_ENTRIES * cfg_init_entries(void);
// cfg_init_sections
// file common/parseconfig.c line 33
static struct CFG_SECTIONS * cfg_init_sections(void);
// cfg_list_entries
// file common/parseconfig.h line 6
char ** cfg_list_entries(char *name);
// cfg_list_sections
// file common/parseconfig.h line 5
char ** cfg_list_sections(void);
// cfg_parse_file
// file common/parseconfig.h line 1
signed int cfg_parse_file(char *filename);
// cfg_parse_option
// file common/parseconfig.c line 153
void cfg_parse_option(char *section, char *tag, char *value);
// cfg_parse_options
// file common/parseconfig.h line 3
void cfg_parse_options(signed int *argc, char **argv);
// cfg_set_entry
// file common/parseconfig.c line 85
static void cfg_set_entry(struct CFG_ENTRIES *e, char *name, char *value);
// channel_menu
// file console/fbtv.c line 489
static void channel_menu(void);
// channel_switch_hook_object
//
void channel_switch_hook_object(void);
// chown
// file /usr/include/unistd.h line 473
extern signed int chown(const char *, unsigned int, unsigned int);
// clip_drop
// file libng/grab-ng.c line 841
static void clip_drop(struct OVERLAY_CLIP *oc, signed int n, signed int *count);
// clip_dump
// file libng/grab-ng.c line 829
static void clip_dump(char *state, struct OVERLAY_CLIP *oc, signed int count);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// console_switch
// file console/fbtv.c line 539
static void console_switch(void);
// ctrlc
// file console/fbtv.c line 352
static void ctrlc(signed int signal);
// dattr_handler
// file common/commands.c line 980
static signed int dattr_handler(char *name, signed int argc, char **argv);
// del_channel
// file common/channel.c line 287
void del_channel(signed int i);
// dev_init
// file console/fbtools.c line 74
static void dev_init(void);
// discover_media_devices
// file ./common/get_media_devices.h line 81
void * discover_media_devices(void);
// display_media_devices
// file common/get_media_devices.c line 418
void display_media_devices(void *opaque);
// display_message_object
//
void display_message_object(char *);
// dither_palette
// file console/fbtv.c line 215
static void dither_palette(signed int r, signed int g, signed int b);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// do_capture
// file console/fbtv.c line 366
static void do_capture(signed int from, signed int to, signed int tmp_switch);
// do_command
// file common/commands.h line 78
signed int do_command(signed int argc, char **argv);
// do_exit
// file console/fbtv.c line 471
static void do_exit(void);
// do_fullscreen
// file console/fbtv.c line 507
static void do_fullscreen(void);
// do_va_cmd
// file ./common/commands.h line 77
signed int do_va_cmd(signed int argc, ...);
// do_write_jpeg
// file libng/writefile.c line 87
static signed int do_write_jpeg(struct _IO_FILE *fp, struct ng_video_buf *buf, signed int quality, signed int gray);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// endwin
// file /usr/include/curses.h line 625
extern signed int endwin(void);
// event_dispatch
// file ./common/event.h line 23
signed int event_dispatch(char *event);
// event_readconfig
// file common/event.h line 20
void event_readconfig(void);
// event_register
// file ./common/event.h line 17
signed int event_register(char *event, char *action);
// event_register_list
// file ./common/event.h line 18
signed int event_register_list(struct event_entry *entry);
// event_writeconfig
// file common/event.h line 21
void event_writeconfig(struct _IO_FILE *fp);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_handler
// file common/commands.c line 1189
static signed int exit_handler(char *name, signed int argc, char **argv);
// exit_hook_object
//
void exit_hook_object(void);
// fb_activate_current
// file console/fbtools.c line 304
static signed int fb_activate_current(signed int tty);
// fb_catch_exit_signal
// file console/fbtools.c line 493
static void fb_catch_exit_signal(signed int signal);
// fb_catch_exit_signals
// file console/fbtools.h line 17
void fb_catch_exit_signals(void);
// fb_cleanup
// file console/fbtools.h line 16
void fb_cleanup(void);
// fb_init
// file console/fbtools.h line 15
signed int fb_init(char *device, char *mode, signed int vt);
// fb_initcolors
// file console/fbtv.c line 230
static void fb_initcolors(signed int fd, signed int gray);
// fb_memset
// file console/fbtools.h line 18
void fb_memset(void *addr, signed int c, unsigned long int len);
// fb_setmode
// file console/fbtools.c line 173
static signed int fb_setmode(char *name);
// fb_setvt
// file console/fbtools.c line 251
static void fb_setvt(signed int vtno);
// fb_switch_acquire
// file console/fbtools.h line 23
void fb_switch_acquire(void);
// fb_switch_init
// file console/fbtools.h line 21
signed int fb_switch_init(void);
// fb_switch_release
// file console/fbtools.h line 22
void fb_switch_release(void);
// fb_switch_signal
// file console/fbtools.c line 92
static void fb_switch_signal(signed int signal);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fget_associated_device
// file common/get_media_devices.c line 501
const char * fget_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const signed int fd_seek_device, const enum device_type seek_type);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fifo_get
// file common/capture.c line 81
void * fifo_get(struct FIFO *fifo);
// fifo_init
// file common/capture.c line 31
void fifo_init(struct FIFO *fifo, char *name, signed int slots, signed int writers);
// fifo_put
// file common/capture.c line 45
signed int fifo_put(struct FIFO *fifo, void *data);
// files_audio
// file libng/writefile.c line 364
static signed int files_audio(void *handle, struct ng_audio_buf *buf);
// files_close
// file libng/writefile.c line 374
static signed int files_close(void *handle);
// files_open
// file libng/writefile.c line 298
static void * files_open(char *filesname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio);
// files_video
// file libng/writefile.c line 330
static signed int files_video(void *handle, struct ng_video_buf *buf);
// flushit
// file common/capture.c line 106
static void * flushit(void *arg);
// fnmatch
// file /usr/include/fnmatch.h line 56
extern signed int fnmatch(const char *, const char *, signed int);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_media_devices
// file ./common/get_media_devices.h line 92
void free_media_devices(void *opaque);
// freq_init
// file ./common/frequencies.h line 105
void freq_init(void);
// freq_newtab
// file common/frequencies.h line 106
void freq_newtab(signed int n);
// freq_readlist
// file common/frequencies.c line 78
static signed int freq_readlist(struct CHANLIST **list, signed int n, char *name);
// freqtab_notify_object
//
void freqtab_notify_object(void);
// fs_consolefont
// file console/fs.h line 45
struct fs_font * fs_consolefont(char **filename);
// fs_free
// file console/fs.c line 186
void fs_free(struct fs_font *f);
// fs_init_fb
// file console/fs.h line 33
signed int fs_init_fb(signed int white8);
// fs_puts
// file console/fs.h line 36
signed int fs_puts(struct fs_font *f, unsigned int x, unsigned int y, unsigned char *str);
// fs_render_fb
// file console/fs.c line 104
void fs_render_fb(unsigned char *ptr, signed int pitch, struct _FSXCharInfo *charInfo, unsigned char *data);
// fs_render_tty
// file console/fs.c line 165
void fs_render_tty(struct _FSXCharInfo *charInfo, unsigned char *data);
// fs_textwidth
// file console/fs.h line 38
signed int fs_textwidth(struct fs_font *f, unsigned char *str);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat(signed int, struct stat *);
// fullscreen_handler
// file common/commands.c line 1158
static signed int fullscreen_handler(char *name, signed int argc, char **argv);
// fullscreen_hook_object
//
void fullscreen_hook_object(void);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_associated_device
// file ./common/get_media_devices.h line 124
const char * get_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const char *seek_device, const enum device_type seek_type);
// get_bus
// file common/get_media_devices.c line 96
static enum bus_type get_bus(char *device);
// get_class
// file common/get_media_devices.c line 121
static signed int get_class(char *class, struct media_device_entry **md, unsigned int *md_size, signed int (*fill)(struct media_device_entry *));
// get_class::fill_object
//
signed int fill_object(struct media_device_entry *);
// get_freq
// file common/channel.c line 152
signed int get_freq(signed int i);
// get_not_associated_device
// file common/get_media_devices.c line 561
const char * get_not_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const enum device_type not_desired_type);
// get_uevent_info
// file common/get_media_devices.c line 69
static void get_uevent_info(struct media_device_entry *md_ptr, char *dname);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getgid
// file /usr/include/unistd.h line 681
extern unsigned int getgid(void);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gfx_init
// file console/matrox.h line 1
extern signed int gfx_init(signed int fd);

//

// gfx_scaler_on_object
//
void gfx_scaler_on_object(signed int, signed int, signed int, signed int, signed int, signed int, signed int, signed int);
// gnu_dev_major
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 27
extern unsigned int gnu_dev_major(unsigned long long int);
// gnu_dev_minor
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 30
extern unsigned int gnu_dev_minor(unsigned long long int);
// grabber_init
// file console/fbtv.c line 518
static void grabber_init(void);
// gray_to_lut2
// file libng/color_lut.c line 82
static void gray_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// gray_to_lut4
// file libng/color_lut.c line 148
static void gray_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// init_channel
// file common/channel.c line 318
static void init_channel(char *name, struct CHANNEL *c);
// init_overlay
// file ./common/commands.h line 75
void init_overlay(void);
// initscr
// file /usr/include/curses.h line 646
extern struct _win_st * initscr(void);
// int_to_str
// file common/channel.c line 752
const char * int_to_str(signed int n, struct STRTAB *tab);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// joystick_tv_havedata
// file ./common/joystick.h line 2
void joystick_tv_havedata(signed int js);
// joystick_tv_init
// file ./common/joystick.h line 1
signed int joystick_tv_init(char *dev);
// jpeg_CreateCompress
// file /usr/include/jpeglib.h line 904
extern void jpeg_CreateCompress(struct jpeg_compress_struct *, signed int, unsigned long int);
// jpeg_destroy_compress
// file /usr/include/jpeglib.h line 909
extern void jpeg_destroy_compress(struct jpeg_compress_struct *);
// jpeg_finish_compress
// file /usr/include/jpeglib.h line 954
extern void jpeg_finish_compress(struct jpeg_compress_struct *);
// jpeg_set_defaults
// file /usr/include/jpeglib.h line 926
extern void jpeg_set_defaults(struct jpeg_compress_struct *);
// jpeg_set_quality
// file /usr/include/jpeglib.h line 931
extern void jpeg_set_quality(struct jpeg_compress_struct *, signed int, signed int);
// jpeg_start_compress
// file /usr/include/jpeglib.h line 949
extern void jpeg_start_compress(struct jpeg_compress_struct *, signed int);
// jpeg_std_error
// file /usr/include/jpeglib.h line 889
extern struct jpeg_error_mgr * jpeg_std_error(struct jpeg_error_mgr *);
// jpeg_stdio_dest
// file /usr/include/jpeglib.h line 914
extern void jpeg_stdio_dest(struct jpeg_compress_struct *, struct _IO_FILE *);
// jpeg_write_scanlines
// file /usr/include/jpeglib.h line 951
extern unsigned int jpeg_write_scanlines(struct jpeg_compress_struct *, unsigned char **, unsigned int);
// keypad
// file /usr/include/curses.h line 661
extern signed int keypad(struct _win_st *, _Bool);
// keypad_handler
// file common/commands.c line 1484
static signed int keypad_handler(char *name, signed int argc, char **argv);
// keypad_timeout
// file ./common/commands.h line 80
void keypad_timeout(void);
// linear_palette
// file console/fbtv.c line 194
static void linear_palette(signed int r, signed int g, signed int b);
// link
// file /usr/include/unistd.h line 790
extern signed int link(const char *, const char *);
// lirc_code2char
// file /usr/include/lirc/lirc_client.h line 89
signed int lirc_code2char(struct lirc_config *, char *, char **);
// lirc_init
// file /usr/include/lirc/lirc_client.h line 77
signed int lirc_init(char *, signed int);
// lirc_nextcode
// file /usr/include/lirc/lirc_client.h line 88
signed int lirc_nextcode(char **);
// lirc_readconfig
// file /usr/include/lirc/lirc_client.h line 80
signed int lirc_readconfig(char *, struct lirc_config **, signed int (*)(char *));
// lirc_tv_havedata
// file ./common/lirc.h line 2
signed int lirc_tv_havedata(void);
// lirc_tv_init
// file ./common/lirc.h line 1
signed int lirc_tv_init(void);
// list_add_tail
// file libng/list.h line 65
static inline void list_add_tail(struct list_head *new, struct list_head *head);
// list_handler
// file common/commands.c line 943
static signed int list_handler(char *name, signed int argc, char **argv);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// lookup_channel
// file common/channel.c line 102
signed int lookup_channel(char *channel);
// lseek
// file /usr/include/unistd.h line 337
extern signed long int lseek(signed int, signed long int, signed int);
// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 266
extern signed int lstat(const char *, struct stat *);
// mach64_scaler_off
// file console/matrox.c line 186
static void mach64_scaler_off(void);
// mach64_scaler_on
// file console/matrox.c line 148
static void mach64_scaler_on(signed int offscreen, signed int pitch, signed int width, signed int height, signed int left, signed int right, signed int top, signed int bottom);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// matrox_scaler_off
// file console/matrox.c line 111
static void matrox_scaler_off(void);
// matrox_scaler_on
// file console/matrox.c line 74
static void matrox_scaler_on(signed int offscreen, signed int pitch, signed int width, signed int height, signed int left, signed int right, signed int top, signed int bottom);
// media_device_type
// file common/get_media_devices.c line 364
const char * media_device_type(enum device_type type);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// midi_close
// file common/midictrl.c line 182
signed int midi_close(struct midi_handle *h);
// midi_connect
// file ./common/midictrl.h line 18
signed int midi_connect(struct midi_handle *h, char *arg);
// midi_dump_ev
// file common/midictrl.c line 68
static void midi_dump_ev(struct _IO_FILE *out, struct snd_seq_event *ev);
// midi_open
// file ./common/midictrl.h line 16
signed int midi_open(struct midi_handle *h, char *name);
// midi_read
// file ./common/midictrl.h line 19
signed int midi_read(struct midi_handle *h);
// midi_translate
// file ./common/midictrl.h line 21
void midi_translate(struct midi_handle *h);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 61
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// movie_grab_put_video
// file common/capture.c line 606
signed int movie_grab_put_video(struct movie_handle *h, struct ng_video_buf **ret);
// movie_handler
// file common/commands.c line 1149
static signed int movie_handler(char *name, signed int argc, char **argv);
// movie_hook_object
//
void movie_hook_object(signed int, char **);
// movie_print_timestamps
// file common/capture.c line 583
static void movie_print_timestamps(struct movie_handle *h);
// movie_writer_init
// file common/capture.c line 398
struct movie_handle * movie_writer_init(char *moviename, char *audioname, struct ng_writer *writer, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio, char *dsp, signed int slots, signed int threads);
// movie_writer_start
// file common/capture.c line 498
signed int movie_writer_start(struct movie_handle *h);
// movie_writer_stop
// file common/capture.c line 518
signed int movie_writer_stop(struct movie_handle *h);
// msg_handler
// file common/commands.c line 1166
static signed int msg_handler(char *name, signed int argc, char **argv);
// mute_notify_object
//
void mute_notify_object(signed int);
// new_message
// file console/fbtv.c line 483
static void new_message(char *txt);
// new_title
// file console/fbtv.c line 477
static void new_title(char *txt);
// ng_aconv_register
// file libng/grab-ng.c line 409
signed int ng_aconv_register(signed int magic, char *plugname, struct ng_audio_conv *list, signed int count);
// ng_attr_byid
// file ./libng/grab-ng.h line 257
struct ng_attribute * ng_attr_byid(struct ng_attribute *attrs, signed int id);
// ng_attr_byname
// file ./libng/grab-ng.h line 258
struct ng_attribute * ng_attr_byname(struct ng_attribute *attrs, char *name);
// ng_attr_getint
// file ./libng/grab-ng.h line 260
signed int ng_attr_getint(struct ng_attribute *attr, char *value);
// ng_attr_getstr
// file ./libng/grab-ng.h line 259
const char * ng_attr_getstr(struct ng_attribute *attr, signed int value);
// ng_attr_int2percent
// file ./libng/grab-ng.h line 262
signed int ng_attr_int2percent(struct ng_attribute *attr, signed int value);
// ng_attr_listchoices
// file ./libng/grab-ng.h line 261
void ng_attr_listchoices(struct ng_attribute *attr);
// ng_attr_parse_int
// file ./libng/grab-ng.h line 264
signed int ng_attr_parse_int(struct ng_attribute *attr, char *str);
// ng_attr_percent2int
// file libng/grab-ng.c line 297
signed int ng_attr_percent2int(struct ng_attribute *attr, signed int percent);
// ng_check_clipping
// file libng/grab-ng.c line 847
void ng_check_clipping(signed int width, signed int height, signed int xadjust, signed int yadjust, struct OVERLAY_CLIP *oc, signed int *count);
// ng_check_magic
// file libng/grab-ng.c line 381
static signed int ng_check_magic(signed int magic, char *plugname, char *type);
// ng_color_packed_init
// file libng/grab-ng.h line 479
void ng_color_packed_init(void);
// ng_color_yuv2rgb_init
// file libng/grab-ng.h line 480
void ng_color_yuv2rgb_init(void);
// ng_conv_find_from
// file libng/grab-ng.c line 504
struct ng_video_conv * ng_conv_find_from(unsigned int in, signed int *i);
// ng_conv_find_match
// file libng/grab-ng.c line 531
struct ng_video_conv * ng_conv_find_match(unsigned int in, unsigned int out);
// ng_conv_find_to
// file ./libng/grab-ng.h line 445
struct ng_video_conv * ng_conv_find_to(unsigned int out, signed int *i);
// ng_conv_nop_fini
// file libng/color_common.c line 56
void ng_conv_nop_fini(void *handle);
// ng_conv_nop_init
// file libng/color_common.c line 49
void * ng_conv_nop_init(struct ng_video_fmt *out, void *priv);
// ng_conv_register
// file libng/grab-ng.c line 396
signed int ng_conv_register(signed int magic, char *plugname, struct ng_video_conv *list, signed int count);
// ng_convert_alloc
// file ./libng/grab-ng.h line 373
struct ng_convert_handle * ng_convert_alloc(struct ng_video_conv *conv, struct ng_video_fmt *i, struct ng_video_fmt *o);
// ng_convert_copyframe
// file libng/convert.c line 69
static void ng_convert_copyframe(struct ng_video_buf *dest, struct ng_video_buf *src);
// ng_convert_fini
// file ./libng/grab-ng.h line 380
void ng_convert_fini(struct ng_convert_handle *h);
// ng_convert_frame
// file ./libng/grab-ng.h line 377
struct ng_video_buf * ng_convert_frame(struct ng_convert_handle *h, struct ng_video_buf *dest, struct ng_video_buf *buf);
// ng_convert_init
// file ./libng/grab-ng.h line 376
void ng_convert_init(struct ng_convert_handle *h);
// ng_convert_single
// file ./libng/grab-ng.h line 381
struct ng_video_buf * ng_convert_single(struct ng_convert_handle *h, struct ng_video_buf *in);
// ng_convert_thread
// file common/capture.c line 132
void * ng_convert_thread(void *arg);
// ng_device_init
// file libng/devices.h line 14
void ng_device_init(void);
// ng_dsp_driver_register
// file libng/grab-ng.c line 458
signed int ng_dsp_driver_register(signed int magic, char *plugname, struct ng_dsp_driver *driver);
// ng_dsp_open
// file ./libng/grab-ng.h line 452
struct ng_dsp_driver * ng_dsp_open(char *device, struct ng_audio_fmt *fmt, signed int record, void **handle);
// ng_filter_register
// file libng/grab-ng.c line 422
signed int ng_filter_register(signed int magic, char *plugname, struct ng_filter *filter);
// ng_filter_single
// file ./libng/grab-ng.h line 461
struct ng_video_buf * ng_filter_single(struct ng_filter *filter, struct ng_video_buf *in);
// ng_find_reader
// file libng/grab-ng.c line 763
struct ng_reader * ng_find_reader(char *filename);
// ng_free_video_buf
// file libng/grab-ng.c line 154
static void ng_free_video_buf(struct ng_video_buf *buf);
// ng_get_timestamp
// file ./libng/grab-ng.h line 458
signed long int ng_get_timestamp(void);
// ng_grabber_findconv
// file ./common/capture.h line 21
struct ng_video_conv * ng_grabber_findconv(struct ng_video_fmt *fmt, signed int fix_ratio);
// ng_grabber_get_image
// file common/capture.h line 24
struct ng_video_buf * ng_grabber_get_image(struct ng_video_fmt *fmt);
// ng_grabber_grab_image
// file ./common/capture.h line 23
struct ng_video_buf * ng_grabber_grab_image(signed int single);
// ng_grabber_setformat
// file ./common/capture.h line 20
signed int ng_grabber_setformat(struct ng_video_fmt *fmt, signed int fix_ratio);
// ng_init
// file ./libng/grab-ng.h line 466
void ng_init(void);
// ng_init_video_buf
// file libng/grab-ng.c line 122
void ng_init_video_buf(struct ng_video_buf *buf);
// ng_lut_init
// file libng/color_lut.c line 241
void ng_lut_init(unsigned long int red_mask, unsigned long int green_mask, unsigned long int blue_mask, unsigned int fmtid, signed int swap);
// ng_malloc_audio_buf
// file libng/grab-ng.c line 184
struct ng_audio_buf * ng_malloc_audio_buf(struct ng_audio_fmt *fmt, signed int size);
// ng_malloc_video_buf
// file libng/grab-ng.c line 161
struct ng_video_buf * ng_malloc_video_buf(struct ng_video_fmt *fmt, signed int size);
// ng_mix_driver_register
// file libng/grab-ng.c line 467
signed int ng_mix_driver_register(signed int magic, char *plugname, struct ng_mix_driver *driver);
// ng_mix_init
// file ./libng/grab-ng.h line 454
struct ng_attribute * ng_mix_init(char *device, char *channel);
// ng_packed_frame
// file libng/color_common.c line 22
void ng_packed_frame(void *handle, struct ng_video_buf *out, struct ng_video_buf *in);

//

// ng_packed_init
// file libng/color_common.c line 16
void * ng_packed_init(struct ng_video_fmt *out, void *priv);
// ng_plugins
// file libng/grab-ng.c line 940
static signed int ng_plugins(char *dirname);
// ng_plugins::1::initcall_object
//
void initcall_object(void);
// ng_ratio_fixup
// file ./libng/grab-ng.h line 268
void ng_ratio_fixup(signed int *width, signed int *height, signed int *xoff, signed int *yoff);
// ng_ratio_fixup2
// file libng/grab-ng.c line 349
void ng_ratio_fixup2(signed int *width, signed int *height, signed int *xoff, signed int *yoff, signed int ratio_x, signed int ratio_y, signed int up);
// ng_reader_register
// file libng/grab-ng.c line 440
signed int ng_reader_register(signed int magic, char *plugname, struct ng_reader *reader);
// ng_release_video_buf
// file ./libng/grab-ng.h line 162
void ng_release_video_buf(struct ng_video_buf *buf);
// ng_rgb24_to_lut2
// file libng/color_lut.c line 30
void ng_rgb24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// ng_rgb24_to_lut4
// file libng/color_lut.c line 96
void ng_rgb24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// ng_tofday_to_timestamp
// file libng/grab-ng.c line 793
signed long int ng_tofday_to_timestamp(struct timeval *tv);
// ng_vid_driver_register
// file libng/grab-ng.c line 449
signed int ng_vid_driver_register(signed int magic, char *plugname, struct ng_vid_driver *driver);
// ng_vid_open
// file ./libng/grab-ng.h line 449
struct ng_vid_driver * ng_vid_open(char **device, char *driver, struct ng_video_fmt *screen, void *base, void **handle);
// ng_vid_open_auto
// file libng/grab-ng.c line 547
static void * ng_vid_open_auto(struct ng_vid_driver *drv, char *devpath, signed int allow_grabber);
// ng_waiton_video_buf
// file libng/grab-ng.c line 146
void ng_waiton_video_buf(struct ng_video_buf *buf);
// ng_wakeup_video_buf
// file libng/grab-ng.c line 141
void ng_wakeup_video_buf(struct ng_video_buf *buf);
// ng_writefile_init
// file libng/grab-ng.h line 481
void ng_writefile_init(void);
// ng_writer_register
// file libng/grab-ng.c line 431
signed int ng_writer_register(signed int magic, char *plugname, struct ng_writer *writer);
// ng_yuv420p_to_lut2
// file libng/grab-ng.h line 489
void ng_yuv420p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_yuv420p_to_lut4
// file libng/grab-ng.h line 491
void ng_yuv420p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_yuv422_to_lut2
// file libng/grab-ng.h line 487
void ng_yuv422_to_lut2(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// ng_yuv422_to_lut4
// file libng/grab-ng.h line 488
void ng_yuv422_to_lut4(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// ng_yuv422p_to_lut2
// file libng/grab-ng.h line 493
void ng_yuv422p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_yuv422p_to_lut4
// file libng/grab-ng.h line 495
void ng_yuv422p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// noecho
// file /usr/include/curses.h line 725
extern signed int noecho(void);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// oss_levels
// file common/sound.c line 13
void oss_levels(struct ng_audio_buf *buf, signed int *left, signed int *right);
// parse_action
// file common/event.c line 21
static void parse_action(struct event_entry *entry);
// parse_config
// file ./common/channel.h line 77
void parse_config(signed int parse_channels);
// patch_up
// file libng/writefile.c line 36
signed int patch_up(char *name);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// print_choices
// file common/commands.c line 753
static void print_choices(char *name, char *value, struct STRTAB *tab);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_7 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_7 *, const union anonymous_9 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_7 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_7 *, union anonymous_8 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_8 *, const union anonymous_9 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_8 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous_8 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_8 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_setcanceltype
// file /usr/include/pthread.h line 512
extern signed int pthread_setcanceltype(signed int, signed int *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// raw_audio
// file libng/writefile.c line 519
static signed int raw_audio(void *handle, struct ng_audio_buf *buf);
// raw_close
// file libng/writefile.c line 529
static signed int raw_close(void *handle);
// raw_open
// file libng/writefile.c line 408
static void * raw_open(char *videoname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio);
// raw_video
// file libng/writefile.c line 497
static signed int raw_video(void *handle, struct ng_video_buf *buf);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_config
// file ./common/channel.h line 76
void read_config(char *conffile, signed int *argc, char **argv);
// readdir
// file /usr/include/dirent.h line 165
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// rec_status_object
//
void rec_status_object(char *);
// record_audio_thread
// file common/capture.c line 371
static void * record_audio_thread(void *arg);
// redblue_swap
// file libng/color_packed.c line 25
static void redblue_swap(unsigned char *dest, unsigned char *src, signed int p);
// rgb15_be_gray
// file libng/color_packed.c line 137
static void rgb15_be_gray(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb15_native_gray
// file libng/color_packed.c line 119
static void rgb15_native_gray(unsigned char * restrict dest, unsigned char *s, signed int p);
// rgb32_to_bgr24
// file libng/color_packed.c line 85
static void rgb32_to_bgr24(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb32_to_lut2
// file libng/color_lut.c line 56
static void rgb32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb32_to_lut4
// file libng/color_lut.c line 122
static void rgb32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb32_to_rgb24
// file libng/color_packed.c line 70
static void rgb32_to_rgb24(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// save_config
// file common/channel.c line 559
void save_config(void);
// scandir
// file /usr/include/dirent.h line 262
extern signed int scandir(const char *, struct dirent *** restrict , signed int (*)(struct dirent *), signed int (*)(struct dirent **, struct dirent **));
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_30 *, struct anonymous_30 *, struct anonymous_30 *, struct timeval *);
// set_attr
// file common/commands.c line 331
static void set_attr(struct ng_attribute *attr, signed int val);
// set_capture
// file common/commands.c line 304
static void set_capture(signed int capture, signed int tmp_switch);
// set_capture_hook_object
//
void set_capture_hook_object(signed int, signed int, signed int);
// set_defaults
// file ./common/commands.h line 72
void set_defaults(void);
// set_freqtab
// file common/commands.c line 364
static void set_freqtab(signed int j);
// set_msg_bool
// file common/commands.c line 418
static void set_msg_bool(const char *name, signed int val);
// set_msg_int
// file common/commands.c line 406
static void set_msg_int(struct ng_attribute *attr, signed int val);
// set_msg_str
// file common/commands.c line 429
static void set_msg_str(const char *name, const char *val);
// set_mute
// file common/commands.c line 351
static void set_mute(signed int val);
// set_title
// file common/commands.c line 381
static void set_title(void);
// set_volume
// file common/commands.c line 342
static void set_volume(signed int val);
// setchannel_handler
// file common/commands.c line 667
static signed int setchannel_handler(char *name, signed int argc, char **argv);
// setfreqtab_handler
// file common/commands.c line 763
static signed int setfreqtab_handler(char *name, signed int argc, char **argv);
// setfreqtab_notify_object
//
void setfreqtab_notify_object(void);
// setpixel_object
//
void setpixel_object(void *, unsigned int);
// setpixel1
// file console/fs.c line 49
static void setpixel1(void *ptr, unsigned int color);
// setpixel2
// file console/fs.c line 54
static void setpixel2(void *ptr, unsigned int color);
// setpixel3
// file console/fs.c line 59
static void setpixel3(void *ptr, unsigned int color);
// setpixel4
// file console/fs.c line 66
static void setpixel4(void *ptr, unsigned int color);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setstation_handler
// file common/commands.c line 567
static signed int setstation_handler(char *name, signed int argc, char **argv);
// setstation_notify_object
//
void setstation_notify_object(void);
// show_handler
// file common/commands.c line 909
static signed int show_handler(char *name, signed int argc, char **argv);
// showtime_handler
// file common/commands.c line 1174
static signed int showtime_handler(char *name, signed int argc, char **argv);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_32 *);
// siglongjmp
// file /usr/include/setjmp.h line 102
extern void siglongjmp(struct __jmp_buf_tag *, signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snap_filename
// file ./libng/writefile.h line 2
char * snap_filename(char *base, char *channel, char *ext);
// snap_handler
// file common/commands.c line 1006
static signed int snap_handler(char *hname, signed int argc, char **argv);
// snd_seq_client_id
// file /usr/include/alsa/seq.h line 87
signed int snd_seq_client_id(struct _snd_seq *);
// snd_seq_close
// file /usr/include/alsa/seq.h line 82
signed int snd_seq_close(struct _snd_seq *);
// snd_seq_create_simple_port
// file /usr/include/alsa/seqmid.h line 328
signed int snd_seq_create_simple_port(struct _snd_seq *, const char *, unsigned int, unsigned int);
// snd_seq_event_input
// file /usr/include/alsa/seq.h line 522
signed int snd_seq_event_input(struct _snd_seq *, struct snd_seq_event **);
// snd_seq_free_event
// file /usr/include/alsa/seq.h line 517
signed int snd_seq_free_event(struct snd_seq_event *);
// snd_seq_open
// file /usr/include/alsa/seq.h line 78
signed int snd_seq_open(struct _snd_seq **, const char *, signed int, signed int);
// snd_seq_poll_descriptors
// file /usr/include/alsa/seq.h line 84
signed int snd_seq_poll_descriptors(struct _snd_seq *, struct pollfd *, unsigned int, signed short int);
// snd_seq_port_subscribe_free
// file /usr/include/alsa/seq.h line 324
void snd_seq_port_subscribe_free(struct _snd_seq_port_subscribe *);
// snd_seq_port_subscribe_malloc
// file /usr/include/alsa/seq.h line 323
signed int snd_seq_port_subscribe_malloc(struct _snd_seq_port_subscribe **);
// snd_seq_port_subscribe_set_dest
// file /usr/include/alsa/seq.h line 335
void snd_seq_port_subscribe_set_dest(struct _snd_seq_port_subscribe *, const struct snd_seq_addr *);
// snd_seq_port_subscribe_set_sender
// file /usr/include/alsa/seq.h line 334
void snd_seq_port_subscribe_set_sender(struct _snd_seq_port_subscribe *, const struct snd_seq_addr *);
// snd_seq_set_client_name
// file /usr/include/alsa/seqmid.h line 344
signed int snd_seq_set_client_name(struct _snd_seq *, const char *);
// snd_seq_subscribe_port
// file /usr/include/alsa/seq.h line 342
signed int snd_seq_subscribe_port(struct _snd_seq *, struct _snd_seq_port_subscribe *);
// snd_strerror
// file /usr/include/alsa/error.h line 45
const char * snd_strerror(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sort_media_device_entry
// file common/get_media_devices.c line 299
static signed int sort_media_device_entry(const void *a, const void *b);
// split_cmdline
// file common/commands.h line 79
char ** split_cmdline(char *line, signed int *count);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// str_to_int
// file common/channel.c line 739
signed int str_to_int(char *str, struct STRTAB *tab);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcasestr
// file /usr/include/string.h line 372
extern char * strcasestr(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strfamily
// file common/commands.c line 1198
static char * strfamily(signed int family);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// sync
// file /usr/include/unistd.h line 972
extern void sync(void);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcp_connect
// file common/commands.c line 1209
static signed int tcp_connect(struct addrinfo *ai, char *host, char *serv);
// tcp_readbuf
// file common/commands.c line 1256
static signed int tcp_readbuf(signed int sock, signed int timeout, char *dest, char dlen);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// text_init
// file console/fbtv.c line 317
static void text_init(char *font);
// text_out
// file console/fbtv.c line 330
static void text_out(signed int x, signed int y, char *str);
// text_width
// file console/fbtv.c line 338
static signed int text_width(char *str);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tty_cleanup
// file console/fbtv.c line 306
static void tty_cleanup(void);
// tty_init
// file console/fbtv.c line 296
static void tty_init(void);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_int
// file common/commands.c line 441
static signed int update_int(struct ng_attribute *attr, signed int old, char *new);
// update_title_object
//
void update_title_object(char *);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vdr_handler
// file common/commands.c line 1293
static signed int vdr_handler(char *name, signed int argc, char **argv);
// volume_handler
// file common/commands.c line 796
static signed int volume_handler(char *name, signed int argc, char **argv);
// volume_notify_object
//
void volume_notify_object(void);
// vtx_subtitle_object
//
void vtx_subtitle_object(struct vbi_page *, struct vbi_rect *);
// wav_init_header
// file libng/writefile.c line 233
static void wav_init_header(struct WAVEHDR *fileheader, struct ng_audio_fmt *audio);
// wav_start_write
// file libng/writefile.c line 261
static void wav_start_write(signed int fd, struct WAVEHDR *fileheader, struct ng_audio_fmt *audio);
// wav_stop_write
// file libng/writefile.c line 268
static void wav_stop_write(signed int fd, struct WAVEHDR *fileheader, signed int wav_size);
// wclear
// file /usr/include/curses.h line 815
extern signed int wclear(struct _win_st *);
// webcam_exit
// file common/webcam.c line 118
void webcam_exit(void);
// webcam_handler
// file common/commands.c line 1115
static signed int webcam_handler(char *hname, signed int argc, char **argv);
// webcam_init
// file common/webcam.c line 108
void webcam_init(void);
// webcam_put
// file common/webcam.c line 128
signed int webcam_put(char *filename, struct ng_video_buf *buf);
// webcam_writer
// file common/webcam.c line 30
static void * webcam_writer(void *arg);
// wgetch
// file /usr/include/curses.h line 824
extern signed int wgetch(struct _win_st *);
// wrefresh
// file /usr/include/curses.h line 843
extern signed int wrefresh(struct _win_st *);
// wrio4
// file console/matrox.c line 30
static void wrio4(signed int adr, unsigned long int val);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_jpeg
// file ./libng/writefile.h line 4
signed int write_jpeg(char *filename, struct ng_video_buf *buf, signed int quality, signed int gray);
// write_pgm
// file libng/writefile.c line 161
signed int write_pgm(char *filename, struct ng_video_buf *buf);
// write_ppm
// file ./libng/writefile.h line 6
signed int write_ppm(char *filename, struct ng_video_buf *buf);
// writer_audio_thread
// file common/capture.c line 295
static void * writer_audio_thread(void *arg);
// writer_video_thread
// file common/capture.c line 321
static void * writer_video_thread(void *arg);
// yuv420p_to_rgb24
// file libng/color_yuv2rgb.c line 170
static void yuv420p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// yuv422_to_gray
// file libng/color_yuv2rgb.c line 64
static void yuv422_to_gray(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// yuv422_to_rgb24
// file libng/color_yuv2rgb.c line 78
static void yuv422_to_rgb24(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// yuv422p_to_rgb24
// file libng/color_yuv2rgb.c line 206
static void yuv422p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// yuv42xp_to_gray
// file libng/color_yuv2rgb.c line 149
static void yuv42xp_to_gray(void *h, struct ng_video_buf *out, struct ng_video_buf *in);

struct anonymous_23
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_21
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_30
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_16
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_32
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_2
{
  // bits
  unsigned char bits[17l];
  // huffval
  unsigned char huffval[256l];
  // sent_table
  signed int sent_table;
};

struct anonymous_1
{
  // quantval
  unsigned short int quantval[64l];
  // sent_table
  signed int sent_table;
};

struct anonymous_33
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_0
{
  // component_id
  signed int component_id;
  // component_index
  signed int component_index;
  // h_samp_factor
  signed int h_samp_factor;
  // v_samp_factor
  signed int v_samp_factor;
  // quant_tbl_no
  signed int quant_tbl_no;
  // dc_tbl_no
  signed int dc_tbl_no;
  // ac_tbl_no
  signed int ac_tbl_no;
  // width_in_blocks
  unsigned int width_in_blocks;
  // height_in_blocks
  unsigned int height_in_blocks;
  // DCT_scaled_size
  signed int DCT_scaled_size;
  // downsampled_width
  unsigned int downsampled_width;
  // downsampled_height
  unsigned int downsampled_height;
  // component_needed
  signed int component_needed;
  // MCU_width
  signed int MCU_width;
  // MCU_height
  signed int MCU_height;
  // MCU_blocks
  signed int MCU_blocks;
  // MCU_sample_width
  signed int MCU_sample_width;
  // last_col_width
  signed int last_col_width;
  // last_row_height
  signed int last_row_height;
  // quant_table
  struct anonymous_1 *quant_table;
  // dct_table
  void *dct_table;
};

struct anonymous_3
{
  // comps_in_scan
  signed int comps_in_scan;
  // component_index
  signed int component_index[4l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
};

struct anonymous_14
{
  // pgno
  signed int pgno;
  // subno
  signed int subno;
};

struct anonymous_17
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_20
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_19
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_18
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_22
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_24
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_17 _kill;
  // _timer
  struct anonymous_18 _timer;
  // _rt
  struct anonymous_19 _rt;
  // _sigchld
  struct anonymous_20 _sigchld;
  // _sigfault
  struct anonymous_21 _sigfault;
  // _sigpoll
  struct anonymous_22 _sigpoll;
  // _sigsys
  struct anonymous_23 _sigsys;
};

struct anonymous_25
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_24 _sifields;
};

struct anonymous_13
{
  // y0
  signed int y0;
  // y1
  signed int y1;
  // roll
  signed int roll;
};

struct anonymous_6
{
  // ts
  signed long int ts;
};

struct anonymous_27
{
  // ts
  signed long int ts;
  // seq
  signed int seq;
  // twice
  signed int twice;
};

union anonymous_31
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_25 *, void *);
};

union anonymous_15
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_9
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_5
{
  // i
  signed int i[8l];
  // s
  char s[80l];
};

struct snd_seq_real_time
{
  // tv_sec
  unsigned int tv_sec;
  // tv_nsec
  unsigned int tv_nsec;
};

union snd_seq_timestamp
{
  // tick
  unsigned int tick;
  // time
  struct snd_seq_real_time time;
};

struct snd_seq_queue_skew
{
  // value
  unsigned int value;
  // base
  unsigned int base;
};

union anonymous_28
{
  // value
  signed int value;
  // time
  union snd_seq_timestamp time;
  // position
  unsigned int position;
  // skew
  struct snd_seq_queue_skew skew;
  // d32
  unsigned int d32[2l];
  // d8
  unsigned char d8[8l];
};

union anonymous_7
{
  // __data
  struct anonymous_33 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_8
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct snd_seq_ev_note
{
  // channel
  unsigned char channel;
  // note
  unsigned char note;
  // velocity
  unsigned char velocity;
  // off_velocity
  unsigned char off_velocity;
  // duration
  unsigned int duration;
};

struct snd_seq_ev_ctrl
{
  // channel
  unsigned char channel;
  // unused
  unsigned char unused[3l];
  // param
  unsigned int param;
  // value
  signed int value;
};

struct snd_seq_ev_raw8
{
  // d
  unsigned char d[12l];
};

struct snd_seq_ev_raw32
{
  // d
  unsigned int d[3l];
};

struct snd_seq_ev_ext
{
  // len
  unsigned int len;
  // ptr
  void *ptr;
} __attribute__ ((__packed__));

struct snd_seq_ev_queue_control
{
  // queue
  unsigned char queue;
  // unused
  unsigned char unused[3l];
  // param
  union anonymous_28 param;
};

struct snd_seq_addr
{
  // client
  unsigned char client;
  // port
  unsigned char port;
};

struct snd_seq_connect
{
  // sender
  struct snd_seq_addr sender;
  // dest
  struct snd_seq_addr dest;
};

struct snd_seq_result
{
  // event
  signed int event;
  // result
  signed int result;
};

union anonymous_29
{
  // note
  struct snd_seq_ev_note note;
  // control
  struct snd_seq_ev_ctrl control;
  // raw8
  struct snd_seq_ev_raw8 raw8;
  // raw32
  struct snd_seq_ev_raw32 raw32;
  // ext
  struct snd_seq_ev_ext ext;
  // queue
  struct snd_seq_ev_queue_control queue;
  // time
  union snd_seq_timestamp time;
  // addr
  struct snd_seq_addr addr;
  // connect
  struct snd_seq_connect connect;
  // result
  struct snd_seq_result result;
};

union anonymous_26
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_10
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct CFG_ENTRIES
{
  // ent_count
  signed int ent_count;
  // ent_names
  char **ent_names;
  // ent_values
  char **ent_values;
  // ent_seen
  signed int **ent_seen;
};

struct CFG_SECTIONS
{
  // sec_count
  signed int sec_count;
  // sec_names
  char **sec_names;
  // sec_entries
  struct CFG_ENTRIES **sec_entries;
};

struct CHANLIST
{
  // name
  char *name;
  // freq
  unsigned int freq;
};

struct CHANLISTS
{
  // name
  char *name;
  // filename
  char *filename;
  // list
  struct CHANLIST *list;
  // count
  signed int count;
};

struct CHANNEL
{
  // name
  char *name;
  // key
  char *key;
  // group
  char *group;
  // midi
  signed int midi;
  // cname
  char *cname;
  // channel
  signed int channel;
  // fine
  signed int fine;
  // freq
  signed int freq;
  // audio
  signed int audio;
  // capture
  signed int capture;
  // input
  signed int input;
  // norm
  signed int norm;
  // color
  signed int color;
  // bright
  signed int bright;
  // hue
  signed int hue;
  // contrast
  signed int contrast;
  // pixmap
  unsigned long int pixmap;
  // button
  struct _WidgetRec *button;
};

struct CHUNKHDR
{
  // ckid
  unsigned int ckid;
  // dwSize
  unsigned int dwSize;
};

struct COMMANDS
{
  // name
  char *name;
  // min_args
  signed int min_args;
  // handler
  signed int (*handler)(char *, signed int, char **);
};

struct DEVS
{
  // fb0
  char *fb0;
  // fbnr
  char *fbnr;
  // ttynr
  char *ttynr;
};

struct FIFO
{
  // name
  char *name;
  // data
  unsigned char *data[64l];
  // slots
  signed int slots;
  // read
  signed int read;
  // write
  signed int write;
  // eof
  signed int eof;
  // max
  signed int max;
  // writers
  signed int writers;
  // lock
  union anonymous_8 lock;
  // hasdata
  union anonymous_7 hasdata;
};

struct JOYTAB
{
  // class
  signed int class;
  // number
  signed int number;
  // value
  signed int value;
  // event
  char *event;
};

struct KEYTAB
{
  // key
  signed int key;
  // name
  char *name;
};

struct LAUNCH
{
  // name
  char *name;
  // key
  char *key;
  // cmdline
  char *cmdline;
};

struct OVERLAY_CLIP
{
  // x1
  signed int x1;
  // x2
  signed int x2;
  // y1
  signed int y1;
  // y2
  signed int y2;
};

struct STRTAB
{
  // nr
  signed long int nr;
  // str
  const char *str;
};

struct WAVEHDR
{
  // chkRiff
  struct CHUNKHDR chkRiff;
  // fccWave
  unsigned int fccWave;
  // chkFmt
  struct CHUNKHDR chkFmt;
  // wFormatTag
  unsigned short int wFormatTag;
  // nChannels
  unsigned short int nChannels;
  // nSamplesPerSec
  unsigned int nSamplesPerSec;
  // nAvgBytesPerSec
  unsigned int nAvgBytesPerSec;
  // nBlockAlign
  unsigned short int nBlockAlign;
  // wBitsPerSample
  unsigned short int wBitsPerSample;
  // chkData
  struct CHUNKHDR chkData;
};

struct WEBCAM
{
  // lock
  union anonymous_8 lock;
  // wait
  union anonymous_7 wait;
  // filename
  char *filename;
  // buf
  struct ng_video_buf *buf;
};

struct _FSXCharInfo
{
  // left
  signed short int left;
  // right
  signed short int right;
  // width
  signed short int width;
  // ascent
  signed short int ascent;
  // descent
  signed short int descent;
};

struct _FSXFontInfoHeader
{
  // min_bounds
  struct _FSXCharInfo min_bounds;
  // max_bounds
  struct _FSXCharInfo max_bounds;
  // font_ascent
  signed short int font_ascent;
  // font_descent
  signed short int font_descent;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous_32 __saved_mask;
};

struct pdat
{
  // _pad_y
  signed short int _pad_y;
  // _pad_x
  signed short int _pad_x;
  // _pad_top
  signed short int _pad_top;
  // _pad_left
  signed short int _pad_left;
  // _pad_bottom
  signed short int _pad_bottom;
  // _pad_right
  signed short int _pad_right;
};

struct _win_st
{
  // _cury
  signed short int _cury;
  // _curx
  signed short int _curx;
  // _maxy
  signed short int _maxy;
  // _maxx
  signed short int _maxx;
  // _begy
  signed short int _begy;
  // _begx
  signed short int _begx;
  // _flags
  signed short int _flags;
  // _attrs
  unsigned long int _attrs;
  // _bkgd
  unsigned long int _bkgd;
  // _notimeout
  _Bool _notimeout;
  // _clear
  _Bool _clear;
  // _leaveok
  _Bool _leaveok;
  // _scroll
  _Bool _scroll;
  // _idlok
  _Bool _idlok;
  // _idcok
  _Bool _idcok;
  // _immed
  _Bool _immed;
  // _sync
  _Bool _sync;
  // _use_keypad
  _Bool _use_keypad;
  // _delay
  signed int _delay;
  // _line
  struct ldat *_line;
  // _regtop
  signed short int _regtop;
  // _regbottom
  signed short int _regbottom;
  // _parx
  signed int _parx;
  // _pary
  signed int _pary;
  // _parent
  struct _win_st *_parent;
  // _pad
  struct pdat _pad;
  // _yoffset
  signed short int _yoffset;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct event_entry
{
  // event
  char event[128l];
  // action
  char action[128l];
  // argbuf
  char argbuf[128l];
  // argc
  signed int argc;
  // argv
  char *argv[16l];
  // next
  struct event_entry *next;
};

struct fb_bitfield
{
  // offset
  unsigned int offset;
  // length
  unsigned int length;
  // msb_right
  unsigned int msb_right;
};

struct fb_cmap
{
  // start
  unsigned int start;
  // len
  unsigned int len;
  // red
  unsigned short int *red;
  // green
  unsigned short int *green;
  // blue
  unsigned short int *blue;
  // transp
  unsigned short int *transp;
};

struct fb_con2fbmap
{
  // console
  unsigned int console;
  // framebuffer
  unsigned int framebuffer;
};

struct fb_fix_screeninfo
{
  // id
  char id[16l];
  // smem_start
  unsigned long int smem_start;
  // smem_len
  unsigned int smem_len;
  // type
  unsigned int type;
  // type_aux
  unsigned int type_aux;
  // visual
  unsigned int visual;
  // xpanstep
  unsigned short int xpanstep;
  // ypanstep
  unsigned short int ypanstep;
  // ywrapstep
  unsigned short int ywrapstep;
  // line_length
  unsigned int line_length;
  // mmio_start
  unsigned long int mmio_start;
  // mmio_len
  unsigned int mmio_len;
  // accel
  unsigned int accel;
  // capabilities
  unsigned short int capabilities;
  // reserved
  unsigned short int reserved[2l];
};

struct fb_var_screeninfo
{
  // xres
  unsigned int xres;
  // yres
  unsigned int yres;
  // xres_virtual
  unsigned int xres_virtual;
  // yres_virtual
  unsigned int yres_virtual;
  // xoffset
  unsigned int xoffset;
  // yoffset
  unsigned int yoffset;
  // bits_per_pixel
  unsigned int bits_per_pixel;
  // grayscale
  unsigned int grayscale;
  // red
  struct fb_bitfield red;
  // green
  struct fb_bitfield green;
  // blue
  struct fb_bitfield blue;
  // transp
  struct fb_bitfield transp;
  // nonstd
  unsigned int nonstd;
  // activate
  unsigned int activate;
  // height
  unsigned int height;
  // width
  unsigned int width;
  // accel_flags
  unsigned int accel_flags;
  // pixclock
  unsigned int pixclock;
  // left_margin
  unsigned int left_margin;
  // right_margin
  unsigned int right_margin;
  // upper_margin
  unsigned int upper_margin;
  // lower_margin
  unsigned int lower_margin;
  // hsync_len
  unsigned int hsync_len;
  // vsync_len
  unsigned int vsync_len;
  // sync
  unsigned int sync;
  // vmode
  unsigned int vmode;
  // rotate
  unsigned int rotate;
  // colorspace
  unsigned int colorspace;
  // reserved
  unsigned int reserved[4l];
};

struct ng_video_fmt
{
  // fmtid
  unsigned int fmtid;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // bytesperline
  unsigned int bytesperline;
};

struct ng_audio_fmt
{
  // fmtid
  unsigned int fmtid;
  // rate
  unsigned int rate;
};

struct files_handle
{
  // file
  char file[4096l];
  // video
  struct ng_video_fmt video;
  // audio
  struct ng_audio_fmt audio;
  // wav_fd
  signed int wav_fd;
  // wav_header
  struct WAVEHDR wav_header;
  // wav_size
  signed int wav_size;
  // gotcha
  signed int gotcha;
};

struct fs_font
{
  // fontHeader
  struct _FSXFontInfoHeader fontHeader;
  // extents
  struct _FSXCharInfo *extents;
  // glyphs
  unsigned char *glyphs;
  // maxenc
  signed int maxenc;
  // width
  signed int width;
  // height
  signed int height;
  // eindex
  struct _FSXCharInfo **eindex;
  // gindex
  unsigned char **gindex;
};

struct in6_addr
{
  // __in6_u
  union anonymous_15 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct jpeg_common_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
};

struct jpeg_compress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // dest
  struct jpeg_destination_mgr *dest;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // input_components
  signed int input_components;
  // in_color_space
  enum anonymous in_color_space;
  // input_gamma
  double input_gamma;
  // data_precision
  signed int data_precision;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous jpeg_color_space;
  // comp_info
  struct anonymous_0 *comp_info;
  // quant_tbl_ptrs
  struct anonymous_1 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous_2 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous_2 *ac_huff_tbl_ptrs[4l];
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // num_scans
  signed int num_scans;
  // scan_info
  const struct anonymous_3 *scan_info;
  // raw_data_in
  signed int raw_data_in;
  // arith_code
  signed int arith_code;
  // optimize_coding
  signed int optimize_coding;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // smoothing_factor
  signed int smoothing_factor;
  // dct_method
  enum anonymous_4 dct_method;
  // restart_interval
  unsigned int restart_interval;
  // restart_in_rows
  signed int restart_in_rows;
  // write_JFIF_header
  signed int write_JFIF_header;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // write_Adobe_marker
  signed int write_Adobe_marker;
  // next_scanline
  unsigned int next_scanline;
  // progressive_mode
  signed int progressive_mode;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous_0 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // master
  struct jpeg_comp_master *master;
  // main
  struct jpeg_c_main_controller *main;
  // prep
  struct jpeg_c_prep_controller *prep;
  // coef
  struct jpeg_c_coef_controller *coef;
  // marker
  struct jpeg_marker_writer *marker;
  // cconvert
  struct jpeg_color_converter *cconvert;
  // downsample
  struct jpeg_downsampler *downsample;
  // fdct
  struct jpeg_forward_dct *fdct;
  // entropy
  struct jpeg_entropy_encoder *entropy;
  // script_space
  struct anonymous_3 *script_space;
  // script_space_size
  signed int script_space_size;
};

struct jpeg_destination_mgr
{
  // next_output_byte
  unsigned char *next_output_byte;
  // free_in_buffer
  unsigned long int free_in_buffer;
  // init_destination
  void (*init_destination)(struct jpeg_compress_struct *);
  // empty_output_buffer
  signed int (*empty_output_buffer)(struct jpeg_compress_struct *);
  // term_destination
  void (*term_destination)(struct jpeg_compress_struct *);
};

struct jpeg_error_mgr
{
  // error_exit
  void (*error_exit)(struct jpeg_common_struct *);
  // emit_message
  void (*emit_message)(struct jpeg_common_struct *, signed int);
  // output_message
  void (*output_message)(struct jpeg_common_struct *);
  // format_message
  void (*format_message)(struct jpeg_common_struct *, char *);
  // reset_error_mgr
  void (*reset_error_mgr)(struct jpeg_common_struct *);
  // msg_code
  signed int msg_code;
  // msg_parm
  union anonymous_5 msg_parm;
  // trace_level
  signed int trace_level;
  // num_warnings
  signed long int num_warnings;
  // jpeg_message_table
  const char * const *jpeg_message_table;
  // last_jpeg_message
  signed int last_jpeg_message;
  // addon_message_table
  const char * const *addon_message_table;
  // first_addon_message
  signed int first_addon_message;
  // last_addon_message
  signed int last_addon_message;
};

struct jpeg_memory_mgr
{
  // alloc_small
  void * (*alloc_small)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_large
  void * (*alloc_large)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_sarray
  unsigned char ** (*alloc_sarray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int);
  // alloc_barray
  signed short int (**(*alloc_barray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int))[64l];
  // request_virt_sarray
  struct jvirt_sarray_control * (*request_virt_sarray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // request_virt_barray
  struct jvirt_barray_control * (*request_virt_barray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // realize_virt_arrays
  void (*realize_virt_arrays)(struct jpeg_common_struct *);
  // access_virt_sarray
  unsigned char ** (*access_virt_sarray)(struct jpeg_common_struct *, struct jvirt_sarray_control *, unsigned int, unsigned int, signed int);
  // access_virt_barray
  signed short int (**(*access_virt_barray)(struct jpeg_common_struct *, struct jvirt_barray_control *, unsigned int, unsigned int, signed int))[64l];
  // free_pool
  void (*free_pool)(struct jpeg_common_struct *, signed int);
  // self_destruct
  void (*self_destruct)(struct jpeg_common_struct *);
  // max_memory_to_use
  signed long int max_memory_to_use;
  // max_alloc_chunk
  signed long int max_alloc_chunk;
};

struct jpeg_progress_mgr
{
  // progress_monitor
  void (*progress_monitor)(struct jpeg_common_struct *);
  // pass_counter
  signed long int pass_counter;
  // pass_limit
  signed long int pass_limit;
  // completed_passes
  signed int completed_passes;
  // total_passes
  signed int total_passes;
};

struct js_event
{
  // time
  unsigned int time;
  // value
  signed short int value;
  // type
  unsigned char type;
  // number
  unsigned char number;
};

struct lirc_code
{
  // remote
  char *remote;
  // button
  char *button;
  // next
  struct lirc_code *next;
};

struct lirc_config
{
  // current_mode
  char *current_mode;
  // next
  struct lirc_config_entry *next;
  // first
  struct lirc_config_entry *first;
  // sockfd
  signed int sockfd;
};

struct lirc_config_entry
{
  // prog
  char *prog;
  // code
  struct lirc_code *code;
  // rep_delay
  unsigned int rep_delay;
  // rep
  unsigned int rep;
  // config
  struct lirc_list *config;
  // change_mode
  char *change_mode;
  // flags
  unsigned int flags;
  // mode
  char *mode;
  // next_config
  struct lirc_list *next_config;
  // next_code
  struct lirc_code *next_code;
  // next
  struct lirc_config_entry *next;
};

struct lirc_list
{
  // string
  char *string;
  // next
  struct lirc_list *next;
};

struct list_head
{
  // next
  struct list_head *next;
  // prev
  struct list_head *prev;
};

struct media_device_entry
{
  // device
  char *device;
  // node
  char *node;
  // type
  enum device_type type;
  // bus
  enum bus_type bus;
  // major
  unsigned int major;
  // minor
  unsigned int minor;
};

struct media_devices
{
  // md_entry
  struct media_device_entry *md_entry;
  // md_size
  unsigned int md_size;
};

struct midi_handle
{
  // seq
  struct _snd_seq *seq;
  // fd
  signed int fd;
  // port
  signed int port;
  // ev
  struct snd_seq_event *ev;
};

struct ng_convthread_handle
{
  // c
  struct ng_convert_handle *c;
  // in
  struct FIFO *in;
  // out
  struct FIFO *out;
};

struct movie_handle
{
  // lock
  union anonymous_8 lock;
  // writer
  struct ng_writer *writer;
  // handle
  void *handle;
  // tflush
  unsigned long int tflush;
  // start
  unsigned long int start;
  // rts
  unsigned long int rts;
  // stopby
  unsigned long int stopby;
  // slots
  signed int slots;
  // vfmt
  struct ng_video_fmt vfmt;
  // fps
  signed int fps;
  // frames
  signed int frames;
  // seq
  signed int seq;
  // vfifo
  struct FIFO vfifo;
  // tvideo
  unsigned long int tvideo;
  // vts
  unsigned long int vts;
  // cfifo
  struct FIFO cfifo;
  // cthreads
  signed int cthreads;
  // hconv
  struct ng_convthread_handle *hconv[4l];
  // tconv
  unsigned long int tconv[4l];
  // dsp
  struct ng_dsp_driver *dsp;
  // hdsp
  void *hdsp;
  // afmt
  struct ng_audio_fmt afmt;
  // bytes_per_sec
  unsigned long int bytes_per_sec;
  // bytes
  unsigned long int bytes;
  // afifo
  struct FIFO afifo;
  // taudio
  unsigned long int taudio;
  // raudio
  unsigned long int raudio;
  // ats
  unsigned long int ats;
  // rdrift
  unsigned long int rdrift;
  // vdrift
  unsigned long int vdrift;
};

struct ng_attribute
{
  // id
  signed int id;
  // name
  const char *name;
  // type
  signed int type;
  // defval
  signed int defval;
  // choices
  struct STRTAB *choices;
  // min
  signed int min;
  // max
  signed int max;
  // points
  signed int points;
  // priv
  const void *priv;
  // handle
  void *handle;
  // read
  signed int (*read)(struct ng_attribute *);
  // write
  void (*write)(struct ng_attribute *, signed int);
};

struct ng_audio_buf
{
  // fmt
  struct ng_audio_fmt fmt;
  // size
  signed int size;
  // written
  signed int written;
  // data
  char *data;
  // info
  struct anonymous_6 info;
};

struct ng_audio_conv
{
  // fmtid_in
  unsigned int fmtid_in;
  // fmtid_out
  unsigned int fmtid_out;
  // init
  void * (*init)(void *);
  // frame
  struct ng_audio_buf * (*frame)(void *, struct ng_audio_buf *);
  // fini
  void (*fini)(void *);
  // priv
  void *priv;
  // list
  struct list_head list;
};

struct ng_convert_handle
{
  // ifmt
  struct ng_video_fmt ifmt;
  // ofmt
  struct ng_video_fmt ofmt;
  // isize
  signed int isize;
  // osize
  signed int osize;
  // conv
  struct ng_video_conv *conv;
  // chandle
  void *chandle;
};

struct ng_device_config
{
  // video
  char *video;
  // driver
  char *driver;
  // radio
  char *radio;
  // vbi
  char *vbi;
  // dsp
  char *dsp;
  // mixer
  char *mixer;
  // video_scan
  char *video_scan[32l];
  // mixer_scan
  char *mixer_scan[32l];
};

struct ng_devinfo
{
  // device
  char device[32l];
  // name
  char name[64l];
  // flags
  signed int flags;
};

struct ng_dsp_driver
{
  // name
  const char *name;
  // open
  void * (*open)(char *, struct ng_audio_fmt *, signed int);
  // close
  void (*close)(void *);
  // fd
  signed int (*fd)(void *);
  // startrec
  signed int (*startrec)(void *);
  // read
  struct ng_audio_buf * (*read)(void *, signed long int);
  // write
  struct ng_audio_buf * (*write)(void *, struct ng_audio_buf *);
  // latency
  signed long int (*latency)(void *);
  // list
  struct list_head list;
};

struct ng_filter
{
  // name
  char *name;
  // fmts
  signed int fmts;
  // attrs
  struct ng_attribute *attrs;
  // init
  void * (*init)(struct ng_video_fmt *);
  // frame
  struct ng_video_buf * (*frame)(void *, struct ng_video_buf *);
  // fini
  void (*fini)(void *);
  // list
  struct list_head list;
};

struct ng_format_list
{
  // name
  char *name;
  // desc
  char *desc;
  // ext
  char *ext;
  // fmtid
  unsigned int fmtid;
  // priv
  void *priv;
};

struct ng_mix_driver
{
  // name
  const char *name;
  // probe
  struct ng_devinfo * (*probe)(void);
  // channels
  struct ng_devinfo * (*channels)(char *);
  // open
  void * (*open)(char *);
  // volctl
  struct ng_attribute * (*volctl)(void *, char *);
  // close
  void (*close)(void *);
  // list
  struct list_head list;
};

struct ng_reader
{
  // name
  const char *name;
  // desc
  const char *desc;
  // magic
  char *magic[4l];
  // moff
  signed int moff[4l];
  // mlen
  signed int mlen[4l];
  // rd_open
  void * (*rd_open)(char *);
  // rd_vfmt
  struct ng_video_fmt * (*rd_vfmt)(void *, signed int *, signed int);
  // rd_afmt
  struct ng_audio_fmt * (*rd_afmt)(void *);
  // rd_vdata
  struct ng_video_buf * (*rd_vdata)(void *, unsigned int);
  // rd_adata
  struct ng_audio_buf * (*rd_adata)(void *);
  // frame_time
  signed long int (*frame_time)(void *);
  // rd_close
  signed int (*rd_close)(void *);
  // list
  struct list_head list;
};

struct ng_vid_driver
{
  // name
  const char *name;
  // open
  void * (*open)(char *, signed int);
  // close
  signed int (*close)(void *);
  // get_devname
  char * (*get_devname)(void *);
  // capabilities
  signed int (*capabilities)(void *);
  // list_attrs
  struct ng_attribute * (*list_attrs)(void *);
  // get_min_size
  void (*get_min_size)(void *, signed int *, signed int *);
  // setupfb
  signed int (*setupfb)(void *, struct ng_video_fmt *, void *);
  // overlay
  signed int (*overlay)(void *, struct ng_video_fmt *, signed int, signed int, struct OVERLAY_CLIP *, signed int, signed int);
  // setformat
  signed int (*setformat)(void *, struct ng_video_fmt *);
  // startvideo
  signed int (*startvideo)(void *, signed int, unsigned int);
  // stopvideo
  void (*stopvideo)(void *);
  // nextframe
  struct ng_video_buf * (*nextframe)(void *);
  // getimage
  struct ng_video_buf * (*getimage)(void *);
  // getfreq
  unsigned long int (*getfreq)(void *);
  // setfreq
  void (*setfreq)(void *, unsigned long int);
  // is_tuned
  signed int (*is_tuned)(void *);
  // list
  struct list_head list;
};

struct ng_video_buf
{
  // fmt
  struct ng_video_fmt fmt;
  // size
  unsigned long int size;
  // data
  unsigned char *data;
  // info
  struct anonymous_27 info;
  // lock
  union anonymous_8 lock;
  // cond
  union anonymous_7 cond;
  // refcount
  signed int refcount;
  // release
  void (*release)(struct ng_video_buf *);
  // priv
  void *priv;
};

struct ng_video_conv
{
  // fmtid_in
  unsigned int fmtid_in;
  // fmtid_out
  unsigned int fmtid_out;
  // init
  void * (*init)(struct ng_video_fmt *, void *);
  // frame
  void (*frame)(void *, struct ng_video_buf *, struct ng_video_buf *);
  // fini
  void (*fini)(void *);
  // priv
  void *priv;
  // list
  struct list_head list;
};

struct ng_writer
{
  // name
  const char *name;
  // desc
  const char *desc;
  // video
  struct ng_format_list *video;
  // audio
  struct ng_format_list *audio;
  // combined
  const signed int combined;
  // wr_open
  void * (*wr_open)(char *, char *, struct ng_video_fmt *, const void *, signed int, struct ng_audio_fmt *, const void *);
  // wr_video
  signed int (*wr_video)(void *, struct ng_video_buf *);
  // wr_audio
  signed int (*wr_audio)(void *, struct ng_audio_buf *);
  // wr_close
  signed int (*wr_close)(void *);
  // list
  struct list_head list;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct raw_handle
{
  // video
  struct ng_video_fmt video;
  // audio
  struct ng_audio_fmt audio;
  // vpriv
  struct raw_priv *vpriv;
  // fd
  signed int fd;
  // wav_fd
  signed int wav_fd;
  // wav_header
  struct WAVEHDR wav_header;
  // wav_size
  signed int wav_size;
};

struct raw_priv
{
  // yuv4mpeg
  signed int yuv4mpeg;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_31 __sigaction_handler;
  // sa_mask
  struct anonymous_32 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct snd_seq_event
{
  // type
  unsigned char type;
  // flags
  unsigned char flags;
  // tag
  unsigned char tag;
  // queue
  unsigned char queue;
  // time
  union snd_seq_timestamp time;
  // source
  struct snd_seq_addr source;
  // dest
  struct snd_seq_addr dest;
  // data
  union anonymous_29 data;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct vbi_char
{
  // underline
  unsigned int underline : 1;
  // bold
  unsigned int bold : 1;
  // italic
  unsigned int italic : 1;
  // flash
  unsigned int flash : 1;
  // conceal
  unsigned int conceal : 1;
  // proportional
  unsigned int proportional : 1;
  // link
  unsigned int link : 1;
  // reserved
  unsigned int reserved : 1;
  // size
  unsigned int size : 8;
  // opacity
  unsigned int opacity : 8;
  // foreground
  unsigned int foreground : 8;
  // background
  unsigned int background : 8;
  // drcs_clut_offs
  unsigned int drcs_clut_offs : 8;
  // unicode
  unsigned int unicode : 16;
};

struct vbi_page
{
  // vbi
  struct vbi_decoder *vbi;
  // nuid
  unsigned int nuid;
  // pgno
  signed int pgno;
  // subno
  signed int subno;
  // rows
  signed int rows;
  // columns
  signed int columns;
  // text
  struct vbi_char text[1056l];
  // dirty
  struct anonymous_13 dirty;
  // screen_color
  enum anonymous_11 screen_color;
  // screen_opacity
  enum anonymous_12 screen_opacity;
  // color_map
  unsigned int color_map[40l];
  // drcs_clut
  unsigned char *drcs_clut;
  // drcs
  unsigned char *drcs[32l];
  // nav_link
  struct anonymous_14 nav_link[6l];
  // nav_index
  char nav_index[64l];
  // font
  struct vbi_font_descr *font[2l];
  // double_height_lower
  unsigned int double_height_lower;
  // page_opacity
  enum anonymous_12 page_opacity[2l];
  // boxed_opacity
  enum anonymous_12 boxed_opacity[2l];
};

struct vbi_rect
{
  // x1
  signed int x1;
  // x2
  signed int x2;
  // y1
  signed int y1;
  // y2
  signed int y2;
};

struct vt_mode
{
  // mode
  char mode;
  // waitv
  char waitv;
  // relsig
  signed short int relsig;
  // acqsig
  signed short int acqsig;
  // frsig
  signed short int frsig;
};

struct vt_stat
{
  // v_active
  unsigned short int v_active;
  // v_signal
  unsigned short int v_signal;
  // v_state
  unsigned short int v_state;
};


// alloc_count
// file common/channel.c line 66
signed int alloc_count = 0;
// attr_notify
// file common/commands.c line 46
void (*attr_notify)(struct ng_attribute *, signed int);
// attrs
// file common/commands.c line 79
struct ng_attribute *attrs = (struct ng_attribute *)(void *)0;
// black
// file console/fs.c line 45
static unsigned int black;
// blue
// file console/fbtv.c line 59
static unsigned short int blue[256l];
// bmmio
// file console/matrox.c line 26
static unsigned char *bmmio;
// booltab
// file common/channel.c line 728
struct STRTAB booltab[7l] = { { .nr=(signed long int)0, .str="no" }, { .nr=(signed long int)0, .str="false" },
    { .nr=(signed long int)0, .str="off" }, { .nr=(signed long int)1, .str="yes" }, { .nr=(signed long int)1, .str="true" },
    { .nr=(signed long int)1, .str="on" }, { .nr=(signed long int)-1, .str=(const char *)(void *)0 } };
// bpp
// file console/fs.c line 45
static unsigned int bpp;
// buf
// file console/fbtv.c line 69
static struct ng_video_buf *buf;
// c
// file common/parseconfig.c line 26
static struct CFG_SECTIONS *c;
// captab
// file common/channel.c line 170
struct STRTAB captab[11l] = { { .nr=(signed long int)9, .str="on" }, { .nr=(signed long int)9, .str="yes" }, { .nr=(signed long int)9, .str="true" },
    { .nr=(signed long int)0, .str="off" }, { .nr=(signed long int)0, .str="no" }, { .nr=(signed long int)0, .str="false" },
    { .nr=(signed long int)1, .str="over" },
    { .nr=(signed long int)1, .str="overlay" },
    { .nr=(signed long int)2, .str="grab" },
    { .nr=(signed long int)2, .str="grabdisplay" },
    { .nr=(signed long int)-1, .str=(const char *)(void *)0 } };
// capture_get_hook
// file common/commands.c line 62
void (*capture_get_hook)(void);
// capture_rel_hook
// file common/commands.c line 63
void (*capture_rel_hook)(void);
// ch
// file console/fbtv.c line 72
static struct ng_convert_handle *ch;
// chanlist_names
// file common/frequencies.c line 17
struct STRTAB *chanlist_names;
// chanlists
// file common/frequencies.c line 16
struct CHANLISTS *chanlists;
// channel_switch_hook
// file common/commands.c line 54
void (*channel_switch_hook)(void);
// channels
// file common/channel.c line 64
struct CHANNEL **channels = (struct CHANNEL **)(void *)0;
// chantab
// file common/frequencies.c line 15
signed int chantab = -1;
// cmap
// file console/fbtv.c line 60
static struct fb_cmap cmap;
// green
// file console/fbtv.c line 59
static unsigned short int green[256l];
// red
// file console/fbtv.c line 59
static unsigned short int red[256l];
// cmap
// file console/fbtv.c line 60
static struct fb_cmap cmap = { .start=(unsigned int)0, .len=(unsigned int)256, .red=red,
    .green=green, .blue=blue, .transp=((unsigned short int *)NULL) };
// commands
// file common/commands.c line 113
static struct COMMANDS commands[29l];
// commands
// file common/commands.c line 113
static struct COMMANDS commands[29l] = { { .name="setstation", .min_args=0, .handler=setstation_handler },
    { .name="setchannel", .min_args=0, .handler=setchannel_handler },
    { .name="setfreq", .min_args=1, .handler=setchannel_handler },
    { .name="setfreqtab", .min_args=1, .handler=setfreqtab_handler },
    { .name="capture", .min_args=1, .handler=capture_handler },
    { .name="setnorm", .min_args=1, .handler=attr_handler },
    { .name="setinput", .min_args=1, .handler=attr_handler },
    { .name="setattr", .min_args=1, .handler=attr_handler },
    { .name="color", .min_args=0, .handler=attr_handler },
    { .name="hue", .min_args=0, .handler=attr_handler },
    { .name="bright", .min_args=0, .handler=attr_handler },
    { .name="contrast", .min_args=0, .handler=attr_handler },
    { .name="show", .min_args=0, .handler=show_handler },
    { .name="list", .min_args=0, .handler=list_handler },
    { .name="volume", .min_args=0, .handler=volume_handler },
    { .name="attr", .min_args=0, .handler=dattr_handler },
    { .name="snap", .min_args=0, .handler=snap_handler },
    { .name="webcam", .min_args=1, .handler=webcam_handler },
    { .name="movie", .min_args=1, .handler=movie_handler },
    { .name="fullscreen", .min_args=0, .handler=fullscreen_handler },
    { .name="msg", .min_args=1, .handler=msg_handler },
    { .name="message", .min_args=0, .handler=msg_handler },
    { .name="exit", .min_args=0, .handler=exit_handler },
    { .name="quit", .min_args=0, .handler=exit_handler },
    { .name="bye", .min_args=0, .handler=exit_handler },
    { .name="keypad", .min_args=1, .handler=keypad_handler },
    { .name="showtime", .min_args=0, .handler=showtime_handler },
    { .name="vdr", .min_args=1, .handler=vdr_handler },
    { .name=(char *)(void *)0, .min_args=0, .handler=(signed int (*)(char *, signed int, char **))(void *)0 } };
// config
// file common/lirc.c line 24
static struct lirc_config *config = (struct lirc_config *)(void *)0;
// conv
// file console/fbtv.c line 71
static struct ng_video_conv *conv;
// conv_list
// file libng/color_packed.c line 174
static struct ng_video_conv conv_list[12l];
// conv_list
// file libng/color_packed.c line 174
static struct ng_video_conv conv_list[12l] = { { .fmtid_in=(unsigned int)5, .fmtid_out=(unsigned int)2, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb15_be_gray, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)3, .fmtid_out=(unsigned int)2, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb15_native_gray, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)3, .fmtid_out=(unsigned int)5, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)5, .fmtid_out=(unsigned int)3, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)4, .fmtid_out=(unsigned int)6, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)6, .fmtid_out=(unsigned int)4, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=(unsigned int)9, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)redblue_swap, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)9, .fmtid_out=(unsigned int)7, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)redblue_swap, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=(unsigned int)9, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_rgb24, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=(unsigned int)7, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_bgr24, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=(unsigned int)8, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_bgr32, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=(unsigned int)10, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_rgb32, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// conv_list_link1
// file libng/color_yuv2rgb.c line 384
static struct ng_video_conv conv_list_link1[6l];
// conv_list_link1
// file libng/color_yuv2rgb.c line 384
static struct ng_video_conv conv_list_link1[6l] = { { .fmtid_in=(unsigned int)13, .fmtid_out=(unsigned int)9, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)yuv422_to_rgb24, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)13, .fmtid_out=(unsigned int)2, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)yuv422_to_gray, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=(unsigned int)9, .init=ng_conv_nop_init,
    .frame=yuv422p_to_rgb24, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=(unsigned int)9, .init=ng_conv_nop_init,
    .frame=yuv420p_to_rgb24, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=(unsigned int)2, .init=ng_conv_nop_init,
    .frame=yuv42xp_to_gray, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=(unsigned int)2, .init=ng_conv_nop_init,
    .frame=yuv42xp_to_gray, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// count
// file common/channel.c line 65
signed int count = 0;
// cur_attrs
// file common/commands.c line 72
signed int cur_attrs[256l];
// cur_capture
// file common/channel.c line 72
signed int cur_capture = 0;
// cur_channel
// file common/channel.c line 68
signed int cur_channel = -1;
// cur_dattr
// file common/commands.c line 154
static signed int cur_dattr = 0;
// cur_filter
// file common/channel.c line 70
struct ng_filter *cur_filter;
// cur_fine
// file common/channel.c line 68
signed int cur_fine = 0;
// cur_freq
// file common/channel.c line 69
signed int cur_freq;
// cur_movie
// file common/commands.c line 72
signed int cur_movie;
// cur_sender
// file common/channel.c line 68
signed int cur_sender = -1;
// cur_tv_height
// file common/commands.c line 71
unsigned int cur_tv_height;
// cur_tv_width
// file common/commands.c line 71
unsigned int cur_tv_width;
// dattr
// file common/commands.c line 155
static signed int dattr[5l] = { 3, 7, 9, 6, 8 };
// debug
// file console/fbtv.c line 76
signed int debug;
// default_font
// file console/fs.c line 200
static char *default_font[13l] = { "/usr/share/consolefonts/lat1-16.psf", "/usr/share/consolefonts/lat1-16.psf.gz",
    "/usr/share/consolefonts/lat1-16.psfu.gz",
    "/usr/share/kbd/consolefonts/lat1-16.psf",
    "/usr/share/kbd/consolefonts/lat1-16.psf.gz",
    "/usr/share/kbd/consolefonts/lat1-16.psfu.gz",
    "/usr/lib/kbd/consolefonts/lat1-16.psf",
    "/usr/lib/kbd/consolefonts/lat1-16.psf.gz",
    "/usr/lib/kbd/consolefonts/lat1-16.psfu.gz",
    "/lib/kbd/consolefonts/lat1-16.psf", "/lib/kbd/consolefonts/lat1-16.psf.gz", "/lib/kbd/consolefonts/lat1-16.psfu.gz",
    (char *)(void *)0 };
// default_title
// file console/fbtv.c line 187
static char default_title[128l] = { '?', '?', '?', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// defaults
// file common/channel.c line 52
struct CHANNEL defaults = { .name="defaults", .key=((char *)NULL), .group="main",
    .midi=0, .cname=((char *)NULL), .channel=-1,
    .fine=0, .freq=0, .audio=-1, .capture=9,
    .input=0, .norm=0, .color=-1, .bright=-1,
    .hue=-1, .contrast=-1, .pixmap=0ul, .button=((struct _WidgetRec *)NULL) };
// devices
// file console/fbtools.c line 72
struct DEVS *devices;
// devs_default
// file console/fbtools.c line 62
struct DEVS devs_default = { .fb0="/dev/fb0", .fbnr="/dev/fb%d", .ttynr="/dev/tty%d" };
// devs_devfs
// file console/fbtools.c line 67
struct DEVS devs_devfs = { .fb0="/dev/fb/0", .fbnr="/dev/fb/%d", .ttynr="/dev/vc/%d" };
// display_message
// file common/commands.c line 36
void (*display_message)(char *);
// do_overlay
// file common/commands.c line 67
signed int do_overlay;
// drv
// file common/commands.c line 75
struct ng_vid_driver *drv;
// dx
// file console/fbtv.c line 73
static signed int dx;
// dy
// file console/fbtv.c line 73
static signed int dy;
// event_builtin_list
// file common/event.c line 17
static struct event_entry *event_builtin_list;
// event_conf_list
// file common/event.c line 16
static struct event_entry *event_conf_list;
// exit_hook
// file common/commands.c line 61
void (*exit_hook)(void);
// f
// file console/fbtv.c line 57
static struct fs_font *f;
// f_drv
// file common/commands.c line 77
signed int f_drv;
// fb
// file console/fbtv.c line 62
static signed int fb;
// fb_link1
// file console/fbtools.c line 38
static signed int fb_link1;
// fb_fatal_cleanup
// file console/fbtools.c line 490
static struct __jmp_buf_tag fb_fatal_cleanup[1l];
// fb_fix
// file console/fbtools.c line 29
struct fb_fix_screeninfo fb_fix;
// fb_mem
// file console/fbtools.c line 31
unsigned char *fb_mem;
// fb_mem_offset
// file console/fbtools.c line 32
signed int fb_mem_offset = 0;
// fb_midi
// file console/fbtv.c line 346
static struct midi_handle fb_midi;
// fb_ovar
// file console/fbtools.c line 49
static struct fb_var_screeninfo fb_ovar;
// fb_switch_state
// file console/fbtools.c line 33
signed int fb_switch_state = 0;
// fb_var
// file console/fbtools.c line 30
struct fb_var_screeninfo fb_var;
// fbdev
// file console/fbtv.c line 53
static char *fbdev = (char *)(void *)0;
// fbgamma
// file console/fbtv.c line 67
static float fbgamma = (float)1.0;
// files_vformats
// file libng/writefile.c line 546
static struct ng_format_list files_vformats[4l] = { { .name="ppm", .desc=((char *)NULL), .ext="ppm", .fmtid=(unsigned int)9,
    .priv=NULL },
    { .name="pgm", .desc=((char *)NULL), .ext="pgm", .fmtid=(unsigned int)2,
    .priv=NULL },
    { .name="jpeg", .desc=((char *)NULL), .ext="jpeg", .fmtid=(unsigned int)17,
    .priv=NULL },
    { .name=((char *)NULL), .desc=((char *)NULL), .ext=((char *)NULL),
    .fmtid=0u, .priv=NULL } };
// files_writer
// file libng/writefile.c line 624
struct ng_writer files_writer;
// wav_aformats
// file libng/writefile.c line 606
static struct ng_format_list wav_aformats[4l] = { { .name="mono8", .desc=((char *)NULL), .ext="wav", .fmtid=(unsigned int)1,
    .priv=NULL },
    { .name="mono16", .desc=((char *)NULL), .ext="wav", .fmtid=(unsigned int)3,
    .priv=NULL },
    { .name="stereo", .desc=((char *)NULL), .ext="wav", .fmtid=(unsigned int)4,
    .priv=NULL },
    { .name=((char *)NULL), .desc=((char *)NULL), .ext=((char *)NULL),
    .fmtid=0u, .priv=NULL } };
// files_writer
// file libng/writefile.c line 624
struct ng_writer files_writer = { .name="files", .desc="multiple image files", .video=files_vformats,
    .audio=wav_aformats, .combined=0,
    .wr_open=files_open, .wr_video=files_video, .wr_audio=files_audio,
    .wr_close=files_close, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } };
// fmt
// file console/fbtv.c line 70
static struct ng_video_fmt fmt;
// fontfile
// file console/fbtv.c line 54
static char *fontfile = (char *)(void *)0;
// freqtab_notify
// file common/commands.c line 49
void (*freqtab_notify)(void);
// fs_height
// file common/channel.c line 80
signed int fs_height;
// fs_masktab
// file console/fs.c line 38
static const unsigned int fs_masktab[8l] = { (const unsigned int)(1 << 7), (const unsigned int)(1 << 6), (const unsigned int)(1 << 5), (const unsigned int)(1 << 4), (const unsigned int)(1 << 3), (const unsigned int)(1 << 2), (const unsigned int)(1 << 1), (const unsigned int)(1 << 0) };
// fs_width
// file common/channel.c line 80
signed int fs_width;
// fs_xoff
// file common/channel.c line 80
signed int fs_xoff;
// fs_yoff
// file common/channel.c line 80
signed int fs_yoff;
// fullscreen_hook
// file common/commands.c line 60
void (*fullscreen_hook)(void);
// gfmt
// file console/fbtv.c line 70
static struct ng_video_fmt gfmt;
// gfx_scaler_off
// file console/matrox.c line 24
void (*gfx_scaler_off)(void);
// gfx_scaler_on
// file console/matrox.c line 22
void (*gfx_scaler_on)(signed int, signed int, signed int, signed int, signed int, signed int, signed int, signed int);
// h_drv
// file common/commands.c line 76
void *h_drv;
// have_config
// file console/fbtv.c line 75
signed int have_config;
// have_dga
// file console/fbtv.c line 76
signed int have_dga = 1;
// have_shmem
// file common/commands.c line 69
signed int have_shmem;
// hh
// file console/fbtv.c line 66
static signed int hh;
// joy_events
// file common/joystick.c line 43
static struct event_entry joy_events[7l] = { { .event={ 'j', 'o', 'y', '-', 'b', 'u', 't', 't', 'o', 'n', '-', '0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'q', 'u', 'i', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'j', 'o', 'y', '-', 'b', 'u', 't', 't', 'o', 'n', '-', '1', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'f', 'u', 'l', 'l', 's', 'c', 'r', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'j', 'o', 'y', '-', 'a', 'x', 'i', 's', '-', 'u', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'i', 'n', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'j', 'o', 'y', '-', 'a', 'x', 'i', 's', '-', 'd', 'o', 'w', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'd', 'e', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'j', 'o', 'y', '-', 'a', 'x', 'i', 's', '-', 'l', 'e', 'f', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 'c', 'h', 'a', 'n', 'n', 'e', 'l', ' ', 'p', 'r', 'e', 'v', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'j', 'o', 'y', '-', 'a', 'x', 'i', 's', '-', 'r', 'i', 'g', 'h', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 'c', 'h', 'a', 'n', 'n', 'e', 'l', ' ', 'n', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) } };
// joydev
// file console/fbtv.c line 56
static char *joydev = (char *)(void *)0;
// joytab
// file common/joystick.c line 33
static struct JOYTAB joytab[6l] = { { .class=0x01, .number=0, .value=1, .event="joy-button-0" },
    { .class=0x01, .number=1, .value=1, .event="joy-button-1" },
    { .class=0x02, .number=1, .value=-32767, .event="joy-axis-up" },
    { .class=0x02, .number=1, .value=32767, .event="joy-axis-down" },
    { .class=0x02, .number=0, .value=32767, .event="joy-axis-left" },
    { .class=0x02, .number=0, .value=-32767, .event="joy-axis-right" } };
// kbd_events
// file console/fbtv.c line 80
struct event_entry kbd_events[26l] = { { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', '+', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'i', 'n', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', '-', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'd', 'e', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 'e', 'n', 't', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'm', 'u', 't', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 's', 'p', 'a', 'c', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 's', 't', 'a', 't', 'i', 'o', 'n', ' ', 'n', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 'b', 'a', 'c', 'k', 's', 'p', 'a', 'c', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 's', 't', 'a', 't', 'i', 'o', 'n', ' ', 'b', 'a', 'c', 'k', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 'p', 'g', 'u', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 's', 't', 'a', 't', 'i', 'o', 'n', ' ', 'n', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 'p', 'g', 'd', 'o', 'w', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 's', 't', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'e', 'v', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 'r', 'i', 'g', 'h', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 'c', 'h', 'a', 'n', 'n', 'e', 'l', ' ', 'f', 'i', 'n', 'e', '_', 'u', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 'l', 'e', 'f', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 'c', 'h', 'a', 'n', 'n', 'e', 'l', ' ', 'f', 'i', 'n', 'e', '_', 'd', 'o', 'w', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 'u', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 'c', 'h', 'a', 'n', 'n', 'e', 'l', ' ', 'n', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 'd', 'o', 'w', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 'c', 'h', 'a', 'n', 'n', 'e', 'l', ' ', 'p', 'r', 'e', 'v', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 'g', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'n', 'a', 'p', ' ', 'p', 'p', 'm', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 'j', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'n', 'a', 'p', ' ', 'j', 'p', 'e', 'g', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 'v', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'c', 'a', 'p', 't', 'u', 'r', 'e', ' ', 't', 'o', 'g', 'g', 'l', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', 'f', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'f', 'u', 'l', 'l', 's', 'c', 'r', 'e', 'e', 'n', ' ', 't', 'o', 'g', 'g', 'l', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', '0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', '1', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '1', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', '2', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '2', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', '3', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '3', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', '4', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '4', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', '5', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '5', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', '6', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '6', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', '7', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '7', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', '8', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '8', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'k', 'b', 'd', '-', 'k', 'e', 'y', '-', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) } };
// kd_mode
// file console/fbtools.c line 46
static signed int kd_mode;
// keep_dma_on
// file console/fbtv.c line 63
static signed int keep_dma_on = 0;
// keypad_ntsc
// file common/channel.c line 74
signed int keypad_ntsc = 0;
// keypad_partial
// file common/channel.c line 75
signed int keypad_partial = 1;
// keypad_state
// file common/commands.c line 164
static signed int keypad_state = -1;
// keytab
// file console/fbtv.c line 166
static struct KEYTAB keytab[14l] = { { .key=9, .name="tab" }, { .key=10, .name="enter" }, { .key=13, .name="enter" }, { .key=0527, .name="enter" }, { .key=32, .name="space" }, { .key=0407, .name="backspace" }, { .key=0405, .name="right" }, { .key=0404, .name="left" }, { .key=0403, .name="up" }, { .key=0402, .name="down" }, { .key=0523, .name="pgup" }, { .key=0522, .name="pgdown" }, { .key=0406, .name="home" }, { .key=0550, .name="end" } };
// last_sender
// file common/channel.c line 68
signed int last_sender = -1;
// launch
// file common/channel.c line 97
struct LAUNCH *launch = (struct LAUNCH *)(void *)0;
// lirc_events
// file common/lirc.c line 26
static struct event_entry lirc_events[19l] = { { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'c', 'h', '+', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 's', 't', 'a', 't', 'i', 'o', 'n', ' ', 'n', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'c', 'h', '-', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 's', 't', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'e', 'v', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'v', 'o', 'l', '+', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'i', 'n', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'v', 'o', 'l', '-', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'd', 'e', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'm', 'u', 't', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'm', 'u', 't', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'f', 'u', 'l', 'l', '_', 's', 'c', 'r', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'f', 'u', 'l', 'l', 's', 'c', 'r', 'e', 'e', 'n', ' ', 't', 'o', 'g', 'g', 'l', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 's', 'o', 'u', 'r', 'c', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 'i', 'n', 'p', 'u', 't', ' ', 'n', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'r', 'e', 's', 'e', 'r', 'v', 'e', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'q', 'u', 'i', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '1', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '1', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '2', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '2', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '3', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '3', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '4', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '4', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '5', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '5', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '6', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '6', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '7', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '7', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '8', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '8', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) } };
// lut2_list
// file libng/color_lut.c line 161
static struct ng_video_conv lut2_list[8l];
// lut2_list
// file libng/color_lut.c line 161
static struct ng_video_conv lut2_list[8l] = { { .fmtid_in=(unsigned int)9, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_rgb24_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)8, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr32_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)2, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)gray_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)13, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_yuv422_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv422p_to_lut2, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv420p_to_lut2, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// lut4_list
// file libng/color_lut.c line 199
static struct ng_video_conv lut4_list[8l];
// lut4_list
// file libng/color_lut.c line 199
static struct ng_video_conv lut4_list[8l] = { { .fmtid_in=(unsigned int)9, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_rgb24_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)8, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr32_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)2, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)gray_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)13, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_yuv422_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv422p_to_lut4, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv420p_to_lut4, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// matrox
// file console/fbtv.c line 65
static signed int matrox;
// message
// file console/fbtv.c line 188
static char message[128l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// midi
// file common/channel.c line 95
char *midi = (char *)(void *)0;
// midi_events
// file common/midictrl.c line 21
static char *midi_events[152l] = { "system", "result", "r2", "r3", "r4", "note", "noteon", "noteoff", "keypress", "r9", "controller", "pgmchange", "chanpress", "pitchbend", "control14", "nonregparam", "regparam", "r17", "r18", "r19", "songpos", "songsel", "qframe", "timesign", "keysign", "r25", "r26", "r27", "r28", "r29", "start", "continue", "stop", "setpos_tick", "setpos_time", "tempo", "clock", "tick", "r38", "r39", "tune_request", "reset", "sensing", "r43", "r44", "r45", "r46", "r47", "r48", "r49", "echo", "oss", "r52", "r53", "r54", "r55", "r56", "r57", "r58", "r59", "client_start", "client_exit", "client_change", "port_start", "port_exit", "port_change", "subscribed", "used", "unsubscribed", "unused", "sample", "sample_cluster", "sample_start", "sample_stop", "sample_freq", "sample_volume", "sample_loop", "sample_position", "sample_private1", "r79", "r80", "r81", "r82", "r83", "r84", "r85", "r86", "r87", "r88", "r89", "usr0", "usr1", "usr2", "usr3", "usr4", "usr5", "usr6", "usr7", "usr8", "usr9", "instr_begin", "instr_end", "instr_info", "instr_info_result", "instr_finfo", "instr_finfo_result", "instr_reset", "instr_status", "instr_status_result", "instr_put", "instr_get", "instr_get_result", "instr_free", "instr_list", "instr_list_result", "instr_cluster", "instr_cluster_get", "instr_cluster_result", "instr_change", "r119", "r120", "r121", "r122", "r123", "r124", "r125", "r126", "r127", "r128", "r129", "sysext", "bounce", "r132", "r133", "r134", "usr_var0", "usr_var1", "usr_var2", "usr_var3", "usr_var4", "ipcshm", "r141", "r142", "r143", "r144", "usr_varipc0", "usr_varipc1", "usr_varipc2", "usr_varipc3", "usr_varipc4", "kernel_error", "kernel_quote" };
// mixer
// file common/channel.c line 93
static char *mixer = (char *)(void *)0;
// mixerctl
// file common/channel.c line 94
char mixerctl[16l];
// mixerdev
// file common/channel.c line 94
char mixerdev[32l];
// mmio
// file console/matrox.c line 27
static unsigned int *mmio;
// mode
// file console/fbtv.c line 55
static char *mode = (char *)(void *)0;
// mov_audio
// file common/channel.c line 86
char *mov_audio = (char *)(void *)0;
// mov_driver
// file common/channel.c line 83
char *mov_driver = (char *)(void *)0;
// mov_fps
// file common/channel.c line 85
char *mov_fps = (char *)(void *)0;
// mov_rate
// file common/channel.c line 87
char *mov_rate = (char *)(void *)0;
// mov_video
// file common/channel.c line 84
char *mov_video = (char *)(void *)0;
// movie_hook
// file common/commands.c line 64
void (*movie_hook)(signed int, char **);
// mute_notify
// file common/commands.c line 47
void (*mute_notify)(signed int);
// nconv
// file libng/color_packed.c line 255
static const signed int nconv = (const signed int)(sizeof(struct ng_video_conv [12l]) /*672ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nconv_link1
// file libng/color_yuv2rgb.c line 421
static const signed int nconv_link1 = (const signed int)(sizeof(struct ng_video_conv [6l]) /*336ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nconv2
// file libng/color_lut.c line 237
static const unsigned int nconv2 = (const unsigned int)(sizeof(struct ng_video_conv [8l]) /*448ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nconv4
// file libng/color_lut.c line 238
static const unsigned int nconv4 = (const unsigned int)(sizeof(struct ng_video_conv [8l]) /*448ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// ng_aconv
// file libng/grab-ng.c line 373
struct list_head ng_aconv;
// ng_aconv
// file libng/grab-ng.c line 373
struct list_head ng_aconv = { .next=&ng_aconv, .prev=&ng_aconv };
// ng_afmt_to_bits
// file libng/grab-ng.c line 91
const unsigned int ng_afmt_to_bits[8l] = { (const unsigned int)0, (const unsigned int)8, (const unsigned int)8, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)0 };
// ng_afmt_to_channels
// file libng/grab-ng.c line 88
const unsigned int ng_afmt_to_channels[8l] = { (const unsigned int)0, (const unsigned int)1, (const unsigned int)2, (const unsigned int)1, (const unsigned int)2, (const unsigned int)1, (const unsigned int)2, (const unsigned int)0 };
// ng_afmt_to_desc
// file libng/grab-ng.c line 94
const char *ng_afmt_to_desc[8l] = { "none", "8bit mono", "8bit stereo", "16bit mono (LE)", "16bit stereo (LE)", "16bit mono (BE)", "16bit stereo (BE)", "mp3 compressed audio" };
// ng_attr_to_desc
// file libng/grab-ng.c line 107
const char *ng_attr_to_desc[10l] = { "none", "norm", "input", "volume", "mute", "audio mode", "color", "bright", "hue", "contrast" };
// ng_chromakey
// file libng/grab-ng.c line 33
signed int ng_chromakey = 0x00ff00ff;
// ng_clip
// file libng/color_yuv2rgb.c line 52
static unsigned int ng_clip[896l];
// ng_conv
// file libng/grab-ng.c line 372
struct list_head ng_conv;
// ng_conv
// file libng/grab-ng.c line 372
struct list_head ng_conv = { .next=&ng_conv, .prev=&ng_conv };
// ng_debug
// file libng/grab-ng.c line 32
signed int ng_debug = 0;
// ng_dev
// file libng/devices.c line 37
struct ng_device_config ng_dev = { .video="/dev/video0", .driver="libv4l", .radio="/dev/radio0",
    .vbi="/dev/vbi0", .dsp="/dev/dsp",
    .mixer="/dev/mixer", .video_scan={ "/dev/video0", "/dev/video1", "/dev/video2", "/dev/video3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) },
    .mixer_scan={ "/dev/mixer", "/dev/mixer1", "/dev/mixer2", "/dev/mixer3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) } };
// ng_dev_devfs
// file libng/devices.c line 60
struct ng_device_config ng_dev_devfs = { .video="/dev/v4l/video0", .driver="libv4l", .radio="/dev/v4l/radio0",
    .vbi="/dev/v4l/vbi0", .dsp="/dev/sound/dsp",
    .mixer="/dev/sound/mixer", .video_scan={ "/dev/v4l/video0", "/dev/v4l/video1", "/dev/v4l/video2", "/dev/v4l/video3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) },
    .mixer_scan={ "/dev/sound/mixer", "/dev/sound/mixer1", "/dev/sound/mixer2", "/dev/sound/mixer3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) } };
// ng_dsp_drivers
// file libng/grab-ng.c line 378
struct list_head ng_dsp_drivers;
// ng_dsp_drivers
// file libng/grab-ng.c line 378
struct list_head ng_dsp_drivers = { .next=&ng_dsp_drivers, .prev=&ng_dsp_drivers };
// ng_filters
// file libng/grab-ng.c line 374
struct list_head ng_filters;
// ng_filters
// file libng/grab-ng.c line 374
struct list_head ng_filters = { .next=&ng_filters, .prev=&ng_filters };
// ng_jpeg_quality
// file libng/grab-ng.c line 34
signed int ng_jpeg_quality = 75;
// ng_lut_blue
// file libng/grab-ng.h line 486
unsigned long int ng_lut_blue[256l];
// ng_lut_green
// file libng/grab-ng.h line 485
unsigned long int ng_lut_green[256l];
// ng_lut_red
// file libng/grab-ng.h line 484
unsigned long int ng_lut_red[256l];
// ng_mix_drivers
// file libng/grab-ng.c line 379
struct list_head ng_mix_drivers;
// ng_mix_drivers
// file libng/grab-ng.c line 379
struct list_head ng_mix_drivers = { .next=&ng_mix_drivers, .prev=&ng_mix_drivers };
// ng_ratio_x
// file libng/grab-ng.c line 35
signed int ng_ratio_x = 4;
// ng_ratio_y
// file libng/grab-ng.c line 36
signed int ng_ratio_y = 3;
// ng_readers
// file libng/grab-ng.c line 376
struct list_head ng_readers;
// ng_readers
// file libng/grab-ng.c line 376
struct list_head ng_readers = { .next=&ng_readers, .prev=&ng_readers };
// ng_v4l_conf
// file libng/grab-ng.c line 38
char ng_v4l_conf[256l] = { 'v', '4', 'l', '-', 'c', 'o', 'n', 'f', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// ng_vfmt_to_depth
// file libng/grab-ng.c line 42
const unsigned int ng_vfmt_to_depth[19l] = { (const unsigned int)0, (const unsigned int)8, (const unsigned int)8, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)24, (const unsigned int)32, (const unsigned int)24, (const unsigned int)32, (const unsigned int)16, (const unsigned int)32, (const unsigned int)16, (const unsigned int)16, (const unsigned int)12, (const unsigned int)0, (const unsigned int)0, (const unsigned int)16 };
// ng_vfmt_to_desc
// file libng/grab-ng.c line 64
const char *ng_vfmt_to_desc[19l] = { "none", "8 bit PseudoColor (dithering)", "8 bit StaticGray", "15 bit TrueColor (LE)", "16 bit TrueColor (LE)", "15 bit TrueColor (BE)", "16 bit TrueColor (BE)", "24 bit TrueColor (LE: bgr)", "32 bit TrueColor (LE: bgr-)", "24 bit TrueColor (BE: rgb)", "32 bit TrueColor (BE: -rgb)", "16 bit TrueColor (lut)", "32 bit TrueColor (lut)", "16 bit YUV 4:2:2 (packed, YUYV)", "16 bit YUV 4:2:2 (planar)", "12 bit YUV 4:2:0 (planar)", "MJPEG (AVI)", "JPEG (JFIF)", "16 bit YUV 4:2:2 (packed, UYVY)" };
// ng_vid_drivers
// file libng/grab-ng.c line 377
struct list_head ng_vid_drivers;
// ng_vid_drivers
// file libng/grab-ng.c line 377
struct list_head ng_vid_drivers = { .next=&ng_vid_drivers, .prev=&ng_vid_drivers };
// ng_writers
// file libng/grab-ng.c line 375
struct list_head ng_writers;
// ng_writers
// file libng/grab-ng.c line 375
struct list_head ng_writers = { .next=&ng_writers, .prev=&ng_writers };
// ng_yuv_blue
// file libng/color_yuv2rgb.c line 49
static unsigned int ng_yuv_blue[256l];
// ng_yuv_g1
// file libng/color_yuv2rgb.c line 50
static unsigned int ng_yuv_g1[256l];
// ng_yuv_g2
// file libng/color_yuv2rgb.c line 51
static unsigned int ng_yuv_g2[256l];
// ng_yuv_gray
// file libng/color_yuv2rgb.c line 47
static unsigned int ng_yuv_gray[256l];
// ng_yuv_red
// file libng/color_yuv2rgb.c line 48
static unsigned int ng_yuv_red[256l];
// nlaunch
// file common/channel.c line 98
signed int nlaunch = 0;
// oblue
// file console/fbtools.c line 50
static unsigned short int oblue[256l];
// ocmap
// file console/fbtools.c line 51
static struct fb_cmap ocmap;
// ogreen
// file console/fbtools.c line 50
static unsigned short int ogreen[256l];
// ored
// file console/fbtools.c line 50
static unsigned short int ored[256l];
// ocmap
// file console/fbtools.c line 51
static struct fb_cmap ocmap = { .start=(unsigned int)0, .len=(unsigned int)256, .red=ored,
    .green=ogreen, .blue=oblue, .transp=((unsigned short int *)NULL) };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// orig_vt_no
// file console/fbtools.c line 43
static signed int orig_vt_no = 0;
// osd_x
// file common/channel.c line 78
signed int osd_x = 30;
// osd_y
// file common/channel.c line 79
signed int osd_y = 20;
// pix_cols
// file common/channel.c line 81
signed int pix_cols = 1;
// pix_height
// file common/channel.c line 81
signed int pix_height = 96;
// pix_width
// file common/channel.c line 81
signed int pix_width = 128;
// quiet
// file console/fbtv.c line 65
static signed int quiet;
// raw_vformats
// file libng/writefile.c line 572
static struct ng_format_list raw_vformats[7l];
// yuv4mpeg
// file libng/writefile.c line 564
static struct raw_priv yuv4mpeg = { .yuv4mpeg=1 };
// yuv4mpeg2
// file libng/writefile.c line 568
static struct raw_priv yuv4mpeg2 = { .yuv4mpeg=2 };
// raw_vformats
// file libng/writefile.c line 572
static struct ng_format_list raw_vformats[7l] = { { .name="rgb", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)9,
    .priv=NULL },
    { .name="gray", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)2,
    .priv=NULL },
    { .name="422", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)13,
    .priv=NULL },
    { .name="422p", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)14,
    .priv=NULL },
    { .name="4mpeg", .desc="yuv4mpeg (mpeg2enc >= 1.6)", .ext="yuv",
    .fmtid=(unsigned int)15, .priv=(void *)&yuv4mpeg2 },
    { .name="4mpeg-o", .desc="yuv4mpeg (old mpeg2enc)", .ext="yuv",
    .fmtid=(unsigned int)15, .priv=(void *)&yuv4mpeg },
    { .name=((char *)NULL), .desc=((char *)NULL), .ext=((char *)NULL),
    .fmtid=0u, .priv=NULL } };
// raw_writer
// file libng/writefile.c line 635
struct ng_writer raw_writer;
// raw_writer
// file libng/writefile.c line 635
struct ng_writer raw_writer = { .name="raw", .desc="single file, raw video data", .video=raw_vformats,
    .audio=wav_aformats, .combined=0,
    .wr_open=raw_open, .wr_video=raw_video, .wr_audio=raw_audio,
    .wr_close=raw_close, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } };
// rec_status
// file common/commands.c line 37
void (*rec_status)(char *);
// set_capture_hook
// file common/commands.c line 57
void (*set_capture_hook)(signed int, signed int, signed int);
// setfreqtab_notify
// file common/commands.c line 50
void (*setfreqtab_notify)(void);
// setpixel
// file console/fs.c line 47
static void (*setpixel)(void *, unsigned int);
// setstation_notify
// file common/commands.c line 51
void (*setstation_notify)(void);
// sig
// file console/fbtv.c line 65
static signed int sig;
// snapbase
// file common/commands.c line 68
char *snapbase = "snap";
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stdscr
// file /usr/include/curses.h line 1402
extern struct _win_st *stdscr;
// switch_last
// file console/fbtv.c line 62
static signed int switch_last;
// sys_siglist
// file /usr/include/signal.h line 304
extern const char * const sys_siglist[65l];
// term
// file console/fbtools.c line 48
static struct termios term;
// tty
// file console/fbtools.c line 38
static signed int tty;
// tweb
// file common/webcam.c line 105
static unsigned long int tweb;
// update_title
// file common/commands.c line 35
void (*update_title)(char *);
// use_osd
// file common/channel.c line 77
signed int use_osd = 1;
// use_wm_fullscreen
// file common/channel.c line 76
signed int use_wm_fullscreen = 1;
// vdr_sock
// file common/commands.c line 1290
static signed int vdr_sock = -1;
// volume_notify
// file common/commands.c line 48
void (*volume_notify)(void);
// vt_mode
// file console/fbtools.c line 44
static struct vt_mode vt_mode;
// vt_omode
// file console/fbtools.c line 47
static struct vt_mode vt_omode;
// vtx_subtitle
// file common/commands.c line 42
void (*vtx_subtitle)(struct vbi_page *, struct vbi_rect *);
// web
// file common/webcam.c line 104
static struct WEBCAM *web;
// webcam
// file common/webcam.c line 20
char *webcam;
// white
// file console/fs.c line 45
static unsigned int white;
// ww
// file console/fbtv.c line 66
static signed int ww;
// x11_native_format
// file console/fbtv.c line 76
signed int x11_native_format;

// __list_add
// file libng/list.h line 34
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
}

// add_attrs
// file ./common/commands.h line 74
void add_attrs(struct ng_attribute *new)
{
  struct ng_attribute *all;
  signed int nold;
  signed int nnew;
  if(!(attrs == ((struct ng_attribute *)NULL)))
  {
    nold = 0;
    for( ; !((attrs + (signed long int)nold)->name == ((const char *)NULL)); nold = nold + 1)
      ;
  }

  else
    nold = 0;
  nnew = 0;
  for( ; !((new + (signed long int)nnew)->name == ((const char *)NULL)); nnew = nnew + 1)
    ;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)(nold + nnew + 1));
  all = (struct ng_attribute *)return_value_malloc_1;
  memset((void *)all, 0, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)(nold + nnew + 1));
  memcpy((void *)all, (const void *)new, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)nnew);
  if(!(attrs == ((struct ng_attribute *)NULL)))
  {
    memcpy((void *)(all + (signed long int)nnew), (const void *)attrs, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)nold);
    free((void *)attrs);
  }

  attrs = all;
}

// add_channel
// file common/channel.c line 186
struct CHANNEL * add_channel(char *name)
{
  struct CHANNEL *channel;
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if(alloc_count == count)
  {
    alloc_count = alloc_count + 16;
    if(alloc_count == 16)
    {
      return_value_malloc_1=malloc(sizeof(struct CHANNEL *) /*8ul*/  * (unsigned long int)alloc_count);
      channels = (struct CHANNEL **)return_value_malloc_1;
    }

    else
    {
      return_value_realloc_2=realloc((void *)channels, sizeof(struct CHANNEL *) /*8ul*/  * (unsigned long int)alloc_count);
      channels = (struct CHANNEL **)return_value_realloc_2;
    }
  }

  signed int tmp_post_3 = count;
  count = count + 1;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(sizeof(struct CHANNEL) /*104ul*/ );
  channels[(signed long int)tmp_post_3] = (struct CHANNEL *)return_value_malloc_4;
  channel = channels[(signed long int)tmp_post_3];
  memcpy((void *)channel, (const void *)&defaults, sizeof(struct CHANNEL) /*104ul*/ );
  channel->name=strdup(name);
  return channel;
}

// add_dvb_class
// file common/get_media_devices.c line 275
static signed int add_dvb_class(struct media_device_entry *md)
{
  char *return_value_strstr_1;
  return_value_strstr_1=strstr(md->node, "video");
  if(!(return_value_strstr_1 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_VIDEO;

  char *return_value_strstr_2;
  return_value_strstr_2=strstr(md->node, "audio");
  if(!(return_value_strstr_2 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_AUDIO;

  char *return_value_strstr_3;
  return_value_strstr_3=strstr(md->node, "sec");
  if(!(return_value_strstr_3 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_SEC;

  char *return_value_strstr_9;
  return_value_strstr_9=strstr(md->node, "frontend");
  char *return_value_strstr_8;
  char *return_value_strstr_7;
  char *return_value_strstr_6;
  char *return_value_strstr_5;
  char *return_value_strstr_4;
  if(!(return_value_strstr_9 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_FRONTEND;

  else
  {
    return_value_strstr_8=strstr(md->node, "demux");
    if(!(return_value_strstr_8 == ((char *)NULL)))
      md->type = (enum device_type)MEDIA_DVB_DEMUX;

    else
    {
      return_value_strstr_7=strstr(md->node, "dvr");
      if(!(return_value_strstr_7 == ((char *)NULL)))
        md->type = (enum device_type)MEDIA_DVB_DVR;

      else
      {
        return_value_strstr_6=strstr(md->node, "net");
        if(!(return_value_strstr_6 == ((char *)NULL)))
          md->type = (enum device_type)MEDIA_DVB_NET;

        else
        {
          return_value_strstr_5=strstr(md->node, "ca");
          if(!(return_value_strstr_5 == ((char *)NULL)))
            md->type = (enum device_type)MEDIA_DVB_CA;

          else
          {
            return_value_strstr_4=strstr(md->node, "osd");
            if(!(return_value_strstr_4 == ((char *)NULL)))
              md->type = (enum device_type)MEDIA_DVB_OSD;

          }
        }
      }
    }
  }
  return 0;
}

// add_snd_class
// file common/get_media_devices.c line 232
static signed int add_snd_class(struct media_device_entry *md)
{
  unsigned int add_snd_class__1__c = (unsigned int)65535;
  unsigned int d = (unsigned int)65535;
  char node[64l];
  char *return_value_strstr_2;
  return_value_strstr_2=strstr(md->node, "timer");
  char *return_value_strstr_1;
  if(!(return_value_strstr_2 == ((char *)NULL)))
  {
    md->type = (enum device_type)MEDIA_SND_TIMER;
    return 0;
  }

  else
  {
    return_value_strstr_1=strstr(md->node, "seq");
    if(!(return_value_strstr_1 == ((char *)NULL)))
    {
      md->type = (enum device_type)MEDIA_SND_SEQ;
      return 0;
    }

  }
  char *return_value_strstr_8;
  return_value_strstr_8=strstr(md->node, "card");
  char *return_value_strstr_7;
  char *return_value_strstr_6;
  char *return_value_strstr_5;
  unsigned long int return_value_strlen_3;
  if(!(return_value_strstr_8 == ((char *)NULL)))
  {
    sscanf(md->node, "card%u", &add_snd_class__1__c);
    md->type = (enum device_type)MEDIA_SND_CARD;
  }

  else
  {
    return_value_strstr_7=strstr(md->node, "hw");
    if(!(return_value_strstr_7 == ((char *)NULL)))
    {
      sscanf(md->node, "hwC%uD%u", &add_snd_class__1__c, &d);
      md->type = (enum device_type)MEDIA_SND_HW;
    }

    else
    {
      return_value_strstr_6=strstr(md->node, "control");
      if(!(return_value_strstr_6 == ((char *)NULL)))
      {
        sscanf(md->node, "controlC%u", &add_snd_class__1__c);
        md->type = (enum device_type)MEDIA_SND_CONTROL;
      }

      else
      {
        return_value_strstr_5=strstr(md->node, "pcm");
        if(!(return_value_strstr_5 == ((char *)NULL)))
        {
          sscanf(md->node, "pcmC%uD%u", &add_snd_class__1__c, &d);
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(md->node);
          if((signed int)md->node[-1l + (signed long int)return_value_strlen_4] == 112)
            md->type = (enum device_type)MEDIA_SND_OUT;

          else
          {
            return_value_strlen_3=strlen(md->node);
            if((signed int)md->node[-1l + (signed long int)return_value_strlen_3] == 99)
              md->type = (enum device_type)MEDIA_SND_CAP;

          }
        }

      }
    }
  }
  if(add_snd_class__1__c == 65535u)
    return 0;

  else
  {
    if(d == 65535u)
      snprintf(node, sizeof(char [64l]) /*64ul*/ , "hw:%u", add_snd_class__1__c);

    else
      snprintf(node, sizeof(char [64l]) /*64ul*/ , "hw:%u,%u", add_snd_class__1__c, d);
    free((void *)md->node);
    md->node=strdup(node);
    return 0;
  }
}

// add_v4l_class
// file common/get_media_devices.c line 218
static signed int add_v4l_class(struct media_device_entry *md)
{
  char *return_value_strstr_4;
  return_value_strstr_4=strstr(md->node, "video");
  char *return_value_strstr_3;
  char *return_value_strstr_2;
  char *return_value_strstr_1;
  if(!(return_value_strstr_4 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_V4L_VIDEO;

  else
  {
    return_value_strstr_3=strstr(md->node, "vbi");
    if(!(return_value_strstr_3 == ((char *)NULL)))
      md->type = (enum device_type)MEDIA_V4L_VBI;

    else
    {
      return_value_strstr_2=strstr(md->node, "radio");
      if(!(return_value_strstr_2 == ((char *)NULL)))
        md->type = (enum device_type)MEDIA_V4L_RADIO;

      else
      {
        return_value_strstr_1=strstr(md->node, "v4l-subdev");
        if(!(return_value_strstr_1 == ((char *)NULL)))
          md->type = (enum device_type)MEDIA_V4L_SUBDEV;

      }
    }
  }
  return 0;
}

// attr_handler
// file common/commands.c line 833
static signed int attr_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  signed int val;
  signed int arg = 0;
  signed int return_value_strcasecmp_4;
  return_value_strcasecmp_4=strcasecmp(name, "setnorm");
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_2;
  if(return_value_strcasecmp_4 == 0)
    attr=ng_attr_byname(attrs, "norm");

  else
  {
    return_value_strcasecmp_3=strcasecmp(name, "setinput");
    if(return_value_strcasecmp_3 == 0)
      attr=ng_attr_byname(attrs, "input");

    else
    {
      return_value_strcasecmp_2=strcasecmp(name, "setattr");
      if(return_value_strcasecmp_2 == 0 && argc >= 1)
      {
        signed int tmp_post_1 = arg;
        arg = arg + 1;
        attr=ng_attr_byname(attrs, argv[(signed long int)tmp_post_1]);
      }

      else
        attr=ng_attr_byname(attrs, name);
    }
  }
  if(attr == ((struct ng_attribute *)NULL))
  {
    char *tmp_if_expr_5;
    if(arg >= 1)
      tmp_if_expr_5 = argv[(signed long int)0];

    else
      tmp_if_expr_5 = name;
    fprintf(stderr, "cmd: %s: attribute not found\nvalid choices are:", tmp_if_expr_5);
    attr = attrs;
    for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
      fprintf(stderr, "%s \"%s\"", attr != attrs ? "," : "", attr->name);
    fprintf(stderr, "\n");
    return -1;
  }

  else
  {
    if(cur_movie == 0 && !(capture_get_hook == ((void (*)(void))NULL)))
      capture_get_hook();

    switch(attr->type)
    {
      case 2:
      {
        if(!(arg >= argc))
        {
          signed int return_value_strcasecmp_6;
          return_value_strcasecmp_6=strcasecmp("next", argv[(signed long int)arg]);
          if(return_value_strcasecmp_6 == 0)
          {
            val = cur_attrs[(signed long int)attr->id];
            val = val + 1;
            if((attr->choices + (signed long int)val)->str == ((const char *)NULL))
              val = 0;

          }

          else
            val=ng_attr_getint(attr, argv[(signed long int)arg]);
          if(val == -1)
          {
            fprintf(stderr, "invalid value for %s: %s\n", attr->name, argv[(signed long int)arg]);
            ng_attr_listchoices(attr);
          }

          else
          {
            set_attr(attr, val);
            set_msg_str(attr->name, (attr->choices + (signed long int)val)->str);
          }
        }

        break;
      }
      case 1:
      {
        if(!(arg >= argc))
        {
          cur_attrs[(signed long int)attr->id]=attr->read(attr);
          val=update_int(attr, cur_attrs[(signed long int)attr->id], argv[(signed long int)arg]);
          set_attr(attr, val);
        }

        set_msg_int(attr, cur_attrs[(signed long int)attr->id]);
        break;
      }
      case 3:
      {
        if(!(arg >= argc))
        {
          val=str_to_int(argv[(signed long int)arg], booltab);
          if(val == -1)
          {
            signed int return_value_strcasecmp_7;
            return_value_strcasecmp_7=strcasecmp(argv[(signed long int)arg], "toggle");
            if(return_value_strcasecmp_7 == 0)
              val = (signed int)!(cur_attrs[(signed long int)attr->id] != 0);

          }

          set_attr(attr, val);
        }

        set_msg_bool(attr->name, cur_attrs[(signed long int)attr->id]);
      }
    }
    if(cur_movie == 0 && !(capture_rel_hook == ((void (*)(void))NULL)))
      capture_rel_hook();

    return 0;
  }
}

// attr_init
// file ./common/commands.h line 68
void attr_init(void)
{
  struct ng_attribute *attr;
  signed int val;
  attr = attrs;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(attr == ((struct ng_attribute *)NULL)))
      tmp_if_expr_1 = attr->name != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    _Bool tmp_if_expr_2;
    if(attr->id == 3)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = attr->id == 4 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
    {
      val=attr->read(attr);
      if(!(attr_notify == ((void (*)(struct ng_attribute *, signed int))NULL)))
        attr_notify(attr, val);

      cur_attrs[(signed long int)attr->id] = val;
    }

    attr = attr + 1l;
  }
  while((_Bool)1);
  struct ng_attribute *return_value_ng_attr_byid_3;
  if(defaults.color == -1)
  {
    return_value_ng_attr_byid_3=ng_attr_byid(attrs, 6);
    if(!(return_value_ng_attr_byid_3 == ((struct ng_attribute *)NULL)))
      defaults.color = cur_attrs[(signed long int)6];

  }

  struct ng_attribute *return_value_ng_attr_byid_4;
  if(defaults.bright == -1)
  {
    return_value_ng_attr_byid_4=ng_attr_byid(attrs, 7);
    if(!(return_value_ng_attr_byid_4 == ((struct ng_attribute *)NULL)))
      defaults.bright = cur_attrs[(signed long int)7];

  }

  struct ng_attribute *return_value_ng_attr_byid_5;
  if(defaults.hue == -1)
  {
    return_value_ng_attr_byid_5=ng_attr_byid(attrs, 8);
    if(!(return_value_ng_attr_byid_5 == ((struct ng_attribute *)NULL)))
      defaults.hue = cur_attrs[(signed long int)8];

  }

  struct ng_attribute *return_value_ng_attr_byid_6;
  if(defaults.contrast == -1)
  {
    return_value_ng_attr_byid_6=ng_attr_byid(attrs, 9);
    if(!(return_value_ng_attr_byid_6 == ((struct ng_attribute *)NULL)))
      defaults.contrast = cur_attrs[(signed long int)9];

  }

}

// audio_init
// file ./common/commands.h line 69
void audio_init(void)
{
  struct ng_attribute *attr;
  attr=ng_attr_byid(attrs, 3);
  if(!(attr == ((struct ng_attribute *)NULL)))
    cur_attrs[(signed long int)3]=attr->read(attr);

  attr=ng_attr_byid(attrs, 4);
  if(!(attr == ((struct ng_attribute *)NULL)))
    cur_attrs[(signed long int)4]=attr->read(attr);

  if(!(volume_notify == ((void (*)(void))NULL)))
    volume_notify();

}

// audio_off
// file ./common/commands.h line 71
void audio_off(void)
{
  set_mute(1);
}

// audio_on
// file ./common/commands.h line 70
void audio_on(void)
{
  set_mute(0);
}

// bgr24_to_bgr32
// file libng/color_packed.c line 39
static void bgr24_to_bgr32(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_3 = s;
    s = s + 1l;
    *tmp_post_2 = *tmp_post_3;
    unsigned char * restrict tmp_post_4 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_5 = s;
    s = s + 1l;
    *tmp_post_4 = *tmp_post_5;
    unsigned char * restrict tmp_post_6 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_7 = s;
    s = s + 1l;
    *tmp_post_6 = *tmp_post_7;
    unsigned char * restrict tmp_post_8 = d;
    d = d + 1l;
    *tmp_post_8 = (unsigned char)0;
  }
  while((_Bool)1);
}

// bgr24_to_lut2
// file libng/color_lut.c line 43
static void bgr24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// bgr24_to_lut4
// file libng/color_lut.c line 109
static void bgr24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// bgr24_to_rgb32
// file libng/color_packed.c line 54
static void bgr24_to_rgb32(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned char)0;
    unsigned char * restrict tmp_post_3 = d;
    d = d + 1l;
    *tmp_post_3 = s[(signed long int)2];
    unsigned char * restrict tmp_post_4 = d;
    d = d + 1l;
    *tmp_post_4 = s[(signed long int)1];
    unsigned char * restrict tmp_post_5 = d;
    d = d + 1l;
    *tmp_post_5 = s[(signed long int)0];
    s = s + (signed long int)3;
  }
  while((_Bool)1);
}

// bgr32_to_lut2
// file libng/color_lut.c line 69
static void bgr32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// bgr32_to_lut4
// file libng/color_lut.c line 135
static void bgr32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// byteswap_short
// file libng/color_packed.c line 102
static void byteswap_short(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  do
  {
    p = p - 1;
    if(p == 0)
      break;

    unsigned char * restrict tmp_post_1 = d;
    d = d + 1l;
    *tmp_post_1 = s[(signed long int)1];
    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = s[(signed long int)0];
    s = s + (signed long int)2;
  }
  while((_Bool)1);
}

// calc_frequencies
// file common/channel.c line 299
void calc_frequencies(void)
{
  signed int i = 0;
  signed int return_value_get_freq_1;
  for( ; !(i >= count); i = i + 1)
    if(!(channels[(signed long int)i]->cname == ((char *)NULL)))
    {
      channels[(signed long int)i]->channel=lookup_channel(channels[(signed long int)i]->cname);
      if(channels[(signed long int)i]->channel == -1)
        channels[(signed long int)i]->freq = -1;

      else
      {
        return_value_get_freq_1=get_freq(channels[(signed long int)i]->channel);
        channels[(signed long int)i]->freq = return_value_get_freq_1 + channels[(signed long int)i]->fine;
      }
    }

}

// capture_handler
// file common/commands.c line 778
static signed int capture_handler(char *name, signed int argc, char **argv)
{
  signed int i;
  signed int temp = 0;
  signed int return_value_strcasecmp_1;
  return_value_strcasecmp_1=strcasecmp(argv[(signed long int)0], "toggle");
  if(return_value_strcasecmp_1 == 0)
    i = cur_capture == 0 ? 9 : 0;

  else
    i=str_to_int(argv[(signed long int)0], captab);
  signed int return_value_strcasecmp_2;
  if(argc == 2)
  {
    return_value_strcasecmp_2=strcasecmp(argv[(signed long int)1], "temp");
    if(return_value_strcasecmp_2 == 0)
      temp = 1;

  }

  if(!(i == -1))
    set_capture(i, temp);

  return 0;
}

// cf2freq
// file common/channel.c line 159
signed int cf2freq(char *name, signed int fine)
{
  signed int i;
  i=lookup_channel(name);
  if(i == -1)
    return -1;

  else
  {
    signed int return_value_get_freq_1;
    return_value_get_freq_1=get_freq(i);
    return return_value_get_freq_1 + fine;
  }
}

// cfg_find_section
// file common/parseconfig.c line 61
static struct CFG_ENTRIES * cfg_find_section(struct CFG_SECTIONS *c, char *name)
{
  struct CFG_ENTRIES *e;
  signed int i = 0;
  signed int return_value_strcasecmp_1;
  for( ; !(i >= c->sec_count); i = i + 1)
  {
    return_value_strcasecmp_1=strcasecmp(c->sec_names[(signed long int)i], name);
    if(return_value_strcasecmp_1 == 0)
      return c->sec_entries[(signed long int)i];

  }
  if(c->sec_count % 16 == 16)
  {
    void *return_value_realloc_2;
    return_value_realloc_2=realloc((void *)c->sec_names, (unsigned long int)(c->sec_count + 2 + 16) * sizeof(char *) /*8ul*/ );
    c->sec_names = (char **)return_value_realloc_2;
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)c->sec_entries, (unsigned long int)(c->sec_count + 2 + 16) * sizeof(struct CFG_ENTRIES *) /*8ul*/ );
    c->sec_entries = (struct CFG_ENTRIES **)return_value_realloc_3;
  }

  e=cfg_init_entries();
  c->sec_names[(signed long int)c->sec_count]=strdup(name);
  c->sec_entries[(signed long int)c->sec_count] = e;
  c->sec_count = c->sec_count + 1;
  c->sec_names[(signed long int)c->sec_count] = (char *)(void *)0;
  c->sec_entries[(signed long int)c->sec_count] = (struct CFG_ENTRIES *)(void *)0;
  return e;
}

// cfg_get_float
// file common/parseconfig.c line 245
float cfg_get_float(char *sec, char *ent)
{
  char *val;
  val=cfg_get_str(sec, ent);
  if(val == ((char *)NULL))
    return (float)-1;

  else
  {
    double return_value_atof_1;
    return_value_atof_1=atof(val);
    return (float)return_value_atof_1;
  }
}

// cfg_get_int
// file common/parseconfig.h line 8
signed int cfg_get_int(char *sec, char *ent)
{
  char *val;
  val=cfg_get_str(sec, ent);
  if(val == ((char *)NULL))
    return -1;

  else
  {
    signed int return_value_atoi_1;
    return_value_atoi_1=atoi(val);
    return return_value_atoi_1;
  }
}

// cfg_get_signed_int
// file common/parseconfig.h line 9
signed int cfg_get_signed_int(char *sec, char *ent)
{
  char *val;
  val=cfg_get_str(sec, ent);
  if(val == ((char *)NULL))
    return 0;

  else
  {
    signed int return_value_atoi_1;
    return_value_atoi_1=atoi(val);
    return return_value_atoi_1;
  }
}

// cfg_get_str
// file common/parseconfig.h line 7
char * cfg_get_str(char *sec, char *ent)
{
  struct CFG_ENTRIES *e = (struct CFG_ENTRIES *)(void *)0;
  char *v = (char *)(void *)0;
  signed int i = 0;
  signed int return_value_strcasecmp_1;
  for( ; !(i >= c->sec_count); i = i + 1)
  {
    return_value_strcasecmp_1=strcasecmp(c->sec_names[(signed long int)i], sec);
    if(return_value_strcasecmp_1 == 0)
      e = c->sec_entries[(signed long int)i];

  }
  signed int return_value_strcasecmp_2;
  if(e == ((struct CFG_ENTRIES *)NULL))
    return (char *)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= e->ent_count); i = i + 1)
    {
      return_value_strcasecmp_2=strcasecmp(e->ent_names[(signed long int)i], ent);
      if(return_value_strcasecmp_2 == 0)
      {
        v = e->ent_values[(signed long int)i];
        e->ent_seen[(signed long int)i] = e->ent_seen[(signed long int)i] + 1l;
      }

    }
    return v;
  }
}

// cfg_init_entries
// file common/parseconfig.c line 46
static struct CFG_ENTRIES * cfg_init_entries(void)
{
  struct CFG_ENTRIES *e;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct CFG_ENTRIES) /*32ul*/ );
  e = (struct CFG_ENTRIES *)return_value_malloc_1;
  memset((void *)e, 0, sizeof(struct CFG_ENTRIES) /*32ul*/ );
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
  e->ent_names = (char **)return_value_malloc_2;
  e->ent_names[(signed long int)0] = (char *)(void *)0;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
  e->ent_values = (char **)return_value_malloc_3;
  e->ent_values[(signed long int)0] = (char *)(void *)0;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)16 * sizeof(signed int *) /*8ul*/ );
  e->ent_seen = (signed int **)return_value_malloc_4;
  e->ent_seen[(signed long int)0] = ((signed int *)NULL);
  return e;
}

// cfg_init_sections
// file common/parseconfig.c line 33
static struct CFG_SECTIONS * cfg_init_sections(void)
{
  struct CFG_SECTIONS *cfg_init_sections__1__c;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct CFG_SECTIONS) /*24ul*/ );
  cfg_init_sections__1__c = (struct CFG_SECTIONS *)return_value_malloc_1;
  memset((void *)cfg_init_sections__1__c, 0, sizeof(struct CFG_SECTIONS) /*24ul*/ );
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
  cfg_init_sections__1__c->sec_names = (char **)return_value_malloc_2;
  cfg_init_sections__1__c->sec_names[(signed long int)0] = (char *)(void *)0;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)16 * sizeof(struct CFG_ENTRIES *) /*8ul*/ );
  cfg_init_sections__1__c->sec_entries = (struct CFG_ENTRIES **)return_value_malloc_3;
  cfg_init_sections__1__c->sec_entries[(signed long int)0] = (struct CFG_ENTRIES *)(void *)0;
  return cfg_init_sections__1__c;
}

// cfg_list_entries
// file common/parseconfig.h line 6
char ** cfg_list_entries(char *name)
{
  signed int i;
  signed int return_value_strcasecmp_1;
  if(c == ((struct CFG_SECTIONS *)NULL))
    return (char **)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= c->sec_count); i = i + 1)
    {
      return_value_strcasecmp_1=strcasecmp(c->sec_names[(signed long int)i], name);
      if(return_value_strcasecmp_1 == 0)
        return c->sec_entries[(signed long int)i]->ent_names;

    }
    return (char **)(void *)0;
  }
}

// cfg_list_sections
// file common/parseconfig.h line 5
char ** cfg_list_sections(void)
{
  return c->sec_names;
}

// cfg_parse_file
// file common/parseconfig.h line 1
signed int cfg_parse_file(char *filename)
{
  struct CFG_ENTRIES *e = (struct CFG_ENTRIES *)(void *)0;
  char line[256l];
  char tag[64l];
  char value[192l];
  struct _IO_FILE *fp;
  signed int nr;
  if(c == ((struct CFG_SECTIONS *)NULL))
    c=cfg_init_sections();

  fp=fopen(filename, "r");
  char *return_value_fgets_1;
  signed int return_value_sscanf_6;
  if(fp == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    nr = 0;
    do
    {
      return_value_fgets_1=fgets(line, 255, fp);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      nr = nr + 1;
      _Bool tmp_if_expr_2;
      if((signed int)line[0l] == 10)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_3;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)line[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_3)
      {
        signed int return_value_sscanf_7;
        return_value_sscanf_7=sscanf(line, "[%99[^]]]", (const void *)value);
        if(return_value_sscanf_7 == 1)
          e=cfg_find_section(c, value);

        else
        {
          return_value_sscanf_6=sscanf(line, " %63[^= ] = %191[^\n]", (const void *)tag, (const void *)value);
          if(return_value_sscanf_6 == 2)
          {
            if(e == ((struct CFG_ENTRIES *)NULL))
              fprintf(stderr, "%s:%d: error: no section\n", filename, nr);

            else
            {
              char *cfg_parse_file__1__1__2__2__c;
              unsigned long int return_value_strlen_4;
              return_value_strlen_4=strlen(value);
              cfg_parse_file__1__1__2__2__c = (value + (signed long int)return_value_strlen_4) - (signed long int)1;
              while(!(value >= cfg_parse_file__1__1__2__2__c))
              {
                if(!((signed int)*cfg_parse_file__1__1__2__2__c == 32))
                {
                  if(!((signed int)*cfg_parse_file__1__1__2__2__c == 9))
                    break;

                }

                char *tmp_post_5 = cfg_parse_file__1__1__2__2__c;
                cfg_parse_file__1__1__2__2__c = cfg_parse_file__1__1__2__2__c - 1l;
                *tmp_post_5 = (char)0;
              }
              cfg_set_entry(e, tag, value);
            }
          }

          else
            fprintf(stderr, "%s:%d: syntax error\n", filename, nr);
        }
      }

    }
    while((_Bool)1);
    fclose(fp);
    return 0;
  }
}

// cfg_parse_option
// file common/parseconfig.c line 153
void cfg_parse_option(char *section, char *tag, char *value)
{
  struct CFG_ENTRIES *e = (struct CFG_ENTRIES *)(void *)0;
  if(c == ((struct CFG_SECTIONS *)NULL))
    c=cfg_init_sections();

  e=cfg_find_section(c, section);
  cfg_set_entry(e, tag, value);
}

// cfg_parse_options
// file common/parseconfig.h line 3
void cfg_parse_options(signed int *argc, char **argv)
{
  char section[64l];
  char tag[64l];
  signed int i;
  signed int j;
  i = 1;
  while(!(1 + i >= *argc))
  {
    signed int return_value_sscanf_1;
    return_value_sscanf_1=sscanf(argv[(signed long int)i], "-%63[^:]:%63s", (const void *)section, (const void *)tag);
    if(return_value_sscanf_1 == 2)
    {
      cfg_parse_option(section, tag, argv[(signed long int)(i + 1)]);
      j = i;
      for( ; !(j >= *argc + -1); j = j + 1)
        argv[(signed long int)j] = argv[(signed long int)(j + 2)];
      *argc = *argc - 2;
    }

    else
      i = i + 1;
  }
}

// cfg_set_entry
// file common/parseconfig.c line 85
static void cfg_set_entry(struct CFG_ENTRIES *e, char *name, char *value)
{
  signed int i = 0;
  signed int return_value_strcasecmp_1;
  for( ; !(i >= e->ent_count); i = i + 1)
  {
    return_value_strcasecmp_1=strcasecmp(e->ent_names[(signed long int)i], name);
    if(return_value_strcasecmp_1 == 0)
      break;

  }
  if(i == e->ent_count)
  {
    if(e->ent_count % 16 == 16)
    {
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)e->ent_names, (unsigned long int)(e->ent_count + 2 + 16) * sizeof(char *) /*8ul*/ );
      e->ent_names = (char **)return_value_realloc_2;
      void *return_value_realloc_3;
      return_value_realloc_3=realloc((void *)e->ent_values, (unsigned long int)(e->ent_count + 2 + 16) * sizeof(char *) /*8ul*/ );
      e->ent_values = (char **)return_value_realloc_3;
      void *return_value_realloc_4;
      return_value_realloc_4=realloc((void *)e->ent_seen, (unsigned long int)(e->ent_count + 2 + 16) * sizeof(signed int *) /*8ul*/ );
      e->ent_seen = (signed int **)return_value_realloc_4;
    }

    e->ent_count = e->ent_count + 1;
    e->ent_names[(signed long int)e->ent_count] = (char *)(void *)0;
    e->ent_values[(signed long int)e->ent_count] = (char *)(void *)0;
    e->ent_seen[(signed long int)e->ent_count] = ((signed int *)NULL);
  }

  e->ent_names[(signed long int)i]=strdup(name);
  e->ent_values[(signed long int)i]=strdup(value);
}

// channel_menu
// file console/fbtv.c line 489
static void channel_menu(void)
{
  char key[32l];
  char ctrl[16l];
  char event[64l];
  char action[128l];
  signed int i = 0;
  for( ; !(i >= count); i = i + 1)
    if(!(channels[(signed long int)i]->key == ((char *)NULL)))
    {
      signed int return_value_sscanf_1;
      return_value_sscanf_1=sscanf(channels[(signed long int)i]->key, "%15[A-Za-z0-9_]+%31[A-Za-z0-9_]", (const void *)ctrl, (const void *)key);
      if(!(return_value_sscanf_1 == 2))
        strcpy(key, channels[(signed long int)i]->key);

      sprintf(event, "kbd-key-%s", (const void *)key);
      sprintf(action, "setstation \"%s\"", channels[(signed long int)i]->name);
      event_register(event, action);
    }

}

// clip_drop
// file libng/grab-ng.c line 841
static void clip_drop(struct OVERLAY_CLIP *oc, signed int n, signed int *count)
{
  *count = *count - 1;
  memmove((void *)(oc + (signed long int)n), (const void *)(oc + (signed long int)n + (signed long int)1), sizeof(struct OVERLAY_CLIP) /*16ul*/  * (unsigned long int)(*count - n));
}

// clip_dump
// file libng/grab-ng.c line 829
static void clip_dump(char *state, struct OVERLAY_CLIP *oc, signed int count)
{
  signed int i;
  fprintf(stderr, "clip: %s - %d clips\n", state, count);
  i = 0;
  for( ; !(i >= count); i = i + 1)
    fprintf(stderr, "clip:   %d: %dx%d+%d+%d\n", i, (oc + (signed long int)i)->x2 - (oc + (signed long int)i)->x1, (oc + (signed long int)i)->y2 - (oc + (signed long int)i)->y1, (oc + (signed long int)i)->x1, (oc + (signed long int)i)->y1);
}

// console_switch
// file console/fbtv.c line 539
static void console_switch(void)
{
  switch(fb_switch_state)
  {
    case 1:
    {
      if(keep_dma_on == 0)
        do_va_cmd(2, (const void *)"capture", (const void *)"off");

      switch_last = fb_switch_state;
      fb_switch_release();
      break;
    }
    case 3:
    {
      switch_last = fb_switch_state;
      fb_switch_acquire();
      fb_memset((void *)(fb_mem + (signed long int)fb_mem_offset), 0, (unsigned long int)fb_fix.smem_len);
      ioctl(fb, (unsigned long int)0x4606, &fb_var);
      do_va_cmd(2, (const void *)"capture", (const void *)"on");
      break;
    }
    case 0:

    case 2:

    default:
      switch_last = fb_switch_state;
  }
}

// ctrlc
// file console/fbtv.c line 352
static void ctrlc(signed int signal)
{
  sig = 1;
}

// dattr_handler
// file common/commands.c line 980
static signed int dattr_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr = (struct ng_attribute *)(void *)0;
  unsigned int i;
  signed int return_value_strcasecmp_1;
  if(argc >= 1)
  {
    return_value_strcasecmp_1=strcasecmp(argv[(signed long int)0], "next");
    if(return_value_strcasecmp_1 == 0)
    {
      i = (unsigned int)0;
      for( ; !((unsigned long int)i >= 2ul); i = i + 1u)
      {
        cur_dattr = cur_dattr + 1;
        cur_dattr = cur_dattr % (signed int)(sizeof(signed int [5l]) /*20ul*/  / sizeof(char *) /*8ul*/ );
        attr=ng_attr_byid(attrs, dattr[(signed long int)cur_dattr]);
        if(!(attr == ((struct ng_attribute *)NULL)))
          break;

      }
      if(attr == ((struct ng_attribute *)NULL))
        return 0;

      argc = 0;
    }

  }

  if(attr == ((struct ng_attribute *)NULL))
    attr=ng_attr_byid(attrs, dattr[(signed long int)cur_dattr]);

  if(attr == ((struct ng_attribute *)NULL))
    return 0;

  else
  {
    signed int return_value_attr_handler_2;
    return_value_attr_handler_2=attr_handler((char *)attr->name, argc, argv);
    return return_value_attr_handler_2;
  }
}

// del_channel
// file common/channel.c line 287
void del_channel(signed int i)
{
  free((void *)channels[(signed long int)i]->name);
  if(!(channels[(signed long int)i]->key == ((char *)NULL)))
    free((void *)channels[(signed long int)i]->key);

  free((void *)channels[(signed long int)i]);
  count = count - 1;
  if(!(i >= count))
    memmove((void *)(channels + (signed long int)i), (const void *)(channels + (signed long int)i + (signed long int)1), (unsigned long int)(count - i) * sizeof(struct CHANNEL *) /*8ul*/ );

}

// dev_init
// file console/fbtools.c line 74
static void dev_init(void)
{
  struct stat dummy;
  if(devices == ((struct DEVS *)NULL))
  {
    signed int return_value_stat_1;
    return_value_stat_1=stat("/dev/.devfsd", &dummy);
    if(return_value_stat_1 == 0)
      devices = &devs_devfs;

    else
      devices = &devs_default;
  }

}

// discover_media_devices
// file ./common/get_media_devices.h line 81
void * discover_media_devices(void)
{
  struct media_devices *md = (struct media_devices *)(void *)0;
  struct media_device_entry *md_entry = (struct media_device_entry *)(void *)0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct media_devices) /*16ul*/ );
  md = (struct media_devices *)return_value_calloc_1;
  signed int return_value_get_class_3;
  signed int return_value_get_class_4;
  if(md == ((struct media_devices *)NULL))
    return (void *)0;

  else
  {
    md->md_size = (unsigned int)0;
    signed int return_value_get_class_2;
    return_value_get_class_2=get_class("video4linux", &md_entry, &md->md_size, add_v4l_class);
    if(return_value_get_class_2 == 0)
    {
      return_value_get_class_3=get_class("sound", &md_entry, &md->md_size, add_snd_class);
      if(!(return_value_get_class_3 == 0))
        goto error;

      return_value_get_class_4=get_class("dvb", &md_entry, &md->md_size, add_dvb_class);
      if(!(return_value_get_class_4 == 0))
        goto error;

      if(md_entry == ((struct media_device_entry *)NULL))
        goto error;

      qsort((void *)md_entry, (unsigned long int)md->md_size, sizeof(struct media_device_entry) /*32ul*/ , sort_media_device_entry);
      md->md_entry = md_entry;
      return (void *)md;
    }

    else
    {

    error:
      ;
      free_media_devices((void *)md);
      return (void *)0;
    }
  }
}

// display_media_devices
// file common/get_media_devices.c line 418
void display_media_devices(void *opaque)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i;
  char *prev = "";
  i = 0;
  for( ; !((unsigned int)i >= md->md_size); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(prev, md_ptr->device);
    if(!(return_value_strcmp_1 == 0))
    {
      printf("\nDevice %s:\n\t", md_ptr->device);
      prev = md_ptr->device;
    }

    const char *return_value_media_device_type_2;
    return_value_media_device_type_2=media_device_type(md_ptr->type);
    printf("%s(%s, dev %i:%i) ", md_ptr->node, return_value_media_device_type_2, md_ptr->major, md_ptr->minor);
    md_ptr = md_ptr + 1l;
  }
  printf("\n");
}

// dither_palette
// file console/fbtv.c line 215
static void dither_palette(signed int r, signed int g, signed int b)
{
  signed int rs;
  signed int gs;
  signed int bs;
  signed int i;
  rs = 256 / (r - 1);
  gs = 256 / (g - 1);
  bs = 256 / (b - 1);
  i = 0;
  for( ; !(i >= b * g * r); i = i + 1)
  {
    green[(signed long int)(i + 16)] = (unsigned short int)(gs * ((i / (r * b)) % g) * 255);
    red[(signed long int)(i + 16)] = (unsigned short int)(rs * ((i / b) % r) * 255);
    blue[(signed long int)(i + 16)] = (unsigned short int)(bs * (i % b) * 255);
  }
}

// do_capture
// file console/fbtv.c line 366
static void do_capture(signed int from, signed int to, signed int tmp_switch)
{
  switch(from)
  {
    case 2:
    {
      if(!((2 & f_drv) == 0))
        drv->stopvideo(h_drv);

      break;
    }
    case 1:
    {
      if(!((2 & f_drv) == 0))
        drv->overlay(h_drv, (struct ng_video_fmt *)(void *)0, 0, 0, (struct OVERLAY_CLIP *)(void *)0, 0, 0);

      if(tmp_switch == 0 && !(matrox == 0))
        gfx_scaler_off();

    }
  }
  memset((void *)&buf, 0, sizeof(struct ng_video_buf *) /*8ul*/ );
  signed int return_value_ng_grabber_setformat_1;
  switch(to)
  {
    case 2:
    {
      if(!(hh == 0) && !(ww == 0))
      {
        dx = (signed int)(fb_var.xres - fmt.width);
        dy = 0;
        fmt.fmtid = (unsigned int)x11_native_format;
        fmt.width = (unsigned int)ww;
        fmt.height = (unsigned int)hh;
        fmt.bytesperline = fb_fix.line_length;
      }

      else
      {
        if(!(quiet == 0))
        {
          dx = 0;
          dy = 0;
        }

        else
        {
          dx = (f->height * 3) / 2;
          dy = f->height;
        }
        fmt.fmtid = (unsigned int)x11_native_format;
        fmt.width = fb_var.xres - (unsigned int)dx;
        fmt.height = fb_var.yres - (unsigned int)dy;
        fmt.bytesperline = fb_fix.line_length;
      }
      return_value_ng_grabber_setformat_1=ng_grabber_setformat(&fmt, 1);
      if(!(return_value_ng_grabber_setformat_1 == 0))
      {
        gfmt = fmt;
        conv=ng_grabber_findconv(&gfmt, 0);
        if(conv == ((struct ng_video_conv *)NULL))
        {
          fprintf(stderr, "can't fint useful capture format\n");
          exit(1);
        }

        ch=ng_convert_alloc(conv, &gfmt, &fmt);
        ng_convert_init(ch);
      }

      dx = dx + (signed int)(((fb_var.xres - (unsigned int)24) - fmt.width) / (unsigned int)2);
      dy = dy + (signed int)(((fb_var.yres - (unsigned int)16) - fmt.height) / (unsigned int)2);
      if(!((2 & f_drv) == 0))
        drv->startvideo(h_drv, -1, (unsigned int)2);

      break;
    }
    case 1:
    {
      fmt.fmtid = (unsigned int)x11_native_format;
      if(!(hh == 0) && !(ww == 0))
      {
        fmt.width = (unsigned int)ww;
        fmt.height = (unsigned int)hh;
        dx = (signed int)(fb_var.xres - fmt.width);
        dy = 0;
      }

      else
        if(!(quiet == 0))
        {
          fmt.width = fb_var.xres;
          fmt.height = fb_var.yres;
          dx = 0;
          dy = 0;
        }

        else
        {
          fmt.width = fb_var.xres - (unsigned int)24;
          fmt.height = fb_var.yres - (unsigned int)16;
          dx = (f->height * 3) / 2;
          dy = f->height;
        }
      if(!(matrox == 0))
      {
        struct ng_video_fmt off;
        signed int starty;
        off.width = (unsigned int)768;
        off.height = (unsigned int)288;
        starty = (signed int)fb_var.yres;
        off.bytesperline = fb_fix.line_length;
        if(!(off.bytesperline >= 2u * off.width))
          off.width = off.bytesperline / (unsigned int)2;

        off.fmtid = (unsigned int)13;
        drv->overlay(h_drv, &off, 0, starty, (struct OVERLAY_CLIP *)(void *)0, 0, 0);
        gfx_scaler_on((signed int)((unsigned int)starty * off.bytesperline), (signed int)off.bytesperline, (signed int)off.width, (signed int)off.height, dx, (signed int)((unsigned int)dx + fmt.width), dy, (signed int)((unsigned int)dy + fmt.height));
      }

      else
        drv->overlay(h_drv, &fmt, dx, dy, (struct OVERLAY_CLIP *)(void *)0, 0, 1);
    }
  }
}

// do_command
// file common/commands.h line 78
signed int do_command(signed int argc, char **argv)
{
  signed int i;
  signed int return_value_strcasecmp_1;
  if(argc == 0)
  {
    fprintf(stderr, "do_command: no argument\n");
    return -1;
  }

  else
  {
    if(!(debug == 0))
    {
      fprintf(stderr, "cmd:");
      i = 0;
      for( ; !(i >= argc); i = i + 1)
        fprintf(stderr, " \"%s\"", argv[(signed long int)i]);
      fprintf(stderr, "\n");
    }

    i = 0;
    for( ; !(commands[(signed long int)i].name == ((char *)NULL)); i = i + 1)
    {
      return_value_strcasecmp_1=strcasecmp(commands[(signed long int)i].name, argv[(signed long int)0]);
      if(return_value_strcasecmp_1 == 0)
        break;

    }
    if(commands[(signed long int)i].name == ((char *)NULL))
    {
      fprintf(stderr, "no handler for %s\n", argv[(signed long int)0]);
      return -1;
    }

    else
      if(!(argc + -1 >= commands[(signed long int)i].min_args))
      {
        fprintf(stderr, "no enough args for %s\n", argv[(signed long int)0]);
        return -1;
      }

      else
      {
        signed int return_value;
        return_value=commands[(signed long int)i].handler(argv[(signed long int)0], argc - 1, argv + (signed long int)1);
        return return_value;
      }
  }
}

// do_exit
// file console/fbtv.c line 471
static void do_exit(void)
{
  sig = 1;
}

// do_fullscreen
// file console/fbtv.c line 507
static void do_fullscreen(void)
{
  do_va_cmd(2, (const void *)"capture", (const void *)"off");
  quiet = (signed int)!(quiet != 0);
  fb_memset((void *)(fb_mem + (signed long int)fb_mem_offset), 0, (unsigned long int)fb_fix.smem_len);
  do_va_cmd(2, (const void *)"capture", (const void *)"on");
}

// do_va_cmd
// file ./common/commands.h line 77
signed int do_va_cmd(signed int argc, ...)
{
  __builtin_va_list ap;
  signed int i;
  char *argv[32l];
  va_start(ap, argc);
  i = 0;
  for( ; !(i >= argc); i = i + 1)
    argv[(signed long int)i]=va_arg(ap, __typeof__(argv[(signed long int)i]));
  argv[(signed long int)i] = (char *)(void *)0;
  va_end(ap);
  signed int return_value_do_command_1;
  return_value_do_command_1=do_command(argc, argv);
  return return_value_do_command_1;
}

// do_write_jpeg
// file libng/writefile.c line 87
static signed int do_write_jpeg(struct _IO_FILE *fp, struct ng_video_buf *buf, signed int quality, signed int gray)
{
  struct jpeg_compress_struct cinfo;
  struct jpeg_error_mgr jerr;
  unsigned int i;
  unsigned char *line;
  signed int line_length;
  cinfo.err=jpeg_std_error(&jerr);
  jpeg_CreateCompress(&cinfo, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
  jpeg_stdio_dest(&cinfo, fp);
  cinfo.image_width = buf->fmt.width;
  cinfo.image_height = buf->fmt.height;
  cinfo.input_components = gray != 0 ? 1 : 3;
  cinfo.in_color_space = (enum anonymous)(gray != 0 ? JCS_GRAYSCALE : JCS_RGB);
  jpeg_set_defaults(&cinfo);
  jpeg_set_quality(&cinfo, quality, 1);
  jpeg_start_compress(&cinfo, 1);
  unsigned int tmp_if_expr_1;
  if(!(gray == 0))
    tmp_if_expr_1 = buf->fmt.width;

  else
    tmp_if_expr_1 = buf->fmt.width * (unsigned int)3;
  line_length = (signed int)tmp_if_expr_1;
  i = (unsigned int)0;
  line = buf->data;
  for( ; !(i >= buf->fmt.height); line = line + (signed long int)line_length)
  {
    jpeg_write_scanlines(&cinfo, &line, (unsigned int)1);
    i = i + 1u;
  }
  jpeg_finish_compress(&cinfo);
  jpeg_destroy_compress(&cinfo);
  fclose(fp);
  return 0;
}

// event_dispatch
// file ./common/event.h line 23
signed int event_dispatch(char *event)
{
  struct event_entry *entry = (struct event_entry *)(void *)0;
  char *name;
  char *arg;
  char *h;
  char *argv[16l];
  signed int argc;
  h=strchr(event, 40);
  if(!(h == ((char *)NULL)))
  {
    name = event;
    arg = h + (signed long int)1;
    *h = (char)0;
    h=strchr(arg, 41);
    if(!(h == ((char *)NULL)))
      *h = (char)0;

    if(!(debug == 0))
      fprintf(stderr, "ev: dispatch name=%s arg=%s\n", name, arg);

  }

  else
  {
    name = event;
    arg = (char *)(void *)0;
    if(!(debug == 0))
      fprintf(stderr, "ev: dispatch name=%s\n", name);

  }
  signed int return_value_strcasecmp_1;
  if(entry == ((struct event_entry *)NULL))
  {
    entry = event_conf_list;
    for( ; !(entry == ((struct event_entry *)NULL)); entry = entry->next)
    {
      return_value_strcasecmp_1=strcasecmp(name, entry->event);
      if(return_value_strcasecmp_1 == 0)
        break;

    }
  }

  signed int return_value_strcasecmp_2;
  if(entry == ((struct event_entry *)NULL))
  {
    entry = event_builtin_list;
    for( ; !(entry == ((struct event_entry *)NULL)); entry = entry->next)
    {
      return_value_strcasecmp_2=strcasecmp(name, entry->event);
      if(return_value_strcasecmp_2 == 0)
        break;

    }
  }

  if(entry == ((struct event_entry *)NULL))
  {
    if(!(debug == 0))
      fprintf(stderr, "ev: 404: %s\n", name);

    return 0;
  }

  else
  {
    memcpy((void *)argv, (const void *)entry->argv, sizeof(char *[16l]) /*128ul*/ );
    argc = entry->argc;
    if(!(arg == ((char *)NULL)))
    {
      signed int tmp_post_3 = argc;
      argc = argc + 1;
      argv[(signed long int)tmp_post_3] = arg;
    }

    do_command(argc, argv);
    return 0;
  }
}

// event_readconfig
// file common/event.h line 20
void event_readconfig(void)
{
  char **list;
  char *val;
  list=cfg_list_entries("eventmap");
  if(!(list == ((char **)NULL)))
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      val=cfg_get_str("eventmap", *list);
      if(!(val == ((char *)NULL)))
        event_register(*list, val);

    }

}

// event_register
// file ./common/event.h line 17
signed int event_register(char *event, char *action)
{
  struct event_entry *entry;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct event_entry) /*528ul*/ );
  entry = (struct event_entry *)return_value_malloc_1;
  memset((void *)entry, 0, sizeof(struct event_entry) /*528ul*/ );
  strncpy(entry->event, event, (unsigned long int)127);
  strncpy(entry->action, action, (unsigned long int)127);
  entry->next = event_conf_list;
  event_conf_list = entry;
  parse_action(entry);
  if(!(debug == 0))
    fprintf(stderr, "ev: reg conf \"%s\" => \"%s\"\n", (const void *)entry->event, (const void *)entry->action);

  return 0;
}

// event_register_list
// file ./common/event.h line 18
signed int event_register_list(struct event_entry *entry)
{
  _Bool tmp_if_expr_1;
  do
  {
    if(!(entry == ((struct event_entry *)NULL)))
      tmp_if_expr_1 = 0 != (signed int)entry->event[(signed long int)0] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    entry->next = event_builtin_list;
    event_builtin_list = entry;
    parse_action(entry);
    if(!(debug == 0))
      fprintf(stderr, "ev: reg built-in \"%s\" => \"%s\"\n", (const void *)entry->event, (const void *)entry->action);

    entry = entry + 1l;
  }
  while((_Bool)1);
  return 0;
}

// event_writeconfig
// file common/event.h line 21
void event_writeconfig(struct _IO_FILE *fp)
{
  struct event_entry *entry;
  if(!(event_conf_list == ((struct event_entry *)NULL)))
  {
    fprintf(fp, "[eventmap]\n");
    entry = event_conf_list;
    for( ; !(entry == ((struct event_entry *)NULL)); entry = entry->next)
      fprintf(fp, "%s = %s\n", (const void *)entry->event, (const void *)entry->action);
    fprintf(fp, "\n");
  }

}

// exit_handler
// file common/commands.c line 1189
static signed int exit_handler(char *name, signed int argc, char **argv)
{
  if(!(exit_hook == ((void (*)(void))NULL)))
    exit_hook();

  return 0;
}

// fb_activate_current
// file console/fbtools.c line 304
static signed int fb_activate_current(signed int tty)
{
  struct vt_stat vts;
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(tty, (unsigned long int)0x5603, &vts);
  if(return_value_ioctl_1 == -1)
  {
    perror("ioctl VT_GETSTATE");
    return -1;
  }

  else
  {
    signed int return_value_ioctl_2;
    return_value_ioctl_2=ioctl(tty, (unsigned long int)0x5606, vts.v_active);
    if(return_value_ioctl_2 == -1)
    {
      perror("ioctl VT_ACTIVATE");
      return -1;
    }

    else
    {
      signed int return_value_ioctl_3;
      return_value_ioctl_3=ioctl(tty, (unsigned long int)0x5607, vts.v_active);
      if(return_value_ioctl_3 == -1)
      {
        perror("ioctl VT_WAITACTIVE");
        return -1;
      }

      else
        return 0;
    }
  }
}

// fb_catch_exit_signal
// file console/fbtools.c line 493
static void fb_catch_exit_signal(signed int signal)
{
  siglongjmp(fb_fatal_cleanup, signal);
}

// fb_catch_exit_signals
// file console/fbtools.h line 17
void fb_catch_exit_signals(void)
{
  struct sigaction act;
  struct sigaction old;
  signed int termsig;
  memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
  act.__sigaction_handler.sa_handler = fb_catch_exit_signal;
  sigemptyset(&act.sa_mask);
  sigaction(2, &act, &old);
  sigaction(3, &act, &old);
  sigaction(15, &act, &old);
  sigaction(6, &act, &old);
  sigaction(20, &act, &old);
  sigaction(7, &act, &old);
  sigaction(4, &act, &old);
  sigaction(11, &act, &old);
  termsig=__sigsetjmp(fb_fatal_cleanup, 0);
  if(!(termsig == 0))
  {
    fb_cleanup();
    fprintf(stderr, "Oops: %s\n", sys_siglist[(signed long int)termsig]);
    exit(42);
  }

}

// fb_cleanup
// file console/fbtools.h line 16
void fb_cleanup(void)
{
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(fb_link1, (unsigned long int)0x4601, &fb_ovar);
  if(return_value_ioctl_1 == -1)
    perror("ioctl FBIOPUT_VSCREENINFO");

  signed int return_value_ioctl_2;
  return_value_ioctl_2=ioctl(fb_link1, (unsigned long int)0x4602, &fb_fix);
  if(return_value_ioctl_2 == -1)
    perror("ioctl FBIOGET_FSCREENINFO");

  if(fb_fix.visual == 4u || fb_ovar.bits_per_pixel == 8u)
  {
    signed int return_value_ioctl_3;
    return_value_ioctl_3=ioctl(fb_link1, (unsigned long int)0x4605, &ocmap);
    if(return_value_ioctl_3 == -1)
      perror("ioctl FBIOPUTCMAP");

  }

  close(fb_link1);
  signed int return_value_ioctl_4;
  return_value_ioctl_4=ioctl(tty, (unsigned long int)0x4B3A, kd_mode);
  if(return_value_ioctl_4 == -1)
    perror("ioctl KDSETMODE");

  signed int return_value_ioctl_5;
  return_value_ioctl_5=ioctl(tty, (unsigned long int)0x5602, &vt_omode);
  if(return_value_ioctl_5 == -1)
    perror("ioctl VT_SETMODE");

  signed int return_value_ioctl_6;
  if(!(orig_vt_no == 0))
  {
    return_value_ioctl_6=ioctl(tty, (unsigned long int)0x5606, orig_vt_no);
    if(return_value_ioctl_6 == -1)
      perror("ioctl VT_ACTIVATE");

  }

  signed int return_value_ioctl_7;
  if(!(orig_vt_no == 0))
  {
    return_value_ioctl_7=ioctl(tty, (unsigned long int)0x5607, orig_vt_no);
    if(return_value_ioctl_7 == -1)
      perror("ioctl VT_WAITACTIVE");

  }

  tcsetattr(tty, 0, &term);
  close(tty);
}

// fb_init
// file console/fbtools.h line 15
signed int fb_init(char *device, char *mode, signed int vt)
{
  char fb_init__1__fbdev[16l];
  struct vt_stat vts;
  dev_init();
  tty = 0;
  if(!(vt == 0))
    fb_setvt(vt);

  signed int return_value_ioctl_3;
  return_value_ioctl_3=ioctl(tty, (unsigned long int)0x5603, &vts);
  if(return_value_ioctl_3 == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "ioctl VT_GETSTATE: %s (not a linux console?)\n", return_value_strerror_2);
    exit(1);
  }

  if(device == ((char *)NULL))
  {
    device=getenv("FRAMEBUFFER");
    if(device == ((char *)NULL))
    {
      struct fb_con2fbmap c2m;
      fb_link1=open(devices->fb0, 01, 0);
      if(fb_link1 == -1)
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        fprintf(stderr, "open %s: %s\n", devices->fb0, return_value_strerror_5);
        exit(1);
      }

      c2m.console = (unsigned int)vts.v_active;
      signed int return_value_ioctl_6;
      return_value_ioctl_6=ioctl(fb_link1, (unsigned long int)0x460F, &c2m);
      if(return_value_ioctl_6 == -1)
      {
        perror("ioctl FBIOGET_CON2FBMAP");
        exit(1);
      }

      close(fb_link1);
      fprintf(stderr, "map: vt%02d => fb%d\n", c2m.console, c2m.framebuffer);
      sprintf(fb_init__1__fbdev, devices->fbnr, c2m.framebuffer);
      device = fb_init__1__fbdev;
    }

  }

  fb_link1=open(device, 02);
  if(fb_link1 == -1)
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    char *return_value_strerror_8;
    return_value_strerror_8=strerror(*return_value___errno_location_7);
    fprintf(stderr, "open %s: %s\n", device, return_value_strerror_8);
    exit(1);
  }

  signed int return_value_ioctl_9;
  return_value_ioctl_9=ioctl(fb_link1, (unsigned long int)0x4600, &fb_ovar);
  if(return_value_ioctl_9 == -1)
  {
    perror("ioctl FBIOGET_VSCREENINFO");
    exit(1);
  }

  signed int return_value_ioctl_10;
  return_value_ioctl_10=ioctl(fb_link1, (unsigned long int)0x4602, &fb_fix);
  if(return_value_ioctl_10 == -1)
  {
    perror("ioctl FBIOGET_FSCREENINFO");
    exit(1);
  }

  if(fb_fix.visual == 4u || fb_ovar.bits_per_pixel == 8u)
  {
    signed int return_value_ioctl_11;
    return_value_ioctl_11=ioctl(fb_link1, (unsigned long int)0x4604, &ocmap);
    if(return_value_ioctl_11 == -1)
    {
      perror("ioctl FBIOGETCMAP");
      exit(1);
    }

  }

  signed int return_value_ioctl_12;
  return_value_ioctl_12=ioctl(tty, (unsigned long int)0x4B3B, &kd_mode);
  if(return_value_ioctl_12 == -1)
  {
    perror("ioctl KDGETMODE");
    exit(1);
  }

  signed int return_value_ioctl_13;
  return_value_ioctl_13=ioctl(tty, (unsigned long int)0x5601, &vt_omode);
  if(return_value_ioctl_13 == -1)
  {
    perror("ioctl VT_GETMODE");
    exit(1);
  }

  tcgetattr(tty, &term);
  fb_setmode(mode);
  signed int return_value_ioctl_14;
  return_value_ioctl_14=ioctl(fb_link1, (unsigned long int)0x4602, &fb_fix);
  if(return_value_ioctl_14 == -1)
  {
    perror("ioctl FBIOGET_FSCREENINFO");
    exit(1);
  }

  signed int return_value_getpagesize_15;
  void *return_value_mmap_16;
  signed int return_value_ioctl_18;
  if(!(fb_fix.type == 0u))
    fprintf(stderr, "can handle only packed pixel frame buffers\n");

  else
  {
    return_value_getpagesize_15=getpagesize();
    fb_mem_offset = (signed int)((unsigned long int)fb_fix.smem_start & (unsigned long int)(return_value_getpagesize_15 - 1));
    return_value_mmap_16=mmap((void *)0, (unsigned long int)(fb_fix.smem_len + (unsigned int)fb_mem_offset), 0x1 | 0x2, 0x01, fb_link1, (signed long int)0);
    fb_mem = (unsigned char *)return_value_mmap_16;
    if((signed long int)fb_mem == -1l)
      perror("mmap");

    else
    {
      if(!(fb_var.xoffset == 0u) || !(fb_var.yoffset == 0u))
      {
        fb_var.xoffset = (unsigned int)0;
        fb_var.yoffset = (unsigned int)0;
        signed int return_value_ioctl_17;
        return_value_ioctl_17=ioctl(fb_link1, (unsigned long int)0x4606, &fb_var);
        if(return_value_ioctl_17 == -1)
        {
          perror("ioctl FBIOPAN_DISPLAY");
          goto err;
        }

      }

      return_value_ioctl_18=ioctl(tty, (unsigned long int)0x4B3A, 0x01);
      if(return_value_ioctl_18 == -1)
        perror("ioctl KDSETMODE");

      else
      {
        fb_activate_current(tty);
        fb_memset((void *)(fb_mem + (signed long int)fb_mem_offset), 0, (unsigned long int)fb_fix.smem_len);
        return fb_link1;
      }
    }
  }

err:
  ;
  fb_cleanup();
  exit(1);
}

// fb_initcolors
// file console/fbtv.c line 230
static void fb_initcolors(signed int fd, signed int gray)
{
  if(fb_fix.visual == 4u || fb_var.bits_per_pixel == 8u)
  {
    signed int return_value_ioctl_1;
    return_value_ioctl_1=ioctl(fd, (unsigned long int)0x4604, &cmap);
    if(return_value_ioctl_1 == -1)
      perror("ioctl FBIOGETCMAP");

  }

  switch(fb_var.bits_per_pixel)
  {
    case (unsigned int)8:
    {
      if(!(gray == 0))
      {
        linear_palette(8, 8, 8);
        x11_native_format = 2;
      }

      else
      {
        dither_palette(5, 9, 5);
        x11_native_format = 1;
      }
      break;
    }
    case (unsigned int)15:

    case (unsigned int)16:
    {
      if(fb_fix.visual == 4u)
        linear_palette((signed int)fb_var.red.length, (signed int)fb_var.green.length, (signed int)fb_var.blue.length);

      x11_native_format = fb_var.green.length == (unsigned int)6 ? 4 : 3;
      break;
    }
    case (unsigned int)24:
    {
      if(fb_fix.visual == 4u)
        linear_palette(8, 8, 8);

      x11_native_format = 7;
      break;
    }
    case (unsigned int)32:
    {
      if(fb_fix.visual == 4u)
        linear_palette(8, 8, 8);

      x11_native_format = 8;
      break;
    }
    default:
    {
      fprintf(stderr, "Oops: %i bit/pixel ???\n", fb_var.bits_per_pixel);
      exit(1);
    }
  }
  if(fb_fix.visual == 4u || fb_var.bits_per_pixel == 8u)
  {
    signed int return_value_ioctl_2;
    return_value_ioctl_2=ioctl(fd, (unsigned long int)0x4605, &cmap);
    if(return_value_ioctl_2 == -1)
      perror("ioctl FBIOPUTCMAP");

  }

}

// fb_memset
// file console/fbtools.h line 18
void fb_memset(void *addr, signed int c, unsigned long int len)
{
  unsigned int i;
  unsigned int *p;
  i = (unsigned int)((c & 0xff) << 8);
  i = i | i << 16;
  len = len >> 2;
  p = (unsigned int *)addr;
  unsigned long int tmp_post_1;
  do
  {
    tmp_post_1 = len;
    len = len - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    *p = i;
    p = p + 1l;
  }
  while((_Bool)1);
}

// fb_setmode
// file console/fbtools.c line 173
static signed int fb_setmode(char *name)
{
  struct _IO_FILE *fp;
  char line[80l];
  char label[32l];
  char value[16l];
  signed int geometry = 0;
  signed int timings = 0;
  signed int err = -1;
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(fb_link1, (unsigned long int)0x4600, &fb_var);
  if(return_value_ioctl_1 == -1)
  {
    perror("ioctl FBIOGET_VSCREENINFO");
    exit(1);
  }

  char *return_value_fgets_2;
  signed int return_value_strcmp_21;
  char *return_value_fgets_3;
  char *return_value_strstr_4;
  signed int return_value_strcasecmp_7;
  signed int return_value_strcasecmp_9;
  signed int return_value_strcasecmp_11;
  signed int return_value_strcasecmp_13;
  signed int return_value_strcasecmp_15;
  signed int return_value_strcasecmp_17;
  if(name == ((char *)NULL))
    return -1;

  else
  {
    fp=fopen("/etc/fb.modes", "r");
    if(fp == ((struct _IO_FILE *)NULL))
      return -1;

    else
    {
      do
      {
        return_value_fgets_2=fgets(line, 79, fp);
        if(return_value_fgets_2 == ((char *)NULL))
          break;

        signed int return_value_sscanf_22;
        return_value_sscanf_22=sscanf(line, "mode \"%31[^\"]\"", (const void *)label);
        if(return_value_sscanf_22 == 1)
        {
          return_value_strcmp_21=strcmp(label, name);
          if(return_value_strcmp_21 == 0)
          {
            fb_var.sync = (unsigned int)0;
            fb_var.vmode = (unsigned int)0;
            do
            {
              return_value_fgets_3=fgets(line, 79, fp);
              if(return_value_fgets_3 == ((char *)NULL))
                break;

              return_value_strstr_4=strstr(line, "endmode");
              if(!(return_value_strstr_4 == ((char *)NULL)))
                break;

              signed int return_value_sscanf_5;
              return_value_sscanf_5=sscanf(line, " geometry %d %d %d %d %d", &fb_var.xres, &fb_var.yres, &fb_var.xres_virtual, &fb_var.yres_virtual, &fb_var.bits_per_pixel);
              if(return_value_sscanf_5 == 5)
                geometry = 1;

              signed int return_value_sscanf_6;
              return_value_sscanf_6=sscanf(line, " timings %d %d %d %d %d %d %d", &fb_var.pixclock, &fb_var.left_margin, &fb_var.right_margin, &fb_var.upper_margin, &fb_var.lower_margin, &fb_var.hsync_len, &fb_var.vsync_len);
              if(return_value_sscanf_6 == 7)
                timings = 1;

              signed int return_value_sscanf_8;
              return_value_sscanf_8=sscanf(line, " hsync %15s", (const void *)value);
              if(return_value_sscanf_8 == 1)
              {
                return_value_strcasecmp_7=strcasecmp(value, "high");
                if(return_value_strcasecmp_7 == 0)
                  fb_var.sync = fb_var.sync | (unsigned int)1;

              }

              signed int return_value_sscanf_10;
              return_value_sscanf_10=sscanf(line, " vsync %15s", (const void *)value);
              if(return_value_sscanf_10 == 1)
              {
                return_value_strcasecmp_9=strcasecmp(value, "high");
                if(return_value_strcasecmp_9 == 0)
                  fb_var.sync = fb_var.sync | (unsigned int)2;

              }

              signed int return_value_sscanf_12;
              return_value_sscanf_12=sscanf(line, " csync %15s", (const void *)value);
              if(return_value_sscanf_12 == 1)
              {
                return_value_strcasecmp_11=strcasecmp(value, "high");
                if(return_value_strcasecmp_11 == 0)
                  fb_var.sync = fb_var.sync | (unsigned int)8;

              }

              signed int return_value_sscanf_14;
              return_value_sscanf_14=sscanf(line, " extsync %15s", (const void *)value);
              if(return_value_sscanf_14 == 1)
              {
                return_value_strcasecmp_13=strcasecmp(value, "true");
                if(return_value_strcasecmp_13 == 0)
                  fb_var.sync = fb_var.sync | (unsigned int)4;

              }

              signed int return_value_sscanf_16;
              return_value_sscanf_16=sscanf(line, " laced %15s", (const void *)value);
              if(return_value_sscanf_16 == 1)
              {
                return_value_strcasecmp_15=strcasecmp(value, "true");
                if(return_value_strcasecmp_15 == 0)
                  fb_var.vmode = fb_var.vmode | (unsigned int)1;

              }

              signed int return_value_sscanf_18;
              return_value_sscanf_18=sscanf(line, " double %15s", (const void *)value);
              if(return_value_sscanf_18 == 1)
              {
                return_value_strcasecmp_17=strcasecmp(value, "true");
                if(return_value_strcasecmp_17 == 0)
                  fb_var.vmode = fb_var.vmode | (unsigned int)2;

              }

            }
            while((_Bool)1);
            if(geometry == 0 || timings == 0)
              goto out;

            fb_var.xoffset = (unsigned int)0;
            fb_var.yoffset = (unsigned int)0;
            signed int return_value_ioctl_19;
            return_value_ioctl_19=ioctl(fb_link1, (unsigned long int)0x4601, &fb_var);
            if(return_value_ioctl_19 == -1)
              perror("ioctl FBIOPUT_VSCREENINFO");

            signed int return_value_ioctl_20;
            return_value_ioctl_20=ioctl(fb_link1, (unsigned long int)0x4600, &fb_var);
            if(return_value_ioctl_20 == -1)
            {
              perror("ioctl FBIOGET_VSCREENINFO");
              exit(1);
            }

            err = 0;
            goto out;
          }

        }

      }
      while((_Bool)1);

    out:
      ;
      fclose(fp);
      return err;
    }
  }
}

// fb_setvt
// file console/fbtools.c line 251
static void fb_setvt(signed int vtno)
{
  struct vt_stat vts;
  char vtname[12l];
  if(!(vtno >= 0))
  {
    signed int return_value_ioctl_1;
    return_value_ioctl_1=ioctl(tty, (unsigned long int)0x5600, &vtno);
    if(return_value_ioctl_1 == -1 || vtno == -1)
    {
      perror("ioctl VT_OPENQRY");
      exit(1);
    }

  }

  vtno = vtno & 0xff;
  sprintf(vtname, devices->ttynr, vtno);
  unsigned int return_value_getuid_2;
  return_value_getuid_2=getuid();
  unsigned int return_value_getgid_3;
  return_value_getgid_3=getgid();
  chown(vtname, return_value_getuid_2, return_value_getgid_3);
  signed int return_value_access_6;
  return_value_access_6=access(vtname, 4 | 2);
  if(return_value_access_6 == -1)
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    fprintf(stderr, "access %s: %s\n", (const void *)vtname, return_value_strerror_5);
    exit(1);
  }

  signed int return_value_fork_7;
  return_value_fork_7=fork();
  if(!(return_value_fork_7 == 0))
  {
    if(return_value_fork_7 == -1)
      goto __CPROVER_DUMP_L5;

  }

  else
  {
    goto __CPROVER_DUMP_L7;

  __CPROVER_DUMP_L5:
    ;
    perror("fork");
    exit(1);
  }
  exit(0);

__CPROVER_DUMP_L7:
  ;
  close(tty);
  close(0);
  close(1);
  close(2);
  setsid();
  open(vtname, 02);
  dup(0);
  dup(0);
  signed int return_value_ioctl_8;
  return_value_ioctl_8=ioctl(tty, (unsigned long int)0x5603, &vts);
  if(return_value_ioctl_8 == -1)
  {
    perror("ioctl VT_GETSTATE");
    exit(1);
  }

  orig_vt_no = (signed int)vts.v_active;
  signed int return_value_ioctl_9;
  return_value_ioctl_9=ioctl(tty, (unsigned long int)0x5606, vtno);
  if(return_value_ioctl_9 == -1)
  {
    perror("ioctl VT_ACTIVATE");
    exit(1);
  }

  signed int return_value_ioctl_10;
  return_value_ioctl_10=ioctl(tty, (unsigned long int)0x5607, vtno);
  if(return_value_ioctl_10 == -1)
  {
    perror("ioctl VT_WAITACTIVE");
    exit(1);
  }

}

// fb_switch_acquire
// file console/fbtools.h line 23
void fb_switch_acquire(void)
{
  ioctl(tty, (unsigned long int)0x5605, 0x02);
  fb_switch_state = 0;
  if(!(debug == 0))
    write(2, (const void *)"vt: acquire\n", (unsigned long int)12);

}

// fb_switch_init
// file console/fbtools.h line 21
signed int fb_switch_init(void)
{
  struct sigaction act;
  struct sigaction old;
  memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
  act.__sigaction_handler.sa_handler = fb_switch_signal;
  sigemptyset(&act.sa_mask);
  sigaction(10, &act, &old);
  sigaction(12, &act, &old);
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(tty, (unsigned long int)0x5601, &vt_mode);
  if(return_value_ioctl_1 == -1)
  {
    perror("ioctl VT_GETMODE");
    exit(1);
  }

  vt_mode.mode = (char)0x01;
  vt_mode.waitv = (char)0;
  vt_mode.relsig = (signed short int)10;
  vt_mode.acqsig = (signed short int)12;
  signed int return_value_ioctl_2;
  return_value_ioctl_2=ioctl(tty, (unsigned long int)0x5602, &vt_mode);
  if(return_value_ioctl_2 == -1)
  {
    perror("ioctl VT_SETMODE");
    exit(1);
  }

  return 0;
}

// fb_switch_release
// file console/fbtools.h line 22
void fb_switch_release(void)
{
  ioctl(tty, (unsigned long int)0x5605, 1);
  fb_switch_state = 2;
  if(!(debug == 0))
    write(2, (const void *)"vt: release\n", (unsigned long int)12);

}

// fb_switch_signal
// file console/fbtools.c line 92
static void fb_switch_signal(signed int signal)
{
  if(signal == 10)
  {
    fb_switch_state = 1;
    if(!(debug == 0))
      write(2, (const void *)"vt: SIGUSR1\n", (unsigned long int)12);

  }

  if(signal == 12)
  {
    fb_switch_state = 3;
    if(!(debug == 0))
      write(2, (const void *)"vt: SIGUSR2\n", (unsigned long int)12);

  }

}

// fget_associated_device
// file common/get_media_devices.c line 501
const char * fget_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const signed int fd_seek_device, const enum device_type seek_type)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  struct stat f_status;
  unsigned int dev_major;
  unsigned int dev_minor;
  signed int i;
  signed int found = 0;
  char *prev;
  signed int return_value_fstat_1;
  return_value_fstat_1=fstat(fd_seek_device, &f_status);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(return_value_fstat_1 == 0))
  {
    perror("Can't get file status");
    return (const char *)(void *)0;
  }

  else
    if(!((61440u & f_status.st_mode) == 8192u))
    {
      fprintf(stderr, "File descriptor is not a char device\n");
      return (const char *)(void *)0;
    }

    else
    {
      dev_major=gnu_dev_major(f_status.st_rdev);
      dev_minor=gnu_dev_minor(f_status.st_rdev);
      i = 0;
      for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
      {
        if(!(last_seek == ((const char *)NULL)))
        {
          if(!(md_ptr->type == seek_type))
            goto __CPROVER_DUMP_L4;

          if(!(md_ptr->major == dev_major))
            goto __CPROVER_DUMP_L4;

          if(!(md_ptr->minor == dev_minor))
            goto __CPROVER_DUMP_L4;

          found = 1;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(!(found == 0) || last_seek == ((const char *)NULL))
          {
            if(md_ptr->type == seek_type)
            {
              if(md_ptr->major == dev_major)
              {
                if(md_ptr->minor == dev_minor)
                  break;

              }

            }

          }

        }
        i = i + 1;
      }
      if((unsigned int)i == md->md_size)
        return (const char *)(void *)0;

      else
      {
        i = i + 1;
        prev = md_ptr->device;
        md_ptr = md_ptr + 1l;
        do
        {
          if(!((unsigned int)i >= md->md_size))
          {
            return_value_strcmp_2=strcmp(prev, md_ptr->device);
            tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_3 = (_Bool)0;
          if(!tmp_if_expr_3)
            break;

          if(!(last_seek == ((const char *)NULL)))
          {
            if(!(md_ptr->type == seek_type))
              goto __CPROVER_DUMP_L11;

            if(!(md_ptr->major == dev_major))
              goto __CPROVER_DUMP_L11;

            if(!(md_ptr->minor == dev_minor))
              goto __CPROVER_DUMP_L11;

            found = 1;
          }

          else
          {

          __CPROVER_DUMP_L11:
            ;
            if(!(found == 0) || last_seek == ((const char *)NULL))
            {
              if(md_ptr->type == desired_type)
                return md_ptr->node;

            }

          }
          i = i + 1;
          md_ptr = md_ptr + 1l;
        }
        while((_Bool)1);
        return (const char *)(void *)0;
      }
    }
}

// fifo_get
// file common/capture.c line 81
void * fifo_get(struct FIFO *fifo)
{
  void *data;
  pthread_mutex_lock(&fifo->lock);
  while(fifo->write == fifo->read)
  {
    if(fifo->writers == fifo->eof)
      break;

    pthread_cond_wait(&fifo->hasdata, &fifo->lock);
  }
  signed int return_value_getpid_1;
  if(fifo->write == fifo->read)
  {
    pthread_cond_signal(&fifo->hasdata);
    pthread_mutex_unlock(&fifo->lock);
    return (void *)0;
  }

  else
  {
    if(debug >= 2)
    {
      return_value_getpid_1=getpid();
      fprintf(stderr, "get %s %d=%p [pid=%d]\n", fifo->name, fifo->read, fifo->data[(signed long int)fifo->read], return_value_getpid_1);
    }

    data = (void *)fifo->data[(signed long int)fifo->read];
    fifo->read = fifo->read + 1;
    if(fifo->read >= fifo->slots)
      fifo->read = 0;

    pthread_mutex_unlock(&fifo->lock);
    return data;
  }
}

// fifo_init
// file common/capture.c line 31
void fifo_init(struct FIFO *fifo, char *name, signed int slots, signed int writers)
{
  pthread_mutex_init(&fifo->lock, (const union anonymous_9 *)(void *)0);
  pthread_cond_init(&fifo->hasdata, (const union anonymous_9 *)(void *)0);
  fifo->name = name;
  fifo->slots = slots;
  fifo->writers = writers;
  fifo->read = 0;
  fifo->write = 0;
  fifo->eof = 0;
  fifo->max = 0;
}

// fifo_put
// file common/capture.c line 45
signed int fifo_put(struct FIFO *fifo, void *data)
{
  signed int full;
  pthread_mutex_lock(&fifo->lock);
  signed int return_value_getpid_1;
  if(data == NULL)
  {
    fifo->eof = fifo->eof + 1;
    if(!(debug == 0))
      fprintf(stderr, "fifo %s: EOF %d/%d\n", fifo->name, fifo->eof, fifo->writers);

    if(fifo->writers == fifo->eof)
      pthread_cond_broadcast(&fifo->hasdata);

    pthread_mutex_unlock(&fifo->lock);
    return 0;
  }

  else
    if((1 + fifo->write) % fifo->slots == fifo->read)
    {
      pthread_mutex_unlock(&fifo->lock);
      fprintf(stderr, "fifo %s is full\n", fifo->name);
      return -1;
    }

    else
    {
      if(debug >= 2)
      {
        return_value_getpid_1=getpid();
        fprintf(stderr, "put %s %d=%p [pid=%d]\n", fifo->name, fifo->write, data, return_value_getpid_1);
      }

      fifo->data[(signed long int)fifo->write] = (unsigned char *)data;
      fifo->write = fifo->write + 1;
      full = ((fifo->write + fifo->slots) - fifo->read) % fifo->slots;
      if(!(fifo->max >= full))
        fifo->max = full;

      if(fifo->write >= fifo->slots)
        fifo->write = 0;

      pthread_cond_signal(&fifo->hasdata);
      pthread_mutex_unlock(&fifo->lock);
      return 0;
    }
}

// files_audio
// file libng/writefile.c line 364
static signed int files_audio(void *handle, struct ng_audio_buf *buf)
{
  struct files_handle *h = (struct files_handle *)handle;
  signed long int return_value_write_1;
  return_value_write_1=write(h->wav_fd, (const void *)buf->data, (unsigned long int)buf->size);
  if(!((signed long int)buf->size == return_value_write_1))
    return -1;

  else
  {
    h->wav_size = h->wav_size + buf->size;
    return 0;
  }
}

// files_close
// file libng/writefile.c line 374
static signed int files_close(void *handle)
{
  struct files_handle *h = (struct files_handle *)handle;
  if(!(h->audio.fmtid == 0u))
  {
    wav_stop_write(h->wav_fd, &h->wav_header, h->wav_size);
    close(h->wav_fd);
  }

  free((void *)h);
  return 0;
}

// files_open
// file libng/writefile.c line 298
static void * files_open(char *filesname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio)
{
  struct files_handle *h;
  if(!(video->fmtid == 0u))
  {
    if(!(filesname == ((char *)NULL)))
      goto __CPROVER_DUMP_L1;

    return (void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct files_handle) /*4176ul*/ );
    h = (struct files_handle *)return_value_malloc_1;
    if(h == ((struct files_handle *)NULL))
      return (void *)0;

    else
    {
      memset((void *)h, 0, sizeof(struct files_handle) /*4176ul*/ );
      h->video = *video;
      h->audio = *audio;
      if(!(filesname == ((char *)NULL)))
        strcpy(h->file, filesname);

      if(!(h->audio.fmtid == 0u))
      {
        h->wav_fd=open(audioname, 0100 | 02 | 01000, 0666);
        if(h->wav_fd == -1)
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          char *return_value_strerror_3;
          return_value_strerror_3=strerror(*return_value___errno_location_2);
          fprintf(stderr, "open %s: %s\n", audioname, return_value_strerror_3);
          free((void *)h);
          return (void *)0;
        }

        wav_start_write(h->wav_fd, &h->wav_header, &h->audio);
      }

      return (void *)h;
    }
  }
}

// files_video
// file libng/writefile.c line 330
static signed int files_video(void *handle, struct ng_video_buf *buf)
{
  struct files_handle *h = (struct files_handle *)handle;
  signed int rc = -1;
  struct _IO_FILE *fp;
  if(!(h->gotcha == 0))
  {
    fprintf(stderr, "Oops: can't count up file names any more\n");
    return -1;
  }

  else
  {
    switch(h->video.fmtid)
    {
      case (unsigned int)9:
      {
        rc=write_ppm(h->file, buf);
        break;
      }
      case (unsigned int)2:
      {
        rc=write_pgm(h->file, buf);
        break;
      }
      case (unsigned int)17:
      {
        fp=fopen(h->file, "w");
        if(fp == ((struct _IO_FILE *)NULL))
        {
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          char *return_value_strerror_2;
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          fprintf(stderr, "grab: can't open %s: %s\n", (const void *)h->file, return_value_strerror_2);
          rc = -1;
        }

        else
        {
          fwrite((const void *)buf->data, buf->size, (unsigned long int)1, fp);
          fclose(fp);
          rc = 0;
        }
      }
    }
    signed int return_value_patch_up_3;
    return_value_patch_up_3=patch_up(h->file);
    if(!(return_value_patch_up_3 == 1))
      h->gotcha = 1;

    return rc;
  }
}

// flushit
// file common/capture.c line 106
static void * flushit(void *arg)
{
  signed int old;
  pthread_setcancelstate(0, &old);
  pthread_setcanceltype(1, &old);
  do
  {
    sleep((unsigned int)1);
    sync();
  }
  while((_Bool)1);
  return (void *)0;
}

// free_media_devices
// file ./common/get_media_devices.h line 92
void free_media_devices(void *opaque)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i = 0;
  for( ; !((unsigned int)i >= md->md_size); i = i + 1)
  {
    free((void *)md_ptr->node);
    free((void *)md_ptr->device);
    md_ptr = md_ptr + 1l;
  }
  free((void *)md->md_entry);
  free((void *)md);
}

// freq_init
// file ./common/frequencies.h line 105
void freq_init(void)
{
  char line[256l];
  char value[256l];
  struct _IO_FILE *fp;
  signed int nr;
  signed int i;
  signed int j;
  fp=fopen("/usr/share/xawtv/Index.map", "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    perror("open /usr/share/xawtv/Index.map");
    exit(1);
  }

  if(!(debug == 0))
    fprintf(stderr, "freq: reading /usr/share/xawtv/Index.map\n");

  nr = 0;
  i = 0;
  char *return_value_fgets_1;
  do
  {
    return_value_fgets_1=fgets(line, 255, fp);
    if(return_value_fgets_1 == ((char *)NULL))
      break;

    nr = nr + 1;
    _Bool tmp_if_expr_2;
    if((signed int)line[0l] == 10)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)line[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_3)
    {
      signed int return_value_sscanf_5;
      return_value_sscanf_5=sscanf(line, "[%255[^]]]", (const void *)value);
      if(return_value_sscanf_5 == 1)
      {
        void *return_value_realloc_4;
        return_value_realloc_4=realloc((void *)chanlists, (unsigned long int)(i + 2) * sizeof(struct CHANLISTS) /*32ul*/ );
        chanlists = (struct CHANLISTS *)return_value_realloc_4;
        memset((void *)(chanlists + (signed long int)i), 0, (unsigned long int)2 * sizeof(struct CHANLISTS) /*32ul*/ );
        (chanlists + (signed long int)i)->name=strdup(value);
        i = i + 1;
        continue;
      }

      if(chanlists == ((struct CHANLISTS *)NULL))
        fprintf(stderr, "%s:%d: error: no section\n", (const void *)"/usr/share/xawtv/Index.map", nr);

      else
      {
        signed int return_value_sscanf_6;
        return_value_sscanf_6=sscanf(line, " file = %255[^\n]", (const void *)value);
        if(return_value_sscanf_6 == 1)
          (chanlists + (signed long int)(i - 1))->filename=strdup(value);

        else
          fprintf(stderr, "%s:%d: syntax error\n", (const void *)"/usr/share/xawtv/Index.map", nr);
      }
    }

  }
  while((_Bool)1);
  fclose(fp);
  void *return_value_malloc_7;
  return_value_malloc_7=malloc((unsigned long int)(i + 1) * sizeof(struct STRTAB) /*16ul*/ );
  chanlist_names = (struct STRTAB *)return_value_malloc_7;
  j = 0;
  for( ; !(j >= i); j = j + 1)
  {
    (chanlist_names + (signed long int)j)->nr = (signed long int)j;
    (chanlist_names + (signed long int)j)->str = (chanlists + (signed long int)j)->name;
  }
  (chanlist_names + (signed long int)j)->nr = (signed long int)-1;
  (chanlist_names + (signed long int)j)->str = (const char *)(void *)0;
}

// freq_newtab
// file common/frequencies.h line 106
void freq_newtab(signed int n)
{
  if(!(debug == 0))
    fprintf(stderr, "freq: newtab %d\n", n);

  if((chanlists + (signed long int)n)->list == ((struct CHANLIST *)NULL))
    (chanlists + (signed long int)n)->count=freq_readlist(&(chanlists + (signed long int)n)->list, 0, (chanlists + (signed long int)n)->filename);

  chantab = n;
}

// freq_readlist
// file common/frequencies.c line 78
static signed int freq_readlist(struct CHANLIST **list, signed int n, char *name)
{
  char line[256l];
  char value[256l];
  char filename[256l];
  struct _IO_FILE *fp;
  signed int nr;
  sprintf(filename, "%s/%s", (const void *)"/usr/share/xawtv", name);
  fp=fopen(filename, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "open %s: %s\n", (const void *)filename, return_value_strerror_2);
    exit(1);
  }

  if(!(debug == 0))
    fprintf(stderr, "freq: reading %s\n", (const void *)filename);

  nr = 0;
  char *return_value_fgets_3;
  do
  {
    return_value_fgets_3=fgets(line, 255, fp);
    if(return_value_fgets_3 == ((char *)NULL))
      break;

    nr = nr + 1;
    signed int return_value_sscanf_4;
    return_value_sscanf_4=sscanf(line, "# include \"%[^\"]\"", (const void *)value);
    if(return_value_sscanf_4 == 1)
      n=freq_readlist(list, n, value);

    else
    {
      _Bool tmp_if_expr_5;
      if((signed int)line[0l] == 10)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_6;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = (signed int)line[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_6)
      {
        signed int return_value_sscanf_8;
        return_value_sscanf_8=sscanf(line, "[%255[^]]]", (const void *)value);
        if(return_value_sscanf_8 == 1)
        {
          if(n % 16 == 0)
          {
            void *return_value_realloc_7;
            return_value_realloc_7=realloc((void *)*list, (unsigned long int)(n + 16) * sizeof(struct CHANLIST) /*16ul*/ );
            *list = (struct CHANLIST *)return_value_realloc_7;
            memset((void *)(*list + (signed long int)n), 0, (unsigned long int)16 * sizeof(struct CHANLIST) /*16ul*/ );
          }

          (*list + (signed long int)n)->name=strdup(value);
          n = n + 1;
        }

        else
          if(n == 0)
            fprintf(stderr, "%s:%d: error: no section\n", (const void *)filename, nr);

          else
          {
            signed int return_value_sscanf_10;
            return_value_sscanf_10=sscanf(line, " freq = %255[^\n]", (const void *)value);
            if(return_value_sscanf_10 == 1)
            {
              signed int return_value_atoi_9;
              return_value_atoi_9=atoi(value);
              (*list + (signed long int)(n - 1))->freq = (unsigned int)return_value_atoi_9;
              continue;
            }

            fprintf(stderr, "%s:%d: syntax error\n", (const void *)filename, nr);
          }
      }

    }
  }
  while((_Bool)1);
  fclose(fp);
  return n;
}

// fs_consolefont
// file console/fs.h line 45
struct fs_font * fs_consolefont(char **filename)
{
  signed int i;
  char *h;
  char command[256l];
  struct fs_font *fs_consolefont__1__f = (struct fs_font *)(void *)0;
  struct _IO_FILE *fp;
  if(filename == ((char **)NULL))
    filename = default_font;

  i = 0;
  for( ; !(filename[(signed long int)i] == ((char *)NULL)); i = i + 1)
  {
    signed int return_value_access_1;
    return_value_access_1=access(filename[(signed long int)i], 4);
    if(!(return_value_access_1 == -1))
      break;

  }
  signed int return_value_fgetc_7;
  if(filename[(signed long int)i] == ((char *)NULL))
  {
    fprintf(stderr, "can't find console font file\n");
    return (struct fs_font *)(void *)0;
  }

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(filename[(signed long int)i]);
    h = (filename[(signed long int)i] + (signed long int)return_value_strlen_2) - (signed long int)3;
    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(h, ".gz");
    if(return_value_strcmp_3 == 0)
    {
      sprintf(command, "zcat %s", filename[(signed long int)i]);
      fp=popen(command, "r");
    }

    else
      fp=fopen(filename[(signed long int)i], "r");
    if(fp == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      fprintf(stderr, "can't open %s: %s\n", filename[(signed long int)i], return_value_strerror_5);
      return (struct fs_font *)(void *)0;
    }

    signed int return_value_fgetc_6;
    return_value_fgetc_6=fgetc(fp);
    _Bool tmp_if_expr_8;
    if(!(return_value_fgetc_6 == 0x36))
      tmp_if_expr_8 = (_Bool)1;

    else
    {
      return_value_fgetc_7=fgetc(fp);
      tmp_if_expr_8 = return_value_fgetc_7 != 0x04 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_8)
    {
      fprintf(stderr, "can't use font %s\n", filename[(signed long int)i]);
      return (struct fs_font *)(void *)0;
    }

    else
    {
      fprintf(stderr, "using linux console font \"%s\"\n", filename[(signed long int)i]);
      void *return_value_malloc_9;
      return_value_malloc_9=malloc(sizeof(struct fs_font) /*72ul*/ );
      fs_consolefont__1__f = (struct fs_font *)return_value_malloc_9;
      memset((void *)fs_consolefont__1__f, 0, sizeof(struct fs_font) /*72ul*/ );
      fgetc(fp);
      fs_consolefont__1__f->maxenc = 256;
      fs_consolefont__1__f->width = 8;
      fs_consolefont__1__f->height=fgetc(fp);
      fs_consolefont__1__f->fontHeader.min_bounds.left = (signed short int)0;
      fs_consolefont__1__f->fontHeader.max_bounds.right = (signed short int)fs_consolefont__1__f->width;
      fs_consolefont__1__f->fontHeader.max_bounds.descent = (signed short int)0;
      fs_consolefont__1__f->fontHeader.max_bounds.ascent = (signed short int)fs_consolefont__1__f->height;
      void *return_value_malloc_10;
      return_value_malloc_10=malloc((unsigned long int)(fs_consolefont__1__f->height * 256));
      fs_consolefont__1__f->glyphs = (unsigned char *)return_value_malloc_10;
      void *return_value_malloc_11;
      return_value_malloc_11=malloc(sizeof(struct _FSXCharInfo) /*10ul*/  * (unsigned long int)256);
      fs_consolefont__1__f->extents = (struct _FSXCharInfo *)return_value_malloc_11;
      fread((void *)fs_consolefont__1__f->glyphs, (unsigned long int)256, (unsigned long int)fs_consolefont__1__f->height, fp);
      fclose(fp);
      void *return_value_malloc_12;
      return_value_malloc_12=malloc(sizeof(struct _FSXCharInfo *) /*8ul*/  * (unsigned long int)256);
      fs_consolefont__1__f->eindex = (struct _FSXCharInfo **)return_value_malloc_12;
      void *return_value_malloc_13;
      return_value_malloc_13=malloc(sizeof(unsigned char *) /*8ul*/  * (unsigned long int)256);
      fs_consolefont__1__f->gindex = (unsigned char **)return_value_malloc_13;
      i = 0;
      for( ; !(i >= 256); i = i + 1)
      {
        fs_consolefont__1__f->eindex[(signed long int)i] = fs_consolefont__1__f->extents + (signed long int)i;
        fs_consolefont__1__f->gindex[(signed long int)i] = fs_consolefont__1__f->glyphs + (signed long int)(i * fs_consolefont__1__f->height);
        fs_consolefont__1__f->eindex[(signed long int)i]->left = (signed short int)0;
        fs_consolefont__1__f->eindex[(signed long int)i]->right = (signed short int)7;
        fs_consolefont__1__f->eindex[(signed long int)i]->width = (signed short int)8;
        fs_consolefont__1__f->eindex[(signed long int)i]->descent = (signed short int)0;
        fs_consolefont__1__f->eindex[(signed long int)i]->ascent = (signed short int)fs_consolefont__1__f->height;
      }
      return fs_consolefont__1__f;
    }
  }
}

// fs_free
// file console/fs.c line 186
void fs_free(struct fs_font *f)
{
  if(!(f->gindex == ((unsigned char **)NULL)))
    free((void *)f->gindex);

  free((void *)f);
}

// fs_init_fb
// file console/fs.h line 33
signed int fs_init_fb(signed int white8)
{
  switch(fb_var.bits_per_pixel)
  {
    case (unsigned int)8:
    {
      white = (unsigned int)white8;
      black = (unsigned int)0;
      bpp = (unsigned int)1;
      setpixel = setpixel1;
      break;
    }
    case (unsigned int)15:

    case (unsigned int)16:
    {
      if(fb_var.green.length == 6u)
        white = (unsigned int)0xffff;

      else
        white = (unsigned int)0x7fff;
      black = (unsigned int)0;
      bpp = (unsigned int)2;
      setpixel = setpixel2;
      break;
    }
    case (unsigned int)24:
    {
      white = (unsigned int)0xffffff;
      black = (unsigned int)0;
      bpp = fb_var.bits_per_pixel / (unsigned int)8;
      setpixel = setpixel3;
      break;
    }
    case (unsigned int)32:
    {
      white = (unsigned int)0xffffff;
      black = (unsigned int)0;
      bpp = fb_var.bits_per_pixel / (unsigned int)8;
      setpixel = setpixel4;
      break;
    }
    default:
    {
      fprintf(stderr, "Oops: %i bit/pixel ???\n", fb_var.bits_per_pixel);
      return -1;
    }
  }
  return 0;
}

// fs_puts
// file console/fs.h line 36
signed int fs_puts(struct fs_font *f, unsigned int x, unsigned int y, unsigned char *str)
{
  unsigned char *pos;
  unsigned char *start;
  signed int i;
  signed int fs_puts__1__c;
  signed int j;
  signed int w;
  pos = fb_mem + (signed long int)fb_mem_offset;
  pos = pos + (signed long int)(fb_fix.line_length * y);
  i = 0;
  for( ; !((signed int)str[(signed long int)i] == 0); i = i + 1)
  {
    fs_puts__1__c = (signed int)str[(signed long int)i];
    if(!(f->eindex[(signed long int)fs_puts__1__c] == ((struct _FSXCharInfo *)NULL)))
    {
      start = pos + (signed long int)(x * bpp) + (signed long int)((unsigned int)f->fontHeader.max_bounds.descent * fb_fix.line_length);
      w = (signed int)((unsigned int)((signed int)f->eindex[(signed long int)fs_puts__1__c]->width + 1) * bpp);
      j = 0;
      for( ; !(j >= f->height); j = j + 1)
      {
        memset((void *)start, 0, (unsigned long int)w);
        start = start + (signed long int)fb_fix.line_length;
      }
      start = pos + (signed long int)(x * bpp) + (signed long int)(fb_fix.line_length * (unsigned int)(f->height - (signed int)f->eindex[(signed long int)fs_puts__1__c]->ascent));
      fs_render_fb(start, (signed int)fb_fix.line_length, f->eindex[(signed long int)fs_puts__1__c], f->gindex[(signed long int)fs_puts__1__c]);
      x = x + (unsigned int)f->eindex[(signed long int)fs_puts__1__c]->width;
      if(!(fb_var.xres + -((unsigned int)f->width) >= x))
        return -1;

    }

  }
  return (signed int)x;
}

// fs_render_fb
// file console/fs.c line 104
void fs_render_fb(unsigned char *ptr, signed int pitch, struct _FSXCharInfo *charInfo, unsigned char *data)
{
  signed int row;
  signed int bit;
  signed int bpr;
  signed int x;
  bpr = ((signed int)charInfo->right - (signed int)charInfo->left) + 7 >> 3;
  row = 0;
  for( ; !(row >= (signed int)charInfo->ascent + (signed int)charInfo->descent); row = row + 1)
  {
    x = 0;
    bit = 0;
    for( ; !(bit >= (signed int)charInfo->right + -((signed int)charInfo->left)); bit = bit + 1)
    {
      if(!((fs_masktab[(signed long int)(7 & bit)] & (unsigned int)data[(signed long int)(bit >> 3)]) == 0u))
        setpixel((void *)(ptr + (signed long int)x), white);

      x = x + (signed int)bpp;
    }
    data = data + (signed long int)bpr;
    ptr = ptr + (signed long int)pitch;
  }
}

// fs_render_tty
// file console/fs.c line 165
void fs_render_tty(struct _FSXCharInfo *charInfo, unsigned char *data)
{
  signed int bpr;
  signed int row;
  signed int bit;
  signed int on;
  bpr = ((signed int)charInfo->right - (signed int)charInfo->left) + 7 >> 3;
  row = 0;
  for( ; !(row >= (signed int)charInfo->ascent + (signed int)charInfo->descent); row = row + 1)
  {
    fprintf(stdout, "|");
    bit = 0;
    for( ; !(bit >= (signed int)charInfo->right + -((signed int)charInfo->left)); bit = bit + 1)
    {
      on = (signed int)((unsigned int)data[(signed long int)(bit >> 3)] & fs_masktab[(signed long int)(bit & 7)]);
      fprintf(stdout, "%s", on != 0 ? "##" : "  ");
    }
    fprintf(stdout, "|\n");
    data = data + (signed long int)bpr;
  }
  fprintf(stdout, "--\n");
}

// fs_textwidth
// file console/fs.h line 38
signed int fs_textwidth(struct fs_font *f, unsigned char *str)
{
  signed int width = 0;
  signed int i;
  signed int fs_textwidth__1__c;
  i = 0;
  for( ; !((signed int)str[(signed long int)i] == 0); i = i + 1)
  {
    fs_textwidth__1__c = (signed int)str[(signed long int)i];
    if(!(f->eindex[(signed long int)fs_textwidth__1__c] == ((struct _FSXCharInfo *)NULL)))
      width = width + (signed int)f->eindex[(signed long int)fs_textwidth__1__c]->width;

  }
  return width;
}

// fullscreen_handler
// file common/commands.c line 1158
static signed int fullscreen_handler(char *name, signed int argc, char **argv)
{
  if(!(fullscreen_hook == ((void (*)(void))NULL)))
    fullscreen_hook();

  return 0;
}

// get_associated_device
// file ./common/get_media_devices.h line 124
const char * get_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const char *seek_device, const enum device_type seek_type)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i;
  signed int found = 0;
  char *prev;
  char *p;
  _Bool tmp_if_expr_7;
  if(!((signed int)seek_type == NONE))
    tmp_if_expr_7 = seek_device[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  signed int return_value_strcmp_1;
  signed int return_value_strcmp_2;
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_6;
  if(tmp_if_expr_7)
  {
    p=strrchr(seek_device, 47);
    if(!(p == ((char *)NULL)))
      seek_device = p + (signed long int)1;

    i = 0;
    for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
    {
      if(!(last_seek == ((const char *)NULL)))
      {
        if(md_ptr->type == seek_type)
        {
          return_value_strcmp_1=strcmp(md_ptr->node, last_seek);
          if(return_value_strcmp_1 == 0)
          {
            found = 1;
            goto __CPROVER_DUMP_L10;
          }

        }

      }

      if(!(found == 0) || last_seek == ((const char *)NULL))
      {
        if(md_ptr->type == seek_type)
        {
          return_value_strcmp_2=strcmp(seek_device, md_ptr->node);
          if(return_value_strcmp_2 == 0)
            break;

        }

      }


    __CPROVER_DUMP_L10:
      ;
      i = i + 1;
    }
    if((unsigned int)i == md->md_size)
      return (const char *)(void *)0;

    i = i + 1;
    prev = md_ptr->device;
    md_ptr = md_ptr + 1l;
    do
    {
      if(!((unsigned int)i >= md->md_size))
      {
        return_value_strcmp_3=strcmp(prev, md_ptr->device);
        tmp_if_expr_4 = !(return_value_strcmp_3 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(!tmp_if_expr_4)
        break;

      if(!(last_seek == ((const char *)NULL)))
      {
        if(md_ptr->type == seek_type)
        {
          return_value_strcmp_5=strcmp(md_ptr->node, last_seek);
          if(return_value_strcmp_5 == 0)
          {
            found = 1;
            goto __CPROVER_DUMP_L20;
          }

        }

      }

      if(!(found == 0) || last_seek == ((const char *)NULL))
      {
        if(md_ptr->type == desired_type)
          return md_ptr->node;

      }


    __CPROVER_DUMP_L20:
      ;
      i = i + 1;
      md_ptr = md_ptr + 1l;
    }
    while((_Bool)1);
  }

  else
  {
    i = 0;
    for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
    {
      if(!(last_seek == ((const char *)NULL)))
      {
        return_value_strcmp_6=strcmp(md_ptr->node, last_seek);
        if(return_value_strcmp_6 == 0)
        {
          found = 1;
          goto __CPROVER_DUMP_L28;
        }

      }

      if(!(found == 0) || last_seek == ((const char *)NULL))
      {
        if(md_ptr->type == desired_type)
          return md_ptr->node;

      }


    __CPROVER_DUMP_L28:
      ;
      i = i + 1;
    }
  }
  return (const char *)(void *)0;
}

// get_bus
// file common/get_media_devices.c line 96
static enum bus_type get_bus(char *device)
{
  char file[4096l];
  char s[1024l];
  struct _IO_FILE *get_bus__1__f;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(device, "/sys/devices/virtual");
  if(return_value_strcmp_1 == 0)
    return (enum bus_type)MEDIA_BUS_VIRTUAL;

  else
  {
    snprintf(file, (unsigned long int)4096, "%s/modalias", device);
    get_bus__1__f=fopen(file, "r");
    if(get_bus__1__f == ((struct _IO_FILE *)NULL))
      return (enum bus_type)MEDIA_BUS_UNKNOWN;

    else
    {
      char *return_value_fgets_2;
      return_value_fgets_2=fgets(s, (signed int)sizeof(char [1024l]) /*1024ul*/ , get_bus__1__f);
      if(return_value_fgets_2 == ((char *)NULL))
        return (enum bus_type)MEDIA_BUS_UNKNOWN;

      else
      {
        fclose(get_bus__1__f);
        signed int return_value_strncmp_3;
        return_value_strncmp_3=strncmp(s, "pci", (unsigned long int)3);
        if(return_value_strncmp_3 == 0)
          return (enum bus_type)MEDIA_BUS_PCI;

        else
        {
          signed int return_value_strncmp_4;
          return_value_strncmp_4=strncmp(s, "usb", (unsigned long int)3);
          if(return_value_strncmp_4 == 0)
            return (enum bus_type)MEDIA_BUS_USB;

          else
            return (enum bus_type)MEDIA_BUS_UNKNOWN;
        }
      }
    }
  }
}

// get_class
// file common/get_media_devices.c line 121
static signed int get_class(char *class, struct media_device_entry **md, unsigned int *md_size, signed int (*fill)(struct media_device_entry *))
{
  struct __dirstream *dir;
  struct dirent *entry;
  char dname[4096l];
  char fname[4096l];
  char get_class__1__link[4096l];
  char virt_dev[60l];
  signed int err = -2;
  struct media_device_entry *md_ptr = (struct media_device_entry *)(void *)0;
  char *p;
  char *device;
  enum bus_type bus;
  snprintf(dname, (unsigned long int)4096, "/sys/class/%s", class);
  dir=opendir(dname);
  char *return_value_strchr_1;
  if(dir == ((struct __dirstream *)NULL))
    return 0;

  else
  {
    entry=readdir(dir);
    while(!(entry == ((struct dirent *)NULL)))
    {
      if(!((signed int)entry->d_name[0l] == 46))
      {
        snprintf(fname, (unsigned long int)4096, "%s/%s", (const void *)dname, (const void *)entry->d_name);
        char *return_value_realpath_4;
        return_value_realpath_4=realpath(fname, get_class__1__link);
        if(!(return_value_realpath_4 == ((char *)NULL)))
        {
          device = get_class__1__link;
          p=strstr(device, class);
          if(p == ((char *)NULL))
            goto __CPROVER_DUMP_L9;

          *(p - (signed long int)1) = (char)0;
          bus=get_bus(device);
          device = device + (signed long int)13;
          switch((signed int)bus)
          {
            case MEDIA_BUS_PCI:
            {
              p=strrchr(device, 46);
              if(p == ((char *)NULL))
                goto __CPROVER_DUMP_L9;

              *p = (char)0;
              break;
            }
            case MEDIA_BUS_USB:
            {
              p=strrchr(device, 47);
              if(p == ((char *)NULL))
                goto __CPROVER_DUMP_L9;

              return_value_strchr_1=strchr(p, 58);
              if(return_value_strchr_1 == ((char *)NULL))
                break;

              *p = (char)0;
              break;
            }
            case MEDIA_BUS_VIRTUAL:
            {
              static signed int virtual = 0;
              signed int tmp_post_2 = virtual;
              virtual = virtual + 1;
              sprintf(virt_dev, "virtual%d", tmp_post_2);
              device = virt_dev;
              break;
            }
            case MEDIA_BUS_UNKNOWN:
              ;
          }
          void *return_value_realloc_3;
          return_value_realloc_3=realloc((void *)*md, (unsigned long int)(*md_size + (unsigned int)1) * sizeof(struct media_device_entry) /*32ul*/ );
          *md = (struct media_device_entry *)return_value_realloc_3;
          if(*md == ((struct media_device_entry *)NULL))
            goto error;

          md_ptr = *md + (signed long int)*md_size;
          *md_size = *md_size + 1u;
          memset((void *)md_ptr, 0, sizeof(struct media_device_entry) /*32ul*/ );
          md_ptr->type = (enum device_type)UNKNOWN;
          md_ptr->device=strdup(device);
          md_ptr->node=strdup(entry->d_name);
          get_uevent_info(md_ptr, dname);
          fill(md_ptr);
        }

      }


    __CPROVER_DUMP_L9:
      ;
      entry=readdir(dir);
    }
    err = 0;

  error:
    ;
    closedir(dir);
    return err;
  }
}

// get_freq
// file common/channel.c line 152
signed int get_freq(signed int i)
{
  _Bool tmp_if_expr_2;
  signed int tmp_if_expr_1;
  if(!(i >= 0))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!(chantab == -1))
      tmp_if_expr_1 = (chanlists + (signed long int)chantab)->count;

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = i >= tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return -1;

  else
  {
    struct CHANLIST *tmp_if_expr_3;
    if(!(chantab == -1))
      tmp_if_expr_3 = (chanlists + (signed long int)chantab)->list;

    else
      tmp_if_expr_3 = (struct CHANLIST *)(void *)0;
    return (signed int)(((tmp_if_expr_3 + (signed long int)i)->freq * (unsigned int)16) / (unsigned int)1000);
  }
}

// get_not_associated_device
// file common/get_media_devices.c line 561
const char * get_not_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const enum device_type not_desired_type)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i;
  signed int skip = 0;
  signed int found = 0;
  char *prev = "";
  char *result = (char *)(void *)0;
  i = 0;
  signed int return_value_strcmp_1;
  for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
  {
    if(!(last_seek == ((const char *)NULL)))
    {
      return_value_strcmp_1=strcmp(md_ptr->node, last_seek);
      if(return_value_strcmp_1 == 0)
      {
        found = 1;
        goto __CPROVER_DUMP_L9;
      }

    }

    if(!(found == 0) || last_seek == ((const char *)NULL))
    {
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(prev, md_ptr->device);
      if(!(return_value_strcmp_2 == 0))
      {
        if(skip == 0 && !(result == ((char *)NULL)))
          break;

        prev = md_ptr->device;
        skip = 0;
        result = (char *)(void *)0;
      }

      if(md_ptr->type == not_desired_type)
        skip = 1;

      else
        if(result == ((char *)NULL) && skip == 0)
        {
          if(md_ptr->type == desired_type)
            result = md_ptr->node;

        }

    }


  __CPROVER_DUMP_L9:
    ;
    i = i + 1;
  }
  if(!(skip == 0))
    result = (char *)(void *)0;

  return result;
}

// get_uevent_info
// file common/get_media_devices.c line 69
static void get_uevent_info(struct media_device_entry *md_ptr, char *dname)
{
  struct _IO_FILE *fd;
  char file[4096l];
  char *name;
  char *p;
  char s[1024l];
  snprintf(file, (unsigned long int)4096, "%s/%s/uevent", dname, md_ptr->node);
  fd=fopen(file, "r");
  char *return_value_fgets_1;
  signed long int return_value_atol_2;
  signed int return_value_strcmp_4;
  signed long int return_value_atol_3;
  if(!(fd == ((struct _IO_FILE *)NULL)))
  {
    do
    {
      return_value_fgets_1=fgets(s, (signed int)sizeof(char [1024l]) /*1024ul*/ , fd);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      p=strtok(s, "=");
      if(!(p == ((char *)NULL)))
      {
        name = p;
        p=strtok((char *)(void *)0, "\n");
        if(!(p == ((char *)NULL)))
        {
          signed int return_value_strcmp_5;
          return_value_strcmp_5=strcmp(name, "MAJOR");
          if(return_value_strcmp_5 == 0)
          {
            return_value_atol_2=atol(p);
            md_ptr->major = (unsigned int)return_value_atol_2;
          }

          else
          {
            return_value_strcmp_4=strcmp(name, "MINOR");
            if(return_value_strcmp_4 == 0)
            {
              return_value_atol_3=atol(p);
              md_ptr->minor = (unsigned int)return_value_atol_3;
            }

          }
        }

      }

    }
    while((_Bool)1);
    fclose(fd);
  }

}

// gfx_init
// file console/matrox.h line 1
extern signed int gfx_init(signed int fd)
{
  signed int off;
  switch(fb_fix.accel)
  {
    case (unsigned int)21:

    case (unsigned int)26:
    {
      gfx_scaler_on = matrox_scaler_on;
      gfx_scaler_off = matrox_scaler_off;
      break;
    }
    case (unsigned int)9:

    case (unsigned int)10:
    {
      gfx_scaler_on = mach64_scaler_on;
      gfx_scaler_off = mach64_scaler_off;
      break;
    }
    default:
      return -1;
  }
  fb_var.accel_flags = (unsigned int)0;
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(fd, (unsigned long int)0x4601, &fb_var);
  if(!(return_value_ioctl_1 == 0))
  {
    perror("FBIOPUT_VSCREENINFO");
    return -1;
  }

  else
  {
    void *return_value_mmap_2;
    return_value_mmap_2=mmap((void *)0, (unsigned long int)fb_fix.mmio_len, 0x1 | 0x2, 0x01, fd, (signed long int)fb_fix.smem_len);
    bmmio = (unsigned char *)return_value_mmap_2;
    if((unsigned char *)-1 == bmmio)
    {
      perror("mmap");
      return -1;
    }

    else
    {
      signed int return_value_getpagesize_3;
      return_value_getpagesize_3=getpagesize();
      off = (signed int)((unsigned long int)fb_fix.mmio_start - ((unsigned long int)fb_fix.mmio_start & (unsigned long int)~(return_value_getpagesize_3 - 1)));
      bmmio = bmmio + (signed long int)off;
      mmio = (unsigned int *)bmmio;
      return 0;
    }
  }
}

// grabber_init
// file console/fbtv.c line 518
static void grabber_init(void)
{
  drv = (struct ng_vid_driver *)(void *)0;
  struct ng_video_fmt screen;
  memset((void *)&screen, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
  screen.fmtid = (unsigned int)x11_native_format;
  screen.width = fb_var.xres_virtual;
  screen.height = fb_var.yres_virtual;
  screen.bytesperline = fb_fix.line_length;
  drv=ng_vid_open(&ng_dev.video, ng_dev.driver, &screen, NULL, &h_drv);
  if(drv == ((struct ng_vid_driver *)NULL))
  {
    fprintf(stderr, "no grabber device available\n");
    exit(1);
  }

  f_drv=drv->capabilities(h_drv);
  struct ng_attribute *return_value;
  return_value=drv->list_attrs(h_drv);
  add_attrs(return_value);
}

// gray_to_lut2
// file libng/color_lut.c line 82
static void gray_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)*src] | ng_lut_green[(signed long int)*src] | ng_lut_blue[(signed long int)*src]);
    src = src + 1l;
  }
  while((_Bool)1);
}

// gray_to_lut4
// file libng/color_lut.c line 148
static void gray_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)*src] | ng_lut_green[(signed long int)*src] | ng_lut_blue[(signed long int)*src]);
    src = src + 1l;
  }
  while((_Bool)1);
}

// init_channel
// file common/channel.c line 318
static void init_channel(char *name, struct CHANNEL *c)
{
  struct ng_attribute *attr;
  char *val;
  signed int n;
  signed int i;
  val=cfg_get_str(name, "capture");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, captab);
    if(!(i == -1))
      c->capture = i;

    else
      fprintf(stderr, "config: invalid value for capture: %s\n", val);
  }

  attr=ng_attr_byid(attrs, 2);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "input");
    _Bool tmp_if_expr_1;
    if(!(val == ((char *)NULL)))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      val=cfg_get_str(name, "source");
      tmp_if_expr_1 = (char *)(void *)0 != val ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_1)
    {
      i=ng_attr_getint(attr, val);
      if(!(i == -1))
        c->input = i;

      else
      {
        fprintf(stderr, "config: invalid value for input: %s\n", val);
        ng_attr_listchoices(attr);
      }
    }

  }

  attr=ng_attr_byid(attrs, 1);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "norm");
    if(!(val == ((char *)NULL)))
    {
      i=ng_attr_getint(attr, val);
      if(!(i == -1))
        c->norm = i;

      else
      {
        fprintf(stderr, "config: invalid value for norm: %s\n", val);
        ng_attr_listchoices(attr);
      }
    }

  }

  attr=ng_attr_byid(attrs, 5);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "audio");
    if(!(val == ((char *)NULL)))
    {
      i=ng_attr_getint(attr, val);
      if(!(i == -1))
        c->audio = i;

      else
      {
        fprintf(stderr, "config: invalid value for audio: %s\n", val);
        ng_attr_listchoices(attr);
      }
    }

  }

  val=cfg_get_str(name, "channel");
  if(!(val == ((char *)NULL)))
    c->cname=strdup(val);

  val=cfg_get_str(name, "freq");
  double return_value_atof_2;
  if(!(val == ((char *)NULL)))
  {
    return_value_atof_2=atof(val);
    c->freq = (signed int)(return_value_atof_2 * (double)16);
  }

  n=cfg_get_signed_int(name, "fine");
  if(!(n == 0))
    c->fine = n;

  val=cfg_get_str(name, "key");
  if(!(val == ((char *)NULL)))
    c->key=strdup(val);

  val=cfg_get_str(name, "group");
  if(!(val == ((char *)NULL)))
    c->group=strdup(val);

  val=cfg_get_str(name, "midi");
  if(!(val == ((char *)NULL)))
    c->midi=atoi(val);

  attr=ng_attr_byid(attrs, 6);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "color");
    if(!(val == ((char *)NULL)))
      c->color=ng_attr_parse_int(attr, val);

  }

  attr=ng_attr_byid(attrs, 7);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "bright");
    if(!(val == ((char *)NULL)))
      c->bright=ng_attr_parse_int(attr, val);

  }

  attr=ng_attr_byid(attrs, 8);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "hue");
    if(!(val == ((char *)NULL)))
      c->hue=ng_attr_parse_int(attr, val);

  }

  attr=ng_attr_byid(attrs, 9);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "contrast");
    if(!(val == ((char *)NULL)))
      c->contrast=ng_attr_parse_int(attr, val);

  }

}

// init_overlay
// file ./common/commands.h line 75
void init_overlay(void)
{
  const char *tmp_if_expr_1;
  if(!(chantab == -1))
    tmp_if_expr_1 = (chanlist_names + (signed long int)chantab)->str;

  else
    tmp_if_expr_1 = "europe-west";
  do_va_cmd(2, (const void *)"setfreqtab", tmp_if_expr_1);
  cur_capture = -1;
  switch(defaults.capture)
  {
    case 9:

    case 1:
    {
      do_va_cmd(2, (const void *)"capture", (const void *)"overlay");
      break;
    }
    case 2:
    {
      do_va_cmd(2, (const void *)"capture", (const void *)"grabdisplay");
      break;
    }
    default:
      do_va_cmd(2, (const void *)"capture", (const void *)"off");
  }
}

// int_to_str
// file common/channel.c line 752
const char * int_to_str(signed int n, struct STRTAB *tab)
{
  signed int i = 0;
  for( ; !((tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    if((tab + (signed long int)i)->nr == (signed long int)n)
      return (tab + (signed long int)i)->str;

  return (const char *)(void *)0;
}

// joystick_tv_havedata
// file ./common/joystick.h line 2
void joystick_tv_havedata(signed int js)
{
  unsigned int i;
  struct js_event event;
  if(!(debug == 0))
    fprintf(stderr, "joystick: received input\n");

  signed long int return_value_read_1;
  return_value_read_1=read(js, (void *)&event, sizeof(struct js_event) /*8ul*/ );
  if(!(return_value_read_1 == 0l))
  {
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 6ul); i = i + 1u)
      if(joytab[(signed long int)i].class == (signed int)event.type)
      {
        if(joytab[(signed long int)i].number == (signed int)event.number)
        {
          if(joytab[(signed long int)i].value == (signed int)event.value)
            break;

        }

      }

    if(!((unsigned long int)i == 6ul))
      event_dispatch(joytab[(signed long int)i].event);

  }

}

// joystick_tv_init
// file ./common/joystick.h line 1
signed int joystick_tv_init(char *dev)
{
  signed int fd;
  if(dev == ((char *)NULL))
    return -1;

  else
  {
    fd=open(dev, 04000);
    if(fd == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      fprintf(stderr, "joystick: open %s: %s\n", dev, return_value_strerror_2);
      return -1;
    }

    fcntl(fd, 2, 1);
    event_register_list(joy_events);
    return fd;
  }
}

// keypad_handler
// file common/commands.c line 1484
static signed int keypad_handler(char *name, signed int argc, char **argv)
{
  signed int n;
  signed int return_value_atoi_1;
  return_value_atoi_1=atoi(argv[(signed long int)0]);
  n = return_value_atoi_1 % 10;
  char msg[8l];
  char keypad_handler__1__ch[8l];
  if(!(debug == 0))
    fprintf(stderr, "keypad: key %d\n", n);

  if(keypad_state == -1)
  {
    if((keypad_ntsc == 0 ? count >= n : !(n >= 100)) && n >= 1 && !(keypad_partial == 0) || keypad_partial == 0 && (keypad_ntsc == 0 ? count >= n : !(n >= 100)) && n >= 1 && !(keypad_ntsc == 0 ? count >= 10 * n : !(10 * n >= 100)))
    {
      if(!(keypad_ntsc == 0))
      {
        sprintf(keypad_handler__1__ch, "%d", n);
        do_va_cmd(2, (const void *)"setchannel", (const void *)keypad_handler__1__ch, (void *)0);
      }

      else
        do_va_cmd(2, (const void *)"setstation", channels[(signed long int)(n - 1)]->name, (void *)0);
    }

    if((keypad_ntsc == 0 ? count >= 10 * n : !(10 * n >= 100)) && n >= 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "keypad: hang: %d\n", n);

      keypad_state = n;
      if(!(display_message == ((void (*)(char *))NULL)))
      {
        sprintf(msg, "%d_", n);
        display_message(msg);
      }

    }

  }

  else
  {
    if((keypad_ntsc == 0 ? count : 99) >= 10 * keypad_state + n)
      n = n + keypad_state * 10;

    keypad_state = -1;
    if(!(debug == 0))
      fprintf(stderr, "keypad: ok: %d\n", n);

    if((keypad_ntsc == 0 ? count >= n : !(n >= 100)) && n >= 1)
    {
      if(!(keypad_ntsc == 0))
      {
        sprintf(keypad_handler__1__ch, "%d", n);
        do_va_cmd(2, (const void *)"setchannel", (const void *)keypad_handler__1__ch, (void *)0);
      }

      else
        do_va_cmd(2, (const void *)"setstation", channels[(signed long int)(n - 1)]->name, (void *)0);
    }

  }
  return 0;
}

// keypad_timeout
// file ./common/commands.h line 80
void keypad_timeout(void)
{
  if(!(debug == 0))
    fprintf(stderr, "keypad: timeout\n");

  if(keypad_state == 1 + cur_sender)
    set_title();

  keypad_state = -1;
}

// linear_palette
// file console/fbtv.c line 194
static void linear_palette(signed int r, signed int g, signed int b)
{
  signed int i;
  signed int size = 256 >> 8 - r;
  i = 0;
  double return_value_pow_1;
  for( ; !(i >= size); i = i + 1)
  {
    return_value_pow_1=pow((double)i / ((double)size - 1.0), (double)fbgamma);
    red[(signed long int)i] = (unsigned short int)(65535.0 * return_value_pow_1);
  }
  size = 256 >> 8 - g;
  i = 0;
  double return_value_pow_2;
  for( ; !(i >= size); i = i + 1)
  {
    return_value_pow_2=pow((double)i / ((double)size - 1.0), (double)fbgamma);
    green[(signed long int)i] = (unsigned short int)(65535.0 * return_value_pow_2);
  }
  size = 256 >> 8 - b;
  i = 0;
  double return_value_pow_3;
  for( ; !(i >= size); i = i + 1)
  {
    return_value_pow_3=pow((double)i / ((double)size - 1.0), (double)fbgamma);
    blue[(signed long int)i] = (unsigned short int)(65535.0 * return_value_pow_3);
  }
}

// lirc_tv_havedata
// file ./common/lirc.h line 2
signed int lirc_tv_havedata(void)
{
  char *code;
  char event[32l];
  char *cmd;
  char **argv;
  signed int dummy;
  signed int repeat;
  signed int argc;
  signed int ret = -1;
  strcpy(event, "lirc-key-");
  signed int return_value_lirc_nextcode_1;
  signed int return_value_lirc_code2char_3;
  do
  {
    return_value_lirc_nextcode_1=lirc_nextcode(&code);
    if(!(return_value_lirc_nextcode_1 == 0))
      break;

    if(code == ((char *)NULL))
      break;

    ret = 0;
    signed int return_value_sscanf_2;
    return_value_sscanf_2=sscanf(code, "%x %x %20s", &dummy, &repeat, event + (signed long int)9);
    if(!(return_value_sscanf_2 == 3))
      fprintf(stderr, "lirc: oops, parse error: %s", code);

    else
    {
      if(!(debug == 0))
        fprintf(stderr, "lirc: key=%s repeat=%d\n", event + (signed long int)9, repeat);

      if(!(config == ((struct lirc_config *)NULL)))
        do
        {
          return_value_lirc_code2char_3=lirc_code2char(config, code, &cmd);
          if(!(return_value_lirc_code2char_3 == 0))
            break;

          if(cmd == ((char *)NULL))
            break;

          if(!(debug == 0))
            fprintf(stderr, "lirc: cmd \"%s\"\n", cmd);

          signed int return_value_strcasecmp_4;
          return_value_strcasecmp_4=strcasecmp(cmd, "eventmap");
          if(return_value_strcasecmp_4 == 0)
            event_dispatch(event);

          else
          {
            argv=split_cmdline(cmd, &argc);
            do_command(argc, argv);
          }
        }
        while((_Bool)1);

      else
        if(repeat == 0)
          event_dispatch(event);

      free((void *)code);
    }
  }
  while((_Bool)1);
  return ret;
}

// lirc_tv_init
// file ./common/lirc.h line 1
signed int lirc_tv_init(void)
{
  signed int fd;
  fd=lirc_init("xawtv", debug);
  if(fd == -1)
  {
    if(!(debug == 0))
      fprintf(stderr, "lirc: no infrared remote support available\n");

    return -1;
  }

  else
  {
    signed int return_value_lirc_readconfig_1;
    return_value_lirc_readconfig_1=lirc_readconfig((char *)(void *)0, &config, (signed int (*)(char *))(void *)0);
    if(!(return_value_lirc_readconfig_1 == 0))
      config = (struct lirc_config *)(void *)0;

    if(!(debug == 0))
      fprintf(stderr, "lirc: ~/.lircrc file %sfound\n", config != ((struct lirc_config *)NULL) ? "" : "not ");

    fcntl(fd, 4, 04000);
    fcntl(fd, 2, 1);
    event_register_list(lirc_events);
    if(!(debug == 0))
      fprintf(stderr, "lirc: init ok\n");

    return fd;
  }
}

// list_add_tail
// file libng/list.h line 65
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
  __list_add(new, head->prev, head);
}

// list_handler
// file common/commands.c line 943
static signed int list_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  signed int val;
  signed int i;
  printf("%-10.10s | type   | %-7.7s | %-7.7s | %s\n", (const void *)"attribute", (const void *)"current", (const void *)"default", (const void *)"comment");
  printf("-----------+--------+---------+---------+-------------------------------------\n");
  attr = attrs;
  const char *return_value_ng_attr_getstr_1;
  const char *return_value_ng_attr_getstr_2;
  for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
  {
    val = cur_attrs[(signed long int)attr->id];
    switch(attr->type)
    {
      case 2:
      {
        return_value_ng_attr_getstr_1=ng_attr_getstr(attr, val);
        return_value_ng_attr_getstr_2=ng_attr_getstr(attr, attr->defval);
        printf("%-10.10s | choice | %-7.7s | %-7.7s |", attr->name, return_value_ng_attr_getstr_1, return_value_ng_attr_getstr_2);
        i = 0;
        for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
          printf(" %s", (attr->choices + (signed long int)i)->str);
        printf("\n");
        break;
      }
      case 1:
      {
        printf("%-10.10s | int    | %7d | %7d | range is %d => %d\n", attr->name, val, attr->defval, attr->min, attr->max);
        break;
      }
      case 3:
        printf("%-10.10s | bool   | %-7.7s | %-7.7s |\n", attr->name, val != 0 ? "on" : "off", attr->defval != 0 ? "on" : "off");
    }
  }
  return 0;
}

// lookup_channel
// file common/channel.c line 102
signed int lookup_channel(char *channel)
{
  signed int i;
  signed int tmp_if_expr_1;
  signed int return_value_strcasecmp_3;
  if(channel == ((char *)NULL))
    return -1;

  else
  {
    i = 0;
    do
    {
      if(!(chantab == -1))
        tmp_if_expr_1 = (chanlists + (signed long int)chantab)->count;

      else
        tmp_if_expr_1 = 0;
      if(i >= tmp_if_expr_1)
        break;

      struct CHANLIST *tmp_if_expr_2;
      if(!(chantab == -1))
        tmp_if_expr_2 = (chanlists + (signed long int)chantab)->list;

      else
        tmp_if_expr_2 = (struct CHANLIST *)(void *)0;
      return_value_strcasecmp_3=strcasecmp((tmp_if_expr_2 + (signed long int)i)->name, channel);
      if(return_value_strcasecmp_3 == 0)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    signed int tmp_if_expr_4;
    if(!(chantab == -1))
      tmp_if_expr_4 = (chanlists + (signed long int)chantab)->count;

    else
      tmp_if_expr_4 = 0;
    if(i == tmp_if_expr_4)
      return -1;

    else
      return i;
  }
}

// mach64_scaler_off
// file console/matrox.c line 186
static void mach64_scaler_off(void)
{
  wrio4(0x0009, (unsigned long int)0);
}

// mach64_scaler_on
// file console/matrox.c line 148
static void mach64_scaler_on(signed int offscreen, signed int pitch, signed int width, signed int height, signed int left, signed int right, signed int top, signed int bottom)
{
  signed int v;
  signed int h;
  v = (height << 12) / (bottom - top);
  h = (width << 12) / (right - left);
  wrio4(0x0009, (unsigned long int)0);
  wrio4(0x0008, (unsigned long int)(h << 16 | v));
  wrio4(0x0012, (unsigned long int)(12 << 16));
  wrio4(0x000d, (unsigned long int)offscreen);
  wrio4(0x000e, (unsigned long int)offscreen);
  wrio4(0x000f, (unsigned long int)(pitch / 2));
  wrio4(0x000a, (unsigned long int)(width << 16 | height));
  wrio4(0x0014, (unsigned long int)0);
  wrio4(0x0054, (unsigned long int)0x00101000);
  wrio4(0x0055, (unsigned long int)0x00002000);
  wrio4(0x0056, (unsigned long int)0x0D06200D);
  wrio4(0x0057, (unsigned long int)0x0D0A1C0D);
  wrio4(0x0058, (unsigned long int)0x0C0E1A0C);
  wrio4(0x0059, (unsigned long int)0x0C14140C);
  wrio4(0x0000, (unsigned long int)(left << 16 | top));
  wrio4(0x0001, (unsigned long int)(right - 1 << 16 | bottom - 1));
  wrio4(0x0003, (unsigned long int)0);
  wrio4(0x0002, (unsigned long int)0);
  wrio4(0x0006, (unsigned long int)1);
  wrio4(0x000b, (unsigned long int)0);
  wrio4(0x0009, (unsigned long int)(1 << 31 | 1 << 30));
}

// main
// file console/fbtv.c line 583
signed int main(signed int argc, char **argv)
{
  signed int i;
  signed int key;
  signed int main__1__c;
  signed int gray = 0;
  signed int rc;
  signed int vt = 0;
  signed int fps = 0;
  signed int t1;
  signed int t2;
  signed int lirc;
  signed int js;
  signed int err;
  signed int mute = 1;
  signed int fdmax;
  unsigned int ui;
  unsigned long int freq;
  struct timeval tv;
  signed long int t;
  char text[80l];
  char event[64l];
  char *env;
  char *dst;
  struct anonymous_30 set;
  struct sigaction act;
  struct sigaction old;
  unsigned int return_value_geteuid_2;
  return_value_geteuid_2=geteuid();
  unsigned int return_value_getuid_1;
  if(return_value_geteuid_2 == 0u)
  {
    return_value_getuid_1=getuid();
    if(!(return_value_getuid_1 == 0u))
    {
      fprintf(stderr, "fbtv /must not/ be installed suid root\n");
      exit(1);
    }

  }

  env=getenv("FBFONT");
  if(!(env == ((char *)NULL)))
    fontfile = env;

  ng_init();
  signed int return_value_sscanf_3;
  unsigned long int return_value_strtoul_4;
  do
  {
    double val;
    main__1__c=getopt(argc, argv, "Mgvqxk2d:o:s:c:f:m:z:t:j:D:");
    if(main__1__c == -1)
      break;

    switch(main__1__c)
    {
      case 122:
      {
        return_value_sscanf_3=sscanf(optarg, "%lf", &val);
        if(return_value_sscanf_3 == 1)
        {
          if(val < 0.1 || val > 10.000000)
            fprintf(stderr, "gamma value is out of range.  must be 0.1 < value < 10.0\n");

          else
            fbgamma = (float)(1.0 / val);
        }

        break;
      }
      case 102:
      {
        fontfile = optarg;
        break;
      }
      case 109:
      {
        mode = optarg;
        break;
      }
      case 103:
      {
        gray = 1;
        break;
      }
      case 77:
      {
        matrox = 1;
        break;
      }
      case 107:
      {
        keep_dma_on = 1;
        break;
      }
      case 118:
      {
        debug = debug + 1;
        ng_debug = ng_debug + 1;
        break;
      }
      case 113:
      {
        quiet = 1;
        break;
      }
      case 100:
      {
        fbdev = optarg;
        break;
      }
      case 111:
      {
        snapbase=strdup(optarg);
        break;
      }
      case 115:
      {
        sscanf(optarg, "%dx%d", &ww, &hh);
        break;
      }
      case 99:
      {
        ng_dev.video = optarg;
        break;
      }
      case 68:
      {
        ng_dev.driver = optarg;
        break;
      }
      case 116:
      {
        if(!(optarg == ((char *)NULL)))
        {
          return_value_strtoul_4=strtoul(optarg, ((char ** restrict )NULL), 0);
          vt = (signed int)return_value_strtoul_4;
        }

        else
          vt = 0;
        break;
      }
      case 106:
      {
        joydev = optarg;
        break;
      }
      default:
        exit(1);
    }
  }
  while((_Bool)1);
  do_overlay = 1;
  text_init(fontfile);
  fb=fb_init(fbdev, mode, vt);
  fb_catch_exit_signals();
  fb_initcolors(fb, gray);
  fb_switch_init();
  switch_last = fb_switch_state;
  fs_init_fb(15);
  signed int return_value_gfx_init_5;
  if(!(matrox == 0))
  {
    return_value_gfx_init_5=gfx_init(fb);
    if(return_value_gfx_init_5 == -1)
      matrox = 0;

  }

  if(!(matrox == 0))
    strcat(ng_v4l_conf, " -y ");

  grabber_init();
  freq_init();
  read_config((char *)(void *)0, (signed int *)(void *)0, (char **)(void *)0);
  unsigned long int return_value_strlen_6;
  return_value_strlen_6=strlen(mixerdev);
  if(!(return_value_strlen_6 == 0ul))
  {
    struct ng_attribute *attr;
    attr=ng_mix_init(mixerdev, mixerctl);
    if(!(attr == ((struct ng_attribute *)NULL)))
      add_attrs(attr);

  }

  update_title = new_title;
  display_message = new_message;
  set_capture_hook = do_capture;
  exit_hook = do_exit;
  fullscreen_hook = do_fullscreen;
  tty_init();
  memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
  act.__sigaction_handler.sa_handler = ctrlc;
  sigemptyset(&act.sa_mask);
  sigaction(2, &act, &old);
  attr_init();
  audio_on();
  audio_init();
  parse_config(1);
  channel_menu();
  init_overlay();
  if(1 + optind == argc)
    do_va_cmd(2, (const void *)"setstation", argv[(signed long int)optind]);

  else
  {
    if(!((4 & f_drv) == 0))
    {
      freq=drv->getfreq(h_drv);
      if(!(freq == 0ul))
      {
        i = 0;
        signed int tmp_if_expr_7;
        if(!(chantab == -1))
          tmp_if_expr_7 = (chanlists + (signed long int)chantab)->count;

        else
          tmp_if_expr_7 = 0;
        if(!(i >= tmp_if_expr_7))
        {
          struct CHANLIST *tmp_if_expr_9;
          if(!(chantab == -1))
            tmp_if_expr_9 = (chanlists + (signed long int)chantab)->list;

          else
            tmp_if_expr_9 = (struct CHANLIST *)(void *)0;
          if((unsigned long int)(tmp_if_expr_9 + (signed long int)i)->freq == (1000ul * freq) / 16ul)
          {
            struct CHANLIST *tmp_if_expr_8;
            if(!(chantab == -1))
              tmp_if_expr_8 = (chanlists + (signed long int)chantab)->list;

            else
              tmp_if_expr_8 = (struct CHANLIST *)(void *)0;
            do_va_cmd(2, (const void *)"setchannel", (tmp_if_expr_8 + (signed long int)i)->name);
          }

          else
            i = i + 1;
        }

      }

    }

    if(cur_channel == -1)
    {
      if(count >= 1)
        do_va_cmd(2, (const void *)"setstation", (const void *)"0");

      else
        set_defaults();
    }

  }
  event_register_list(kbd_events);
  lirc=lirc_tv_init();
  js=joystick_tv_init(joydev);
  fb_midi.fd = -1;
  if(!(midi == ((char *)NULL)))
  {
    signed int return_value_midi_open_10;
    return_value_midi_open_10=midi_open(&fb_midi, "fbtv");
    if(!(return_value_midi_open_10 == -1))
      midi_connect(&fb_midi, midi);

  }

  fb_memset((void *)(fb_mem + (signed long int)fb_mem_offset), 0, (unsigned long int)fb_fix.smem_len);
  while(sig == 0)
  {
    if(quiet == 0 && (fb_switch_state == 0 || !(keep_dma_on == 0)))
    {
      fb_memset((void *)(fb_mem + (signed long int)fb_mem_offset), 0, (unsigned long int)((unsigned int)f->height * fb_fix.line_length));
      if(!((signed int)message[0l] == 0))
        strcpy(text, message);

      else
        sprintf(text, "Framebuffer TV - %s", (const void *)default_title);
      if(cur_capture == 2)
      {
        unsigned long int return_value_strlen_11;
        return_value_strlen_11=strlen(text);
        sprintf(text + (signed long int)return_value_strlen_11, " - grab %d.%d fps", fps / 5, (fps * 2) % 10);
      }

      text_out(0, 0, text);
      if(dy >= 1)
      {
        time(&t);
        struct tm *return_value_localtime_12;
        return_value_localtime_12=localtime(&t);
        strftime(text, (unsigned long int)16, "%H:%M", return_value_localtime_12);
        signed int return_value_text_width_13;
        return_value_text_width_13=text_width(text);
        text_out((signed int)((fb_var.xres - (unsigned int)return_value_text_width_13) - (unsigned int)f->width), 0, text);
      }

    }

    if(!(switch_last == fb_switch_state))
      console_switch();

    signed long int return_value_time_14;
    return_value_time_14=time((signed long int *)(void *)0);
    t1 = (signed int)return_value_time_14;
    fps = 0;
    message[(signed long int)0] = (char)0;
    while(sig == 0)
    {
      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_30) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&set)->__fds_bits[(signed long int)(0 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->__fds_bits[(signed long int)(0 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << 0 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      fdmax = 1;
      if(!(lirc == -1))
      {
        (&set)->__fds_bits[(signed long int)(lirc / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->__fds_bits[(signed long int)(lirc / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << lirc % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        fdmax = fdmax > lirc + 1 ? fdmax : lirc + 1;
      }

      if(!(js == -1))
      {
        (&set)->__fds_bits[(signed long int)(js / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->__fds_bits[(signed long int)(js / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << js % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        fdmax = fdmax > js + 1 ? fdmax : js + 1;
      }

      if(!(fb_midi.fd == -1))
      {
        (&set)->__fds_bits[(signed long int)(fb_midi.fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->__fds_bits[(signed long int)(fb_midi.fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fb_midi.fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        fdmax = fdmax > fb_midi.fd + 1 ? fdmax : fb_midi.fd + 1;
      }

      if(cur_capture == 2 && (fb_switch_state == 0 || !(keep_dma_on == 0)))
      {
        fps = fps + 1;
        buf=ng_grabber_grab_image(0);
        if(buf == ((struct ng_video_buf *)NULL))
        {
          fprintf(stderr, "capturing image failed\n");
          exit(1);
        }

        if(!(ch == ((struct ng_convert_handle *)NULL)))
          buf=ng_convert_frame(ch, (struct ng_video_buf *)(void *)0, buf);

        dst = (char *)(fb_mem + (signed long int)((unsigned int)dy * fb_fix.line_length) + (signed long int)((unsigned int)dx * ((fb_var.bits_per_pixel + (unsigned int)7) / (unsigned int)8)));
        ui = (unsigned int)0;
        for( ; !(ui >= buf->fmt.height); ui = ui + 1u)
        {
          memcpy((void *)dst, (const void *)(buf->data + (signed long int)(ui * buf->fmt.bytesperline)), (unsigned long int)buf->fmt.bytesperline);
          dst = dst + (signed long int)fb_fix.line_length;
        }
        ng_release_video_buf(buf);
        tv.tv_sec = (signed long int)0;
        tv.tv_usec = (signed long int)0;
        rc=select(fdmax, &set, (struct anonymous_30 *)(void *)0, (struct anonymous_30 *)(void *)0, &tv);
      }

      else
      {
        tv.tv_sec = (signed long int)6;
        tv.tv_usec = (signed long int)0;
        rc=select(fdmax, &set, (struct anonymous_30 *)(void *)0, (struct anonymous_30 *)(void *)0, &tv);
      }
      signed int *return_value___errno_location_15;
      return_value___errno_location_15=__errno_location();
      err = *return_value___errno_location_15;
      if(!(switch_last == fb_switch_state))
        console_switch();

      if(err == 4 && rc == -1)
        do
        {
          signed int main__1__7__1__2__1__7__1____d0;
          signed int main__1__7__1__2__1__7__1____d1;
          asm("cld; rep; stosq" : "=c"(main__1__7__1__2__1__7__1____d0), "=D"(main__1__7__1__2__1__7__1____d1) : "a"(0), "0"(sizeof(struct anonymous_30) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);

      else
      {
        if(rc >= 1)
          break;

        signed long int return_value_time_16;
        return_value_time_16=time((signed long int *)(void *)0);
        t2 = (signed int)return_value_time_16;
        if(t2 + -t1 >= 5)
        {
          keypad_timeout();
          break;
        }

      }
    }
    if(!((1l & set.__fds_bits[0l]) == 0l))
    {
      key=wgetch(stdscr);
      if(!(key == 27) && !(key == 81) && !(key == 113))
      {
        if(key == 88 || key == 120)
          goto __CPROVER_DUMP_L73;

        if(key == -1)
          goto __CPROVER_DUMP_L74;

      }

      else
      {
        sig = 1;
        goto __CPROVER_DUMP_L82;

      __CPROVER_DUMP_L73:
        ;
        sig = 1;
        mute = 0;
        goto __CPROVER_DUMP_L82;

      __CPROVER_DUMP_L74:
        ;
        goto __CPROVER_DUMP_L82;
      }
      event[(signed long int)0] = (char)0;
      if(key >= 33 && !(key >= 127))
        sprintf(event, "kbd-key-%c", key);

      else
        if(key >= 0 && !(key >= 277))
          sprintf(event, "kbd-key-f%d", key - (0410 + 0));

        else
        {
          ui = (unsigned int)0;
          for( ; !((unsigned long int)ui >= 14ul); ui = ui + 1u)
            if(keytab[(signed long int)ui].key == key)
              break;

          if(!((unsigned long int)ui == 14ul))
            sprintf(event, "kbd-key-%s", keytab[(signed long int)ui].name);

        }
      if(!((signed int)event[0l] == 0))
        event_dispatch(event);

      else
        sprintf(message, "unknown key: %d 0x%x ", key, key);
    }


  __CPROVER_DUMP_L82:
    ;
    if(!(lirc == -1))
    {
      if(!((set.__fds_bits[(signed long int)(lirc / 8)] & (signed long int)(1UL << lirc % 8)) == 0l))
      {
        signed int return_value_lirc_tv_havedata_17;
        return_value_lirc_tv_havedata_17=lirc_tv_havedata();
        if(return_value_lirc_tv_havedata_17 == -1)
        {
          fprintf(stderr, "lirc: connection lost\n");
          close(lirc);
          lirc = -1;
        }

      }

    }

    if(!(js == -1))
    {
      if(!((set.__fds_bits[(signed long int)(js / 8)] & (signed long int)(1UL << js % 8)) == 0l))
        joystick_tv_havedata(js);

    }

    if(!(fb_midi.fd == -1))
    {
      if(!((set.__fds_bits[(signed long int)(fb_midi.fd / 8)] & (signed long int)(1UL << fb_midi.fd % 8)) == 0l))
      {
        midi_read(&fb_midi);
        midi_translate(&fb_midi);
      }

    }

  }
  do_va_cmd(2, (const void *)"capture", (const void *)"off");
  if(!(mute == 0))
    audio_off();

  drv->close(h_drv);
  if(fb_switch_state == 0)
    fb_memset((void *)(fb_mem + (signed long int)fb_mem_offset), 0, (unsigned long int)fb_fix.smem_len);

  tty_cleanup();
  fb_cleanup();
  exit(0);
}

// matrox_scaler_off
// file console/matrox.c line 111
static void matrox_scaler_off(void)
{
  wrio4(0x3d00 + 0x20 >> 2, (unsigned long int)0);
}

// matrox_scaler_on
// file console/matrox.c line 74
static void matrox_scaler_on(signed int offscreen, signed int pitch, signed int width, signed int height, signed int left, signed int right, signed int top, signed int bottom)
{
  bmmio[(signed long int)0x3c00] = (unsigned char)0x51;
  bmmio[(signed long int)0x3c0a] = (unsigned char)0;
  wrio4(0x3d00 + 0x00 >> 2, (unsigned long int)offscreen);
  wrio4(0x3d00 + 0x04 >> 2, (unsigned long int)offscreen);
  wrio4(0x3d00 + 0x08 >> 2, (unsigned long int)offscreen);
  wrio4(0x3d00 + 0x0c >> 2, (unsigned long int)offscreen);
  wrio4(0x3d00 + 0x24 >> 2, (unsigned long int)(pitch / 2));
  wrio4(0x3d00 + 0x28 >> 2, (unsigned long int)(left << 16 | right));
  wrio4(0x3d00 + 0x2c >> 2, (unsigned long int)(top << 16 | bottom));
  wrio4(0x3d00 + 0x30 >> 2, (unsigned long int)((width * 65536) / (right - left) & 0x001ffffc));
  wrio4(0x3d00 + 0x38 >> 2, (unsigned long int)(0 << 16));
  wrio4(0x3d00 + 0x3c >> 2, (unsigned long int)(width << 16));
  wrio4(0x3d00 + 0x50 >> 2, (unsigned long int)(width - 1 << 16));
  wrio4(0x3d00 + 0x34 >> 2, (unsigned long int)((height * 65536) / (bottom - top) & 0x001ffffc));
  wrio4(0x3d00 + 0x48 >> 2, (unsigned long int)0);
  wrio4(0x3d00 + 0x4c >> 2, (unsigned long int)0);
  wrio4(0x3d00 + 0x54 >> 2, (unsigned long int)(height - 1));
  wrio4(0x3d00 + 0x58 >> 2, (unsigned long int)(height - 1));
  wrio4(0x3d00 + 0x20 >> 2, (unsigned long int)(1 << 0 | 1 << 10 | 1 << 11));
  wrio4(0x3d00 + 0xc0 >> 2, (unsigned long int)0);
}

// media_device_type
// file common/get_media_devices.c line 364
const char * media_device_type(enum device_type type)
{
  switch((signed int)type)
  {
    case MEDIA_V4L_VIDEO:
      return "video";
    case MEDIA_V4L_VBI:
      return "vbi";
    case MEDIA_V4L_RADIO:
      return "radio";
    case MEDIA_V4L_SUBDEV:
      return "v4l subdevice";
    case MEDIA_DVB_VIDEO:
      return "dvb video";
    case MEDIA_DVB_AUDIO:
      return "dvb audio";
    case MEDIA_DVB_SEC:
      return "dvb sec";
    case MEDIA_DVB_FRONTEND:
      return "dvb frontend";
    case MEDIA_DVB_DEMUX:
      return "dvb demux";
    case MEDIA_DVB_DVR:
      return "dvb dvr";
    case MEDIA_DVB_NET:
      return "dvb net";
    case MEDIA_DVB_CA:
      return "dvb conditional access";
    case MEDIA_DVB_OSD:
      return "dvb OSD";
    case MEDIA_SND_CARD:
      return "sound card";
    case MEDIA_SND_CAP:
      return "pcm capture";
    case MEDIA_SND_OUT:
      return "pcm output";
    case MEDIA_SND_CONTROL:
      return "mixer";
    case MEDIA_SND_HW:
      return "sound hardware";
    case MEDIA_SND_TIMER:
      return "sound timer";
    case MEDIA_SND_SEQ:
      return "sound sequencer";
    default:
      return "unknown";
  }
}

// midi_close
// file common/midictrl.c line 182
signed int midi_close(struct midi_handle *h)
{
  if(!(debug == 0))
    fprintf(stderr, "midi: close\n");

  if(!(h->ev == ((struct snd_seq_event *)NULL)))
  {
    snd_seq_free_event(h->ev);
    h->ev = (struct snd_seq_event *)(void *)0;
  }

  if(!(h->seq == ((struct _snd_seq *)NULL)))
  {
    snd_seq_close(h->seq);
    h->seq = (struct _snd_seq *)(void *)0;
  }

  return 0;
}

// midi_connect
// file ./common/midictrl.h line 18
signed int midi_connect(struct midi_handle *h, char *arg)
{
  signed int client;
  signed int port;
  signed int rc;
  struct _snd_seq_port_subscribe *psubs;
  struct snd_seq_addr addr;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(arg, "%d:%d", &client, &port);
  if(!(return_value_sscanf_1 == 2))
    return -1;

  else
  {
    snd_seq_port_subscribe_malloc(&psubs);
    addr.client = (unsigned char)client;
    addr.port = (unsigned char)port;
    snd_seq_port_subscribe_set_sender(psubs, &addr);
    signed int return_value_snd_seq_client_id_2;
    return_value_snd_seq_client_id_2=snd_seq_client_id(h->seq);
    addr.client = (unsigned char)return_value_snd_seq_client_id_2;
    addr.port = (unsigned char)h->port;
    snd_seq_port_subscribe_set_dest(psubs, &addr);
    rc=snd_seq_subscribe_port(h->seq, psubs);
    if(!(rc >= 0))
    {
      const char *return_value_snd_strerror_3;
      return_value_snd_strerror_3=snd_strerror(rc);
      fprintf(stderr, "midi: snd_seq_subscribe_port: %s\n", return_value_snd_strerror_3);
    }

    else
      if(!(debug == 0))
        fprintf(stderr, "midi: subscribe ok [%d:%d]\n", client, port);

    snd_seq_port_subscribe_free(psubs);
    return rc;
  }
}

// midi_dump_ev
// file common/midictrl.c line 68
static void midi_dump_ev(struct _IO_FILE *out, struct snd_seq_event *ev)
{
  fprintf(out, "midi ev:");
  if(!((0 & (signed int)ev->flags) == 0))
    fprintf(out, " tick %d", ev->time.tick);

  if(!((1 & (signed int)ev->flags) == 0))
    fprintf(out, " real %d:%06d", ev->time.time.tv_sec, ev->time.time.tv_nsec);

  if(!((0 & (signed int)ev->flags) == 0))
    fprintf(out, " abs");

  if(!((2 & (signed int)ev->flags) == 0))
    fprintf(out, " rel");

  char *tmp_if_expr_1;
  if(!((unsigned long int)ev->type >= 152ul))
    tmp_if_expr_1 = midi_events[(signed long int)ev->type];

  else
    tmp_if_expr_1 = "UNKNOWN";
  fprintf(out, " [%d:%d] %s", ev->source.client, ev->source.port, tmp_if_expr_1);
  switch((signed int)ev->type)
  {
    case 5:
    {
      fprintf(out, " ch=%d note=%d vel=%d off_vel=%d dur=%d", ev->data.note.channel, ev->data.note.note, ev->data.note.velocity, ev->data.note.off_velocity, ev->data.note.duration);
      goto __CPROVER_DUMP_L12;
    }
    case 6:

    case 7:

    case 8:
    {
      fprintf(out, " ch=%d note=%d vel=%d", ev->data.note.channel, ev->data.note.note, ev->data.note.velocity);
      goto __CPROVER_DUMP_L12;
    }
    case 10:

    case 11:

    case 14:

    case 15:

    case 16:
    {
      fprintf(out, " ch=%d par=%d val=%d", ev->data.control.channel, ev->data.control.param, ev->data.control.value);
      goto __CPROVER_DUMP_L12;
    }
    case 12:

    case 13:
    {
      fprintf(out, " ch=%d val=%d", ev->data.control.channel, ev->data.control.value);
      goto __CPROVER_DUMP_L12;
    }
    case 20:

    case 21:

    case 22:

    case 23:

    case 24:
      fprintf(out, " val=%d", ev->data.control.value);
    default:
    {

    __CPROVER_DUMP_L12:
      ;
      fprintf(out, "\n");
    }
  }
}

// midi_open
// file ./common/midictrl.h line 16
signed int midi_open(struct midi_handle *h, char *name)
{
  char *func;
  signed int rc;
  func = "snd_seq_open";
  rc=snd_seq_open(&h->seq, "default", 2, 0x0001);
  signed int return_value_snd_seq_client_id_1;
  if(rc >= 0)
  {
    func = "snd_seq_set_client_name";
    rc=snd_seq_set_client_name(h->seq, name);
    if(!(rc >= 0))
      goto err;

    func = "snd_seq_create_simple_port";
    rc=snd_seq_create_simple_port(h->seq, "name", (unsigned int)(1 << 1 | 1 << 6), (unsigned int)(1 << 20));
    if(!(rc >= 0))
      goto err;

    h->port = rc;
    if(!(debug == 0))
    {
      return_value_snd_seq_client_id_1=snd_seq_client_id(h->seq);
      fprintf(stderr, "midi: open ok [%d:%d]\n", return_value_snd_seq_client_id_1, h->port);
    }

    struct pollfd p;
    snd_seq_poll_descriptors(h->seq, &p, (unsigned int)1, (signed short int)0x001);
    h->fd = p.fd;
    return h->fd;
  }

  else
  {

  err:
    ;
    const char *return_value_snd_strerror_2;
    return_value_snd_strerror_2=snd_strerror(rc);
    fprintf(stderr, "midi: %s: %s\n", func, return_value_snd_strerror_2);
    if(!(h->seq == ((struct _snd_seq *)NULL)))
    {
      snd_seq_close(h->seq);
      h->seq = (struct _snd_seq *)(void *)0;
    }

    return -1;
  }
}

// midi_read
// file ./common/midictrl.h line 19
signed int midi_read(struct midi_handle *h)
{
  signed int rc;
  if(!(h->ev == ((struct snd_seq_event *)NULL)))
  {
    snd_seq_free_event(h->ev);
    h->ev = (struct snd_seq_event *)(void *)0;
  }

  rc=snd_seq_event_input(h->seq, &h->ev);
  if(!(rc >= 0))
  {
    const char *return_value_snd_strerror_1;
    return_value_snd_strerror_1=snd_strerror(rc);
    fprintf(stderr, "midi: snd_seq_event_input: %s\n", return_value_snd_strerror_1);
    return -1;
  }

  if(debug >= 2)
    midi_dump_ev(stderr, h->ev);

  return 0;
}

// midi_translate
// file ./common/midictrl.h line 21
void midi_translate(struct midi_handle *h)
{
  char event[64l];
  signed int i;
  switch((signed int)h->ev->type)
  {
    case 6:
    {
      if((signed int)h->ev->data.note.velocity == 0)
        goto __CPROVER_DUMP_L8;

      i = 0;
      for( ; !(i >= count); i = i + 1)
        if(!(channels[(signed long int)i]->midi == 0))
        {
          if(channels[(signed long int)i]->midi == (signed int)h->ev->data.note.note)
          {
            do_va_cmd(2, (const void *)"setstation", channels[(signed long int)i]->name);
            goto __CPROVER_DUMP_L8;
          }

        }

      sprintf(event, "midi-note-%d", h->ev->data.note.note);
      event_dispatch(event);
      break;
    }
    case 10:
    {
      sprintf(event, "midi-ctrl-%d(%d%%)", h->ev->data.control.param, (h->ev->data.control.value * 100) / 128);
      event_dispatch(event);
    }
  }

__CPROVER_DUMP_L8:
  ;
}

// movie_grab_put_video
// file common/capture.c line 606
signed int movie_grab_put_video(struct movie_handle *h, struct ng_video_buf **ret)
{
  struct ng_video_buf *movie_grab_put_video__1__buf;
  signed int expected;
  signed int rc;
  if(debug >= 2)
    fprintf(stderr, "grab_put_video\n");

  movie_grab_put_video__1__buf=ng_grabber_grab_image(0);
  if(movie_grab_put_video__1__buf == ((struct ng_video_buf *)NULL))
  {
    if(!(debug == 0))
      fprintf(stderr, "grab_put_video: grab image failed\n");

    return -1;
  }

  else
  {
    expected = (signed int)((((unsigned long int)movie_grab_put_video__1__buf->info.ts - h->vdrift) * (unsigned long int)h->fps) / (unsigned long int)1000000000000ULL);
    if(!(expected >= h->frames + -1))
    {
      if(debug >= 2)
        fprintf(stderr, "rate: ignoring frame [%d %d]\n", expected, h->frames);

      ng_release_video_buf(movie_grab_put_video__1__buf);
      return 0;
    }

    else
    {
      if(!(1 + h->frames >= expected))
      {
        fprintf(stderr, "rate: queueing frame twice (%d)\n", expected - h->frames);
        movie_grab_put_video__1__buf->info.twice = movie_grab_put_video__1__buf->info.twice + 1;
        h->frames = h->frames + 1;
      }

      h->frames = h->frames + 1;
      h->vts = (unsigned long int)movie_grab_put_video__1__buf->info.ts;
      movie_grab_put_video__1__buf->info.seq = h->seq;
      if(!(ret == ((struct ng_video_buf **)NULL)))
      {
        movie_grab_put_video__1__buf->refcount = movie_grab_put_video__1__buf->refcount + 1;
        *ret = movie_grab_put_video__1__buf;
      }

      if(!(h->cthreads == 0))
        rc=fifo_put(&h->cfifo, (void *)movie_grab_put_video__1__buf);

      else
        rc=fifo_put(&h->vfifo, (void *)movie_grab_put_video__1__buf);
      if(!(rc == 0))
      {
        ng_release_video_buf(movie_grab_put_video__1__buf);
        return h->frames;
      }

      else
      {
        h->seq = h->seq + 1;
        movie_print_timestamps(h);
        return h->frames;
      }
    }
  }
}

// movie_handler
// file common/commands.c line 1149
static signed int movie_handler(char *name, signed int argc, char **argv)
{
  if(movie_hook == ((void (*)(signed int, char **))NULL))
    return 0;

  else
  {
    movie_hook(argc, argv);
    return 0;
  }
}

// movie_print_timestamps
// file common/capture.c line 583
static void movie_print_timestamps(struct movie_handle *h)
{
  char line[128l];
  if(!(rec_status == ((void (*)(char *))NULL)))
  {
    signed int return_value_abs_1;
    return_value_abs_1=abs((signed int)h->rdrift);
    signed int return_value_abs_2;
    return_value_abs_2=abs((signed int)h->rdrift);
    signed int return_value_abs_3;
    return_value_abs_3=abs((signed int)h->vdrift);
    signed int return_value_abs_4;
    return_value_abs_4=abs((signed int)h->vdrift);
    sprintf(line, "rec %d:%02d.%02d  -  a/r: %c%d.%02ds [%d], a/v: %c%d.%02ds [%d]", (signed int)((h->rts / (unsigned long int)1000000000) / (unsigned long int)60), (signed int)((h->rts / (unsigned long int)1000000000) % (unsigned long int)60), (signed int)((h->rts % (unsigned long int)1000000000) / (unsigned long int)10000000), h->rdrift > (unsigned long int)0 ? 43 : 45, (signed int)(return_value_abs_1 / 1000000000), (signed int)((return_value_abs_2 % 1000000000) / 10000000), (signed int)((h->rdrift * (unsigned long int)h->fps) / (unsigned long int)1000000000000ULL), h->vdrift > (unsigned long int)0 ? 43 : 45, (signed int)(return_value_abs_3 / 1000000000), (signed int)((return_value_abs_4 % 1000000000) / 10000000), (signed int)((h->vdrift * (unsigned long int)h->fps) / (unsigned long int)1000000000000ULL));
    rec_status(line);
  }

}

// movie_writer_init
// file common/capture.c line 398
struct movie_handle * movie_writer_init(char *moviename, char *audioname, struct ng_writer *writer, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio, char *dsp, signed int slots, signed int threads)
{
  struct movie_handle *h;
  struct ng_video_conv *movie_writer_init__1__conv;
  void *dummy;
  signed int i;
  if(!(debug == 0))
    fprintf(stderr, "movie_init_writer start\n");

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct movie_handle) /*2184ul*/ );
  h = (struct movie_handle *)return_value_malloc_1;
  if(h == ((struct movie_handle *)NULL))
    return (struct movie_handle *)(void *)0;

  else
  {
    memset((void *)h, 0, sizeof(struct movie_handle) /*2184ul*/ );
    pthread_mutex_init(&h->lock, (const union anonymous_9 *)(void *)0);
    h->writer = writer;
    h->slots = slots;
    if(!(audio->fmtid == 0u))
    {
      h->dsp=ng_dsp_open(dsp, audio, 1, &h->hdsp);
      if(h->dsp == ((struct ng_dsp_driver *)NULL))
      {
        free((void *)h);
        return (struct movie_handle *)(void *)0;
      }

      fifo_init(&h->afifo, "audio", slots, 1);
      pthread_create(&h->taudio, (const union pthread_attr_t *)(void *)0, writer_audio_thread, (void *)h);
      h->bytes_per_sec = (unsigned long int)((ng_afmt_to_bits[(signed long int)audio->fmtid] * ng_afmt_to_channels[(signed long int)audio->fmtid] * audio->rate) / (unsigned int)8);
      h->afmt = *audio;
    }

    if(!(video->fmtid == 0u))
    {
      signed int return_value_ng_grabber_setformat_3;
      return_value_ng_grabber_setformat_3=ng_grabber_setformat(video, 1);
      if(return_value_ng_grabber_setformat_3 == 0)
      {
        fifo_init(&h->vfifo, "video", slots, 1);
        pthread_create(&h->tvideo, (const union pthread_attr_t *)(void *)0, writer_video_thread, (void *)h);
      }

      else
      {
        struct ng_video_fmt movie_writer_init__1__2__2__gfmt = *video;
        movie_writer_init__1__conv=ng_grabber_findconv(&movie_writer_init__1__2__2__gfmt, 1);
        if(movie_writer_init__1__conv == ((struct ng_video_conv *)NULL))
        {
          if(!(h->afmt.fmtid == 0u))
            h->dsp->close(h->hdsp);

          free((void *)h);
          return (struct movie_handle *)(void *)0;
        }

        h->cthreads = threads;
        if(!(h->cthreads >= 1))
          h->cthreads = 1;

        if(h->cthreads >= 5)
          h->cthreads = 4;

        fifo_init(&h->vfifo, "video", slots, h->cthreads);
        fifo_init(&h->cfifo, "conv", slots, 1);
        pthread_create(&h->tvideo, (const union pthread_attr_t *)(void *)0, writer_video_thread, (void *)h);
        i = 0;
        for( ; !(i >= h->cthreads); i = i + 1)
        {
          void *return_value_malloc_2;
          return_value_malloc_2=malloc(sizeof(struct ng_convthread_handle) /*24ul*/ );
          h->hconv[(signed long int)i] = (struct ng_convthread_handle *)return_value_malloc_2;
          memset((void *)h->hconv[(signed long int)i], 0, sizeof(struct ng_convthread_handle) /*24ul*/ );
          h->hconv[(signed long int)i]->c=ng_convert_alloc(movie_writer_init__1__conv, &movie_writer_init__1__2__2__gfmt, video);
          h->hconv[(signed long int)i]->in = &h->cfifo;
          h->hconv[(signed long int)i]->out = &h->vfifo;
          pthread_create(&h->tconv[(signed long int)i], (const union pthread_attr_t *)(void *)0, ng_convert_thread, (void *)h->hconv[(signed long int)i]);
        }
      }
      h->vfmt = *video;
      h->fps = fps;
    }

    h->handle=writer->wr_open(moviename, audioname, video, priv_video, fps, audio, priv_audio);
    if(!(debug == 0))
      fprintf(stderr, "movie_init_writer end (h=%p)\n", h->handle);

    if(!(h->handle == NULL))
      return h;

    else
    {
      if(!(h->afmt.fmtid == 0u))
      {
        pthread_cancel(h->taudio);
        pthread_join(h->taudio, &dummy);
        h->dsp->close(h->hdsp);
      }

      if(!(h->vfmt.fmtid == 0u))
      {
        pthread_cancel(h->tvideo);
        pthread_join(h->tvideo, &dummy);
      }

      i = 0;
      if(!(i >= h->cthreads))
      {
        pthread_cancel(h->tconv[(signed long int)i]);
        pthread_join(h->tconv[(signed long int)i], &dummy);
        i = i + 1;
      }

      free((void *)h);
      return (struct movie_handle *)(void *)0;
    }
  }
}

// movie_writer_start
// file common/capture.c line 498
signed int movie_writer_start(struct movie_handle *h)
{
  signed int rc = 0;
  if(!(debug == 0))
    fprintf(stderr, "movie_writer_start\n");

  signed long int return_value_ng_get_timestamp_1;
  return_value_ng_get_timestamp_1=ng_get_timestamp();
  h->start = (unsigned long int)return_value_ng_get_timestamp_1;
  signed int return_value;
  if(!(h->afmt.fmtid == 0u))
  {
    return_value=h->dsp->startrec(h->hdsp);
    if(!(return_value == 0))
      rc = -1;

  }

  signed int return_value_1;
  if(!(h->vfmt.fmtid == 0u))
  {
    return_value_1=drv->startvideo(h_drv, h->fps, (unsigned int)h->slots);
    if(!(return_value_1 == 0))
      rc = -1;

  }

  if(!(h->afmt.fmtid == 0u))
    pthread_create(&h->raudio, (const union pthread_attr_t *)(void *)0, record_audio_thread, (void *)h);

  pthread_create(&h->tflush, (const union pthread_attr_t *)(void *)0, flushit, (void *)0);
  return rc;
}

// movie_writer_stop
// file common/capture.c line 518
signed int movie_writer_stop(struct movie_handle *h)
{
  char line[128l];
  unsigned long int stopby;
  signed int frames;
  signed int i;
  void *dummy;
  if(!(debug == 0))
    fprintf(stderr, "movie_writer_stop\n");

  _Bool tmp_if_expr_1;
  if(!(h->vfmt.fmtid == 0u))
    tmp_if_expr_1 = h->afmt.fmtid != (unsigned int)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    frames = 0;
    for( ; !(frames >= 16); frames = frames + 1)
    {
      stopby = ((unsigned long int)(h->frames + frames) * (unsigned long int)1000000000000ULL) / (unsigned long int)h->fps;
      if(!(h->ats >= stopby))
        break;

    }
    frames = frames + 1;
    h->stopby = ((unsigned long int)(h->frames + frames) * (unsigned long int)1000000000000ULL) / (unsigned long int)h->fps;
    for( ; !(frames == 0); frames = frames - 1)
      movie_grab_put_video(h, (struct ng_video_buf **)(void *)0);
  }

  else
    if(!(h->afmt.fmtid == 0u))
      h->stopby = h->ats;

  if(!(h->cthreads == 0))
    fifo_put(&h->cfifo, (void *)0);

  else
    fifo_put(&h->vfifo, (void *)0);
  if(!(h->afmt.fmtid == 0u))
  {
    pthread_join(h->raudio, &dummy);
    pthread_join(h->taudio, &dummy);
  }

  if(!(h->vfmt.fmtid == 0u))
    pthread_join(h->tvideo, &dummy);

  i = 0;
  for( ; !(i >= h->cthreads); i = i + 1)
    pthread_join(h->tconv[(signed long int)i], &dummy);
  pthread_cancel(h->tflush);
  pthread_join(h->tflush, &dummy);
  h->writer->wr_close(h->handle);
  if(!(h->afmt.fmtid == 0u))
    h->dsp->close(h->hdsp);

  if(!(h->vfmt.fmtid == 0u))
    drv->stopvideo(h_drv);

  sprintf(line, "fifo max fill: audio %d/%d, video %d/%d, convert %d/%d", h->afifo.max, h->afifo.slots, h->vfifo.max, h->vfifo.slots, h->cfifo.max, h->cfifo.slots);
  rec_status(line);
  free((void *)h);
  return 0;
}

// msg_handler
// file common/commands.c line 1166
static signed int msg_handler(char *name, signed int argc, char **argv)
{
  if(!(display_message == ((void (*)(char *))NULL)))
    display_message(argv[(signed long int)0]);

  return 0;
}

// new_message
// file console/fbtv.c line 483
static void new_message(char *txt)
{
  strcpy(message, txt);
}

// new_title
// file console/fbtv.c line 477
static void new_title(char *txt)
{
  strcpy(default_title, txt);
}

// ng_aconv_register
// file libng/grab-ng.c line 409
signed int ng_aconv_register(signed int magic, char *plugname, struct ng_audio_conv *list, signed int count)
{
  signed int n;
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "audio converters");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    n = 0;
    for( ; !(n >= count); n = n + 1)
      list_add_tail(&(list + (signed long int)n)->list, &ng_aconv);
    return 0;
  }
}

// ng_attr_byid
// file ./libng/grab-ng.h line 257
struct ng_attribute * ng_attr_byid(struct ng_attribute *attrs, signed int id)
{
  if(attrs == ((struct ng_attribute *)NULL))
    return (struct ng_attribute *)(void *)0;

  else
    for( ; (_Bool)1; attrs = attrs + 1l)
    {
      if(attrs->name == ((const char *)NULL))
        return (struct ng_attribute *)(void *)0;

      if(attrs->id == id)
        return attrs;

    }
}

// ng_attr_byname
// file ./libng/grab-ng.h line 258
struct ng_attribute * ng_attr_byname(struct ng_attribute *attrs, char *name)
{
  if(attrs == ((struct ng_attribute *)NULL))
    return (struct ng_attribute *)(void *)0;

  else
    while((_Bool)1)
    {
      if(attrs->name == ((const char *)NULL))
        return (struct ng_attribute *)(void *)0;

      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(attrs->name, name);
      if(return_value_strcasecmp_1 == 0)
        return attrs;

      attrs = attrs + 1l;
    }
}

// ng_attr_getint
// file ./libng/grab-ng.h line 260
signed int ng_attr_getint(struct ng_attribute *attr, char *value)
{
  signed int i;
  signed int val;
  if(attr == ((struct ng_attribute *)NULL))
    return -1;

  else
    if(!(attr->type == 2))
      return -1;

    else
    {
      i = 0;
      for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
      {
        signed int return_value_strcasecmp_1;
        return_value_strcasecmp_1=strcasecmp((attr->choices + (signed long int)i)->str, value);
        if(return_value_strcasecmp_1 == 0)
          return (signed int)(attr->choices + (signed long int)i)->nr;

      }
      const unsigned short int **return_value___ctype_b_loc_2;
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*value]) == 0))
      {
        val=atoi(value);
        i = 0;
        for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
          if((signed long int)val == (attr->choices + (signed long int)i)->nr)
            return (signed int)(attr->choices + (signed long int)i)->nr;

      }

      return -1;
    }
}

// ng_attr_getstr
// file ./libng/grab-ng.h line 259
const char * ng_attr_getstr(struct ng_attribute *attr, signed int value)
{
  signed int i;
  if(attr == ((struct ng_attribute *)NULL))
    return (const char *)(void *)0;

  else
    if(!(attr->type == 2))
      return (const char *)(void *)0;

    else
    {
      i = 0;
      for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
        if((attr->choices + (signed long int)i)->nr == (signed long int)value)
          return (attr->choices + (signed long int)i)->str;

      return (const char *)(void *)0;
    }
}

// ng_attr_int2percent
// file ./libng/grab-ng.h line 262
signed int ng_attr_int2percent(struct ng_attribute *attr, signed int value)
{
  signed int range;
  signed int percent;
  range = attr->max - attr->min;
  percent = ((value - attr->min) * 100) / range;
  if(!(percent >= 0))
    percent = 0;

  if(percent >= 101)
    percent = 100;

  return percent;
}

// ng_attr_listchoices
// file ./libng/grab-ng.h line 261
void ng_attr_listchoices(struct ng_attribute *attr)
{
  signed int i;
  fprintf(stderr, "valid choices for \"%s\": ", attr->name);
  i = 0;
  for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    fprintf(stderr, "%s\"%s\"", i != 0 ? ", " : "", (attr->choices + (signed long int)i)->str);
  fprintf(stderr, "\n");
}

// ng_attr_parse_int
// file ./libng/grab-ng.h line 264
signed int ng_attr_parse_int(struct ng_attribute *attr, char *str)
{
  signed int value;
  signed int n;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(str, "%d%n", &value, &n);
  if(return_value_sscanf_1 == 0)
    return attr->defval;

  else
  {
    if((signed int)str[(signed long int)n] == 37)
      value=ng_attr_percent2int(attr, value);

    if(!(value >= attr->min))
      value = attr->min;

    if(!(attr->max >= value))
      value = attr->max;

    return value;
  }
}

// ng_attr_percent2int
// file libng/grab-ng.c line 297
signed int ng_attr_percent2int(struct ng_attribute *attr, signed int percent)
{
  signed int range;
  signed int value;
  range = attr->max - attr->min;
  value = (percent * range) / 100 + attr->min;
  if(!(value >= attr->min))
    value = attr->min;

  if(!(attr->max >= value))
    value = attr->max;

  return value;
}

// ng_check_clipping
// file libng/grab-ng.c line 847
void ng_check_clipping(signed int width, signed int height, signed int xadjust, signed int yadjust, struct OVERLAY_CLIP *oc, signed int *count)
{
  signed int i;
  signed int j;
  if(ng_debug >= 2)
  {
    fprintf(stderr, "clip: win=%dx%d xa=%d ya=%d\n", width, height, xadjust, yadjust);
    clip_dump("init", oc, *count);
  }

  i = 0;
  for( ; !(i >= *count); i = i + 1)
  {
    (oc + (signed long int)i)->x1 = (oc + (signed long int)i)->x1 + xadjust;
    (oc + (signed long int)i)->x2 = (oc + (signed long int)i)->x2 + xadjust;
    (oc + (signed long int)i)->y1 = (oc + (signed long int)i)->y1 + yadjust;
    (oc + (signed long int)i)->y2 = (oc + (signed long int)i)->y2 + yadjust;
  }
  if(ng_debug >= 2)
    clip_dump("fixup adjust", oc, *count);

  i = 0;
  for( ; !(i >= *count); i = i + 1)
  {
    if(!((oc + (signed long int)i)->x1 >= 0))
      (oc + (signed long int)i)->x1 = 0;

    if(!((oc + (signed long int)i)->x2 >= 0))
      (oc + (signed long int)i)->x2 = 0;

    if(!(width >= (oc + (signed long int)i)->x1))
      (oc + (signed long int)i)->x1 = width;

    if(!(width >= (oc + (signed long int)i)->x2))
      (oc + (signed long int)i)->x2 = width;

    if(!((oc + (signed long int)i)->y1 >= 0))
      (oc + (signed long int)i)->y1 = 0;

    if(!((oc + (signed long int)i)->y2 >= 0))
      (oc + (signed long int)i)->y2 = 0;

    if(!(height >= (oc + (signed long int)i)->y1))
      (oc + (signed long int)i)->y1 = height;

    if(!(height >= (oc + (signed long int)i)->y2))
      (oc + (signed long int)i)->y2 = height;

  }
  if(ng_debug >= 2)
    clip_dump("fixup range", oc, *count);

  i = 0;
  while(!(i >= *count))
  {
    _Bool tmp_if_expr_1;
    if((oc + (signed long int)i)->x1 == (oc + (signed long int)i)->x2)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (oc + (signed long int)i)->y1 == (oc + (signed long int)i)->y2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      clip_drop(oc, i, count);

    else
      i = i + 1;
  }
  if(ng_debug >= 2)
    clip_dump("zerosize done", oc, *count);

  do
  {

  restart_merge:
    ;
    j = *count - 1;

  __CPROVER_DUMP_L23:
    ;
    if(!(j >= 0))
      goto __CPROVER_DUMP_L34;

    i = 0;

  __CPROVER_DUMP_L24:
    ;
    if(i >= *count)
      goto __CPROVER_DUMP_L33;

    if(i == j)
      break;

    if((oc + (signed long int)i)->x1 == (oc + (signed long int)j)->x1)
    {
      if((oc + (signed long int)i)->x2 == (oc + (signed long int)j)->x2)
      {
        if((oc + (signed long int)j)->y1 >= (oc + (signed long int)i)->y1)
        {
          if((oc + (signed long int)i)->y2 >= (oc + (signed long int)j)->y1)
          {
            if(ng_debug >= 2)
              fprintf(stderr, "clip: merge y %d,%d\n", i, j);

            if(!((oc + (signed long int)i)->y2 >= (oc + (signed long int)j)->y2))
              (oc + (signed long int)i)->y2 = (oc + (signed long int)j)->y2;

            clip_drop(oc, j, count);
            if(ng_debug >= 2)
              clip_dump("merge y done", oc, *count);

            goto restart_merge;
          }

        }

      }

    }

    if(!((oc + (signed long int)i)->y1 == (oc + (signed long int)j)->y1))
      break;

    if(!((oc + (signed long int)i)->y2 == (oc + (signed long int)j)->y2))
      break;

    if(!((oc + (signed long int)j)->x1 >= (oc + (signed long int)i)->x1))
      break;

    if(!((oc + (signed long int)i)->x2 >= (oc + (signed long int)j)->x1))
      break;

    if(ng_debug >= 2)
      fprintf(stderr, "clip: merge x %d,%d\n", i, j);

    if(!((oc + (signed long int)i)->x2 >= (oc + (signed long int)j)->x2))
      (oc + (signed long int)i)->x2 = (oc + (signed long int)j)->x2;

    clip_drop(oc, j, count);
    if(ng_debug >= 2)
      clip_dump("merge x done", oc, *count);

  }
  while((_Bool)1);
  i = i + 1;
  goto __CPROVER_DUMP_L24;

__CPROVER_DUMP_L33:
  ;
  j = j - 1;
  goto __CPROVER_DUMP_L23;

__CPROVER_DUMP_L34:
  ;
  if(!(ng_debug == 0))
    clip_dump("final", oc, *count);

}

// ng_check_magic
// file libng/grab-ng.c line 381
static signed int ng_check_magic(signed int magic, char *plugname, char *type)
{
  if(!(magic == 0x20030129))
  {
    fprintf(stderr, "ERROR: plugin magic mismatch [xawtv=%d,%s=%d]\n", 0x20030129, plugname, magic);
    return -1;
  }

  else
    return 0;
}

// ng_color_packed_init
// file libng/grab-ng.h line 479
void ng_color_packed_init(void)
{
  ng_conv_register(0x20030129, "built-in", conv_list, nconv);
}

// ng_color_yuv2rgb_init
// file libng/grab-ng.h line 480
void ng_color_yuv2rgb_init(void)
{
  signed int i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    ng_yuv_gray[(signed long int)i] = (unsigned int)(i * 256 >> 8);
    ng_yuv_red[(signed long int)i] = (unsigned int)(-128 * 512 + i * 512 >> 8);
    ng_yuv_blue[(signed long int)i] = (unsigned int)(-128 * 512 + i * 512 >> 8);
    ng_yuv_g1[(signed long int)i] = (unsigned int)(-(-128 * 512) / 2 + i * (-512 / 2) >> 8);
    ng_yuv_g2[(signed long int)i] = (unsigned int)(-(-128 * 512) / 6 + i * (-512 / 6) >> 8);
  }
  i = 0;
  for( ; !(i >= 320); i = i + 1)
    ng_clip[(signed long int)i] = (unsigned int)0;
  for( ; !(i >= 256); i = i + 1)
    ng_clip[(signed long int)i] = (unsigned int)(i - 320);
  for( ; !(i >= 256); i = i + 1)
    ng_clip[(signed long int)i] = (unsigned int)255;
  ng_conv_register(0x20030129, "built-in", conv_list_link1, nconv_link1);
}

// ng_conv_find_from
// file libng/grab-ng.c line 504
struct ng_video_conv * ng_conv_find_from(unsigned int in, signed int *i)
{
  struct list_head *item;
  struct ng_video_conv *ret;
  signed int j = 0;
  item = (&ng_conv)->next;
  for( ; !(item == &ng_conv); item = item->next)
    if(!(j >= *i))
      j = j + 1;

    else
    {
      ret = (struct ng_video_conv *)((char *)item - (signed long int)(unsigned long int)&((struct ng_video_conv *)0)->list);
      if(ret->fmtid_in == in)
      {
        *i = *i + 1;
        return ret;
      }

    }
  return (struct ng_video_conv *)(void *)0;
}

// ng_conv_find_match
// file libng/grab-ng.c line 531
struct ng_video_conv * ng_conv_find_match(unsigned int in, unsigned int out)
{
  struct list_head *item;
  struct ng_video_conv *ret = (struct ng_video_conv *)(void *)0;
  item = (&ng_conv)->next;
  for( ; !(item == &ng_conv); item = item->next)
  {
    ret = (struct ng_video_conv *)((char *)item - (signed long int)(unsigned long int)&((struct ng_video_conv *)0)->list);
    if(ret->fmtid_in == in)
    {
      if(ret->fmtid_out == out)
        return ret;

    }

  }
  return (struct ng_video_conv *)(void *)0;
}

// ng_conv_find_to
// file ./libng/grab-ng.h line 445
struct ng_video_conv * ng_conv_find_to(unsigned int out, signed int *i)
{
  struct list_head *item;
  struct ng_video_conv *ret;
  signed int j = 0;
  item = (&ng_conv)->next;
  for( ; !(item == &ng_conv); item = item->next)
    if(!(j >= *i))
      j = j + 1;

    else
    {
      ret = (struct ng_video_conv *)((char *)item - (signed long int)(unsigned long int)&((struct ng_video_conv *)0)->list);
      if(ret->fmtid_out == out)
      {
        *i = *i + 1;
        return ret;
      }

      *i = *i + 1;
      j = j + 1;
    }
  return (struct ng_video_conv *)(void *)0;
}

// ng_conv_nop_fini
// file libng/color_common.c line 56
void ng_conv_nop_fini(void *handle)
{
  ;
}

// ng_conv_nop_init
// file libng/color_common.c line 49
void * ng_conv_nop_init(struct ng_video_fmt *out, void *priv)
{
  return (void *)0;
}

// ng_conv_register
// file libng/grab-ng.c line 396
signed int ng_conv_register(signed int magic, char *plugname, struct ng_video_conv *list, signed int count)
{
  signed int n;
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "video converters");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    n = 0;
    for( ; !(n >= count); n = n + 1)
      list_add_tail(&(list + (signed long int)n)->list, &ng_conv);
    return 0;
  }
}

// ng_convert_alloc
// file ./libng/grab-ng.h line 373
struct ng_convert_handle * ng_convert_alloc(struct ng_video_conv *conv, struct ng_video_fmt *i, struct ng_video_fmt *o)
{
  struct ng_convert_handle *h;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ng_convert_handle) /*56ul*/ );
  h = (struct ng_convert_handle *)return_value_malloc_1;
  if(h == ((struct ng_convert_handle *)NULL))
    return ((struct ng_convert_handle *)NULL);

  else
  {
    memset((void *)h, 0, sizeof(struct ng_convert_handle) /*56ul*/ );
    o->width = i->width;
    o->height = i->height;
    if(o->bytesperline == 0u)
      o->bytesperline = (o->width * ng_vfmt_to_depth[(signed long int)o->fmtid]) / (unsigned int)8;

    h->ifmt = *i;
    h->ofmt = *o;
    if(!(conv == ((struct ng_video_conv *)NULL)))
      h->conv = conv;

    return h;
  }
}

// ng_convert_copyframe
// file libng/convert.c line 69
static void ng_convert_copyframe(struct ng_video_buf *dest, struct ng_video_buf *src)
{
  unsigned int i;
  unsigned int sw;
  unsigned int dw;
  unsigned char *sp;
  unsigned char *dp;
  dw = (dest->fmt.width * ng_vfmt_to_depth[(signed long int)dest->fmt.fmtid]) / (unsigned int)8;
  sw = (src->fmt.width * ng_vfmt_to_depth[(signed long int)src->fmt.fmtid]) / (unsigned int)8;
  _Bool tmp_if_expr_1;
  if(src->fmt.bytesperline == sw)
    tmp_if_expr_1 = dest->fmt.bytesperline == dw ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    memcpy((void *)dest->data, (const void *)src->data, (unsigned long int)(src->fmt.bytesperline * src->fmt.height));

  else
  {
    dp = dest->data;
    sp = src->data;
    i = (unsigned int)0;
    for( ; !(i >= src->fmt.height); i = i + 1u)
    {
      memcpy((void *)dp, (const void *)sp, (unsigned long int)dw);
      dp = dp + (signed long int)dest->fmt.bytesperline;
      sp = sp + (signed long int)src->fmt.bytesperline;
    }
  }
}

// ng_convert_fini
// file ./libng/grab-ng.h line 380
void ng_convert_fini(struct ng_convert_handle *h)
{
  if(!(h->conv == ((struct ng_video_conv *)NULL)))
    h->conv->fini(h->chandle);

  free((void *)h);
}

// ng_convert_frame
// file ./libng/grab-ng.h line 377
struct ng_video_buf * ng_convert_frame(struct ng_convert_handle *h, struct ng_video_buf *dest, struct ng_video_buf *buf)
{
  if(buf == ((struct ng_video_buf *)NULL))
    return (struct ng_video_buf *)(void *)0;

  else
  {
    if(dest == ((struct ng_video_buf *)NULL))
    {
      if(!(h->conv == ((struct ng_video_conv *)NULL)))
        dest=ng_malloc_video_buf(&h->ofmt, h->osize);

    }

    if(!(dest == ((struct ng_video_buf *)NULL)))
    {
      dest->fmt = h->ofmt;
      dest->size = (unsigned long int)h->osize;
      if(!(h->conv == ((struct ng_video_conv *)NULL)))
        h->conv->frame(h->chandle, dest, buf);

      else
        ng_convert_copyframe(dest, buf);
      dest->info = buf->info;
      ng_release_video_buf(buf);
      buf = dest;
    }

    return buf;
  }
}

// ng_convert_init
// file ./libng/grab-ng.h line 376
void ng_convert_init(struct ng_convert_handle *h)
{
  if(h->ifmt.bytesperline == 0u)
    h->ifmt.bytesperline = (h->ifmt.width * ng_vfmt_to_depth[(signed long int)h->ifmt.fmtid]) / (unsigned int)8;

  if(h->ofmt.bytesperline == 0u)
    h->ofmt.bytesperline = (h->ofmt.width * ng_vfmt_to_depth[(signed long int)h->ofmt.fmtid]) / (unsigned int)8;

  h->isize = (signed int)(h->ifmt.height * h->ifmt.bytesperline);
  if(h->isize == 0)
    h->isize = (signed int)(h->ifmt.width * h->ifmt.height * (unsigned int)3);

  h->osize = (signed int)(h->ofmt.height * h->ofmt.bytesperline);
  if(h->osize == 0)
    h->osize = (signed int)(h->ofmt.width * h->ofmt.height * (unsigned int)3);

  if(!(h->conv == ((struct ng_video_conv *)NULL)))
    h->chandle=h->conv->init(&h->ofmt, h->conv->priv);

  if(!(ng_debug == 0))
  {
    fprintf(stderr, "convert-in : %dx%d %s (size=%d)\n", h->ifmt.width, h->ifmt.height, ng_vfmt_to_desc[(signed long int)h->ifmt.fmtid], h->isize);
    fprintf(stderr, "convert-out: %dx%d %s (size=%d)\n", h->ofmt.width, h->ofmt.height, ng_vfmt_to_desc[(signed long int)h->ofmt.fmtid], h->osize);
  }

}

// ng_convert_single
// file ./libng/grab-ng.h line 381
struct ng_video_buf * ng_convert_single(struct ng_convert_handle *h, struct ng_video_buf *in)
{
  struct ng_video_buf *out;
  ng_convert_init(h);
  out=ng_convert_frame(h, (struct ng_video_buf *)(void *)0, in);
  ng_convert_fini(h);
  return out;
}

// ng_convert_thread
// file common/capture.c line 132
void * ng_convert_thread(void *arg)
{
  struct ng_convthread_handle *h = (struct ng_convthread_handle *)arg;
  struct ng_video_buf *in;
  struct ng_video_buf *out;
  signed int return_value_getpid_1;
  if(!(debug == 0))
  {
    return_value_getpid_1=getpid();
    fprintf(stderr, "convert_thread start [pid=%d]\n", return_value_getpid_1);
  }

  ng_convert_init(h->c);
  signed int return_value_webcam_put_3;
  do
  {
    void *return_value_fifo_get_2;
    return_value_fifo_get_2=fifo_get(h->in);
    in = (struct ng_video_buf *)return_value_fifo_get_2;
    if(in == ((struct ng_video_buf *)NULL))
      break;

    out=ng_convert_frame(h->c, (struct ng_video_buf *)(void *)0, in);
    if(!(webcam == ((char *)NULL)))
    {
      return_value_webcam_put_3=webcam_put(webcam, out);
      if(return_value_webcam_put_3 == 0)
      {
        free((void *)webcam);
        webcam = (char *)(void *)0;
      }

    }

    fifo_put(h->out, (void *)out);
  }
  while((_Bool)1);
  fifo_put(h->out, (void *)0);
  ng_convert_fini(h->c);
  signed int return_value_getpid_4;
  if(!(debug == 0))
  {
    return_value_getpid_4=getpid();
    fprintf(stderr, "convert_thread done [pid=%d]\n", return_value_getpid_4);
  }

  return (void *)0;
}

// ng_device_init
// file libng/devices.h line 14
void ng_device_init(void)
{
  struct stat st;
  signed int return_value_lstat_1;
  return_value_lstat_1=lstat("/dev/.devfsd", &st);
  if(!(return_value_lstat_1 == -1))
  {
    if((61440u & st.st_mode) == 8192u)
      ng_dev = ng_dev_devfs;

  }

}

// ng_dsp_driver_register
// file libng/grab-ng.c line 458
signed int ng_dsp_driver_register(signed int magic, char *plugname, struct ng_dsp_driver *driver)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "dsp drv");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail(&driver->list, &ng_dsp_drivers);
    return 0;
  }
}

// ng_dsp_open
// file ./libng/grab-ng.h line 452
struct ng_dsp_driver * ng_dsp_open(char *device, struct ng_audio_fmt *fmt, signed int record, void **handle)
{
  struct list_head *item;
  struct ng_dsp_driver *ng_dsp_open__1__drv;
  item = (&ng_dsp_drivers)->next;
  for( ; !(item == &ng_dsp_drivers); item = item->next)
  {
    ng_dsp_open__1__drv = (struct ng_dsp_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_dsp_driver *)0)->list);
    if(!(ng_dsp_open__1__drv->name == ((const char *)NULL)))
    {
      if(!(record == 0))
      {
        if(ng_dsp_open__1__drv->read == ((struct ng_audio_buf * (*)(void *, signed long int))NULL))
          goto __CPROVER_DUMP_L5;

      }

      if(record == 0)
      {
        if(ng_dsp_open__1__drv->write == ((struct ng_audio_buf * (*)(void *, struct ng_audio_buf *))NULL))
          goto __CPROVER_DUMP_L5;

      }

      if(!(ng_debug == 0))
        fprintf(stderr, "dsp-open: trying: %s... \n", ng_dsp_open__1__drv->name);

      *handle=ng_dsp_open__1__drv->open(device, fmt, record);
      if(!(*handle == NULL))
        break;

      if(!(ng_debug == 0))
        fprintf(stderr, "dsp-open: failed: %s\n", ng_dsp_open__1__drv->name);

    }


  __CPROVER_DUMP_L5:
    ;
  }
  if(item == &ng_dsp_drivers)
    return (struct ng_dsp_driver *)(void *)0;

  else
  {
    if(!(ng_debug == 0))
      fprintf(stderr, "dsp-open: ok: %s\n", ng_dsp_open__1__drv->name);

    return ng_dsp_open__1__drv;
  }
}

// ng_filter_register
// file libng/grab-ng.c line 422
signed int ng_filter_register(signed int magic, char *plugname, struct ng_filter *filter)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "filter");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail(&filter->list, &ng_filters);
    return 0;
  }
}

// ng_filter_single
// file ./libng/grab-ng.h line 461
struct ng_video_buf * ng_filter_single(struct ng_filter *filter, struct ng_video_buf *in)
{
  struct ng_video_buf *out = in;
  void *handle;
  if(!(filter == ((struct ng_filter *)NULL)))
  {
    if(!((filter->fmts & 1 << in->fmt.fmtid) == 0))
    {
      handle=filter->init(&in->fmt);
      out=filter->frame(handle, in);
      filter->fini(handle);
    }

  }

  return out;
}

// ng_find_reader
// file libng/grab-ng.c line 763
struct ng_reader * ng_find_reader(char *filename)
{
  struct list_head *item;
  struct ng_reader *reader;
  char blk[512l];
  struct _IO_FILE *fp;
  signed int m;
  fp=fopen(filename, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "open %s: %s\n", filename, return_value_strerror_2);
    return (struct ng_reader *)(void *)0;
  }

  memset((void *)blk, 0, sizeof(char [512l]) /*512ul*/ );
  fread((void *)blk, (unsigned long int)1, sizeof(char [512l]) /*512ul*/ , fp);
  fclose(fp);
  item = (&ng_readers)->next;
  _Bool tmp_if_expr_3;
  for( ; !(item == &ng_readers); item = item->next)
  {
    reader = (struct ng_reader *)((char *)item - (signed long int)(unsigned long int)&((struct ng_reader *)0)->list);
    m = 0;
    do
    {
      if(!(m >= 4))
        tmp_if_expr_3 = reader->mlen[(signed long int)m] > 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      signed int return_value_memcmp_4;
      return_value_memcmp_4=memcmp((const void *)(blk + (signed long int)reader->moff[(signed long int)m]), (const void *)reader->magic[(signed long int)m], (unsigned long int)reader->mlen[(signed long int)m]);
      if(return_value_memcmp_4 == 0)
        return reader;

      m = m + 1;
    }
    while((_Bool)1);
  }
  if(!(ng_debug == 0))
    fprintf(stderr, "%s: no reader found\n", filename);

  return (struct ng_reader *)(void *)0;
}

// ng_free_video_buf
// file libng/grab-ng.c line 154
static void ng_free_video_buf(struct ng_video_buf *buf)
{
  free((void *)buf->data);
  free((void *)buf);
}

// ng_get_timestamp
// file ./libng/grab-ng.h line 458
signed long int ng_get_timestamp(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  signed long int return_value_ng_tofday_to_timestamp_1;
  return_value_ng_tofday_to_timestamp_1=ng_tofday_to_timestamp(&tv);
  return return_value_ng_tofday_to_timestamp_1;
}

// ng_grabber_findconv
// file ./common/capture.h line 21
struct ng_video_conv * ng_grabber_findconv(struct ng_video_fmt *fmt, signed int fix_ratio)
{
  struct ng_video_fmt ng_grabber_findconv__1__gfmt;
  struct ng_video_conv *ng_grabber_findconv__1__conv;
  signed int i = 0;
  do
  {
    ng_grabber_findconv__1__conv=ng_conv_find_to(fmt->fmtid, &i);
    if(ng_grabber_findconv__1__conv == ((struct ng_video_conv *)NULL))
      break;

    ng_grabber_findconv__1__gfmt = *fmt;
    ng_grabber_findconv__1__gfmt.fmtid = ng_grabber_findconv__1__conv->fmtid_in;
    signed int return_value_ng_grabber_setformat_1;
    return_value_ng_grabber_setformat_1=ng_grabber_setformat(&ng_grabber_findconv__1__gfmt, fix_ratio);
    if(return_value_ng_grabber_setformat_1 == 0)
      goto found;

  }
  while((_Bool)1);
  fprintf(stderr, "no way to get: %dx%d %s\n", fmt->width, fmt->height, ng_vfmt_to_desc[(signed long int)fmt->fmtid]);
  return (struct ng_video_conv *)(void *)0;

found:
  ;
  *fmt = ng_grabber_findconv__1__gfmt;
  return ng_grabber_findconv__1__conv;
}

// ng_grabber_get_image
// file common/capture.h line 24
struct ng_video_buf * ng_grabber_get_image(struct ng_video_fmt *fmt)
{
  struct ng_video_fmt ng_grabber_get_image__1__gfmt;
  struct ng_video_conv *ng_grabber_get_image__1__conv;
  struct ng_convert_handle *ng_grabber_get_image__1__ch;
  struct ng_video_buf *ng_grabber_get_image__1__buf;
  signed int return_value_ng_grabber_setformat_2;
  return_value_ng_grabber_setformat_2=ng_grabber_setformat(fmt, 1);
  struct ng_video_buf *return_value_ng_grabber_grab_image_1;
  if(return_value_ng_grabber_setformat_2 == 0)
  {
    return_value_ng_grabber_grab_image_1=ng_grabber_grab_image(1);
    return return_value_ng_grabber_grab_image_1;
  }

  ng_grabber_get_image__1__gfmt = *fmt;
  ng_grabber_get_image__1__conv=ng_grabber_findconv(&ng_grabber_get_image__1__gfmt, 1);
  if(ng_grabber_get_image__1__conv == ((struct ng_video_conv *)NULL))
    return (struct ng_video_buf *)(void *)0;

  else
  {
    ng_grabber_get_image__1__ch=ng_convert_alloc(ng_grabber_get_image__1__conv, &ng_grabber_get_image__1__gfmt, fmt);
    ng_grabber_get_image__1__buf=ng_grabber_grab_image(1);
    if(ng_grabber_get_image__1__buf == ((struct ng_video_buf *)NULL))
      return (struct ng_video_buf *)(void *)0;

    else
    {
      ng_grabber_get_image__1__buf=ng_convert_single(ng_grabber_get_image__1__ch, ng_grabber_get_image__1__buf);
      return ng_grabber_get_image__1__buf;
    }
  }
}

// ng_grabber_grab_image
// file ./common/capture.h line 23
struct ng_video_buf * ng_grabber_grab_image(signed int single)
{
  struct ng_video_buf *tmp_if_expr_1;
  struct ng_video_buf *return_value;
  struct ng_video_buf *return_value_1;
  if(!(single == 0))
  {
    return_value=drv->getimage(h_drv);
    tmp_if_expr_1 = return_value;
  }

  else
  {
    return_value_1=drv->nextframe(h_drv);
    tmp_if_expr_1 = return_value_1;
  }
  return tmp_if_expr_1;
}

// ng_grabber_setformat
// file ./common/capture.h line 20
signed int ng_grabber_setformat(struct ng_video_fmt *fmt, signed int fix_ratio)
{
  struct ng_video_fmt ng_grabber_setformat__1__gfmt;
  signed int rc;
  if((2 & f_drv) == 0)
    return -1;

  else
  {
    ng_grabber_setformat__1__gfmt = *fmt;
    rc=drv->setformat(h_drv, &ng_grabber_setformat__1__gfmt);
    if(!(debug == 0))
      fprintf(stderr, "setformat: %s (%dx%d): %s\n", ng_vfmt_to_desc[(signed long int)ng_grabber_setformat__1__gfmt.fmtid], ng_grabber_setformat__1__gfmt.width, ng_grabber_setformat__1__gfmt.height, 0 == rc ? "ok" : "failed");

    if(!(rc == 0))
      return -1;

    else
    {
      if(!(fix_ratio == 0))
      {
        ng_ratio_fixup((signed int *)&ng_grabber_setformat__1__gfmt.width, (signed int *)&ng_grabber_setformat__1__gfmt.height, (signed int *)(void *)0, (signed int *)(void *)0);
        ng_grabber_setformat__1__gfmt.bytesperline = (unsigned int)0;
        signed int return_value;
        return_value=drv->setformat(h_drv, &ng_grabber_setformat__1__gfmt);
        if(!(return_value == 0))
        {
          fprintf(stderr, "Oops: ratio size renegotiation failed\n");
          exit(1);
        }

      }

      *fmt = ng_grabber_setformat__1__gfmt;
      return 0;
    }
  }
}

// ng_init
// file ./libng/grab-ng.h line 466
void ng_init(void)
{
  signed int ng_init__1__count = 0;
  static signed int once = 0;
  signed int tmp_post_1 = once;
  once = once + 1;
  if(!(tmp_post_1 == 0))
  {
    fprintf(stderr, "panic: ng_init called twice\n");
    exit(1);
  }

  ng_device_init();
  ng_color_packed_init();
  ng_color_yuv2rgb_init();
  ng_writefile_init();
  signed int return_value_ng_plugins_2;
  return_value_ng_plugins_2=ng_plugins("/usr/lib/x86_64-linux-gnu/xawtv");
  ng_init__1__count = ng_init__1__count + return_value_ng_plugins_2;
  if(ng_init__1__count == 0)
  {
    signed int return_value_ng_plugins_3;
    return_value_ng_plugins_3=ng_plugins("../libng/plugins");
    ng_init__1__count = ng_init__1__count + return_value_ng_plugins_3;
    signed int return_value_ng_plugins_4;
    return_value_ng_plugins_4=ng_plugins("../libng/contrib-plugins");
    ng_init__1__count = ng_init__1__count + return_value_ng_plugins_4;
  }

  if(ng_init__1__count == 0)
    fprintf(stderr, "WARNING: no plugins found [%s]\n", (const void *)"/usr/lib/x86_64-linux-gnu/xawtv");

}

// ng_init_video_buf
// file libng/grab-ng.c line 122
void ng_init_video_buf(struct ng_video_buf *buf)
{
  memset((void *)buf, 0, sizeof(struct ng_video_buf) /*160ul*/ );
  pthread_mutex_init(&buf->lock, (const union anonymous_9 *)(void *)0);
  pthread_cond_init(&buf->cond, (const union anonymous_9 *)(void *)0);
}

// ng_lut_init
// file libng/color_lut.c line 241
void ng_lut_init(unsigned long int red_mask, unsigned long int green_mask, unsigned long int blue_mask, unsigned int fmtid, signed int swap)
{
  signed int rgb_red_bits = 0;
  signed int rgb_red_shift = 0;
  signed int rgb_green_bits = 0;
  signed int rgb_green_shift = 0;
  signed int rgb_blue_bits = 0;
  signed int rgb_blue_shift = 0;
  unsigned int i;
  unsigned int mask;
  static signed int once = 0;
  signed int tmp_post_1 = once;
  once = once + 1;
  if(!(tmp_post_1 == 0))
  {
    fprintf(stderr, "panic: ng_lut_init called twice\n");
    exit(1);
  }

  i = (unsigned int)0;
  for( ; !(i >= 32u); i = i + 1u)
  {
    mask = (unsigned int)(1 << i);
    if(!((red_mask & (unsigned long int)mask) == 0ul))
      rgb_red_bits = rgb_red_bits + 1;

    else
      if(rgb_red_bits == 0)
        rgb_red_shift = rgb_red_shift + 1;

    if(!((green_mask & (unsigned long int)mask) == 0ul))
      rgb_green_bits = rgb_green_bits + 1;

    else
      if(rgb_green_bits == 0)
        rgb_green_shift = rgb_green_shift + 1;

    if(!((blue_mask & (unsigned long int)mask) == 0ul))
      rgb_blue_bits = rgb_blue_bits + 1;

    else
      if(rgb_blue_bits == 0)
        rgb_blue_shift = rgb_blue_shift + 1;

  }
  if(rgb_red_bits >= 9)
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_red[(signed long int)i] = (unsigned long int)(i << (rgb_red_bits + rgb_red_shift) - 8);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_red[(signed long int)i] = (unsigned long int)((i >> 8 - rgb_red_bits) << rgb_red_shift);
  }
  if(rgb_green_bits >= 9)
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_green[(signed long int)i] = (unsigned long int)(i << (rgb_green_bits + rgb_green_shift) - 8);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_green[(signed long int)i] = (unsigned long int)((i >> 8 - rgb_green_bits) << rgb_green_shift);
  }
  if(rgb_blue_bits >= 9)
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_blue[(signed long int)i] = (unsigned long int)(i << (rgb_blue_bits + rgb_blue_shift) - 8);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_blue[(signed long int)i] = (unsigned long int)((i >> 8 - rgb_blue_bits) << rgb_blue_shift);
  }
  switch(ng_vfmt_to_depth[(signed long int)fmtid])
  {
    case (const unsigned int)16:
    {
      if(!(swap == 0))
      {
        i = (unsigned int)0;
        for( ; !(i >= 256u); i = i + 1u)
        {
          ng_lut_red[(signed long int)i] = ng_lut_red[(signed long int)i] >> 8 & (unsigned long int)0x00ff | ng_lut_red[(signed long int)i] << 8 & (unsigned long int)0xff00;
          ng_lut_green[(signed long int)i] = ng_lut_green[(signed long int)i] >> 8 & (unsigned long int)0x00ff | ng_lut_green[(signed long int)i] << 8 & (unsigned long int)0xff00;
          ng_lut_blue[(signed long int)i] = ng_lut_blue[(signed long int)i] >> 8 & (unsigned long int)0x00ff | ng_lut_blue[(signed long int)i] << 8 & (unsigned long int)0xff00;
        }
      }

      i = (unsigned int)0;
      for( ; !(i >= nconv2); i = i + 1u)
        lut2_list[(signed long int)i].fmtid_out = fmtid;
      ng_conv_register(0x20030129, "built-in", lut2_list, (signed int)nconv2);
      break;
    }
    case (const unsigned int)32:
    {
      if(!(swap == 0))
      {
        i = (unsigned int)0;
        for( ; !(i >= 256u); i = i + 1u)
        {
          ng_lut_red[(signed long int)i] = ng_lut_red[(signed long int)i] >> 24 & (unsigned long int)0x000000ff | ng_lut_red[(signed long int)i] >> 8 & (unsigned long int)0x0000ff00 | ng_lut_red[(signed long int)i] << 8 & (unsigned long int)0x00ff0000 | ng_lut_red[(signed long int)i] << 24 & (unsigned long int)0xff000000;
          ng_lut_green[(signed long int)i] = ng_lut_green[(signed long int)i] >> 24 & (unsigned long int)0x000000ff | ng_lut_green[(signed long int)i] >> 8 & (unsigned long int)0x0000ff00 | ng_lut_green[(signed long int)i] << 8 & (unsigned long int)0x00ff0000 | ng_lut_green[(signed long int)i] << 24 & (unsigned long int)0xff000000;
          ng_lut_blue[(signed long int)i] = ng_lut_blue[(signed long int)i] >> 24 & (unsigned long int)0x000000ff | ng_lut_blue[(signed long int)i] >> 8 & (unsigned long int)0x0000ff00 | ng_lut_blue[(signed long int)i] << 8 & (unsigned long int)0x00ff0000 | ng_lut_blue[(signed long int)i] << 24 & (unsigned long int)0xff000000;
        }
      }

      i = (unsigned int)0;
      for( ; !(i >= nconv4); i = i + 1u)
        lut4_list[(signed long int)i].fmtid_out = fmtid;
      ng_conv_register(0x20030129, "built-in", lut4_list, (signed int)nconv4);
    }
  }
}

// ng_malloc_audio_buf
// file libng/grab-ng.c line 184
struct ng_audio_buf * ng_malloc_audio_buf(struct ng_audio_fmt *fmt, signed int size)
{
  struct ng_audio_buf *ng_malloc_audio_buf__1__buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ng_audio_buf) /*32ul*/  + (unsigned long int)size);
  ng_malloc_audio_buf__1__buf = (struct ng_audio_buf *)return_value_malloc_1;
  memset((void *)ng_malloc_audio_buf__1__buf, 0, sizeof(struct ng_audio_buf) /*32ul*/ );
  ng_malloc_audio_buf__1__buf->fmt = *fmt;
  ng_malloc_audio_buf__1__buf->size = size;
  ng_malloc_audio_buf__1__buf->data = (char *)ng_malloc_audio_buf__1__buf + (signed long int)sizeof(struct ng_audio_buf) /*32ul*/ ;
  return ng_malloc_audio_buf__1__buf;
}

// ng_malloc_video_buf
// file libng/grab-ng.c line 161
struct ng_video_buf * ng_malloc_video_buf(struct ng_video_fmt *fmt, signed int size)
{
  struct ng_video_buf *ng_malloc_video_buf__1__buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ng_video_buf) /*160ul*/ );
  ng_malloc_video_buf__1__buf = (struct ng_video_buf *)return_value_malloc_1;
  if(ng_malloc_video_buf__1__buf == ((struct ng_video_buf *)NULL))
    return (struct ng_video_buf *)(void *)0;

  else
  {
    ng_init_video_buf(ng_malloc_video_buf__1__buf);
    ng_malloc_video_buf__1__buf->fmt = *fmt;
    ng_malloc_video_buf__1__buf->size = (unsigned long int)size;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)size);
    ng_malloc_video_buf__1__buf->data = (unsigned char *)return_value_malloc_2;
    if(ng_malloc_video_buf__1__buf->data == ((unsigned char *)NULL))
    {
      free((void *)ng_malloc_video_buf__1__buf);
      return (struct ng_video_buf *)(void *)0;
    }

    else
    {
      ng_malloc_video_buf__1__buf->refcount = 1;
      ng_malloc_video_buf__1__buf->release = ng_free_video_buf;
      return ng_malloc_video_buf__1__buf;
    }
  }
}

// ng_mix_driver_register
// file libng/grab-ng.c line 467
signed int ng_mix_driver_register(signed int magic, char *plugname, struct ng_mix_driver *driver)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "mixer drv");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail(&driver->list, &ng_mix_drivers);
    return 0;
  }
}

// ng_mix_init
// file ./libng/grab-ng.h line 454
struct ng_attribute * ng_mix_init(char *device, char *channel)
{
  struct list_head *item;
  struct ng_mix_driver *ng_mix_init__1__drv = (struct ng_mix_driver *)(void *)0;
  struct ng_attribute *ng_mix_init__1__attrs = (struct ng_attribute *)(void *)0;
  void *handle;
  item = (&ng_mix_drivers)->next;
  if(!(item == &ng_mix_drivers))
  {
    ng_mix_init__1__drv = (struct ng_mix_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_mix_driver *)0)->list);
    if(!(ng_debug == 0))
      fprintf(stderr, "mix-init: trying: %s... \n", ng_mix_init__1__drv->name);

    handle=ng_mix_init__1__drv->open(device);
    if(!(handle == NULL))
    {
      ng_mix_init__1__attrs=ng_mix_init__1__drv->volctl(handle, channel);
      ng_mix_init__1__drv->close(handle);
    }

    if(!(ng_debug == 0))
      fprintf(stderr, "mix-init: failed: %s\n", ng_mix_init__1__drv->name);

    item = item->next;
  }

  if(!(ng_mix_init__1__attrs == ((struct ng_attribute *)NULL)) && !(ng_debug == 0))
    fprintf(stderr, "mix-init: ok: %s\n", ng_mix_init__1__drv->name);

  return ng_mix_init__1__attrs;
}

// ng_packed_frame
// file libng/color_common.c line 22
void ng_packed_frame(void *handle, struct ng_video_buf *out, struct ng_video_buf *in)
{
  signed int (*func)(unsigned char *, unsigned char *, signed int) = (signed int (*)(unsigned char *, unsigned char *, signed int))handle;
  unsigned char *sp;
  unsigned char *dp;
  unsigned int i;
  unsigned int sw;
  unsigned int dw = out->fmt.width * ng_vfmt_to_depth[(signed long int)out->fmt.fmtid] >> 3;
  sw = in->fmt.width * ng_vfmt_to_depth[(signed long int)in->fmt.fmtid] >> 3;
  _Bool tmp_if_expr_1;
  if(in->fmt.bytesperline == sw)
    tmp_if_expr_1 = out->fmt.bytesperline == dw ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    func(out->data, in->data, (signed int)(in->fmt.width * in->fmt.height));

  else
  {
    dp = out->data;
    sp = in->data;
    i = (unsigned int)0;
    if(!(i >= in->fmt.height))
    {
      func(dp, sp, (signed int)in->fmt.width);
      dp = dp + (signed long int)out->fmt.bytesperline;
      sp = sp + (signed long int)in->fmt.bytesperline;
      i = i + 1u;
    }

  }
}

// ng_packed_init
// file libng/color_common.c line 16
void * ng_packed_init(struct ng_video_fmt *out, void *priv)
{
  return priv;
}

// ng_plugins
// file libng/grab-ng.c line 940
static signed int ng_plugins(char *dirname)
{
  struct dirent **list;
  char filename[1024l];
  void *plugin;
  void (*initcall)(void);
  signed int i;
  signed int n = 0;
  signed int l = 0;
  n=scandir(dirname, &list, (signed int (*)(struct dirent *))(void *)0, alphasort);
  if(!(n >= 1))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      signed int return_value_fnmatch_1;
      return_value_fnmatch_1=fnmatch("*.so", list[(signed long int)i]->d_name, 0);
      if(return_value_fnmatch_1 == 0)
      {
        sprintf(filename, "%s/%s", dirname, (const void *)list[(signed long int)i]->d_name);
        plugin=dlopen(filename, 0x00002);
        if(plugin == NULL)
        {
          char *return_value_dlerror_2;
          return_value_dlerror_2=dlerror();
          fprintf(stderr, "dlopen: %s\n", return_value_dlerror_2);
          goto __CPROVER_DUMP_L6;
        }

        void *return_value_dlsym_5;
        return_value_dlsym_5=dlsym(plugin, "ng_plugin_init");
        initcall = (void (*)(void))return_value_dlsym_5;
        if(initcall == ((void (*)(void))NULL))
        {
          void *return_value_dlsym_4;
          return_value_dlsym_4=dlsym(plugin, "_ng_plugin_init");
          initcall = (void (*)(void))return_value_dlsym_4;
          if(initcall == ((void (*)(void))NULL))
          {
            char *return_value_dlerror_3;
            return_value_dlerror_3=dlerror();
            fprintf(stderr, "dlsym[%s]: %s\n", (const void *)filename, return_value_dlerror_3);
            goto __CPROVER_DUMP_L6;
          }

        }

        initcall();
        l = l - 1;
      }


    __CPROVER_DUMP_L6:
      ;
    }
    i = 0;
    for( ; !(i >= n); i = i + 1)
      free((void *)list[(signed long int)i]);
    free((void *)list);
    return l;
  }
}

// ng_ratio_fixup
// file ./libng/grab-ng.h line 268
void ng_ratio_fixup(signed int *width, signed int *height, signed int *xoff, signed int *yoff)
{
  signed int h = *height;
  signed int w = *width;
  if(!(ng_ratio_x == 0) && !(ng_ratio_y == 0))
  {
    if(!(w * ng_ratio_y >= h * ng_ratio_x))
    {
      *height = (*width * ng_ratio_y) / ng_ratio_x;
      if(!(yoff == ((signed int *)NULL)))
        *yoff = *yoff + (h - *height) / 2;

    }

    else
      if(!(h * ng_ratio_x >= w * ng_ratio_y))
      {
        *width = (*height * ng_ratio_x) / ng_ratio_y;
        if(!(yoff == ((signed int *)NULL)))
          *xoff = *xoff + (w - *width) / 2;

      }

  }

}

// ng_ratio_fixup2
// file libng/grab-ng.c line 349
void ng_ratio_fixup2(signed int *width, signed int *height, signed int *xoff, signed int *yoff, signed int ratio_x, signed int ratio_y, signed int up)
{
  signed int h = *height;
  signed int w = *width;
  if(!(ratio_x == 0) && !(ratio_y == 0))
  {
    if(up == 0 && !(w * ratio_y >= h * ratio_x) || !(up == 0) && !(h * ratio_x >= w * ratio_y))
    {
      *height = (*width * ratio_y) / ratio_x;
      if(!(yoff == ((signed int *)NULL)))
        *yoff = *yoff + (h - *height) / 2;

    }

    else
      if(up == 0 && !(h * ratio_x >= w * ratio_y) || !(up == 0) && !(w * ratio_y >= h * ratio_x))
      {
        *width = (*height * ratio_x) / ratio_y;
        if(!(yoff == ((signed int *)NULL)))
          *xoff = *xoff + (w - *width) / 2;

      }

  }

}

// ng_reader_register
// file libng/grab-ng.c line 440
signed int ng_reader_register(signed int magic, char *plugname, struct ng_reader *reader)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "reader");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail(&reader->list, &ng_readers);
    return 0;
  }
}

// ng_release_video_buf
// file ./libng/grab-ng.h line 162
void ng_release_video_buf(struct ng_video_buf *buf)
{
  signed int release;
  pthread_mutex_lock(&buf->lock);
  buf->refcount = buf->refcount - 1;
  release = (signed int)(buf->refcount == 0);
  pthread_mutex_unlock(&buf->lock);
  if(!(release == 0))
  {
    if(!(buf->release == ((void (*)(struct ng_video_buf *))NULL)))
      buf->release(buf);

  }

}

// ng_rgb24_to_lut2
// file libng/color_lut.c line 30
void ng_rgb24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)0]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)2]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// ng_rgb24_to_lut4
// file libng/color_lut.c line 96
void ng_rgb24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)0]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)2]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// ng_tofday_to_timestamp
// file libng/grab-ng.c line 793
signed long int ng_tofday_to_timestamp(struct timeval *tv)
{
  signed long long int ts = tv->tv_sec;
  ts = ts * (signed long long int)1000000;
  ts = ts + tv->tv_usec;
  ts = ts * (signed long long int)1000;
  return ts;
}

// ng_vid_driver_register
// file libng/grab-ng.c line 449
signed int ng_vid_driver_register(signed int magic, char *plugname, struct ng_vid_driver *driver)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "video drv");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail(&driver->list, &ng_vid_drivers);
    return 0;
  }
}

// ng_vid_open
// file ./libng/grab-ng.h line 449
struct ng_vid_driver * ng_vid_open(char **device, char *driver, struct ng_video_fmt *screen, void *base, void **handle)
{
  struct list_head *item;
  struct ng_vid_driver *ng_vid_open__1__drv;
  signed int return_value_strcmp_5;
  signed int return_value;
  if(driver == ((char *)NULL))
  {
    fprintf(stderr, "Video4linux driver is not specified\n");
    return (struct ng_vid_driver *)(void *)0;
  }

  else
  {
    item = (&ng_vid_drivers)->next;
    for( ; !(item == &ng_vid_drivers); item = item->next)
    {
      ng_vid_open__1__drv = (struct ng_vid_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_vid_driver *)0)->list);
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(driver, ng_vid_open__1__drv->name);
      if(return_value_strcasecmp_1 == 0)
        break;

    }
    if(item == &ng_vid_drivers)
    {
      signed int return_value_strcasecmp_2;
      return_value_strcasecmp_2=strcasecmp(driver, "help");
      if(!(return_value_strcasecmp_2 == 0))
        fprintf(stderr, "Cannot find %s video driver\n", driver);

      fprintf(stderr, "Available drivers:");
      item = (&ng_vid_drivers)->next;
      for( ; !(item == &ng_vid_drivers); item = item->next)
      {
        ng_vid_open__1__drv = (struct ng_vid_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_vid_driver *)0)->list);
        fprintf(stderr, " %s", ng_vid_open__1__drv->name);
      }
      fprintf(stderr, "\n");
      return (struct ng_vid_driver *)(void *)0;
    }

    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(*device, "auto");
    _Bool tmp_if_expr_6;
    if(return_value_strcmp_4 == 0)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strcmp_5=strcmp(*device, "auto_tv");
      tmp_if_expr_6 = !(return_value_strcmp_5 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      char devpath[4096l];
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(*device, "auto_tv");
      *handle=ng_vid_open_auto(ng_vid_open__1__drv, devpath, !(return_value_strcmp_3 != 0) ? 0 : 1);
      if(*handle == NULL)
      {
        fprintf(stderr, "vid-open: could not find a suitable videodev\n");
        return (struct ng_vid_driver *)(void *)0;
      }

      *device=strdup(devpath);
    }

    else
    {
      if(!(ng_debug == 0))
        fprintf(stderr, "vid-open: trying: %s... \n", ng_vid_open__1__drv->name);

      *handle=ng_vid_open__1__drv->open(*device, 0);
      if(*handle == NULL)
      {
        fprintf(stderr, "vid-open: failed: %s\n", ng_vid_open__1__drv->name);
        return (struct ng_vid_driver *)(void *)0;
      }

      if(!(ng_debug == 0))
        fprintf(stderr, "vid-open: ok: %s\n", ng_vid_open__1__drv->name);

    }
    if(!(screen == ((struct ng_video_fmt *)NULL)))
    {
      return_value=ng_vid_open__1__drv->capabilities(*handle);
      if(!((1 & return_value) == 0))
      {
        signed int l;
        unsigned long int return_value_strlen_7;
        return_value_strlen_7=strlen(ng_v4l_conf);
        l = (signed int)return_value_strlen_7;
        snprintf(ng_v4l_conf + (signed long int)l, sizeof(char [256l]) /*256ul*/  - (unsigned long int)l, " -c %s", *device);
        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open: closing dev to run v4lconf\n");

        ng_vid_open__1__drv->close(*handle);
        signed int return_value_system_8;
        return_value_system_8=system(ng_v4l_conf);
        if(return_value_system_8 == -1)
          fprintf(stderr, "could'nt start v4l-conf\n");

        fprintf(stderr, "v4l-conf had some trouble, trying to continue anyway\n");
        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open: re-opening dev after v4lconf\n");

        *handle=ng_vid_open__1__drv->open(*device, 0);
        if(*handle == NULL)
        {
          fprintf(stderr, "vid-open: failed: %s\n", ng_vid_open__1__drv->name);
          return (struct ng_vid_driver *)(void *)0;
        }

        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open: re-open ok\n");

        ng_vid_open__1__drv->setupfb(*handle, screen, base);
      }

    }

    return ng_vid_open__1__drv;
  }
}

// ng_vid_open_auto
// file libng/grab-ng.c line 547
static void * ng_vid_open_auto(struct ng_vid_driver *drv, char *devpath, signed int allow_grabber)
{
  void *md;
  void *handle = (void *)0;
  const char *device = (const char *)(void *)0;
  const char *scan_type = "an analog TV";
  *devpath = (char)0;
  md=discover_media_devices();
  if(!(md == NULL))
  {
    device=get_associated_device(md, device, (const enum device_type)MEDIA_V4L_VIDEO, (const char *)(void *)0, (const enum device_type)NONE);
    if(!(device == ((const char *)NULL)))
    {
      snprintf(devpath, (unsigned long int)4096, "/dev/%s", device);
      if(!(ng_debug == 0))
        fprintf(stderr, "vid-open-auto: trying: %s... \n", devpath);

      handle=drv->open(devpath, 2 | 4);
      if(!(handle == NULL))
        fprintf(stderr, "vid-open-auto: using analog TV device %s\n", devpath);

    }

    if(handle == NULL)
    {
      if(allow_grabber == 0)
        goto error;

      scan_type = "a capture";
      device = (const char *)(void *)0;
      device=get_associated_device(md, device, (const enum device_type)MEDIA_V4L_VIDEO, (const char *)(void *)0, (const enum device_type)NONE);
      if(!(device == ((const char *)NULL)))
      {
        snprintf(devpath, (unsigned long int)4096, "/dev/%s", device);
        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open-auto: trying: %s... \n", devpath);

        handle=drv->open(devpath, 2);
        if(!(handle == NULL))
          fprintf(stderr, "vid-open-auto: using grabber/webcam device %s\n", devpath);

      }

    }

    free_media_devices(md);
  }


error:
  ;
  if(handle == NULL)
  {
    fprintf(stderr, "vid-open-auto: failed to open %s device", scan_type);
    if(!(*devpath == 0))
      fprintf(stderr, " at %s\n", devpath);

    else
      fprintf(stderr, "\n");
    return (void *)0;
  }

  else
  {
    if(!(handle == NULL) && !(ng_debug == 0))
      fprintf(stderr, "vid-open-auto: success, using: %s\n", devpath);

    return handle;
  }
}

// ng_waiton_video_buf
// file libng/grab-ng.c line 146
void ng_waiton_video_buf(struct ng_video_buf *buf)
{
  pthread_mutex_lock(&buf->lock);
  while(!(buf->refcount == 0))
    pthread_cond_wait(&buf->cond, &buf->lock);
  pthread_mutex_unlock(&buf->lock);
}

// ng_wakeup_video_buf
// file libng/grab-ng.c line 141
void ng_wakeup_video_buf(struct ng_video_buf *buf)
{
  pthread_cond_signal(&buf->cond);
}

// ng_writefile_init
// file libng/grab-ng.h line 481
void ng_writefile_init(void)
{
  ng_writer_register(0x20030129, "built-in", &files_writer);
  ng_writer_register(0x20030129, "built-in", &raw_writer);
}

// ng_writer_register
// file libng/grab-ng.c line 431
signed int ng_writer_register(signed int magic, char *plugname, struct ng_writer *writer)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "writer");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail(&writer->list, &ng_writers);
    return 0;
  }
}

// ng_yuv420p_to_lut2
// file libng/grab-ng.h line 489
void ng_yuv420p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *us;
  unsigned char *vs;
  unsigned char *dp;
  unsigned short int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)4);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned short int *)dp;
    us = u;
    vs = v;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    if(i % 2u == 0u)
    {
      u = us;
      v = vs;
    }

    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// ng_yuv420p_to_lut4
// file libng/grab-ng.h line 491
void ng_yuv420p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *us;
  unsigned char *vs;
  unsigned char *dp;
  unsigned int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)4);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned int *)dp;
    us = u;
    vs = v;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    if(i % 2u == 0u)
    {
      u = us;
      v = vs;
    }

    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// ng_yuv422_to_lut2
// file libng/grab-ng.h line 487
void ng_yuv422_to_lut2(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int gray;
  for( ; !(p == 0); p = p - 2)
  {
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    unsigned short int * restrict tmp_post_1 = d;
    d = d + 1l;
    *tmp_post_1 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)2]];
    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    s = s + (signed long int)4;
  }
}

// ng_yuv422_to_lut4
// file libng/grab-ng.h line 488
void ng_yuv422_to_lut4(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int gray;
  for( ; !(p == 0); p = p - 2)
  {
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    unsigned int * restrict tmp_post_1 = d;
    d = d + 1l;
    *tmp_post_1 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)2]];
    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    s = s + (signed long int)4;
  }
}

// ng_yuv422p_to_lut2
// file libng/grab-ng.h line 493
void ng_yuv422p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *dp;
  unsigned short int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)2);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned short int *)dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// ng_yuv422p_to_lut4
// file libng/grab-ng.h line 495
void ng_yuv422p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *dp;
  unsigned int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)2);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned int *)dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// oss_levels
// file common/sound.c line 13
void oss_levels(struct ng_audio_buf *buf, signed int *left, signed int *right)
{
  signed int lmax;
  signed int rmax;
  signed int i;
  signed int level;
  signed char *s = (signed char *)buf->data;
  unsigned char *u = (unsigned char *)buf->data;
  lmax = 0;
  rmax = 0;
  switch(buf->fmt.fmtid)
  {
    case (unsigned int)1:
    {
      i = 0;
      while(!(i >= buf->size))
      {
        signed int tmp_post_1 = i;
        i = i + 1;
        level=abs((signed int)u[(signed long int)tmp_post_1] - 128);
        if(!(lmax >= level))
        {
          lmax = level;
          rmax = level;
        }

      }
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)2:
    {
      i = 0;
      while(!(i >= buf->size))
      {
        signed int tmp_post_2 = i;
        i = i + 1;
        level=abs((signed int)u[(signed long int)tmp_post_2] - 128);
        if(!(lmax >= level))
          lmax = level;

        signed int tmp_post_3 = i;
        i = i + 1;
        level=abs((signed int)u[(signed long int)tmp_post_3] - 128);
        if(!(rmax >= level))
          rmax = level;

      }
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)5:

    case (unsigned int)3:
    {
      i = (unsigned int)5 == buf->fmt.fmtid ? 0 : 1;
      while(!(i >= buf->size))
      {
        level=abs((signed int)s[(signed long int)i]);
        i = i + 2;
        if(!(lmax >= level))
        {
          lmax = level;
          rmax = level;
        }

      }
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)4:

    case (unsigned int)6:
    {
      i = (unsigned int)6 == buf->fmt.fmtid ? 0 : 1;
      while(!(i >= buf->size))
      {
        level=abs((signed int)s[(signed long int)i]);
        i = i + 2;
        if(!(lmax >= level))
          lmax = level;

        level=abs((signed int)s[(signed long int)i]);
        i = i + 2;
        if(!(rmax >= level))
          rmax = level;

      }
    }
    default:
    {

    __CPROVER_DUMP_L18:
      ;
      *left = lmax;
      *right = rmax;
    }
  }
}

// parse_action
// file common/event.c line 21
static void parse_action(struct event_entry *entry)
{
  char *token;
  char *h;
  strcpy(entry->argbuf, entry->action);
  h = entry->argbuf;

__CPROVER_DUMP_L1:
  ;
  while((_Bool)1)
  {
    if(!((signed int)*h == 32))
    {
      if((signed int)*h == 9)
        goto __CPROVER_DUMP_L2;

    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      h = h + 1l;
      goto __CPROVER_DUMP_L1;
    }
    if((signed int)*h == 0)
      break;

    if((signed int)*h == 34)
    {
      h = h + 1l;
      token = h;
      for( ; !((signed int)*h == 0); h = h + 1l)
        if((signed int)*h == 34)
          break;

    }

    else
    {
      token = h;
      for( ; !((signed int)*h == 0); h = h + 1l)
      {
        if((signed int)*h == 32)
          break;

        if((signed int)*h == 9)
          break;

      }
    }
    if(!((signed int)*h == 0))
    {
      *h = (char)0;
      h = h + 1l;
    }

    signed int tmp_post_1 = entry->argc;
    entry->argc = entry->argc + 1;
    entry->argv[(signed long int)tmp_post_1] = token;
  }
}

// parse_config
// file ./common/channel.h line 77
void parse_config(signed int parse_channels)
{
  char key[16l];
  char cmdline[128l];
  char **list;
  char *val;
  list=cfg_list_entries("launch");
  signed int return_value_sscanf_2;
  if(!(list == ((char **)NULL)))
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      val=cfg_get_str("launch", *list);
      _Bool tmp_if_expr_3;
      if(!(val == ((char *)NULL)))
      {
        return_value_sscanf_2=sscanf(val, "%15[^,], %127[^\n]", (const void *)key, (const void *)cmdline);
        tmp_if_expr_3 = 2 == return_value_sscanf_2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
      {
        void *return_value_realloc_1;
        return_value_realloc_1=realloc((void *)launch, sizeof(struct LAUNCH) /*24ul*/  * (unsigned long int)(nlaunch + 1));
        launch = (struct LAUNCH *)return_value_realloc_1;
        (launch + (signed long int)nlaunch)->name=strdup(*list);
        (launch + (signed long int)nlaunch)->key=strdup(key);
        (launch + (signed long int)nlaunch)->cmdline=strdup(cmdline);
        nlaunch = nlaunch + 1;
      }

      else
        fprintf(stderr, "invalid value in section [launch]: %s\n", val);
    }

  event_readconfig();
  if(!(parse_channels == 0))
  {
    init_channel("defaults", &defaults);
    list=cfg_list_sections();
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      signed int return_value_strcmp_4;
      return_value_strcmp_4=strcmp(*list, "defaults");
      if(!(return_value_strcmp_4 == 0))
      {
        signed int return_value_strcmp_5;
        return_value_strcmp_5=strcmp(*list, "global");
        if(!(return_value_strcmp_5 == 0))
        {
          signed int return_value_strcmp_6;
          return_value_strcmp_6=strcmp(*list, "launch");
          if(!(return_value_strcmp_6 == 0))
          {
            signed int return_value_strcmp_7;
            return_value_strcmp_7=strcmp(*list, "eventmap");
            if(!(return_value_strcmp_7 == 0))
            {
              struct CHANNEL *return_value_add_channel_8;
              return_value_add_channel_8=add_channel(*list);
              init_channel(*list, return_value_add_channel_8);
            }

          }

        }

      }

    }
    defaults.channel=lookup_channel(defaults.cname);
    signed int return_value_get_freq_9;
    return_value_get_freq_9=get_freq(defaults.channel);
    defaults.freq = return_value_get_freq_9 + defaults.fine;
    calc_frequencies();
  }

}

// patch_up
// file libng/writefile.c line 36
signed int patch_up(char *name)
{
  char *ptr;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  ptr = name + (signed long int)return_value_strlen_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  for( ; ptr >= name; ptr = ptr - 1l)
  {
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if(!((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*ptr]) == 0))
      break;

  }
  if(!(ptr >= name))
    return 0;

  else
  {
    while((signed int)*ptr == 57)
    {
      if(!(ptr >= name))
        break;

      char *tmp_post_3 = ptr;
      ptr = ptr - 1l;
      *tmp_post_3 = (char)48;
    }
    if(!(ptr >= name))
      return 0;

    else
    {
      const unsigned short int **return_value___ctype_b_loc_4;
      return_value___ctype_b_loc_4=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)*ptr]) == 0))
      {
        *ptr = *ptr + 1;
        return 1;
      }

      else
        return 0;
    }
  }
}

// print_choices
// file common/commands.c line 753
static void print_choices(char *name, char *value, struct STRTAB *tab)
{
  signed int i;
  fprintf(stderr, "unknown %s: '%s' (available: ", name, value);
  i = 0;
  for( ; !((tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    fprintf(stderr, "%s'%s'", 0 == i ? "" : ", ", (tab + (signed long int)i)->str);
  fprintf(stderr, ")\n");
}

// raw_audio
// file libng/writefile.c line 519
static signed int raw_audio(void *handle, struct ng_audio_buf *buf)
{
  struct raw_handle *h = (struct raw_handle *)handle;
  signed long int return_value_write_1;
  return_value_write_1=write(h->wav_fd, (const void *)buf->data, (unsigned long int)buf->size);
  if(!((signed long int)buf->size == return_value_write_1))
    return -1;

  else
  {
    h->wav_size = h->wav_size + buf->size;
    return 0;
  }
}

// raw_close
// file libng/writefile.c line 529
static signed int raw_close(void *handle)
{
  struct raw_handle *h = (struct raw_handle *)handle;
  if(!(h->audio.fmtid == 0u))
  {
    wav_stop_write(h->wav_fd, &h->wav_header, h->wav_size);
    close(h->wav_fd);
  }

  if(!(h->video.fmtid == 0u))
  {
    if(!(h->fd == 1))
      close(h->fd);

  }

  free((void *)h);
  return 0;
}

// raw_open
// file libng/writefile.c line 408
static void * raw_open(char *videoname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio)
{
  struct raw_handle *h;
  signed int frame_rate_code = 0;
  signed int frame_rate_mul = fps;
  signed int frame_rate_div = 1000;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct raw_handle) /*88ul*/ );
  h = (struct raw_handle *)return_value_malloc_1;
  if(h == ((struct raw_handle *)NULL))
    return (void *)0;

  else
  {
    memset((void *)h, 0, sizeof(struct raw_handle) /*88ul*/ );
    h->video = *video;
    h->audio = *audio;
    h->vpriv = (struct raw_priv *)priv_video;
    if(!(h->audio.fmtid == 0u))
    {
      h->wav_fd=open(audioname, 0100 | 02 | 01000, 0666);
      if(h->wav_fd == -1)
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(*return_value___errno_location_2);
        fprintf(stderr, "open %s: %s\n", audioname, return_value_strerror_3);
        free((void *)h);
        return (void *)0;
      }

      wav_start_write(h->wav_fd, &h->wav_header, &h->audio);
    }

    if(!(h->video.fmtid == 0u))
    {
      if(!(h->vpriv == ((struct raw_priv *)NULL)))
      {
        if(!(h->vpriv->yuv4mpeg == 0))
          switch(fps)
          {
            case 23976:
            {
              frame_rate_code = 1;
              frame_rate_mul = 24000;
              frame_rate_div = 1001;
              break;
            }
            case 29970:
            {
              frame_rate_code = 4;
              frame_rate_mul = 30000;
              frame_rate_div = 1001;
              break;
            }
            case 59940:
            {
              frame_rate_code = 7;
              frame_rate_mul = 60000;
              frame_rate_div = 1001;
              break;
            }
            case 24000:
            {
              frame_rate_code = 2;
              break;
            }
            case 25000:
            {
              frame_rate_code = 3;
              break;
            }
            case 30000:
            {
              frame_rate_code = 5;
              break;
            }
            case 50000:
            {
              frame_rate_code = 6;
              break;
            }
            case 60000:
            {
              frame_rate_code = 8;
              break;
            }
            default:
            {
              fprintf(stderr, "illegal frame rate\n");
              free((void *)h);
              return (void *)0;
            }
          }

      }

      if(!(videoname == ((char *)NULL)))
      {
        h->fd=open(videoname, 0100 | 02 | 01000, 0666);
        if(h->fd == -1)
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          char *return_value_strerror_5;
          return_value_strerror_5=strerror(*return_value___errno_location_4);
          fprintf(stderr, "open %s: %s\n", videoname, return_value_strerror_5);
          if(!(h->wav_fd == 0))
            close(h->wav_fd);

          free((void *)h);
          return (void *)0;
        }

      }

      else
        h->fd = 1;
      if(!(h->vpriv == ((struct raw_priv *)NULL)))
      {
        if(!(h->vpriv->yuv4mpeg == 0))
        {
          char header[64l];
          switch(h->vpriv->yuv4mpeg)
          {
            case 1:
            {
              sprintf(header, "YUV4MPEG %d %d %d\n", h->video.width, h->video.height, frame_rate_code);
              break;
            }
            case 2:
              sprintf(header, "YUV4MPEG2 W%d H%d F%d:%d\n", h->video.width, h->video.height, frame_rate_mul, frame_rate_div);
          }
          unsigned long int return_value_strlen_6;
          return_value_strlen_6=strlen(header);
          write(h->fd, (const void *)header, return_value_strlen_6);
        }

      }

    }

    return (void *)h;
  }
}

// raw_video
// file libng/writefile.c line 497
static signed int raw_video(void *handle, struct ng_video_buf *buf)
{
  struct raw_handle *h = (struct raw_handle *)handle;
  signed long int return_value_write_1;
  signed long int return_value_write_2;
  if(!(h->vpriv == ((struct raw_priv *)NULL)))
  {
    if(!(h->vpriv->yuv4mpeg == 0))
      switch(h->vpriv->yuv4mpeg)
      {
        case 1:
        {
          return_value_write_1=write(h->fd, (const void *)"FRAME\n", (unsigned long int)6);
          if(!(return_value_write_1 == 6l))
            return -1;

          break;
        }
        case 2:
        {
          return_value_write_2=write(h->fd, (const void *)"FRAME \n", (unsigned long int)7);
          if(!(return_value_write_2 == 7l))
            return -1;

        }
      }

  }

  signed long int return_value_write_3;
  return_value_write_3=write(h->fd, (const void *)buf->data, buf->size);
  if(!(buf->size == (unsigned long int)return_value_write_3))
    return -1;

  else
    return 0;
}

// read_config
// file ./common/channel.h line 76
void read_config(char *conffile, signed int *argc, char **argv)
{
  struct list_head *item;
  char filename[100l];
  char *val;
  signed int i;
  if(!(conffile == ((char *)NULL)))
  {
    signed int return_value_cfg_parse_file_1;
    return_value_cfg_parse_file_1=cfg_parse_file(conffile);
    if(return_value_cfg_parse_file_1 == 0)
      have_config = 1;

  }

  else
  {
    char *return_value_getenv_2;
    return_value_getenv_2=getenv("HOME");
    sprintf(filename, "%.*s/%s", (signed int)sizeof(char [100l]) /*100ul*/  - 8, return_value_getenv_2, (const void *)".xawtv");
    signed int return_value_cfg_parse_file_3;
    return_value_cfg_parse_file_3=cfg_parse_file("/etc/X11/xawtvrc");
    if(return_value_cfg_parse_file_3 == 0)
      have_config = 1;

    signed int return_value_cfg_parse_file_4;
    return_value_cfg_parse_file_4=cfg_parse_file(filename);
    if(return_value_cfg_parse_file_4 == 0)
      have_config = 1;

  }
  if(!(argc == ((signed int *)NULL)))
    cfg_parse_options(argc, argv);

  val=cfg_get_str("global", "mixer");
  if(!(val == ((char *)NULL)))
  {
    mixer=strdup(val);
    signed int return_value_sscanf_5;
    return_value_sscanf_5=sscanf(mixer, "%31[^:]:%15s", (const void *)mixerdev, (const void *)mixerctl);
    if(!(return_value_sscanf_5 == 2))
    {
      strcpy(mixerdev, ng_dev.mixer);
      strncpy(mixerctl, val, (unsigned long int)15);
      mixerctl[(signed long int)15] = (char)0;
    }

  }

  val=cfg_get_str("global", "midi");
  if(!(val == ((char *)NULL)))
    midi=strdup(val);

  val=cfg_get_str("global", "freqtab");
  signed int return_value_strcasecmp_6;
  if(!(val == ((char *)NULL)))
  {
    i = 0;
    for( ; !((chanlists + (signed long int)i)->name == ((char *)NULL)); i = i + 1)
    {
      return_value_strcasecmp_6=strcasecmp(val, (chanlists + (signed long int)i)->name);
      if(return_value_strcasecmp_6 == 0)
        break;

    }
    if(!((chanlists + (signed long int)i)->name == ((char *)NULL)))
      freq_newtab(i);

    else
      fprintf(stderr, "invalid value for freqtab: %s\n", val);
  }

  val=cfg_get_str("global", "fullscreen");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf_7;
    return_value_sscanf_7=sscanf(val, "%d x %d", &fs_width, &fs_height);
    if(!(return_value_sscanf_7 == 2))
    {
      fprintf(stderr, "invalid value for fullscreen: %s\n", val);
      fs_height = 0;
      fs_width = fs_height;
    }

  }

  val=cfg_get_str("global", "pixsize");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf_8;
    return_value_sscanf_8=sscanf(val, "%d x %d", &pix_width, &pix_height);
    if(!(return_value_sscanf_8 == 2))
    {
      fprintf(stderr, "invalid value for pixsize: %s\n", val);
      pix_width = 128;
      pix_height = 96;
    }

  }

  i=cfg_get_int("global", "pixcols");
  if(!(i == -1))
    pix_cols = i;

  val=cfg_get_str("global", "wm-off-by");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf_9;
    return_value_sscanf_9=sscanf(val, "%d %d", &fs_xoff, &fs_yoff);
    if(!(return_value_sscanf_9 == 2))
    {
      fprintf(stderr, "invalid value for wm-off-by: %s\n", val);
      fs_yoff = 0;
      fs_xoff = fs_yoff;
    }

  }

  val=cfg_get_str("global", "ratio");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf_10;
    return_value_sscanf_10=sscanf(val, "%d:%d", &ng_ratio_x, &ng_ratio_y);
    if(!(return_value_sscanf_10 == 2))
    {
      fprintf(stderr, "invalid value for ratio: %s\n", val);
      ng_ratio_y = 0;
      ng_ratio_x = ng_ratio_y;
    }

  }

  i=cfg_get_int("global", "jpeg-quality");
  if(!(i == -1))
    ng_jpeg_quality = i;

  val=cfg_get_str("global", "keypad-ntsc");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      keypad_ntsc = i;

  }

  val=cfg_get_str("global", "keypad-partial");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      keypad_partial = i;

  }

  val=cfg_get_str("global", "osd");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      use_osd = i;

  }

  val=cfg_get_str("global", "osd-position");
  signed int return_value_sscanf_11;
  if(!(val == ((char *)NULL)))
  {
    return_value_sscanf_11=sscanf(val, "%d , %d", &osd_x, &osd_y);
    if(!(return_value_sscanf_11 == 2))
      fprintf(stderr, "invalid values for osd-position: %s\n", val);

  }

  val=cfg_get_str("global", "use-wm-fullscreen");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      use_wm_fullscreen = i;

  }

  val=cfg_get_str("global", "mov-driver");
  if(!(val == ((char *)NULL)))
    mov_driver = val;

  val=cfg_get_str("global", "mov-video");
  if(!(val == ((char *)NULL)))
    mov_video = val;

  val=cfg_get_str("global", "mov-fps");
  if(!(val == ((char *)NULL)))
    mov_fps = val;

  val=cfg_get_str("global", "mov-audio");
  if(!(val == ((char *)NULL)))
    mov_audio = val;

  val=cfg_get_str("global", "mov-rate");
  if(!(val == ((char *)NULL)))
    mov_rate = val;

  val=cfg_get_str("global", "filter");
  if(!(val == ((char *)NULL)))
  {
    item = (&ng_filters)->next;
    for( ; !(item == &ng_filters); item = item->next)
    {
      struct ng_filter *read_config__1__9__1__1__f = (struct ng_filter *)((char *)item - (signed long int)(unsigned long int)&((struct ng_filter *)0)->list);
      signed int return_value_strcasecmp_12;
      return_value_strcasecmp_12=strcasecmp(read_config__1__9__1__1__f->name, val);
      if(return_value_strcasecmp_12 == 0)
        cur_filter = read_config__1__9__1__1__f;

    }
  }

}

// record_audio_thread
// file common/capture.c line 371
static void * record_audio_thread(void *arg)
{
  struct movie_handle *h = (struct movie_handle *)arg;
  struct ng_audio_buf *record_audio_thread__1__buf;
  signed int return_value_getpid_1;
  if(!(debug == 0))
  {
    return_value_getpid_1=getpid();
    fprintf(stderr, "record_audio_thread start [pid=%d]\n", return_value_getpid_1);
  }

  record_audio_thread__1__buf=h->dsp->read(h->hdsp, (signed long int)h->stopby);
  if(!(record_audio_thread__1__buf == ((struct ng_audio_buf *)NULL)))
  {
    if(!(record_audio_thread__1__buf->size == 0))
    {
      h->ats = (unsigned long int)record_audio_thread__1__buf->info.ts;
      signed long int return_value_ng_get_timestamp_2;
      return_value_ng_get_timestamp_2=ng_get_timestamp();
      h->rts = (unsigned long int)return_value_ng_get_timestamp_2 - h->start;
      h->rdrift = h->rts - h->ats;
      h->vdrift = h->vts - h->ats;
      signed int return_value_fifo_put_3;
      return_value_fifo_put_3=fifo_put(&h->afifo, (void *)record_audio_thread__1__buf);
      if(!(return_value_fifo_put_3 == 0))
        free((void *)record_audio_thread__1__buf);

    }

  }

  fifo_put(&h->afifo, (void *)0);
  if(!(debug == 0))
    fprintf(stderr, "record_audio_thread done\n");

  return (void *)0;
}

// redblue_swap
// file libng/color_packed.c line 25
static void redblue_swap(unsigned char *dest, unsigned char *src, signed int p)
{
  unsigned char *s = src;
  unsigned char *d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    unsigned char *tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = s[(signed long int)2];
    unsigned char *tmp_post_3 = d;
    d = d + 1l;
    *tmp_post_3 = s[(signed long int)1];
    unsigned char *tmp_post_4 = d;
    d = d + 1l;
    *tmp_post_4 = s[(signed long int)0];
    s = s + (signed long int)3;
  }
  while((_Bool)1);
}

// rgb15_be_gray
// file libng/color_packed.c line 137
static void rgb15_be_gray(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  signed int r;
  signed int g;
  signed int b;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    r = ((signed int)src[(signed long int)0] & 0x7c) >> 2;
    g = ((signed int)src[(signed long int)0] & 0x03) << 3 | ((signed int)src[(signed long int)1] & 0xe0) >> 5;
    b = (signed int)src[(signed long int)1] & 0x1f;
    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned char)((3 * r + 6 * g + b) / 10 << 3);
    src = src + (signed long int)2;
  }
  while((_Bool)1);
}

// rgb15_native_gray
// file libng/color_packed.c line 119
static void rgb15_native_gray(unsigned char * restrict dest, unsigned char *s, signed int p)
{
  signed int r;
  signed int g;
  signed int b;
  unsigned short int * restrict src = (unsigned short int *)s;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    r = ((signed int)src[(signed long int)0] & 0x7c00) >> 10;
    g = ((signed int)src[(signed long int)0] & 0x03e0) >> 5;
    b = (signed int)src[(signed long int)0] & 0x001f;
    unsigned char * restrict tmp_post_2 = dest;
    dest = dest + 1l;
    *tmp_post_2 = (unsigned char)((3 * r + 6 * g + b) / 10 << 3);
    src = src + 1l;
  }
  while((_Bool)1);
}

// rgb32_to_bgr24
// file libng/color_packed.c line 85
static void rgb32_to_bgr24(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    s = s + 1l;
    unsigned char * restrict tmp_post_2 = s;
    s = s + 1l;
    d[(signed long int)2] = *tmp_post_2;
    unsigned char * restrict tmp_post_3 = s;
    s = s + 1l;
    d[(signed long int)1] = *tmp_post_3;
    unsigned char * restrict tmp_post_4 = s;
    s = s + 1l;
    d[(signed long int)0] = *tmp_post_4;
    d = d + (signed long int)3;
  }
  while((_Bool)1);
}

// rgb32_to_lut2
// file libng/color_lut.c line 56
static void rgb32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)1]] | ng_lut_green[(signed long int)src[(signed long int)2]] | ng_lut_blue[(signed long int)src[(signed long int)3]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// rgb32_to_lut4
// file libng/color_lut.c line 122
static void rgb32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)1]] | ng_lut_green[(signed long int)src[(signed long int)2]] | ng_lut_blue[(signed long int)src[(signed long int)3]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// rgb32_to_rgb24
// file libng/color_packed.c line 70
static void rgb32_to_rgb24(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    s = s + 1l;
    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_3 = s;
    s = s + 1l;
    *tmp_post_2 = *tmp_post_3;
    unsigned char * restrict tmp_post_4 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_5 = s;
    s = s + 1l;
    *tmp_post_4 = *tmp_post_5;
    unsigned char * restrict tmp_post_6 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_7 = s;
    s = s + 1l;
    *tmp_post_6 = *tmp_post_7;
  }
  while((_Bool)1);
}

// save_config
// file common/channel.c line 559
void save_config(void)
{
  struct ng_attribute *attr;
  char filename1[100l];
  char filename2[100l];
  struct _IO_FILE *fp;
  signed int i;
  char *return_value_getenv_1;
  return_value_getenv_1=getenv("HOME");
  sprintf(filename1, "%s/%s", return_value_getenv_1, (const void *)".xawtv");
  char *return_value_getenv_2;
  return_value_getenv_2=getenv("HOME");
  sprintf(filename2, "%s/%s", return_value_getenv_2, (const void *)".xawtv~");
  unlink(filename2);
  signed int return_value_link_3;
  return_value_link_3=link(filename1, filename2);
  if(return_value_link_3 == 0)
    unlink(filename1);

  fp=fopen(filename1, "w");
  signed int return_value_ng_attr_int2percent_13;
  signed int return_value_ng_attr_int2percent_14;
  signed int return_value_ng_attr_int2percent_15;
  signed int return_value_ng_attr_int2percent_16;
  struct ng_attribute *return_value_ng_attr_byid_18;
  const char *return_value_ng_attr_getstr_19;
  struct ng_attribute *return_value_ng_attr_byid_20;
  const char *return_value_ng_attr_getstr_21;
  const char *return_value_int_to_str_23;
  signed int return_value_ng_attr_int2percent_24;
  signed int return_value_ng_attr_int2percent_25;
  signed int return_value_ng_attr_int2percent_26;
  signed int return_value_ng_attr_int2percent_27;
  if(fp == ((struct _IO_FILE *)NULL))
    fprintf(stderr, "can't open config file %s\n", (const void *)filename1);

  else
  {
    fprintf(fp, "[global]\n");
    if(!(fs_height == 0) && !(fs_width == 0))
      fprintf(fp, "fullscreen = %d x %d\n", fs_width, fs_height);

    if(!(fs_xoff == 0) || !(fs_yoff == 0))
      fprintf(fp, "wm-off-by = %+d%+d\n", fs_xoff, fs_yoff);

    if(!(ng_ratio_x == 0) || !(ng_ratio_y == 0))
      fprintf(fp, "ratio = %d:%d\n", ng_ratio_x, ng_ratio_y);

    fprintf(fp, "freqtab = %s\n", (chanlists + (signed long int)chantab)->name);
    fprintf(fp, "pixsize = %d x %d\n", pix_width, pix_height);
    fprintf(fp, "pixcols = %d\n", pix_cols);
    fprintf(fp, "jpeg-quality = %d\n", ng_jpeg_quality);
    const char *return_value_int_to_str_4;
    return_value_int_to_str_4=int_to_str(keypad_ntsc, booltab);
    fprintf(fp, "keypad-ntsc = %s\n", return_value_int_to_str_4);
    const char *return_value_int_to_str_5;
    return_value_int_to_str_5=int_to_str(keypad_partial, booltab);
    fprintf(fp, "keypad-partial = %s\n", return_value_int_to_str_5);
    const char *return_value_int_to_str_6;
    return_value_int_to_str_6=int_to_str(use_osd, booltab);
    fprintf(fp, "osd = %s\n", return_value_int_to_str_6);
    fprintf(fp, "osd-position = %d , %d\n", osd_x, osd_y);
    const char *return_value_int_to_str_7;
    return_value_int_to_str_7=int_to_str(use_wm_fullscreen, booltab);
    fprintf(fp, "use-wm-fullscreen = %s\n", return_value_int_to_str_7);
    if(!(mixer == ((char *)NULL)))
      fprintf(fp, "mixer = %s\n", mixer);

    if(!(midi == ((char *)NULL)))
      fprintf(fp, "midi = %s\n", midi);

    if(!(mov_driver == ((char *)NULL)))
      fprintf(fp, "mov-driver = %s\n", mov_driver);

    if(!(mov_video == ((char *)NULL)))
      fprintf(fp, "mov-video = %s\n", mov_video);

    if(!(mov_fps == ((char *)NULL)))
      fprintf(fp, "mov-fps = %s\n", mov_fps);

    if(!(mov_audio == ((char *)NULL)))
      fprintf(fp, "mov-audio = %s\n", mov_audio);

    if(!(mov_rate == ((char *)NULL)))
      fprintf(fp, "mov-rate = %s\n", mov_rate);

    fprintf(fp, "\n");
    if(nlaunch >= 1)
    {
      fprintf(fp, "[launch]\n");
      i = 0;
      for( ; !(i >= nlaunch); i = i + 1)
        fprintf(fp, "%s = %s, %s\n", (launch + (signed long int)i)->name, (launch + (signed long int)i)->key, (launch + (signed long int)i)->cmdline);
      fprintf(fp, "\n");
    }

    event_writeconfig(fp);
    fprintf(fp, "# [Station name]\n");
    fprintf(fp, "# capture = overlay | grabdisplay | on | off\n");
    fprintf(fp, "# input = Television | Composite1 | S-Video | ...\n");
    fprintf(fp, "# norm = PAL | NTSC | SECAM | ... \n");
    fprintf(fp, "# channel = #\n");
    fprintf(fp, "# fine = # (-128..+127)\n");
    fprintf(fp, "# key = keysym | modifier+keysym\n");
    fprintf(fp, "# color = #\n");
    fprintf(fp, "# bright = #\n");
    fprintf(fp, "# hue = #\n");
    fprintf(fp, "# contrast = #\n");
    fprintf(fp, "\n");
    fprintf(fp, "[defaults]\n");
    fprintf(fp, "group = %s\n", defaults.group);
    struct ng_attribute *return_value_ng_attr_byid_8;
    return_value_ng_attr_byid_8=ng_attr_byid(attrs, 1);
    const char *return_value_ng_attr_getstr_9;
    return_value_ng_attr_getstr_9=ng_attr_getstr(return_value_ng_attr_byid_8, cur_attrs[(signed long int)1]);
    fprintf(fp, "norm = %s\n", return_value_ng_attr_getstr_9);
    struct ng_attribute *return_value_ng_attr_byid_10;
    return_value_ng_attr_byid_10=ng_attr_byid(attrs, 2);
    const char *return_value_ng_attr_getstr_11;
    return_value_ng_attr_getstr_11=ng_attr_getstr(return_value_ng_attr_byid_10, cur_attrs[(signed long int)2]);
    fprintf(fp, "input = %s\n", return_value_ng_attr_getstr_11);
    const char *return_value_int_to_str_12;
    return_value_int_to_str_12=int_to_str(cur_capture, captab);
    fprintf(fp, "capture = %s\n", return_value_int_to_str_12);
    attr=ng_attr_byid(attrs, 6);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[6l]))
      {
        return_value_ng_attr_int2percent_13=ng_attr_int2percent(attr, cur_attrs[(signed long int)6]);
        fprintf(fp, "color = %d%%\n", return_value_ng_attr_int2percent_13);
      }

    }

    attr=ng_attr_byid(attrs, 7);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[7l]))
      {
        return_value_ng_attr_int2percent_14=ng_attr_int2percent(attr, cur_attrs[(signed long int)7]);
        fprintf(fp, "bright = %d%%\n", return_value_ng_attr_int2percent_14);
      }

    }

    attr=ng_attr_byid(attrs, 8);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[8l]))
      {
        return_value_ng_attr_int2percent_15=ng_attr_int2percent(attr, cur_attrs[(signed long int)8]);
        fprintf(fp, "hue = %d%%\n", return_value_ng_attr_int2percent_15);
      }

    }

    attr=ng_attr_byid(attrs, 9);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[9l]))
      {
        return_value_ng_attr_int2percent_16=ng_attr_int2percent(attr, cur_attrs[(signed long int)9]);
        fprintf(fp, "contrast = %d%%\n", return_value_ng_attr_int2percent_16);
      }

    }

    fprintf(fp, "\n");
    i = 0;
    for( ; !(i >= count); i = i + 1)
    {
      fprintf(fp, "[%s]\n", channels[(signed long int)i]->name);
      if(!(channels[(signed long int)i]->cname == ((char *)NULL)))
      {
        struct CHANLIST *tmp_if_expr_17;
        if(!(chantab == -1))
          tmp_if_expr_17 = (chanlists + (signed long int)chantab)->list;

        else
          tmp_if_expr_17 = (struct CHANLIST *)(void *)0;
        fprintf(fp, "channel = %s\n", (tmp_if_expr_17 + (signed long int)channels[(signed long int)i]->channel)->name);
        if(!(channels[(signed long int)i]->fine == 0))
          fprintf(fp, "fine = %+d\n", channels[(signed long int)i]->fine);

      }

      else
        fprintf(fp, "freq = %.2f\n", (float)channels[(signed long int)i]->freq / (float)16);
      if(!(channels[(signed long int)i]->norm == cur_attrs[1l]))
      {
        return_value_ng_attr_byid_18=ng_attr_byid(attrs, 1);
        return_value_ng_attr_getstr_19=ng_attr_getstr(return_value_ng_attr_byid_18, channels[(signed long int)i]->norm);
        fprintf(fp, "norm = %s\n", return_value_ng_attr_getstr_19);
      }

      if(!(channels[(signed long int)i]->input == cur_attrs[2l]))
      {
        return_value_ng_attr_byid_20=ng_attr_byid(attrs, 2);
        return_value_ng_attr_getstr_21=ng_attr_getstr(return_value_ng_attr_byid_20, channels[(signed long int)i]->input);
        fprintf(fp, "input = %s\n", return_value_ng_attr_getstr_21);
      }

      if(!(channels[(signed long int)i]->key == ((char *)NULL)))
        fprintf(fp, "key = %s\n", channels[(signed long int)i]->key);

      signed int return_value_strcmp_22;
      return_value_strcmp_22=strcmp(channels[(signed long int)i]->group, defaults.group);
      if(!(return_value_strcmp_22 == 0))
        fprintf(fp, "group = %s\n", channels[(signed long int)i]->group);

      if(!(channels[(signed long int)i]->midi == 0))
        fprintf(fp, "midi = %d\n", channels[(signed long int)i]->midi);

      if(!(channels[(signed long int)i]->capture == cur_capture))
      {
        return_value_int_to_str_23=int_to_str(channels[(signed long int)i]->capture, captab);
        fprintf(fp, "capture = %s\n", return_value_int_to_str_23);
      }

      attr=ng_attr_byid(attrs, 6);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[6l] == channels[(signed long int)i]->color))
        {
          return_value_ng_attr_int2percent_24=ng_attr_int2percent(attr, channels[(signed long int)i]->color);
          fprintf(fp, "color = %d%%\n", return_value_ng_attr_int2percent_24);
        }

      }

      attr=ng_attr_byid(attrs, 7);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[7l] == channels[(signed long int)i]->bright))
        {
          return_value_ng_attr_int2percent_25=ng_attr_int2percent(attr, channels[(signed long int)i]->bright);
          fprintf(fp, "bright = %d%%\n", return_value_ng_attr_int2percent_25);
        }

      }

      attr=ng_attr_byid(attrs, 8);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[8l] == channels[(signed long int)i]->hue))
        {
          return_value_ng_attr_int2percent_26=ng_attr_int2percent(attr, channels[(signed long int)i]->hue);
          fprintf(fp, "hue = %d%%\n", return_value_ng_attr_int2percent_26);
        }

      }

      attr=ng_attr_byid(attrs, 9);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[9l] == channels[(signed long int)i]->contrast))
        {
          return_value_ng_attr_int2percent_27=ng_attr_int2percent(attr, channels[(signed long int)i]->contrast);
          fprintf(fp, "contrast = %d%%\n", return_value_ng_attr_int2percent_27);
        }

      }

      fprintf(fp, "\n");
    }
    fclose(fp);
  }
}

// set_attr
// file common/commands.c line 331
static void set_attr(struct ng_attribute *attr, signed int val)
{
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    attr->write(attr, val);
    cur_attrs[(signed long int)attr->id] = val;
    if(!(attr_notify == ((void (*)(struct ng_attribute *, signed int))NULL)))
      attr_notify(attr, val);

  }

}

// set_capture
// file common/commands.c line 304
static void set_capture(signed int capture, signed int tmp_switch)
{
  if(!(set_capture_hook == ((void (*)(signed int, signed int, signed int))NULL)))
  {
    static signed int last_on = 1;
    if(capture == 9)
      capture = last_on;

    if(capture == 1)
    {
      if((1 & f_drv) == 0)
        capture = 2;

      if(do_overlay == 0)
        capture = 2;

    }

    if(!(cur_capture == capture))
    {
      set_capture_hook(cur_capture, capture, tmp_switch);
      cur_capture = capture;
    }

    if(!(cur_capture == 0))
      last_on = cur_capture;

  }

}

// set_defaults
// file ./common/commands.h line 72
void set_defaults(void)
{
  struct ng_attribute *attr;
  attr=ng_attr_byid(attrs, 6);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.color);

  attr=ng_attr_byid(attrs, 7);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.bright);

  attr=ng_attr_byid(attrs, 8);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.hue);

  attr=ng_attr_byid(attrs, 9);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.contrast);

  attr=ng_attr_byid(attrs, 2);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.input);

  attr=ng_attr_byid(attrs, 1);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.norm);

  set_capture(defaults.capture, 0);
  cur_channel = defaults.channel;
  cur_fine = defaults.fine;
  cur_freq = defaults.freq;
  if(!((4 & f_drv) == 0))
    drv->setfreq(h_drv, (unsigned long int)defaults.freq);

}

// set_freqtab
// file common/commands.c line 364
static void set_freqtab(signed int j)
{
  if(!((4 & f_drv) == 0))
  {
    freq_newtab(j);
    cur_channel = -1;
    calc_frequencies();
    if(!(freqtab_notify == ((void (*)(void))NULL)))
      freqtab_notify();

  }

}

// set_msg_bool
// file common/commands.c line 418
static void set_msg_bool(const char *name, signed int val)
{
  if(!(display_message == ((void (*)(char *))NULL)))
  {
    static char title[256l];
    sprintf(title, "%s: %s", name, val != 0 ? "on" : "off");
    display_message(title);
  }

}

// set_msg_int
// file common/commands.c line 406
static void set_msg_int(struct ng_attribute *attr, signed int val)
{
  if(!(display_message == ((void (*)(char *))NULL)))
  {
    signed int return_value_ng_attr_int2percent_1;
    return_value_ng_attr_int2percent_1=ng_attr_int2percent(attr, val);
    static char title[256l];
    sprintf(title, "%s: %d%%", attr->name, return_value_ng_attr_int2percent_1);
    display_message(title);
  }

}

// set_msg_str
// file common/commands.c line 429
static void set_msg_str(const char *name, const char *val)
{
  if(!(display_message == ((void (*)(char *))NULL)))
  {
    static char title[256l];
    sprintf(title, "%s: %s", name, val);
    display_message(title);
  }

}

// set_mute
// file common/commands.c line 351
static void set_mute(signed int val)
{
  struct ng_attribute *attr;
  cur_attrs[(signed long int)4] = val;
  attr=ng_attr_byid(attrs, 4);
  if(!(attr == ((struct ng_attribute *)NULL)))
    attr->write(attr, val);

  if(!(mute_notify == ((void (*)(signed int))NULL)))
    mute_notify(val);

}

// set_title
// file common/commands.c line 381
static void set_title(void)
{
  const char *norm;
  keypad_state = -1;
  unsigned long int return_value_strlen_2;
  if(!(update_title == ((void (*)(char *))NULL)))
  {
    static char title[256l];
    if(!(cur_sender == -1))
      sprintf(title, "%s", channels[(signed long int)cur_sender]->name);

    else
      if(!(cur_channel == -1))
      {
        struct CHANLIST *tmp_if_expr_1;
        if(!(chantab == -1))
          tmp_if_expr_1 = (chanlists + (signed long int)chantab)->list;

        else
          tmp_if_expr_1 = (struct CHANLIST *)(void *)0;
        sprintf(title, "channel %s", (tmp_if_expr_1 + (signed long int)cur_channel)->name);
        if(!(cur_fine == 0))
        {
          return_value_strlen_2=strlen(title);
          sprintf(title + (signed long int)return_value_strlen_2, " (%d)", cur_fine);
        }

        struct ng_attribute *return_value_ng_attr_byid_3;
        return_value_ng_attr_byid_3=ng_attr_byid(attrs, 1);
        norm=ng_attr_getstr(return_value_ng_attr_byid_3, cur_attrs[(signed long int)1]);
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(title);
        sprintf(title + (signed long int)return_value_strlen_4, " (%s/%s)", norm != ((const char *)NULL) ? norm : "???", (chanlists + (signed long int)chantab)->name);
      }

      else
        sprintf(title, "%.3f MHz", (double)cur_freq / 16.0);
    update_title(title);
  }

}

// set_volume
// file common/commands.c line 342
static void set_volume(signed int val)
{
  struct ng_attribute *attr;
  cur_attrs[(signed long int)3] = val;
  attr=ng_attr_byid(attrs, 3);
  if(!(attr == ((struct ng_attribute *)NULL)))
    attr->write(attr, val);

}

// setchannel_handler
// file common/commands.c line 667
static signed int setchannel_handler(char *name, signed int argc, char **argv)
{
  signed int i;
  signed int setchannel_handler__1__c;
  signed int orig_mute;
  signed int return_value_strcasecmp_7;
  signed int return_value_strcasecmp_6;
  signed int return_value_strcasecmp_5;
  signed int return_value_get_freq_11;
  if((4 & f_drv) == 0)
    return 0;

  else
    if(argc == 0)
    {
      set_title();
      return 0;
    }

    else
      if(!(cur_movie == 0))
      {
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message("grabber busy");

        return -1;
      }

      else
      {
        signed int return_value_strcasecmp_12;
        return_value_strcasecmp_12=strcasecmp("setfreq", name);
        if(return_value_strcasecmp_12 == 0)
        {
          double return_value_atof_1;
          return_value_atof_1=atof(argv[(signed long int)0]);
          cur_freq = (signed int)(unsigned long int)(return_value_atof_1 * (double)16);
          cur_sender = -1;
          cur_channel = -1;
          cur_fine = 0;
        }

        else
        {
          signed int return_value_strcasecmp_8;
          return_value_strcasecmp_8=strcasecmp(argv[(signed long int)0], "next");
          if(return_value_strcasecmp_8 == 0)
          {
            signed int tmp_if_expr_2;
            if(!(chantab == -1))
              tmp_if_expr_2 = (chanlists + (signed long int)chantab)->count;

            else
              tmp_if_expr_2 = 0;
            cur_channel = (cur_channel + 1) % tmp_if_expr_2;
            cur_fine = defaults.fine;
          }

          else
          {
            return_value_strcasecmp_7=strcasecmp(argv[(signed long int)0], "prev");
            if(return_value_strcasecmp_7 == 0)
            {
              signed int tmp_if_expr_3;
              if(!(chantab == -1))
                tmp_if_expr_3 = (chanlists + (signed long int)chantab)->count;

              else
                tmp_if_expr_3 = 0;
              signed int tmp_if_expr_4;
              if(!(chantab == -1))
                tmp_if_expr_4 = (chanlists + (signed long int)chantab)->count;

              else
                tmp_if_expr_4 = 0;
              cur_channel = ((cur_channel + tmp_if_expr_3) - 1) % tmp_if_expr_4;
              cur_fine = defaults.fine;
            }

            else
            {
              return_value_strcasecmp_6=strcasecmp(argv[(signed long int)0], "fine_up");
              if(return_value_strcasecmp_6 == 0)
                cur_fine = cur_fine + 1;

              else
              {
                return_value_strcasecmp_5=strcasecmp(argv[(signed long int)0], "fine_down");
                if(return_value_strcasecmp_5 == 0)
                  cur_fine = cur_fine - 1;

                else
                {
                  setchannel_handler__1__c=lookup_channel(argv[(signed long int)0]);
                  if(!(setchannel_handler__1__c == -1))
                  {
                    cur_channel = setchannel_handler__1__c;
                    cur_fine = defaults.fine;
                  }

                }
              }
            }
          }
          signed int return_value_strncmp_10;
          return_value_strncmp_10=strncmp(argv[(signed long int)0], "fine", (unsigned long int)4);
          if(!(return_value_strncmp_10 == 0))
          {
            i = 0;
            for( ; !(i >= count); i = i + 1)
              if(cur_channel == channels[(signed long int)i]->channel)
              {
                char *setchannel_handler__1__4__6__1__1__1__argv[2l];
                setchannel_handler__1__4__6__1__1__1__argv[(signed long int)0] = channels[(signed long int)i]->name;
                setchannel_handler__1__4__6__1__1__1__argv[(signed long int)1] = (char *)(void *)0;
                signed int return_value_setstation_handler_9;
                return_value_setstation_handler_9=setstation_handler("", argc, setchannel_handler__1__4__6__1__1__1__argv);
                return return_value_setstation_handler_9;
              }

          }

          cur_sender = -1;
          if(!(cur_channel == -1))
          {
            return_value_get_freq_11=get_freq(cur_channel);
            cur_freq = return_value_get_freq_11 + cur_fine;
          }

          else
          {
            cur_freq = cur_freq + cur_fine;
            cur_fine = 0;
          }
        }
        if(!(channel_switch_hook == ((void (*)(void))NULL)))
          channel_switch_hook();

        set_capture(0, 1);
        orig_mute = cur_attrs[(signed long int)4];
        if(orig_mute == 0)
          set_mute(1);

        if(!((4 & f_drv) == 0))
          drv->setfreq(h_drv, (unsigned long int)cur_freq);

        set_capture(defaults.capture, 0);
        set_title();
        if(!(setstation_notify == ((void (*)(void))NULL)))
          setstation_notify();

        if(orig_mute == 0)
        {
          usleep((unsigned int)20000);
          set_mute(0);
        }

        return 0;
      }
}

// setfreqtab_handler
// file common/commands.c line 763
static signed int setfreqtab_handler(char *name, signed int argc, char **argv)
{
  signed int i;
  if((4 & f_drv) == 0)
    return 0;

  else
  {
    i=str_to_int(argv[(signed long int)0], chanlist_names);
    if(!(i == -1))
      set_freqtab(i);

    else
      print_choices("freqtab", argv[(signed long int)0], chanlist_names);
    return 0;
  }
}

// setpixel1
// file console/fs.c line 49
static void setpixel1(void *ptr, unsigned int color)
{
  unsigned char *p = (unsigned char *)ptr;
  *p = (unsigned char)color;
}

// setpixel2
// file console/fs.c line 54
static void setpixel2(void *ptr, unsigned int color)
{
  unsigned short int *p = (unsigned short int *)ptr;
  *p = (unsigned short int)color;
}

// setpixel3
// file console/fs.c line 59
static void setpixel3(void *ptr, unsigned int color)
{
  unsigned char *p = (unsigned char *)ptr;
  unsigned char *tmp_post_1 = p;
  p = p + 1l;
  *tmp_post_1 = (unsigned char)(color >> 16 & (unsigned int)0xff);
  unsigned char *tmp_post_2 = p;
  p = p + 1l;
  *tmp_post_2 = (unsigned char)(color >> 8 & (unsigned int)0xff);
  unsigned char *tmp_post_3 = p;
  p = p + 1l;
  *tmp_post_3 = (unsigned char)(color & (unsigned int)0xff);
}

// setpixel4
// file console/fs.c line 66
static void setpixel4(void *ptr, unsigned int color)
{
  unsigned long int *p = (unsigned long int *)ptr;
  *p = (unsigned long int)color;
}

// setstation_handler
// file common/commands.c line 567
static signed int setstation_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  signed int i;
  signed int orig_mute;
  signed int return_value_strcasecmp_8;
  signed int return_value_strcasecmp_6;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_1;
  char *return_value_strcasestr_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  if((4 & f_drv) == 0)
    return 0;

  else
    if(argc == 0)
    {
      set_title();
      return 0;
    }

    else
      if(!(cur_movie == 0))
      {
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message("grabber busy");

        return -1;
      }

      else
      {
        _Bool tmp_if_expr_9;
        if(!(count == 0))
        {
          return_value_strcasecmp_8=strcasecmp(argv[(signed long int)0], "next");
          tmp_if_expr_9 = 0 == return_value_strcasecmp_8 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_9 = (_Bool)0;
        if(tmp_if_expr_9)
          i = (cur_sender + 1) % count;

        else
        {
          _Bool tmp_if_expr_7;
          if(!(count == 0))
          {
            return_value_strcasecmp_6=strcasecmp(argv[(signed long int)0], "prev");
            tmp_if_expr_7 = 0 == return_value_strcasecmp_6 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_7 = (_Bool)0;
          if(tmp_if_expr_7)
            i = ((cur_sender + count) - 1) % count;

          else
          {
            _Bool tmp_if_expr_5;
            if(!(count == 0))
            {
              return_value_strcasecmp_4=strcasecmp(argv[(signed long int)0], "back");
              tmp_if_expr_5 = 0 == return_value_strcasecmp_4 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_5 = (_Bool)0;
            if(tmp_if_expr_5)
            {
              if(last_sender == -1)
                return -1;

              i = last_sender;
            }

            else
            {
              i = 0;
              for( ; !(i >= count); i = i + 1)
              {
                return_value_strcasecmp_1=strcasecmp(channels[(signed long int)i]->name, argv[(signed long int)0]);
                if(return_value_strcasecmp_1 == 0)
                  break;

              }
              if(i == count)
              {
                i = 0;
                for( ; !(i >= count); i = i + 1)
                {
                  return_value_strcasestr_2=strcasestr(channels[(signed long int)i]->name, argv[(signed long int)0]);
                  if(!(return_value_strcasestr_2 == ((char *)NULL)))
                    break;

                }
              }

              if(i == count)
              {
                return_value___ctype_b_loc_3=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*(*argv)]) == 0))
                  i=atoi(argv[(signed long int)0]);

              }

              if(i == count)
              {
                fprintf(stderr, "station \"%s\" not found\n", argv[(signed long int)0]);
                return -1;
              }

            }
          }
        }
        if(i >= count || !(i >= 0))
          return -1;

        else
        {
          if(!(channel_switch_hook == ((void (*)(void))NULL)))
            channel_switch_hook();

          set_capture(0, 1);
          orig_mute = cur_attrs[(signed long int)4];
          if(orig_mute == 0)
            set_mute(1);

          last_sender = cur_sender;
          cur_sender = i;
          attr=ng_attr_byid(attrs, 6);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->color);

          attr=ng_attr_byid(attrs, 7);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->bright);

          attr=ng_attr_byid(attrs, 8);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->hue);

          attr=ng_attr_byid(attrs, 9);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->contrast);

          if(!(cur_attrs[2l] == channels[(signed long int)i]->input))
          {
            attr=ng_attr_byid(attrs, 2);
            if(!(attr == ((struct ng_attribute *)NULL)))
              set_attr(attr, channels[(signed long int)i]->input);

          }

          if(!(cur_attrs[1l] == channels[(signed long int)i]->norm))
          {
            attr=ng_attr_byid(attrs, 1);
            if(!(attr == ((struct ng_attribute *)NULL)))
              set_attr(attr, channels[(signed long int)i]->norm);

          }

          cur_channel = channels[(signed long int)i]->channel;
          cur_fine = channels[(signed long int)i]->fine;
          cur_freq = channels[(signed long int)i]->freq;
          if(!((4 & f_drv) == 0))
            drv->setfreq(h_drv, (unsigned long int)channels[(signed long int)i]->freq);

          set_capture(channels[(signed long int)i]->capture, 0);
          set_title();
          if(!(setstation_notify == ((void (*)(void))NULL)))
            setstation_notify();

          if(orig_mute == 0)
          {
            usleep((unsigned int)20000);
            set_mute(0);
          }

          return 0;
        }
      }
}

// show_handler
// file common/commands.c line 909
static signed int show_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  char *n[2l] = { (char *)(void *)0, (char *)(void *)0 };
  signed int val;
  const char *return_value_ng_attr_getstr_1;
  if(argc == 0)
  {
    attr = attrs;
    for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
    {
      n[(signed long int)0] = (char *)attr->name;
      show_handler("show", 1, n);
    }
    return 0;
  }

  else
  {
    attr=ng_attr_byname(attrs, argv[(signed long int)0]);
    if(attr == ((struct ng_attribute *)NULL))
    {
      fprintf(stderr, "fixme: 404 %s\n", argv[(signed long int)0]);
      return 0;
    }

    else
    {
      val = cur_attrs[(signed long int)attr->id];
      switch(attr->type)
      {
        case 2:
        {
          return_value_ng_attr_getstr_1=ng_attr_getstr(attr, val);
          printf("%s: %s\n", attr->name, return_value_ng_attr_getstr_1);
          break;
        }
        case 1:
        {
          printf("%s: %d\n", attr->name, val);
          break;
        }
        case 3:
          printf("%s: %s\n", attr->name, val != 0 ? "on" : "off");
      }
      return 0;
    }
  }
}

// showtime_handler
// file common/commands.c line 1174
static signed int showtime_handler(char *name, signed int argc, char **argv)
{
  char timestr[6l];
  struct tm *times;
  signed long int timet;
  timet=time((signed long int *)(void *)0);
  times=localtime(&timet);
  strftime(timestr, (unsigned long int)6, "%k:%M", times);
  if(!(display_message == ((void (*)(char *))NULL)))
    display_message(timestr);

  return 0;
}

// snap_filename
// file ./libng/writefile.h line 2
char * snap_filename(char *base, char *channel, char *ext)
{
  signed long int now;
  struct tm *tm;
  char timestamp[32l];
  time(&now);
  tm=localtime(&now);
  static signed int snap_filename__1__count = 0;
  static signed long int last = (signed long int)0;
  if(!(last == now))
    snap_filename__1__count = 0;

  last = now;
  snap_filename__1__count = snap_filename__1__count + 1;
  static char *filename = (char *)(void *)0;
  if(!(filename == ((char *)NULL)))
    free((void *)filename);

  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(base);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(channel);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(ext);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(return_value_strlen_1 + return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)32);
  filename = (char *)return_value_malloc_4;
  strftime(timestamp, (unsigned long int)31, "%Y%m%d-%H%M%S", tm);
  sprintf(filename, "%s-%s-%s-%d.%s", base, channel, (const void *)timestamp, snap_filename__1__count, ext);
  return filename;
}

// snap_handler
// file common/commands.c line 1006
static signed int snap_handler(char *hname, signed int argc, char **argv)
{
  char snap_handler__1__message[512l];
  char *tmpfilename = (char *)(void *)0;
  char *filename = (char *)(void *)0;
  char *name;
  signed int jpeg = 0;
  signed int ret = 0;
  struct ng_video_fmt snap_handler__1__fmt;
  struct ng_video_buf *snap_handler__1__buf = (struct ng_video_buf *)(void *)0;
  signed int return_value_strcasecmp_4;
  signed int return_value_sscanf_3;
  unsigned long int return_value_strlen_7;
  void *return_value_malloc_8;
  signed int return_value_link_17;
  if((2 & f_drv) == 0)
  {
    fprintf(stderr, "grabbing: not supported [try -noxv switch?]\n");
    return -1;
  }

  else
    if(!(cur_movie == 0))
    {
      if(!(display_message == ((void (*)(char *))NULL)))
        display_message("grabber busy");

      return -1;
    }

    else
    {
      if(!(capture_get_hook == ((void (*)(void))NULL)))
        capture_get_hook();

      if(argc >= 1)
      {
        signed int return_value_strcasecmp_1;
        return_value_strcasecmp_1=strcasecmp(argv[(signed long int)0], "jpeg");
        if(return_value_strcasecmp_1 == 0)
          jpeg = 1;

        signed int return_value_strcasecmp_2;
        return_value_strcasecmp_2=strcasecmp(argv[(signed long int)0], "ppm");
        if(return_value_strcasecmp_2 == 0)
          jpeg = 0;

      }

      memset((void *)&snap_handler__1__fmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
      snap_handler__1__fmt.fmtid = (unsigned int)9;
      snap_handler__1__fmt.width = (unsigned int)2048;
      snap_handler__1__fmt.height = (unsigned int)1572;
      if(argc >= 2)
      {
        signed int return_value_strcasecmp_5;
        return_value_strcasecmp_5=strcasecmp(argv[(signed long int)1], "full");
        if(!(return_value_strcasecmp_5 == 0))
        {
          return_value_strcasecmp_4=strcasecmp(argv[(signed long int)1], "win");
          if(return_value_strcasecmp_4 == 0)
          {
            snap_handler__1__fmt.width = cur_tv_width;
            snap_handler__1__fmt.height = cur_tv_height;
          }

          else
          {
            return_value_sscanf_3=sscanf(argv[(signed long int)1], "%dx%d", &snap_handler__1__fmt.width, &snap_handler__1__fmt.height);
            if(!(return_value_sscanf_3 == 2))
              return -1;

          }
        }

      }

      if(argc >= 3)
        filename = argv[(signed long int)2];

      snap_handler__1__buf=ng_grabber_get_image(&snap_handler__1__fmt);
      if(snap_handler__1__buf == ((struct ng_video_buf *)NULL))
      {
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message("grabbing failed");

        ret = -1;
      }

      else
      {
        snap_handler__1__buf=ng_filter_single(cur_filter, snap_handler__1__buf);
        if(filename == ((char *)NULL))
        {
          if(!(cur_sender == -1))
            name = channels[(signed long int)cur_sender]->name;

          else
            if(!(cur_channel == -1))
            {
              struct CHANLIST *tmp_if_expr_6;
              if(!(chantab == -1))
                tmp_if_expr_6 = (chanlists + (signed long int)chantab)->list;

              else
                tmp_if_expr_6 = (struct CHANLIST *)(void *)0;
              name = (tmp_if_expr_6 + (signed long int)cur_channel)->name;
            }

            else
              name = "unknown";
          filename=snap_filename(snapbase, name, jpeg != 0 ? "jpeg" : "ppm");
        }

        return_value_strlen_7=strlen(filename);
        return_value_malloc_8=malloc(return_value_strlen_7 + (unsigned long int)8);
        tmpfilename = (char *)return_value_malloc_8;
        sprintf(tmpfilename, "%s.___", filename);
        if(!(jpeg == 0))
        {
          signed int return_value_write_jpeg_11;
          return_value_write_jpeg_11=write_jpeg(tmpfilename, snap_handler__1__buf, ng_jpeg_quality, 0);
          if(return_value_write_jpeg_11 == -1)
          {
            signed int *return_value___errno_location_9;
            return_value___errno_location_9=__errno_location();
            char *return_value_strerror_10;
            return_value_strerror_10=strerror(*return_value___errno_location_9);
            sprintf(snap_handler__1__message, "open %s: %s\n", tmpfilename, return_value_strerror_10);
          }

          else
            sprintf(snap_handler__1__message, "saved jpeg: %s", filename);
        }

        else
        {
          signed int return_value_write_ppm_14;
          return_value_write_ppm_14=write_ppm(tmpfilename, snap_handler__1__buf);
          if(return_value_write_ppm_14 == -1)
          {
            signed int *return_value___errno_location_12;
            return_value___errno_location_12=__errno_location();
            char *return_value_strerror_13;
            return_value_strerror_13=strerror(*return_value___errno_location_12);
            sprintf(snap_handler__1__message, "open %s: %s\n", tmpfilename, return_value_strerror_13);
          }

          else
            sprintf(snap_handler__1__message, "saved ppm: %s", filename);
        }
        unlink(filename);
        return_value_link_17=link(tmpfilename, filename);
        if(return_value_link_17 == -1)
        {
          signed int *return_value___errno_location_15;
          return_value___errno_location_15=__errno_location();
          char *return_value_strerror_16;
          return_value_strerror_16=strerror(*return_value___errno_location_15);
          fprintf(stderr, "link(%s,%s): %s\n", tmpfilename, filename, return_value_strerror_16);
          goto done;
        }

        unlink(tmpfilename);
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message(snap_handler__1__message);

      }

    done:
      ;
      if(!(tmpfilename == ((char *)NULL)))
        free((void *)tmpfilename);

      if(!(snap_handler__1__buf == ((struct ng_video_buf *)NULL)))
        ng_release_video_buf(snap_handler__1__buf);

      if(!(capture_rel_hook == ((void (*)(void))NULL)))
        capture_rel_hook();

      return ret;
    }
}

// sort_media_device_entry
// file common/get_media_devices.c line 299
static signed int sort_media_device_entry(const void *a, const void *b)
{
  struct media_device_entry *md_a = (struct media_device_entry *)a;
  struct media_device_entry *md_b = (struct media_device_entry *)b;
  signed int cmp;
  cmp=strcmp(md_a->device, md_b->device);
  if(!(cmp == 0))
    return cmp;

  else
  {
    cmp = (signed int)md_a->type - (signed int)md_b->type;
    if(!(cmp == 0))
      return cmp;

    else
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(md_a->node, md_b->node);
      return return_value_strcmp_1;
    }
  }
}

// split_cmdline
// file common/commands.h line 79
char ** split_cmdline(char *line, signed int *count)
{
  signed int argc;
  signed int i;
  static char cmdline[1024l];
  strcpy(cmdline, line);
  argc = 0;
  i = 0;
  static char *argv[32l];
  while(!(argc >= 31))
  {
    signed int tmp_post_1 = argc;
    argc = argc + 1;
    argv[(signed long int)tmp_post_1] = cmdline + (signed long int)i;
    for( ; !((signed int)cmdline[(signed long int)i] == 32); i = i + 1)
    {
      if((signed int)cmdline[(signed long int)i] == 9)
        break;

      if((signed int)cmdline[(signed long int)i] == 0)
        break;

    }
    if((signed int)cmdline[(signed long int)i] == 0)
      break;

    signed int tmp_post_2 = i;
    i = i + 1;
    cmdline[(signed long int)tmp_post_2] = (char)0;
    for( ; (_Bool)1; i = i + 1)
      if(!((signed int)cmdline[(signed long int)i] == 32))
      {
        if(!((signed int)cmdline[(signed long int)i] == 9))
          goto __CPROVER_DUMP_L6;

      }


  __CPROVER_DUMP_L6:
    ;
    if((signed int)cmdline[(signed long int)i] == 0)
      break;

  }
  argv[(signed long int)argc] = (char *)(void *)0;
  *count = argc;
  return argv;
}

// str_to_int
// file common/channel.c line 739
signed int str_to_int(char *str, struct STRTAB *tab)
{
  signed int i;
  signed int return_value_atoi_1;
  if((signed int)*str >= 48)
  {
    if(!((signed int)*str >= 58))
    {
      return_value_atoi_1=atoi(str);
      return return_value_atoi_1;
    }

  }

  i = 0;
  signed int return_value_strcasecmp_2;
  for( ; !((tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
  {
    return_value_strcasecmp_2=strcasecmp(str, (tab + (signed long int)i)->str);
    if(return_value_strcasecmp_2 == 0)
      return (signed int)(tab + (signed long int)i)->nr;

  }
  return -1;
}

// strfamily
// file common/commands.c line 1198
static char * strfamily(signed int family)
{
  switch(family)
  {
    case 10:
      return "ipv6";
    case 2:
      return "ipv4";
    case 1:
      return "unix";
    default:
      return "????";
  }
}

// tcp_connect
// file common/commands.c line 1209
static signed int tcp_connect(struct addrinfo *ai, char *host, char *serv)
{
  struct addrinfo *res;
  struct addrinfo *e;
  char uhost[47l];
  char userv[33l];
  signed int sock;
  signed int rc;
  signed int opt = 1;
  ai->ai_flags = 0x0002;
  if(!(debug == 0))
    fprintf(stderr, "tcp: lookup %s:%s ... ", host, serv);

  rc=getaddrinfo(host, serv, ai, &res);
  if(!(rc == 0))
  {
    const char *return_value_gai_strerror_1;
    return_value_gai_strerror_1=gai_strerror(rc);
    fprintf(stderr, "tcp: getaddrinfo (%s:%s): %s\n", host, serv, return_value_gai_strerror_1);
    return -1;
  }

  if(!(debug == 0))
    fprintf(stderr, "ok\n");

  e = res;
  char *return_value_strfamily_3;
  for( ; !(e == ((struct addrinfo *)NULL)); e = e->ai_next)
  {
    signed int return_value_getnameinfo_2;
    return_value_getnameinfo_2=getnameinfo((struct sockaddr *)e->ai_addr, e->ai_addrlen, uhost, (unsigned int)46, userv, (unsigned int)32, 1 | 2);
    if(!(return_value_getnameinfo_2 == 0))
      fprintf(stderr, "tcp: getnameinfo (peer): oops\n");

    else
    {
      if(!(debug == 0))
      {
        return_value_strfamily_3=strfamily(e->ai_family);
        fprintf(stderr, "tcp: trying %s (%s:%s) ... ", return_value_strfamily_3, (const void *)uhost, (const void *)userv);
      }

      sock=socket(e->ai_family, e->ai_socktype, e->ai_protocol);
      if(sock == -1)
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        fprintf(stderr, "tcp: socket: %s\n", return_value_strerror_5);
        goto __CPROVER_DUMP_L10;
      }

      setsockopt(sock, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int return_value_connect_8;
      return_value_connect_8=connect(sock, e->ai_addr, e->ai_addrlen);
      if(return_value_connect_8 == -1)
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        char *return_value_strerror_7;
        return_value_strerror_7=strerror(*return_value___errno_location_6);
        fprintf(stderr, "tcp: connect: %s\n", return_value_strerror_7);
        close(sock);
        goto __CPROVER_DUMP_L10;
      }

      if(!(debug == 0))
        fprintf(stderr, "ok\n");

      fcntl(sock, 4, 04000);
      fcntl(sock, 2, 1);
      return sock;
    }

  __CPROVER_DUMP_L10:
    ;
  }
  return -1;
}

// tcp_readbuf
// file common/commands.c line 1256
static signed int tcp_readbuf(signed int sock, signed int timeout, char *dest, char dlen)
{
  struct timeval tv;
  struct anonymous_16 set;
  signed int rc;
  signed int *return_value___errno_location_1;
  do
  {

  again:
    ;
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->fds_bits[(signed long int)0]) : "memory");
    (&set)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    tv.tv_sec = (signed long int)timeout;
    tv.tv_usec = (signed long int)0;
    rc=select(sock + 1, &set, (struct anonymous_16 *)(void *)0, (struct anonymous_16 *)(void *)0, &tv);
    if(!(rc == -1))
      goto __CPROVER_DUMP_L2;

    return_value___errno_location_1=__errno_location();
  }
  while(*return_value___errno_location_1 == 4);

__CPROVER_DUMP_L2:
  ;
  if(rc == -1)
  {
    if(!(debug == 0))
      perror("tcp: select");

    return -1;
  }

  else
    if(rc == 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "tcp: select timeout\n");

      return -1;
    }

    else
    {
      signed long int return_value_read_2;
      return_value_read_2=read(sock, (void *)dest, (unsigned long int)((signed int)dlen - 1));
      rc = (signed int)return_value_read_2;
      if(rc == -1)
      {
        if(!(debug == 0))
          perror("tcp: read");

        return -1;
      }

      else
      {
        dest[(signed long int)rc] = (char)0;
        return rc;
      }
    }
}

// text_init
// file console/fbtv.c line 317
static void text_init(char *font)
{
  char *fonts[2l] = { font, (char *)(void *)0 };
  if(f == ((struct fs_font *)NULL))
  {
    char **tmp_if_expr_1;
    if(!(font == ((char *)NULL)))
      tmp_if_expr_1 = fonts;

    else
      tmp_if_expr_1 = (char **)(void *)0;
    f=fs_consolefont(tmp_if_expr_1);
  }

  if(f == ((struct fs_font *)NULL))
  {
    fprintf(stderr, "no font available\n");
    exit(1);
  }

}

// text_out
// file console/fbtv.c line 330
static void text_out(signed int x, signed int y, char *str)
{
  y = y * f->height;
  y = y - (signed int)f->fontHeader.max_bounds.descent;
  fs_puts(f, (unsigned int)x, (unsigned int)y, (unsigned char *)str);
}

// text_width
// file console/fbtv.c line 338
static signed int text_width(char *str)
{
  signed int return_value_fs_textwidth_1;
  return_value_fs_textwidth_1=fs_textwidth(f, (unsigned char *)str);
  return return_value_fs_textwidth_1;
}

// tty_cleanup
// file console/fbtv.c line 306
static void tty_cleanup(void)
{
  wclear(stdscr);
  wrefresh(stdscr);
  endwin();
}

// tty_init
// file console/fbtv.c line 296
static void tty_init(void)
{
  initscr();
  cbreak();
  noecho();
  keypad(stdscr, (_Bool)1);
}

// update_int
// file common/commands.c line 441
static signed int update_int(struct ng_attribute *attr, signed int old, char *new)
{
  signed int value = old;
  signed int step = ((attr->max - attr->min) * 3) / 100;
  if(step == 0)
    step = 1;

  signed int return_value_strcasecmp_9;
  return_value_strcasecmp_9=strcasecmp(new, "inc");
  signed int return_value_strcasecmp_8;
  signed int return_value_strncasecmp_7;
  signed int return_value_ng_attr_parse_int_1;
  signed int return_value_strncasecmp_6;
  signed int return_value_ng_attr_parse_int_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  if(return_value_strcasecmp_9 == 0)
    value = value + step;

  else
  {
    return_value_strcasecmp_8=strcasecmp(new, "dec");
    if(return_value_strcasecmp_8 == 0)
      value = value - step;

    else
    {
      return_value_strncasecmp_7=strncasecmp(new, "+=", (unsigned long int)2);
      if(return_value_strncasecmp_7 == 0)
      {
        return_value_ng_attr_parse_int_1=ng_attr_parse_int(attr, new + (signed long int)2);
        value = value + return_value_ng_attr_parse_int_1;
      }

      else
      {
        return_value_strncasecmp_6=strncasecmp(new, "-=", (unsigned long int)2);
        if(return_value_strncasecmp_6 == 0)
        {
          return_value_ng_attr_parse_int_2=ng_attr_parse_int(attr, new + (signed long int)2);
          value = value - return_value_ng_attr_parse_int_2;
        }

        else
        {
          return_value___ctype_b_loc_3=__ctype_b_loc();
          _Bool tmp_if_expr_4;
          if(!((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*new]) == 0))
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = 43 == (signed int)new[(signed long int)0] ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr_5;
          if(tmp_if_expr_4)
            tmp_if_expr_5 = (_Bool)1;

          else
            tmp_if_expr_5 = 45 == (signed int)new[(signed long int)0] ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_5)
            value=ng_attr_parse_int(attr, new);

          else
            fprintf(stderr, "update_int: can't parse %s\n", new);
        }
      }
    }
  }
  if(!(value >= attr->min))
    value = attr->min;

  if(!(attr->max >= value))
    value = attr->max;

  return value;
}

// vdr_handler
// file common/commands.c line 1293
static signed int vdr_handler(char *name, signed int argc, char **argv)
{
  char line[80l];
  struct addrinfo ask;
  signed int i;
  signed int rc;
  unsigned int l;
  unsigned int len;

reconnect:
  ;
  signed long int return_value_write_4;
  signed int *return_value___errno_location_3;
  for( ; (_Bool)1; vdr_sock = -1)
  {
    if(vdr_sock == -1)
    {
      memset((void *)&ask, 0, sizeof(struct addrinfo) /*48ul*/ );
      ask.ai_family = 0;
      ask.ai_socktype = 1;
      vdr_sock=tcp_connect(&ask, "localhost", "2001");
      if(vdr_sock == -1)
        return -1;

      if(!(debug == 0))
        fprintf(stderr, "vdr: connected\n");

      signed int return_value_tcp_readbuf_1;
      return_value_tcp_readbuf_1=tcp_readbuf(vdr_sock, 3, line, (char)sizeof(char [80l]) /*80ul*/ );
      if(return_value_tcp_readbuf_1 == -1)
        goto oops;

      if(!(debug == 0))
        fprintf(stderr, "vdr: << %s", (const void *)line);

    }

    line[(signed long int)0] = (char)0;
    i = 0;
    len = (unsigned int)0;
    for( ; !(i >= argc); i = i + 1)
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(argv[(signed long int)i]);
      l = (unsigned int)return_value_strlen_2;
      if((unsigned long int)(4u + l + len) >= 81ul)
        break;

      if(!(len == 0u))
      {
        strcpy(line + (signed long int)len, " ");
        len = len + 1u;
      }

      strcpy(line + (signed long int)len, argv[(signed long int)i]);
      len = len + l;
    }
    strcpy(line + (signed long int)len, "\r\n");
    len = len + (unsigned int)2;
    return_value_write_4=write(vdr_sock, (const void *)line, (unsigned long int)len);
    rc = (signed int)return_value_write_4;
    if(len == (unsigned int)rc)
      goto __CPROVER_DUMP_L14;

    if(!(rc == -1))
      goto __CPROVER_DUMP_L12;

    return_value___errno_location_3=__errno_location();
    if(!(*return_value___errno_location_3 == 32))
      break;

    if(!(debug == 0))
      fprintf(stderr, "tcp: write: broken pipe, trying reconnect\n");

    close(vdr_sock);
  }

__CPROVER_DUMP_L12:
  ;
  if(!(debug == 0))
    perror("tcp: write");

  goto oops;

__CPROVER_DUMP_L14:
  ;
  if(!(debug == 0))
    fprintf(stderr, "vdr: >> %s", (const void *)line);

  signed int return_value_tcp_readbuf_5;
  return_value_tcp_readbuf_5=tcp_readbuf(vdr_sock, 3, line, (char)sizeof(char [80l]) /*80ul*/ );
  if(!(return_value_tcp_readbuf_5 == -1))
  {
    if(!(debug == 0))
      fprintf(stderr, "vdr: << %s", (const void *)line);

    return 0;
  }

  else
  {

  oops:
    ;
    close(vdr_sock);
    vdr_sock = -1;
    return -1;
  }
}

// volume_handler
// file common/commands.c line 796
static signed int volume_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *vol;
  vol=ng_attr_byid(attrs, 3);
  signed int return_value_strcasecmp_3;
  if(!(argc == 0))
  {
    return_value_strcasecmp_3=strcasecmp(argv[(signed long int)0], "mute");
    if(return_value_strcasecmp_3 == 0)
    {
      if(argc >= 2)
      {
        signed int return_value_str_to_int_1;
        return_value_str_to_int_1=str_to_int(argv[(signed long int)1], booltab);
        switch(return_value_str_to_int_1)
        {
          case 0:
          {
            set_mute(0);
            break;
          }
          case 1:
          {
            set_mute(1);
            break;
          }
          default:
            set_mute((signed int)!(cur_attrs[(signed long int)4] != 0));
        }
      }

      else
        set_mute((signed int)!(cur_attrs[(signed long int)4] != 0));
    }

    else
      if(!(vol == ((struct ng_attribute *)NULL)))
      {
        signed int return_value;
        return_value=vol->read(vol);
        signed int return_value_update_int_2;
        return_value_update_int_2=update_int(vol, return_value, argv[(signed long int)0]);
        set_volume(return_value_update_int_2);
      }

    if(!(volume_notify == ((void (*)(void))NULL)))
      volume_notify();

  }


display:
  ;
  if(!(cur_attrs[4l] == 0))
    set_msg_str("volume", "muted");

  else
    if(!(vol == ((struct ng_attribute *)NULL)))
      set_msg_int(vol, cur_attrs[(signed long int)3]);

    else
      set_msg_str("volume", "unmuted");
  return 0;
}

// wav_init_header
// file libng/writefile.c line 233
static void wav_init_header(struct WAVEHDR *fileheader, struct ng_audio_fmt *audio)
{
  signed int nBitsPerSample = (signed int)ng_afmt_to_bits[(signed long int)audio->fmtid];
  signed int wav_init_header__1__channels = (signed int)ng_afmt_to_channels[(signed long int)audio->fmtid];
  signed int rate = (signed int)audio->rate;
  unsigned long int nBlockAlign = (unsigned long int)(wav_init_header__1__channels * ((nBitsPerSample + 7) / 8));
  unsigned long int nAvgBytesPerSec = nBlockAlign * (unsigned long int)rate;
  unsigned long int temp = ((unsigned long int)0 + sizeof(struct WAVEHDR) /*44ul*/ ) - sizeof(struct CHUNKHDR) /*8ul*/ ;
  fileheader->chkRiff.ckid = (unsigned int)(unsigned char)82 | (unsigned int)(unsigned char)73 << 8 | (unsigned int)(unsigned char)70 << 16 | (unsigned int)(unsigned char)70 << 24;
  fileheader->fccWave = (unsigned int)(unsigned char)87 | (unsigned int)(unsigned char)65 << 8 | (unsigned int)(unsigned char)86 << 16 | (unsigned int)(unsigned char)69 << 24;
  fileheader->chkFmt.ckid = (unsigned int)(unsigned char)102 | (unsigned int)(unsigned char)109 << 8 | (unsigned int)(unsigned char)116 << 16 | (unsigned int)(unsigned char)32 << 24;
  fileheader->chkFmt.dwSize = (unsigned int)16;
  fileheader->wFormatTag = (unsigned short int)1;
  fileheader->nChannels = (unsigned short int)wav_init_header__1__channels;
  fileheader->nSamplesPerSec = (unsigned int)rate;
  fileheader->nAvgBytesPerSec = (unsigned int)nAvgBytesPerSec;
  fileheader->nBlockAlign = (unsigned short int)nBlockAlign;
  fileheader->wBitsPerSample = (unsigned short int)nBitsPerSample;
  fileheader->chkData.ckid = (unsigned int)(unsigned char)100 | (unsigned int)(unsigned char)97 << 8 | (unsigned int)(unsigned char)116 << 16 | (unsigned int)(unsigned char)97 << 24;
  fileheader->chkRiff.dwSize = (unsigned int)temp;
  fileheader->chkData.dwSize = (unsigned int)0;
}

// wav_start_write
// file libng/writefile.c line 261
static void wav_start_write(signed int fd, struct WAVEHDR *fileheader, struct ng_audio_fmt *audio)
{
  wav_init_header(fileheader, audio);
  write(fd, (const void *)fileheader, sizeof(struct WAVEHDR) /*44ul*/ );
}

// wav_stop_write
// file libng/writefile.c line 268
static void wav_stop_write(signed int fd, struct WAVEHDR *fileheader, signed int wav_size)
{
  unsigned long int temp = ((unsigned long int)wav_size + sizeof(struct WAVEHDR) /*44ul*/ ) - sizeof(struct CHUNKHDR) /*8ul*/ ;
  fileheader->chkRiff.dwSize = (unsigned int)temp;
  fileheader->chkData.dwSize = (unsigned int)wav_size;
  lseek(fd, (signed long int)0, 0);
  write(fd, (const void *)fileheader, sizeof(struct WAVEHDR) /*44ul*/ );
}

// webcam_exit
// file common/webcam.c line 118
void webcam_exit(void)
{
  if(!(web == ((struct WEBCAM *)NULL)))
  {
    pthread_cancel(tweb);
    free((void *)web);
    web = (struct WEBCAM *)(void *)0;
  }

}

// webcam_handler
// file common/commands.c line 1115
static signed int webcam_handler(char *hname, signed int argc, char **argv)
{
  struct ng_video_fmt webcam_handler__1__fmt;
  struct ng_video_buf *webcam_handler__1__buf;
  if(!(webcam == ((char *)NULL)))
    free((void *)webcam);

  webcam=strdup(argv[(signed long int)0]);
  if(!(cur_movie == 0))
    return 0;

  else
    if(cur_capture == 2)
      return 0;

    else
    {
      if(!(capture_get_hook == ((void (*)(void))NULL)))
        capture_get_hook();

      memset((void *)&webcam_handler__1__fmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
      webcam_handler__1__fmt.fmtid = (unsigned int)9;
      webcam_handler__1__fmt.width = cur_tv_width;
      webcam_handler__1__fmt.height = cur_tv_height;
      webcam_handler__1__buf=ng_grabber_get_image(&webcam_handler__1__fmt);
      if(!(webcam_handler__1__buf == ((struct ng_video_buf *)NULL)))
        ng_release_video_buf(webcam_handler__1__buf);

      if(!(capture_rel_hook == ((void (*)(void))NULL)))
        capture_rel_hook();

      return 0;
    }
}

// webcam_init
// file common/webcam.c line 108
void webcam_init(void)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct WEBCAM) /*104ul*/ );
  web = (struct WEBCAM *)return_value_malloc_1;
  memset((void *)web, 0, sizeof(struct WEBCAM) /*104ul*/ );
  pthread_mutex_init(&web->lock, (const union anonymous_9 *)(void *)0);
  pthread_create(&tweb, (const union pthread_attr_t *)(void *)0, webcam_writer, (void *)web);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// webcam_put
// file common/webcam.c line 128
signed int webcam_put(char *filename, struct ng_video_buf *buf)
{
  signed int ret = 0;
  if(web == ((struct WEBCAM *)NULL))
    webcam_init();

  signed int return_value_pthread_mutex_trylock_1;
  return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&web->lock);
  if(return_value_pthread_mutex_trylock_1 == -1)
  {
    if(!(debug == 0))
      fprintf(stderr, "webcam_put: locked\n");

    return -1;
  }

  else
  {
    if(!(web->buf == ((struct ng_video_buf *)NULL)))
    {
      if(!(debug == 0))
        fprintf(stderr, "webcam_put: still has data\n");

      ret = -1;
    }

    else
    {
      web->filename=strdup(filename);
      web->buf = buf;
      buf->refcount = buf->refcount + 1;
      if(!(debug == 0))
        fprintf(stderr, "webcam_put: ok\n");

      pthread_cond_signal(&web->wait);
    }

  done:
    ;
    pthread_mutex_unlock(&web->lock);
    return ret;
  }
}

// webcam_writer
// file common/webcam.c line 30
static void * webcam_writer(void *arg)
{
  struct WEBCAM *webcam_writer__1__web = (struct WEBCAM *)arg;
  signed int rename;
  signed int fd;
  signed int old;
  char tmpfilename[512l];
  struct ng_video_fmt *webcam_writer__1__fmt;
  if(!(debug == 0))
    fprintf(stderr, "webcam_writer start\n");

  pthread_setcancelstate(0, &old);
  pthread_setcanceltype(1, &old);
  pthread_mutex_lock(&webcam_writer__1__web->lock);

__CPROVER_DUMP_L2:
  ;
  for( ; (_Bool)1; webcam_writer__1__web->buf = (struct ng_video_buf *)(void *)0)
  {
    if(webcam_writer__1__web->buf == ((struct ng_video_buf *)NULL))
    {
      if(!(debug == 0))
        fprintf(stderr, "webcam_writer: waiting for data\n");

      pthread_cond_wait(&webcam_writer__1__web->wait, &webcam_writer__1__web->lock);
      goto __CPROVER_DUMP_L2;
    }

    webcam_writer__1__fmt = &webcam_writer__1__web->buf->fmt;
    if(!(debug == 0))
      fprintf(stderr, "webcam_writer: %d %dx%d \n", webcam_writer__1__fmt->fmtid, webcam_writer__1__fmt->width, webcam_writer__1__fmt->height);

    rename = 1;
    sprintf(tmpfilename, "%s.___", webcam_writer__1__web->filename);
    switch(webcam_writer__1__fmt->fmtid)
    {
      case (unsigned int)16:

      case (unsigned int)17:
      {
        fd=open(tmpfilename, 0100 | 01, 0666);
        if(fd == -1)
        {
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          char *return_value_strerror_2;
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          fprintf(stderr, "open(%s): %s\n", (const void *)tmpfilename, return_value_strerror_2);
          goto done;
        }

        write(fd, (const void *)webcam_writer__1__web->buf->data, webcam_writer__1__web->buf->size);
        close(fd);
        break;
      }
      case (unsigned int)9:
      {
        write_jpeg(tmpfilename, webcam_writer__1__web->buf, ng_jpeg_quality, 0);
        break;
      }
      default:
      {
        fprintf(stderr, "webcam_writer: can't deal with format=%d\n", webcam_writer__1__fmt->fmtid);
        rename = 0;
      }
    }
    if(!(rename == 0))
    {
      unlink(webcam_writer__1__web->filename);
      signed int return_value_link_5;
      return_value_link_5=link(tmpfilename, webcam_writer__1__web->filename);
      if(return_value_link_5 == -1)
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        fprintf(stderr, "link(%s,%s): %s\n", (const void *)tmpfilename, webcam_writer__1__web->filename, return_value_strerror_4);
        break;
      }

      unlink(tmpfilename);
    }

    free((void *)webcam_writer__1__web->filename);
    ng_release_video_buf(webcam_writer__1__web->buf);
  }

done:
  ;
  pthread_mutex_unlock(&webcam_writer__1__web->lock);
  if(!(debug == 0))
    fprintf(stderr, "webcam_writer done\n");

  return (void *)0;
}

// wrio4
// file console/matrox.c line 30
static void wrio4(signed int adr, unsigned long int val)
{
  mmio[(signed long int)adr] = (unsigned int)val;
}

// write_jpeg
// file ./libng/writefile.h line 4
signed int write_jpeg(char *filename, struct ng_video_buf *buf, signed int quality, signed int gray)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "grab: can't open %s: %s\n", filename, return_value_strerror_2);
    return -1;
  }

  signed int return_value_do_write_jpeg_3;
  return_value_do_write_jpeg_3=do_write_jpeg(fp, buf, quality, gray);
  return return_value_do_write_jpeg_3;
}

// write_pgm
// file libng/writefile.c line 161
signed int write_pgm(char *filename, struct ng_video_buf *buf)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "grab: can't open %s: %s\n", filename, return_value_strerror_2);
    return -1;
  }

  fprintf(fp, "P5\n%d %d\n255\n", buf->fmt.width, buf->fmt.height);
  fwrite((const void *)buf->data, (unsigned long int)buf->fmt.height, (unsigned long int)buf->fmt.width, fp);
  fclose(fp);
  return 0;
}

// write_ppm
// file ./libng/writefile.h line 6
signed int write_ppm(char *filename, struct ng_video_buf *buf)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "grab: can't open %s: %s\n", filename, return_value_strerror_2);
    return -1;
  }

  fprintf(fp, "P6\n%d %d\n255\n", buf->fmt.width, buf->fmt.height);
  fwrite((const void *)buf->data, (unsigned long int)buf->fmt.height, (unsigned long int)((unsigned int)3 * buf->fmt.width), fp);
  fclose(fp);
  return 0;
}

// writer_audio_thread
// file common/capture.c line 295
static void * writer_audio_thread(void *arg)
{
  struct movie_handle *h = (struct movie_handle *)arg;
  struct ng_audio_buf *writer_audio_thread__1__buf;
  signed int return_value_getpid_1;
  if(!(debug == 0))
  {
    return_value_getpid_1=getpid();
    fprintf(stderr, "writer_audio_thread start [pid=%d]\n", return_value_getpid_1);
  }

  void *return_value_fifo_get_2;
  return_value_fifo_get_2=fifo_get(&h->afifo);
  writer_audio_thread__1__buf = (struct ng_audio_buf *)return_value_fifo_get_2;
  if(!(writer_audio_thread__1__buf == ((struct ng_audio_buf *)NULL)))
  {
    pthread_mutex_lock(&h->lock);
    h->writer->wr_audio(h->handle, writer_audio_thread__1__buf);
    pthread_mutex_unlock(&h->lock);
    free((void *)writer_audio_thread__1__buf);
  }

  if(!(debug == 0))
    fprintf(stderr, "writer_audio_thread done\n");

  return (void *)0;
}

// writer_video_thread
// file common/capture.c line 321
static void * writer_video_thread(void *arg)
{
  struct movie_handle *h = (struct movie_handle *)arg;
  struct ng_video_buf *writer_video_thread__1__buf;
  struct ng_video_buf *reorder[32l];
  signed int seq;
  signed int slot;
  signed int return_value_getpid_1;
  if(!(debug == 0))
  {
    return_value_getpid_1=getpid();
    fprintf(stderr, "writer_video_thread start [pid=%d]\n", return_value_getpid_1);
  }

  seq = 0;
  memset((void *)&reorder, 0, sizeof(struct ng_video_buf *[32l]) /*256ul*/ );
  do
  {
    void *return_value_fifo_get_2;
    return_value_fifo_get_2=fifo_get(&h->vfifo);
    writer_video_thread__1__buf = (struct ng_video_buf *)return_value_fifo_get_2;
    if(writer_video_thread__1__buf == ((struct ng_video_buf *)NULL))
      break;

    slot = writer_video_thread__1__buf->info.seq % 32;
    if(debug >= 2)
      fprintf(stderr, "video write: get seq=%d [%d]\n", writer_video_thread__1__buf->info.seq, slot);

    if(!(reorder[(signed long int)slot] == ((struct ng_video_buf *)NULL)))
    {
      fprintf(stderr, "panic: reorder buffer full\n");
      exit(1);
    }

    reorder[(signed long int)slot] = writer_video_thread__1__buf;
    slot = seq % 32;
    if(!(reorder[(signed long int)slot] == ((struct ng_video_buf *)NULL)))
    {
      writer_video_thread__1__buf = reorder[(signed long int)slot];
      reorder[(signed long int)slot] = (struct ng_video_buf *)(void *)0;
      if(debug >= 2)
        fprintf(stderr, "video write: put seq=%d [%d/%d]\n", writer_video_thread__1__buf->info.seq, slot, seq);

      seq = seq + 1;
      pthread_mutex_lock(&h->lock);
      h->writer->wr_video(h->handle, writer_video_thread__1__buf);
      if(!(writer_video_thread__1__buf->info.twice == 0))
        h->writer->wr_video(h->handle, writer_video_thread__1__buf);

      pthread_mutex_unlock(&h->lock);
      ng_release_video_buf(writer_video_thread__1__buf);
    }

  }
  while((_Bool)1);
  if(!(debug == 0))
    fprintf(stderr, "writer_video_thread done\n");

  return (void *)0;
}

// yuv420p_to_rgb24
// file libng/color_yuv2rgb.c line 170
static void yuv420p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char * restrict d;
  unsigned char *us;
  unsigned char *vs;
  unsigned char *dp;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)4);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = dp;
    us = u;
    vs = v;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post_3 = d;
      d = d + 1l;
      *tmp_post_3 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post_4 = d;
      d = d + 1l;
      *tmp_post_4 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post_5 = d;
      d = d + 1l;
      *tmp_post_5 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post_6 = d;
      d = d + 1l;
      *tmp_post_6 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    if(i % 2u == 0u)
    {
      u = us;
      v = vs;
    }

    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// yuv422_to_gray
// file libng/color_yuv2rgb.c line 64
static void yuv422_to_gray(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned char * restrict d = dest;
  for( ; !(p == 0); s = s + (signed long int)2)
  {
    d[(signed long int)0] = (unsigned char)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    p = p - 1;
    d = d + 1l;
  }
}

// yuv422_to_rgb24
// file libng/color_yuv2rgb.c line 78
static void yuv422_to_rgb24(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned char * restrict d = dest;
  signed int gray;
  for( ; !(p == 0); p = p - 2)
  {
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    d[(signed long int)0] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])];
    d[(signed long int)1] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])];
    d[(signed long int)2] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])];
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)2]];
    d[(signed long int)3] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])];
    d[(signed long int)4] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])];
    d[(signed long int)5] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])];
    d = d + (signed long int)6;
    s = s + (signed long int)4;
  }
}

// yuv422p_to_rgb24
// file libng/color_yuv2rgb.c line 206
static void yuv422p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char * restrict d;
  unsigned char *dp;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)2);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post_3 = d;
      d = d + 1l;
      *tmp_post_3 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post_4 = d;
      d = d + 1l;
      *tmp_post_4 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post_5 = d;
      d = d + 1l;
      *tmp_post_5 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post_6 = d;
      d = d + 1l;
      *tmp_post_6 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// yuv42xp_to_gray
// file libng/color_yuv2rgb.c line 149
static void yuv42xp_to_gray(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict d;
  unsigned char *dp;
  unsigned int i;
  unsigned int j;
  dp = out->data;
  y = in->data;
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + 1u)
    {
      *d = (unsigned char)ng_yuv_gray[(signed long int)*y];
      d = d + 1l;
      y = y + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

