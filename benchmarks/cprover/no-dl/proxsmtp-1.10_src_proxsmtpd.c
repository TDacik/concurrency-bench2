// #anon_enum$CAP_CLEAR=0$CAP_SET=1
// file /usr/include/sys/capability.h line 63
enum anonymous$4 { CAP_CLEAR=0, CAP_SET=1 };

// #anon_enum$CAP_EFFECTIVE=0$CAP_PERMITTED=1$CAP_INHERITABLE=2
// file /usr/include/sys/capability.h line 54
enum anonymous$3 { CAP_EFFECTIVE=0, CAP_PERMITTED=1, CAP_INHERITABLE=2 };

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$2;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$5;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$6;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$1;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$7;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_cap_struct
// file /usr/include/sys/capability.h line 41
struct _cap_struct;

// tag-_sockaddr_any
// file ../common/sock_any.h line 48
union _sockaddr_any;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-pxstate
// file proxsmtpd.c line 61
struct pxstate;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_any
// file ../common/sock_any.h line 46
struct sockaddr_any;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/un.h line 29
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-spctx
// file ../common/smtppass.h line 44
struct spctx;

// tag-spio
// file ../common/smtppass.h line 65
struct spio;

// tag-spstate
// file ../common/sppriv.h line 54
struct spstate;

// tag-spthread
// file ../common/smtppass.c line 85
struct spthread;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$7, unsigned int *);
// asctime_r
// file /usr/include/time.h line 272
extern char * asctime_r(struct tm *, char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$7, unsigned int);
// buffer_reject_message
// file proxsmtpd.c line 871
static void buffer_reject_message(char *data, char *buf, signed int buflen);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cap_free
// file /usr/include/sys/capability.h line 74
extern signed int cap_free(void *);
// cap_init
// file /usr/include/sys/capability.h line 75
extern struct _cap_struct * cap_init(void);
// cap_set_flag
// file /usr/include/sys/capability.h line 79
extern signed int cap_set_flag(struct _cap_struct *, enum anonymous$3, signed int, const signed int *, enum anonymous$4);
// cap_set_proc
// file /usr/include/sys/capability.h line 93
extern signed int cap_set_proc(struct _cap_struct *);
// cb_check_data
// file proxsmtpd.c line 241
extern signed int cb_check_data(struct spctx *ctx);
// cb_check_pre
// file proxsmtpd.c line 228
extern signed int cb_check_pre(struct spctx *ctx);
// cb_del_context
// file proxsmtpd.c line 348
extern void cb_del_context(struct spctx *ctx);
// cb_new_context
// file proxsmtpd.c line 340
extern struct spctx * cb_new_context();
// cb_parse_option
// file proxsmtpd.c line 285
extern signed int cb_parse_option(const char *name, const char *value);
// check_first_word
// file ../common/stringx.h line 42
signed int check_first_word(const char *line, const char *word, signed int len, char *delims);
// cleanup_context
// file ../common/smtppass.c line 685
static void cleanup_context(struct spctx *ctx);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_raw
// file ../common/spio.c line 79
static void close_raw(signed int *fd);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// connection_loop
// file ../common/smtppass.c line 516
static void connection_loop(signed int sock);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// do_server_noop
// file ../common/smtppass.c line 1955
static void do_server_noop(struct spctx *ctx);
// done_thread
// file ../common/smtppass.c line 730
static void done_thread(struct spctx *ctx);
// drop_privileges
// file ../common/smtppass.c line 413
static void drop_privileges();
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// err
// file /usr/include/err.h line 46
extern void err(signed int, const char *, ...);
// errx
// file /usr/include/err.h line 50
extern void errx(signed int, const char *, ...);
// execl
// file /usr/include/unistd.h line 573
extern signed int execl(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// final_reject_message
// file proxsmtpd.c line 863
static void final_reject_message(char *buf, signed int buflen);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fork_filter
// file proxsmtpd.c line 365
static signed int fork_filter(struct spctx *sp, signed int *infd, signed int *outfd, signed int *errfd);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_successful_rsp
// file ../common/smtppass.c line 1365
static const char * get_successful_rsp(const char *line, signed int *cont);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getline
// file /usr/include/stdio.h line 678
extern signed long int getline(char ** restrict , unsigned long int *, struct _IO_FILE *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpeername
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 141
extern signed int getpeername(signed int, struct sockaddr *, unsigned int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init_thread
// file ../common/smtppass.c line 651
static struct spctx * init_thread(signed int fd);
// is_blank_line
// file ../common/stringx.h line 45
signed int is_blank_line(const char *line);
// is_first_word
// file ../common/stringx.h line 43
signed int is_first_word(const char *line, const char *word, signed int len);
// is_last_word
// file ../common/stringx.c line 99
signed int is_last_word(const char *line, const char *word, signed int len);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// kill_myself
// file proxsmtpd.c line 357
static void kill_myself();
// kill_process
// file proxsmtpd.c line 955
static signed int kill_process(struct spctx *sp, signed int pid);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log_io_data
// file ../common/spio.c line 87
static void log_io_data(struct spctx *ctx, struct spio *io, const char *data, signed int read);
// make_connections
// file ../common/smtppass.c line 793
static signed int make_connections(struct spctx *ctx, signed int client);
// make_date
// file ../common/smtppass.c line 1548
static void make_date(struct spctx *ctx, char *date);
// make_header
// file ../common/smtppass.c line 1613
static signed int make_header(struct spctx *ctx, const char *format_str, char *header);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkstemp
// file /usr/include/stdlib.h line 619
extern signed int mkstemp(char *);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// on_quit
// file ../common/smtppass.c line 408
static void on_quit(signed int signal);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// parse_address
// file ../common/smtppass.c line 1305
static char * parse_address(char *line);
// parse_config_file
// file ../common/smtppass.c line 2257
static signed int parse_config_file(const char *configfile);
// parse_xforward
// file ../common/smtppass.c line 1331
static char * parse_xforward(char *line, const char *part);
// pid_file
// file ../common/smtppass.c line 483
static void pid_file(signed int write);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// prctl
// file /usr/include/x86_64-linux-gnu/sys/prctl.h line 27
extern signed int prctl(signed int, ...);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_file_command
// file proxsmtpd.c line 485
static signed int process_file_command(struct spctx *sp);
// process_pipe_command
// file proxsmtpd.c line 616
static signed int process_pipe_command(struct spctx *sp);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$6 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$6 *, const union anonymous *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$6 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$6 *);
// pthread_mutexattr_destroy
// file /usr/include/pthread.h line 812
extern signed int pthread_mutexattr_destroy(union anonymous *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous *);
// pthread_mutexattr_settype
// file /usr/include/pthread.h line 835
extern signed int pthread_mutexattr_settype(union anonymous *, signed int);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_raw
// file ../common/spio.c line 342
signed int read_raw(struct spctx *ctx, struct spio *io, signed int opts);
// read_server_response
// file ../common/smtppass.c line 1932
static signed int read_server_response(struct spctx *ctx);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reallocf
// file ../common/compat.h line 58
void * reallocf(void *ptr, unsigned long int size);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$2 *, struct anonymous$2 *, struct anonymous$2 *, struct timeval *);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// setresgid
// file /usr/include/unistd.h line 748
extern signed int setresgid(unsigned int, unsigned int, unsigned int);
// setresuid
// file /usr/include/unistd.h line 743
extern signed int setresuid(unsigned int, unsigned int, unsigned int);
// setreuid
// file /usr/include/unistd.h line 705
extern signed int setreuid(unsigned int, unsigned int);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// should_skip_processing
// file ../common/smtppass.c line 902
static signed int should_skip_processing(struct spctx *ctx);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// siginterrupt
// file /usr/include/signal.h line 323
extern signed int siginterrupt(signed int, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// smtp_passthru
// file ../common/smtppass.c line 912
static signed int smtp_passthru(struct spctx *ctx);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sock_any_cmp
// file ../common/sock_any.h line 88
signed int sock_any_cmp(struct sockaddr_any *a1, struct sockaddr_any *a2, signed int opts);
// sock_any_cpy
// file ../common/sock_any.h line 90
void sock_any_cpy(struct sockaddr_any *dst, struct sockaddr_any *src, signed int opts);
// sock_any_ntop
// file ../common/sock_any.h line 83
signed int sock_any_ntop(struct sockaddr_any *any, char *addr, unsigned long int addrlen, signed int opts);
// sock_any_pton
// file ../common/sock_any.h line 67
signed int sock_any_pton(const char *addr, struct sockaddr_any *any, signed int opts);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sp_add_log
// file ../common/smtppass.h line 191
void sp_add_log(struct spctx *ctx, char *prefix, char *line);
// sp_cache_data
// file ../common/smtppass.h line 220
signed int sp_cache_data(struct spctx *ctx);
// sp_done
// file ../common/smtppass.h line 171
void sp_done();
// sp_done_data
// file ../common/smtppass.h line 226
signed int sp_done_data(struct spctx *ctx, const char *headertmpl);
// sp_fail_data
// file ../common/smtppass.h line 232
signed int sp_fail_data(struct spctx *ctx, const char *smtp_status);
// sp_fail_msg
// file ../common/smtppass.h line 244
signed int sp_fail_msg(struct spctx *ctx, const char *smtp_status);
// sp_init
// file ../common/smtppass.h line 147
void sp_init(const char *name);
// sp_is_quit
// file ../common/smtppass.h line 165
signed int sp_is_quit();
// sp_lock
// file ../common/smtppass.c line 2075
void sp_lock();
// sp_message
// file ../common/smtppass.h line 258
void sp_message(struct spctx *ctx, signed int level, const char *msg, ...);
// sp_messagex
// file ../common/smtppass.h line 259
void sp_messagex(struct spctx *ctx, signed int level, const char *msg, ...);
// sp_parse_option
// file ../common/smtppass.c line 2125
signed int sp_parse_option(const char *name, const char *value);
// sp_pass_data
// file ../common/smtppass.c line 1829
signed int sp_pass_data(struct spctx *ctx);
// sp_quit
// file ../common/smtppass.c line 385
void sp_quit();
// sp_read_data
// file ../common/smtppass.h line 206
signed int sp_read_data(struct spctx *ctx, const char **data);
// sp_run
// file ../common/smtppass.h line 153
signed int sp_run(const char *configfile, const char *pidfile, signed int dbg_level);
// sp_setup_forked
// file ../common/smtppass.h line 251
void sp_setup_forked(struct spctx *ctx, signed int file);
// sp_start_data
// file ../common/smtppass.h line 197
signed int sp_start_data(struct spctx *ctx);
// sp_unlock
// file ../common/smtppass.c line 2111
void sp_unlock();
// sp_write_data
// file ../common/smtppass.h line 214
signed int sp_write_data(struct spctx *ctx, const char *buf, signed int len);
// spio_attach
// file ../common/spio.c line 122
void spio_attach(struct spctx *ctx, struct spio *io, signed int fd, struct sockaddr_any *peer);
// spio_connect
// file ../common/spio.c line 162
signed int spio_connect(struct spctx *ctx, struct spio *io, struct sockaddr_any *sdst, const char *dstname, struct sockaddr_any *ssrc, const char *srcname);
// spio_disconnect
// file ../common/spio.c line 229
void spio_disconnect(struct spctx *ctx, struct spio *io);
// spio_init
// file ../common/spio.c line 114
void spio_init(struct spio *io, const char *name);
// spio_read_junk
// file ../common/spio.c line 639
void spio_read_junk(struct spctx *ctx, struct spio *io);
// spio_read_line
// file ../common/spio.c line 509
signed int spio_read_line(struct spctx *ctx, struct spio *io, signed int opts);
// spio_select
// file ../common/spio.c line 240
unsigned int spio_select(struct spctx *ctx, ...);
// spio_write_data
// file ../common/spio.c line 555
signed int spio_write_data(struct spctx *ctx, struct spio *io, const char *data);
// spio_write_data_raw
// file ../common/spio.c line 587
signed int spio_write_data_raw(struct spctx *ctx, struct spio *io, const unsigned char *buf, signed int len);
// spio_write_dataf
// file ../common/spio.c line 570
signed int spio_write_dataf(struct spctx *ctx, struct spio *io, const char *fmt, ...);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcasestr
// file /usr/include/string.h line 372
extern char * strcasestr(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlcat
// file ../common/compat.h line 82
unsigned long int strlcat(char *dst, const char *src, unsigned long int siz);
// strlcpy
// file ../common/compat.h line 86
unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strlwr
// file ../common/compat.c line 89
char * strlwr(char *s);
// strncasecmp
// file /usr/include/strings.h line 120
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strtob
// file ../common/stringx.h line 51
signed int strtob(const char *str);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strupr
// file ../common/compat.c line 102
char * strupr(char *s);
// thread_main
// file ../common/smtppass.c line 742
static void * thread_main(void *arg);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// trim_end
// file ../common/stringx.h line 48
char * trim_end(char *data);
// trim_space
// file ../common/stringx.h line 49
char * trim_space(char *data);
// trim_start
// file ../common/stringx.h line 47
char * trim_start(const char *data);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file proxsmtpd.c line 217
static void usage();
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vmessage
// file ../common/smtppass.c line 2007
static void vmessage(struct spctx *ctx, signed int level, signed int err, const char *msg, void **ap);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vsyslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 200
extern void vsyslog(signed int, const char *, void **);
// vwarnx
// file /usr/include/err.h line 42
extern void vwarnx(const char *, void **);
// wait_process
// file proxsmtpd.c line 920
static signed int wait_process(struct spctx *sp, signed int pid, signed int *status);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// warnx
// file /usr/include/err.h line 40
extern void warnx(const char *, ...);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$2
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

union anonymous$5
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$6
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$1
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$7
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

union _sockaddr_any
{
  // a
  struct sockaddr a;
  // un
  struct sockaddr_un un;
  // in
  struct sockaddr_in in;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct in6_addr
{
  // __in6_u
  union anonymous$5 __in6_u;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct pxstate
{
  // filter_type
  signed int filter_type;
  // command
  const char *command;
  // reject
  const char *reject;
  // timeout
  struct timeval timeout;
  // directory
  const char *directory;
  // header
  const char *header;
};

struct sockaddr_any
{
  // s
  union _sockaddr_any s;
  // namelen
  unsigned int namelen;
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct spio
{
  // fd
  signed int fd;
  // name
  const char *name;
  // last_action
  signed long int last_action;
  // peername
  char peername[4096l];
  // localname
  char localname[4096l];
  // line
  char line[4224l];
  // _nx
  char *_nx;
  // _ln
  unsigned long int _ln;
};

struct spctx
{
  // id
  unsigned int id;
  // client
  struct spio client;
  // server
  struct spio server;
  // cachefile
  struct _IO_FILE *cachefile;
  // cachename
  char cachename[4096l];
  // logline
  char logline[768l];
  // sender
  char *sender;
  // recipients
  char *recipients;
  // xforwardaddr
  char *xforwardaddr;
  // xforwardhelo
  char *xforwardhelo;
  // authenticated
  signed int authenticated;
  // _crlf
  signed int _crlf;
};

struct spstate
{
  // debug_level
  signed int debug_level;
  // max_threads
  signed int max_threads;
  // timeout
  struct timeval timeout;
  // keepalives
  signed int keepalives;
  // transparent
  signed int transparent;
  // xclient
  signed int xclient;
  // directory
  const char *directory;
  // user
  const char *user;
  // pidfile
  const char *pidfile;
  // header
  const char *header;
  // skip
  signed int skip;
  // outaddr
  struct sockaddr_any outaddr;
  // outname
  const char *outname;
  // listenaddr
  struct sockaddr_any listenaddr;
  // listenname
  const char *listenname;
  // name
  const char *name;
  // quit
  signed int quit;
  // daemonized
  signed int daemonized;
  // _p
  char *_p;
};

struct spthread
{
  // tid
  unsigned long int tid;
  // fd
  signed int fd;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// __argv
// file proxsmtpd.c line 136
char **__argv;
// g_mtxattr
// file ../common/smtppass.c line 209
union anonymous g_mtxattr;
// g_mutex
// file ../common/smtppass.c line 208
union anonymous$6 g_mutex;
// g_pxstate
// file proxsmtpd.c line 117
struct pxstate g_pxstate;
// g_state
// file ../common/smtppass.c line 206
struct spstate g_state;
// g_unique_id
// file ../common/smtppass.c line 207
unsigned int g_unique_id = (unsigned int)0x00100000;
// kMsgDelimiter
// file ../common/smtppass.c line 2004
const char kMsgDelimiter[3l] = { ':', ' ', 0 };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;

// buffer_reject_message
// file proxsmtpd.c line 871
static void buffer_reject_message(char *data, char *buf, signed int buflen)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(data);
  len = (signed int)return_value_strlen$1;
  char *t = data + (signed long int)len;
  signed int newline = 0;
  const unsigned short int **return_value___ctype_b_loc$2;
  while(!(data >= t))
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)t[-1l]]) == 0)
      break;

    t = t - 1l;
    if((signed int)*t == 10)
      newline = 1;

  }
  if(!(data >= t))
  {
    if(!(newline == 0))
      *t = (char)0;

    t=strrchr(data, 10);
    if(t == ((char *)NULL))
    {
      t=trim_start(data);
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(buf);
      if((signed int)buf[-1l + (signed long int)return_value_strlen$3] == 10)
        buf[(signed long int)0] = (char)0;

    }

    else
    {
      t=trim_start(t);
      buf[(signed long int)0] = (char)0;
    }
    strlcat(buf, t, (unsigned long int)buflen);
  }

  if(!(newline == 0))
    strlcat(buf, "\n", (unsigned long int)buflen);

}

// cb_check_data
// file proxsmtpd.c line 241
extern signed int cb_check_data(struct spctx *ctx)
{
  signed int r = 0;
  if(g_pxstate.filter_type == 3)
  {
    sp_add_log(ctx, "status=", "REJECTED");
    signed int return_value_sp_fail_data$1;
    return_value_sp_fail_data$1=sp_fail_data(ctx, g_pxstate.reject);
    if(!(return_value_sp_fail_data$1 >= 0))
      return -1;

    return 0;
  }

  signed int return_value_sp_start_data$2;
  return_value_sp_start_data$2=sp_start_data(ctx);
  _Bool tmp_if_expr$5;
  signed int return_value_sp_done_data$4;
  signed int return_value_waitpid$6;
  if(!(return_value_sp_start_data$2 >= 0))
    return -1;

  else
  {
    if(g_pxstate.command == ((const char *)NULL))
    {
      sp_messagex(ctx, 4, "no filter command specified. passing message through");
      signed int return_value_sp_cache_data$3;
      return_value_sp_cache_data$3=sp_cache_data(ctx);
      if(return_value_sp_cache_data$3 == -1)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_sp_done_data$4=sp_done_data(ctx, g_pxstate.header);
        tmp_if_expr$5 = return_value_sp_done_data$4 == -1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        return -1;

      return 0;
    }

    do
    {
      return_value_waitpid$6=waitpid(-1, &r, 1);
      if(!(return_value_waitpid$6 >= 1))
        break;

    }
    while((_Bool)1);
    if(g_pxstate.filter_type == 1)
      r=process_pipe_command(ctx);

    else
      r=process_file_command(ctx);
    if(r == -1)
    {
      signed int return_value_sp_fail_data$7;
      return_value_sp_fail_data$7=sp_fail_data(ctx, (const char *)(void *)0);
      if(return_value_sp_fail_data$7 == -1)
        return -1;

    }

    return 0;
  }
}

// cb_check_pre
// file proxsmtpd.c line 228
extern signed int cb_check_pre(struct spctx *ctx)
{
  if(g_pxstate.filter_type == 3)
  {
    sp_add_log(ctx, "status=", "REJECTED");
    signed int return_value_sp_fail_msg$1;
    return_value_sp_fail_msg$1=sp_fail_msg(ctx, g_pxstate.reject);
    if(!(return_value_sp_fail_msg$1 >= 0))
      return -1;

    return 0;
  }

  return 1;
}

// cb_del_context
// file proxsmtpd.c line 348
extern void cb_del_context(struct spctx *ctx)
{
  free((void *)ctx);
}

// cb_new_context
// file proxsmtpd.c line 340
extern struct spctx * cb_new_context()
{
  struct spctx *ctx;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct spctx) /*29832ul*/ );
  ctx = (struct spctx *)return_value_calloc$1;
  if(ctx == ((struct spctx *)NULL))
    sp_messagex((struct spctx *)(void *)0, 2, "out of memory");

  return ctx;
}

// cb_parse_option
// file proxsmtpd.c line 285
extern signed int cb_parse_option(const char *name, const char *value)
{
  char *t;
  signed int return_value_strcasecmp$10;
  return_value_strcasecmp$10=strcasecmp("FilterCommand", name);
  signed int return_value_strcasecmp$9;
  signed int return_value_strcasecmp$8;
  signed int return_value_strcasecmp$7;
  signed int return_value_strcasecmp$2;
  signed int return_value_strcasecmp$1;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$5;
  if(return_value_strcasecmp$10 == 0)
  {
    g_pxstate.command = value;
    return 1;
  }

  else
  {
    return_value_strcasecmp$9=strcasecmp("TempDirectory", name);
    if(return_value_strcasecmp$9 == 0)
    {
      g_pxstate.directory = value;
      return 1;
    }

    else
    {
      return_value_strcasecmp$8=strcasecmp("FilterTimeout", name);
      if(return_value_strcasecmp$8 == 0)
      {
        g_pxstate.timeout.tv_sec=strtol(value, &t, 10);
        if(!(*t == 0) || !(g_pxstate.timeout.tv_sec >= 1l))
          errx(2, "invalid setting: FilterTimeout");

        return 1;
      }

      else
      {
        return_value_strcasecmp$7=strcasecmp("FilterType", name);
        if(return_value_strcasecmp$7 == 0)
        {
          signed int return_value_strcasecmp$3;
          return_value_strcasecmp$3=strcasecmp(value, "pipe");
          if(return_value_strcasecmp$3 == 0)
            g_pxstate.filter_type = 1;

          else
          {
            return_value_strcasecmp$2=strcasecmp(value, "file");
            if(return_value_strcasecmp$2 == 0)
              g_pxstate.filter_type = 2;

            else
            {
              return_value_strcasecmp$1=strcasecmp(value, "reject");
              if(return_value_strcasecmp$1 == 0)
                g_pxstate.filter_type = 3;

              else
                errx(2, "invalid value for FilterType (must specify 'pipe' or 'file' or 'reject')");
            }
          }
          return 1;
        }

        else
        {
          return_value_strcasecmp$6=strcasecmp("FilterReject", name);
          if(return_value_strcasecmp$6 == 0)
          {
            g_pxstate.reject = value;
            return 1;
          }

          else
          {
            return_value_strcasecmp$5=strcasecmp("Header", name);
            if(return_value_strcasecmp$5 == 0)
            {
              g_pxstate.header=trim_start(value);
              unsigned long int return_value_strlen$4;
              return_value_strlen$4=strlen(g_pxstate.header);
              if(return_value_strlen$4 == 0ul)
                g_pxstate.header = (const char *)(void *)0;

              return 1;
            }

          }
        }
      }
    }
  }
  return 0;
}

// check_first_word
// file ../common/stringx.h line 42
signed int check_first_word(const char *line, const char *word, signed int len, char *delims)
{
  const char *t;
  signed int found = 0;
  t = line;
  char *return_value_strchr$1;
  for( ; !(*t == 0); t = t + 1l)
  {
    return_value_strchr$1=strchr(delims, (signed int)*t);
    if(return_value_strchr$1 == ((char *)NULL))
      break;

  }
  signed int return_value_strncasecmp$2;
  return_value_strncasecmp$2=strncasecmp(t, word, (unsigned long int)len);
  char *return_value_strchr$3;
  if(!(return_value_strncasecmp$2 == 0))
    return 0;

  else
  {
    t = t + (signed long int)len;
    for( ; !(*t == 0); t = t + 1l)
    {
      return_value_strchr$3=strchr(delims, (signed int)*t);
      if(return_value_strchr$3 == ((char *)NULL))
        break;

      found = 1;
    }
    return (signed int)((!(*t != 0) ? (_Bool)1 : (found != 0 ? (_Bool)1 : (_Bool)0)) ? t - line : (signed long int)0);
  }
}

// cleanup_context
// file ../common/smtppass.c line 685
static void cleanup_context(struct spctx *ctx)
{
  if(!(ctx->cachefile == ((struct _IO_FILE *)NULL)))
  {
    fclose(ctx->cachefile);
    ctx->cachefile = (struct _IO_FILE *)(void *)0;
  }

  if(!(ctx->cachename[0l] == 0))
  {
    unlink(ctx->cachename);
    ctx->cachename[(signed long int)0] = (char)0;
  }

  if(!(ctx->recipients == ((char *)NULL)))
  {
    free((void *)ctx->recipients);
    ctx->recipients = (char *)(void *)0;
  }

  if(!(ctx->sender == ((char *)NULL)))
  {
    free((void *)ctx->sender);
    ctx->sender = (char *)(void *)0;
  }

  if(!(ctx->xforwardaddr == ((char *)NULL)))
  {
    free((void *)ctx->xforwardaddr);
    ctx->xforwardaddr = (char *)(void *)0;
  }

  if(!(ctx->xforwardhelo == ((char *)NULL)))
  {
    free((void *)ctx->xforwardhelo);
    ctx->xforwardhelo = (char *)(void *)0;
  }

  ctx->logline[(signed long int)0] = (char)0;
  sp_add_log(ctx, "client=", ctx->client.peername);
}

// close_raw
// file ../common/spio.c line 79
static void close_raw(signed int *fd)
{
  shutdown(*fd, 2);
  close(*fd);
  *fd = -1;
}

// connection_loop
// file ../common/smtppass.c line 516
static void connection_loop(signed int sock)
{
  struct spthread *threads = (struct spthread *)(void *)0;
  signed int fd;
  signed int i;
  signed int x;
  signed int r;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)g_state.max_threads, sizeof(struct spthread) /*16ul*/ );
  threads = (struct spthread *)return_value_calloc$1;
  signed int return_value_sp_is_quit$2;
  _Bool tmp_if_expr$7;
  signed int return_value_setsockopt$6;
  if(threads == ((struct spthread *)NULL))
    sp_messagex((struct spctx *)(void *)0, 2, "out of memory");

  else
  {
    do
    {
      return_value_sp_is_quit$2=sp_is_quit();
      if(!(return_value_sp_is_quit$2 == 0))
        break;

      fd=accept(sock, (void *)0, (unsigned int *)(void *)0);
      if(fd == -1)
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        switch(*return_value___errno_location$3)
        {
          case 4:

          case 11:
            break;
          case 103:
          {
            sp_message((struct spctx *)(void *)0, 3, "couldn't accept a connection");
            break;
          }
          default:
            sp_message((struct spctx *)(void *)0, 3, "couldn't accept a connection");
        }
        signed int return_value_sp_is_quit$4;
        return_value_sp_is_quit$4=sp_is_quit();
        if(!(return_value_sp_is_quit$4 == 0))
          break;

        continue;
      }

      signed int return_value_setsockopt$5;
      return_value_setsockopt$5=setsockopt(fd, 1, 20, (const void *)&g_state.timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
      if(!(return_value_setsockopt$5 >= 0))
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        return_value_setsockopt$6=setsockopt(fd, 1, 21, (const void *)&g_state.timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
        tmp_if_expr$7 = return_value_setsockopt$6 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$7)
        sp_message((struct spctx *)(void *)0, 7, "couldn't set timeouts on incoming connection");

      signed int return_value_fcntl$8;
      return_value_fcntl$8=fcntl(fd, 1, 0);
      fcntl(fd, 2, return_value_fcntl$8 | 1);
      i = 0;
      for( ; !(i >= g_state.max_threads); i = i + 1)
      {
        if(!((threads + (signed long int)i)->tid == 0ul))
        {
          sp_lock();
          x = (threads + (signed long int)i)->fd;
          sp_unlock();
          if(x == -1)
          {
            sp_messagex((struct spctx *)(void *)0, 7, "cleaning up completed thread");
            pthread_join((threads + (signed long int)i)->tid, (void **)(void *)0);
            (threads + (signed long int)i)->tid = (unsigned long int)0;
          }

        }

        if(!(fd == -1))
        {
          if((threads + (signed long int)i)->tid == 0ul)
          {
            (threads + (signed long int)i)->fd = fd;
            r=pthread_create(&(threads + (signed long int)i)->tid, (const union pthread_attr_t *)(void *)0, thread_main, (void *)(threads + (signed long int)i));
            if(!(r == 0))
            {
              signed int *return_value___errno_location$9;
              return_value___errno_location$9=__errno_location();
              *return_value___errno_location$9 = r;
              sp_message((struct spctx *)(void *)0, 3, "couldn't create thread");
              write(fd, (const void *)"421 Local Error, cannot start thread\r\n", (sizeof(char [39l]) /*39ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ );
              shutdown(fd, 2);
              close(fd);
              fd = -1;
              break;
            }

            sp_messagex((struct spctx *)(void *)0, 7, "created thread for connection");
            fd = -1;
            break;
          }

        }

      }
      if(!(fd == -1))
      {
        sp_messagex((struct spctx *)(void *)0, 3, "too many connections open (max %d). sent busy response", g_state.max_threads);
        write(fd, (const void *)"421 Server busy, too many connections\r\n", (sizeof(char [40l]) /*40ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ );
        shutdown(fd, 2);
        close(fd);
        fd = -1;
      }

    }
    while((_Bool)1);
    sp_messagex((struct spctx *)(void *)0, 7, "waiting for threads to quit");
    i = 0;
    for( ; !(i >= g_state.max_threads); i = i + 1)
      if(!((threads + (signed long int)i)->tid == 0ul))
      {
        if(!((threads + (signed long int)i)->fd == -1))
        {
          sp_lock();
          fd = (threads + (signed long int)i)->fd;
          (threads + (signed long int)i)->fd = -1;
          sp_unlock();
          shutdown(fd, 2);
          close(fd);
        }

        sp_messagex((struct spctx *)(void *)0, 7, "cleaning up completed thread");
        pthread_join((threads + (signed long int)i)->tid, (void **)(void *)0);
        (threads + (signed long int)i)->tid = (unsigned long int)0;
      }

    free((void *)threads);
  }
}

// do_server_noop
// file ../common/smtppass.c line 1955
static void do_server_noop(struct spctx *ctx)
{
  if(!(ctx->server.fd == -1))
  {
    signed int return_value_spio_write_data$1;
    return_value_spio_write_data$1=spio_write_data(ctx, &ctx->server, "NOOP\r\n");
    if(!(return_value_spio_write_data$1 == -1))
      spio_read_line(ctx, &ctx->server, 0x00000002);

  }

}

// done_thread
// file ../common/smtppass.c line 730
static void done_thread(struct spctx *ctx)
{
  spio_disconnect(ctx, &ctx->client);
  spio_disconnect(ctx, &ctx->server);
  cleanup_context(ctx);
  cb_del_context(ctx);
}

// drop_privileges
// file ../common/smtppass.c line 413
static void drop_privileges()
{
  char *t;
  struct passwd *pw;
  unsigned int uid;
  struct _cap_struct *caps;
  signed int value;
  _Bool tmp_if_expr$6;
  signed int return_value_setresuid$5;
  _Bool tmp_if_expr$9;
  signed int return_value_cap_set_flag$8;
  _Bool tmp_if_expr$11;
  signed int return_value_cap_set_proc$10;
  if(!(g_state.user == ((const char *)NULL)))
  {
    unsigned int return_value_geteuid$1;
    return_value_geteuid$1=geteuid();
    if(!(return_value_geteuid$1 == 0u))
    {
      sp_messagex((struct spctx *)(void *)0, 4, "must be started as root to switch to user: %s", g_state.user);
      goto __CPROVER_DUMP_L18;
    }

    signed int return_value_prctl$2;
    return_value_prctl$2=prctl(8, 1);
    if(!(return_value_prctl$2 >= 0))
      sp_message((struct spctx *)(void *)0, 4, "couldn't keep capabilities when dropping privileges");

    signed long int return_value_strtol$3;
    return_value_strtol$3=strtol(g_state.user, &t, 10);
    uid = (unsigned int)return_value_strtol$3;
    if(*t == 0)
      pw=getpwuid(uid);

    else
      pw=getpwnam(g_state.user);
    if(pw == ((struct passwd *)NULL))
      errx(1, "couldn't look up user: %s", g_state.user);

    signed int return_value_setresgid$4;
    return_value_setresgid$4=setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid);
    if(return_value_setresgid$4 == -1)
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value_setresuid$5=setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid);
      tmp_if_expr$6 = return_value_setresuid$5 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
      err(1, "unable to switch to user: %s (uid %d, gid %d)", g_state.user, pw->pw_uid, pw->pw_gid);

    caps=cap_init();
    if(caps == ((struct _cap_struct *)NULL))
      err(1, "unable to init capabilities");

    value = 12;
    signed int return_value_cap_set_flag$7;
    return_value_cap_set_flag$7=cap_set_flag(caps, (enum anonymous$3)CAP_EFFECTIVE, 1, &value, (enum anonymous$4)CAP_SET);
    if(!(return_value_cap_set_flag$7 >= 0))
      tmp_if_expr$9 = (_Bool)1;

    else
    {
      return_value_cap_set_flag$8=cap_set_flag(caps, (enum anonymous$3)CAP_PERMITTED, 1, &value, (enum anonymous$4)CAP_SET);
      tmp_if_expr$9 = return_value_cap_set_flag$8 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$9)
      tmp_if_expr$11 = (_Bool)1;

    else
    {
      return_value_cap_set_proc$10=cap_set_proc(caps);
      tmp_if_expr$11 = return_value_cap_set_proc$10 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$11)
      err(1, "couldn't set capabilities when switching user");

    cap_free((void *)caps);
    signed int return_value_setreuid$12;
    return_value_setreuid$12=setreuid((unsigned int)-1, (unsigned int)0);
    if(return_value_setreuid$12 == 0)
      err(1, "unable to completely drop privileges");

    sp_messagex((struct spctx *)(void *)0, 7, "switched to user %s (uid %d, gid %d)", g_state.user, pw->pw_uid, pw->pw_gid);
  }

  unsigned int return_value_geteuid$13;
  return_value_geteuid$13=geteuid();
  if(return_value_geteuid$13 == 0u)
    sp_messagex((struct spctx *)(void *)0, 4, "running as root is NOT recommended");


__CPROVER_DUMP_L18:
  ;
}

// final_reject_message
// file proxsmtpd.c line 863
static void final_reject_message(char *buf, signed int buflen)
{
  if((signed int)*buf == 0)
    strlcpy(buf, "Content Rejected", (unsigned long int)buflen);

  else
    trim_end(buf);
}

// fork_filter
// file proxsmtpd.c line 365
static signed int fork_filter(struct spctx *sp, signed int *infd, signed int *outfd, signed int *errfd)
{
  signed int pid;
  signed int ret = 0;
  signed int r = 0;
  signed int pipe_i[2l];
  signed int pipe_o[2l];
  signed int pipe_e[2l];
  memset((void *)pipe_i, ~0, sizeof(signed int [2l]) /*8ul*/ );
  memset((void *)pipe_o, ~0, sizeof(signed int [2l]) /*8ul*/ );
  memset((void *)pipe_e, ~0, sizeof(signed int [2l]) /*8ul*/ );
  _Bool tmp_if_expr$2;
  signed int return_value_pipe$1;
  if(!(infd == ((signed int *)NULL)))
  {
    return_value_pipe$1=pipe(pipe_i);
    tmp_if_expr$2 = return_value_pipe$1 == -1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  signed int return_value_pipe$3;
  if(tmp_if_expr$2)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(!(outfd == ((signed int *)NULL)))
    {
      return_value_pipe$3=pipe(pipe_o);
      tmp_if_expr$4 = return_value_pipe$3 == -1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  signed int return_value_pipe$6;
  if(tmp_if_expr$5)
    tmp_if_expr$8 = (_Bool)1;

  else
  {
    if(!(errfd == ((signed int *)NULL)))
    {
      return_value_pipe$6=pipe(pipe_e);
      tmp_if_expr$7 = return_value_pipe$6 == -1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$7 = (_Bool)0;
    tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$8)
  {
    sp_message(sp, 3, "couldn't create pipe for filter command");
    ret = -1;
  }

  else
  {
    pid=fork();
    if(!(pid == -1))
    {
      if(pid == 0)
        goto __CPROVER_DUMP_L13;

    }

    else
    {
      sp_message(sp, 3, "couldn't fork for filter command");
      ret = -1;
      goto cleanup;

    __CPROVER_DUMP_L13:
      ;
      if(r >= 0 && !(infd == ((signed int *)NULL)))
      {
        close(pipe_i[(signed long int)1]);
        r=dup2(pipe_i[(signed long int)0], 0);
        close(pipe_i[(signed long int)0]);
      }

      if(r >= 0 && !(outfd == ((signed int *)NULL)))
      {
        close(pipe_o[(signed long int)0]);
        r=dup2(pipe_o[(signed long int)1], 1);
        close(pipe_o[(signed long int)1]);
      }

      if(r >= 0 && !(errfd == ((signed int *)NULL)))
      {
        close(pipe_e[(signed long int)0]);
        r=dup2(pipe_e[(signed long int)1], 2);
        close(pipe_e[(signed long int)1]);
      }

      if(!(r >= 0))
      {
        sp_message(sp, 3, "couldn't dup descriptors for filter command");
        kill_myself();
      }

      r = 3;
      for( ; !(r >= 1024); r = r + 1)
        close(r);
      sp_setup_forked(sp, 1);
      execl("/bin/sh", "sh", (const void *)"-c", g_pxstate.command, (void *)0);
      sp_message(sp, 3, "error executing the shell for filter command");
      kill_myself();
    }
    sp_messagex(sp, 7, "executed filter command: %s (pid: %d)", g_pxstate.command, (signed int)pid);
    if(!(infd == ((signed int *)NULL)))
    {
      *infd = pipe_i[(signed long int)1];
      pipe_i[(signed long int)1] = -1;
      signed int return_value_fcntl$9;
      return_value_fcntl$9=fcntl(*infd, 3, 0);
      fcntl(*infd, 4, return_value_fcntl$9 | 04000);
    }

    if(!(outfd == ((signed int *)NULL)))
    {
      *outfd = pipe_o[(signed long int)0];
      pipe_o[(signed long int)0] = -1;
      signed int return_value_fcntl$10;
      return_value_fcntl$10=fcntl(*outfd, 3, 0);
      fcntl(*outfd, 4, return_value_fcntl$10 | 04000);
    }

    if(!(errfd == ((signed int *)NULL)))
    {
      *errfd = pipe_e[(signed long int)0];
      pipe_e[(signed long int)0] = -1;
      signed int return_value_fcntl$11;
      return_value_fcntl$11=fcntl(*errfd, 3, 0);
      fcntl(*errfd, 4, return_value_fcntl$11 | 04000);
    }

  }

cleanup:
  ;
  if(!(pipe_i[0l] == -1))
    close(pipe_i[(signed long int)0]);

  if(!(pipe_i[1l] == -1))
    close(pipe_i[(signed long int)1]);

  if(!(pipe_o[0l] == -1))
    close(pipe_o[(signed long int)0]);

  if(!(pipe_o[1l] == -1))
    close(pipe_o[(signed long int)1]);

  if(!(pipe_e[0l] == -1))
    close(pipe_e[(signed long int)0]);

  if(!(pipe_e[1l] == -1))
    close(pipe_e[(signed long int)1]);

  return ret >= 0 ? pid : (signed int)-1;
}

// get_successful_rsp
// file ../common/smtppass.c line 1365
static const char * get_successful_rsp(const char *line, signed int *cont)
{
  line=trim_start(line);
  const unsigned short int **return_value___ctype_b_loc$3;
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$1;
  if((signed int)*line == 50)
  {
    return_value___ctype_b_loc$3=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)line[1l]]) == 0)
      goto __CPROVER_DUMP_L4;

    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)line[2l]]) == 0)
      goto __CPROVER_DUMP_L4;

    if((signed int)line[3l] == 32)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)line[(signed long int)3] == 45 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
      goto __CPROVER_DUMP_L4;

    if(!(cont == ((signed int *)NULL)))
      *cont = (signed int)((signed int)line[(signed long int)3] == 45);

    return line + (signed long int)4;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    return (const char *)(void *)0;
  }
}

// init_thread
// file ../common/smtppass.c line 651
static struct spctx * init_thread(signed int fd)
{
  struct spctx *ctx;
  ctx=cb_new_context();
  unsigned int tmp_post$1;
  if(!(ctx == ((struct spctx *)NULL)))
  {
    memset((void *)ctx, 0, sizeof(struct spctx) /*29832ul*/ );
    spio_init(&ctx->server, "SERVER");
    spio_init(&ctx->client, "CLIENT");
    sp_lock();
    tmp_post$1 = g_unique_id;
    g_unique_id = g_unique_id + 1u;
    ctx->id = tmp_post$1;
    if(g_unique_id == 0u)
      g_unique_id = g_unique_id + 1u;

    sp_unlock();
    unsigned long int return_value_pthread_self$2;
    return_value_pthread_self$2=pthread_self();
    sp_messagex(ctx, 7, "processing %d on thread %x", fd, (signed int)return_value_pthread_self$2);
    signed int return_value_make_connections$3;
    return_value_make_connections$3=make_connections(ctx, fd);
    if(return_value_make_connections$3 == -1)
    {
      cb_del_context(ctx);
      ctx = (struct spctx *)(void *)0;
    }

  }

  return ctx;
}

// is_blank_line
// file ../common/stringx.h line 45
signed int is_blank_line(const char *line)
{
  const unsigned short int **return_value___ctype_b_loc$1;
  if(*line == 0)
    return 1;

  else
  {
    for( ; !(*line == 0); line = line + 1l)
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*line]) == 0)
        break;

    }
    return (signed int)((signed int)*line == 0);
  }
}

// is_first_word
// file ../common/stringx.h line 43
signed int is_first_word(const char *line, const char *word, signed int len)
{
  const unsigned short int **return_value___ctype_b_loc$1;
  for( ; !(*line == 0); line = line + 1l)
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*line]) == 0)
      break;

  }
  signed int return_value_strncasecmp$2;
  return_value_strncasecmp$2=strncasecmp(line, word, (unsigned long int)len);
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  if(!(return_value_strncasecmp$2 == 0))
    return 0;

  else
  {
    line = line + (signed long int)len;
    if(*line == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      tmp_if_expr$4 = ((signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*line] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
    }
    return (signed int)tmp_if_expr$4;
  }
}

// is_last_word
// file ../common/stringx.c line 99
signed int is_last_word(const char *line, const char *word, signed int len)
{
  const char *t;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(line);
  t = line + (signed long int)return_value_strlen$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  for( ; !(line >= t); t = t - 1l)
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)t[-1l]]) == 0)
      break;

  }
  if(!(t + -((signed long int)len) >= line))
    return 0;

  else
  {
    signed int return_value_strncasecmp$3;
    return_value_strncasecmp$3=strncasecmp(t - (signed long int)len, word, (unsigned long int)len);
    return (signed int)(return_value_strncasecmp$3 == 0);
  }
}

// kill_myself
// file proxsmtpd.c line 357
static void kill_myself()
{
  while((_Bool)1)
  {
    signed int return_value_getpid$1;
    return_value_getpid$1=getpid();
    kill(return_value_getpid$1, 9);
    sleep((unsigned int)1);
  }
}

// kill_process
// file proxsmtpd.c line 955
static signed int kill_process(struct spctx *sp, signed int pid)
{
  signed int status;
  signed int return_value_kill$2;
  return_value_kill$2=kill(pid, 15);
  if(return_value_kill$2 == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 3)
      return 0;

    sp_message(sp, 3, "couldn't send signal to process");
    return -1;
  }

  signed int return_value_wait_process$5;
  return_value_wait_process$5=wait_process(sp, pid, &status);
  if(return_value_wait_process$5 == -1)
  {
    signed int return_value_kill$4;
    return_value_kill$4=kill(pid, 9);
    if(return_value_kill$4 == -1)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      if(*return_value___errno_location$3 == 3)
        return 0;

      sp_message(sp, 3, "couldn't send signal to process");
      return -1;
    }

    sp_messagex(sp, 3, "process wouldn't quit. forced termination");
  }

  return 0;
}

// log_io_data
// file ../common/spio.c line 87
static void log_io_data(struct spctx *ctx, struct spio *io, const char *data, signed int read)
{
  char buf[80l];
  signed int pos;
  signed int len;
  const char *tmp_if_expr$3;
  do
  {
    unsigned long int return_value_strspn$1;
    return_value_strspn$1=strspn(data, "\r\n");
    data = data + (signed long int)return_value_strspn$1;
    if(*data == 0)
      break;

    unsigned long int return_value_strcspn$2;
    return_value_strcspn$2=strcspn(data, "\r\n");
    pos = (signed int)return_value_strcspn$2;
    len = pos < 79 ? pos : 79;
    memcpy((void *)buf, (const void *)data, (unsigned long int)len);
    buf[(signed long int)len] = (char)0;
    if(!(io->name == ((const char *)NULL)))
      tmp_if_expr$3 = io->name;

    else
      tmp_if_expr$3 = "???   ";
    sp_messagex(ctx, 7, "%s%s%s", tmp_if_expr$3, read != 0 ? " < " : " > ", (const void *)buf);
    data = data + (signed long int)pos;
  }
  while((_Bool)1);
}

// main
// file proxsmtpd.c line 139
signed int main(signed int argc, char **argv)
{
  const char *configfile = "/etc/proxsmtpd.conf";
  const char *pidfile = (const char *)(void *)0;
  signed int dbg_level = -1;
  signed int ch = 0;
  signed int r;
  char *t;
  __argv = argv;
  memset((void *)&g_pxstate, 0, sizeof(struct pxstate) /*56ul*/ );
  g_pxstate.directory = "/tmp/";
  g_pxstate.filter_type = 1;
  g_pxstate.timeout.tv_sec = (signed long int)30;
  g_pxstate.reject = "530 Email Rejected";
  sp_init("proxsmtpd");
  signed long int return_value_strtol$1;
  do
  {
    ch=getopt(argc, argv, "d:f:p:v");
    if(ch == -1)
      break;

    switch(ch)
    {
      case 100:
      {
        return_value_strtol$1=strtol(optarg, &t, 10);
        dbg_level = (signed int)return_value_strtol$1;
        if(!(*t == 0))
          errx(1, "invalid debug log level");

        dbg_level = dbg_level + 3;
        break;
      }
      case 102:
      {
        configfile = optarg;
        break;
      }
      case 112:
      {
        pidfile = optarg;
        break;
      }
      case 118:
      {
        printf("proxsmtpd (version %s)\n", (const void *)"1.10");
        printf("          (config: %s)\n", (const void *)"/etc/proxsmtpd.conf");
        exit(0);
        break;
      }
      case 63:

      default:
        usage();
    }
  }
  while((_Bool)1);
  argc = argc - optind;
  argv = argv + (signed long int)optind;
  if(argc >= 1)
    usage();

  r=sp_run(configfile, pidfile, dbg_level);
  sp_done();
  return r;
}

// make_connections
// file ../common/smtppass.c line 793
static signed int make_connections(struct spctx *ctx, signed int client)
{
  struct sockaddr_any peeraddr;
  struct sockaddr_any peersrc;
  struct sockaddr_any addr;
  struct sockaddr_any *dstaddr;
  struct sockaddr_any *srcaddr;
  char buf[4096l];
  const char *dstname;
  const char *srcname;
  spio_attach(ctx, &ctx->client, client, &peeraddr);
  sp_messagex(ctx, 6, "accepted connection from: %s", (const void *)ctx->client.peername);
  dstaddr = &g_state.outaddr;
  dstname = g_state.outname;
  srcaddr = (struct sockaddr_any *)(void *)0;
  srcname = (const char *)(void *)0;
  if(!(g_state.transparent == 0))
  {
    memset((void *)&addr, 0, sizeof(struct sockaddr_any) /*224ul*/ );
    addr.namelen = (unsigned int)sizeof(struct sockaddr_any) /*224ul*/ ;
    signed int return_value_getsockopt$1;
    return_value_getsockopt$1=getsockopt(ctx->client.fd, 0, 80, (void *)&addr.s.a, &addr.namelen);
    if(return_value_getsockopt$1 == -1)
    {
      sp_message(ctx, 3, "couldn't get source address for transparent proxying");
      return -1;
    }

    signed int return_value_sock_any_cmp$2;
    return_value_sock_any_cmp$2=sock_any_cmp(&addr, &peeraddr, 0x01000000);
    if(return_value_sock_any_cmp$2 == 0)
    {
      sp_messagex(ctx, 3, "loop detected in transparent proxying");
      return -1;
    }

    dstaddr = &addr;
  }

  _Bool tmp_if_expr$4;
  if(g_state.transparent == 2)
  {
    sock_any_cpy(&peersrc, &peeraddr, 0x01000000);
    srcaddr = &peersrc;
    srcname = ctx->client.peername;
  }

  else
  {
    if((signed int)dstaddr->s.a.sa_family == 2)
      tmp_if_expr$4 = dstaddr->s.in.sin_addr.s_addr == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
    {
      memcpy((void *)&addr, (const void *)&g_state.outaddr, sizeof(struct sockaddr_any) /*224ul*/ );
      memcpy((void *)&addr.s.in.sin_addr, (const void *)&peeraddr.s.in.sin_addr, sizeof(struct in_addr) /*4ul*/ );
      dstaddr = &addr;
    }

    else
    {
      signed int return_value_sock_any_pton$3;
      return_value_sock_any_pton$3=sock_any_pton(g_state.outname, &addr, (signed int)(25 & 0xFFFF));
      if(!(return_value_sock_any_pton$3 == -1))
        memcpy((void *)&g_state.outaddr, (const void *)&addr, sizeof(struct sockaddr_any) /*224ul*/ );

      else
        sp_messagex(ctx, 4, "couldn't resolve OutAddress: %s", g_state.outname);
    }
  }
  if(!(dstaddr == &g_state.outaddr))
  {
    signed int return_value_sock_any_ntop$5;
    return_value_sock_any_ntop$5=sock_any_ntop(dstaddr, buf, (unsigned long int)4096, 0);
    if(!(return_value_sock_any_ntop$5 == -1))
      dstname = buf;

    else
      dstname = "unknown";
  }

  signed int return_value_spio_connect$6;
  return_value_spio_connect$6=spio_connect(ctx, &ctx->server, dstaddr, dstname, srcaddr, srcname);
  if(return_value_spio_connect$6 == -1)
    return -1;

  else
    return 0;
}

// make_date
// file ../common/smtppass.c line 1548
static void make_date(struct spctx *ctx, char *date)
{
  unsigned long int date_len;
  struct tm t2;
  signed long int t;
  signed long int return_value_time$1;
  return_value_time$1=time(&t);
  _Bool tmp_if_expr$3;
  struct tm *return_value_localtime_r$2;
  if(return_value_time$1 == -1l)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_localtime_r$2=localtime_r(&t, &t2);
    tmp_if_expr$3 = !(return_value_localtime_r$2 != ((struct tm *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  char *return_value_asctime_r$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_asctime_r$4=asctime_r(&t2, date);
    tmp_if_expr$5 = !(return_value_asctime_r$4 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    sp_message(ctx, 4, "unable to get date for header");
    date[(signed long int)0] = (char)0;
  }

  else
  {
    trim_end(date);
    date_len=strlen(date);
    signed long int timezone = t2.tm_gmtoff;
    const char *tzname[2l] = { t2.tm_zone, t2.tm_zone };
    snprintf(date + (signed long int)date_len, (unsigned long int)64 - date_len, " %+03d%02d (%s)", (signed int)(timezone / (signed long int)3600), (signed int)(timezone % (signed long int)3600), tzname[(signed long int)(t2.tm_isdst != 0 ? 1 : 0)]);
    date[(signed long int)(64 - 1)] = (char)0;
  }
}

// make_header
// file ../common/smtppass.c line 1613
static signed int make_header(struct spctx *ctx, const char *format_str, char *header)
{
  char date[64l];
  signed int remaining;
  signed int l;
  const char *f;
  char *p;
  date[(signed long int)0] = (char)0;
  remaining = 1024 - 1;
  p = header;
  f = format_str;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  unsigned long int return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  unsigned long int return_value_strlen$3;
  char *tmp_post$4;
  for( ; remaining >= 1 && !(*f == 0); f = f + 1l)
  {
    if((signed int)*f == 92)
      tmp_if_expr$6 = (signed int)f[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
    {
      f = f + 1l;
      switch((signed int)*f)
      {
        case 114:
        {
          *p = (char)13;
          break;
        }
        case 110:
        {
          *p = (char)10;
          break;
        }
        case 116:
        {
          *p = (char)9;
          break;
        }
        default:
          *p = *f;
      }
      p = p + 1l;
      remaining = remaining - 1;
    }

    else
    {
      if((signed int)*f == 37)
        tmp_if_expr$5 = (signed int)f[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
      {
        f = f + 1l;
        switch((signed int)*f)
        {
          case 105:
          {
            return_value_strlen$1=strlen(ctx->client.peername);
            l = (signed int)return_value_strlen$1;
            strncpy(p, ctx->client.peername, (unsigned long int)remaining);
            remaining = remaining - l;
            p = p + (signed long int)l;
            break;
          }
          case 108:
          {
            return_value_strlen$2=strlen(ctx->client.localname);
            l = (signed int)return_value_strlen$2;
            strncpy(p, ctx->client.localname, (unsigned long int)remaining);
            remaining = remaining - l;
            p = p + (signed long int)l;
            break;
          }
          case 100:
          {
            if((signed int)date[0l] == 0)
              make_date(ctx, date);

            return_value_strlen$3=strlen(date);
            l = (signed int)return_value_strlen$3;
            strncpy(p, date, (unsigned long int)remaining);
            remaining = remaining - l;
            p = p + (signed long int)l;
            break;
          }
          case 37:
          {
            *p = (char)37;
            p = p + 1l;
            break;
          }
          default:
            sp_messagex(ctx, 4, "invalid header symbol: %%%c", *f);
        }
      }

      else
      {
        tmp_post$4 = p;
        p = p + 1l;
        *tmp_post$4 = *f;
        remaining = remaining - 1;
      }
    }
  }
  if(!(p + 1l >= header + 1024l))
    p[(signed long int)1] = (char)0;

  header[(signed long int)(1024 - 1)] = (char)0;
  l = (signed int)(p - header);
  return l >= 1024 ? 1024 - 1 : l;
}

// on_quit
// file ../common/smtppass.c line 408
static void on_quit(signed int signal)
{
  g_state.quit = 1;
}

// parse_address
// file ../common/smtppass.c line 1305
static char * parse_address(char *line)
{
  char *t;
  line=trim_start(line);
  signed int return_value_strncmp$1;
  return_value_strncmp$1=strncmp(line, "<>", (unsigned long int)2);
  if(return_value_strncmp$1 == 0)
    return "<>";

  else
    if((signed int)*line == 60)
    {
      t=strchr(line, 62);
      if(t == ((char *)NULL))
        goto __CPROVER_DUMP_L2;

      *t = (char)0;
      line = line + 1l;
      return line;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      char *return_value_trim_end$2;
      return_value_trim_end$2=trim_end(line);
      return return_value_trim_end$2;
    }
}

// parse_config_file
// file ../common/smtppass.c line 2257
static signed int parse_config_file(const char *configfile)
{
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  signed long int len;
  char *p;
  char *t;
  char *n;
  f=fopen(configfile, "r");
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 2)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 == 20 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      return -1;

    else
      err(1, "couldn't open config file: %s", configfile);
  }

  signed int return_value_fseek$4;
  return_value_fseek$4=fseek(f, (signed long int)0, 2);
  _Bool tmp_if_expr$5;
  if(return_value_fseek$4 == -1)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    len=ftell(f);
    tmp_if_expr$5 = len == (signed long int)-1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_fseek$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_fseek$6=fseek(f, (signed long int)0, 0);
    tmp_if_expr$7 = return_value_fseek$6 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
    err(1, "couldn't seek config file: %s", configfile);

  void *return_value_malloc$8;
  return_value_malloc$8=malloc((unsigned long int)(len + (signed long int)2));
  g_state._p = (char *)return_value_malloc$8;
  if(g_state._p == ((char *)NULL))
    errx(1, "out of memory");

  unsigned long int return_value_fread$9;
  return_value_fread$9=fread((void *)g_state._p, (unsigned long int)1, (unsigned long int)len, f);
  if(!(return_value_fread$9 == (unsigned long int)len))
    err(1, "couldn't read config file: %s", configfile);

  fclose(f);
  sp_messagex((struct spctx *)(void *)0, 7, "read config file: %s", configfile);
  p = g_state._p;
  p[len] = (char)10;
  p[len + (signed long int)1] = (char)0;
  n = g_state._p;
  _Bool tmp_if_expr$10;
  do
  {
    t=strchr(n, 10);
    if(t == ((char *)NULL))
      break;

    *t = (char)0;
    p = n;
    n = t + (signed long int)1;
    p=trim_start(p);
    if((signed int)*p == 0)
      tmp_if_expr$10 = (_Bool)1;

    else
      tmp_if_expr$10 = (signed int)*p == 35 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$10)
    {
      t=strchr(p, 58);
      if(t == ((char *)NULL))
        errx(2, "invalid config line: %s", p);

      *t = (char)0;
      t = t + 1l;
      t=trim_space(t);
      p=trim_space(p);
      signed int return_value_sp_parse_option$11;
      return_value_sp_parse_option$11=sp_parse_option(p, t);
      if(return_value_sp_parse_option$11 == 0)
        errx(2, "invalid config line: %s", p);

      sp_messagex((struct spctx *)(void *)0, 7, "parsed option: %s: %s", p, t);
    }

  }
  while((_Bool)1);
  return 0;
}

// parse_xforward
// file ../common/smtppass.c line 1331
static char * parse_xforward(char *line, const char *part)
{
  char *t;
  char *e;
  t=strcasestr(line, part);
  if(t == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(part);
    t=trim_start(t + (signed long int)return_value_strlen$1);
    if(!((signed int)*t == 61))
      return (char *)(void *)0;

    else
    {
      t=trim_start(t + (signed long int)1);
      if(*t == 0)
        return (char *)(void *)0;

      else
      {
        if((signed int)*t == 91)
        {
          t = t + 1l;
          e=strchr(t, 93);
        }

        else
        {
          unsigned long int return_value_strcspn$2;
          return_value_strcspn$2=strcspn(t, " \t");
          e = t + (signed long int)return_value_strcspn$2;
        }
        if(e == ((char *)NULL))
          return (char *)(void *)0;

        else
        {
          *e = (char)0;
          return t;
        }
      }
    }
  }
}

// pid_file
// file ../common/smtppass.c line 483
static void pid_file(signed int write)
{
  if(!(g_state.pidfile == ((const char *)NULL)))
  {
    if(!(write == 0))
    {
      struct _IO_FILE *f;
      f=fopen(g_state.pidfile, "w");
      if(f == ((struct _IO_FILE *)NULL))
        sp_message((struct spctx *)(void *)0, 3, "couldn't open pid file: %s", g_state.pidfile);

      else
      {
        signed int return_value_getpid$1;
        return_value_getpid$1=getpid();
        fprintf(f, "%d\n", (signed int)return_value_getpid$1);
        signed int return_value_ferror$2;
        return_value_ferror$2=ferror(f);
        if(!(return_value_ferror$2 == 0))
          sp_message((struct spctx *)(void *)0, 3, "couldn't write to pid file: %s", g_state.pidfile);

        signed int return_value_fclose$3;
        return_value_fclose$3=fclose(f);
        if(return_value_fclose$3 == -1)
          sp_message((struct spctx *)(void *)0, 3, "couldn't write to pid file: %s", g_state.pidfile);

      }
      sp_messagex((struct spctx *)(void *)0, 7, "wrote pid file: %s", g_state.pidfile);
    }

    else
    {
      unlink(g_state.pidfile);
      sp_messagex((struct spctx *)(void *)0, 7, "removed pid file: %s", g_state.pidfile);
    }
  }

}

// process_file_command
// file proxsmtpd.c line 485
static signed int process_file_command(struct spctx *sp)
{
  signed int pid = 0;
  signed int ret = 0;
  signed int status;
  signed int r;
  struct timeval timeout;
  signed int errfd;
  struct anonymous$2 rmask;
  char obuf[1024l];
  char ebuf[256l];
  memset((void *)ebuf, 0, sizeof(char [256l]) /*256ul*/ );
  signed int return_value_sp_cache_data$1;
  return_value_sp_cache_data$1=sp_cache_data(sp);
  signed int *return_value___errno_location$3;
  signed int return_value_wait_process$6;
  if(return_value_sp_cache_data$1 == -1)
    ret = -1;

  else
  {
    pid=fork_filter(sp, (signed int *)(void *)0, (signed int *)(void *)0, &errfd);
    if(pid == -1)
      ret = -1;

    else
    {
      while(!(errfd == -1))
      {
        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$2) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rmask)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&rmask)->__fds_bits[(signed long int)(errfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rmask)->__fds_bits[(signed long int)(errfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << errfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        memcpy((void *)&timeout, (const void *)&g_pxstate.timeout, sizeof(struct timeval) /*16ul*/ );
        r=select(1024, &rmask, (struct anonymous$2 *)(void *)0, (struct anonymous$2 *)(void *)0, &timeout);
        if(!(r == -1))
        {
          if(r == 0)
            goto __CPROVER_DUMP_L5;

        }

        else
        {
          sp_message(sp, 3, "couldn't select while listening to filter command");
          ret = -1;
          goto cleanup;

        __CPROVER_DUMP_L5:
          ;
          sp_messagex(sp, 3, "timeout while listening to filter command");
          ret = -1;
          goto cleanup;
        }
        signed long int return_value_read$2;
        return_value_read$2=read(errfd, (void *)obuf, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
        r = (signed int)return_value_read$2;
        if(!(r >= 0))
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          if(!(*return_value___errno_location$4 == 4))
          {
            return_value___errno_location$3=__errno_location();
            if(!(*return_value___errno_location$3 == 11))
            {
              sp_message(sp, 3, "couldn't read data from filter command");
              ret = -1;
              goto cleanup;
            }

          }

          continue;
        }

        if(r == 0)
        {
          close(errfd);
          errfd = -1;
          break;
        }

        obuf[(signed long int)r] = (char)0;
        buffer_reject_message(obuf, ebuf, (signed int)sizeof(char [256l]) /*256ul*/ );
        signed int return_value_sp_is_quit$5;
        return_value_sp_is_quit$5=sp_is_quit();
        if(!(return_value_sp_is_quit$5 == 0))
        {
          ret = -1;
          goto cleanup;
        }

      }
      return_value_wait_process$6=wait_process(sp, pid, &status);
      if(return_value_wait_process$6 == -1)
      {
        sp_messagex(sp, 3, "timeout waiting for filter command to exit");
        ret = -1;
      }

      else
      {
        pid = 0;
        if(!((0x7f & status) == 0))
        {
          sp_messagex(sp, 3, "filter command terminated abnormally");
          ret = -1;
        }

        else
        {
          /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous$0
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
          ;
          sp_messagex(sp, 7, "filter exit code: %d", (signed int)((((union anonymous$0){ .__in=status }).__i & 0xff00) >> 8));
          if((0xff00 & status) >> 8 == 0)
          {
            signed int return_value_sp_done_data$7;
            return_value_sp_done_data$7=sp_done_data(sp, g_pxstate.header);
            if(return_value_sp_done_data$7 == -1)
            {
              ret = -1;
              goto cleanup;
            }

            sp_add_log(sp, "status=", "FILTERED");
          }

          else
          {
            final_reject_message(ebuf, (signed int)sizeof(char [256l]) /*256ul*/ );
            signed int return_value_sp_fail_data$8;
            return_value_sp_fail_data$8=sp_fail_data(sp, ebuf);
            if(return_value_sp_fail_data$8 == -1)
            {
              ret = -1;
              goto cleanup;
            }

            sp_add_log(sp, "status=", ebuf);
          }
          ret = 0;
        }
      }
    }
  }

cleanup:
  ;
  if(!(pid == 0))
  {
    sp_messagex(sp, 4, "killing filter process (pid %d)", (signed int)pid);
    kill_process(sp, pid);
  }

  if(!(errfd == -1))
    close(errfd);

  if(!(ret >= 0))
    sp_add_log(sp, "status=", "FILTER-ERROR");

  return ret;
}

// process_pipe_command
// file proxsmtpd.c line 616
static signed int process_pipe_command(struct spctx *sp)
{
  signed int pid;
  signed int ret = 0;
  signed int status;
  signed int r;
  struct timeval timeout;
  const char *ibuf = (const char *)(void *)0;
  signed int ilen = 0;
  signed int infd;
  signed int icount = 0;
  struct anonymous$2 wmask;
  signed int outfd;
  signed int errfd;
  struct anonymous$2 rmask;
  char obuf[1024l];
  char ebuf[256l];
  signed int ocount = 0;
  memset((void *)ebuf, 0, sizeof(char [256l]) /*256ul*/ );
  pid=fork_filter(sp, &infd, &outfd, &errfd);
  signed int return_value_sp_write_data$1;
  signed int return_value_sp_read_data$3;
  signed int *return_value___errno_location$5;
  signed int *return_value___errno_location$4;
  signed int *return_value___errno_location$9;
  signed int *return_value___errno_location$12;
  signed int return_value_sp_write_data$15;
  signed int return_value_wait_process$16;
  if(pid == -1)
    ret = -1;

  else
  {
    return_value_sp_write_data$1=sp_write_data(sp, obuf, 0);
    if(return_value_sp_write_data$1 == -1)
      ret = -1;

    else
    {
      while(!(errfd == -1) || !(infd == -1) || !(outfd == -1))
      {
        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$2) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rmask)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        do
        {
          signed int process_pipe_command$$1$$3$$2$$__d0;
          signed int process_pipe_command$$1$$3$$2$$__d1;
          asm("cld; rep; stosq" : "=c"(process_pipe_command$$1$$3$$2$$__d0), "=D"(process_pipe_command$$1$$3$$2$$__d1) : "a"(0), "0"(sizeof(struct anonymous$2) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wmask)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        if(!(infd == -1))
          (&wmask)->__fds_bits[(signed long int)(infd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wmask)->__fds_bits[(signed long int)(infd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << infd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

        if(!(outfd == -1))
          (&rmask)->__fds_bits[(signed long int)(outfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rmask)->__fds_bits[(signed long int)(outfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << outfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

        if(!(errfd == -1))
          (&rmask)->__fds_bits[(signed long int)(errfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rmask)->__fds_bits[(signed long int)(errfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << errfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

        memcpy((void *)&timeout, (const void *)&g_pxstate.timeout, sizeof(struct timeval) /*16ul*/ );
        r=select(1024, &rmask, &wmask, (struct anonymous$2 *)(void *)0, &timeout);
        if(!(r == -1))
        {
          if(r == 0)
            goto __CPROVER_DUMP_L9;

        }

        else
        {
          sp_message(sp, 3, "couldn't select while listening to filter command");
          ret = -1;
          goto cleanup;

        __CPROVER_DUMP_L9:
          ;
          sp_messagex(sp, 4, "timeout while listening to filter command");
          ret = -1;
          goto cleanup;
        }
        if(!(infd == -1))
        {
          if(!((wmask.__fds_bits[(signed long int)(infd / 8)] & (signed long int)(1UL << infd % 8)) == 0l))
          {
            if(!(ilen >= 1))
            {
              r=sp_read_data(sp, &ibuf);
              if(!(r == -1))
              {
                if(r == 0)
                  goto __CPROVER_DUMP_L12;

              }

              else
              {
                ret = -1;
                goto cleanup;

              __CPROVER_DUMP_L12:
                ;
                close(infd);
                infd = -1;
                goto __CPROVER_DUMP_L14;
              }
              ilen = r;
            }


          __CPROVER_DUMP_L14:
            ;
            if(ilen >= 1)
            {
              signed long int return_value_write$2;
              return_value_write$2=write(infd, (const void *)ibuf, (unsigned long int)ilen);
              r = (signed int)return_value_write$2;
              if(r == -1)
              {
                signed int *return_value___errno_location$6;
                return_value___errno_location$6=__errno_location();
                if(*return_value___errno_location$6 == 32)
                {
                  sp_messagex(sp, 6, "filter command closed input early");
                  do
                  {
                    return_value_sp_read_data$3=sp_read_data(sp, &ibuf);
                    if(!(return_value_sp_read_data$3 >= 1))
                      break;

                  }
                  while((_Bool)1);
                  close(infd);
                  infd = -1;
                }

                else
                {
                  return_value___errno_location$5=__errno_location();
                  if(!(*return_value___errno_location$5 == 11))
                  {
                    return_value___errno_location$4=__errno_location();
                    if(!(*return_value___errno_location$4 == 4))
                    {
                      sp_message(sp, 3, "couldn't write to filter command");
                      ret = -1;
                      goto cleanup;
                    }

                  }

                }
              }

              else
              {
                icount = icount + r;
                ilen = ilen - r;
                ibuf = ibuf + (signed long int)r;
              }
            }

          }

        }

        if(!(outfd == -1))
        {
          if(!((rmask.__fds_bits[(signed long int)(outfd / 8)] & (signed long int)(1UL << outfd % 8)) == 0l))
          {
            signed long int return_value_read$7;
            return_value_read$7=read(outfd, (void *)obuf, sizeof(char [1024l]) /*1024ul*/ );
            r = (signed int)return_value_read$7;
            if(r >= 1)
            {
              signed int return_value_sp_write_data$8;
              return_value_sp_write_data$8=sp_write_data(sp, obuf, r);
              if(return_value_sp_write_data$8 == -1)
              {
                ret = -1;
                goto cleanup;
              }

              ocount = ocount + r;
            }

            else
              if(r == 0)
              {
                close(outfd);
                outfd = -1;
              }

              else
                if(!(r >= 0))
                {
                  signed int *return_value___errno_location$10;
                  return_value___errno_location$10=__errno_location();
                  if(!(*return_value___errno_location$10 == 4))
                  {
                    return_value___errno_location$9=__errno_location();
                    if(!(*return_value___errno_location$9 == 11))
                    {
                      sp_message(sp, 3, "couldn't read data from filter command");
                      ret = -1;
                      goto cleanup;
                    }

                  }

                }

          }

        }

        if(!(errfd == -1))
        {
          if(!((rmask.__fds_bits[(signed long int)(errfd / 8)] & (signed long int)(1UL << errfd % 8)) == 0l))
          {
            signed long int return_value_read$11;
            return_value_read$11=read(errfd, (void *)obuf, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
            r = (signed int)return_value_read$11;
            if(!(r >= 0))
            {
              signed int *return_value___errno_location$13;
              return_value___errno_location$13=__errno_location();
              if(!(*return_value___errno_location$13 == 4))
              {
                return_value___errno_location$12=__errno_location();
                if(!(*return_value___errno_location$12 == 11))
                {
                  sp_message(sp, 3, "couldn't read data from filter command");
                  ret = -1;
                  goto cleanup;
                }

              }

            }

            else
              if(r == 0)
              {
                close(errfd);
                errfd = -1;
              }

              else
                if(r >= 1)
                {
                  obuf[(signed long int)r] = (char)0;
                  buffer_reject_message(obuf, ebuf, (signed int)sizeof(char [256l]) /*256ul*/ );
                }

          }

        }

        signed int return_value_sp_is_quit$14;
        return_value_sp_is_quit$14=sp_is_quit();
        if(!(return_value_sp_is_quit$14 == 0))
        {
          ret = -1;
          goto cleanup;
        }

      }
      sp_messagex(sp, 7, "wrote %d bytes to filter, read %d bytes", icount, ocount);
      return_value_sp_write_data$15=sp_write_data(sp, (const char *)(void *)0, 0);
      if(return_value_sp_write_data$15 == -1)
        ret = -1;

      else
      {
        return_value_wait_process$16=wait_process(sp, pid, &status);
        if(return_value_wait_process$16 == -1)
        {
          sp_messagex(sp, 3, "timeout waiting for filter command to exit");
          ret = -1;
        }

        else
        {
          pid = 0;
          if(!((0x7f & status) == 0))
          {
            sp_messagex(sp, 3, "filter command terminated abnormally");
            ret = -1;
          }

          else
          {
            /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous$0
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
            ;
            sp_messagex(sp, 7, "filter exit code: %d", (signed int)((((union anonymous$0){ .__in=status }).__i & 0xff00) >> 8));
            if((0xff00 & status) >> 8 == 0)
            {
              signed int return_value_sp_done_data$17;
              return_value_sp_done_data$17=sp_done_data(sp, g_pxstate.header);
              if(return_value_sp_done_data$17 == -1)
              {
                ret = -1;
                goto cleanup;
              }

              sp_add_log(sp, "status=", "FILTERED");
            }

            else
            {
              final_reject_message(ebuf, (signed int)sizeof(char [256l]) /*256ul*/ );
              signed int return_value_sp_fail_data$18;
              return_value_sp_fail_data$18=sp_fail_data(sp, ebuf);
              if(return_value_sp_fail_data$18 == -1)
              {
                ret = -1;
                goto cleanup;
              }

              sp_add_log(sp, "status=", ebuf);
            }
            ret = 0;
          }
        }
      }
    }
  }

cleanup:
  ;
  if(!(infd == -1))
    close(infd);

  if(!(outfd == -1))
    close(outfd);

  if(!(errfd == -1))
    close(errfd);

  if(!(pid == 0))
  {
    sp_messagex(sp, 4, "killing filter process (pid %d)", (signed int)pid);
    kill_process(sp, pid);
  }

  if(!(ret >= 0))
    sp_add_log(sp, "status=", "FILTER-ERROR");

  return ret;
}

// read_raw
// file ../common/spio.c line 342
signed int read_raw(struct spctx *ctx, struct spio *io, signed int opts)
{
  signed int len;
  signed int x;
  signed int count;
  char *at;
  char *p;
  count = 0;
  io->line[(signed long int)0] = (char)0;
  _Bool tmp_if_expr$2;
  if(!(io->_nx == ((char *)NULL)))
    tmp_if_expr$2 = io->_ln > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
  {
    void *return_value_memchr$1;
    return_value_memchr$1=memchr((const void *)io->_nx, 10, io->_ln);
    p = (char *)return_value_memchr$1;
    if(!(p == ((char *)NULL)))
    {
      x = (signed int)((p - io->_nx) + (signed long int)1);
      memmove((void *)io->line, (const void *)io->_nx, (unsigned long int)x);
      io->line[(signed long int)x] = (char)0;
      io->_ln = io->_ln - (unsigned long int)x;
      io->_nx = io->_nx + (signed long int)x;
      count = count + x;
      return count;
    }

    memmove((void *)io->line, (const void *)io->_nx, io->_ln);
    count = count + (signed int)io->_ln;
    len = (signed int)(((unsigned long int)(4096 + 128) - io->_ln) - (unsigned long int)1);
    at = io->line + (signed long int)io->_ln;
  }

  else
  {
    len = (4096 + 128) - 1;
    at = io->line;
  }
  const char *tmp_if_expr$6;
  signed int *return_value___errno_location$9;
  const char *tmp_if_expr$7;
  const char *tmp_if_expr$8;
  do
  {
    signed long int return_value_read$3;
    return_value_read$3=read(io->fd, (void *)at, sizeof(char) /*1ul*/  * (unsigned long int)len);
    x = (signed int)return_value_read$3;
    if(x == -1)
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      if(*return_value___errno_location$5 == 4)
      {
        signed int return_value_sp_is_quit$4;
        return_value_sp_is_quit$4=sp_is_quit();
        if(!(return_value_sp_is_quit$4 == 0))
          return -1;

        continue;
      }

      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      if(*return_value___errno_location$10 == 104)
      {
        if(!(io->name == ((const char *)NULL)))
          tmp_if_expr$6 = io->name;

        else
          tmp_if_expr$6 = "???   ";
        sp_messagex(ctx, 7, "%s: connection disconnected by peer", tmp_if_expr$6);
      }

      else
      {
        return_value___errno_location$9=__errno_location();
        if(*return_value___errno_location$9 == 11)
        {
          if(!(io->name == ((const char *)NULL)))
            tmp_if_expr$7 = io->name;

          else
            tmp_if_expr$7 = "???   ";
          sp_messagex(ctx, 4, "%s: network read operation timed out", tmp_if_expr$7);
        }

        else
        {
          if(!(io->name == ((const char *)NULL)))
            tmp_if_expr$8 = io->name;

          else
            tmp_if_expr$8 = "???   ";
          sp_message(ctx, 3, "%s: couldn't read data from socket", tmp_if_expr$8);
        }
      }
      close_raw(&io->fd);
      return -1;
    }

    else
      if(x == 0)
      {
        io->_nx = (char *)(void *)0;
        io->_ln = (unsigned long int)0;
        return count;
      }

    io->last_action=time((signed long int *)(void *)0);
    void *return_value_memchr$11;
    return_value_memchr$11=memchr((const void *)at, 10, (unsigned long int)x);
    p = (char *)return_value_memchr$11;
    if(!(p == ((char *)NULL)))
    {
      p = p + 1l;
      count = count + (signed int)(p - at);
      len = (signed int)((signed long int)x - (p - at));
      memmove((void *)(p + (signed long int)1), (const void *)p, (unsigned long int)len);
      *p = (char)0;
      io->_nx = p + (signed long int)1;
      io->_ln = (unsigned long int)len;
      return count;
    }

    at = at + (signed long int)x;
    len = len - x;
    count = count + x;
    if(!(len >= 1))
    {
      if(!((0x00000002 & opts) == 0))
      {
        at = (io->line + (signed long int)(4096 + 128)) - (signed long int)128;
        len = 128;
        continue;
      }

      io->_nx = (char *)(void *)0;
      io->_ln = (unsigned long int)0;
      io->line[(signed long int)(4096 + 128)] = (char)0;
      return count;
    }

  }
  while((_Bool)1);
}

// read_server_response
// file ../common/smtppass.c line 1932
static signed int read_server_response(struct spctx *ctx)
{
  signed int r;
  r=spio_read_line(ctx, &ctx->server, 0x00000002);
  if(r == -1)
    return -1;

  else
    if(r == 0)
    {
      sp_messagex(ctx, 3, "server disconnected unexpectedly");
      spio_write_data(ctx, &ctx->client, "451 Local Error\r\n");
      return 0;
    }

    else
    {
      if(r >= 128)
        sp_messagex(ctx, 4, "SMTP response line too long. discarded extra");

      return 0;
    }
}

// reallocf
// file ../common/compat.h line 58
void * reallocf(void *ptr, unsigned long int size)
{
  void *ret;
  ret=realloc(ptr, size);
  if(ret == NULL && !(size == 0ul))
    free(ptr);

  return ret;
}

// should_skip_processing
// file ../common/smtppass.c line 902
static signed int should_skip_processing(struct spctx *ctx)
{
  if(!(ctx->authenticated == 0))
  {
    if((1 & g_state.skip) == 0)
      goto __CPROVER_DUMP_L1;

    sp_messagex(ctx, 7, "skipping processing because client is authenticated");
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// smtp_passthru
// file ../common/smtppass.c line 912
static signed int smtp_passthru(struct spctx *ctx)
{
  char *t;
  const char *p;
  signed int r;
  signed int cont;
  signed int ret = 0;
  unsigned int mask;
  signed int neterror = 0;
  signed int first_rsp = 1;
  signed int filter_host = 0;
  signed int auth_started = 0;
  signed int xclient_sup = 0;
  signed int xclient_sent = 0;
  signed int return_value_sp_is_quit$1;
  signed int return_value_is_first_word$21;
  signed int return_value_is_first_word$20;
  signed int return_value_is_first_word$17;
  _Bool tmp_if_expr$19;
  signed int return_value_is_first_word$18;
  signed int return_value_is_first_word$16;
  signed int return_value_is_first_word$15;
  signed int return_value_check_first_word$12;
  _Bool tmp_if_expr$14;
  signed int return_value_check_first_word$13;
  _Bool tmp_if_expr$32;
  signed int return_value_is_first_word$31;
  _Bool tmp_if_expr$34;
  signed int return_value_is_first_word$33;
  _Bool tmp_if_expr$36;
  signed int return_value_is_first_word$35;
  _Bool tmp_if_expr$38;
  signed int return_value_is_first_word$37;
  _Bool tmp_if_expr$40;
  signed int return_value_is_first_word$39;
  _Bool tmp_if_expr$42;
  signed int return_value_is_first_word$41;
  unsigned long int tmp_if_expr$47;
  unsigned long int return_value_strlen$46;
  signed int return_value_is_first_word$56;
  signed int return_value_is_first_word$55;
  signed int return_value_is_first_word$54;
  do
  {
    return_value_sp_is_quit$1=sp_is_quit();
    if(!(return_value_sp_is_quit$1 == 0))
      break;

    mask=spio_select(ctx, &ctx->client, &ctx->server, (void *)0);
    if(mask == 4294967295u)
    {
      neterror = 1;
      ret = -1;
      break;
    }

    if(!((1u & mask) == 0u))
    {
      r=spio_read_line(ctx, &ctx->client, 0x00000002);
      if(r == -1)
      {
        ret = -1;
        break;
      }

      if(r == 0)
      {
        ret = 0;
        break;
      }

      if(r >= 128)
      {
        signed int return_value_spio_write_data$2;
        return_value_spio_write_data$2=spio_write_data(ctx, &ctx->client, "500 Line too long\r\n");
        if(return_value_spio_write_data$2 == -1)
        {
          ret = -1;
          break;
        }

        continue;
      }

      filter_host = 0;
      if(xclient_sent == 0 && !(g_state.xclient == 0) && !(xclient_sup == 0))
      {
        sp_messagex(ctx, 7, "sending XCLIENT");
        signed int return_value_spio_write_dataf$3;
        return_value_spio_write_dataf$3=spio_write_dataf(ctx, &ctx->server, "XCLIENT ADDR=%s\r\n", (const void *)ctx->client.peername);
        if(return_value_spio_write_dataf$3 == -1)
        {
          ret = -1;
          break;
        }

        signed int return_value_read_server_response$4;
        return_value_read_server_response$4=read_server_response(ctx);
        if(return_value_read_server_response$4 == -1)
        {
          ret = -1;
          break;
        }

        const char *return_value_get_successful_rsp$5;
        return_value_get_successful_rsp$5=get_successful_rsp(ctx->server.line, (signed int *)(void *)0);
        if(return_value_get_successful_rsp$5 == ((const char *)NULL))
          sp_messagex(ctx, 4, "server didn't accept XCLIENT");

        xclient_sent = 1;
      }

      signed int return_value_is_first_word$22;
      return_value_is_first_word$22=is_first_word(ctx->client.line, "DATA", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
      if(!(return_value_is_first_word$22 == 0))
      {
        signed int return_value_should_skip_processing$8;
        return_value_should_skip_processing$8=should_skip_processing(ctx);
        if(!(return_value_should_skip_processing$8 == 0))
        {
          signed int return_value_sp_pass_data$6;
          return_value_sp_pass_data$6=sp_pass_data(ctx);
          if(!(return_value_sp_pass_data$6 >= 0))
          {
            ret = -1;
            break;
          }

        }

        else
        {
          signed int return_value_cb_check_data$7;
          return_value_cb_check_data$7=cb_check_data(ctx);
          if(return_value_cb_check_data$7 == -1)
          {
            ret = -1;
            break;
          }

        }
        sp_messagex(ctx, 6, "%s", (const void *)ctx->logline);
        cleanup_context(ctx);
        continue;
      }

      else
      {
        return_value_is_first_word$21=is_first_word(ctx->client.line, "EHLO", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
        if(!(return_value_is_first_word$21 == 0))
          filter_host = 1;

        else
        {
          return_value_is_first_word$20=is_first_word(ctx->client.line, "HELO", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
          if(!(return_value_is_first_word$20 == 0))
          {
            sp_messagex(ctx, 7, "XCLIENT support assumed");
            xclient_sup = 1;
            filter_host = 1;
          }

          else
          {
            return_value_is_first_word$17=is_first_word(ctx->client.line, "STARTTLS", (signed int)((sizeof(char [9l]) /*9ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            if(!(return_value_is_first_word$17 == 0))
              tmp_if_expr$19 = (_Bool)1;

            else
            {
              return_value_is_first_word$18=is_first_word(ctx->client.line, "BDAT", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
              tmp_if_expr$19 = return_value_is_first_word$18 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$19)
            {
              sp_messagex(ctx, 7, "ESMTP feature not supported");
              signed int return_value_spio_write_data$9;
              return_value_spio_write_data$9=spio_write_data(ctx, &ctx->client, "502 Command not implemented\r\n");
              if(return_value_spio_write_data$9 == -1)
              {
                ret = -1;
                break;
              }

              continue;
            }

            else
            {
              return_value_is_first_word$16=is_first_word(ctx->client.line, "XCLIENT", (signed int)((sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
              if(!(return_value_is_first_word$16 == 0))
              {
                sp_messagex(ctx, 4, "client attempted use of privileged XCLIENT feature");
                signed int return_value_spio_write_data$10;
                return_value_spio_write_data$10=spio_write_data(ctx, &ctx->client, "554 Insufficient authorization\r\n");
                if(return_value_spio_write_data$10 == -1)
                {
                  ret = -1;
                  break;
                }

                continue;
              }

              else
              {
                return_value_is_first_word$15=is_first_word(ctx->client.line, "AUTH", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
                if(!(return_value_is_first_word$15 == 0))
                  auth_started = 1;

                else
                {
                  return_value_check_first_word$12=check_first_word(ctx->client.line, "MAIL FROM", (signed int)((sizeof(char [10l]) /*10ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ), "\r\n\t :");
                  if(return_value_check_first_word$12 >= 1)
                    tmp_if_expr$14 = (_Bool)1;

                  else
                  {
                    return_value_check_first_word$13=check_first_word(ctx->client.line, "RCPT TO", (signed int)((sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ), "\r\n\t :");
                    tmp_if_expr$14 = return_value_check_first_word$13 > 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$14)
                  {
                    signed int return_value_should_skip_processing$11;
                    return_value_should_skip_processing$11=should_skip_processing(ctx);
                    if(return_value_should_skip_processing$11 == 0)
                    {
                      r=cb_check_pre(ctx);
                      if(!(r >= 0))
                      {
                        ret = -1;
                        break;
                      }

                      else
                        if(r == 0)
                        {
                          cleanup_context(ctx);
                          continue;
                        }

                    }

                  }

                }
              }
            }
          }
        }
      }
      signed int return_value_spio_write_data$23;
      return_value_spio_write_data$23=spio_write_data(ctx, &ctx->server, ctx->client.line);
      if(return_value_spio_write_data$23 == -1)
      {
        ret = -1;
        break;
      }

      continue;
    }

    if(!((2u & mask) == 0u))
    {
      r=spio_read_line(ctx, &ctx->server, 0x00000002);
      if(r == -1)
      {
        ret = -1;
        break;
      }

      if(r == 0)
      {
        ret = 0;
        break;
      }

      if(r >= 128)
        sp_messagex(ctx, 4, "SMTP response line too long. discarded extra");

      if(!(first_rsp == 0))
      {
        first_rsp = 0;
        signed int return_value_is_first_word$25;
        return_value_is_first_word$25=is_first_word(ctx->server.line, "220", (signed int)((sizeof(char [4l]) /*4ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
        if(!(return_value_is_first_word$25 == 0))
        {
          sp_messagex(ctx, 7, "intercepting initial response");
          signed int return_value_spio_write_data$24;
          return_value_spio_write_data$24=spio_write_data(ctx, &ctx->client, "220 smtp.passthru\r\n");
          if(return_value_spio_write_data$24 == -1)
          {
            ret = -1;
            break;
          }

          continue;
        }

      }

      p=get_successful_rsp(ctx->server.line, &cont);
      if(!(p == ((const char *)NULL)))
      {
        if(!(filter_host == 0))
        {
          filter_host = 0;
          sp_messagex(ctx, 7, "intercepting host response");
          signed int return_value_spio_write_data$26;
          return_value_spio_write_data$26=spio_write_data(ctx, &ctx->client, cont != 0 ? "250-smtp.passthru\r\n" : "250 smtp.passthru\r\n");
          if(return_value_spio_write_data$26 == -1)
          {
            ret = -1;
            break;
          }

          cleanup_context(ctx);
          continue;
        }

        signed int return_value_is_first_word$43;
        return_value_is_first_word$43=is_first_word(ctx->client.line, "EHLO", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
        if(!(return_value_is_first_word$43 == 0))
        {
          signed int return_value_is_first_word$27;
          return_value_is_first_word$27=is_first_word(p, "XCLIENT", (signed int)((sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
          if(!(return_value_is_first_word$27 == 0))
          {
            sp_messagex(ctx, 7, "XCLIENT supported");
            xclient_sup = 1;
          }

          signed int return_value_is_first_word$30;
          return_value_is_first_word$30=is_first_word(p, "PIPELINING", (signed int)((sizeof(char [11l]) /*11ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
          if(!(return_value_is_first_word$30 == 0))
            tmp_if_expr$32 = (_Bool)1;

          else
          {
            return_value_is_first_word$31=is_first_word(p, "STARTTLS", (signed int)((sizeof(char [9l]) /*9ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            tmp_if_expr$32 = return_value_is_first_word$31 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$32)
            tmp_if_expr$34 = (_Bool)1;

          else
          {
            return_value_is_first_word$33=is_first_word(p, "CHUNKING", (signed int)((sizeof(char [9l]) /*9ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            tmp_if_expr$34 = return_value_is_first_word$33 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$34)
            tmp_if_expr$36 = (_Bool)1;

          else
          {
            return_value_is_first_word$35=is_first_word(p, "BINARYMIME", (signed int)((sizeof(char [11l]) /*11ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            tmp_if_expr$36 = return_value_is_first_word$35 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$36)
            tmp_if_expr$38 = (_Bool)1;

          else
          {
            return_value_is_first_word$37=is_first_word(p, "CHECKPOINT", (signed int)((sizeof(char [11l]) /*11ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            tmp_if_expr$38 = return_value_is_first_word$37 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$38)
            tmp_if_expr$40 = (_Bool)1;

          else
          {
            return_value_is_first_word$39=is_first_word(p, "XCLIENT", (signed int)((sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            tmp_if_expr$40 = return_value_is_first_word$39 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$40)
            tmp_if_expr$42 = (_Bool)1;

          else
          {
            return_value_is_first_word$41=is_first_word(p, "XEXCH50", (signed int)((sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            tmp_if_expr$42 = return_value_is_first_word$41 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$42)
          {
            char *return_value_trim_space$28;
            return_value_trim_space$28=trim_space((char *)p);
            sp_messagex(ctx, 7, "filtered ESMTP feature: %s", return_value_trim_space$28);
            if(cont == 0)
            {
              signed int return_value_spio_write_data$29;
              return_value_spio_write_data$29=spio_write_data(ctx, &ctx->client, "250 XFILTERED\r\n");
              if(return_value_spio_write_data$29 == -1)
              {
                ret = -1;
                break;
              }

            }

            continue;
          }

        }

        r=check_first_word(ctx->client.line, "MAIL FROM", (signed int)((sizeof(char [10l]) /*10ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ), "\r\n\t :");
        if(r >= 1)
        {
          t=parse_address(ctx->client.line + (signed long int)r);
          sp_add_log(ctx, "from=", t);
          unsigned long int return_value_strlen$44;
          return_value_strlen$44=strlen(t);
          void *return_value_reallocf$45;
          return_value_reallocf$45=reallocf((void *)ctx->sender, return_value_strlen$44 + (unsigned long int)1);
          ctx->sender = (char *)return_value_reallocf$45;
          if(!(ctx->sender == ((char *)NULL)))
            strcpy(ctx->sender, t);

        }

        else
        {
          r=check_first_word(ctx->client.line, "RCPT TO", (signed int)((sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ), "\r\n\t :");
          if(r >= 1)
          {
            t=parse_address(ctx->client.line + (signed long int)r);
            sp_add_log(ctx, "to=", t);
            if(!(ctx->recipients == ((char *)NULL)))
            {
              return_value_strlen$46=strlen(ctx->recipients);
              tmp_if_expr$47 = return_value_strlen$46;
            }

            else
              tmp_if_expr$47 = (unsigned long int)0;
            r = (signed int)tmp_if_expr$47;
            unsigned long int return_value_strlen$48;
            return_value_strlen$48=strlen(t);
            void *return_value_reallocf$49;
            return_value_reallocf$49=reallocf((void *)ctx->recipients, (unsigned long int)r + return_value_strlen$48 + (unsigned long int)2);
            ctx->recipients = (char *)return_value_reallocf$49;
            if(!(ctx->recipients == ((char *)NULL)))
            {
              if(!(r == 0))
                strcat(ctx->recipients, "\n");

              else
                ctx->recipients[(signed long int)0] = (char)0;
              strcat(ctx->recipients, t);
            }

          }

          else
          {
            return_value_is_first_word$56=is_first_word(ctx->client.line, "XFORWARD", (signed int)((sizeof(char [9l]) /*9ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            if(!(return_value_is_first_word$56 == 0))
            {
              t=parse_xforward(ctx->client.line + (signed long int)((sizeof(char [9l]) /*9ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ), "ADDR");
              if(!(t == ((char *)NULL)))
              {
                unsigned long int return_value_strlen$50;
                return_value_strlen$50=strlen(t);
                void *return_value_reallocf$51;
                return_value_reallocf$51=reallocf((void *)ctx->xforwardaddr, return_value_strlen$50 + (unsigned long int)1);
                ctx->xforwardaddr = (char *)return_value_reallocf$51;
                if(!(ctx->xforwardaddr == ((char *)NULL)))
                  strcpy(ctx->xforwardaddr, t);

              }

              t=parse_xforward(ctx->client.line + (signed long int)((sizeof(char [9l]) /*9ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ), "HELO");
              if(!(t == ((char *)NULL)))
              {
                unsigned long int return_value_strlen$52;
                return_value_strlen$52=strlen(t);
                void *return_value_reallocf$53;
                return_value_reallocf$53=reallocf((void *)ctx->xforwardhelo, return_value_strlen$52 + (unsigned long int)1);
                ctx->xforwardhelo = (char *)return_value_reallocf$53;
                if(!(ctx->xforwardhelo == ((char *)NULL)))
                  strcpy(ctx->xforwardhelo, t);

              }

            }

            else
            {
              return_value_is_first_word$55=is_first_word(ctx->client.line, "RSET", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
              if(!(return_value_is_first_word$55 == 0))
                cleanup_context(ctx);

              else
              {
                return_value_is_first_word$54=is_first_word(ctx->server.line, "235", (signed int)((sizeof(char [4l]) /*4ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
                if(!(return_value_is_first_word$54 == 0))
                {
                  if(!(auth_started == 0))
                  {
                    sp_messagex(ctx, 7, "Client authenticated successfully");
                    ctx->authenticated = 1;
                  }

                  else
                    sp_messagex(ctx, 4, "Authentication success code without AUTH");
                }

              }
            }
          }
        }
      }

      signed int return_value_spio_write_data$57;
      return_value_spio_write_data$57=spio_write_data(ctx, &ctx->client, ctx->server.line);
      if(return_value_spio_write_data$57 == -1)
      {
        ret = -1;
        break;
      }

    }

  }
  while((_Bool)1);

cleanup:
  ;
  if(neterror == 0 && ret == -1)
  {
    if(!(ctx->client.fd == -1))
      spio_write_data(ctx, &ctx->client, "451 Local Error\r\n");

  }

  return ret;
}

// sock_any_cmp
// file ../common/sock_any.h line 88
signed int sock_any_cmp(struct sockaddr_any *a1, struct sockaddr_any *a2, signed int opts)
{
  signed int return_value_strcmp$1;
  signed int return_value_memcmp$2;
  signed int *return_value___errno_location$3;
  if(!(a1->s.a.sa_family == a2->s.a.sa_family))
    return -1;

  else
    switch((signed int)a1->s.a.sa_family)
    {
      case 1:
      {
        return_value_strcmp$1=strcmp(a1->s.un.sun_path, a2->s.un.sun_path);
        return return_value_strcmp$1;
      }
      case 2:
      {
        return_value_memcmp$2=memcmp((const void *)&a1->s.in.sin_addr, (const void *)&a2->s.in.sin_addr, sizeof(struct in_addr) /*4ul*/ );
        if(!(return_value_memcmp$2 == 0))
          return -1;

        if((0x01000000 & opts) == 0)
        {
          if(!(a1->s.in.sin_port == a2->s.in.sin_port))
            return -1;

        }

        return 0;
      }
      default:
      {
        return_value___errno_location$3=__errno_location();
        *return_value___errno_location$3 = 97;
        return -1;
      }
    }
}

// sock_any_cpy
// file ../common/sock_any.h line 90
void sock_any_cpy(struct sockaddr_any *dst, struct sockaddr_any *src, signed int opts)
{
  memcpy((void *)dst, (const void *)src, sizeof(struct sockaddr_any) /*224ul*/ );
  if((signed int)src->s.a.sa_family == 2)
  {
    if(!((0x01000000 & opts) == 0))
      dst->s.in.sin_port = (unsigned short int)0;

  }

}

// sock_any_ntop
// file ../common/sock_any.h line 83
signed int sock_any_ntop(struct sockaddr_any *any, char *addr, unsigned long int addrlen, signed int opts)
{
  signed int len = 0;
  signed int port = 0;
  unsigned long int return_value_strlen$1;
  const char *return_value_inet_ntop$3;
  unsigned short int return_value_ntohs$4;
  signed int *return_value___errno_location$5;
  switch((signed int)any->s.a.sa_family)
  {
    case 1:
    {
      return_value_strlen$1=strlen(any->s.un.sun_path);
      len = (signed int)return_value_strlen$1;
      if(!(addrlen >= (unsigned long int)(1 + len)))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        *return_value___errno_location$2 = 28;
        return -1;
      }

      strcpy(addr, any->s.un.sun_path);
      break;
    }
    case 2:
    {
      return_value_inet_ntop$3=inet_ntop((signed int)any->s.a.sa_family, (const void *)&any->s.in.sin_addr, addr, (unsigned int)addrlen);
      if(return_value_inet_ntop$3 == ((const char *)NULL))
        return -1;

      return_value_ntohs$4=ntohs(any->s.in.sin_port);
      port = (signed int)return_value_ntohs$4;
      break;
    }
    default:
    {
      return_value___errno_location$5=__errno_location();
      *return_value___errno_location$5 = 97;
      return -1;
    }
  }
  if((0x01000000 & opts) == 0 && !(port == 0))
  {
    strncat(addr, ":", addrlen);
    addr[(signed long int)(addrlen - (unsigned long int)1)] = (char)0;
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(addr);
    len = (signed int)return_value_strlen$6;
    addr = addr + (signed long int)len;
    addrlen = addrlen - (unsigned long int)len;
    snprintf(addr, addrlen, "%d", port);
  }

  return 0;
}

// sock_any_pton
// file ../common/sock_any.h line 67
signed int sock_any_pton(const char *addr, struct sockaddr_any *any, signed int opts)
{
  unsigned long int l;
  char buf[256l];
  char *t;
  char *t2;
  signed int defport = opts & 0xFFFF;
  memset((void *)any, 0, sizeof(struct sockaddr_any) /*224ul*/ );
  signed int sock_any_pton$$1$$1$$port = 0;
  l=strspn(addr, "0123456789");
  _Bool tmp_if_expr$1;
  if(l >= 6ul || !(l >= 1ul))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)addr[(signed long int)l] != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {
    signed long int return_value_strtol$2;
    return_value_strtol$2=strtol(addr, &t2, 10);
    sock_any_pton$$1$$1$$port = (signed int)return_value_strtol$2;
    if(!(sock_any_pton$$1$$1$$port >= 65536) && *t2 == 0 && sock_any_pton$$1$$1$$port >= 1)
    {
      any->s.in.sin_port=htons((unsigned short int)sock_any_pton$$1$$1$$port);
      any->s.in.sin_family = (unsigned short int)2;
      if(!((0x00100000 & opts) == 0))
        any->s.in.sin_addr.s_addr=htonl((unsigned int)0x7f000001);

      any->namelen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
      return 2;
    }

  }

  signed int sock_any_pton$$1$$2$$port = 0;
  t = (char *)(void *)0;
  l=strlen(addr);
  if(!(l >= 22ul) && l >= 3ul)
  {
    strcpy(buf, addr);
    l=strspn(buf, "0123456789.");
    if(l >= 3ul)
    {
      if(!((signed int)buf[(signed long int)l] == 0))
      {
        if((signed int)buf[(signed long int)l] == 58)
          goto __CPROVER_DUMP_L10;

      }

      else
      {

      __CPROVER_DUMP_L10:
        ;
        if(!((signed int)buf[(signed long int)l] == 0))
        {
          t = buf + (signed long int)l + (signed long int)1;
          buf[(signed long int)l] = (char)0;
        }

        if(!(t == ((char *)NULL)))
        {
          signed long int return_value_strtol$3;
          return_value_strtol$3=strtol(t, &t2, 10);
          sock_any_pton$$1$$2$$port = (signed int)return_value_strtol$3;
          if(sock_any_pton$$1$$2$$port >= 65536 || !(*t2 == 0) || !(sock_any_pton$$1$$2$$port >= 1))
            goto __CPROVER_DUMP_L15;

        }

        any->s.in.sin_family = (unsigned short int)2;
        any->s.in.sin_port=htons((unsigned short int)(sock_any_pton$$1$$2$$port <= 0 ? defport : sock_any_pton$$1$$2$$port));
        signed int return_value_inet_pton$4;
        return_value_inet_pton$4=inet_pton(2, buf, (void *)&any->s.in.sin_addr);
        if(return_value_inet_pton$4 >= 1)
        {
          any->namelen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
          return 2;
        }

      }
    }

  }


__CPROVER_DUMP_L15:
  ;
  char *return_value_strchr$5;
  return_value_strchr$5=strchr(addr, 58);
  _Bool tmp_if_expr$7;
  char *return_value_strchr$6;
  if(!(return_value_strchr$5 == ((char *)NULL)))
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_strchr$6=strchr(addr, 47);
    tmp_if_expr$7 = !(return_value_strchr$6 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr$7)
  {
    l=strlen(addr);
    if(!(l >= sizeof(char [108l]) /*108ul*/ ))
    {
      any->s.un.sun_family = (unsigned short int)1;
      strcpy(any->s.un.sun_path, addr);
      any->namelen = (unsigned int)(sizeof(struct sockaddr_un) /*110ul*/  - (sizeof(char [108l]) /*108ul*/  - l));
      return 1;
    }

  }

  struct addrinfo *res;
  signed int port = 0;
  t = (char *)(void *)0;
  l=strlen(addr);
  _Bool tmp_if_expr$9;
  const unsigned short int **return_value___ctype_b_loc$8;
  if(l >= 255ul)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value___ctype_b_loc$8=__ctype_b_loc();
    tmp_if_expr$9 = !(((signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)addr[(signed long int)0]] & (signed int)(unsigned short int)1024) != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr$9)
  {
    unsigned long int return_value_strcspn$10;
    return_value_strcspn$10=strcspn(addr, " /\\");
    if(return_value_strcspn$10 == l)
    {
      strcpy(buf, addr);
      t=strchr(buf, 58);
      if(!(t == ((char *)NULL)))
      {
        *t = (char)0;
        t = t + 1l;
      }

      if(!(t == ((char *)NULL)))
      {
        signed long int return_value_strtol$11;
        return_value_strtol$11=strtol(t, &t2, 10);
        port = (signed int)return_value_strtol$11;
        if(port >= 65536 || !(*t2 == 0) || !(port >= 1))
          goto __CPROVER_DUMP_L30;

      }

      signed int return_value_getaddrinfo$12;
      return_value_getaddrinfo$12=getaddrinfo(buf, (const char *)(void *)0, (struct addrinfo *)(void *)0, &res);
      if(!(res == ((struct addrinfo *)NULL)) && return_value_getaddrinfo$12 == 0)
      {
        memcpy((void *)&any->s.a, (const void *)res->ai_addr, sizeof(struct sockaddr) /*16ul*/ );
        any->namelen = res->ai_addrlen;
        freeaddrinfo(res);
        unsigned short int return_value_htons$13;
        return_value_htons$13=htons((unsigned short int)(port <= 0 ? defport : port));
        port = (signed int)return_value_htons$13;
        if((signed int)any->s.a.sa_family == 2)
          any->s.in.sin_port = (unsigned short int)port;

        return (signed int)any->s.a.sa_family;
      }

    }

  }


__CPROVER_DUMP_L30:
  ;
  return -1;
}

// sp_add_log
// file ../common/smtppass.h line 191
void sp_add_log(struct spctx *ctx, char *prefix, char *line)
{
  char *t = ctx->logline;
  signed int l;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  l = (signed int)return_value_strlen$1;
  signed int x;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(prefix);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(line);
  x = (signed int)((unsigned long int)2 + return_value_strlen$2 + return_value_strlen$3 + (unsigned long int)1);
  if(l + x >= 768)
    l = 768 - x;

  t = t + (signed long int)l;
  l = 768 - l;
  *t = (char)0;
  if(!((signed int)ctx->logline[0l] == 0))
    strlcat(t, ", ", (unsigned long int)l);

  strlcat(t, prefix, (unsigned long int)l);
  line=trim_start(line);
  strlcat(t, line, (unsigned long int)l);
  trim_end(t);
}

// sp_cache_data
// file ../common/smtppass.h line 220
signed int sp_cache_data(struct spctx *ctx)
{
  signed int r;
  signed int count = 0;
  const char *data;
  do
  {
    r=sp_read_data(ctx, &data);
    if(r == 0)
      break;

    if(!(r >= 0))
      return -1;

    count = count + r;
    r=sp_write_data(ctx, data, r);
    if(!(r >= 0))
      return -1;

  }
  while((_Bool)1);
  signed int return_value_sp_write_data$1;
  return_value_sp_write_data$1=sp_write_data(ctx, (const char *)(void *)0, 0);
  if(!(return_value_sp_write_data$1 >= 0))
    return -1;

  else
  {
    sp_messagex(ctx, 7, "wrote %d bytes to cache", count);
    return count;
  }
}

// sp_done
// file ../common/smtppass.h line 171
void sp_done()
{
  pthread_mutex_destroy(&g_mutex);
  pthread_mutexattr_destroy(&g_mtxattr);
  if(!(g_state._p == ((char *)NULL)))
    free((void *)g_state._p);

  memset((void *)&g_state, 0, sizeof(struct spstate) /*784ul*/ );
}

// sp_done_data
// file ../common/smtppass.h line 226
signed int sp_done_data(struct spctx *ctx, const char *headertmpl)
{
  struct _IO_FILE *file = ((struct _IO_FILE *)NULL);
  signed int ret = 0;
  char *line;
  char header[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  unsigned long int header_len;
  unsigned long int line_len;
  signed int header_prepend = 0;
  signed long int rc;
  memset((void *)header, 0, sizeof(char [1024l]) /*1024ul*/ );
  line_len = (unsigned long int)(4096 + 128);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(line_len);
  line = (char *)return_value_malloc$1;
  signed int return_value_spio_write_data$2;
  signed int return_value_read_server_response$3;
  signed int return_value_is_first_word$5;
  _Bool tmp_if_expr$10;
  signed int return_value_spio_write_data_raw$9;
  _Bool tmp_if_expr$14;
  signed int return_value_spio_write_data_raw$13;
  signed int return_value_ferror$17;
  signed int return_value_ferror$18;
  _Bool tmp_if_expr$20;
  signed int return_value_spio_write_data$19;
  signed int return_value_read_server_response$21;
  signed int return_value_spio_write_data$22;
  if(line == ((char *)NULL))
    ret = -1;

  else
  {
    file=fopen(ctx->cachename, "r");
    if(file == ((struct _IO_FILE *)NULL))
    {
      sp_message(ctx, 3, "couldn't open cache file: %s", (const void *)ctx->cachename);
      ret = -1;
    }

    else
    {
      return_value_spio_write_data$2=spio_write_data(ctx, &ctx->server, "DATA\r\n");
      if(return_value_spio_write_data$2 == -1)
        ret = -1;

      else
      {
        return_value_read_server_response$3=read_server_response(ctx);
        if(return_value_read_server_response$3 == -1)
          ret = -1;

        else
        {
          return_value_is_first_word$5=is_first_word(ctx->server.line, "354", (signed int)((sizeof(char [4l]) /*4ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
          if(return_value_is_first_word$5 == 0)
          {
            signed int return_value_spio_write_data$4;
            return_value_spio_write_data$4=spio_write_data(ctx, &ctx->client, ctx->server.line);
            if(return_value_spio_write_data$4 == -1)
            {
              ret = -1;
              goto cleanup;
            }

            sp_messagex(ctx, 7, "server refused data transfer");
            ret = 0;
            goto cleanup;
          }

          sp_messagex(ctx, 7, "sending from cache file: %s", (const void *)ctx->cachename);
          if(!(headertmpl == ((const char *)NULL)))
          {
            signed int return_value_make_header$6;
            return_value_make_header$6=make_header(ctx, headertmpl, header);
            header_len = (unsigned long int)return_value_make_header$6;
            signed int return_value_is_first_word$7;
            return_value_is_first_word$7=is_first_word("Received:", header, (signed int)((sizeof(char [10l]) /*10ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            if(!(return_value_is_first_word$7 == 0))
              header_prepend = 1;

          }

          if(!((signed int)header[0l] == 0))
          {
            if(!(header_prepend == 0))
            {
              signed int return_value_spio_write_data_raw$8;
              return_value_spio_write_data_raw$8=spio_write_data_raw(ctx, &ctx->server, (unsigned char *)header, (signed int)header_len);
              if(return_value_spio_write_data_raw$8 == -1)
                tmp_if_expr$10 = (_Bool)1;

              else
              {
                return_value_spio_write_data_raw$9=spio_write_data_raw(ctx, &ctx->server, (unsigned char *)"\r\n", (signed int)((sizeof(char [3l]) /*3ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
                tmp_if_expr$10 = return_value_spio_write_data_raw$9 == -1 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$10)
              {
                ret = -1;
                goto cleanup;
              }

              header[(signed long int)0] = (char)0;
            }

          }

          do
          {
            rc=getline(&line, &line_len, file);
            if(rc == -1l)
              break;

            signed int return_value_strcmp$11;
            return_value_strcmp$11=strcmp(line, ".\r\n");
            if(return_value_strcmp$11 == 0)
              strncpy(line, ". \r\n", (unsigned long int)(4096 + 128));

            if(!((signed int)header[0l] == 0))
            {
              signed int return_value_is_blank_line$15;
              return_value_is_blank_line$15=is_blank_line(line);
              if(!(return_value_is_blank_line$15 == 0))
              {
                signed int return_value_spio_write_data_raw$12;
                return_value_spio_write_data_raw$12=spio_write_data_raw(ctx, &ctx->server, (unsigned char *)header, (signed int)header_len);
                if(return_value_spio_write_data_raw$12 == -1)
                  tmp_if_expr$14 = (_Bool)1;

                else
                {
                  return_value_spio_write_data_raw$13=spio_write_data_raw(ctx, &ctx->server, (unsigned char *)"\r\n", (signed int)((sizeof(char [3l]) /*3ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
                  tmp_if_expr$14 = return_value_spio_write_data_raw$13 == -1 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$14)
                {
                  ret = -1;
                  goto cleanup;
                }

                header[(signed long int)0] = (char)0;
              }

            }

            signed int return_value_spio_write_data_raw$16;
            return_value_spio_write_data_raw$16=spio_write_data_raw(ctx, &ctx->server, (unsigned char *)line, (signed int)rc);
            if(return_value_spio_write_data_raw$16 == -1)
            {
              ret = -1;
              goto cleanup;
            }

          }
          while((_Bool)1);
          return_value_ferror$17=ferror(file);
          if(!(return_value_ferror$17 == 0))
            sp_message(ctx, 3, "error reading cache file: %s", (const void *)ctx->cachename);

          return_value_ferror$18=ferror(file);
          if(!(return_value_ferror$18 == 0))
            tmp_if_expr$20 = (_Bool)1;

          else
          {
            return_value_spio_write_data$19=spio_write_data(ctx, &ctx->server, ".\r\n");
            tmp_if_expr$20 = return_value_spio_write_data$19 == -1 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$20)
          {
            spio_write_data(ctx, &ctx->client, "451 Local Error\r\n");
            ret = -1;
          }

          else
          {
            sp_messagex(ctx, 7, "sent email data");
            return_value_read_server_response$21=read_server_response(ctx);
            if(return_value_read_server_response$21 == -1)
              ret = -1;

            else
            {
              return_value_spio_write_data$22=spio_write_data(ctx, &ctx->client, ctx->server.line);
              if(return_value_spio_write_data$22 == -1)
                ret = -1;

            }
          }
        }
      }
    }
  }

cleanup:
  ;
  if(!(line == ((char *)NULL)))
    free((void *)line);

  if(!(file == ((struct _IO_FILE *)NULL)))
    fclose(file);

  return ret;
}

// sp_fail_data
// file ../common/smtppass.h line 232
signed int sp_fail_data(struct spctx *ctx, const char *smtp_status)
{
  signed int return_value_sp_fail_msg$1;
  return_value_sp_fail_msg$1=sp_fail_msg(ctx, smtp_status);
  _Bool tmp_if_expr$4;
  signed int return_value_read_server_response$3;
  if(!(return_value_sp_fail_msg$1 >= 0))
    return -1;

  else
  {
    signed int return_value_spio_write_data$2;
    return_value_spio_write_data$2=spio_write_data(ctx, &ctx->server, "RSET\r\n");
    if(return_value_spio_write_data$2 == -1)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_read_server_response$3=read_server_response(ctx);
      tmp_if_expr$4 = return_value_read_server_response$3 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      return -1;

    else
      return 0;
  }
}

// sp_fail_msg
// file ../common/smtppass.h line 244
signed int sp_fail_msg(struct spctx *ctx, const char *smtp_status)
{
  char buf[281l];
  char *t = (char *)(void *)0;
  signed int len;
  signed int x;
  signed int pref = 0;
  signed int crlf = 0;
  if(smtp_status == ((const char *)NULL))
    smtp_status = "451 Local Error\r\n";

  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(smtp_status, &t, 10);
  x = (signed int)return_value_strtol$1;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(smtp_status);
  len = (signed int)return_value_strlen$2;
  if(x == 0 || !(t == smtp_status + 3l))
    pref = 1;

  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(smtp_status + (signed long int)((unsigned long int)len - (sizeof(char [3l]) /*3ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ), "\r\n");
  if(!(return_value_strcmp$3 == 0))
    crlf = 1;

  if(!(crlf == 0) || !(pref == 0))
  {
    snprintf(buf, sizeof(char [281l]) /*281ul*/ , "%s%.256s%s", pref != 0 ? "550 Content Rejected; " : "", smtp_status, crlf != 0 ? "\r\n" : "");
    buf[(signed long int)(sizeof(char [281l]) /*281ul*/  - (unsigned long int)1)] = (char)0;
    smtp_status = buf;
  }

  signed int return_value_spio_write_data$4;
  return_value_spio_write_data$4=spio_write_data(ctx, &ctx->client, smtp_status);
  if(return_value_spio_write_data$4 == -1)
    return -1;

  else
    return 0;
}

// sp_init
// file ../common/smtppass.h line 147
void sp_init(const char *name)
{
  signed int r;
  memset((void *)&g_state, 0, sizeof(struct spstate) /*784ul*/ );
  sp_message((struct spctx *)(void *)0, 7, "%s (%s)", name, (const void *)"1.10");
  g_state.debug_level = -1;
  g_state.max_threads = 64;
  g_state.timeout.tv_sec = (signed long int)180;
  g_state.keepalives = 0;
  g_state.directory = "/tmp/";
  g_state.name = name;
  r=sp_parse_option("Listen", "10025");
  signed int return_value_pthread_mutexattr_init$1;
  return_value_pthread_mutexattr_init$1=pthread_mutexattr_init(&g_mtxattr);
  _Bool tmp_if_expr$3;
  signed int return_value_pthread_mutexattr_settype$2;
  if(!(return_value_pthread_mutexattr_init$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_pthread_mutexattr_settype$2=pthread_mutexattr_settype(&g_mtxattr, 2);
    tmp_if_expr$3 = return_value_pthread_mutexattr_settype$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  signed int return_value_pthread_mutex_init$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_pthread_mutex_init$4=pthread_mutex_init(&g_mutex, &g_mtxattr);
    tmp_if_expr$5 = return_value_pthread_mutex_init$4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
    errx(1, "threading problem. can't create mutex or condition var");

}

// sp_is_quit
// file ../common/smtppass.h line 165
signed int sp_is_quit()
{
  return g_state.quit != 0 ? 1 : 0;
}

// sp_lock
// file ../common/smtppass.c line 2075
void sp_lock()
{
  signed int r;
  r=pthread_mutex_lock(&g_mutex);
  if(!(r == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = r;
    sp_message((struct spctx *)(void *)0, 2, "threading problem. couldn't lock mutex");
  }

}

// sp_message
// file ../common/smtppass.h line 258
void sp_message(struct spctx *ctx, signed int level, const char *msg, ...)
{
  void **ap = (void **)&msg;
  vmessage(ctx, level, 1, msg, ap);
  ap = ((void **)NULL);
}

// sp_messagex
// file ../common/smtppass.h line 259
void sp_messagex(struct spctx *ctx, signed int level, const char *msg, ...)
{
  void **ap = (void **)&msg;
  vmessage(ctx, level, 0, msg, ap);
  ap = ((void **)NULL);
}

// sp_parse_option
// file ../common/smtppass.c line 2125
signed int sp_parse_option(const char *name, const char *value)
{
  char *t;
  signed int ret = 0;
  signed int return_value_strcasecmp$21;
  return_value_strcasecmp$21=strcasecmp("MaxConnections", name);
  signed int return_value_strcasecmp$20;
  signed int return_value_strcasecmp$19;
  signed int return_value_strcasecmp$18;
  signed int return_value_strcasecmp$17;
  signed int return_value_strcasecmp$16;
  signed int return_value_strcasecmp$15;
  signed int return_value_strcasecmp$5;
  signed int return_value_strcasecmp$14;
  signed int return_value_strcasecmp$13;
  signed int return_value_strcasecmp$12;
  signed int return_value_strcasecmp$11;
  if(return_value_strcasecmp$21 == 0)
  {
    signed long int return_value_strtol$1;
    return_value_strtol$1=strtol(value, &t, 10);
    g_state.max_threads = (signed int)return_value_strtol$1;
    if(g_state.max_threads >= 10240 || !(*t == 0) || !(g_state.max_threads >= 2))
      errx(2, "invalid setting: MaxConnections (must be between 1 and %d)", 10240);

    ret = 1;
  }

  else
  {
    return_value_strcasecmp$20=strcasecmp("TimeOut", name);
    if(return_value_strcasecmp$20 == 0)
    {
      g_state.timeout.tv_sec=strtol(value, &t, 10);
      if(!(*t == 0) || !(g_state.timeout.tv_sec >= 1l))
        errx(2, "invalid setting: TimeOut");

      ret = 1;
    }

    else
    {
      return_value_strcasecmp$19=strcasecmp("KeepAlives", name);
      if(return_value_strcasecmp$19 == 0)
      {
        signed long int return_value_strtol$2;
        return_value_strtol$2=strtol(value, &t, 10);
        g_state.keepalives = (signed int)return_value_strtol$2;
        if(!(*t == 0) || !(g_state.keepalives >= 0))
          errx(2, "invalid setting: KeepAlives");

        ret = 1;
      }

      else
      {
        return_value_strcasecmp$18=strcasecmp("XClient", name);
        if(return_value_strcasecmp$18 == 0)
        {
          g_state.xclient=strtob(value);
          if(g_state.xclient == -1)
            errx(2, "invalid value for XClient");

          ret = 1;
        }

        else
        {
          return_value_strcasecmp$17=strcasecmp("OutAddress", name);
          if(return_value_strcasecmp$17 == 0)
          {
            signed int return_value_sock_any_pton$3;
            return_value_sock_any_pton$3=sock_any_pton(value, &g_state.outaddr, (signed int)(25 & 0xFFFF));
            if(return_value_sock_any_pton$3 == -1)
              errx(2, "invalid OutAddress socket name or ip: %s", value);

            g_state.outname = value;
            ret = 1;
          }

          else
          {
            return_value_strcasecmp$16=strcasecmp("Listen", name);
            if(return_value_strcasecmp$16 == 0)
            {
              signed int return_value_sock_any_pton$4;
              return_value_sock_any_pton$4=sock_any_pton(value, &g_state.listenaddr, 0x00000000 | (signed int)(10025 & 0xFFFF));
              if(return_value_sock_any_pton$4 == -1)
                errx(2, "invalid Listen socket name or ip: %s", value);

              g_state.listenname = value;
              ret = 1;
            }

            else
            {
              return_value_strcasecmp$15=strcasecmp("TransparentProxy", name);
              if(return_value_strcasecmp$15 == 0)
              {
                signed int val;
                val=strtob(value);
                if(val == -1)
                {
                  signed int return_value_strcasecmp$6;
                  return_value_strcasecmp$6=strcasecmp("client", value);
                  if(return_value_strcasecmp$6 == 0)
                    g_state.transparent = 1;

                  else
                  {
                    return_value_strcasecmp$5=strcasecmp("full", value);
                    if(return_value_strcasecmp$5 == 0)
                      g_state.transparent = 2;

                    else
                      errx(2, "invalid value for TransparentProxy");
                  }
                }

                else
                  if(!(val == 0))
                    g_state.transparent = 1;

                  else
                    g_state.transparent = 0;
                ret = 1;
              }

              else
              {
                return_value_strcasecmp$14=strcasecmp("TempDirectory", name);
                if(return_value_strcasecmp$14 == 0)
                {
                  unsigned long int return_value_strlen$7;
                  return_value_strlen$7=strlen(value);
                  if(return_value_strlen$7 == 0ul)
                    errx(2, "invalid setting: TempDirectory");

                  g_state.directory = value;
                  ret = 1;
                }

                else
                {
                  return_value_strcasecmp$13=strcasecmp("User", name);
                  if(return_value_strcasecmp$13 == 0)
                  {
                    unsigned long int return_value_strlen$8;
                    return_value_strlen$8=strlen(value);
                    if(return_value_strlen$8 == 0ul)
                      errx(2, "invalid setting: User");

                    g_state.user = value;
                    ret = 1;
                  }

                  else
                  {
                    return_value_strcasecmp$12=strcasecmp("PidFile", name);
                    if(return_value_strcasecmp$12 == 0)
                    {
                      if(!(g_state.pidfile == ((const char *)NULL)))
                        sp_messagex((struct spctx *)(void *)0, 4, "ignoring pid file specified on the command line. ");

                      unsigned long int return_value_strlen$9;
                      return_value_strlen$9=strlen(value);
                      if(return_value_strlen$9 == 0ul)
                        g_state.pidfile = (const char *)(void *)0;

                      else
                        g_state.pidfile = value;
                      ret = 1;
                    }

                    else
                    {
                      return_value_strcasecmp$11=strcasecmp("Skip", name);
                      if(return_value_strcasecmp$11 == 0)
                      {
                        signed int return_value_strcasecmp$10;
                        return_value_strcasecmp$10=strcasecmp(value, "authenticated");
                        if(return_value_strcasecmp$10 == 0)
                          g_state.skip = g_state.skip | 1;

                        else
                          errx(2, "invalid value for Skip (must specify 'authenticated')");
                        return 1;
                      }

                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  signed int return_value_cb_parse_option$22;
  return_value_cb_parse_option$22=cb_parse_option(name, value);
  if(return_value_cb_parse_option$22 == 1)
    ret = 1;

  return ret;
}

// sp_pass_data
// file ../common/smtppass.c line 1829
signed int sp_pass_data(struct spctx *ctx)
{
  signed int count = 0;
  const char *data;
  signed long int rc;
  signed int return_value_spio_write_data$1;
  return_value_spio_write_data$1=spio_write_data(ctx, &ctx->server, "DATA\r\n");
  signed int return_value_sp_read_data$5;
  if(!(return_value_spio_write_data$1 >= 0))
    return -1;

  else
  {
    signed int return_value_read_server_response$2;
    return_value_read_server_response$2=read_server_response(ctx);
    if(return_value_read_server_response$2 == -1)
      return -1;

    else
    {
      signed int return_value_spio_write_data$3;
      return_value_spio_write_data$3=spio_write_data(ctx, &ctx->client, ctx->server.line);
      if(return_value_spio_write_data$3 == -1)
        return -1;

      else
      {
        signed int return_value_is_first_word$4;
        return_value_is_first_word$4=is_first_word(ctx->server.line, "354", (signed int)((sizeof(char [4l]) /*4ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
        if(return_value_is_first_word$4 == 0)
        {
          sp_messagex(ctx, 7, "server refused data transfer");
          return 0;
        }

        else
        {
          do
          {
            return_value_sp_read_data$5=sp_read_data(ctx, &data);
            rc = (signed long int)return_value_sp_read_data$5;
            if(rc == 0l)
              break;

            if(!(rc >= 0l))
              return -1;

            count = count + (signed int)rc;
            signed int return_value_spio_write_data_raw$6;
            return_value_spio_write_data_raw$6=spio_write_data_raw(ctx, &ctx->server, (unsigned char *)data, (signed int)rc);
            if(!(return_value_spio_write_data_raw$6 >= 0))
              return -1;

          }
          while((_Bool)1);
          signed int return_value_spio_write_data$7;
          return_value_spio_write_data$7=spio_write_data(ctx, &ctx->server, ".\r\n");
          if(!(return_value_spio_write_data$7 >= 0))
          {
            spio_write_data(ctx, &ctx->client, "451 Local Error\r\n");
            return -1;
          }

          else
          {
            signed int return_value_read_server_response$8;
            return_value_read_server_response$8=read_server_response(ctx);
            if(return_value_read_server_response$8 == -1)
              return -1;

            else
            {
              signed int return_value_spio_write_data$9;
              return_value_spio_write_data$9=spio_write_data(ctx, &ctx->client, ctx->server.line);
              if(return_value_spio_write_data$9 == -1)
                return -1;

              else
              {
                sp_add_log(ctx, "status=", "SKIPPED");
                sp_messagex(ctx, 7, "skipped %d data bytes", count);
                return 0;
              }
            }
          }
        }
      }
    }
  }
}

// sp_quit
// file ../common/smtppass.c line 385
void sp_quit()
{
  signed int return_value_getpid$1;
  return_value_getpid$1=getpid();
  kill(return_value_getpid$1, 15);
}

// sp_read_data
// file ../common/smtppass.h line 206
signed int sp_read_data(struct spctx *ctx, const char **data)
{
  signed int r;
  *data = (const char *)(void *)0;
  r=spio_read_line(ctx, &ctx->client, 0x00000004);
  if(!(r == 0))
  {
    if(r == -1)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    sp_messagex(ctx, 3, "unexpected end of data from client");
    return -1;

  __CPROVER_DUMP_L2:
    ;
    return -1;
  }
  if(g_state.keepalives >= 1)
  {
    signed long int return_value_time$1;
    return_value_time$1=time((signed long int *)(void *)0);
    if(!(ctx->server.last_action + (signed long int)g_state.keepalives >= return_value_time$1))
      do_server_noop(ctx);

  }

  signed int return_value_strcmp$2;
  if(!(ctx->_crlf == 0))
  {
    return_value_strcmp$2=strcmp(ctx->client.line, ".\r\n");
    if(!(return_value_strcmp$2 == 0))
      goto __CPROVER_DUMP_L6;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L6:
    ;
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp("\r\n", ctx->client.line + (signed long int)((unsigned long int)r - (sizeof(char [3l]) /*3ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
    ctx->_crlf = (signed int)(return_value_strcmp$3 == 0);
    *data = ctx->client.line;
    return r;
  }
}

// sp_run
// file ../common/smtppass.h line 153
signed int sp_run(const char *configfile, const char *pidfile, signed int dbg_level)
{
  signed int sock;
  signed int true = 1;
  if(!(dbg_level == -1) && dbg_level >= 8)
    errx(2, "invalid debug log level (must be between 1 and 4)");

  g_state.debug_level = dbg_level;
  g_state.pidfile = pidfile;
  signed int return_value_parse_config_file$1;
  return_value_parse_config_file$1=parse_config_file(configfile);
  if(return_value_parse_config_file$1 == -1)
    warnx("configuration file not found: %s", configfile);

  if(g_state.outname == ((const char *)NULL) && g_state.transparent == 0)
    errx(2, "no OutAddress specified.");

  else
    if(!(g_state.outname == ((const char *)NULL)) && !(g_state.transparent == 0))
      warnx("the OutAddress option will be ignored when TransparentProxy is enabled");

  sp_messagex((struct spctx *)(void *)0, 7, "starting up (%s)...", (const void *)"1.10");
  drop_privileges();
  if(g_state.debug_level == -1)
  {
    signed int return_value_daemon$2;
    return_value_daemon$2=daemon(0, 0);
    if(return_value_daemon$2 == -1)
    {
      sp_message((struct spctx *)(void *)0, 3, "couldn't run as daemon");
      exit(1);
    }

    sp_messagex((struct spctx *)(void *)0, 7, "running as a daemon");
    g_state.daemonized = 1;
    openlog(g_state.name, 0, 2 << 3);
  }

  signal(13, (void (*)(signed int))1);
  signal(1, (void (*)(signed int))1);
  signal(2, on_quit);
  signal(15, on_quit);
  siginterrupt(2, 1);
  siginterrupt(15, 1);
  sock=socket((signed int)g_state.listenaddr.s.a.sa_family, 1, 0);
  if(!(sock >= 0))
  {
    sp_message((struct spctx *)(void *)0, 2, "couldn't open socket");
    exit(1);
  }

  signed int return_value_fcntl$3;
  return_value_fcntl$3=fcntl(sock, 1, 0);
  fcntl(sock, 2, return_value_fcntl$3 | 1);
  setsockopt(sock, 1, 2, (void *)&true, (unsigned int)sizeof(signed int) /*4ul*/ );
  if((signed int)g_state.listenaddr.s.a.sa_family == 1)
    unlink(g_state.listenname);

  if(g_state.transparent == 2)
  {
    signed int value = 1;
    signed int return_value_setsockopt$4;
    return_value_setsockopt$4=setsockopt(sock, 0, 19, (const void *)&value, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt$4 >= 0))
      sp_message((struct spctx *)(void *)0, 4, "couldn't set transparent mode on socket");

  }

  signed int return_value_bind$5;
  return_value_bind$5=bind(sock, &g_state.listenaddr.s.a, g_state.listenaddr.namelen);
  if(!(return_value_bind$5 == 0))
  {
    sp_message((struct spctx *)(void *)0, 2, "couldn't bind to address: %s", g_state.listenname);
    exit(1);
  }

  sp_messagex((struct spctx *)(void *)0, 7, "created socket: %s", g_state.listenname);
  signed int return_value_listen$6;
  return_value_listen$6=listen(sock, 5);
  if(!(return_value_listen$6 == 0))
  {
    sp_message((struct spctx *)(void *)0, 2, "couldn't listen on socket");
    exit(1);
  }

  pid_file(1);
  sp_messagex((struct spctx *)(void *)0, 7, "accepting connections");
  connection_loop(sock);
  pid_file(0);
  close(sock);
  sp_messagex((struct spctx *)(void *)0, 7, "stopped processing");
  return 0;
}

// sp_setup_forked
// file ../common/smtppass.h line 251
void sp_setup_forked(struct spctx *ctx, signed int file)
{
  signal(13, (void (*)(signed int))0);
  signal(1, (void (*)(signed int))0);
  signal(2, (void (*)(signed int))0);
  signal(15, (void (*)(signed int))0);
  siginterrupt(2, 0);
  siginterrupt(15, 0);
  if(!(ctx->sender == ((char *)NULL)))
    setenv("SENDER", ctx->sender, 1);

  if(!(ctx->recipients == ((char *)NULL)))
    setenv("RECIPIENTS", ctx->recipients, 1);

  if(!(file == 0))
  {
    if(!(ctx->cachename[0l] == 0))
      setenv("EMAIL", ctx->cachename, 1);

  }

  if(!(ctx->client.fd == -1))
    setenv("CLIENT", ctx->client.peername, 1);

  if(!(ctx->xforwardaddr == ((char *)NULL)))
    setenv("REMOTE", ctx->xforwardaddr, 1);

  if(!(ctx->xforwardhelo == ((char *)NULL)))
    setenv("REMOTE_HELO", ctx->xforwardhelo, 1);

  if(!(ctx->server.fd == -1))
    setenv("SERVER", ctx->server.peername, 1);

  setenv("TMPDIR", g_state.directory, 1);
}

// sp_start_data
// file ../common/smtppass.h line 197
signed int sp_start_data(struct spctx *ctx)
{
  signed int return_value_spio_write_data$1;
  return_value_spio_write_data$1=spio_write_data(ctx, &ctx->client, "354 Start mail input; end with <CRLF>.<CRLF>\r\n");
  return return_value_spio_write_data$1;
}

// sp_unlock
// file ../common/smtppass.c line 2111
void sp_unlock()
{
  signed int r;
  r=pthread_mutex_unlock(&g_mutex);
  if(!(r == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = r;
    sp_message((struct spctx *)(void *)0, 2, "threading problem. couldn't unlock mutex");
  }

}

// sp_write_data
// file ../common/smtppass.h line 214
signed int sp_write_data(struct spctx *ctx, const char *buf, signed int len)
{
  signed int r = 0;
  _Bool tmp_if_expr$2;
  if(buf == ((const char *)NULL))
  {
    if(!(ctx->cachefile == ((struct _IO_FILE *)NULL)))
    {
      signed int return_value_fclose$1;
      return_value_fclose$1=fclose(ctx->cachefile);
      if(return_value_fclose$1 == -1)
      {
        sp_message(ctx, 3, "couldn't write to cache file: %s", (const void *)ctx->cachename);
        r = -1;
      }

      ctx->cachefile = (struct _IO_FILE *)(void *)0;
    }

    return r;
  }

  else
  {
    if(ctx->cachefile == ((struct _IO_FILE *)NULL))
    {
      signed int tfd;
      if(!(ctx->cachename[0l] == 0))
        unlink(ctx->cachename);

      snprintf(ctx->cachename, (unsigned long int)4096, "%s/%s.XXXXXX", g_state.directory, g_state.name);
      tfd=mkstemp(ctx->cachename);
      if(tfd == -1)
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        ctx->cachefile=fdopen(tfd, "w");
        tmp_if_expr$2 = ctx->cachefile == (struct _IO_FILE *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$2)
      {
        if(!(tfd == -1))
          close(tfd);

        sp_message(ctx, 3, "couldn't open cache file");
        return -1;
      }

      signed int return_value_fcntl$3;
      return_value_fcntl$3=fcntl(tfd, 1, 0);
      fcntl(tfd, 2, return_value_fcntl$3 | 1);
      sp_messagex(ctx, 7, "created cache file: %s", (const void *)ctx->cachename);
    }

    fwrite((const void *)buf, (unsigned long int)1, (unsigned long int)len, ctx->cachefile);
    signed int return_value_ferror$4;
    return_value_ferror$4=ferror(ctx->cachefile);
    if(!(return_value_ferror$4 == 0))
    {
      sp_message(ctx, 3, "couldn't write to cache file: %s", (const void *)ctx->cachename);
      return -1;
    }

    else
      return len;
  }
}

// spio_attach
// file ../common/spio.c line 122
void spio_attach(struct spctx *ctx, struct spio *io, signed int fd, struct sockaddr_any *peer)
{
  struct sockaddr_any peeraddr;
  struct sockaddr_any locaddr;
  io->fd = fd;
  memset((void *)&locaddr, 0, sizeof(struct sockaddr_any) /*224ul*/ );
  locaddr.namelen = (unsigned int)sizeof(struct sockaddr_any) /*224ul*/ ;
  signed int return_value_getsockname$3;
  return_value_getsockname$3=getsockname(fd, &locaddr.s.a, &locaddr.namelen);
  _Bool tmp_if_expr$5;
  signed int return_value_sock_any_ntop$4;
  if(return_value_getsockname$3 == -1)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_sock_any_ntop$4=sock_any_ntop(&locaddr, io->localname, (unsigned long int)4096, 0x01000000);
    tmp_if_expr$5 = return_value_sock_any_ntop$4 == -1 ? (_Bool)1 : (_Bool)0;
  }
  const char *tmp_if_expr$1;
  if(tmp_if_expr$5)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(!(*return_value___errno_location$2 == 97))
    {
      if(!(io->name == ((const char *)NULL)))
        tmp_if_expr$1 = io->name;

      else
        tmp_if_expr$1 = "???   ";
      sp_message(ctx, 4, "%s: couldn't get socket address", tmp_if_expr$1);
    }

    strlcpy(io->localname, "UNKNOWN", (unsigned long int)4096);
  }

  if(peer == ((struct sockaddr_any *)NULL))
    peer = &peeraddr;

  memset((void *)peer, 0, sizeof(struct sockaddr_any) /*224ul*/ );
  peer->namelen = (unsigned int)sizeof(struct sockaddr_any) /*224ul*/ ;
  signed int return_value_getpeername$8;
  return_value_getpeername$8=getpeername(fd, &peer->s.a, &peer->namelen);
  _Bool tmp_if_expr$10;
  signed int return_value_sock_any_ntop$9;
  if(return_value_getpeername$8 == -1)
    tmp_if_expr$10 = (_Bool)1;

  else
  {
    return_value_sock_any_ntop$9=sock_any_ntop(peer, io->peername, (unsigned long int)4096, 0x01000000);
    tmp_if_expr$10 = return_value_sock_any_ntop$9 == -1 ? (_Bool)1 : (_Bool)0;
  }
  const char *tmp_if_expr$6;
  if(tmp_if_expr$10)
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    if(!(*return_value___errno_location$7 == 97))
    {
      if(!(io->name == ((const char *)NULL)))
        tmp_if_expr$6 = io->name;

      else
        tmp_if_expr$6 = "???   ";
      sp_message(ctx, 4, "%s: couldn't get peer address", tmp_if_expr$6);
    }

    strlcpy(io->peername, "UNKNOWN", (unsigned long int)4096);
  }

  io->line[(signed long int)0] = (char)0;
  io->_nx = (char *)(void *)0;
  io->_ln = (unsigned long int)0;
}

// spio_connect
// file ../common/spio.c line 162
signed int spio_connect(struct spctx *ctx, struct spio *io, struct sockaddr_any *sdst, const char *dstname, struct sockaddr_any *ssrc, const char *srcname)
{
  signed int ret = 0;
  signed int fd;
  fd=socket((signed int)sdst->s.a.sa_family, 1, 0);
  signed int return_value_setsockopt$2;
  _Bool tmp_if_expr$4;
  signed int return_value_setsockopt$3;
  const char *tmp_if_expr$1;
  signed int return_value_fcntl$5;
  _Bool tmp_if_expr$9;
  signed int return_value_setsockopt$8;
  const char *tmp_if_expr$6;
  const char *tmp_if_expr$10;
  const char *tmp_if_expr$11;
  signed int return_value_connect$13;
  if(fd == -1)
    ret = -1;

  else
  {
    return_value_setsockopt$2=setsockopt(fd, 1, 20, (const void *)&g_state.timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
    if(return_value_setsockopt$2 == -1)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_setsockopt$3=setsockopt(fd, 1, 21, (const void *)&g_state.timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
      tmp_if_expr$4 = return_value_setsockopt$3 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      if(!(io->name == ((const char *)NULL)))
        tmp_if_expr$1 = io->name;

      else
        tmp_if_expr$1 = "???   ";
      sp_messagex(ctx, 7, "%s: couldn't set timeouts on connection", tmp_if_expr$1);
    }

    return_value_fcntl$5=fcntl(fd, 1, 0);
    fcntl(fd, 2, return_value_fcntl$5 | 1);
    if(!(ssrc == ((struct sockaddr_any *)NULL)))
    {
      signed int value = 1;
      signed int return_value_setsockopt$7;
      return_value_setsockopt$7=setsockopt(fd, 1, 2, (const void *)&value, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt$7 >= 0))
        tmp_if_expr$9 = (_Bool)1;

      else
      {
        return_value_setsockopt$8=setsockopt(fd, 0, 19, (const void *)&value, (unsigned int)sizeof(signed int) /*4ul*/ );
        tmp_if_expr$9 = return_value_setsockopt$8 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$9)
      {
        if(!(io->name == ((const char *)NULL)))
          tmp_if_expr$6 = io->name;

        else
          tmp_if_expr$6 = "???   ";
        sp_message(ctx, 7, "%s: couldn't set transparent mode on connection", tmp_if_expr$6);
        ssrc = (struct sockaddr_any *)(void *)0;
      }

    }

    if(!(ssrc == ((struct sockaddr_any *)NULL)))
    {
      signed int return_value_bind$12;
      return_value_bind$12=bind(fd, &ssrc->s.a, ssrc->namelen);
      if(!(return_value_bind$12 >= 0))
      {
        if(!(io->name == ((const char *)NULL)))
          tmp_if_expr$10 = io->name;

        else
          tmp_if_expr$10 = "???   ";
        sp_message(ctx, 4, "%s: couldn't set source of transparent connection to: %s", tmp_if_expr$10, srcname);
      }

      else
      {
        if(!(io->name == ((const char *)NULL)))
          tmp_if_expr$11 = io->name;

        else
          tmp_if_expr$11 = "???   ";
        sp_messagex(ctx, 7, "%s: setup source of transparent connection: %s", tmp_if_expr$11, srcname);
      }
    }

    return_value_connect$13=connect(fd, &sdst->s.a, sdst->namelen);
    if(return_value_connect$13 == -1)
    {
      close_raw(&fd);
      ret = -1;
    }

    else
      spio_attach(ctx, io, fd, (struct sockaddr_any *)(void *)0);
  }

cleanup:
  ;
  const char *tmp_if_expr$14;
  const char *tmp_if_expr$15;
  if(!(ret >= 0))
  {
    if(!(io == ((struct spio *)NULL)))
    {
      if(!(io->fd == -1))
        close_raw(&io->fd);

    }

    if(!(io->name == ((const char *)NULL)))
      tmp_if_expr$14 = io->name;

    else
      tmp_if_expr$14 = "???   ";
    sp_message(ctx, 3, "%s: couldn't connect to: %s", tmp_if_expr$14, dstname);
    return -1;
  }

  else
  {
    if(!(io->name == ((const char *)NULL)))
      tmp_if_expr$15 = io->name;

    else
      tmp_if_expr$15 = "???   ";
    sp_messagex(ctx, 7, "%s connected to: %s", tmp_if_expr$15, (const void *)io->peername);
    return 0;
  }
}

// spio_disconnect
// file ../common/spio.c line 229
void spio_disconnect(struct spctx *ctx, struct spio *io)
{
  const char *tmp_if_expr$1;
  if(!(io == ((struct spio *)NULL)))
  {
    if(!(io->fd == -1))
    {
      close_raw(&io->fd);
      if(!(io->name == ((const char *)NULL)))
        tmp_if_expr$1 = io->name;

      else
        tmp_if_expr$1 = "???   ";
      sp_messagex(ctx, 7, "%s connection closed", tmp_if_expr$1);
    }

  }

}

// spio_init
// file ../common/spio.c line 114
void spio_init(struct spio *io, const char *name)
{
  memset((void *)io, 0, sizeof(struct spio) /*12456ul*/ );
  io->name = name;
  io->fd = -1;
}

// spio_read_junk
// file ../common/spio.c line 639
void spio_read_junk(struct spctx *ctx, struct spio *io)
{
  char buf[16l];
  const char *t;
  signed int said = 0;
  signed int l;
  io->_ln = (unsigned long int)0;
  io->_nx = ((char *)NULL);
  _Bool tmp_if_expr$1;
  if(!(io == ((struct spio *)NULL)))
    tmp_if_expr$1 = io->fd != -1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  const char *tmp_if_expr$4;
  if(tmp_if_expr$1)
  {
    signed int return_value_fcntl$2;
    return_value_fcntl$2=fcntl(io->fd, 3, 0);
    fcntl(io->fd, 4, return_value_fcntl$2 | 04000);
    do
    {
      signed long int return_value_read$3;
      return_value_read$3=read(io->fd, (void *)buf, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
      l = (signed int)return_value_read$3;
      if(!(l >= 1))
        break;

      io->last_action=time((signed long int *)(void *)0);
      buf[(signed long int)l] = (char)0;
      t=trim_start(buf);
      if(said == 0)
      {
        if(!(*t == 0))
        {
          if(!(io->name == ((const char *)NULL)))
            tmp_if_expr$4 = io->name;

          else
            tmp_if_expr$4 = "???   ";
          sp_messagex(ctx, 7, "%s: received junk data from daemon", tmp_if_expr$4);
          said = 1;
        }

      }

    }
    while((_Bool)1);
    signed int return_value_fcntl$5;
    return_value_fcntl$5=fcntl(io->fd, 3, 0);
    fcntl(io->fd, 4, return_value_fcntl$5 & ~04000);
  }

}

// spio_read_line
// file ../common/spio.c line 509
signed int spio_read_line(struct spctx *ctx, struct spio *io, signed int opts)
{
  signed int x;
  signed int l;
  char *t;
  _Bool tmp_if_expr$2;
  if(!(io == ((struct spio *)NULL)))
    tmp_if_expr$2 = io->fd != -1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  const char *tmp_if_expr$1;
  const unsigned short int **return_value___ctype_b_loc$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  if(!tmp_if_expr$2)
  {
    if(!(io->name == ((const char *)NULL)))
      tmp_if_expr$1 = io->name;

    else
      tmp_if_expr$1 = "???   ";
    sp_messagex(ctx, 4, "%s: tried to read from a closed connection", tmp_if_expr$1);
    return 0;
  }

  else
  {
    x=read_raw(ctx, io, opts);
    if(x >= 1)
    {
      if(!((0x00000001 & opts) == 0))
      {
        t = io->line;
        for( ; !(*t == 0); t = t + 1l)
        {
          return_value___ctype_b_loc$3=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*t]) == 0)
            break;

        }
        l = (signed int)(t - io->line);
        memmove((void *)io->line, (const void *)t, (unsigned long int)((x + 1) - l));
        x = x - l;
        t = io->line + (signed long int)x;
        for( ; !(io->line >= t); x = x - 1)
        {
          return_value___ctype_b_loc$4=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)t[-1l]]) == 0)
            break;

          t = t - 1l;
          *t = (char)0;
        }
      }

      if((0x00000004 & opts) == 0)
        log_io_data(ctx, io, io->line, 1);

    }

    return x;
  }
}

// spio_select
// file ../common/spio.c line 240
unsigned int spio_select(struct spctx *ctx, ...)
{
  struct anonymous$2 mask;
  struct spio *io;
  signed int ret = 0;
  signed int have = 0;
  signed int i = 0;
  __builtin_va_list ap;
  struct timeval timeout;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$2) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&mask)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  va_start(ap, ctx);
  do
  {
    io=va_arg(ap, __typeof__(io));
    if(io == ((struct spio *)NULL))
      break;

    if(!(io == ((struct spio *)NULL)))
    {
      if(!(io->fd == -1))
      {
        if((unsigned long int)i >= 31ul)
          break;

        if(io->_ln >= 1ul)
          ret = ret | 1 << i;

        (&mask)->__fds_bits[(signed long int)(io->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&mask)->__fds_bits[(signed long int)(io->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << io->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        have = 1;
      }

    }

    i = i + 1;
  }
  while((_Bool)1);
  va_end(ap);
  if(!(ret == 0))
    return (unsigned int)ret;

  else
    if(have == 0)
      return (unsigned int)~0;

    else
    {
      do
      {
        memcpy((void *)&timeout, (const void *)&g_state.timeout, sizeof(struct timeval) /*16ul*/ );
        signed int return_value_select$1;
        return_value_select$1=select(1024, &mask, (struct anonymous$2 *)(void *)0, (struct anonymous$2 *)(void *)0, &timeout);
        if(!(return_value_select$1 == 0))
        {
          if(return_value_select$1 == -1)
            goto __CPROVER_DUMP_L9;

        }

        else
        {
          sp_messagex(ctx, 3, "network operation timed out");
          return (unsigned int)~0;

        __CPROVER_DUMP_L9:
          ;
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          if(*return_value___errno_location$3 == 4)
          {
            signed int return_value_sp_is_quit$2;
            return_value_sp_is_quit$2=sp_is_quit();
            if(return_value_sp_is_quit$2 == 0)
              continue;

          }

          else
            sp_message(ctx, 3, "couldn't select on sockets");
          return (unsigned int)~0;
        }
        break;
      }
      while((_Bool)1);
      i = 0;
      va_start(ap, ctx);
      do
      {
        io=va_arg(ap, __typeof__(io));
        if(io == ((struct spio *)NULL))
          break;

        if(!(io == ((struct spio *)NULL)))
        {
          if(!(io->fd == -1))
          {
            if((unsigned long int)i >= 31ul)
              break;

            io->last_action=time((signed long int *)(void *)0);
            if(!((mask.__fds_bits[(signed long int)(io->fd / 8)] & (signed long int)(1UL << io->fd % 8)) == 0l))
              ret = ret | 1 << i;

          }

        }

        i = i + 1;
      }
      while((_Bool)1);
      va_end(ap);
      return (unsigned int)ret;
    }
}

// spio_write_data
// file ../common/spio.c line 555
signed int spio_write_data(struct spctx *ctx, struct spio *io, const char *data)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(data);
  len = (signed int)return_value_strlen$1;
  _Bool tmp_if_expr$3;
  if(!(io == ((struct spio *)NULL)))
    tmp_if_expr$3 = io->fd != -1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  const char *tmp_if_expr$2;
  if(!tmp_if_expr$3)
  {
    if(!(io->name == ((const char *)NULL)))
      tmp_if_expr$2 = io->name;

    else
      tmp_if_expr$2 = "???   ";
    sp_message(ctx, 3, "%s: connection closed. can't write data", tmp_if_expr$2);
    return -1;
  }

  else
  {
    log_io_data(ctx, io, data, 0);
    signed int return_value_spio_write_data_raw$4;
    return_value_spio_write_data_raw$4=spio_write_data_raw(ctx, io, (unsigned char *)data, len);
    return return_value_spio_write_data_raw$4;
  }
}

// spio_write_data_raw
// file ../common/spio.c line 587
signed int spio_write_data_raw(struct spctx *ctx, struct spio *io, const unsigned char *buf, signed int len)
{
  signed int r;
  const char *tmp_if_expr$4;
  const char *tmp_if_expr$5;
  if(io->fd == -1)
    return 0;

  else
  {
    io->last_action=time((signed long int *)(void *)0);
    while(len >= 1)
    {
      signed long int return_value_write$1;
      return_value_write$1=write(io->fd, (const void *)buf, (unsigned long int)len);
      r = (signed int)return_value_write$1;
      if(r >= 1)
      {
        buf = buf + (signed long int)r;
        len = len - r;
      }

      else
        if(r == -1)
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          if(*return_value___errno_location$3 == 4)
          {
            signed int return_value_sp_is_quit$2;
            return_value_sp_is_quit$2=sp_is_quit();
            if(!(return_value_sp_is_quit$2 == 0))
              return -1;

            continue;
          }

          close_raw(&io->fd);
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          if(*return_value___errno_location$6 == 11)
          {
            if(!(io->name == ((const char *)NULL)))
              tmp_if_expr$4 = io->name;

            else
              tmp_if_expr$4 = "???   ";
            sp_messagex(ctx, 4, "%s: network write operation timed out", tmp_if_expr$4);
          }

          else
          {
            if(!(io->name == ((const char *)NULL)))
              tmp_if_expr$5 = io->name;

            else
              tmp_if_expr$5 = "???   ";
            sp_message(ctx, 3, "%s: couldn't write data to socket", tmp_if_expr$5);
          }
          return -1;
        }

    }
    return 0;
  }
}

// spio_write_dataf
// file ../common/spio.c line 570
signed int spio_write_dataf(struct spctx *ctx, struct spio *io, const char *fmt, ...)
{
  char buf[4224l];
  void **ap;
  buf[(signed long int)0] = (char)0;
  ap = (void **)&fmt;
  vsnprintf(buf, (unsigned long int)(4096 + 128), fmt, ap);
  ap = ((void **)NULL);
  buf[(signed long int)((4096 + 128) - 1)] = (char)0;
  signed int return_value_spio_write_data$1;
  return_value_spio_write_data$1=spio_write_data(ctx, io, buf);
  return return_value_spio_write_data$1;
}

// strlcat
// file ../common/compat.h line 82
unsigned long int strlcat(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  unsigned long int dlen;
  unsigned long int tmp_post$1;
  do
  {
    tmp_post$1 = n;
    n = n - 1ul;
    if(tmp_post$1 == 0ul)
      break;

    if((signed int)*d == 0)
      break;

    d = d + 1l;
  }
  while((_Bool)1);
  dlen = (unsigned long int)(d - dst);
  n = siz - dlen;
  unsigned long int return_value_strlen$2;
  char *tmp_post$3;
  if(n == 0ul)
  {
    return_value_strlen$2=strlen(s);
    return dlen + return_value_strlen$2;
  }

  else
  {
    for( ; !((signed int)*s == 0); s = s + 1l)
      if(!(n == 1ul))
      {
        tmp_post$3 = d;
        d = d + 1l;
        *tmp_post$3 = *s;
        n = n - 1ul;
      }

    *d = (char)0;
    return dlen + (unsigned long int)(s - src);
  }
}

// strlcpy
// file ../common/compat.h line 86
unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  char *tmp_post$1;
  const char *tmp_post$2;
  if(!(n == 0ul))
  {
    n = n - 1ul;
    if(!(n == 0ul))
      do
      {
        tmp_post$1 = d;
        d = d + 1l;
        tmp_post$2 = s;
        s = s + 1l;
        *tmp_post$1 = *tmp_post$2;
        if((signed int)*tmp_post$1 == 0)
          break;

        n = n - 1ul;
      }
      while(!(n == 0ul));

  }

  const char *tmp_post$3;
  if(n == 0ul)
  {
    if(!(siz == 0ul))
      *d = (char)0;

    do
    {
      tmp_post$3 = s;
      s = s + 1l;
      if(*tmp_post$3 == 0)
        break;

    }
    while((_Bool)1);
  }

  return (unsigned long int)((s - src) - (signed long int)1);
}

// strlwr
// file ../common/compat.c line 89
char * strlwr(char *s)
{
  char *t = s;
  while(!(*t == 0))
  {
    signed int return_value_tolower$1;
    return_value_tolower$1=tolower((signed int)*t);
    *t = (char)return_value_tolower$1;
    t = t + 1l;
  }
  return s;
}

// strtob
// file ../common/stringx.h line 51
signed int strtob(const char *str)
{
  signed int return_value_strcasecmp$1;
  return_value_strcasecmp$1=strcasecmp(str, "0");
  _Bool tmp_if_expr$3;
  signed int return_value_strcasecmp$2;
  if(return_value_strcasecmp$1 == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strcasecmp$2=strcasecmp(str, "no");
    tmp_if_expr$3 = return_value_strcasecmp$2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  signed int return_value_strcasecmp$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_strcasecmp$4=strcasecmp(str, "false");
    tmp_if_expr$5 = return_value_strcasecmp$4 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_strcasecmp$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_strcasecmp$6=strcasecmp(str, "f");
    tmp_if_expr$7 = return_value_strcasecmp$6 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$9;
  signed int return_value_strcasecmp$8;
  if(tmp_if_expr$7)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value_strcasecmp$8=strcasecmp(str, "off");
    tmp_if_expr$9 = return_value_strcasecmp$8 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$12;
  signed int return_value_strcasecmp$11;
  _Bool tmp_if_expr$14;
  signed int return_value_strcasecmp$13;
  _Bool tmp_if_expr$16;
  signed int return_value_strcasecmp$15;
  _Bool tmp_if_expr$18;
  signed int return_value_strcasecmp$17;
  if(tmp_if_expr$9)
    return 0;

  else
  {
    signed int return_value_strcasecmp$10;
    return_value_strcasecmp$10=strcasecmp(str, "1");
    if(return_value_strcasecmp$10 == 0)
      tmp_if_expr$12 = (_Bool)1;

    else
    {
      return_value_strcasecmp$11=strcasecmp(str, "yes");
      tmp_if_expr$12 = return_value_strcasecmp$11 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$12)
      tmp_if_expr$14 = (_Bool)1;

    else
    {
      return_value_strcasecmp$13=strcasecmp(str, "true");
      tmp_if_expr$14 = return_value_strcasecmp$13 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$14)
      tmp_if_expr$16 = (_Bool)1;

    else
    {
      return_value_strcasecmp$15=strcasecmp(str, "t");
      tmp_if_expr$16 = return_value_strcasecmp$15 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$16)
      tmp_if_expr$18 = (_Bool)1;

    else
    {
      return_value_strcasecmp$17=strcasecmp(str, "on");
      tmp_if_expr$18 = return_value_strcasecmp$17 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$18)
      return 1;

    else
      return -1;
  }
}

// strupr
// file ../common/compat.c line 102
char * strupr(char *s)
{
  char *t = s;
  while(!(*t == 0))
  {
    signed int return_value_toupper$1;
    return_value_toupper$1=toupper((signed int)*t);
    *t = (char)return_value_toupper$1;
    t = t + 1l;
  }
  return s;
}

// thread_main
// file ../common/smtppass.c line 742
static void * thread_main(void *arg)
{
  struct spthread *thread = (struct spthread *)arg;
  struct spctx *ctx = (struct spctx *)(void *)0;
  signed int processing = 0;
  signed int ret = 0;
  signed int fd;
  siginterrupt(2, 1);
  siginterrupt(15, 1);
  sp_lock();
  fd = thread->fd;
  sp_unlock();
  signed int return_value_sp_is_quit$1;
  return_value_sp_is_quit$1=sp_is_quit();
  _Bool tmp_if_expr$2;
  if(!(return_value_sp_is_quit$1 == 0))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    ctx=init_thread(fd);
    tmp_if_expr$2 = ctx == (struct spctx *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    close(fd);
    ret = -1;
  }

  else
  {
    processing = 1;
    ret=smtp_passthru(ctx);
  }

cleanup:
  ;
  if(!(ctx == ((struct spctx *)NULL)))
  {
    if(processing == 0 && ret == -1)
    {
      if(!(ctx->client.fd == -1))
        spio_write_data(ctx, &ctx->client, "421 Local Error, cannot start thread\r\n");

    }

    done_thread(ctx);
  }

  sp_lock();
  thread->fd = -1;
  sp_unlock();
  return (void *)(ret == 0 ? (unsigned long int)0 : (unsigned long int)1);
}

// trim_end
// file ../common/stringx.h line 48
char * trim_end(char *data)
{
  char *t;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(data);
  t = data + (signed long int)return_value_strlen$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  for( ; !(data >= t); *t = (char)0)
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)t[-1l]]) == 0)
      break;

    t = t - 1l;
  }
  return data;
}

// trim_space
// file ../common/stringx.h line 49
char * trim_space(char *data)
{
  char *return_value_trim_start$1;
  return_value_trim_start$1=trim_start(data);
  data = (char *)return_value_trim_start$1;
  char *return_value_trim_end$2;
  return_value_trim_end$2=trim_end(data);
  return return_value_trim_end$2;
}

// trim_start
// file ../common/stringx.h line 47
char * trim_start(const char *data)
{
  const unsigned short int **return_value___ctype_b_loc$1;
  for( ; !(*data == 0); data = data + 1l)
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*data]) == 0)
      break;

  }
  return (char *)data;
}

// usage
// file proxsmtpd.c line 217
static void usage()
{
  fprintf(stderr, "usage: proxsmtpd [-d debuglevel] [-f configfile] [-p pidfile]\n");
  fprintf(stderr, "       proxsmtpd -v\n");
  exit(2);
}

// vmessage
// file ../common/smtppass.c line 2007
static void vmessage(struct spctx *ctx, signed int level, signed int err, const char *msg, void **ap)
{
  char buf[1024l];
  signed int e;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  e = *return_value___errno_location$1;
  if(!(g_state.daemonized == 0))
  {
    if(level >= 7)
      goto __CPROVER_DUMP_L9;

  }

  else
    if(!(g_state.debug_level >= level))
      goto __CPROVER_DUMP_L9;

  if(!(ctx == ((struct spctx *)NULL)))
    snprintf(buf, (unsigned long int)1024, "%06X: %s%s", ctx->id, msg, err != 0 ? ": " : "");

  else
    snprintf(buf, (unsigned long int)1024, "%s%s", msg, err != 0 ? ": " : "");
  if(!(err == 0))
  {
    sp_lock();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(e);
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(buf);
    strncat(buf, return_value_strerror$2, ((unsigned long int)1024 - return_value_strlen$3) - (unsigned long int)1);
    sp_unlock();
  }

  buf[(signed long int)(1024 - 1)] = (char)0;
  if(!(g_state.daemonized == 0))
    vsyslog(level, buf, ap);

  else
    vwarnx(buf, ap);

__CPROVER_DUMP_L9:
  ;
}

// wait_process
// file proxsmtpd.c line 920
static signed int wait_process(struct spctx *sp, signed int pid, signed int *status)
{
  signed int waits = (signed int)(g_pxstate.timeout.tv_sec * (signed long int)(1000 / 20));
  *status = 0;
  signed int return_value_kill$3;
  signed int *return_value___errno_location$2;
  signed int *return_value___errno_location$5;
  signed int *return_value___errno_location$4;
  while(waits >= 1)
  {
    signed int return_value_waitpid$1;
    return_value_waitpid$1=waitpid(pid, status, 1);
    if(!(return_value_waitpid$1 == 0))
    {
      if(return_value_waitpid$1 == -1)
        goto __CPROVER_DUMP_L4;

    }

    else
    {
      return_value_kill$3=kill(pid, 0);
      if(!(return_value_kill$3 >= 0))
      {
        return_value___errno_location$2=__errno_location();
        if(*return_value___errno_location$2 == 3)
          return 0;

      }

      goto __CPROVER_DUMP_L6;

    __CPROVER_DUMP_L4:
      ;
      return_value___errno_location$5=__errno_location();
      if(!(*return_value___errno_location$5 == 10))
      {
        return_value___errno_location$4=__errno_location();
        if(!(*return_value___errno_location$4 == 3))
        {
          sp_message(sp, 2, "error waiting on process");
          return -1;
        }

      }

    }
    return 0;

  __CPROVER_DUMP_L6:
    ;
    usleep((unsigned int)(20 * 1000));
    waits = waits - 1;
  }
  return -1;
}

