// #anon_enum_J_UNDEFINED=0_J_SUSPICIOUS=1_J_BLOCK=2_J_PASS=3
// file ../include/srvutils.h line 70
enum anonymous_0 { J_UNDEFINED=0, J_SUSPICIOUS=1, J_BLOCK=2, J_PASS=3 };

// #anon_enum_STATUS_GREY=0_STATUS_MATCH=1_STATUS_TRUST=2_STATUS_UNKNOWN=3_STATUS_FAIL=4_STATUS_BLOCK=5
// file ../include/worker.h line 28
enum anonymous_1 { STATUS_GREY=0, STATUS_MATCH=1, STATUS_TRUST=2, STATUS_UNKNOWN=3, STATUS_FAIL=4, STATUS_BLOCK=5 };

// #anon_enum_TYPE_DNSBL=0_TYPE_RHSBL=1_TYPE_DNSWL=2
// file ../include/check_dnsbl.h line 25
enum anonymous_2 { TYPE_DNSBL=0, TYPE_RHSBL=1, TYPE_DNSWL=2 };

// tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]
// file ../include/bloom.h line 56
struct anonymous_23;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]
// file ../include/bloom.h line 62
struct anonymous_22;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#_'filter'||S32'update_q'||U32'_pad0'||*{SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]#}_SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]#_'sync_guard'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'bloom_guard'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'update_guard'||*{S64}_S64_'last_rotate'||*{SYM#tag-dnsbl_s#}_SYM#tag-dnsbl_s#_'dnsbl'||*{SYM#tag-dnsbl_s#}_SYM#tag-dnsbl_s#_'dnswl'||*{SYM#tag-dnsbl_s#}_SYM#tag-dnsbl_s#_'rhsbl'||SYM#tag-#anon#ST[SYM#tag-sockaddr_in#'gross_host'||SYM#tag-sockaddr_in#'sync_host'||SYM#tag-sockaddr_in#'status_host'||SYM#tag-peer_s#'peer'||S32'max_connq'||U32'_pad0'||S64'rotate_interval'||S64'stat_interval'||U32'filter_size'||U32'num_bufs'||*{S8}_S8_'statefile'||S32'loglevel'||S32'syslogfacility'||S32'statlevel'||S32'flags'||S32'checks'||S32'grey_mask'||S32'protocols'||S32'greylist_delay'||SYM#tag-postfix_config_s#'postfix'||SYM#tag-sjsms_config_s#'sjsms'||SYM#tag-blocker_config_s#'blocker'||S32'query_timelimit'||S32'grey_threshold'||S32'block_threshold'||S32'pool_maxthreads'||U32'_pad1'||*{S8}_S8_'grey_reason'||*{S8}_S8_'block_reason'||*{S8}_S8_'pidfile'|]#'config'||*{SYM#tag-#anon#ST[ARR8{S8}_S8_'magic'||*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#_'brq'||U64'lumpsize'||S64'last_rotate'|]#}_SYM#tag-#anon#ST[ARR8{S8}_S8_'magic'||*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#_'brq'||U64'lumpsize'||S64'last_rotate'|]#_'mmap_info'||*{SYM#tag-statefile_info_s#}_SYM#tag-statefile_info_s#_'statefile_info'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'bloommgr'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'syncmgr'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'postfix_server'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'sjsms_server'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'milter_server'|]#'process_parts'||SYM#tag-#anon#ST[S64'startup'||S64'begin'||S64'end'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'mx'||U64'block'||U64'greylist'||U64'match'||U64'trust'||U64'all_block'||U64'all_greylist'||U64'all_match'||U64'all_trust'||F64'block_avg_delay'||F64'greylist_avg_delay'||F64'match_avg_delay'||F64'trust_avg_delay'||F64'block_max_delay'||F64'greylist_max_delay'||F64'match_max_delay'||F64'trust_max_delay'||*{SYM#tag-dnsbl_stat#}_SYM#tag-dnsbl_stat#_'dnsbl_match'|]#'stats'||ARR128{*{SYM#tag-#anon#ST[*{SYM#tag-thread_pool_s#}_SYM#tag-thread_pool_s#_'pool'||S32'definitive'||U32'_pad0'||*{S8}_S8_'name'||*{V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V}_V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V_'init_routine'||*{V}_V_'check_arg'|]#}_SYM#tag-#anon#ST[*{SYM#tag-thread_pool_s#}_SYM#tag-thread_pool_s#_'pool'||S32'definitive'||U32'_pad0'||*{S8}_S8_'name'||*{V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V}_V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V_'init_routine'||*{V}_V_'check_arg'|]#_}_*{SYM#tag-#anon#ST[*{SYM#tag-thread_pool_s#}_SYM#tag-thread_pool_s#_'pool'||S32'definitive'||U32'_pad0'||*{S8}_S8_'name'||*{V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V}_V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V_'init_routine'||*{V}_V_'check_arg'|]#}_SYM#tag-#anon#ST[*{SYM#tag-thread_pool_s#}_SYM#tag-thread_pool_s#_'pool'||S32'definitive'||U32'_pad0'||*{S8}_S8_'name'||*{V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V}_V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V_'init_routine'||*{V}_V_'check_arg'|]#__'checklist'||S32'syslog_open'||U32'_pad1'|]
// file ../include/common.h line 270
struct anonymous_20;

// tag-#anon#ST[*{SYM#tag-dnsbl_s#}_SYM#tag-dnsbl_s#_'dnsbl'||*{S32}_S32_'done'||*{S32}_S32_'timeout'||*{cS8}_cS8_'querystr'||*{*{cS8}_cS8_}_*{cS8}_cS8__'dnslname'||*{SYM#tag-edict_s#}_SYM#tag-edict_s#_'edict'||*{SYM#tag-#anon#ST[*{cS8}_cS8_'name'||S32'definitive'||EN#anon_enum_TYPE_DNSBL=0_TYPE_RHSBL=1_TYPE_DNSWL=2#{U32}_U32_'type'||*{SYM#tag-dnsbl_s#}_SYM#tag-dnsbl_s#_'dnsbase'|]#}_SYM#tag-#anon#ST[*{cS8}_cS8_'name'||S32'definitive'||EN#anon_enum_TYPE_DNSBL=0_TYPE_RHSBL=1_TYPE_DNSWL=2#{U32}_U32_'type'||*{SYM#tag-dnsbl_s#}_SYM#tag-dnsbl_s#_'dnsbase'|]#_'check_info'|]
// file ../include/check_dnsbl.h line 38
struct anonymous_38;

// tag-#anon#ST[*{SYM#tag-msgqueue_s#}_SYM#tag-msgqueue_s#_'inq'||*{SYM#tag-msgqueue_s#}_SYM#tag-msgqueue_s#_'outq'|]
// file ../include/msgqueue.h line 45
struct anonymous_28;

// tag-#anon#ST[*{SYM#tag-thread_pool_s#}_SYM#tag-thread_pool_s#_'pool'||S32'definitive'||U32'_pad0'||*{S8}_S8_'name'||*{V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V}_V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V_'init_routine'||*{V}_V_'check_arg'|]
// file ../include/common.h line 256
struct anonymous_42;

// tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]
// file ../include/bloom.h line 48
struct anonymous_24;

// tag-#anon#ST[*{U64}_U64_'thread'|]
// file ../include/common.h line 239
struct anonymous_40;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_12;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_10;

// tag-#anon#ST[*{V}_V_'state'||*{S32(...)->S32}_S32(...)->S32_'cleanup'||SYM#tag-watchdog_s#'watchdog'|]
// file ../include/thread_pool.h line 68
struct anonymous_32;

// tag-#anon#ST[*{cS8}_cS8_'name'||S32'definitive'||EN#anon_enum_TYPE_DNSBL=0_TYPE_RHSBL=1_TYPE_DNSWL=2#{U32}_U32_'type'||*{SYM#tag-dnsbl_s#}_SYM#tag-dnsbl_s#_'dnsbase'|]
// file ../include/check_dnsbl.h line 28
struct anonymous_37;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_36;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_3;

// tag-#anon#ST[ARR8{S8}_S8_'magic'||*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#_'brq'||U64'lumpsize'||S64'last_rotate'|]
// file ../include/bloom.h line 69
struct anonymous_44;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_25;

// tag-#anon#ST[S32'buffer'||U32'index'||ARR32{U32}_U32_'filter'|]
// file ../include/syncmgr.h line 49
struct anonymous_14;

// tag-#anon#ST[S32'count'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'mx'|]
// file ../include/thread_pool.h line 34
struct anonymous;

// tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]
// file ../include/thread_pool.h line 77
struct anonymous_33;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_6;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_9;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_8;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_5;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_7;

// tag-#anon#ST[S32'type'||U32'length'|]
// file ../include/syncmgr.h line 43
struct anonymous_16;

// tag-#anon#ST[S64'mtype'||*{V}_V_'result'|]
// file ../include/srvutils.h line 93
struct anonymous_34;

// tag-#anon#ST[S64'mtype'||ARR1024{S8}_S8_'mtext'|]
// file ../include/srvutils.h line 81
struct anonymous_19;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_11;

// tag-#anon#ST[S64'startup'||S64'begin'||S64'end'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'mx'||U64'block'||U64'greylist'||U64'match'||U64'trust'||U64'all_block'||U64'all_greylist'||U64'all_match'||U64'all_trust'||F64'block_avg_delay'||F64'greylist_avg_delay'||F64'match_avg_delay'||F64'trust_avg_delay'||F64'block_max_delay'||F64'greylist_max_delay'||F64'match_max_delay'||F64'trust_max_delay'||*{SYM#tag-dnsbl_stat#}_SYM#tag-dnsbl_stat#_'dnsbl_match'|]
// file ../include/stats.h line 33
struct anonymous_35;

// tag-#anon#ST[SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'bloommgr'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'syncmgr'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'postfix_server'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'sjsms_server'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'milter_server'|]
// file ../include/common.h line 245
struct anonymous_41;

// tag-#anon#ST[SYM#tag-#anon#ST[U32'h0'||U32'h1'||U32'h2'||U32'h3'||U32'h4'||U32'h5'||U32'h6'||U32'h7'|]#'digest'|]
// file ../include/syncmgr.h line 56
struct anonymous_15;

// tag-#anon#ST[SYM#tag-sockaddr_in#'gross_host'||SYM#tag-sockaddr_in#'sync_host'||SYM#tag-sockaddr_in#'status_host'||SYM#tag-peer_s#'peer'||S32'max_connq'||U32'_pad0'||S64'rotate_interval'||S64'stat_interval'||U32'filter_size'||U32'num_bufs'||*{S8}_S8_'statefile'||S32'loglevel'||S32'syslogfacility'||S32'statlevel'||S32'flags'||S32'checks'||S32'grey_mask'||S32'protocols'||S32'greylist_delay'||SYM#tag-postfix_config_s#'postfix'||SYM#tag-sjsms_config_s#'sjsms'||SYM#tag-blocker_config_s#'blocker'||S32'query_timelimit'||S32'grey_threshold'||S32'block_threshold'||S32'pool_maxthreads'||U32'_pad1'||*{S8}_S8_'grey_reason'||*{S8}_S8_'block_reason'||*{S8}_S8_'pidfile'|]
// file ../include/common.h line 183
struct anonymous_21;

// tag-#anon#ST[U16'msglen'||U16'sender'||U16'recipient'||U16'client_address'||ARR1024{S8}_S8_'message'|]
// file ../include/proto_sjsms.h line 28
struct anonymous_30;

// tag-#anon#ST[U16'msgtype'||U16'msglen'||ARR1024{S8}_S8_'message'|]
// file ../include/proto_sjsms.h line 44
struct anonymous_31;

// tag-#anon#ST[U32'array_index'||U32'intra_index'|]
// file ../include/bloom.h line 42
struct anonymous_39;

// tag-#anon#ST[U32'filter_size'||S32'num_bufs'|]
// file ../include/syncmgr.h line 61
struct anonymous_17;

// tag-#anon#ST[U32'h0'||U32'h1'||U32'h2'||U32'h3'||U32'h4'||U32'h5'||U32'h6'||U32'h7'|]
// file ../include/sha256.h line 38
struct anonymous_18;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_4;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_13;

// tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous_43;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_29;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_26;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_27;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-apattern
// file /usr/include/ares.h line 229
struct apattern;

// tag-ares_channeldata
// file /usr/include/ares.h line 272
struct ares_channeldata;

// tag-ares_options
// file /usr/include/ares.h line 248
struct ares_options;

// tag-blocker_config_s
// file ../include/common.h line 170
struct blocker_config_s;

// tag-check_match_s
// file ../include/worker.h line 44
struct check_match_s;

// tag-chkresult_s
// file ../include/worker.h line 34
struct chkresult_s;

// tag-client_info_s
// file ../include/worker.h line 72
struct client_info_s;

// tag-configlist_s
// file ../include/conf.h line 126
struct configlist_s;

// tag-dnsbl_s
// file ../include/common.h line 219
struct dnsbl_s;

// tag-dnsbl_stat
// file ../include/stats.h line 24
struct dnsbl_stat;

// tag-edict_message_s
// file ../include/thread_pool.h line 100
struct edict_message_s;

// tag-edict_s
// file ../include/thread_pool.h line 52
struct edict_s;

// tag-final_status_s
// file ../include/worker.h line 64
struct final_status_s;

// tag-grey_tuple_s
// file ../include/worker.h line 82
struct grey_tuple_s;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-msg_s
// file ../include/msgqueue.h line 23
struct msg_s;

// tag-msgqueue_s
// file ../include/msgqueue.h line 31
struct msgqueue_s;

// tag-params_s
// file ../include/conf.h line 120
struct params_s;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-peer_s
// file ../include/common.h line 147
struct peer_s;

// tag-pool_ctx_s
// file ../include/thread_pool.h line 84
struct pool_ctx_s;

// tag-postfix_config_s
// file ../include/common.h line 164
struct postfix_config_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-querylog_entry_s
// file ../include/worker.h line 51
struct querylog_entry_s;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sjsms_config_s
// file ../include/common.h line 156
struct sjsms_config_s;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-statefile_info_s
// file ../include/common.h line 265
struct statefile_info_s;

// tag-thread_pool_s
// file ../include/thread_pool.h line 27
struct thread_pool_s;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tmout_action_s
// file ../include/common.h line 231
struct tmout_action_s;

// tag-watchdog_s
// file ../include/thread_pool.h line 61
struct watchdog_s;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// Malloc
// file ../include/srvutils.h line 113
void * Malloc(unsigned long int size);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// a_delim_b
// file conf.c line 239
signed int a_delim_b(char *buffer, char delim, char **stra, char **strb);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// add_config_item
// file conf.c line 95
signed int add_config_item(struct configlist_s **current, const char *name, const char *value, struct params_s *params, signed int is_default);
// add_dnsbl
// file ../include/check_dnsbl.h line 49
signed int add_dnsbl(struct dnsbl_s **current, const char *name, signed int weight);
// add_filter
// file bloom.c line 309
struct anonymous_24 * add_filter(struct anonymous_24 *lvalue, const struct anonymous_24 *rvalue);
// add_mask
// file bloom.c line 92
unsigned int add_mask(unsigned int intra_index);
// addrinfo_callback
// file check_dnsbl.c line 108
static void addrinfo_callback(void *arg, signed int status, signed int timeouts, struct hostent *host);
// advance_bloom_ring_queue
// file bloom.c line 366
struct anonymous_22 * advance_bloom_ring_queue(struct anonymous_22 *brq);
// ares_cancel
// file /usr/include/ares.h line 320
void ares_cancel(struct ares_channeldata *);
// ares_destroy
// file /usr/include/ares.h line 318
void ares_destroy(struct ares_channeldata *);
// ares_fds
// file /usr/include/ares.h line 385
signed int ares_fds(struct ares_channeldata *, struct anonymous_36 *, struct anonymous_36 *);
// ares_gethostbyname
// file /usr/include/ares.h line 360
void ares_gethostbyname(struct ares_channeldata *, const char *, signed int, void (*)(void *, signed int, signed int, struct hostent *), void *);
// ares_init_options
// file /usr/include/ares.h line 305
signed int ares_init_options(struct ares_channeldata **, struct ares_options *, signed int);
// ares_process
// file /usr/include/ares.h line 397
void ares_process(struct ares_channeldata *, struct anonymous_36 *, struct anonymous_36 *);
// ares_timeout
// file /usr/include/ares.h line 393
struct timeval * ares_timeout(struct ares_channeldata *, struct timeval *, struct timeval *);
// array_index
// file bloom.c line 27
struct anonymous_39 array_index(unsigned int bit_index);
// assemble_mapresult
// file worker_sjsms.c line 58
char * assemble_mapresult(char *template, char *reason);
// assemble_response
// file worker_postfix.c line 35
char * assemble_response(char *result, unsigned long int len, char *template, char *reason);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// block_delay_update
// file ../include/stats.h line 62
double block_delay_update(double d);
// blocker
// file check_blocker.c line 34
signed int blocker(struct thread_pool_s *info, struct anonymous_32 *thread_ctx, struct edict_s *edict);
// blocker_init
// file ../include/check_blocker.h line 22
void blocker_init(struct anonymous_33 *limits);
// bloom_error_rate
// file bloom.c line 278
double bloom_error_rate(unsigned int n, unsigned int k, unsigned int m);
// bloom_required_size
// file bloom.c line 284
unsigned int bloom_required_size(double c, unsigned int k, unsigned int n);
// bloom_ring_queue_next_index
// file bloom.c line 356
unsigned int bloom_ring_queue_next_index(struct anonymous_22 *brq);
// bloommgr
// file bloommgr.c line 57
static void * bloommgr(void *arg);
// bloommgr_init
// file bloommgr.c line 124
void bloommgr_init();
// build_bloom_ring
// file srvutils.c line 224
struct anonymous_22 * build_bloom_ring(unsigned int num, unsigned int num_bits);
// buildquerystr
// file proto_sjsms.c line 29
char * buildquerystr(const char *sender, const char *rcpt, const char *caddr, const char *helo);
// bzero
// file /usr/include/string.h line 458
extern void bzero(void *, unsigned long int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// calm_client
// file worker_sjsms.c line 150
void calm_client(void *arg, signed int timeused);
// check_pidfile
// file srvutils.c line 421
void check_pidfile(void);
// check_request
// file worker.c line 507
signed int check_request(struct grey_tuple_s *tuple);
// chomp
// file utils.c line 165
signed int chomp(char *buffer);
// cleanup_dnsblc
// file check_dnsbl.c line 34
signed int cleanup_dnsblc(void *state);
// cleanup_random
// file check_random.c line 33
signed int cleanup_random(void *state);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// configure_grossd
// file gross.c line 107
void configure_grossd(struct configlist_s *config);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// connected
// file srvutils.c line 145
signed int connected(struct peer_s *peer);
// convert_int32_big_endian
// file sha256.c line 103
void convert_int32_big_endian(unsigned int *num);
// convert_int32_little_endian
// file sha256.c line 94
void convert_int32_little_endian(unsigned int *num);
// convert_int64_big_endian
// file sha256.c line 86
void convert_int64_big_endian(unsigned long int *num);
// convert_int64_little_endian
// file sha256.c line 75
void convert_int64_little_endian(unsigned long int *num);
// copy_bloom_filter
// file bloom.c line 218
struct anonymous_24 * copy_bloom_filter(struct anonymous_24 *filter, signed int empty);
// create_bloom_filter
// file bloom.c line 179
struct anonymous_24 * create_bloom_filter(unsigned int num_bits);
// create_bloom_filter_group
// file bloom.c line 241
struct anonymous_23 * create_bloom_filter_group(unsigned int num, unsigned int num_bits);
// create_bloom_ring_queue
// file bloom.c line 327
struct anonymous_22 * create_bloom_ring_queue(unsigned int num, unsigned int num_bits);
// create_pidfile
// file srvutils.c line 399
void create_pidfile(void);
// create_queue
// file msgqueue.c line 187
struct msgqueue_s * create_queue(void);
// create_statefile
// file srvutils.c line 186
void create_statefile(void);
// create_thread
// file srvutils.c line 502
void * create_thread(struct anonymous_40 *tinfo, signed int detach, void * (*routine)(void *), void *arg);
// create_thread::routine_object
//
void * routine_object(void *);
// create_thread_pool
// file thread_pool.c line 208
struct thread_pool_s * create_thread_pool(const char *name, signed int (*routine)(struct thread_pool_s *, struct anonymous_32 *, struct edict_s *), struct anonymous_33 *limits, void *arg);
// create_thread_pool::routine_object
//
signed int routine_object(struct thread_pool_s *, struct anonymous_32 *, struct edict_s *);
// ctime_r
// file /usr/include/time.h line 276
extern char * ctime_r(const signed long int *, char *);
// daemon_fatal
// file srvutils.c line 124
void daemon_fatal(const char *reason);
// daemon_shutdown
// file srvutils.c line 97
void daemon_shutdown(signed int return_code, const char *fmt, ...);
// daemonize
// file srvutils.c line 440
void daemonize(void);
// date_fmt
// file srvutils.c line 552
unsigned long int date_fmt(char *msg, unsigned long int len);
// debug_print_array_index
// file bloom.c line 69
void debug_print_array_index(struct anonymous_39 index, signed int with_newline);
// debug_print_bit_up
// file bloom.c line 77
void debug_print_bit_up(unsigned int *array, unsigned int bit_index, signed int with_newline);
// debug_print_bits
// file bloom.c line 53
void debug_print_bits(signed int value, signed int with_newline);
// debug_print_digest
// file sha256.c line 111
void debug_print_digest(struct anonymous_18 digest, signed int with_newline);
// debug_print_filter
// file bloom.c line 38
void debug_print_filter(struct anonymous_24 *filter, signed int with_newline);
// debug_print_ring_queue
// file bloom.c line 409
void debug_print_ring_queue(struct anonymous_22 *brq, signed int with_newline);
// default_config
// file conf.c line 273
struct configlist_s * default_config(void);
// delay
// file msgqueue.c line 142
void * delay(void *arg);
// disable_delay
// file msgqueue.c line 253
signed int disable_delay(signed int msqid);
// dnsbl_init
// file ../include/check_dnsbl.h line 52
void dnsbl_init(struct anonymous_37 *check_info, struct anonymous_33 *limits);
// dnsbl_stats
// file ../include/stats.h line 68
char * dnsbl_stats(char *buf, signed int size);
// dnsblc
// file check_dnsbl.c line 207
signed int dnsblc(struct thread_pool_s *info, struct anonymous_32 *thread_ctx, struct edict_s *edict);
// dtoh
// file syncmgr.c line 93
struct anonymous_18 dtoh(struct anonymous_18 digest);
// dton
// file syncmgr.c line 76
struct anonymous_18 dton(struct anonymous_18 digest);
// edict_get
// file thread_pool.c line 286
struct edict_s * edict_get(signed int forget);
// edict_reference
// file thread_pool.c line 253
void edict_reference(struct edict_s *edict);
// edict_unlink
// file ../include/thread_pool.h line 115
void edict_unlink(struct edict_s *edict);
// enable_delay
// file msgqueue.c line 259
signed int enable_delay(signed int msqid);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
extern double exp(double);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// finalize
// file worker.c line 597
void finalize(struct final_status_s *status);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// force_peer_aggregate
// file syncmgr.c line 211
signed int force_peer_aggregate(struct peer_s *peer);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_client_info
// file worker.c line 46
void free_client_info(struct client_info_s *arg);
// gconf
// file ../include/conf.h line 136
const char * gconf(struct configlist_s *config, const char *name);
// get_bit
// file bloom.c line 99
unsigned int get_bit(unsigned int *array, unsigned int bit_index);
// get_delay_queue
// file ../include/msgqueue.h line 52
signed int get_delay_queue(struct timespec *ts);
// get_msg
// file ../include/msgqueue.h line 59
unsigned long int get_msg(signed int msqid, void *msgp, unsigned long int maxsize, signed int msgflag);
// get_msg_raw
// file msgqueue.c line 582
struct msg_s * get_msg_raw(struct msgqueue_s *mq, signed int timeout);
// get_msg_timed
// file ../include/msgqueue.h line 60
unsigned long int get_msg_timed(signed int msqid, void *msgp, unsigned long int maxsize, signed int msgflag, signed int timeout);
// get_queue
// file msgqueue.c line 207
signed int get_queue(void);
// get_srvstatus
// file srvstatus.c line 54
void get_srvstatus(char *buf, signed int len);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// grey_mask
// file worker.c line 116
char * grey_mask(char *ipstr);
// greylist_delay_update
// file ../include/stats.h line 63
double greylist_delay_update(double d);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// in_queue_len
// file msgqueue.c line 683
unsigned long int in_queue_len(signed int msgid);
// increment_dnsbl_tolerance_counters
// file ../include/check_dnsbl.h line 51
signed int increment_dnsbl_tolerance_counters(struct dnsbl_s *dnsbl);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init_bit_array
// file bloom.c line 121
void init_bit_array(unsigned int *array, unsigned int size);
// init_stats
// file ../include/stats.h line 58
void init_stats();
// init_status
// file worker.c line 527
struct final_status_s * init_status(const char *proto);
// initgroups
// file /usr/include/grp.h line 200
extern signed int initgroups(const char *, unsigned int);
// initialize_context
// file gross.c line 59
struct anonymous_20 * initialize_context();
// insert_absolute_bloom_ring_queue
// file bloom.c line 427
void insert_absolute_bloom_ring_queue(struct anonymous_22 *brq, unsigned int *buffer, signed int size, signed int index, unsigned int buf_index);
// insert_bit
// file bloom.c line 110
void insert_bit(unsigned int *array, unsigned int bit_index);
// insert_digest
// file bloom.c line 139
void insert_digest(struct anonymous_24 *filter, struct anonymous_18 digest);
// insert_digest_bloom_ring_queue
// file bloom.c line 341
void insert_digest_bloom_ring_queue(struct anonymous_22 *brq, struct anonymous_18 digest);
// insert_digest_to_group_member
// file bloom.c line 169
void insert_digest_to_group_member(struct anonymous_23 *filter_group, unsigned int member_index, struct anonymous_18 digest);
// instant_msg
// file ../include/msgqueue.h line 57
signed int instant_msg(signed int msqid, void *omsgp, unsigned long int msgsz, signed int msgflg);
// int_to_index
// file bloom.c line 133
unsigned int int_to_index(unsigned int value, unsigned int mask);
// ipstr
// file srvutils.c line 589
char * ipstr(struct sockaddr_in *saddr);
// is_in_array
// file bloom.c line 154
signed int is_in_array(struct anonymous_24 *filter, struct anonymous_18 digest);
// is_in_ring_queue
// file bloom.c line 349
signed int is_in_ring_queue(struct anonymous_22 *brq, struct anonymous_18 digest);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// little_endian
// file sha256.c line 53
signed int little_endian();
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// log_close
// file srvutils.c line 618
signed int log_close(void);
// log_open
// file srvutils.c line 603
signed int log_open(void);
// log_put
// file srvutils.c line 538
signed int log_put(const char *msg);
// log_stats
// file ../include/stats.h line 60
struct anonymous_35 log_stats();
// logstr
// file srvutils.c line 36
signed int logstr(signed int level, const char *fmt, ...);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mappingstr
// file worker_sjsms.c line 33
signed int mappingstr(const char *from, char *to, unsigned long int len);
// match_delay_update
// file ../include/stats.h line 64
double match_delay_update(double d);
// maxparams
// file conf.c line 53
unsigned int maxparams(const char *name);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// min
// file syncmgr.c line 33
signed int min(signed int x, signed int y);
// minparams
// file conf.c line 74
unsigned int minparams(const char *name);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mrproper
// file gross.c line 515
void mrproper(signed int signo);
// ms_diff
// file utils.c line 206
signed int ms_diff(struct timespec *t1, struct timespec *t2);
// mstotimespec
// file utils.c line 249
void mstotimespec(signed int mseconds, struct timespec *ts);
// msync
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 89
extern signed int msync(void *, unsigned long int, signed int);
// multivalue
// file conf.c line 32
signed int multivalue(const char *name);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// namevalueparams
// file conf.c line 176
signed int namevalueparams(char *buffer, char **name, char **value, struct params_s **params);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// new_address
// file srvutils.c line 151
void * new_address(void *val1, unsigned long int val2);
// noop
// file gross.c line 506
void noop(signed int signo);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// optimal_size
// file bloom.c line 292
unsigned int optimal_size(unsigned int n, double c);
// out_queue_len
// file msgqueue.c line 695
unsigned long int out_queue_len(signed int msgid);
// p_convert_int32_to_big_endian_object
//
void p_convert_int32_to_big_endian_object(unsigned int *);
// p_convert_int64_to_big_endian_object
//
void p_convert_int64_to_big_endian_object(unsigned long int *);
// parse_postfix
// file worker_postfix.c line 141
signed int parse_postfix(struct client_info_s *client_info, struct grey_tuple_s *grey_tuple);
// parsequery
// file worker_sjsms.c line 86
struct grey_tuple_s * parsequery(const char *request);
// peek_msg_timestamp
// file msgqueue.c line 550
struct timespec * peek_msg_timestamp(struct msgqueue_s *mq);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// postfix_connection
// file worker_postfix.c line 62
signed int postfix_connection(struct thread_pool_s *info, struct anonymous_32 *thread_ctx, struct edict_s *edict);
// postfix_server
// file worker_postfix.c line 211
static void * postfix_server(void *arg);
// postfix_server_init
// file worker.c line 34
void postfix_server_init();
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_parameter
// file worker.c line 468
signed int process_parameter(struct grey_tuple_s *tuple, const char *str);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 377
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_26 *, const union anonymous_29 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_26 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_26 *, union anonymous_27 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_26 *, union anonymous_27 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_27 *, const union anonymous_29 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_27 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_27 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_3 *, struct anonymous_3 *);
// put_msg
// file ../include/msgqueue.h line 56
signed int put_msg(signed int msqid, void *omsgp, unsigned long int msgsz, signed int msgflg);
// put_msg_raw
// file msgqueue.c line 378
signed int put_msg_raw(struct msgqueue_s *mq, struct msg_s *msg);
// query_clearance
// file check_dnsbl.c line 71
signed int query_clearance(struct dnsbl_s *dnsbl);
// querylogwrite
// file worker.c line 626
void querylogwrite(struct querylog_entry_s *q);
// queue_freeze
// file ../include/msgqueue.h line 63
signed int queue_freeze(signed int msqid);
// queue_realloc
// file msgqueue.c line 60
void queue_realloc(void);
// queue_thaw
// file ../include/msgqueue.h line 64
signed int queue_thaw(signed int msqid);
// queuebyid
// file msgqueue.c line 82
struct msgqueue_s * queuebyid(signed int msqid);
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// random_init
// file ../include/check_random.h line 22
void random_init(struct anonymous_33 *limits);
// randomc
// file check_random.c line 43
signed int randomc(struct thread_pool_s *info, struct anonymous_32 *thread_ctx, struct edict_s *edict);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_config
// file ../include/conf.h line 135
struct configlist_s * read_config(const char *filename);
// readline
// file utils.c line 33
signed int readline(signed int fd, void *vptr, unsigned long int maxlen);
// readn
// file utils.c line 67
signed long int readn(signed int fd, void *vptr, unsigned long int n);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// record_config_item
// file conf.c line 117
signed int record_config_item(struct configlist_s **config, const char *name, const char *value, struct params_s *params);
// record_match
// file worker.c line 544
void record_match(struct querylog_entry_s *q, struct chkresult_s *r);
// recv_config_sync
// file syncmgr.c line 348
signed int recv_config_sync(struct peer_s *peer);
// recv_oper_sync
// file syncmgr.c line 323
signed int recv_oper_sync(struct peer_s *peer);
// recv_startup_sync
// file syncmgr.c line 294
signed int recv_startup_sync(struct peer_s *peer);
// recv_sync_msg
// file syncmgr.c line 245
signed int recv_sync_msg(struct peer_s *peer);
// recv_syncs
// file syncmgr.c line 222
void * recv_syncs(void *arg);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, struct sockaddr *, unsigned int *);
// recvquery
// file proto_sjsms.c line 80
signed int recvquery(struct anonymous_31 *message, struct anonymous_30 *request);
// recvquerystr
// file proto_sjsms.c line 89
char * recvquerystr(struct anonymous_31 *message);
// register_check
// file srvutils.c line 570
void register_check(struct thread_pool_s *pool, signed int definitive);
// release_bloom_filter
// file bloom.c line 202
void release_bloom_filter(struct anonymous_24 *filter);
// release_bloom_filter_group
// file bloom.c line 263
void release_bloom_filter_group(struct anonymous_23 *filter_group);
// release_bloom_ring_queue
// file srvutils.c line 380
void release_bloom_ring_queue(struct anonymous_22 *brq);
// release_queue
// file msgqueue.c line 490
signed int release_queue(signed int msqid);
// request_new
// file worker.c line 89
struct grey_tuple_s * request_new();
// request_reference
// file worker.c line 103
void request_reference(struct grey_tuple_s *request);
// request_unlink
// file worker.c line 61
void request_unlink(struct grey_tuple_s *request);
// respond
// file utils.c line 154
signed long int respond(signed int fd, const char *response);
// reverse_inet_addr
// file check_dnsbl.c line 152
signed int reverse_inet_addr(char *ipstr);
// rotate
// file bloommgr.c line 30
static void * rotate(void *arg);
// rotate_bloom_ring_queue
// file bloom.c line 375
struct anonymous_22 * rotate_bloom_ring_queue(struct anonymous_22 *brq);
// rotate_right
// file sha256.c line 46
unsigned int rotate_right(unsigned int num, signed int amount);
// sctoh
// file syncmgr.c line 121
struct anonymous_17 sctoh(struct anonymous_17 *sync);
// scton
// file syncmgr.c line 110
struct anonymous_17 scton(struct anonymous_17 *sync);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_36 *, struct anonymous_36 *, struct anonymous_36 *, struct timeval *);
// sem_init
// file /usr/include/semaphore.h line 36
extern signed int sem_init(union anonymous_43 *, signed int, unsigned int);
// sem_post
// file /usr/include/semaphore.h line 69
extern signed int sem_post(union anonymous_43 *);
// sem_wait
// file /usr/include/semaphore.h line 54
extern signed int sem_wait(union anonymous_43 *);
// send_filters
// file syncmgr.c line 382
void send_filters(struct peer_s *peer);
// send_oper_sync
// file ../include/syncmgr.h line 75
signed int send_oper_sync(struct peer_s *peer, struct anonymous_15 *sync);
// send_result
// file thread_pool.c line 336
void send_result(struct edict_s *edict, void *result);
// send_sjsms_msg
// file proto_sjsms.c line 100
signed int send_sjsms_msg(signed int fd, struct sockaddr_in *gserv, struct anonymous_31 *message);
// send_startup_sync
// file syncmgr.c line 154
signed int send_startup_sync(struct peer_s *peer, struct anonymous_14 *sync);
// send_sync_config
// file syncmgr.c line 145
signed int send_sync_config(struct peer_s *peer, struct anonymous_17 *sync);
// send_update_msg_as_oper_sync
// file syncmgr.c line 184
signed int send_update_msg_as_oper_sync(void *arg);
// send_update_to_peer
// file syncmgr.c line 132
signed int send_update_to_peer(struct peer_s *peer, void *ptr, signed int size);
// senderrormsg
// file proto_sjsms.c line 40
signed int senderrormsg(signed int fd, struct sockaddr_in *gserv, const char *fmt, ...);
// sendquery
// file proto_sjsms.c line 57
signed int sendquery(signed int fd, struct sockaddr_in *gserv, struct anonymous_30 *request);
// sendquerystr
// file proto_sjsms.c line 69
signed int sendquerystr(signed int fd, struct sockaddr_in *gserv, const char *querystr);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, struct sockaddr *, unsigned int);
// set_delay
// file msgqueue.c line 347
signed int set_delay(signed int msqid, struct timespec *ts);
// set_delay_status
// file msgqueue.c line 265
signed int set_delay_status(signed int msqid, signed int state);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// setup_signal_handlers
// file gross.c line 542
void setup_signal_handlers(void);
// sha256
// file sha256.c line 120
struct anonymous_18 sha256(unsigned char *message, unsigned long int size);
// sha256_string
// file sha256.c line 220
struct anonymous_18 sha256_string(char *message);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_3 *, signed int);
// sigdelset
// file /usr/include/signal.h line 224
extern signed int sigdelset(struct anonymous_3 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_3 *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_3 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sjsms_connection
// file worker_sjsms.c line 167
signed int sjsms_connection(struct thread_pool_s *info, struct anonymous_32 *thread_ctx, struct edict_s *edict);
// sjsms_server
// file worker_sjsms.c line 299
static void * sjsms_server(void *arg);
// sjsms_server_init
// file worker.c line 35
void sjsms_server_init();
// sjsms_to_host_order
// file proto_sjsms.c line 114
signed int sjsms_to_host_order(struct anonymous_31 *message);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// srvstatus
// file srvstatus.c line 109
static void * srvstatus(void *arg);
// srvstatus_init
// file gross.c line 56
void srvstatus_init();
// sstoh
// file syncmgr.c line 59
struct anonymous_14 sstoh(struct anonymous_14 ss);
// sston
// file syncmgr.c line 42
struct anonymous_14 sston(struct anonymous_14 ss);
// start_syncer
// file syncmgr.c line 375
void start_syncer(void *arg);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// stat_add_dnsbl
// file ../include/stats.h line 67
signed int stat_add_dnsbl(const char *name);
// stat_dnsbl_match
// file stats.c line 77
unsigned long int stat_dnsbl_match(const char *name);
// statstr
// file srvutils.c line 67
signed int statstr(signed int level, const char *fmt, ...);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// submit_job
// file ../include/thread_pool.h line 109
signed int submit_job(struct thread_pool_s *pool, struct edict_s *edict);
// swap_bytes
// file sha256.c line 66
void swap_bytes(unsigned char *a, unsigned char *b);
// sync_aggregate
// file bloom.c line 445
void sync_aggregate(struct anonymous_22 *brq);
// synchronize
// file syncmgr.c line 418
signed int synchronize(struct peer_s *peer, signed int syncfd);
// syncmgr
// file syncmgr.c line 533
static void * syncmgr(void *arg);
// syncmgr_init
// file gross.c line 54
void syncmgr_init();
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// test_thread
// file srvstatus.c line 43
signed int test_thread(unsigned long int *thread);
// test_tuple
// file worker.c line 190
signed int test_tuple(struct final_status_s *final, struct grey_tuple_s *request, struct tmout_action_s *ta);
// thread_pool
// file thread_pool.c line 43
static void * thread_pool(void *arg);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolerate_dnsbl
// file check_dnsbl.c line 84
signed int tolerate_dnsbl(struct dnsbl_s *dnsbl);
// trim
// file utils.c line 186
signed int trim(char **buf);
// trust_delay_update
// file ../include/stats.h line 65
double trust_delay_update(double d);
// try_available
// file msgqueue.c line 530
struct msgqueue_s * try_available(void);
// try_match
// file worker.c line 517
char * try_match(const char *matcher, const char *matchee);
// ts_diff
// file utils.c line 229
signed int ts_diff(struct timespec *diff, struct timespec *t1, struct timespec *t2);
// ts_sum
// file utils.c line 215
signed int ts_sum(struct timespec *sum, struct timespec *t1, struct timespec *t2);
// tstotv
// file utils.c line 263
void tstotv(struct timespec *ts, struct timeval *tv);
// tvtots
// file utils.c line 256
void tvtots(struct timeval *tv, struct timespec *ts);
// unfold
// file worker_sjsms.c line 122
struct grey_tuple_s * unfold(struct anonymous_30 *request);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_counters
// file worker.c line 162
void update_counters(signed int status);
// update_delay_stats
// file worker.c line 575
void update_delay_stats(struct querylog_entry_s *q);
// usage
// file gross.c line 524
void usage(void);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// walk_mmap_info
// file srvutils.c line 162
signed int walk_mmap_info(void);
// walk_queue
// file ../include/msgqueue.h line 65
signed int walk_queue(signed int msgid, signed int (*callback)(void *));
// walk_queue::callback_object
//
signed int callback_object(void *);
// worker_init
// file worker.c line 690
void worker_init();
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writeline
// file utils.c line 143
signed long int writeline(signed int fd, const char *line);
// writen
// file utils.c line 96
signed long int writen(signed int fd, const void *vptr, unsigned long int n);
// writet
// file utils.c line 121
signed long int writet(signed int fd, const char *line, const char *terminator);
// zero_bloom_filter
// file bloom.c line 211
void zero_bloom_filter(struct anonymous_24 *filter);
// zero_bloom_ring_queue
// file bloom.c line 395
void zero_bloom_ring_queue(struct anonymous_22 *brq);
// zero_stats
// file stats.c line 40
struct anonymous_35 zero_stats();

struct anonymous_23
{
  // filter_group
  struct anonymous_24 **filter_group;
  // group_size
  unsigned int group_size;
};

struct anonymous_22
{
  // group
  struct anonymous_23 *group;
  // aggregate
  struct anonymous_24 *aggregate;
  // current_index
  unsigned int current_index;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_27
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct peer_s
{
  // peer_addr
  struct sockaddr_in peer_addr;
  // peer_in_mutex
  union anonymous_27 peer_in_mutex;
  // peerfd_in
  signed int peerfd_in;
  // peerfd_out
  signed int peerfd_out;
  // connected
  signed int connected;
};

struct postfix_config_s
{
  // responsegrey
  char *responsegrey;
  // responseblock
  char *responseblock;
};

struct sjsms_config_s
{
  // responsegrey
  char *responsegrey;
  // responsematch
  char *responsematch;
  // responsetrust
  char *responsetrust;
  // responseblock
  char *responseblock;
};

struct blocker_config_s
{
  // server
  struct sockaddr_in server;
  // weight
  signed int weight;
};

struct anonymous_21
{
  // gross_host
  struct sockaddr_in gross_host;
  // sync_host
  struct sockaddr_in sync_host;
  // status_host
  struct sockaddr_in status_host;
  // peer
  struct peer_s peer;
  // max_connq
  signed int max_connq;
  // rotate_interval
  signed long int rotate_interval;
  // stat_interval
  signed long int stat_interval;
  // filter_size
  unsigned int filter_size;
  // num_bufs
  unsigned int num_bufs;
  // statefile
  char *statefile;
  // loglevel
  signed int loglevel;
  // syslogfacility
  signed int syslogfacility;
  // statlevel
  signed int statlevel;
  // flags
  signed int flags;
  // checks
  signed int checks;
  // grey_mask
  signed int grey_mask;
  // protocols
  signed int protocols;
  // greylist_delay
  signed int greylist_delay;
  // postfix
  struct postfix_config_s postfix;
  // sjsms
  struct sjsms_config_s sjsms;
  // blocker
  struct blocker_config_s blocker;
  // query_timelimit
  signed int query_timelimit;
  // grey_threshold
  signed int grey_threshold;
  // block_threshold
  signed int block_threshold;
  // pool_maxthreads
  signed int pool_maxthreads;
  // grey_reason
  char *grey_reason;
  // block_reason
  char *block_reason;
  // pidfile
  char *pidfile;
};

struct anonymous_40
{
  // thread
  unsigned long int *thread;
};

struct anonymous_41
{
  // bloommgr
  struct anonymous_40 bloommgr;
  // syncmgr
  struct anonymous_40 syncmgr;
  // postfix_server
  struct anonymous_40 postfix_server;
  // sjsms_server
  struct anonymous_40 sjsms_server;
  // milter_server
  struct anonymous_40 milter_server;
};

struct anonymous_35
{
  // startup
  signed long int startup;
  // begin
  signed long int begin;
  // end
  signed long int end;
  // mx
  union anonymous_27 mx;
  // block
  unsigned long int block;
  // greylist
  unsigned long int greylist;
  // match
  unsigned long int match;
  // trust
  unsigned long int trust;
  // all_block
  unsigned long int all_block;
  // all_greylist
  unsigned long int all_greylist;
  // all_match
  unsigned long int all_match;
  // all_trust
  unsigned long int all_trust;
  // block_avg_delay
  double block_avg_delay;
  // greylist_avg_delay
  double greylist_avg_delay;
  // match_avg_delay
  double match_avg_delay;
  // trust_avg_delay
  double trust_avg_delay;
  // block_max_delay
  double block_max_delay;
  // greylist_max_delay
  double greylist_max_delay;
  // match_max_delay
  double match_max_delay;
  // trust_max_delay
  double trust_max_delay;
  // dnsbl_match
  struct dnsbl_stat *dnsbl_match;
};

struct anonymous_42
{
  // pool
  struct thread_pool_s *pool;
  // definitive
  signed int definitive;
  // name
  char *name;
  // init_routine
  void (*init_routine)(void *, struct anonymous_33 *);
  // check_arg
  void *check_arg;
};

struct anonymous_20
{
  // filter
  struct anonymous_22 *filter;
  // update_q
  signed int update_q;
  // sync_guard
  union anonymous_43 *sync_guard;
  // bloom_guard
  union anonymous_27 bloom_guard;
  // update_guard
  union anonymous_27 update_guard;
  // last_rotate
  signed long int *last_rotate;
  // dnsbl
  struct dnsbl_s *dnsbl;
  // dnswl
  struct dnsbl_s *dnswl;
  // rhsbl
  struct dnsbl_s *rhsbl;
  // config
  struct anonymous_21 config;
  // mmap_info
  struct anonymous_44 *mmap_info;
  // statefile_info
  struct statefile_info_s *statefile_info;
  // process_parts
  struct anonymous_41 process_parts;
  // stats
  struct anonymous_35 stats;
  // checklist
  struct anonymous_42 *checklist[128l];
  // syslog_open
  signed int syslog_open;
};

struct anonymous_38
{
  // dnsbl
  struct dnsbl_s *dnsbl;
  // done
  signed int *done;
  // timeout
  signed int *timeout;
  // querystr
  const char *querystr;
  // dnslname
  const char **dnslname;
  // edict
  struct edict_s *edict;
  // check_info
  struct anonymous_37 *check_info;
};

struct anonymous_28
{
  // inq
  struct msgqueue_s *inq;
  // outq
  struct msgqueue_s *outq;
};

struct anonymous_24
{
  // filter
  unsigned int *filter;
  // bitsize
  unsigned int bitsize;
  // mask
  unsigned int mask;
  // size
  unsigned int size;
};

struct anonymous_12
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_10
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct watchdog_s
{
  // last_seen
  struct timespec last_seen;
  // tid
  unsigned long int tid;
  // next
  struct watchdog_s *next;
};

struct anonymous_32
{
  // state
  void *state;
  // cleanup
  signed int (*cleanup)();
  // watchdog
  struct watchdog_s watchdog;
};

struct anonymous_37
{
  // name
  const char *name;
  // definitive
  signed int definitive;
  // type
  enum anonymous_2 type;
  // dnsbase
  struct dnsbl_s *dnsbase;
};

struct anonymous_36
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_3
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_44
{
  // magic
  char magic[8l];
  // brq
  struct anonymous_22 *brq;
  // lumpsize
  unsigned long int lumpsize;
  // last_rotate
  signed long int last_rotate;
};

struct anonymous_25
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_14
{
  // buffer
  signed int buffer;
  // index
  unsigned int index;
  // filter
  unsigned int filter[32l];
};

struct anonymous
{
  // count
  signed int count;
  // mx
  union anonymous_27 mx;
};

struct anonymous_33
{
  // max_thread
  signed int max_thread;
  // watchdog_time
  signed int watchdog_time;
  // watchdog
  signed int watchdog;
};

struct anonymous_6
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_9
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_8
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_7
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_11
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_13
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_6 _kill;
  // _timer
  struct anonymous_7 _timer;
  // _rt
  struct anonymous_8 _rt;
  // _sigchld
  struct anonymous_9 _sigchld;
  // _sigfault
  struct anonymous_10 _sigfault;
  // _sigpoll
  struct anonymous_11 _sigpoll;
  // _sigsys
  struct anonymous_12 _sigsys;
};

struct anonymous_5
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_13 _sifields;
};

struct anonymous_16
{
  // type
  signed int type;
  // length
  unsigned int length;
};

struct anonymous_34
{
  // mtype
  signed long int mtype;
  // result
  void *result;
};

struct anonymous_19
{
  // mtype
  signed long int mtype;
  // mtext
  char mtext[1024l];
};

struct anonymous_18
{
  // h0
  unsigned int h0;
  // h1
  unsigned int h1;
  // h2
  unsigned int h2;
  // h3
  unsigned int h3;
  // h4
  unsigned int h4;
  // h5
  unsigned int h5;
  // h6
  unsigned int h6;
  // h7
  unsigned int h7;
};

struct anonymous_15
{
  // digest
  struct anonymous_18 digest;
};

struct anonymous_30
{
  // msglen
  unsigned short int msglen;
  // sender
  unsigned short int sender;
  // recipient
  unsigned short int recipient;
  // client_address
  unsigned short int client_address;
  // message
  char message[1024l];
};

struct anonymous_31
{
  // msgtype
  unsigned short int msgtype;
  // msglen
  unsigned short int msglen;
  // message
  char message[1024l];
};

struct anonymous_39
{
  // array_index
  unsigned int array_index;
  // intra_index
  unsigned int intra_index;
};

struct anonymous_17
{
  // filter_size
  unsigned int filter_size;
  // num_bufs
  signed int num_bufs;
};

union anonymous_4
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_5 *, void *);
};

union anonymous_43
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous_29
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_26
{
  // __data
  struct anonymous_25 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct ares_options
{
  // flags
  signed int flags;
  // timeout
  signed int timeout;
  // tries
  signed int tries;
  // ndots
  signed int ndots;
  // udp_port
  unsigned short int udp_port;
  // tcp_port
  unsigned short int tcp_port;
  // socket_send_buffer_size
  signed int socket_send_buffer_size;
  // socket_receive_buffer_size
  signed int socket_receive_buffer_size;
  // servers
  struct in_addr *servers;
  // nservers
  signed int nservers;
  // domains
  char **domains;
  // ndomains
  signed int ndomains;
  // lookups
  char *lookups;
  // sock_state_cb
  void (*sock_state_cb)(void *, signed int, signed int, signed int);
  // sock_state_cb_data
  void *sock_state_cb_data;
  // sortlist
  struct apattern *sortlist;
  // nsort
  signed int nsort;
  // ednspsz
  signed int ednspsz;
};

struct check_match_s
{
  // name
  const char *name;
  // weight
  signed int weight;
  // next
  struct check_match_s *next;
};

struct chkresult_s
{
  // definitive
  signed int definitive;
  // wait
  signed int wait;
  // weight
  signed int weight;
  // judgment
  enum anonymous_0 judgment;
  // reason
  char *reason;
  // checkname
  const char *checkname;
};

struct client_info_s
{
  // connfd
  signed int connfd;
  // caddr
  struct sockaddr_in *caddr;
  // ipstr
  char *ipstr;
  // msglen
  signed int msglen;
  // message
  void *message;
  // single_query
  signed int single_query;
};

struct configlist_s
{
  // is_default
  signed int is_default;
  // name
  const char *name;
  // value
  const char *value;
  // params
  struct params_s *params;
  // next
  struct configlist_s *next;
};

struct dnsbl_s
{
  // name
  const char *name;
  // weight
  signed int weight;
  // tolerancecounter
  signed int tolerancecounter;
  // next
  struct dnsbl_s *next;
};

struct dnsbl_stat
{
  // dnsbl_name
  char *dnsbl_name;
  // matches_startup
  unsigned long int matches_startup;
  // next
  struct dnsbl_stat *next;
};

struct edict_message_s
{
  // mtype
  signed long int mtype;
  // edict
  struct edict_s *edict;
};

struct edict_s
{
  // job
  void *job;
  // resultmq
  signed int resultmq;
  // obsolete
  signed int obsolete;
  // reference
  struct anonymous reference;
  // timelimit
  signed int timelimit;
};

struct querylog_entry_s
{
  // action
  signed int action;
  // delay
  signed int delay;
  // totalweight
  signed int totalweight;
  // proto
  const char *proto;
  // client_ip
  const char *client_ip;
  // sender
  const char *sender;
  // recipient
  const char *recipient;
  // helo
  const char *helo;
  // match
  struct check_match_s *match;
};

struct final_status_s
{
  // reason
  char *reason;
  // status
  enum anonymous_1 status;
  // querylog_entry
  struct querylog_entry_s querylog_entry;
  // starttime
  struct timespec starttime;
};

struct grey_tuple_s
{
  // sender
  char *sender;
  // recipient
  char *recipient;
  // client_address
  char *client_address;
  // helo_name
  char *helo_name;
  // reference
  struct anonymous reference;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct msg_s
{
  // msgp
  void *msgp;
  // msgsz
  unsigned long int msgsz;
  // next
  struct msg_s *next;
  // timestamp
  struct timespec timestamp;
};

struct msgqueue_s
{
  // cv
  union anonymous_26 cv;
  // mx
  union anonymous_27 mx;
  // head
  struct msg_s *head;
  // tail
  struct msg_s *tail;
  // msgcount
  signed int msgcount;
  // delaypair
  struct msgqueue_s *delaypair;
  // delay_ts
  struct timespec *delay_ts;
  // impose_delay
  signed int *impose_delay;
  // active
  signed int active;
  // id
  signed int id;
};

struct params_s
{
  // value
  const char *value;
  // next
  struct params_s *next;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pool_ctx_s
{
  // mx
  union anonymous_27 *mx;
  // routine
  signed int (*routine)(struct thread_pool_s *, struct anonymous_32 *, struct edict_s *);
  // info
  struct thread_pool_s *info;
  // count_thread
  signed int count_thread;
  // count_idle
  signed int count_idle;
  // ewma_idle
  float ewma_idle;
  // last_idle_check
  struct timespec last_idle_check;
  // max_thread
  signed int max_thread;
  // idle_time
  signed int idle_time;
  // wdlist
  struct watchdog_s *wdlist;
  // watchdog_time
  signed int watchdog_time;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_4 __sigaction_handler;
  // sa_mask
  struct anonymous_3 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct statefile_info_s
{
  // fd
  signed int fd;
};

struct thread_pool_s
{
  // work_queue_id
  signed int work_queue_id;
  // name
  const char *name;
  // arg
  void *arg;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct tmout_action_s
{
  // timeout
  signed int timeout;
  // action
  void (*action)(void *, signed int);
  // arg
  void *arg;
  // next
  struct tmout_action_s *next;
};


// BITARRAY_BASE_SIZE
// file bloom.c line 24
unsigned int BITARRAY_BASE_SIZE = (unsigned int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)(unsigned int)8);
// DEFAULT_SHA256
// file sha256.c line 28
const struct anonymous_18 DEFAULT_SHA256 = { .h0=(unsigned int)0x6a09e667, .h1=0xbb67ae85, .h2=(unsigned int)0x3c6ef372,
    .h3=0xa54ff53a, .h4=(unsigned int)0x510e527f,
    .h5=0x9b05688c, .h6=(unsigned int)0x1f83d9ab,
    .h7=(unsigned int)0x5be0cd19 };
// ROUND_CONSTANTS
// file sha256.c line 33
unsigned int ROUND_CONSTANTS[64l] = { (unsigned int)0x428a2f98, (unsigned int)0x71374491, 0xb5c0fbcf, 0xe9b5dba5, (unsigned int)0x3956c25b, (unsigned int)0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, (unsigned int)0x12835b01, (unsigned int)0x243185be, (unsigned int)0x550c7dc3, (unsigned int)0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, (unsigned int)0x0fc19dc6, (unsigned int)0x240ca1cc, (unsigned int)0x2de92c6f, (unsigned int)0x4a7484aa, (unsigned int)0x5cb0a9dc, (unsigned int)0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, (unsigned int)0x06ca6351, (unsigned int)0x14292967, (unsigned int)0x27b70a85, (unsigned int)0x2e1b2138, (unsigned int)0x4d2c6dfc, (unsigned int)0x53380d13, (unsigned int)0x650a7354, (unsigned int)0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, (unsigned int)0x106aa070, (unsigned int)0x19a4c116, (unsigned int)0x1e376c08, (unsigned int)0x2748774c, (unsigned int)0x34b0bcb5, (unsigned int)0x391c0cb3, (unsigned int)0x4ed8aa4a, (unsigned int)0x5b9cca4f, (unsigned int)0x682e6ff3, (unsigned int)0x748f82ee, (unsigned int)0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 };
// ctx
// file srvutils.c line 29
struct anonymous_20 *ctx;
// global_queue_lk
// file msgqueue.c line 53
union anonymous_27 global_queue_lk = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// initialized
// file msgqueue.c line 51
signed int initialized = 0;
// metaqueue
// file msgqueue.c line 48
struct msgqueue_s *metaqueue;
// numqueues
// file msgqueue.c line 50
signed int numqueues = 0;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optopt
// file /usr/include/getopt.h line 80
extern signed int optopt;
// p_convert_int32_to_big_endian
// file sha256.c line 25
void (*p_convert_int32_to_big_endian)(unsigned int *);
// p_convert_int32_to_big_endian
// file sha256.c line 25
void (*p_convert_int32_to_big_endian)(unsigned int *) = convert_int32_big_endian;
// p_convert_int64_to_big_endian
// file sha256.c line 24
void (*p_convert_int64_to_big_endian)(unsigned long int *);
// p_convert_int64_to_big_endian
// file sha256.c line 24
void (*p_convert_int64_to_big_endian)(unsigned long int *) = convert_int64_big_endian;
// queues
// file msgqueue.c line 47
struct msgqueue_s **queues;
// queuespace
// file msgqueue.c line 49
signed int queuespace = 1;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// Malloc
// file ../include/srvutils.h line 113
void * Malloc(unsigned long int size)
{
  void *chunk;
  /* assertion size */
  assert(size != 0ul);
  chunk=malloc(size);
  if(chunk == NULL)
    daemon_fatal("malloc");

  return chunk;
}

// a_delim_b
// file conf.c line 239
signed int a_delim_b(char *buffer, char delim, char **stra, char **strb)
{
  char *ptr;
  *strb = (char *)(void *)0;
  *stra = *strb;
  ptr=strchr(buffer, (signed int)delim);
  if(!(ptr == ((char *)NULL)))
  {
    *stra = buffer;
    *ptr = (char)0;
    *strb = ptr + (signed long int)1;
    signed int return_value_trim_1;
    return_value_trim_1=trim(stra);
    if(return_value_trim_1 == 0)
      return -1;

    signed int return_value_trim_2;
    return_value_trim_2=trim(strb);
    if(return_value_trim_2 == 0)
      return -1;

    /* assertion *stra */
    assert(*stra != ((char *)NULL));
    /* assertion *strb */
    assert(*strb != ((char *)NULL));
    return 1;
  }

  else
    return 0;
}

// add_config_item
// file conf.c line 95
signed int add_config_item(struct configlist_s **current, const char *name, const char *value, struct params_s *params, signed int is_default)
{
  struct configlist_s *new;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct configlist_s) /*40ul*/ );
  new = (struct configlist_s *)return_value_Malloc_1;
  memset((void *)new, 0, sizeof(struct configlist_s) /*40ul*/ );
  new->name = name;
  new->value = value;
  new->params = params;
  new->is_default = is_default;
  new->next = *current;
  *current = new;
  return 1;
}

// add_dnsbl
// file ../include/check_dnsbl.h line 49
signed int add_dnsbl(struct dnsbl_s **current, const char *name, signed int weight)
{
  struct dnsbl_s *new;
  logstr(65543, "adding dnsbl: %s, weight %d", name, weight);
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct dnsbl_s) /*24ul*/ );
  new = (struct dnsbl_s *)return_value_Malloc_1;
  memset((void *)new, 0, sizeof(struct dnsbl_s) /*24ul*/ );
  new->tolerancecounter = 5;
  new->name=strdup(name);
  new->next = *current;
  new->weight = weight;
  *current = new;
  return 1;
}

// add_filter
// file bloom.c line 309
struct anonymous_24 * add_filter(struct anonymous_24 *lvalue, const struct anonymous_24 *rvalue)
{
  signed int i;
  /* assertion lvalue */
  assert(lvalue != ((struct anonymous_24 *)NULL));
  /* assertion rvalue */
  assert(rvalue != ((const struct anonymous_24 *)NULL));
  /* assertion lvalue->size == rvalue->size */
  assert(lvalue->size == rvalue->size);
  /* assertion lvalue->mask == rvalue->mask */
  assert(lvalue->mask == rvalue->mask);
  i = 0;
  for( ; !((unsigned int)i >= lvalue->size); i = i + 1)
    lvalue->filter[(signed long int)i] = lvalue->filter[(signed long int)i] | rvalue->filter[(signed long int)i];
  return lvalue;
}

// add_mask
// file bloom.c line 92
unsigned int add_mask(unsigned int intra_index)
{
  /* assertion intra_index <= 32 */
  assert(intra_index <= (unsigned int)32);
  return (unsigned int)(1 << intra_index);
}

// addrinfo_callback
// file check_dnsbl.c line 108
static void addrinfo_callback(void *arg, signed int status, signed int timeouts, struct hostent *host)
{
  struct chkresult_s *result;
  struct anonymous_38 *cba = (struct anonymous_38 *)arg;
  if(status == 0)
  {
    if(!((signed int)cba->check_info->type == TYPE_DNSWL))
    {
      void *return_value_Malloc_1;
      return_value_Malloc_1=Malloc(sizeof(struct chkresult_s) /*32ul*/ );
      result = (struct chkresult_s *)return_value_Malloc_1;
      memset((void *)result, 0, sizeof(struct chkresult_s) /*32ul*/ );
      result->judgment = (enum anonymous_0)J_SUSPICIOUS;
      result->weight = cba->dnsbl->weight;
      result->wait = 1;
      result->checkname = cba->dnsbl->name;
      send_result(cba->edict, (void *)result);
    }

    else
    {
      *cba->dnslname = cba->dnsbl->name;
      *cba->done = 1;
    }
    stat_dnsbl_match(cba->dnsbl->name);
    logstr(65543, "dns-match: %s for %s", cba->dnsbl->name, cba->querystr);
  }

  if(!(*cba->timeout == 0))
  {
    logstr(65543, "dns-timeout: %s for %s", cba->dnsbl->name, cba->querystr);
    cba->dnsbl->tolerancecounter = cba->dnsbl->tolerancecounter - 1;
  }

  /* assertion cba */
  assert(cba != ((struct anonymous_38 *)NULL));
  free((void *)cba);
  cba = (struct anonymous_38 *)(void *)0;
}

// advance_bloom_ring_queue
// file bloom.c line 366
struct anonymous_22 * advance_bloom_ring_queue(struct anonymous_22 *brq)
{
  /* assertion brq */
  assert(brq != ((struct anonymous_22 *)NULL));
  brq->current_index=bloom_ring_queue_next_index(brq);
  return brq;
}

// array_index
// file bloom.c line 27
struct anonymous_39 array_index(unsigned int bit_index)
{
  struct anonymous_39 index;
  index.array_index = bit_index / BITARRAY_BASE_SIZE;
  index.intra_index = bit_index % BITARRAY_BASE_SIZE;
  return index;
}

// assemble_mapresult
// file worker_sjsms.c line 58
char * assemble_mapresult(char *template, char *reason)
{
  char result[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char *reasonsubstitute;
  char *prologue;
  char *epilogue;
  char mapreason[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  mappingstr(reason, mapreason, (unsigned long int)1024);
  prologue=strdup(template);
  reasonsubstitute=strstr(prologue, "%reason%");
  if(reasonsubstitute == ((char *)NULL))
    snprintf(result, (unsigned long int)1024, "%s", prologue);

  else
  {
    *reasonsubstitute = (char)0;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen("%reason%");
    epilogue = reasonsubstitute + (signed long int)return_value_strlen_1;
    snprintf(result, (unsigned long int)1024, "%s%s%s", prologue, (const void *)mapreason, epilogue);
  }
  /* assertion prologue */
  assert(prologue != ((char *)NULL));
  free((void *)prologue);
  prologue = (char *)(void *)0;
  char *return_value_strdup_2;
  return_value_strdup_2=strdup(result);
  return return_value_strdup_2;
}

// assemble_response
// file worker_postfix.c line 35
char * assemble_response(char *result, unsigned long int len, char *template, char *reason)
{
  char *reasonsubstitute;
  char *prologue;
  char *epilogue;
  prologue=strdup(template);
  reasonsubstitute=strstr(prologue, "%reason%");
  if(reasonsubstitute == ((char *)NULL))
    snprintf(result, len, "%s", prologue);

  else
  {
    *reasonsubstitute = (char)0;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen("%reason%");
    epilogue = reasonsubstitute + (signed long int)return_value_strlen_1;
    snprintf(result, len, "%s%s%s", prologue, reason, epilogue);
    result[(signed long int)(len - (unsigned long int)1)] = (char)0;
  }
  /* assertion prologue */
  assert(prologue != ((char *)NULL));
  free((void *)prologue);
  prologue = (char *)(void *)0;
  return result;
}

// block_delay_update
// file ../include/stats.h line 62
double block_delay_update(double d)
{
  pthread_mutex_lock(&ctx->stats.mx);
  if(ctx->stats.block == 0ul)
  {
    ctx->stats.block_avg_delay = d;
    logstr(65540, "Block average updated before updating counters");
  }

  else
    ctx->stats.block_avg_delay = (ctx->stats.block_avg_delay * (double)(ctx->stats.block - (unsigned long int)1) + d) / (double)ctx->stats.block;
  if(ctx->stats.block_max_delay < d)
    ctx->stats.block_max_delay = d;

  pthread_mutex_unlock(&ctx->stats.mx);
  return ctx->stats.block_avg_delay;
}

// blocker
// file check_blocker.c line 34
signed int blocker(struct thread_pool_s *info, struct anonymous_32 *thread_ctx, struct edict_s *edict)
{
  struct chkresult_s *result;
  signed int blocker__1__blocker;
  signed int ret;
  struct grey_tuple_s *request;
  const char *client_address;
  char buffer[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct timespec start;
  struct timespec timeleft;
  request = (struct grey_tuple_s *)edict->job;
  client_address = request->client_address;
  /* assertion client_address */
  assert(client_address != ((const char *)NULL));
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct chkresult_s) /*32ul*/ );
  result = (struct chkresult_s *)return_value_Malloc_1;
  memset((void *)result, 0, sizeof(struct chkresult_s) /*32ul*/ );
  result->judgment = (enum anonymous_0)J_UNDEFINED;
  result->checkname = "blocker";
  clock_gettime(1, &start);
  mstotimespec(edict->timelimit, &timeleft);
  blocker__1__blocker=socket(2, 1, 0);
  if(!(blocker__1__blocker >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    logstr(65539, "blocker: socket: %s", return_value_strerror_3);
    goto FINISH;
  }

  ret=connect(blocker__1__blocker, (struct sockaddr *)&ctx->config.blocker.server, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    logstr(65539, "blocker: connect: %s", return_value_strerror_5);
    close(blocker__1__blocker);
    goto FINISH;
  }

  snprintf(buffer, (unsigned long int)1024, "client_address=%s\n\n", request->client_address);
  buffer[(signed long int)(1024 - 1)] = (char)0;
  unsigned long int return_value_strlen_6;
  return_value_strlen_6=strlen(buffer);
  signed long int return_value_writen_7;
  return_value_writen_7=writen(blocker__1__blocker, (const void *)buffer, return_value_strlen_6);
  ret = (signed int)return_value_writen_7;
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    char *return_value_strerror_9;
    return_value_strerror_9=strerror(*return_value___errno_location_8);
    logstr(65539, "blocker: writen: %s", return_value_strerror_9);
    close(blocker__1__blocker);
    goto FINISH;
  }

  ret=readline(blocker__1__blocker, (void *)&buffer, (unsigned long int)1024);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location_10;
    return_value___errno_location_10=__errno_location();
    char *return_value_strerror_11;
    return_value_strerror_11=strerror(*return_value___errno_location_10);
    logstr(65539, "blocker: readline: %s", return_value_strerror_11);
    close(blocker__1__blocker);
    goto FINISH;
  }

  close(blocker__1__blocker);
  signed int return_value_strncmp_12;
  return_value_strncmp_12=strncmp(buffer, "action=565 ", (unsigned long int)11);
  if(return_value_strncmp_12 == 0)
  {
    logstr(65543, "found match from blocker: %s", request->client_address);
    result->judgment = (enum anonymous_0)J_SUSPICIOUS;
    result->weight = ctx->config.blocker.weight;
  }


FINISH:
  ;
  send_result(edict, (void *)result);
  logstr(65543, "blocker returning");
  request_unlink(request);
  return 0;
}

// blocker_init
// file ../include/check_blocker.h line 22
void blocker_init(struct anonymous_33 *limits)
{
  struct thread_pool_s *pool;
  logstr(65542, "initializing Sophos blocker thread pool");
  pool=create_thread_pool("blocker", blocker, limits, (void *)0);
  if(pool == ((struct thread_pool_s *)NULL))
    daemon_fatal("create_thread_pool");

  register_check(pool, 0);
}

// bloom_error_rate
// file bloom.c line 278
double bloom_error_rate(unsigned int n, unsigned int k, unsigned int m)
{
  double return_value_exp_1;
  return_value_exp_1=exp(-((double)n * (double)k) / (double)m);
  return 1.0 - return_value_exp_1 * (double)k;
}

// bloom_required_size
// file bloom.c line 284
unsigned int bloom_required_size(double c, unsigned int k, unsigned int n)
{
  double return_value_pow_1;
  return_value_pow_1=pow(c, 1.0 / (double)k);
  double return_value_log_2;
  return_value_log_2=log(1.0 - return_value_pow_1);
  return (unsigned int)((-((double)k) * (double)n) / return_value_log_2);
}

// bloom_ring_queue_next_index
// file bloom.c line 356
unsigned int bloom_ring_queue_next_index(struct anonymous_22 *brq)
{
  /* assertion brq */
  assert(brq != ((struct anonymous_22 *)NULL));
  if(1u + brq->current_index >= brq->group->group_size)
    return (unsigned int)0;

  else
    return brq->current_index + (unsigned int)1;
}

// bloommgr
// file bloommgr.c line 57
static void * bloommgr(void *arg)
{
  struct anonymous_19 message;
  struct anonymous_18 digest;
  signed int ret;
  unsigned long int size;
  struct anonymous_14 ss;
  ctx->filter=build_bloom_ring(ctx->config.num_bufs, ctx->config.filter_size);
  logstr(65542, "bloommgr starting...");
  sem_post(ctx->sync_guard);
  do
  {
    size=get_msg(ctx->update_q, (void *)&message, (unsigned long int)1024, 0);
    switch(message.mtype)
    {
      case (signed long int)1:
      {
        logstr(65543, "received update command");
        memcpy((void *)&digest, (const void *)message.mtext, sizeof(struct anonymous_18) /*32ul*/ );
        pthread_mutex_lock(&ctx->bloom_guard);
        insert_digest_bloom_ring_queue(ctx->filter, digest);
        pthread_mutex_unlock(&ctx->bloom_guard);
        break;
      }
      case (signed long int)5:
      {
        memcpy((void *)&digest, (const void *)message.mtext, sizeof(struct anonymous_18) /*32ul*/ );
        pthread_mutex_lock(&ctx->bloom_guard);
        insert_digest_bloom_ring_queue(ctx->filter, digest);
        pthread_mutex_unlock(&ctx->bloom_guard);
        break;
      }
      case (signed long int)3:
      {
        memcpy((void *)&ss, (const void *)message.mtext, sizeof(struct anonymous_14) /*136ul*/ );
        pthread_mutex_lock(&ctx->bloom_guard);
        insert_absolute_bloom_ring_queue(ctx->filter, ss.filter, (signed int)(unsigned int)32, (signed int)ss.index, (unsigned int)ss.buffer);
        pthread_mutex_unlock(&ctx->bloom_guard);
        break;
      }
      case (signed long int)2:
      {
        logstr(65543, "received rotate command");
        create_thread((struct anonymous_40 *)(void *)0, 1, rotate, (void *)0);
        break;
      }
      case (signed long int)4:
      {
        sync_aggregate(ctx->filter);
        ret=sem_post(ctx->sync_guard);
        if(!(ret == 0))
          daemon_fatal("pthread_mutex_unlock");

        break;
      }
      default:
        logstr(65539, "Unknown message type in update queue");
    }
  }
  while((_Bool)1);
}

// bloommgr_init
// file bloommgr.c line 124
void bloommgr_init()
{
  sem_wait(ctx->sync_guard);
  create_thread(&ctx->process_parts.bloommgr, 1, bloommgr, (void *)0);
}

// build_bloom_ring
// file srvutils.c line 224
struct anonymous_22 * build_bloom_ring(unsigned int num, unsigned int num_bits)
{
  struct anonymous_22 *brq;
  char *ptr;
  signed int i;
  signed int ret;
  unsigned long int lumpsize;
  struct stat statbuf;
  char *magic = "mmbrq2\n";
  signed int use_mmap = 0;
  /* assertion num_bits > 3 */
  assert(num_bits > (unsigned int)3);
  lumpsize = sizeof(struct anonymous_22) /*24ul*/  + sizeof(struct anonymous_23) /*16ul*/  + (unsigned long int)num * sizeof(struct anonymous_24 *) /*8ul*/  + (unsigned long int)(num + (unsigned int)1) * sizeof(struct anonymous_24) /*24ul*/  + (unsigned long int)((num + (unsigned int)1) * ((unsigned int)(1 << num_bits) / (unsigned int)8));
  if(!(ctx->config.statefile == ((char *)NULL)))
    use_mmap = 1;

  if(!(use_mmap == 0))
  {
    if(!(ctx->statefile_info == ((struct statefile_info_s *)NULL)))
      daemon_shutdown(2, "statefile already open");

    lumpsize = lumpsize + sizeof(struct anonymous_44) /*32ul*/ ;
    ret=stat(ctx->config.statefile, &statbuf);
    if(!(ret >= 0))
      daemon_fatal("stat(): statefile opening failed");

    else
      if(!((unsigned long int)statbuf.st_size == lumpsize))
      {
        printf("statefile size (%d) differs from the calculated size (%d)\n", (signed int)statbuf.st_size, lumpsize);
        daemon_shutdown(2, "statefile size differs from the calculated size");
      }

    void *return_value_Malloc_1;
    return_value_Malloc_1=Malloc(sizeof(struct statefile_info_s) /*4ul*/ );
    ctx->statefile_info = (struct statefile_info_s *)return_value_Malloc_1;
    ctx->statefile_info->fd=open(ctx->config.statefile, 02);
    if(!(ctx->statefile_info->fd >= 0))
      daemon_fatal("open() statefile:");

    void *return_value_mmap_2;
    return_value_mmap_2=mmap((void *)0, lumpsize, 0x1 | 0x2, 0x01, ctx->statefile_info->fd, (signed long int)0);
    ptr = (char *)return_value_mmap_2;
    /* assertion ptr */
    assert(ptr != ((char *)NULL));
    ctx->mmap_info = (struct anonymous_44 *)ptr;
    ctx->last_rotate = &ctx->mmap_info->last_rotate;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(magic);
    signed int return_value_strncmp_4;
    return_value_strncmp_4=strncmp(ctx->mmap_info->magic, magic, return_value_strlen_3);
    if(return_value_strncmp_4 == 0)
    {
      logstr(65543, "Found the correct state file magic string.");
      ctx->mmap_info->brq = (struct anonymous_22 *)&ctx->mmap_info[(signed long int)1];
      walk_mmap_info();
      return ctx->mmap_info->brq;
    }

    logstr(65543, "Unable to find the state file magic string. Initializing.");
    strncpy(ctx->mmap_info->magic, magic, (unsigned long int)8);
    ctx->mmap_info->last_rotate=time((signed long int *)(void *)0);
    ptr = ptr + (signed long int)sizeof(struct anonymous_44) /*32ul*/ ;
  }

  else
  {
    void *return_value_Malloc_5;
    return_value_Malloc_5=Malloc(lumpsize);
    ptr = (char *)return_value_Malloc_5;
  }
  brq = (struct anonymous_22 *)ptr;
  if(!(use_mmap == 0))
    ctx->mmap_info->brq = brq;

  brq->current_index = (unsigned int)0;
  ptr = ptr + (signed long int)sizeof(struct anonymous_22) /*24ul*/ ;
  brq->group = (struct anonymous_23 *)ptr;
  brq->group->group_size = num;
  ptr = ptr + (signed long int)sizeof(struct anonymous_23) /*16ul*/ ;
  brq->group->filter_group = (struct anonymous_24 **)ptr;
  ptr = ptr + (signed long int)((unsigned long int)num * sizeof(struct anonymous_24 *) /*8ul*/ );
  brq->aggregate = (struct anonymous_24 *)ptr;
  brq->aggregate->bitsize = (unsigned int)(1 << num_bits);
  brq->aggregate->mask = (unsigned int)-1 >> BITARRAY_BASE_SIZE - num_bits;
  brq->aggregate->size = brq->aggregate->bitsize / BITARRAY_BASE_SIZE;
  i = 0;
  for( ; !((unsigned int)i >= brq->group->group_size); i = i + 1)
  {
    brq->group->filter_group[(signed long int)i] = (struct anonymous_24 *)(ptr + (signed long int)(sizeof(struct anonymous_24) /*24ul*/  * (unsigned long int)(i + 1)));
    brq->group->filter_group[(signed long int)i]->bitsize = (unsigned int)(1 << num_bits);
    brq->group->filter_group[(signed long int)i]->mask = (unsigned int)-1 >> BITARRAY_BASE_SIZE - num_bits;
    brq->group->filter_group[(signed long int)i]->size = brq->group->filter_group[(signed long int)i]->bitsize / BITARRAY_BASE_SIZE;
  }
  ptr = ptr + (signed long int)((unsigned long int)(num + (unsigned int)1) * sizeof(struct anonymous_24) /*24ul*/ );
  brq->aggregate->filter = (unsigned int *)ptr;
  i = 0;
  for( ; !((unsigned int)i >= brq->group->group_size); i = i + 1)
    brq->group->filter_group[(signed long int)i]->filter = (unsigned int *)(ptr + (signed long int)((unsigned long int)(i + 1) * sizeof(unsigned int) /*4ul*/  * (unsigned long int)brq->group->filter_group[(signed long int)i]->size));
  zero_bloom_filter(brq->aggregate);
  i = 0;
  for( ; !((unsigned int)i >= brq->group->group_size); i = i + 1)
    zero_bloom_filter(brq->group->filter_group[(signed long int)i]);
  if(!(use_mmap == 0))
  {
    ret=msync((void *)ctx->mmap_info, lumpsize, 4);
    if(!(ret >= 0))
      daemon_fatal("msync");

  }

  return brq;
}

// buildquerystr
// file proto_sjsms.c line 29
char * buildquerystr(const char *sender, const char *rcpt, const char *caddr, const char *helo)
{
  char buffer[1024l];
  snprintf(buffer, (unsigned long int)(1024 - 1), "sender=%s\nrecipient=%s\nclient_address=%s%s%s\n\n", sender, rcpt, caddr, helo != ((const char *)NULL) ? "\nhelo_name=" : "", helo != ((const char *)NULL) ? helo : "");
  char *return_value_strdup_1;
  return_value_strdup_1=strdup(buffer);
  return return_value_strdup_1;
}

// calm_client
// file worker_sjsms.c line 150
void calm_client(void *arg, signed int timeused)
{
  struct client_info_s *client_info;
  char response = (char)80;
  unsigned int len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  client_info = (struct client_info_s *)arg;
  sendto(client_info->connfd, (const void *)&response, (unsigned long int)1, 0, (struct sockaddr *)client_info->caddr, len);
  logstr(65543, "timeout: used %d ms. PROGRESS sent", timeused);
}

// check_pidfile
// file srvutils.c line 421
void check_pidfile(void)
{
  signed int ret;
  struct stat statinfo;
  ret=stat(ctx->config.pidfile, &statinfo);
  signed int *return_value___errno_location_1;
  if(!(ret >= 0))
  {
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 2))
      daemon_fatal("stat");

    else
      goto __CPROVER_DUMP_L5;
  }

  else
    daemon_shutdown(3, "pidfile already exists");

__CPROVER_DUMP_L5:
  ;
}

// check_request
// file worker.c line 507
signed int check_request(struct grey_tuple_s *tuple)
{
  _Bool tmp_if_expr_1;
  if(!(tuple->sender == ((char *)NULL)))
    tmp_if_expr_1 = tuple->recipient != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = tuple->client_address != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    return 0;

  else
    return -1;
}

// chomp
// file utils.c line 165
signed int chomp(char *buffer)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buffer);
  len = (signed int)return_value_strlen_1;
  if(!(len >= 2))
    return -1;

  else
  {
    if((signed int)buffer[(signed long int)(len + -1)] == 10)
      buffer[(signed long int)(len - 1)] = (char)0;

    if((signed int)buffer[(signed long int)(len + -2)] == 13)
      buffer[(signed long int)(len - 2)] = (char)0;

    return 0;
  }
}

// cleanup_dnsblc
// file check_dnsbl.c line 34
signed int cleanup_dnsblc(void *state)
{
  struct ares_channeldata **channel = (struct ares_channeldata **)state;
  ares_destroy(*channel);
  /* assertion channel */
  assert(channel != ((struct ares_channeldata **)NULL));
  free((void *)channel);
  channel = (struct ares_channeldata **)(void *)0;
  return 0;
}

// cleanup_random
// file check_random.c line 33
signed int cleanup_random(void *state)
{
  signed int *foo = (signed int *)state;
  /* assertion foo */
  assert(foo != ((signed int *)NULL));
  free((void *)foo);
  foo = (signed int *)(void *)0;
  return 0;
}

// configure_grossd
// file gross.c line 107
void configure_grossd(struct configlist_s *config)
{
  signed int ret;
  struct configlist_s *cp;
  const char *updatestr;
  struct hostent *host = (struct hostent *)(void *)0;
  char buffer[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct params_s *pp;
  cp = config;
  if(!((0x01 & ctx->config.flags) == 0))
    for( ; !(cp == ((struct configlist_s *)NULL)); cp = cp->next)
    {
      pp = cp->params;
      buffer[0l] = (char)0;
      for( ; !(pp == ((struct params_s *)NULL)); pp = pp->next)
      {
        strncat(buffer, " ; ", (unsigned long int)(1024 - 1));
        strncat(buffer, pp->value, (unsigned long int)(1024 - 1));
      }
      logstr(65543, "config: %s = %s%s", cp->name, cp->value, (const void *)buffer);
    }

  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(union anonymous_43) /*32ul*/ );
  ctx->sync_guard = (union anonymous_43 *)return_value_Malloc_1;
  ret=sem_init(ctx->sync_guard, 0, (unsigned int)1);
  if(!(ret == 0))
    daemon_fatal("sem_init");

  pthread_mutex_init(&ctx->bloom_guard, (const union anonymous_29 *)(void *)0);
  pthread_mutex_init(&ctx->config.peer.peer_in_mutex, (const union anonymous_29 *)(void *)0);
  ctx->config.gross_host.sin_family = (unsigned short int)2;
  const char *return_value_gconf_2;
  return_value_gconf_2=gconf(config, "host");
  host=gethostbyname(return_value_gconf_2);
  if(host == ((struct hostent *)NULL))
    daemon_fatal("'host' configuration option invalid:");

  char *return_value_inet_ntoa_3;
  return_value_inet_ntoa_3=inet_ntoa(*((struct in_addr *)host->h_addr_list[(signed long int)0]));
  ret=inet_pton(2, return_value_inet_ntoa_3, (void *)&ctx->config.gross_host.sin_addr);
  if(!(ret >= 0))
    daemon_fatal("error setting 'host':");

  else
    if(ret == 0)
      daemon_shutdown(4, "'host' configuration option invalid");

  char *return_value_inet_ntoa_4;
  return_value_inet_ntoa_4=inet_ntoa(*((struct in_addr *)host->h_addr_list[(signed long int)0]));
  logstr(65543, "Listening host address %s", return_value_inet_ntoa_4);
  ctx->config.sync_host.sin_family = (unsigned short int)2;
  const char *return_value_gconf_5;
  return_value_gconf_5=gconf(config, "sync_listen");
  const char *tmp_if_expr_8;
  const char *return_value_gconf_6;
  const char *return_value_gconf_7;
  if(!(return_value_gconf_5 == ((const char *)NULL)))
  {
    return_value_gconf_6=gconf(config, "sync_listen");
    tmp_if_expr_8 = return_value_gconf_6;
  }

  else
  {
    return_value_gconf_7=gconf(config, "host");
    tmp_if_expr_8 = return_value_gconf_7;
  }
  host=gethostbyname(tmp_if_expr_8);
  if(host == ((struct hostent *)NULL))
    daemon_fatal("'sync_listen' configuration option invalid:");

  char *return_value_inet_ntoa_9;
  return_value_inet_ntoa_9=inet_ntoa(*((struct in_addr *)host->h_addr_list[(signed long int)0]));
  ret=inet_pton(2, return_value_inet_ntoa_9, (void *)&ctx->config.sync_host.sin_addr);
  if(!(ret >= 0))
    daemon_fatal("'error setting 'sync_listen':");

  else
    if(ret == 0)
      daemon_shutdown(4, "'sync_listen' configuration option invalid");

  char *return_value_inet_ntoa_10;
  return_value_inet_ntoa_10=inet_ntoa(*((struct in_addr *)host->h_addr_list[(signed long int)0]));
  logstr(65543, "Sync listen address %s", return_value_inet_ntoa_10);
  const char *return_value_gconf_11;
  return_value_gconf_11=gconf(config, "sync_port");
  signed int return_value_atoi_12;
  return_value_atoi_12=atoi(return_value_gconf_11);
  ctx->config.sync_host.sin_port=htons((unsigned short int)return_value_atoi_12);
  const char *return_value_gconf_13;
  return_value_gconf_13=gconf(config, "port");
  signed int return_value_atoi_14;
  return_value_atoi_14=atoi(return_value_gconf_13);
  ctx->config.gross_host.sin_port=htons((unsigned short int)return_value_atoi_14);
  ctx->config.max_connq = 50;
  ctx->config.peer.connected = 0;
  const char *return_value_gconf_15;
  return_value_gconf_15=gconf(config, "grey_delay");
  ctx->config.greylist_delay=atoi(return_value_gconf_15);
  if(!(ctx->config.greylist_delay == 10))
    logstr(65543, "Greylisting delay %d", ctx->config.greylist_delay);

  const char *return_value_gconf_16;
  return_value_gconf_16=gconf(config, "sync_port");
  signed int return_value_atoi_17;
  return_value_atoi_17=atoi(return_value_gconf_16);
  ctx->config.peer.peer_addr.sin_port=htons((unsigned short int)return_value_atoi_17);
  const char *return_value_gconf_22;
  return_value_gconf_22=gconf(config, "sync_peer");
  if(return_value_gconf_22 == ((const char *)NULL))
  {
    logstr(65543, "No peer configured. Replication suppressed.");
    ctx->config.flags = ctx->config.flags | (signed int)0x02;
  }

  else
  {
    const char *return_value_gconf_18;
    return_value_gconf_18=gconf(config, "sync_peer");
    logstr(65543, "Peer %s configured. Replicating.", return_value_gconf_18);
    ctx->config.peer.peer_addr.sin_family = (unsigned short int)2;
    const char *return_value_gconf_19;
    return_value_gconf_19=gconf(config, "sync_peer");
    host=gethostbyname(return_value_gconf_19);
    if(host == ((struct hostent *)NULL))
      daemon_fatal("'sync_peer' configuration option invalid:");

    char *return_value_inet_ntoa_20;
    return_value_inet_ntoa_20=inet_ntoa(*((struct in_addr *)host->h_addr_list[(signed long int)0]));
    ret=inet_pton(2, return_value_inet_ntoa_20, (void *)&ctx->config.peer.peer_addr.sin_addr);
    if(!(ret >= 0))
      daemon_fatal("error setting 'sync_peer':");

    else
      if(ret == 0)
        daemon_shutdown(4, "'sync_peer' configuration option invalid");

    char *return_value_inet_ntoa_21;
    return_value_inet_ntoa_21=inet_ntoa(*((struct in_addr *)host->h_addr_list[(signed long int)0]));
    logstr(65543, "Sync peer address %s", return_value_inet_ntoa_21);
  }
  updatestr=gconf(config, "update");
  signed int return_value_strncmp_25;
  return_value_strncmp_25=strncmp(updatestr, "always", (unsigned long int)7);
  _Bool tmp_if_expr_24;
  signed int return_value_strncmp_23;
  if(return_value_strncmp_25 == 0)
  {
    logstr(65543, "updatestyle: ALWAYS");
    ctx->config.flags = ctx->config.flags | (signed int)0x04;
  }

  else
  {
    if(updatestr == ((const char *)NULL))
      tmp_if_expr_24 = (_Bool)1;

    else
    {
      return_value_strncmp_23=strncmp(updatestr, "grey", (unsigned long int)5);
      tmp_if_expr_24 = return_value_strncmp_23 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_24)
      logstr(65543, "updatestyle: GREY");

    else
      daemon_shutdown(4, "Invalid updatestyle: %s", updatestr);
  }
  signed int *return_value___errno_location_26;
  return_value___errno_location_26=__errno_location();
  *return_value___errno_location_26 = 0;
  const char *return_value_gconf_27;
  return_value_gconf_27=gconf(config, "grey_mask");
  signed long int return_value_strtol_28;
  return_value_strtol_28=strtol(return_value_gconf_27, (char **)(void *)0, 10);
  ctx->config.grey_mask = (signed int)return_value_strtol_28;
  signed int *return_value___errno_location_30;
  return_value___errno_location_30=__errno_location();
  _Bool tmp_if_expr_31;
  if(!(*return_value___errno_location_30 == 0))
    tmp_if_expr_31 = (_Bool)1;

  else
    tmp_if_expr_31 = ctx->config.grey_mask > 32 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_32;
  if(tmp_if_expr_31)
    tmp_if_expr_32 = (_Bool)1;

  else
    tmp_if_expr_32 = ctx->config.grey_mask < 0 ? (_Bool)1 : (_Bool)0;
  const char *return_value_gconf_29;
  if(tmp_if_expr_32)
  {
    return_value_gconf_29=gconf(config, "grey_mask");
    daemon_shutdown(4, "Invalid grey_mask: %s", return_value_gconf_29);
  }

  ctx->config.status_host.sin_family = (unsigned short int)2;
  const char *return_value_gconf_33;
  return_value_gconf_33=gconf(config, "status_host");
  const char *tmp_if_expr_36;
  const char *return_value_gconf_34;
  const char *return_value_gconf_35;
  if(!(return_value_gconf_33 == ((const char *)NULL)))
  {
    return_value_gconf_34=gconf(config, "status_host");
    tmp_if_expr_36 = return_value_gconf_34;
  }

  else
  {
    return_value_gconf_35=gconf(config, "host");
    tmp_if_expr_36 = return_value_gconf_35;
  }
  host=gethostbyname(tmp_if_expr_36);
  if(host == ((struct hostent *)NULL))
    daemon_fatal("'status_host' configuration option invalid:");

  char *return_value_inet_ntoa_37;
  return_value_inet_ntoa_37=inet_ntoa(*((struct in_addr *)host->h_addr_list[(signed long int)0]));
  ret=inet_pton(2, return_value_inet_ntoa_37, (void *)&ctx->config.status_host.sin_addr);
  if(!(ret >= 0))
    daemon_fatal("error setting 'status_host':");

  else
    if(ret == 0)
      daemon_shutdown(4, "'status_host' configuration option invalid");

  const char *return_value_gconf_38;
  return_value_gconf_38=gconf(config, "status_port");
  signed int return_value_atoi_39;
  return_value_atoi_39=atoi(return_value_gconf_38);
  ctx->config.status_host.sin_port=htons((unsigned short int)return_value_atoi_39);
  const char *return_value_gconf_40;
  return_value_gconf_40=gconf(config, "rotate_interval");
  signed int return_value_atoi_41;
  return_value_atoi_41=atoi(return_value_gconf_40);
  ctx->config.rotate_interval = (signed long int)return_value_atoi_41;
  const char *return_value_gconf_42;
  return_value_gconf_42=gconf(config, "filter_bits");
  signed int return_value_atoi_43;
  return_value_atoi_43=atoi(return_value_gconf_42);
  ctx->config.filter_size = (unsigned int)return_value_atoi_43;
  const char *return_value_gconf_44;
  return_value_gconf_44=gconf(config, "number_buffers");
  signed int return_value_atoi_45;
  return_value_atoi_45=atoi(return_value_gconf_44);
  ctx->config.num_bufs = (unsigned int)return_value_atoi_45;
  const char *return_value_gconf_47;
  return_value_gconf_47=gconf(config, "statefile");
  const char *return_value_gconf_46;
  if(!(return_value_gconf_47 == ((const char *)NULL)))
  {
    return_value_gconf_46=gconf(config, "statefile");
    ctx->config.statefile=strdup(return_value_gconf_46);
  }

  else
    ctx->config.statefile = (char *)(void *)0;
  _Bool tmp_if_expr_48;
  if(!(ctx->config.filter_size >= 5u))
    tmp_if_expr_48 = (_Bool)1;

  else
    tmp_if_expr_48 = ctx->config.filter_size > (unsigned int)32 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_48)
    daemon_shutdown(4, "filter_bits should be in range [4,32]");

  const char *return_value_gconf_50;
  return_value_gconf_50=gconf(config, "postfix_response_grey");
  const char *return_value_gconf_49;
  if(return_value_gconf_50 == ((const char *)NULL))
    daemon_shutdown(4, "No postfix_response_grey set!");

  else
  {
    return_value_gconf_49=gconf(config, "postfix_response_grey");
    ctx->config.postfix.responsegrey=strdup(return_value_gconf_49);
  }
  const char *return_value_gconf_52;
  return_value_gconf_52=gconf(config, "postfix_response_block");
  const char *return_value_gconf_51;
  if(return_value_gconf_52 == ((const char *)NULL))
    daemon_shutdown(4, "No postfix_response_block set!");

  else
  {
    return_value_gconf_51=gconf(config, "postfix_response_block");
    ctx->config.postfix.responseblock=strdup(return_value_gconf_51);
  }
  const char *return_value_gconf_54;
  return_value_gconf_54=gconf(config, "sjsms_response_grey");
  const char *return_value_gconf_53;
  if(return_value_gconf_54 == ((const char *)NULL))
    daemon_shutdown(4, "No sjsms_response_grey set!");

  else
  {
    return_value_gconf_53=gconf(config, "sjsms_response_grey");
    ctx->config.sjsms.responsegrey=strdup(return_value_gconf_53);
  }
  const char *return_value_gconf_56;
  return_value_gconf_56=gconf(config, "sjsms_response_trust");
  const char *return_value_gconf_55;
  if(return_value_gconf_56 == ((const char *)NULL))
    daemon_shutdown(4, "No sjsms_response_trust set!");

  else
  {
    return_value_gconf_55=gconf(config, "sjsms_response_trust");
    ctx->config.sjsms.responsetrust=strdup(return_value_gconf_55);
  }
  const char *return_value_gconf_58;
  return_value_gconf_58=gconf(config, "sjsms_response_block");
  const char *return_value_gconf_57;
  if(return_value_gconf_58 == ((const char *)NULL))
    daemon_shutdown(4, "No sjsms_response_block set!");

  else
  {
    return_value_gconf_57=gconf(config, "sjsms_response_block");
    ctx->config.sjsms.responseblock=strdup(return_value_gconf_57);
  }
  const char *return_value_gconf_60;
  return_value_gconf_60=gconf(config, "sjsms_response_match");
  const char *return_value_gconf_59;
  if(return_value_gconf_60 == ((const char *)NULL))
    daemon_shutdown(4, "No sjsms_response_match set!");

  else
  {
    return_value_gconf_59=gconf(config, "sjsms_response_match");
    ctx->config.sjsms.responsematch=strdup(return_value_gconf_59);
  }
  const char *return_value_gconf_63;
  return_value_gconf_63=gconf(config, "stat_interval");
  const char *return_value_gconf_61;
  signed int return_value_atoi_62;
  if(!(return_value_gconf_63 == ((const char *)NULL)))
  {
    return_value_gconf_61=gconf(config, "stat_interval");
    return_value_atoi_62=atoi(return_value_gconf_61);
    ctx->config.stat_interval = (signed long int)return_value_atoi_62;
  }

  cp = config;
  while(!(cp == ((struct configlist_s *)NULL)))
  {
    signed int return_value_strcmp_65;
    return_value_strcmp_65=strcmp(cp->name, "pidfile");
    if(return_value_strcmp_65 == 0)
    {
      ctx->config.pidfile=strdup(cp->value);
      ctx->config.flags = ctx->config.flags | (signed int)0x80;
      if(!(cp->params == ((struct params_s *)NULL)))
      {
        signed int return_value_strcmp_64;
        return_value_strcmp_64=strcmp(cp->params->value, "check");
        if(return_value_strcmp_64 == 0)
          ctx->config.flags = ctx->config.flags | (signed int)0x40;

        else
          daemon_shutdown(4, "invalid parameter for 'pidfile': %s", cp->params->value);
      }

    }

    cp = cp->next;
  }
  ctx->config.statlevel = 262144;
  cp = config;
  while(!(cp == ((struct configlist_s *)NULL)))
  {
    signed int return_value_strcmp_66;
    return_value_strcmp_66=strcmp(cp->name, "stat_type");
    if(!(return_value_strcmp_66 == 0))
      cp = cp->next;

    else
    {
      signed int return_value_strncmp_67;
      return_value_strncmp_67=strncmp(cp->value, "full", (unsigned long int)5);
      if(return_value_strncmp_67 == 0)
      {
        ctx->config.statlevel = 327679;
        break;
      }

      signed int return_value_strncmp_68;
      return_value_strncmp_68=strncmp(cp->value, "none", (unsigned long int)5);
      if(return_value_strncmp_68 == 0)
      {
        ctx->config.statlevel = 262144;
        break;
      }

      signed int return_value_strncmp_69;
      return_value_strncmp_69=strncmp(cp->value, "status", (unsigned long int)7);
      if(return_value_strncmp_69 == 0)
        ctx->config.statlevel = ctx->config.statlevel | 262145;

      signed int return_value_strncmp_70;
      return_value_strncmp_70=strncmp(cp->value, "since_startup", (unsigned long int)14);
      if(return_value_strncmp_70 == 0)
        ctx->config.statlevel = ctx->config.statlevel | 262146;

      signed int return_value_strncmp_71;
      return_value_strncmp_71=strncmp(cp->value, "delay", (unsigned long int)6);
      if(return_value_strncmp_71 == 0)
        ctx->config.statlevel = ctx->config.statlevel | 262148;

      cp = cp->next;
    }
  }
  *ctx->last_rotate=time((signed long int *)(void *)0);
  init_stats();
  cp = config;
  signed int return_value_atoi_72;
  while(!(cp == ((struct configlist_s *)NULL)))
  {
    signed int return_value_strcmp_73;
    return_value_strcmp_73=strcmp(cp->name, "dnsbl");
    if(return_value_strcmp_73 == 0)
    {
      if(!(cp->params == ((struct params_s *)NULL)))
      {
        return_value_atoi_72=atoi(cp->params->value);
        add_dnsbl(&ctx->dnsbl, cp->value, return_value_atoi_72);
      }

      else
        add_dnsbl(&ctx->dnsbl, cp->value, 1);
      stat_add_dnsbl(cp->value);
    }

    cp = cp->next;
  }
  cp = config;
  while(!(cp == ((struct configlist_s *)NULL)))
  {
    signed int return_value_strcmp_74;
    return_value_strcmp_74=strcmp(cp->name, "dnswl");
    if(return_value_strcmp_74 == 0)
    {
      add_dnsbl(&ctx->dnswl, cp->value, 1);
      stat_add_dnsbl(cp->value);
    }

    cp = cp->next;
  }
  cp = config;
  signed int return_value_atoi_75;
  while(!(cp == ((struct configlist_s *)NULL)))
  {
    signed int return_value_strcmp_76;
    return_value_strcmp_76=strcmp(cp->name, "rhsbl");
    if(return_value_strcmp_76 == 0)
    {
      if(!(cp->params == ((struct params_s *)NULL)))
      {
        return_value_atoi_75=atoi(cp->params->value);
        add_dnsbl(&ctx->rhsbl, cp->value, return_value_atoi_75);
      }

      else
        add_dnsbl(&ctx->rhsbl, cp->value, 1);
      stat_add_dnsbl(cp->value);
    }

    cp = cp->next;
  }
  const char *return_value_gconf_77;
  return_value_gconf_77=gconf(config, "pool_maxthreads");
  ctx->config.pool_maxthreads=atoi(return_value_gconf_77);
  const char *return_value_gconf_78;
  return_value_gconf_78=gconf(config, "query_timelimit");
  ctx->config.query_timelimit=atoi(return_value_gconf_78);
  cp = config;
  signed int return_value_strcmp_79;
  while(!(cp == ((struct configlist_s *)NULL)))
  {
    signed int return_value_strcmp_81;
    return_value_strcmp_81=strcmp(cp->name, "protocol");
    if(return_value_strcmp_81 == 0)
    {
      signed int return_value_strcmp_80;
      return_value_strcmp_80=strcmp(cp->value, "sjsms");
      if(return_value_strcmp_80 == 0)
        ctx->config.protocols = ctx->config.protocols | (signed int)0x01;

      else
      {
        return_value_strcmp_79=strcmp(cp->value, "postfix");
        if(return_value_strcmp_79 == 0)
          ctx->config.protocols = ctx->config.protocols | (signed int)0x02;

        else
          daemon_shutdown(4, "unknown protocol: %s", cp->value);
      }
    }

    cp = cp->next;
  }
  const char *return_value_gconf_82;
  return_value_gconf_82=gconf(config, "blocker_weight");
  ctx->config.blocker.weight=atoi(return_value_gconf_82);
  cp = config;
  signed int return_value_strcmp_86;
  signed int return_value_strcmp_85;
  signed int return_value_strcmp_84;
  signed int return_value_strcmp_83;
  while(!(cp == ((struct configlist_s *)NULL)))
  {
    signed int return_value_strcmp_88;
    return_value_strcmp_88=strcmp(cp->name, "check");
    if(return_value_strcmp_88 == 0)
    {
      signed int return_value_strcmp_87;
      return_value_strcmp_87=strcmp(cp->value, "dnsbl");
      if(return_value_strcmp_87 == 0)
        ctx->config.checks = ctx->config.checks | (signed int)0x01;

      else
      {
        return_value_strcmp_86=strcmp(cp->value, "dnswl");
        if(return_value_strcmp_86 == 0)
          ctx->config.checks = ctx->config.checks | (signed int)0x10;

        else
        {
          return_value_strcmp_85=strcmp(cp->value, "rhsbl");
          if(return_value_strcmp_85 == 0)
            ctx->config.checks = ctx->config.checks | (signed int)0x08;

          else
          {
            return_value_strcmp_84=strcmp(cp->value, "blocker");
            if(return_value_strcmp_84 == 0)
              ctx->config.checks = ctx->config.checks | (signed int)0x02;

            else
            {
              return_value_strcmp_83=strcmp(cp->value, "random");
              if(return_value_strcmp_83 == 0)
                ctx->config.checks = ctx->config.checks | (signed int)0x04;

            }
          }
        }
      }
    }

    cp = cp->next;
  }
  cp = config;
  signed int return_value_strcmp_105;
  _Bool tmp_if_expr_106;
  signed int return_value_strcmp_93;
  signed int return_value_strcmp_92;
  signed int return_value_strcmp_91;
  signed int return_value_strcmp_90;
  signed int return_value_strcmp_104;
  signed int return_value_strcmp_102;
  signed int return_value_strcmp_101;
  signed int return_value_strcmp_100;
  signed int return_value_strcmp_99;
  signed int return_value_strcmp_98;
  signed int return_value_strcmp_97;
  signed int return_value_strcmp_96;
  signed int return_value_strcmp_95;
  while(!(cp == ((struct configlist_s *)NULL)))
  {
    signed int return_value_strcmp_107;
    return_value_strcmp_107=strcmp(cp->name, "log_method");
    if(return_value_strcmp_107 == 0)
    {
      signed int return_value_strcmp_89;
      return_value_strcmp_89=strcmp(cp->value, "syslog");
      if(return_value_strcmp_89 == 0)
        ctx->config.flags = ctx->config.flags | (signed int)0x20;

    }

    else
    {
      return_value_strcmp_105=strcmp(cp->name, "log_level");
      if(return_value_strcmp_105 == 0)
        tmp_if_expr_106 = ctx->config.loglevel == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_106 = (_Bool)0;
      if(tmp_if_expr_106)
      {
        signed int return_value_strcmp_94;
        return_value_strcmp_94=strcmp(cp->value, "debug");
        if(return_value_strcmp_94 == 0)
          ctx->config.loglevel = 65543;

        else
        {
          return_value_strcmp_93=strcmp(cp->value, "info");
          if(return_value_strcmp_93 == 0)
            ctx->config.loglevel = 65542;

          else
          {
            return_value_strcmp_92=strcmp(cp->value, "notice");
            if(return_value_strcmp_92 == 0)
              ctx->config.loglevel = 65541;

            else
            {
              return_value_strcmp_91=strcmp(cp->value, "warning");
              if(return_value_strcmp_91 == 0)
                ctx->config.loglevel = 65540;

              else
              {
                return_value_strcmp_90=strcmp(cp->value, "error");
                if(return_value_strcmp_90 == 0)
                  ctx->config.loglevel = 65539;

                else
                  daemon_shutdown(4, "Unknown log_level: %s", cp->value);
              }
            }
          }
        }
      }

      else
      {
        return_value_strcmp_104=strcmp(cp->name, "syslog_facility");
        if(return_value_strcmp_104 == 0)
        {
          signed int return_value_strcmp_103;
          return_value_strcmp_103=strcmp(cp->value, "mail");
          if(return_value_strcmp_103 == 0)
            ctx->config.syslogfacility = 2 << 3;

          else
          {
            return_value_strcmp_102=strcmp(cp->value, "local0");
            if(return_value_strcmp_102 == 0)
              ctx->config.syslogfacility = 16 << 3;

            else
            {
              return_value_strcmp_101=strcmp(cp->value, "local1");
              if(return_value_strcmp_101 == 0)
                ctx->config.syslogfacility = 17 << 3;

              else
              {
                return_value_strcmp_100=strcmp(cp->value, "local2");
                if(return_value_strcmp_100 == 0)
                  ctx->config.syslogfacility = 18 << 3;

                else
                {
                  return_value_strcmp_99=strcmp(cp->value, "local3");
                  if(return_value_strcmp_99 == 0)
                    ctx->config.syslogfacility = 19 << 3;

                  else
                  {
                    return_value_strcmp_98=strcmp(cp->value, "local4");
                    if(return_value_strcmp_98 == 0)
                      ctx->config.syslogfacility = 20 << 3;

                    else
                    {
                      return_value_strcmp_97=strcmp(cp->value, "local5");
                      if(return_value_strcmp_97 == 0)
                        ctx->config.syslogfacility = 21 << 3;

                      else
                      {
                        return_value_strcmp_96=strcmp(cp->value, "local6");
                        if(return_value_strcmp_96 == 0)
                          ctx->config.syslogfacility = 22 << 3;

                        else
                        {
                          return_value_strcmp_95=strcmp(cp->value, "local7");
                          if(return_value_strcmp_95 == 0)
                            ctx->config.syslogfacility = 23 << 3;

                          else
                            daemon_shutdown(4, "Unknown syslog_facility: %s", cp->value);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

      }
    }
    cp = cp->next;
  }
  /* assertion ctx->config.loglevel */
  assert(ctx->config.loglevel != 0);
  /* assertion ctx->config.syslogfacility */
  assert(ctx->config.syslogfacility != 0);
  memset((void *)&ctx->config.blocker.server, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  if(!((0x02 & ctx->config.checks) == 0))
  {
    ctx->config.blocker.server.sin_family = (unsigned short int)2;
    const char *return_value_gconf_108;
    return_value_gconf_108=gconf(config, "blocker_host");
    if(return_value_gconf_108 == ((const char *)NULL))
      daemon_fatal("'blocker' configured, but 'blocker_host' not");

    const char *return_value_gconf_109;
    return_value_gconf_109=gconf(config, "blocker_host");
    host=gethostbyname(return_value_gconf_109);
    if(host == ((struct hostent *)NULL))
      daemon_fatal("'blocker_host' configuration option invalid:");

    char *return_value_inet_ntoa_110;
    return_value_inet_ntoa_110=inet_ntoa(*((struct in_addr *)host->h_addr_list[(signed long int)0]));
    ret=inet_pton(2, return_value_inet_ntoa_110, (void *)&ctx->config.blocker.server.sin_addr);
    if(!(ret >= 0))
      daemon_fatal("error setting 'blocker_host':");

    else
      if(ret == 0)
        daemon_shutdown(4, "'blocker_host' configuration option invalid");

    char *return_value_inet_ntoa_111;
    return_value_inet_ntoa_111=inet_ntoa(*((struct in_addr *)host->h_addr_list[(signed long int)0]));
    logstr(65543, "Blocker host address %s", return_value_inet_ntoa_111);
    const char *return_value_gconf_112;
    return_value_gconf_112=gconf(config, "blocker_port");
    signed int return_value_atoi_113;
    return_value_atoi_113=atoi(return_value_gconf_112);
    ctx->config.blocker.server.sin_port=htons((unsigned short int)return_value_atoi_113);
  }

  const char *return_value_gconf_115;
  return_value_gconf_115=gconf(config, "grey_threshold");
  const char *return_value_gconf_114;
  if(!(return_value_gconf_115 == ((const char *)NULL)))
  {
    return_value_gconf_114=gconf(config, "grey_threshold");
    ctx->config.grey_threshold=atoi(return_value_gconf_114);
  }

  else
    ctx->config.grey_threshold = 1;
  const char *return_value_gconf_117;
  return_value_gconf_117=gconf(config, "block_threshold");
  const char *return_value_gconf_116;
  if(!(return_value_gconf_117 == ((const char *)NULL)))
  {
    return_value_gconf_116=gconf(config, "block_threshold");
    ctx->config.block_threshold=atoi(return_value_gconf_116);
  }

  else
    ctx->config.block_threshold = 0;
  const char *return_value_gconf_119;
  return_value_gconf_119=gconf(config, "grey_reason");
  const char *return_value_gconf_118;
  if(!(return_value_gconf_119 == ((const char *)NULL)))
  {
    return_value_gconf_118=gconf(config, "grey_reason");
    ctx->config.grey_reason=strdup(return_value_gconf_118);
  }

  const char *return_value_gconf_121;
  return_value_gconf_121=gconf(config, "block_reason");
  const char *return_value_gconf_120;
  if(!(return_value_gconf_121 == ((const char *)NULL)))
  {
    return_value_gconf_120=gconf(config, "block_reason");
    ctx->config.block_reason=strdup(return_value_gconf_120);
  }

  if(ctx->config.block_threshold == 0)
    ctx->config.flags = ctx->config.flags | (signed int)0x0100;

}

// connected
// file srvutils.c line 145
signed int connected(struct peer_s *peer)
{
  return peer->connected;
}

// convert_int32_big_endian
// file sha256.c line 103
void convert_int32_big_endian(unsigned int *num)
{
  do
    num = num;
  while((_Bool)0);
}

// convert_int32_little_endian
// file sha256.c line 94
void convert_int32_little_endian(unsigned int *num)
{
  unsigned char *index = (unsigned char *)num;
  swap_bytes(index + (signed long int)0, index + (signed long int)3);
  swap_bytes(index + (signed long int)1, index + (signed long int)2);
}

// convert_int64_big_endian
// file sha256.c line 86
void convert_int64_big_endian(unsigned long int *num)
{
  do
    num = num;
  while((_Bool)0);
}

// convert_int64_little_endian
// file sha256.c line 75
void convert_int64_little_endian(unsigned long int *num)
{
  unsigned char *index = (unsigned char *)num;
  swap_bytes(index + (signed long int)0, index + (signed long int)7);
  swap_bytes(index + (signed long int)1, index + (signed long int)6);
  swap_bytes(index + (signed long int)2, index + (signed long int)5);
  swap_bytes(index + (signed long int)3, index + (signed long int)4);
}

// copy_bloom_filter
// file bloom.c line 218
struct anonymous_24 * copy_bloom_filter(struct anonymous_24 *filter, signed int empty)
{
  struct anonymous_24 *tmp;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct anonymous_24) /*24ul*/ );
  tmp = (struct anonymous_24 *)return_value_Malloc_1;
  /* assertion tmp */
  assert(tmp != ((struct anonymous_24 *)NULL));
  tmp->bitsize = filter->bitsize;
  tmp->mask = filter->mask;
  tmp->size = filter->size;
  void *return_value_Malloc_2;
  return_value_Malloc_2=Malloc((unsigned long int)(tmp->bitsize / (unsigned int)8));
  tmp->filter = (unsigned int *)return_value_Malloc_2;
  /* assertion tmp->filter */
  assert(tmp->filter != ((unsigned int *)NULL));
  if(!(empty == 0))
    zero_bloom_filter(tmp);

  else
    memcpy((void *)tmp->filter, (const void *)filter->filter, (unsigned long int)(tmp->bitsize / (unsigned int)8));
  return tmp;
}

// create_bloom_filter
// file bloom.c line 179
struct anonymous_24 * create_bloom_filter(unsigned int num_bits)
{
  struct anonymous_24 *result;
  /* assertion num_bits < sizeof(num_bits) * ((uint32_t)8) */
  assert((unsigned long int)num_bits < sizeof(unsigned int) /*4ul*/  * (unsigned long int)(unsigned int)8);
  /* assertion num_bits >= 4 */
  assert(num_bits >= (unsigned int)4);
  /* assertion num_bits <= 32 */
  assert(num_bits <= (unsigned int)32);
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct anonymous_24) /*24ul*/ );
  result = (struct anonymous_24 *)return_value_Malloc_1;
  /* assertion result */
  assert(result != ((struct anonymous_24 *)NULL));
  result->bitsize = (unsigned int)(1 << num_bits);
  result->mask = (unsigned int)-1 >> BITARRAY_BASE_SIZE - num_bits;
  void *return_value_Malloc_2;
  return_value_Malloc_2=Malloc((unsigned long int)(result->bitsize / (unsigned int)8));
  result->filter = (unsigned int *)return_value_Malloc_2;
  result->size = result->bitsize / BITARRAY_BASE_SIZE;
  zero_bloom_filter(result);
  return result;
}

// create_bloom_filter_group
// file bloom.c line 241
struct anonymous_23 * create_bloom_filter_group(unsigned int num, unsigned int num_bits)
{
  struct anonymous_23 *result;
  unsigned int i;
  /* assertion num > 0 */
  assert(num > (unsigned int)0);
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct anonymous_23) /*16ul*/ );
  result = (struct anonymous_23 *)return_value_Malloc_1;
  result->group_size = num;
  void *return_value_Malloc_2;
  return_value_Malloc_2=Malloc(sizeof(struct anonymous_23 *) /*8ul*/  * (unsigned long int)num);
  result->filter_group = (struct anonymous_24 **)return_value_Malloc_2;
  /* assertion result->filter_group */
  assert(result->filter_group != ((struct anonymous_24 **)NULL));
  i = (unsigned int)0;
  for( ; !(i >= result->group_size); i = i + 1u)
  {
    result->filter_group[(signed long int)i]=create_bloom_filter(num_bits);
    /* assertion result->filter_group[i] */
    assert(result->filter_group[(signed long int)i] != ((struct anonymous_24 *)NULL));
  }
  return result;
}

// create_bloom_ring_queue
// file bloom.c line 327
struct anonymous_22 * create_bloom_ring_queue(unsigned int num, unsigned int num_bits)
{
  struct anonymous_22 *result;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct anonymous_22) /*24ul*/ );
  result = (struct anonymous_22 *)return_value_Malloc_1;
  result->group=create_bloom_filter_group(num, num_bits);
  result->current_index = (unsigned int)0;
  result->aggregate=create_bloom_filter(num_bits);
  return result;
}

// create_pidfile
// file srvutils.c line 399
void create_pidfile(void)
{
  struct _IO_FILE *pf;
  signed int ret;
  /* assertion ctx->config.pidfile */
  assert(ctx->config.pidfile != ((char *)NULL));
  logstr(65542, "creating pidfile %s", ctx->config.pidfile);
  pf=fopen(ctx->config.pidfile, "w");
  if(!(pf == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    ret=fprintf(pf, "%d", return_value_getpid_1);
    if(!(ret >= 0))
      daemon_fatal("writing pidfile");

  }

  else
    daemon_fatal("opening pidfile: fdopen");
  fclose(pf);
}

// create_queue
// file msgqueue.c line 187
struct msgqueue_s * create_queue(void)
{
  struct msgqueue_s *mq;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct msgqueue_s) /*144ul*/ );
  mq = (struct msgqueue_s *)return_value_Malloc_1;
  memset((void *)mq, 0, sizeof(struct msgqueue_s) /*144ul*/ );
  pthread_cond_init(&mq->cv, (const union anonymous_29 *)(void *)0);
  pthread_mutex_init(&mq->mx, (const union anonymous_29 *)(void *)0);
  return mq;
}

// create_statefile
// file srvutils.c line 186
void create_statefile(void)
{
  signed int ret;
  unsigned long int lumpsize;
  signed int i;
  struct stat statbuf;
  struct _IO_FILE *statefile;
  unsigned int num = ctx->config.num_bufs;
  unsigned int num_bits = ctx->config.filter_size;
  lumpsize = sizeof(struct anonymous_22) /*24ul*/  + sizeof(struct anonymous_23) /*16ul*/  + (unsigned long int)num * sizeof(struct anonymous_24 *) /*8ul*/  + (unsigned long int)(num + (unsigned int)1) * sizeof(struct anonymous_24) /*24ul*/  + (unsigned long int)((num + (unsigned int)1) * ((unsigned int)(1 << num_bits) / (unsigned int)8)) + sizeof(struct anonymous_44) /*32ul*/ ;
  ret=stat(ctx->config.statefile, &statbuf);
  signed int *return_value___errno_location_2;
  signed int return_value_fputc_1;
  if(ret == 0)
    daemon_shutdown(2, "statefile already exists");

  else
  {
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 2)
    {
      statefile=fopen(ctx->config.statefile, "w");
      if(statefile == ((struct _IO_FILE *)NULL))
        daemon_fatal("stat(): statefile creation failed");

      i = 0;
      for( ; !((unsigned long int)i >= lumpsize); i = i + 1)
      {
        return_value_fputc_1=fputc(0, statefile);
        if(!(return_value_fputc_1 == 0))
          daemon_fatal("fputc()");

      }
      fclose(statefile);
      goto __CPROVER_DUMP_L8;
    }

    else
      daemon_fatal("statefile opening failed: stat:");
  }

__CPROVER_DUMP_L8:
  ;
}

// create_thread
// file srvutils.c line 502
void * create_thread(struct anonymous_40 *tinfo, signed int detach, void * (*routine)(void *), void *arg)
{
  unsigned long int *tid;
  union pthread_attr_t tattr;
  signed int ret;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(unsigned long int) /*8ul*/ );
  tid = (unsigned long int *)return_value_Malloc_1;
  ret=pthread_attr_init(&tattr);
  if(!(ret == 0))
    daemon_fatal("pthread_attr_init");

  if(detach == 1)
  {
    ret=pthread_attr_setdetachstate(&tattr, 1);
    if(!(ret == 0))
      daemon_fatal("pthread_attr_setdetachstate");

  }

  ret=pthread_attr_setstacksize(&tattr, (unsigned long int)(1024 * 1024));
  if(!(ret == 0))
    daemon_fatal("pthread_attr_setstacksize");

  ret=pthread_create(tid, &tattr, routine, arg);
  if(!(ret == 0))
    daemon_fatal("pthread_create");

  if(!(tinfo == ((struct anonymous_40 *)NULL)))
    tinfo->thread = tid;

  else
  {
    /* assertion tid */
    assert(tid != ((unsigned long int *)NULL));
    free((void *)tid);
    tid = (unsigned long int *)(void *)0;
  }
  pthread_attr_destroy(&tattr);
  return (void *)tid;
}

// create_thread_pool
// file thread_pool.c line 208
struct thread_pool_s * create_thread_pool(const char *name, signed int (*routine)(struct thread_pool_s *, struct anonymous_32 *, struct edict_s *), struct anonymous_33 *limits, void *arg)
{
  struct thread_pool_s *pool;
  union anonymous_27 *pool_mx;
  struct pool_ctx_s *pool_ctx;
  signed int ret;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct thread_pool_s) /*24ul*/ );
  pool = (struct thread_pool_s *)return_value_Malloc_1;
  pool->work_queue_id=get_queue();
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_5;
  if(!(pool->work_queue_id >= 0))
  {
    /* assertion pool */
    assert(pool != ((struct thread_pool_s *)NULL));
    free((void *)pool);
    pool = (struct thread_pool_s *)(void *)0;
    return (struct thread_pool_s *)(void *)0;
  }

  else
  {
    pool->arg = arg;
    pool->name = name;
    void *return_value_Malloc_2;
    return_value_Malloc_2=Malloc(sizeof(union anonymous_27) /*40ul*/ );
    pool_mx = (union anonymous_27 *)return_value_Malloc_2;
    ret=pthread_mutex_init(pool_mx, (const union anonymous_29 *)(void *)0);
    if(!(ret == 0))
      daemon_fatal("pthread_mutex_init");

    void *return_value_Malloc_3;
    return_value_Malloc_3=Malloc(sizeof(struct pool_ctx_s) /*80ul*/ );
    pool_ctx = (struct pool_ctx_s *)return_value_Malloc_3;
    pool_ctx->mx = pool_mx;
    pool_ctx->routine = routine;
    pool_ctx->info = pool;
    pool_ctx->count_thread = 0;
    pool_ctx->count_idle = 0;
    pool_ctx->ewma_idle = (float)0;
    if(!(limits == ((struct anonymous_33 *)NULL)))
      tmp_if_expr_4 = limits->max_thread;

    else
      tmp_if_expr_4 = 0;
    pool_ctx->max_thread = tmp_if_expr_4;
    if(!(limits == ((struct anonymous_33 *)NULL)))
      tmp_if_expr_5 = limits->watchdog_time;

    else
      tmp_if_expr_5 = 0;
    pool_ctx->watchdog_time = tmp_if_expr_5;
    pool_ctx->wdlist = (struct watchdog_s *)(void *)0;
    create_thread((struct anonymous_40 *)(void *)0, 1, thread_pool, (void *)pool_ctx);
    return pool;
  }
}

// daemon_fatal
// file srvutils.c line 124
void daemon_fatal(const char *reason)
{
  char *combo;
  char *errstr;
  signed int errnum;
  unsigned long int combolen;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  errnum = *return_value___errno_location_1;
  errstr=strerror(errnum);
  /* assertion errstr */
  assert(errstr != ((char *)NULL));
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(reason);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(errstr);
  combolen = return_value_strlen_2 + (unsigned long int)1 + return_value_strlen_3 + (unsigned long int)1;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(combolen);
  combo = (char *)return_value_malloc_4;
  /* assertion combo */
  assert(combo != ((char *)NULL));
  snprintf(combo, combolen, "%s %s\n", reason, errstr);
  daemon_shutdown(2, combo);
}

// daemon_shutdown
// file srvutils.c line 97
void daemon_shutdown(signed int return_code, const char *fmt, ...)
{
  char logfmt[1024l];
  char out[1024l];
  void **vap;
  if(!(fmt == ((const char *)NULL)))
  {
    snprintf(logfmt, (unsigned long int)1024, "Grossd shutdown with exit code %d: %s", return_code, fmt);
    vap = (void **)&fmt;
    vsnprintf(out, (unsigned long int)1024, logfmt, vap);
    vap = ((void **)NULL);
    fprintf(stderr, "%s\n", (const void *)out);
    if(!(ctx->syslog_open == 0))
      logstr(65539, "%s", (const void *)out);

  }

  if(return_code == 0)
  {
    if(!((0x80 & ctx->config.flags) == 0))
    {
      if(!(ctx->config.pidfile == ((char *)NULL)))
        unlink(ctx->config.pidfile);

    }

  }

  exit(return_code);
}

// daemonize
// file srvutils.c line 440
void daemonize(void)
{
  signed int i;
  signed int pid;
  log_close();
  pid=fork();
  if(pid >= 1)
  {
    log_open();
    exit(0);
  }

  else
    if(!(pid >= 0))
    {
      log_open();
      daemon_fatal("fork(): ");
    }

  pid=setsid();
  if(!(pid >= 0))
  {
    log_open();
    daemon_fatal("setsid(): ");
  }

  pid=fork();
  if(pid >= 1)
  {
    log_open();
    exit(0);
  }

  else
    if(!(pid >= 0))
    {
      log_open();
      daemon_fatal("fork: ");
    }

  close(0);
  open("/dev/null", 00, 0);
  close(1);
  open("/dev/null", 01, 0);
  close(2);
  open("/dev/null", 01, 0);
  i = 3;
  for( ; !(i >= 64); i = i + 1)
    close(i);
  log_open();
}

// date_fmt
// file srvutils.c line 552
unsigned long int date_fmt(char *msg, unsigned long int len)
{
  signed long int tt;
  char timestr[26l];
  char buf[1024l];
  tt=time((signed long int *)(void *)0);
  ctime_r(&tt, timestr);
  chomp(timestr);
  snprintf(buf, (unsigned long int)(1024 - 1), "%s %s\n", (const void *)timestr, msg);
  strncpy(msg, buf, len - (unsigned long int)1);
  msg[(signed long int)(len - (unsigned long int)1)] = (char)0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(msg);
  return return_value_strlen_1;
}

// debug_print_array_index
// file bloom.c line 69
void debug_print_array_index(struct anonymous_39 index, signed int with_newline)
{
  printf("array index=%d intra index=%d", index.array_index, index.intra_index);
  if(!(with_newline == 0))
    printf("\n");

}

// debug_print_bit_up
// file bloom.c line 77
void debug_print_bit_up(unsigned int *array, unsigned int bit_index, signed int with_newline)
{
  struct anonymous_39 index;
  index=array_index(bit_index);
  unsigned int bit;
  bit=get_bit(array, bit_index);
  /* assertion array */
  assert(array != ((unsigned int *)NULL));
  printf("bit %d at (", bit_index);
  debug_print_array_index(index, 0);
  printf(") is %d", bit);
  if(!(with_newline == 0))
    printf("\n");

}

// debug_print_bits
// file bloom.c line 53
void debug_print_bits(signed int value, signed int with_newline)
{
  signed int i = 31;
  for( ; i >= 0; i = i - 1)
    if(!((value >> i & 0x01) == 0))
      printf("1");

    else
      printf("0");
  if(!(with_newline == 0))
    printf("\n");

}

// debug_print_digest
// file sha256.c line 111
void debug_print_digest(struct anonymous_18 digest, signed int with_newline)
{
  printf("sha256: %08x %08x %08x %08x %08x %08x %08x %08x", digest.h0, digest.h1, digest.h2, digest.h3, digest.h4, digest.h5, digest.h6, digest.h7);
  if(!(with_newline == 0))
    printf("\n");

}

// debug_print_filter
// file bloom.c line 38
void debug_print_filter(struct anonymous_24 *filter, signed int with_newline)
{
  signed int i;
  /* assertion filter */
  assert(filter != ((struct anonymous_24 *)NULL));
  i = 0;
  for( ; !((unsigned int)i >= filter->size); i = i + 1)
    debug_print_bits((signed int)filter->filter[(signed long int)i], 0);
  if(!(with_newline == 0))
    printf("\n");

}

// debug_print_ring_queue
// file bloom.c line 409
void debug_print_ring_queue(struct anonymous_22 *brq, signed int with_newline)
{
  unsigned int i;
  /* assertion brq */
  assert(brq != ((struct anonymous_22 *)NULL));
  printf("Aggregate: ");
  debug_print_filter(brq->aggregate, 1);
  i = (unsigned int)0;
  for( ; !(i >= brq->group->group_size); i = i + 1u)
  {
    printf("Filter %d: ", i);
    debug_print_filter(brq->group->filter_group[(signed long int)i], 1);
  }
  if(!(with_newline == 0))
    printf("\n");

}

// default_config
// file conf.c line 273
struct configlist_s * default_config(void)
{
  struct configlist_s *config;
  signed int i;
  const char *defaults[61l] = { "update", "grey", "host", "127.0.0.1", "port", "5525", "sync_port", "5524", "status_port", "5522", "rotate_interval", "3600", "filter_bits", "24", "number_buffers", "8", "stat_interval", "300", "postfix_response_grey", "action=defer_if_permit %reason%", "postfix_response_block", "action=reject %reason%", "sjsms_response_grey", "_X4.4.3|_N%reason%", "sjsms_response_match", "_Y", "sjsms_response_trust", "_Y", "sjsms_response_block", "_N%reason%", "log_method", "syslog", "log_level", "info", "stat_type", "delay", "stat_type", "status", "grey_mask", "24", "grey_delay", "10", "syslog_facility", "mail", "blocker_port", "4466", "blocker_weight", "1", "block_threshold", "0", "grey_threshold", "1", "grey_reason", "Please try again later", "block_reason", "Bad reputation", "query_timelimit", "5000", "pool_maxthreads", "100", (const char *)(void *)0 };
  config = (struct configlist_s *)(void *)0;
  i = 0;
  for( ; !(defaults[(signed long int)i] == ((const char *)NULL)); i = i + 2)
  {
    /* assertion defaults[i] */
    assert(defaults[(signed long int)i] != ((const char *)NULL));
    /* assertion defaults[i + 1] */
    assert(defaults[(signed long int)(i + 1)] != ((const char *)NULL));
    add_config_item(&config, defaults[(signed long int)i], defaults[(signed long int)(i + 1)], (struct params_s *)(void *)0, 1);
  }
  return config;
}

// delay
// file msgqueue.c line 142
void * delay(void *arg)
{
  struct anonymous_28 *queue_info;
  struct msg_s *msg;
  struct timespec sleeptime;
  struct timespec reftime;
  struct timespec sleepleft;
  struct timespec now;
  struct timespec *msgtimestamp;
  signed int ret;
  logstr(65543, "delay queue manager thread starting");
  queue_info = (struct anonymous_28 *)arg;
  _Bool tmp_if_expr_1;
  do
  {
    logstr(65544, "waiting for messages");
    msgtimestamp=peek_msg_timestamp(queue_info->inq);
    if(!(msgtimestamp == ((struct timespec *)NULL)))
    {
      if(!(*queue_info->inq->impose_delay == 0))
      {
        if(!(queue_info->inq->delay_ts == ((struct timespec *)NULL)))
        {
          if(!(queue_info->inq->delay_ts->tv_sec == 0l))
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = queue_info->inq->delay_ts->tv_nsec != 0l ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_1)
          {
            clock_gettime(1, &now);
            ts_sum(&reftime, msgtimestamp, queue_info->inq->delay_ts);
            ret=ts_diff(&sleeptime, &reftime, &now);
            if(ret == 0)
              do
              {
                logstr(65544, "reftime in future, sleeping for %d.%d seconds", sleeptime.tv_sec, sleeptime.tv_nsec);
                ret=nanosleep(&sleeptime, &sleepleft);
                if(!(ret == 0))
                {
                  sleeptime.tv_sec = sleepleft.tv_sec;
                  sleeptime.tv_nsec = sleepleft.tv_nsec;
                }

              }
              while(!(ret == 0));

          }

        }

      }

    }

    msg=get_msg_raw(queue_info->inq, 0);
    /* assertion msg->next == ((void *)0) */
    assert(msg->next == (struct msg_s *)(void *)0);
    logstr(65544, "passing message from inq to outq");
    put_msg_raw(queue_info->outq, msg);
  }
  while((_Bool)1);
}

// disable_delay
// file msgqueue.c line 253
signed int disable_delay(signed int msqid)
{
  signed int return_value_set_delay_status_1;
  return_value_set_delay_status_1=set_delay_status(msqid, 0);
  return return_value_set_delay_status_1;
}

// dnsbl_init
// file ../include/check_dnsbl.h line 52
void dnsbl_init(struct anonymous_37 *check_info, struct anonymous_33 *limits)
{
  struct thread_pool_s *pool;
  logstr(65542, "initializing dns checker thread pool '%s'", check_info->name);
  pool=create_thread_pool(check_info->name, dnsblc, limits, (void *)check_info);
  if(pool == ((struct thread_pool_s *)NULL))
    daemon_fatal("create_thread_pool");

  register_check(pool, check_info->definitive);
}

// dnsbl_stats
// file ../include/stats.h line 68
char * dnsbl_stats(char *buf, signed int size)
{
  signed int count = 0;
  struct dnsbl_stat *cur = ctx->stats.dnsbl_match;
  char *tick = buf;
  count=snprintf(tick, (unsigned long int)size, "grossd dnsbl matches (");
  tick = tick + (signed long int)count;
  size = size - count;
  for( ; !(cur == ((struct dnsbl_stat *)NULL)); cur = cur->next)
  {
    count=snprintf(tick, (unsigned long int)size, "%s", cur->dnsbl_name);
    tick = tick + (signed long int)count;
    size = size - count;
    if(!(cur->next == ((struct dnsbl_stat *)NULL)))
    {
      count=snprintf(tick, (unsigned long int)size, ", ");
      tick = tick + (signed long int)count;
      size = size - count;
    }

  }
  count=snprintf(tick, (unsigned long int)size, "): ");
  tick = tick + (signed long int)count;
  size = size - count;
  cur = ctx->stats.dnsbl_match;
  for( ; !(cur == ((struct dnsbl_stat *)NULL)); cur = cur->next)
  {
    count=snprintf(tick, (unsigned long int)size, "%llu", cur->matches_startup);
    tick = tick + (signed long int)count;
    size = size - count;
    if(!(cur->next == ((struct dnsbl_stat *)NULL)))
    {
      count=snprintf(tick, (unsigned long int)size, ", ");
      tick = tick + (signed long int)count;
      size = size - count;
    }

  }
  return buf;
}

// dnsblc
// file check_dnsbl.c line 207
signed int dnsblc(struct thread_pool_s *info, struct anonymous_32 *thread_ctx, struct edict_s *edict)
{
  struct ares_channeldata **channel;
  signed int nfds;
  signed int count;
  signed int ret;
  signed int done = 0;
  signed int timeout = 0;
  struct anonymous_36 readers;
  struct anonymous_36 writers;
  struct timeval tv;
  struct timespec ts;
  struct timespec start;
  struct timespec now;
  struct timespec timeleft;
  char buffer[256l];
  char *query;
  char *qstr;
  char *sender;
  char *ptr;
  const char *orig_qstr;
  struct dnsbl_s *dnsbl;
  struct anonymous_38 *callback_arg;
  const char *dnslname;
  signed int timeused;
  struct chkresult_s *result;
  struct grey_tuple_s *request;
  struct anonymous_37 *check_info;
  struct ares_options ares_opts = { .flags=0, .timeout=0, .tries=0, .ndots=0, .udp_port=0,
    .tcp_port=0, .socket_send_buffer_size=0, .socket_receive_buffer_size=0,
    .servers=((struct in_addr *)NULL), .nservers=0,
    .domains=((char **)NULL), .ndomains=0,
    .lookups=((char *)NULL), .sock_state_cb=((void (*)(void *, signed int, signed int, signed int))NULL),
    .sock_state_cb_data=NULL,
    .sortlist=((struct apattern *)NULL), .nsort=0,
    .ednspsz=0 };
  logstr(65543, "dnsblc called: timelimit %d", edict->timelimit);
  /* assertion info */
  assert(info != ((struct thread_pool_s *)NULL));
  /* assertion info->arg */
  assert(info->arg != NULL);
  check_info = (struct anonymous_37 *)info->arg;
  if(thread_ctx->state == NULL)
  {
    ares_opts.lookups = "b";
    void *return_value_Malloc_1;
    return_value_Malloc_1=Malloc(sizeof(struct ares_channeldata *) /*8ul*/ );
    channel = (struct ares_channeldata **)return_value_Malloc_1;
    signed int return_value_ares_init_options_2;
    return_value_ares_init_options_2=ares_init_options(channel, &ares_opts, 1 << 8);
    if(!(return_value_ares_init_options_2 == 0))
    {
      perror("ares_init");
      goto FINISH;
    }

    thread_ctx->state = (void *)channel;
    thread_ctx->cleanup = (signed int (*)())cleanup_dnsblc;
  }

  else
    channel = (struct ares_channeldata **)thread_ctx->state;
  request = (struct grey_tuple_s *)edict->job;
  /* assertion request */
  assert(request != ((struct grey_tuple_s *)NULL));
  void *return_value_Malloc_3;
  return_value_Malloc_3=Malloc(sizeof(struct chkresult_s) /*32ul*/ );
  result = (struct chkresult_s *)return_value_Malloc_3;
  memset((void *)result, 0, sizeof(struct chkresult_s) /*32ul*/ );
  _Bool tmp_if_expr_6;
  if((signed int)check_info->type == TYPE_DNSBL)
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = (signed int)check_info->type == TYPE_DNSWL ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_6)
  {
    /* assertion request->client_address */
    assert(request->client_address != ((char *)NULL));
    orig_qstr = request->client_address;
    qstr=strdup(request->client_address);
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(qstr);
    if(return_value_strlen_4 >= 16ul)
    {
      logstr(65539, "invalid ipaddress: %s", qstr);
      /* assertion qstr */
      assert(qstr != ((char *)NULL));
      free((void *)qstr);
      qstr = (char *)(void *)0;
      goto FINISH;
    }

    ret=reverse_inet_addr(qstr);
    if(!(ret >= 0))
    {
      /* assertion qstr */
      assert(qstr != ((char *)NULL));
      free((void *)qstr);
      qstr = (char *)(void *)0;
      goto FINISH;
    }

  }

  else
    if((signed int)check_info->type == TYPE_RHSBL)
    {
      sender=strdup(request->sender);
      /* assertion sender */
      assert(sender != ((char *)NULL));
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(sender);
      ptr = sender + (signed long int)return_value_strlen_5;
      for( ; !(sender >= ptr); ptr = ptr - 1l)
        if((signed int)*ptr == 64)
          break;

      if(!(sender >= ptr))
      {
        qstr=strdup(ptr + (signed long int)1);
        orig_qstr = qstr;
        /* assertion sender */
        assert(sender != ((char *)NULL));
        free((void *)sender);
        sender = (char *)(void *)0;
      }

      else
      {
        /* assertion sender */
        assert(sender != ((char *)NULL));
        free((void *)sender);
        sender = (char *)(void *)0;
        goto FINISH;
      }
    }

    else
    {
      logstr(65539, "invalid check type");
      goto FINISH;
    }
  dnsbl = check_info->dnsbase;
  while(!(dnsbl == ((struct dnsbl_s *)NULL)))
  {
    /* assertion dnsbl->name */
    assert(dnsbl->name != ((const char *)NULL));
    unsigned long int return_value_strlen_7;
    return_value_strlen_7=strlen(dnsbl->name);
    snprintf(buffer, (unsigned long int)256, "%s.%s%s", qstr, dnsbl->name, (signed int)*((dnsbl->name + (signed long int)return_value_strlen_7) - (signed long int)1) != 46 ? "." : "");
    query=strdup(buffer);
    signed int return_value_query_clearance_9;
    return_value_query_clearance_9=query_clearance(dnsbl);
    if(return_value_query_clearance_9 == 1)
    {
      logstr(65544, "initiating dns query: %s", query);
      void *return_value_Malloc_8;
      return_value_Malloc_8=Malloc(sizeof(struct anonymous_38) /*56ul*/ );
      callback_arg = (struct anonymous_38 *)return_value_Malloc_8;
      callback_arg->dnsbl = dnsbl;
      callback_arg->done = &done;
      callback_arg->dnslname = &dnslname;
      callback_arg->timeout = &timeout;
      callback_arg->querystr = orig_qstr;
      callback_arg->edict = edict;
      callback_arg->check_info = check_info;
      ares_gethostbyname(*channel, query, 2, addrinfo_callback, (void *)callback_arg);
    }

    else
      logstr(65543, "skipping dnsbl %s due to timeouts.", dnsbl->name);
    /* assertion query */
    assert(query != ((char *)NULL));
    free((void *)query);
    query = (char *)(void *)0;
    dnsbl = dnsbl->next;
  }
  clock_gettime(1, &start);
  _Bool tmp_if_expr_10;
  while(timeout == 0)
  {
    do
    {
      clock_gettime(1, &now);
      timeused=ms_diff(&now, &start);
      if(timeused >= edict->timelimit)
        break;

      mstotimespec(edict->timelimit - timeused, &timeleft);
      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_36) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readers)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      do
      {
        signed int dnsblc__1__7__1__2____d0;
        signed int dnsblc__1__7__1__2____d1;
        asm("cld; rep; stosq" : "=c"(dnsblc__1__7__1__2____d0), "=D"(dnsblc__1__7__1__2____d1) : "a"(0), "0"(sizeof(struct anonymous_36) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&writers)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      nfds=ares_fds(*channel, &readers, &writers);
      if(nfds == 0)
        break;

      ares_timeout(*channel, (struct timeval *)(void *)0, &tv);
      tvtots(&tv, &ts);
      signed int return_value_ms_diff_11;
      return_value_ms_diff_11=ms_diff(&timeleft, &ts);
      if(!(return_value_ms_diff_11 >= 0))
        memcpy((void *)&ts, (const void *)&timeleft, sizeof(struct timespec) /*16ul*/ );

      tstotv(&ts, &tv);
      count=select(nfds, &readers, &writers, (struct anonymous_36 *)(void *)0, &tv);
      ares_process(*channel, &readers, &writers);
      if(!(done == 0))
        tmp_if_expr_10 = (_Bool)1;

      else
        tmp_if_expr_10 = edict->obsolete != 0 ? (_Bool)1 : (_Bool)0;
    }
    while(!tmp_if_expr_10);
    clock_gettime(1, &now);
    timeused=ms_diff(&now, &start);
    if(timeused >= edict->timelimit)
    {
      logstr(65544, "dnsbl timeout");
      timeout = 1;
    }

    if(nfds == 0 || !(edict->obsolete == 0) || !(done == 0))
      break;

  }
  /* assertion qstr */
  assert(qstr != ((char *)NULL));
  free((void *)qstr);
  qstr = (char *)(void *)0;
  ares_cancel(*channel);

FINISH:
  ;
  _Bool tmp_if_expr_12;
  if(!(done == 0))
    tmp_if_expr_12 = (signed int)check_info->type == TYPE_DNSWL ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_12 = (_Bool)0;
  if(tmp_if_expr_12)
  {
    result->judgment = (enum anonymous_0)J_PASS;
    result->checkname = dnslname;
  }

  else
    result->judgment = (enum anonymous_0)J_UNDEFINED;
  send_result(edict, (void *)result);
  logstr(65543, "dnsblc returning");
  request_unlink(request);
  return 0;
}

// dtoh
// file syncmgr.c line 93
struct anonymous_18 dtoh(struct anonymous_18 digest)
{
  struct anonymous_18 ret_value;
  ret_value.h0=ntohl(digest.h0);
  ret_value.h1=ntohl(digest.h1);
  ret_value.h2=ntohl(digest.h2);
  ret_value.h3=ntohl(digest.h3);
  ret_value.h4=ntohl(digest.h4);
  ret_value.h5=ntohl(digest.h5);
  ret_value.h6=ntohl(digest.h6);
  ret_value.h7=ntohl(digest.h7);
  return ret_value;
}

// dton
// file syncmgr.c line 76
struct anonymous_18 dton(struct anonymous_18 digest)
{
  struct anonymous_18 ret_value;
  ret_value.h0=htonl(digest.h0);
  ret_value.h1=htonl(digest.h1);
  ret_value.h2=htonl(digest.h2);
  ret_value.h3=htonl(digest.h3);
  ret_value.h4=htonl(digest.h4);
  ret_value.h5=htonl(digest.h5);
  ret_value.h6=htonl(digest.h6);
  ret_value.h7=htonl(digest.h7);
  return ret_value;
}

// edict_get
// file thread_pool.c line 286
struct edict_s * edict_get(signed int forget)
{
  struct edict_s *edict;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct edict_s) /*72ul*/ );
  edict = (struct edict_s *)return_value_Malloc_1;
  bzero((void *)edict, sizeof(struct edict_s) /*72ul*/ );
  if(forget == 0)
    edict->resultmq=get_queue();

  else
    edict->resultmq = -1;
  pthread_mutex_init(&edict->reference.mx, (const union anonymous_29 *)(void *)0);
  edict->reference.count = 1;
  return edict;
}

// edict_reference
// file thread_pool.c line 253
void edict_reference(struct edict_s *edict)
{
  signed int ret;
  ret=pthread_mutex_lock(&edict->reference.mx);
  /* assertion 0 == ret */
  assert(0 == ret);
  edict->reference.count = edict->reference.count + 1;
  ret=pthread_mutex_unlock(&edict->reference.mx);
  /* assertion 0 == ret */
  assert(0 == ret);
}

// edict_unlink
// file ../include/thread_pool.h line 115
void edict_unlink(struct edict_s *edict)
{
  signed int ret;
  struct anonymous_34 message;
  ret=pthread_mutex_lock(&edict->reference.mx);
  /* assertion 0 == ret */
  assert(0 == ret);
  /* assertion edict->reference.count > 0 */
  assert(edict->reference.count > 0);
  edict->reference.count = edict->reference.count - 1;
  signed int return_value_release_queue_1;
  if(edict->reference.count == 0)
  {
    if(edict->resultmq >= 1)
      do
      {
        return_value_release_queue_1=release_queue(edict->resultmq);
        if(return_value_release_queue_1 >= 0)
          break;

        logstr(65544, "queue not empty, flushing");
        unsigned long int return_value_get_msg_timed_2;
        return_value_get_msg_timed_2=get_msg_timed(edict->resultmq, (void *)&message, sizeof(void *) /*8ul*/ , 0, -1);
        ret = (signed int)return_value_get_msg_timed_2;
        if(ret >= 1)
        {
          /* assertion message.result */
          assert(message.result != NULL);
          free((void *)(struct chkresult_s *)message.result);
          message.result = (void *)0;
        }

      }
      while((_Bool)1);

    pthread_mutex_unlock(&edict->reference.mx);
    /* assertion edict */
    assert(edict != ((struct edict_s *)NULL));
    free((void *)edict);
    edict = (struct edict_s *)(void *)0;
  }

  else
    pthread_mutex_unlock(&edict->reference.mx);
}

// enable_delay
// file msgqueue.c line 259
signed int enable_delay(signed int msqid)
{
  signed int return_value_set_delay_status_1;
  return_value_set_delay_status_1=set_delay_status(msqid, 1);
  return return_value_set_delay_status_1;
}

// finalize
// file worker.c line 597
void finalize(struct final_status_s *status)
{
  struct timespec now;
  struct check_match_s *m;
  struct check_match_s *n;
  struct querylog_entry_s *q = &status->querylog_entry;
  clock_gettime(1, &now);
  q->delay=ms_diff(&now, &status->starttime);
  update_delay_stats(q);
  querylogwrite(q);
  n = q->match;
  m = n;
  for( ; !(n == ((struct check_match_s *)NULL)); m = n)
  {
    n = m->next;
    /* assertion m */
    assert(m != ((struct check_match_s *)NULL));
    free((void *)m);
    m = (struct check_match_s *)(void *)0;
  }
  if(!(status->reason == ((char *)NULL)))
  {
    /* assertion status->reason */
    assert(status->reason != ((char *)NULL));
    free((void *)status->reason);
    status->reason = (char *)(void *)0;
  }

  /* assertion status */
  assert(status != ((struct final_status_s *)NULL));
  free((void *)status);
  status = (struct final_status_s *)(void *)0;
}

// force_peer_aggregate
// file syncmgr.c line 211
signed int force_peer_aggregate(struct peer_s *peer)
{
  struct anonymous_16 prologue;
  unsigned int return_value_htonl_1;
  return_value_htonl_1=htonl((unsigned int)0x02);
  prologue.type = (signed int)return_value_htonl_1;
  prologue.length = (unsigned int)0;
  signed int return_value_send_update_to_peer_2;
  return_value_send_update_to_peer_2=send_update_to_peer(peer, (void *)&prologue, (signed int)sizeof(struct anonymous_16) /*8ul*/ );
  return return_value_send_update_to_peer_2;
}

// free_client_info
// file worker.c line 46
void free_client_info(struct client_info_s *arg)
{
  if(!(arg->caddr == ((struct sockaddr_in *)NULL)))
  {
    /* assertion arg->caddr */
    assert(arg->caddr != ((struct sockaddr_in *)NULL));
    free((void *)arg->caddr);
    arg->caddr = (struct sockaddr_in *)(void *)0;
  }

  if(!(arg->ipstr == ((char *)NULL)))
  {
    /* assertion arg->ipstr */
    assert(arg->ipstr != ((char *)NULL));
    free((void *)arg->ipstr);
    arg->ipstr = (char *)(void *)0;
  }

  if(!(arg->message == NULL))
  {
    /* assertion arg->message */
    assert(arg->message != NULL);
    free(arg->message);
    arg->message = (void *)0;
  }

  /* assertion arg */
  assert(arg != ((struct client_info_s *)NULL));
  free((void *)arg);
  arg = (struct client_info_s *)(void *)0;
}

// gconf
// file ../include/conf.h line 136
const char * gconf(struct configlist_s *config, const char *name)
{
  while(!(config == ((struct configlist_s *)NULL)))
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(config->name, name);
    if(return_value_strcmp_1 == 0)
      return config->value;

    config = config->next;
  }
  return (const char *)(void *)0;
}

// get_bit
// file bloom.c line 99
unsigned int get_bit(unsigned int *array, unsigned int bit_index)
{
  struct anonymous_39 index;
  index=array_index(bit_index);
  /* assertion array */
  assert(array != ((unsigned int *)NULL));
  /* assertion index.intra_index <= 32 */
  assert(index.intra_index <= (unsigned int)32);
  return array[(signed long int)index.array_index] >> index.intra_index & (unsigned int)1;
}

// get_delay_queue
// file ../include/msgqueue.h line 52
signed int get_delay_queue(struct timespec *ts)
{
  signed int putqid;
  signed int getqid;
  struct anonymous_28 *queue_info;
  signed int *impose_delay;
  if(ts == ((struct timespec *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  void *return_value_Malloc_2;
  return_value_Malloc_2=Malloc(sizeof(struct anonymous_28) /*16ul*/ );
  queue_info = (struct anonymous_28 *)return_value_Malloc_2;
  putqid=get_queue();
  getqid=get_queue();
  void *return_value_Malloc_3;
  return_value_Malloc_3=Malloc(sizeof(signed int) /*4ul*/ );
  impose_delay = (signed int *)return_value_Malloc_3;
  *impose_delay = 1;
  queue_info->inq=queuebyid(putqid);
  /* assertion queue_info->inq != ((void *)0) */
  assert(queue_info->inq != (struct msgqueue_s *)(void *)0);
  queue_info->inq->delay_ts = ts;
  queue_info->inq->impose_delay = impose_delay;
  queue_info->outq=queuebyid(getqid);
  /* assertion queue_info->outq != ((void *)0) */
  assert(queue_info->outq != (struct msgqueue_s *)(void *)0);
  queue_info->outq->delay_ts = ts;
  queue_info->outq->impose_delay = impose_delay;
  queue_info->inq->delaypair = queue_info->outq;
  queue_info->outq->delaypair = queue_info->inq;
  create_thread((struct anonymous_40 *)(void *)0, 1, delay, (void *)queue_info);
  return putqid;
}

// get_msg
// file ../include/msgqueue.h line 59
unsigned long int get_msg(signed int msqid, void *msgp, unsigned long int maxsize, signed int msgflag)
{
  unsigned long int return_value_get_msg_timed_1;
  return_value_get_msg_timed_1=get_msg_timed(msqid, msgp, maxsize, msgflag, 0);
  return return_value_get_msg_timed_1;
}

// get_msg_raw
// file msgqueue.c line 582
struct msg_s * get_msg_raw(struct msgqueue_s *mq, signed int timeout)
{
  struct msg_s *msg;
  signed int ret;
  struct timespec to;
  if(mq->active == 0)
  {
    logstr(65539, "get_msg_raw: message queue is marked inactive");
    return (struct msg_s *)(void *)0;
  }

  else
  {
    ret=pthread_mutex_lock(&mq->mx);
    /* assertion ret == 0 */
    assert(ret == 0);
    msg = (struct msg_s *)(void *)0;
    mstotimespec(timeout, &to);
    signed long int return_value_time_1;
    return_value_time_1=time((signed long int *)(void *)0);
    to.tv_sec = to.tv_sec + return_value_time_1;
    if(timeout >= 0)
      while(mq->head == ((struct msg_s *)NULL))
        if(timeout == 0)
          ret=pthread_cond_wait(&mq->cv, &mq->mx);

        else
        {
          ret=pthread_cond_timedwait(&mq->cv, &mq->mx, &to);
          if(ret == 110)
            break;

        }

    else
      if(mq->head == ((struct msg_s *)NULL))
        ret = -1;

    if(ret == 0)
    {
      /* assertion mq->head */
      assert(mq->head != ((struct msg_s *)NULL));
      /* assertion mq->tail */
      assert(mq->tail != ((struct msg_s *)NULL));
      msg = mq->head;
      mq->head = msg->next;
      msg->next = (struct msg_s *)(void *)0;
      mq->msgcount = mq->msgcount - 1;
      if(mq->head == ((struct msg_s *)NULL))
      {
        /* assertion mq->tail == msg */
        assert(mq->tail == msg);
        /* assertion mq->msgcount == 0 */
        assert(mq->msgcount == 0);
        mq->tail = (struct msg_s *)(void *)0;
      }

    }

    pthread_mutex_unlock(&mq->mx);
    return msg;
  }
}

// get_msg_timed
// file ../include/msgqueue.h line 60
unsigned long int get_msg_timed(signed int msqid, void *msgp, unsigned long int maxsize, signed int msgflag, signed int timeout)
{
  struct msgqueue_s *mq;
  struct msg_s *msg;
  unsigned long int msglen;
  unsigned long int msgsize;
  mq=queuebyid(msqid);
  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
    msg=get_msg_raw(mq->delaypair, timeout);

  else
    msg=get_msg_raw(mq, timeout);
  if(msg == ((struct msg_s *)NULL))
    msglen = (unsigned long int)0;

  else
  {
    msgsize = msg->msgsz - sizeof(signed long int) /*8ul*/ ;
    msglen = maxsize < msgsize ? maxsize : msgsize;
    memcpy(msgp, msg->msgp, msglen + sizeof(signed long int) /*8ul*/ );
    /* assertion msg->msgp */
    assert(msg->msgp != NULL);
    free(msg->msgp);
    msg->msgp = (void *)0;
    /* assertion msg */
    assert(msg != ((struct msg_s *)NULL));
    free((void *)msg);
    msg = (struct msg_s *)(void *)0;
  }
  return msglen;
}

// get_queue
// file msgqueue.c line 207
signed int get_queue(void)
{
  signed int i;
  struct msgqueue_s *mq;
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&global_queue_lk);
  /* assertion pthread_mutex_lock(&global_queue_lk) == 0 */
  assert(return_value_pthread_mutex_lock_1 == 0);
  if(initialized == 0)
  {
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)queuespace, sizeof(struct msgqueue_s *) /*8ul*/ );
    queues = (struct msgqueue_s **)return_value_calloc_2;
    metaqueue=create_queue();
    metaqueue->active = 1;
    initialized = 1;
  }

  mq=try_available();
  if(!(mq == ((struct msgqueue_s *)NULL)))
    i = mq->id;

  else
  {
    i = numqueues;
    numqueues = numqueues + 1;
    mq=create_queue();
    mq->id = i;
    mq->active = 1;
    if(!(queuespace >= numqueues))
      queue_realloc();

    queues[(signed long int)i] = mq;
  }
  pthread_mutex_unlock(&global_queue_lk);
  return i;
}

// get_srvstatus
// file srvstatus.c line 54
void get_srvstatus(char *buf, signed int len)
{
  signed int state = 0x00;
  unsigned int update_len_in;
  unsigned long int return_value_in_queue_len_1;
  return_value_in_queue_len_1=in_queue_len(ctx->update_q);
  update_len_in = (unsigned int)return_value_in_queue_len_1;
  unsigned int update_len_out;
  unsigned long int return_value_out_queue_len_2;
  return_value_out_queue_len_2=out_queue_len(ctx->update_q);
  update_len_out = (unsigned int)return_value_out_queue_len_2;
  unsigned int update_len = update_len_in + update_len_out;
  *buf = (char)0;
  signed int return_value_test_thread_27;
  return_value_test_thread_27=test_thread(ctx->process_parts.bloommgr.thread);
  _Bool tmp_if_expr_26;
  signed int return_value_test_thread_25;
  _Bool tmp_if_expr_24;
  signed int return_value_test_thread_23;
  _Bool tmp_if_expr_22;
  signed int return_value_test_thread_21;
  signed long int return_value_time_20;
  _Bool tmp_if_expr_19;
  if(return_value_test_thread_27 == -1)
  {
    state = state | 0x02;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(buf);
    snprintf(buf, (unsigned long int)len - return_value_strlen_3, "%d: bloommgr-thread is dead.", state);
  }

  else
  {
    if(!(ctx->process_parts.syncmgr.thread == ((unsigned long int *)NULL)))
    {
      return_value_test_thread_25=test_thread(ctx->process_parts.syncmgr.thread);
      tmp_if_expr_26 = return_value_test_thread_25 == -1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_26 = (_Bool)0;
    if(tmp_if_expr_26)
    {
      state = state | 0x02;
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(buf);
      snprintf(buf, (unsigned long int)len - return_value_strlen_4, "%d: syncmgr-thread is dead.", state);
    }

    else
    {
      if(!(ctx->process_parts.sjsms_server.thread == ((unsigned long int *)NULL)))
      {
        return_value_test_thread_23=test_thread(ctx->process_parts.sjsms_server.thread);
        tmp_if_expr_24 = return_value_test_thread_23 == -1 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_24 = (_Bool)0;
      if(tmp_if_expr_24)
      {
        state = state | 0x02;
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(buf);
        snprintf(buf, (unsigned long int)len - return_value_strlen_5, "%d: sjsms_server-thread is dead.", state);
      }

      else
      {
        if(!(ctx->process_parts.postfix_server.thread == ((unsigned long int *)NULL)))
        {
          return_value_test_thread_21=test_thread(ctx->process_parts.postfix_server.thread);
          tmp_if_expr_22 = return_value_test_thread_21 == -1 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_22 = (_Bool)0;
        if(tmp_if_expr_22)
        {
          state = state | 0x02;
          unsigned long int return_value_strlen_6;
          return_value_strlen_6=strlen(buf);
          snprintf(buf, (unsigned long int)len - return_value_strlen_6, "%d: postfix_server-thread is dead.", state);
        }

        else
        {
          return_value_time_20=time((signed long int *)(void *)0);
          if(!(60l + ctx->config.rotate_interval >= return_value_time_20 + -(*ctx->last_rotate)))
          {
            state = state | 0x02;
            unsigned long int return_value_strlen_7;
            return_value_strlen_7=strlen(buf);
            snprintf(buf, (unsigned long int)len - return_value_strlen_7, "%d: Rotate stuck.", state);
          }

          else
            if(update_len_out >= 51u)
            {
              state = state | 0x02;
              unsigned long int return_value_strlen_8;
              return_value_strlen_8=strlen(buf);
              snprintf(buf, (unsigned long int)len - return_value_strlen_8, "%d: Update queue length %d (In: %d + Out: %d).", state, update_len, update_len_in, update_len_out);
            }

            else
              if(update_len_out >= 31u)
              {
                state = state | 0x01;
                unsigned long int return_value_strlen_9;
                return_value_strlen_9=strlen(buf);
                snprintf(buf, (unsigned long int)len - return_value_strlen_9, "%d: Update queue length %d (In: %d + Out: %d).", state, update_len, update_len_in, update_len_out);
              }

              else
              {
                if(!(ctx->config.peer.connected >= 1))
                  tmp_if_expr_19 = (ctx->config.flags & (signed int)0x02) == 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_19 = (_Bool)0;
                if(tmp_if_expr_19)
                {
                  state = state | 0x01;
                  unsigned long int return_value_strlen_10;
                  return_value_strlen_10=strlen(buf);
                  snprintf(buf, (unsigned long int)len - return_value_strlen_10, "%d: Peer unreachable.", state);
                }

                else
                {
                  state = state | 0x00;
                  unsigned long int return_value_strlen_11;
                  return_value_strlen_11=strlen(buf);
                  snprintf(buf, (unsigned long int)len - return_value_strlen_11, "%d: Grossd OK. Update queue: %d (In: %d + Out: %d)", state, update_len, update_len_in, update_len_out);
                  pthread_mutex_lock(&ctx->stats.mx);
                  unsigned long int return_value_strlen_12;
                  return_value_strlen_12=strlen(buf);
                  unsigned long int return_value_strlen_13;
                  return_value_strlen_13=strlen(buf);
                  signed long int return_value_time_14;
                  return_value_time_14=time((signed long int *)(void *)0);
                  snprintf(buf + (signed long int)return_value_strlen_12, (unsigned long int)len - return_value_strlen_13, " Trust: %llu Match: %llu Greylist: %llu Block: %llu Queries/sec: %lf", ctx->stats.all_trust, ctx->stats.all_match, ctx->stats.all_greylist, ctx->stats.all_block, (double)(ctx->stats.all_trust + ctx->stats.all_match + ctx->stats.all_greylist + ctx->stats.all_block) / (double)(return_value_time_14 - ctx->stats.startup));
                  unsigned long int return_value_strlen_15;
                  return_value_strlen_15=strlen(buf);
                  unsigned long int return_value_strlen_16;
                  return_value_strlen_16=strlen(buf);
                  snprintf(buf + (signed long int)return_value_strlen_15, (unsigned long int)len - return_value_strlen_16, " Dnsbl matches: ");
                  unsigned long int return_value_strlen_17;
                  return_value_strlen_17=strlen(buf);
                  unsigned long int return_value_strlen_18;
                  return_value_strlen_18=strlen(buf);
                  dnsbl_stats(buf + (signed long int)return_value_strlen_17, (signed int)((unsigned long int)len - return_value_strlen_18));
                  pthread_mutex_unlock(&ctx->stats.mx);
                }
              }
        }
      }
    }
  }
}

// grey_mask
// file worker.c line 116
char * grey_mask(char *ipstr)
{
  signed int ret;
  unsigned int ip;
  unsigned int net;
  unsigned int mask;
  const char *ptr = (const char *)(void *)0;
  char masked[16l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct in_addr inaddr;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(ipstr);
  if(return_value_strlen_1 >= 17ul)
  {
    logstr(65541, "invalid ipaddress: %s", ipstr);
    return (char *)(void *)0;
  }

  else
  {
    ret=inet_pton(2, ipstr, (void *)&inaddr);
    if(!(ret == -1))
    {
      if(ret == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      logstr(65539, "test_tuple: inet_pton: %s", return_value_strerror_3);
      return (char *)(void *)0;

    __CPROVER_DUMP_L3:
      ;
      logstr(65539, "not a valid ip address: %s", ipstr);
      return (char *)(void *)0;
    }
    ip = inaddr.s_addr;
    mask = 0xffffffff ^ (unsigned int)((1 << 32 - ctx->config.grey_mask) - 1);
    unsigned int return_value_htonl_4;
    return_value_htonl_4=htonl(mask);
    net = ip & return_value_htonl_4;
    ptr=inet_ntop(2, (const void *)&net, masked, (unsigned int)16);
    if(ptr == ((const char *)NULL))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      char *return_value_strerror_6;
      return_value_strerror_6=strerror(*return_value___errno_location_5);
      logstr(65539, "test_tuple: inet_ntop: %s", return_value_strerror_6);
      return (char *)(void *)0;
    }

    char *return_value_strdup_7;
    return_value_strdup_7=strdup(masked);
    return return_value_strdup_7;
  }
}

// greylist_delay_update
// file ../include/stats.h line 63
double greylist_delay_update(double d)
{
  pthread_mutex_lock(&ctx->stats.mx);
  if(ctx->stats.greylist == 0ul)
  {
    logstr(65540, "Greylist average updated before updating counters");
    ctx->stats.greylist_avg_delay = d;
  }

  else
    ctx->stats.greylist_avg_delay = (ctx->stats.greylist_avg_delay * (double)(ctx->stats.greylist - (unsigned long int)1) + d) / (double)ctx->stats.greylist;
  if(ctx->stats.greylist_max_delay < d)
    ctx->stats.greylist_max_delay = d;

  pthread_mutex_unlock(&ctx->stats.mx);
  return ctx->stats.greylist_avg_delay;
}

// in_queue_len
// file msgqueue.c line 683
unsigned long int in_queue_len(signed int msgid)
{
  struct msgqueue_s *mq;
  mq=queuebyid(msgid);
  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  return (unsigned long int)mq->msgcount;
}

// increment_dnsbl_tolerance_counters
// file ../include/check_dnsbl.h line 51
signed int increment_dnsbl_tolerance_counters(struct dnsbl_s *dnsbl)
{
  for( ; !(dnsbl == ((struct dnsbl_s *)NULL)); dnsbl = dnsbl->next)
    tolerate_dnsbl(dnsbl);
  return 0;
}

// init_bit_array
// file bloom.c line 121
void init_bit_array(unsigned int *array, unsigned int size)
{
  unsigned int i;
  /* assertion array */
  assert(array != ((unsigned int *)NULL));
  i = (unsigned int)0;
  for( ; !(i >= size); i = i + 1u)
    array[(signed long int)i] = (unsigned int)0;
}

// init_stats
// file ../include/stats.h line 58
void init_stats()
{
  pthread_mutex_init(&ctx->stats.mx, (const union anonymous_29 *)(void *)0);
  ctx->stats.dnsbl_match = (struct dnsbl_stat *)(void *)0;
  time(&ctx->stats.startup);
  ctx->stats.all_block = (unsigned long int)0;
  ctx->stats.all_greylist = (unsigned long int)0;
  ctx->stats.all_match = (unsigned long int)0;
  ctx->stats.all_trust = (unsigned long int)0;
  zero_stats();
}

// init_status
// file worker.c line 527
struct final_status_s * init_status(const char *proto)
{
  struct final_status_s *status;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct final_status_s) /*96ul*/ );
  status = (struct final_status_s *)return_value_Malloc_1;
  memset((void *)status, 0, sizeof(struct final_status_s) /*96ul*/ );
  status->querylog_entry.proto = proto;
  clock_gettime(1, &status->starttime);
  return status;
}

// initialize_context
// file gross.c line 59
struct anonymous_20 * initialize_context()
{
  struct anonymous_20 *initialize_context__1__ctx;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct anonymous_20) /*1728ul*/ );
  initialize_context__1__ctx = (struct anonymous_20 *)return_value_Malloc_1;
  memset((void *)initialize_context__1__ctx, 0, sizeof(struct anonymous_20) /*1728ul*/ );
  initialize_context__1__ctx->config.flags = 0;
  initialize_context__1__ctx->config.protocols = 0;
  initialize_context__1__ctx->config.checks = 0;
  memset((void *)initialize_context__1__ctx->checklist, 0, (unsigned long int)128 * sizeof(struct anonymous_42 *) /*8ul*/ );
  initialize_context__1__ctx->config.loglevel = 65542;
  initialize_context__1__ctx->config.syslogfacility = 0;
  initialize_context__1__ctx->filter = (struct anonymous_22 *)(void *)0;
  memset((void *)&initialize_context__1__ctx->config.gross_host, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  memset((void *)&initialize_context__1__ctx->config.sync_host, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  memset((void *)&initialize_context__1__ctx->config.peer.peer_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  memset((void *)&initialize_context__1__ctx->config.status_host, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  initialize_context__1__ctx->config.peer.peerfd_out = -1;
  initialize_context__1__ctx->config.peer.peerfd_in = -1;
  void *return_value_Malloc_2;
  return_value_Malloc_2=Malloc(sizeof(signed long int) /*8ul*/ );
  initialize_context__1__ctx->last_rotate = (signed long int *)return_value_Malloc_2;
  initialize_context__1__ctx->dnsbl = (struct dnsbl_s *)(void *)0;
  initialize_context__1__ctx->dnswl = (struct dnsbl_s *)(void *)0;
  initialize_context__1__ctx->rhsbl = (struct dnsbl_s *)(void *)0;
  return initialize_context__1__ctx;
}

// insert_absolute_bloom_ring_queue
// file bloom.c line 427
void insert_absolute_bloom_ring_queue(struct anonymous_22 *brq, unsigned int *buffer, signed int size, signed int index, unsigned int buf_index)
{
  unsigned int i;
  /* assertion brq */
  assert(brq != ((struct anonymous_22 *)NULL));
  /* assertion buf_index < brq->group->group_size */
  assert(buf_index < brq->group->group_size);
  if(!(brq->group->filter_group[(signed long int)buf_index]->size >= (unsigned int)size))
    size = (signed int)brq->group->filter_group[(signed long int)buf_index]->size;

  i = (unsigned int)0;
  for( ; !(i >= (unsigned int)size); i = i + 1u)
  {
    /* assertion index + i < brq->group->filter_group[buf_index]->size */
    assert((unsigned int)index + i < brq->group->filter_group[(signed long int)buf_index]->size);
    brq->group->filter_group[(signed long int)buf_index]->filter[(signed long int)((unsigned int)(index * size) + i)] = brq->group->filter_group[(signed long int)buf_index]->filter[(signed long int)((unsigned int)(index * size) + i)] | buffer[(signed long int)i];
  }
}

// insert_bit
// file bloom.c line 110
void insert_bit(unsigned int *array, unsigned int bit_index)
{
  struct anonymous_39 index;
  index=array_index(bit_index);
  /* assertion array */
  assert(array != ((unsigned int *)NULL));
  /* assertion index.intra_index <= 32 */
  assert(index.intra_index <= (unsigned int)32);
  unsigned int return_value_add_mask_1;
  return_value_add_mask_1=add_mask(index.intra_index);
  array[(signed long int)index.array_index] = array[(signed long int)index.array_index] | return_value_add_mask_1;
}

// insert_digest
// file bloom.c line 139
void insert_digest(struct anonymous_24 *filter, struct anonymous_18 digest)
{
  /* assertion filter */
  assert(filter != ((struct anonymous_24 *)NULL));
  unsigned int return_value_int_to_index_1;
  return_value_int_to_index_1=int_to_index(digest.h0, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_1);
  unsigned int return_value_int_to_index_2;
  return_value_int_to_index_2=int_to_index(digest.h1, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_2);
  unsigned int return_value_int_to_index_3;
  return_value_int_to_index_3=int_to_index(digest.h2, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_3);
  unsigned int return_value_int_to_index_4;
  return_value_int_to_index_4=int_to_index(digest.h3, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_4);
  unsigned int return_value_int_to_index_5;
  return_value_int_to_index_5=int_to_index(digest.h4, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_5);
  unsigned int return_value_int_to_index_6;
  return_value_int_to_index_6=int_to_index(digest.h5, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_6);
  unsigned int return_value_int_to_index_7;
  return_value_int_to_index_7=int_to_index(digest.h6, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_7);
  unsigned int return_value_int_to_index_8;
  return_value_int_to_index_8=int_to_index(digest.h7, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_8);
}

// insert_digest_bloom_ring_queue
// file bloom.c line 341
void insert_digest_bloom_ring_queue(struct anonymous_22 *brq, struct anonymous_18 digest)
{
  /* assertion brq */
  assert(brq != ((struct anonymous_22 *)NULL));
  insert_digest(brq->aggregate, digest);
  insert_digest_to_group_member(brq->group, brq->current_index, digest);
}

// insert_digest_to_group_member
// file bloom.c line 169
void insert_digest_to_group_member(struct anonymous_23 *filter_group, unsigned int member_index, struct anonymous_18 digest)
{
  /* assertion filter_group */
  assert(filter_group != ((struct anonymous_23 *)NULL));
  /* assertion member_index < filter_group->group_size */
  assert(member_index < filter_group->group_size);
  insert_digest(filter_group->filter_group[(signed long int)member_index], digest);
}

// instant_msg
// file ../include/msgqueue.h line 57
signed int instant_msg(signed int msqid, void *omsgp, unsigned long int msgsz, signed int msgflg)
{
  struct msgqueue_s *mq;
  struct msg_s *new;
  void *msgp;
  signed int ret;
  unsigned long int truesize;
  mq=queuebyid(msqid);
  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
    mq = mq->delaypair;

  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct msg_s) /*40ul*/ );
  new = (struct msg_s *)return_value_Malloc_1;
  memset((void *)new, 0, sizeof(struct msg_s) /*40ul*/ );
  clock_gettime(1, &new->timestamp);
  truesize = msgsz + sizeof(signed long int) /*8ul*/ ;
  msgp=Malloc(truesize);
  memcpy(msgp, omsgp, truesize);
  new->msgp = msgp;
  new->msgsz = truesize;
  ret=put_msg_raw(mq, new);
  return ret;
}

// int_to_index
// file bloom.c line 133
unsigned int int_to_index(unsigned int value, unsigned int mask)
{
  return (unsigned int)(value & mask);
}

// ipstr
// file srvutils.c line 589
char * ipstr(struct sockaddr_in *saddr)
{
  char ipstr__1__ipstr[16l];
  const char *return_value_inet_ntop_1;
  return_value_inet_ntop_1=inet_ntop(2, (const void *)&saddr->sin_addr, ipstr__1__ipstr, (unsigned int)16);
  if(return_value_inet_ntop_1 == ((const char *)NULL))
    strncpy(ipstr__1__ipstr, "UNKNOWN\0", (unsigned long int)16);

  char *return_value_strdup_2;
  return_value_strdup_2=strdup(ipstr__1__ipstr);
  return return_value_strdup_2;
}

// is_in_array
// file bloom.c line 154
signed int is_in_array(struct anonymous_24 *filter, struct anonymous_18 digest)
{
  /* assertion filter */
  assert(filter != ((struct anonymous_24 *)NULL));
  unsigned int return_value_int_to_index_1;
  return_value_int_to_index_1=int_to_index(digest.h0, filter->mask);
  unsigned int return_value_get_bit_2;
  return_value_get_bit_2=get_bit(filter->filter, return_value_int_to_index_1);
  _Bool tmp_if_expr_5;
  unsigned int return_value_int_to_index_3;
  unsigned int return_value_get_bit_4;
  if(!(return_value_get_bit_2 == 0u))
  {
    return_value_int_to_index_3=int_to_index(digest.h1, filter->mask);
    return_value_get_bit_4=get_bit(filter->filter, return_value_int_to_index_3);
    tmp_if_expr_5 = return_value_get_bit_4 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  _Bool tmp_if_expr_8;
  unsigned int return_value_int_to_index_6;
  unsigned int return_value_get_bit_7;
  if(tmp_if_expr_5)
  {
    return_value_int_to_index_6=int_to_index(digest.h2, filter->mask);
    return_value_get_bit_7=get_bit(filter->filter, return_value_int_to_index_6);
    tmp_if_expr_8 = return_value_get_bit_7 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_8 = (_Bool)0;
  _Bool tmp_if_expr_11;
  unsigned int return_value_int_to_index_9;
  unsigned int return_value_get_bit_10;
  if(tmp_if_expr_8)
  {
    return_value_int_to_index_9=int_to_index(digest.h3, filter->mask);
    return_value_get_bit_10=get_bit(filter->filter, return_value_int_to_index_9);
    tmp_if_expr_11 = return_value_get_bit_10 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_11 = (_Bool)0;
  _Bool tmp_if_expr_14;
  unsigned int return_value_int_to_index_12;
  unsigned int return_value_get_bit_13;
  if(tmp_if_expr_11)
  {
    return_value_int_to_index_12=int_to_index(digest.h4, filter->mask);
    return_value_get_bit_13=get_bit(filter->filter, return_value_int_to_index_12);
    tmp_if_expr_14 = return_value_get_bit_13 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_14 = (_Bool)0;
  _Bool tmp_if_expr_17;
  unsigned int return_value_int_to_index_15;
  unsigned int return_value_get_bit_16;
  if(tmp_if_expr_14)
  {
    return_value_int_to_index_15=int_to_index(digest.h5, filter->mask);
    return_value_get_bit_16=get_bit(filter->filter, return_value_int_to_index_15);
    tmp_if_expr_17 = return_value_get_bit_16 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_17 = (_Bool)0;
  _Bool tmp_if_expr_20;
  unsigned int return_value_int_to_index_18;
  unsigned int return_value_get_bit_19;
  if(tmp_if_expr_17)
  {
    return_value_int_to_index_18=int_to_index(digest.h6, filter->mask);
    return_value_get_bit_19=get_bit(filter->filter, return_value_int_to_index_18);
    tmp_if_expr_20 = return_value_get_bit_19 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_20 = (_Bool)0;
  _Bool tmp_if_expr_23;
  unsigned int return_value_int_to_index_21;
  unsigned int return_value_get_bit_22;
  if(tmp_if_expr_20)
  {
    return_value_int_to_index_21=int_to_index(digest.h7, filter->mask);
    return_value_get_bit_22=get_bit(filter->filter, return_value_int_to_index_21);
    tmp_if_expr_23 = return_value_get_bit_22 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_23 = (_Bool)0;
  return (signed int)tmp_if_expr_23;
}

// is_in_ring_queue
// file bloom.c line 349
signed int is_in_ring_queue(struct anonymous_22 *brq, struct anonymous_18 digest)
{
  /* assertion brq */
  assert(brq != ((struct anonymous_22 *)NULL));
  signed int return_value_is_in_array_1;
  return_value_is_in_array_1=is_in_array(brq->aggregate, digest);
  return return_value_is_in_array_1;
}

// little_endian
// file sha256.c line 53
signed int little_endian()
{
  signed int i = 1;
  char *p = (char *)&i;
  if((signed int)*p == 1)
    return 1;

  else
    return 0;
}

// log_close
// file srvutils.c line 618
signed int log_close(void)
{
  if((33 & ctx->config.flags) == 0x20)
  {
    if(ctx->syslog_open == 0)
      return -1;

    closelog();
    ctx->syslog_open = 0;
  }

  return 0;
}

// log_open
// file srvutils.c line 603
signed int log_open(void)
{
  if((33 & ctx->config.flags) == 0x20)
  {
    if(!(ctx->syslog_open == 0))
      return -1;

    openlog("grossd", 0x04, ctx->config.syslogfacility);
    ctx->syslog_open = 1;
  }

  return 0;
}

// log_put
// file srvutils.c line 538
signed int log_put(const char *msg)
{
  char *final;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc((unsigned long int)1024);
  final = (char *)return_value_Malloc_1;
  snprintf(final, (unsigned long int)(1024 - 1), "%s", msg);
  date_fmt(final, (unsigned long int)1024);
  printf("%s", final);
  /* assertion final */
  assert(final != ((char *)NULL));
  free((void *)final);
  final = (char *)(void *)0;
  fflush(stdout);
  return 0;
}

// log_stats
// file ../include/stats.h line 60
struct anonymous_35 log_stats()
{
  char buf[640l] = { (char)0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct anonymous_35 stats;
  stats=zero_stats();
  statstr(262145, "grossd status summary (begin, end, trust, match, greylist, block): %lu, %lu, %llu, %llu, %llu, %llu", stats.begin, stats.end, stats.trust, stats.match, stats.greylist, stats.block);
  statstr(262148, "grossd processing average delay (begin, end, trust[ms], match[ms], greylist[ms], block[ms]): %lu, %lu, %.3lf, %.3lf, %.3lf, %.3lf", stats.begin, stats.end, stats.trust_avg_delay, stats.match_avg_delay, stats.greylist_avg_delay, stats.block_avg_delay);
  statstr(262148, "grossd processing max delay (begin, end, trust[ms], match[ms], greylist[ms], block[ms]): %lu, %lu, %.3lf, %.3lf, %.3lf, %.3lf", stats.begin, stats.end, stats.trust_max_delay, stats.match_max_delay, stats.greylist_max_delay, stats.block_max_delay);
  statstr(262146, "grossd summary since startup (startup, now, trust, match, greylist, block): %lu, %lu, %llu, %llu, %llu, %llu", stats.startup, stats.end, stats.all_trust, stats.all_match, stats.all_greylist, stats.all_block);
  char *return_value_dnsbl_stats_1;
  return_value_dnsbl_stats_1=dnsbl_stats(buf, (signed int)(unsigned int)640);
  statstr(262152, "%s", return_value_dnsbl_stats_1);
  return stats;
}

// logstr
// file srvutils.c line 36
signed int logstr(signed int level, const char *fmt, ...)
{
  char logfmt[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char mbuf[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  void **vap;
  signed int return_value_log_put_2;
  if(!(ctx->config.loglevel >= level))
    return 0;

  else
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    snprintf(logfmt, (unsigned long int)1024, "#%x: %s", (unsigned int)return_value_pthread_self_1, fmt);
    vap = (void **)&fmt;
    vsnprintf(mbuf, (unsigned long int)1024, logfmt, vap);
    vap = ((void **)NULL);
    if(ctx->syslog_open == 0)
    {
      return_value_log_put_2=log_put(mbuf);
      return return_value_log_put_2;
    }

    else
    {
      if(level >= 65544)
        level = 65543;

      level = level ^ 65536;
      syslog(level, "%s", (const void *)mbuf);
      return 0;
    }
  }
}

// main
// file gross.c line 565
signed int main(signed int argc, char **argv)
{
  signed int ret;
  struct anonymous_19 rotatecmd;
  signed long int toleration;
  struct configlist_s *config;
  char *configfile = "/etc/grossd.conf";
  signed int c;
  struct timespec *main__1__delay;
  struct anonymous_33 limits;
  struct anonymous_3 mask;
  struct anonymous_3 oldmask;
  struct passwd *pwd;
  char *user = "gross";
  struct anonymous_37 *dns_check_info;
  ctx=initialize_context();
  if(ctx == ((struct anonymous_20 *)NULL))
    daemon_shutdown(2, "Couldn't initialize context");

  do
  {
    c=getopt(argc, argv, ":drf:VCDnp:P:u:");
    if(c == -1)
      break;

    switch(c)
    {
      case 100:
      {
        ctx->config.flags = ctx->config.flags | (signed int)0x01;
        break;
      }
      case 110:
      {
        ctx->config.flags = ctx->config.flags | (signed int)0x10;
        break;
      }
      case 102:
      {
        configfile = optarg;
        break;
      }
      case 58:
      {
        fprintf(stderr, "Option -%c requires an operand\n", optopt);
        usage();
        break;
      }
      case 114:
      {
        ctx->config.flags = ctx->config.flags | (signed int)0x02;
        break;
      }
      case 86:
      {
        printf("grossd - Greylisting of Suspicious Sources. Version %s.\n", (const void *)"1.0.2");
        daemon_shutdown(0, (const char *)(void *)0);
        break;
      }
      case 67:
      {
        ctx->config.flags = ctx->config.flags | (signed int)0x08;
        break;
      }
      case 68:
      {
        if(ctx->config.loglevel == 65543)
          ctx->config.loglevel = 65544;

        else
          ctx->config.loglevel = 65543;
        break;
      }
      case 112:
      {
        ctx->config.pidfile = optarg;
        ctx->config.flags = ctx->config.flags | (signed int)0x80;
        break;
      }
      case 80:
      {
        ctx->config.pidfile = optarg;
        ctx->config.flags = ctx->config.flags | (signed int)0x40;
        ctx->config.flags = ctx->config.flags | (signed int)0x80;
        break;
      }
      case 117:
      {
        user = optarg;
        break;
      }
      case 104:
      {
        usage();
        break;
      }
      default:
      {
        fprintf(stderr, "Unrecognized option: -%c\n", optopt);
        usage();
      }
    }
  }
  while((_Bool)1);
  unsigned int return_value_geteuid_10;
  return_value_geteuid_10=geteuid();
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  signed int *return_value___errno_location_7;
  char *return_value_strerror_8;
  if(return_value_geteuid_10 == 0u)
  {
    logstr(65543, "Running as root: setuid() to '%s'", user);
    pwd=getpwnam(user);
    if(pwd == ((struct passwd *)NULL))
      daemon_shutdown(2, "Running as root: can't find user '%s'", user);

    signed int return_value_initgroups_3;
    return_value_initgroups_3=initgroups(pwd->pw_name, pwd->pw_gid);
    if(!(return_value_initgroups_3 == 0))
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      daemon_shutdown(2, "Running as root: can't initgroups() to user 'nobody' groups: %s", return_value_strerror_2);
    }

    signed int return_value_setgid_6;
    return_value_setgid_6=setgid(pwd->pw_gid);
    if(!(return_value_setgid_6 == 0))
    {
      return_value___errno_location_4=__errno_location();
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      daemon_shutdown(2, "Running as root: can't setgid(%d) to '%s': %s", pwd->pw_gid, user, return_value_strerror_5);
    }

    signed int return_value_setuid_9;
    return_value_setuid_9=setuid(pwd->pw_uid);
    if(!(return_value_setuid_9 == 0))
    {
      return_value___errno_location_7=__errno_location();
      return_value_strerror_8=strerror(*return_value___errno_location_7);
      daemon_shutdown(2, "Running as root: can't setuid(%d) to '%s': %s", pwd->pw_uid, user, return_value_strerror_8);
    }

  }

  config=read_config(configfile);
  configure_grossd(config);
  log_open();
  logstr(65542, "grossd version %s starting...", (const void *)"1.0.2");
  if((0x08 & ctx->config.flags) == 0x08)
  {
    if(!(ctx->config.statefile == ((char *)NULL)))
    {
      create_statefile();
      daemon_shutdown(0, "statefile %s created, exiting...", ctx->config.statefile);
    }

    else
      daemon_shutdown(2, "statefile not configured");
  }

  if(!((0x40 & ctx->config.flags) == 0))
    check_pidfile();

  if((0x01 & ctx->config.flags) == 0)
    daemonize();

  if(!((0x80 & ctx->config.flags) == 0))
    create_pidfile();

  setup_signal_handlers();
  sigfillset(&mask);
  sigdelset(&mask, 14);
  ret=pthread_sigmask(0, &mask, &oldmask);
  if(!(ret == 0))
    daemon_fatal("pthread_sigmask");

  void *return_value_Malloc_11;
  return_value_Malloc_11=Malloc(sizeof(struct timespec) /*16ul*/ );
  main__1__delay = (struct timespec *)return_value_Malloc_11;
  main__1__delay->tv_sec = (signed long int)ctx->config.greylist_delay;
  main__1__delay->tv_nsec = (signed long int)0;
  ctx->update_q=get_delay_queue(main__1__delay);
  if(!(ctx->update_q >= 0))
    daemon_fatal("get_delay_queue");

  bloommgr_init();
  if((0x02 & ctx->config.flags) == 0)
    syncmgr_init();

  sem_wait(ctx->sync_guard);
  logstr(65542, "Filters in sync. Starting...");
  sem_post(ctx->sync_guard);
  limits.max_thread = ctx->config.pool_maxthreads;
  limits.watchdog = 1;
  limits.watchdog_time = ctx->config.query_timelimit * 2;
  if(!((0x01 & ctx->config.checks) == 0))
  {
    void *return_value_Malloc_12;
    return_value_Malloc_12=Malloc(sizeof(struct anonymous_37) /*24ul*/ );
    dns_check_info = (struct anonymous_37 *)return_value_Malloc_12;
    dns_check_info->definitive = 0;
    dns_check_info->type = (enum anonymous_2)TYPE_DNSBL;
    dns_check_info->name = "dnsbl";
    dns_check_info->dnsbase = ctx->dnsbl;
    dnsbl_init(dns_check_info, &limits);
  }

  if(!((0x10 & ctx->config.checks) == 0))
  {
    void *return_value_Malloc_13;
    return_value_Malloc_13=Malloc(sizeof(struct anonymous_37) /*24ul*/ );
    dns_check_info = (struct anonymous_37 *)return_value_Malloc_13;
    dns_check_info->definitive = 1;
    dns_check_info->type = (enum anonymous_2)TYPE_DNSWL;
    dns_check_info->name = "dnswl";
    dns_check_info->dnsbase = ctx->dnswl;
    dnsbl_init(dns_check_info, &limits);
  }

  if(!((0x08 & ctx->config.checks) == 0))
  {
    void *return_value_Malloc_14;
    return_value_Malloc_14=Malloc(sizeof(struct anonymous_37) /*24ul*/ );
    dns_check_info = (struct anonymous_37 *)return_value_Malloc_14;
    dns_check_info->definitive = 0;
    dns_check_info->type = (enum anonymous_2)TYPE_RHSBL;
    dns_check_info->name = "rhsbl";
    dns_check_info->dnsbase = ctx->rhsbl;
    dnsbl_init(dns_check_info, &limits);
  }

  if(!((0x02 & ctx->config.checks) == 0))
    blocker_init(&limits);

  if(!((0x04 & ctx->config.checks) == 0))
    random_init(&limits);

  worker_init();
  srvstatus_init();
  ret=pthread_sigmask(2, &oldmask, (struct anonymous_3 *)(void *)0);
  if(!(ret == 0))
    daemon_fatal("pthread_sigmask");

  toleration=time((signed long int *)(void *)0);
  do
  {
    signed long int return_value_time_15;
    return_value_time_15=time((signed long int *)(void *)0);
    if(!(ctx->config.rotate_interval >= return_value_time_15 + -(*ctx->last_rotate)))
    {
      rotatecmd.mtype = (signed long int)2;
      ret=instant_msg(ctx->update_q, (void *)&rotatecmd, (unsigned long int)0, 0);
      if(!(ret >= 0))
        perror("rotate instant_msg");

    }

    signed long int return_value_time_16;
    return_value_time_16=time((signed long int *)(void *)0);
    if(!(ctx->stats.begin + ctx->config.stat_interval >= return_value_time_16))
      log_stats();

    signed long int return_value_time_17;
    return_value_time_17=time((signed long int *)(void *)0);
    if(return_value_time_17 >= 10l + toleration)
    {
      toleration=time((signed long int *)(void *)0);
      increment_dnsbl_tolerance_counters(ctx->dnsbl);
    }

    sleep((unsigned int)1);
  }
  while((_Bool)1);
}

// mappingstr
// file worker_sjsms.c line 33
signed int mappingstr(const char *from, char *to, unsigned long int len)
{
  const char *from_ptr;
  char *to_ptr;
  from_ptr = from;
  to_ptr = to;
  char *tmp_post_1;
  char *tmp_post_2;
  const char *tmp_post_3;
  for( ; !(from == ((const char *)NULL)); *tmp_post_2 = *tmp_post_3)
  {
    if(*from_ptr == 0)
      break;

    if((unsigned long int)(from_ptr - from) >= len + 18446744073709551613ul)
      break;

    /* assertion *from_ptr */
    assert(*from_ptr != 0);
    if((signed int)*from_ptr == 32)
    {
      tmp_post_1 = to_ptr;
      to_ptr = to_ptr + 1l;
      *tmp_post_1 = (char)36;
    }

    tmp_post_2 = to_ptr;
    to_ptr = to_ptr + 1l;
    tmp_post_3 = from_ptr;
    from_ptr = from_ptr + 1l;
  }
  if(!(len + 18446744073709551614ul >= (unsigned long int)(from_ptr - from)))
    return -1;

  else
    return 0;
}

// match_delay_update
// file ../include/stats.h line 64
double match_delay_update(double d)
{
  pthread_mutex_lock(&ctx->stats.mx);
  if(ctx->stats.match == 0ul)
  {
    logstr(65540, "Match average updated before updating counters");
    ctx->stats.match_avg_delay = d;
  }

  else
    ctx->stats.match_avg_delay = (ctx->stats.match_avg_delay * (double)(ctx->stats.match - (unsigned long int)1) + d) / (double)ctx->stats.match;
  if(ctx->stats.match_max_delay < d)
    ctx->stats.match_max_delay = d;

  pthread_mutex_unlock(&ctx->stats.mx);
  return ctx->stats.match_avg_delay;
}

// maxparams
// file conf.c line 53
unsigned int maxparams(const char *name)
{
  signed int i;
  const char *paramcounts[10l] = { "dnsbl", "0", "1", "rhsbl", "0", "1", "pidfile", "0", "1", (const char *)(void *)0 };
  i = 0;
  signed int return_value_atoi_1;
  while(!(paramcounts[(signed long int)i] == ((const char *)NULL)))
  {
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(name, paramcounts[(signed long int)i]);
    if(return_value_strcmp_2 == 0)
    {
      return_value_atoi_1=atoi(paramcounts[(signed long int)(i + 2)]);
      return (unsigned int)return_value_atoi_1;
    }

    i = i + 1;
  }
  return (unsigned int)0;
}

// min
// file syncmgr.c line 33
signed int min(signed int x, signed int y)
{
  if(!(x >= y))
    return x;

  else
    return y;
}

// minparams
// file conf.c line 74
unsigned int minparams(const char *name)
{
  signed int i;
  const char *paramcounts[10l] = { "dnsbl", "0", "1", "rhsbl", "0", "1", "pidfile", "0", "1", (const char *)(void *)0 };
  i = 0;
  signed int return_value_atoi_1;
  while(!(paramcounts[(signed long int)i] == ((const char *)NULL)))
  {
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(name, paramcounts[(signed long int)i]);
    if(return_value_strcmp_2 == 0)
    {
      return_value_atoi_1=atoi(paramcounts[(signed long int)(i + 1)]);
      return (unsigned int)return_value_atoi_1;
    }

    i = i + 1;
  }
  return (unsigned int)0;
}

// mrproper
// file gross.c line 515
void mrproper(signed int signo)
{
  if(!((0x80 & ctx->config.flags) == 0))
  {
    if(!(ctx->config.pidfile == ((char *)NULL)))
      unlink(ctx->config.pidfile);

  }

  raise(signo);
}

// ms_diff
// file utils.c line 206
signed int ms_diff(struct timespec *t1, struct timespec *t2)
{
  return (signed int)((t1->tv_sec - t2->tv_sec) * (signed long int)1000 + (t1->tv_nsec - t2->tv_nsec) / (signed long int)(1000 * 1000));
}

// mstotimespec
// file utils.c line 249
void mstotimespec(signed int mseconds, struct timespec *ts)
{
  ts->tv_sec = (signed long int)(mseconds / 1000);
  signed int return_value_abs_1;
  return_value_abs_1=abs(mseconds % 1000);
  ts->tv_nsec = (signed long int)(return_value_abs_1 * 1000 * 1000);
}

// multivalue
// file conf.c line 32
signed int multivalue(const char *name)
{
  signed int i;
  const char *multivalues[8l] = { "dnsbl", "rhsbl", "dnswl", "check", "stat_type", "protocol", "log_method", (const char *)(void *)0 };
  i = 0;
  while(!(multivalues[(signed long int)i] == ((const char *)NULL)))
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(name, multivalues[(signed long int)i]);
    if(return_value_strcmp_1 == 0)
      return 1;

    i = i + 1;
  }
  return 0;
}

// namevalueparams
// file conf.c line 176
signed int namevalueparams(char *buffer, char **name, char **value, struct params_s **params)
{
  char *ptr;
  struct params_s *p;
  char *head;
  char *tail;
  signed int ret;
  *value = (char *)(void *)0;
  *name = *value;
  ptr=strchr(buffer, 35);
  if(!(ptr == ((char *)NULL)))
    *ptr = (char)0;

  ret=a_delim_b(buffer, (char)61, name, value);
  signed int return_value_a_delim_b_1;
  if(ret == 1)
  {
    *params = (struct params_s *)(void *)0;
    tail = *value;
    do
    {
      return_value_a_delim_b_1=a_delim_b(tail, (char)59, &head, &tail);
      if(!(return_value_a_delim_b_1 == 1))
        break;

      p = *params;
      if(*params == ((struct params_s *)NULL))
      {
        void *return_value_Malloc_2;
        return_value_Malloc_2=Malloc(sizeof(struct params_s) /*16ul*/ );
        p = (struct params_s *)return_value_Malloc_2;
        *params = p;
        memset((void *)p, 0, sizeof(struct params_s) /*16ul*/ );
      }

      else
      {
        for( ; !(p->next == ((struct params_s *)NULL)); p = p->next)
          ;
        void *return_value_Malloc_3;
        return_value_Malloc_3=Malloc(sizeof(struct params_s) /*16ul*/ );
        p->next = (struct params_s *)return_value_Malloc_3;
        p = p->next;
        memset((void *)p, 0, sizeof(struct params_s) /*16ul*/ );
      }
      p->value = tail;
      p->next = (struct params_s *)(void *)0;
    }
    while((_Bool)1);
    p = *params;
    for( ; !(p == ((struct params_s *)NULL)); p = p->next)
      p->value=strdup(p->value);
    *name=strdup(*name);
    *value=strdup(*value);
    return 1;
  }

  else
    return ret;
}

// new_address
// file srvutils.c line 151
void * new_address(void *val1, unsigned long int val2)
{
  return (void *)((unsigned long int)val1 + val2);
}

// noop
// file gross.c line 506
void noop(signed int signo)
{
  ;
}

// optimal_size
// file bloom.c line 292
unsigned int optimal_size(unsigned int n, double c)
{
  unsigned int result;
  unsigned int native_size;
  native_size=bloom_required_size(c, (unsigned int)8, n);
  result = (unsigned int)1;
  for( ; !(result >= BITARRAY_BASE_SIZE); result = result + 1u)
  {
    unsigned int return_value_bloom_required_size_1;
    return_value_bloom_required_size_1=bloom_required_size(c, (unsigned int)8, (unsigned int)(1 << result));
    if(return_value_bloom_required_size_1 >= native_size)
      return result;

  }
  /* assertion 0 */
  assert(0 != 0);
  return (unsigned int)0;
}

// out_queue_len
// file msgqueue.c line 695
unsigned long int out_queue_len(signed int msgid)
{
  struct msgqueue_s *mq;
  mq=queuebyid(msgid);
  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
    return (unsigned long int)mq->delaypair->msgcount;

  else
  {
    unsigned long int return_value_in_queue_len_1;
    return_value_in_queue_len_1=in_queue_len(msgid);
    return return_value_in_queue_len_1;
  }
}

// parse_postfix
// file worker_postfix.c line 141
signed int parse_postfix(struct client_info_s *client_info, struct grey_tuple_s *grey_tuple)
{
  char line[1024l];
  char *match;
  signed int input = 0;
  signed int ret;
  unsigned long int return_value_strlen_2;
  unsigned long int return_value_strlen_1;
  do
  {
    ret=readline(client_info->connfd, (void *)&line, (unsigned long int)1024);
    if(ret == -1)
    {
      logstr(65539, "readline returned error");
      return 3;
    }

    else
      if(ret == 0)
      {
        logstr(65543, "connection closed by client");
        return 1;
      }

      else
        if(ret == 1)
        {
          return_value_strlen_2=strlen(line);
          if(return_value_strlen_2 == 0ul)
          {
            if(input == 0)
            {
              logstr(65543, "connection close requested by client");
              return 1;
            }

          }

        }

    input = 1;
    match=try_match("sender=", line);
    if(!(match == ((char *)NULL)))
    {
      grey_tuple->sender = match;
      logstr(65543, "sender=%s", match);
    }

    else
    {
      match=try_match("recipient=", line);
      if(!(match == ((char *)NULL)))
      {
        grey_tuple->recipient = match;
        logstr(65543, "recipient=%s", match);
      }

      else
      {
        match=try_match("client_address=", line);
        if(!(match == ((char *)NULL)))
        {
          grey_tuple->client_address = match;
          logstr(65543, "client_address=%s", match);
        }

        else
        {
          match=try_match("helo_name=", line);
          if(!(match == ((char *)NULL)))
          {
            grey_tuple->helo_name = match;
            logstr(65543, "helo_name=%s", match);
          }

          else
          {
            match=try_match("grossd_mode=", line);
            if(!(match == ((char *)NULL)))
            {
              client_info->single_query = 1;
              logstr(65543, "Client requested a single connection mode");
            }

          }
        }
      }
    }
    return_value_strlen_1=strlen(line);
  }
  while(return_value_strlen_1 >= 1ul);
  ret=check_request(grey_tuple);
  if(!(ret >= 0))
    return 2;

  else
    return 0;
}

// parsequery
// file worker_sjsms.c line 86
struct grey_tuple_s * parsequery(const char *request)
{
  struct grey_tuple_s *tuple;
  char *copy;
  char *start;
  char *end;
  signed int ret;
  tuple=request_new();
  copy=strdup(request);
  end = copy;
  start = end;
  do
  {
    start = end;
    end=strchr(start, 10);
    if(end == ((char *)NULL) || end == start)
      break;

    *end = (char)0;
    ret=process_parameter(tuple, start);
    if(!(ret >= 0))
      logstr(65539, "unknown request parameter: %s", start);

    end = end + 1l;
  }
  while((_Bool)1);
  /* assertion copy */
  assert(copy != ((char *)NULL));
  free((void *)copy);
  copy = (char *)(void *)0;
  ret=check_request(tuple);
  if(!(ret >= 0))
  {
    /* assertion tuple */
    assert(tuple != ((struct grey_tuple_s *)NULL));
    free((void *)tuple);
    tuple = (struct grey_tuple_s *)(void *)0;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 42;
    return (struct grey_tuple_s *)(void *)0;
  }

  return tuple;
}

// peek_msg_timestamp
// file msgqueue.c line 550
struct timespec * peek_msg_timestamp(struct msgqueue_s *mq)
{
  struct timespec *timestamp;
  signed int ret;
  if(mq->active == 0)
  {
    logstr(65539, "get_msg_raw: message queue is marked inactive");
    return (struct timespec *)(void *)0;
  }

  else
  {
    ret=pthread_mutex_lock(&mq->mx);
    /* assertion ret == 0 */
    assert(ret == 0);
    while(mq->head == ((struct msg_s *)NULL))
      pthread_cond_wait(&mq->cv, &mq->mx);
    /* assertion mq->head */
    assert(mq->head != ((struct msg_s *)NULL));
    /* assertion mq->tail */
    assert(mq->tail != ((struct msg_s *)NULL));
    timestamp = &mq->head->timestamp;
    pthread_mutex_unlock(&mq->mx);
    return timestamp;
  }
}

// postfix_connection
// file worker_postfix.c line 62
signed int postfix_connection(struct thread_pool_s *info, struct anonymous_32 *thread_ctx, struct edict_s *edict)
{
  struct grey_tuple_s *request;
  char response[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int ret;
  struct client_info_s *client_info;
  struct final_status_s *status;
  client_info = (struct client_info_s *)edict->job;
  /* assertion client_info */
  assert(client_info != ((struct client_info_s *)NULL));
  logstr(65543, "postfix client connected from %s", client_info->ipstr);
  signed int return_value_snprintf_1;
  char *tmp_if_expr_2;
  char *tmp_if_expr_3;
  while((_Bool)1)
  {
    request=request_new();
    ret=parse_postfix(client_info, request);
    if(ret == 0)
    {
      status=init_status("postfix");
      ret=test_tuple(status, request, (struct tmout_action_s *)(void *)0);
      if(!(ret >= 0))
        snprintf(response, (unsigned long int)1024, "action=dunno");

      else
        switch((signed int)status->status)
        {
          case STATUS_TRUST:

          case STATUS_MATCH:
          {
            return_value_snprintf_1=snprintf(response, (unsigned long int)1024, "action=dunno");
            break;
          }
          case STATUS_BLOCK:
          {
            if(!(status->reason == ((char *)NULL)))
              tmp_if_expr_2 = status->reason;

            else
              tmp_if_expr_2 = "Rejected";
            assemble_response(response, (unsigned long int)1024, ctx->config.postfix.responseblock, tmp_if_expr_2);
            break;
          }
          case STATUS_GREY:
          {
            if(!(status->reason == ((char *)NULL)))
              tmp_if_expr_3 = status->reason;

            else
              tmp_if_expr_3 = "Please try again later";
            assemble_response(response, (unsigned long int)1024, ctx->config.postfix.responsegrey, tmp_if_expr_3);
            break;
          }
          default:
            snprintf(response, (unsigned long int)1024, "action=dunno");
        }
      response[(signed long int)(1024 - 1)] = (char)0;
      signed long int return_value_respond_4;
      return_value_respond_4=respond(client_info->connfd, response);
      ret = (signed int)return_value_respond_4;
      if(ret == -1)
        logstr(65539, "respond() failed in handle_connection");

      finalize(status);
      request_unlink(request);
      if(!(client_info->single_query == 0))
        break;

    }

    else
      if(ret == 2)
      {
        logstr(65539, "couldn't parse request, closing connection");
        request_unlink(request);
        break;
      }

      else
        if(ret == 3)
        {
          request_unlink(request);
          break;
        }

        else
          if(ret == 1)
          {
            request_unlink(request);
            break;
          }

  }
  close(client_info->connfd);
  free_client_info(client_info);
  logstr(65543, "postfix_connection returning");
  return ret;
}

// postfix_server
// file worker_postfix.c line 211
static void * postfix_server(void *arg)
{
  signed int ret;
  signed int grossfd;
  signed int opt;
  struct client_info_s *client_info;
  unsigned int clen;
  struct thread_pool_s *postfix_pool;
  struct edict_s *edict;
  grossfd=socket(2, 1, 6);
  if(!(grossfd >= 0))
    daemon_fatal("postfix_server: socket");

  opt = 1;
  ret=setsockopt(grossfd, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(ret >= 0))
    daemon_fatal("setsockopt (SO_REUSEADDR)");

  ret=bind(grossfd, (struct sockaddr *)&ctx->config.gross_host, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(ret >= 0))
    daemon_fatal("bind");

  ret=listen(grossfd, 5);
  if(!(ret >= 0))
    daemon_fatal("listen");

  logstr(65542, "initializing postfix thread pool");
  postfix_pool=create_thread_pool("postfix", postfix_connection, (struct anonymous_33 *)(void *)0, (void *)0);
  if(postfix_pool == ((struct thread_pool_s *)NULL))
    daemon_fatal("create_thread_pool");

  do
  {
    void *return_value_Malloc_1;
    return_value_Malloc_1=Malloc(sizeof(struct client_info_s) /*48ul*/ );
    client_info = (struct client_info_s *)return_value_Malloc_1;
    memset((void *)client_info, 0, sizeof(struct client_info_s) /*48ul*/ );
    void *return_value_Malloc_2;
    return_value_Malloc_2=Malloc(sizeof(struct sockaddr_in) /*16ul*/ );
    client_info->caddr = (struct sockaddr_in *)return_value_Malloc_2;
    clen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
    logstr(65544, "waiting for connections");
    client_info->connfd=accept(grossfd, (struct sockaddr *)client_info->caddr, &clen);
    if(!(client_info->connfd >= 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      if(!(*return_value___errno_location_3 == 4))
        daemon_fatal("accept()");

    }

    else
    {
      logstr(65544, "new connection");
      client_info->ipstr=ipstr(client_info->caddr);
      edict=edict_get(1);
      edict->job = (void *)client_info;
      submit_job(postfix_pool, edict);
      edict_unlink(edict);
    }
  }
  while((_Bool)1);
}

// postfix_server_init
// file worker.c line 34
void postfix_server_init()
{
  logstr(65542, "starting postfix policy server");
  create_thread(&ctx->process_parts.postfix_server, 1, postfix_server, (void *)0);
}

// process_parameter
// file worker.c line 468
signed int process_parameter(struct grey_tuple_s *tuple, const char *str)
{
  char *match;
  do
  {
    match=try_match("sender=", str);
    if(!(match == ((char *)NULL)))
    {
      tuple->sender = match;
      logstr(65543, "sender=%s", match);
    }

    else
    {
      match=try_match("recipient=", str);
      if(!(match == ((char *)NULL)))
      {
        tuple->recipient = match;
        logstr(65543, "recipient=%s", match);
      }

      else
      {
        match=try_match("client_address=", str);
        if(!(match == ((char *)NULL)))
        {
          tuple->client_address = match;
          logstr(65543, "client_address=%s", match);
        }

        else
        {
          match=try_match("helo_name=", str);
          if(!(match == ((char *)NULL)))
          {
            tuple->helo_name = match;
            logstr(65543, "helo_name=%s", match);
          }

          else
            return -1;
        }
      }
    }
  }
  while((_Bool)0);
  return 0;
}

// put_msg
// file ../include/msgqueue.h line 56
signed int put_msg(signed int msqid, void *omsgp, unsigned long int msgsz, signed int msgflg)
{
  struct msgqueue_s *mq;
  struct msg_s *new;
  void *msgp;
  signed int ret;
  unsigned long int truesize;
  mq=queuebyid(msqid);
  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct msg_s) /*40ul*/ );
  new = (struct msg_s *)return_value_Malloc_1;
  memset((void *)new, 0, sizeof(struct msg_s) /*40ul*/ );
  clock_gettime(1, &new->timestamp);
  truesize = msgsz + sizeof(signed long int) /*8ul*/ ;
  msgp=Malloc(truesize);
  memcpy(msgp, omsgp, truesize);
  new->msgp = msgp;
  new->msgsz = truesize;
  ret=put_msg_raw(mq, new);
  return ret;
}

// put_msg_raw
// file msgqueue.c line 378
signed int put_msg_raw(struct msgqueue_s *mq, struct msg_s *msg)
{
  signed int ret;
  struct msg_s *tail;
  if(mq->active == 0)
  {
    logstr(65539, "message queue is marked inactive");
    return -1;
  }

  else
  {
    ret=pthread_mutex_lock(&mq->mx);
    /* assertion ret == 0 */
    assert(ret == 0);
    if(!(mq->tail == ((struct msg_s *)NULL)))
    {
      /* assertion mq->head */
      assert(mq->head != ((struct msg_s *)NULL));
      tail = mq->tail;
      tail->next = msg;
    }

    else
    {
      /* assertion mq->head == ((void *)0) */
      assert(mq->head == (struct msg_s *)(void *)0);
      mq->head = msg;
    }
    mq->tail = msg;
    /* assertion mq->tail->next == ((void *)0) */
    assert(mq->tail->next == (struct msg_s *)(void *)0);
    mq->msgcount = mq->msgcount + 1;
    pthread_cond_signal(&mq->cv);
    pthread_mutex_unlock(&mq->mx);
    return 0;
  }
}

// query_clearance
// file check_dnsbl.c line 71
signed int query_clearance(struct dnsbl_s *dnsbl)
{
  signed int retvalue;
  if(dnsbl->tolerancecounter >= 1)
    retvalue = 1;

  else
    retvalue = 0;
  return retvalue;
}

// querylogwrite
// file worker.c line 626
void querylogwrite(struct querylog_entry_s *q)
{
  char line[1024l];
  char buffer[1024l];
  char *actionstr;
  struct check_match_s *m;
  switch(q->action)
  {
    case STATUS_GREY:
    {
      actionstr = "greylist";
      break;
    }
    case STATUS_MATCH:
    {
      actionstr = "match";
      break;
    }
    case STATUS_TRUST:
    {
      actionstr = "trust";
      break;
    }
    case STATUS_UNKNOWN:
    {
      actionstr = "unknown";
      break;
    }
    case STATUS_FAIL:
    {
      actionstr = "fail";
      break;
    }
    case STATUS_BLOCK:
    {
      actionstr = "block";
      break;
    }
    default:
    {
      actionstr = "this should not be seen anywhere";
      daemon_shutdown(2, "querylogwrite: unknown statuscode %d", q->action);
    }
  }
  if(q->proto == ((const char *)NULL))
    q->proto = "N/A";

  if(q->client_ip == ((const char *)NULL))
    q->client_ip = "N/A";

  if(q->sender == ((const char *)NULL))
    q->sender = "N/A";

  if(q->recipient == ((const char *)NULL))
    q->recipient = "N/A";

  snprintf(line, (unsigned long int)(1024 - 1), "a=%s d=%d w=%d c=%s s=%s r=%s", actionstr, q->delay, q->totalweight, q->client_ip, q->sender, q->recipient);
  if(!(q->helo == ((const char *)NULL)))
  {
    snprintf(buffer, (unsigned long int)(1024 - 1), " h=%s", q->helo);
    strncat(line, buffer, (unsigned long int)(1024 - 1));
  }

  m = q->match;
  for( ; !(m == ((struct check_match_s *)NULL)); m = m->next)
  {
    snprintf(buffer, (unsigned long int)(1024 - 1), " m=%s", m->name);
    strncat(line, buffer, (unsigned long int)(1024 - 1));
    if(!(m->weight == 0))
    {
      snprintf(buffer, (unsigned long int)(1024 - 1), "%+d", m->weight);
      strncat(line, buffer, (unsigned long int)(1024 - 1));
    }

  }
  logstr(65542, "%s", (const void *)line);
}

// queue_freeze
// file ../include/msgqueue.h line 63
signed int queue_freeze(signed int msqid)
{
  struct msgqueue_s *mq;
  signed int ret;
  mq=queuebyid(msqid);
  if(mq == ((struct msgqueue_s *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  logstr(65539, "freeze queue %d", msqid);
  ret=pthread_mutex_lock(&mq->mx);
  /* assertion ret == 0 */
  assert(ret == 0);
  if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
  {
    ret=pthread_mutex_lock(&mq->delaypair->mx);
    /* assertion ret == 0 */
    assert(ret == 0);
  }

  return 0;
}

// queue_realloc
// file msgqueue.c line 60
void queue_realloc(void)
{
  unsigned long int queuesize;
  if(queuespace == 0)
    queuespace = 1;

  logstr(65543, "doubling the space for message queues from %d to %d", queuespace, queuespace * 2);
  queuesize = (unsigned long int)queuespace * sizeof(struct msgqueue_s *) /*8ul*/ ;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)queues, queuesize * (unsigned long int)2);
  queues = (struct msgqueue_s **)return_value_realloc_1;
  queuespace = queuespace * 2;
}

// queue_thaw
// file ../include/msgqueue.h line 64
signed int queue_thaw(signed int msqid)
{
  struct msgqueue_s *mq;
  signed int ret;
  mq=queuebyid(msqid);
  if(mq == ((struct msgqueue_s *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  logstr(65539, "thaw queue %d", msqid);
  ret=pthread_mutex_unlock(&mq->mx);
  /* assertion ret == 0 */
  assert(ret == 0);
  if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
  {
    ret=pthread_mutex_unlock(&mq->delaypair->mx);
    /* assertion ret == 0 */
    assert(ret == 0);
  }

  return 0;
}

// queuebyid
// file msgqueue.c line 82
struct msgqueue_s * queuebyid(signed int msqid)
{
  struct msgqueue_s *mq;
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&global_queue_lk);
  /* assertion pthread_mutex_lock(&global_queue_lk) == 0 */
  assert(return_value_pthread_mutex_lock_1 == 0);
  mq = queues[(signed long int)msqid];
  pthread_mutex_unlock(&global_queue_lk);
  return mq;
}

// random_init
// file ../include/check_random.h line 22
void random_init(struct anonymous_33 *limits)
{
  struct thread_pool_s *pool;
  logstr(65542, "initializing random check thread pool");
  pool=create_thread_pool("random", randomc, limits, (void *)0);
  if(pool == ((struct thread_pool_s *)NULL))
    daemon_fatal("create_thread_pool");

  register_check(pool, 1);
}

// randomc
// file check_random.c line 43
signed int randomc(struct thread_pool_s *info, struct anonymous_32 *thread_ctx, struct edict_s *edict)
{
  struct chkresult_s *result;
  signed int r;
  struct grey_tuple_s *request;
  const char *client_address;
  if(thread_ctx->state == NULL)
  {
    thread_ctx->state=Malloc(sizeof(signed int) /*4ul*/ );
    signed long int return_value_time_1;
    return_value_time_1=time((signed long int *)(void *)0);
    srand((unsigned int)return_value_time_1);
    thread_ctx->cleanup = (signed int (*)())cleanup_random;
  }

  request = (struct grey_tuple_s *)edict->job;
  client_address = request->client_address;
  /* assertion client_address */
  assert(client_address != ((const char *)NULL));
  void *return_value_Malloc_2;
  return_value_Malloc_2=Malloc(sizeof(struct chkresult_s) /*32ul*/ );
  result = (struct chkresult_s *)return_value_Malloc_2;
  memset((void *)result, 0, sizeof(struct chkresult_s) /*32ul*/ );
  result->judgment = (enum anonymous_0)J_UNDEFINED;
  result->checkname = "random";
  r=rand();
  if(r % 7 == 0)
  {
    logstr(65543, "random pass: %s", request->client_address);
    result->judgment = (enum anonymous_0)J_PASS;
  }

  else
    if(r % 5 == 0)
    {
      logstr(65543, "random block: %s", request->client_address);
      result->judgment = (enum anonymous_0)J_BLOCK;
      result->reason=strdup("This is just a random block.");
    }

    else
      if(r % 3 == 0)
      {
        logstr(65543, "random suspect: %s", request->client_address);
        result->judgment = (enum anonymous_0)J_SUSPICIOUS;
        result->weight = 1;
      }

  send_result(edict, (void *)result);
  logstr(65543, "random returning");
  request_unlink(request);
  return 0;
}

// read_config
// file ../include/conf.h line 135
struct configlist_s * read_config(const char *filename)
{
  struct configlist_s *config;
  signed int fd;
  char buffer[1024l];
  char line[1024l];
  signed int rlstatus;
  signed int ret;
  signed int i;
  signed int count = 0;
  char *name[1l];
  char *value[1l];
  struct params_s *params[1l];
  struct params_s *paramptr;
  signed int paramcount;
  const char *valids[42l] = { "dnsbl", "rhsbl", "dnswl", "host", "port", "filter_bits", "rotate_interval", "number_buffers", "update", "peer_name", "statefile", "postfix_response_grey", "postfix_response_block", "sjsms_response_grey", "sjsms_response_match", "sjsms_response_trust", "sjsms_response_block", "log_method", "log_level", "grey_mask", "grey_delay", "check", "protocol", "syslog_facility", "sync_listen", "sync_peer", "sync_port", "stat_interval", "stat_type", "status", "blocker_host", "blocker_port", "blocker_weight", "query_timelimit", "block_threshold", "grey_threshold", "grey_reason", "block_reason", "milter_listen", "pidfile", "pool_maxthreads", (const char *)(void *)0 };
  const char *deprecated[7l] = { "syncport", "synchost", "peerport", "peerhost", "statushost", "statusport", (const char *)(void *)0 };
  config=default_config();
  fd=open(filename, 00);
  _Bool tmp_if_expr_4;
  unsigned int return_value_minparams_3;
  if(!(fd >= 0))
    return config;

  else
  {
    do
    {
      count = count + 1;
      rlstatus=readline(fd, (void *)buffer, (unsigned long int)1024);
      if(!(rlstatus == 1))
        break;

      strncpy(line, buffer, (unsigned long int)1024);
      ret=namevalueparams(buffer, name, value, params);
      if(!(ret >= 0))
      {
        fprintf(stderr, "Couldn't parse line %d: %s\n", count, (const void *)line);
        exit(1);
      }

      else
        if(!(ret == 0))
        {
          i = 0;
          while(!(valids[(signed long int)i] == ((const char *)NULL)))
          {
            signed int return_value_strcmp_1;
            return_value_strcmp_1=strcmp(name[0l], valids[(signed long int)i]);
            if(return_value_strcmp_1 == 0)
              break;

            i = i + 1;
          }
          if(!(valids[(signed long int)i] == ((const char *)NULL)))
          {
            paramptr = params[0l];
            paramcount = 0;
            for( ; !(paramptr == ((struct params_s *)NULL)); paramptr = paramptr->next)
              paramcount = paramcount + 1;
            unsigned int return_value_maxparams_2;
            return_value_maxparams_2=maxparams(name[0l]);
            if(return_value_maxparams_2 >= (unsigned int)paramcount)
            {
              return_value_minparams_3=minparams(name[0l]);
              tmp_if_expr_4 = (unsigned int)paramcount >= return_value_minparams_3 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_4 = (_Bool)0;
            if(tmp_if_expr_4)
            {
              record_config_item(&config, name[0l], value[0l], params[0l]);
              if(!(ret >= 0))
                daemon_fatal("record_config_item");

            }

            else
              daemon_shutdown(4, "Invalid parameter count for configuration parameter: %s", name[0l]);
          }

          else
          {
            i = 0;
            while(!(deprecated[(signed long int)i] == ((const char *)NULL)))
            {
              signed int return_value_strcmp_5;
              return_value_strcmp_5=strcmp(name[0l], deprecated[(signed long int)i]);
              if(return_value_strcmp_5 == 0)
                break;

              i = i + 1;
            }
            if(!(deprecated[(signed long int)i] == ((const char *)NULL)))
              daemon_shutdown(4, "Deprecated configuration parameter: %s", name[0l]);

            else
              daemon_shutdown(4, "Unknown configuration parameter: %s", name[0l]);
          }
        }

    }
    while(rlstatus == 1);
    if(rlstatus == -1)
      daemon_fatal("readline");

    return config;
  }
}

// readline
// file utils.c line 33
signed int readline(signed int fd, void *vptr, unsigned long int maxlen)
{
  signed long int n;
  signed long int rc;
  char c;
  char *ptr = (char *)vptr;
  n = (signed long int)1;
  char *tmp_post_1;
  signed int *return_value___errno_location_2;
  for( ; !((unsigned long int)n >= maxlen); n = n + 1l)
  {
    do
    {

    again:
      ;
      rc=read(fd, (void *)&c, (unsigned long int)1);
      if(rc == 1l)
      {
        if((signed int)c == 10)
          goto __CPROVER_DUMP_L9;

        if(!((signed int)c == 13))
        {
          tmp_post_1 = ptr;
          ptr = ptr + 1l;
          *tmp_post_1 = c;
        }

        goto __CPROVER_DUMP_L8;
      }

      if(rc == 0l)
      {
        if(n == 1l)
          return 0;

        else
          goto __CPROVER_DUMP_L9;
      }

      return_value___errno_location_2=__errno_location();
    }
    while(*return_value___errno_location_2 == 4);
    return -1;

  __CPROVER_DUMP_L8:
    ;
  }

__CPROVER_DUMP_L9:
  ;
  *ptr = (char)0;
  return 1;
}

// readn
// file utils.c line 67
signed long int readn(signed int fd, void *vptr, unsigned long int n)
{
  unsigned long int nleft;
  signed long int nread;
  char *ptr = (char *)vptr;
  nleft = n;
  for( ; nleft >= 1ul; ptr = ptr + nread)
  {
    nread=read(fd, (void *)ptr, nleft);
    if(!(nread >= 0l))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        nread = (signed long int)0;

      else
        return (signed long int)-1;
    }

    else
      if(nread == 0l)
        break;

    nleft = nleft - (unsigned long int)nread;
  }
  return (signed long int)(n - nleft);
}

// record_config_item
// file conf.c line 117
signed int record_config_item(struct configlist_s **config, const char *name, const char *value, struct params_s *params)
{
  struct configlist_s *cp;
  struct configlist_s *prev;
  struct configlist_s *delete;
  cp = *config;
  prev = (struct configlist_s *)(void *)0;
  signed int return_value_multivalue_4;
  return_value_multivalue_4=multivalue(name);
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(!(return_value_multivalue_4 == 0))
  {
    while(!(cp == ((struct configlist_s *)NULL)))
    {
      if(cp->is_default == 1)
      {
        return_value_strcmp_1=strcmp(cp->name, name);
        tmp_if_expr_2 = return_value_strcmp_1 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
      {
        delete = cp;
        if(!(prev == ((struct configlist_s *)NULL)))
          prev->next = cp->next;

        cp = cp->next;
        /* assertion delete */
        assert(delete != ((struct configlist_s *)NULL));
        free((void *)delete);
        delete = (struct configlist_s *)(void *)0;
      }

      else
      {
        prev = cp;
        cp = cp->next;
      }
    }
    add_config_item(config, name, value, params, 0);
  }

  else
  {
    while(!(cp == ((struct configlist_s *)NULL)))
    {
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(cp->name, name);
      if(return_value_strcmp_3 == 0)
      {
        cp->value = value;
        break;
      }

      cp = cp->next;
    }
    if(cp == ((struct configlist_s *)NULL))
      add_config_item(config, name, value, params, 0);

  }
  return 1;
}

// record_match
// file worker.c line 544
void record_match(struct querylog_entry_s *q, struct chkresult_s *r)
{
  struct check_match_s *m;
  struct check_match_s *n;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct check_match_s) /*24ul*/ );
  m = (struct check_match_s *)return_value_Malloc_1;
  memset((void *)m, 0, sizeof(struct check_match_s) /*24ul*/ );
  if(!(r->checkname == ((const char *)NULL)))
    m->name = r->checkname;

  else
    m->name=strdup("<anonymous>");
  m->weight = r->weight;
  m->next = (struct check_match_s *)(void *)0;
  q->totalweight = q->totalweight + m->weight;
  n = q->match;
  if(!(n == ((struct check_match_s *)NULL)))
  {
    for( ; !(n->next == ((struct check_match_s *)NULL)); n = n->next)
      ;
    n->next = m;
  }

  else
    q->match = m;
}

// recv_config_sync
// file syncmgr.c line 348
signed int recv_config_sync(struct peer_s *peer)
{
  struct anonymous_17 msg;
  signed int ret;
  signed long int return_value_readn_1;
  return_value_readn_1=readn(peer->connected, (void *)&msg, sizeof(struct anonymous_17) /*8ul*/ );
  ret = (signed int)return_value_readn_1;
  if(ret == -1)
  {
    peer->connected = 0;
    daemon_fatal("recv_config_sync: read");
  }

  else
    if(ret == 0)
    {
      peer->connected = 0;
      daemon_shutdown(2, "recv_config_sync: connection closed by client");
    }

  msg=sctoh(&msg);
  _Bool tmp_if_expr_2;
  if(!(msg.filter_size == ctx->config.filter_size))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (unsigned int)msg.num_bufs != ctx->config.num_bufs ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    daemon_shutdown(4, "Configs differ!\nMy:   filter_size %d number_buffers %d\nPeer: filter_size %d number_buffers %d\n", ctx->config.filter_size, ctx->config.num_bufs, msg.filter_size, msg.num_bufs);

  return 1;
}

// recv_oper_sync
// file syncmgr.c line 323
signed int recv_oper_sync(struct peer_s *peer)
{
  struct anonymous_15 msg;
  signed int ret;
  signed long int return_value_readn_1;
  return_value_readn_1=readn(peer->connected, (void *)&msg, sizeof(struct anonymous_15) /*32ul*/ );
  ret = (signed int)return_value_readn_1;
  struct anonymous_19 update;
  if(ret == -1)
  {
    peer->connected = 0;
    logstr(65539, "read returned error");
    return 0;
  }

  else
    if(ret == 0)
    {
      peer->connected = 0;
      logstr(65542, "connection closed by client");
      return 0;
    }

  update.mtype = (signed long int)5;
  msg.digest=dtoh(msg.digest);
  memcpy((void *)update.mtext, (const void *)&msg.digest, sizeof(struct anonymous_18) /*32ul*/ );
  signed int return_value_put_msg_2;
  return_value_put_msg_2=put_msg(ctx->update_q, (void *)&update, sizeof(struct anonymous_18) /*32ul*/ , 0);
  return (signed int)!(return_value_put_msg_2 != 0);
}

// recv_startup_sync
// file syncmgr.c line 294
signed int recv_startup_sync(struct peer_s *peer)
{
  struct anonymous_14 msg = { .buffer=-1, .index=0u, .filter={ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u } };
  signed int ret;
  signed long int return_value_readn_1;
  return_value_readn_1=readn(peer->connected, (void *)&msg, sizeof(struct anonymous_14) /*136ul*/ );
  ret = (signed int)return_value_readn_1;
  struct anonymous_19 update;
  if(!((unsigned long int)ret == sizeof(struct anonymous_14) /*136ul*/ ))
    logstr(65539, "read too few bytes");

  if(ret == -1)
  {
    peer->connected = 0;
    logstr(65539, "read returned error");
    return 0;
  }

  else
    if(ret == 0)
    {
      peer->connected = 0;
      logstr(65542, "connection closed by client");
      return 0;
    }

  msg=sstoh(msg);
  update.mtype = (signed long int)3;
  memcpy((void *)update.mtext, (const void *)&msg, sizeof(struct anonymous_14) /*136ul*/ );
  signed int return_value_instant_msg_2;
  return_value_instant_msg_2=instant_msg(ctx->update_q, (void *)&update, sizeof(struct anonymous_14) /*136ul*/ , 0);
  return (signed int)!(return_value_instant_msg_2 != 0);
}

// recv_sync_msg
// file syncmgr.c line 245
signed int recv_sync_msg(struct peer_s *peer)
{
  struct anonymous_16 msg = { .type=-1, .length=0u };
  signed int ret;
  signed long int return_value_readn_1;
  return_value_readn_1=readn(peer->connected, (void *)&msg, sizeof(struct anonymous_16) /*8ul*/ );
  ret = (signed int)return_value_readn_1;
  struct anonymous_19 update;
  if(ret == -1)
  {
    peer->connected = 0;
    logstr(65539, "read returned error");
    return 0;
  }

  else
    if(ret == 0)
    {
      peer->connected = 0;
      logstr(65542, "connection closed by client");
      return 0;
    }

  unsigned int return_value_ntohl_2;
  return_value_ntohl_2=ntohl((unsigned int)msg.type);
  signed int return_value_recv_startup_sync_3;
  signed int return_value_recv_oper_sync_4;
  switch(return_value_ntohl_2)
  {
    case (unsigned int)0x00:
    {
      return_value_recv_startup_sync_3=recv_startup_sync(peer);
      return return_value_recv_startup_sync_3;
    }
    case (unsigned int)0x01:
    {
      logstr(65543, "Recv oper sync");
      return_value_recv_oper_sync_4=recv_oper_sync(peer);
      return return_value_recv_oper_sync_4;
    }
    case (unsigned int)0x02:
    {
      logstr(65542, "Startup sync received. Syncing aggregate");
      update.mtype = (signed long int)4;
      ret=instant_msg(ctx->update_q, (void *)&update, (unsigned long int)0, 0);
      sleep((unsigned int)1);
      return (signed int)!(ret != 0);
    }
    default:
    {
      logstr(65539, "Unknown sync message type.");
      sem_wait(ctx->sync_guard);
      peer->connected = 0;
      close(peer->peerfd_out);
      sem_post(ctx->sync_guard);
      return -1;
    }
  }
}

// recv_syncs
// file syncmgr.c line 222
void * recv_syncs(void *arg)
{
  signed int ret;
  struct peer_s *peer = &ctx->config.peer;
  /* assertion peer */
  assert(peer != ((struct peer_s *)NULL));
  recv_config_sync(peer);
  while((_Bool)1)
  {
    ret=recv_sync_msg(peer);
    if(ret == 0x00)
      return (void *)0;

  }
}

// recvquery
// file proto_sjsms.c line 80
signed int recvquery(struct anonymous_31 *message, struct anonymous_30 *request)
{
  signed int tmp_if_expr_1;
  if(!((signed int)message->msglen >= 1024))
    tmp_if_expr_1 = (signed int)message->msglen;

  else
    tmp_if_expr_1 = 1024;
  memcpy((void *)request, (const void *)message->message, (unsigned long int)tmp_if_expr_1);
  request->message[(signed long int)(1024 - 1)] = (char)0;
  return 1;
}

// recvquerystr
// file proto_sjsms.c line 89
char * recvquerystr(struct anonymous_31 *message)
{
  char querystr[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  snprintf(querystr, (unsigned long int)(1024 - 1), "%s", (const void *)message->message);
  querystr[(signed long int)(1024 - 1)] = (char)0;
  char *return_value_strdup_1;
  return_value_strdup_1=strdup(querystr);
  return return_value_strdup_1;
}

// register_check
// file srvutils.c line 570
void register_check(struct thread_pool_s *pool, signed int definitive)
{
  signed int i;
  struct anonymous_42 *check;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct anonymous_42) /*40ul*/ );
  check = (struct anonymous_42 *)return_value_Malloc_1;
  check->pool = pool;
  check->definitive = definitive;
  i = 0;
  for( ; !(i >= 128); i = i + 1)
    if(ctx->checklist[(signed long int)i] == ((struct anonymous_42 *)NULL))
    {
      ctx->checklist[(signed long int)i] = check;
      break;
    }

  if(i == 128)
    logstr(65539, "unable to register pool %s", pool->name);

}

// release_bloom_filter
// file bloom.c line 202
void release_bloom_filter(struct anonymous_24 *filter)
{
  /* assertion filter->filter */
  assert(filter->filter != ((unsigned int *)NULL));
  free((void *)(unsigned int *)filter->filter);
  filter->filter = (unsigned int *)(void *)0;
  /* assertion filter */
  assert(filter != ((struct anonymous_24 *)NULL));
  free((void *)filter);
  filter = (struct anonymous_24 *)(void *)0;
}

// release_bloom_filter_group
// file bloom.c line 263
void release_bloom_filter_group(struct anonymous_23 *filter_group)
{
  unsigned int i;
  /* assertion filter_group */
  assert(filter_group != ((struct anonymous_23 *)NULL));
  i = (unsigned int)0;
  for( ; !(i >= filter_group->group_size); i = i + 1u)
  {
    release_bloom_filter(filter_group->filter_group[(signed long int)i]);
    filter_group->filter_group[(signed long int)i] = ((struct anonymous_24 *)NULL);
  }
  /* assertion filter_group */
  assert(filter_group != ((struct anonymous_23 *)NULL));
  free((void *)filter_group);
  filter_group = (struct anonymous_23 *)(void *)0;
}

// release_bloom_ring_queue
// file srvutils.c line 380
void release_bloom_ring_queue(struct anonymous_22 *brq)
{
  _Bool tmp_if_expr_1;
  if(!(ctx->statefile_info == ((struct statefile_info_s *)NULL)))
    tmp_if_expr_1 = brq == ctx->mmap_info->brq ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    munmap((void *)ctx->mmap_info->brq, ctx->mmap_info->lumpsize);
    close(ctx->statefile_info->fd);
    /* assertion ctx->statefile_info */
    assert(ctx->statefile_info != ((struct statefile_info_s *)NULL));
    free((void *)ctx->statefile_info);
    ctx->statefile_info = (struct statefile_info_s *)(void *)0;
    ctx->statefile_info = (struct statefile_info_s *)(void *)0;
    ctx->filter = (struct anonymous_22 *)(void *)0;
    ctx->mmap_info = (struct anonymous_44 *)(void *)0;
  }

  else
  {
    /* assertion brq */
    assert(brq != ((struct anonymous_22 *)NULL));
    free((void *)brq);
    brq = (struct anonymous_22 *)(void *)0;
  }
}

// release_queue
// file msgqueue.c line 490
signed int release_queue(signed int msqid)
{
  struct msg_s *msg;
  signed int ret;
  struct msgqueue_s *mq;
  mq=queuebyid(msqid);
  if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
  {
    logstr(65539, "release_queue: attempt to free a delay queue");
    return -1;
  }

  else
    if(!(mq->head == ((struct msg_s *)NULL)))
    {
      logstr(65544, "release_queue: queue not empty");
      return -1;
    }

    else
    {
      ret=pthread_mutex_lock(&mq->mx);
      /* assertion ret == 0 */
      assert(ret == 0);
      mq->active = 0;
      ret=pthread_mutex_unlock(&mq->mx);
      /* assertion ret == 0 */
      assert(ret == 0);
      void *return_value_Malloc_1;
      return_value_Malloc_1=Malloc(sizeof(struct msg_s) /*40ul*/ );
      msg = (struct msg_s *)return_value_Malloc_1;
      memset((void *)msg, 0, sizeof(struct msg_s) /*40ul*/ );
      msg->msgp = (void *)mq;
      ret=put_msg_raw(metaqueue, msg);
      /* assertion ret == 0 */
      assert(ret == 0);
      return 0;
    }
}

// request_new
// file worker.c line 89
struct grey_tuple_s * request_new()
{
  struct grey_tuple_s *request;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct grey_tuple_s) /*80ul*/ );
  request = (struct grey_tuple_s *)return_value_Malloc_1;
  bzero((void *)request, sizeof(struct grey_tuple_s) /*80ul*/ );
  pthread_mutex_init(&request->reference.mx, (const union anonymous_29 *)(void *)0);
  request->reference.count = 1;
  return request;
}

// request_reference
// file worker.c line 103
void request_reference(struct grey_tuple_s *request)
{
  signed int ret;
  ret=pthread_mutex_lock(&request->reference.mx);
  /* assertion 0 == ret */
  assert(0 == ret);
  request->reference.count = request->reference.count + 1;
  ret=pthread_mutex_unlock(&request->reference.mx);
  /* assertion 0 == ret */
  assert(0 == ret);
}

// request_unlink
// file worker.c line 61
void request_unlink(struct grey_tuple_s *request)
{
  signed int ret;
  ret=pthread_mutex_lock(&request->reference.mx);
  /* assertion request */
  assert(request != ((struct grey_tuple_s *)NULL));
  /* assertion 0 == ret */
  assert(0 == ret);
  /* assertion request->reference.count > 0 */
  assert(request->reference.count > 0);
  request->reference.count = request->reference.count - 1;
  if(request->reference.count == 0)
  {
    if(!(request->sender == ((char *)NULL)))
    {
      /* assertion request->sender */
      assert(request->sender != ((char *)NULL));
      free((void *)request->sender);
      request->sender = (char *)(void *)0;
    }

    if(!(request->recipient == ((char *)NULL)))
    {
      /* assertion request->recipient */
      assert(request->recipient != ((char *)NULL));
      free((void *)request->recipient);
      request->recipient = (char *)(void *)0;
    }

    if(!(request->client_address == ((char *)NULL)))
    {
      /* assertion request->client_address */
      assert(request->client_address != ((char *)NULL));
      free((void *)request->client_address);
      request->client_address = (char *)(void *)0;
    }

    if(!(request->helo_name == ((char *)NULL)))
    {
      /* assertion request->helo_name */
      assert(request->helo_name != ((char *)NULL));
      free((void *)request->helo_name);
      request->helo_name = (char *)(void *)0;
    }

    pthread_mutex_unlock(&request->reference.mx);
    /* assertion request */
    assert(request != ((struct grey_tuple_s *)NULL));
    free((void *)request);
    request = (struct grey_tuple_s *)(void *)0;
  }

  else
    pthread_mutex_unlock(&request->reference.mx);
}

// respond
// file utils.c line 154
signed long int respond(signed int fd, const char *response)
{
  const char terminator[3l] = { '\n', '\n', 0 };
  signed long int return_value_writet_1;
  return_value_writet_1=writet(fd, response, terminator);
  return return_value_writet_1;
}

// reverse_inet_addr
// file check_dnsbl.c line 152
signed int reverse_inet_addr(char *ipstr)
{
  unsigned int ipa;
  unsigned int tmp;
  signed int i;
  signed int ret;
  struct in_addr inaddr;
  const char *ptr;
  char tmpstr[16l];
  unsigned long int iplen;
  iplen=strlen(ipstr);
  if(iplen >= 17ul)
  {
    fprintf(stderr, "invalid ipaddress: %s\n", ipstr);
    return -1;
  }

  else
  {
    ret=inet_pton(2, ipstr, (void *)&inaddr);
    if(!(ret == -1))
    {
      if(ret == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      perror("reverse_inet_addr: inet_pton");
      return -1;

    __CPROVER_DUMP_L3:
      ;
      logstr(65539, "not a valid ip address: %s", ipstr);
      return -1;
    }
    ipa = inaddr.s_addr;
    tmp = (unsigned int)0;
    i = 0;
    for( ; !(i >= 4); i = i + 1)
    {
      tmp = tmp << 8;
      tmp = tmp | ipa & (unsigned int)0xff;
      ipa = ipa >> 8;
    }
    ptr=inet_ntop(2, (const void *)&tmp, tmpstr, (unsigned int)16);
    if(ptr == ((const char *)NULL))
    {
      perror("inet_ntop");
      return -1;
    }

    else
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(tmpstr);
      /* assertion strlen(tmpstr) == iplen */
      assert(return_value_strlen_1 == iplen);
      strncpy(ipstr, tmpstr, iplen);
      return 0;
    }
  }
}

// rotate
// file bloommgr.c line 30
static void * rotate(void *arg)
{
  logstr(65543, "rotate thread starting");
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  if(ctx->config.rotate_interval >= return_value_time_1 + -(*ctx->last_rotate))
  {
    logstr(65543, "rotation not needed");
    return (void *)0;
  }

  else
  {
    signed long int return_value_time_2;
    return_value_time_2=time((signed long int *)(void *)0);
    logstr(65543, "Now: %d Last: %d Max-diff %d", return_value_time_2, *ctx->last_rotate, ctx->config.rotate_interval * (signed long int)ctx->config.num_bufs);
    pthread_mutex_lock(&ctx->bloom_guard);
    signed long int return_value_time_3;
    return_value_time_3=time((signed long int *)(void *)0);
    if(!(ctx->config.rotate_interval * (signed long int)ctx->config.num_bufs >= return_value_time_3 + -(*ctx->last_rotate)))
    {
      zero_bloom_ring_queue(ctx->filter);
      *ctx->last_rotate=time((signed long int *)(void *)0);
      logstr(65542, "Max timediff exceeded. Zeroing whole bloom ring.");
    }

    else
    {
      *ctx->last_rotate = *ctx->last_rotate + ctx->config.rotate_interval;
      ctx->filter=rotate_bloom_ring_queue(ctx->filter);
    }
    pthread_mutex_unlock(&ctx->bloom_guard);
    logstr(65543, "rotation completed");
    return (void *)0;
  }
}

// rotate_bloom_ring_queue
// file bloom.c line 375
struct anonymous_22 * rotate_bloom_ring_queue(struct anonymous_22 *brq)
{
  unsigned int i;
  struct anonymous_24 *tmp;
  tmp=copy_bloom_filter(brq->aggregate, 1);
  unsigned int return_value_bloom_ring_queue_next_index_1;
  return_value_bloom_ring_queue_next_index_1=bloom_ring_queue_next_index(brq);
  zero_bloom_filter(brq->group->filter_group[(signed long int)return_value_bloom_ring_queue_next_index_1]);
  i = (unsigned int)0;
  for( ; !(i >= brq->group->group_size); i = i + 1u)
    tmp=add_filter(tmp, brq->group->filter_group[(signed long int)i]);
  advance_bloom_ring_queue(brq);
  memcpy((void *)brq->aggregate->filter, (const void *)tmp->filter, (unsigned long int)(tmp->bitsize / (unsigned int)8));
  release_bloom_filter(tmp);
  return brq;
}

// rotate_right
// file sha256.c line 46
unsigned int rotate_right(unsigned int num, signed int amount)
{
  return num >> amount | num << 32 - amount;
}

// sctoh
// file syncmgr.c line 121
struct anonymous_17 sctoh(struct anonymous_17 *sync)
{
  struct anonymous_17 tmp;
  tmp.filter_size=ntohl(sync->filter_size);
  unsigned int return_value_ntohl_1;
  return_value_ntohl_1=ntohl((unsigned int)sync->num_bufs);
  tmp.num_bufs = (signed int)return_value_ntohl_1;
  return tmp;
}

// scton
// file syncmgr.c line 110
struct anonymous_17 scton(struct anonymous_17 *sync)
{
  struct anonymous_17 tmp;
  tmp.filter_size=htonl(sync->filter_size);
  unsigned int return_value_htonl_1;
  return_value_htonl_1=htonl((unsigned int)sync->num_bufs);
  tmp.num_bufs = (signed int)return_value_htonl_1;
  return tmp;
}

// send_filters
// file syncmgr.c line 382
void send_filters(struct peer_s *peer)
{
  signed int ret = -1;
  signed int i;
  signed int j;
  signed int index;
  struct anonymous_14 msg;
  char *err;
  signed int size;
  size=min((signed int)(unsigned int)32, (signed int)ctx->filter->group->filter_group[(signed long int)0]->size);
  i = 0;
  for( ; !((unsigned int)i >= ctx->filter->group->group_size); i = i + 1)
  {
    bzero((void *)msg.filter, sizeof(unsigned int) /*4ul*/  * (unsigned long int)(unsigned int)32);
    index = 0;
    j = 0;
    for( ; !((unsigned int)j >= ctx->filter->group->filter_group[(signed long int)i]->size); j = j + 1)
    {
      msg.filter[(signed long int)((unsigned int)j - (unsigned int)index * (unsigned int)32)] = ctx->filter->group->filter_group[(signed long int)i]->filter[(signed long int)j];
      if(j % size == size + -1)
      {
        msg.buffer = i;
        msg.index = (unsigned int)index;
        ret=send_startup_sync(peer, &msg);
        if(!(ret >= 0))
        {
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          err=strerror(*return_value___errno_location_1);
          logstr(65539, "Send filters: %s", err);
        }

        index = index + 1;
        bzero((void *)msg.filter, sizeof(unsigned int) /*4ul*/  * (unsigned long int)(unsigned int)32);
      }

    }
    logstr(65543, "Sent buffer: %d", i);
  }
  logstr(65543, "Forcing peer aggregate sync");
  force_peer_aggregate(peer);
}

// send_oper_sync
// file ../include/syncmgr.h line 75
signed int send_oper_sync(struct peer_s *peer, struct anonymous_15 *sync)
{
  struct anonymous_16 prologue;
  char buf[(signed long int)(sizeof(struct anonymous_16) * 5) /*40l*/ ] = { (char)0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  unsigned int return_value_htonl_1;
  return_value_htonl_1=htonl((unsigned int)0x01);
  prologue.type = (signed int)return_value_htonl_1;
  prologue.length=htonl((unsigned int)sizeof(struct anonymous_15) /*32ul*/ );
  sync->digest=dton(sync->digest);
  memcpy((void *)buf, (const void *)&prologue, sizeof(struct anonymous_16) /*8ul*/ );
  memcpy((void *)(buf + (signed long int)sizeof(struct anonymous_16) /*8ul*/ ), (const void *)sync, sizeof(struct anonymous_15) /*32ul*/ );
  signed int return_value_send_update_to_peer_2;
  return_value_send_update_to_peer_2=send_update_to_peer(peer, (void *)buf, (signed int)(sizeof(struct anonymous_16) /*8ul*/  + sizeof(struct anonymous_15) /*32ul*/ ));
  return return_value_send_update_to_peer_2;
}

// send_result
// file thread_pool.c line 336
void send_result(struct edict_s *edict, void *result)
{
  signed int ret;
  struct anonymous_34 message;
  message.result = result;
  ret=put_msg(edict->resultmq, (void *)&message, sizeof(struct anonymous_34) /*16ul*/ , 0);
  if(!(ret >= 0))
    perror("send_result");

}

// send_sjsms_msg
// file proto_sjsms.c line 100
signed int send_sjsms_msg(signed int fd, struct sockaddr_in *gserv, struct anonymous_31 *message)
{
  signed int slen;
  signed int mlen;
  slen = (signed int)sizeof(struct sockaddr_in) /*16ul*/ ;
  mlen = (signed int)((unsigned long int)message->msglen + (unsigned long int)2 * sizeof(unsigned short int) /*2ul*/ );
  message->msgtype=htons(message->msgtype);
  message->msglen=htons(message->msglen);
  signed long int return_value_sendto_1;
  return_value_sendto_1=sendto(fd, (const void *)message, (unsigned long int)mlen, 0, (struct sockaddr *)gserv, (unsigned int)slen);
  return (signed int)return_value_sendto_1;
}

// send_startup_sync
// file syncmgr.c line 154
signed int send_startup_sync(struct peer_s *peer, struct anonymous_14 *sync)
{
  struct anonymous_16 prologue;
  char buf[(signed long int)(sizeof(struct anonymous_16) * 18) /*144l*/ ] = { (char)0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct anonymous_14 tmp;
  tmp=sston(*sync);
  unsigned int return_value_htonl_1;
  return_value_htonl_1=htonl((unsigned int)0x00);
  prologue.type = (signed int)return_value_htonl_1;
  prologue.length=htonl((unsigned int)sizeof(struct anonymous_14) /*136ul*/ );
  memcpy((void *)buf, (const void *)&prologue, sizeof(struct anonymous_16) /*8ul*/ );
  memcpy((void *)(buf + (signed long int)sizeof(struct anonymous_16) /*8ul*/ ), (const void *)&tmp, sizeof(struct anonymous_14) /*136ul*/ );
  signed int return_value_send_update_to_peer_2;
  return_value_send_update_to_peer_2=send_update_to_peer(peer, (void *)buf, (signed int)(sizeof(struct anonymous_16) /*8ul*/  + sizeof(struct anonymous_14) /*136ul*/ ));
  return return_value_send_update_to_peer_2;
}

// send_sync_config
// file syncmgr.c line 145
signed int send_sync_config(struct peer_s *peer, struct anonymous_17 *sync)
{
  struct anonymous_17 tmp;
  tmp=scton(sync);
  signed int return_value_send_update_to_peer_1;
  return_value_send_update_to_peer_1=send_update_to_peer(peer, (void *)&tmp, (signed int)sizeof(struct anonymous_17) /*8ul*/ );
  return return_value_send_update_to_peer_1;
}

// send_update_msg_as_oper_sync
// file syncmgr.c line 184
signed int send_update_msg_as_oper_sync(void *arg)
{
  struct anonymous_19 *update;
  struct anonymous_16 prologue;
  char buf[(signed long int)(sizeof(struct anonymous_16) * 5) /*40l*/ ] = { (char)0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct anonymous_18 digest;
  struct anonymous_15 os;
  update = (struct anonymous_19 *)arg;
  /* assertion update */
  assert(update != ((struct anonymous_19 *)NULL));
  if(update->mtype == 1l)
  {
    memcpy((void *)&digest, (const void *)update->mtext, sizeof(struct anonymous_18) /*32ul*/ );
    unsigned int return_value_htonl_1;
    return_value_htonl_1=htonl((unsigned int)0x01);
    prologue.type = (signed int)return_value_htonl_1;
    prologue.length=htonl((unsigned int)sizeof(struct anonymous_15) /*32ul*/ );
    os.digest=dton(digest);
    memcpy((void *)buf, (const void *)&prologue, sizeof(struct anonymous_16) /*8ul*/ );
    memcpy((void *)(buf + (signed long int)sizeof(struct anonymous_16) /*8ul*/ ), (const void *)&os, sizeof(struct anonymous_15) /*32ul*/ );
    signed int return_value_send_update_to_peer_2;
    return_value_send_update_to_peer_2=send_update_to_peer(&ctx->config.peer, (void *)buf, (signed int)(sizeof(struct anonymous_16) /*8ul*/  + sizeof(struct anonymous_15) /*32ul*/ ));
    return return_value_send_update_to_peer_2;
  }

  return 0;
}

// send_update_to_peer
// file syncmgr.c line 132
signed int send_update_to_peer(struct peer_s *peer, void *ptr, signed int size)
{
  signed int ret;
  pthread_mutex_lock(&peer->peer_in_mutex);
  signed long int return_value_writen_1;
  return_value_writen_1=writen(peer->connected, ptr, (unsigned long int)size);
  ret = (signed int)return_value_writen_1;
  pthread_mutex_unlock(&peer->peer_in_mutex);
  return ret;
}

// senderrormsg
// file proto_sjsms.c line 40
signed int senderrormsg(signed int fd, struct sockaddr_in *gserv, const char *fmt, ...)
{
  struct anonymous_31 message;
  void **vap = (void **)&fmt;
  vsnprintf(message.message, (unsigned long int)1024, fmt, vap);
  vap = ((void **)NULL);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(message.message);
  unsigned long int tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  if(!(1ul + return_value_strlen_1 >= 1024ul))
  {
    return_value_strlen_2=strlen(message.message);
    tmp_if_expr_3 = return_value_strlen_2 + (unsigned long int)1;
  }

  else
    tmp_if_expr_3 = (unsigned long int)1024;
  message.msglen = (unsigned short int)tmp_if_expr_3;
  message.msgtype = (unsigned short int)1;
  signed int return_value_send_sjsms_msg_4;
  return_value_send_sjsms_msg_4=send_sjsms_msg(fd, gserv, &message);
  return return_value_send_sjsms_msg_4;
}

// sendquery
// file proto_sjsms.c line 57
signed int sendquery(signed int fd, struct sockaddr_in *gserv, struct anonymous_30 *request)
{
  struct anonymous_31 message;
  unsigned short int return_value_ntohs_1;
  return_value_ntohs_1=ntohs(request->msglen);
  unsigned long int tmp_if_expr_3;
  unsigned short int return_value_ntohs_2;
  if(!(sizeof(struct anonymous_30) /*1032ul*/  + (unsigned long int)return_value_ntohs_1 + 18446744073709551608ul >= 1024ul))
  {
    return_value_ntohs_2=ntohs(request->msglen);
    tmp_if_expr_3 = ((unsigned long int)return_value_ntohs_2 + sizeof(struct anonymous_30) /*1032ul*/ ) - sizeof(char *) /*8ul*/ ;
  }

  else
    tmp_if_expr_3 = (unsigned long int)1024;
  message.msglen = (unsigned short int)tmp_if_expr_3;
  message.msgtype = (unsigned short int)0;
  memcpy((void *)&message.message, (const void *)request, (unsigned long int)message.msglen);
  signed int return_value_send_sjsms_msg_4;
  return_value_send_sjsms_msg_4=send_sjsms_msg(fd, gserv, &message);
  return return_value_send_sjsms_msg_4;
}

// sendquerystr
// file proto_sjsms.c line 69
signed int sendquerystr(signed int fd, struct sockaddr_in *gserv, const char *querystr)
{
  struct anonymous_31 message;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(querystr);
  unsigned long int tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  if(!(return_value_strlen_1 >= 1024ul))
  {
    return_value_strlen_2=strlen(querystr);
    tmp_if_expr_3 = return_value_strlen_2;
  }

  else
    tmp_if_expr_3 = (unsigned long int)1024;
  message.msglen = (unsigned short int)tmp_if_expr_3;
  message.msgtype = (unsigned short int)2;
  memcpy((void *)&message.message, (const void *)querystr, (unsigned long int)message.msglen);
  signed int return_value_send_sjsms_msg_4;
  return_value_send_sjsms_msg_4=send_sjsms_msg(fd, gserv, &message);
  return return_value_send_sjsms_msg_4;
}

// set_delay
// file msgqueue.c line 347
signed int set_delay(signed int msqid, struct timespec *ts)
{
  struct msgqueue_s *mq;
  signed int ret;
  mq=queuebyid(msqid);
  if(mq == ((struct msgqueue_s *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(mq->delaypair == ((struct msgqueue_s *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  if(mq->delay_ts == ((struct timespec *)NULL))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 22;
    return -1;
  }

  ret=pthread_mutex_lock(&mq->mx);
  /* assertion ret == 0 */
  assert(ret == 0);
  memcpy((void *)mq->delay_ts, (const void *)ts, sizeof(struct timespec) /*16ul*/ );
  ret=pthread_mutex_unlock(&mq->mx);
  /* assertion ret == 0 */
  assert(ret == 0);
  return 0;
}

// set_delay_status
// file msgqueue.c line 265
signed int set_delay_status(signed int msqid, signed int state)
{
  struct msgqueue_s *mq;
  signed int ret;
  mq=queuebyid(msqid);
  if(mq == ((struct msgqueue_s *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(mq->delaypair == ((struct msgqueue_s *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  ret=pthread_mutex_lock(&mq->mx);
  /* assertion ret == 0 */
  assert(ret == 0);
  *mq->impose_delay = state;
  ret=pthread_mutex_unlock(&mq->mx);
  /* assertion ret == 0 */
  assert(ret == 0);
  return 0;
}

// setup_signal_handlers
// file gross.c line 542
void setup_signal_handlers(void)
{
  struct sigaction act;
  signal(1, (void (*)(signed int))1);
  signal(13, (void (*)(signed int))1);
  sigemptyset(&act.sa_mask);
  sigaddset(&act.sa_mask, 14);
  act.__sigaction_handler.sa_handler = noop;
  act.sa_flags = 0;
  sigaction(14, &act, (struct sigaction *)(void *)0);
  sigemptyset(&act.sa_mask);
  act.__sigaction_handler.sa_handler = mrproper;
  act.sa_flags = (signed int)0x80000000;
  sigaction(2, &act, (struct sigaction *)(void *)0);
  sigaction(15, &act, (struct sigaction *)(void *)0);
}

// sha256
// file sha256.c line 120
struct anonymous_18 sha256(unsigned char *message, unsigned long int size)
{
  struct anonymous_18 digest = DEFAULT_SHA256;
  struct anonymous_18 tmp_digest = DEFAULT_SHA256;
  unsigned long int new_size = size + (unsigned long int)1 + (unsigned long int)8 + (((unsigned long int)448 - (unsigned long int)8 * (size + (unsigned long int)1)) % (unsigned long int)512) / (unsigned long int)8;
  unsigned long int tmp_size = size * (unsigned long int)8;
  unsigned int i;
  unsigned int j;
  unsigned char *iter;
  unsigned int w[64l];
  unsigned int s0;
  unsigned int s1;
  unsigned int maj;
  unsigned int t2;
  unsigned int ch;
  unsigned int t1;
  unsigned int chunk;
  unsigned char *digestable_message;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(unsigned char) /*1ul*/  * new_size);
  digestable_message = (unsigned char *)return_value_Malloc_1;
  signed int return_value_little_endian_2;
  return_value_little_endian_2=little_endian();
  if(!(return_value_little_endian_2 == 0))
  {
    p_convert_int64_to_big_endian = convert_int64_little_endian;
    p_convert_int32_to_big_endian = convert_int32_little_endian;
  }

  bzero((void *)digestable_message, new_size);
  memcpy((void *)digestable_message, (const void *)message, size);
  digestable_message[(signed long int)size] = (unsigned char)0x80;
  p_convert_int64_to_big_endian(&tmp_size);
  i = (unsigned int)(new_size - (unsigned long int)8);
  j = (unsigned int)0;
  iter = (unsigned char *)&tmp_size;
  if(!((unsigned long int)i >= new_size))
  {
    digestable_message[(signed long int)i] = iter[(signed long int)j];
    i = i + 1u;
    j = j + 1u;
  }

  iter = (unsigned char *)digestable_message;
  i = (unsigned int)0;
  if(!((unsigned long int)i >= new_size))
  {
    j = (unsigned int)0;
    if(!(j >= 64u))
    {
      chunk = *((unsigned int *)(iter + (signed long int)i + (signed long int)j));
      p_convert_int32_to_big_endian(&chunk);
      w[(signed long int)(j / (unsigned int)4)] = chunk;
      j = j + (unsigned int)4;
    }

    j = (unsigned int)16;
    if(!(j >= 64u))
    {
      unsigned int return_value_rotate_right_3;
      return_value_rotate_right_3=rotate_right(w[(signed long int)(j - (unsigned int)15)], 7);
      unsigned int return_value_rotate_right_4;
      return_value_rotate_right_4=rotate_right(w[(signed long int)(j - (unsigned int)15)], 18);
      s0 = return_value_rotate_right_3 ^ return_value_rotate_right_4 ^ w[(signed long int)(j - (unsigned int)15)] >> 3;
      unsigned int return_value_rotate_right_5;
      return_value_rotate_right_5=rotate_right(w[(signed long int)(j - (unsigned int)2)], 17);
      unsigned int return_value_rotate_right_6;
      return_value_rotate_right_6=rotate_right(w[(signed long int)(j - (unsigned int)2)], 19);
      s1 = return_value_rotate_right_5 ^ return_value_rotate_right_6 ^ w[(signed long int)(j - (unsigned int)2)] >> 10;
      w[(signed long int)j] = w[(signed long int)(j - (unsigned int)16)] + s0 + w[(signed long int)(j - (unsigned int)7)] + s1;
      j = j + 1u;
    }

    tmp_digest = digest;
    j = (unsigned int)0;
    if(!(j >= 64u))
    {
      unsigned int return_value_rotate_right_7;
      return_value_rotate_right_7=rotate_right(tmp_digest.h0, 2);
      unsigned int return_value_rotate_right_8;
      return_value_rotate_right_8=rotate_right(tmp_digest.h0, 13);
      unsigned int return_value_rotate_right_9;
      return_value_rotate_right_9=rotate_right(tmp_digest.h0, 22);
      s0 = return_value_rotate_right_7 ^ return_value_rotate_right_8 ^ return_value_rotate_right_9;
      maj = tmp_digest.h0 & tmp_digest.h1 ^ tmp_digest.h1 & tmp_digest.h2 ^ tmp_digest.h2 & tmp_digest.h0;
      t2 = s0 + maj;
      unsigned int return_value_rotate_right_10;
      return_value_rotate_right_10=rotate_right(tmp_digest.h4, 6);
      unsigned int return_value_rotate_right_11;
      return_value_rotate_right_11=rotate_right(tmp_digest.h4, 11);
      unsigned int return_value_rotate_right_12;
      return_value_rotate_right_12=rotate_right(tmp_digest.h4, 25);
      s1 = return_value_rotate_right_10 ^ return_value_rotate_right_11 ^ return_value_rotate_right_12;
      ch = tmp_digest.h4 & tmp_digest.h5 ^ ~tmp_digest.h4 & tmp_digest.h6;
      t1 = tmp_digest.h7 + s1 + ch + ROUND_CONSTANTS[(signed long int)j] + w[(signed long int)j];
      tmp_digest.h7 = tmp_digest.h6;
      tmp_digest.h6 = tmp_digest.h5;
      tmp_digest.h5 = tmp_digest.h4;
      tmp_digest.h4 = tmp_digest.h3 + t1;
      tmp_digest.h3 = tmp_digest.h2;
      tmp_digest.h2 = tmp_digest.h1;
      tmp_digest.h1 = tmp_digest.h0;
      tmp_digest.h0 = t2 + t1;
      j = j + 1u;
    }

    digest.h0 = digest.h0 + tmp_digest.h0;
    digest.h1 = digest.h1 + tmp_digest.h1;
    digest.h2 = digest.h2 + tmp_digest.h2;
    digest.h3 = digest.h3 + tmp_digest.h3;
    digest.h4 = digest.h4 + tmp_digest.h4;
    digest.h5 = digest.h5 + tmp_digest.h5;
    digest.h6 = digest.h6 + tmp_digest.h6;
    digest.h7 = digest.h7 + tmp_digest.h7;
    i = i + (unsigned int)64;
  }

  /* assertion digestable_message */
  assert(digestable_message != ((unsigned char *)NULL));
  free((void *)digestable_message);
  digestable_message = (unsigned char *)(void *)0;
  return digest;
}

// sha256_string
// file sha256.c line 220
struct anonymous_18 sha256_string(char *message)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(message);
  struct anonymous_18 return_value_sha256_2;
  return_value_sha256_2=sha256((unsigned char *)message, return_value_strlen_1);
  return return_value_sha256_2;
}

// sjsms_connection
// file worker_sjsms.c line 167
signed int sjsms_connection(struct thread_pool_s *info, struct anonymous_32 *thread_ctx, struct edict_s *edict)
{
  unsigned int len;
  struct anonymous_30 request;
  struct anonymous_31 *msg;
  struct grey_tuple_s *tuple;
  char response[1024l];
  struct final_status_s *status;
  signed int ret;
  struct tmout_action_s ta1;
  struct tmout_action_s ta2;
  char *mapstr;
  char *str;
  struct client_info_s *client_info;
  char *querystr = (char *)(void *)0;
  client_info = (struct client_info_s *)edict->job;
  /* assertion client_info */
  assert(client_info != ((struct client_info_s *)NULL));
  /* assertion 0 < client_info->msglen */
  assert(0 < client_info->msglen);
  /* assertion client_info->msglen <= 1024 */
  assert(client_info->msglen <= 1024);
  logstr(65543, "query from %s", client_info->ipstr);
  strncpy(response, "F", (unsigned long int)1024);
  if(ctx->config.query_timelimit >= 1001)
  {
    ta1.timeout = 1000;
    ta1.action = calm_client;
    ta1.arg = (void *)client_info;
    ta1.next = &ta2;
    ta2.timeout = ctx->config.query_timelimit;
    ta2.action = (void (*)(void *, signed int))(void *)0;
    ta2.next = (struct tmout_action_s *)(void *)0;
  }

  else
  {
    ta1.timeout = ctx->config.query_timelimit;
    ta1.action = (void (*)(void *, signed int))(void *)0;
    ta1.next = (struct tmout_action_s *)(void *)0;
  }
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct anonymous_31) /*1028ul*/ );
  msg = (struct anonymous_31 *)return_value_Malloc_1;
  memset((void *)msg, 0, sizeof(struct anonymous_31) /*1028ul*/ );
  memcpy((void *)msg, client_info->message, (unsigned long int)client_info->msglen);
  sjsms_to_host_order(msg);
  unsigned long int return_value_strlen_4;
  void *return_value_Malloc_5;
  signed int tmp_if_expr_6;
  switch((signed int)msg->msgtype)
  {
    case (signed int)(unsigned short int)0:

    case (signed int)(unsigned short int)2:
    {
      if(msg->msgtype == 0)
      {
        recvquery(msg, &request);
        tuple=unfold(&request);
      }

      else
      {
        querystr=recvquerystr(msg);
        tuple=parsequery(querystr);
        /* assertion querystr */
        assert(querystr != ((char *)NULL));
        free((void *)querystr);
        querystr = (char *)(void *)0;
      }
      if(tuple == ((struct grey_tuple_s *)NULL))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(*return_value___errno_location_2);
        logstr(65539, "unfold: %s", return_value_strerror_3);
        break;
      }

      status=init_status("sjsms");
      ret=test_tuple(status, tuple, &ta1);
      if(!(ret >= 0))
        snprintf(response, (unsigned long int)1024, "F");

      else
        switch((signed int)status->status)
        {
          case STATUS_MATCH:
          {
            snprintf(response, (unsigned long int)1024, "M %s", ctx->config.sjsms.responsematch);
            break;
          }
          case STATUS_GREY:
          {
            mapstr=assemble_mapresult(ctx->config.sjsms.responsegrey, status->reason);
            snprintf(response, (unsigned long int)1024, "G %s", mapstr);
            /* assertion mapstr */
            assert(mapstr != ((char *)NULL));
            free((void *)mapstr);
            mapstr = (char *)(void *)0;
            break;
          }
          case STATUS_BLOCK:
          {
            mapstr=assemble_mapresult(ctx->config.sjsms.responseblock, status->reason);
            snprintf(response, (unsigned long int)1024, "B %s", mapstr);
            /* assertion mapstr */
            assert(mapstr != ((char *)NULL));
            free((void *)mapstr);
            mapstr = (char *)(void *)0;
            break;
          }
          case STATUS_TRUST:
          {
            snprintf(response, (unsigned long int)1024, "T %s", ctx->config.sjsms.responsetrust);
            break;
          }
          default:
            snprintf(response, (unsigned long int)1024, "F");
        }
      response[(signed long int)(1024 - 1)] = (char)0;
      len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
      return_value_strlen_4=strlen(response);
      sendto(client_info->connfd, (const void *)response, return_value_strlen_4, 0, (struct sockaddr *)client_info->caddr, len);
      finalize(status);
      request_unlink(tuple);
      break;
    }
    case (signed int)(unsigned short int)1:
    {
      return_value_Malloc_5=Malloc((unsigned long int)msg->msglen);
      str = (char *)return_value_Malloc_5;
      if(!((signed int)msg->msglen >= 1024))
        tmp_if_expr_6 = (signed int)msg->msglen;

      else
        tmp_if_expr_6 = 1024;
      memcpy((void *)str, (const void *)msg->message, (unsigned long int)tmp_if_expr_6);
      str[(signed long int)((signed int)msg->msglen - 1)] = (char)0;
      logstr(65539, "Client %s said: %s", client_info->ipstr, str);
      /* assertion str */
      assert(str != ((char *)NULL));
      free((void *)str);
      str = (char *)(void *)0;
      break;
    }
    default:
      logstr(65539, "Unknown message from client %s", client_info->ipstr);
  }
/* assertion msg */

OUT:
  ;
  /* assertion msg */
  assert(msg != ((struct anonymous_31 *)NULL));
  free((void *)msg);
  msg = (struct anonymous_31 *)(void *)0;
  free_client_info(client_info);
  logstr(65543, "sjsms_connection returning");
  return 1;
}

// sjsms_server
// file worker_sjsms.c line 299
static void * sjsms_server(void *arg)
{
  signed int grossfd;
  signed int ret;
  signed int msglen;
  unsigned int clen;
  struct client_info_s *client_info;
  char mesg[1024l];
  struct edict_s *edict;
  struct thread_pool_s *sjsms_pool;
  grossfd=socket(2, 2, 17);
  if(!(grossfd >= 0))
    daemon_fatal("socket");

  ret=bind(grossfd, (struct sockaddr *)&ctx->config.gross_host, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(ret >= 0))
    daemon_fatal("bind");

  logstr(65542, "initializing sjsms worker thread pool");
  sjsms_pool=create_thread_pool("sjsms", sjsms_connection, (struct anonymous_33 *)(void *)0, (void *)0);
  if(sjsms_pool == ((struct thread_pool_s *)NULL))
    daemon_fatal("create_thread_pool");

  do
  {
    void *return_value_Malloc_1;
    return_value_Malloc_1=Malloc(sizeof(struct client_info_s) /*48ul*/ );
    client_info = (struct client_info_s *)return_value_Malloc_1;
    memset((void *)client_info, 0, sizeof(struct client_info_s) /*48ul*/ );
    void *return_value_Malloc_2;
    return_value_Malloc_2=Malloc(sizeof(struct sockaddr_in) /*16ul*/ );
    client_info->caddr = (struct sockaddr_in *)return_value_Malloc_2;
    clen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
    signed long int return_value_recvfrom_3;
    return_value_recvfrom_3=recvfrom(grossfd, (void *)mesg, (unsigned long int)1024, 0, (struct sockaddr *)client_info->caddr, &clen);
    msglen = (signed int)return_value_recvfrom_3;
    if(!(msglen >= 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      if(*return_value___errno_location_4 == 4)
        continue;

      daemon_fatal("recvfrom");
      free_client_info(client_info);
      return (void *)0;
    }

    else
    {
      client_info->message=Malloc((unsigned long int)msglen);
      client_info->connfd = grossfd;
      client_info->msglen = msglen;
      client_info->ipstr=ipstr(client_info->caddr);
      memcpy(client_info->message, (const void *)mesg, (unsigned long int)msglen);
      edict=edict_get(1);
      edict->job = (void *)client_info;
      submit_job(sjsms_pool, edict);
      edict_unlink(edict);
    }
  }
  while((_Bool)1);
}

// sjsms_server_init
// file worker.c line 35
void sjsms_server_init()
{
  logstr(65542, "starting sjsms policy server");
  create_thread(&ctx->process_parts.sjsms_server, 1, sjsms_server, (void *)0);
}

// sjsms_to_host_order
// file proto_sjsms.c line 114
signed int sjsms_to_host_order(struct anonymous_31 *message)
{
  message->msgtype=ntohs(message->msgtype);
  message->msglen=ntohs(message->msglen);
  return 1;
}

// srvstatus
// file srvstatus.c line 109
static void * srvstatus(void *arg)
{
  signed int ret = -1;
  signed int statfd = -1;
  signed int opt = -1;
  signed int tmpfd = -1;
  char statbuf[1024l] = { (char)0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  unsigned int clen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  struct sockaddr_in receive;
  statfd=socket(2, 1, 6);
  if(!(statfd >= 0))
  {
    logstr(65538, "Srvstatus socket failed.");
    pthread_exit((void *)0);
  }

  opt = 1;
  ret=setsockopt(statfd, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(ret >= 0))
  {
    logstr(65538, "Socket option setting failed");
    pthread_exit((void *)0);
  }

  ret=bind(statfd, (struct sockaddr *)&ctx->config.status_host, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(ret >= 0))
  {
    unsigned short int return_value_ntohs_1;
    return_value_ntohs_1=ntohs(ctx->config.status_host.sin_port);
    logstr(65538, "Bind failed in statmgr, port %d", return_value_ntohs_1);
    pthread_exit((void *)0);
  }

  ret=listen(statfd, ctx->config.max_connq);
  if(!(ret >= 0))
  {
    logstr(65538, "Listen failed in statmgr");
    pthread_exit((void *)0);
  }

  while((_Bool)1)
  {
    memset((void *)statbuf, 0, (unsigned long int)1024);
    tmpfd=accept(statfd, (struct sockaddr *)&receive, &clen);
    if(!(tmpfd >= 0))
      perror("Syncfd accept");

    else
    {
      get_srvstatus(statbuf, 1024 - 2);
      statbuf[(signed long int)(1024 - 1)] = (char)0;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(statbuf);
      statbuf[(signed long int)return_value_strlen_2] = (char)10;
      logstr(65543, "Telling service status.");
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(statbuf);
      writen(tmpfd, (const void *)statbuf, return_value_strlen_3);
      close(tmpfd);
    }
  }
}

// srvstatus_init
// file gross.c line 56
void srvstatus_init()
{
  create_thread((struct anonymous_40 *)(void *)0, 1, srvstatus, (void *)0);
}

// sstoh
// file syncmgr.c line 59
struct anonymous_14 sstoh(struct anonymous_14 ss)
{
  signed int i;
  struct anonymous_14 ret_value;
  unsigned int return_value_ntohl_1;
  return_value_ntohl_1=ntohl((unsigned int)ss.buffer);
  ret_value.buffer = (signed int)return_value_ntohl_1;
  ret_value.index=ntohl(ss.index);
  i = 0;
  for( ; !((unsigned int)i >= 32u); i = i + 1)
    ret_value.filter[(signed long int)i]=ntohl(ss.filter[(signed long int)i]);
  return ret_value;
}

// sston
// file syncmgr.c line 42
struct anonymous_14 sston(struct anonymous_14 ss)
{
  signed int i;
  struct anonymous_14 ret_value;
  unsigned int return_value_htonl_1;
  return_value_htonl_1=htonl((unsigned int)ss.buffer);
  ret_value.buffer = (signed int)return_value_htonl_1;
  ret_value.index=htonl(ss.index);
  i = 0;
  for( ; !((unsigned int)i >= 32u); i = i + 1)
    ret_value.filter[(signed long int)i]=htonl(ss.filter[(signed long int)i]);
  return ret_value;
}

// start_syncer
// file syncmgr.c line 375
void start_syncer(void *arg)
{
  create_thread((struct anonymous_40 *)(void *)0, 1, recv_syncs, (void *)0);
}

// stat_add_dnsbl
// file ../include/stats.h line 67
signed int stat_add_dnsbl(const char *name)
{
  struct dnsbl_stat *prev = ctx->stats.dnsbl_match;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct dnsbl_stat) /*24ul*/ );
  ctx->stats.dnsbl_match = (struct dnsbl_stat *)return_value_Malloc_1;
  ctx->stats.dnsbl_match->dnsbl_name=strdup(name);
  ctx->stats.dnsbl_match->matches_startup = (unsigned long int)0;
  ctx->stats.dnsbl_match->next = prev;
  return 1;
}

// stat_dnsbl_match
// file stats.c line 77
unsigned long int stat_dnsbl_match(const char *name)
{
  struct dnsbl_stat *cur = ctx->stats.dnsbl_match;
  signed int max_dnsbl_name_len = 256;
  signed int result = 0;
  pthread_mutex_lock(&ctx->stats.mx);
  while(!(cur == ((struct dnsbl_stat *)NULL)))
  {
    signed int return_value_strncmp_1;
    return_value_strncmp_1=strncmp(cur->dnsbl_name, name, (unsigned long int)max_dnsbl_name_len);
    if(return_value_strncmp_1 == 0)
    {
      cur->matches_startup = cur->matches_startup + 1ul;
      logstr(65543, "%llu matches from %s", cur->matches_startup, name);
      result = (signed int)cur->matches_startup;
      break;
    }

    cur = cur->next;
  }
  pthread_mutex_unlock(&ctx->stats.mx);
  if(result == 0)
    logstr(65540, "Match from unknown dnsbl: %s", name);

  return (unsigned long int)result;
}

// statstr
// file srvutils.c line 67
signed int statstr(signed int level, const char *fmt, ...)
{
  char mbuf[1024l] = { (char)0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  void **vap;
  signed int return_value_log_put_1;
  if((ctx->config.statlevel & level) == 262144)
    return 0;

  else
    if(!(ctx->config.loglevel >= 65541))
      return 0;

    else
    {
      vap = (void **)&fmt;
      vsnprintf(mbuf, (unsigned long int)1024, fmt, vap);
      vap = ((void **)NULL);
      if(!((0x01 & ctx->config.flags) == 0))
      {
        return_value_log_put_1=log_put(mbuf);
        return return_value_log_put_1;
      }

      else
      {
        level = 65541;
        level = level ^ 65536;
        syslog(level, "%s", (const void *)mbuf);
        return 0;
      }
    }
}

// submit_job
// file ../include/thread_pool.h line 109
signed int submit_job(struct thread_pool_s *pool, struct edict_s *edict)
{
  struct edict_message_s message;
  message.mtype = (signed long int)0;
  message.edict = edict;
  edict_reference(edict);
  signed int return_value_put_msg_1;
  return_value_put_msg_1=put_msg(pool->work_queue_id, (void *)&message, sizeof(struct edict_s *) /*8ul*/ , 0);
  return return_value_put_msg_1;
}

// swap_bytes
// file sha256.c line 66
void swap_bytes(unsigned char *a, unsigned char *b)
{
  unsigned char tmp = *a;
  *a = *b;
  *b = tmp;
}

// sync_aggregate
// file bloom.c line 445
void sync_aggregate(struct anonymous_22 *brq)
{
  signed int i;
  unsigned int index = brq->current_index;
  zero_bloom_filter(brq->aggregate);
  i = 0;
  for( ; !((unsigned int)i >= brq->group->group_size); i = i + 1)
  {
    brq->aggregate=add_filter(brq->aggregate, brq->group->filter_group[(signed long int)index]);
    index = index + 1u;
    if(index >= brq->group->group_size)
      index = (unsigned int)0;

  }
}

// synchronize
// file syncmgr.c line 418
signed int synchronize(struct peer_s *peer, signed int syncfd)
{
  signed int opt = 0;
  unsigned int clen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  char synchronize__1__ipstr[16l];
  char conn_ipstr[16l];
  signed int ret;
  struct anonymous_17 conf;
  struct anonymous_19 rotatecmd;
  struct sockaddr_in receive;
  struct sockaddr_in sync_out;
  peer->peerfd_out=socket(2, 1, 0);
  ret=setsockopt(peer->peerfd_out, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(ret == 0))
    daemon_fatal("setsockopt");

  memcpy((void *)&sync_out, (const void *)&ctx->config.sync_host, sizeof(struct sockaddr_in) /*16ul*/ );
  sync_out.sin_port = (unsigned short int)0;
  ret=bind(peer->peerfd_out, (struct sockaddr *)&sync_out, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(ret >= 0))
    daemon_fatal("bind");

  signed int return_value_connect_3;
  return_value_connect_3=connect(peer->peerfd_out, (struct sockaddr *)&peer->peer_addr, clen);
  if(!(return_value_connect_3 == 0))
  {
    const char *return_value_inet_ntop_1;
    return_value_inet_ntop_1=inet_ntop(2, (const void *)&peer->peer_addr.sin_addr, synchronize__1__ipstr, (unsigned int)16);
    if(return_value_inet_ntop_1 == ((const char *)NULL))
      daemon_fatal("inet_ntop");

    unsigned short int return_value_ntohs_2;
    return_value_ntohs_2=ntohs(peer->peer_addr.sin_port);
    logstr(65542, "Connect to peer failed, host %s, port %d", (const void *)synchronize__1__ipstr, return_value_ntohs_2);
    sem_post(ctx->sync_guard);
    if(!(ret == 0))
      daemon_fatal("pthread_mutex_unlock");

  }

  else
  {
    logstr(65543, "Peer fd %d", peer->peerfd_out);
    peer->connected = peer->peerfd_out;
    rotatecmd.mtype = (signed long int)2;
    instant_msg(ctx->update_q, (void *)&rotatecmd, (unsigned long int)0, 0);
    start_syncer((void *)0);
  }
  const char *return_value_inet_ntop_4;
  return_value_inet_ntop_4=inet_ntop(2, (const void *)&ctx->config.sync_host.sin_addr, synchronize__1__ipstr, (unsigned int)16);
  if(return_value_inet_ntop_4 == ((const char *)NULL))
    daemon_fatal("inet_ntop");

  while((_Bool)1)
  {
    unsigned short int return_value_ntohs_5;
    return_value_ntohs_5=ntohs(ctx->config.sync_host.sin_port);
    logstr(65542, "Waiting sync connection on host %s port %d", (const void *)synchronize__1__ipstr, return_value_ntohs_5);
    peer->peerfd_in=accept(syncfd, (struct sockaddr *)&receive, &clen);
    logstr(65542, "Got sync connection");
    if(!(ctx->config.peer.peer_addr.sin_addr.s_addr == receive.sin_addr.s_addr))
    {
      const char *return_value_inet_ntop_6;
      return_value_inet_ntop_6=inet_ntop(2, (const void *)&receive.sin_addr, conn_ipstr, (unsigned int)16);
      if(return_value_inet_ntop_6 == ((const char *)NULL))
        daemon_fatal("inet_ntop");

      close(peer->peerfd_in);
      logstr(65542, "Sync connection not from peer. Disconnecting %s.", (const void *)conn_ipstr);
      continue;
    }

    else
    {
      const char *return_value_inet_ntop_7;
      return_value_inet_ntop_7=inet_ntop(2, (const void *)&receive.sin_addr, conn_ipstr, (unsigned int)16);
      if(return_value_inet_ntop_7 == ((const char *)NULL))
        daemon_fatal("inet_ntop");

      logstr(65542, "Good peer %s.", (const void *)conn_ipstr);
    }
    peer->connected = peer->peerfd_in;
    if(!(peer->peerfd_in >= 0))
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      if(!(*return_value___errno_location_8 == 4))
      {
        perror("Peer sync in accept()");
        return 0;
      }

    }

    conf.filter_size = ctx->config.filter_size;
    conf.num_bufs = (signed int)ctx->config.num_bufs;
    logstr(65542, "Examining peer config");
    send_sync_config(peer, &conf);
    sem_wait(ctx->sync_guard);
    queue_freeze(ctx->update_q);
    send_filters(peer);
    walk_queue(ctx->update_q, send_update_msg_as_oper_sync);
    queue_thaw(ctx->update_q);
    sem_post(ctx->sync_guard);
    logstr(65542, "Sent filters. Waiting for oper syncs");
    do
      ret=recv_sync_msg(peer);
    while(!(ret == 0x00));
  }
}

// syncmgr
// file syncmgr.c line 533
static void * syncmgr(void *arg)
{
  signed int ret = -1;
  signed int syncfd = -1;
  signed int opt = -1;
  syncfd=socket(2, 1, 6);
  if(!(syncfd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    logstr(65538, "syncmgr: socket: %s", return_value_strerror_2);
    pthread_exit((void *)0);
  }

  opt = 1;
  ret=setsockopt(syncfd, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(ret >= 0))
  {
    logstr(65538, "Socket option setting failed");
    pthread_exit((void *)0);
  }

  ret=bind(syncfd, (struct sockaddr *)&ctx->config.sync_host, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(ret >= 0))
  {
    unsigned short int return_value_ntohs_3;
    return_value_ntohs_3=ntohs(ctx->config.sync_host.sin_port);
    logstr(65538, "Bind failed in syncmgr, port %d", return_value_ntohs_3);
    pthread_exit((void *)0);
  }

  ret=listen(syncfd, ctx->config.max_connq);
  if(!(ret >= 0))
  {
    logstr(65538, "Listen failed in syncmgr");
    pthread_exit((void *)0);
  }

  synchronize(&ctx->config.peer, syncfd);
  return (void *)0;
}

// syncmgr_init
// file gross.c line 54
void syncmgr_init()
{
  sem_wait(ctx->sync_guard);
  create_thread(&ctx->process_parts.syncmgr, 1, syncmgr, (void *)0);
}

// test_thread
// file srvstatus.c line 43
signed int test_thread(unsigned long int *thread)
{
  signed int ret;
  ret=pthread_kill(*thread, 0);
  if(ret == 0)
    return 1;

  else
    return -1;
}

// test_tuple
// file worker.c line 190
signed int test_tuple(struct final_status_s *final, struct grey_tuple_s *request, struct tmout_action_s *ta)
{
  char maskedtuple[1024l];
  char *chkipstr = (char *)(void *)0;
  struct anonymous_18 digest;
  struct anonymous_19 update;
  signed int ret;
  signed int retvalue = STATUS_UNKNOWN;
  struct anonymous_15 os;
  struct edict_s *edict = (struct edict_s *)(void *)0;
  struct anonymous_34 message;
  struct chkresult_s *result = (struct chkresult_s *)(void *)0;
  struct timespec start;
  struct timespec now;
  signed int timeused;
  struct tmout_action_s *tap = (struct tmout_action_s *)(void *)0;
  struct tmout_action_s *ta_default_reserved = (struct tmout_action_s *)(void *)0;
  signed int i;
  signed int checks_running;
  signed int definitives_running;
  signed int checkcount;
  signed int susp_weight = 0;
  signed int block_threshold;
  signed int grey_threshold;
  signed int free_ta = 0;
  enum anonymous_0 judgment;
  signed int definitive;
  char *reasonstr = (char *)(void *)0;
  struct querylog_entry_s *querylog_entry;
  clock_gettime(1, &start);
  final->status = (enum anonymous_1)STATUS_FAIL;
  block_threshold = ctx->config.block_threshold;
  grey_threshold = ctx->config.grey_threshold;
  chkipstr=grey_mask(request->client_address);
  _Bool tmp_if_expr_6;
  signed int tmp_if_expr_3;
  _Bool tmp_if_expr_8;
  if(chkipstr == ((char *)NULL))
  {
    logstr(65539, "applying grey_mask failed: %s", request->client_address);
    return -1;
  }

  else
  {
    snprintf(maskedtuple, (unsigned long int)1024, "%s %s %s", chkipstr, request->sender, request->recipient);
    digest=sha256_string(maskedtuple);
    querylog_entry = &final->querylog_entry;
    querylog_entry->sender = request->sender;
    querylog_entry->recipient = request->recipient;
    querylog_entry->helo = request->helo_name;
    querylog_entry->client_ip = request->client_address;
    logstr(65544, "checking ip=%s, net=%s", request->client_address, chkipstr);
    /* assertion chkipstr */
    assert(chkipstr != ((char *)NULL));
    free((void *)chkipstr);
    chkipstr = (char *)(void *)0;
    i = 0;
    for( ; !(ctx->checklist[(signed long int)i] == ((struct anonymous_42 *)NULL)); i = i + 1)
      ;
    checkcount = i;
    signed int return_value_is_in_ring_queue_5;
    return_value_is_in_ring_queue_5=is_in_ring_queue(ctx->filter, digest);
    if(!(return_value_is_in_ring_queue_5 == 0))
      tmp_if_expr_6 = ((ctx->config.flags & (signed int)0x0100) != 0 ? (_Bool)1 : (0 == checkcount ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
      retvalue = STATUS_MATCH;

    else
      if(checkcount == 0)
      {
        reasonstr=strdup(ctx->config.grey_reason);
        retvalue = STATUS_GREY;
      }

      else
      {
        if(ta == ((struct tmout_action_s *)NULL))
        {
          free_ta = 1;
          void *return_value_Malloc_1;
          return_value_Malloc_1=Malloc(sizeof(struct tmout_action_s) /*32ul*/ );
          ta = (struct tmout_action_s *)return_value_Malloc_1;
          ta->timeout = ctx->config.query_timelimit;
          ta->action = (void (*)(void *, signed int))(void *)0;
          ta->next = (struct tmout_action_s *)(void *)0;
          ta_default_reserved = ta;
        }

        edict=edict_get(0);
        edict->job = (void *)request;
        tap = ta;
        for( ; !(tap == ((struct tmout_action_s *)NULL)); tap = tap->next)
          edict->timelimit = edict->timelimit + tap->timeout;
        i = 0;
        definitives_running = 0;
        for( ; !(ctx->checklist[(signed long int)i] == ((struct anonymous_42 *)NULL)); i = i + 1)
        {
          request_reference(request);
          submit_job(ctx->checklist[(signed long int)i]->pool, edict);
          if(!(ctx->checklist[(signed long int)i]->definitive == 0))
            definitives_running = definitives_running + 1;

        }
        checks_running = i;
        judgment = (enum anonymous_0)J_UNDEFINED;
        definitive = 0;
        while(definitive == 0 && checks_running >= 1 && !(ta == ((struct tmout_action_s *)NULL)))
        {
          clock_gettime(1, &now);
          timeused=ms_diff(&now, &start);
          if(!(timeused >= ta->timeout))
          {
            unsigned long int return_value_get_msg_timed_2;
            return_value_get_msg_timed_2=get_msg_timed(edict->resultmq, (void *)&message, sizeof(void *) /*8ul*/ , 0, ta->timeout - timeused);
            ret = (signed int)return_value_get_msg_timed_2;
            if(ret >= 1)
            {
              result = (struct chkresult_s *)message.result;
              if(result == ((struct chkresult_s *)NULL))
              {
                logstr(65543, "NULL check result received (pool exhausted)");
                checks_running = checks_running - 1;
                request_unlink(request);
              }

              else
              {
                logstr(65544, "Received a check result, judgment = %d, weight = %d", result->judgment, result->weight);
                if(result->wait == 0)
                  checks_running = checks_running - 1;

                if(!((signed int)result->judgment >= (signed int)judgment))
                  tmp_if_expr_3 = (signed int)judgment;

                else
                  tmp_if_expr_3 = (signed int)result->judgment;
                judgment = (enum anonymous_0)tmp_if_expr_3;
                susp_weight = susp_weight + result->weight;
                if(!((signed int)result->judgment == J_UNDEFINED))
                  record_match(querylog_entry, result);

                if(!(result->definitive == 0))
                  definitives_running = definitives_running - 1;

                if(!(result->reason == ((char *)NULL)))
                {
                  reasonstr=strdup(result->reason);
                  /* assertion result->reason */
                  assert(result->reason != ((char *)NULL));
                  free((void *)result->reason);
                  result->reason = (char *)(void *)0;
                }

                /* assertion result */
                assert(result != ((struct chkresult_s *)NULL));
                free((void *)result);
                result = (struct chkresult_s *)(void *)0;
              }
              if((signed int)judgment == J_PASS)
                definitive = 1;

              else
                if(definitives_running == 0)
                {
                  if(susp_weight >= block_threshold && !(block_threshold == 0))
                    definitive = 1;

                  else
                    if(block_threshold == 0 && susp_weight >= grey_threshold)
                      definitive = 1;

                }

            }

          }

          else
            if(!(ta->action == ((void (*)(void *, signed int))NULL)))
            {
              ta->action(ta->arg, timeused);
              ta = ta->next;
            }

            else
              ta = ta->next;
        }
        edict->obsolete = 1;
        switch((signed int)judgment)
        {
          case J_PASS:
          {
            retvalue = STATUS_TRUST;
            break;
          }
          case J_BLOCK:
          {
            retvalue = STATUS_BLOCK;
            break;
          }
          case J_SUSPICIOUS:

          case J_UNDEFINED:
          {
            if(block_threshold >= 1 && susp_weight >= block_threshold)
            {
              retvalue = STATUS_BLOCK;
              reasonstr=strdup(ctx->config.block_reason);
            }

            else
              if(susp_weight >= grey_threshold)
              {
                signed int return_value_is_in_ring_queue_4;
                return_value_is_in_ring_queue_4=is_in_ring_queue(ctx->filter, digest);
                if(!(return_value_is_in_ring_queue_4 == 0))
                  retvalue = STATUS_MATCH;

                else
                {
                  reasonstr=strdup(ctx->config.grey_reason);
                  retvalue = STATUS_GREY;
                }
              }

              else
                retvalue = STATUS_TRUST;
            break;
          }
          default:
          {
            logstr(65539, "BUG: case default in switch (judgment)");
            retvalue = STATUS_TRUST;
          }
        }
        edict_unlink(edict);
      }
    querylog_entry->action = retvalue;
    if(!(free_ta == 0))
    {
      /* assertion ta_default_reserved */
      assert(ta_default_reserved != ((struct tmout_action_s *)NULL));
      free((void *)ta_default_reserved);
      ta_default_reserved = (struct tmout_action_s *)(void *)0;
    }

    if(retvalue == STATUS_GREY || retvalue == STATUS_MATCH)
      tmp_if_expr_8 = (_Bool)1;

    else
      tmp_if_expr_8 = (ctx->config.flags & (signed int)0x04) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_8)
    {
      update.mtype = (signed long int)1;
      memcpy((void *)update.mtext, (const void *)&digest, sizeof(struct anonymous_18) /*32ul*/ );
      ret=put_msg(ctx->update_q, (void *)&update, sizeof(struct anonymous_18) /*32ul*/ , 0);
      if(!(ret >= 0))
        perror("update put_msg");

      signed int return_value_connected_7;
      return_value_connected_7=connected(&ctx->config.peer);
      if(!(return_value_connected_7 == 0))
      {
        os.digest = digest;
        logstr(65544, "Sending oper sync");
        send_oper_sync(&ctx->config.peer, &os);
      }

    }

    if(!((0x10 & ctx->config.flags) == 0))
      retvalue = STATUS_TRUST;

    update_counters(retvalue);
    final->status = (enum anonymous_1)retvalue;
    if(!(reasonstr == ((char *)NULL)))
      final->reason = reasonstr;

    return 0;
  }
}

// thread_pool
// file thread_pool.c line 43
static void * thread_pool(void *arg)
{
  signed int ret;
  struct pool_ctx_s *pool_ctx = (struct pool_ctx_s *)(void *)0;
  struct edict_message_s message;
  struct edict_s *edict = (struct edict_s *)(void *)0;
  struct anonymous_32 thread_ctx = { .state=(void *)0, .cleanup=((signed int (*)())NULL), .watchdog={ .last_seen={ .tv_sec=0l, .tv_nsec=0l }, .tid=0ul,
    .next=((struct watchdog_s *)NULL) } };
  struct watchdog_s *dogp;
  signed int process;
  struct timespec now;
  signed int waited;
  signed int lastseenms;
  pool_ctx = (struct pool_ctx_s *)arg;
  /* assertion pool_ctx->mx */
  assert(pool_ctx->mx != ((union anonymous_27 *)NULL));
  /* assertion pool_ctx->routine */
  assert(pool_ctx->routine != ((signed int (*)(struct thread_pool_s *, struct anonymous_32 *, struct edict_s *))NULL));
  /* assertion pool_ctx->info */
  assert(pool_ctx->info != ((struct thread_pool_s *)NULL));
  pthread_mutex_lock(pool_ctx->mx);
  pool_ctx->count_thread = pool_ctx->count_thread + 1;
  if(!(pool_ctx->watchdog_time == 0))
  {
    dogp = pool_ctx->wdlist;
    pool_ctx->wdlist = &thread_ctx.watchdog;
    pool_ctx->wdlist->next = dogp;
    clock_gettime(1, &thread_ctx.watchdog.last_seen);
    thread_ctx.watchdog.tid=pthread_self();
  }

  clock_gettime(1, &pool_ctx->last_idle_check);
  pthread_mutex_unlock(pool_ctx->mx);
  logstr(65543, "threadpool '%s' thread #%d starting%s", pool_ctx->info->name, pool_ctx->count_thread, pool_ctx->watchdog_time != 0 ? " watchdog enabled" : "");
  _Bool tmp_if_expr_4;
  do
  {
    pthread_mutex_lock(pool_ctx->mx);
    if(!(pool_ctx->watchdog_time == 0))
      clock_gettime(1, &thread_ctx.watchdog.last_seen);

    clock_gettime(1, &now);
    waited=ms_diff(&now, &pool_ctx->last_idle_check);
    if(waited >= 1001)
    {
      clock_gettime(1, &pool_ctx->last_idle_check);
      if(!(pool_ctx->watchdog_time == 0))
      {
        dogp = pool_ctx->wdlist;
        for( ; !(dogp == ((struct watchdog_s *)NULL)); dogp = dogp->next)
        {
          lastseenms=ms_diff(&now, &dogp->last_seen);
          if(!(pool_ctx->watchdog_time >= lastseenms))
          {
            logstr(65540, "thread #%x of pool '%s' stuck, last seen %d ms ago.", (unsigned int)dogp->tid, pool_ctx->info->name, lastseenms);
            pthread_kill(dogp->tid, 14);
          }

        }
      }

      if(pool_ctx->count_thread >= 9)
      {
        if(pool_ctx->ewma_idle > (float)(pool_ctx->count_thread / 2))
        {
          pool_ctx->count_thread = pool_ctx->count_thread - 1;
          pool_ctx->ewma_idle = pool_ctx->ewma_idle - 1.000000f;
          if(!(pool_ctx->watchdog_time == 0))
          {
            dogp = pool_ctx->wdlist;
            unsigned long int return_value_pthread_self_2;
            return_value_pthread_self_2=pthread_self();
            if(dogp->tid == return_value_pthread_self_2)
              pool_ctx->wdlist = pool_ctx->wdlist->next;

            else
              while(!(dogp->next == ((struct watchdog_s *)NULL)))
              {
                unsigned long int return_value_pthread_self_1;
                return_value_pthread_self_1=pthread_self();
                if(dogp->next->tid == return_value_pthread_self_1)
                {
                  dogp->next = dogp->next->next;
                  break;
                }

                dogp = dogp->next;
              }
          }

          pthread_mutex_unlock(pool_ctx->mx);
          logstr(65543, "threadpool '%s' thread shutting down", pool_ctx->info->name);
          if(!(thread_ctx.cleanup == ((signed int (*)())NULL)))
            thread_ctx.cleanup(thread_ctx.state);

          pthread_exit((void *)0);
        }

      }

    }

    pool_ctx->ewma_idle = (float)(0.1 * (double)pool_ctx->count_idle + ((double)1 - 0.1) * (double)pool_ctx->ewma_idle);
    pool_ctx->count_idle = pool_ctx->count_idle + 1;
    pthread_mutex_unlock(pool_ctx->mx);
    unsigned long int return_value_get_msg_timed_3;
    return_value_get_msg_timed_3=get_msg_timed(pool_ctx->info->work_queue_id, (void *)&message, sizeof(struct edict_s *) /*8ul*/ , 0, (signed int)1000);
    ret = (signed int)return_value_get_msg_timed_3;
    pthread_mutex_lock(pool_ctx->mx);
    if(!(pool_ctx->watchdog_time == 0))
      clock_gettime(1, &thread_ctx.watchdog.last_seen);

    pool_ctx->count_idle = pool_ctx->count_idle - 1;
    pthread_mutex_unlock(pool_ctx->mx);
    process = 1;
    if(ret >= 1)
    {
      edict = message.edict;
      /* assertion edict->job */
      assert(edict->job != NULL);
      logstr(65543, "threadpool '%s' processing", pool_ctx->info->name);
      pthread_mutex_lock(pool_ctx->mx);
      if(!(pool_ctx->count_idle >= 1))
      {
        if(pool_ctx->max_thread >= pool_ctx->count_thread)
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = 0 == pool_ctx->max_thread ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_4)
        {
          logstr(65543, "threadpool '%s' starting another thread", pool_ctx->info->name);
          create_thread((struct anonymous_40 *)(void *)0, 1, thread_pool, (void *)pool_ctx);
        }

        else
        {
          logstr(65539, "threadpool '%s': maximum thread count (%d) reached", pool_ctx->info->name, pool_ctx->max_thread);
          process = 0;
        }
      }

      pthread_mutex_unlock(pool_ctx->mx);
      if(!(process == 0))
        pool_ctx->routine(pool_ctx->info, &thread_ctx, edict);

      else
        if(edict->resultmq >= 0)
          send_result(edict, (void *)0);

      edict_unlink(edict);
    }

    else
      logstr(65544, "threadpool '%s' idling", pool_ctx->info->name);
  }
  while((_Bool)1);
}

// tolerate_dnsbl
// file check_dnsbl.c line 84
signed int tolerate_dnsbl(struct dnsbl_s *dnsbl)
{
  if(!(dnsbl->tolerancecounter >= 5))
  {
    logstr(65542, "incrementing tolerance counter for dnsbl %s", dnsbl->name);
    dnsbl->tolerancecounter = dnsbl->tolerancecounter + 1;
  }

  return 0;
}

// trim
// file utils.c line 186
signed int trim(char **buf)
{
  char *end;
  unsigned long int return_value_strspn_1;
  return_value_strspn_1=strspn(*buf, " \t");
  *buf = *buf + (signed long int)return_value_strspn_1;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(*buf);
  end = (*buf + (signed long int)return_value_strlen_2) - (signed long int)1;
  char *tmp_post_3;
  for( ; (_Bool)1; *tmp_post_3 = (char)0)
  {
    if(!((signed int)*end == 32))
    {
      if(!((signed int)*end == 9))
        goto __CPROVER_DUMP_L3;

    }

    tmp_post_3 = end;
    end = end - 1l;
  }

__CPROVER_DUMP_L3:
  ;
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(*buf);
  return (signed int)return_value_strlen_4;
}

// trust_delay_update
// file ../include/stats.h line 65
double trust_delay_update(double d)
{
  pthread_mutex_lock(&ctx->stats.mx);
  if(ctx->stats.trust == 0ul)
  {
    ctx->stats.trust_avg_delay = d;
    logstr(65540, "Trust average updated before updating counters");
  }

  else
    ctx->stats.trust_avg_delay = (ctx->stats.trust_avg_delay * (double)(ctx->stats.trust - (unsigned long int)1) + d) / (double)ctx->stats.trust;
  if(ctx->stats.trust_max_delay < d)
    ctx->stats.trust_max_delay = d;

  pthread_mutex_unlock(&ctx->stats.mx);
  return ctx->stats.trust_avg_delay;
}

// try_available
// file msgqueue.c line 530
struct msgqueue_s * try_available(void)
{
  struct msg_s *msg;
  struct msgqueue_s *mq = (struct msgqueue_s *)(void *)0;
  msg=get_msg_raw(metaqueue, -1);
  if(!(msg == ((struct msg_s *)NULL)))
  {
    mq = (struct msgqueue_s *)msg->msgp;
    mq->active = 1;
    /* assertion msg */
    assert(msg != ((struct msg_s *)NULL));
    free((void *)msg);
    msg = (struct msg_s *)(void *)0;
  }

  return mq;
}

// try_match
// file worker.c line 517
char * try_match(const char *matcher, const char *matchee)
{
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(matcher);
  signed int return_value_strncmp_4;
  return_value_strncmp_4=strncmp(matcher, matchee, return_value_strlen_3);
  unsigned long int return_value_strlen_1;
  char *return_value_strdup_2;
  if(return_value_strncmp_4 == 0)
  {
    return_value_strlen_1=strlen(matcher);
    return_value_strdup_2=strdup(matchee + (signed long int)return_value_strlen_1);
    return return_value_strdup_2;
  }

  else
    return (char *)(void *)0;
}

// ts_diff
// file utils.c line 229
signed int ts_diff(struct timespec *diff, struct timespec *t1, struct timespec *t2)
{
  diff->tv_sec = t1->tv_sec - t2->tv_sec;
  diff->tv_nsec = t1->tv_nsec - t2->tv_nsec;
  if(!(diff->tv_nsec >= 0l))
  {
    diff->tv_nsec = diff->tv_nsec + (signed long int)(1000 * 1000 * 1000);
    diff->tv_sec = diff->tv_sec - 1l;
  }

  if(!(diff->tv_sec >= 0l))
    return -1;

  else
    return 0;
}

// ts_sum
// file utils.c line 215
signed int ts_sum(struct timespec *sum, struct timespec *t1, struct timespec *t2)
{
  sum->tv_sec = t1->tv_sec + t2->tv_sec;
  sum->tv_nsec = (t1->tv_nsec + t2->tv_nsec) % (signed long int)(1000 * 1000 * 1000);
  if((t1->tv_nsec + t2->tv_nsec) / 1000000000l >= 1l)
    sum->tv_sec = sum->tv_sec + 1l;

  return 0;
}

// tstotv
// file utils.c line 263
void tstotv(struct timespec *ts, struct timeval *tv)
{
  tv->tv_sec = ts->tv_sec;
  tv->tv_usec = ts->tv_nsec / (signed long int)1000;
}

// tvtots
// file utils.c line 256
void tvtots(struct timeval *tv, struct timespec *ts)
{
  ts->tv_sec = tv->tv_sec;
  ts->tv_nsec = tv->tv_usec * (signed long int)1000;
}

// unfold
// file worker_sjsms.c line 122
struct grey_tuple_s * unfold(struct anonymous_30 *request)
{
  struct grey_tuple_s *tuple;
  unsigned short int sender;
  unsigned short int recipient;
  unsigned short int client_address;
  unsigned short int helo_name;
  tuple=request_new();
  sender=ntohs(request->sender);
  recipient=ntohs(request->recipient);
  client_address=ntohs(request->client_address);
  helo_name = (unsigned short int)0;
  if((signed int)client_address >= 1024 || (signed int)helo_name >= 1024 || (signed int)recipient >= 1024 || (signed int)sender >= 1024)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 42;
    return (struct grey_tuple_s *)(void *)0;
  }

  tuple->sender=strdup(request->message + (signed long int)sender);
  tuple->recipient=strdup(request->message + (signed long int)recipient);
  tuple->client_address=strdup(request->message + (signed long int)client_address);
  tuple->helo_name=strdup("<unknown>");
  return tuple;
}

// update_counters
// file worker.c line 162
void update_counters(signed int status)
{
  switch(status)
  {
    case STATUS_BLOCK:
    {
      logstr(65544, "updating block counters", status);
      do
      {
        pthread_mutex_lock(&ctx->stats.mx);
        ctx->stats.block = ctx->stats.block + 1ul;
        pthread_mutex_unlock(&ctx->stats.mx);
      }
      while((_Bool)0);
      do
      {
        pthread_mutex_lock(&ctx->stats.mx);
        ctx->stats.all_block = ctx->stats.all_block + 1ul;
        pthread_mutex_unlock(&ctx->stats.mx);
      }
      while((_Bool)0);
      break;
    }
    case STATUS_MATCH:
    {
      logstr(65544, "updating match counters", status);
      do
      {
        pthread_mutex_lock(&ctx->stats.mx);
        ctx->stats.match = ctx->stats.match + 1ul;
        pthread_mutex_unlock(&ctx->stats.mx);
      }
      while((_Bool)0);
      do
      {
        pthread_mutex_lock(&ctx->stats.mx);
        ctx->stats.all_match = ctx->stats.all_match + 1ul;
        pthread_mutex_unlock(&ctx->stats.mx);
      }
      while((_Bool)0);
      break;
    }
    case STATUS_GREY:
    {
      logstr(65544, "updating grey counters", status);
      do
      {
        pthread_mutex_lock(&ctx->stats.mx);
        ctx->stats.greylist = ctx->stats.greylist + 1ul;
        pthread_mutex_unlock(&ctx->stats.mx);
      }
      while((_Bool)0);
      do
      {
        pthread_mutex_lock(&ctx->stats.mx);
        ctx->stats.all_greylist = ctx->stats.all_greylist + 1ul;
        pthread_mutex_unlock(&ctx->stats.mx);
      }
      while((_Bool)0);
      break;
    }
    case STATUS_TRUST:
    {
      logstr(65544, "updating trust counters", status);
      do
      {
        pthread_mutex_lock(&ctx->stats.mx);
        ctx->stats.trust = ctx->stats.trust + 1ul;
        pthread_mutex_unlock(&ctx->stats.mx);
      }
      while((_Bool)0);
      do
      {
        pthread_mutex_lock(&ctx->stats.mx);
        ctx->stats.all_trust = ctx->stats.all_trust + 1ul;
        pthread_mutex_unlock(&ctx->stats.mx);
      }
      while((_Bool)0);
    }
    default:
      ;
  }
}

// update_delay_stats
// file worker.c line 575
void update_delay_stats(struct querylog_entry_s *q)
{
  switch(q->action)
  {
    case STATUS_BLOCK:
    {
      block_delay_update((double)q->delay);
      break;
    }
    case STATUS_MATCH:
    {
      match_delay_update((double)q->delay);
      break;
    }
    case STATUS_GREY:
    {
      greylist_delay_update((double)q->delay);
      break;
    }
    case STATUS_TRUST:
      trust_delay_update((double)q->delay);
  }
}

// usage
// file gross.c line 524
void usage(void)
{
  printf("Usage: grossd [-CDdhnPpruV] [-f configfile]\n");
  printf("       -C\tcreate statefile and exit\n");
  printf("       -D\tEnable debug logging (insane verbosity with -DD)\n");
  printf("       -d\tRun grossd as a foreground process\n");
  printf("       -h\tPrint command usage and exit\n");
  printf("       -f\toverride default configfile\n");
  printf("       -n\tdry run: always send TRUST\n");
  printf("       -p file  write the process id in a pidfile\n");
  printf("       -P file  same as -p, but pid file must not exist\n");
  printf("       -r\tdisable replication\n");
  printf("       -u user  run gross as user\n");
  printf("       -V\tversion information\n");
  exit(1);
}

// walk_mmap_info
// file srvutils.c line 162
signed int walk_mmap_info(void)
{
  signed int i;
  unsigned long int offset = (unsigned long int)&ctx->mmap_info->brq[(signed long int)1] - (unsigned long int)ctx->mmap_info->brq->group;
  logstr(65543, "fixing bloom ring queue memory pointers, offset=%x", offset);
  void *return_value_new_address_1;
  return_value_new_address_1=new_address((void *)ctx->mmap_info->brq->group, offset);
  ctx->mmap_info->brq->group = (struct anonymous_23 *)return_value_new_address_1;
  void *return_value_new_address_2;
  return_value_new_address_2=new_address((void *)ctx->mmap_info->brq->aggregate, offset);
  ctx->mmap_info->brq->aggregate = (struct anonymous_24 *)return_value_new_address_2;
  void *return_value_new_address_3;
  return_value_new_address_3=new_address((void *)ctx->mmap_info->brq->aggregate->filter, offset);
  ctx->mmap_info->brq->aggregate->filter = (unsigned int *)return_value_new_address_3;
  void *return_value_new_address_4;
  return_value_new_address_4=new_address((void *)ctx->mmap_info->brq->group->filter_group, offset);
  ctx->mmap_info->brq->group->filter_group = (struct anonymous_24 **)return_value_new_address_4;
  i = 0;
  for( ; !((unsigned int)i >= ctx->mmap_info->brq->group->group_size); i = i + 1)
  {
    void *return_value_new_address_5;
    return_value_new_address_5=new_address((void *)ctx->mmap_info->brq->group->filter_group[(signed long int)i], offset);
    ctx->mmap_info->brq->group->filter_group[(signed long int)i] = (struct anonymous_24 *)return_value_new_address_5;
    void *return_value_new_address_6;
    return_value_new_address_6=new_address((void *)ctx->mmap_info->brq->group->filter_group[(signed long int)i]->filter, offset);
    ctx->mmap_info->brq->group->filter_group[(signed long int)i]->filter = (unsigned int *)return_value_new_address_6;
  }
  return 1;
}

// walk_queue
// file ../include/msgqueue.h line 65
signed int walk_queue(signed int msgid, signed int (*callback)(void *))
{
  struct msgqueue_s *mq;
  struct msg_s *msg;
  signed int ret;
  mq=queuebyid(msgid);
  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  if(mq->active == 0)
  {
    logstr(65539, "get_msg_raw: message queue is marked inactive");
    return -1;
  }

  else
  {
    if(!(mq->head == ((struct msg_s *)NULL)))
    {
      msg = mq->head;
      if(!(msg == ((struct msg_s *)NULL)))
      {
        logstr(65543, "walk_queue: calling callback function");
        ret=callback(msg->msgp);
        if(!(ret >= 0))
        {
          logstr(65539, "walk_queue: callback returned FAILURE");
          return -1;
        }

        msg = msg->next;
      }

    }

    if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
    {
      if(!(mq->delaypair->head == ((struct msg_s *)NULL)))
      {
        msg = mq->head;
        if(!(msg == ((struct msg_s *)NULL)))
        {
          logstr(65543, "walk_queue: calling callback function");
          ret=callback(msg->msgp);
          if(!(ret >= 0))
          {
            logstr(65539, "walk_queue: callback returned FAILURE");
            return -1;
          }

          msg = msg->next;
        }

      }

    }

    return 0;
  }
}

// worker_init
// file worker.c line 690
void worker_init()
{
  if(ctx->config.protocols == 0)
    logstr(65541, "No protocols configured");

  if(!((0x02 & ctx->config.protocols) == 0))
    postfix_server_init();

  if(!((0x01 & ctx->config.protocols) == 0))
    sjsms_server_init();

}

// writeline
// file utils.c line 143
signed long int writeline(signed int fd, const char *line)
{
  const char terminator[3l] = { '\r', '\n', 0 };
  signed long int return_value_writet_1;
  return_value_writet_1=writet(fd, line, terminator);
  return return_value_writet_1;
}

// writen
// file utils.c line 96
signed long int writen(signed int fd, const void *vptr, unsigned long int n)
{
  unsigned long int nleft;
  signed long int nwritten;
  const char *ptr = (const char *)vptr;
  nleft = n;
  for( ; nleft >= 1ul; ptr = ptr + nwritten)
  {
    nwritten=write(fd, (const void *)ptr, nleft);
    if(!(nwritten >= 1l))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        nwritten = (signed long int)0;

      else
        return (signed long int)-1;
    }

    nleft = nleft - (unsigned long int)nwritten;
  }
  return (signed long int)n;
}

// writet
// file utils.c line 121
signed long int writet(signed int fd, const char *line, const char *terminator)
{
  char *str;
  unsigned long int linelen;
  unsigned long int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(line);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(terminator);
  linelen = return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)1;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(linelen);
  str = (char *)return_value_malloc_3;
  if(str == ((char *)NULL))
  {
    perror("malloc");
    return (signed long int)-1;
  }

  else
  {
    snprintf(str, linelen, "%s%s", line, terminator);
    signed long int return_value_writen_4;
    return_value_writen_4=writen(fd, (const void *)str, linelen - (unsigned long int)1);
    len = (unsigned long int)return_value_writen_4;
    /* assertion str */
    assert(str != ((char *)NULL));
    free((void *)str);
    str = (char *)(void *)0;
    return (signed long int)len;
  }
}

// zero_bloom_filter
// file bloom.c line 211
void zero_bloom_filter(struct anonymous_24 *filter)
{
  /* assertion filter */
  assert(filter != ((struct anonymous_24 *)NULL));
  init_bit_array(filter->filter, filter->size);
}

// zero_bloom_ring_queue
// file bloom.c line 395
void zero_bloom_ring_queue(struct anonymous_22 *brq)
{
  unsigned int i;
  /* assertion brq */
  assert(brq != ((struct anonymous_22 *)NULL));
  zero_bloom_filter(brq->aggregate);
  i = (unsigned int)0;
  for( ; !(i >= brq->group->group_size); i = i + 1u)
    zero_bloom_filter(brq->group->filter_group[(signed long int)i]);
  brq->current_index = (unsigned int)0;
}

// zero_stats
// file stats.c line 40
struct anonymous_35 zero_stats()
{
  struct anonymous_35 old;
  pthread_mutex_lock(&ctx->stats.mx);
  old = ctx->stats;
  time(&old.end);
  ctx->stats.block = (unsigned long int)0;
  ctx->stats.greylist = (unsigned long int)0;
  ctx->stats.match = (unsigned long int)0;
  ctx->stats.trust = (unsigned long int)0;
  ctx->stats.block_avg_delay = 0.0;
  ctx->stats.greylist_avg_delay = 0.0;
  ctx->stats.match_avg_delay = 0.0;
  ctx->stats.trust_avg_delay = 0.0;
  time(&ctx->stats.begin);
  ctx->stats.end = (signed long int)0;
  pthread_mutex_unlock(&ctx->stats.mx);
  return old;
}

