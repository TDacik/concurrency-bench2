// #anon_enum_NULL_event=0_terminate_event=1_hello_event=2_ok_event=3_finished_event=4_publish_event=5_forward_event=6_ping_event=7_expired_event=8
// file src/zgossip_engine.inc line 34
enum anonymous_30 { NULL_event=0, terminate_event=1, hello_event=2, ok_event=3, finished_event=4, publish_event=5, forward_event=6, ping_event=7, expired_event=8 };

// #anon_enum_ZARMOUR_MODE_BASE64_STD=0_ZARMOUR_MODE_BASE64_URL=1_ZARMOUR_MODE_BASE32_STD=2_ZARMOUR_MODE_BASE32_HEX=3_ZARMOUR_MODE_BASE16=4_ZARMOUR_MODE_Z85=5
// file src/../include/zarmour.h line 24
enum anonymous_37 { ZARMOUR_MODE_BASE64_STD=0, ZARMOUR_MODE_BASE64_URL=1, ZARMOUR_MODE_BASE32_STD=2, ZARMOUR_MODE_BASE32_HEX=3, ZARMOUR_MODE_BASE16=4, ZARMOUR_MODE_Z85=5 };

// #anon_enum_ZDIR_PATCH_CREATE=1_ZDIR_PATCH_DELETE=2
// file src/../include/zdir_patch.h line 28
enum anonymous_6 { ZDIR_PATCH_CREATE=1, ZDIR_PATCH_DELETE=2 };

// #anon_enum_start_state=1_have_tuple_state=2_connected_state=3_external_state=4
// file src/zgossip_engine.inc line 27
enum anonymous_29 { start_state=1, have_tuple_state=2, connected_state=3, external_state=4 };

// ST[*{SYM#0={ST[*{SYM#0}_SYM#0_'next'|*{V}_V_'item'|*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'free_fn']}}_SYM#0_'head'|*{SYM#0}_SYM#0_'tail'|*{SYM#0}_SYM#0_'cursor'|U64'size'|B'autofree'|U56'_pad0'|*{S32(*{V}_V_|*{V}_V_)->S32}_S32(*{V}_V_|*{V}_V_)->S32_'compare_fn']
// file src/../include/czmq_library.h line 119
struct _zlist_t;

// ST[*{SYM#0={ST[*{SYM#0}_SYM#0_'next'|*{V}_V_'item'|*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'free_fn']}}_SYM#0_'next'|*{V}_V_'item'|*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'free_fn']
// file src/zlist.c line 30
struct _node_t_0;

// ST[*{V}_V_'value'|*{SYM#0={ST[*{V}_V_'value'|*{SYM#0}_SYM#0_'next'|U64'index'|*{S8}_S8_'key'|*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'free_fn']}}_SYM#0_'next'|U64'index'|*{S8}_S8_'key'|*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'free_fn']
// file src/zhash.c line 36
struct _item_t_0;

// ST[U64'size'|U64'limit'|*{*{SYM#0={ST[*{V}_V_'value'|*{SYM#0}_SYM#0_'next'|U64'index'|*{S8}_S8_'key'|*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'free_fn']}}_SYM#0_}_*{SYM#0}_SYM#0__'items'|U64'cached_index'|B'autofree'|U56'_pad0'|U64'cursor_index'|*{SYM#0}_SYM#0_'cursor_item'|*{cS8}_cS8_'cursor_key'|*{ST?}_ST?_'comments'|S64'modified'|*{S8}_S8_'filename']
// file src/../include/czmq_library.h line 117
struct _zhash_t;

// tag-#anon#ST[*{S8}_S8_'name'|*{S8}_S8_'address'|*{S8}_S8_'netmask'|*{S8}_S8_'broadcast']
// file src/ziflist.c line 29
struct anonymous_19;

// tag-#anon#ST[*{SYM#tag-_zctx_t#}_SYM#tag-_zctx_t#_'ctx'|*{V}_V_'pipe'|*{V}_V_'handler'|B'verbose'|U56'_pad0'|*{SYM#tag-_zhash_t#}_SYM#tag-_zhash_t#_'whitelist'|*{SYM#tag-_zhash_t#}_SYM#tag-_zhash_t#_'blacklist'|*{SYM#tag-_zhash_t#}_SYM#tag-_zhash_t#_'passwords'|*{SYM#tag-_zcertstore_t#}_SYM#tag-_zcertstore_t#_'certstore'|B'allow_any'|B'terminated'|U48'_pad1']
// file src/zauth_v2.c line 301
struct anonymous_23;

// tag-#anon#ST[*{SYM#tag-_zctx_t#}_SYM#tag-_zctx_t#_'ctx'|*{V}_V_'pipe'|*{V}_V_'socket'|*{S8}_S8_'endpoint'|B'verbose'|B'terminated'|U48'_pad0']
// file src/zmonitor_v2.c line 146
struct anonymous_39;

// tag-#anon#ST[*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'handler'|B'verbose'|U56'_pad0'|*{S8}_S8_'version'|*{S8}_S8_'sequence'|*{S8}_S8_'domain'|*{S8}_S8_'address'|*{S8}_S8_'identity'|*{S8}_S8_'mechanism'|*{S8}_S8_'username'|*{S8}_S8_'password'|*{S8}_S8_'client_key'|*{S8}_S8_'principal']
// file src/zauth.c line 183
struct anonymous_34;

// tag-#anon#ST[*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'pipe'|*{SYM#tag-_zpoller_t#}_SYM#tag-_zpoller_t#_'poller'|*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'frontend'|*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'backend'|*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'capture'|B'terminated'|B'verbose'|U48'_pad0']
// file src/zproxy.c line 30
struct anonymous_35;

// tag-#anon#ST[*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'pipe'|*{SYM#tag-_zpoller_t#}_SYM#tag-_zpoller_t#_'poller'|*{V}_V_'monitored'|*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'sink'|S32'events'|B'terminated'|B'verbose'|U16'_pad0']
// file src/zmonitor.c line 32
struct anonymous_25;

// tag-#anon#ST[*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'pipe'|*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'handler'|*{SYM#tag-_zhashx_t#}_SYM#tag-_zhashx_t#_'whitelist'|*{SYM#tag-_zhashx_t#}_SYM#tag-_zhashx_t#_'blacklist'|*{SYM#tag-_zhashx_t#}_SYM#tag-_zhashx_t#_'passwords'|*{SYM#tag-_zpoller_t#}_SYM#tag-_zpoller_t#_'poller'|*{SYM#tag-_zcertstore_t#}_SYM#tag-_zcertstore_t#_'certstore'|B'allow_any'|B'terminated'|B'verbose'|U40'_pad0']
// file src/zauth.c line 31
struct anonymous_26;

// tag-#anon#ST[*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'pipe'|S32'udpsock'|S32'port_nbr'|S32'interval'|U32'_pad0'|S64'ping_at'|*{SYM#tag-_zframe_t#}_SYM#tag-_zframe_t#_'transmit'|*{SYM#tag-_zframe_t#}_SYM#tag-_zframe_t#_'filter'|SYM#tag-sockaddr_in#'broadcast'|B'terminated'|B'verbose'|ARR1025{S8}_S8_'hostname'|U40'_pad1']
// file src/zbeacon.c line 37
struct anonymous_36;

// tag-#anon#ST[*{V(*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_|*{V}_V_)->V}_V(*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_|*{V}_V_)->V_'handler'|*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'pipe'|*{V}_V_'args']
// file src/zactor.c line 50
struct anonymous_22;

// tag-#anon#ST[*{V(*{V}_V_|*{SYM#tag-_zctx_t#}_SYM#tag-_zctx_t#_|*{V}_V_)->V}_V(*{V}_V_|*{SYM#tag-_zctx_t#}_SYM#tag-_zctx_t#_|*{V}_V_)->V_'attached'|*{*{V}_V_(*{V}_V_)->*{V}_V_}_*{V}_V_(*{V}_V_)->*{V}_V__'detached'|*{V}_V_'args'|*{SYM#tag-_zctx_t#}_SYM#tag-_zctx_t#_'ctx'|*{V}_V_'pipe']
// file src/zthread.c line 62
struct anonymous_21;

// tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 126
struct anonymous_13;

// tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 111
struct anonymous_10;

// tag-#anon#ST[*{V}_V_'handle'|S32'type'|U32'_pad0'|*{cS8}_cS8_'filename'|U64'line_nbr']
// file src/zsys.c line 87
struct anonymous_18;

// tag-#anon#ST[*{V}_V_'handler'|*{S8}_S8_'version'|*{S8}_S8_'sequence'|*{S8}_S8_'domain'|*{S8}_S8_'address'|*{S8}_S8_'identity'|*{S8}_S8_'mechanism'|*{S8}_S8_'username'|*{S8}_S8_'password'|*{S8}_S8_'client_key'|*{S8}_S8_'principal']
// file src/zauth_v2.c line 193
struct anonymous_24;

// tag-#anon#ST[*{V}_V_'pipe'|S32'udpsock'|S32'port_nbr'|S32'interval'|B'noecho'|B'terminated'|U16'_pad0'|S64'ping_at'|*{SYM#tag-_zframe_t#}_SYM#tag-_zframe_t#_'transmit'|*{SYM#tag-_zframe_t#}_SYM#tag-_zframe_t#_'filter'|SYM#tag-sockaddr_in#'address'|SYM#tag-sockaddr_in#'broadcast']
// file src/zbeacon_v2.c line 217
struct anonymous_27;

// tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_11;

// tag-#anon#ST[*{cS8}_cS8_'name'|S32'narg'|U32'_pad0'|*{cS8}_cS8_'flags']
// file src/foreign/slre/slre.inc_c line 26
struct anonymous_38;

// tag-#anon#ST[ARR16{U64}_U64_'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_2;

// tag-#anon#ST[S32'si_pid'|U32'si_uid']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_5;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_9;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_8;

// tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_15;

// tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_7;

// tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 119
struct anonymous_12;

// tag-#anon#ST[SYM#tag-_client_t#'client'|*{SYM#tag-#anon#ST[SYM#tag-_server_t#'server'|*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'pipe'|*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'router'|S32'port'|U32'_pad0'|*{SYM#tag-_zloop_t#}_SYM#tag-_zloop_t#_'loop'|*{SYM#tag-_zgossip_msg_t#}_SYM#tag-_zgossip_msg_t#_'message'|*{SYM#tag-_zhash_t#}_SYM#tag-_zhash_t#_'clients'|*{SYM#tag-_zconfig_t#}_SYM#tag-_zconfig_t#_'config'|U32'client_id'|U32'_pad1'|U64'timeout'|B'verbose'|U56'_pad2'|*{S8}_S8_'log_prefix']#}_SYM#tag-#anon#ST[SYM#tag-_server_t#'server'|*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'pipe'|*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'router'|S32'port'|U32'_pad0'|*{SYM#tag-_zloop_t#}_SYM#tag-_zloop_t#_'loop'|*{SYM#tag-_zgossip_msg_t#}_SYM#tag-_zgossip_msg_t#_'message'|*{SYM#tag-_zhash_t#}_SYM#tag-_zhash_t#_'clients'|*{SYM#tag-_zconfig_t#}_SYM#tag-_zconfig_t#_'config'|U32'client_id'|U32'_pad1'|U64'timeout'|B'verbose'|U56'_pad2'|*{S8}_S8_'log_prefix']#_'server'|*{S8}_S8_'hashkey'|*{SYM#tag-_zframe_t#}_SYM#tag-_zframe_t#_'routing_id'|U32'unique_id'|SYM##anon_enum_start_state=1_have_tuple_state=2_connected_state=3_external_state=4#'state'|SYM##anon_enum_NULL_event=0_terminate_event=1_hello_event=2_ok_event=3_finished_event=4_publish_event=5_forward_event=6_ping_event=7_expired_event=8#'event'|SYM##anon_enum_NULL_event=0_terminate_event=1_hello_event=2_ok_event=3_finished_event=4_publish_event=5_forward_event=6_ping_event=7_expired_event=8#'next_event'|SYM##anon_enum_NULL_event=0_terminate_event=1_hello_event=2_ok_event=3_finished_event=4_publish_event=5_forward_event=6_ping_event=7_expired_event=8#'exception'|S32'wakeup'|*{V}_V_'ticket'|SYM##anon_enum_NULL_event=0_terminate_event=1_hello_event=2_ok_event=3_finished_event=4_publish_event=5_forward_event=6_ping_event=7_expired_event=8#'wakeup_event'|ARR41{S8}_S8_'log_prefix'|U24'_pad0']
// file src/zgossip_engine.inc line 95
struct anonymous_31;

// tag-#anon#ST[SYM#tag-_server_t#'server'|*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'pipe'|*{SYM#tag-_zsock_t#}_SYM#tag-_zsock_t#_'router'|S32'port'|U32'_pad0'|*{SYM#tag-_zloop_t#}_SYM#tag-_zloop_t#_'loop'|*{SYM#tag-_zgossip_msg_t#}_SYM#tag-_zgossip_msg_t#_'message'|*{SYM#tag-_zhash_t#}_SYM#tag-_zhash_t#_'clients'|*{SYM#tag-_zconfig_t#}_SYM#tag-_zconfig_t#_'config'|U32'client_id'|U32'_pad1'|U64'timeout'|B'verbose'|U56'_pad2'|*{S8}_S8_'log_prefix']
// file src/zgossip_engine.inc line 74
struct anonymous_28;

// tag-#anon#UN[*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'ifu_broadaddr'|*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'ifu_dstaddr']
// file /usr/include/ifaddrs.h line 38
union anonymous_20;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'|*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}_SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}_SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#_|*{V}_V_)->V_'sa_sigaction']
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_17;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'|ARR8{U16}_U16_'__u6_addr16'|ARR4{U32}_U32_'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous_40;

// tag-#anon#UN[ARR20{U8}_U8_'b8'|ARR5{U32}_U32_'b32']
// file src/foreign/sha1/sha1.h line 43
union anonymous;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_14;

// tag-#anon#UN[ARR4{S8}_S8_'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_4;

// tag-#anon#UN[ARR64{U8}_U8_'b8'|ARR16{U32}_U32_'b32']
// file src/foreign/sha1/sha1.h line 53
union anonymous_1;

// tag-#anon#UN[ARR8{U8}_U8_'b8'|ARR1{U64}_U64_'b64']
// file src/foreign/sha1/sha1.h line 48
union anonymous_0;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_3;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_16;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_33;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_client_t
// file src/zgossip.c line 100
struct _client_t;

// tag-_item_t
// file src/zhashx.c line 42
struct _item_t;

// tag-_node_t
// file src/zlistx.c line 33
struct _node_t;

// tag-_s_poller_t
// file src/zloop.c line 27
struct _s_poller_t;

// tag-_s_reader_t
// file src/zloop.c line 26
struct _s_reader_t;

// tag-_s_ticket_t
// file src/zloop.c line 29
struct _s_ticket_t;

// tag-_s_timer_t
// file src/zloop.c line 28
struct _s_timer_t;

// tag-_server_t
// file src/zgossip.c line 99
struct _server_t;

// tag-_tuple_t
// file src/zgossip.c line 101
struct _tuple_t;

// tag-_zactor_t
// file src/../include/czmq_library.h line 53
struct _zactor_t;

// tag-_zarmour_t
// file src/../include/czmq_library.h line 57
struct _zarmour_t;

// tag-_zauth_t
// file src/../include/czmq_library.h line 55
struct _zauth_t;

// tag-_zbeacon_t
// file src/../include/czmq_library.h line 59
struct _zbeacon_t;

// tag-_zcert_t
// file src/../include/czmq_library.h line 61
struct _zcert_t;

// tag-_zcertstore_t
// file src/../include/czmq_library.h line 63
struct _zcertstore_t;

// tag-_zchunk_t
// file src/../include/czmq_library.h line 65
struct _zchunk_t;

// tag-_zconfig_t
// file src/../include/czmq_library.h line 69
struct _zconfig_t;

// tag-_zctx_t
// file src/../include/czmq_library.h line 115
struct _zctx_t;

// tag-_zdigest_t
// file src/../include/czmq_library.h line 71
struct _zdigest_t;

// tag-_zdir_patch_t
// file src/../include/czmq_library.h line 75
struct _zdir_patch_t;

// tag-_zdir_t
// file src/../include/czmq_library.h line 73
struct _zdir_t;

// tag-_zdir_watch_sub_t
// file src/zdir.c line 658
struct _zdir_watch_sub_t;

// tag-_zdir_watch_t
// file src/zdir.c line 649
struct _zdir_watch_t;

// tag-_zfile_t
// file src/../include/czmq_library.h line 77
struct _zfile_t;

// tag-_zframe_t
// file src/../include/czmq_library.h line 79
struct _zframe_t;

// tag-_zgossip_msg_t
// file src/./zgossip_msg.h line 66
struct _zgossip_msg_t;

// tag-_zhash_t
// file src/../include/czmq_library.h line 117
struct _zhash_t;

// tag-_zhashx_t
// file src/../include/czmq_library.h line 83
struct _zhashx_t;

// tag-_ziflist_t
// file src/../include/czmq_library.h line 85
struct _ziflist_t;

// tag-_zlist_t
// file src/../include/czmq_library.h line 119
struct _zlist_t;

// tag-_zlistx_t
// file src/../include/czmq_library.h line 87
struct _zlistx_t;

// tag-_zloop_t
// file src/../include/czmq_library.h line 89
struct _zloop_t;

// tag-_zmonitor_t
// file src/../include/czmq_library.h line 91
struct _zmonitor_t;

// tag-_zmsg_t
// file src/../include/czmq_library.h line 93
struct _zmsg_t;

// tag-_zmutex_t
// file src/../include/czmq_library.h line 123
struct _zmutex_t;

// tag-_zpoller_t
// file src/../include/czmq_library.h line 95
struct _zpoller_t;

// tag-_zproxy_t
// file src/../include/czmq_library.h line 97
struct _zproxy_t;

// tag-_zrex_t
// file src/../include/czmq_library.h line 99
struct _zrex_t;

// tag-_zsock_t
// file src/../include/czmq_library.h line 101
struct _zsock_t;

// tag-_zuuid_t
// file src/../include/czmq_library.h line 109
struct _zuuid_t;

// tag-cap
// file src/foreign/slre/slre.h line 68
struct cap;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-ifaddrs
// file /usr/include/ifaddrs.h line 29
struct ifaddrs;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sha1_ctxt
// file src/foreign/sha1/sha1.h line 41
struct sha1_ctxt;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-slre
// file src/foreign/slre/slre.h line 55
struct slre;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 153
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-zmq_msg_t
// file /usr/include/zmq.h line 198
struct zmq_msg_t;

// tag-zmq_pollitem_t
// file /usr/include/zmq.h line 367
struct zmq_pollitem_t;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef FENCE
#define FENCE(x) ((void)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __sync_add_and_fetch
// file gcc_builtin_headers_generic.h line 99
signed int __sync_add_and_fetch();
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// anyof
// file src/foreign/slre/slre.inc_c line 223
static void anyof(struct slre *r, const char **re);
// assert_status
// file src/test_zgossip.c line 4
void assert_status(struct _zactor_t *actor, signed int count);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// atoll
// file /usr/include/stdlib.h line 157
extern signed long long int atoll(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous_33, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 500
extern signed int chdir(const char *);
// client_initialize
// file src/zgossip.c line 309
static signed int client_initialize(struct _client_t *self);
// client_terminate
// file src/zgossip.c line 318
static void client_terminate(struct _client_t *self);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// compile
// file src/foreign/slre/slre.inc_c line 299
static void compile(struct slre *r, const char **re);
// dup
// file /usr/include/unistd.h line 534
extern signed int dup(signed int);
// echo_actor
// file src/zactor.c line 247
static void echo_actor(struct _zsock_t *pipe, void *args);
// emit
// file src/foreign/slre/slre.inc_c line 169
static void emit(struct slre *r, signed int code);
// engine_broadcast_event
// file src/zgossip_engine.inc line 200
static void engine_broadcast_event(struct _server_t *server, struct _client_t *client, enum anonymous_30 event);
// engine_configure
// file src/zgossip_engine.inc line 271
static void engine_configure(struct _server_t *server, const char *path, const char *value);
// engine_handle_socket
// file src/zgossip_engine.inc line 221
static void engine_handle_socket(struct _server_t *server, void *sock, signed int (*handler)(struct _zloop_t *, struct _zsock_t *, void *));
// engine_handle_socket::handler_object
//
signed int handler_object(struct _zloop_t *, struct _zsock_t *, void *);
// engine_send_event
// file src/zgossip_engine.inc line 187
static void engine_send_event(struct _client_t *client, enum anonymous_30 event);
// engine_set_exception
// file src/zgossip_engine.inc line 156
static void engine_set_exception(struct _client_t *client, enum anonymous_30 event);
// engine_set_log_prefix
// file src/zgossip_engine.inc line 257
static void engine_set_log_prefix(struct _client_t *client, const char *string);
// engine_set_monitor
// file src/zgossip_engine.inc line 244
static void engine_set_monitor(struct _server_t *server, unsigned long int interval, signed int (*monitor)(struct _zloop_t *, signed int, void *));
// engine_set_monitor::monitor_object
//
signed int monitor_object(struct _zloop_t *, signed int, void *);
// engine_set_next_event
// file src/zgossip_engine.inc line 144
static void engine_set_next_event(struct _client_t *client, enum anonymous_30 event);
// engine_set_wakeup_event
// file src/zgossip_engine.inc line 169
static void engine_set_wakeup_event(struct _client_t *client, unsigned long int delay, enum anonymous_30 event);
// engine_verbose
// file src/zgossip_engine.inc line 282
static _Bool engine_verbose(struct _server_t *server);
// exact
// file src/foreign/slre/slre.inc_c line 187
static void exact(struct slre *r, const char **re);
// exact_one_char
// file src/foreign/slre/slre.inc_c line 281
static void exact_one_char(struct slre *r, signed int ch);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 146
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fixup_branch
// file src/foreign/slre/slre.inc_c line 290
static void fixup_branch(struct slre *r, signed int fixup);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 759
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeifaddrs
// file /usr/include/ifaddrs.h line 69
extern void freeifaddrs(struct ifaddrs *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_escape_char
// file src/foreign/slre/slre.inc_c line 200
static signed int get_escape_char(const char **re);
// get_first_tuple
// file src/zgossip.c line 329
static void get_first_tuple(struct _client_t *self);
// get_next_tuple
// file src/zgossip.c line 347
static void get_next_tuple(struct _client_t *self);
// get_tuple_to_forward
// file src/zgossip.c line 378
static void get_tuple_to_forward(struct _client_t *self);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 681
extern unsigned int geteuid(void);
// getgrnam
// file /usr/include/grp.h line 108
extern struct group * getgrnam(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// gethostname
// file /usr/include/unistd.h line 882
extern signed int gethostname(char *, unsigned long int);
// getifaddrs
// file /usr/include/ifaddrs.h line 66
extern signed int getifaddrs(struct ifaddrs **);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getpid
// file /usr/include/unistd.h line 631
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 678
extern unsigned int getuid(void);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// is_any_but
// file src/foreign/slre/slre.inc_c line 457
static signed int is_any_but(const unsigned char *p, signed int len, const char *s, unsigned long int *ofs);
// is_any_of
// file src/foreign/slre/slre.inc_c line 441
static signed int is_any_of(const unsigned char *p, signed int len, const char *s, unsigned long int *ofs);
// isalnum
// file /usr/include/ctype.h line 110
extern signed int isalnum(signed int);
// isalpha
// file /usr/include/ctype.h line 111
extern signed int isalpha(signed int);
// isdigit
// file /usr/include/ctype.h line 113
extern signed int isdigit(signed int);
// isprint
// file /usr/include/ctype.h line 116
extern signed int isprint(signed int);
// isspace
// file /usr/include/ctype.h line 118
extern signed int isspace(signed int);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// loop_greedy
// file src/foreign/slre/slre.inc_c line 410
static void loop_greedy(struct slre *r, signed int pc, const char *s, unsigned long int len, unsigned long int *ofs);
// loop_non_greedy
// file src/foreign/slre/slre.inc_c line 427
static void loop_non_greedy(struct slre *r, signed int pc, const char *s, unsigned long int len, unsigned long int *ofs);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// match
// file src/foreign/slre/slre.inc_c line 472
static signed int match(struct slre *r, signed int pc, const char *s, unsigned long int len, unsigned long int *ofs, struct cap *caps);
// memchr
// file /usr/include/string.h line 92
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 65
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 46
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// open
// file /usr/include/fcntl.h line 156
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// pathconf
// file /usr/include/unistd.h line 615
extern signed long int pathconf(const char *, signed int);
// print_character_set
// file src/foreign/slre/slre.inc_c line 90
static void print_character_set(struct _IO_FILE *fp, const unsigned char *p, signed int len);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 271
extern signed int pthread_detach(unsigned long int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 754
extern signed int pthread_mutex_destroy(union anonymous_3 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 749
extern signed int pthread_mutex_init(union anonymous_3 *, const union anonymous_4 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous_3 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 758
extern signed int pthread_mutex_trylock(union anonymous_3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous_3 *);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// quantifier
// file src/foreign/slre/slre.inc_c line 266
static void quantifier(struct slre *r, signed int prev, signed int op);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// read
// file /usr/include/unistd.h line 363
extern signed long int read(signed int, void *, unsigned long int);
// readdir_r
// file /usr/include/dirent.h line 183
extern signed int readdir_r(struct __dirstream *, struct dirent *, struct dirent ** restrict );
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, union anonymous_33, unsigned int *);
// relocate
// file src/foreign/slre/slre.inc_c line 258
static void relocate(struct slre *r, signed int begin, signed int shift);
// remote_handler
// file src/zgossip.c line 393
static signed int remote_handler(struct _zloop_t *loop, struct _zsock_t *remote, void *argument);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// rmdir
// file /usr/include/unistd.h line 838
extern signed int rmdir(const char *);
// s_agent_authenticate
// file src/zauth_v2.c line 455
static signed int s_agent_authenticate(struct anonymous_23 *self);
// s_agent_destroy
// file src/zauth_v2.c line 315
static void s_agent_destroy(struct anonymous_23 **self_p);
// s_agent_destroy_link1
// file src/zbeacon_v2.c line 478
static void s_agent_destroy_link1(struct anonymous_27 **self_p_link1);
// s_agent_destroy_link2
// file src/zmonitor_v2.c line 201
static void s_agent_destroy_link2(struct anonymous_39 **self_p_link2);
// s_agent_handle_pipe
// file src/zauth_v2.c line 362
static signed int s_agent_handle_pipe(struct anonymous_23 *self);
// s_agent_new
// file src/zauth_v2.c line 332
static struct anonymous_23 * s_agent_new(struct _zctx_t *ctx, void *pipe);
// s_agent_new_link1
// file src/zbeacon_v2.c line 294
static struct anonymous_27 * s_agent_new_link1(void *pipe_link1, signed int port_nbr);
// s_agent_new_link2
// file src/zmonitor_v2.c line 217
static struct anonymous_39 * s_agent_new_link2(struct _zctx_t *ctx_link1, void *pipe_link2, char *endpoint);
// s_agent_task
// file src/zauth_v2.c line 583
static void s_agent_task(void *args, struct _zctx_t *ctx, void *pipe);
// s_agent_task_link1
// file src/zbeacon_v2.c line 248
static void s_agent_task_link1(void *args_link1, struct _zctx_t *ctx_link1, void *pipe_link1);
// s_agent_task_link2
// file src/zmonitor_v2.c line 170
static void s_agent_task_link2(void *args_link2, struct _zctx_t *ctx_link2, void *pipe_link2);
// s_api_command
// file src/zbeacon_v2.c line 393
static void s_api_command(struct anonymous_27 *self);
// s_api_command_link1
// file src/zmonitor_v2.c line 245
static void s_api_command_link1(struct anonymous_39 *self_link1);
// s_armour_decode
// file src/zarmour.c line 662
static void s_armour_decode(struct _zarmour_t *self, const char *test_string, const char *expected_result, _Bool verbose);
// s_armour_test
// file src/zarmour.c line 636
static void s_armour_test(struct _zarmour_t *self, const char *test_string, const char *expected_result, _Bool verbose);
// s_armour_test_long
// file src/zarmour.c line 680
static void s_armour_test_long(struct _zarmour_t *self, unsigned char *test_data, unsigned long int length, _Bool verbose);
// s_assert_event
// file src/zmonitor.c line 312
static void s_assert_event(struct _zactor_t *self, char *expected);
// s_authenticate_curve
// file src/zauth.c line 323
static _Bool s_authenticate_curve(struct anonymous_26 *self, struct anonymous_34 *request);
// s_authenticate_curve_link1
// file src/zauth_v2.c line 550
static _Bool s_authenticate_curve_link1(struct anonymous_23 *self_link1, struct anonymous_24 *request_link1);
// s_authenticate_gssapi
// file src/zauth.c line 346
static _Bool s_authenticate_gssapi(struct anonymous_26 *self, struct anonymous_34 *request);
// s_authenticate_gssapi_link1
// file src/zauth_v2.c line 573
static _Bool s_authenticate_gssapi_link1(struct anonymous_23 *self_link1, struct anonymous_24 *request_link1);
// s_authenticate_plain
// file src/zauth.c line 296
static _Bool s_authenticate_plain(struct anonymous_26 *self, struct anonymous_34 *request);
// s_authenticate_plain_link1
// file src/zauth_v2.c line 523
static _Bool s_authenticate_plain_link1(struct anonymous_23 *self_link1, struct anonymous_24 *request_link1);
// s_base16_decode
// file src/zarmour.c line 375
static unsigned char * s_base16_decode(const char *data, unsigned long int *size, const char *alphabet, unsigned long int linebreakchars);
// s_base16_encode
// file src/zarmour.c line 358
static char * s_base16_encode(const unsigned char *data, unsigned long int length, const char *alphabet);
// s_base32_decode
// file src/zarmour.c line 305
static unsigned char * s_base32_decode(const char *data, unsigned long int *size, const char *alphabet, unsigned long int linebreakchars);
// s_base32_encode
// file src/zarmour.c line 253
static char * s_base32_encode(const unsigned char *data, unsigned long int length, const char *alphabet, _Bool pad, char pad_char);
// s_base64_decode
// file src/zarmour.c line 212
static unsigned char * s_base64_decode(const char *data, unsigned long int *size, const char *alphabet, unsigned long int linebreakchars);
// s_base64_encode
// file src/zarmour.c line 178
static char * s_base64_encode(const unsigned char *data, unsigned long int length, const char *alphabet, _Bool pad, char pad_char);
// s_beacon_recv
// file src/zbeacon_v2.c line 438
static void s_beacon_recv(struct anonymous_27 *self);
// s_bernstein_hash
// file src/zhashx.c line 89
static unsigned long int s_bernstein_hash(const void *key);
// s_can_connect
// file src/zauth.c line 458
static _Bool s_can_connect(struct _zsock_t **server, struct _zsock_t **client);
// s_can_connect_link1
// file src/zauth_v2.c line 612
static _Bool s_can_connect_link1(struct _zctx_t *ctx, void **server_link1, void **client_link1);
// s_cancel_timer_event
// file src/zloop.c line 877
static signed int s_cancel_timer_event(struct _zloop_t *loop, signed int timer_id, void *arg);
// s_check_event
// file src/zmonitor_v2.c line 333
static _Bool s_check_event(struct _zmonitor_t *self, signed int expected_event);
// s_client_destroy
// file src/zgossip_engine.inc line 365
static void s_client_destroy(struct anonymous_31 **self_p);
// s_client_execute
// file src/zgossip_engine.inc line 396
static void s_client_execute(struct anonymous_31 *self, enum anonymous_30 event);
// s_client_free
// file src/zgossip_engine.inc line 386
static void s_client_free(void *argument);
// s_client_handle_ticket
// file src/zgossip_engine.inc line 632
static signed int s_client_handle_ticket(struct _zloop_t *loop, signed int timer_id, void *argument);
// s_client_handle_wakeup
// file src/zgossip_engine.inc line 643
static signed int s_client_handle_wakeup(struct _zloop_t *loop, signed int timer_id, void *argument);
// s_client_new
// file src/zgossip_engine.inc line 339
static struct anonymous_31 * s_client_new(struct anonymous_28 *server, struct _zframe_t *routing_id);
// s_collect_level
// file src/zconfig.c line 683
static signed int s_collect_level(char **start, signed int lineno);
// s_collect_name
// file src/zconfig.c line 717
static char * s_collect_name(char **start, signed int lineno);
// s_collect_value
// file src/zconfig.c line 764
static char * s_collect_value(char **start, signed int lineno);
// s_comparator
// file src/zlistx.c line 93
static signed int s_comparator(const void *item1, const void *item2);
// s_compare
// file src/zlist.c line 487
static signed int s_compare(void *item1, void *item2);
// s_config_execute
// file src/zconfig.c line 365
static signed int s_config_execute(struct _zconfig_t *self, signed int (*handler)(struct _zconfig_t *, void *, signed int), void *arg, signed int level);
// s_config_execute::handler_object
//
signed int handler_object(struct _zconfig_t *, void *, signed int);
// s_config_printf
// file src/zconfig.c line 450
static signed int s_config_printf(struct _zconfig_t *self, void *arg, char *format, ...);
// s_config_save
// file src/zconfig.c line 475
static signed int s_config_save(struct _zconfig_t *self, void *arg, signed int level);
// s_create_socket
// file src/zproxy.c line 70
static struct _zsock_t * s_create_socket(char *type_name, char *endpoints);
// s_dir_compare
// file src/zdir.c line 359
static signed int s_dir_compare(void *item1, void *item2);
// s_dir_flatten
// file src/zdir.c line 337
static signed int s_dir_flatten(struct _zdir_t *self, struct _zfile_t **files, signed int index);
// s_file_compare
// file src/zdir.c line 371
static signed int s_file_compare(void *item1, void *item2);
// s_get_interface
// file src/zbeacon_v2.c line 352
static void s_get_interface(struct anonymous_27 *self);
// s_interface_destroy
// file src/ziflist.c line 41
static void s_interface_destroy(struct anonymous_19 **self_p);
// s_interface_new
// file src/ziflist.c line 60
static struct anonymous_19 * s_interface_new(char *name, struct sockaddr_in address, struct sockaddr_in netmask, struct sockaddr_in broadcast);
// s_is_namechar
// file src/zconfig.c line 703
static _Bool s_is_namechar(char thischar);
// s_item_destroy
// file src/zhashx.c line 171
static void s_item_destroy(struct _zhashx_t *self, struct _item_t *item, _Bool hard);
// s_item_destroy_link1
// file src/zhash.c line 121
static void s_item_destroy_link1(struct _zhash_t *self_link1, struct _item_t_0 *item_link1, _Bool hard_link1);
// s_item_hash
// file src/zhash.c line 199
static unsigned int s_item_hash(const char *key, unsigned long int limit);
// s_item_insert
// file src/zhashx.c line 274
static struct _item_t * s_item_insert(struct _zhashx_t *self, const void *key, void *value);
// s_item_insert_link1
// file src/zhash.c line 216
static struct _item_t_0 * s_item_insert_link1(struct _zhash_t *self_link1, const char *key_link1, void *value_link1);
// s_item_lookup
// file src/zhashx.c line 317
static struct _item_t * s_item_lookup(struct _zhashx_t *self, const void *key);
// s_item_lookup_link1
// file src/zhash.c line 249
static struct _item_t_0 * s_item_lookup_link1(struct _zhash_t *self_link1, const char *key_link1);
// s_load_certs_from_disk
// file src/zcertstore.c line 93
static void s_load_certs_from_disk(struct _zcertstore_t *self);
// s_log
// file src/zsys.c line 1431
static void s_log(char loglevel, char *string);
// s_next_timer_id
// file src/zloop.c line 97
static signed int s_next_timer_id(struct _zloop_t *self);
// s_node_new
// file src/zlistx.c line 60
static struct _node_t * s_node_new(void *item);
// s_node_relink
// file src/zlistx.c line 80
static void s_node_relink(struct _node_t *node, struct _node_t *prev, struct _node_t *next);
// s_on_command
// file src/zdir.c line 822
static signed int s_on_command(struct _zloop_t *loop, struct _zsock_t *reader, void *arg);
// s_on_read_timer
// file src/zdir.c line 663
static signed int s_on_read_timer(struct _zloop_t *loop, signed int timer_id, void *arg);
// s_poller_destroy
// file src/zloop.c line 140
static void s_poller_destroy(struct _s_poller_t **self_p);
// s_poller_new
// file src/zloop.c line 127
static struct _s_poller_t * s_poller_new(struct zmq_pollitem_t *item, signed int (*handler)(struct _zloop_t *, struct zmq_pollitem_t *, void *), void *arg);
// s_poller_new::handler_object
//
signed int handler_object(struct _zloop_t *, struct zmq_pollitem_t *, void *);
// s_posix_populate_entry
// file src/zdir.c line 73
static void s_posix_populate_entry(struct _zdir_t *self, struct dirent *entry);
// s_protocol_event
// file src/zgossip_engine.inc line 315
static enum anonymous_30 s_protocol_event(struct _zgossip_msg_t *message);
// s_proxy_task
// file src/zproxy_v2.c line 136
static void s_proxy_task(void *args, struct _zctx_t *ctx, void *command_pipe);
// s_purge
// file src/zhashx.c line 128
static void s_purge(struct _zhashx_t *self);
// s_reader_destroy
// file src/zloop.c line 116
static void s_reader_destroy(struct _s_reader_t **self_p);
// s_reader_new
// file src/zloop.c line 103
static struct _s_reader_t * s_reader_new(struct _zsock_t *sock, signed int (*handler)(struct _zloop_t *, struct _zsock_t *, void *), void *arg);
// s_reader_new::handler_object
//
signed int handler_object(struct _zloop_t *, struct _zsock_t *, void *);
// s_rebuild_poll_set
// file src/zpoller.c line 166
static signed int s_rebuild_poll_set(struct _zpoller_t *self);
// s_rebuild_pollset
// file src/zloop.c line 248
static signed int s_rebuild_pollset(struct _zloop_t *self);
// s_satisfy_pedantic_compilers
// file src/zgossip_engine.inc line 295
static void s_satisfy_pedantic_compilers(void);
// s_save_metadata_all
// file src/zcert.c line 255
static void s_save_metadata_all(struct _zcert_t *self);
// s_self_authenticate
// file src/zauth.c line 356
static signed int s_self_authenticate(struct anonymous_26 *self);
// s_self_configure
// file src/zbeacon.c line 157
static void s_self_configure(struct anonymous_36 *self, signed int port_nbr);
// s_self_configure_link1
// file src/zproxy.c line 97
static void s_self_configure_link1(struct anonymous_35 *self_link1, struct _zsock_t **sock_p, struct _zmsg_t *request, char *name);
// s_self_destroy
// file src/zauth.c line 45
static void s_self_destroy(struct anonymous_26 **self_p);
// s_self_destroy_link1
// file src/zbeacon.c line 52
static void s_self_destroy_link1(struct anonymous_36 **self_p_link1);
// s_self_destroy_link2
// file src/zmonitor.c line 43
static void s_self_destroy_link2(struct anonymous_25 **self_p_link2);
// s_self_destroy_link3
// file src/zproxy.c line 41
static void s_self_destroy_link3(struct anonymous_35 **self_p_link3);
// s_self_handle_pipe
// file src/zauth.c line 93
static signed int s_self_handle_pipe(struct anonymous_26 *self);
// s_self_handle_pipe_link1
// file src/zbeacon.c line 172
static signed int s_self_handle_pipe_link1(struct anonymous_36 *self_link1);
// s_self_handle_pipe_link2
// file src/zmonitor.c line 151
static signed int s_self_handle_pipe_link2(struct anonymous_25 *self_link2);
// s_self_handle_pipe_link3
// file src/zproxy.c line 118
static signed int s_self_handle_pipe_link3(struct anonymous_35 *self_link3);
// s_self_handle_sink
// file src/zmonitor.c line 200
static void s_self_handle_sink(struct anonymous_25 *self);
// s_self_handle_udp
// file src/zbeacon.c line 229
static void s_self_handle_udp(struct anonymous_36 *self);
// s_self_listen
// file src/zmonitor.c line 78
static void s_self_listen(struct anonymous_25 *self, const char *event);
// s_self_new
// file src/zauth.c line 65
static struct anonymous_26 * s_self_new(struct _zsock_t *pipe);
// s_self_new_link1
// file src/zbeacon.c line 66
static struct anonymous_36 * s_self_new_link1(struct _zsock_t *pipe_link1);
// s_self_new_link2
// file src/zmonitor.c line 59
static struct anonymous_25 * s_self_new_link2(struct _zsock_t *pipe_link2, void *sock);
// s_self_new_link3
// file src/zproxy.c line 56
static struct anonymous_35 * s_self_new_link3(struct _zsock_t *pipe_link3);
// s_self_prepare_udp
// file src/zbeacon.c line 80
static void s_self_prepare_udp(struct anonymous_36 *self);
// s_self_start
// file src/zmonitor.c line 128
static void s_self_start(struct anonymous_25 *self);
// s_self_switch
// file src/zproxy.c line 188
static void s_self_switch(struct anonymous_35 *self, struct _zsock_t *input, struct _zsock_t *output);
// s_send_string
// file src/zstr.c line 36
static signed int s_send_string(void *dest, _Bool more, char *string);
// s_server_config_global
// file src/zgossip_engine.inc line 654
static void s_server_config_global(struct anonymous_28 *self);
// s_server_config_service
// file src/zgossip_engine.inc line 731
static void s_server_config_service(struct anonymous_28 *self);
// s_server_destroy
// file src/zgossip_engine.inc line 708
static void s_server_destroy(struct anonymous_28 **self_p);
// s_server_handle_pipe
// file src/zgossip_engine.inc line 774
static signed int s_server_handle_pipe(struct _zloop_t *loop, struct _zsock_t *reader, void *argument);
// s_server_handle_protocol
// file src/zgossip_engine.inc line 857
static signed int s_server_handle_protocol(struct _zloop_t *loop, struct _zsock_t *reader, void *argument);
// s_server_new
// file src/zgossip_engine.inc line 676
static struct anonymous_28 * s_server_new(struct _zsock_t *pipe);
// s_signal_handler
// file src/zsys.c line 493
static void s_signal_handler(signed int signal_value);
// s_socket_event
// file src/zloop.c line 893
static signed int s_socket_event(struct _zloop_t *loop, struct _zsock_t *handle, void *arg);
// s_socket_event_link1
// file src/zmonitor_v2.c line 269
static void s_socket_event_link1(struct anonymous_39 *self);
// s_sub_free
// file src/zdir.c line 735
static void s_sub_free(void *data);
// s_test_attached
// file src/zthread.c line 222
static void s_test_attached(void *args, struct _zctx_t *ctx, void *pipe);
// s_test_detached
// file src/zthread.c line 209
static void * s_test_detached(void *args);
// s_thread_shim
// file src/zactor.c line 63
static void * s_thread_shim(void *args);
// s_thread_shim_link1
// file src/zthread.c line 77
static void * s_thread_shim_link1(void *args_link1);
// s_thread_start
// file src/zthread.c line 112
static void s_thread_start(struct anonymous_21 *shim);
// s_ticket_comparator
// file src/zloop.c line 216
static signed int s_ticket_comparator(struct _s_ticket_t *ticket1, struct _s_ticket_t *ticket2);
// s_ticket_destroy
// file src/zloop.c line 204
static void s_ticket_destroy(struct _s_ticket_t **self_p);
// s_ticket_new
// file src/zloop.c line 190
static struct _s_ticket_t * s_ticket_new(unsigned long int delay, signed int (*handler)(struct _zloop_t *, signed int, void *), void *arg);
// s_ticket_new::handler_object
//
signed int handler_object(struct _zloop_t *, signed int, void *);
// s_tickless
// file src/zloop.c line 291
static signed long int s_tickless(struct _zloop_t *self);
// s_timer_comparator
// file src/zloop.c line 178
static signed int s_timer_comparator(struct _s_timer_t *timer1, struct _s_timer_t *timer2);
// s_timer_destroy
// file src/zloop.c line 167
static void s_timer_destroy(struct _s_timer_t **self_p);
// s_timer_event
// file src/zloop.c line 886
static signed int s_timer_event(struct _zloop_t *loop, signed int timer_id, void *output);
// s_timer_event3
// file src/zloop.c line 900
static signed int s_timer_event3(struct _zloop_t *loop, signed int timer_id, void *called);
// s_timer_new
// file src/zloop.c line 152
static struct _s_timer_t * s_timer_new(signed int timer_id, unsigned long int delay, unsigned long int times, signed int (*handler)(struct _zloop_t *, signed int, void *), void *arg);
// s_timer_new::handler_object
//
signed int handler_object(struct _zloop_t *, signed int, void *);
// s_timer_remove
// file src/zloop.c line 230
static void s_timer_remove(struct _zloop_t *self, signed int timer_id);
// s_valid_flags
// file src/ziflist.c line 128
static _Bool s_valid_flags(signed short int flags);
// s_verify_eoln
// file src/zconfig.c line 744
static signed int s_verify_eoln(char *readptr, signed int lineno);
// s_watch_server_config
// file src/zgossip_engine.inc line 888
static signed int s_watch_server_config(struct _zloop_t *loop, signed int timer_id, void *argument);
// s_z85_decode
// file src/zarmour.c line 417
static unsigned char * s_z85_decode(const char *data, unsigned long int *size);
// s_z85_encode
// file src/zarmour.c line 403
static char * s_z85_encode(const unsigned char *data, unsigned long int length);
// s_zap_request_destroy
// file src/zauth.c line 200
static void s_zap_request_destroy(struct anonymous_34 **self_p);
// s_zap_request_new
// file src/zauth.c line 224
static struct anonymous_34 * s_zap_request_new(struct _zsock_t *handler, _Bool verbose);
// s_zap_request_reply
// file src/zauth.c line 279
static signed int s_zap_request_reply(struct anonymous_34 *self, char *status_code, char *status_text);
// s_zdir_watch_destroy
// file src/zdir.c line 721
static void s_zdir_watch_destroy(struct _zdir_watch_t **watch_p);
// s_zdir_watch_new
// file src/zdir.c line 810
static struct _zdir_watch_t * s_zdir_watch_new(struct _zsock_t *pipe);
// s_zdir_watch_subscribe
// file src/zdir.c line 744
static void s_zdir_watch_subscribe(struct _zdir_watch_t *watch, const char *path);
// s_zdir_watch_timeout
// file src/zdir.c line 792
static signed int s_zdir_watch_timeout(struct _zdir_watch_t *watch, signed int timeout);
// s_zdir_watch_unsubscribe
// file src/zdir.c line 780
static void s_zdir_watch_unsubscribe(struct _zdir_watch_t *watch, const char *path);
// s_zhashx_rehash
// file src/zhashx.c line 207
static signed int s_zhashx_rehash(struct _zhashx_t *self, unsigned int new_prime_index);
// s_zlist_free
// file src/zlist.c line 480
static void s_zlist_free(void *data);
// safe_malloc
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc(unsigned long int size, const char *file, unsigned int line);
// safe_malloc_link1
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link1(unsigned long int size_link1, const char *file_link1, unsigned int line_link1);
// safe_malloc_link10
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link10(unsigned long int size_link10, const char *file_link10, unsigned int line_link10);
// safe_malloc_link11
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link11(unsigned long int size_link11, const char *file_link11, unsigned int line_link11);
// safe_malloc_link12
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link12(unsigned long int size_link12, const char *file_link12, unsigned int line_link12);
// safe_malloc_link13
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link13(unsigned long int size_link13, const char *file_link13, unsigned int line_link13);
// safe_malloc_link14
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link14(unsigned long int size_link14, const char *file_link14, unsigned int line_link14);
// safe_malloc_link15
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link15(unsigned long int size_link15, const char *file_link15, unsigned int line_link15);
// safe_malloc_link16
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link16(unsigned long int size_link16, const char *file_link16, unsigned int line_link16);
// safe_malloc_link17
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link17(unsigned long int size_link17, const char *file_link17, unsigned int line_link17);
// safe_malloc_link18
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link18(unsigned long int size_link18, const char *file_link18, unsigned int line_link18);
// safe_malloc_link19
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link19(unsigned long int size_link19, const char *file_link19, unsigned int line_link19);
// safe_malloc_link2
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link2(unsigned long int size_link2, const char *file_link2, unsigned int line_link2);
// safe_malloc_link20
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link20(unsigned long int size_link20, const char *file_link20, unsigned int line_link20);
// safe_malloc_link21
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link21(unsigned long int size_link21, const char *file_link21, unsigned int line_link21);
// safe_malloc_link22
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link22(unsigned long int size_link22, const char *file_link22, unsigned int line_link22);
// safe_malloc_link23
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link23(unsigned long int size_link23, const char *file_link23, unsigned int line_link23);
// safe_malloc_link24
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link24(unsigned long int size_link24, const char *file_link24, unsigned int line_link24);
// safe_malloc_link25
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link25(unsigned long int size_link25, const char *file_link25, unsigned int line_link25);
// safe_malloc_link26
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link26(unsigned long int size_link26, const char *file_link26, unsigned int line_link26);
// safe_malloc_link27
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link27(unsigned long int size_link27, const char *file_link27, unsigned int line_link27);
// safe_malloc_link28
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link28(unsigned long int size_link28, const char *file_link28, unsigned int line_link28);
// safe_malloc_link29
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link29(unsigned long int size_link29, const char *file_link29, unsigned int line_link29);
// safe_malloc_link3
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link3(unsigned long int size_link3, const char *file_link3, unsigned int line_link3);
// safe_malloc_link30
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link30(unsigned long int size_link30, const char *file_link30, unsigned int line_link30);
// safe_malloc_link31
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link31(unsigned long int size_link31, const char *file_link31, unsigned int line_link31);
// safe_malloc_link32
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link32(unsigned long int size_link32, const char *file_link32, unsigned int line_link32);
// safe_malloc_link33
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link33(unsigned long int size_link33, const char *file_link33, unsigned int line_link33);
// safe_malloc_link34
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link34(unsigned long int size_link34, const char *file_link34, unsigned int line_link34);
// safe_malloc_link35
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link35(unsigned long int size_link35, const char *file_link35, unsigned int line_link35);
// safe_malloc_link36
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link36(unsigned long int size_link36, const char *file_link36, unsigned int line_link36);
// safe_malloc_link37
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link37(unsigned long int size_link37, const char *file_link37, unsigned int line_link37);
// safe_malloc_link4
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link4(unsigned long int size_link4, const char *file_link4, unsigned int line_link4);
// safe_malloc_link5
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link5(unsigned long int size_link5, const char *file_link5, unsigned int line_link5);
// safe_malloc_link6
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link6(unsigned long int size_link6, const char *file_link6, unsigned int line_link6);
// safe_malloc_link7
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link7(unsigned long int size_link7, const char *file_link7, unsigned int line_link7);
// safe_malloc_link8
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link8(unsigned long int size_link8, const char *file_link8, unsigned int line_link8);
// safe_malloc_link9
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link9(unsigned long int size_link9, const char *file_link9, unsigned int line_link9);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, union anonymous_33, unsigned int);
// server_accept
// file src/zgossip.c line 232
static void server_accept(struct _server_t *self, const char *key, const char *value);
// server_connect
// file src/zgossip.c line 195
static void server_connect(struct _server_t *self, const char *endpoint);
// server_initialize
// file src/zgossip.c line 166
static signed int server_initialize(struct _server_t *self);
// server_method
// file src/zgossip.c line 272
static struct _zmsg_t * server_method(struct _server_t *self, const char *method, struct _zmsg_t *msg);
// server_terminate
// file src/zgossip.c line 185
static void server_terminate(struct _server_t *self);
// set_jump_offset
// file src/foreign/slre/slre.inc_c line 158
static void set_jump_offset(struct slre *r, signed int pc, signed int offset);
// seteuid
// file /usr/include/unistd.h line 713
extern signed int seteuid(unsigned int);
// setgid
// file /usr/include/unistd.h line 720
extern signed int setgid(unsigned int);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 703
extern signed int setuid(unsigned int);
// sha1_init
// file src/foreign/sha1/sha1.inc_c line 223
extern void sha1_init(struct sha1_ctxt *ctxt);
// sha1_loop
// file src/foreign/sha1/sha1.inc_c line 277
extern void sha1_loop(struct sha1_ctxt *ctxt, const unsigned char *input0, unsigned long int len);
// sha1_pad
// file src/foreign/sha1/sha1.inc_c line 234
extern void sha1_pad(struct sha1_ctxt *ctxt);
// sha1_result
// file src/foreign/sha1/sha1.inc_c line 305
extern void sha1_result(struct sha1_ctxt *ctxt, unsigned char *digest0);
// sha1_step
// file src/foreign/sha1/sha1.inc_c line 78
static void sha1_step(struct sha1_ctxt *ctxt);
// sigaction
// file /usr/include/signal.h line 257
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 213
extern signed int sigemptyset(struct anonymous_2 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// slre_compile
// file src/foreign/slre/slre.inc_c line 386
signed int slre_compile(struct slre *r, const char *re);
// slre_dump
// file src/foreign/slre/slre.inc_c line 114
void slre_dump(struct slre *r, struct _IO_FILE *fp);
// slre_match
// file src/foreign/slre/slre.inc_c line 646
signed int slre_match(struct slre *r, const char *buf, unsigned long int len, struct cap *caps);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// store_char_in_data
// file src/foreign/slre/slre.inc_c line 178
static void store_char_in_data(struct slre *r, signed int ch);
// store_tuple_if_new
// file src/zgossip.c line 365
static void store_tuple_if_new(struct _client_t *self);
// strcat
// file /usr/include/string.h line 133
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 408
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 136
extern char * strncat(char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 258
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 337
extern char * strstr(const char *, const char *);
// sysconf
// file /usr/include/unistd.h line 622
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// tuple_free
// file src/zgossip.c line 145
static void tuple_free(void *argument);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// unlink
// file /usr/include/unistd.h line 829
extern signed int unlink(const char *);
// vprintf
// file /usr/include/stdio.h line 377
extern signed int vprintf(const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// write
// file /usr/include/unistd.h line 369
extern signed long int write(signed int, const void *, unsigned long int);
// zactor_destroy
// file src/../include/zactor.h line 34
void zactor_destroy(struct _zactor_t **self_p);
// zactor_is
// file src/zactor.c line 205
_Bool zactor_is(void *self);
// zactor_new
// file src/../include/zactor.h line 30
struct _zactor_t * zactor_new(void (*actor)(struct _zsock_t *, void *), void *args);
// zactor_new::actor_object
//
void actor_object(struct _zsock_t *, void *);
// zactor_recv
// file src/zactor.c line 195
struct _zmsg_t * zactor_recv(struct _zactor_t *self);
// zactor_resolve
// file src/zactor.c line 218
void * zactor_resolve(void *self);
// zactor_send
// file src/zactor.c line 183
signed int zactor_send(struct _zactor_t *self, struct _zmsg_t **msg_p);
// zactor_sock
// file src/zactor.c line 233
struct _zsock_t * zactor_sock(struct _zactor_t *self);
// zactor_test
// file src/zactor.c line 280
void zactor_test(_Bool verbose);
// zap_request_destroy
// file src/zauth_v2.c line 209
static void zap_request_destroy(struct anonymous_24 **self_p);
// zap_request_new
// file src/zauth_v2.c line 233
static struct anonymous_24 * zap_request_new(void *handler);
// zap_request_reply
// file src/zauth_v2.c line 287
static signed int zap_request_reply(struct anonymous_24 *self, char *status_code, char *status_text);
// zarmour_decode
// file src/zarmour.c line 510
unsigned char * zarmour_decode(struct _zarmour_t *self, const char *data, unsigned long int *decode_size);
// zarmour_destroy
// file src/zarmour.c line 109
void zarmour_destroy(struct _zarmour_t **self_p);
// zarmour_encode
// file src/zarmour.c line 437
char * zarmour_encode(struct _zarmour_t *self, const unsigned char *data, unsigned long int data_size);
// zarmour_line_breaks
// file src/zarmour.c line 601
_Bool zarmour_line_breaks(struct _zarmour_t *self);
// zarmour_line_length
// file src/zarmour.c line 618
unsigned long int zarmour_line_length(struct _zarmour_t *self);
// zarmour_mode
// file src/zarmour.c line 549
enum anonymous_37 zarmour_mode(struct _zarmour_t *self);
// zarmour_mode_str
// file src/zarmour.c line 146
const char * zarmour_mode_str(struct _zarmour_t *self);
// zarmour_new
// file src/zarmour.c line 83
struct _zarmour_t * zarmour_new();
// zarmour_pad
// file src/zarmour.c line 566
_Bool zarmour_pad(struct _zarmour_t *self);
// zarmour_pad_char
// file src/zarmour.c line 583
char zarmour_pad_char(struct _zarmour_t *self);
// zarmour_print
// file src/zarmour.c line 129
void zarmour_print(struct _zarmour_t *self);
// zarmour_set_line_breaks
// file src/zarmour.c line 608
void zarmour_set_line_breaks(struct _zarmour_t *self, _Bool line_breaks);
// zarmour_set_line_length
// file src/zarmour.c line 625
void zarmour_set_line_length(struct _zarmour_t *self, unsigned long int line_length);
// zarmour_set_mode
// file src/zarmour.c line 556
void zarmour_set_mode(struct _zarmour_t *self, enum anonymous_37 mode);
// zarmour_set_pad
// file src/zarmour.c line 573
void zarmour_set_pad(struct _zarmour_t *self, _Bool pad);
// zarmour_set_pad_char
// file src/zarmour.c line 590
void zarmour_set_pad_char(struct _zarmour_t *self, char pad_char);
// zarmour_test
// file src/zarmour.c line 706
signed int zarmour_test(_Bool verbose);
// zauth
// file src/zauth.c line 428
void zauth(struct _zsock_t *pipe, void *unused);
// zauth_allow
// file src/zauth_v2.c line 101
void zauth_allow(struct _zauth_t *self, const char *address);
// zauth_configure_curve
// file src/zauth_v2.c line 147
void zauth_configure_curve(struct _zauth_t *self, const char *domain, const char *location);
// zauth_configure_gssapi
// file src/zauth_v2.c line 163
void zauth_configure_gssapi(struct _zauth_t *self, char *domain);
// zauth_configure_plain
// file src/zauth_v2.c line 128
void zauth_configure_plain(struct _zauth_t *self, const char *domain, const char *filename);
// zauth_deny
// file src/zauth_v2.c line 115
void zauth_deny(struct _zauth_t *self, const char *address);
// zauth_destroy
// file src/zauth_v2.c line 79
void zauth_destroy(struct _zauth_t **self_p);
// zauth_new
// file src/zauth_v2.c line 53
struct _zauth_t * zauth_new(struct _zctx_t *ctx);
// zauth_set_verbose
// file src/zauth_v2.c line 176
void zauth_set_verbose(struct _zauth_t *self, _Bool verbose);
// zauth_test
// file src/zauth.c line 486
void zauth_test(_Bool verbose);
// zauth_v2_test
// file src/zauth_v2.c line 642
void zauth_v2_test(_Bool verbose);
// zbeacon
// file src/zbeacon.c line 270
void zbeacon(struct _zsock_t *pipe, void *args);
// zbeacon_destroy
// file src/zbeacon_v2.c line 95
void zbeacon_destroy(struct _zbeacon_t **self_p);
// zbeacon_hostname
// file src/zbeacon_v2.c line 205
char * zbeacon_hostname(struct _zbeacon_t *self);
// zbeacon_new
// file src/zbeacon_v2.c line 60
struct _zbeacon_t * zbeacon_new(struct _zctx_t *ctx, signed int port_nbr);
// zbeacon_noecho
// file src/zbeacon_v2.c line 129
void zbeacon_noecho(struct _zbeacon_t *self);
// zbeacon_publish
// file src/zbeacon_v2.c line 140
void zbeacon_publish(struct _zbeacon_t *self, unsigned char *transmit, unsigned long int size);
// zbeacon_set_interval
// file src/zbeacon_v2.c line 117
void zbeacon_set_interval(struct _zbeacon_t *self, signed int interval);
// zbeacon_silence
// file src/zbeacon_v2.c line 157
void zbeacon_silence(struct _zbeacon_t *self);
// zbeacon_socket
// file src/zbeacon_v2.c line 194
void * zbeacon_socket(struct _zbeacon_t *self);
// zbeacon_subscribe
// file src/zbeacon_v2.c line 168
void zbeacon_subscribe(struct _zbeacon_t *self, unsigned char *filter, unsigned long int size);
// zbeacon_test
// file src/zbeacon.c line 315
void zbeacon_test(_Bool verbose);
// zbeacon_unsubscribe
// file src/zbeacon_v2.c line 184
void zbeacon_unsubscribe(struct _zbeacon_t *self);
// zbeacon_v2_test
// file src/zbeacon_v2.c line 499
void zbeacon_v2_test(_Bool verbose);
// zcert_apply
// file src/../include/zcert.h line 86
void zcert_apply(struct _zcert_t *self, void *zocket);
// zcert_destroy
// file src/../include/zcert.h line 33
void zcert_destroy(struct _zcert_t **self_p);
// zcert_dup
// file src/zcert.c line 364
struct _zcert_t * zcert_dup(struct _zcert_t *self);
// zcert_eq
// file src/zcert.c line 385
_Bool zcert_eq(struct _zcert_t *self, struct _zcert_t *compare);
// zcert_fprint
// file src/zcert.c line 421
void zcert_fprint(struct _zcert_t *self, struct _IO_FILE *file);
// zcert_load
// file src/zcert.c line 211
struct _zcert_t * zcert_load(const char *filename);
// zcert_meta
// file src/zcert.c line 188
char * zcert_meta(struct _zcert_t *self, const char *name);
// zcert_meta_keys
// file src/zcert.c line 200
struct _zlist_t * zcert_meta_keys(struct _zcert_t *self);
// zcert_new
// file src/../include/zcert.h line 25
struct _zcert_t * zcert_new(void);
// zcert_new_from
// file src/zcert.c line 79
struct _zcert_t * zcert_new_from(unsigned char *public_key, unsigned char *secret_key);
// zcert_print
// file src/zcert.c line 399
void zcert_print(struct _zcert_t *self);
// zcert_public_key
// file src/zcert.c line 127
unsigned char * zcert_public_key(struct _zcert_t *self);
// zcert_public_txt
// file src/../include/zcert.h line 45
char * zcert_public_txt(struct _zcert_t *self);
// zcert_save
// file src/zcert.c line 277
signed int zcert_save(struct _zcert_t *self, const char *filename);
// zcert_save_public
// file src/../include/zcert.h line 76
signed int zcert_save_public(struct _zcert_t *self, const char *filename);
// zcert_save_secret
// file src/zcert.c line 320
signed int zcert_save_secret(struct _zcert_t *self, const char *filename);
// zcert_secret_key
// file src/zcert.c line 138
unsigned char * zcert_secret_key(struct _zcert_t *self);
// zcert_secret_txt
// file src/zcert.c line 160
char * zcert_secret_txt(struct _zcert_t *self);
// zcert_set_meta
// file src/zcert.c line 171
void zcert_set_meta(struct _zcert_t *self, const char *name, const char *format, ...);
// zcert_test
// file src/zcert.c line 441
void zcert_test(_Bool verbose);
// zcertstore_destroy
// file src/../include/zcertstore.h line 35
void zcertstore_destroy(struct _zcertstore_t **self_p);
// zcertstore_fprint
// file src/zcertstore.c line 207
void zcertstore_fprint(struct _zcertstore_t *self, struct _IO_FILE *file);
// zcertstore_insert
// file src/zcertstore.c line 175
void zcertstore_insert(struct _zcertstore_t *self, struct _zcert_t **cert_p);
// zcertstore_lookup
// file src/../include/zcertstore.h line 40
struct _zcert_t * zcertstore_lookup(struct _zcertstore_t *self, const char *public_key);
// zcertstore_new
// file src/../include/zcertstore.h line 30
struct _zcertstore_t * zcertstore_new(const char *location);
// zcertstore_print
// file src/zcertstore.c line 187
void zcertstore_print(struct _zcertstore_t *self);
// zcertstore_test
// file src/zcertstore.c line 226
void zcertstore_test(_Bool verbose);
// zchunk_append
// file src/zchunk.c line 193
unsigned long int zchunk_append(struct _zchunk_t *self, const void *data, unsigned long int size);
// zchunk_consume
// file src/zchunk.c line 244
unsigned long int zchunk_consume(struct _zchunk_t *self, struct _zchunk_t *source);
// zchunk_data
// file src/zchunk.c line 139
unsigned char * zchunk_data(struct _zchunk_t *self);
// zchunk_destroy
// file src/zchunk.c line 70
void zchunk_destroy(struct _zchunk_t **self_p);
// zchunk_digest
// file src/zchunk.c line 446
const char * zchunk_digest(struct _zchunk_t *self);
// zchunk_dup
// file src/zchunk.c line 340
struct _zchunk_t * zchunk_dup(struct _zchunk_t *self);
// zchunk_exhausted
// file src/zchunk.c line 270
_Bool zchunk_exhausted(struct _zchunk_t *self);
// zchunk_extend
// file src/zchunk.c line 213
unsigned long int zchunk_extend(struct _zchunk_t *self, const void *data, unsigned long int size);
// zchunk_fill
// file src/zchunk.c line 172
unsigned long int zchunk_fill(struct _zchunk_t *self, unsigned char filler, unsigned long int size);
// zchunk_fprint
// file src/zchunk.c line 464
void zchunk_fprint(struct _zchunk_t *self, struct _IO_FILE *file);
// zchunk_is
// file src/zchunk.c line 521
_Bool zchunk_is(void *self);
// zchunk_max_size
// file src/zchunk.c line 127
unsigned long int zchunk_max_size(struct _zchunk_t *self);
// zchunk_new
// file src/zchunk.c line 46
struct _zchunk_t * zchunk_new(const void *data, unsigned long int size);
// zchunk_pack
// file src/zchunk.c line 421
struct _zframe_t * zchunk_pack(struct _zchunk_t *self);
// zchunk_print
// file src/zchunk.c line 508
void zchunk_print(struct _zchunk_t *self);
// zchunk_read
// file src/zchunk.c line 284
struct _zchunk_t * zchunk_read(struct _IO_FILE *handle, unsigned long int bytes);
// zchunk_resize
// file src/zchunk.c line 91
void zchunk_resize(struct _zchunk_t *self, unsigned long int size);
// zchunk_set
// file src/zchunk.c line 152
unsigned long int zchunk_set(struct _zchunk_t *self, const void *data, unsigned long int size);
// zchunk_size
// file src/zchunk.c line 115
unsigned long int zchunk_size(struct _zchunk_t *self);
// zchunk_slurp
// file src/zchunk.c line 317
struct _zchunk_t * zchunk_slurp(const char *filename, unsigned long int maxsize);
// zchunk_strdup
// file src/zchunk.c line 385
char * zchunk_strdup(struct _zchunk_t *self);
// zchunk_streq
// file src/zchunk.c line 404
_Bool zchunk_streq(struct _zchunk_t *self, const char *string);
// zchunk_strhex
// file src/zchunk.c line 356
char * zchunk_strhex(struct _zchunk_t *self);
// zchunk_test
// file src/zchunk.c line 532
void zchunk_test(_Bool verbose);
// zchunk_unpack
// file src/zchunk.c line 433
struct _zchunk_t * zchunk_unpack(struct _zframe_t *frame);
// zchunk_write
// file src/zchunk.c line 299
signed int zchunk_write(struct _zchunk_t *self, struct _IO_FILE *handle);
// zclock_log
// file src/zclock.c line 193
void zclock_log(const char *format, ...);
// zclock_mono
// file src/../include/zclock.h line 36
signed long int zclock_mono(void);
// zclock_sleep
// file src/../include/zclock.h line 24
void zclock_sleep(signed int msecs);
// zclock_test
// file src/zclock.c line 213
void zclock_test(_Bool verbose);
// zclock_time
// file src/zclock.c line 82
signed long int zclock_time(void);
// zclock_timestr
// file src/../include/zclock.h line 46
char * zclock_timestr(void);
// zclock_usecs
// file src/zclock.c line 141
signed long int zclock_usecs(void);
// zconfig_at_depth
// file src/zconfig.c line 331
struct _zconfig_t * zconfig_at_depth(struct _zconfig_t *self, signed int level);
// zconfig_child
// file src/../include/zconfig.h line 68
struct _zconfig_t * zconfig_child(struct _zconfig_t *self);
// zconfig_chunk_load
// file src/zconfig.c line 588
struct _zconfig_t * zconfig_chunk_load(struct _zchunk_t *chunk);
// zconfig_chunk_save
// file src/zconfig.c line 824
struct _zchunk_t * zconfig_chunk_save(struct _zconfig_t *self);
// zconfig_comments
// file src/zconfig.c line 912
struct _zlist_t * zconfig_comments(struct _zconfig_t *self);
// zconfig_destroy
// file src/../include/zconfig.h line 31
void zconfig_destroy(struct _zconfig_t **self_p);
// zconfig_execute
// file src/zconfig.c line 354
signed int zconfig_execute(struct _zconfig_t *self, signed int (*handler)(struct _zconfig_t *, void *, signed int), void *arg);
// zconfig_execute::handler_object
//
signed int handler_object(struct _zconfig_t *, void *, signed int);
// zconfig_filename
// file src/zconfig.c line 550
const char * zconfig_filename(struct _zconfig_t *self);
// zconfig_fprint
// file src/zconfig.c line 923
void zconfig_fprint(struct _zconfig_t *self, struct _IO_FILE *file);
// zconfig_get
// file src/../include/zconfig.h line 53
char * zconfig_get(struct _zconfig_t *self, const char *path, const char *default_value);
// zconfig_has_changed
// file src/zconfig.c line 871
_Bool zconfig_has_changed(struct _zconfig_t *self);
// zconfig_load
// file src/../include/zconfig.h line 101
struct _zconfig_t * zconfig_load(const char *filename);
// zconfig_loadf
// file src/zconfig.c line 508
struct _zconfig_t * zconfig_loadf(const char *format, ...);
// zconfig_locate
// file src/../include/zconfig.h line 76
struct _zconfig_t * zconfig_locate(struct _zconfig_t *self, const char *path);
// zconfig_name
// file src/../include/zconfig.h line 35
char * zconfig_name(struct _zconfig_t *self);
// zconfig_new
// file src/../include/zconfig.h line 27
struct _zconfig_t * zconfig_new(const char *name, struct _zconfig_t *parent);
// zconfig_next
// file src/../include/zconfig.h line 72
struct _zconfig_t * zconfig_next(struct _zconfig_t *self);
// zconfig_print
// file src/zconfig.c line 933
void zconfig_print(struct _zconfig_t *self);
// zconfig_put
// file src/../include/zconfig.h line 43
void zconfig_put(struct _zconfig_t *self, const char *path, const char *value);
// zconfig_putf
// file src/zconfig.c line 210
void zconfig_putf(struct _zconfig_t *self, const char *path, const char *format, ...);
// zconfig_reload
// file src/zconfig.c line 566
signed int zconfig_reload(struct _zconfig_t **self_p);
// zconfig_save
// file src/../include/zconfig.h line 106
signed int zconfig_save(struct _zconfig_t *self, const char *filename);
// zconfig_savef
// file src/zconfig.c line 529
signed int zconfig_savef(struct _zconfig_t *self, const char *format, ...);
// zconfig_set_comment
// file src/../include/zconfig.h line 91
void zconfig_set_comment(struct _zconfig_t *self, const char *format, ...);
// zconfig_set_name
// file src/zconfig.c line 226
void zconfig_set_name(struct _zconfig_t *self, const char *name);
// zconfig_set_value
// file src/../include/zconfig.h line 64
void zconfig_set_value(struct _zconfig_t *self, const char *format, ...);
// zconfig_str_load
// file src/zconfig.c line 844
struct _zconfig_t * zconfig_str_load(const char *string);
// zconfig_str_save
// file src/zconfig.c line 857
char * zconfig_str_save(struct _zconfig_t *self);
// zconfig_test
// file src/zconfig.c line 943
void zconfig_test(_Bool verbose);
// zconfig_value
// file src/../include/zconfig.h line 39
char * zconfig_value(struct _zconfig_t *self);
// zctx__initialize_underlying
// file src/zctx.c line 264
void zctx__initialize_underlying(struct _zctx_t *self);
// zctx__socket_destroy
// file src/zctx.c line 329
void zctx__socket_destroy(struct _zctx_t *self, void *zocket);
// zctx__socket_new
// file src/zctx.c line 278
void * zctx__socket_new(struct _zctx_t *self, signed int type);
// zctx__socket_pipe
// file src/zctx.c line 315
void * zctx__socket_pipe(struct _zctx_t *self);
// zctx_destroy
// file src/../include/zctx.h line 29
void zctx_destroy(struct _zctx_t **self_p);
// zctx_new
// file src/../include/zctx.h line 25
struct _zctx_t * zctx_new(void);
// zctx_set_iothreads
// file src/zctx.c line 177
void zctx_set_iothreads(struct _zctx_t *self, signed int iothreads);
// zctx_set_linger
// file src/zctx.c line 192
void zctx_set_linger(struct _zctx_t *self, signed int linger);
// zctx_set_pipehwm
// file src/zctx.c line 210
void zctx_set_pipehwm(struct _zctx_t *self, signed int pipehwm);
// zctx_set_rcvhwm
// file src/zctx.c line 240
void zctx_set_rcvhwm(struct _zctx_t *self, signed int rcvhwm);
// zctx_set_sndhwm
// file src/zctx.c line 225
void zctx_set_sndhwm(struct _zctx_t *self, signed int sndhwm);
// zctx_shadow
// file src/../include/zctx.h line 33
struct _zctx_t * zctx_shadow(struct _zctx_t *ctx);
// zctx_shadow_zmq_ctx
// file src/../include/zctx.h line 38
struct _zctx_t * zctx_shadow_zmq_ctx(void *zmqctx);
// zctx_test
// file src/zctx.c line 346
void zctx_test(_Bool verbose);
// zctx_underlying
// file src/zctx.c line 253
void * zctx_underlying(struct _zctx_t *self);
// zdigest_data
// file src/zdigest.c line 90
unsigned char * zdigest_data(struct _zdigest_t *self);
// zdigest_destroy
// file src/../include/zdigest.h line 29
void zdigest_destroy(struct _zdigest_t **self_p);
// zdigest_new
// file src/../include/zdigest.h line 25
struct _zdigest_t * zdigest_new(void);
// zdigest_size
// file src/zdigest.c line 105
unsigned long int zdigest_size(struct _zdigest_t *self);
// zdigest_string
// file src/../include/zdigest.h line 48
char * zdigest_string(struct _zdigest_t *self);
// zdigest_test
// file src/zdigest.c line 137
void zdigest_test(_Bool verbose);
// zdigest_update
// file src/../include/zdigest.h line 33
void zdigest_update(struct _zdigest_t *self, unsigned char *buffer, unsigned long int length);
// zdir_cache
// file src/zdir.c line 574
struct _zhash_t * zdir_cache(struct _zdir_t *self);
// zdir_count
// file src/../include/zdir.h line 49
unsigned long int zdir_count(struct _zdir_t *self);
// zdir_cursize
// file src/../include/zdir.h line 45
signed long int zdir_cursize(struct _zdir_t *self);
// zdir_destroy
// file src/../include/zdir.h line 32
void zdir_destroy(struct _zdir_t **self_p);
// zdir_diff
// file src/zdir.c line 456
struct _zlist_t * zdir_diff(struct _zdir_t *older, struct _zdir_t *newer, const char *alias);
// zdir_flatten
// file src/../include/zdir.h line 131
struct _zfile_t ** zdir_flatten(struct _zdir_t *self);
// zdir_flatten_free
// file src/../include/zdir.h line 136
void zdir_flatten_free(struct _zfile_t ***files_p);
// zdir_fprint
// file src/zdir.c line 621
void zdir_fprint(struct _zdir_t *self, struct _IO_FILE *stream, signed int indent);
// zdir_list
// file src/zdir.c line 399
struct _zlist_t * zdir_list(struct _zdir_t *self);
// zdir_modified
// file src/../include/zdir.h line 40
signed long int zdir_modified(struct _zdir_t *self);
// zdir_new
// file src/../include/zdir.h line 28
struct _zdir_t * zdir_new(const char *path, const char *parent);
// zdir_patch_destroy
// file src/../include/zdir_patch.h line 39
void zdir_patch_destroy(struct _zdir_patch_t **self_p);
// zdir_patch_digest
// file src/zdir_patch.c line 190
const char * zdir_patch_digest(struct _zdir_patch_t *self);
// zdir_patch_digest_set
// file src/zdir_patch.c line 175
void zdir_patch_digest_set(struct _zdir_patch_t *self);
// zdir_patch_dup
// file src/zdir_patch.c line 102
struct _zdir_patch_t * zdir_patch_dup(struct _zdir_patch_t *self);
// zdir_patch_file
// file src/../include/zdir_patch.h line 53
struct _zfile_t * zdir_patch_file(struct _zdir_patch_t *self);
// zdir_patch_new
// file src/../include/zdir_patch.h line 35
struct _zdir_patch_t * zdir_patch_new(const char *path, struct _zfile_t *file, enum anonymous_6 op, const char *alias);
// zdir_patch_op
// file src/../include/zdir_patch.h line 57
enum anonymous_6 zdir_patch_op(struct _zdir_patch_t *self);
// zdir_patch_path
// file src/../include/zdir_patch.h line 49
const char * zdir_patch_path(struct _zdir_patch_t *self);
// zdir_patch_test
// file src/zdir_patch.c line 201
void zdir_patch_test(_Bool verbose);
// zdir_patch_vpath
// file src/zdir_patch.c line 164
const char * zdir_patch_vpath(struct _zdir_patch_t *self);
// zdir_path
// file src/zdir.c line 267
const char * zdir_path(struct _zdir_t *self);
// zdir_print
// file src/zdir.c line 641
void zdir_print(struct _zdir_t *self, signed int indent);
// zdir_remove
// file src/../include/zdir.h line 62
void zdir_remove(struct _zdir_t *self, _Bool force);
// zdir_resync
// file src/zdir.c line 545
struct _zlist_t * zdir_resync(struct _zdir_t *self, const char *alias);
// zdir_test
// file src/zdir.c line 933
void zdir_test(_Bool verbose);
// zdir_watch
// file src/zdir.c line 897
void zdir_watch(struct _zsock_t *pipe, void *unused);
// zfile_close
// file src/../include/zfile.h line 131
void zfile_close(struct _zfile_t *self);
// zfile_cursize
// file src/../include/zfile.h line 60
signed long int zfile_cursize(struct _zfile_t *self);
// zfile_delete
// file src/zfile.c line 579
signed int zfile_delete(const char *filename);
// zfile_destroy
// file src/../include/zfile.h line 34
void zfile_destroy(struct _zfile_t **self_p);
// zfile_digest
// file src/../include/zfile.h line 139
const char * zfile_digest(struct _zfile_t *self);
// zfile_dup
// file src/../include/zfile.h line 40
struct _zfile_t * zfile_dup(struct _zfile_t *self);
// zfile_eof
// file src/zfile.c line 429
_Bool zfile_eof(struct _zfile_t *self);
// zfile_exists
// file src/zfile.c line 564
_Bool zfile_exists(const char *filename);
// zfile_filename
// file src/../include/zfile.h line 44
const char * zfile_filename(struct _zfile_t *self, const char *path);
// zfile_handle
// file src/../include/zfile.h line 135
struct _IO_FILE * zfile_handle(struct _zfile_t *self);
// zfile_has_changed
// file src/../include/zfile.h line 92
_Bool zfile_has_changed(struct _zfile_t *self);
// zfile_input
// file src/../include/zfile.h line 101
signed int zfile_input(struct _zfile_t *self);
// zfile_is_directory
// file src/zfile.c line 238
_Bool zfile_is_directory(struct _zfile_t *self);
// zfile_is_readable
// file src/zfile.c line 263
_Bool zfile_is_readable(struct _zfile_t *self);
// zfile_is_regular
// file src/../include/zfile.h line 70
_Bool zfile_is_regular(struct _zfile_t *self);
// zfile_is_stable
// file src/../include/zfile.h line 87
_Bool zfile_is_stable(struct _zfile_t *self);
// zfile_is_writeable
// file src/zfile.c line 276
_Bool zfile_is_writeable(struct _zfile_t *self);
// zfile_mkdir
// file src/zfile.c line 589
signed int zfile_mkdir(const char *pathname);
// zfile_mode
// file src/zfile.c line 574
unsigned int zfile_mode(const char *filename);
// zfile_mode_default
// file src/zfile.c line 604
void zfile_mode_default(void);
// zfile_mode_private
// file src/zfile.c line 599
void zfile_mode_private(void);
// zfile_modified
// file src/../include/zfile.h line 55
signed long int zfile_modified(struct _zfile_t *self);
// zfile_new
// file src/../include/zfile.h line 30
struct _zfile_t * zfile_new(const char *path, const char *name);
// zfile_output
// file src/../include/zfile.h line 107
signed int zfile_output(struct _zfile_t *self);
// zfile_read
// file src/../include/zfile.h line 113
struct _zchunk_t * zfile_read(struct _zfile_t *self, unsigned long int bytes, signed long int offset);
// zfile_readln
// file src/zfile.c line 457
const char * zfile_readln(struct _zfile_t *self);
// zfile_remove
// file src/../include/zfile.h line 96
void zfile_remove(struct _zfile_t *self);
// zfile_restat
// file src/../include/zfile.h line 50
void zfile_restat(struct _zfile_t *self);
// zfile_rmdir
// file src/zfile.c line 594
signed int zfile_rmdir(const char *pathname);
// zfile_size
// file src/zfile.c line 569
signed long int zfile_size(const char *filename);
// zfile_stable
// file src/zfile.c line 584
_Bool zfile_stable(const char *filename);
// zfile_test
// file src/zfile.c line 614
void zfile_test(_Bool verbose);
// zfile_write
// file src/zfile.c line 441
signed int zfile_write(struct _zfile_t *self, struct _zchunk_t *chunk, signed long int offset);
// zframe_data
// file src/../include/zframe.h line 66
unsigned char * zframe_data(struct _zframe_t *self);
// zframe_destroy
// file src/../include/zframe.h line 36
void zframe_destroy(struct _zframe_t **self_p);
// zframe_dup
// file src/zframe.c line 198
struct _zframe_t * zframe_dup(struct _zframe_t *self);
// zframe_eq
// file src/zframe.c line 308
_Bool zframe_eq(struct _zframe_t *self, struct _zframe_t *other);
// zframe_fprint
// file src/zframe.c line 422
void zframe_fprint(struct _zframe_t *self, const char *prefix, struct _IO_FILE *file);
// zframe_from
// file src/zframe.c line 102
struct _zframe_t * zframe_from(const char *string);
// zframe_is
// file src/../include/zframe.h line 116
_Bool zframe_is(void *self);
// zframe_more
// file src/zframe.c line 280
signed int zframe_more(struct _zframe_t *self);
// zframe_new
// file src/../include/zframe.h line 32
struct _zframe_t * zframe_new(const void *data, unsigned long int size);
// zframe_new_empty
// file src/zframe.c line 68
struct _zframe_t * zframe_new_empty(void);
// zframe_print
// file src/zframe.c line 348
void zframe_print(struct _zframe_t *self, const char *prefix);
// zframe_recv
// file src/../include/zframe.h line 53
struct _zframe_t * zframe_recv(void *source);
// zframe_recv_nowait
// file src/zframe.c line 399
struct _zframe_t * zframe_recv_nowait(void *source);
// zframe_reset
// file src/zframe.c line 331
void zframe_reset(struct _zframe_t *self, const void *data, unsigned long int size);
// zframe_send
// file src/zframe.c line 135
signed int zframe_send(struct _zframe_t **self_p, void *dest, signed int flags);
// zframe_set_more
// file src/zframe.c line 294
void zframe_set_more(struct _zframe_t *self, signed int more);
// zframe_size
// file src/../include/zframe.h line 62
unsigned long int zframe_size(struct _zframe_t *self);
// zframe_strdup
// file src/zframe.c line 243
char * zframe_strdup(struct _zframe_t *self);
// zframe_streq
// file src/zframe.c line 262
_Bool zframe_streq(struct _zframe_t *self, const char *string);
// zframe_strhex
// file src/zframe.c line 214
char * zframe_strhex(struct _zframe_t *self);
// zframe_test
// file src/zframe.c line 459
void zframe_test(_Bool verbose);
// zgossip
// file src/../include/zgossip.h line 84
void zgossip(struct _zsock_t *pipe, void *args);
// zgossip_msg_command
// file src/zgossip_msg.c line 505
const char * zgossip_msg_command(struct _zgossip_msg_t *self);
// zgossip_msg_destroy
// file src/zgossip_msg.h line 77
void zgossip_msg_destroy(struct _zgossip_msg_t **self_p);
// zgossip_msg_id
// file src/zgossip_msg.h line 100
signed int zgossip_msg_id(struct _zgossip_msg_t *self);
// zgossip_msg_key
// file src/zgossip_msg.h line 108
const char * zgossip_msg_key(struct _zgossip_msg_t *self);
// zgossip_msg_new
// file src/zgossip_msg.h line 73
struct _zgossip_msg_t * zgossip_msg_new(void);
// zgossip_msg_print
// file src/zgossip_msg.c line 427
void zgossip_msg_print(struct _zgossip_msg_t *self);
// zgossip_msg_recv
// file src/zgossip_msg.h line 82
signed int zgossip_msg_recv(struct _zgossip_msg_t *self, struct _zsock_t *input);
// zgossip_msg_routing_id
// file src/zgossip_msg.h line 94
struct _zframe_t * zgossip_msg_routing_id(struct _zgossip_msg_t *self);
// zgossip_msg_send
// file src/zgossip_msg.h line 86
signed int zgossip_msg_send(struct _zgossip_msg_t *self, struct _zsock_t *output);
// zgossip_msg_set_id
// file src/zgossip_msg.h line 102
void zgossip_msg_set_id(struct _zgossip_msg_t *self, signed int id);
// zgossip_msg_set_key
// file src/zgossip_msg.h line 110
void zgossip_msg_set_key(struct _zgossip_msg_t *self, const char *value);
// zgossip_msg_set_routing_id
// file src/zgossip_msg.h line 96
void zgossip_msg_set_routing_id(struct _zgossip_msg_t *self, struct _zframe_t *routing_id);
// zgossip_msg_set_ttl
// file src/zgossip_msg.c line 581
void zgossip_msg_set_ttl(struct _zgossip_msg_t *self, unsigned int ttl);
// zgossip_msg_set_value
// file src/zgossip_msg.h line 116
void zgossip_msg_set_value(struct _zgossip_msg_t *self, const char *value);
// zgossip_msg_test
// file src/zgossip_msg.c line 593
signed int zgossip_msg_test(_Bool verbose);
// zgossip_msg_ttl
// file src/zgossip_msg.c line 574
unsigned int zgossip_msg_ttl(struct _zgossip_msg_t *self);
// zgossip_msg_value
// file src/zgossip_msg.h line 114
const char * zgossip_msg_value(struct _zgossip_msg_t *self);
// zgossip_test
// file src/zgossip.c line 421
void zgossip_test(_Bool verbose);
// zhash_autofree
// file src/zhash.c line 777
void zhash_autofree(struct _zhash_t *self);
// zhash_comment
// file src/zhash.c line 503
void zhash_comment(struct _zhash_t *self, const char *format, ...);
// zhash_cursor
// file src/zhash.c line 490
const char * zhash_cursor(struct _zhash_t *self);
// zhash_delete
// file src/zhash.c line 297
void zhash_delete(struct _zhash_t *self, const char *key);
// zhash_destroy
// file src/zhash.c line 90
void zhash_destroy(struct _zhash_t **self_p);
// zhash_dup
// file src/zhash.c line 390
struct _zhash_t * zhash_dup(struct _zhash_t *self);
// zhash_first
// file src/zhash.c line 442
void * zhash_first(struct _zhash_t *self);
// zhash_foreach
// file src/zhash.c line 791
signed int zhash_foreach(struct _zhash_t *self, signed int (*callback)(const char *, void *, void *), void *argument);
// zhash_foreach::callback_object
//
signed int callback_object(const char *, void *, void *);
// zhash_freefn
// file src/zhash.c line 357
void * zhash_freefn(struct _zhash_t *self, const char *key, void (*free_fn)(void *));
// zhash_freefn::free_fn_object
//
void free_fn_object(void *);
// zhash_insert
// file src/zhash.c line 156
signed int zhash_insert(struct _zhash_t *self, const char *key, void *value);
// zhash_keys
// file src/zhash.c line 415
struct _zlist_t * zhash_keys(struct _zhash_t *self);
// zhash_load
// file src/zhash.c line 566
signed int zhash_load(struct _zhash_t *self, const char *filename);
// zhash_lookup
// file src/zhash.c line 312
void * zhash_lookup(struct _zhash_t *self, const char *key);
// zhash_new
// file src/zhash.c line 73
struct _zhash_t * zhash_new(void);
// zhash_next
// file src/zhash.c line 461
void * zhash_next(struct _zhash_t *self);
// zhash_pack
// file src/zhash.c line 672
struct _zframe_t * zhash_pack(struct _zhash_t *self);
// zhash_refresh
// file src/zhash.c line 624
signed int zhash_refresh(struct _zhash_t *self);
// zhash_rename
// file src/zhash.c line 330
signed int zhash_rename(struct _zhash_t *self, const char *old_key, const char *new_key);
// zhash_save
// file src/zhash.c line 531
signed int zhash_save(struct _zhash_t *self, const char *filename);
// zhash_size
// file src/zhash.c line 376
unsigned long int zhash_size(struct _zhash_t *self);
// zhash_test
// file src/zhash.c line 816
void zhash_test(signed int verbose);
// zhash_unpack
// file src/zhash.c line 724
struct _zhash_t * zhash_unpack(struct _zframe_t *frame);
// zhash_update
// file src/zhash.c line 269
void zhash_update(struct _zhash_t *self, const char *key, void *value);
// zhashx_autofree
// file src/zhashx.c line 1054
void zhashx_autofree(struct _zhashx_t *self);
// zhashx_comment
// file src/zhashx.c line 633
void zhashx_comment(struct _zhashx_t *self, const char *format, ...);
// zhashx_cursor
// file src/zhashx.c line 619
const void * zhashx_cursor(struct _zhashx_t *self);
// zhashx_delete
// file src/zhashx.c line 379
void zhashx_delete(struct _zhashx_t *self, const void *key);
// zhashx_destroy
// file src/../include/zhashx.h line 55
void zhashx_destroy(struct _zhashx_t **self_p);
// zhashx_dup
// file src/zhashx.c line 917
struct _zhashx_t * zhashx_dup(struct _zhashx_t *self);
// zhashx_dup_v2
// file src/zhashx.c line 1024
struct _zhashx_t * zhashx_dup_v2(struct _zhashx_t *self);
// zhashx_first
// file src/../include/zhashx.h line 122
void * zhashx_first(struct _zhashx_t *self);
// zhashx_foreach
// file src/zhashx.c line 1069
signed int zhashx_foreach(struct _zhashx_t *self, signed int (*callback)(const char *, void *, void *), void *argument);
// zhashx_foreach::callback_object
//
signed int callback_object(const char *, void *, void *);
// zhashx_freefn
// file src/../include/zhashx.h line 97
void * zhashx_freefn(struct _zhashx_t *self, const void *key, void (*free_fn)(void *));
// zhashx_freefn::free_fn_object
//
void free_fn_object(void *);
// zhashx_insert
// file src/../include/zhashx.h line 61
signed int zhashx_insert(struct _zhashx_t *self, const void *key, void *value);
// zhashx_keys
// file src/zhashx.c line 509
struct _zlistx_t * zhashx_keys(struct _zhashx_t *self);
// zhashx_load
// file src/../include/zhashx.h line 156
signed int zhashx_load(struct _zhashx_t *self, const char *filename);
// zhashx_lookup
// file src/../include/zhashx.h line 84
void * zhashx_lookup(struct _zhashx_t *self, const void *key);
// zhashx_new
// file src/../include/zhashx.h line 51
struct _zhashx_t * zhashx_new(void);
// zhashx_next
// file src/../include/zhashx.h line 131
void * zhashx_next(struct _zhashx_t *self);
// zhashx_pack
// file src/zhashx.c line 803
struct _zframe_t * zhashx_pack(struct _zhashx_t *self);
// zhashx_purge
// file src/../include/zhashx.h line 80
void zhashx_purge(struct _zhashx_t *self);
// zhashx_refresh
// file src/../include/zhashx.h line 163
signed int zhashx_refresh(struct _zhashx_t *self);
// zhashx_rename
// file src/zhashx.c line 442
signed int zhashx_rename(struct _zhashx_t *self, const void *old_key, const void *new_key);
// zhashx_save
// file src/zhashx.c line 660
signed int zhashx_save(struct _zhashx_t *self, const char *filename);
// zhashx_set_destructor
// file src/../include/zhashx.h line 208
void zhashx_set_destructor(struct _zhashx_t *self, void (*destructor)(void **));
// zhashx_set_destructor::destructor_object
//
void destructor_object(void **);
// zhashx_set_duplicator
// file src/zhashx.c line 960
void zhashx_set_duplicator(struct _zhashx_t *self, void * (*duplicator)(const void *));
// zhashx_set_duplicator::duplicator_object
//
void * duplicator_object(const void *);
// zhashx_set_key_comparator
// file src/zhashx.c line 996
void zhashx_set_key_comparator(struct _zhashx_t *self, signed int (*comparator)(const void *, const void *));
// zhashx_set_key_comparator::comparator_object
//
signed int comparator_object(const void *, const void *);
// zhashx_set_key_destructor
// file src/zhashx.c line 972
void zhashx_set_key_destructor(struct _zhashx_t *self, void (*destructor)(void **));
// zhashx_set_key_destructor::destructor_object
//
void destructor_object(void **);
// zhashx_set_key_duplicator
// file src/zhashx.c line 984
void zhashx_set_key_duplicator(struct _zhashx_t *self, void * (*duplicator)(const void *));
// zhashx_set_key_duplicator::duplicator_object
//
void * duplicator_object(const void *);
// zhashx_set_key_hasher
// file src/zhashx.c line 1009
void zhashx_set_key_hasher(struct _zhashx_t *self, unsigned long int (*hasher)(const void *));
// zhashx_set_key_hasher::hasher_object
//
unsigned long int hasher_object(const void *);
// zhashx_size
// file src/../include/zhashx.h line 101
unsigned long int zhashx_size(struct _zhashx_t *self);
// zhashx_test
// file src/zhashx.c line 1095
void zhashx_test(signed int verbose);
// zhashx_unpack
// file src/zhashx.c line 856
struct _zhashx_t * zhashx_unpack(struct _zframe_t *frame);
// zhashx_update
// file src/../include/zhashx.h line 69
void zhashx_update(struct _zhashx_t *self, const void *key, void *value);
// zhashx_values
// file src/zhashx.c line 537
struct _zlistx_t * zhashx_values(struct _zhashx_t *self);
// ziflist_address
// file src/../include/ziflist.h line 54
const char * ziflist_address(struct _ziflist_t *self);
// ziflist_broadcast
// file src/../include/ziflist.h line 58
const char * ziflist_broadcast(struct _ziflist_t *self);
// ziflist_destroy
// file src/../include/ziflist.h line 30
void ziflist_destroy(struct _ziflist_t **self_p);
// ziflist_first
// file src/../include/ziflist.h line 46
const char * ziflist_first(struct _ziflist_t *self);
// ziflist_netmask
// file src/ziflist.c line 353
const char * ziflist_netmask(struct _ziflist_t *self);
// ziflist_new
// file src/../include/ziflist.h line 26
struct _ziflist_t * ziflist_new(void);
// ziflist_next
// file src/../include/ziflist.h line 50
const char * ziflist_next(struct _ziflist_t *self);
// ziflist_print
// file src/ziflist.c line 99
void ziflist_print(struct _ziflist_t *self);
// ziflist_reload
// file src/ziflist.c line 145
void ziflist_reload(struct _ziflist_t *self);
// ziflist_size
// file src/ziflist.c line 282
unsigned long int ziflist_size(struct _ziflist_t *self);
// ziflist_test
// file src/ziflist.c line 368
void ziflist_test(_Bool verbose);
// zlist_append
// file src/zlist.c line 173
signed int zlist_append(struct _zlist_t *self, void *item);
// zlist_autofree
// file src/zlist.c line 472
void zlist_autofree(struct _zlist_t *self);
// zlist_comparefn
// file src/zlist.c line 430
void zlist_comparefn(struct _zlist_t *self, signed int (*fn)(void *, void *));
// zlist_comparefn::fn_object
//
signed int fn_object(void *, void *);
// zlist_destroy
// file src/zlist.c line 66
void zlist_destroy(struct _zlist_t **self_p);
// zlist_dup
// file src/zlist.c line 328
struct _zlist_t * zlist_dup(struct _zlist_t *self);
// zlist_exists
// file src/zlist.c line 257
_Bool zlist_exists(struct _zlist_t *self, void *item);
// zlist_first
// file src/zlist.c line 83
void * zlist_first(struct _zlist_t *self);
// zlist_freefn
// file src/zlist.c line 445
void * zlist_freefn(struct _zlist_t *self, void *item, void (*fn)(void *), _Bool at_tail);
// zlist_freefn::fn_object
//
void fn_object(void *);
// zlist_head
// file src/zlist.c line 134
void * zlist_head(struct _zlist_t *self);
// zlist_item
// file src/zlist.c line 158
void * zlist_item(struct _zlist_t *self);
// zlist_last
// file src/zlist.c line 118
void * zlist_last(struct _zlist_t *self);
// zlist_new
// file src/zlist.c line 55
struct _zlist_t * zlist_new(void);
// zlist_next
// file src/zlist.c line 99
void * zlist_next(struct _zlist_t *self);
// zlist_pop
// file src/zlist.c line 234
void * zlist_pop(struct _zlist_t *self);
// zlist_purge
// file src/zlist.c line 351
void zlist_purge(struct _zlist_t *self);
// zlist_push
// file src/zlist.c line 207
signed int zlist_push(struct _zlist_t *self, void *item);
// zlist_remove
// file src/zlist.c line 285
void zlist_remove(struct _zlist_t *self, void *item);
// zlist_size
// file src/zlist.c line 377
unsigned long int zlist_size(struct _zlist_t *self);
// zlist_sort
// file src/zlist.c line 388
void zlist_sort(struct _zlist_t *self, signed int (*compare)(void *, void *));
// zlist_sort::compare_object
//
signed int compare_object(void *, void *);
// zlist_tail
// file src/zlist.c line 146
void * zlist_tail(struct _zlist_t *self);
// zlist_test
// file src/zlist.c line 497
void zlist_test(signed int verbose);
// zlistx_add_end
// file src/../include/zlistx.h line 42
void * zlistx_add_end(struct _zlistx_t *self, void *item);
// zlistx_add_start
// file src/zlistx.c line 150
void * zlistx_add_start(struct _zlistx_t *self, void *item);
// zlistx_cursor
// file src/zlistx.c line 284
void * zlistx_cursor(struct _zlistx_t *self);
// zlistx_delete
// file src/zlistx.c line 387
signed int zlistx_delete(struct _zlistx_t *self, void *handle);
// zlistx_destroy
// file src/../include/zlistx.h line 30
void zlistx_destroy(struct _zlistx_t **self_p);
// zlistx_detach
// file src/zlistx.c line 338
void * zlistx_detach(struct _zlistx_t *self, void *handle);
// zlistx_detach_cur
// file src/zlistx.c line 373
void * zlistx_detach_cur(struct _zlistx_t *self);
// zlistx_dup
// file src/zlistx.c line 567
struct _zlistx_t * zlistx_dup(struct _zlistx_t *self);
// zlistx_find
// file src/zlistx.c line 312
void * zlistx_find(struct _zlistx_t *self, void *item);
// zlistx_first
// file src/../include/zlistx.h line 51
void * zlistx_first(struct _zlistx_t *self);
// zlistx_handle_item
// file src/zlistx.c line 295
void * zlistx_handle_item(void *handle);
// zlistx_insert
// file src/zlistx.c line 503
void * zlistx_insert(struct _zlistx_t *self, void *item, _Bool low_value);
// zlistx_item
// file src/../include/zlistx.h line 73
void * zlistx_item(struct _zlistx_t *self);
// zlistx_last
// file src/zlistx.c line 259
void * zlistx_last(struct _zlistx_t *self);
// zlistx_move_end
// file src/zlistx.c line 425
void zlistx_move_end(struct _zlistx_t *self, void *handle);
// zlistx_move_start
// file src/zlistx.c line 405
void zlistx_move_start(struct _zlistx_t *self, void *handle);
// zlistx_new
// file src/../include/zlistx.h line 25
struct _zlistx_t * zlistx_new(void);
// zlistx_next
// file src/../include/zlistx.h line 57
void * zlistx_next(struct _zlistx_t *self);
// zlistx_prev
// file src/zlistx.c line 246
void * zlistx_prev(struct _zlistx_t *self);
// zlistx_purge
// file src/../include/zlistx.h line 125
void zlistx_purge(struct _zlistx_t *self);
// zlistx_reorder
// file src/zlistx.c line 528
void zlistx_reorder(struct _zlistx_t *self, void *handle, _Bool low_value);
// zlistx_set_comparator
// file src/zlistx.c line 622
void zlistx_set_comparator(struct _zlistx_t *self, signed int (*comparator)(const void *, const void *));
// zlistx_set_comparator::comparator_object
//
signed int comparator_object(const void *, const void *);
// zlistx_set_destructor
// file src/../include/zlistx.h line 158
void zlistx_set_destructor(struct _zlistx_t *self, void (*destructor)(void **));
// zlistx_set_destructor::destructor_object
//
void destructor_object(void **);
// zlistx_set_duplicator
// file src/../include/zlistx.h line 163
void zlistx_set_duplicator(struct _zlistx_t *self, void * (*duplicator)(const void *));
// zlistx_set_duplicator::duplicator_object
//
void * duplicator_object(const void *);
// zlistx_size
// file src/../include/zlistx.h line 46
unsigned long int zlistx_size(struct _zlistx_t *self);
// zlistx_sort
// file src/zlistx.c line 460
void zlistx_sort(struct _zlistx_t *self);
// zlistx_test
// file src/zlistx.c line 633
void zlistx_test(signed int verbose);
// zloop_destroy
// file src/../include/zloop.h line 42
void zloop_destroy(struct _zloop_t **self_p);
// zloop_ignore_interrupts
// file src/zloop.c line 705
void zloop_ignore_interrupts(struct _zloop_t *self);
// zloop_new
// file src/../include/zloop.h line 38
struct _zloop_t * zloop_new(void);
// zloop_poller
// file src/zloop.c line 467
signed int zloop_poller(struct _zloop_t *self, struct zmq_pollitem_t *item, signed int (*handler)(struct _zloop_t *, struct zmq_pollitem_t *, void *), void *arg);
// zloop_poller::handler_object
//
signed int handler_object(struct _zloop_t *, struct zmq_pollitem_t *, void *);
// zloop_poller_end
// file src/zloop.c line 500
void zloop_poller_end(struct _zloop_t *self, struct zmq_pollitem_t *item);
// zloop_poller_set_tolerant
// file src/zloop.c line 534
void zloop_poller_set_tolerant(struct _zloop_t *self, struct zmq_pollitem_t *item);
// zloop_reader
// file src/../include/zloop.h line 49
signed int zloop_reader(struct _zloop_t *self, struct _zsock_t *sock, signed int (*handler)(struct _zloop_t *, struct _zsock_t *, void *), void *arg);
// zloop_reader::handler_object
//
signed int handler_object(struct _zloop_t *, struct _zsock_t *, void *);
// zloop_reader_end
// file src/../include/zloop.h line 54
void zloop_reader_end(struct _zloop_t *self, struct _zsock_t *sock);
// zloop_reader_set_tolerant
// file src/../include/zloop.h line 59
void zloop_reader_set_tolerant(struct _zloop_t *self, struct _zsock_t *sock);
// zloop_set_max_timers
// file src/zloop.c line 720
void zloop_set_max_timers(struct _zloop_t *self, unsigned long int max_timers);
// zloop_set_ticket_delay
// file src/../include/zloop.h line 118
void zloop_set_ticket_delay(struct _zloop_t *self, unsigned long int ticket_delay);
// zloop_set_verbose
// file src/zloop.c line 693
void zloop_set_verbose(struct _zloop_t *self, _Bool verbose);
// zloop_start
// file src/../include/zloop.h line 137
signed int zloop_start(struct _zloop_t *self);
// zloop_test
// file src/zloop.c line 908
void zloop_test(_Bool verbose);
// zloop_ticket
// file src/../include/zloop.h line 102
void * zloop_ticket(struct _zloop_t *self, signed int (*handler)(struct _zloop_t *, signed int, void *), void *arg);
// zloop_ticket::handler_object
//
signed int handler_object(struct _zloop_t *, signed int, void *);
// zloop_ticket_delete
// file src/../include/zloop.h line 113
void zloop_ticket_delete(struct _zloop_t *self, void *handle);
// zloop_ticket_reset
// file src/../include/zloop.h line 107
void zloop_ticket_reset(struct _zloop_t *self, void *handle);
// zloop_timer
// file src/../include/zloop.h line 85
signed int zloop_timer(struct _zloop_t *self, unsigned long int delay, unsigned long int times, signed int (*handler)(struct _zloop_t *, signed int, void *), void *arg);
// zloop_timer::handler_object
//
signed int handler_object(struct _zloop_t *, signed int, void *);
// zloop_timer_end
// file src/../include/zloop.h line 90
signed int zloop_timer_end(struct _zloop_t *self, signed int timer_id);
// zmonitor
// file src/zmonitor.c line 285
void zmonitor(struct _zsock_t *pipe, void *sock);
// zmonitor_destroy
// file src/zmonitor_v2.c line 87
void zmonitor_destroy(struct _zmonitor_t **self_p);
// zmonitor_new
// file src/zmonitor_v2.c line 50
struct _zmonitor_t * zmonitor_new(struct _zctx_t *ctx, void *socket, signed int events);
// zmonitor_recv
// file src/zmonitor_v2.c line 111
struct _zmsg_t * zmonitor_recv(struct _zmonitor_t *self);
// zmonitor_set_verbose
// file src/zmonitor_v2.c line 133
void zmonitor_set_verbose(struct _zmonitor_t *self, _Bool verbose);
// zmonitor_socket
// file src/zmonitor_v2.c line 122
void * zmonitor_socket(struct _zmonitor_t *self);
// zmonitor_test
// file src/zmonitor.c line 324
void zmonitor_test(_Bool verbose);
// zmonitor_v2_test
// file src/zmonitor_v2.c line 346
void zmonitor_v2_test(_Bool verbose);
// zmq_bind
// file /usr/include/zmq.h line 349
signed int zmq_bind(void *, const char *);
// zmq_close
// file /usr/include/zmq.h line 344
signed int zmq_close(void *);
// zmq_connect
// file /usr/include/zmq.h line 350
signed int zmq_connect(void *, const char *);
// zmq_ctx_get
// file /usr/include/zmq.h line 186
signed int zmq_ctx_get(void *, signed int);
// zmq_ctx_set
// file /usr/include/zmq.h line 185
signed int zmq_ctx_set(void *, signed int, signed int);
// zmq_curve_keypair
// file /usr/include/zmq.h line 420
signed int zmq_curve_keypair(char *, char *);
// zmq_disconnect
// file /usr/include/zmq.h line 352
signed int zmq_disconnect(void *, const char *);
// zmq_errno
// file /usr/include/zmq.h line 156
signed int zmq_errno(void);
// zmq_getsockopt
// file /usr/include/zmq.h line 347
signed int zmq_getsockopt(void *, signed int, void *, unsigned long int *);
// zmq_has
// file /usr/include/zmq.h line 395
signed int zmq_has(const char *);
// zmq_init
// file /usr/include/zmq.h line 189
void * zmq_init(signed int);
// zmq_msg_close
// file /usr/include/zmq.h line 208
signed int zmq_msg_close(struct zmq_msg_t *);
// zmq_msg_copy
// file /usr/include/zmq.h line 210
signed int zmq_msg_copy(struct zmq_msg_t *, struct zmq_msg_t *);
// zmq_msg_data
// file /usr/include/zmq.h line 211
void * zmq_msg_data(struct zmq_msg_t *);
// zmq_msg_init
// file /usr/include/zmq.h line 202
signed int zmq_msg_init(struct zmq_msg_t *);
// zmq_msg_init_size
// file /usr/include/zmq.h line 203
signed int zmq_msg_init_size(struct zmq_msg_t *, unsigned long int);
// zmq_msg_recv
// file /usr/include/zmq.h line 207
signed int zmq_msg_recv(struct zmq_msg_t *, void *, signed int);
// zmq_msg_send
// file /usr/include/zmq.h line 206
signed int zmq_msg_send(struct zmq_msg_t *, void *, signed int);
// zmq_msg_size
// file /usr/include/zmq.h line 212
unsigned long int zmq_msg_size(struct zmq_msg_t *);
// zmq_poll
// file /usr/include/zmq.h line 381
signed int zmq_poll(struct zmq_pollitem_t *, signed int, signed long int);
// zmq_recvmsg
// file /usr/include/zmq.h line 405
signed int zmq_recvmsg(void *, struct zmq_msg_t *, signed int);
// zmq_sendmsg
// file /usr/include/zmq.h line 404
signed int zmq_sendmsg(void *, struct zmq_msg_t *, signed int);
// zmq_setsockopt
// file /usr/include/zmq.h line 345
signed int zmq_setsockopt(void *, signed int, const void *, unsigned long int);
// zmq_socket
// file /usr/include/zmq.h line 343
void * zmq_socket(void *, signed int);
// zmq_socket_monitor
// file /usr/include/zmq.h line 356
signed int zmq_socket_monitor(void *, const char *, signed int);
// zmq_strerror
// file /usr/include/zmq.h line 159
const char * zmq_strerror(signed int);
// zmq_term
// file /usr/include/zmq.h line 190
signed int zmq_term(void *);
// zmq_unbind
// file /usr/include/zmq.h line 351
signed int zmq_unbind(void *, const char *);
// zmq_z85_decode
// file /usr/include/zmq.h line 416
unsigned char * zmq_z85_decode(unsigned char *, const char *);
// zmq_z85_encode
// file /usr/include/zmq.h line 413
char * zmq_z85_encode(char *, const unsigned char *, unsigned long int);
// zmsg_add
// file src/zmsg.c line 912
signed int zmsg_add(struct _zmsg_t *self, struct _zframe_t *frame);
// zmsg_addmem
// file src/zmsg.c line 288
signed int zmsg_addmem(struct _zmsg_t *self, const void *src, unsigned long int size);
// zmsg_addmsg
// file src/zmsg.c line 434
signed int zmsg_addmsg(struct _zmsg_t *self, struct _zmsg_t **msg_p);
// zmsg_addstr
// file src/../include/zmsg.h line 101
signed int zmsg_addstr(struct _zmsg_t *self, const char *string);
// zmsg_addstrf
// file src/../include/zmsg.h line 111
signed int zmsg_addstrf(struct _zmsg_t *self, const char *format, ...);
// zmsg_append
// file src/../include/zmsg.h line 76
signed int zmsg_append(struct _zmsg_t *self, struct _zframe_t **frame_p);
// zmsg_content_size
// file src/zmsg.c line 198
unsigned long int zmsg_content_size(struct _zmsg_t *self);
// zmsg_decode
// file src/zmsg.c line 663
struct _zmsg_t * zmsg_decode(const unsigned char *buffer, unsigned long int buffer_size);
// zmsg_destroy
// file src/../include/zmsg.h line 30
void zmsg_destroy(struct _zmsg_t **self_p);
// zmsg_dup
// file src/zmsg.c line 710
struct _zmsg_t * zmsg_dup(struct _zmsg_t *self);
// zmsg_encode
// file src/zmsg.c line 611
unsigned long int zmsg_encode(struct _zmsg_t *self, unsigned char **buffer);
// zmsg_eq
// file src/zmsg.c line 760
_Bool zmsg_eq(struct _zmsg_t *self, struct _zmsg_t *other);
// zmsg_first
// file src/zmsg.c line 495
struct _zframe_t * zmsg_first(struct _zmsg_t *self);
// zmsg_fprint
// file src/zmsg.c line 928
void zmsg_fprint(struct _zmsg_t *self, struct _IO_FILE *file);
// zmsg_is
// file src/zmsg.c line 817
_Bool zmsg_is(void *self);
// zmsg_last
// file src/zmsg.c line 520
struct _zframe_t * zmsg_last(struct _zmsg_t *self);
// zmsg_load
// file src/zmsg.c line 561
struct _zmsg_t * zmsg_load(struct _zmsg_t *self, struct _IO_FILE *file);
// zmsg_new
// file src/../include/zmsg.h line 26
struct _zmsg_t * zmsg_new(void);
// zmsg_new_signal
// file src/zmsg.c line 786
struct _zmsg_t * zmsg_new_signal(unsigned char status);
// zmsg_next
// file src/zmsg.c line 508
struct _zframe_t * zmsg_next(struct _zmsg_t *self);
// zmsg_pop
// file src/../include/zmsg.h line 81
struct _zframe_t * zmsg_pop(struct _zmsg_t *self);
// zmsg_popmsg
// file src/zmsg.c line 459
struct _zmsg_t * zmsg_popmsg(struct _zmsg_t *self);
// zmsg_popstr
// file src/../include/zmsg.h line 117
char * zmsg_popstr(struct _zmsg_t *self);
// zmsg_prepend
// file src/zmsg.c line 214
signed int zmsg_prepend(struct _zmsg_t *self, struct _zframe_t **frame_p);
// zmsg_print
// file src/zmsg.c line 737
void zmsg_print(struct _zmsg_t *self);
// zmsg_push
// file src/zmsg.c line 896
signed int zmsg_push(struct _zmsg_t *self, struct _zframe_t *frame);
// zmsg_pushmem
// file src/zmsg.c line 269
signed int zmsg_pushmem(struct _zmsg_t *self, const void *src, unsigned long int size);
// zmsg_pushstr
// file src/zmsg.c line 308
signed int zmsg_pushstr(struct _zmsg_t *self, const char *string);
// zmsg_pushstrf
// file src/zmsg.c line 352
signed int zmsg_pushstrf(struct _zmsg_t *self, const char *format, ...);
// zmsg_recv
// file src/../include/zmsg.h line 38
struct _zmsg_t * zmsg_recv(void *source);
// zmsg_recv_nowait
// file src/zmsg.c line 849
struct _zmsg_t * zmsg_recv_nowait(void *source);
// zmsg_remove
// file src/zmsg.c line 480
void zmsg_remove(struct _zmsg_t *self, struct _zframe_t *frame);
// zmsg_save
// file src/zmsg.c line 536
signed int zmsg_save(struct _zmsg_t *self, struct _IO_FILE *file);
// zmsg_send
// file src/../include/zmsg.h line 45
signed int zmsg_send(struct _zmsg_t **self_p, void *dest);
// zmsg_sendm
// file src/zmsg.c line 158
signed int zmsg_sendm(struct _zmsg_t **self_p, void *dest);
// zmsg_signal
// file src/zmsg.c line 800
signed int zmsg_signal(struct _zmsg_t *self);
// zmsg_size
// file src/zmsg.c line 185
unsigned long int zmsg_size(struct _zmsg_t *self);
// zmsg_test
// file src/zmsg.c line 951
void zmsg_test(_Bool verbose);
// zmsg_unwrap
// file src/zmsg.c line 830
struct _zframe_t * zmsg_unwrap(struct _zmsg_t *self);
// zmsg_wrap
// file src/zmsg.c line 880
void zmsg_wrap(struct _zmsg_t *self, struct _zframe_t *frame);
// zmutex_destroy
// file src/../include/zmutex.h line 28
void zmutex_destroy(struct _zmutex_t **self_p);
// zmutex_lock
// file src/../include/zmutex.h line 32
void zmutex_lock(struct _zmutex_t *self);
// zmutex_new
// file src/../include/zmutex.h line 24
struct _zmutex_t * zmutex_new(void);
// zmutex_test
// file src/zmutex.c line 135
void zmutex_test(_Bool verbose);
// zmutex_try_lock
// file src/zmutex.c line 117
signed int zmutex_try_lock(struct _zmutex_t *self);
// zmutex_unlock
// file src/../include/zmutex.h line 36
void zmutex_unlock(struct _zmutex_t *self);
// zpoller_add
// file src/../include/zpoller.h line 34
signed int zpoller_add(struct _zpoller_t *self, void *reader);
// zpoller_destroy
// file src/../include/zpoller.h line 29
void zpoller_destroy(struct _zpoller_t **self_p);
// zpoller_expired
// file src/zpoller.c line 210
_Bool zpoller_expired(struct _zpoller_t *self);
// zpoller_ignore_interrupts
// file src/zpoller.c line 234
void zpoller_ignore_interrupts(struct _zpoller_t *self);
// zpoller_new
// file src/../include/zpoller.h line 25
struct _zpoller_t * zpoller_new(void *reader, ...);
// zpoller_remove
// file src/zpoller.c line 112
signed int zpoller_remove(struct _zpoller_t *self, void *reader);
// zpoller_terminated
// file src/../include/zpoller.h line 62
_Bool zpoller_terminated(struct _zpoller_t *self);
// zpoller_test
// file src/zpoller.c line 244
void zpoller_test(_Bool verbose);
// zpoller_wait
// file src/../include/zpoller.h line 52
void * zpoller_wait(struct _zpoller_t *self, signed int timeout);
// zproxy
// file src/zproxy.c line 220
void zproxy(struct _zsock_t *pipe, void *unused);
// zproxy_capture
// file src/zproxy_v2.c line 96
void zproxy_capture(struct _zproxy_t *self, const char *endpoint);
// zproxy_destroy
// file src/zproxy_v2.c line 75
void zproxy_destroy(struct _zproxy_t **self_p);
// zproxy_new
// file src/zproxy_v2.c line 51
struct _zproxy_t * zproxy_new(struct _zctx_t *ctx, void *frontend, void *backend);
// zproxy_pause
// file src/zproxy_v2.c line 112
void zproxy_pause(struct _zproxy_t *self);
// zproxy_resume
// file src/zproxy_v2.c line 124
void zproxy_resume(struct _zproxy_t *self);
// zproxy_test
// file src/zproxy.c line 249
void zproxy_test(_Bool verbose);
// zproxy_v2_test
// file src/zproxy_v2.c line 234
void zproxy_v2_test(_Bool verbose);
// zrex_destroy
// file src/../include/zrex.h line 31
void zrex_destroy(struct _zrex_t **self_p);
// zrex_eq
// file src/zrex.c line 179
_Bool zrex_eq(struct _zrex_t *self, const char *text, const char *expression);
// zrex_fetch
// file src/zrex.c line 238
signed int zrex_fetch(struct _zrex_t *self, const char **string_p, ...);
// zrex_hit
// file src/zrex.c line 220
const char * zrex_hit(struct _zrex_t *self, unsigned int index);
// zrex_hits
// file src/zrex.c line 206
signed int zrex_hits(struct _zrex_t *self);
// zrex_matches
// file src/../include/zrex.h line 44
_Bool zrex_matches(struct _zrex_t *self, const char *text);
// zrex_new
// file src/../include/zrex.h line 27
struct _zrex_t * zrex_new(const char *expression);
// zrex_strerror
// file src/zrex.c line 120
const char * zrex_strerror(struct _zrex_t *self);
// zrex_test
// file src/zrex.c line 257
void zrex_test(_Bool verbose);
// zrex_valid
// file src/zrex.c line 109
_Bool zrex_valid(struct _zrex_t *self);
// zsock_affinity
// file src/zsock_option.c line 882
signed int zsock_affinity(void *self);
// zsock_attach
// file src/../include/zsock.h line 156
signed int zsock_attach(struct _zsock_t *self, const char *endpoints, _Bool serverish);
// zsock_backlog
// file src/zsock_option.c line 1224
signed int zsock_backlog(void *self);
// zsock_bind
// file src/../include/zsock.h line 126
signed int zsock_bind(struct _zsock_t *self, const char *format, ...);
// zsock_brecv
// file src/zsock.c line 1267
signed int zsock_brecv(void *selfish, const char *picture, ...);
// zsock_bsend
// file src/zsock.c line 1075
signed int zsock_bsend(void *self, const char *picture, ...);
// zsock_connect
// file src/../include/zsock.h line 141
signed int zsock_connect(struct _zsock_t *self, const char *format, ...);
// zsock_curve_publickey
// file src/zsock_option.c line 405
char * zsock_curve_publickey(void *self);
// zsock_curve_secretkey
// file src/zsock_option.c line 452
char * zsock_curve_secretkey(void *self);
// zsock_curve_server
// file src/zsock_option.c line 358
signed int zsock_curve_server(void *self);
// zsock_curve_serverkey
// file src/zsock_option.c line 499
char * zsock_curve_serverkey(void *self);
// zsock_destroy
// file src/../include/zsock.h line 42
void zsock_destroy(struct _zsock_t **self_p);
// zsock_destroy_checked
// file src/../include/zsock.h line 336
void zsock_destroy_checked(struct _zsock_t **self_p, const char *filename, unsigned long int line_nbr);
// zsock_disconnect
// file src/zsock.c line 530
signed int zsock_disconnect(struct _zsock_t *self, const char *format, ...);
// zsock_endpoint
// file src/zsock.c line 454
const char * zsock_endpoint(struct _zsock_t *self);
// zsock_events
// file src/../include/zsock_option.h line 71
signed int zsock_events(void *self);
// zsock_fd
// file src/../include/zsock_option.h line 70
signed int zsock_fd(void *self);
// zsock_flush
// file src/zsock.c line 1478
void zsock_flush(void *self);
// zsock_gssapi_plaintext
// file src/zsock_option.c line 565
signed int zsock_gssapi_plaintext(void *self);
// zsock_gssapi_principal
// file src/zsock_option.c line 598
char * zsock_gssapi_principal(void *self);
// zsock_gssapi_server
// file src/zsock_option.c line 532
signed int zsock_gssapi_server(void *self);
// zsock_gssapi_service_principal
// file src/zsock_option.c line 631
char * zsock_gssapi_service_principal(void *self);
// zsock_identity
// file src/zsock_option.c line 960
char * zsock_identity(void *self);
// zsock_immediate
// file src/zsock_option.c line 697
signed int zsock_immediate(void *self);
// zsock_ipv4only
// file src/zsock_option.c line 749
signed int zsock_ipv4only(void *self);
// zsock_ipv6
// file src/zsock_option.c line 664
signed int zsock_ipv6(void *self);
// zsock_is
// file src/../include/zsock.h line 297
_Bool zsock_is(void *self);
// zsock_last_endpoint
// file src/zsock_option.c line 1613
char * zsock_last_endpoint(void *self);
// zsock_linger
// file src/zsock_option.c line 1125
signed int zsock_linger(void *self);
// zsock_maxmsgsize
// file src/zsock_option.c line 1258
signed int zsock_maxmsgsize(void *self);
// zsock_mechanism
// file src/zsock_option.c line 226
signed int zsock_mechanism(void *self);
// zsock_multicast_hops
// file src/zsock_option.c line 1291
signed int zsock_multicast_hops(void *self);
// zsock_new
// file src/zsock.c line 73
struct _zsock_t * zsock_new(signed int type);
// zsock_new_checked
// file src/../include/zsock.h line 333
struct _zsock_t * zsock_new_checked(signed int type, const char *filename, unsigned long int line_nbr);
// zsock_new_dealer
// file src/zsock.c line 207
struct _zsock_t * zsock_new_dealer(const char *endpoints);
// zsock_new_dealer_checked
// file src/zsock.c line 197
struct _zsock_t * zsock_new_dealer_checked(const char *endpoints, const char *filename, unsigned long int line_nbr);
// zsock_new_pair
// file src/zsock.c line 329
struct _zsock_t * zsock_new_pair(const char *endpoints);
// zsock_new_pair_checked
// file src/../include/zsock.h line 369
struct _zsock_t * zsock_new_pair_checked(const char *endpoints, const char *filename, unsigned long int line_nbr);
// zsock_new_pub
// file src/zsock.c line 125
struct _zsock_t * zsock_new_pub(const char *endpoints);
// zsock_new_pub_checked
// file src/zsock.c line 115
struct _zsock_t * zsock_new_pub_checked(const char *endpoints, const char *filename, unsigned long int line_nbr);
// zsock_new_pull
// file src/zsock.c line 264
struct _zsock_t * zsock_new_pull(const char *endpoints);
// zsock_new_pull_checked
// file src/../include/zsock.h line 360
struct _zsock_t * zsock_new_pull_checked(const char *endpoints, const char *filename, unsigned long int line_nbr);
// zsock_new_push
// file src/zsock.c line 245
struct _zsock_t * zsock_new_push(const char *endpoints);
// zsock_new_push_checked
// file src/../include/zsock.h line 357
struct _zsock_t * zsock_new_push_checked(const char *endpoints, const char *filename, unsigned long int line_nbr);
// zsock_new_rep
// file src/zsock.c line 188
struct _zsock_t * zsock_new_rep(const char *endpoints);
// zsock_new_rep_checked
// file src/zsock.c line 178
struct _zsock_t * zsock_new_rep_checked(const char *endpoints, const char *filename, unsigned long int line_nbr);
// zsock_new_req
// file src/zsock.c line 169
struct _zsock_t * zsock_new_req(const char *endpoints);
// zsock_new_req_checked
// file src/zsock.c line 159
struct _zsock_t * zsock_new_req_checked(const char *endpoints, const char *filename, unsigned long int line_nbr);
// zsock_new_router
// file src/zsock.c line 226
struct _zsock_t * zsock_new_router(const char *endpoints);
// zsock_new_router_checked
// file src/zsock.c line 216
struct _zsock_t * zsock_new_router_checked(const char *endpoints, const char *filename, unsigned long int line_nbr);
// zsock_new_stream
// file src/zsock.c line 352
struct _zsock_t * zsock_new_stream(const char *endpoints);
// zsock_new_stream_checked
// file src/zsock.c line 338
struct _zsock_t * zsock_new_stream_checked(const char *endpoints, const char *filename, unsigned long int line_nbr);
// zsock_new_sub
// file src/zsock.c line 150
struct _zsock_t * zsock_new_sub(const char *endpoints, const char *subscribe);
// zsock_new_sub_checked
// file src/zsock.c line 135
struct _zsock_t * zsock_new_sub_checked(const char *endpoints, const char *subscribe, const char *filename, unsigned long int line_nbr);
// zsock_new_xpub
// file src/zsock.c line 287
struct _zsock_t * zsock_new_xpub(const char *endpoints);
// zsock_new_xpub_checked
// file src/zsock.c line 273
struct _zsock_t * zsock_new_xpub_checked(const char *endpoints, const char *filename, unsigned long int line_nbr);
// zsock_new_xsub
// file src/zsock.c line 310
struct _zsock_t * zsock_new_xsub(const char *endpoints);
// zsock_new_xsub_checked
// file src/zsock.c line 296
struct _zsock_t * zsock_new_xsub_checked(const char *endpoints, const char *filename, unsigned long int line_nbr);
// zsock_option_test
// file src/zsock_option.c line 3206
void zsock_option_test(_Bool verbose);
// zsock_plain_password
// file src/zsock_option.c line 325
char * zsock_plain_password(void *self);
// zsock_plain_server
// file src/zsock_option.c line 259
signed int zsock_plain_server(void *self);
// zsock_plain_username
// file src/zsock_option.c line 292
char * zsock_plain_username(void *self);
// zsock_rate
// file src/zsock_option.c line 993
signed int zsock_rate(void *self);
// zsock_rcvbuf
// file src/zsock_option.c line 1092
signed int zsock_rcvbuf(void *self);
// zsock_rcvhwm
// file src/zsock_option.c line 848
signed int zsock_rcvhwm(void *self);
// zsock_rcvmore
// file src/../include/zsock_option.h line 69
signed int zsock_rcvmore(void *self);
// zsock_rcvtimeo
// file src/zsock_option.c line 1324
signed int zsock_rcvtimeo(void *self);
// zsock_reconnect_ivl
// file src/zsock_option.c line 1158
signed int zsock_reconnect_ivl(void *self);
// zsock_reconnect_ivl_max
// file src/zsock_option.c line 1191
signed int zsock_reconnect_ivl_max(void *self);
// zsock_recovery_ivl
// file src/zsock_option.c line 1026
signed int zsock_recovery_ivl(void *self);
// zsock_recv
// file src/../include/zsock.h line 224
signed int zsock_recv(void *self, const char *picture, ...);
// zsock_resolve
// file src/../include/zsock.h line 304
void * zsock_resolve(void *self);
// zsock_send
// file src/../include/zsock.h line 189
signed int zsock_send(void *self, const char *picture, ...);
// zsock_set_affinity
// file src/zsock_option.c line 866
void zsock_set_affinity(void *self, signed int affinity);
// zsock_set_backlog
// file src/zsock_option.c line 1209
void zsock_set_backlog(void *self, signed int backlog);
// zsock_set_conflate
// file src/zsock_option.c line 170
void zsock_set_conflate(void *self, signed int conflate);
// zsock_set_curve_publickey
// file src/zsock_option.c line 376
void zsock_set_curve_publickey(void *self, const char *curve_publickey);
// zsock_set_curve_publickey_bin
// file src/../include/zsock_option.h line 88
void zsock_set_curve_publickey_bin(void *self, const unsigned char *curve_publickey);
// zsock_set_curve_secretkey
// file src/zsock_option.c line 423
void zsock_set_curve_secretkey(void *self, const char *curve_secretkey);
// zsock_set_curve_secretkey_bin
// file src/../include/zsock_option.h line 90
void zsock_set_curve_secretkey_bin(void *self, const unsigned char *curve_secretkey);
// zsock_set_curve_server
// file src/../include/zsock_option.h line 86
void zsock_set_curve_server(void *self, signed int curve_server);
// zsock_set_curve_serverkey
// file src/../include/zsock_option.h line 91
void zsock_set_curve_serverkey(void *self, const char *curve_serverkey);
// zsock_set_curve_serverkey_bin
// file src/zsock_option.c line 485
void zsock_set_curve_serverkey_bin(void *self, const unsigned char *curve_serverkey);
// zsock_set_delay_attach_on_connect
// file src/zsock_option.c line 767
void zsock_set_delay_attach_on_connect(void *self, signed int delay_attach_on_connect);
// zsock_set_gssapi_plaintext
// file src/zsock_option.c line 550
void zsock_set_gssapi_plaintext(void *self, signed int gssapi_plaintext);
// zsock_set_gssapi_principal
// file src/zsock_option.c line 583
void zsock_set_gssapi_principal(void *self, const char *gssapi_principal);
// zsock_set_gssapi_server
// file src/zsock_option.c line 517
void zsock_set_gssapi_server(void *self, signed int gssapi_server);
// zsock_set_gssapi_service_principal
// file src/zsock_option.c line 616
void zsock_set_gssapi_service_principal(void *self, const char *gssapi_service_principal);
// zsock_set_identity
// file src/zsock_option.c line 938
void zsock_set_identity(void *self, const char *identity);
// zsock_set_immediate
// file src/zsock_option.c line 682
void zsock_set_immediate(void *self, signed int immediate);
// zsock_set_ipv4only
// file src/zsock_option.c line 734
void zsock_set_ipv4only(void *self, signed int ipv4only);
// zsock_set_ipv6
// file src/zsock_option.c line 649
void zsock_set_ipv6(void *self, signed int ipv6);
// zsock_set_linger
// file src/zsock_option.c line 1110
void zsock_set_linger(void *self, signed int linger);
// zsock_set_maxmsgsize
// file src/zsock_option.c line 1242
void zsock_set_maxmsgsize(void *self, signed int maxmsgsize);
// zsock_set_multicast_hops
// file src/zsock_option.c line 1276
void zsock_set_multicast_hops(void *self, signed int multicast_hops);
// zsock_set_plain_password
// file src/../include/zsock_option.h line 85
void zsock_set_plain_password(void *self, const char *plain_password);
// zsock_set_plain_server
// file src/../include/zsock_option.h line 83
void zsock_set_plain_server(void *self, signed int plain_server);
// zsock_set_plain_username
// file src/../include/zsock_option.h line 84
void zsock_set_plain_username(void *self, const char *plain_username);
// zsock_set_probe_router
// file src/zsock_option.c line 111
void zsock_set_probe_router(void *self, signed int probe_router);
// zsock_set_rate
// file src/zsock_option.c line 978
void zsock_set_rate(void *self, signed int rate);
// zsock_set_rcvbuf
// file src/zsock_option.c line 1077
void zsock_set_rcvbuf(void *self, signed int rcvbuf);
// zsock_set_rcvhwm
// file src/../include/zsock_option.h line 103
void zsock_set_rcvhwm(void *self, signed int rcvhwm);
// zsock_set_rcvtimeo
// file src/../include/zsock_option.h line 118
void zsock_set_rcvtimeo(void *self, signed int rcvtimeo);
// zsock_set_reconnect_ivl
// file src/zsock_option.c line 1143
void zsock_set_reconnect_ivl(void *self, signed int reconnect_ivl);
// zsock_set_reconnect_ivl_max
// file src/zsock_option.c line 1176
void zsock_set_reconnect_ivl_max(void *self, signed int reconnect_ivl_max);
// zsock_set_recovery_ivl
// file src/zsock_option.c line 1011
void zsock_set_recovery_ivl(void *self, signed int recovery_ivl);
// zsock_set_req_correlate
// file src/zsock_option.c line 151
void zsock_set_req_correlate(void *self, signed int req_correlate);
// zsock_set_req_relaxed
// file src/zsock_option.c line 132
void zsock_set_req_relaxed(void *self, signed int req_relaxed);
// zsock_set_router_handover
// file src/zsock_option.c line 73
void zsock_set_router_handover(void *self, signed int router_handover);
// zsock_set_router_mandatory
// file src/zsock_option.c line 92
void zsock_set_router_mandatory(void *self, signed int router_mandatory);
// zsock_set_router_raw
// file src/zsock_option.c line 715
void zsock_set_router_raw(void *self, signed int router_raw);
// zsock_set_sndbuf
// file src/zsock_option.c line 1044
void zsock_set_sndbuf(void *self, signed int sndbuf);
// zsock_set_sndhwm
// file src/../include/zsock_option.h line 102
void zsock_set_sndhwm(void *self, signed int sndhwm);
// zsock_set_sndtimeo
// file src/../include/zsock_option.h line 119
void zsock_set_sndtimeo(void *self, signed int sndtimeo);
// zsock_set_subscribe
// file src/../include/zsock_option.h line 105
void zsock_set_subscribe(void *self, const char *subscribe);
// zsock_set_tcp_accept_filter
// file src/zsock_option.c line 1526
void zsock_set_tcp_accept_filter(void *self, const char *tcp_accept_filter);
// zsock_set_tcp_keepalive
// file src/zsock_option.c line 1394
void zsock_set_tcp_keepalive(void *self, signed int tcp_keepalive);
// zsock_set_tcp_keepalive_cnt
// file src/zsock_option.c line 1460
void zsock_set_tcp_keepalive_cnt(void *self, signed int tcp_keepalive_cnt);
// zsock_set_tcp_keepalive_idle
// file src/zsock_option.c line 1427
void zsock_set_tcp_keepalive_idle(void *self, signed int tcp_keepalive_idle);
// zsock_set_tcp_keepalive_intvl
// file src/zsock_option.c line 1493
void zsock_set_tcp_keepalive_intvl(void *self, signed int tcp_keepalive_intvl);
// zsock_set_tos
// file src/zsock_option.c line 40
void zsock_set_tos(void *self, signed int tos);
// zsock_set_unbounded
// file src/../include/zsock.h line 271
void zsock_set_unbounded(void *self);
// zsock_set_unsubscribe
// file src/zsock_option.c line 919
void zsock_set_unsubscribe(void *self, const char *unsubscribe);
// zsock_set_xpub_verbose
// file src/zsock_option.c line 1375
void zsock_set_xpub_verbose(void *self, signed int xpub_verbose);
// zsock_set_zap_domain
// file src/../include/zsock_option.h line 82
void zsock_set_zap_domain(void *self, const char *zap_domain);
// zsock_signal
// file src/../include/zsock.h line 279
signed int zsock_signal(void *self, unsigned char status);
// zsock_sndbuf
// file src/zsock_option.c line 1059
signed int zsock_sndbuf(void *self);
// zsock_sndhwm
// file src/zsock_option.c line 815
signed int zsock_sndhwm(void *self);
// zsock_sndtimeo
// file src/zsock_option.c line 1357
signed int zsock_sndtimeo(void *self);
// zsock_tcp_accept_filter
// file src/zsock_option.c line 1541
char * zsock_tcp_accept_filter(void *self);
// zsock_tcp_keepalive
// file src/zsock_option.c line 1409
signed int zsock_tcp_keepalive(void *self);
// zsock_tcp_keepalive_cnt
// file src/zsock_option.c line 1475
signed int zsock_tcp_keepalive_cnt(void *self);
// zsock_tcp_keepalive_idle
// file src/zsock_option.c line 1442
signed int zsock_tcp_keepalive_idle(void *self);
// zsock_tcp_keepalive_intvl
// file src/zsock_option.c line 1508
signed int zsock_tcp_keepalive_intvl(void *self);
// zsock_test
// file src/zsock.c line 1540
void zsock_test(_Bool verbose);
// zsock_tos
// file src/zsock_option.c line 55
signed int zsock_tos(void *self);
// zsock_type
// file src/../include/zsock_option.h line 47
signed int zsock_type(void *self);
// zsock_type_str
// file src/../include/zsock.h line 160
const char * zsock_type_str(struct _zsock_t *self);
// zsock_unbind
// file src/../include/zsock.h line 136
signed int zsock_unbind(struct _zsock_t *self, const char *format, ...);
// zsock_vrecv
// file src/zsock.c line 788
signed int zsock_vrecv(void *self, const char *picture, __builtin_va_list argptr);
// zsock_vsend
// file src/zsock.c line 657
signed int zsock_vsend(void *self, const char *picture, __builtin_va_list argptr);
// zsock_wait
// file src/../include/zsock.h line 286
signed int zsock_wait(void *self);
// zsock_zap_domain
// file src/zsock_option.c line 208
char * zsock_zap_domain(void *self);
// zsocket_affinity
// file src/zsockopt.c line 961
signed int zsocket_affinity(void *zocket);
// zsocket_backlog
// file src/zsockopt.c line 1336
signed int zsocket_backlog(void *zocket);
// zsocket_bind
// file src/../include/zsocket.h line 47
signed int zsocket_bind(void *self, const char *format, ...);
// zsocket_connect
// file src/../include/zsocket.h line 58
signed int zsocket_connect(void *self, const char *format, ...);
// zsocket_curve_publickey
// file src/zsockopt.c line 442
char * zsocket_curve_publickey(void *zocket);
// zsocket_curve_secretkey
// file src/zsockopt.c line 492
char * zsocket_curve_secretkey(void *zocket);
// zsocket_curve_server
// file src/zsockopt.c line 392
signed int zsocket_curve_server(void *zocket);
// zsocket_curve_serverkey
// file src/zsockopt.c line 542
char * zsocket_curve_serverkey(void *zocket);
// zsocket_destroy
// file src/../include/zsocket.h line 39
void zsocket_destroy(struct _zctx_t *ctx, void *self);
// zsocket_disconnect
// file src/zsocket.c line 135
signed int zsocket_disconnect(void *self, const char *format, ...);
// zsocket_events
// file src/zsockopt.c line 1737
signed int zsocket_events(void *zocket);
// zsocket_fd
// file src/zsockopt.c line 1719
signed int zsocket_fd(void *zocket);
// zsocket_gssapi_plaintext
// file src/zsockopt.c line 614
signed int zsocket_gssapi_plaintext(void *zocket);
// zsocket_gssapi_principal
// file src/zsockopt.c line 650
char * zsocket_gssapi_principal(void *zocket);
// zsocket_gssapi_server
// file src/zsockopt.c line 578
signed int zsocket_gssapi_server(void *zocket);
// zsocket_gssapi_service_principal
// file src/zsockopt.c line 686
char * zsocket_gssapi_service_principal(void *zocket);
// zsocket_identity
// file src/zsockopt.c line 1048
char * zsocket_identity(void *zocket);
// zsocket_immediate
// file src/zsockopt.c line 758
signed int zsocket_immediate(void *zocket);
// zsocket_ipv4only
// file src/zsockopt.c line 816
signed int zsocket_ipv4only(void *zocket);
// zsocket_ipv6
// file src/zsockopt.c line 722
signed int zsocket_ipv6(void *zocket);
// zsocket_last_endpoint
// file src/zsockopt.c line 1755
char * zsocket_last_endpoint(void *zocket);
// zsocket_linger
// file src/zsockopt.c line 1228
signed int zsocket_linger(void *zocket);
// zsocket_maxmsgsize
// file src/zsockopt.c line 1373
signed int zsocket_maxmsgsize(void *zocket);
// zsocket_mechanism
// file src/zsockopt.c line 248
signed int zsocket_mechanism(void *zocket);
// zsocket_multicast_hops
// file src/zsockopt.c line 1409
signed int zsocket_multicast_hops(void *zocket);
// zsocket_new
// file src/../include/zsocket.h line 35
void * zsocket_new(struct _zctx_t *ctx, signed int type);
// zsocket_plain_password
// file src/zsockopt.c line 356
char * zsocket_plain_password(void *zocket);
// zsocket_plain_server
// file src/zsockopt.c line 284
signed int zsocket_plain_server(void *zocket);
// zsocket_plain_username
// file src/zsockopt.c line 320
char * zsocket_plain_username(void *zocket);
// zsocket_poll
// file src/zsocket.c line 155
_Bool zsocket_poll(void *self, signed int msecs);
// zsocket_rate
// file src/zsockopt.c line 1084
signed int zsocket_rate(void *zocket);
// zsocket_rcvbuf
// file src/zsockopt.c line 1192
signed int zsocket_rcvbuf(void *zocket);
// zsocket_rcvhwm
// file src/zsockopt.c line 924
signed int zsocket_rcvhwm(void *zocket);
// zsocket_rcvmore
// file src/../include/zsockopt.h line 69
signed int zsocket_rcvmore(void *zocket);
// zsocket_rcvtimeo
// file src/zsockopt.c line 1445
signed int zsocket_rcvtimeo(void *zocket);
// zsocket_reconnect_ivl
// file src/zsockopt.c line 1264
signed int zsocket_reconnect_ivl(void *zocket);
// zsocket_reconnect_ivl_max
// file src/zsockopt.c line 1300
signed int zsocket_reconnect_ivl_max(void *zocket);
// zsocket_recovery_ivl
// file src/zsockopt.c line 1120
signed int zsocket_recovery_ivl(void *zocket);
// zsocket_sendmem
// file src/zsocket.c line 179
signed int zsocket_sendmem(void *self, const void *data, unsigned long int size, signed int flags);
// zsocket_set_affinity
// file src/zsockopt.c line 942
void zsocket_set_affinity(void *zocket, signed int affinity);
// zsocket_set_backlog
// file src/zsockopt.c line 1318
void zsocket_set_backlog(void *zocket, signed int backlog);
// zsocket_set_conflate
// file src/zsockopt.c line 186
void zsocket_set_conflate(void *zocket, signed int conflate);
// zsocket_set_curve_publickey
// file src/zsockopt.c line 410
void zsocket_set_curve_publickey(void *zocket, const char *curve_publickey);
// zsocket_set_curve_publickey_bin
// file src/zsockopt.c line 428
void zsocket_set_curve_publickey_bin(void *zocket, const unsigned char *curve_publickey);
// zsocket_set_curve_secretkey
// file src/zsockopt.c line 460
void zsocket_set_curve_secretkey(void *zocket, const char *curve_secretkey);
// zsocket_set_curve_secretkey_bin
// file src/zsockopt.c line 478
void zsocket_set_curve_secretkey_bin(void *zocket, const unsigned char *curve_secretkey);
// zsocket_set_curve_server
// file src/../include/zsockopt.h line 86
void zsocket_set_curve_server(void *zocket, signed int curve_server);
// zsocket_set_curve_serverkey
// file src/../include/zsockopt.h line 91
void zsocket_set_curve_serverkey(void *zocket, const char *curve_serverkey);
// zsocket_set_curve_serverkey_bin
// file src/zsockopt.c line 528
void zsocket_set_curve_serverkey_bin(void *zocket, const unsigned char *curve_serverkey);
// zsocket_set_delay_attach_on_connect
// file src/zsockopt.c line 834
void zsocket_set_delay_attach_on_connect(void *zocket, signed int delay_attach_on_connect);
// zsocket_set_gssapi_plaintext
// file src/zsockopt.c line 596
void zsocket_set_gssapi_plaintext(void *zocket, signed int gssapi_plaintext);
// zsocket_set_gssapi_principal
// file src/zsockopt.c line 632
void zsocket_set_gssapi_principal(void *zocket, const char *gssapi_principal);
// zsocket_set_gssapi_server
// file src/zsockopt.c line 560
void zsocket_set_gssapi_server(void *zocket, signed int gssapi_server);
// zsocket_set_gssapi_service_principal
// file src/zsockopt.c line 668
void zsocket_set_gssapi_service_principal(void *zocket, const char *gssapi_service_principal);
// zsocket_set_hwm
// file src/../include/zsocket.h line 104
void zsocket_set_hwm(void *self, signed int hwm);
// zsocket_set_identity
// file src/zsockopt.c line 1023
void zsocket_set_identity(void *zocket, const char *identity);
// zsocket_set_immediate
// file src/zsockopt.c line 740
void zsocket_set_immediate(void *zocket, signed int immediate);
// zsocket_set_ipv4only
// file src/zsockopt.c line 798
void zsocket_set_ipv4only(void *zocket, signed int ipv4only);
// zsocket_set_ipv6
// file src/zsockopt.c line 704
void zsocket_set_ipv6(void *zocket, signed int ipv6);
// zsocket_set_linger
// file src/../include/zsockopt.h line 112
void zsocket_set_linger(void *zocket, signed int linger);
// zsocket_set_maxmsgsize
// file src/zsockopt.c line 1354
void zsocket_set_maxmsgsize(void *zocket, signed int maxmsgsize);
// zsocket_set_multicast_hops
// file src/zsockopt.c line 1391
void zsocket_set_multicast_hops(void *zocket, signed int multicast_hops);
// zsocket_set_plain_password
// file src/../include/zsockopt.h line 85
void zsocket_set_plain_password(void *zocket, const char *plain_password);
// zsocket_set_plain_server
// file src/../include/zsockopt.h line 83
void zsocket_set_plain_server(void *zocket, signed int plain_server);
// zsocket_set_plain_username
// file src/../include/zsockopt.h line 84
void zsocket_set_plain_username(void *zocket, const char *plain_username);
// zsocket_set_probe_router
// file src/zsockopt.c line 118
void zsocket_set_probe_router(void *zocket, signed int probe_router);
// zsocket_set_rate
// file src/zsockopt.c line 1066
void zsocket_set_rate(void *zocket, signed int rate);
// zsocket_set_rcvbuf
// file src/zsockopt.c line 1174
void zsocket_set_rcvbuf(void *zocket, signed int rcvbuf);
// zsocket_set_rcvhwm
// file src/../include/zsockopt.h line 103
void zsocket_set_rcvhwm(void *zocket, signed int rcvhwm);
// zsocket_set_rcvtimeo
// file src/../include/zsockopt.h line 118
void zsocket_set_rcvtimeo(void *zocket, signed int rcvtimeo);
// zsocket_set_reconnect_ivl
// file src/zsockopt.c line 1246
void zsocket_set_reconnect_ivl(void *zocket, signed int reconnect_ivl);
// zsocket_set_reconnect_ivl_max
// file src/zsockopt.c line 1282
void zsocket_set_reconnect_ivl_max(void *zocket, signed int reconnect_ivl_max);
// zsocket_set_recovery_ivl
// file src/zsockopt.c line 1102
void zsocket_set_recovery_ivl(void *zocket, signed int recovery_ivl);
// zsocket_set_req_correlate
// file src/zsockopt.c line 164
void zsocket_set_req_correlate(void *zocket, signed int req_correlate);
// zsocket_set_req_relaxed
// file src/zsockopt.c line 142
void zsocket_set_req_relaxed(void *zocket, signed int req_relaxed);
// zsocket_set_router_handover
// file src/zsockopt.c line 74
void zsocket_set_router_handover(void *zocket, signed int router_handover);
// zsocket_set_router_mandatory
// file src/zsockopt.c line 96
void zsocket_set_router_mandatory(void *zocket, signed int router_mandatory);
// zsocket_set_router_raw
// file src/zsockopt.c line 776
void zsocket_set_router_raw(void *zocket, signed int router_raw);
// zsocket_set_sndbuf
// file src/zsockopt.c line 1138
void zsocket_set_sndbuf(void *zocket, signed int sndbuf);
// zsocket_set_sndhwm
// file src/../include/zsockopt.h line 102
void zsocket_set_sndhwm(void *zocket, signed int sndhwm);
// zsocket_set_sndtimeo
// file src/zsockopt.c line 1463
void zsocket_set_sndtimeo(void *zocket, signed int sndtimeo);
// zsocket_set_subscribe
// file src/zsockopt.c line 979
void zsocket_set_subscribe(void *zocket, const char *subscribe);
// zsocket_set_tcp_accept_filter
// file src/zsockopt.c line 1665
void zsocket_set_tcp_accept_filter(void *zocket, const char *tcp_accept_filter);
// zsocket_set_tcp_keepalive
// file src/zsockopt.c line 1521
void zsocket_set_tcp_keepalive(void *zocket, signed int tcp_keepalive);
// zsocket_set_tcp_keepalive_cnt
// file src/zsockopt.c line 1593
void zsocket_set_tcp_keepalive_cnt(void *zocket, signed int tcp_keepalive_cnt);
// zsocket_set_tcp_keepalive_idle
// file src/zsockopt.c line 1557
void zsocket_set_tcp_keepalive_idle(void *zocket, signed int tcp_keepalive_idle);
// zsocket_set_tcp_keepalive_intvl
// file src/zsockopt.c line 1629
void zsocket_set_tcp_keepalive_intvl(void *zocket, signed int tcp_keepalive_intvl);
// zsocket_set_tos
// file src/zsockopt.c line 38
void zsocket_set_tos(void *zocket, signed int tos);
// zsocket_set_unsubscribe
// file src/zsockopt.c line 1001
void zsocket_set_unsubscribe(void *zocket, const char *unsubscribe);
// zsocket_set_xpub_verbose
// file src/zsockopt.c line 1499
void zsocket_set_xpub_verbose(void *zocket, signed int xpub_verbose);
// zsocket_set_zap_domain
// file src/../include/zsockopt.h line 82
void zsocket_set_zap_domain(void *zocket, const char *zap_domain);
// zsocket_signal
// file src/../include/zsocket.h line 85
signed int zsocket_signal(void *self);
// zsocket_sndbuf
// file src/zsockopt.c line 1156
signed int zsocket_sndbuf(void *zocket);
// zsocket_sndhwm
// file src/zsockopt.c line 888
signed int zsocket_sndhwm(void *zocket);
// zsocket_sndtimeo
// file src/zsockopt.c line 1481
signed int zsocket_sndtimeo(void *zocket);
// zsocket_tcp_accept_filter
// file src/zsockopt.c line 1683
char * zsocket_tcp_accept_filter(void *zocket);
// zsocket_tcp_keepalive
// file src/zsockopt.c line 1539
signed int zsocket_tcp_keepalive(void *zocket);
// zsocket_tcp_keepalive_cnt
// file src/zsockopt.c line 1611
signed int zsocket_tcp_keepalive_cnt(void *zocket);
// zsocket_tcp_keepalive_idle
// file src/zsockopt.c line 1575
signed int zsocket_tcp_keepalive_idle(void *zocket);
// zsocket_tcp_keepalive_intvl
// file src/zsockopt.c line 1647
signed int zsocket_tcp_keepalive_intvl(void *zocket);
// zsocket_test
// file src/zsocket.c line 248
void zsocket_test(_Bool verbose);
// zsocket_tos
// file src/zsockopt.c line 56
signed int zsocket_tos(void *zocket);
// zsocket_type
// file src/../include/zsockopt.h line 47
signed int zsocket_type(void *zocket);
// zsocket_type_str
// file src/zsocket.c line 167
const char * zsocket_type_str(void *self);
// zsocket_unbind
// file src/../include/zsocket.h line 53
signed int zsocket_unbind(void *self, const char *format, ...);
// zsocket_wait
// file src/../include/zsocket.h line 90
signed int zsocket_wait(void *self);
// zsocket_zap_domain
// file src/zsockopt.c line 230
char * zsocket_zap_domain(void *zocket);
// zsockopt_test
// file src/zsockopt.c line 3483
void zsockopt_test(_Bool verbose);
// zstr_free
// file src/../include/zstr.h line 70
void zstr_free(char **string_p);
// zstr_recv
// file src/../include/zstr.h line 26
char * zstr_recv(void *source);
// zstr_recv_nowait
// file src/zstr.c line 239
char * zstr_recv_nowait(void *dest);
// zstr_recvx
// file src/../include/zstr.h line 65
signed int zstr_recvx(void *source, char **string_p, ...);
// zstr_send
// file src/../include/zstr.h line 33
signed int zstr_send(void *dest, const char *string);
// zstr_sendf
// file src/../include/zstr.h line 44
signed int zstr_sendf(void *dest, const char *format, ...);
// zstr_sendfm
// file src/../include/zstr.h line 50
signed int zstr_sendfm(void *dest, const char *format, ...);
// zstr_sendm
// file src/../include/zstr.h line 38
signed int zstr_sendm(void *dest, const char *string);
// zstr_sendx
// file src/../include/zstr.h line 55
signed int zstr_sendx(void *dest, const char *string, ...);
// zstr_test
// file src/zstr.c line 264
void zstr_test(_Bool verbose);
// zsys_catch_interrupts
// file src/zsys.c line 483
void zsys_catch_interrupts(void);
// zsys_close
// file src/../include/zsys.h line 54
signed int zsys_close(void *handle, const char *filename, unsigned long int line_nbr);
// zsys_create_pipe
// file src/../include/zsys.h line 65
struct _zsock_t * zsys_create_pipe(struct _zsock_t **backend_p);
// zsys_daemonize
// file src/zsys.c line 994
signed int zsys_daemonize(const char *workdir);
// zsys_debug
// file src/../include/zsys.h line 329
void zsys_debug(const char *format, ...);
// zsys_dir_change
// file src/zsys.c line 686
signed int zsys_dir_change(const char *pathname);
// zsys_dir_create
// file src/../include/zsys.h line 113
signed int zsys_dir_create(const char *pathname, ...);
// zsys_dir_delete
// file src/../include/zsys.h line 117
signed int zsys_dir_delete(const char *pathname, ...);
// zsys_error
// file src/../include/zsys.h line 313
void zsys_error(const char *format, ...);
// zsys_file_delete
// file src/../include/zsys.h line 104
signed int zsys_file_delete(const char *filename);
// zsys_file_exists
// file src/../include/zsys.h line 86
_Bool zsys_file_exists(const char *filename);
// zsys_file_mode
// file src/../include/zsys.h line 100
signed int zsys_file_mode(const char *filename);
// zsys_file_mode_default
// file src/../include/zsys.h line 131
void zsys_file_mode_default(void);
// zsys_file_mode_private
// file src/../include/zsys.h line 126
void zsys_file_mode_private(void);
// zsys_file_modified
// file src/../include/zsys.h line 94
signed long int zsys_file_modified(const char *filename);
// zsys_file_size
// file src/../include/zsys.h line 90
signed long int zsys_file_size(const char *filename);
// zsys_file_stable
// file src/../include/zsys.h line 108
_Bool zsys_file_stable(const char *filename);
// zsys_handler_reset
// file src/zsys.c line 457
void zsys_handler_reset(void);
// zsys_handler_set
// file src/zsys.c line 416
void zsys_handler_set(void (*handler_fn)(signed int));
// zsys_handler_set::handler_fn_object
//
void handler_fn_object(signed int);
// zsys_has_curve
// file src/../include/zsys.h line 205
_Bool zsys_has_curve(void);
// zsys_hostname
// file src/zsys.c line 972
char * zsys_hostname(void);
// zsys_info
// file src/../include/zsys.h line 325
void zsys_info(const char *format, ...);
// zsys_init
// file src/zsys.c line 121
void * zsys_init(void);
// zsys_interface
// file src/../include/zsys.h line 282
const char * zsys_interface(void);
// zsys_notice
// file src/../include/zsys.h line 321
void zsys_notice(const char *format, ...);
// zsys_pipehwm
// file src/zsys.c line 1296
unsigned long int zsys_pipehwm(void);
// zsys_run_as
// file src/zsys.c line 1046
signed int zsys_run_as(const char *lockfile, const char *group, const char *user);
// zsys_set_interface
// file src/zsys.c line 1329
void zsys_set_interface(const char *value);
// zsys_set_io_threads
// file src/zsys.c line 1158
void zsys_set_io_threads(unsigned long int io_threads);
// zsys_set_ipv6
// file src/zsys.c line 1311
void zsys_set_ipv6(signed int ipv6);
// zsys_set_linger
// file src/zsys.c line 1232
void zsys_set_linger(unsigned long int linger);
// zsys_set_logident
// file src/zsys.c line 1354
void zsys_set_logident(const char *value);
// zsys_set_logsender
// file src/zsys.c line 1392
void zsys_set_logsender(const char *endpoint);
// zsys_set_logstream
// file src/../include/zsys.h line 294
void zsys_set_logstream(struct _IO_FILE *stream);
// zsys_set_logsystem
// file src/zsys.c line 1417
void zsys_set_logsystem(_Bool logsystem);
// zsys_set_max_sockets
// file src/../include/zsys.h line 220
void zsys_set_max_sockets(unsigned long int max_sockets);
// zsys_set_pipehwm
// file src/zsys.c line 1283
void zsys_set_pipehwm(unsigned long int pipehwm);
// zsys_set_rcvhwm
// file src/zsys.c line 1266
void zsys_set_rcvhwm(unsigned long int rcvhwm);
// zsys_set_sndhwm
// file src/zsys.c line 1249
void zsys_set_sndhwm(unsigned long int sndhwm);
// zsys_shutdown
// file src/zsys.c line 204
void zsys_shutdown(void);
// zsys_socket
// file src/../include/zsys.h line 48
void * zsys_socket(signed int type, const char *filename, unsigned long int line_nbr);
// zsys_socket_error
// file src/../include/zsys.h line 178
void zsys_socket_error(const char *reason);
// zsys_socket_limit
// file src/zsys.c line 1201
unsigned long int zsys_socket_limit(void);
// zsys_sockname
// file src/../include/zsys.h line 59
char * zsys_sockname(signed int socktype);
// zsys_sprintf
// file src/../include/zsys.h line 142
char * zsys_sprintf(const char *format, ...);
// zsys_test
// file src/zsys.c line 1579
void zsys_test(_Bool verbose);
// zsys_udp_close
// file src/../include/zsys.h line 160
signed int zsys_udp_close(signed int handle);
// zsys_udp_new
// file src/../include/zsys.h line 155
signed int zsys_udp_new(_Bool routable);
// zsys_udp_recv
// file src/../include/zsys.h line 172
struct _zframe_t * zsys_udp_recv(signed int udpsock, char *peername);
// zsys_udp_send
// file src/../include/zsys.h line 166
signed int zsys_udp_send(signed int udpsock, struct _zframe_t *frame, struct sockaddr_in *address);
// zsys_version
// file src/zsys.c line 735
void zsys_version(signed int *major, signed int *minor, signed int *patch);
// zsys_vprintf
// file src/../include/zsys.h line 148
char * zsys_vprintf(const char *format, void **argptr);
// zsys_warning
// file src/../include/zsys.h line 317
void zsys_warning(const char *format, ...);
// zthread_fork
// file src/../include/zthread.h line 39
void * zthread_fork(struct _zctx_t *ctx, void (*thread_fn)(void *, struct _zctx_t *, void *), void *args);
// zthread_fork::thread_fn_object
//
void thread_fn_object(void *, struct _zctx_t *, void *);
// zthread_new
// file src/zthread.c line 147
signed int zthread_new(void * (*thread_fn)(void *), void *args);
// zthread_new::thread_fn_object
//
void * thread_fn_object(void *);
// zthread_test
// file src/zthread.c line 237
void zthread_test(_Bool verbose);
// zuuid_data
// file src/../include/zuuid.h line 48
const unsigned char * zuuid_data(struct _zuuid_t *self);
// zuuid_destroy
// file src/../include/zuuid.h line 31
void zuuid_destroy(struct _zuuid_t **self_p);
// zuuid_dup
// file src/zuuid.c line 272
struct _zuuid_t * zuuid_dup(struct _zuuid_t *self);
// zuuid_eq
// file src/zuuid.c line 249
_Bool zuuid_eq(struct _zuuid_t *self, const unsigned char *compare);
// zuuid_export
// file src/zuuid.c line 238
void zuuid_export(struct _zuuid_t *self, unsigned char *target);
// zuuid_neq
// file src/zuuid.c line 260
_Bool zuuid_neq(struct _zuuid_t *self, const unsigned char *compare);
// zuuid_new
// file src/../include/zuuid.h line 27
struct _zuuid_t * zuuid_new(void);
// zuuid_new_from
// file src/zuuid.c line 109
struct _zuuid_t * zuuid_new_from(const unsigned char *source);
// zuuid_set
// file src/../include/zuuid.h line 39
void zuuid_set(struct _zuuid_t *self, const unsigned char *source);
// zuuid_set_str
// file src/zuuid.c line 143
signed int zuuid_set_str(struct _zuuid_t *self, const char *source);
// zuuid_size
// file src/../include/zuuid.h line 52
unsigned long int zuuid_size(struct _zuuid_t *self);
// zuuid_str
// file src/../include/zuuid.h line 56
const char * zuuid_str(struct _zuuid_t *self);
// zuuid_str_canonical
// file src/zuuid.c line 211
const char * zuuid_str_canonical(struct _zuuid_t *self);
// zuuid_test
// file src/zuuid.c line 285
void zuuid_test(_Bool verbose);

struct _zlist_t
{
  // head
  struct _node_t_0 *head;
  // tail
  struct _node_t_0 *tail;
  // cursor
  struct _node_t_0 *cursor;
  // size
  unsigned long int size;
  // autofree
  _Bool autofree;
  // compare_fn
  signed int (*compare_fn)(void *, void *);
};

struct _node_t_0
{
  // next
  struct _node_t_0 *next;
  // item
  void *item;
  // free_fn
  void (*free_fn)(void *);
};

struct _item_t_0
{
  // value
  void *value;
  // next
  struct _item_t_0 *next;
  // index
  unsigned long int index;
  // key
  char *key;
  // free_fn
  void (*free_fn)(void *);
};

struct _zhash_t
{
  // size
  unsigned long int size;
  // limit
  unsigned long int limit;
  // items
  struct _item_t_0 **items;
  // cached_index
  unsigned long int cached_index;
  // autofree
  _Bool autofree;
  // cursor_index
  unsigned long int cursor_index;
  // cursor_item
  struct _item_t_0 *cursor_item;
  // cursor_key
  const char *cursor_key;
  // comments
  struct _zlist_t *comments;
  // modified
  signed long int modified;
  // filename
  char *filename;
};

struct anonymous_19
{
  // name
  char *name;
  // address
  char *address;
  // netmask
  char *netmask;
  // broadcast
  char *broadcast;
};

struct anonymous_23
{
  // ctx
  struct _zctx_t *ctx;
  // pipe
  void *pipe;
  // handler
  void *handler;
  // verbose
  _Bool verbose;
  // whitelist
  struct _zhash_t *whitelist;
  // blacklist
  struct _zhash_t *blacklist;
  // passwords
  struct _zhash_t *passwords;
  // certstore
  struct _zcertstore_t *certstore;
  // allow_any
  _Bool allow_any;
  // terminated
  _Bool terminated;
};

struct anonymous_39
{
  // ctx
  struct _zctx_t *ctx;
  // pipe
  void *pipe;
  // socket
  void *socket;
  // endpoint
  char *endpoint;
  // verbose
  _Bool verbose;
  // terminated
  _Bool terminated;
};

struct anonymous_34
{
  // handler
  struct _zsock_t *handler;
  // verbose
  _Bool verbose;
  // version
  char *version;
  // sequence
  char *sequence;
  // domain
  char *domain;
  // address
  char *address;
  // identity
  char *identity;
  // mechanism
  char *mechanism;
  // username
  char *username;
  // password
  char *password;
  // client_key
  char *client_key;
  // principal
  char *principal;
};

struct anonymous_35
{
  // pipe
  struct _zsock_t *pipe;
  // poller
  struct _zpoller_t *poller;
  // frontend
  struct _zsock_t *frontend;
  // backend
  struct _zsock_t *backend;
  // capture
  struct _zsock_t *capture;
  // terminated
  _Bool terminated;
  // verbose
  _Bool verbose;
};

struct anonymous_25
{
  // pipe
  struct _zsock_t *pipe;
  // poller
  struct _zpoller_t *poller;
  // monitored
  void *monitored;
  // sink
  struct _zsock_t *sink;
  // events
  signed int events;
  // terminated
  _Bool terminated;
  // verbose
  _Bool verbose;
};

struct anonymous_26
{
  // pipe
  struct _zsock_t *pipe;
  // handler
  struct _zsock_t *handler;
  // whitelist
  struct _zhashx_t *whitelist;
  // blacklist
  struct _zhashx_t *blacklist;
  // passwords
  struct _zhashx_t *passwords;
  // poller
  struct _zpoller_t *poller;
  // certstore
  struct _zcertstore_t *certstore;
  // allow_any
  _Bool allow_any;
  // terminated
  _Bool terminated;
  // verbose
  _Bool verbose;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct anonymous_36
{
  // pipe
  struct _zsock_t *pipe;
  // udpsock
  signed int udpsock;
  // port_nbr
  signed int port_nbr;
  // interval
  signed int interval;
  // ping_at
  signed long int ping_at;
  // transmit
  struct _zframe_t *transmit;
  // filter
  struct _zframe_t *filter;
  // broadcast
  struct sockaddr_in broadcast;
  // terminated
  _Bool terminated;
  // verbose
  _Bool verbose;
  // hostname
  char hostname[1025l];
};

struct anonymous_22
{
  // handler
  void (*handler)(struct _zsock_t *, void *);
  // pipe
  struct _zsock_t *pipe;
  // args
  void *args;
};

struct anonymous_21
{
  // attached
  void (*attached)(void *, struct _zctx_t *, void *);
  // detached
  void * (*detached)(void *);
  // args
  void *args;
  // ctx
  struct _zctx_t *ctx;
  // pipe
  void *pipe;
};

struct anonymous_13
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_10
{
  // _lower
  void *_lower;
  // _upper
  void *_upper;
};

struct anonymous_18
{
  // handle
  void *handle;
  // type
  signed int type;
  // filename
  const char *filename;
  // line_nbr
  unsigned long int line_nbr;
};

struct anonymous_24
{
  // handler
  void *handler;
  // version
  char *version;
  // sequence
  char *sequence;
  // domain
  char *domain;
  // address
  char *address;
  // identity
  char *identity;
  // mechanism
  char *mechanism;
  // username
  char *username;
  // password
  char *password;
  // client_key
  char *client_key;
  // principal
  char *principal;
};

struct anonymous_27
{
  // pipe
  void *pipe;
  // udpsock
  signed int udpsock;
  // port_nbr
  signed int port_nbr;
  // interval
  signed int interval;
  // noecho
  _Bool noecho;
  // terminated
  _Bool terminated;
  // ping_at
  signed long int ping_at;
  // transmit
  struct _zframe_t *transmit;
  // filter
  struct _zframe_t *filter;
  // address
  struct sockaddr_in address;
  // broadcast
  struct sockaddr_in broadcast;
};

struct anonymous_11
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
  // si_addr_bnd
  struct anonymous_10 si_addr_bnd;
};

struct anonymous_38
{
  // name
  const char *name;
  // narg
  signed int narg;
  // flags
  const char *flags;
};

struct anonymous_2
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_5
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_9
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_8
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_7
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_12
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_14
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_5 _kill;
  // _timer
  struct anonymous_7 _timer;
  // _rt
  struct anonymous_8 _rt;
  // _sigchld
  struct anonymous_9 _sigchld;
  // _sigfault
  struct anonymous_11 _sigfault;
  // _sigpoll
  struct anonymous_12 _sigpoll;
  // _sigsys
  struct anonymous_13 _sigsys;
};

struct anonymous_15
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_14 _sifields;
};

struct _client_t
{
  // server
  struct _server_t *server;
  // message
  struct _zgossip_msg_t *message;
};

struct anonymous_31
{
  // client
  struct _client_t client;
  // server
  struct anonymous_28 *server;
  // hashkey
  char *hashkey;
  // routing_id
  struct _zframe_t *routing_id;
  // unique_id
  unsigned int unique_id;
  // state
  enum anonymous_29 state;
  // event
  enum anonymous_30 event;
  // next_event
  enum anonymous_30 next_event;
  // exception
  enum anonymous_30 exception;
  // wakeup
  signed int wakeup;
  // ticket
  void *ticket;
  // wakeup_event
  enum anonymous_30 wakeup_event;
  // log_prefix
  char log_prefix[41l];
};

struct _server_t
{
  // pipe
  struct _zsock_t *pipe;
  // config
  struct _zconfig_t *config;
  // remotes
  struct _zlistx_t *remotes;
  // tuples
  struct _zhashx_t *tuples;
  // cur_tuple
  struct _tuple_t *cur_tuple;
  // message
  struct _zgossip_msg_t *message;
};

struct anonymous_28
{
  // server
  struct _server_t server;
  // pipe
  struct _zsock_t *pipe;
  // router
  struct _zsock_t *router;
  // port
  signed int port;
  // loop
  struct _zloop_t *loop;
  // message
  struct _zgossip_msg_t *message;
  // clients
  struct _zhash_t *clients;
  // config
  struct _zconfig_t *config;
  // client_id
  unsigned int client_id;
  // timeout
  unsigned long int timeout;
  // verbose
  _Bool verbose;
  // log_prefix
  char *log_prefix;
};

union anonymous_20
{
  // ifu_broadaddr
  struct sockaddr *ifu_broadaddr;
  // ifu_dstaddr
  struct sockaddr *ifu_dstaddr;
};

union anonymous_17
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_15 *, void *);
};

union anonymous_40
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous
{
  // b8
  unsigned char b8[20l];
  // b32
  unsigned int b32[5l];
};

union anonymous_4
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_1
{
  // b8
  unsigned char b8[64l];
  // b32
  unsigned int b32[16l];
};

union anonymous_0
{
  // b8
  unsigned char b8[8l];
  // b64
  unsigned long int b64[1l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_16
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_33
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _item_t
{
  // value
  void *value;
  // next
  struct _item_t *next;
  // index
  unsigned long int index;
  // key
  const void *key;
  // free_fn
  void (*free_fn)(void *);
};

struct _node_t
{
  // tag
  unsigned int tag;
  // next
  struct _node_t *next;
  // prev
  struct _node_t *prev;
  // item
  void *item;
};

struct zmq_pollitem_t
{
  // socket
  void *socket;
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

struct _s_poller_t
{
  // list_handle
  void *list_handle;
  // item
  struct zmq_pollitem_t item;
  // handler
  signed int (*handler)(struct _zloop_t *, struct zmq_pollitem_t *, void *);
  // arg
  void *arg;
  // errors
  signed int errors;
  // tolerant
  _Bool tolerant;
};

struct _s_reader_t
{
  // list_handle
  void *list_handle;
  // sock
  struct _zsock_t *sock;
  // handler
  signed int (*handler)(struct _zloop_t *, struct _zsock_t *, void *);
  // arg
  void *arg;
  // errors
  signed int errors;
  // tolerant
  _Bool tolerant;
};

struct _s_ticket_t
{
  // tag
  unsigned int tag;
  // list_handle
  void *list_handle;
  // delay
  unsigned long int delay;
  // when
  signed long int when;
  // handler
  signed int (*handler)(struct _zloop_t *, signed int, void *);
  // arg
  void *arg;
  // deleted
  _Bool deleted;
};

struct _s_timer_t
{
  // list_handle
  void *list_handle;
  // timer_id
  signed int timer_id;
  // handler
  signed int (*handler)(struct _zloop_t *, signed int, void *);
  // delay
  unsigned long int delay;
  // times
  unsigned long int times;
  // arg
  void *arg;
  // when
  signed long int when;
};

struct _tuple_t
{
  // container
  struct _zhashx_t *container;
  // key
  char *key;
  // value
  char *value;
};

struct _zactor_t
{
  // tag
  unsigned int tag;
  // pipe
  struct _zsock_t *pipe;
};

struct _zarmour_t
{
  // mode
  enum anonymous_37 mode;
  // pad
  _Bool pad;
  // pad_char
  char pad_char;
  // line_breaks
  _Bool line_breaks;
  // line_length
  unsigned long int line_length;
  // line_end
  char *line_end;
};

struct _zauth_t
{
  // pipe
  void *pipe;
};

struct _zbeacon_t
{
  // pipe
  void *pipe;
  // hostname
  char *hostname;
  // ctx
  struct _zctx_t *ctx;
};

struct _zcert_t
{
  // public_key
  unsigned char public_key[32l];
  // secret_key
  unsigned char secret_key[32l];
  // public_txt
  char public_txt[41l];
  // secret_txt
  char secret_txt[41l];
  // metadata
  struct _zhash_t *metadata;
  // config
  struct _zconfig_t *config;
};

struct _zcertstore_t
{
  // location
  char *location;
  // modified
  signed long int modified;
  // count
  unsigned long int count;
  // cursize
  unsigned long int cursize;
  // certs
  struct _zhashx_t *certs;
};

struct _zchunk_t
{
  // tag
  unsigned int tag;
  // size
  unsigned long int size;
  // max_size
  unsigned long int max_size;
  // consumed
  unsigned long int consumed;
  // digest
  struct _zdigest_t *digest;
  // data
  unsigned char *data;
};

struct _zconfig_t
{
  // name
  char *name;
  // value
  char *value;
  // child
  struct _zconfig_t *child;
  // next
  struct _zconfig_t *next;
  // parent
  struct _zconfig_t *parent;
  // comments
  struct _zlist_t *comments;
  // file
  struct _zfile_t *file;
};

struct _zctx_t
{
  // context
  void *context;
  // sockets
  struct _zlist_t *sockets;
  // mutex
  struct _zmutex_t *mutex;
  // shadow
  _Bool shadow;
  // iothreads
  signed int iothreads;
  // linger
  signed int linger;
  // pipehwm
  signed int pipehwm;
  // sndhwm
  signed int sndhwm;
  // rcvhwm
  signed int rcvhwm;
};

struct sha1_ctxt
{
  // h
  union anonymous h;
  // c
  union anonymous_0 c;
  // m
  union anonymous_1 m;
  // count
  unsigned char count;
};

struct _zdigest_t
{
  // context
  struct sha1_ctxt context;
  // hash
  unsigned char hash[20l];
  // string
  char string[41l];
  // final
  _Bool final;
};

struct _zdir_patch_t
{
  // path
  char *path;
  // vpath
  char *vpath;
  // file
  struct _zfile_t *file;
  // op
  enum anonymous_6 op;
  // digest
  char *digest;
};

struct _zdir_t
{
  // path
  char *path;
  // files
  struct _zlist_t *files;
  // subdirs
  struct _zlist_t *subdirs;
  // modified
  signed long int modified;
  // cursize
  signed long int cursize;
  // count
  unsigned long int count;
  // trimmed
  _Bool trimmed;
};

struct _zdir_watch_sub_t
{
  // dir
  struct _zdir_t *dir;
};

struct _zdir_watch_t
{
  // pipe
  struct _zsock_t *pipe;
  // loop
  struct _zloop_t *loop;
  // read_timer_id
  signed int read_timer_id;
  // verbose
  _Bool verbose;
  // subs
  struct _zhash_t *subs;
};

struct _zfile_t
{
  // fullname
  char *fullname;
  // link
  char *link;
  // exists
  _Bool exists;
  // stable
  _Bool stable;
  // eof
  _Bool eof;
  // handle
  struct _IO_FILE *handle;
  // digest
  struct _zdigest_t *digest;
  // curline
  char *curline;
  // linemax
  unsigned long int linemax;
  // modified
  signed long int modified;
  // cursize
  signed long int cursize;
  // mode
  unsigned int mode;
};

struct zmq_msg_t
{
  // _
  unsigned char _[64l];
};

struct _zframe_t
{
  // tag
  unsigned int tag;
  // zmsg
  struct zmq_msg_t zmsg;
  // more
  signed int more;
};

struct _zgossip_msg_t
{
  // routing_id
  struct _zframe_t *routing_id;
  // id
  signed int id;
  // needle
  unsigned char *needle;
  // ceiling
  unsigned char *ceiling;
  // key
  char key[256l];
  // value
  char *value;
  // ttl
  unsigned int ttl;
};

struct _zhashx_t
{
  // size
  unsigned long int size;
  // prime_index
  unsigned int prime_index;
  // chain_limit
  unsigned int chain_limit;
  // items
  struct _item_t **items;
  // cached_index
  unsigned long int cached_index;
  // cursor_index
  unsigned long int cursor_index;
  // cursor_item
  struct _item_t *cursor_item;
  // cursor_key
  const void *cursor_key;
  // comments
  struct _zlistx_t *comments;
  // modified
  signed long int modified;
  // filename
  char *filename;
  // duplicator
  void * (*duplicator)(const void *);
  // destructor
  void (*destructor)(void **);
  // key_duplicator
  void * (*key_duplicator)(const void *);
  // key_destructor
  void (*key_destructor)(void **);
  // key_comparator
  signed int (*key_comparator)(const void *, const void *);
  // hasher
  unsigned long int (*hasher)(const void *);
};

struct _zlistx_t
{
  // head
  struct _node_t *head;
  // tail
  struct _node_t *tail;
  // cursor
  struct _node_t *cursor;
  // size
  unsigned long int size;
  // duplicator
  void * (*duplicator)(const void *);
  // comparator
  signed int (*comparator)(const void *, const void *);
  // destructor
  void (*destructor)(void **);
};

struct _zloop_t
{
  // readers
  struct _zlistx_t *readers;
  // pollers
  struct _zlistx_t *pollers;
  // timers
  struct _zlistx_t *timers;
  // tickets
  struct _zlistx_t *tickets;
  // last_timer_id
  signed int last_timer_id;
  // max_timers
  unsigned long int max_timers;
  // ticket_delay
  unsigned long int ticket_delay;
  // poll_size
  unsigned long int poll_size;
  // pollset
  struct zmq_pollitem_t *pollset;
  // readact
  struct _s_reader_t *readact;
  // pollact
  struct _s_poller_t *pollact;
  // need_rebuild
  _Bool need_rebuild;
  // verbose
  _Bool verbose;
  // terminated
  _Bool terminated;
  // ignore_interrupts
  _Bool ignore_interrupts;
  // zombies
  struct _zlistx_t *zombies;
};

struct _zmonitor_t
{
  // socket
  void *socket;
  // pipe
  void *pipe;
};

struct _zmsg_t
{
  // tag
  unsigned int tag;
  // frames
  struct _zlist_t *frames;
  // content_size
  unsigned long int content_size;
};

struct _zmutex_t
{
  // mutex
  union anonymous_3 mutex;
};

struct _zpoller_t
{
  // reader_list
  struct _zlist_t *reader_list;
  // poll_set
  struct zmq_pollitem_t *poll_set;
  // poll_readers
  void **poll_readers;
  // poll_size
  unsigned long int poll_size;
  // need_rebuild
  _Bool need_rebuild;
  // expired
  _Bool expired;
  // terminated
  _Bool terminated;
  // ignore_interrupts
  _Bool ignore_interrupts;
};

struct _zproxy_t
{
  // ctx
  struct _zctx_t *ctx;
  // pipe
  void *pipe;
  // frontend
  void *frontend;
  // backend
  void *backend;
};

struct slre
{
  // code
  unsigned char code[256l];
  // data
  unsigned char data[256l];
  // code_size
  signed int code_size;
  // data_size
  signed int data_size;
  // num_caps
  signed int num_caps;
  // anchored
  signed int anchored;
  // err_str
  const char *err_str;
};

struct cap
{
  // ptr
  const char *ptr;
  // len
  unsigned long int len;
};

struct _zrex_t
{
  // slre
  struct slre slre;
  // valid
  _Bool valid;
  // strerror
  const char *strerror;
  // hits
  unsigned int hits;
  // hit_set_len
  unsigned long int hit_set_len;
  // hit_set
  char *hit_set;
  // hit
  char *hit[100l];
  // caps
  struct cap caps[100l];
};

struct _zsock_t
{
  // tag
  unsigned int tag;
  // handle
  void *handle;
  // endpoint
  char *endpoint;
  // cache
  char *cache;
  // type
  signed int type;
  // cache_size
  unsigned long int cache_size;
};

struct _zuuid_t
{
  // uuid
  unsigned char uuid[16l];
  // str
  char str[33l];
  // str_canonical
  char *str_canonical;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct ifaddrs
{
  // ifa_next
  struct ifaddrs *ifa_next;
  // ifa_name
  char *ifa_name;
  // ifa_flags
  unsigned int ifa_flags;
  // ifa_addr
  struct sockaddr *ifa_addr;
  // ifa_netmask
  struct sockaddr *ifa_netmask;
  // ifa_ifu
  union anonymous_20 ifa_ifu;
  // ifa_data
  void *ifa_data;
};

struct in6_addr
{
  // __in6_u
  union anonymous_40 __in6_u;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_17 __sigaction_handler;
  // sa_mask
  struct anonymous_2 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// _K
// file src/foreign/sha1/sha1.inc_c line 40
static unsigned int _K[4l] = { (unsigned int)0x5a827999, (unsigned int)0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6 };
// _NUM_MODES
// file src/zarmour.c line 61
const signed int _NUM_MODES = 6;
// handle_signals
// file src/zsys.c line 38
static _Bool handle_signals = (_Bool)1;
// meta_chars
// file src/foreign/slre/slre.inc_c line 87
static const char *meta_chars = "|.^_*+?()[\\";
// opcodes
// file src/foreign/slre/slre.inc_c line 30
static struct anonymous_38 opcodes[23l] = { { .name="END", .narg=0, .flags="" }, { .name="BRANCH", .narg=2, .flags="oo" },
    { .name="ANY", .narg=0, .flags="" }, { .name="EXACT", .narg=2, .flags="d" }, { .name="ANYOF", .narg=2, .flags="D" }, { .name="ANYBUT", .narg=2, .flags="D" },
    { .name="OPEN ", .narg=1, .flags="i" }, { .name="CLOSE", .narg=1, .flags="i" }, { .name="BOL", .narg=0, .flags="" }, { .name="EOL", .narg=0, .flags="" }, { .name="STAR", .narg=1, .flags="o" }, { .name="PLUS", .narg=1, .flags="o" }, { .name="STARQ", .narg=1, .flags="o" }, { .name="PLUSQ", .narg=1, .flags="o" }, { .name="QUEST", .narg=1, .flags="o" }, { .name="SPACE", .narg=0, .flags="" }, { .name="NONSPACE", .narg=0, .flags="" },
    { .name="DIGIT", .narg=0, .flags="" }, { .name="NONDIGIT", .narg=0, .flags="" },
    { .name="ALPHA", .narg=0, .flags="" }, { .name="NONALPHA", .narg=0, .flags="" },
    { .name="ALNUM", .narg=0, .flags="" }, { .name="NONALNUM", .narg=0, .flags="" } };
// primes
// file src/zhash_primes.inc line 23
static unsigned long int primes[300l] = { 3LLU, 5LLU, 7LLU, 11LLU, 13LLU, 17LLU, 19LLU, 23LLU, 29LLU, 31LLU, 43LLU, 47LLU, 53LLU, 59LLU, 61LLU, 103LLU, 107LLU, 109LLU, 113LLU, 127LLU, 229LLU, 233LLU, 239LLU, 241LLU, 251LLU, 487LLU, 491LLU, 499LLU, 503LLU, 509LLU, 997LLU, 1009LLU, 1013LLU, 1019LLU, 1021LLU, 2011LLU, 2017LLU, 2027LLU, 2029LLU, 2039LLU, 4057LLU, 4073LLU, 4079LLU, 4091LLU, 4093LLU, 8161LLU, 8167LLU, 8171LLU, 8179LLU, 8191LLU, 16349LLU, 16361LLU, 16363LLU, 16369LLU, 16381LLU, 32707LLU, 32713LLU, 32717LLU, 32719LLU, 32749LLU, 65449LLU, 65479LLU, 65497LLU, 65519LLU, 65521LLU, 131023LLU, 131041LLU, 131059LLU, 131063LLU, 131071LLU, 262111LLU, 262121LLU, 262127LLU, 262133LLU, 262139LLU, 524243LLU, 524257LLU, 524261LLU, 524269LLU, 524287LLU, 1048517LLU, 1048549LLU, 1048559LLU, 1048571LLU, 1048573LLU, 2097091LLU, 2097097LLU, 2097131LLU, 2097133LLU, 2097143LLU, 4194247LLU, 4194271LLU, 4194277LLU, 4194287LLU, 4194301LLU, 8388547LLU, 8388571LLU, 8388581LLU, 8388587LLU, 8388593LLU, 16777141LLU, 16777153LLU, 16777183LLU, 16777199LLU, 16777213LLU, 33554341LLU, 33554347LLU, 33554371LLU, 33554383LLU, 33554393LLU, 67108763LLU, 67108777LLU, 67108819LLU, 67108837LLU, 67108859LLU, 134217593LLU, 134217613LLU, 134217617LLU, 134217649LLU, 134217689LLU, 268435331LLU, 268435337LLU, 268435361LLU, 268435367LLU, 268435399LLU, 536870839LLU, 536870849LLU, 536870869LLU, 536870879LLU, 536870909LLU, 1073741719LLU, 1073741723LLU, 1073741741LLU, 1073741783LLU, 1073741789LLU, 2147483563LLU, 2147483579LLU, 2147483587LLU, 2147483629LLU, 2147483647LLU, 4294967197LLU, 4294967231LLU, 4294967279LLU, 4294967291LLU, 4294967295LLU, 8589934581LLU, 8589934585LLU, 8589934587LLU, 8589934589LLU, 8589934591LLU, 17179869175LLU, 17179869177LLU, 17179869179LLU, 17179869181LLU, 17179869183LLU, 34359738359LLU, 34359738361LLU, 34359738363LLU, 34359738365LLU, 34359738367LLU, 68719476725LLU, 68719476727LLU, 68719476729LLU, 68719476733LLU, 68719476735LLU, 137438953463LLU, 137438953465LLU, 137438953467LLU, 137438953469LLU, 137438953471LLU, 274877906935LLU, 274877906937LLU, 274877906939LLU, 274877906941LLU, 274877906943LLU, 549755813877LLU, 549755813879LLU, 549755813883LLU, 549755813885LLU, 549755813887LLU, 1099511627767LLU, 1099511627769LLU, 1099511627771LLU, 1099511627773LLU, 1099511627775LLU, 2199023255543LLU, 2199023255545LLU, 2199023255547LLU, 2199023255549LLU, 2199023255551LLU, 4398046511095LLU, 4398046511097LLU, 4398046511099LLU, 4398046511101LLU, 4398046511103LLU, 8796093022199LLU, 8796093022201LLU, 8796093022203LLU, 8796093022205LLU, 8796093022207LLU, 17592186044407LLU, 17592186044409LLU, 17592186044411LLU, 17592186044413LLU, 17592186044415LLU, 35184372088823LLU, 35184372088825LLU, 35184372088827LLU, 35184372088829LLU, 35184372088831LLU, 70368744177655LLU, 70368744177657LLU, 70368744177659LLU, 70368744177661LLU, 70368744177663LLU, 140737488355319LLU, 140737488355321LLU, 140737488355323LLU, 140737488355325LLU, 140737488355327LLU, 281474976710647LLU, 281474976710649LLU, 281474976710651LLU, 281474976710653LLU, 281474976710655LLU, 562949953421303LLU, 562949953421305LLU, 562949953421307LLU, 562949953421309LLU, 562949953421311LLU, 1125899906842615LLU, 1125899906842617LLU, 1125899906842619LLU, 1125899906842621LLU, 1125899906842623LLU, 2251799813685239LLU, 2251799813685241LLU, 2251799813685243LLU, 2251799813685245LLU, 2251799813685247LLU, 4503599627370487LLU, 4503599627370489LLU, 4503599627370491LLU, 4503599627370493LLU, 4503599627370495LLU, 9007199254740983LLU, 9007199254740985LLU, 9007199254740987LLU, 9007199254740989LLU, 9007199254740991LLU, 18014398509481975LLU, 18014398509481977LLU, 18014398509481979LLU, 18014398509481981LLU, 18014398509481983LLU, 36028797018963959LLU, 36028797018963961LLU, 36028797018963963LLU, 36028797018963965LLU, 36028797018963967LLU, 72057594037927925LLU, 72057594037927927LLU, 72057594037927929LLU, 72057594037927933LLU, 72057594037927935LLU, 144115188075855863LLU, 144115188075855865LLU, 144115188075855867LLU, 144115188075855869LLU, 144115188075855871LLU, 288230376151711735LLU, 288230376151711737LLU, 288230376151711739LLU, 288230376151711741LLU, 288230376151711743LLU, 576460752303423479LLU, 576460752303423481LLU, 576460752303423483LLU, 576460752303423485LLU, 576460752303423487LLU, 1152921504606846967LLU, 1152921504606846969LLU, 1152921504606846971LLU, 1152921504606846973LLU, 1152921504606846975LLU, 2305843009213693941LLU, 2305843009213693943LLU, 2305843009213693945LLU, 2305843009213693947LLU, 2305843009213693949LLU, 4611686018427387895LLU, 4611686018427387897LLU, 4611686018427387899LLU, 4611686018427387901LLU, 4611686018427387903LLU, 9223372036854775799LLU, 9223372036854775801LLU, 9223372036854775803LLU, 9223372036854775805LLU, 9223372036854775807LLU };
// s_base16_alphabet
// file src/zarmour.c line 355
static char s_base16_alphabet[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 0 };
// s_base32_alphabet
// file src/zarmour.c line 245
static char s_base32_alphabet[33l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '2', '3', '4', '5', '6', '7', 0 };
// s_base32hex_alphabet
// file src/zarmour.c line 250
static char s_base32hex_alphabet[33l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 0 };
// s_base64_alphabet
// file src/zarmour.c line 170
static char s_base64_alphabet[65l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', 0 };
// s_base64url_alphabet
// file src/zarmour.c line 175
static char s_base64url_alphabet[65l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_', 0 };
// s_codec_names
// file src/zarmour.c line 67
static char s_codec_names[6l][16l] = { { 'b', 'a', 's', 'e', '6', '4', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'b', 'a', 's', 'e', '6', '4', 'u', 'r', 'l', 0, 0, 0, 0, 0, 0, 0 },
    { 'b', 'a', 's', 'e', '3', '2', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'b', 'a', 's', 'e', '3', '2', 'h', 'e', 'x', 0, 0, 0, 0, 0, 0, 0 },
    { 'b', 'a', 's', 'e', '1', '6', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'z', '8', '5', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
// s_event_name
// file src/zgossip_engine.inc line 57
static char *s_event_name[9l] = { "(NONE)", "terminate", "HELLO", "ok", "finished", "PUBLISH", "forward", "PING", "expired" };
// s_first_time
// file src/zsys.c line 37
static _Bool s_first_time = (_Bool)1;
// s_initialized
// file src/zsys.c line 63
static _Bool s_initialized = (_Bool)0;
// s_interface
// file src/zsys.c line 74
static char *s_interface = (char *)(void *)0;
// s_io_threads
// file src/zsys.c line 67
static unsigned long int s_io_threads = (unsigned long int)1;
// s_ipv6
// file src/zsys.c line 73
static signed int s_ipv6 = 0;
// s_linger
// file src/zsys.c line 69
static unsigned long int s_linger = (unsigned long int)0;
// s_logident
// file src/zsys.c line 75
static char *s_logident = (char *)(void *)0;
// s_logsender
// file src/zsys.c line 78
static struct _zsock_t *s_logsender = (struct _zsock_t *)(void *)0;
// s_logstream
// file src/zsys.c line 76
static struct _IO_FILE *s_logstream = (struct _IO_FILE *)(void *)0;
// s_logsystem
// file src/zsys.c line 77
static _Bool s_logsystem = (_Bool)0;
// s_max_sockets
// file src/zsys.c line 68
static unsigned long int s_max_sockets = (unsigned long int)1024;
// s_mutex
// file src/zsys.c line 110
static union anonymous_3 s_mutex;
// s_old_mask
// file src/zsys.c line 703
static unsigned int s_old_mask = (unsigned int)0;
// s_open_sockets
// file src/zsys.c line 81
static unsigned long int s_open_sockets = (unsigned long int)0;
// s_pipehwm
// file src/zsys.c line 72
static unsigned long int s_pipehwm = (unsigned long int)1000;
// s_process_ctx
// file src/zsys.c line 62
static void *s_process_ctx = (void *)0;
// s_rcvhwm
// file src/zsys.c line 71
static unsigned long int s_rcvhwm = (unsigned long int)1000;
// s_sndhwm
// file src/zsys.c line 70
static unsigned long int s_sndhwm = (unsigned long int)1000;
// s_sockref_list
// file src/zsys.c line 84
static struct _zlist_t *s_sockref_list = (struct _zlist_t *)(void *)0;
// s_state_name
// file src/zgossip_engine.inc line 48
static char *s_state_name[5l] = { "(NONE)", "start", "have tuple", "connected", "external" };
// sigint_default
// file src/zsys.c line 40
static struct sigaction sigint_default;
// sigterm_default
// file src/zsys.c line 41
static struct sigaction sigterm_default;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// zctx_interrupted
// file src/zsys.c line 31
volatile signed int zctx_interrupted = 0;
// zsys_allocs
// file src/zsys.c line 32
volatile unsigned long int zsys_allocs = (volatile unsigned long int)0;
// zsys_interrupted
// file src/zsys.c line 30
volatile signed int zsys_interrupted = 0;

// anyof
// file src/foreign/slre/slre.inc_c line 223
static void anyof(struct slre *r, const char **re)
{
  signed int esc;
  signed int old_data_size = r->data_size;
  signed int op = 4;
  if((signed int)*(*re) == 94)
  {
    op = 5;
    *re = *re + 1l;
  }

  while(!((signed int)*(*re) == 0))
  {
    const char *tmp_post_1 = *re;
    *re = *re + 1l;
    switch((signed int)*tmp_post_1)
    {
      case 93:
      {
        emit(r, op);
        emit(r, old_data_size);
        emit(r, r->data_size - old_data_size);
        goto __CPROVER_DUMP_L9;
      }
      case 92:
      {
        esc=get_escape_char(re);
        if((0xff & esc) == 0)
        {
          store_char_in_data(r, 0);
          store_char_in_data(r, esc >> 8);
        }

        else
          store_char_in_data(r, esc);
        break;
      }
      default:
        store_char_in_data(r, (signed int)(*re)[(signed long int)-1]);
    }
  }
  r->err_str = "No closing ']' bracket";

__CPROVER_DUMP_L9:
  ;
}

// assert_status
// file src/test_zgossip.c line 4
void assert_status(struct _zactor_t *actor, signed int count)
{
  zstr_sendx((void *)actor, "STATUS", (void *)0);
  _Bool ready = (_Bool)0;
  while(ready == (_Bool)0)
  {
    char *command;
    char *status;
    zstr_recvx((void *)actor, &command, &status, (void *)0);
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(command, "STATUS");
    if(return_value_strcmp_2 == 0)
    {
      signed int return_value_atoi_1;
      return_value_atoi_1=atoi(status);
      /* assertion atoi (status) == count */
      assert(return_value_atoi_1 == count);
      ready = (_Bool)1;
    }

    free((void *)command);
    free((void *)status);
  }
}

// client_initialize
// file src/zgossip.c line 309
static signed int client_initialize(struct _client_t *self)
{
  return 0;
}

// client_terminate
// file src/zgossip.c line 318
static void client_terminate(struct _client_t *self)
{
  ;
}

// compile
// file src/foreign/slre/slre.inc_c line 299
static void compile(struct slre *r, const char **re)
{
  signed int op;
  signed int esc;
  signed int branch_start;
  signed int last_op;
  signed int fixup;
  signed int cap_no;
  signed int level;
  fixup = 0;
  level = r->num_caps;
  last_op = r->code_size;
  branch_start = last_op;
  do
  {
    const char *tmp_post_1 = *re;
    *re = *re + 1l;
    switch((signed int)*tmp_post_1)
    {
      case 0:
      {
        *re = *re - 1l;
        goto __CPROVER_DUMP_L20;
      }
      case 94:
      {
        emit(r, 8);
        break;
      }
      case 36:
      {
        emit(r, 9);
        break;
      }
      case 46:
      {
        last_op = r->code_size;
        emit(r, 2);
        break;
      }
      case 91:
      {
        last_op = r->code_size;
        anyof(r, re);
        break;
      }
      case 92:
      {
        last_op = r->code_size;
        esc=get_escape_char(re);
        if(!((0xff00 & esc) == 0))
          emit(r, esc >> 8);

        else
          exact_one_char(r, esc);
        break;
      }
      case 40:
      {
        last_op = r->code_size;
        r->num_caps = r->num_caps + 1;
        cap_no = r->num_caps;
        emit(r, 6);
        emit(r, cap_no);
        compile(r, re);
        const char *tmp_post_2 = *re;
        *re = *re + 1l;
        if(!((signed int)*tmp_post_2 == 41))
        {
          r->err_str = "No closing bracket";
          goto __CPROVER_DUMP_L20;
        }

        emit(r, 7);
        emit(r, cap_no);
        break;
      }
      case 41:
      {
        *re = *re - 1l;
        fixup_branch(r, fixup);
        if(level == 0)
        {
          r->err_str = "Unbalanced brackets";
          goto __CPROVER_DUMP_L20;
        }

        goto __CPROVER_DUMP_L20;
      }
      case 43:

      case 42:
      {
        op = (signed int)(*re)[(signed long int)-1] == 42 ? 10 : 11;
        if((signed int)*(*re) == 63)
        {
          *re = *re + 1l;
          op = op == 10 ? 12 : 13;
        }

        quantifier(r, last_op, op);
        break;
      }
      case 63:
      {
        quantifier(r, last_op, 14);
        break;
      }
      case 124:
      {
        fixup_branch(r, fixup);
        relocate(r, branch_start, 3);
        r->code[(signed long int)branch_start] = (unsigned char)1;
        set_jump_offset(r, branch_start + 1, branch_start);
        fixup = branch_start + 2;
        r->code[(signed long int)fixup] = (unsigned char)0xff;
        break;
      }
      default:
      {
        *re = *re - 1l;
        last_op = r->code_size;
        exact(r, re);
      }
    }
  }
  while((_Bool)1);

__CPROVER_DUMP_L20:
  ;
}

// echo_actor
// file src/zactor.c line 247
static void echo_actor(struct _zsock_t *pipe, void *args)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp((char *)args, "Hello, World");
  /* assertion (!strcmp (((char *) args), ("Hello, World"))) */
  assert(!(return_value_strcmp_1 != 0));
  zsock_signal((void *)pipe, (unsigned char)0);
  _Bool terminated = (_Bool)0;
  signed int return_value_strcmp_2;
  while(terminated == (_Bool)0)
  {
    struct _zmsg_t *msg;
    msg=zmsg_recv((void *)pipe);
    if(msg == ((struct _zmsg_t *)NULL))
      break;

    char *command;
    command=zmsg_popstr(msg);
    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(command, "_TERM");
    if(return_value_strcmp_3 == 0)
      terminated = (_Bool)1;

    else
    {
      return_value_strcmp_2=strcmp(command, "ECHO");
      if(return_value_strcmp_2 == 0)
        zmsg_send(&msg, (void *)pipe);

      else
      {
        puts("E: invalid message to actor");
        /* assertion 0 */
        assert(0 != 0);
      }
    }
    free((void *)command);
    zmsg_destroy(&msg);
  }
}

// emit
// file src/foreign/slre/slre.inc_c line 169
static void emit(struct slre *r, signed int code)
{
  if(r->code_size >= (signed int)sizeof(unsigned char [256l]) /*256*/ )
    r->err_str = "RE is too long (code overflow)";

  else
  {
    signed int tmp_post_1 = r->code_size;
    r->code_size = r->code_size + 1;
    r->code[(signed long int)tmp_post_1] = (unsigned char)code;
  }
}

// engine_broadcast_event
// file src/zgossip_engine.inc line 200
static void engine_broadcast_event(struct _server_t *server, struct _client_t *client, enum anonymous_30 event)
{
  if(!(server == ((struct _server_t *)NULL)))
  {
    struct anonymous_28 *self = (struct anonymous_28 *)server;
    struct _zlist_t *keys;
    keys=zhash_keys(self->clients);
    char *key;
    void *return_value_zlist_first_1;
    return_value_zlist_first_1=zlist_first(keys);
    key = (char *)return_value_zlist_first_1;
    while(!(key == ((char *)NULL)))
    {
      struct anonymous_31 *target;
      void *return_value_zhash_lookup_2;
      return_value_zhash_lookup_2=zhash_lookup(self->clients, key);
      target = (struct anonymous_31 *)return_value_zhash_lookup_2;
      if(!(target == (struct anonymous_31 *)client))
        s_client_execute(target, event);

      void *return_value_zlist_next_3;
      return_value_zlist_next_3=zlist_next(keys);
      key = (char *)return_value_zlist_next_3;
    }
    zlist_destroy(&keys);
  }

}

// engine_configure
// file src/zgossip_engine.inc line 271
static void engine_configure(struct _server_t *server, const char *path, const char *value)
{
  if(!(server == ((struct _server_t *)NULL)))
  {
    struct anonymous_28 *self = (struct anonymous_28 *)server;
    zconfig_put(self->config, path, value);
  }

}

// engine_handle_socket
// file src/zgossip_engine.inc line 221
static void engine_handle_socket(struct _server_t *server, void *sock, signed int (*handler)(struct _zloop_t *, struct _zsock_t *, void *))
{
  struct _zsock_t *return_value_zactor_sock_1;
  _Bool return_value_zsock_is_2;
  if(!(server == ((struct _server_t *)NULL)))
  {
    struct anonymous_28 *self = (struct anonymous_28 *)server;
    _Bool return_value_zactor_is_3;
    return_value_zactor_is_3=zactor_is(sock);
    if(!(return_value_zactor_is_3 == (_Bool)0))
    {
      return_value_zactor_sock_1=zactor_sock((struct _zactor_t *)sock);
      sock = (void *)return_value_zactor_sock_1;
    }

    else
    {
      return_value_zsock_is_2=zsock_is(sock);
      /* assertion zsock_is (sock) */
      assert(return_value_zsock_is_2 != (_Bool)0);
    }
    if(!(handler == ((signed int (*)(struct _zloop_t *, struct _zsock_t *, void *))NULL)))
    {
      signed int rc;
      rc=zloop_reader(self->loop, (struct _zsock_t *)sock, handler, (void *)self);
      /* assertion rc == 0 */
      assert(rc == 0);
      zloop_reader_set_tolerant(self->loop, (struct _zsock_t *)sock);
    }

    else
      zloop_reader_end(self->loop, (struct _zsock_t *)sock);
  }

}

// engine_send_event
// file src/zgossip_engine.inc line 187
static void engine_send_event(struct _client_t *client, enum anonymous_30 event)
{
  if(!(client == ((struct _client_t *)NULL)))
  {
    struct anonymous_31 *self = (struct anonymous_31 *)client;
    s_client_execute(self, event);
  }

}

// engine_set_exception
// file src/zgossip_engine.inc line 156
static void engine_set_exception(struct _client_t *client, enum anonymous_30 event)
{
  if(!(client == ((struct _client_t *)NULL)))
  {
    struct anonymous_31 *self = (struct anonymous_31 *)client;
    self->exception = event;
  }

}

// engine_set_log_prefix
// file src/zgossip_engine.inc line 257
static void engine_set_log_prefix(struct _client_t *client, const char *string)
{
  if(!(client == ((struct _client_t *)NULL)))
  {
    struct anonymous_31 *self = (struct anonymous_31 *)client;
    snprintf(self->log_prefix, sizeof(char [41l]) /*41ul*/  - (unsigned long int)1, "%6d:%-33s", self->unique_id, string);
  }

}

// engine_set_monitor
// file src/zgossip_engine.inc line 244
static void engine_set_monitor(struct _server_t *server, unsigned long int interval, signed int (*monitor)(struct _zloop_t *, signed int, void *))
{
  if(!(server == ((struct _server_t *)NULL)))
  {
    struct anonymous_28 *self = (struct anonymous_28 *)server;
    signed int rc;
    rc=zloop_timer(self->loop, interval, (unsigned long int)0, monitor, (void *)self);
    /* assertion rc >= 0 */
    assert(rc >= 0);
  }

}

// engine_set_next_event
// file src/zgossip_engine.inc line 144
static void engine_set_next_event(struct _client_t *client, enum anonymous_30 event)
{
  if(!(client == ((struct _client_t *)NULL)))
  {
    struct anonymous_31 *self = (struct anonymous_31 *)client;
    self->next_event = event;
  }

}

// engine_set_wakeup_event
// file src/zgossip_engine.inc line 169
static void engine_set_wakeup_event(struct _client_t *client, unsigned long int delay, enum anonymous_30 event)
{
  if(!(client == ((struct _client_t *)NULL)))
  {
    struct anonymous_31 *self = (struct anonymous_31 *)client;
    if(!(self->wakeup == 0))
    {
      zloop_timer_end(self->server->loop, self->wakeup);
      self->wakeup = 0;
    }

    self->wakeup=zloop_timer(self->server->loop, delay, (unsigned long int)1, s_client_handle_wakeup, (void *)self);
    self->wakeup_event = event;
  }

}

// engine_verbose
// file src/zgossip_engine.inc line 282
static _Bool engine_verbose(struct _server_t *server)
{
  if(!(server == ((struct _server_t *)NULL)))
  {
    struct anonymous_28 *self = (struct anonymous_28 *)server;
    return self->verbose;
  }

  return (_Bool)0;
}

// exact
// file src/foreign/slre/slre.inc_c line 187
static void exact(struct slre *r, const char **re)
{
  signed int old_data_size = r->data_size;
  char *return_value_strchr_1;
  while(!((signed int)*(*re) == 0))
  {
    return_value_strchr_1=strchr(meta_chars, (signed int)*(*re));
    if(!(return_value_strchr_1 == ((char *)NULL)))
      break;

    const char *tmp_post_2 = *re;
    *re = *re + 1l;
    store_char_in_data(r, (signed int)*tmp_post_2);
  }
  emit(r, 3);
  emit(r, old_data_size);
  emit(r, r->data_size - old_data_size);
}

// exact_one_char
// file src/foreign/slre/slre.inc_c line 281
static void exact_one_char(struct slre *r, signed int ch)
{
  emit(r, 3);
  emit(r, r->data_size);
  emit(r, 1);
  store_char_in_data(r, ch);
}

// fixup_branch
// file src/foreign/slre/slre.inc_c line 290
static void fixup_branch(struct slre *r, signed int fixup)
{
  if(fixup >= 1)
  {
    emit(r, 0);
    set_jump_offset(r, fixup, fixup - 2);
  }

}

// get_escape_char
// file src/foreign/slre/slre.inc_c line 200
static signed int get_escape_char(const char **re)
{
  signed int res;
  const char *tmp_post_1 = *re;
  *re = *re + 1l;
  switch((signed int)*tmp_post_1)
  {
    case 110:
    {
      res = 10;
      break;
    }
    case 114:
    {
      res = 13;
      break;
    }
    case 116:
    {
      res = 9;
      break;
    }
    case 48:
    {
      res = 0;
      break;
    }
    case 115:
    {
      res = 15 << 8;
      break;
    }
    case 83:
    {
      res = 16 << 8;
      break;
    }
    case 100:
    {
      res = 17 << 8;
      break;
    }
    case 68:
    {
      res = 18 << 8;
      break;
    }
    case 97:
    {
      res = 19 << 8;
      break;
    }
    case 65:
    {
      res = 20 << 8;
      break;
    }
    case 119:
    {
      res = 21 << 8;
      break;
    }
    case 87:
    {
      res = 22 << 8;
      break;
    }
    default:
      res = (signed int)(*re)[(signed long int)-1];
  }
  return res;
}

// get_first_tuple
// file src/zgossip.c line 329
static void get_first_tuple(struct _client_t *self)
{
  struct _tuple_t *tuple;
  void *return_value_zhashx_first_1;
  return_value_zhashx_first_1=zhashx_first(self->server->tuples);
  tuple = (struct _tuple_t *)return_value_zhashx_first_1;
  if(!(tuple == ((struct _tuple_t *)NULL)))
  {
    zgossip_msg_set_key(self->message, tuple->key);
    zgossip_msg_set_value(self->message, tuple->value);
    engine_set_next_event(self, (enum anonymous_30)ok_event);
  }

  else
    engine_set_next_event(self, (enum anonymous_30)finished_event);
}

// get_next_tuple
// file src/zgossip.c line 347
static void get_next_tuple(struct _client_t *self)
{
  struct _tuple_t *tuple;
  void *return_value_zhashx_next_1;
  return_value_zhashx_next_1=zhashx_next(self->server->tuples);
  tuple = (struct _tuple_t *)return_value_zhashx_next_1;
  if(!(tuple == ((struct _tuple_t *)NULL)))
  {
    zgossip_msg_set_key(self->message, tuple->key);
    zgossip_msg_set_value(self->message, tuple->value);
    engine_set_next_event(self, (enum anonymous_30)ok_event);
  }

  else
    engine_set_next_event(self, (enum anonymous_30)finished_event);
}

// get_tuple_to_forward
// file src/zgossip.c line 378
static void get_tuple_to_forward(struct _client_t *self)
{
  struct _tuple_t *tuple = self->server->cur_tuple;
  zgossip_msg_set_key(self->message, tuple->key);
  zgossip_msg_set_value(self->message, tuple->value);
}

// is_any_but
// file src/foreign/slre/slre.inc_c line 457
static signed int is_any_but(const unsigned char *p, signed int len, const char *s, unsigned long int *ofs)
{
  signed int i;
  signed int ch = (signed int)s[(signed long int)*ofs];
  i = 0;
  for( ; !(i >= len); i = i + 1)
    if((signed int)p[(signed long int)i] == ch)
      return 0;

  *ofs = *ofs + 1ul;
  return 1;
}

// is_any_of
// file src/foreign/slre/slre.inc_c line 441
static signed int is_any_of(const unsigned char *p, signed int len, const char *s, unsigned long int *ofs)
{
  signed int i;
  signed int ch = (signed int)s[(signed long int)*ofs];
  i = 0;
  for( ; !(i >= len); i = i + 1)
    if((signed int)p[(signed long int)i] == ch)
    {
      *ofs = *ofs + 1ul;
      return 1;
    }

  return 0;
}

// loop_greedy
// file src/foreign/slre/slre.inc_c line 410
static void loop_greedy(struct slre *r, signed int pc, const char *s, unsigned long int len, unsigned long int *ofs)
{
  unsigned long int saved_offset;
  unsigned long int matched_offset = *ofs;
  saved_offset = matched_offset;
  signed int return_value_match_1;
  do
  {
    return_value_match_1=match(r, pc + 2, s, len, ofs, (struct cap *)(void *)0);
    if(return_value_match_1 == 0)
      break;

    saved_offset = *ofs;
    signed int return_value_match_2;
    return_value_match_2=match(r, pc + (signed int)r->code[(signed long int)(pc + 1)], s, len, ofs, (struct cap *)(void *)0);
    if(!(return_value_match_2 == 0))
      matched_offset = saved_offset;

    *ofs = saved_offset;
  }
  while((_Bool)1);
  *ofs = matched_offset;
}

// loop_non_greedy
// file src/foreign/slre/slre.inc_c line 427
static void loop_non_greedy(struct slre *r, signed int pc, const char *s, unsigned long int len, unsigned long int *ofs)
{
  unsigned long int saved_offset = *ofs;
  signed int return_value_match_1;
  do
  {
    return_value_match_1=match(r, pc + 2, s, len, ofs, (struct cap *)(void *)0);
    if(return_value_match_1 == 0)
      break;

    saved_offset = *ofs;
    signed int return_value_match_2;
    return_value_match_2=match(r, pc + (signed int)r->code[(signed long int)(pc + 1)], s, len, ofs, (struct cap *)(void *)0);
    if(!(return_value_match_2 == 0))
      break;

  }
  while((_Bool)1);
  *ofs = saved_offset;
}

// main
// file src/test_zgossip.c line 25
signed int main(signed int argn, char **argv)
{
  zsys_set_max_sockets((unsigned long int)65535);
  printf("Starting small test case: ");
  fflush(stdout);
  struct _zactor_t *server1;
  server1=zactor_new(zgossip, (void *)"server1");
  /* assertion server1 */
  assert(server1 != ((struct _zactor_t *)NULL));
  zstr_sendx((void *)server1, "SET", (const void *)"server/animate", (const void *)"0", (void *)0);
  zstr_sendx((void *)server1, "BIND", (const void *)"inproc://server1", (void *)0);
  struct _zactor_t *server2;
  server2=zactor_new(zgossip, (void *)"server2");
  /* assertion server2 */
  assert(server2 != ((struct _zactor_t *)NULL));
  zstr_sendx((void *)server2, "SET", (const void *)"server/animate", (const void *)"0", (void *)0);
  zstr_sendx((void *)server2, "BIND", (const void *)"inproc://server2", (void *)0);
  zstr_sendx((void *)server2, "CONNECT", (const void *)"inproc://server1", (void *)0);
  struct _zactor_t *client1;
  client1=zactor_new(zgossip, (void *)"client1");
  /* assertion client1 */
  assert(client1 != ((struct _zactor_t *)NULL));
  zstr_sendx((void *)client1, "BIND", (const void *)"inproc://client1", (void *)0);
  zstr_sendx((void *)client1, "PUBLISH", (const void *)"client1-00", (const void *)"0000", (void *)0);
  zstr_sendx((void *)client1, "PUBLISH", (const void *)"client1-11", (const void *)"1111", (void *)0);
  zstr_sendx((void *)client1, "PUBLISH", (const void *)"client1-22", (const void *)"2222", (void *)0);
  zstr_sendx((void *)client1, "CONNECT", (const void *)"inproc://server1", (void *)0);
  struct _zactor_t *client2;
  client2=zactor_new(zgossip, (void *)"client2");
  /* assertion client2 */
  assert(client2 != ((struct _zactor_t *)NULL));
  zstr_sendx((void *)client2, "BIND", (const void *)"inproc://client2", (void *)0);
  zstr_sendx((void *)client2, "CONNECT", (const void *)"inproc://server1", (void *)0);
  zstr_sendx((void *)client2, "PUBLISH", (const void *)"client2-00", (const void *)"0000", (void *)0);
  zstr_sendx((void *)client2, "PUBLISH", (const void *)"client2-11", (const void *)"1111", (void *)0);
  zstr_sendx((void *)client2, "PUBLISH", (const void *)"client2-22", (const void *)"2222", (void *)0);
  struct _zactor_t *client3;
  client3=zactor_new(zgossip, (void *)"client3");
  /* assertion client3 */
  assert(client3 != ((struct _zactor_t *)NULL));
  zstr_sendx((void *)client3, "CONNECT", (const void *)"inproc://server2", (void *)0);
  struct _zactor_t *client4;
  client4=zactor_new(zgossip, (void *)"client4");
  /* assertion client4 */
  assert(client4 != ((struct _zactor_t *)NULL));
  zstr_sendx((void *)client4, "CONNECT", (const void *)"inproc://server2", (void *)0);
  zclock_sleep(100);
  assert_status(server1, 6);
  assert_status(server2, 6);
  assert_status(client1, 6);
  assert_status(client2, 6);
  assert_status(client3, 6);
  assert_status(client4, 6);
  zactor_destroy(&server1);
  zactor_destroy(&server2);
  zactor_destroy(&client1);
  zactor_destroy(&client2);
  zactor_destroy(&client3);
  zactor_destroy(&client4);
  printf("OK\n");
  printf("Starting swarm test case: ");
  fflush(stdout);
  signed int swarm_size = 254;
  if(argn >= 2)
    swarm_size=atoi(argv[(signed long int)1]);

  printf("swarm_size=%d ", swarm_size);
  signed int set_size = swarm_size * 5;
  if(argn >= 3)
    set_size=atoi(argv[(signed long int)2]);

  printf("set_size=%d ", set_size);
  const signed long int set_size_array_size0 = (signed long int)swarm_size;
  struct _zactor_t *nodes[set_size_array_size0];
  struct _zpoller_t *poller;
  poller=zpoller_new((void *)0);
  /* assertion poller */
  assert(poller != ((struct _zpoller_t *)NULL));
  unsigned int node_nbr = (unsigned int)0;
  for( ; !(node_nbr >= (unsigned int)swarm_size); node_nbr = node_nbr + 1u)
  {
    nodes[(signed long int)node_nbr]=zactor_new(zgossip, (void *)0);
    /* assertion nodes [node_nbr] */
    assert(nodes[(signed long int)node_nbr] != ((struct _zactor_t *)NULL));
    zpoller_add(poller, (void *)nodes[(signed long int)node_nbr]);
  }
  printf(".");
  fflush(stdout);
  node_nbr = (unsigned int)0;
  for( ; !(node_nbr >= (unsigned int)swarm_size); node_nbr = node_nbr + 1u)
  {
    zstr_sendm((void *)nodes[(signed long int)node_nbr], "BIND");
    zstr_sendf((void *)nodes[(signed long int)node_nbr], "inproc://swarm-%d", node_nbr);
    if(node_nbr >= 1u)
    {
      zstr_sendm((void *)nodes[(signed long int)node_nbr], "CONNECT");
      signed long int return_value_random_1;
      return_value_random_1=random();
      zstr_sendf((void *)nodes[(signed long int)node_nbr], "inproc://swarm-%d", (signed int)((double)((float)node_nbr * (float)return_value_random_1) / ((double)2147483647 + 1.0)));
    }

  }
  zstr_sendm((void *)nodes[(signed long int)0], "CONNECT");
  zstr_sendf((void *)nodes[(signed long int)0], "inproc://swarm-%d", node_nbr - (unsigned int)1);
  printf(".");
  fflush(stdout);
  signed int item_nbr = 0;
  for( ; !(item_nbr >= set_size); item_nbr = item_nbr + 1)
  {
    signed long int return_value_random_2;
    return_value_random_2=random();
    node_nbr = (unsigned int)(signed int)((double)((float)swarm_size * (float)return_value_random_2) / ((double)2147483647 + 1.0));
    zstr_sendm((void *)nodes[(signed long int)node_nbr], "PUBLISH");
    zstr_sendfm((void *)nodes[(signed long int)node_nbr], "key-%d", item_nbr);
    zstr_send((void *)nodes[(signed long int)node_nbr], "value");
  }
  printf(". ");
  fflush(stdout);
  signed int total = set_size * swarm_size;
  signed int pending = total;
  signed long int ticker;
  signed long int return_value_zclock_mono_3;
  return_value_zclock_mono_3=zclock_mono();
  ticker = return_value_zclock_mono_3 + (signed long int)2000;
  while(!(pending == 0))
  {
    struct _zsock_t *which;
    void *return_value_zpoller_wait_4;
    return_value_zpoller_wait_4=zpoller_wait(poller, 100);
    which = (struct _zsock_t *)return_value_zpoller_wait_4;
    if(which == ((struct _zsock_t *)NULL))
    {
      puts(" - stuck test, aborting");
      break;
    }

    char *command;
    zstr_recvx((void *)which, &command, (void *)0);
    signed int return_value_strcmp_5;
    return_value_strcmp_5=strcmp(command, "DELIVER");
    /* assertion (!strcmp ((command), ("DELIVER"))) */
    assert(!(return_value_strcmp_5 != 0));
    pending = pending - 1;
    free((void *)command);
    signed long int return_value_zclock_mono_7;
    return_value_zclock_mono_7=zclock_mono();
    if(!(ticker >= return_value_zclock_mono_7))
    {
      printf("(%d%%)", (signed int)((100 * (total - pending)) / total));
      fflush(stdout);
      signed long int return_value_zclock_mono_6;
      return_value_zclock_mono_6=zclock_mono();
      ticker = return_value_zclock_mono_6 + (signed long int)2000;
    }

  }
  node_nbr = (unsigned int)0;
  for( ; !(node_nbr >= (unsigned int)swarm_size); node_nbr = node_nbr + 1u)
    zactor_destroy(&nodes[(signed long int)node_nbr]);
  printf("(100%%) OK\n");
  return 0;
}

// match
// file src/foreign/slre/slre.inc_c line 472
static signed int match(struct slre *r, signed int pc, const char *s, unsigned long int len, unsigned long int *ofs, struct cap *caps)
{
  signed int res = 1;
  unsigned long int n;
  unsigned long int saved_offset;
  signed int return_value_memcmp_1;
  signed int return_value_match_2;
  signed int return_value_isspace_3;
  signed int return_value_isspace_4;
  signed int return_value_isdigit_5;
  signed int return_value_isdigit_6;
  signed int return_value_isalpha_7;
  signed int return_value_isalpha_8;
  signed int return_value_isalnum_9;
  signed int return_value_isalnum_10;
  while(!(res == 0))
  {
    if((signed int)r->code[(signed long int)pc] == 0)
      break;

    /* assertion pc < r->code_size */
    assert(pc < r->code_size);
    /* assertion pc < (int) (sizeof (r->code) / sizeof (r->code [0])) */
    assert(pc < (signed int)(sizeof(unsigned char [256l]) /*256ul*/  / sizeof(unsigned char) /*1ul*/ ));
    switch((signed int)r->code[(signed long int)pc])
    {
      case 1:
      {
        saved_offset = *ofs;
        res=match(r, pc + 3, s, len, ofs, caps);
        if(res == 0)
        {
          *ofs = saved_offset;
          res=match(r, pc + (signed int)r->code[(signed long int)(pc + 1)], s, len, ofs, caps);
        }

        pc = pc + (signed int)r->code[(signed long int)(pc + 2)];
        break;
      }
      case 3:
      {
        res = 0;
        n = (unsigned long int)r->code[(signed long int)(pc + 2)];
        if(len + -(*ofs) >= n)
        {
          return_value_memcmp_1=memcmp((const void *)(s + (signed long int)*ofs), (const void *)(r->data + (signed long int)r->code[(signed long int)(pc + 1)]), n);
          if(return_value_memcmp_1 == 0)
          {
            *ofs = *ofs + n;
            res = 1;
          }

        }

        pc = pc + 3;
        break;
      }
      case 14:
      {
        res = 1;
        saved_offset = *ofs;
        return_value_match_2=match(r, pc + 2, s, len, ofs, caps);
        if(return_value_match_2 == 0)
          *ofs = saved_offset;

        pc = pc + (signed int)r->code[(signed long int)(pc + 1)];
        break;
      }
      case 10:
      {
        res = 1;
        loop_greedy(r, pc, s, len, ofs);
        pc = pc + (signed int)r->code[(signed long int)(pc + 1)];
        break;
      }
      case 12:
      {
        res = 1;
        loop_non_greedy(r, pc, s, len, ofs);
        pc = pc + (signed int)r->code[(signed long int)(pc + 1)];
        break;
      }
      case 11:
      {
        res=match(r, pc + 2, s, len, ofs, caps);
        if(res == 0)
          break;

        loop_greedy(r, pc, s, len, ofs);
        pc = pc + (signed int)r->code[(signed long int)(pc + 1)];
        break;
      }
      case 13:
      {
        res=match(r, pc + 2, s, len, ofs, caps);
        if(res == 0)
          break;

        loop_non_greedy(r, pc, s, len, ofs);
        pc = pc + (signed int)r->code[(signed long int)(pc + 1)];
        break;
      }
      case 15:
      {
        res = 0;
        if(!(*ofs >= len))
        {
          return_value_isspace_3=isspace((signed int)((unsigned char *)s)[(signed long int)*ofs]);
          if(!(return_value_isspace_3 == 0))
          {
            *ofs = *ofs + 1ul;
            res = 1;
          }

        }

        pc = pc + 1;
        break;
      }
      case 16:
      {
        res = 0;
        if(!(*ofs >= len))
        {
          return_value_isspace_4=isspace((signed int)((unsigned char *)s)[(signed long int)*ofs]);
          if(return_value_isspace_4 == 0)
          {
            *ofs = *ofs + 1ul;
            res = 1;
          }

        }

        pc = pc + 1;
        break;
      }
      case 17:
      {
        res = 0;
        if(!(*ofs >= len))
        {
          return_value_isdigit_5=isdigit((signed int)((unsigned char *)s)[(signed long int)*ofs]);
          if(!(return_value_isdigit_5 == 0))
          {
            *ofs = *ofs + 1ul;
            res = 1;
          }

        }

        pc = pc + 1;
        break;
      }
      case 18:
      {
        res = 0;
        if(!(*ofs >= len))
        {
          return_value_isdigit_6=isdigit((signed int)((unsigned char *)s)[(signed long int)*ofs]);
          if(return_value_isdigit_6 == 0)
          {
            *ofs = *ofs + 1ul;
            res = 1;
          }

        }

        pc = pc + 1;
        break;
      }
      case 19:
      {
        res = 0;
        if(!(*ofs >= len))
        {
          return_value_isalpha_7=isalpha((signed int)((unsigned char *)s)[(signed long int)*ofs]);
          if(!(return_value_isalpha_7 == 0))
          {
            *ofs = *ofs + 1ul;
            res = 1;
          }

        }

        pc = pc + 1;
        break;
      }
      case 20:
      {
        res = 0;
        if(!(*ofs >= len))
        {
          return_value_isalpha_8=isalpha((signed int)((unsigned char *)s)[(signed long int)*ofs]);
          if(return_value_isalpha_8 == 0)
          {
            *ofs = *ofs + 1ul;
            res = 1;
          }

        }

        pc = pc + 1;
        break;
      }
      case 21:
      {
        res = 0;
        if(!(*ofs >= len))
        {
          return_value_isalnum_9=isalnum((signed int)((unsigned char *)s)[(signed long int)*ofs]);
          if(!(return_value_isalnum_9 == 0))
          {
            *ofs = *ofs + 1ul;
            res = 1;
          }

        }

        pc = pc + 1;
        break;
      }
      case 22:
      {
        res = 0;
        if(!(*ofs >= len))
        {
          return_value_isalnum_10=isalnum((signed int)((unsigned char *)s)[(signed long int)*ofs]);
          if(return_value_isalnum_10 == 0)
          {
            *ofs = *ofs + 1ul;
            res = 1;
          }

        }

        pc = pc + 1;
        break;
      }
      case 2:
      {
        res = 0;
        if(!(*ofs >= len))
        {
          *ofs = *ofs + 1ul;
          res = 1;
        }

        pc = pc + 1;
        break;
      }
      case 4:
      {
        res = 0;
        if(!(*ofs >= len))
          res=is_any_of(r->data + (signed long int)r->code[(signed long int)(pc + 1)], (signed int)r->code[(signed long int)(pc + 2)], s, ofs);

        pc = pc + 3;
        break;
      }
      case 5:
      {
        res = 0;
        if(!(*ofs >= len))
          res=is_any_but(r->data + (signed long int)r->code[(signed long int)(pc + 1)], (signed int)r->code[(signed long int)(pc + 2)], s, ofs);

        pc = pc + 3;
        break;
      }
      case 8:
      {
        res = *ofs == (unsigned long int)0 ? 1 : 0;
        pc = pc + 1;
        break;
      }
      case 9:
      {
        res = *ofs == len ? 1 : 0;
        pc = pc + 1;
        break;
      }
      case 6:
      {
        if(!(caps == ((struct cap *)NULL)))
          (caps + (signed long int)r->code[(signed long int)(pc + 1)])->ptr = s + (signed long int)*ofs;

        pc = pc + 2;
        break;
      }
      case 7:
      {
        if(!(caps == ((struct cap *)NULL)))
          (caps + (signed long int)r->code[(signed long int)(pc + 1)])->len = (unsigned long int)((s + (signed long int)*ofs) - (caps + (signed long int)r->code[(signed long int)(pc + 1)])->ptr);

        pc = pc + 2;
        break;
      }
      case 0:
      {
        pc = pc + 1;
        break;
      }
      default:
      {
        printf("unknown cmd (%d) at %d\n", r->code[(signed long int)pc], pc);
        /* assertion 0 */
        assert(0 != 0);
      }
    }
  }
  return res;
}

// print_character_set
// file src/foreign/slre/slre.inc_c line 90
static void print_character_set(struct _IO_FILE *fp, const unsigned char *p, signed int len)
{
  signed int i = 0;
  signed int return_value_isprint_1;
  for( ; !(i >= len); i = i + 1)
  {
    if(i >= 1)
      fputc(44, fp);

    if((signed int)p[(signed long int)i] == 0)
    {
      i = i + 1;
      if((signed int)p[(signed long int)i] == 0)
        fprintf(fp, "\\x%02x", p[(signed long int)i]);

      else
        fprintf(fp, "%s", opcodes[(signed long int)p[(signed long int)i]].name);
    }

    else
    {
      return_value_isprint_1=isprint((signed int)p[(signed long int)i]);
      if(!(return_value_isprint_1 == 0))
        fputc((signed int)p[(signed long int)i], fp);

      else
        fprintf(fp, "\\x%02x", p[(signed long int)i]);
    }
  }
}

// quantifier
// file src/foreign/slre/slre.inc_c line 266
static void quantifier(struct slre *r, signed int prev, signed int op)
{
  if((signed int)r->code[(signed long int)prev] == 3)
  {
    if((signed int)r->code[(signed long int)(2 + prev)] >= 2)
    {
      r->code[(signed long int)(prev + 2)] = r->code[(signed long int)(prev + 2)] - 1;
      emit(r, 3);
      emit(r, (signed int)r->code[(signed long int)(prev + 1)] + (signed int)r->code[(signed long int)(prev + 2)]);
      emit(r, 1);
      prev = r->code_size - 3;
    }

  }

  relocate(r, prev, 2);
  r->code[(signed long int)prev] = (unsigned char)op;
  set_jump_offset(r, prev + 1, prev);
}

// relocate
// file src/foreign/slre/slre.inc_c line 258
static void relocate(struct slre *r, signed int begin, signed int shift)
{
  emit(r, 0);
  memmove((void *)(r->code + (signed long int)begin + (signed long int)shift), (const void *)(r->code + (signed long int)begin), (unsigned long int)(r->code_size - begin));
  r->code_size = r->code_size + shift;
}

// remote_handler
// file src/zgossip.c line 393
static signed int remote_handler(struct _zloop_t *loop, struct _zsock_t *remote, void *argument)
{
  struct _server_t *self = (struct _server_t *)argument;
  signed int return_value_zgossip_msg_recv_1;
  return_value_zgossip_msg_recv_1=zgossip_msg_recv(self->message, remote);
  const char *return_value_zgossip_msg_key_2;
  const char *return_value_zgossip_msg_value_3;
  signed int return_value_zgossip_msg_id_5;
  signed int return_value_zgossip_msg_id_4;
  if(!(return_value_zgossip_msg_recv_1 == 0))
    return -1;

  else
  {
    signed int return_value_zgossip_msg_id_6;
    return_value_zgossip_msg_id_6=zgossip_msg_id(self->message);
    if(return_value_zgossip_msg_id_6 == 2)
    {
      return_value_zgossip_msg_key_2=zgossip_msg_key(self->message);
      return_value_zgossip_msg_value_3=zgossip_msg_value(self->message);
      server_accept(self, return_value_zgossip_msg_key_2, return_value_zgossip_msg_value_3);
    }

    else
    {
      return_value_zgossip_msg_id_5=zgossip_msg_id(self->message);
      if(return_value_zgossip_msg_id_5 == 5)
      {
        zgossip_msg_set_id(self->message, 1);
        zgossip_msg_send(self->message, remote);
      }

      else
      {
        return_value_zgossip_msg_id_4=zgossip_msg_id(self->message);
        if(return_value_zgossip_msg_id_4 == 4)
          /* assertion 1 */
          assert(1 != 0);

      }
    }
    return 0;
  }
}

// s_agent_authenticate
// file src/zauth_v2.c line 455
static signed int s_agent_authenticate(struct anonymous_23 *self)
{
  struct anonymous_24 *request;
  request=zap_request_new(self->handler);
  unsigned long int return_value_zhash_size_3;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  if(!(request == ((struct anonymous_24 *)NULL)))
  {
    _Bool allowed = (_Bool)0;
    _Bool denied = (_Bool)0;
    unsigned long int return_value_zhash_size_4;
    return_value_zhash_size_4=zhash_size(self->whitelist);
    if(!(return_value_zhash_size_4 == 0ul))
    {
      void *return_value_zhash_lookup_1;
      return_value_zhash_lookup_1=zhash_lookup(self->whitelist, request->address);
      if(!(return_value_zhash_lookup_1 == NULL))
      {
        allowed = (_Bool)1;
        if(!(self->verbose == (_Bool)0))
          printf("ZAUTH I: PASSED (whitelist) address=%s\n", request->address);

      }

      else
      {
        denied = (_Bool)1;
        if(!(self->verbose == (_Bool)0))
          printf("ZAUTH I: DENIED (not in whitelist) address=%s\n", request->address);

      }
    }

    else
    {
      return_value_zhash_size_3=zhash_size(self->blacklist);
      if(!(return_value_zhash_size_3 == 0ul))
      {
        void *return_value_zhash_lookup_2;
        return_value_zhash_lookup_2=zhash_lookup(self->blacklist, request->address);
        if(!(return_value_zhash_lookup_2 == NULL))
        {
          denied = (_Bool)1;
          if(!(self->verbose == (_Bool)0))
            printf("ZAUTH I: DENIED (blacklist) address=%s\n", request->address);

        }

        else
        {
          allowed = (_Bool)1;
          if(!(self->verbose == (_Bool)0))
            printf("ZAUTH I: PASSED (not in blacklist) address=%s\n", request->address);

        }
      }

    }
    if(denied == (_Bool)0)
    {
      signed int return_value_strcmp_8;
      return_value_strcmp_8=strcmp(request->mechanism, "NULL");
      if(allowed == (_Bool)0 && return_value_strcmp_8 == 0)
      {
        if(!(self->verbose == (_Bool)0))
          printf("ZAUTH I: ALLOWED (NULL)\n");

        allowed = (_Bool)1;
      }

      else
      {
        return_value_strcmp_7=strcmp(request->mechanism, "PLAIN");
        if(return_value_strcmp_7 == 0)
          allowed=s_authenticate_plain_link1(self, request);

        else
        {
          return_value_strcmp_6=strcmp(request->mechanism, "CURVE");
          if(return_value_strcmp_6 == 0)
            allowed=s_authenticate_curve_link1(self, request);

          else
          {
            return_value_strcmp_5=strcmp(request->mechanism, "GSSAPI");
            if(return_value_strcmp_5 == 0)
              allowed=s_authenticate_gssapi_link1(self, request);

          }
        }
      }
    }

    if(!(allowed == (_Bool)0))
      zap_request_reply(request, "200", "OK");

    else
      zap_request_reply(request, "400", "NO ACCESS");
    zap_request_destroy(&request);
  }

  else
    zap_request_reply(request, "500", "Internal error");
  return 0;
}

// s_agent_destroy
// file src/zauth_v2.c line 315
static void s_agent_destroy(struct anonymous_23 **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct anonymous_23 **)NULL));
  if(!(*self_p == ((struct anonymous_23 *)NULL)))
  {
    struct anonymous_23 *self = *self_p;
    zhash_destroy(&self->passwords);
    zhash_destroy(&self->whitelist);
    zhash_destroy(&self->blacklist);
    zcertstore_destroy(&self->certstore);
    zsocket_unbind(self->handler, "inproc://zeromq.zap.01");
    zsocket_destroy(self->ctx, self->handler);
    free((void *)self);
    *self_p = (struct anonymous_23 *)(void *)0;
  }

}

// s_agent_destroy_link1
// file src/zbeacon_v2.c line 478
static void s_agent_destroy_link1(struct anonymous_27 **self_p_link1)
{
  /* assertion self_p */
  assert(self_p_link1 != ((struct anonymous_27 **)NULL));
  if(!(*self_p_link1 == ((struct anonymous_27 *)NULL)))
  {
    struct anonymous_27 *self_link1 = *self_p_link1;
    zsys_udp_close(self_link1->udpsock);
    zframe_destroy(&self_link1->transmit);
    zframe_destroy(&self_link1->filter);
    free((void *)self_link1);
    *self_p_link1 = (struct anonymous_27 *)(void *)0;
  }

}

// s_agent_destroy_link2
// file src/zmonitor_v2.c line 201
static void s_agent_destroy_link2(struct anonymous_39 **self_p_link2)
{
  /* assertion self_p */
  assert(self_p_link2 != ((struct anonymous_39 **)NULL));
  if(!(*self_p_link2 == ((struct anonymous_39 *)NULL)))
  {
    struct anonymous_39 *self_link2 = *self_p_link2;
    free((void *)self_link2->endpoint);
    free((void *)self_link2);
    *self_p_link2 = (struct anonymous_39 *)(void *)0;
  }

}

// s_agent_handle_pipe
// file src/zauth_v2.c line 362
static signed int s_agent_handle_pipe(struct anonymous_23 *self)
{
  struct _zmsg_t *request;
  request=zmsg_recv(self->pipe);
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  if(request == ((struct _zmsg_t *)NULL))
    return -1;

  else
  {
    char *command;
    command=zmsg_popstr(request);
    if(command == ((char *)NULL))
    {
      zmsg_destroy(&request);
      return -1;
    }

    else
    {
      signed int return_value_strcmp_8;
      return_value_strcmp_8=strcmp(command, "ALLOW");
      if(return_value_strcmp_8 == 0)
      {
        char *address;
        address=zmsg_popstr(request);
        zhash_insert(self->whitelist, address, (void *)"OK");
        zstr_free(&address);
        zsocket_signal(self->pipe);
      }

      else
      {
        return_value_strcmp_7=strcmp(command, "DENY");
        if(return_value_strcmp_7 == 0)
        {
          char *s_agent_handle_pipe__1__3__address;
          s_agent_handle_pipe__1__3__address=zmsg_popstr(request);
          zhash_insert(self->blacklist, s_agent_handle_pipe__1__3__address, (void *)"OK");
          zstr_free(&s_agent_handle_pipe__1__3__address);
          zsocket_signal(self->pipe);
        }

        else
        {
          return_value_strcmp_6=strcmp(command, "PLAIN");
          if(return_value_strcmp_6 == 0)
          {
            char *domain;
            domain=zmsg_popstr(request);
            zstr_free(&domain);
            char *filename;
            filename=zmsg_popstr(request);
            zhash_destroy(&self->passwords);
            self->passwords=zhash_new();
            zhash_load(self->passwords, filename);
            zstr_free(&filename);
            zsocket_signal(self->pipe);
          }

          else
          {
            return_value_strcmp_5=strcmp(command, "CURVE");
            if(return_value_strcmp_5 == 0)
            {
              char *s_agent_handle_pipe__1__5__domain;
              s_agent_handle_pipe__1__5__domain=zmsg_popstr(request);
              zstr_free(&s_agent_handle_pipe__1__5__domain);
              char *location;
              location=zmsg_popstr(request);
              signed int return_value_strcmp_1;
              return_value_strcmp_1=strcmp(location, "*");
              if(return_value_strcmp_1 == 0)
                self->allow_any = (_Bool)1;

              else
              {
                zcertstore_destroy(&self->certstore);
                self->certstore=zcertstore_new(location);
                self->allow_any = (_Bool)0;
              }
              zstr_free(&location);
              zsocket_signal(self->pipe);
            }

            else
            {
              return_value_strcmp_4=strcmp(command, "GSSAPI");
              if(return_value_strcmp_4 == 0)
              {
                char *s_agent_handle_pipe__1__6__domain;
                s_agent_handle_pipe__1__6__domain=zmsg_popstr(request);
                zstr_free(&s_agent_handle_pipe__1__6__domain);
                zsocket_signal(self->pipe);
              }

              else
              {
                return_value_strcmp_3=strcmp(command, "VERBOSE");
                if(return_value_strcmp_3 == 0)
                {
                  char *verbose;
                  verbose=zmsg_popstr(request);
                  self->verbose = (signed int)*verbose == 49;
                  zstr_free(&verbose);
                  zsocket_signal(self->pipe);
                }

                else
                {
                  return_value_strcmp_2=strcmp(command, "TERMINATE");
                  if(return_value_strcmp_2 == 0)
                  {
                    self->terminated = (_Bool)1;
                    zsocket_signal(self->pipe);
                  }

                  else
                  {
                    zsys_error("invalid command from API: %s\n", command);
                    /* assertion 0 */
                    assert(0 != 0);
                  }
                }
              }
            }
          }
        }
      }
      zstr_free(&command);
      zmsg_destroy(&request);
      return 0;
    }
  }
}

// s_agent_new
// file src/zauth_v2.c line 332
static struct anonymous_23 * s_agent_new(struct _zctx_t *ctx, void *pipe)
{
  struct anonymous_23 *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link28(sizeof(struct anonymous_23) /*72ul*/ , "src/zauth_v2.c", (unsigned int)334);
  self = (struct anonymous_23 *)return_value_safe_malloc_1;
  if(self == ((struct anonymous_23 *)NULL))
    return (struct anonymous_23 *)(void *)0;

  else
  {
    self->ctx = ctx;
    self->pipe = pipe;
    self->whitelist=zhash_new();
    if(!(self->whitelist == ((struct _zhash_t *)NULL)))
      self->blacklist=zhash_new();

    if(!(self->blacklist == ((struct _zhash_t *)NULL)))
      self->handler=zsocket_new(self->ctx, 4);

    if(!(self->handler == NULL))
    {
      signed int return_value_zsocket_bind_2;
      return_value_zsocket_bind_2=zsocket_bind(self->handler, "inproc://zeromq.zap.01");
      if(return_value_zsocket_bind_2 == 0)
        zstr_send(self->pipe, "OK");

      else
        zstr_send(self->pipe, "ERROR");
    }

    else
      s_agent_destroy(&self);
    return self;
  }
}

// s_agent_new_link1
// file src/zbeacon_v2.c line 294
static struct anonymous_27 * s_agent_new_link1(void *pipe_link1, signed int port_nbr)
{
  struct anonymous_27 *self_link1;
  void *return_value_safe_malloc_1_link1;
  return_value_safe_malloc_1_link1=safe_malloc_link29(sizeof(struct anonymous_27) /*80ul*/ , "src/zbeacon_v2.c", (unsigned int)296);
  self_link1 = (struct anonymous_27 *)return_value_safe_malloc_1_link1;
  if(self_link1 == ((struct anonymous_27 *)NULL))
    return (struct anonymous_27 *)(void *)0;

  else
  {
    self_link1->pipe = pipe_link1;
    self_link1->port_nbr = port_nbr;
    self_link1->interval = 1000;
    self_link1->udpsock=zsys_udp_new((_Bool)0);
    if(self_link1->udpsock == -1)
    {
      free((void *)self_link1);
      return (struct anonymous_27 *)(void *)0;
    }

    else
    {
      s_get_interface(self_link1);
      struct sockaddr_in sockaddr = self_link1->broadcast;
      signed int rc;
      rc=bind(self_link1->udpsock, (struct sockaddr *)&sockaddr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(rc == -1)
        zsys_socket_error("bind");

      char hostname[1025l];
      rc=getnameinfo((struct sockaddr *)&self_link1->address, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ , hostname, (unsigned int)1025, (char *)(void *)0, (unsigned int)0, 1);
      if(rc == 0)
      {
        zstr_send(pipe_link1, hostname);
        return self_link1;
      }

      else
      {
        zstr_send(pipe_link1, "-");
        zsys_udp_close(self_link1->udpsock);
        free((void *)self_link1);
        return (struct anonymous_27 *)(void *)0;
      }
    }
  }
}

// s_agent_new_link2
// file src/zmonitor_v2.c line 217
static struct anonymous_39 * s_agent_new_link2(struct _zctx_t *ctx_link1, void *pipe_link2, char *endpoint)
{
  struct anonymous_39 *self_link2;
  void *return_value_safe_malloc_1_link2;
  return_value_safe_malloc_1_link2=safe_malloc_link33(sizeof(struct anonymous_39) /*40ul*/ , "src/zmonitor_v2.c", (unsigned int)219);
  self_link2 = (struct anonymous_39 *)return_value_safe_malloc_1_link2;
  if(self_link2 == ((struct anonymous_39 *)NULL))
    return (struct anonymous_39 *)(void *)0;

  else
  {
    self_link2->ctx = ctx_link1;
    self_link2->pipe = pipe_link2;
    self_link2->endpoint = endpoint;
    self_link2->socket=zsocket_new(self_link2->ctx, 0);
    if(!(self_link2->socket == NULL))
    {
      signed int return_value_zsocket_connect_2;
      return_value_zsocket_connect_2=zsocket_connect(self_link2->socket, "%s", self_link2->endpoint);
      if(return_value_zsocket_connect_2 == 0)
        zstr_send(self_link2->pipe, "OK");

      else
        zstr_send(self_link2->pipe, "ERROR");
    }

    else
      s_agent_destroy_link2(&self_link2);
    return self_link2;
  }
}

// s_agent_task
// file src/zauth_v2.c line 583
static void s_agent_task(void *args, struct _zctx_t *ctx, void *pipe)
{
  struct anonymous_23 *self;
  self=s_agent_new(ctx, pipe);
  _Bool return_value_zpoller_terminated_1;
  if(!(self == ((struct anonymous_23 *)NULL)))
  {
    struct _zpoller_t *poller;
    poller=zpoller_new(self->pipe, self->handler, (void *)0);
    if(!(poller == ((struct _zpoller_t *)NULL)))
      do
      {
        return_value_zpoller_terminated_1=zpoller_terminated(poller);
        if(return_value_zpoller_terminated_1 != (_Bool)0)
          break;

        if(self->terminated != (_Bool)0)
          break;

        void *which;
        which=zpoller_wait(poller, -1);
        if(which == self->pipe)
          s_agent_handle_pipe(self);

        else
          if(which == self->handler)
            s_agent_authenticate(self);

      }
      while((_Bool)1);

    zpoller_destroy(&poller);
    s_agent_destroy(&self);
  }

}

// s_agent_task_link1
// file src/zbeacon_v2.c line 248
static void s_agent_task_link1(void *args_link1, struct _zctx_t *ctx_link1, void *pipe_link1)
{
  char *port_str;
  port_str=zstr_recv(pipe_link1);
  /* assertion port_str */
  assert(port_str != ((char *)NULL));
  struct anonymous_27 *self_link1;
  signed int return_value_atoi_1;
  return_value_atoi_1=atoi(port_str);
  self_link1=s_agent_new_link1(pipe_link1, return_value_atoi_1);
  zstr_free(&port_str);
  signed long int return_value_zclock_mono_5;
  if(!(self_link1 == ((struct anonymous_27 *)NULL)))
  {
    while(self_link1->terminated == (_Bool)0)
    {
      struct zmq_pollitem_t pollitems[2l] = { { .socket=self_link1->pipe, .fd=0, .events=(signed short int)1, .revents=(signed short int)0 },
    { .socket=(void *)0, .fd=self_link1->udpsock, .events=(signed short int)1,
    .revents=(signed short int)0 } };
      signed long int timeout = (signed long int)-1;
      if(!(self_link1->transmit == ((struct _zframe_t *)NULL)))
      {
        signed long int return_value_zclock_mono_2;
        return_value_zclock_mono_2=zclock_mono();
        timeout = (signed long int)(self_link1->ping_at - return_value_zclock_mono_2);
        if(!(timeout >= 0l))
          timeout = (signed long int)0;

      }

      signed int return_value_zmq_poll_3;
      return_value_zmq_poll_3=zmq_poll(pollitems, 2, timeout * (signed long int)1);
      if(return_value_zmq_poll_3 == -1)
        break;

      if(!((1 & (signed int)pollitems[0l].revents) == 0))
        s_api_command(self_link1);

      if(!((1 & (signed int)pollitems[1l].revents) == 0))
        s_beacon_recv(self_link1);

      if(!(self_link1->transmit == ((struct _zframe_t *)NULL)))
      {
        return_value_zclock_mono_5=zclock_mono();
        if(return_value_zclock_mono_5 >= self_link1->ping_at)
        {
          zsys_udp_send(self_link1->udpsock, self_link1->transmit, &self_link1->broadcast);
          signed long int return_value_zclock_mono_4;
          return_value_zclock_mono_4=zclock_mono();
          self_link1->ping_at = return_value_zclock_mono_4 + (signed long int)self_link1->interval;
        }

      }

    }
    s_agent_destroy_link1(&self_link1);
  }

}

// s_agent_task_link2
// file src/zmonitor_v2.c line 170
static void s_agent_task_link2(void *args_link2, struct _zctx_t *ctx_link2, void *pipe_link2)
{
  char *endpoint;
  endpoint=zstr_recv(pipe_link2);
  /* assertion endpoint */
  assert(endpoint != ((char *)NULL));
  struct anonymous_39 *self_link2;
  self_link2=s_agent_new_link2(ctx_link2, pipe_link2, endpoint);
  if(!(self_link2 == ((struct anonymous_39 *)NULL)))
  {
    struct _zpoller_t *poller_link1;
    poller_link1=zpoller_new(self_link2->pipe, self_link2->socket, (void *)0);
    if(!(poller_link1 == ((struct _zpoller_t *)NULL)))
      while(self_link2->terminated == (_Bool)0)
      {
        void *result;
        result=zpoller_wait(poller_link1, -1);
        if(result == NULL)
          break;

        else
          if(result == self_link2->pipe)
            s_api_command_link1(self_link2);

          else
            if(result == self_link2->socket)
              s_socket_event_link1(self_link2);

      }

    zpoller_destroy(&poller_link1);
    s_agent_destroy_link2(&self_link2);
  }

}

// s_api_command
// file src/zbeacon_v2.c line 393
static void s_api_command(struct anonymous_27 *self)
{
  char *command;
  command=zstr_recv(self->pipe);
  signed int return_value_strcmp_7;
  return_value_strcmp_7=strcmp(command, "INTERVAL");
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(return_value_strcmp_7 == 0)
  {
    char *interval;
    interval=zstr_recv(self->pipe);
    self->interval=atoi(interval);
    zstr_free(&interval);
  }

  else
  {
    return_value_strcmp_6=strcmp(command, "NOECHO");
    if(return_value_strcmp_6 == 0)
      self->noecho = (_Bool)1;

    else
    {
      return_value_strcmp_5=strcmp(command, "PUBLISH");
      if(return_value_strcmp_5 == 0)
      {
        zframe_destroy(&self->transmit);
        self->transmit=zframe_recv(self->pipe);
        /* assertion self->transmit */
        assert(self->transmit != ((struct _zframe_t *)NULL));
        self->ping_at=zclock_mono();
      }

      else
      {
        return_value_strcmp_4=strcmp(command, "SILENCE");
        if(return_value_strcmp_4 == 0)
          zframe_destroy(&self->transmit);

        else
        {
          return_value_strcmp_3=strcmp(command, "SUBSCRIBE");
          if(return_value_strcmp_3 == 0)
          {
            zframe_destroy(&self->filter);
            self->filter=zframe_recv(self->pipe);
          }

          else
          {
            return_value_strcmp_2=strcmp(command, "UNSUBSCRIBE");
            if(return_value_strcmp_2 == 0)
              zframe_destroy(&self->filter);

            else
            {
              return_value_strcmp_1=strcmp(command, "TERMINATE");
              if(return_value_strcmp_1 == 0)
              {
                self->terminated = (_Bool)1;
                zstr_send(self->pipe, "OK");
              }

              else
                zsys_error("zbeacon: unexpected API command '%s'\n", command);
            }
          }
        }
      }
    }
  }
  zstr_free(&command);
}

// s_api_command_link1
// file src/zmonitor_v2.c line 245
static void s_api_command_link1(struct anonymous_39 *self_link1)
{
  char *command_link1;
  command_link1=zstr_recv(self_link1->pipe);
  signed int return_value_strcmp_2_link1;
  return_value_strcmp_2_link1=strcmp(command_link1, "TERMINATE");
  signed int return_value_strcmp_1_link1;
  if(return_value_strcmp_2_link1 == 0)
  {
    self_link1->terminated = (_Bool)1;
    zstr_send(self_link1->pipe, "OK");
  }

  else
  {
    return_value_strcmp_1_link1=strcmp(command_link1, "VERBOSE");
    if(return_value_strcmp_1_link1 == 0)
    {
      char *verbose;
      verbose=zstr_recv(self_link1->pipe);
      self_link1->verbose = (signed int)*verbose == 49;
      free((void *)verbose);
    }

    else
      zsys_error("zmonitor unexpected API command '%s'", command_link1);
  }
  free((void *)command_link1);
}

// s_armour_decode
// file src/zarmour.c line 662
static void s_armour_decode(struct _zarmour_t *self, const char *test_string, const char *expected_result, _Bool verbose)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  /* assertion test_string */
  assert(test_string != ((const char *)NULL));
  /* assertion expected_result */
  assert(expected_result != ((const char *)NULL));
  unsigned long int size;
  char *decoded;
  unsigned char *return_value_zarmour_decode_1;
  return_value_zarmour_decode_1=zarmour_decode(self, test_string, &size);
  decoded = (char *)return_value_zarmour_decode_1;
  /* assertion decoded */
  assert(decoded != ((char *)NULL));
  if(!(verbose == (_Bool)0))
    zsys_debug("    decoded '%s' into '%s'", test_string, decoded);

  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(decoded);
  /* assertion size == strlen (decoded) + 1 */
  assert(size == return_value_strlen_2 + (unsigned long int)1);
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(decoded, expected_result);
  /* assertion (!strcmp ((decoded), (expected_result))) */
  assert(!(return_value_strcmp_3 != 0));
  free((void *)decoded);
}

// s_armour_test
// file src/zarmour.c line 636
static void s_armour_test(struct _zarmour_t *self, const char *test_string, const char *expected_result, _Bool verbose)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  /* assertion test_string */
  assert(test_string != ((const char *)NULL));
  /* assertion expected_result */
  assert(expected_result != ((const char *)NULL));
  char *encoded;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(test_string);
  encoded=zarmour_encode(self, (unsigned char *)test_string, return_value_strlen_1);
  /* assertion encoded */
  assert(encoded != ((char *)NULL));
  if(!(verbose == (_Bool)0))
    zsys_debug("    encoded '%s' into '%s'", test_string, encoded);

  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(encoded);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(expected_result);
  /* assertion strlen (encoded) == strlen (expected_result) */
  assert(return_value_strlen_2 == return_value_strlen_3);
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(encoded, expected_result);
  /* assertion (!strcmp ((encoded), (expected_result))) */
  assert(!(return_value_strcmp_4 != 0));
  unsigned long int size;
  char *decoded;
  unsigned char *return_value_zarmour_decode_5;
  return_value_zarmour_decode_5=zarmour_decode(self, encoded, &size);
  decoded = (char *)return_value_zarmour_decode_5;
  /* assertion decoded */
  assert(decoded != ((char *)NULL));
  if(!(verbose == (_Bool)0))
    zsys_debug("    decoded '%s' into '%s'", encoded, decoded);

  unsigned long int return_value_strlen_6;
  return_value_strlen_6=strlen(decoded);
  /* assertion size == strlen (decoded) + 1 */
  assert(size == return_value_strlen_6 + (unsigned long int)1);
  signed int return_value_strcmp_7;
  return_value_strcmp_7=strcmp(decoded, test_string);
  /* assertion (!strcmp ((decoded), (test_string))) */
  assert(!(return_value_strcmp_7 != 0));
  free((void *)encoded);
  free((void *)decoded);
}

// s_armour_test_long
// file src/zarmour.c line 680
static void s_armour_test_long(struct _zarmour_t *self, unsigned char *test_data, unsigned long int length, _Bool verbose)
{
  if(!(verbose == (_Bool)0))
    zarmour_print(self);

  char *test_string;
  test_string=zarmour_encode(self, test_data, length);
  /* assertion test_string */
  assert(test_string != ((char *)NULL));
  if(!(verbose == (_Bool)0))
    zsys_debug("    encoded %d bytes array to:\n%s", length, test_string);

  unsigned long int test_size;
  unsigned char *test_data2;
  test_data2=zarmour_decode(self, test_string, &test_size);
  free((void *)test_string);
  /* assertion test_data2 */
  assert(test_data2 != ((unsigned char *)NULL));
  /* assertion test_size == length + 1 */
  assert(test_size == length + (unsigned long int)1);
  unsigned int i = (unsigned int)0;
  for( ; !((unsigned long int)i >= length); i = i + 1u)
    /* assertion test_data2[i] == i */
    assert((unsigned int)test_data2[(signed long int)i] == i);
  free((void *)test_data2);
  if(!(verbose == (_Bool)0))
    zsys_debug("    decoded %d bytes, all match", test_size - (unsigned long int)1);

}

// s_assert_event
// file src/zmonitor.c line 312
static void s_assert_event(struct _zactor_t *self, char *expected)
{
  struct _zmsg_t *msg;
  msg=zmsg_recv((void *)self);
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  char *event;
  event=zmsg_popstr(msg);
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(event, expected);
  /* assertion (!strcmp ((event), (expected))) */
  assert(!(return_value_strcmp_1 != 0));
  free((void *)event);
  zmsg_destroy(&msg);
}

// s_authenticate_curve
// file src/zauth.c line 323
static _Bool s_authenticate_curve(struct anonymous_26 *self, struct anonymous_34 *request)
{
  struct _zcert_t *return_value_zcertstore_lookup_1;
  if(!(self->allow_any == (_Bool)0))
  {
    if(!(self->verbose == (_Bool)0))
      zsys_info("zauth: - allowed (CURVE allow any client)");

    return (_Bool)1;
  }

  else
  {
    _Bool tmp_if_expr_2;
    if(!(self->certstore == ((struct _zcertstore_t *)NULL)))
    {
      return_value_zcertstore_lookup_1=zcertstore_lookup(self->certstore, request->client_key);
      tmp_if_expr_2 = return_value_zcertstore_lookup_1 != ((struct _zcert_t *)NULL) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
    {
      if(!(self->verbose == (_Bool)0))
        zsys_info("zauth: - allowed (CURVE) client_key=%s", request->client_key);

      return (_Bool)1;
    }

    else
    {
      if(!(self->verbose == (_Bool)0))
        zsys_info("zauth: - denied (CURVE) client_key=%s", request->client_key);

      return (_Bool)0;
    }
  }
}

// s_authenticate_curve_link1
// file src/zauth_v2.c line 550
static _Bool s_authenticate_curve_link1(struct anonymous_23 *self_link1, struct anonymous_24 *request_link1)
{
  struct _zcert_t *return_value_zcertstore_lookup_1_link1;
  if(!(self_link1->allow_any == (_Bool)0))
  {
    if(!(self_link1->verbose == (_Bool)0))
      printf("ZAUTH I: ALLOWED (CURVE allow any client)\n");

    return (_Bool)1;
  }

  else
  {
    _Bool tmp_if_expr_2_link1;
    if(!(self_link1->certstore == ((struct _zcertstore_t *)NULL)))
    {
      return_value_zcertstore_lookup_1_link1=zcertstore_lookup(self_link1->certstore, request_link1->client_key);
      tmp_if_expr_2_link1 = return_value_zcertstore_lookup_1_link1 != ((struct _zcert_t *)NULL) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2_link1 = (_Bool)0;
    if(tmp_if_expr_2_link1)
    {
      if(!(self_link1->verbose == (_Bool)0))
        printf("ZAUTH I: ALLOWED (CURVE) client_key=%s\n", request_link1->client_key);

      return (_Bool)1;
    }

    else
    {
      if(!(self_link1->verbose == (_Bool)0))
        printf("ZAUTH I: DENIED (CURVE) client_key=%s\n", request_link1->client_key);

      return (_Bool)0;
    }
  }
}

// s_authenticate_gssapi
// file src/zauth.c line 346
static _Bool s_authenticate_gssapi(struct anonymous_26 *self, struct anonymous_34 *request)
{
  if(!(self->verbose == (_Bool)0))
    zsys_info("zauth: - allowed (GSSAPI) principal=%s identity=%s", request->principal, request->identity);

  return (_Bool)1;
}

// s_authenticate_gssapi_link1
// file src/zauth_v2.c line 573
static _Bool s_authenticate_gssapi_link1(struct anonymous_23 *self_link1, struct anonymous_24 *request_link1)
{
  if(!(self_link1->verbose == (_Bool)0))
    printf("I: ALLOWED (GSSAPI) principal=%s identity=%s\n", request_link1->principal, request_link1->identity);

  return (_Bool)1;
}

// s_authenticate_plain
// file src/zauth.c line 296
static _Bool s_authenticate_plain(struct anonymous_26 *self, struct anonymous_34 *request)
{
  signed int return_value_strcmp_2;
  if(!(self->passwords == ((struct _zhashx_t *)NULL)))
  {
    zhashx_refresh(self->passwords);
    char *password;
    void *return_value_zhashx_lookup_1;
    return_value_zhashx_lookup_1=zhashx_lookup(self->passwords, (const void *)request->username);
    password = (char *)return_value_zhashx_lookup_1;
    _Bool tmp_if_expr_3;
    if(!(password == ((char *)NULL)))
    {
      return_value_strcmp_2=strcmp(password, request->password);
      tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      if(!(self->verbose == (_Bool)0))
        zsys_info("zauth: - allowed (PLAIN) username=%s password=%s", request->username, request->password);

      return (_Bool)1;
    }

    else
    {
      if(!(self->verbose == (_Bool)0))
        zsys_info("zauth: - denied (PLAIN) username=%s password=%s", request->username, request->password);

      return (_Bool)0;
    }
  }

  else
  {
    if(!(self->verbose == (_Bool)0))
      zsys_info("zauth: - denied (PLAIN) no password file defined");

    return (_Bool)0;
  }
}

// s_authenticate_plain_link1
// file src/zauth_v2.c line 523
static _Bool s_authenticate_plain_link1(struct anonymous_23 *self_link1, struct anonymous_24 *request_link1)
{
  signed int return_value_strcmp_2_link1;
  if(!(self_link1->passwords == ((struct _zhash_t *)NULL)))
  {
    zhash_refresh(self_link1->passwords);
    char *password_link1;
    void *return_value_zhash_lookup_1;
    return_value_zhash_lookup_1=zhash_lookup(self_link1->passwords, request_link1->username);
    password_link1 = (char *)return_value_zhash_lookup_1;
    _Bool tmp_if_expr_3_link1;
    if(!(password_link1 == ((char *)NULL)))
    {
      return_value_strcmp_2_link1=strcmp(password_link1, request_link1->password);
      tmp_if_expr_3_link1 = !(return_value_strcmp_2_link1 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3_link1 = (_Bool)0;
    if(tmp_if_expr_3_link1)
    {
      if(!(self_link1->verbose == (_Bool)0))
        printf("ZAUTH I: ALLOWED (PLAIN) username=%s password=%s\n", request_link1->username, request_link1->password);

      return (_Bool)1;
    }

    else
    {
      if(!(self_link1->verbose == (_Bool)0))
        printf("ZAUTH I: DENIED (PLAIN) username=%s password=%s\n", request_link1->username, request_link1->password);

      return (_Bool)0;
    }
  }

  else
  {
    if(!(self_link1->verbose == (_Bool)0))
      printf("ZAUTH I: DENIED (PLAIN) no password file defined\n");

    return (_Bool)0;
  }
}

// s_base16_decode
// file src/zarmour.c line 375
static unsigned char * s_base16_decode(const char *data, unsigned long int *size, const char *alphabet, unsigned long int linebreakchars)
{
  unsigned long int length;
  length=strlen(data);
  const unsigned char *needle = (const unsigned char *)data;
  const unsigned char *ceiling = (const unsigned char *)(data + (signed long int)length);
  length = length - linebreakchars;
  *size = length / (unsigned long int)2 + (unsigned long int)1;
  unsigned char *bytes;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link2(*size, "src/zarmour.c", (unsigned int)381);
  bytes = (unsigned char *)return_value_safe_malloc_1;
  char *return_value_strchr_2;
  char *return_value_strchr_3;
  char *return_value_strchr_5;
  char *return_value_strchr_6;
  if(bytes == ((unsigned char *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    unsigned char *dec = bytes;
    unsigned char i1;
    unsigned char i2;
    while(!(needle >= ceiling))
    {
      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_2=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        if(!(return_value_strchr_2 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_4;
      if(!(needle >= ceiling))
      {
        return_value_strchr_3=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        tmp_if_expr_4 = return_value_strchr_3 - alphabet;
      }

      else
        tmp_if_expr_4 = (signed long int)0xff;
      i1 = (unsigned char)tmp_if_expr_4;
      needle = needle + 1l;
      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_5=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        if(!(return_value_strchr_5 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_7;
      if(!(needle >= ceiling))
      {
        return_value_strchr_6=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        tmp_if_expr_7 = return_value_strchr_6 - alphabet;
      }

      else
        tmp_if_expr_7 = (signed long int)0xff;
      i2 = (unsigned char)tmp_if_expr_7;
      needle = needle + 1l;
      if(!((signed int)i1 == 0xff) && !((signed int)i2 == 0xff))
      {
        unsigned char *tmp_post_8 = dec;
        dec = dec + 1l;
        *tmp_post_8 = (unsigned char)((signed int)i1 << 4 | (signed int)i2);
      }

    }
    *dec = (unsigned char)0;
    return bytes;
  }
}

// s_base16_encode
// file src/zarmour.c line 358
static char * s_base16_encode(const unsigned char *data, unsigned long int length, const char *alphabet)
{
  char *str;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link2((unsigned long int)2 * length + (unsigned long int)1, "src/zarmour.c", (unsigned int)360);
  str = (char *)return_value_safe_malloc_1;
  if(str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *enc = str;
    const unsigned char *needle = data;
    const unsigned char *ceiling = data + (signed long int)length;
    while(!(needle >= ceiling))
    {
      char *tmp_post_2 = enc;
      enc = enc + 1l;
      *tmp_post_2 = alphabet[(signed long int)((signed int)*needle >> 4)];
      char *tmp_post_3 = enc;
      enc = enc + 1l;
      const unsigned char *tmp_post_4 = needle;
      needle = needle + 1l;
      *tmp_post_3 = alphabet[(signed long int)((signed int)*tmp_post_4 & 0x0f)];
    }
    *enc = (char)0;
    return str;
  }
}

// s_base32_decode
// file src/zarmour.c line 305
static unsigned char * s_base32_decode(const char *data, unsigned long int *size, const char *alphabet, unsigned long int linebreakchars)
{
  unsigned long int length;
  length=strlen(data);
  char *return_value_strchr_1;
  for( ; length >= 1ul; length = length - 1ul)
  {
    return_value_strchr_1=strchr(alphabet, (signed int)data[(signed long int)(length - (unsigned long int)1)] & (((signed int)data[(signed long int)(length - (unsigned long int)1)] & 0x40) != 0 ? 0xdf : 0xff));
    if(!(return_value_strchr_1 == ((char *)NULL)))
      break;

  }
  const unsigned char *needle = (const unsigned char *)data;
  const unsigned char *ceiling = (const unsigned char *)(data + (signed long int)length);
  length = length - linebreakchars;
  unsigned long int extra_chars = length % (unsigned long int)8;
  unsigned long int extra_bytes = (unsigned long int)0;
  switch(extra_chars)
  {
    case (unsigned long int)0:
      break;
    case (unsigned long int)2:
    {
      extra_bytes = (unsigned long int)1;
      break;
    }
    case (unsigned long int)4:
    {
      extra_bytes = (unsigned long int)2;
      break;
    }
    case (unsigned long int)5:
    {
      extra_bytes = (unsigned long int)3;
      break;
    }
    case (unsigned long int)7:
    {
      extra_bytes = (unsigned long int)4;
      break;
    }
    default:
      /* assertion 0 */
      assert(0 != 0);
  }
  *size = (unsigned long int)5 * (length / (unsigned long int)8) + extra_bytes + (unsigned long int)1;
  unsigned char *bytes;
  void *return_value_safe_malloc_2;
  return_value_safe_malloc_2=safe_malloc_link2(*size, "src/zarmour.c", (unsigned int)321);
  bytes = (unsigned char *)return_value_safe_malloc_2;
  char *return_value_strchr_3;
  char *return_value_strchr_4;
  char *return_value_strchr_6;
  char *return_value_strchr_7;
  char *return_value_strchr_10;
  char *return_value_strchr_11;
  char *return_value_strchr_13;
  char *return_value_strchr_14;
  char *return_value_strchr_17;
  char *return_value_strchr_18;
  char *return_value_strchr_21;
  char *return_value_strchr_22;
  char *return_value_strchr_24;
  char *return_value_strchr_25;
  char *return_value_strchr_28;
  char *return_value_strchr_29;
  if(bytes == ((unsigned char *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    unsigned char *dec = bytes;
    unsigned char i1;
    unsigned char i2;
    unsigned char i3;
    unsigned char i4;
    unsigned char i5;
    unsigned char i6;
    unsigned char i7;
    unsigned char i8;
    while(!(needle >= ceiling))
    {
      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_3=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        if(!(return_value_strchr_3 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_5;
      if(!(needle >= ceiling))
      {
        return_value_strchr_4=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        tmp_if_expr_5 = return_value_strchr_4 - alphabet;
      }

      else
        tmp_if_expr_5 = (signed long int)0xff;
      i1 = (unsigned char)tmp_if_expr_5;
      needle = needle + 1l;
      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_6=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        if(!(return_value_strchr_6 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_8;
      if(!(needle >= ceiling))
      {
        return_value_strchr_7=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        tmp_if_expr_8 = return_value_strchr_7 - alphabet;
      }

      else
        tmp_if_expr_8 = (signed long int)0xff;
      i2 = (unsigned char)tmp_if_expr_8;
      needle = needle + 1l;
      if(!((signed int)i1 == 0xff) && !((signed int)i2 == 0xff))
      {
        unsigned char *tmp_post_9 = dec;
        dec = dec + 1l;
        *tmp_post_9 = (unsigned char)((signed int)i1 << 3 | (signed int)i2 >> 2);
      }

      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_10=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        if(!(return_value_strchr_10 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_12;
      if(!(needle >= ceiling))
      {
        return_value_strchr_11=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        tmp_if_expr_12 = return_value_strchr_11 - alphabet;
      }

      else
        tmp_if_expr_12 = (signed long int)0xff;
      i3 = (unsigned char)tmp_if_expr_12;
      needle = needle + 1l;
      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_13=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        if(!(return_value_strchr_13 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_15;
      if(!(needle >= ceiling))
      {
        return_value_strchr_14=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        tmp_if_expr_15 = return_value_strchr_14 - alphabet;
      }

      else
        tmp_if_expr_15 = (signed long int)0xff;
      i4 = (unsigned char)tmp_if_expr_15;
      needle = needle + 1l;
      if(!((signed int)i2 == 0xff) && !((signed int)i3 == 0xff) && !((signed int)i4 == 0xff))
      {
        unsigned char *tmp_post_16 = dec;
        dec = dec + 1l;
        *tmp_post_16 = (unsigned char)((signed int)i2 << 6 | (signed int)i3 << 1 | (signed int)i4 >> 4);
      }

      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_17=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        if(!(return_value_strchr_17 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_19;
      if(!(needle >= ceiling))
      {
        return_value_strchr_18=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        tmp_if_expr_19 = return_value_strchr_18 - alphabet;
      }

      else
        tmp_if_expr_19 = (signed long int)0xff;
      i5 = (unsigned char)tmp_if_expr_19;
      needle = needle + 1l;
      if(!((signed int)i4 == 0xff) && !((signed int)i5 == 0xff))
      {
        unsigned char *tmp_post_20 = dec;
        dec = dec + 1l;
        *tmp_post_20 = (unsigned char)((signed int)i4 << 4 | (signed int)i5 >> 1);
      }

      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_21=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        if(!(return_value_strchr_21 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_23;
      if(!(needle >= ceiling))
      {
        return_value_strchr_22=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        tmp_if_expr_23 = return_value_strchr_22 - alphabet;
      }

      else
        tmp_if_expr_23 = (signed long int)0xff;
      i6 = (unsigned char)tmp_if_expr_23;
      needle = needle + 1l;
      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_24=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        if(!(return_value_strchr_24 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_26;
      if(!(needle >= ceiling))
      {
        return_value_strchr_25=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        tmp_if_expr_26 = return_value_strchr_25 - alphabet;
      }

      else
        tmp_if_expr_26 = (signed long int)0xff;
      i7 = (unsigned char)tmp_if_expr_26;
      needle = needle + 1l;
      if(!((signed int)i5 == 0xff) && !((signed int)i6 == 0xff) && !((signed int)i7 == 0xff))
      {
        unsigned char *tmp_post_27 = dec;
        dec = dec + 1l;
        *tmp_post_27 = (unsigned char)((signed int)i5 << 7 | (signed int)i6 << 2 | (signed int)i7 >> 3);
      }

      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_28=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        if(!(return_value_strchr_28 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_30;
      if(!(needle >= ceiling))
      {
        return_value_strchr_29=strchr(alphabet, (signed int)*needle & (((signed int)*needle & 0x40) != 0 ? 0xdf : 0xff));
        tmp_if_expr_30 = return_value_strchr_29 - alphabet;
      }

      else
        tmp_if_expr_30 = (signed long int)0xff;
      i8 = (unsigned char)tmp_if_expr_30;
      needle = needle + 1l;
      if(!((signed int)i7 == 0xff) && !((signed int)i8 == 0xff))
      {
        unsigned char *tmp_post_31 = dec;
        dec = dec + 1l;
        *tmp_post_31 = (unsigned char)((signed int)i7 << 5 | (signed int)i8);
      }

    }
    *dec = (unsigned char)0;
    return bytes;
  }
}

// s_base32_encode
// file src/zarmour.c line 253
static char * s_base32_encode(const unsigned char *data, unsigned long int length, const char *alphabet, _Bool pad, char pad_char)
{
  unsigned long int extra_bytes = length % (unsigned long int)5;
  unsigned long int extra_chars = (unsigned long int)0;
  switch(extra_bytes)
  {
    case (unsigned long int)1:
    {
      extra_chars = (unsigned long int)2;
      break;
    }
    case (unsigned long int)2:
    {
      extra_chars = (unsigned long int)4;
      break;
    }
    case (unsigned long int)3:
    {
      extra_chars = (unsigned long int)5;
      break;
    }
    case (unsigned long int)4:
      extra_chars = (unsigned long int)7;
  }
  unsigned long int pad_chars = pad != (_Bool)0 && extra_chars != 0ul ? (unsigned long int)8 - extra_chars : (unsigned long int)0;
  unsigned long int str_chars = (unsigned long int)8 * (length / (unsigned long int)5) + extra_chars + pad_chars;
  char *str;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link2(str_chars + (unsigned long int)1, "src/zarmour.c", (unsigned int)264);
  str = (char *)return_value_safe_malloc_1;
  if(str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *enc = str;
    const unsigned char *needle = data;
    const unsigned char *ceiling = data + (signed long int)length;
    for( ; !(needle >= ceiling); needle = needle + (signed long int)5)
    {
      char *tmp_post_2 = enc;
      enc = enc + 1l;
      *tmp_post_2 = alphabet[(signed long int)((signed int)*needle >> 3)];
      if(!(needle + 1l >= ceiling))
      {
        char *tmp_post_3 = enc;
        enc = enc + 1l;
        *tmp_post_3 = alphabet[(signed long int)((signed int)*needle << 2 & 0x1c | (signed int)needle[(signed long int)1] >> 6)];
        char *tmp_post_4 = enc;
        enc = enc + 1l;
        *tmp_post_4 = alphabet[(signed long int)((signed int)needle[(signed long int)1] >> 1 & 0x1f)];
        if(!(needle + 2l >= ceiling))
        {
          char *tmp_post_5 = enc;
          enc = enc + 1l;
          *tmp_post_5 = alphabet[(signed long int)((signed int)needle[(signed long int)1] << 4 & 0x10 | (signed int)needle[(signed long int)2] >> 4)];
          if(!(needle + 3l >= ceiling))
          {
            char *tmp_post_6 = enc;
            enc = enc + 1l;
            *tmp_post_6 = alphabet[(signed long int)((signed int)needle[(signed long int)2] << 1 & 0x1e | (signed int)needle[(signed long int)3] >> 7)];
            char *tmp_post_7 = enc;
            enc = enc + 1l;
            *tmp_post_7 = alphabet[(signed long int)((signed int)needle[(signed long int)3] >> 2 & 0x1f)];
            if(!(needle + 4l >= ceiling))
            {
              char *tmp_post_8 = enc;
              enc = enc + 1l;
              *tmp_post_8 = alphabet[(signed long int)((signed int)needle[(signed long int)3] << 3 & 0x18 | (signed int)needle[(signed long int)4] >> 5)];
              char *tmp_post_9 = enc;
              enc = enc + 1l;
              *tmp_post_9 = alphabet[(signed long int)((signed int)needle[(signed long int)4] & 0x1f)];
            }

            else
            {
              char *tmp_post_10 = enc;
              enc = enc + 1l;
              *tmp_post_10 = alphabet[(signed long int)((signed int)needle[(signed long int)3] << 3 & 0x18)];
            }
          }

          else
          {
            char *tmp_post_11 = enc;
            enc = enc + 1l;
            *tmp_post_11 = alphabet[(signed long int)((signed int)needle[(signed long int)2] << 1 & 0x1e)];
          }
        }

        else
        {
          char *tmp_post_12 = enc;
          enc = enc + 1l;
          *tmp_post_12 = alphabet[(signed long int)((signed int)needle[(signed long int)1] << 4 & 0x10)];
        }
      }

      else
      {
        char *tmp_post_13 = enc;
        enc = enc + 1l;
        *tmp_post_13 = alphabet[(signed long int)((signed int)*needle << 2 & 0x1c)];
      }
    }
    while(!(enc >= str + (signed long int)str_chars))
    {
      char *tmp_post_14 = enc;
      enc = enc + 1l;
      *tmp_post_14 = pad_char;
    }
    *enc = (char)0;
    return str;
  }
}

// s_base64_decode
// file src/zarmour.c line 212
static unsigned char * s_base64_decode(const char *data, unsigned long int *size, const char *alphabet, unsigned long int linebreakchars)
{
  unsigned long int length;
  length=strlen(data);
  char *return_value_strchr_1;
  for( ; length >= 1ul; length = length - 1ul)
  {
    return_value_strchr_1=strchr(alphabet, (signed int)data[(signed long int)(length - (unsigned long int)1)]);
    if(!(return_value_strchr_1 == ((char *)NULL)))
      break;

  }
  const unsigned char *needle = (const unsigned char *)data;
  const unsigned char *ceiling = (const unsigned char *)(data + (signed long int)length);
  length = length - linebreakchars;
  *size = (unsigned long int)3 * (length / (unsigned long int)4) + (length % (unsigned long int)4 != 0ul ? length % (unsigned long int)4 - (unsigned long int)1 : (unsigned long int)0) + (unsigned long int)1;
  unsigned char *bytes;
  void *return_value_safe_malloc_2;
  return_value_safe_malloc_2=safe_malloc_link2(*size, "src/zarmour.c", (unsigned int)219);
  bytes = (unsigned char *)return_value_safe_malloc_2;
  char *return_value_strchr_3;
  char *return_value_strchr_4;
  char *return_value_strchr_6;
  char *return_value_strchr_7;
  char *return_value_strchr_10;
  char *return_value_strchr_11;
  char *return_value_strchr_14;
  char *return_value_strchr_15;
  if(bytes == ((unsigned char *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    unsigned char *dec = bytes;
    unsigned char i1;
    unsigned char i2;
    unsigned char i3;
    unsigned char i4;
    while(!(needle >= ceiling))
    {
      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_3=strchr(alphabet, (signed int)*needle);
        if(!(return_value_strchr_3 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_5;
      if(!(needle >= ceiling))
      {
        return_value_strchr_4=strchr(alphabet, (signed int)*needle);
        tmp_if_expr_5 = return_value_strchr_4 - alphabet;
      }

      else
        tmp_if_expr_5 = (signed long int)0xff;
      i1 = (unsigned char)tmp_if_expr_5;
      needle = needle + 1l;
      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_6=strchr(alphabet, (signed int)*needle);
        if(!(return_value_strchr_6 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_8;
      if(!(needle >= ceiling))
      {
        return_value_strchr_7=strchr(alphabet, (signed int)*needle);
        tmp_if_expr_8 = return_value_strchr_7 - alphabet;
      }

      else
        tmp_if_expr_8 = (signed long int)0xff;
      i2 = (unsigned char)tmp_if_expr_8;
      needle = needle + 1l;
      if(!((signed int)i1 == 0xff) && !((signed int)i2 == 0xff))
      {
        unsigned char *tmp_post_9 = dec;
        dec = dec + 1l;
        *tmp_post_9 = (unsigned char)((signed int)i1 << 2 | (signed int)i2 >> 4);
      }

      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_10=strchr(alphabet, (signed int)*needle);
        if(!(return_value_strchr_10 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_12;
      if(!(needle >= ceiling))
      {
        return_value_strchr_11=strchr(alphabet, (signed int)*needle);
        tmp_if_expr_12 = return_value_strchr_11 - alphabet;
      }

      else
        tmp_if_expr_12 = (signed long int)0xff;
      i3 = (unsigned char)tmp_if_expr_12;
      needle = needle + 1l;
      if(!((signed int)i2 == 0xff) && !((signed int)i3 == 0xff))
      {
        unsigned char *tmp_post_13 = dec;
        dec = dec + 1l;
        *tmp_post_13 = (unsigned char)((signed int)i2 << 4 | (signed int)i3 >> 2);
      }

      for( ; !(needle >= ceiling); needle = needle + 1l)
      {
        return_value_strchr_14=strchr(alphabet, (signed int)*needle);
        if(!(return_value_strchr_14 == ((char *)NULL)))
          break;

      }
      signed long int tmp_if_expr_16;
      if(!(needle >= ceiling))
      {
        return_value_strchr_15=strchr(alphabet, (signed int)*needle);
        tmp_if_expr_16 = return_value_strchr_15 - alphabet;
      }

      else
        tmp_if_expr_16 = (signed long int)0xff;
      i4 = (unsigned char)tmp_if_expr_16;
      needle = needle + 1l;
      if(!((signed int)i3 == 0xff) && !((signed int)i4 == 0xff))
      {
        unsigned char *tmp_post_17 = dec;
        dec = dec + 1l;
        *tmp_post_17 = (unsigned char)((signed int)i3 << 6 | (signed int)i4);
      }

    }
    *dec = (unsigned char)0;
    return bytes;
  }
}

// s_base64_encode
// file src/zarmour.c line 178
static char * s_base64_encode(const unsigned char *data, unsigned long int length, const char *alphabet, _Bool pad, char pad_char)
{
  unsigned long int extra_chars = length % (unsigned long int)3 != 0ul ? length % (unsigned long int)3 + (unsigned long int)1 : (unsigned long int)0;
  unsigned long int pad_chars = pad != (_Bool)0 && extra_chars != 0ul ? (unsigned long int)4 - extra_chars : (unsigned long int)0;
  unsigned long int str_chars = (unsigned long int)4 * (length / (unsigned long int)3) + extra_chars + pad_chars;
  char *str;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link2(str_chars + (unsigned long int)1, "src/zarmour.c", (unsigned int)183);
  str = (char *)return_value_safe_malloc_1;
  if(str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *enc = str;
    const unsigned char *needle = data;
    const unsigned char *ceiling = data + (signed long int)length;
    for( ; !(needle >= ceiling); needle = needle + (signed long int)3)
    {
      char *tmp_post_2 = enc;
      enc = enc + 1l;
      *tmp_post_2 = alphabet[(signed long int)((signed int)*needle >> 2)];
      if(!(needle + 1l >= ceiling))
      {
        char *tmp_post_3 = enc;
        enc = enc + 1l;
        *tmp_post_3 = alphabet[(signed long int)((signed int)*needle << 4 & 0x30 | (signed int)needle[(signed long int)1] >> 4)];
        if(!(needle + 2l >= ceiling))
        {
          char *tmp_post_4 = enc;
          enc = enc + 1l;
          *tmp_post_4 = alphabet[(signed long int)((signed int)needle[(signed long int)1] << 2 & 0x3c | (signed int)needle[(signed long int)2] >> 6)];
          char *tmp_post_5 = enc;
          enc = enc + 1l;
          *tmp_post_5 = alphabet[(signed long int)((signed int)needle[(signed long int)2] & 0x3f)];
        }

        else
        {
          char *tmp_post_6 = enc;
          enc = enc + 1l;
          *tmp_post_6 = alphabet[(signed long int)((signed int)needle[(signed long int)1] << 2 & 0x3c)];
        }
      }

      else
      {
        char *tmp_post_7 = enc;
        enc = enc + 1l;
        *tmp_post_7 = alphabet[(signed long int)((signed int)*needle << 4 & 0x30)];
      }
    }
    while(!(enc >= str + (signed long int)str_chars) && !(pad == (_Bool)0))
    {
      char *tmp_post_8 = enc;
      enc = enc + 1l;
      *tmp_post_8 = pad_char;
    }
    *enc = (char)0;
    return str;
  }
}

// s_beacon_recv
// file src/zbeacon_v2.c line 438
static void s_beacon_recv(struct anonymous_27 *self)
{
  /* assertion self */
  assert(self != ((struct anonymous_27 *)NULL));
  char peername[16l];
  struct _zframe_t *frame;
  frame=zsys_udp_recv(self->udpsock, peername);
  _Bool is_valid = (_Bool)0;
  unsigned char *return_value_zframe_data_1;
  signed int return_value_memcmp_2;
  if(!(self->filter == ((struct _zframe_t *)NULL)))
  {
    unsigned char *filter_data;
    filter_data=zframe_data(self->filter);
    unsigned long int filter_size;
    filter_size=zframe_size(self->filter);
    unsigned long int return_value_zframe_size_3;
    return_value_zframe_size_3=zframe_size(frame);
    if(return_value_zframe_size_3 >= filter_size)
    {
      return_value_zframe_data_1=zframe_data(frame);
      return_value_memcmp_2=memcmp((const void *)return_value_zframe_data_1, (const void *)filter_data, filter_size);
      if(return_value_memcmp_2 == 0)
        is_valid = (_Bool)1;

    }

  }

  unsigned char *return_value_zframe_data_4;
  signed int return_value_memcmp_5;
  if(!(is_valid == (_Bool)0))
  {
    if(!(self->noecho == (_Bool)0))
    {
      if(!(self->transmit == ((struct _zframe_t *)NULL)))
      {
        unsigned char *transmit_data;
        transmit_data=zframe_data(self->transmit);
        unsigned long int transmit_size;
        transmit_size=zframe_size(self->transmit);
        unsigned long int return_value_zframe_size_6;
        return_value_zframe_size_6=zframe_size(frame);
        if(return_value_zframe_size_6 == transmit_size)
        {
          return_value_zframe_data_4=zframe_data(frame);
          return_value_memcmp_5=memcmp((const void *)return_value_zframe_data_4, (const void *)transmit_data, transmit_size);
          if(return_value_memcmp_5 == 0)
            is_valid = (_Bool)0;

        }

      }

    }

  }

  if(!(is_valid == (_Bool)0))
  {
    struct _zmsg_t *msg;
    msg=zmsg_new();
    /* assertion msg */
    assert(msg != ((struct _zmsg_t *)NULL));
    zmsg_addstr(msg, peername);
    zmsg_append(msg, &frame);
    zmsg_send(&msg, self->pipe);
  }

  else
    zframe_destroy(&frame);
}

// s_bernstein_hash
// file src/zhashx.c line 89
static unsigned long int s_bernstein_hash(const void *key)
{
  const char *pointer = (const char *)key;
  unsigned long int key_hash = (unsigned long int)0;
  while(!(*pointer == 0))
  {
    const char *tmp_post_1 = pointer;
    pointer = pointer + 1l;
    key_hash = (unsigned long int)33 * key_hash ^ (unsigned long int)*tmp_post_1;
  }
  return key_hash;
}

// s_can_connect
// file src/zauth.c line 458
static _Bool s_can_connect(struct _zsock_t **server, struct _zsock_t **client)
{
  signed int port_nbr;
  port_nbr=zsock_bind(*server, "tcp://127.0.0.1:*");
  /* assertion port_nbr > 0 */
  assert(port_nbr > 0);
  signed int rc;
  rc=zsock_connect(*client, "tcp://127.0.0.1:%d", port_nbr);
  /* assertion rc == 0 */
  assert(rc == 0);
  zclock_sleep(200);
  zsock_set_sndtimeo((void *)*server, 200);
  zstr_send((void *)*server, "Hello, World");
  struct _zpoller_t *poller;
  poller=zpoller_new((void *)*client, (void *)0);
  /* assertion poller */
  assert(poller != ((struct _zpoller_t *)NULL));
  _Bool success;
  void *return_value_zpoller_wait_1;
  return_value_zpoller_wait_1=zpoller_wait(poller, 400);
  success = (struct _zsock_t *)return_value_zpoller_wait_1 == *client;
  zpoller_destroy(&poller);
  zsock_destroy_checked(client, "src/zauth.c", (unsigned long int)475);
  zsock_destroy_checked(server, "src/zauth.c", (unsigned long int)476);
  *server=zsock_new_checked(8, "src/zauth.c", (unsigned long int)477);
  /* assertion *server */
  assert(*server != ((struct _zsock_t *)NULL));
  *client=zsock_new_checked(7, "src/zauth.c", (unsigned long int)479);
  /* assertion *client */
  assert(*client != ((struct _zsock_t *)NULL));
  return success;
}

// s_can_connect_link1
// file src/zauth_v2.c line 612
static _Bool s_can_connect_link1(struct _zctx_t *ctx, void **server_link1, void **client_link1)
{
  signed int port_nbr_link1;
  port_nbr_link1=zsocket_bind(*server_link1, "tcp://127.0.0.1:*");
  /* assertion port_nbr > 0 */
  assert(port_nbr_link1 > 0);
  signed int rc_link1;
  rc_link1=zsocket_connect(*client_link1, "tcp://127.0.0.1:%d", port_nbr_link1);
  /* assertion rc == 0 */
  assert(rc_link1 == 0);
  zclock_sleep(200);
  zsock_set_sndtimeo(*server_link1, 200);
  zstr_send(*server_link1, "Hello, World");
  struct _zpoller_t *poller_link1;
  poller_link1=zpoller_new(*client_link1, (void *)0);
  _Bool success_link1;
  void *return_value_zpoller_wait_1_link1;
  return_value_zpoller_wait_1_link1=zpoller_wait(poller_link1, 400);
  success_link1 = return_value_zpoller_wait_1_link1 == *client_link1;
  zpoller_destroy(&poller_link1);
  zsocket_destroy(ctx, *client_link1);
  zsocket_destroy(ctx, *server_link1);
  *server_link1=zsocket_new(ctx, 8);
  /* assertion *server */
  assert(*server_link1 != NULL);
  *client_link1=zsocket_new(ctx, 7);
  /* assertion *client */
  assert(*client_link1 != NULL);
  return success_link1;
}

// s_cancel_timer_event
// file src/zloop.c line 877
static signed int s_cancel_timer_event(struct _zloop_t *loop, signed int timer_id, void *arg)
{
  signed int cancel_timer_id = *((signed int *)arg);
  signed int return_value_zloop_timer_end_1;
  return_value_zloop_timer_end_1=zloop_timer_end(loop, cancel_timer_id);
  return return_value_zloop_timer_end_1;
}

// s_check_event
// file src/zmonitor_v2.c line 333
static _Bool s_check_event(struct _zmonitor_t *self, signed int expected_event)
{
  struct _zmsg_t *msg;
  msg=zmonitor_recv(self);
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  char *string;
  string=zmsg_popstr(msg);
  signed int event;
  event=atoi(string);
  zstr_free(&string);
  zmsg_destroy(&msg);
  return event == expected_event;
}

// s_client_destroy
// file src/zgossip_engine.inc line 365
static void s_client_destroy(struct anonymous_31 **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct anonymous_31 **)NULL));
  if(!(*self_p == ((struct anonymous_31 *)NULL)))
  {
    struct anonymous_31 *self = *self_p;
    if(!(self->wakeup == 0))
      zloop_timer_end(self->server->loop, self->wakeup);

    if(!(self->ticket == NULL))
      zloop_ticket_delete(self->server->loop, self->ticket);

    zframe_destroy(&self->routing_id);
    engine_set_log_prefix(&self->client, "*** TERMINATED ***");
    client_terminate(&self->client);
    free((void *)self->hashkey);
    free((void *)self);
    *self_p = (struct anonymous_31 *)(void *)0;
  }

}

// s_client_execute
// file src/zgossip_engine.inc line 396
static void s_client_execute(struct anonymous_31 *self, enum anonymous_30 event)
{
  self->next_event = event;
  if(!(self->wakeup == 0))
  {
    zloop_timer_end(self->server->loop, self->wakeup);
    self->wakeup = 0;
  }

  while((signed int)self->next_event >= 1)
  {
    self->event = self->next_event;
    self->next_event = (enum anonymous_30)NULL_event;
    self->exception = (enum anonymous_30)NULL_event;
    if(!(self->server->verbose == (_Bool)0))
    {
      zsys_debug("%s: %s:", (const void *)self->log_prefix, s_state_name[(signed long int)self->state]);
      zsys_debug("%s:     %s", (const void *)self->log_prefix, s_event_name[(signed long int)self->event]);
    }

    switch((signed int)self->state)
    {
      case start_state:
      {
        if((signed int)self->event == hello_event)
        {
          if(self->exception == /*enum*/NULL_event)
          {
            if(!(self->server->verbose == (_Bool)0))
              zsys_debug("%s:         _ get first tuple", (const void *)self->log_prefix);

            get_first_tuple(&self->client);
          }

          if(self->exception == /*enum*/NULL_event)
            self->state = (enum anonymous_29)have_tuple_state;

        }

        else
          if((signed int)self->event == ping_event)
          {
            if(self->exception == /*enum*/NULL_event)
            {
              if(!(self->server->verbose == (_Bool)0))
                zsys_debug("%s:         _ send PONG", (const void *)self->log_prefix);

              zgossip_msg_set_id(self->server->message, 4);
              zgossip_msg_set_routing_id(self->server->message, self->routing_id);
              zgossip_msg_send(self->server->message, self->server->router);
            }

          }

          else
            if((signed int)self->event == expired_event)
            {
              if(self->exception == /*enum*/NULL_event)
              {
                if(!(self->server->verbose == (_Bool)0))
                  zsys_debug("%s:         _ terminate", (const void *)self->log_prefix);

                self->next_event = (enum anonymous_30)terminate_event;
              }

            }

            else
            {
              if(self->exception == /*enum*/NULL_event)
              {
                if(!(self->server->verbose == (_Bool)0))
                  zsys_debug("%s:         _ send INVALID", (const void *)self->log_prefix);

                zgossip_msg_set_id(self->server->message, 5);
                zgossip_msg_set_routing_id(self->server->message, self->routing_id);
                zgossip_msg_send(self->server->message, self->server->router);
              }

              if(self->exception == /*enum*/NULL_event)
              {
                if(!(self->server->verbose == (_Bool)0))
                  zsys_debug("%s:         _ terminate", (const void *)self->log_prefix);

                self->next_event = (enum anonymous_30)terminate_event;
              }

            }
        break;
      }
      case have_tuple_state:
      {
        if((signed int)self->event == ok_event)
        {
          if(self->exception == /*enum*/NULL_event)
          {
            if(!(self->server->verbose == (_Bool)0))
              zsys_debug("%s:         _ send PUBLISH", (const void *)self->log_prefix);

            zgossip_msg_set_id(self->server->message, 2);
            zgossip_msg_set_routing_id(self->server->message, self->routing_id);
            zgossip_msg_send(self->server->message, self->server->router);
          }

          if(self->exception == /*enum*/NULL_event)
          {
            if(!(self->server->verbose == (_Bool)0))
              zsys_debug("%s:         _ get next tuple", (const void *)self->log_prefix);

            get_next_tuple(&self->client);
          }

        }

        else
          if((signed int)self->event == finished_event)
          {
            if(self->exception == /*enum*/NULL_event)
              self->state = (enum anonymous_29)connected_state;

          }

          else
          {
            zsys_warning("%s: unhandled event %s in %s", (const void *)self->log_prefix, s_event_name[(signed long int)self->event], s_state_name[(signed long int)self->state]);
            /* assertion 0 */
            assert(0 != 0);
          }
        break;
      }
      case connected_state:
      {
        if((signed int)self->event == publish_event)
        {
          if(self->exception == /*enum*/NULL_event)
          {
            if(!(self->server->verbose == (_Bool)0))
              zsys_debug("%s:         _ store tuple if new", (const void *)self->log_prefix);

            store_tuple_if_new(&self->client);
          }

        }

        else
          if((signed int)self->event == forward_event)
          {
            if(self->exception == /*enum*/NULL_event)
            {
              if(!(self->server->verbose == (_Bool)0))
                zsys_debug("%s:         _ get tuple to forward", (const void *)self->log_prefix);

              get_tuple_to_forward(&self->client);
            }

            if(self->exception == /*enum*/NULL_event)
            {
              if(!(self->server->verbose == (_Bool)0))
                zsys_debug("%s:         _ send PUBLISH", (const void *)self->log_prefix);

              zgossip_msg_set_id(self->server->message, 2);
              zgossip_msg_set_routing_id(self->server->message, self->routing_id);
              zgossip_msg_send(self->server->message, self->server->router);
            }

          }

          else
            if((signed int)self->event == ping_event)
            {
              if(self->exception == /*enum*/NULL_event)
              {
                if(!(self->server->verbose == (_Bool)0))
                  zsys_debug("%s:         _ send PONG", (const void *)self->log_prefix);

                zgossip_msg_set_id(self->server->message, 4);
                zgossip_msg_set_routing_id(self->server->message, self->routing_id);
                zgossip_msg_send(self->server->message, self->server->router);
              }

            }

            else
              if((signed int)self->event == expired_event)
              {
                if(self->exception == /*enum*/NULL_event)
                {
                  if(!(self->server->verbose == (_Bool)0))
                    zsys_debug("%s:         _ terminate", (const void *)self->log_prefix);

                  self->next_event = (enum anonymous_30)terminate_event;
                }

              }

              else
              {
                if(self->exception == /*enum*/NULL_event)
                {
                  if(!(self->server->verbose == (_Bool)0))
                    zsys_debug("%s:         _ send INVALID", (const void *)self->log_prefix);

                  zgossip_msg_set_id(self->server->message, 5);
                  zgossip_msg_set_routing_id(self->server->message, self->routing_id);
                  zgossip_msg_send(self->server->message, self->server->router);
                }

                if(self->exception == /*enum*/NULL_event)
                {
                  if(!(self->server->verbose == (_Bool)0))
                    zsys_debug("%s:         _ terminate", (const void *)self->log_prefix);

                  self->next_event = (enum anonymous_30)terminate_event;
                }

              }
        break;
      }
      case external_state:
        if((signed int)self->event == ping_event)
        {
          if(self->exception == /*enum*/NULL_event)
          {
            if(!(self->server->verbose == (_Bool)0))
              zsys_debug("%s:         _ send PONG", (const void *)self->log_prefix);

            zgossip_msg_set_id(self->server->message, 4);
            zgossip_msg_set_routing_id(self->server->message, self->routing_id);
            zgossip_msg_send(self->server->message, self->server->router);
          }

        }

        else
          if((signed int)self->event == expired_event)
          {
            if(self->exception == /*enum*/NULL_event)
            {
              if(!(self->server->verbose == (_Bool)0))
                zsys_debug("%s:         _ terminate", (const void *)self->log_prefix);

              self->next_event = (enum anonymous_30)terminate_event;
            }

          }

          else
          {
            if(self->exception == /*enum*/NULL_event)
            {
              if(!(self->server->verbose == (_Bool)0))
                zsys_debug("%s:         _ send INVALID", (const void *)self->log_prefix);

              zgossip_msg_set_id(self->server->message, 5);
              zgossip_msg_set_routing_id(self->server->message, self->routing_id);
              zgossip_msg_send(self->server->message, self->server->router);
            }

            if(self->exception == /*enum*/NULL_event)
            {
              if(!(self->server->verbose == (_Bool)0))
                zsys_debug("%s:         _ terminate", (const void *)self->log_prefix);

              self->next_event = (enum anonymous_30)terminate_event;
            }

          }
    }
    if(!(self->exception == /*enum*/NULL_event))
    {
      if(!(self->server->verbose == (_Bool)0))
        zsys_debug("%s:         ! %s", (const void *)self->log_prefix, s_event_name[(signed long int)self->exception]);

      self->next_event = self->exception;
    }

    if((signed int)self->next_event == terminate_event)
    {
      zhash_delete(self->server->clients, self->hashkey);
      break;
    }

    else
      if(!(self->server->verbose == (_Bool)0))
        zsys_debug("%s:         > %s", (const void *)self->log_prefix, s_state_name[(signed long int)self->state]);

  }
}

// s_client_free
// file src/zgossip_engine.inc line 386
static void s_client_free(void *argument)
{
  struct anonymous_31 *client = (struct anonymous_31 *)argument;
  s_client_destroy(&client);
}

// s_client_handle_ticket
// file src/zgossip_engine.inc line 632
static signed int s_client_handle_ticket(struct _zloop_t *loop, signed int timer_id, void *argument)
{
  struct anonymous_31 *self = (struct anonymous_31 *)argument;
  s_client_execute(self, (enum anonymous_30)expired_event);
  self->ticket = (void *)0;
  return 0;
}

// s_client_handle_wakeup
// file src/zgossip_engine.inc line 643
static signed int s_client_handle_wakeup(struct _zloop_t *loop, signed int timer_id, void *argument)
{
  struct anonymous_31 *self = (struct anonymous_31 *)argument;
  s_client_execute(self, self->wakeup_event);
  return 0;
}

// s_client_new
// file src/zgossip_engine.inc line 339
static struct anonymous_31 * s_client_new(struct anonymous_28 *server, struct _zframe_t *routing_id)
{
  struct anonymous_31 *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link13(sizeof(struct anonymous_31) /*120ul*/ , "src/zgossip_engine.inc", (unsigned int)341);
  self = (struct anonymous_31 *)return_value_safe_malloc_1;
  /* assertion self */
  assert(self != ((struct anonymous_31 *)NULL));
  /* assertion (s_client_t *) &self->client == self */
  assert((struct anonymous_31 *)&self->client == self);
  self->server = server;
  self->hashkey=zframe_strhex(routing_id);
  self->routing_id=zframe_dup(routing_id);
  unsigned int tmp_post_2 = server->client_id;
  server->client_id = server->client_id + 1u;
  self->unique_id = tmp_post_2;
  engine_set_log_prefix(&self->client, server->log_prefix);
  self->client.server = (struct _server_t *)server;
  self->client.message = server->message;
  if(!(server->timeout == 0ul))
    self->ticket=zloop_ticket(server->loop, s_client_handle_ticket, (void *)self);

  self->state = (enum anonymous_29)start_state;
  self->event = (enum anonymous_30)NULL_event;
  client_initialize(&self->client);
  return self;
}

// s_collect_level
// file src/zconfig.c line 683
static signed int s_collect_level(char **start, signed int lineno)
{
  char *readptr = *start;
  for( ; (signed int)*readptr == 32; readptr = readptr + 1l)
    ;
  signed long int level = (readptr - *start) / (signed long int)4;
  if(!(4l * level == readptr - *start))
  {
    zclock_log("E (zconfig): (%d) indent 4 spaces at once", lineno);
    level = (signed long int)-1;
  }

  *start = readptr;
  if(level >= 2147483648l)
    return -1;

  else
    return (signed int)level;
}

// s_collect_name
// file src/zconfig.c line 717
static char * s_collect_name(char **start, signed int lineno)
{
  char *readptr = *start;
  _Bool return_value_s_is_namechar_1;
  do
  {
    return_value_s_is_namechar_1=s_is_namechar((char)*(*start));
    if(return_value_s_is_namechar_1 == (_Bool)0)
      break;

    *start = *start + 1l;
  }
  while((_Bool)1);
  unsigned long int length = (unsigned long int)(*start - readptr);
  char *name;
  void *return_value_safe_malloc_2;
  return_value_safe_malloc_2=safe_malloc_link7(length + (unsigned long int)1, "src/zconfig.c", (unsigned int)724);
  name = (char *)return_value_safe_malloc_2;
  if(name == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    memcpy((void *)name, (const void *)readptr, length);
    name[(signed long int)length] = (char)0;
    if(length >= 1ul)
    {
      _Bool tmp_if_expr_3;
      if((signed int)*name == 47)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)name[(signed long int)(length - (unsigned long int)1)] == 47 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
      {
        zclock_log("E (zconfig): (%d) '/' not valid at name start or end", lineno);
        free((void *)name);
        name = (char *)(void *)0;
      }

    }

    return name;
  }
}

// s_collect_value
// file src/zconfig.c line 764
static char * s_collect_value(char **start, signed int lineno)
{
  char *value = (char *)(void *)0;
  char *readptr = *start;
  signed int rc = 0;
  signed int return_value_isspace_1;
  do
  {
    return_value_isspace_1=isspace((signed int)(unsigned char)*readptr);
    if(return_value_isspace_1 == 0)
      break;

    readptr = readptr + 1l;
  }
  while((_Bool)1);
  signed int return_value_isspace_2;
  signed int return_value_isspace_4;
  if((signed int)*readptr == 61)
  {
    readptr = readptr + 1l;
    do
    {
      return_value_isspace_2=isspace((signed int)(unsigned char)*readptr);
      if(return_value_isspace_2 == 0)
        break;

      readptr = readptr + 1l;
    }
    while((_Bool)1);
    _Bool tmp_if_expr_5;
    if((signed int)*readptr == 34)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = (signed int)*readptr == 39 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
    {
      char *endquote;
      endquote=strchr(readptr + (signed long int)1, (signed int)*readptr);
      if(!(endquote == ((char *)NULL)))
      {
        unsigned long int value_length = (unsigned long int)((endquote - readptr) - (signed long int)1);
        void *return_value_safe_malloc_3;
        return_value_safe_malloc_3=safe_malloc_link7(value_length + (unsigned long int)1, "src/zconfig.c", (unsigned int)783);
        value = (char *)return_value_safe_malloc_3;
        if(value == ((char *)NULL))
          return (char *)(void *)0;

        memcpy((void *)value, (const void *)(readptr + (signed long int)1), value_length);
        value[(signed long int)value_length] = (char)0;
        rc=s_verify_eoln(endquote + (signed long int)1, lineno);
      }

      else
      {
        zclock_log("E (zconfig): (%d) missing %c", lineno, *readptr);
        rc = -1;
      }
    }

    else
    {
      char *comment;
      comment=strchr(readptr, 35);
      if(!(comment == ((char *)NULL)))
      {
        do
        {
          return_value_isspace_4=isspace((signed int)(unsigned char)comment[(signed long int)-1]);
          if(return_value_isspace_4 == 0)
            break;

          comment = comment - 1l;
        }
        while((_Bool)1);
        *comment = (char)0;
      }

      value=strdup(readptr);
    }
  }

  else
  {
    value=strdup("");
    rc=s_verify_eoln(readptr, lineno);
  }
  if(!(rc == 0))
  {
    free((void *)value);
    value = (char *)(void *)0;
  }

  return value;
}

// s_comparator
// file src/zlistx.c line 93
static signed int s_comparator(const void *item1, const void *item2)
{
  if(item1 == item2)
    return 0;

  else
    if(!(item1 >= item2))
      return -1;

    else
      return 1;
}

// s_compare
// file src/zlist.c line 487
static signed int s_compare(void *item1, void *item2)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp((char *)item1, (char *)item2);
  return return_value_strcmp_1;
}

// s_config_execute
// file src/zconfig.c line 365
static signed int s_config_execute(struct _zconfig_t *self, signed int (*handler)(struct _zconfig_t *, void *, signed int), void *arg, signed int level)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  signed int size;
  size=handler(self, arg, level);
  struct _zconfig_t *child = self->child;
  if(!(child == ((struct _zconfig_t *)NULL)))
  {
    signed int rc;
    rc=s_config_execute(child, handler, arg, level + 1);
    if(rc == -1)
      return -1;

    size = size + rc;
    child = child->next;
  }

  return size;
}

// s_config_printf
// file src/zconfig.c line 450
static signed int s_config_printf(struct _zconfig_t *self, void *arg, char *format, ...)
{
  void **argptr = (void **)&format;
  char *string;
  string=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  unsigned long int return_value_strlen_1;
  if(string == ((char *)NULL))
    return -1;

  else
  {
    if(!(arg == NULL))
    {
      _Bool return_value_zchunk_is_2;
      return_value_zchunk_is_2=zchunk_is(arg);
      if(!(return_value_zchunk_is_2 == (_Bool)0))
      {
        return_value_strlen_1=strlen(string);
        zchunk_append((struct _zchunk_t *)arg, (const void *)string, return_value_strlen_1);
      }

      else
        fprintf((struct _IO_FILE *)arg, "%s", string);
    }

    unsigned long int size;
    size=strlen(string);
    free((void *)string);
    if(size >= 2147483648ul)
      return -1;

    else
      return (signed int)size;
  }
}

// s_config_save
// file src/zconfig.c line 475
static signed int s_config_save(struct _zconfig_t *self, void *arg, signed int level)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  signed int size = 0;
  if(!(self->comments == ((struct _zlist_t *)NULL)))
  {
    char *comment;
    void *return_value_zlist_first_1;
    return_value_zlist_first_1=zlist_first(self->comments);
    comment = (char *)return_value_zlist_first_1;
    while(!(comment == ((char *)NULL)))
    {
      signed int return_value_s_config_printf_2;
      return_value_s_config_printf_2=s_config_printf(self, arg, "#%s\n", comment);
      size = size + return_value_s_config_printf_2;
      void *return_value_zlist_next_3;
      return_value_zlist_next_3=zlist_next(self->comments);
      comment = (char *)return_value_zlist_next_3;
    }
    signed int return_value_s_config_printf_4;
    return_value_s_config_printf_4=s_config_printf(self, arg, "\n");
    size = size + return_value_s_config_printf_4;
  }

  signed int return_value_s_config_printf_6;
  signed int return_value_s_config_printf_8;
  if(level >= 1)
  {
    if(!(self->value == ((char *)NULL)))
    {
      char *tmp_if_expr_5;
      if(!(self->name == ((char *)NULL)))
        tmp_if_expr_5 = self->name;

      else
        tmp_if_expr_5 = "(Unnamed)";
      return_value_s_config_printf_6=s_config_printf(self, arg, "%*s%s = \"%s\"\n", (level - 1) * 4, (const void *)"", tmp_if_expr_5, self->value);
      size = size + return_value_s_config_printf_6;
    }

    else
    {
      char *tmp_if_expr_7;
      if(!(self->name == ((char *)NULL)))
        tmp_if_expr_7 = self->name;

      else
        tmp_if_expr_7 = "(Unnamed)";
      return_value_s_config_printf_8=s_config_printf(self, arg, "%*s%s\n", (level - 1) * 4, (const void *)"", tmp_if_expr_7);
      size = size + return_value_s_config_printf_8;
    }
  }

  return size;
}

// s_create_socket
// file src/zproxy.c line 70
static struct _zsock_t * s_create_socket(char *type_name, char *endpoints)
{
  /* assertion 0 == 0 */
  assert(0 == 0);
  char *type_names[12l] = { "PAIR", "PUB", "SUB", "REQ", "REP", "DEALER", "ROUTER", "PULL", "PUSH", "XPUB", "XSUB", type_name };
  signed int index = 0;
  signed int return_value_strcmp_1;
  do
  {
    return_value_strcmp_1=strcmp(type_name, type_names[(signed long int)index]);
    if(return_value_strcmp_1 == 0)
      break;

    index = index + 1;
  }
  while((_Bool)1);
  if(index >= 11)
  {
    zsys_error("zproxy: invalid socket type '%s'", type_name);
    return (struct _zsock_t *)(void *)0;
  }

  else
  {
    struct _zsock_t *sock;
    sock=zsock_new_checked(index, "src/zproxy.c", (unsigned long int)86);
    if(!(sock == ((struct _zsock_t *)NULL)))
    {
      signed int return_value_zsock_attach_2;
      return_value_zsock_attach_2=zsock_attach(sock, endpoints, (_Bool)1);
      if(!(return_value_zsock_attach_2 == 0))
      {
        zsys_error("zproxy: invalid endpoints '%s'", endpoints);
        zsock_destroy_checked(&sock, "src/zproxy.c", (unsigned long int)90);
      }

    }

    return sock;
  }
}

// s_dir_compare
// file src/zdir.c line 359
static signed int s_dir_compare(void *item1, void *item2)
{
  /* assertion item1 */
  assert(item1 != NULL);
  /* assertion item2 */
  assert(item2 != NULL);
  const char *return_value_zdir_path_1;
  return_value_zdir_path_1=zdir_path((struct _zdir_t *)item1);
  const char *return_value_zdir_path_2;
  return_value_zdir_path_2=zdir_path((struct _zdir_t *)item2);
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(return_value_zdir_path_1, return_value_zdir_path_2);
  return return_value_strcmp_3;
}

// s_dir_flatten
// file src/zdir.c line 337
static signed int s_dir_flatten(struct _zdir_t *self, struct _zfile_t **files, signed int index)
{
  zlist_sort(self->files, s_file_compare);
  struct _zfile_t *file;
  void *return_value_zlist_first_1;
  return_value_zlist_first_1=zlist_first(self->files);
  file = (struct _zfile_t *)return_value_zlist_first_1;
  while(!(file == ((struct _zfile_t *)NULL)))
  {
    signed int tmp_post_2 = index;
    index = index + 1;
    files[(signed long int)tmp_post_2] = file;
    void *return_value_zlist_next_3;
    return_value_zlist_next_3=zlist_next(self->files);
    file = (struct _zfile_t *)return_value_zlist_next_3;
  }
  zlist_sort(self->subdirs, s_dir_compare);
  struct _zdir_t *subdir;
  void *return_value_zlist_first_4;
  return_value_zlist_first_4=zlist_first(self->subdirs);
  subdir = (struct _zdir_t *)return_value_zlist_first_4;
  while(!(subdir == ((struct _zdir_t *)NULL)))
  {
    index=s_dir_flatten(subdir, files, index);
    void *return_value_zlist_next_5;
    return_value_zlist_next_5=zlist_next(self->subdirs);
    subdir = (struct _zdir_t *)return_value_zlist_next_5;
  }
  return index;
}

// s_file_compare
// file src/zdir.c line 371
static signed int s_file_compare(void *item1, void *item2)
{
  /* assertion item1 */
  assert(item1 != NULL);
  /* assertion item2 */
  assert(item2 != NULL);
  const char *return_value_zfile_filename_1;
  return_value_zfile_filename_1=zfile_filename((struct _zfile_t *)item1, (const char *)(void *)0);
  const char *return_value_zfile_filename_2;
  return_value_zfile_filename_2=zfile_filename((struct _zfile_t *)item2, (const char *)(void *)0);
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(return_value_zfile_filename_1, return_value_zfile_filename_2);
  return return_value_strcmp_3;
}

// s_get_interface
// file src/zbeacon_v2.c line 352
static void s_get_interface(struct anonymous_27 *self)
{
  const char *iface;
  iface=zsys_interface();
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(iface, "*");
  if(return_value_strcmp_4 == 0)
  {
    self->broadcast.sin_family = (unsigned short int)2;
    self->broadcast.sin_addr.s_addr = (unsigned int)0xffffffff;
    self->broadcast.sin_port=htons((unsigned short int)self->port_nbr);
    self->address = self->broadcast;
    self->address.sin_addr.s_addr = (unsigned int)0x00000000;
  }

  else
  {
    struct _ziflist_t *iflist;
    iflist=ziflist_new();
    /* assertion iflist */
    assert(iflist != ((struct _ziflist_t *)NULL));
    const char *name;
    name=ziflist_first(iflist);
    if(!(*iface == 0))
      while(!(name == ((const char *)NULL)))
      {
        signed int return_value_strcmp_1;
        return_value_strcmp_1=strcmp(iface, name);
        if(return_value_strcmp_1 == 0)
          break;

        name=ziflist_next(iflist);
      }

    if(!(name == ((const char *)NULL)))
    {
      self->broadcast.sin_family = (unsigned short int)2;
      const char *return_value_ziflist_broadcast_2;
      return_value_ziflist_broadcast_2=ziflist_broadcast(iflist);
      self->broadcast.sin_addr.s_addr=inet_addr(return_value_ziflist_broadcast_2);
      self->broadcast.sin_port=htons((unsigned short int)self->port_nbr);
      self->address = self->broadcast;
      const char *return_value_ziflist_address_3;
      return_value_ziflist_address_3=ziflist_address(iflist);
      self->address.sin_addr.s_addr=inet_addr(return_value_ziflist_address_3);
    }

    else
      zsys_error("No adapter found, ZSYS_INTERFACE=%s isn't helping", iface);
    ziflist_destroy(&iflist);
  }
}

// s_interface_destroy
// file src/ziflist.c line 41
static void s_interface_destroy(struct anonymous_19 **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct anonymous_19 **)NULL));
  struct anonymous_19 *self = *self_p;
  if(!(self == ((struct anonymous_19 *)NULL)))
  {
    free((void *)self->name);
    free((void *)self->address);
    free((void *)self->netmask);
    free((void *)self->broadcast);
    free((void *)self);
    *self_p = (struct anonymous_19 *)(void *)0;
  }

}

// s_interface_new
// file src/ziflist.c line 60
static struct anonymous_19 * s_interface_new(char *name, struct sockaddr_in address, struct sockaddr_in netmask, struct sockaddr_in broadcast)
{
  struct anonymous_19 *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link15(sizeof(struct anonymous_19) /*32ul*/ , "src/ziflist.c", (unsigned int)62);
  self = (struct anonymous_19 *)return_value_safe_malloc_1;
  char *return_value_inet_ntoa_2;
  char *return_value_inet_ntoa_3;
  char *return_value_inet_ntoa_4;
  if(self == ((struct anonymous_19 *)NULL))
    return (struct anonymous_19 *)(void *)0;

  else
  {
    self->name=strdup(name);
    if(!(self->name == ((char *)NULL)))
    {
      return_value_inet_ntoa_2=inet_ntoa(address.sin_addr);
      self->address=strdup(return_value_inet_ntoa_2);
    }

    if(!(self->address == ((char *)NULL)))
    {
      return_value_inet_ntoa_3=inet_ntoa(netmask.sin_addr);
      self->netmask=strdup(return_value_inet_ntoa_3);
    }

    if(!(self->netmask == ((char *)NULL)))
    {
      return_value_inet_ntoa_4=inet_ntoa(broadcast.sin_addr);
      self->broadcast=strdup(return_value_inet_ntoa_4);
    }

    if(self->broadcast == ((char *)NULL))
      s_interface_destroy(&self);

    return self;
  }
}

// s_is_namechar
// file src/zconfig.c line 703
static _Bool s_is_namechar(char thischar)
{
  signed int return_value_isalnum_1;
  return_value_isalnum_1=isalnum((signed int)thischar);
  return (((((((return_value_isalnum_1 != 0 ? (_Bool)1 : ((signed int)thischar == 36 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : ((signed int)thischar == 45 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : ((signed int)thischar == 95 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : ((signed int)thischar == 64 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : ((signed int)thischar == 46 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : ((signed int)thischar == 38 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : ((signed int)thischar == 43 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : ((signed int)thischar == 47 ? (_Bool)1 : (_Bool)0);
}

// s_item_destroy
// file src/zhashx.c line 171
static void s_item_destroy(struct _zhashx_t *self, struct _item_t *item, _Bool hard)
{
  struct _item_t *cur_item = self->items[(signed long int)item->index];
  struct _item_t **prev_item = &self->items[(signed long int)item->index];
  for( ; !(cur_item == ((struct _item_t *)NULL)); cur_item = cur_item->next)
  {
    if(cur_item == item)
      break;

    prev_item = &cur_item->next;
  }
  /* assertion cur_item */
  assert(cur_item != ((struct _item_t *)NULL));
  *prev_item = item->next;
  self->size = self->size - 1ul;
  if(!(hard == (_Bool)0))
  {
    if(!(self->destructor == ((void (*)(void **))NULL)))
      self->destructor(&item->value);

    else
      if(!(item->free_fn == ((void (*)(void *))NULL)))
        item->free_fn(item->value);

    self->cursor_item = (struct _item_t *)(void *)0;
    self->cursor_key = (void *)0;
    if(!(self->key_destructor == ((void (*)(void **))NULL)))
      self->key_destructor((void **)&item->key);

    free((void *)item);
  }

}

// s_item_destroy_link1
// file src/zhash.c line 121
static void s_item_destroy_link1(struct _zhash_t *self_link1, struct _item_t_0 *item_link1, _Bool hard_link1)
{
  struct _item_t_0 *cur_item_link1 = self_link1->items[(signed long int)item_link1->index];
  struct _item_t_0 **prev_item_link1 = &self_link1->items[(signed long int)item_link1->index];
  for( ; !(cur_item_link1 == ((struct _item_t_0 *)NULL)); cur_item_link1 = cur_item_link1->next)
  {
    if(cur_item_link1 == item_link1)
      break;

    prev_item_link1 = &cur_item_link1->next;
  }
  /* assertion cur_item */
  assert(cur_item_link1 != ((struct _item_t_0 *)NULL));
  *prev_item_link1 = item_link1->next;
  self_link1->size = self_link1->size - 1ul;
  if(!(hard_link1 == (_Bool)0))
  {
    if(!(item_link1->free_fn == ((void (*)(void *))NULL)))
      item_link1->free_fn(item_link1->value);

    else
      if(!(self_link1->autofree == (_Bool)0))
        free(item_link1->value);

    free((void *)item_link1->key);
    self_link1->cursor_item = (struct _item_t_0 *)(void *)0;
    self_link1->cursor_key = (const char *)(void *)0;
    free((void *)item_link1);
  }

}

// s_item_hash
// file src/zhash.c line 199
static unsigned int s_item_hash(const char *key, unsigned long int limit)
{
  unsigned int key_hash = (unsigned int)0;
  while(!(*key == 0))
  {
    const char *tmp_post_1 = key;
    key = key + 1l;
    key_hash = (unsigned int)33 * key_hash ^ (unsigned int)*tmp_post_1;
  }
  key_hash = key_hash % (unsigned int)limit;
  return key_hash;
}

// s_item_insert
// file src/zhashx.c line 274
static struct _item_t * s_item_insert(struct _zhashx_t *self, const void *key, void *value)
{
  struct _item_t *item;
  item=s_item_lookup(self, key);
  if(item == ((struct _item_t *)NULL))
  {
    void *return_value_safe_malloc_1;
    return_value_safe_malloc_1=safe_malloc_link14(sizeof(struct _item_t) /*40ul*/ , "src/zhashx.c", (unsigned int)280);
    item = (struct _item_t *)return_value_safe_malloc_1;
    if(item == ((struct _item_t *)NULL))
      return (struct _item_t *)(void *)0;

    if(!(self->key_duplicator == ((void * (*)(const void *))NULL)))
      item->key=self->key_duplicator((void *)key);

    else
      item->key = key;
    if(!(self->duplicator == ((void * (*)(const void *))NULL)))
      item->value=self->duplicator(value);

    else
      item->value = value;
    item->index = self->cached_index;
    item->next = self->items[(signed long int)self->cached_index];
    self->items[(signed long int)self->cached_index] = item;
    self->size = self->size + 1ul;
    self->cursor_item = item;
    self->cursor_key = item->key;
  }

  else
    item = (struct _item_t *)(void *)0;
  return item;
}

// s_item_insert_link1
// file src/zhash.c line 216
static struct _item_t_0 * s_item_insert_link1(struct _zhash_t *self_link1, const char *key_link1, void *value_link1)
{
  struct _item_t_0 *item_link1;
  item_link1=s_item_lookup_link1(self_link1, key_link1);
  char *return_value_strdup_2;
  if(item_link1 == ((struct _item_t_0 *)NULL))
  {
    void *return_value_safe_malloc_1_link1;
    return_value_safe_malloc_1_link1=safe_malloc_link31(sizeof(struct _item_t_0) /*40ul*/ , "src/zhash.c", (unsigned int)222);
    item_link1 = (struct _item_t_0 *)return_value_safe_malloc_1_link1;
    if(item_link1 == ((struct _item_t_0 *)NULL))
      return (struct _item_t_0 *)(void *)0;

    if(!(self_link1->autofree == (_Bool)0))
    {
      return_value_strdup_2=strdup((char *)value_link1);
      value_link1 = (void *)return_value_strdup_2;
    }

    item_link1->value = value_link1;
    item_link1->key=strdup(key_link1);
    item_link1->index = self_link1->cached_index;
    item_link1->next = self_link1->items[(signed long int)self_link1->cached_index];
    self_link1->items[(signed long int)self_link1->cached_index] = item_link1;
    self_link1->size = self_link1->size + 1ul;
  }

  else
    item_link1 = (struct _item_t_0 *)(void *)0;
  return item_link1;
}

// s_item_lookup
// file src/zhashx.c line 317
static struct _item_t * s_item_lookup(struct _zhashx_t *self, const void *key)
{
  unsigned long int limit = primes[(signed long int)self->prime_index];
  unsigned long int return_value;
  return_value=self->hasher(key);
  self->cached_index = return_value % limit;
  struct _item_t *item = self->items[(signed long int)self->cached_index];
  unsigned int len = (unsigned int)0;
  if(!(item == ((struct _item_t *)NULL)))
  {
    signed int return_value_1;
    return_value_1=self->key_comparator(item->key, key);
    if(!(return_value_1 == 0))
    {
      item = item->next;
      len = len + 1u;
    }

  }

  if(!(self->chain_limit >= len))
  {
    unsigned int new_prime_index = self->prime_index + (unsigned int)5;
    signed int return_value_s_zhashx_rehash_1;
    return_value_s_zhashx_rehash_1=s_zhashx_rehash(self, new_prime_index);
    if(!(return_value_s_zhashx_rehash_1 == 0))
      return (struct _item_t *)(void *)0;

    limit = primes[(signed long int)self->prime_index];
    unsigned long int return_value_2;
    return_value_2=self->hasher(key);
    self->cached_index = return_value_2 % limit;
  }

  return item;
}

// s_item_lookup_link1
// file src/zhash.c line 249
static struct _item_t_0 * s_item_lookup_link1(struct _zhash_t *self_link1, const char *key_link1)
{
  unsigned int return_value_s_item_hash_1;
  return_value_s_item_hash_1=s_item_hash(key_link1, self_link1->limit);
  self_link1->cached_index = (unsigned long int)return_value_s_item_hash_1;
  struct _item_t_0 *item_link1 = self_link1->items[(signed long int)self_link1->cached_index];
  while(!(item_link1 == ((struct _item_t_0 *)NULL)))
  {
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(item_link1->key, key_link1);
    if(return_value_strcmp_2 == 0)
      break;

    item_link1 = item_link1->next;
  }
  return item_link1;
}

// s_load_certs_from_disk
// file src/zcertstore.c line 93
static void s_load_certs_from_disk(struct _zcertstore_t *self)
{
  zhashx_purge(self->certs);
  struct _zdir_t *dir;
  dir=zdir_new(self->location, (const char *)(void *)0);
  const char *return_value_zfile_filename_2;
  _Bool return_value_zrex_matches_3;
  if(!(dir == ((struct _zdir_t *)NULL)))
  {
    struct _zfile_t **filelist;
    filelist=zdir_flatten(dir);
    /* assertion filelist */
    assert(filelist != ((struct _zfile_t **)NULL));
    struct _zrex_t *rex;
    rex=zrex_new("_secret_");
    /* assertion rex */
    assert(rex != ((struct _zrex_t *)NULL));
    unsigned int index = (unsigned int)0;
    do
    {
      struct _zfile_t *file = filelist[(signed long int)index];
      if(file == ((struct _zfile_t *)NULL))
        break;

      _Bool return_value_zfile_is_regular_4;
      return_value_zfile_is_regular_4=zfile_is_regular(file);
      if(!(return_value_zfile_is_regular_4 == (_Bool)0))
      {
        return_value_zfile_filename_2=zfile_filename(file, (const char *)(void *)0);
        return_value_zrex_matches_3=zrex_matches(rex, return_value_zfile_filename_2);
        if(return_value_zrex_matches_3 == (_Bool)0)
        {
          struct _zcert_t *cert;
          const char *return_value_zfile_filename_1;
          return_value_zfile_filename_1=zfile_filename(file, (const char *)(void *)0);
          cert=zcert_load(return_value_zfile_filename_1);
          if(!(cert == ((struct _zcert_t *)NULL)))
            zcertstore_insert(self, &cert);

        }

      }

      index = index + 1u;
    }
    while((_Bool)1);
    zdir_flatten_free(&filelist);
    self->modified=zdir_modified(dir);
    self->count=zdir_count(dir);
    signed long int return_value_zdir_cursize_5;
    return_value_zdir_cursize_5=zdir_cursize(dir);
    self->cursize = (unsigned long int)return_value_zdir_cursize_5;
    zrex_destroy(&rex);
    zdir_destroy(&dir);
  }

}

// s_log
// file src/zsys.c line 1431
static void s_log(char loglevel, char *string)
{
  if(!(s_logsystem == (_Bool)0))
  {
    signed int priority = 6;
    if((signed int)loglevel == 69)
      priority = 3;

    else
      if((signed int)loglevel == 87)
        priority = 4;

      else
        if((signed int)loglevel == 78)
          priority = 5;

        else
          if((signed int)loglevel == 73)
            priority = 6;

          else
            if((signed int)loglevel == 68)
              priority = 7;

    syslog(priority, "%s", string);
  }

  else
    if(s_logstream == ((struct _IO_FILE *)NULL))
      s_logstream = stdout;

  if(!(s_logstream == ((struct _IO_FILE *)NULL)) || !(s_logsender == ((struct _zsock_t *)NULL)))
  {
    signed long int curtime;
    curtime=time((signed long int *)(void *)0);
    struct tm *loctime;
    loctime=localtime(&curtime);
    char date[20l];
    strftime(date, (unsigned long int)20, "%y-%m-%d %H:%M:%S", loctime);
    char log_text[1024l];
    if(!(s_logident == ((char *)NULL)))
      snprintf(log_text, (unsigned long int)1024, "%c: (%s) %s %s", loglevel, s_logident, (const void *)date, string);

    else
      snprintf(log_text, (unsigned long int)1024, "%c: %s %s", loglevel, (const void *)date, string);
    if(!(s_logstream == ((struct _IO_FILE *)NULL)))
    {
      fprintf(s_logstream, "%s\n", (const void *)log_text);
      fflush(s_logstream);
    }

    if(!(s_logsender == ((struct _zsock_t *)NULL)))
      zstr_send((void *)s_logsender, log_text);

  }

}

// s_next_timer_id
// file src/zloop.c line 97
static signed int s_next_timer_id(struct _zloop_t *self)
{
  self->last_timer_id = self->last_timer_id + 1;
  return self->last_timer_id;
}

// s_node_new
// file src/zlistx.c line 60
static struct _node_t * s_node_new(void *item)
{
  struct _node_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link16(sizeof(struct _node_t) /*32ul*/ , "src/zlistx.c", (unsigned int)62);
  self = (struct _node_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _node_t *)NULL)))
  {
    self->tag = (unsigned int)0x0006cafe;
    self->prev = self;
    self->next = self;
    self->item = item;
  }

  return self;
}

// s_node_relink
// file src/zlistx.c line 80
static void s_node_relink(struct _node_t *node, struct _node_t *prev, struct _node_t *next)
{
  struct _node_t *temp = node->next;
  node->next = prev->next;
  prev->next = temp;
  temp = node->prev;
  node->prev = next->prev;
  next->prev = temp;
}

// s_on_command
// file src/zdir.c line 822
static signed int s_on_command(struct _zloop_t *loop, struct _zsock_t *reader, void *arg)
{
  struct _zdir_watch_t *watch = (struct _zdir_watch_t *)arg;
  struct _zmsg_t *msg;
  msg=zmsg_recv((void *)watch->pipe);
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  char *command;
  command=zmsg_popstr(msg);
  /* assertion command */
  assert(command != ((char *)NULL));
  if(!(watch->verbose == (_Bool)0))
    zsys_info("zdir_watch: Command received: %s", command);

  signed int return_value_strcmp_6;
  return_value_strcmp_6=strcmp(command, "_TERM");
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  if(return_value_strcmp_6 == 0)
    return -1;

  else
  {
    return_value_strcmp_5=strcmp(command, "VERBOSE");
    if(return_value_strcmp_5 == 0)
    {
      watch->verbose = (_Bool)1;
      zsock_signal((void *)watch->pipe, (unsigned char)0);
    }

    else
    {
      return_value_strcmp_4=strcmp(command, "SUBSCRIBE");
      if(return_value_strcmp_4 == 0)
      {
        char *path;
        path=zmsg_popstr(msg);
        if(!(path == ((char *)NULL)))
        {
          s_zdir_watch_subscribe(watch, path);
          free((void *)path);
        }

        else
        {
          if(!(watch->verbose == (_Bool)0))
            zsys_error("zdir_watch: Unable to extract path from SUBSCRIBE message");

          zsock_signal((void *)watch->pipe, (unsigned char)1);
        }
      }

      else
      {
        return_value_strcmp_3=strcmp(command, "UNSUBSCRIBE");
        if(return_value_strcmp_3 == 0)
        {
          char *s_on_command__1__4__path;
          s_on_command__1__4__path=zmsg_popstr(msg);
          if(!(s_on_command__1__4__path == ((char *)NULL)))
          {
            /* assertion path */
            assert(s_on_command__1__4__path != ((char *)NULL));
            s_zdir_watch_unsubscribe(watch, s_on_command__1__4__path);
            free((void *)s_on_command__1__4__path);
          }

          else
          {
            if(!(watch->verbose == (_Bool)0))
              zsys_error("zdir_watch: Unable to extract path from UNSUBSCRIBE message");

            zsock_signal((void *)watch->pipe, (unsigned char)1);
          }
        }

        else
        {
          return_value_strcmp_2=strcmp(command, "TIMEOUT");
          if(return_value_strcmp_2 == 0)
          {
            char *timeout_string;
            timeout_string=zmsg_popstr(msg);
            if(!(timeout_string == ((char *)NULL)))
            {
              signed int timeout;
              timeout=atoi(timeout_string);
              signed int return_value_s_zdir_watch_timeout_1;
              return_value_s_zdir_watch_timeout_1=s_zdir_watch_timeout(watch, timeout);
              zsock_signal((void *)watch->pipe, (unsigned char)return_value_s_zdir_watch_timeout_1);
              free((void *)timeout_string);
            }

            else
            {
              if(!(watch->verbose == (_Bool)0))
                zsys_error("zdir_watch: Unable to extract time from TIMEOUT message");

              zsock_signal((void *)watch->pipe, (unsigned char)1);
            }
          }

          else
          {
            if(!(watch->verbose == (_Bool)0))
              zsys_warning("zdir_watch: Unknown command '%s'", command);

            zsock_signal((void *)watch->pipe, (unsigned char)1);
          }
        }
      }
    }
  }
  free((void *)command);
  return 0;
}

// s_on_read_timer
// file src/zdir.c line 663
static signed int s_on_read_timer(struct _zloop_t *loop, signed int timer_id, void *arg)
{
  struct _zdir_watch_t *watch = (struct _zdir_watch_t *)arg;
  void *data;
  data=zhash_first(watch->subs);
  const char *return_value_zdir_path_2;
  const char *return_value_zdir_path_3;
  const char *return_value_zdir_path_11;
  while(!(data == NULL))
  {
    struct _zdir_watch_sub_t *sub = (struct _zdir_watch_sub_t *)data;
    struct _zdir_t *new_dir;
    const char *return_value_zdir_path_1;
    return_value_zdir_path_1=zdir_path(sub->dir);
    new_dir=zdir_new(return_value_zdir_path_1, (const char *)(void *)0);
    if(new_dir == ((struct _zdir_t *)NULL))
    {
      if(!(watch->verbose == (_Bool)0))
      {
        return_value_zdir_path_2=zdir_path(sub->dir);
        zsys_error("zdir_watch: Unable to create new zdir for path %s", return_value_zdir_path_2);
      }

      goto __CPROVER_DUMP_L13;
    }

    struct _zlist_t *diff;
    diff=zdir_diff(sub->dir, new_dir, "");
    zdir_destroy(&sub->dir);
    sub->dir = new_dir;
    if(diff == ((struct _zlist_t *)NULL))
    {
      if(!(watch->verbose == (_Bool)0))
      {
        return_value_zdir_path_3=zdir_path(sub->dir);
        zsys_error("zdir_watch: Unable to create diff for path %s", return_value_zdir_path_3);
      }

      goto __CPROVER_DUMP_L13;
    }

    unsigned long int return_value_zlist_size_14;
    return_value_zlist_size_14=zlist_size(diff);
    if(return_value_zlist_size_14 >= 1ul)
    {
      if(!(watch->verbose == (_Bool)0))
      {
        struct _zdir_patch_t *patch;
        void *return_value_zlist_first_4;
        return_value_zlist_first_4=zlist_first(diff);
        patch = (struct _zdir_patch_t *)return_value_zlist_first_4;
        unsigned long int return_value_zlist_size_5;
        return_value_zlist_size_5=zlist_size(diff);
        const char *return_value_zdir_path_6;
        return_value_zdir_path_6=zdir_path(sub->dir);
        zsys_info("zdir_watch: Found %d changes in %s:", return_value_zlist_size_5, return_value_zdir_path_6);
        while(!(patch == ((struct _zdir_patch_t *)NULL)))
        {
          struct _zfile_t *return_value_zdir_patch_file_7;
          return_value_zdir_patch_file_7=zdir_patch_file(patch);
          const char *return_value_zfile_filename_8;
          return_value_zfile_filename_8=zfile_filename(return_value_zdir_patch_file_7, (const char *)(void *)0);
          enum anonymous_6 return_value_zdir_patch_op_9;
          return_value_zdir_patch_op_9=zdir_patch_op(patch);
          zsys_info("zdir_watch:   %s %s", return_value_zfile_filename_8, (signed int)return_value_zdir_patch_op_9 == ZDIR_PATCH_CREATE ? "created" : "deleted");
          void *return_value_zlist_next_10;
          return_value_zlist_next_10=zlist_next(diff);
          patch = (struct _zdir_patch_t *)return_value_zlist_next_10;
        }
      }

      const char *return_value_zdir_path_12;
      return_value_zdir_path_12=zdir_path(sub->dir);
      signed int return_value_zsock_send_13;
      return_value_zsock_send_13=zsock_send((void *)watch->pipe, "sp", return_value_zdir_path_12, diff);
      if(!(return_value_zsock_send_13 == 0))
      {
        if(!(watch->verbose == (_Bool)0))
        {
          return_value_zdir_path_11=zdir_path(sub->dir);
          zsys_error("zdir_watch: Unable to send patch list for path %s", return_value_zdir_path_11);
        }

        zlist_destroy(&diff);
      }

    }

    else
      zlist_destroy(&diff);

  __CPROVER_DUMP_L13:
    ;
    data=zhash_next(watch->subs);
  }
  return 0;
}

// s_poller_destroy
// file src/zloop.c line 140
static void s_poller_destroy(struct _s_poller_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _s_poller_t **)NULL));
  struct _s_poller_t *self = *self_p;
  if(!(self == ((struct _s_poller_t *)NULL)))
  {
    free((void *)self);
    *self_p = (struct _s_poller_t *)(void *)0;
  }

}

// s_poller_new
// file src/zloop.c line 127
static struct _s_poller_t * s_poller_new(struct zmq_pollitem_t *item, signed int (*handler)(struct _zloop_t *, struct zmq_pollitem_t *, void *), void *arg)
{
  struct _s_poller_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link17(sizeof(struct _s_poller_t) /*48ul*/ , "src/zloop.c", (unsigned int)129);
  self = (struct _s_poller_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _s_poller_t *)NULL)))
  {
    self->item = *item;
    self->handler = handler;
    self->arg = arg;
    self->tolerant = (_Bool)0;
  }

  return self;
}

// s_posix_populate_entry
// file src/zdir.c line 73
static void s_posix_populate_entry(struct _zdir_t *self, struct dirent *entry)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(entry->d_name, ".");
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(return_value_strcmp_1 == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strcmp_2=strcmp(entry->d_name, "..");
    tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr_3)
  {
    char fullpath[1025l];
    snprintf(fullpath, (unsigned long int)1024, "%s/%s", self->path, (const void *)entry->d_name);
    struct stat stat_buf;
    signed int return_value_stat_4;
    return_value_stat_4=stat(fullpath, &stat_buf);
    if(return_value_stat_4 == 0)
    {
      if(!((signed int)entry->d_name[0l] == 46))
      {
        if((61440u & stat_buf.st_mode) == 16384u)
        {
          if(self->trimmed == (_Bool)0)
          {
            struct _zdir_t *subdir;
            subdir=zdir_new(entry->d_name, self->path);
            /* assertion subdir */
            assert(subdir != ((struct _zdir_t *)NULL));
            zlist_append(self->subdirs, (void *)subdir);
          }

        }

        else
        {
          struct _zfile_t *file;
          file=zfile_new(self->path, entry->d_name);
          /* assertion file */
          assert(file != ((struct _zfile_t *)NULL));
          zlist_append(self->files, (void *)file);
        }
      }

    }

  }

}

// s_protocol_event
// file src/zgossip_engine.inc line 315
static enum anonymous_30 s_protocol_event(struct _zgossip_msg_t *message)
{
  /* assertion message */
  assert(message != ((struct _zgossip_msg_t *)NULL));
  signed int return_value_zgossip_msg_id_1;
  return_value_zgossip_msg_id_1=zgossip_msg_id(message);
  switch(return_value_zgossip_msg_id_1)
  {
    case 1:
      return (enum anonymous_30)hello_event;
    case 2:
      return (enum anonymous_30)publish_event;
    case 3:
      return (enum anonymous_30)ping_event;
    default:
      return (enum anonymous_30)terminate_event;
  }
}

// s_proxy_task
// file src/zproxy_v2.c line 136
static void s_proxy_task(void *args, struct _zctx_t *ctx, void *command_pipe)
{
  zsocket_signal(command_pipe);
  struct _zproxy_t *self = (struct _zproxy_t *)args;
  void *capture = (void *)0;
  struct _zpoller_t *poller;
  poller=zpoller_new(self->frontend, self->backend, command_pipe, (void *)0);
  /* assertion poller */
  assert(poller != ((struct _zpoller_t *)NULL));
  _Bool stopped = (_Bool)0;
  signed int return_value_zmq_recvmsg_15;
  signed int return_value_strcmp_12;
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_10;
  while(stopped == (_Bool)0)
  {
    void *which;
    which=zpoller_wait(poller, -1);
    struct zmq_msg_t msg;
    zmq_msg_init(&msg);
    signed int send_flags;
    _Bool tmp_if_expr_16;
    if(!(which == NULL))
    {
      return_value_zmq_recvmsg_15=zmq_recvmsg(which, &msg, 0);
      tmp_if_expr_16 = return_value_zmq_recvmsg_15 != -1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_16 = (_Bool)0;
    if(tmp_if_expr_16)
    {
      signed int return_value_zsocket_rcvmore_1;
      return_value_zsocket_rcvmore_1=zsocket_rcvmore(which);
      send_flags = return_value_zsocket_rcvmore_1 != 0 ? 2 : 0;
      _Bool tmp_if_expr_14;
      if(which == self->frontend)
        tmp_if_expr_14 = (_Bool)1;

      else
        tmp_if_expr_14 = which == self->backend ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_14)
      {
        void *output;
        void *tmp_if_expr_2;
        if(which == self->frontend)
          tmp_if_expr_2 = self->backend;

        else
          tmp_if_expr_2 = self->frontend;
        output = tmp_if_expr_2;
        while((_Bool)1)
        {
          if(!(capture == NULL))
          {
            struct zmq_msg_t s_proxy_task__1__1__1__1__1__1__dup;
            zmq_msg_init(&s_proxy_task__1__1__1__1__1__1__dup);
            zmq_msg_copy(&s_proxy_task__1__1__1__1__1__1__dup, &msg);
            signed int return_value_zmq_sendmsg_3;
            return_value_zmq_sendmsg_3=zmq_sendmsg(capture, &s_proxy_task__1__1__1__1__1__1__dup, send_flags);
            if(return_value_zmq_sendmsg_3 == -1)
              zmq_msg_close(&s_proxy_task__1__1__1__1__1__1__dup);

          }

          signed int return_value_zmq_sendmsg_4;
          return_value_zmq_sendmsg_4=zmq_sendmsg(output, &msg, send_flags);
          if(return_value_zmq_sendmsg_4 == -1)
          {
            zmq_msg_close(&msg);
            break;
          }

          signed int return_value_zmq_recvmsg_5;
          return_value_zmq_recvmsg_5=zmq_recvmsg(which, &msg, 1);
          if(return_value_zmq_recvmsg_5 == -1)
            break;

          signed int return_value_zsocket_rcvmore_6;
          return_value_zsocket_rcvmore_6=zsocket_rcvmore(which);
          send_flags = return_value_zsocket_rcvmore_6 != 0 ? 2 : 0;
        }
      }

      else
        if(which == command_pipe)
        {
          char command[10l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
          unsigned long int return_value_zmq_msg_size_7;
          return_value_zmq_msg_size_7=zmq_msg_size(&msg);
          /* assertion zmq_msg_size (&msg) < 10 */
          assert(return_value_zmq_msg_size_7 < (unsigned long int)10);
          void *return_value_zmq_msg_data_8;
          return_value_zmq_msg_data_8=zmq_msg_data(&msg);
          unsigned long int return_value_zmq_msg_size_9;
          return_value_zmq_msg_size_9=zmq_msg_size(&msg);
          memcpy((void *)command, return_value_zmq_msg_data_8, return_value_zmq_msg_size_9);
          signed int return_value_strcmp_13;
          return_value_strcmp_13=strcmp(command, "PAUSE");
          if(return_value_strcmp_13 == 0)
          {
            zpoller_destroy(&poller);
            poller=zpoller_new(command_pipe, (void *)0);
            /* assertion poller */
            assert(poller != ((struct _zpoller_t *)NULL));
          }

          else
          {
            return_value_strcmp_12=strcmp(command, "RESUME");
            if(return_value_strcmp_12 == 0)
            {
              zpoller_destroy(&poller);
              poller=zpoller_new(self->frontend, self->backend, command_pipe, (void *)0);
              /* assertion poller */
              assert(poller != ((struct _zpoller_t *)NULL));
            }

            else
            {
              return_value_strcmp_11=strcmp(command, "CAPTURE");
              if(return_value_strcmp_11 == 0)
              {
                capture=zsocket_new(self->ctx, 8);
                char *endpoint;
                endpoint=zstr_recv(command_pipe);
                /* assertion endpoint */
                assert(endpoint != ((char *)NULL));
                if(!(capture == NULL))
                {
                  signed int rc;
                  rc=zsocket_connect(capture, "%s", endpoint);
                  /* assertion rc == 0 */
                  assert(rc == 0);
                }

                zstr_free(&endpoint);
              }

              else
              {
                return_value_strcmp_10=strcmp(command, "STOP");
                if(return_value_strcmp_10 == 0)
                  stopped = (_Bool)1;

                else
                  /* assertion 0 */
                  assert(0 != 0);
              }
            }
          }
          zsocket_signal(command_pipe);
        }

        else
          /* assertion 0 */
          assert(0 != 0);
    }

    else
      break;
  }
  zpoller_destroy(&poller);
}

// s_purge
// file src/zhashx.c line 128
static void s_purge(struct _zhashx_t *self)
{
  unsigned int index;
  unsigned long int limit = primes[(signed long int)self->prime_index];
  index = (unsigned int)0;
  for( ; !((unsigned long int)index >= limit); index = index + 1u)
  {
    struct _item_t *cur_item = self->items[(signed long int)index];
    while(!(cur_item == ((struct _item_t *)NULL)))
    {
      struct _item_t *next_item = cur_item->next;
      s_item_destroy(self, cur_item, (_Bool)1);
      cur_item = next_item;
    }
    self->items[(signed long int)index] = (struct _item_t *)(void *)0;
  }
}

// s_reader_destroy
// file src/zloop.c line 116
static void s_reader_destroy(struct _s_reader_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _s_reader_t **)NULL));
  struct _s_reader_t *self = *self_p;
  if(!(self == ((struct _s_reader_t *)NULL)))
  {
    free((void *)self);
    *self_p = (struct _s_reader_t *)(void *)0;
  }

}

// s_reader_new
// file src/zloop.c line 103
static struct _s_reader_t * s_reader_new(struct _zsock_t *sock, signed int (*handler)(struct _zloop_t *, struct _zsock_t *, void *), void *arg)
{
  struct _s_reader_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link17(sizeof(struct _s_reader_t) /*40ul*/ , "src/zloop.c", (unsigned int)105);
  self = (struct _s_reader_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _s_reader_t *)NULL)))
  {
    self->sock = sock;
    self->handler = handler;
    self->arg = arg;
    self->tolerant = (_Bool)0;
  }

  return self;
}

// s_rebuild_poll_set
// file src/zpoller.c line 166
static signed int s_rebuild_poll_set(struct _zpoller_t *self)
{
  free((void *)self->poll_set);
  self->poll_set = (struct zmq_pollitem_t *)(void *)0;
  free((void *)self->poll_readers);
  self->poll_readers = (void **)(void *)0;
  self->poll_size=zlist_size(self->reader_list);
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link20(self->poll_size * sizeof(struct zmq_pollitem_t) /*16ul*/ , "src/zpoller.c", (unsigned int)175);
  self->poll_set = (struct zmq_pollitem_t *)return_value_safe_malloc_1;
  void *return_value_safe_malloc_2;
  return_value_safe_malloc_2=safe_malloc_link20(self->poll_size * sizeof(void *) /*8ul*/ , "src/zpoller.c", (unsigned int)176);
  self->poll_readers = (void **)return_value_safe_malloc_2;
  _Bool tmp_if_expr_3;
  if(self->poll_set == ((struct zmq_pollitem_t *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = !(self->poll_readers != ((void **)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
    return -1;

  else
  {
    unsigned int reader_nbr = (unsigned int)0;
    void *reader;
    reader=zlist_first(self->reader_list);
    while(!(reader == NULL))
    {
      self->poll_readers[(signed long int)reader_nbr] = reader;
      void *s_rebuild_poll_set__1__1__socket;
      s_rebuild_poll_set__1__1__socket=zsock_resolve(reader);
      if(s_rebuild_poll_set__1__1__socket == NULL)
      {
        (self->poll_set + (signed long int)reader_nbr)->socket = (void *)0;
        (self->poll_set + (signed long int)reader_nbr)->fd = *((signed int *)reader);
      }

      else
        (self->poll_set + (signed long int)reader_nbr)->socket = s_rebuild_poll_set__1__1__socket;
      (self->poll_set + (signed long int)reader_nbr)->events = (signed short int)1;
      reader_nbr = reader_nbr + 1u;
      reader=zlist_next(self->reader_list);
    }
    self->need_rebuild = (_Bool)0;
    return 0;
  }
}

// s_rebuild_pollset
// file src/zloop.c line 248
static signed int s_rebuild_pollset(struct _zloop_t *self)
{
  free((void *)self->pollset);
  free((void *)self->readact);
  free((void *)self->pollact);
  self->pollset = (struct zmq_pollitem_t *)(void *)0;
  self->readact = (struct _s_reader_t *)(void *)0;
  self->pollact = (struct _s_poller_t *)(void *)0;
  unsigned long int return_value_zlistx_size_1;
  return_value_zlistx_size_1=zlistx_size(self->readers);
  unsigned long int return_value_zlistx_size_2;
  return_value_zlistx_size_2=zlistx_size(self->pollers);
  self->poll_size = return_value_zlistx_size_1 + return_value_zlistx_size_2;
  void *return_value_safe_malloc_3;
  return_value_safe_malloc_3=safe_malloc_link17(self->poll_size * sizeof(struct zmq_pollitem_t) /*16ul*/ , "src/zloop.c", (unsigned int)258);
  self->pollset = (struct zmq_pollitem_t *)return_value_safe_malloc_3;
  if(self->pollset == ((struct zmq_pollitem_t *)NULL))
    return -1;

  else
  {
    void *return_value_safe_malloc_4;
    return_value_safe_malloc_4=safe_malloc_link17(self->poll_size * sizeof(struct _s_reader_t) /*40ul*/ , "src/zloop.c", (unsigned int)262);
    self->readact = (struct _s_reader_t *)return_value_safe_malloc_4;
    if(self->readact == ((struct _s_reader_t *)NULL))
      return -1;

    else
    {
      void *return_value_safe_malloc_5;
      return_value_safe_malloc_5=safe_malloc_link17(self->poll_size * sizeof(struct _s_poller_t) /*48ul*/ , "src/zloop.c", (unsigned int)266);
      self->pollact = (struct _s_poller_t *)return_value_safe_malloc_5;
      if(self->pollact == ((struct _s_poller_t *)NULL))
        return -1;

      else
      {
        struct _s_reader_t *reader;
        void *return_value_zlistx_first_6;
        return_value_zlistx_first_6=zlistx_first(self->readers);
        reader = (struct _s_reader_t *)return_value_zlistx_first_6;
        unsigned int item_nbr = (unsigned int)0;
        while(!(reader == ((struct _s_reader_t *)NULL)))
        {
          struct zmq_pollitem_t poll_item;
          void *return_value_zsock_resolve_7;
          return_value_zsock_resolve_7=zsock_resolve((void *)reader->sock);
          poll_item = (struct zmq_pollitem_t){ .socket=return_value_zsock_resolve_7, .fd=0, .events=(signed short int)1,
    .revents=0 };
          self->pollset[(signed long int)item_nbr] = poll_item;
          self->readact[(signed long int)item_nbr] = *reader;
          item_nbr = item_nbr + 1u;
          void *return_value_zlistx_next_8;
          return_value_zlistx_next_8=zlistx_next(self->readers);
          reader = (struct _s_reader_t *)return_value_zlistx_next_8;
        }
        struct _s_poller_t *poller;
        void *return_value_zlistx_first_9;
        return_value_zlistx_first_9=zlistx_first(self->pollers);
        poller = (struct _s_poller_t *)return_value_zlistx_first_9;
        while(!(poller == ((struct _s_poller_t *)NULL)))
        {
          self->pollset[(signed long int)item_nbr] = poller->item;
          self->pollact[(signed long int)item_nbr] = *poller;
          item_nbr = item_nbr + 1u;
          void *return_value_zlistx_next_10;
          return_value_zlistx_next_10=zlistx_next(self->pollers);
          poller = (struct _s_poller_t *)return_value_zlistx_next_10;
        }
        self->need_rebuild = (_Bool)0;
        return 0;
      }
    }
  }
}

// s_satisfy_pedantic_compilers
// file src/zgossip_engine.inc line 295
static void s_satisfy_pedantic_compilers(void)
{
  engine_set_next_event((struct _client_t *)(void *)0, (enum anonymous_30)NULL_event);
  engine_set_exception((struct _client_t *)(void *)0, (enum anonymous_30)NULL_event);
  engine_set_wakeup_event((struct _client_t *)(void *)0, (unsigned long int)0, (enum anonymous_30)NULL_event);
  engine_send_event((struct _client_t *)(void *)0, (enum anonymous_30)NULL_event);
  engine_broadcast_event((struct _server_t *)(void *)0, (struct _client_t *)(void *)0, (enum anonymous_30)NULL_event);
  engine_handle_socket((struct _server_t *)(void *)0, NULL, (signed int (*)(struct _zloop_t *, struct _zsock_t *, void *))(void *)0);
  engine_set_monitor((struct _server_t *)(void *)0, (unsigned long int)0, (signed int (*)(struct _zloop_t *, signed int, void *))(void *)0);
  engine_set_log_prefix((struct _client_t *)(void *)0, (const char *)(void *)0);
  engine_configure((struct _server_t *)(void *)0, (const char *)(void *)0, (const char *)(void *)0);
  engine_verbose((struct _server_t *)(void *)0);
}

// s_save_metadata_all
// file src/zcert.c line 255
static void s_save_metadata_all(struct _zcert_t *self)
{
  zconfig_destroy(&self->config);
  self->config=zconfig_new("root", (struct _zconfig_t *)(void *)0);
  /* assertion self->config */
  assert(self->config != ((struct _zconfig_t *)NULL));
  struct _zconfig_t *section;
  section=zconfig_new("metadata", self->config);
  char *value;
  void *return_value_zhash_first_1;
  return_value_zhash_first_1=zhash_first(self->metadata);
  value = (char *)return_value_zhash_first_1;
  while(!(value == ((char *)NULL)))
  {
    struct _zconfig_t *item;
    const char *return_value_zhash_cursor_2;
    return_value_zhash_cursor_2=zhash_cursor(self->metadata);
    item=zconfig_new(return_value_zhash_cursor_2, section);
    /* assertion item */
    assert(item != ((struct _zconfig_t *)NULL));
    zconfig_set_value(item, "%s", value);
    void *return_value_zhash_next_3;
    return_value_zhash_next_3=zhash_next(self->metadata);
    value = (char *)return_value_zhash_next_3;
  }
  char *timestr;
  timestr=zclock_timestr();
  zconfig_set_comment(self->config, "   ****  Generated on %s by CZMQ  ****", timestr);
  zstr_free(&timestr);
}

// s_self_authenticate
// file src/zauth.c line 356
static signed int s_self_authenticate(struct anonymous_26 *self)
{
  struct anonymous_34 *request;
  request=s_zap_request_new(self->handler, self->verbose);
  unsigned long int return_value_zhashx_size_3;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  if(!(request == ((struct anonymous_34 *)NULL)))
  {
    _Bool allowed = (_Bool)0;
    _Bool denied = (_Bool)0;
    unsigned long int return_value_zhashx_size_4;
    return_value_zhashx_size_4=zhashx_size(self->whitelist);
    if(!(return_value_zhashx_size_4 == 0ul))
    {
      void *return_value_zhashx_lookup_1;
      return_value_zhashx_lookup_1=zhashx_lookup(self->whitelist, (const void *)request->address);
      if(!(return_value_zhashx_lookup_1 == NULL))
      {
        allowed = (_Bool)1;
        if(!(self->verbose == (_Bool)0))
          zsys_info("zauth: - passed (whitelist) address=%s", request->address);

      }

      else
      {
        denied = (_Bool)1;
        if(!(self->verbose == (_Bool)0))
          zsys_info("zauth: - denied (not in whitelist) address=%s", request->address);

      }
    }

    else
    {
      return_value_zhashx_size_3=zhashx_size(self->blacklist);
      if(!(return_value_zhashx_size_3 == 0ul))
      {
        void *return_value_zhashx_lookup_2;
        return_value_zhashx_lookup_2=zhashx_lookup(self->blacklist, (const void *)request->address);
        if(!(return_value_zhashx_lookup_2 == NULL))
        {
          denied = (_Bool)1;
          if(!(self->verbose == (_Bool)0))
            zsys_info("zauth: - denied (blacklist) address=%s", request->address);

        }

        else
        {
          allowed = (_Bool)1;
          if(!(self->verbose == (_Bool)0))
            zsys_info("zauth: - passed (not in blacklist) address=%s", request->address);

        }
      }

    }
    if(denied == (_Bool)0)
    {
      signed int return_value_strcmp_8;
      return_value_strcmp_8=strcmp(request->mechanism, "NULL");
      if(allowed == (_Bool)0 && return_value_strcmp_8 == 0)
      {
        if(!(self->verbose == (_Bool)0))
          zsys_info("zauth: - allowed (NULL)");

        allowed = (_Bool)1;
      }

      else
      {
        return_value_strcmp_7=strcmp(request->mechanism, "PLAIN");
        if(return_value_strcmp_7 == 0)
          allowed=s_authenticate_plain(self, request);

        else
        {
          return_value_strcmp_6=strcmp(request->mechanism, "CURVE");
          if(return_value_strcmp_6 == 0)
            allowed=s_authenticate_curve(self, request);

          else
          {
            return_value_strcmp_5=strcmp(request->mechanism, "GSSAPI");
            if(return_value_strcmp_5 == 0)
              allowed=s_authenticate_gssapi(self, request);

          }
        }
      }
    }

    if(!(allowed == (_Bool)0))
      s_zap_request_reply(request, "200", "OK");

    else
      s_zap_request_reply(request, "400", "No access");
    s_zap_request_destroy(&request);
  }

  else
    s_zap_request_reply(request, "500", "Internal error");
  return 0;
}

// s_self_configure
// file src/zbeacon.c line 157
static void s_self_configure(struct anonymous_36 *self, signed int port_nbr)
{
  /* assertion port_nbr */
  assert(port_nbr != 0);
  self->port_nbr = port_nbr;
  s_self_prepare_udp(self);
  zstr_send((void *)self->pipe, self->hostname);
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(self->hostname, "");
  const char *return_value_zsys_interface_1;
  if(return_value_strcmp_2 == 0)
  {
    return_value_zsys_interface_1=zsys_interface();
    zsys_error("No broadcast interface found, (ZSYS_INTERFACE=%s)", return_value_zsys_interface_1);
  }

}

// s_self_configure_link1
// file src/zproxy.c line 97
static void s_self_configure_link1(struct anonymous_35 *self_link1, struct _zsock_t **sock_p, struct _zmsg_t *request, char *name)
{
  char *type_name;
  type_name=zmsg_popstr(request);
  /* assertion type_name */
  assert(type_name != ((char *)NULL));
  char *endpoints;
  endpoints=zmsg_popstr(request);
  /* assertion endpoints */
  assert(endpoints != ((char *)NULL));
  if(!(self_link1->verbose == (_Bool)0))
    zsys_info("zproxy: - %s type=%s attach=%s", name, type_name, endpoints);

  /* assertion *sock_p == ((void *)0) */
  assert(*sock_p == (struct _zsock_t *)(void *)0);
  *sock_p=s_create_socket(type_name, endpoints);
  /* assertion *sock_p */
  assert(*sock_p != ((struct _zsock_t *)NULL));
  zpoller_add(self_link1->poller, (void *)*sock_p);
  zstr_free(&type_name);
  zstr_free(&endpoints);
}

// s_self_destroy
// file src/zauth.c line 45
static void s_self_destroy(struct anonymous_26 **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct anonymous_26 **)NULL));
  if(!(*self_p == ((struct anonymous_26 *)NULL)))
  {
    struct anonymous_26 *self = *self_p;
    zhashx_destroy(&self->passwords);
    zhashx_destroy(&self->whitelist);
    zhashx_destroy(&self->blacklist);
    zcertstore_destroy(&self->certstore);
    zpoller_destroy(&self->poller);
    if(!(self->handler == ((struct _zsock_t *)NULL)))
    {
      zsock_unbind(self->handler, "inproc://zeromq.zap.01");
      zsock_destroy_checked(&self->handler, "src/zauth.c", (unsigned long int)57);
    }

    free((void *)self);
    *self_p = (struct anonymous_26 *)(void *)0;
  }

}

// s_self_destroy_link1
// file src/zbeacon.c line 52
static void s_self_destroy_link1(struct anonymous_36 **self_p_link1)
{
  /* assertion self_p */
  assert(self_p_link1 != ((struct anonymous_36 **)NULL));
  if(!(*self_p_link1 == ((struct anonymous_36 *)NULL)))
  {
    struct anonymous_36 *self_link1 = *self_p_link1;
    zframe_destroy(&self_link1->transmit);
    zframe_destroy(&self_link1->filter);
    zsys_udp_close(self_link1->udpsock);
    free((void *)self_link1);
    *self_p_link1 = (struct anonymous_36 *)(void *)0;
  }

}

// s_self_destroy_link2
// file src/zmonitor.c line 43
static void s_self_destroy_link2(struct anonymous_25 **self_p_link2)
{
  /* assertion self_p */
  assert(self_p_link2 != ((struct anonymous_25 **)NULL));
  if(!(*self_p_link2 == ((struct anonymous_25 *)NULL)))
  {
    struct anonymous_25 *self_link2 = *self_p_link2;
    zmq_socket_monitor(self_link2->monitored, (const char *)(void *)0, 0);
    zpoller_destroy(&self_link2->poller);
    zsock_destroy_checked(&self_link2->sink, "src/zmonitor.c", (unsigned long int)52);
    free((void *)self_link2);
    *self_p_link2 = (struct anonymous_25 *)(void *)0;
  }

}

// s_self_destroy_link3
// file src/zproxy.c line 41
static void s_self_destroy_link3(struct anonymous_35 **self_p_link3)
{
  /* assertion self_p */
  assert(self_p_link3 != ((struct anonymous_35 **)NULL));
  if(!(*self_p_link3 == ((struct anonymous_35 *)NULL)))
  {
    struct anonymous_35 *self_link3 = *self_p_link3;
    zsock_destroy_checked(&self_link3->frontend, "src/zproxy.c", (unsigned long int)46);
    zsock_destroy_checked(&self_link3->backend, "src/zproxy.c", (unsigned long int)47);
    zsock_destroy_checked(&self_link3->capture, "src/zproxy.c", (unsigned long int)48);
    zpoller_destroy(&self_link3->poller);
    free((void *)self_link3);
    *self_p_link3 = (struct anonymous_35 *)(void *)0;
  }

}

// s_self_handle_pipe
// file src/zauth.c line 93
static signed int s_self_handle_pipe(struct anonymous_26 *self)
{
  struct _zmsg_t *request;
  request=zmsg_recv((void *)self->pipe);
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  if(request == ((struct _zmsg_t *)NULL))
    return -1;

  else
  {
    char *command;
    command=zmsg_popstr(request);
    if(!(self->verbose == (_Bool)0))
      zsys_info("zauth: API command=%s", command);

    signed int return_value_strcmp_9;
    return_value_strcmp_9=strcmp(command, "ALLOW");
    if(return_value_strcmp_9 == 0)
    {
      char *address;
      address=zmsg_popstr(request);
      while(!(address == ((char *)NULL)))
      {
        if(!(self->verbose == (_Bool)0))
          zsys_info("zauth: - whitelisting ipaddress=%s", address);

        zhashx_insert(self->whitelist, (const void *)address, (void *)"OK");
        zstr_free(&address);
        address=zmsg_popstr(request);
      }
      zsock_signal((void *)self->pipe, (unsigned char)0);
    }

    else
    {
      return_value_strcmp_8=strcmp(command, "DENY");
      if(return_value_strcmp_8 == 0)
      {
        char *s_self_handle_pipe__1__2__address;
        s_self_handle_pipe__1__2__address=zmsg_popstr(request);
        while(!(s_self_handle_pipe__1__2__address == ((char *)NULL)))
        {
          if(!(self->verbose == (_Bool)0))
            zsys_info("zauth: - blacklisting ipaddress=%s", s_self_handle_pipe__1__2__address);

          zhashx_insert(self->blacklist, (const void *)s_self_handle_pipe__1__2__address, (void *)"OK");
          zstr_free(&s_self_handle_pipe__1__2__address);
          s_self_handle_pipe__1__2__address=zmsg_popstr(request);
        }
        zsock_signal((void *)self->pipe, (unsigned char)0);
      }

      else
      {
        return_value_strcmp_7=strcmp(command, "PLAIN");
        if(return_value_strcmp_7 == 0)
        {
          char *filename;
          filename=zmsg_popstr(request);
          zhashx_destroy(&self->passwords);
          self->passwords=zhashx_new();
          signed int return_value_zhashx_load_1;
          return_value_zhashx_load_1=zhashx_load(self->passwords, filename);
          if(!(return_value_zhashx_load_1 == 0))
          {
            if(!(self->verbose == (_Bool)0))
              zsys_info("zauth: could not load file=%s", filename);

          }

          zstr_free(&filename);
          zsock_signal((void *)self->pipe, (unsigned char)0);
        }

        else
        {
          return_value_strcmp_6=strcmp(command, "CURVE");
          if(return_value_strcmp_6 == 0)
          {
            char *location;
            location=zmsg_popstr(request);
            signed int return_value_strcmp_2;
            return_value_strcmp_2=strcmp(location, "*");
            if(return_value_strcmp_2 == 0)
              self->allow_any = (_Bool)1;

            else
            {
              zcertstore_destroy(&self->certstore);
              self->certstore=zcertstore_new(location);
              self->allow_any = (_Bool)0;
            }
            zstr_free(&location);
            zsock_signal((void *)self->pipe, (unsigned char)0);
          }

          else
          {
            return_value_strcmp_5=strcmp(command, "GSSAPI");
            if(return_value_strcmp_5 == 0)
              zsock_signal((void *)self->pipe, (unsigned char)0);

            else
            {
              return_value_strcmp_4=strcmp(command, "VERBOSE");
              if(return_value_strcmp_4 == 0)
              {
                self->verbose = (_Bool)1;
                zsock_signal((void *)self->pipe, (unsigned char)0);
              }

              else
              {
                return_value_strcmp_3=strcmp(command, "_TERM");
                if(return_value_strcmp_3 == 0)
                  self->terminated = (_Bool)1;

                else
                {
                  zsys_error("zauth: - invalid command: %s", command);
                  /* assertion 0 */
                  assert(0 != 0);
                }
              }
            }
          }
        }
      }
    }
    zstr_free(&command);
    zmsg_destroy(&request);
    return 0;
  }
}

// s_self_handle_pipe_link1
// file src/zbeacon.c line 172
static signed int s_self_handle_pipe_link1(struct anonymous_36 *self_link1)
{
  char *command_link1;
  command_link1=zstr_recv((void *)self_link1->pipe);
  signed int return_value_strcmp_8_link1;
  signed int return_value_strcmp_7_link1;
  signed int return_value_strcmp_6_link1;
  signed int return_value_strcmp_5_link1;
  signed int return_value_strcmp_4_link1;
  signed int return_value_strcmp_3_link1;
  if(command_link1 == ((char *)NULL))
    return -1;

  else
  {
    if(!(self_link1->verbose == (_Bool)0))
      zsys_info("zbeacon: API command=%s", command_link1);

    signed int return_value_strcmp_9_link1;
    return_value_strcmp_9_link1=strcmp(command_link1, "VERBOSE");
    if(return_value_strcmp_9_link1 == 0)
      self_link1->verbose = (_Bool)1;

    else
    {
      return_value_strcmp_8_link1=strcmp(command_link1, "CONFIGURE");
      if(return_value_strcmp_8_link1 == 0)
      {
        signed int port;
        signed int rc;
        rc=zsock_recv((void *)self_link1->pipe, "i", &port);
        /* assertion rc == 0 */
        assert(rc == 0);
        s_self_configure(self_link1, port);
      }

      else
      {
        return_value_strcmp_7_link1=strcmp(command_link1, "PUBLISH");
        if(return_value_strcmp_7_link1 == 0)
        {
          zframe_destroy(&self_link1->transmit);
          zsock_recv((void *)self_link1->pipe, "fi", &self_link1->transmit, &self_link1->interval);
          unsigned long int return_value_zframe_size_1;
          return_value_zframe_size_1=zframe_size(self_link1->transmit);
          /* assertion zframe_size (self->transmit) <= 255 */
          assert(return_value_zframe_size_1 <= (unsigned long int)255);
          if(self_link1->interval == 0)
            self_link1->interval = 1000;

          self_link1->ping_at=zclock_mono();
        }

        else
        {
          return_value_strcmp_6_link1=strcmp(command_link1, "SILENCE");
          if(return_value_strcmp_6_link1 == 0)
            zframe_destroy(&self_link1->transmit);

          else
          {
            return_value_strcmp_5_link1=strcmp(command_link1, "SUBSCRIBE");
            if(return_value_strcmp_5_link1 == 0)
            {
              zframe_destroy(&self_link1->filter);
              self_link1->filter=zframe_recv((void *)self_link1->pipe);
              unsigned long int return_value_zframe_size_2;
              return_value_zframe_size_2=zframe_size(self_link1->filter);
              /* assertion zframe_size (self->filter) <= 255 */
              assert(return_value_zframe_size_2 <= (unsigned long int)255);
            }

            else
            {
              return_value_strcmp_4_link1=strcmp(command_link1, "UNSUBSCRIBE");
              if(return_value_strcmp_4_link1 == 0)
                zframe_destroy(&self_link1->filter);

              else
              {
                return_value_strcmp_3_link1=strcmp(command_link1, "_TERM");
                if(return_value_strcmp_3_link1 == 0)
                  self_link1->terminated = (_Bool)1;

                else
                {
                  zsys_error("zbeacon: - invalid command: %s", command_link1);
                  /* assertion 0 */
                  assert(0 != 0);
                }
              }
            }
          }
        }
      }
    }
    zstr_free(&command_link1);
    return 0;
  }
}

// s_self_handle_pipe_link2
// file src/zmonitor.c line 151
static signed int s_self_handle_pipe_link2(struct anonymous_25 *self_link2)
{
  struct _zmsg_t *request_link1;
  request_link1=zmsg_recv((void *)self_link2->pipe);
  signed int return_value_strcmp_3_link2;
  signed int return_value_strcmp_2_link1;
  signed int return_value_strcmp_1;
  if(request_link1 == ((struct _zmsg_t *)NULL))
    return -1;

  else
  {
    char *command_link2;
    command_link2=zmsg_popstr(request_link1);
    if(command_link2 == ((char *)NULL))
    {
      s_self_destroy_link2(&self_link2);
      return -1;
    }

    else
    {
      if(!(self_link2->verbose == (_Bool)0))
        zsys_info("zmonitor: API command=%s", command_link2);

      signed int return_value_strcmp_4_link2;
      return_value_strcmp_4_link2=strcmp(command_link2, "LISTEN");
      if(return_value_strcmp_4_link2 == 0)
      {
        char *event;
        event=zmsg_popstr(request_link1);
        while(!(event == ((char *)NULL)))
        {
          if(!(self_link2->verbose == (_Bool)0))
            zsys_info("zmonitor: - listening to event=%s", event);

          s_self_listen(self_link2, event);
          zstr_free(&event);
          event=zmsg_popstr(request_link1);
        }
      }

      else
      {
        return_value_strcmp_3_link2=strcmp(command_link2, "START");
        if(return_value_strcmp_3_link2 == 0)
        {
          s_self_start(self_link2);
          zsock_signal((void *)self_link2->pipe, (unsigned char)0);
        }

        else
        {
          return_value_strcmp_2_link1=strcmp(command_link2, "VERBOSE");
          if(return_value_strcmp_2_link1 == 0)
            self_link2->verbose = (_Bool)1;

          else
          {
            return_value_strcmp_1=strcmp(command_link2, "_TERM");
            if(return_value_strcmp_1 == 0)
              self_link2->terminated = (_Bool)1;

            else
            {
              zsys_error("zmonitor: - invalid command: %s", command_link2);
              /* assertion 0 */
              assert(0 != 0);
            }
          }
        }
      }
      zstr_free(&command_link2);
      zmsg_destroy(&request_link1);
      return 0;
    }
  }
}

// s_self_handle_pipe_link3
// file src/zproxy.c line 118
static signed int s_self_handle_pipe_link3(struct anonymous_35 *self_link3)
{
  struct _zmsg_t *request_link2;
  request_link2=zmsg_recv((void *)self_link3->pipe);
  signed int return_value_strcmp_6_link2;
  signed int return_value_strcmp_5_link2;
  signed int return_value_strcmp_4_link3;
  signed int return_value_strcmp_3_link3;
  signed int return_value_strcmp_2_link2;
  signed int return_value_strcmp_1_link1;
  if(request_link2 == ((struct _zmsg_t *)NULL))
    return -1;

  else
  {
    char *command_link3;
    command_link3=zmsg_popstr(request_link2);
    /* assertion command */
    assert(command_link3 != ((char *)NULL));
    if(!(self_link3->verbose == (_Bool)0))
      zsys_info("zproxy: API command=%s", command_link3);

    signed int return_value_strcmp_7_link2;
    return_value_strcmp_7_link2=strcmp(command_link3, "FRONTEND");
    if(return_value_strcmp_7_link2 == 0)
    {
      s_self_configure_link1(self_link3, &self_link3->frontend, request_link2, "frontend");
      zsock_signal((void *)self_link3->pipe, (unsigned char)0);
    }

    else
    {
      return_value_strcmp_6_link2=strcmp(command_link3, "BACKEND");
      if(return_value_strcmp_6_link2 == 0)
      {
        s_self_configure_link1(self_link3, &self_link3->backend, request_link2, "backend");
        zsock_signal((void *)self_link3->pipe, (unsigned char)0);
      }

      else
      {
        return_value_strcmp_5_link2=strcmp(command_link3, "CAPTURE");
        if(return_value_strcmp_5_link2 == 0)
        {
          self_link3->capture=zsock_new_checked(8, "src/zproxy.c", (unsigned long int)141);
          /* assertion self->capture */
          assert(self_link3->capture != ((struct _zsock_t *)NULL));
          char *endpoint;
          endpoint=zmsg_popstr(request_link2);
          /* assertion endpoint */
          assert(endpoint != ((char *)NULL));
          signed int rc;
          rc=zsock_connect(self_link3->capture, "%s", endpoint);
          /* assertion rc == 0 */
          assert(rc == 0);
          zstr_free(&endpoint);
          zsock_signal((void *)self_link3->pipe, (unsigned char)0);
        }

        else
        {
          return_value_strcmp_4_link3=strcmp(command_link3, "PAUSE");
          if(return_value_strcmp_4_link3 == 0)
          {
            zpoller_destroy(&self_link3->poller);
            self_link3->poller=zpoller_new((void *)self_link3->pipe, (void *)0);
            /* assertion self->poller */
            assert(self_link3->poller != ((struct _zpoller_t *)NULL));
            zsock_signal((void *)self_link3->pipe, (unsigned char)0);
          }

          else
          {
            return_value_strcmp_3_link3=strcmp(command_link3, "RESUME");
            if(return_value_strcmp_3_link3 == 0)
            {
              zpoller_destroy(&self_link3->poller);
              self_link3->poller=zpoller_new((void *)self_link3->pipe, self_link3->frontend, self_link3->backend, (void *)0);
              /* assertion self->poller */
              assert(self_link3->poller != ((struct _zpoller_t *)NULL));
              zsock_signal((void *)self_link3->pipe, (unsigned char)0);
            }

            else
            {
              return_value_strcmp_2_link2=strcmp(command_link3, "VERBOSE");
              if(return_value_strcmp_2_link2 == 0)
              {
                self_link3->verbose = (_Bool)1;
                zsock_signal((void *)self_link3->pipe, (unsigned char)0);
              }

              else
              {
                return_value_strcmp_1_link1=strcmp(command_link3, "_TERM");
                if(return_value_strcmp_1_link1 == 0)
                  self_link3->terminated = (_Bool)1;

                else
                {
                  zsys_error("zproxy: - invalid command: %s", command_link3);
                  /* assertion 0 */
                  assert(0 != 0);
                }
              }
            }
          }
        }
      }
    }
    zstr_free(&command_link3);
    zmsg_destroy(&request_link2);
    return 0;
  }
}

// s_self_handle_sink
// file src/zmonitor.c line 200
static void s_self_handle_sink(struct anonymous_25 *self)
{
  struct _zframe_t *frame;
  frame=zframe_recv((void *)self->sink);
  signed int event;
  unsigned char *return_value_zframe_data_1;
  return_value_zframe_data_1=zframe_data(frame);
  event = (signed int)*((unsigned short int *)return_value_zframe_data_1);
  signed int value;
  unsigned char *return_value_zframe_data_2;
  return_value_zframe_data_2=zframe_data(frame);
  value = (signed int)*((unsigned int *)(return_value_zframe_data_2 + (signed long int)2));
  char *address;
  address=zstr_recv((void *)self->sink);
  zframe_destroy(&frame);
  char *name;
  switch(event)
  {
    case 0x0020:
    {
      name = "ACCEPTED";
      break;
    }
    case 0x0040:
    {
      name = "ACCEPT_FAILED";
      break;
    }
    case 0x0010:
    {
      name = "BIND_FAILED";
      break;
    }
    case 0x0080:
    {
      name = "CLOSED";
      break;
    }
    case 0x0100:
    {
      name = "CLOSE_FAILED";
      break;
    }
    case 0x0200:
    {
      name = "DISCONNECTED";
      break;
    }
    case 0x0001:
    {
      name = "CONNECTED";
      break;
    }
    case 0x0002:
    {
      name = "CONNECT_DELAYED";
      break;
    }
    case 0x0004:
    {
      name = "CONNECT_RETRIED";
      break;
    }
    case 0x0008:
    {
      name = "LISTENING";
      break;
    }
    case 0x0400:
    {
      name = "MONITOR_STOPPED";
      break;
    }
    default:
    {
      zsys_error("illegal socket monitor event: %d", event);
      name = "UNKNOWN";
    }
  }
  if(!(self->verbose == (_Bool)0))
    zsys_info("zmonitor: %s - %s", name, address);

  zstr_sendfm((void *)self->pipe, "%s", name);
  zstr_sendfm((void *)self->pipe, "%d", value);
  zstr_send((void *)self->pipe, address);
  free((void *)address);
}

// s_self_handle_udp
// file src/zbeacon.c line 229
static void s_self_handle_udp(struct anonymous_36 *self)
{
  /* assertion self */
  assert(self != ((struct anonymous_36 *)NULL));
  char peername[16l];
  struct _zframe_t *frame;
  frame=zsys_udp_recv(self->udpsock, peername);
  _Bool is_valid = (_Bool)0;
  unsigned char *return_value_zframe_data_1;
  signed int return_value_memcmp_2;
  if(!(self->filter == ((struct _zframe_t *)NULL)))
  {
    unsigned char *filter_data;
    filter_data=zframe_data(self->filter);
    unsigned long int filter_size;
    filter_size=zframe_size(self->filter);
    unsigned long int return_value_zframe_size_3;
    return_value_zframe_size_3=zframe_size(frame);
    if(return_value_zframe_size_3 >= filter_size)
    {
      return_value_zframe_data_1=zframe_data(frame);
      return_value_memcmp_2=memcmp((const void *)return_value_zframe_data_1, (const void *)filter_data, filter_size);
      if(return_value_memcmp_2 == 0)
        is_valid = (_Bool)1;

    }

  }

  unsigned char *return_value_zframe_data_4;
  signed int return_value_memcmp_5;
  if(!(is_valid == (_Bool)0))
  {
    if(!(self->transmit == ((struct _zframe_t *)NULL)))
    {
      unsigned char *transmit_data;
      transmit_data=zframe_data(self->transmit);
      unsigned long int transmit_size;
      transmit_size=zframe_size(self->transmit);
      unsigned long int return_value_zframe_size_6;
      return_value_zframe_size_6=zframe_size(frame);
      if(return_value_zframe_size_6 == transmit_size)
      {
        return_value_zframe_data_4=zframe_data(frame);
        return_value_memcmp_5=memcmp((const void *)return_value_zframe_data_4, (const void *)transmit_data, transmit_size);
        if(return_value_memcmp_5 == 0)
          is_valid = (_Bool)0;

      }

    }

  }

  if(!(is_valid == (_Bool)0))
  {
    struct _zmsg_t *msg;
    msg=zmsg_new();
    /* assertion msg */
    assert(msg != ((struct _zmsg_t *)NULL));
    zmsg_addstr(msg, peername);
    zmsg_append(msg, &frame);
    zmsg_send(&msg, (void *)self->pipe);
  }

  else
    zframe_destroy(&frame);
}

// s_self_listen
// file src/zmonitor.c line 78
static void s_self_listen(struct anonymous_25 *self, const char *event)
{
  signed int return_value_strcmp_12;
  return_value_strcmp_12=strcmp(event, "CONNECTED");
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(return_value_strcmp_12 == 0)
    self->events = self->events | 0x0001;

  else
  {
    return_value_strcmp_11=strcmp(event, "CONNECT_DELAYED");
    if(return_value_strcmp_11 == 0)
      self->events = self->events | 0x0002;

    else
    {
      return_value_strcmp_10=strcmp(event, "CONNECT_RETRIED");
      if(return_value_strcmp_10 == 0)
        self->events = self->events | 0x0004;

      else
      {
        return_value_strcmp_9=strcmp(event, "LISTENING");
        if(return_value_strcmp_9 == 0)
          self->events = self->events | 0x0008;

        else
        {
          return_value_strcmp_8=strcmp(event, "BIND_FAILED");
          if(return_value_strcmp_8 == 0)
            self->events = self->events | 0x0010;

          else
          {
            return_value_strcmp_7=strcmp(event, "ACCEPTED");
            if(return_value_strcmp_7 == 0)
              self->events = self->events | 0x0020;

            else
            {
              return_value_strcmp_6=strcmp(event, "ACCEPT_FAILED");
              if(return_value_strcmp_6 == 0)
                self->events = self->events | 0x0040;

              else
              {
                return_value_strcmp_5=strcmp(event, "CLOSED");
                if(return_value_strcmp_5 == 0)
                  self->events = self->events | 0x0080;

                else
                {
                  return_value_strcmp_4=strcmp(event, "CLOSE_FAILED");
                  if(return_value_strcmp_4 == 0)
                    self->events = self->events | 0x0100;

                  else
                  {
                    return_value_strcmp_3=strcmp(event, "DISCONNECTED");
                    if(return_value_strcmp_3 == 0)
                      self->events = self->events | 0x0200;

                    else
                    {
                      return_value_strcmp_2=strcmp(event, "MONITOR_STOPPED");
                      if(return_value_strcmp_2 == 0)
                        self->events = self->events | 0x0400;

                      else
                      {
                        return_value_strcmp_1=strcmp(event, "ALL");
                        if(return_value_strcmp_1 == 0)
                          self->events = self->events | 0xFFFF;

                        else
                          zsys_warning("zmonitor: - invalid listen event=%s", event);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// s_self_new
// file src/zauth.c line 65
static struct anonymous_26 * s_self_new(struct _zsock_t *pipe)
{
  struct anonymous_26 *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link1(sizeof(struct anonymous_26) /*64ul*/ , "src/zauth.c", (unsigned int)67);
  self = (struct anonymous_26 *)return_value_safe_malloc_1;
  signed int rc = -1;
  if(!(self == ((struct anonymous_26 *)NULL)))
  {
    self->pipe = pipe;
    self->whitelist=zhashx_new();
    if(!(self->whitelist == ((struct _zhashx_t *)NULL)))
      self->blacklist=zhashx_new();

    if(!(self->blacklist == ((struct _zhashx_t *)NULL)))
      self->handler=zsock_new_checked(4, "src/zauth.c", (unsigned long int)77);

    if(!(self->handler == ((struct _zsock_t *)NULL)))
      rc=zsock_bind(self->handler, "inproc://zeromq.zap.01");

    if(rc == 0)
      self->poller=zpoller_new((void *)self->pipe, self->handler, (void *)0);

    if(self->poller == ((struct _zpoller_t *)NULL))
      s_self_destroy(&self);

  }

  return self;
}

// s_self_new_link1
// file src/zbeacon.c line 66
static struct anonymous_36 * s_self_new_link1(struct _zsock_t *pipe_link1)
{
  struct anonymous_36 *self_link1;
  void *return_value_safe_malloc_1_link1;
  return_value_safe_malloc_1_link1=safe_malloc_link3(sizeof(struct anonymous_36) /*1096ul*/ , "src/zbeacon.c", (unsigned int)68);
  self_link1 = (struct anonymous_36 *)return_value_safe_malloc_1_link1;
  if(self_link1 == ((struct anonymous_36 *)NULL))
    return (struct anonymous_36 *)(void *)0;

  else
  {
    self_link1->pipe = pipe_link1;
    return self_link1;
  }
}

// s_self_new_link2
// file src/zmonitor.c line 59
static struct anonymous_25 * s_self_new_link2(struct _zsock_t *pipe_link2, void *sock)
{
  struct anonymous_25 *self_link2;
  void *return_value_safe_malloc_1_link2;
  return_value_safe_malloc_1_link2=safe_malloc_link18(sizeof(struct anonymous_25) /*40ul*/ , "src/zmonitor.c", (unsigned int)61);
  self_link2 = (struct anonymous_25 *)return_value_safe_malloc_1_link2;
  if(self_link2 == ((struct anonymous_25 *)NULL))
    return (struct anonymous_25 *)(void *)0;

  else
  {
    self_link2->pipe = pipe_link2;
    self_link2->monitored=zsock_resolve(sock);
    self_link2->poller=zpoller_new((void *)self_link2->pipe, (void *)0);
    if(self_link2->poller == ((struct _zpoller_t *)NULL))
      s_self_destroy_link2(&self_link2);

    return self_link2;
  }
}

// s_self_new_link3
// file src/zproxy.c line 56
static struct anonymous_35 * s_self_new_link3(struct _zsock_t *pipe_link3)
{
  struct anonymous_35 *self_link3;
  void *return_value_safe_malloc_1_link3;
  return_value_safe_malloc_1_link3=safe_malloc_link21(sizeof(struct anonymous_35) /*48ul*/ , "src/zproxy.c", (unsigned int)58);
  self_link3 = (struct anonymous_35 *)return_value_safe_malloc_1_link3;
  if(!(self_link3 == ((struct anonymous_35 *)NULL)))
  {
    self_link3->pipe = pipe_link3;
    self_link3->poller=zpoller_new((void *)self_link3->pipe, (void *)0);
    if(self_link3->poller == ((struct _zpoller_t *)NULL))
      s_self_destroy_link3(&self_link3);

  }

  return self_link3;
}

// s_self_prepare_udp
// file src/zbeacon.c line 80
static void s_self_prepare_udp(struct anonymous_36 *self)
{
  if(!(self->udpsock == 0))
    zsys_udp_close(self->udpsock);

  self->hostname[(signed long int)0] = (char)0;
  self->udpsock=zsys_udp_new((_Bool)0);
  signed int return_value_strcmp_6;
  const char *return_value_ziflist_address_3;
  const char *return_value_ziflist_broadcast_4;
  if(!(self->udpsock == -1))
  {
    const char *iface;
    iface=zsys_interface();
    unsigned int bind_to = (unsigned int)0;
    unsigned int send_to = (unsigned int)0;
    signed int return_value_strcmp_8;
    return_value_strcmp_8=strcmp(iface, "*");
    if(return_value_strcmp_8 == 0)
    {
      bind_to = (unsigned int)0x00000000;
      send_to = (unsigned int)0xffffffff;
    }

    else
    {
      struct _ziflist_t *iflist;
      iflist=ziflist_new();
      /* assertion iflist */
      assert(iflist != ((struct _ziflist_t *)NULL));
      const char *name;
      name=ziflist_first(iflist);
      while(!(name == ((const char *)NULL)))
      {
        signed int return_value_strcmp_5;
        return_value_strcmp_5=strcmp(iface, name);
        _Bool tmp_if_expr_7;
        if(return_value_strcmp_5 == 0)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_strcmp_6=strcmp(iface, "");
          tmp_if_expr_7 = !(return_value_strcmp_6 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          const char *return_value_ziflist_broadcast_1;
          return_value_ziflist_broadcast_1=ziflist_broadcast(iflist);
          send_to=inet_addr(return_value_ziflist_broadcast_1);
          const char *return_value_ziflist_address_2;
          return_value_ziflist_address_2=ziflist_address(iflist);
          bind_to=inet_addr(return_value_ziflist_address_2);
          if(!(self->verbose == (_Bool)0))
          {
            return_value_ziflist_address_3=ziflist_address(iflist);
            return_value_ziflist_broadcast_4=ziflist_broadcast(iflist);
            zsys_info("zbeacon: interface=%s address=%s broadcast=%s", name, return_value_ziflist_address_3, return_value_ziflist_broadcast_4);
          }

          break;
        }

        name=ziflist_next(iflist);
      }
      ziflist_destroy(&iflist);
    }
    if(!(bind_to == 0u))
    {
      self->broadcast.sin_family = (unsigned short int)2;
      self->broadcast.sin_port=htons((unsigned short int)self->port_nbr);
      self->broadcast.sin_addr.s_addr = send_to;
      struct sockaddr_in address = self->broadcast;
      address.sin_addr.s_addr = bind_to;
      struct sockaddr_in sockaddr = self->broadcast;
      signed int return_value_bind_9;
      return_value_bind_9=bind(self->udpsock, (struct sockaddr *)&sockaddr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(!(return_value_bind_9 == 0))
        zsys_socket_error("bind");

      signed int return_value_getnameinfo_10;
      return_value_getnameinfo_10=getnameinfo((struct sockaddr *)&address, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ , self->hostname, (unsigned int)1025, (char *)(void *)0, (unsigned int)0, 1);
      if(return_value_getnameinfo_10 == 0)
      {
        if(!(self->verbose == (_Bool)0))
          zsys_info("zbeacon: configured, hostname=%s", (const void *)self->hostname);

      }

    }

  }

}

// s_self_start
// file src/zmonitor.c line 128
static void s_self_start(struct anonymous_25 *self)
{
  /* assertion !self->sink */
  assert(!(self->sink != ((struct _zsock_t *)NULL)));
  char *endpoint;
  endpoint=zsys_sprintf("inproc://zmonitor-%p", self->monitored);
  /* assertion endpoint */
  assert(endpoint != ((char *)NULL));
  signed int rc;
  rc=zmq_socket_monitor(self->monitored, endpoint, self->events);
  /* assertion rc == 0 */
  assert(rc == 0);
  self->sink=zsock_new_checked(0, "src/zmonitor.c", (unsigned long int)138);
  /* assertion self->sink */
  assert(self->sink != ((struct _zsock_t *)NULL));
  rc=zsock_connect(self->sink, "%s", endpoint);
  /* assertion rc == 0 */
  assert(rc == 0);
  zpoller_add(self->poller, (void *)self->sink);
  free((void *)endpoint);
}

// s_self_switch
// file src/zproxy.c line 188
static void s_self_switch(struct anonymous_35 *self, struct _zsock_t *input, struct _zsock_t *output)
{
  void *zmq_input;
  zmq_input=zsock_resolve((void *)input);
  void *zmq_output;
  zmq_output=zsock_resolve((void *)output);
  void *zmq_capture;
  void *tmp_if_expr_2;
  void *return_value_zsock_resolve_1;
  if(!(self->capture == ((struct _zsock_t *)NULL)))
  {
    return_value_zsock_resolve_1=zsock_resolve((void *)self->capture);
    tmp_if_expr_2 = return_value_zsock_resolve_1;
  }

  else
    tmp_if_expr_2 = (void *)0;
  zmq_capture = tmp_if_expr_2;
  struct zmq_msg_t msg;
  zmq_msg_init(&msg);
  while((_Bool)1)
  {
    signed int return_value_zmq_recvmsg_3;
    return_value_zmq_recvmsg_3=zmq_recvmsg(zmq_input, &msg, 1);
    if(return_value_zmq_recvmsg_3 == -1)
      break;

    signed int send_flags;
    signed int return_value_zsock_rcvmore_4;
    return_value_zsock_rcvmore_4=zsock_rcvmore(zmq_input);
    send_flags = return_value_zsock_rcvmore_4 != 0 ? 2 : 0;
    if(!(zmq_capture == NULL))
    {
      struct zmq_msg_t s_self_switch__1__1__1__dup;
      zmq_msg_init(&s_self_switch__1__1__1__dup);
      zmq_msg_copy(&s_self_switch__1__1__1__dup, &msg);
      signed int return_value_zmq_sendmsg_5;
      return_value_zmq_sendmsg_5=zmq_sendmsg(zmq_capture, &s_self_switch__1__1__1__dup, send_flags);
      if(return_value_zmq_sendmsg_5 == -1)
        zmq_msg_close(&s_self_switch__1__1__1__dup);

    }

    signed int return_value_zmq_sendmsg_6;
    return_value_zmq_sendmsg_6=zmq_sendmsg(zmq_output, &msg, send_flags);
    if(return_value_zmq_sendmsg_6 == -1)
    {
      zmq_msg_close(&msg);
      break;
    }

  }
}

// s_send_string
// file src/zstr.c line 36
static signed int s_send_string(void *dest, _Bool more, char *string)
{
  /* assertion dest */
  assert(dest != NULL);
  void *handle;
  handle=zsock_resolve(dest);
  unsigned long int len;
  len=strlen(string);
  struct zmq_msg_t message;
  zmq_msg_init_size(&message, len);
  void *return_value_zmq_msg_data_1;
  return_value_zmq_msg_data_1=zmq_msg_data(&message);
  memcpy(return_value_zmq_msg_data_1, (const void *)string, len);
  signed int return_value_zmq_sendmsg_2;
  return_value_zmq_sendmsg_2=zmq_sendmsg(handle, &message, more != (_Bool)0 ? 2 : 0);
  if(return_value_zmq_sendmsg_2 == -1)
  {
    zmq_msg_close(&message);
    return -1;
  }

  else
    return 0;
}

// s_server_config_global
// file src/zgossip_engine.inc line 654
static void s_server_config_global(struct anonymous_28 *self)
{
  char *return_value_zconfig_get_1;
  signed int return_value_atoi_2;
  if(self->verbose == (_Bool)0)
  {
    return_value_zconfig_get_1=zconfig_get(self->config, "server/verbose", "0");
    return_value_atoi_2=atoi(return_value_zconfig_get_1);
    if(!(return_value_atoi_2 == 0))
      self->verbose = (_Bool)1;

  }

  char *return_value_zconfig_get_3;
  return_value_zconfig_get_3=zconfig_get(self->config, "server/timeout", "60000");
  signed int return_value_atoi_4;
  return_value_atoi_4=atoi(return_value_zconfig_get_3);
  self->timeout = (unsigned long int)return_value_atoi_4;
  zloop_set_ticket_delay(self->loop, self->timeout);
  signed int background;
  char *return_value_zconfig_get_5;
  return_value_zconfig_get_5=zconfig_get(self->config, "server/background", "0");
  background=atoi(return_value_zconfig_get_5);
  if(background == 0)
    zsys_set_logstream(stdout);

}

// s_server_config_service
// file src/zgossip_engine.inc line 731
static void s_server_config_service(struct anonymous_28 *self)
{
  struct _zconfig_t *section;
  section=zconfig_locate(self->config, "zgossip");
  if(!(section == ((struct _zconfig_t *)NULL)))
    section=zconfig_child(section);

  char *return_value_zconfig_value_1;
  char *return_value_zconfig_name_9;
  signed int return_value_strcmp_10;
  signed int return_value_zmq_errno_2;
  const char *return_value_zmq_strerror_3;
  char *return_value_zconfig_name_7;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_5;
  while(!(section == ((struct _zconfig_t *)NULL)))
  {
    char *return_value_zconfig_name_11;
    return_value_zconfig_name_11=zconfig_name(section);
    signed int return_value_strcmp_12;
    return_value_strcmp_12=strcmp(return_value_zconfig_name_11, "echo");
    if(return_value_strcmp_12 == 0)
    {
      return_value_zconfig_value_1=zconfig_value(section);
      zsys_notice("%s", return_value_zconfig_value_1);
    }

    else
    {
      return_value_zconfig_name_9=zconfig_name(section);
      return_value_strcmp_10=strcmp(return_value_zconfig_name_9, "bind");
      if(return_value_strcmp_10 == 0)
      {
        char *endpoint;
        endpoint=zconfig_get(section, "endpoint", "?");
        signed int return_value_zsock_bind_4;
        return_value_zsock_bind_4=zsock_bind(self->router, "%s", endpoint);
        if(return_value_zsock_bind_4 == -1)
        {
          return_value_zmq_errno_2=zmq_errno();
          return_value_zmq_strerror_3=zmq_strerror(return_value_zmq_errno_2);
          zsys_warning("could not bind to %s (%s)", endpoint, return_value_zmq_strerror_3);
        }

      }

      else
      {
        return_value_zconfig_name_7=zconfig_name(section);
        return_value_strcmp_8=strcmp(return_value_zconfig_name_7, "security");
        if(return_value_strcmp_8 == 0)
        {
          char *mechanism;
          mechanism=zconfig_get(section, "mechanism", "null");
          char *domain;
          domain=zconfig_get(section, "domain", (const char *)(void *)0);
          signed int return_value_strcmp_6;
          return_value_strcmp_6=strcmp(mechanism, "null");
          if(return_value_strcmp_6 == 0)
          {
            zsys_notice("server is using NULL security");
            if(!(domain == ((char *)NULL)))
              zsock_set_zap_domain((void *)self->router, (const char *)(void *)0);

          }

          else
          {
            return_value_strcmp_5=strcmp(mechanism, "plain");
            if(return_value_strcmp_5 == 0)
            {
              zsys_notice("server is using PLAIN security");
              zsock_set_plain_server((void *)self->router, 1);
            }

            else
              zsys_warning("mechanism=%s is not supported", mechanism);
          }
        }

      }
    }
    section=zconfig_next(section);
  }
  s_server_config_global(self);
}

// s_server_destroy
// file src/zgossip_engine.inc line 708
static void s_server_destroy(struct anonymous_28 **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct anonymous_28 **)NULL));
  if(!(*self_p == ((struct anonymous_28 *)NULL)))
  {
    struct anonymous_28 *self = *self_p;
    zgossip_msg_destroy(&self->message);
    zhash_destroy(&self->clients);
    server_terminate(&self->server);
    zsock_destroy_checked(&self->router, "src/zgossip_engine.inc", (unsigned long int)717);
    zconfig_destroy(&self->config);
    zloop_destroy(&self->loop);
    free((void *)self);
    *self_p = (struct anonymous_28 *)(void *)0;
  }

}

// s_server_handle_pipe
// file src/zgossip_engine.inc line 774
static signed int s_server_handle_pipe(struct _zloop_t *loop, struct _zsock_t *reader, void *argument)
{
  struct anonymous_28 *self = (struct anonymous_28 *)argument;
  struct _zmsg_t *msg;
  msg=zmsg_recv((void *)self->pipe);
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  if(msg == ((struct _zmsg_t *)NULL))
    return -1;

  else
  {
    char *method;
    method=zmsg_popstr(msg);
    if(!(self->verbose == (_Bool)0))
      zsys_debug("%s:     API command=%s", self->log_prefix, method);

    signed int return_value_strcmp_12;
    return_value_strcmp_12=strcmp(method, "VERBOSE");
    if(return_value_strcmp_12 == 0)
      self->verbose = (_Bool)1;

    else
    {
      return_value_strcmp_11=strcmp(method, "_TERM");
      if(return_value_strcmp_11 == 0)
      {
        free((void *)method);
        zmsg_destroy(&msg);
        return -1;
      }

      else
      {
        return_value_strcmp_10=strcmp(method, "BIND");
        if(return_value_strcmp_10 == 0)
        {
          char *endpoint;
          endpoint=zmsg_popstr(msg);
          self->port=zsock_bind(self->router, "%s", endpoint);
          if(self->port == -1)
            zsys_warning("could not bind to %s", endpoint);

          free((void *)endpoint);
        }

        else
        {
          return_value_strcmp_9=strcmp(method, "PORT");
          if(return_value_strcmp_9 == 0)
          {
            zstr_sendm((void *)self->pipe, "PORT");
            zstr_sendf((void *)self->pipe, "%d", self->port);
          }

          else
          {
            return_value_strcmp_6=strcmp(method, "LOAD");
            _Bool tmp_if_expr_8;
            if(return_value_strcmp_6 == 0)
              tmp_if_expr_8 = (_Bool)1;

            else
            {
              return_value_strcmp_7=strcmp(method, "CONFIGURE");
              tmp_if_expr_8 = !(return_value_strcmp_7 != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_8)
            {
              char *s_server_handle_pipe__1__4__filename;
              s_server_handle_pipe__1__4__filename=zmsg_popstr(msg);
              zconfig_destroy(&self->config);
              self->config=zconfig_load(s_server_handle_pipe__1__4__filename);
              if(!(self->config == ((struct _zconfig_t *)NULL)))
              {
                s_server_config_service(self);
                self->server.config = self->config;
              }

              else
              {
                zsys_warning("cannot load config file '%s'", s_server_handle_pipe__1__4__filename);
                self->config=zconfig_new("root", (struct _zconfig_t *)(void *)0);
              }
              free((void *)s_server_handle_pipe__1__4__filename);
            }

            else
            {
              return_value_strcmp_5=strcmp(method, "SET");
              if(return_value_strcmp_5 == 0)
              {
                char *path;
                path=zmsg_popstr(msg);
                char *value;
                value=zmsg_popstr(msg);
                zconfig_put(self->config, path, value);
                signed int return_value_strcmp_2;
                return_value_strcmp_2=strcmp(path, "server/animate");
                if(return_value_strcmp_2 == 0)
                {
                  zsys_warning("'%s' is deprecated, use VERBOSE command instead", path);
                  signed int return_value_atoi_1;
                  return_value_atoi_1=atoi(value);
                  self->verbose = (_Bool)return_value_atoi_1;
                }

                s_server_config_global(self);
                free((void *)path);
                free((void *)value);
              }

              else
              {
                return_value_strcmp_4=strcmp(method, "SAVE");
                if(return_value_strcmp_4 == 0)
                {
                  char *filename;
                  filename=zmsg_popstr(msg);
                  signed int return_value_zconfig_save_3;
                  return_value_zconfig_save_3=zconfig_save(self->config, filename);
                  if(!(return_value_zconfig_save_3 == 0))
                    zsys_warning("cannot save config file '%s'", filename);

                  free((void *)filename);
                }

                else
                {
                  struct _zmsg_t *reply;
                  reply=server_method(&self->server, method, msg);
                  zmsg_send(&reply, (void *)self->pipe);
                }
              }
            }
          }
        }
      }
    }
    free((void *)method);
    zmsg_destroy(&msg);
    return 0;
  }
}

// s_server_handle_protocol
// file src/zgossip_engine.inc line 857
static signed int s_server_handle_protocol(struct _zloop_t *loop, struct _zsock_t *reader, void *argument)
{
  struct anonymous_28 *self = (struct anonymous_28 *)argument;
  signed int return_value_zsock_events_1;
  do
  {
    return_value_zsock_events_1=zsock_events((void *)self->router);
    if((1 & return_value_zsock_events_1) == 0)
      break;

    signed int return_value_zgossip_msg_recv_2;
    return_value_zgossip_msg_recv_2=zgossip_msg_recv(self->message, self->router);
    if(!(return_value_zgossip_msg_recv_2 == 0))
      return -1;

    char *hashkey;
    struct _zframe_t *return_value_zgossip_msg_routing_id_3;
    return_value_zgossip_msg_routing_id_3=zgossip_msg_routing_id(self->message);
    hashkey=zframe_strhex(return_value_zgossip_msg_routing_id_3);
    struct anonymous_31 *client;
    void *return_value_zhash_lookup_4;
    return_value_zhash_lookup_4=zhash_lookup(self->clients, hashkey);
    client = (struct anonymous_31 *)return_value_zhash_lookup_4;
    if(client == ((struct anonymous_31 *)NULL))
    {
      struct _zframe_t *return_value_zgossip_msg_routing_id_5;
      return_value_zgossip_msg_routing_id_5=zgossip_msg_routing_id(self->message);
      client=s_client_new(self, return_value_zgossip_msg_routing_id_5);
      zhash_insert(self->clients, hashkey, (void *)client);
      zhash_freefn(self->clients, hashkey, s_client_free);
    }

    free((void *)hashkey);
    if(!(client->ticket == NULL))
      zloop_ticket_reset(self->loop, client->ticket);

    enum anonymous_30 return_value_s_protocol_event_6;
    return_value_s_protocol_event_6=s_protocol_event(self->message);
    s_client_execute(client, return_value_s_protocol_event_6);
  }
  while((_Bool)1);
  return 0;
}

// s_server_new
// file src/zgossip_engine.inc line 676
static struct anonymous_28 * s_server_new(struct _zsock_t *pipe)
{
  struct anonymous_28 *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link13(sizeof(struct anonymous_28) /*136ul*/ , "src/zgossip_engine.inc", (unsigned int)678);
  self = (struct anonymous_28 *)return_value_safe_malloc_1;
  /* assertion self */
  assert(self != ((struct anonymous_28 *)NULL));
  /* assertion (s_server_t *) &self->server == self */
  assert((struct anonymous_28 *)&self->server == self);
  self->pipe = pipe;
  self->router=zsock_new_checked(6, "src/zgossip_engine.inc", (unsigned long int)683);
  zsock_set_unbounded((void *)self->router);
  self->message=zgossip_msg_new();
  self->clients=zhash_new();
  self->config=zconfig_new("root", (struct _zconfig_t *)(void *)0);
  self->loop=zloop_new();
  signed long int return_value_zclock_time_2;
  return_value_zclock_time_2=zclock_time();
  srandom((unsigned int)return_value_zclock_time_2);
  signed long int return_value_random_3;
  return_value_random_3=random();
  self->client_id = (unsigned int)(signed int)((double)((float)1000 * (float)return_value_random_3) / ((double)2147483647 + 1.0));
  s_server_config_global(self);
  self->server.pipe = self->pipe;
  self->server.config = self->config;
  server_initialize(&self->server);
  s_satisfy_pedantic_compilers();
  return self;
}

// s_signal_handler
// file src/zsys.c line 493
static void s_signal_handler(signed int signal_value)
{
  zctx_interrupted = 1;
  zsys_interrupted = 1;
}

// s_socket_event
// file src/zloop.c line 893
static signed int s_socket_event(struct _zloop_t *loop, struct _zsock_t *handle, void *arg)
{
  return -1;
}

// s_socket_event_link1
// file src/zmonitor_v2.c line 269
static void s_socket_event_link1(struct anonymous_39 *self)
{
  struct _zframe_t *frame;
  frame=zframe_recv(self->socket);
  signed int event;
  unsigned char *return_value_zframe_data_1;
  return_value_zframe_data_1=zframe_data(frame);
  event = (signed int)*((unsigned short int *)return_value_zframe_data_1);
  signed int value;
  unsigned char *return_value_zframe_data_2;
  return_value_zframe_data_2=zframe_data(frame);
  value = (signed int)*((unsigned int *)(return_value_zframe_data_2 + (signed long int)2));
  zframe_destroy(&frame);
  char *address;
  address=zstr_recv(self->socket);
  char *description = "Unknown";
  switch(event)
  {
    case 0x0020:
    {
      description = "Accepted";
      break;
    }
    case 0x0040:
    {
      description = "Accept failed";
      break;
    }
    case 0x0010:
    {
      description = "Bind failed";
      break;
    }
    case 0x0080:
    {
      description = "Closed";
      break;
    }
    case 0x0100:
    {
      description = "Close failed";
      break;
    }
    case 0x0200:
    {
      description = "Disconnected";
      break;
    }
    case 0x0001:
    {
      description = "Connected";
      break;
    }
    case 0x0002:
    {
      description = "Connect delayed";
      break;
    }
    case 0x0004:
    {
      description = "Connect retried";
      break;
    }
    case 0x0008:
    {
      description = "Listening";
      break;
    }
    case 0x0400:
    {
      description = "Monitor stopped";
      break;
    }
    default:
      zsys_error("illegal socket monitor event: %d", event);
  }
  if(!(self->verbose == (_Bool)0))
    zsys_info("zmonitor: %s - %s", description, address);

  zstr_sendfm(self->pipe, "%d", event);
  zstr_sendfm(self->pipe, "%d", value);
  zstr_sendm(self->pipe, address);
  zstr_send(self->pipe, description);
  free((void *)address);
}

// s_sub_free
// file src/zdir.c line 735
static void s_sub_free(void *data)
{
  struct _zdir_watch_sub_t *sub = (struct _zdir_watch_sub_t *)data;
  zdir_destroy(&sub->dir);
  free((void *)sub);
}

// s_test_attached
// file src/zthread.c line 222
static void s_test_attached(void *args, struct _zctx_t *ctx, void *pipe)
{
  zsocket_new(ctx, 8);
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  char *ping;
  ping=zstr_recv(pipe);
  /* assertion ping */
  assert(ping != ((char *)NULL));
  zstr_free(&ping);
  zstr_send(pipe, "pong");
}

// s_test_detached
// file src/zthread.c line 209
static void * s_test_detached(void *args)
{
  struct _zctx_t *ctx;
  ctx=zctx_new();
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  void *push;
  push=zsocket_new(ctx, 8);
  /* assertion push */
  assert(push != NULL);
  zctx_destroy(&ctx);
  return (void *)0;
}

// s_thread_shim
// file src/zactor.c line 63
static void * s_thread_shim(void *args)
{
  /* assertion args */
  assert(args != NULL);
  struct anonymous_22 *shim = (struct anonymous_22 *)args;
  shim->handler(shim->pipe, shim->args);
  zsock_set_sndtimeo((void *)shim->pipe, 0);
  zsock_signal((void *)shim->pipe, (unsigned char)0);
  zsock_destroy_checked(&shim->pipe, "src/zactor.c", (unsigned long int)71);
  free((void *)shim);
  return (void *)0;
}

// s_thread_shim_link1
// file src/zthread.c line 77
static void * s_thread_shim_link1(void *args_link1)
{
  /* assertion args */
  assert(args_link1 != NULL);
  struct anonymous_21 *shim_link1 = (struct anonymous_21 *)args_link1;
  if(!(shim_link1->attached == ((void (*)(void *, struct _zctx_t *, void *))NULL)))
    shim_link1->attached(shim_link1->args, shim_link1->ctx, shim_link1->pipe);

  else
    shim_link1->detached(shim_link1->args);
  zctx_destroy(&shim_link1->ctx);
  free((void *)shim_link1);
  return (void *)0;
}

// s_thread_start
// file src/zthread.c line 112
static void s_thread_start(struct anonymous_21 *shim)
{
  unsigned long int thread;
  pthread_create(&thread, (const union pthread_attr_t *)(void *)0, s_thread_shim_link1, (void *)shim);
  pthread_detach(thread);
}

// s_ticket_comparator
// file src/zloop.c line 216
static signed int s_ticket_comparator(struct _s_ticket_t *ticket1, struct _s_ticket_t *ticket2)
{
  if(!(ticket2->when >= ticket1->when))
    return 1;

  else
    if(!(ticket1->when >= ticket2->when))
      return -1;

    else
      return 0;
}

// s_ticket_destroy
// file src/zloop.c line 204
static void s_ticket_destroy(struct _s_ticket_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _s_ticket_t **)NULL));
  struct _s_ticket_t *self = *self_p;
  if(!(self == ((struct _s_ticket_t *)NULL)))
  {
    self->tag = 0xDeadBeef;
    free((void *)self);
    *self_p = (struct _s_ticket_t *)(void *)0;
  }

}

// s_ticket_new
// file src/zloop.c line 190
static struct _s_ticket_t * s_ticket_new(unsigned long int delay, signed int (*handler)(struct _zloop_t *, signed int, void *), void *arg)
{
  struct _s_ticket_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link17(sizeof(struct _s_ticket_t) /*56ul*/ , "src/zloop.c", (unsigned int)192);
  self = (struct _s_ticket_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _s_ticket_t *)NULL)))
  {
    self->tag = (unsigned int)0x0007cafe;
    self->delay = delay;
    signed long int return_value_zclock_mono_2;
    return_value_zclock_mono_2=zclock_mono();
    self->when = (signed long int)((unsigned long int)return_value_zclock_mono_2 + delay);
    self->handler = handler;
    self->arg = arg;
  }

  return self;
}

// s_tickless
// file src/zloop.c line 291
static signed long int s_tickless(struct _zloop_t *self)
{
  signed long int tickless;
  signed long int return_value_zclock_mono_1;
  return_value_zclock_mono_1=zclock_mono();
  tickless = return_value_zclock_mono_1 + (signed long int)(1000 * 3600);
  struct _s_timer_t *timer;
  void *return_value_zlistx_first_2;
  return_value_zlistx_first_2=zlistx_first(self->timers);
  timer = (struct _s_timer_t *)return_value_zlistx_first_2;
  while(!(timer == ((struct _s_timer_t *)NULL)))
  {
    if(!(timer->when >= tickless))
      tickless = timer->when;

    void *return_value_zlistx_next_3;
    return_value_zlistx_next_3=zlistx_next(self->timers);
    timer = (struct _s_timer_t *)return_value_zlistx_next_3;
  }
  struct _s_ticket_t *ticket;
  void *return_value_zlistx_first_4;
  return_value_zlistx_first_4=zlistx_first(self->tickets);
  ticket = (struct _s_ticket_t *)return_value_zlistx_first_4;
  if(!(ticket == ((struct _s_ticket_t *)NULL)))
  {
    if(!(ticket->when >= tickless))
      tickless = ticket->when;

  }

  signed long int timeout;
  signed long int return_value_zclock_mono_5;
  return_value_zclock_mono_5=zclock_mono();
  timeout = (signed long int)(tickless - return_value_zclock_mono_5);
  if(!(timeout >= 0l))
    timeout = (signed long int)0;

  if(!(self->verbose == (_Bool)0))
    zsys_debug("zloop polling for %d msec", (signed int)timeout);

  return timeout * (signed long int)1;
}

// s_timer_comparator
// file src/zloop.c line 178
static signed int s_timer_comparator(struct _s_timer_t *timer1, struct _s_timer_t *timer2)
{
  if(!(timer2->when >= timer1->when))
    return 1;

  else
    if(!(timer1->when >= timer2->when))
      return -1;

    else
      return 0;
}

// s_timer_destroy
// file src/zloop.c line 167
static void s_timer_destroy(struct _s_timer_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _s_timer_t **)NULL));
  struct _s_timer_t *self = *self_p;
  if(!(self == ((struct _s_timer_t *)NULL)))
  {
    free((void *)self);
    *self_p = (struct _s_timer_t *)(void *)0;
  }

}

// s_timer_event
// file src/zloop.c line 886
static signed int s_timer_event(struct _zloop_t *loop, signed int timer_id, void *output)
{
  zstr_send(output, "PING");
  return 0;
}

// s_timer_event3
// file src/zloop.c line 900
static signed int s_timer_event3(struct _zloop_t *loop, signed int timer_id, void *called)
{
  *((_Bool *)called) = (_Bool)1;
  return -1;
}

// s_timer_new
// file src/zloop.c line 152
static struct _s_timer_t * s_timer_new(signed int timer_id, unsigned long int delay, unsigned long int times, signed int (*handler)(struct _zloop_t *, signed int, void *), void *arg)
{
  struct _s_timer_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link17(sizeof(struct _s_timer_t) /*56ul*/ , "src/zloop.c", (unsigned int)154);
  self = (struct _s_timer_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _s_timer_t *)NULL)))
  {
    self->timer_id = timer_id;
    self->delay = delay;
    self->times = times;
    signed long int return_value_zclock_mono_2;
    return_value_zclock_mono_2=zclock_mono();
    self->when = (signed long int)((unsigned long int)return_value_zclock_mono_2 + delay);
    self->handler = handler;
    self->arg = arg;
  }

  return self;
}

// s_timer_remove
// file src/zloop.c line 230
static void s_timer_remove(struct _zloop_t *self, signed int timer_id)
{
  struct _s_timer_t *timer;
  void *return_value_zlistx_first_1;
  return_value_zlistx_first_1=zlistx_first(self->timers);
  timer = (struct _s_timer_t *)return_value_zlistx_first_1;
  while(!(timer == ((struct _s_timer_t *)NULL)))
  {
    if(timer->timer_id == timer_id)
    {
      zlistx_delete(self->timers, timer->list_handle);
      break;
    }

    void *return_value_zlistx_next_2;
    return_value_zlistx_next_2=zlistx_next(self->timers);
    timer = (struct _s_timer_t *)return_value_zlistx_next_2;
  }
}

// s_valid_flags
// file src/ziflist.c line 128
static _Bool s_valid_flags(signed short int flags)
{
  return ((signed int)flags & 1) != 0 && !(((signed int)flags & 8) != 0) && ((signed int)flags & 2) != 0 && !(((signed int)flags & 2048) != 0) && !(((signed int)flags & 16) != 0);
}

// s_verify_eoln
// file src/zconfig.c line 744
static signed int s_verify_eoln(char *readptr, signed int lineno)
{
  while(!(*readptr == 0))
  {
    signed int return_value_isspace_1;
    return_value_isspace_1=isspace((signed int)(unsigned char)*readptr);
    if(!(return_value_isspace_1 == 0))
      readptr = readptr + 1l;

    else
      if((signed int)*readptr == 35)
        break;

      else
      {
        zclock_log("E (zconfig): (%d) invalid syntax '%s'", lineno, readptr);
        return -1;
        break;
      }
  }
  return 0;
}

// s_watch_server_config
// file src/zgossip_engine.inc line 888
static signed int s_watch_server_config(struct _zloop_t *loop, signed int timer_id, void *argument)
{
  struct anonymous_28 *self = (struct anonymous_28 *)argument;
  _Bool return_value_zconfig_has_changed_3;
  return_value_zconfig_has_changed_3=zconfig_has_changed(self->config);
  signed int return_value_zconfig_reload_2;
  if(!(return_value_zconfig_has_changed_3 == (_Bool)0))
  {
    return_value_zconfig_reload_2=zconfig_reload(&self->config);
    if(return_value_zconfig_reload_2 == 0)
    {
      s_server_config_service(self);
      self->server.config = self->config;
      const char *return_value_zconfig_filename_1;
      return_value_zconfig_filename_1=zconfig_filename(self->config);
      zsys_notice("reloaded configuration from %s", return_value_zconfig_filename_1);
    }

  }

  return 0;
}

// s_z85_decode
// file src/zarmour.c line 417
static unsigned char * s_z85_decode(const char *data, unsigned long int *size)
{
  /* assertion data */
  assert(data != ((const char *)NULL));
  /* assertion size */
  assert(size != ((unsigned long int *)NULL));
  unsigned long int length;
  length=strlen(data);
  /* assertion length % 5 == 0 */
  assert(length % (unsigned long int)5 == (unsigned long int)0);
  *size = ((unsigned long int)4 * length) / (unsigned long int)5 + (unsigned long int)1;
  unsigned char *bytes;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link2(*size, "src/zarmour.c", (unsigned int)424);
  bytes = (unsigned char *)return_value_safe_malloc_1;
  unsigned char *result;
  result=zmq_z85_decode(bytes, (char *)data);
  if(result == ((unsigned char *)NULL))
  {
    free((void *)bytes);
    bytes = (unsigned char *)(void *)0;
  }

  return bytes;
}

// s_z85_encode
// file src/zarmour.c line 403
static char * s_z85_encode(const unsigned char *data, unsigned long int length)
{
  /* assertion data != ((void *)0) */
  assert(data != (const unsigned char *)(void *)0);
  /* assertion length % 4 == 0 */
  assert(length % (unsigned long int)4 == (unsigned long int)0);
  char *str;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link2(((unsigned long int)5 * length) / (unsigned long int)4 + (unsigned long int)1, "src/zarmour.c", (unsigned int)407);
  str = (char *)return_value_safe_malloc_1;
  char *result;
  result=zmq_z85_encode(str, (unsigned char *)data, length);
  if(result == ((char *)NULL))
  {
    free((void *)str);
    str = (char *)(void *)0;
  }

  return str;
}

// s_zap_request_destroy
// file src/zauth.c line 200
static void s_zap_request_destroy(struct anonymous_34 **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct anonymous_34 **)NULL));
  if(!(*self_p == ((struct anonymous_34 *)NULL)))
  {
    struct anonymous_34 *self = *self_p;
    free((void *)self->version);
    free((void *)self->sequence);
    free((void *)self->domain);
    free((void *)self->address);
    free((void *)self->identity);
    free((void *)self->mechanism);
    free((void *)self->username);
    free((void *)self->password);
    free((void *)self->client_key);
    free((void *)self->principal);
    free((void *)self);
    *self_p = (struct anonymous_34 *)(void *)0;
  }

}

// s_zap_request_new
// file src/zauth.c line 224
static struct anonymous_34 * s_zap_request_new(struct _zsock_t *handler, _Bool verbose)
{
  struct anonymous_34 *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link1(sizeof(struct anonymous_34) /*96ul*/ , "src/zauth.c", (unsigned int)226);
  self = (struct anonymous_34 *)return_value_safe_malloc_1;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  if(self == ((struct anonymous_34 *)NULL))
    return (struct anonymous_34 *)(void *)0;

  else
  {
    self->handler = handler;
    self->verbose = verbose;
    struct _zmsg_t *request;
    request=zmsg_recv((void *)handler);
    if(request == ((struct _zmsg_t *)NULL))
    {
      s_zap_request_destroy(&self);
      return (struct anonymous_34 *)(void *)0;
    }

    else
    {
      self->version=zmsg_popstr(request);
      self->sequence=zmsg_popstr(request);
      self->domain=zmsg_popstr(request);
      self->address=zmsg_popstr(request);
      self->identity=zmsg_popstr(request);
      self->mechanism=zmsg_popstr(request);
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(self->version, "1.0");
      /* assertion (!strcmp ((self->version), ("1.0"))) */
      assert(!(return_value_strcmp_2 != 0));
      signed int return_value_strcmp_8;
      return_value_strcmp_8=strcmp(self->mechanism, "PLAIN");
      if(return_value_strcmp_8 == 0)
      {
        self->username=zmsg_popstr(request);
        self->password=zmsg_popstr(request);
      }

      else
      {
        return_value_strcmp_7=strcmp(self->mechanism, "CURVE");
        if(return_value_strcmp_7 == 0)
        {
          struct _zframe_t *frame;
          frame=zmsg_pop(request);
          unsigned long int return_value_zframe_size_3;
          return_value_zframe_size_3=zframe_size(frame);
          /* assertion zframe_size (frame) == 32 */
          assert(return_value_zframe_size_3 == (unsigned long int)32);
          void *return_value_safe_malloc_4;
          return_value_safe_malloc_4=safe_malloc_link1((unsigned long int)41, "src/zauth.c", (unsigned int)259);
          self->client_key = (char *)return_value_safe_malloc_4;
          unsigned char *return_value_zframe_data_5;
          return_value_zframe_data_5=zframe_data(frame);
          zmq_z85_encode(self->client_key, return_value_zframe_data_5, (unsigned long int)32);
          zframe_destroy(&frame);
        }

        else
        {
          return_value_strcmp_6=strcmp(self->mechanism, "GSSAPI");
          if(return_value_strcmp_6 == 0)
            self->principal=zmsg_popstr(request);

        }
      }
      if(!(self->verbose == (_Bool)0))
        zsys_info("zauth: ZAP request mechanism=%s ipaddress=%s", self->mechanism, self->address);

      zmsg_destroy(&request);
      return self;
    }
  }
}

// s_zap_request_reply
// file src/zauth.c line 279
static signed int s_zap_request_reply(struct anonymous_34 *self, char *status_code, char *status_text)
{
  if(!(self->verbose == (_Bool)0))
    zsys_info("zauth: - ZAP reply status_code=%s status_text=%s", status_code, status_text);

  zstr_sendx((void *)self->handler, "1.0", self->sequence, status_code, status_text, (const void *)"", (const void *)"", (void *)0);
  return 0;
}

// s_zdir_watch_destroy
// file src/zdir.c line 721
static void s_zdir_watch_destroy(struct _zdir_watch_t **watch_p)
{
  /* assertion watch_p */
  assert(watch_p != ((struct _zdir_watch_t **)NULL));
  if(!(*watch_p == ((struct _zdir_watch_t *)NULL)))
  {
    struct _zdir_watch_t *watch = *watch_p;
    zloop_destroy(&watch->loop);
    free((void *)watch);
    *watch_p = (struct _zdir_watch_t *)(void *)0;
  }

}

// s_zdir_watch_new
// file src/zdir.c line 810
static struct _zdir_watch_t * s_zdir_watch_new(struct _zsock_t *pipe)
{
  struct _zdir_watch_t *watch;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link9(sizeof(struct _zdir_watch_t) /*32ul*/ , "src/zdir.c", (unsigned int)812);
  watch = (struct _zdir_watch_t *)return_value_safe_malloc_1;
  if(watch == ((struct _zdir_watch_t *)NULL))
    return (struct _zdir_watch_t *)(void *)0;

  else
  {
    watch->pipe = pipe;
    watch->read_timer_id = -1;
    watch->verbose = (_Bool)0;
    return watch;
  }
}

// s_zdir_watch_subscribe
// file src/zdir.c line 744
static void s_zdir_watch_subscribe(struct _zdir_watch_t *watch, const char *path)
{
  if(!(watch->verbose == (_Bool)0))
    zsys_info("zdir_watch: Subscribing to directory path: %s", path);

  struct _zdir_watch_sub_t *sub;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link9(sizeof(struct _zdir_watch_sub_t) /*8ul*/ , "src/zdir.c", (unsigned int)749);
  sub = (struct _zdir_watch_sub_t *)return_value_safe_malloc_1;
  sub->dir=zdir_new(path, (const char *)(void *)0);
  if(sub->dir == ((struct _zdir_t *)NULL))
  {
    if(!(watch->verbose == (_Bool)0))
      zsys_error("zdir_watch: Unable to create zdir for path: %s", path);

    zsock_signal((void *)watch->pipe, (unsigned char)1);
  }

  else
  {
    signed int rc;
    rc=zhash_insert(watch->subs, path, (void *)sub);
    if(!(rc == 0))
    {
      if(!(watch->verbose == (_Bool)0))
        zsys_error("zdir_watch: Unable to insert path '%s' into subscription list", path);

      zsock_signal((void *)watch->pipe, (unsigned char)1);
    }

    else
    {
      void *item;
      item=zhash_freefn(watch->subs, path, s_sub_free);
      if(!((struct _zdir_watch_sub_t *)item == sub))
      {
        if(!(watch->verbose == (_Bool)0))
          zsys_error("zdir_watch: Unable to set free fn for path %s", path);

        zsock_signal((void *)watch->pipe, (unsigned char)1);
      }

      else
      {
        if(!(watch->verbose == (_Bool)0))
          zsys_info("zdir_watch: Successfully subscribed to %s", path);

        zsock_signal((void *)watch->pipe, (unsigned char)0);
      }
    }
  }
}

// s_zdir_watch_timeout
// file src/zdir.c line 792
static signed int s_zdir_watch_timeout(struct _zdir_watch_t *watch, signed int timeout)
{
  if(!(watch->verbose == (_Bool)0))
    zsys_info("zdir_watch: Setting directory poll timeout to %d", timeout);

  if(!(watch->read_timer_id == -1))
  {
    zloop_timer_end(watch->loop, watch->read_timer_id);
    watch->read_timer_id = -1;
  }

  watch->read_timer_id=zloop_timer(watch->loop, (unsigned long int)timeout, (unsigned long int)0, s_on_read_timer, (void *)watch);
  if(!(watch->verbose == (_Bool)0))
    zsys_info("zdir_watch: Successfully set directory poll timeout to %d", timeout);

  return 0;
}

// s_zdir_watch_unsubscribe
// file src/zdir.c line 780
static void s_zdir_watch_unsubscribe(struct _zdir_watch_t *watch, const char *path)
{
  if(!(watch->verbose == (_Bool)0))
    zsys_info("zdir_watch: Unsubscribing from directory path: %s", path);

  zhash_delete(watch->subs, path);
  if(!(watch->verbose == (_Bool)0))
    zsys_info("zdir_watch: Successfully unsubscribed from %s", path);

  zsock_signal((void *)watch->pipe, (unsigned char)0);
}

// s_zhashx_rehash
// file src/zhashx.c line 207
static signed int s_zhashx_rehash(struct _zhashx_t *self, unsigned int new_prime_index)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  /* assertion new_prime_index < sizeof (primes) */
  assert((unsigned long int)new_prime_index < sizeof(unsigned long int [300l]) /*2400ul*/ );
  unsigned long int limit = primes[(signed long int)self->prime_index];
  unsigned long int new_limit = primes[(signed long int)new_prime_index];
  struct _item_t **new_items;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link14(sizeof(struct _item_t *) /*8ul*/  * new_limit, "src/zhashx.c", (unsigned int)214);
  new_items = (struct _item_t **)return_value_safe_malloc_1;
  if(new_items == ((struct _item_t **)NULL))
    return -1;

  else
  {
    unsigned long int index = (unsigned long int)0;
    for( ; !(index >= limit); index = index + 1ul)
    {
      struct _item_t *cur_item = self->items[(signed long int)index];
      if(!(cur_item == ((struct _item_t *)NULL)))
      {
        struct _item_t *next_item = cur_item->next;
        unsigned long int new_index;
        new_index=self->hasher(cur_item->key);
        new_index = new_index % new_limit;
        cur_item->index = new_index;
        cur_item->next = new_items[(signed long int)new_index];
        new_items[(signed long int)new_index] = cur_item;
        cur_item = next_item;
      }

    }
    free((void *)self->items);
    self->items = new_items;
    self->prime_index = new_prime_index;
    return 0;
  }
}

// s_zlist_free
// file src/zlist.c line 480
static void s_zlist_free(void *data)
{
  struct _zlist_t *self = (struct _zlist_t *)data;
  zlist_destroy(&self);
}

// safe_malloc
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc(unsigned long int size, const char *file, unsigned int line)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem;
  mem=calloc((unsigned long int)1, size);
  if(mem == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file, line);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem;
}

// safe_malloc_link1
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link1(unsigned long int size_link1, const char *file_link1, unsigned int line_link1)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link1;
  mem_link1=calloc((unsigned long int)1, size_link1);
  if(mem_link1 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link1, line_link1);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link1;
}

// safe_malloc_link10
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link10(unsigned long int size_link10, const char *file_link10, unsigned int line_link10)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link10;
  mem_link10=calloc((unsigned long int)1, size_link10);
  if(mem_link10 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link10, line_link10);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link10;
}

// safe_malloc_link11
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link11(unsigned long int size_link11, const char *file_link11, unsigned int line_link11)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link11;
  mem_link11=calloc((unsigned long int)1, size_link11);
  if(mem_link11 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link11, line_link11);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link11;
}

// safe_malloc_link12
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link12(unsigned long int size_link12, const char *file_link12, unsigned int line_link12)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link12;
  mem_link12=calloc((unsigned long int)1, size_link12);
  if(mem_link12 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link12, line_link12);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link12;
}

// safe_malloc_link13
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link13(unsigned long int size_link13, const char *file_link13, unsigned int line_link13)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link13;
  mem_link13=calloc((unsigned long int)1, size_link13);
  if(mem_link13 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link13, line_link13);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link13;
}

// safe_malloc_link14
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link14(unsigned long int size_link14, const char *file_link14, unsigned int line_link14)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link14;
  mem_link14=calloc((unsigned long int)1, size_link14);
  if(mem_link14 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link14, line_link14);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link14;
}

// safe_malloc_link15
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link15(unsigned long int size_link15, const char *file_link15, unsigned int line_link15)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link15;
  mem_link15=calloc((unsigned long int)1, size_link15);
  if(mem_link15 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link15, line_link15);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link15;
}

// safe_malloc_link16
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link16(unsigned long int size_link16, const char *file_link16, unsigned int line_link16)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link16;
  mem_link16=calloc((unsigned long int)1, size_link16);
  if(mem_link16 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link16, line_link16);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link16;
}

// safe_malloc_link17
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link17(unsigned long int size_link17, const char *file_link17, unsigned int line_link17)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link17;
  mem_link17=calloc((unsigned long int)1, size_link17);
  if(mem_link17 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link17, line_link17);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link17;
}

// safe_malloc_link18
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link18(unsigned long int size_link18, const char *file_link18, unsigned int line_link18)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link18;
  mem_link18=calloc((unsigned long int)1, size_link18);
  if(mem_link18 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link18, line_link18);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link18;
}

// safe_malloc_link19
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link19(unsigned long int size_link19, const char *file_link19, unsigned int line_link19)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link19;
  mem_link19=calloc((unsigned long int)1, size_link19);
  if(mem_link19 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link19, line_link19);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link19;
}

// safe_malloc_link2
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link2(unsigned long int size_link2, const char *file_link2, unsigned int line_link2)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link2;
  mem_link2=calloc((unsigned long int)1, size_link2);
  if(mem_link2 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link2, line_link2);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link2;
}

// safe_malloc_link20
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link20(unsigned long int size_link20, const char *file_link20, unsigned int line_link20)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link20;
  mem_link20=calloc((unsigned long int)1, size_link20);
  if(mem_link20 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link20, line_link20);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link20;
}

// safe_malloc_link21
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link21(unsigned long int size_link21, const char *file_link21, unsigned int line_link21)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link21;
  mem_link21=calloc((unsigned long int)1, size_link21);
  if(mem_link21 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link21, line_link21);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link21;
}

// safe_malloc_link22
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link22(unsigned long int size_link22, const char *file_link22, unsigned int line_link22)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link22;
  mem_link22=calloc((unsigned long int)1, size_link22);
  if(mem_link22 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link22, line_link22);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link22;
}

// safe_malloc_link23
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link23(unsigned long int size_link23, const char *file_link23, unsigned int line_link23)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link23;
  mem_link23=calloc((unsigned long int)1, size_link23);
  if(mem_link23 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link23, line_link23);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link23;
}

// safe_malloc_link24
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link24(unsigned long int size_link24, const char *file_link24, unsigned int line_link24)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link24;
  mem_link24=calloc((unsigned long int)1, size_link24);
  if(mem_link24 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link24, line_link24);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link24;
}

// safe_malloc_link25
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link25(unsigned long int size_link25, const char *file_link25, unsigned int line_link25)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link25;
  mem_link25=calloc((unsigned long int)1, size_link25);
  if(mem_link25 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link25, line_link25);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link25;
}

// safe_malloc_link26
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link26(unsigned long int size_link26, const char *file_link26, unsigned int line_link26)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link26;
  mem_link26=calloc((unsigned long int)1, size_link26);
  if(mem_link26 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link26, line_link26);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link26;
}

// safe_malloc_link27
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link27(unsigned long int size_link27, const char *file_link27, unsigned int line_link27)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link27;
  mem_link27=calloc((unsigned long int)1, size_link27);
  if(mem_link27 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link27, line_link27);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link27;
}

// safe_malloc_link28
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link28(unsigned long int size_link28, const char *file_link28, unsigned int line_link28)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link28;
  mem_link28=calloc((unsigned long int)1, size_link28);
  if(mem_link28 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link28, line_link28);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link28;
}

// safe_malloc_link29
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link29(unsigned long int size_link29, const char *file_link29, unsigned int line_link29)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link29;
  mem_link29=calloc((unsigned long int)1, size_link29);
  if(mem_link29 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link29, line_link29);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link29;
}

// safe_malloc_link3
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link3(unsigned long int size_link3, const char *file_link3, unsigned int line_link3)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link3;
  mem_link3=calloc((unsigned long int)1, size_link3);
  if(mem_link3 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link3, line_link3);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link3;
}

// safe_malloc_link30
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link30(unsigned long int size_link30, const char *file_link30, unsigned int line_link30)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link30;
  mem_link30=calloc((unsigned long int)1, size_link30);
  if(mem_link30 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link30, line_link30);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link30;
}

// safe_malloc_link31
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link31(unsigned long int size_link31, const char *file_link31, unsigned int line_link31)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link31;
  mem_link31=calloc((unsigned long int)1, size_link31);
  if(mem_link31 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link31, line_link31);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link31;
}

// safe_malloc_link32
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link32(unsigned long int size_link32, const char *file_link32, unsigned int line_link32)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link32;
  mem_link32=calloc((unsigned long int)1, size_link32);
  if(mem_link32 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link32, line_link32);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link32;
}

// safe_malloc_link33
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link33(unsigned long int size_link33, const char *file_link33, unsigned int line_link33)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link33;
  mem_link33=calloc((unsigned long int)1, size_link33);
  if(mem_link33 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link33, line_link33);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link33;
}

// safe_malloc_link34
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link34(unsigned long int size_link34, const char *file_link34, unsigned int line_link34)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link34;
  mem_link34=calloc((unsigned long int)1, size_link34);
  if(mem_link34 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link34, line_link34);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link34;
}

// safe_malloc_link35
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link35(unsigned long int size_link35, const char *file_link35, unsigned int line_link35)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link35;
  mem_link35=calloc((unsigned long int)1, size_link35);
  if(mem_link35 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link35, line_link35);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link35;
}

// safe_malloc_link36
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link36(unsigned long int size_link36, const char *file_link36, unsigned int line_link36)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link36;
  mem_link36=calloc((unsigned long int)1, size_link36);
  if(mem_link36 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link36, line_link36);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link36;
}

// safe_malloc_link37
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link37(unsigned long int size_link37, const char *file_link37, unsigned int line_link37)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link37;
  mem_link37=calloc((unsigned long int)1, size_link37);
  if(mem_link37 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link37, line_link37);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link37;
}

// safe_malloc_link4
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link4(unsigned long int size_link4, const char *file_link4, unsigned int line_link4)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link4;
  mem_link4=calloc((unsigned long int)1, size_link4);
  if(mem_link4 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link4, line_link4);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link4;
}

// safe_malloc_link5
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link5(unsigned long int size_link5, const char *file_link5, unsigned int line_link5)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link5;
  mem_link5=calloc((unsigned long int)1, size_link5);
  if(mem_link5 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link5, line_link5);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link5;
}

// safe_malloc_link6
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link6(unsigned long int size_link6, const char *file_link6, unsigned int line_link6)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link6;
  mem_link6=calloc((unsigned long int)1, size_link6);
  if(mem_link6 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link6, line_link6);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link6;
}

// safe_malloc_link7
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link7(unsigned long int size_link7, const char *file_link7, unsigned int line_link7)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link7;
  mem_link7=calloc((unsigned long int)1, size_link7);
  if(mem_link7 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link7, line_link7);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link7;
}

// safe_malloc_link8
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link8(unsigned long int size_link8, const char *file_link8, unsigned int line_link8)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link8;
  mem_link8=calloc((unsigned long int)1, size_link8);
  if(mem_link8 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link8, line_link8);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link8;
}

// safe_malloc_link9
// file src/../include/czmq_prelude.h line 529
static inline void * safe_malloc_link9(unsigned long int size_link9, const char *file_link9, unsigned int line_link9)
{
  __CPROVER_atomic_begin();
  *(&zsys_allocs) = *(&zsys_allocs) + (volatile unsigned long int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  void *mem_link9;
  mem_link9=calloc((unsigned long int)1, size_link9);
  if(mem_link9 == NULL)
  {
    fprintf(stderr, "FATAL ERROR at %s:%u\n", file_link9, line_link9);
    fprintf(stderr, "OUT OF MEMORY (malloc returned NULL)\n");
    fflush(stderr);
    abort();
  }

  return mem_link9;
}

// server_accept
// file src/zgossip.c line 232
static void server_accept(struct _server_t *self, const char *key, const char *value)
{
  struct _tuple_t *tuple;
  void *return_value_zhashx_lookup_1;
  return_value_zhashx_lookup_1=zhashx_lookup(self->tuples, (const void *)key);
  tuple = (struct _tuple_t *)return_value_zhashx_lookup_1;
  signed int return_value_strcmp_2;
  if(!(tuple == ((struct _tuple_t *)NULL)))
  {
    return_value_strcmp_2=strcmp(tuple->value, value);
    if(return_value_strcmp_2 == 0)
      goto __CPROVER_DUMP_L5;

  }

  void *return_value_safe_malloc_3;
  return_value_safe_malloc_3=safe_malloc_link13(sizeof(struct _tuple_t) /*24ul*/ , "src/zgossip.c", (unsigned int)239);
  tuple = (struct _tuple_t *)return_value_safe_malloc_3;
  /* assertion tuple */
  assert(tuple != ((struct _tuple_t *)NULL));
  tuple->container = self->tuples;
  tuple->key=strdup(key);
  tuple->value=strdup(value);
  zhashx_update(tuple->container, (const void *)key, (void *)tuple);
  zhashx_freefn(tuple->container, (const void *)key, tuple_free);
  zstr_sendx((void *)self->pipe, "DELIVER", key, value, (void *)0);
  self->cur_tuple = tuple;
  engine_broadcast_event(self, (struct _client_t *)(void *)0, (enum anonymous_30)forward_event);
  struct _zgossip_msg_t *gossip;
  gossip=zgossip_msg_new();
  zgossip_msg_set_id(gossip, 2);
  struct _zsock_t *remote;
  void *return_value_zlistx_first_4;
  return_value_zlistx_first_4=zlistx_first(self->remotes);
  remote = (struct _zsock_t *)return_value_zlistx_first_4;
  while(!(remote == ((struct _zsock_t *)NULL)))
  {
    zgossip_msg_set_key(gossip, tuple->key);
    zgossip_msg_set_value(gossip, tuple->value);
    zgossip_msg_send(gossip, remote);
    void *return_value_zlistx_next_5;
    return_value_zlistx_next_5=zlistx_next(self->remotes);
    remote = (struct _zsock_t *)return_value_zlistx_next_5;
  }
  zgossip_msg_destroy(&gossip);

__CPROVER_DUMP_L5:
  ;
}

// server_connect
// file src/zgossip.c line 195
static void server_connect(struct _server_t *self, const char *endpoint)
{
  struct _zsock_t *remote;
  remote=zsock_new_checked(5, "src/zgossip.c", (unsigned long int)197);
  /* assertion remote */
  assert(remote != ((struct _zsock_t *)NULL));
  zsock_set_unbounded((void *)remote);
  signed int return_value_zsock_connect_1;
  return_value_zsock_connect_1=zsock_connect(remote, "%s", endpoint);
  if(!(return_value_zsock_connect_1 == 0))
  {
    zsys_warning("bad zgossip endpoint '%s'", endpoint);
    zsock_destroy_checked(&remote, "src/zgossip.c", (unsigned long int)206);
  }

  else
  {
    struct _zgossip_msg_t *gossip;
    gossip=zgossip_msg_new();
    zgossip_msg_set_id(gossip, 1);
    zgossip_msg_send(gossip, remote);
    struct _tuple_t *tuple;
    void *return_value_zhashx_first_2;
    return_value_zhashx_first_2=zhashx_first(self->tuples);
    tuple = (struct _tuple_t *)return_value_zhashx_first_2;
    while(!(tuple == ((struct _tuple_t *)NULL)))
    {
      zgossip_msg_set_id(gossip, 2);
      zgossip_msg_set_key(gossip, tuple->key);
      zgossip_msg_set_value(gossip, tuple->value);
      zgossip_msg_send(gossip, remote);
      void *return_value_zhashx_next_3;
      return_value_zhashx_next_3=zhashx_next(self->tuples);
      tuple = (struct _tuple_t *)return_value_zhashx_next_3;
    }
    zgossip_msg_destroy(&gossip);
    engine_handle_socket(self, (void *)remote, remote_handler);
    zlistx_add_end(self->remotes, (void *)remote);
  }
}

// server_initialize
// file src/zgossip.c line 166
static signed int server_initialize(struct _server_t *self)
{
  engine_configure(self, "server/timeout", "1000");
  self->message=zgossip_msg_new();
  self->remotes=zlistx_new();
  /* assertion self->remotes */
  assert(self->remotes != ((struct _zlistx_t *)NULL));
  zlistx_set_destructor(self->remotes, (void (*)(void **))zsock_destroy);
  self->tuples=zhashx_new();
  /* assertion self->tuples */
  assert(self->tuples != ((struct _zhashx_t *)NULL));
  return 0;
}

// server_method
// file src/zgossip.c line 272
static struct _zmsg_t * server_method(struct _server_t *self, const char *method, struct _zmsg_t *msg)
{
  struct _zmsg_t *reply = (struct _zmsg_t *)(void *)0;
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(method, "CONNECT");
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  if(return_value_strcmp_4 == 0)
  {
    char *endpoint;
    endpoint=zmsg_popstr(msg);
    /* assertion endpoint */
    assert(endpoint != ((char *)NULL));
    server_connect(self, endpoint);
    zstr_free(&endpoint);
  }

  else
  {
    return_value_strcmp_3=strcmp(method, "PUBLISH");
    if(return_value_strcmp_3 == 0)
    {
      char *key;
      key=zmsg_popstr(msg);
      char *value;
      value=zmsg_popstr(msg);
      server_accept(self, key, value);
      zstr_free(&key);
      zstr_free(&value);
    }

    else
    {
      return_value_strcmp_2=strcmp(method, "STATUS");
      if(return_value_strcmp_2 == 0)
      {
        reply=zmsg_new();
        /* assertion reply */
        assert(reply != ((struct _zmsg_t *)NULL));
        zmsg_addstr(reply, "STATUS");
        unsigned long int return_value_zhashx_size_1;
        return_value_zhashx_size_1=zhashx_size(self->tuples);
        zmsg_addstrf(reply, "%d", (signed int)return_value_zhashx_size_1);
      }

      else
        zsys_error("unknown zgossip method '%s'", method);
    }
  }
  return reply;
}

// server_terminate
// file src/zgossip.c line 185
static void server_terminate(struct _server_t *self)
{
  zgossip_msg_destroy(&self->message);
  zlistx_destroy(&self->remotes);
  zhashx_destroy(&self->tuples);
}

// set_jump_offset
// file src/foreign/slre/slre.inc_c line 158
static void set_jump_offset(struct slre *r, signed int pc, signed int offset)
{
  /* assertion offset < r->code_size */
  assert(offset < r->code_size);
  if(r->code_size + -offset >= 256)
    r->err_str = "Jump offset is too big";

  else
    r->code[(signed long int)pc] = (unsigned char)(r->code_size - offset);
}

// sha1_init
// file src/foreign/sha1/sha1.inc_c line 223
extern void sha1_init(struct sha1_ctxt *ctxt)
{
  memset((void *)ctxt, 0, sizeof(struct sha1_ctxt) /*104ul*/ );
  ctxt->h.b32[(signed long int)0] = (unsigned int)0x67452301;
  ctxt->h.b32[(signed long int)1] = 0xefcdab89;
  ctxt->h.b32[(signed long int)2] = 0x98badcfe;
  ctxt->h.b32[(signed long int)3] = (unsigned int)0x10325476;
  ctxt->h.b32[(signed long int)4] = 0xc3d2e1f0;
}

// sha1_loop
// file src/foreign/sha1/sha1.inc_c line 277
extern void sha1_loop(struct sha1_ctxt *ctxt, const unsigned char *input0, unsigned long int len)
{
  const unsigned char *input;
  unsigned long int gaplen;
  unsigned long int gapstart;
  unsigned long int off;
  unsigned long int copysiz;
  input = (const unsigned char *)input0;
  off = (unsigned long int)0;
  for( ; !(off >= len); off = off + copysiz)
  {
    gapstart = (unsigned long int)((signed int)ctxt->count % 64);
    gaplen = (unsigned long int)64 - gapstart;
    copysiz = gaplen < len - off ? gaplen : len - off;
    memmove((void *)&ctxt->m.b8[(signed long int)gapstart], (const void *)&input[(signed long int)off], copysiz);
    ctxt->count = ctxt->count + (unsigned char)copysiz;
    ctxt->count = ctxt->count % (unsigned char)64;
    ctxt->c.b64[(signed long int)0] = ctxt->c.b64[(signed long int)0] + copysiz * (unsigned long int)8;
    if((signed int)ctxt->count % 64 == 0)
      sha1_step(ctxt);

  }
}

// sha1_pad
// file src/foreign/sha1/sha1.inc_c line 234
extern void sha1_pad(struct sha1_ctxt *ctxt)
{
  unsigned long int padlen;
  unsigned long int padstart;
  do
  {
    ctxt->m.b8[(signed long int)((signed int)ctxt->count % 64)] = (unsigned char)0x80;
    ctxt->count = ctxt->count + 1;
    ctxt->count = ctxt->count % (unsigned char)64;
    if((signed int)ctxt->count % 64 == 0)
      sha1_step(ctxt);

  }
  while((_Bool)0);
  padstart = (unsigned long int)((signed int)ctxt->count % 64);
  padlen = (unsigned long int)64 - padstart;
  if(!(padlen >= 8ul))
  {
    memset((void *)&ctxt->m.b8[(signed long int)padstart], 0, padlen);
    ctxt->count = ctxt->count + (unsigned char)padlen;
    ctxt->count = ctxt->count % (unsigned char)64;
    sha1_step(ctxt);
    padstart = (unsigned long int)((signed int)ctxt->count % 64);
    padlen = (unsigned long int)64 - padstart;
  }

  memset((void *)&ctxt->m.b8[(signed long int)padstart], 0, padlen - (unsigned long int)8);
  ctxt->count = ctxt->count + (unsigned char)((signed int)(unsigned char)padlen - 8);
  ctxt->count = ctxt->count % (unsigned char)64;
  do
  {
    ctxt->m.b8[(signed long int)((signed int)ctxt->count % 64)] = ctxt->c.b8[(signed long int)7];
    ctxt->count = ctxt->count + 1;
    ctxt->count = ctxt->count % (unsigned char)64;
    if((signed int)ctxt->count % 64 == 0)
      sha1_step(ctxt);

  }
  while((_Bool)0);
  do
  {
    ctxt->m.b8[(signed long int)((signed int)ctxt->count % 64)] = ctxt->c.b8[(signed long int)6];
    ctxt->count = ctxt->count + 1;
    ctxt->count = ctxt->count % (unsigned char)64;
    if((signed int)ctxt->count % 64 == 0)
      sha1_step(ctxt);

  }
  while((_Bool)0);
  do
  {
    ctxt->m.b8[(signed long int)((signed int)ctxt->count % 64)] = ctxt->c.b8[(signed long int)5];
    ctxt->count = ctxt->count + 1;
    ctxt->count = ctxt->count % (unsigned char)64;
    if((signed int)ctxt->count % 64 == 0)
      sha1_step(ctxt);

  }
  while((_Bool)0);
  do
  {
    ctxt->m.b8[(signed long int)((signed int)ctxt->count % 64)] = ctxt->c.b8[(signed long int)4];
    ctxt->count = ctxt->count + 1;
    ctxt->count = ctxt->count % (unsigned char)64;
    if((signed int)ctxt->count % 64 == 0)
      sha1_step(ctxt);

  }
  while((_Bool)0);
  do
  {
    ctxt->m.b8[(signed long int)((signed int)ctxt->count % 64)] = ctxt->c.b8[(signed long int)3];
    ctxt->count = ctxt->count + 1;
    ctxt->count = ctxt->count % (unsigned char)64;
    if((signed int)ctxt->count % 64 == 0)
      sha1_step(ctxt);

  }
  while((_Bool)0);
  do
  {
    ctxt->m.b8[(signed long int)((signed int)ctxt->count % 64)] = ctxt->c.b8[(signed long int)2];
    ctxt->count = ctxt->count + 1;
    ctxt->count = ctxt->count % (unsigned char)64;
    if((signed int)ctxt->count % 64 == 0)
      sha1_step(ctxt);

  }
  while((_Bool)0);
  do
  {
    ctxt->m.b8[(signed long int)((signed int)ctxt->count % 64)] = ctxt->c.b8[(signed long int)1];
    ctxt->count = ctxt->count + 1;
    ctxt->count = ctxt->count % (unsigned char)64;
    if((signed int)ctxt->count % 64 == 0)
      sha1_step(ctxt);

  }
  while((_Bool)0);
  do
  {
    ctxt->m.b8[(signed long int)((signed int)ctxt->count % 64)] = ctxt->c.b8[(signed long int)0];
    ctxt->count = ctxt->count + 1;
    ctxt->count = ctxt->count % (unsigned char)64;
    if((signed int)ctxt->count % 64 == 0)
      sha1_step(ctxt);

  }
  while((_Bool)0);
}

// sha1_result
// file src/foreign/sha1/sha1.inc_c line 305
extern void sha1_result(struct sha1_ctxt *ctxt, unsigned char *digest0)
{
  unsigned char *digest = (unsigned char *)digest0;
  sha1_pad(ctxt);
  digest[(signed long int)0] = ctxt->h.b8[(signed long int)3];
  digest[(signed long int)1] = ctxt->h.b8[(signed long int)2];
  digest[(signed long int)2] = ctxt->h.b8[(signed long int)1];
  digest[(signed long int)3] = ctxt->h.b8[(signed long int)0];
  digest[(signed long int)4] = ctxt->h.b8[(signed long int)7];
  digest[(signed long int)5] = ctxt->h.b8[(signed long int)6];
  digest[(signed long int)6] = ctxt->h.b8[(signed long int)5];
  digest[(signed long int)7] = ctxt->h.b8[(signed long int)4];
  digest[(signed long int)8] = ctxt->h.b8[(signed long int)11];
  digest[(signed long int)9] = ctxt->h.b8[(signed long int)10];
  digest[(signed long int)10] = ctxt->h.b8[(signed long int)9];
  digest[(signed long int)11] = ctxt->h.b8[(signed long int)8];
  digest[(signed long int)12] = ctxt->h.b8[(signed long int)15];
  digest[(signed long int)13] = ctxt->h.b8[(signed long int)14];
  digest[(signed long int)14] = ctxt->h.b8[(signed long int)13];
  digest[(signed long int)15] = ctxt->h.b8[(signed long int)12];
  digest[(signed long int)16] = ctxt->h.b8[(signed long int)19];
  digest[(signed long int)17] = ctxt->h.b8[(signed long int)18];
  digest[(signed long int)18] = ctxt->h.b8[(signed long int)17];
  digest[(signed long int)19] = ctxt->h.b8[(signed long int)16];
}

// sha1_step
// file src/foreign/sha1/sha1.inc_c line 78
static void sha1_step(struct sha1_ctxt *ctxt)
{
  unsigned int a;
  unsigned int b;
  unsigned int c;
  unsigned int d;
  unsigned int e;
  unsigned long int t;
  unsigned long int s;
  unsigned int tmp;
  struct sha1_ctxt tctxt;
  memmove((void *)&tctxt.m.b8[(signed long int)0], (const void *)&ctxt->m.b8[(signed long int)0], (unsigned long int)64);
  ctxt->m.b8[(signed long int)0] = tctxt.m.b8[(signed long int)3];
  ctxt->m.b8[(signed long int)1] = tctxt.m.b8[(signed long int)2];
  ctxt->m.b8[(signed long int)2] = tctxt.m.b8[(signed long int)1];
  ctxt->m.b8[(signed long int)3] = tctxt.m.b8[(signed long int)0];
  ctxt->m.b8[(signed long int)4] = tctxt.m.b8[(signed long int)7];
  ctxt->m.b8[(signed long int)5] = tctxt.m.b8[(signed long int)6];
  ctxt->m.b8[(signed long int)6] = tctxt.m.b8[(signed long int)5];
  ctxt->m.b8[(signed long int)7] = tctxt.m.b8[(signed long int)4];
  ctxt->m.b8[(signed long int)8] = tctxt.m.b8[(signed long int)11];
  ctxt->m.b8[(signed long int)9] = tctxt.m.b8[(signed long int)10];
  ctxt->m.b8[(signed long int)10] = tctxt.m.b8[(signed long int)9];
  ctxt->m.b8[(signed long int)11] = tctxt.m.b8[(signed long int)8];
  ctxt->m.b8[(signed long int)12] = tctxt.m.b8[(signed long int)15];
  ctxt->m.b8[(signed long int)13] = tctxt.m.b8[(signed long int)14];
  ctxt->m.b8[(signed long int)14] = tctxt.m.b8[(signed long int)13];
  ctxt->m.b8[(signed long int)15] = tctxt.m.b8[(signed long int)12];
  ctxt->m.b8[(signed long int)16] = tctxt.m.b8[(signed long int)19];
  ctxt->m.b8[(signed long int)17] = tctxt.m.b8[(signed long int)18];
  ctxt->m.b8[(signed long int)18] = tctxt.m.b8[(signed long int)17];
  ctxt->m.b8[(signed long int)19] = tctxt.m.b8[(signed long int)16];
  ctxt->m.b8[(signed long int)20] = tctxt.m.b8[(signed long int)23];
  ctxt->m.b8[(signed long int)21] = tctxt.m.b8[(signed long int)22];
  ctxt->m.b8[(signed long int)22] = tctxt.m.b8[(signed long int)21];
  ctxt->m.b8[(signed long int)23] = tctxt.m.b8[(signed long int)20];
  ctxt->m.b8[(signed long int)24] = tctxt.m.b8[(signed long int)27];
  ctxt->m.b8[(signed long int)25] = tctxt.m.b8[(signed long int)26];
  ctxt->m.b8[(signed long int)26] = tctxt.m.b8[(signed long int)25];
  ctxt->m.b8[(signed long int)27] = tctxt.m.b8[(signed long int)24];
  ctxt->m.b8[(signed long int)28] = tctxt.m.b8[(signed long int)31];
  ctxt->m.b8[(signed long int)29] = tctxt.m.b8[(signed long int)30];
  ctxt->m.b8[(signed long int)30] = tctxt.m.b8[(signed long int)29];
  ctxt->m.b8[(signed long int)31] = tctxt.m.b8[(signed long int)28];
  ctxt->m.b8[(signed long int)32] = tctxt.m.b8[(signed long int)35];
  ctxt->m.b8[(signed long int)33] = tctxt.m.b8[(signed long int)34];
  ctxt->m.b8[(signed long int)34] = tctxt.m.b8[(signed long int)33];
  ctxt->m.b8[(signed long int)35] = tctxt.m.b8[(signed long int)32];
  ctxt->m.b8[(signed long int)36] = tctxt.m.b8[(signed long int)39];
  ctxt->m.b8[(signed long int)37] = tctxt.m.b8[(signed long int)38];
  ctxt->m.b8[(signed long int)38] = tctxt.m.b8[(signed long int)37];
  ctxt->m.b8[(signed long int)39] = tctxt.m.b8[(signed long int)36];
  ctxt->m.b8[(signed long int)40] = tctxt.m.b8[(signed long int)43];
  ctxt->m.b8[(signed long int)41] = tctxt.m.b8[(signed long int)42];
  ctxt->m.b8[(signed long int)42] = tctxt.m.b8[(signed long int)41];
  ctxt->m.b8[(signed long int)43] = tctxt.m.b8[(signed long int)40];
  ctxt->m.b8[(signed long int)44] = tctxt.m.b8[(signed long int)47];
  ctxt->m.b8[(signed long int)45] = tctxt.m.b8[(signed long int)46];
  ctxt->m.b8[(signed long int)46] = tctxt.m.b8[(signed long int)45];
  ctxt->m.b8[(signed long int)47] = tctxt.m.b8[(signed long int)44];
  ctxt->m.b8[(signed long int)48] = tctxt.m.b8[(signed long int)51];
  ctxt->m.b8[(signed long int)49] = tctxt.m.b8[(signed long int)50];
  ctxt->m.b8[(signed long int)50] = tctxt.m.b8[(signed long int)49];
  ctxt->m.b8[(signed long int)51] = tctxt.m.b8[(signed long int)48];
  ctxt->m.b8[(signed long int)52] = tctxt.m.b8[(signed long int)55];
  ctxt->m.b8[(signed long int)53] = tctxt.m.b8[(signed long int)54];
  ctxt->m.b8[(signed long int)54] = tctxt.m.b8[(signed long int)53];
  ctxt->m.b8[(signed long int)55] = tctxt.m.b8[(signed long int)52];
  ctxt->m.b8[(signed long int)56] = tctxt.m.b8[(signed long int)59];
  ctxt->m.b8[(signed long int)57] = tctxt.m.b8[(signed long int)58];
  ctxt->m.b8[(signed long int)58] = tctxt.m.b8[(signed long int)57];
  ctxt->m.b8[(signed long int)59] = tctxt.m.b8[(signed long int)56];
  ctxt->m.b8[(signed long int)60] = tctxt.m.b8[(signed long int)63];
  ctxt->m.b8[(signed long int)61] = tctxt.m.b8[(signed long int)62];
  ctxt->m.b8[(signed long int)62] = tctxt.m.b8[(signed long int)61];
  ctxt->m.b8[(signed long int)63] = tctxt.m.b8[(signed long int)60];
  a = ctxt->h.b32[(signed long int)0];
  b = ctxt->h.b32[(signed long int)1];
  c = ctxt->h.b32[(signed long int)2];
  d = ctxt->h.b32[(signed long int)3];
  e = ctxt->h.b32[(signed long int)4];
  t = (unsigned long int)0;
  for( ; !(t >= 20ul); t = t + 1ul)
  {
    s = t & (unsigned long int)0x0f;
    if(t >= 16ul)
      ctxt->m.b32[(signed long int)s] = (ctxt->m.b32[(signed long int)(s + (unsigned long int)13 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)8 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)2 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)s]) << 1 | (ctxt->m.b32[(signed long int)(s + (unsigned long int)13 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)8 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)2 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)s]) >> 32 - 1;

    tmp = (a << 5 | a >> 32 - 5) + (b & c | ~b & d) + e + ctxt->m.b32[(signed long int)s] + _K[(signed long int)(t / (unsigned long int)20)];
    e = d;
    d = c;
    c = b << 30 | b >> 32 - 30;
    b = a;
    a = tmp;
  }
  t = (unsigned long int)20;
  for( ; !(t >= 40ul); t = t + 1ul)
  {
    s = t & (unsigned long int)0x0f;
    ctxt->m.b32[(signed long int)s] = (ctxt->m.b32[(signed long int)(s + (unsigned long int)13 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)8 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)2 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)s]) << 1 | (ctxt->m.b32[(signed long int)(s + (unsigned long int)13 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)8 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)2 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)s]) >> 32 - 1;
    tmp = (a << 5 | a >> 32 - 5) + (b ^ c ^ d) + e + ctxt->m.b32[(signed long int)s] + _K[(signed long int)(t / (unsigned long int)20)];
    e = d;
    d = c;
    c = b << 30 | b >> 32 - 30;
    b = a;
    a = tmp;
  }
  t = (unsigned long int)40;
  for( ; !(t >= 60ul); t = t + 1ul)
  {
    s = t & (unsigned long int)0x0f;
    ctxt->m.b32[(signed long int)s] = (ctxt->m.b32[(signed long int)(s + (unsigned long int)13 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)8 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)2 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)s]) << 1 | (ctxt->m.b32[(signed long int)(s + (unsigned long int)13 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)8 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)2 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)s]) >> 32 - 1;
    tmp = (a << 5 | a >> 32 - 5) + (b & c | b & d | c & d) + e + ctxt->m.b32[(signed long int)s] + _K[(signed long int)(t / (unsigned long int)20)];
    e = d;
    d = c;
    c = b << 30 | b >> 32 - 30;
    b = a;
    a = tmp;
  }
  t = (unsigned long int)60;
  for( ; !(t >= 80ul); t = t + 1ul)
  {
    s = t & (unsigned long int)0x0f;
    ctxt->m.b32[(signed long int)s] = (ctxt->m.b32[(signed long int)(s + (unsigned long int)13 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)8 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)2 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)s]) << 1 | (ctxt->m.b32[(signed long int)(s + (unsigned long int)13 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)8 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)(s + (unsigned long int)2 & (unsigned long int)0x0f)] ^ ctxt->m.b32[(signed long int)s]) >> 32 - 1;
    tmp = (a << 5 | a >> 32 - 5) + (b ^ c ^ d) + e + ctxt->m.b32[(signed long int)s] + _K[(signed long int)(t / (unsigned long int)20)];
    e = d;
    d = c;
    c = b << 30 | b >> 32 - 30;
    b = a;
    a = tmp;
  }
  ctxt->h.b32[(signed long int)0] = ctxt->h.b32[(signed long int)0] + a;
  ctxt->h.b32[(signed long int)1] = ctxt->h.b32[(signed long int)1] + b;
  ctxt->h.b32[(signed long int)2] = ctxt->h.b32[(signed long int)2] + c;
  ctxt->h.b32[(signed long int)3] = ctxt->h.b32[(signed long int)3] + d;
  ctxt->h.b32[(signed long int)4] = ctxt->h.b32[(signed long int)4] + e;
  memset((void *)&ctxt->m.b8[(signed long int)0], 0, (unsigned long int)64);
}

// slre_compile
// file src/foreign/slre/slre.inc_c line 386
signed int slre_compile(struct slre *r, const char *re)
{
  r->err_str = (const char *)(void *)0;
  r->anchored = 0;
  r->num_caps = r->anchored;
  r->data_size = r->num_caps;
  r->code_size = r->data_size;
  if((signed int)*re == 94)
    r->anchored = r->anchored + 1;

  emit(r, 6);
  emit(r, 0);
  while(!((signed int)*re == 0))
    compile(r, &re);
  if((signed int)r->code[2l] == 1)
    fixup_branch(r, 4);

  emit(r, 7);
  emit(r, 0);
  emit(r, 0);
  return r->err_str == (const char *)(void *)0 ? 1 : 0;
}

// slre_dump
// file src/foreign/slre/slre.inc_c line 114
void slre_dump(struct slre *r, struct _IO_FILE *fp)
{
  signed int i;
  signed int j;
  signed int ch;
  signed int op;
  signed int pc = 0;
  for( ; !(pc >= r->code_size); pc = pc + 1)
  {
    op = (signed int)r->code[(signed long int)pc];
    fprintf(fp, "%3d %s ", pc, opcodes[(signed long int)op].name);
    i = 0;
    for( ; !((signed int)opcodes[(signed long int)op].flags[(signed long int)i] == 0); i = i + 1)
      switch((signed int)opcodes[(signed long int)op].flags[(signed long int)i])
      {
        case 105:
        {
          fprintf(fp, "%d ", r->code[(signed long int)(pc + 1)]);
          pc = pc + 1;
          break;
        }
        case 111:
        {
          fprintf(fp, "%d ", (pc + (signed int)r->code[(signed long int)(pc + 1)]) - i);
          pc = pc + 1;
          break;
        }
        case 68:
        {
          print_character_set(fp, r->data + (signed long int)r->code[(signed long int)(pc + 1)], (signed int)r->code[(signed long int)(pc + 2)]);
          pc = pc + 2;
          break;
        }
        case 100:
        {
          fputc(34, fp);
          j = 0;
          for( ; !(j >= (signed int)r->code[(signed long int)(2 + pc)]); j = j + 1)
          {
            ch = (signed int)r->data[(signed long int)((signed int)r->code[(signed long int)(pc + 1)] + j)];
            signed int return_value_isprint_1;
            return_value_isprint_1=isprint(ch);
            if(!(return_value_isprint_1 == 0))
              fputc(ch, fp);

            else
              fprintf(fp, "\\x%02x", ch);
          }
          fputc(34, fp);
          pc = pc + 2;
        }
      }
    fputc(10, fp);
  }
}

// slre_match
// file src/foreign/slre/slre.inc_c line 646
signed int slre_match(struct slre *r, const char *buf, unsigned long int len, struct cap *caps)
{
  signed int res = 0;
  unsigned long int ofs = (unsigned long int)0;
  if(!(r->anchored == 0))
    res=match(r, 0, buf, len, &ofs, caps);

  else
  {
    unsigned long int i = (unsigned long int)0;
    for( ; res == 0 && !(i >= len); i = i + 1ul)
    {
      ofs = i;
      res=match(r, 0, buf, len, &ofs, caps);
    }
  }
  return res;
}

// store_char_in_data
// file src/foreign/slre/slre.inc_c line 178
static void store_char_in_data(struct slre *r, signed int ch)
{
  if(r->data_size >= (signed int)sizeof(unsigned char [256l]) /*256*/ )
    r->err_str = "RE is too long (data overflow)";

  else
  {
    signed int tmp_post_1 = r->data_size;
    r->data_size = r->data_size + 1;
    r->data[(signed long int)tmp_post_1] = (unsigned char)ch;
  }
}

// store_tuple_if_new
// file src/zgossip.c line 365
static void store_tuple_if_new(struct _client_t *self)
{
  const char *return_value_zgossip_msg_key_1;
  return_value_zgossip_msg_key_1=zgossip_msg_key(self->message);
  const char *return_value_zgossip_msg_value_2;
  return_value_zgossip_msg_value_2=zgossip_msg_value(self->message);
  server_accept(self->server, return_value_zgossip_msg_key_1, return_value_zgossip_msg_value_2);
}

// tuple_free
// file src/zgossip.c line 145
static void tuple_free(void *argument)
{
  struct _tuple_t *self = (struct _tuple_t *)argument;
  free((void *)self->key);
  free((void *)self->value);
  free((void *)self);
}

// zactor_destroy
// file src/../include/zactor.h line 34
void zactor_destroy(struct _zactor_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zactor_t **)NULL));
  if(!(*self_p == ((struct _zactor_t *)NULL)))
  {
    struct _zactor_t *self = *self_p;
    _Bool return_value_zactor_is_1;
    return_value_zactor_is_1=zactor_is((void *)self);
    /* assertion zactor_is (self) */
    assert(return_value_zactor_is_1 != (_Bool)0);
    zsock_set_sndtimeo((void *)self->pipe, 0);
    signed int return_value_zstr_send_2;
    return_value_zstr_send_2=zstr_send((void *)self->pipe, "_TERM");
    if(return_value_zstr_send_2 == 0)
      zsock_wait((void *)self->pipe);

    zsock_destroy_checked(&self->pipe, "src/zactor.c", (unsigned long int)170);
    self->tag = 0xDeadBeef;
    free((void *)self);
    *self_p = (struct _zactor_t *)(void *)0;
  }

}

// zactor_is
// file src/zactor.c line 205
_Bool zactor_is(void *self)
{
  /* assertion self */
  assert(self != NULL);
  return ((struct _zactor_t *)self)->tag == (unsigned int)0x0005cafe;
}

// zactor_new
// file src/../include/zactor.h line 30
struct _zactor_t * zactor_new(void (*actor)(struct _zsock_t *, void *), void *args)
{
  struct _zactor_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc(sizeof(struct _zactor_t) /*16ul*/ , "src/zactor.c", (unsigned int)102);
  self = (struct _zactor_t *)return_value_safe_malloc_1;
  if(self == ((struct _zactor_t *)NULL))
    return (struct _zactor_t *)(void *)0;

  else
  {
    self->tag = (unsigned int)0x0005cafe;
    struct anonymous_22 *shim;
    void *return_value_safe_malloc_2;
    return_value_safe_malloc_2=safe_malloc(sizeof(struct anonymous_22) /*24ul*/ , "src/zactor.c", (unsigned int)107);
    shim = (struct anonymous_22 *)return_value_safe_malloc_2;
    if(shim == ((struct anonymous_22 *)NULL))
    {
      zactor_destroy(&self);
      return (struct _zactor_t *)(void *)0;
    }

    else
    {
      shim->pipe=zsys_create_pipe(&self->pipe);
      if(shim->pipe == ((struct _zsock_t *)NULL))
      {
        zactor_destroy(&self);
        return (struct _zactor_t *)(void *)0;
      }

      else
      {
        shim->handler = actor;
        shim->args = args;
        unsigned long int thread;
        pthread_create(&thread, (const union pthread_attr_t *)(void *)0, s_thread_shim, (void *)shim);
        pthread_detach(thread);
        zsock_wait((void *)self->pipe);
        return self;
      }
    }
  }
}

// zactor_recv
// file src/zactor.c line 195
struct _zmsg_t * zactor_recv(struct _zactor_t *self)
{
  struct _zmsg_t *return_value_zmsg_recv_1;
  return_value_zmsg_recv_1=zmsg_recv((void *)self);
  return return_value_zmsg_recv_1;
}

// zactor_resolve
// file src/zactor.c line 218
void * zactor_resolve(void *self)
{
  /* assertion self */
  assert(self != NULL);
  _Bool return_value_zactor_is_2;
  return_value_zactor_is_2=zactor_is(self);
  void *return_value_zsock_resolve_1;
  if(!(return_value_zactor_is_2 == (_Bool)0))
  {
    return_value_zsock_resolve_1=zsock_resolve((void *)((struct _zactor_t *)self)->pipe);
    return return_value_zsock_resolve_1;
  }

  else
    return self;
}

// zactor_send
// file src/zactor.c line 183
signed int zactor_send(struct _zactor_t *self, struct _zmsg_t **msg_p)
{
  signed int return_value_zmsg_send_1;
  return_value_zmsg_send_1=zmsg_send(msg_p, (void *)self);
  return return_value_zmsg_send_1;
}

// zactor_sock
// file src/zactor.c line 233
struct _zsock_t * zactor_sock(struct _zactor_t *self)
{
  /* assertion self */
  assert(self != ((struct _zactor_t *)NULL));
  _Bool return_value_zactor_is_1;
  return_value_zactor_is_1=zactor_is((void *)self);
  /* assertion zactor_is (self) */
  assert(return_value_zactor_is_1 != (_Bool)0);
  return self->pipe;
}

// zactor_test
// file src/zactor.c line 280
void zactor_test(_Bool verbose)
{
  printf(" * zactor: ");
  struct _zactor_t *actor;
  actor=zactor_new(echo_actor, (void *)"Hello, World");
  /* assertion actor */
  assert(actor != ((struct _zactor_t *)NULL));
  zstr_sendx((void *)actor, "ECHO", (const void *)"This is a string", (void *)0);
  char *string;
  string=zstr_recv((void *)actor);
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(string, "This is a string");
  /* assertion (!strcmp ((string), ("This is a string"))) */
  assert(!(return_value_strcmp_1 != 0));
  free((void *)string);
  zactor_destroy(&actor);
  printf("OK\n");
}

// zap_request_destroy
// file src/zauth_v2.c line 209
static void zap_request_destroy(struct anonymous_24 **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct anonymous_24 **)NULL));
  if(!(*self_p == ((struct anonymous_24 *)NULL)))
  {
    struct anonymous_24 *self = *self_p;
    free((void *)self->version);
    free((void *)self->sequence);
    free((void *)self->domain);
    free((void *)self->address);
    free((void *)self->identity);
    free((void *)self->mechanism);
    free((void *)self->username);
    free((void *)self->password);
    free((void *)self->client_key);
    free((void *)self->principal);
    free((void *)self);
    *self_p = (struct anonymous_24 *)(void *)0;
  }

}

// zap_request_new
// file src/zauth_v2.c line 233
static struct anonymous_24 * zap_request_new(void *handler)
{
  struct anonymous_24 *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link28(sizeof(struct anonymous_24) /*88ul*/ , "src/zauth_v2.c", (unsigned int)236);
  self = (struct anonymous_24 *)return_value_safe_malloc_1;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  if(self == ((struct anonymous_24 *)NULL))
    return (struct anonymous_24 *)(void *)0;

  else
  {
    self->handler = handler;
    struct _zmsg_t *request;
    request=zmsg_recv(handler);
    if(request == ((struct _zmsg_t *)NULL))
    {
      zap_request_destroy(&self);
      return (struct anonymous_24 *)(void *)0;
    }

    else
    {
      self->version=zmsg_popstr(request);
      self->sequence=zmsg_popstr(request);
      self->domain=zmsg_popstr(request);
      self->address=zmsg_popstr(request);
      self->identity=zmsg_popstr(request);
      self->mechanism=zmsg_popstr(request);
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(self->version, "1.0");
      /* assertion (!strcmp ((self->version), ("1.0"))) */
      assert(!(return_value_strcmp_2 != 0));
      signed int return_value_strcmp_8;
      return_value_strcmp_8=strcmp(self->mechanism, "PLAIN");
      if(return_value_strcmp_8 == 0)
      {
        self->username=zmsg_popstr(request);
        self->password=zmsg_popstr(request);
      }

      else
      {
        return_value_strcmp_7=strcmp(self->mechanism, "CURVE");
        if(return_value_strcmp_7 == 0)
        {
          struct _zframe_t *frame;
          frame=zmsg_pop(request);
          unsigned long int return_value_zframe_size_3;
          return_value_zframe_size_3=zframe_size(frame);
          /* assertion zframe_size (frame) == 32 */
          assert(return_value_zframe_size_3 == (unsigned long int)32);
          void *return_value_safe_malloc_4;
          return_value_safe_malloc_4=safe_malloc_link28((unsigned long int)41, "src/zauth_v2.c", (unsigned int)268);
          self->client_key = (char *)return_value_safe_malloc_4;
          unsigned char *return_value_zframe_data_5;
          return_value_zframe_data_5=zframe_data(frame);
          zmq_z85_encode(self->client_key, return_value_zframe_data_5, (unsigned long int)32);
          zframe_destroy(&frame);
        }

        else
        {
          return_value_strcmp_6=strcmp(self->mechanism, "GSSAPI");
          if(return_value_strcmp_6 == 0)
            self->principal=zmsg_popstr(request);

        }
      }
      zmsg_destroy(&request);
      return self;
    }
  }
}

// zap_request_reply
// file src/zauth_v2.c line 287
static signed int zap_request_reply(struct anonymous_24 *self, char *status_code, char *status_text)
{
  zstr_sendx(self->handler, "1.0", self->sequence, status_code, status_text, (const void *)"", (const void *)"", (void *)0);
  return 0;
}

// zarmour_decode
// file src/zarmour.c line 510
unsigned char * zarmour_decode(struct _zarmour_t *self, const char *data, unsigned long int *decode_size)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  /* assertion data */
  assert(data != ((const char *)NULL));
  /* assertion decode_size */
  assert(decode_size != ((unsigned long int *)NULL));
  unsigned long int linebreakchars = (unsigned long int)0;
  char *line_end = self->line_end;
  const char *pos = data;
  do
  {
    pos=strstr(pos, line_end);
    if(pos == ((const char *)NULL))
      break;

    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(line_end);
    linebreakchars = linebreakchars + return_value_strlen_1;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(line_end);
    pos = pos + (signed long int)return_value_strlen_2;
  }
  while((_Bool)1);
  unsigned char *return_value_s_base64_decode_3;
  unsigned char *return_value_s_base64_decode_4;
  unsigned char *return_value_s_base32_decode_5;
  unsigned char *return_value_s_base32_decode_6;
  unsigned char *return_value_s_base16_decode_7;
  unsigned char *return_value_s_z85_decode_8;
  switch((signed int)self->mode)
  {
    case ZARMOUR_MODE_BASE64_STD:
    {
      return_value_s_base64_decode_3=s_base64_decode(data, decode_size, s_base64_alphabet, linebreakchars);
      return return_value_s_base64_decode_3;
    }
    case ZARMOUR_MODE_BASE64_URL:
    {
      return_value_s_base64_decode_4=s_base64_decode(data, decode_size, s_base64url_alphabet, linebreakchars);
      return return_value_s_base64_decode_4;
    }
    case ZARMOUR_MODE_BASE32_STD:
    {
      return_value_s_base32_decode_5=s_base32_decode(data, decode_size, s_base32_alphabet, linebreakchars);
      return return_value_s_base32_decode_5;
    }
    case ZARMOUR_MODE_BASE32_HEX:
    {
      return_value_s_base32_decode_6=s_base32_decode(data, decode_size, s_base32hex_alphabet, linebreakchars);
      return return_value_s_base32_decode_6;
    }
    case ZARMOUR_MODE_BASE16:
    {
      return_value_s_base16_decode_7=s_base16_decode(data, decode_size, s_base16_alphabet, linebreakchars);
      return return_value_s_base16_decode_7;
    }
    case ZARMOUR_MODE_Z85:
    {
      return_value_s_z85_decode_8=s_z85_decode(data, decode_size);
      return return_value_s_z85_decode_8;
    }
    default:
      return (unsigned char *)(void *)0;
  }
}

// zarmour_destroy
// file src/zarmour.c line 109
void zarmour_destroy(struct _zarmour_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zarmour_t **)NULL));
  if(!(*self_p == ((struct _zarmour_t *)NULL)))
  {
    struct _zarmour_t *self = *self_p;
    free((void *)self->line_end);
    free((void *)self);
    *self_p = (struct _zarmour_t *)(void *)0;
  }

}

// zarmour_encode
// file src/zarmour.c line 437
char * zarmour_encode(struct _zarmour_t *self, const unsigned char *data, unsigned long int data_size)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  /* assertion data */
  assert(data != ((const unsigned char *)NULL));
  char *encoded = (char *)(void *)0;
  switch((signed int)self->mode)
  {
    case ZARMOUR_MODE_BASE64_STD:
    {
      encoded=s_base64_encode(data, data_size, s_base64_alphabet, self->pad, self->pad_char);
      break;
    }
    case ZARMOUR_MODE_BASE64_URL:
    {
      encoded=s_base64_encode(data, data_size, s_base64url_alphabet, self->pad, self->pad_char);
      break;
    }
    case ZARMOUR_MODE_BASE32_STD:
    {
      encoded=s_base32_encode(data, data_size, s_base32_alphabet, self->pad, self->pad_char);
      break;
    }
    case ZARMOUR_MODE_BASE32_HEX:
    {
      encoded=s_base32_encode(data, data_size, s_base32hex_alphabet, self->pad, self->pad_char);
      break;
    }
    case ZARMOUR_MODE_BASE16:
    {
      encoded=s_base16_encode(data, data_size, s_base16_alphabet);
      break;
    }
    case ZARMOUR_MODE_Z85:
      encoded=s_z85_encode(data, data_size);
  }
  unsigned long int return_value_strlen_10;
  unsigned long int return_value_strlen_5;
  if(encoded == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    if(!((signed int)self->mode == ZARMOUR_MODE_Z85))
    {
      if(!(self->line_breaks == (_Bool)0))
      {
        if(self->line_length >= 1ul)
        {
          return_value_strlen_10=strlen(encoded);
          if(!(self->line_length >= return_value_strlen_10))
          {
            char *line_end = self->line_end;
            unsigned long int nbr_lines;
            unsigned long int return_value_strlen_1;
            return_value_strlen_1=strlen(encoded);
            nbr_lines = return_value_strlen_1 / self->line_length;
            unsigned long int new_length;
            unsigned long int return_value_strlen_2;
            return_value_strlen_2=strlen(line_end);
            unsigned long int return_value_strlen_3;
            return_value_strlen_3=strlen(encoded);
            new_length = nbr_lines * (self->line_length + return_value_strlen_2) + return_value_strlen_3 % self->line_length;
            char *src = encoded;
            char *temp = encoded;
            void *return_value_safe_malloc_4;
            return_value_safe_malloc_4=safe_malloc_link2(new_length + (unsigned long int)1, "src/zarmour.c", (unsigned int)484);
            encoded = (char *)return_value_safe_malloc_4;
            char *dest = encoded;
            do
            {
              return_value_strlen_5=strlen(src);
              if(!(return_value_strlen_5 >= self->line_length))
                break;

              memcpy((void *)dest, (const void *)src, self->line_length);
              src = src + (signed long int)self->line_length;
              dest = dest + (signed long int)self->line_length;
              if(!(*src == 0))
              {
                unsigned long int return_value_strlen_6;
                return_value_strlen_6=strlen(line_end);
                memcpy((void *)dest, (const void *)line_end, return_value_strlen_6);
                unsigned long int return_value_strlen_7;
                return_value_strlen_7=strlen(line_end);
                dest = dest + (signed long int)return_value_strlen_7;
              }

            }
            while((_Bool)1);
            if(!(*src == 0))
            {
              unsigned long int return_value_strlen_8;
              return_value_strlen_8=strlen(src);
              memcpy((void *)dest, (const void *)src, return_value_strlen_8);
              unsigned long int return_value_strlen_9;
              return_value_strlen_9=strlen(src);
              dest = dest + (signed long int)return_value_strlen_9;
            }

            free((void *)temp);
            *dest = (char)0;
          }

        }

      }

    }

    return encoded;
  }
}

// zarmour_line_breaks
// file src/zarmour.c line 601
_Bool zarmour_line_breaks(struct _zarmour_t *self)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  return self->line_breaks;
}

// zarmour_line_length
// file src/zarmour.c line 618
unsigned long int zarmour_line_length(struct _zarmour_t *self)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  return self->line_length;
}

// zarmour_mode
// file src/zarmour.c line 549
enum anonymous_37 zarmour_mode(struct _zarmour_t *self)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  return self->mode;
}

// zarmour_mode_str
// file src/zarmour.c line 146
const char * zarmour_mode_str(struct _zarmour_t *self)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  _Bool tmp_if_expr_1;
  if((signed int)self->mode >= 0)
    tmp_if_expr_1 = (signed int)self->mode < _NUM_MODES ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  /* assertion (int) self->mode >= 0 && (int) self->mode < _NUM_MODES */
  assert(tmp_if_expr_1);
  return s_codec_names[(signed long int)(signed int)self->mode];
}

// zarmour_new
// file src/zarmour.c line 83
struct _zarmour_t * zarmour_new()
{
  struct _zarmour_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link2(sizeof(struct _zarmour_t) /*24ul*/ , "src/zarmour.c", (unsigned int)85);
  self = (struct _zarmour_t *)return_value_safe_malloc_1;
  if(self == ((struct _zarmour_t *)NULL))
    return (struct _zarmour_t *)(void *)0;

  else
  {
    self->mode = (enum anonymous_37)ZARMOUR_MODE_BASE64_STD;
    self->pad = (_Bool)1;
    self->pad_char = (char)61;
    self->line_breaks = (_Bool)0;
    self->line_length = (unsigned long int)72;
    self->line_end=strdup("\n");
    if(self->line_end == ((char *)NULL))
    {
      zarmour_destroy(&self);
      return (struct _zarmour_t *)(void *)0;
    }

    else
      return self;
  }
}

// zarmour_pad
// file src/zarmour.c line 566
_Bool zarmour_pad(struct _zarmour_t *self)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  return self->pad;
}

// zarmour_pad_char
// file src/zarmour.c line 583
char zarmour_pad_char(struct _zarmour_t *self)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  return self->pad_char;
}

// zarmour_print
// file src/zarmour.c line 129
void zarmour_print(struct _zarmour_t *self)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  zsys_debug("zarmour:");
  const char *return_value_zarmour_mode_str_1;
  return_value_zarmour_mode_str_1=zarmour_mode_str(self);
  zsys_debug("    mode:        %s", return_value_zarmour_mode_str_1);
  zsys_debug("    pad:         %s", self->pad != (_Bool)0 ? "true" : "false");
  zsys_debug("    pad_char:    '%c'", self->pad_char);
  zsys_debug("    line_breaks: %s", self->line_breaks != (_Bool)0 ? "true" : "false");
  zsys_debug("    line_length: %d", self->line_length);
}

// zarmour_set_line_breaks
// file src/zarmour.c line 608
void zarmour_set_line_breaks(struct _zarmour_t *self, _Bool line_breaks)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  self->line_breaks = line_breaks;
}

// zarmour_set_line_length
// file src/zarmour.c line 625
void zarmour_set_line_length(struct _zarmour_t *self, unsigned long int line_length)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  self->line_length = line_length;
}

// zarmour_set_mode
// file src/zarmour.c line 556
void zarmour_set_mode(struct _zarmour_t *self, enum anonymous_37 mode)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  self->mode = mode;
}

// zarmour_set_pad
// file src/zarmour.c line 573
void zarmour_set_pad(struct _zarmour_t *self, _Bool pad)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  self->pad = pad;
}

// zarmour_set_pad_char
// file src/zarmour.c line 590
void zarmour_set_pad_char(struct _zarmour_t *self, char pad_char)
{
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  self->pad_char = pad_char;
}

// zarmour_test
// file src/zarmour.c line 706
signed int zarmour_test(_Bool verbose)
{
  printf(" * zarmour: ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  struct _zarmour_t *self;
  self=zarmour_new();
  /* assertion self */
  assert(self != ((struct _zarmour_t *)NULL));
  enum anonymous_37 mode;
  mode=zarmour_mode(self);
  /* assertion mode == ZARMOUR_MODE_BASE64_STD */
  assert((signed int)mode == ZARMOUR_MODE_BASE64_STD);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_BASE64_URL);
  mode=zarmour_mode(self);
  /* assertion mode == ZARMOUR_MODE_BASE64_URL */
  assert((signed int)mode == ZARMOUR_MODE_BASE64_URL);
  _Bool return_value_zarmour_pad_1;
  return_value_zarmour_pad_1=zarmour_pad(self);
  /* assertion zarmour_pad (self) */
  assert(return_value_zarmour_pad_1 != (_Bool)0);
  zarmour_set_pad(self, (_Bool)0);
  _Bool return_value_zarmour_pad_2;
  return_value_zarmour_pad_2=zarmour_pad(self);
  /* assertion !zarmour_pad (self) */
  assert(!(return_value_zarmour_pad_2 != (_Bool)0));
  char return_value_zarmour_pad_char_3;
  return_value_zarmour_pad_char_3=zarmour_pad_char(self);
  /* assertion zarmour_pad_char (self) == '=' */
  assert((signed int)return_value_zarmour_pad_char_3 == 61);
  zarmour_set_pad_char(self, (char)33);
  char return_value_zarmour_pad_char_4;
  return_value_zarmour_pad_char_4=zarmour_pad_char(self);
  /* assertion zarmour_pad_char (self) == '!' */
  assert((signed int)return_value_zarmour_pad_char_4 == 33);
  zarmour_set_pad_char(self, (char)61);
  char return_value_zarmour_pad_char_5;
  return_value_zarmour_pad_char_5=zarmour_pad_char(self);
  /* assertion zarmour_pad_char (self) == '=' */
  assert((signed int)return_value_zarmour_pad_char_5 == 61);
  _Bool return_value_zarmour_line_breaks_6;
  return_value_zarmour_line_breaks_6=zarmour_line_breaks(self);
  /* assertion !zarmour_line_breaks (self) */
  assert(!(return_value_zarmour_line_breaks_6 != (_Bool)0));
  zarmour_set_line_breaks(self, (_Bool)1);
  _Bool return_value_zarmour_line_breaks_7;
  return_value_zarmour_line_breaks_7=zarmour_line_breaks(self);
  /* assertion zarmour_line_breaks (self) */
  assert(return_value_zarmour_line_breaks_7 != (_Bool)0);
  unsigned long int return_value_zarmour_line_length_8;
  return_value_zarmour_line_length_8=zarmour_line_length(self);
  /* assertion zarmour_line_length (self) == 72 */
  assert(return_value_zarmour_line_length_8 == (unsigned long int)72);
  zarmour_set_line_length(self, (unsigned long int)64);
  unsigned long int return_value_zarmour_line_length_9;
  return_value_zarmour_line_length_9=zarmour_line_length(self);
  /* assertion zarmour_line_length (self) == 64 */
  assert(return_value_zarmour_line_length_9 == (unsigned long int)64);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_BASE64_STD);
  if(!(verbose == (_Bool)0))
    zarmour_print(self);

  s_armour_test(self, "", "", verbose);
  s_armour_test(self, "f", "Zg", verbose);
  s_armour_test(self, "fo", "Zm8", verbose);
  s_armour_test(self, "foo", "Zm9v", verbose);
  s_armour_test(self, "foob", "Zm9vYg", verbose);
  s_armour_test(self, "fooba", "Zm9vYmE", verbose);
  s_armour_test(self, "foobar", "Zm9vYmFy", verbose);
  zarmour_set_pad(self, (_Bool)1);
  if(!(verbose == (_Bool)0))
    zarmour_print(self);

  s_armour_test(self, "", "", verbose);
  s_armour_test(self, "f", "Zg==", verbose);
  s_armour_test(self, "fo", "Zm8=", verbose);
  s_armour_test(self, "foo", "Zm9v", verbose);
  s_armour_test(self, "foob", "Zm9vYg==", verbose);
  s_armour_test(self, "fooba", "Zm9vYmE=", verbose);
  s_armour_test(self, "foobar", "Zm9vYmFy", verbose);
  zarmour_set_pad(self, (_Bool)0);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_BASE64_URL);
  if(!(verbose == (_Bool)0))
    zarmour_print(self);

  s_armour_test(self, "", "", verbose);
  s_armour_test(self, "f", "Zg", verbose);
  s_armour_test(self, "fo", "Zm8", verbose);
  s_armour_test(self, "foo", "Zm9v", verbose);
  s_armour_test(self, "foob", "Zm9vYg", verbose);
  s_armour_test(self, "fooba", "Zm9vYmE", verbose);
  s_armour_test(self, "foobar", "Zm9vYmFy", verbose);
  zarmour_set_pad(self, (_Bool)1);
  if(!(verbose == (_Bool)0))
    zarmour_print(self);

  s_armour_test(self, "", "", verbose);
  s_armour_test(self, "f", "Zg==", verbose);
  s_armour_test(self, "fo", "Zm8=", verbose);
  s_armour_test(self, "foo", "Zm9v", verbose);
  s_armour_test(self, "foob", "Zm9vYg==", verbose);
  s_armour_test(self, "fooba", "Zm9vYmE=", verbose);
  s_armour_test(self, "foobar", "Zm9vYmFy", verbose);
  zarmour_set_pad(self, (_Bool)0);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_BASE32_STD);
  if(!(verbose == (_Bool)0))
    zarmour_print(self);

  s_armour_test(self, "", "", verbose);
  s_armour_test(self, "f", "MY", verbose);
  s_armour_test(self, "fo", "MZXQ", verbose);
  s_armour_test(self, "foo", "MZXW6", verbose);
  s_armour_test(self, "foob", "MZXW6YQ", verbose);
  s_armour_test(self, "fooba", "MZXW6YTB", verbose);
  s_armour_test(self, "foobar", "MZXW6YTBOI", verbose);
  s_armour_decode(self, "my", "f", verbose);
  s_armour_decode(self, "mzxq", "fo", verbose);
  s_armour_decode(self, "mzxw6", "foo", verbose);
  s_armour_decode(self, "mzxw6yq", "foob", verbose);
  s_armour_decode(self, "mzxw6ytb", "fooba", verbose);
  s_armour_decode(self, "mzxw6ytboi", "foobar", verbose);
  zarmour_set_pad(self, (_Bool)1);
  if(!(verbose == (_Bool)0))
    zarmour_print(self);

  s_armour_test(self, "", "", verbose);
  s_armour_test(self, "f", "MY======", verbose);
  s_armour_test(self, "fo", "MZXQ====", verbose);
  s_armour_test(self, "foo", "MZXW6===", verbose);
  s_armour_test(self, "foob", "MZXW6YQ=", verbose);
  s_armour_test(self, "fooba", "MZXW6YTB", verbose);
  s_armour_test(self, "foobar", "MZXW6YTBOI======", verbose);
  s_armour_decode(self, "my======", "f", verbose);
  s_armour_decode(self, "mzxq====", "fo", verbose);
  s_armour_decode(self, "mzxw6===", "foo", verbose);
  s_armour_decode(self, "mzxw6yq=", "foob", verbose);
  s_armour_decode(self, "mzxw6ytb", "fooba", verbose);
  s_armour_decode(self, "mzxw6ytboi======", "foobar", verbose);
  zarmour_set_pad(self, (_Bool)0);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_BASE32_HEX);
  if(!(verbose == (_Bool)0))
    zarmour_print(self);

  s_armour_test(self, "", "", verbose);
  s_armour_test(self, "f", "CO", verbose);
  s_armour_test(self, "fo", "CPNG", verbose);
  s_armour_test(self, "foo", "CPNMU", verbose);
  s_armour_test(self, "foob", "CPNMUOG", verbose);
  s_armour_test(self, "fooba", "CPNMUOJ1", verbose);
  s_armour_test(self, "foobar", "CPNMUOJ1E8", verbose);
  s_armour_decode(self, "co", "f", verbose);
  s_armour_decode(self, "cpng", "fo", verbose);
  s_armour_decode(self, "cpnmu", "foo", verbose);
  s_armour_decode(self, "cpnmuog", "foob", verbose);
  s_armour_decode(self, "cpnmuoj1", "fooba", verbose);
  s_armour_decode(self, "cpnmuoj1e8", "foobar", verbose);
  zarmour_set_pad(self, (_Bool)1);
  if(!(verbose == (_Bool)0))
    zarmour_print(self);

  s_armour_test(self, "", "", verbose);
  s_armour_test(self, "f", "CO======", verbose);
  s_armour_test(self, "fo", "CPNG====", verbose);
  s_armour_test(self, "foo", "CPNMU===", verbose);
  s_armour_test(self, "foob", "CPNMUOG=", verbose);
  s_armour_test(self, "fooba", "CPNMUOJ1", verbose);
  s_armour_test(self, "foobar", "CPNMUOJ1E8======", verbose);
  s_armour_decode(self, "co======", "f", verbose);
  s_armour_decode(self, "cpng====", "fo", verbose);
  s_armour_decode(self, "cpnmu===", "foo", verbose);
  s_armour_decode(self, "cpnmuog=", "foob", verbose);
  s_armour_decode(self, "cpnmuoj1", "fooba", verbose);
  s_armour_decode(self, "cpnmuoj1e8======", "foobar", verbose);
  zarmour_set_pad(self, (_Bool)1);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_BASE16);
  if(!(verbose == (_Bool)0))
    zarmour_print(self);

  s_armour_test(self, "", "", verbose);
  s_armour_test(self, "f", "66", verbose);
  s_armour_test(self, "fo", "666F", verbose);
  s_armour_test(self, "foo", "666F6F", verbose);
  s_armour_test(self, "foob", "666F6F62", verbose);
  s_armour_test(self, "fooba", "666F6F6261", verbose);
  s_armour_test(self, "foobar", "666F6F626172", verbose);
  s_armour_decode(self, "666f", "fo", verbose);
  s_armour_decode(self, "666f6f", "foo", verbose);
  s_armour_decode(self, "666f6f62", "foob", verbose);
  s_armour_decode(self, "666f6f6261", "fooba", verbose);
  s_armour_decode(self, "666f6f626172", "foobar", verbose);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_BASE16);
  zarmour_set_line_breaks(self, (_Bool)0);
  unsigned long int key_len;
  unsigned char *key_data;
  key_data=zarmour_decode(self, "4E6F87E2FB6EB22A1EF5E257B75D79124949565F0B8B36A878A4F03111C96E0B", &key_len);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_Z85);
  zarmour_set_pad(self, (_Bool)0);
  zarmour_set_line_breaks(self, (_Bool)0);
  if(!(verbose == (_Bool)0))
    zarmour_print(self);

  s_armour_test(self, "", "", verbose);
  s_armour_test(self, "foob", "w]zP%", verbose);
  s_armour_test(self, "foobar!!", "w]zP%vr9Im", verbose);
  s_armour_test(self, (char *)key_data, "ph+{E}!&X?9}!I]W{sm(nL8@&3Yu{wC+<*-5Y[[#", verbose);
  free((void *)key_data);
  zarmour_set_pad(self, (_Bool)1);
  zarmour_set_line_breaks(self, (_Bool)1);
  unsigned char test_data[256l];
  signed int i = 0;
  for( ; !(i >= 256); i = i + 1)
    test_data[(signed long int)i] = (unsigned char)i;
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_BASE64_STD);
  s_armour_test_long(self, test_data, (unsigned long int)256, verbose);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_BASE64_URL);
  s_armour_test_long(self, test_data, (unsigned long int)256, verbose);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_BASE32_STD);
  s_armour_test_long(self, test_data, (unsigned long int)256, verbose);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_BASE32_HEX);
  s_armour_test_long(self, test_data, (unsigned long int)256, verbose);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_BASE16);
  s_armour_test_long(self, test_data, (unsigned long int)256, verbose);
  zarmour_set_mode(self, (enum anonymous_37)ZARMOUR_MODE_Z85);
  s_armour_test_long(self, test_data, (unsigned long int)256, verbose);
  zarmour_destroy(&self);
  printf("OK\n");
  return 0;
}

// zauth
// file src/zauth.c line 428
void zauth(struct _zsock_t *pipe, void *unused)
{
  struct anonymous_26 *self;
  self=s_self_new(pipe);
  _Bool return_value_zpoller_terminated_2;
  if(!(self == ((struct anonymous_26 *)NULL)))
  {
    zsock_signal((void *)pipe, (unsigned char)0);
    while(self->terminated == (_Bool)0)
    {
      struct _zsock_t *which;
      void *return_value_zpoller_wait_1;
      return_value_zpoller_wait_1=zpoller_wait(self->poller, -1);
      which = (struct _zsock_t *)return_value_zpoller_wait_1;
      if(which == self->pipe)
        s_self_handle_pipe(self);

      else
        if(which == self->handler)
          s_self_authenticate(self);

        else
        {
          return_value_zpoller_terminated_2=zpoller_terminated(self->poller);
          if(!(return_value_zpoller_terminated_2 == (_Bool)0))
            break;

        }
    }
    s_self_destroy(&self);
  }

}

// zauth_allow
// file src/zauth_v2.c line 101
void zauth_allow(struct _zauth_t *self, const char *address)
{
  zstr_sendx(self->pipe, "ALLOW", address, (void *)0);
  zsocket_wait(self->pipe);
}

// zauth_configure_curve
// file src/zauth_v2.c line 147
void zauth_configure_curve(struct _zauth_t *self, const char *domain, const char *location)
{
  /* assertion self */
  assert(self != ((struct _zauth_t *)NULL));
  /* assertion domain */
  assert(domain != ((const char *)NULL));
  /* assertion location */
  assert(location != ((const char *)NULL));
  zstr_sendx(self->pipe, "CURVE", domain, location, (void *)0);
  zsocket_wait(self->pipe);
}

// zauth_configure_gssapi
// file src/zauth_v2.c line 163
void zauth_configure_gssapi(struct _zauth_t *self, char *domain)
{
  /* assertion self */
  assert(self != ((struct _zauth_t *)NULL));
  /* assertion domain */
  assert(domain != ((char *)NULL));
  zstr_sendx(self->pipe, "GSSAPI", domain, (void *)0);
  zsocket_wait(self->pipe);
}

// zauth_configure_plain
// file src/zauth_v2.c line 128
void zauth_configure_plain(struct _zauth_t *self, const char *domain, const char *filename)
{
  /* assertion self */
  assert(self != ((struct _zauth_t *)NULL));
  /* assertion domain */
  assert(domain != ((const char *)NULL));
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  zstr_sendx(self->pipe, "PLAIN", domain, filename, (void *)0);
  zsocket_wait(self->pipe);
}

// zauth_deny
// file src/zauth_v2.c line 115
void zauth_deny(struct _zauth_t *self, const char *address)
{
  zstr_sendx(self->pipe, "DENY", address, (void *)0);
  zsocket_wait(self->pipe);
}

// zauth_destroy
// file src/zauth_v2.c line 79
void zauth_destroy(struct _zauth_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zauth_t **)NULL));
  if(!(*self_p == ((struct _zauth_t *)NULL)))
  {
    struct _zauth_t *self = *self_p;
    zstr_send(self->pipe, "TERMINATE");
    char *reply;
    reply=zstr_recv(self->pipe);
    zstr_free(&reply);
    free((void *)self);
    *self_p = (struct _zauth_t *)(void *)0;
  }

}

// zauth_new
// file src/zauth_v2.c line 53
struct _zauth_t * zauth_new(struct _zctx_t *ctx)
{
  struct _zauth_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link28(sizeof(struct _zauth_t) /*8ul*/ , "src/zauth_v2.c", (unsigned int)55);
  self = (struct _zauth_t *)return_value_safe_malloc_1;
  if(self == ((struct _zauth_t *)NULL))
    return (struct _zauth_t *)(void *)0;

  else
  {
    /* assertion ctx */
    assert(ctx != ((struct _zctx_t *)NULL));
    self->pipe=zthread_fork(ctx, s_agent_task, (void *)0);
    if(!(self->pipe == NULL))
    {
      char *status;
      status=zstr_recv(self->pipe);
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(status, "OK");
      if(!(return_value_strcmp_2 == 0))
        zauth_destroy(&self);

      zstr_free(&status);
    }

    else
      zauth_destroy(&self);
    return self;
  }
}

// zauth_set_verbose
// file src/zauth_v2.c line 176
void zauth_set_verbose(struct _zauth_t *self, _Bool verbose)
{
  /* assertion self */
  assert(self != ((struct _zauth_t *)NULL));
  zstr_sendm(self->pipe, "VERBOSE");
  zstr_sendf(self->pipe, "%d", verbose);
  zsocket_wait(self->pipe);
}

// zauth_test
// file src/zauth.c line 486
void zauth_test(_Bool verbose)
{
  printf(" * zauth: ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  zsys_dir_create(".test_zauth");
  struct _zsock_t *server;
  server=zsock_new_checked(8, "src/zauth.c", (unsigned long int)499);
  /* assertion server */
  assert(server != ((struct _zsock_t *)NULL));
  struct _zsock_t *client;
  client=zsock_new_checked(7, "src/zauth.c", (unsigned long int)501);
  /* assertion client */
  assert(client != ((struct _zsock_t *)NULL));
  _Bool success;
  success=s_can_connect(&server, &client);
  /* assertion success */
  assert(success != (_Bool)0);
  struct _zactor_t *auth;
  auth=zactor_new(zauth, (void *)0);
  /* assertion auth */
  assert(auth != ((struct _zactor_t *)NULL));
  if(!(verbose == (_Bool)0))
  {
    zstr_sendx((void *)auth, "VERBOSE", (void *)0);
    zsock_wait((void *)auth);
  }

  success=s_can_connect(&server, &client);
  /* assertion success */
  assert(success != (_Bool)0);
  zsock_set_zap_domain((void *)server, "global");
  success=s_can_connect(&server, &client);
  /* assertion success */
  assert(success != (_Bool)0);
  zsock_set_zap_domain((void *)server, "global");
  zstr_sendx((void *)auth, "DENY", (const void *)"127.0.0.1", (void *)0);
  zsock_wait((void *)auth);
  success=s_can_connect(&server, &client);
  /* assertion !success */
  assert(!(success != (_Bool)0));
  zsock_set_zap_domain((void *)server, "global");
  zstr_sendx((void *)auth, "ALLOW", (const void *)"127.0.0.1", (void *)0);
  zsock_wait((void *)auth);
  success=s_can_connect(&server, &client);
  /* assertion success */
  assert(success != (_Bool)0);
  zsock_set_plain_server((void *)server, 1);
  zsock_set_plain_username((void *)client, "admin");
  zsock_set_plain_password((void *)client, "Password");
  success=s_can_connect(&server, &client);
  /* assertion !success */
  assert(!(success != (_Bool)0));
  struct _IO_FILE *password;
  password=fopen(".test_zauth/password-file", "w");
  /* assertion password */
  assert(password != ((struct _IO_FILE *)NULL));
  fprintf(password, "admin=Password\n");
  fclose(password);
  zsock_set_plain_server((void *)server, 1);
  zsock_set_plain_username((void *)client, "admin");
  zsock_set_plain_password((void *)client, "Password");
  zstr_sendx((void *)auth, "PLAIN", (const void *)".test_zauth/password-file", (void *)0);
  zsock_wait((void *)auth);
  success=s_can_connect(&server, &client);
  /* assertion success */
  assert(success != (_Bool)0);
  zsock_set_plain_server((void *)server, 1);
  zsock_set_plain_username((void *)client, "admin");
  zsock_set_plain_password((void *)client, "Bogus");
  success=s_can_connect(&server, &client);
  /* assertion !success */
  assert(!(success != (_Bool)0));
  _Bool return_value_zsys_has_curve_1;
  return_value_zsys_has_curve_1=zsys_has_curve();
  if(!(return_value_zsys_has_curve_1 == (_Bool)0))
  {
    struct _zcert_t *server_cert;
    server_cert=zcert_new();
    /* assertion server_cert */
    assert(server_cert != ((struct _zcert_t *)NULL));
    struct _zcert_t *client_cert;
    client_cert=zcert_new();
    /* assertion client_cert */
    assert(client_cert != ((struct _zcert_t *)NULL));
    char *server_key;
    server_key=zcert_public_txt(server_cert);
    zcert_apply(server_cert, (void *)server);
    zcert_apply(client_cert, (void *)client);
    zsock_set_curve_server((void *)server, 1);
    zsock_set_curve_serverkey((void *)client, server_key);
    success=s_can_connect(&server, &client);
    /* assertion !success */
    assert(!(success != (_Bool)0));
    zcert_apply(server_cert, (void *)server);
    zcert_apply(client_cert, (void *)client);
    zsock_set_curve_server((void *)server, 1);
    zsock_set_curve_serverkey((void *)client, server_key);
    zstr_sendx((void *)auth, "CURVE", (const void *)"*", (void *)0);
    zsock_wait((void *)auth);
    success=s_can_connect(&server, &client);
    /* assertion success */
    assert(success != (_Bool)0);
    zcert_apply(server_cert, (void *)server);
    zcert_apply(client_cert, (void *)client);
    zsock_set_curve_server((void *)server, 1);
    zsock_set_curve_serverkey((void *)client, server_key);
    zcert_save_public(client_cert, ".test_zauth/mycert.txt");
    zstr_sendx((void *)auth, "CURVE", (const void *)".test_zauth", (void *)0);
    zsock_wait((void *)auth);
    success=s_can_connect(&server, &client);
    /* assertion success */
    assert(success != (_Bool)0);
    zcert_destroy(&server_cert);
    zcert_destroy(&client_cert);
  }

  zactor_destroy(&auth);
  success=s_can_connect(&server, &client);
  /* assertion success */
  assert(success != (_Bool)0);
  zsock_destroy_checked(&client, "src/zauth.c", (unsigned long int)611);
  zsock_destroy_checked(&server, "src/zauth.c", (unsigned long int)612);
  struct _zdir_t *dir;
  dir=zdir_new(".test_zauth", (const char *)(void *)0);
  /* assertion dir */
  assert(dir != ((struct _zdir_t *)NULL));
  zdir_remove(dir, (_Bool)1);
  zdir_destroy(&dir);
  printf("OK\n");
}

// zauth_v2_test
// file src/zauth_v2.c line 642
void zauth_v2_test(_Bool verbose)
{
  printf(" * zauth (deprecated): ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  zsys_dir_create(".test_zauth");
  struct _zctx_t *ctx;
  ctx=zctx_new();
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  struct _zauth_t *auth;
  auth=zauth_new(ctx);
  /* assertion auth */
  assert(auth != ((struct _zauth_t *)NULL));
  zauth_set_verbose(auth, verbose);
  void *server;
  server=zsocket_new(ctx, 8);
  /* assertion server */
  assert(server != NULL);
  void *client;
  client=zsocket_new(ctx, 7);
  /* assertion client */
  assert(client != NULL);
  _Bool success;
  success=s_can_connect_link1(ctx, &server, &client);
  /* assertion success */
  assert(success != (_Bool)0);
  zsocket_set_zap_domain(server, "global");
  success=s_can_connect_link1(ctx, &server, &client);
  /* assertion success */
  assert(success != (_Bool)0);
  zsocket_set_zap_domain(server, "global");
  zauth_deny(auth, "127.0.0.1");
  success=s_can_connect_link1(ctx, &server, &client);
  /* assertion !success */
  assert(!(success != (_Bool)0));
  zsocket_set_zap_domain(server, "global");
  zauth_allow(auth, "127.0.0.1");
  success=s_can_connect_link1(ctx, &server, &client);
  /* assertion success */
  assert(success != (_Bool)0);
  zsocket_set_plain_server(server, 1);
  zsocket_set_plain_username(client, "admin");
  zsocket_set_plain_password(client, "Password");
  success=s_can_connect_link1(ctx, &server, &client);
  /* assertion !success */
  assert(!(success != (_Bool)0));
  struct _IO_FILE *password;
  password=fopen(".test_zauth/password-file", "w");
  /* assertion password */
  assert(password != ((struct _IO_FILE *)NULL));
  fprintf(password, "admin=Password\n");
  fclose(password);
  zsocket_set_plain_server(server, 1);
  zsocket_set_plain_username(client, "admin");
  zsocket_set_plain_password(client, "Password");
  zauth_configure_plain(auth, "*", ".test_zauth/password-file");
  success=s_can_connect_link1(ctx, &server, &client);
  /* assertion success */
  assert(success != (_Bool)0);
  zsocket_set_plain_server(server, 1);
  zsocket_set_plain_username(client, "admin");
  zsocket_set_plain_password(client, "Bogus");
  success=s_can_connect_link1(ctx, &server, &client);
  /* assertion !success */
  assert(!(success != (_Bool)0));
  _Bool return_value_zsys_has_curve_1;
  return_value_zsys_has_curve_1=zsys_has_curve();
  if(!(return_value_zsys_has_curve_1 == (_Bool)0))
  {
    struct _zcert_t *server_cert;
    server_cert=zcert_new();
    /* assertion server_cert */
    assert(server_cert != ((struct _zcert_t *)NULL));
    struct _zcert_t *client_cert;
    client_cert=zcert_new();
    /* assertion client_cert */
    assert(client_cert != ((struct _zcert_t *)NULL));
    char *server_key;
    server_key=zcert_public_txt(server_cert);
    zcert_apply(server_cert, server);
    zcert_apply(client_cert, client);
    zsocket_set_curve_server(server, 1);
    zsocket_set_curve_serverkey(client, server_key);
    success=s_can_connect_link1(ctx, &server, &client);
    /* assertion !success */
    assert(!(success != (_Bool)0));
    zcert_apply(server_cert, server);
    zcert_apply(client_cert, client);
    zsocket_set_curve_server(server, 1);
    zsocket_set_curve_serverkey(client, server_key);
    zauth_configure_curve(auth, "*", "*");
    success=s_can_connect_link1(ctx, &server, &client);
    /* assertion success */
    assert(success != (_Bool)0);
    zcert_apply(server_cert, server);
    zcert_apply(client_cert, client);
    zsocket_set_curve_server(server, 1);
    zsocket_set_curve_serverkey(client, server_key);
    zcert_save_public(client_cert, ".test_zauth/mycert.txt");
    zauth_configure_curve(auth, "*", ".test_zauth");
    success=s_can_connect_link1(ctx, &server, &client);
    /* assertion success */
    assert(success != (_Bool)0);
    zcert_destroy(&server_cert);
    zcert_destroy(&client_cert);
  }

  zauth_destroy(&auth);
  success=s_can_connect_link1(ctx, &server, &client);
  /* assertion success */
  assert(success != (_Bool)0);
  zctx_destroy(&ctx);
  struct _zdir_t *dir;
  dir=zdir_new(".test_zauth", (const char *)(void *)0);
  /* assertion dir */
  assert(dir != ((struct _zdir_t *)NULL));
  zdir_remove(dir, (_Bool)1);
  zdir_destroy(&dir);
  printf("OK\n");
}

// zbeacon
// file src/zbeacon.c line 270
void zbeacon(struct _zsock_t *pipe, void *args)
{
  struct anonymous_36 *self;
  self=s_self_new_link1(pipe);
  /* assertion self */
  assert(self != ((struct anonymous_36 *)NULL));
  zsock_signal((void *)pipe, (unsigned char)0);
  signed long int return_value_zclock_mono_6;
  while(self->terminated == (_Bool)0)
  {
    struct zmq_pollitem_t pollitems[2l];
    void *return_value_zsock_resolve_1;
    return_value_zsock_resolve_1=zsock_resolve((void *)self->pipe);
    pollitems[0] = (struct zmq_pollitem_t){ .socket=return_value_zsock_resolve_1, .fd=0, .events=(signed short int)1,
    .revents=(signed short int)0 };
    pollitems[1] = (struct zmq_pollitem_t){ .socket=(void *)0, .fd=self->udpsock, .events=(signed short int)1, .revents=(signed short int)0 };
    signed long int timeout = (signed long int)-1;
    if(!(self->transmit == ((struct _zframe_t *)NULL)))
    {
      signed long int return_value_zclock_mono_2;
      return_value_zclock_mono_2=zclock_mono();
      timeout = (signed long int)(self->ping_at - return_value_zclock_mono_2);
      if(!(timeout >= 0l))
        timeout = (signed long int)0;

    }

    signed int pollset_size = self->udpsock != 0 ? 2 : 1;
    signed int return_value_zmq_poll_3;
    return_value_zmq_poll_3=zmq_poll(pollitems, pollset_size, timeout * (signed long int)1);
    if(return_value_zmq_poll_3 == -1)
      break;

    if(!((1 & (signed int)pollitems[0l].revents) == 0))
      s_self_handle_pipe_link1(self);

    if(!((1 & (signed int)pollitems[1l].revents) == 0))
      s_self_handle_udp(self);

    if(!(self->transmit == ((struct _zframe_t *)NULL)))
    {
      return_value_zclock_mono_6=zclock_mono();
      if(return_value_zclock_mono_6 >= self->ping_at)
      {
        signed int return_value_zsys_udp_send_4;
        return_value_zsys_udp_send_4=zsys_udp_send(self->udpsock, self->transmit, &self->broadcast);
        if(!(return_value_zsys_udp_send_4 == 0))
          s_self_prepare_udp(self);

        signed long int return_value_zclock_mono_5;
        return_value_zclock_mono_5=zclock_mono();
        self->ping_at = return_value_zclock_mono_5 + (signed long int)self->interval;
      }

    }

  }
  s_self_destroy_link1(&self);
}

// zbeacon_destroy
// file src/zbeacon_v2.c line 95
void zbeacon_destroy(struct _zbeacon_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zbeacon_t **)NULL));
  if(!(*self_p == ((struct _zbeacon_t *)NULL)))
  {
    struct _zbeacon_t *self = *self_p;
    if(!(self->pipe == NULL))
    {
      zstr_send(self->pipe, "TERMINATE");
      char *reply;
      reply=zstr_recv(self->pipe);
      zstr_free(&reply);
    }

    zctx_destroy(&self->ctx);
    free((void *)self->hostname);
    free((void *)self);
    *self_p = (struct _zbeacon_t *)(void *)0;
  }

}

// zbeacon_hostname
// file src/zbeacon_v2.c line 205
char * zbeacon_hostname(struct _zbeacon_t *self)
{
  /* assertion self */
  assert(self != ((struct _zbeacon_t *)NULL));
  return self->hostname;
}

// zbeacon_new
// file src/zbeacon_v2.c line 60
struct _zbeacon_t * zbeacon_new(struct _zctx_t *ctx, signed int port_nbr)
{
  struct _zbeacon_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link29(sizeof(struct _zbeacon_t) /*24ul*/ , "src/zbeacon_v2.c", (unsigned int)62);
  self = (struct _zbeacon_t *)return_value_safe_malloc_1;
  void *return_value_zsys_init_2;
  if(self == ((struct _zbeacon_t *)NULL))
    return (struct _zbeacon_t *)(void *)0;

  else
  {
    if(!(ctx == ((struct _zctx_t *)NULL)))
      self->ctx=zctx_shadow(ctx);

    else
    {
      return_value_zsys_init_2=zsys_init();
      self->ctx=zctx_shadow_zmq_ctx(return_value_zsys_init_2);
    }
    self->pipe=zthread_fork(self->ctx, s_agent_task_link1, (void *)0);
    if(!(self->pipe == NULL))
    {
      zstr_sendf(self->pipe, "%d", port_nbr);
      self->hostname=zstr_recv(self->pipe);
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(self->hostname, "-");
      if(return_value_strcmp_3 == 0)
      {
        free((void *)self->hostname);
        free((void *)self);
        self = (struct _zbeacon_t *)(void *)0;
      }

    }

    else
      zbeacon_destroy(&self);
    return self;
  }
}

// zbeacon_noecho
// file src/zbeacon_v2.c line 129
void zbeacon_noecho(struct _zbeacon_t *self)
{
  /* assertion self */
  assert(self != ((struct _zbeacon_t *)NULL));
  zstr_send(self->pipe, "NOECHO");
}

// zbeacon_publish
// file src/zbeacon_v2.c line 140
void zbeacon_publish(struct _zbeacon_t *self, unsigned char *transmit, unsigned long int size)
{
  /* assertion self */
  assert(self != ((struct _zbeacon_t *)NULL));
  /* assertion transmit */
  assert(transmit != ((unsigned char *)NULL));
  /* assertion size > 0 && size <= 255 */
  assert(size > (unsigned long int)0 && size <= (unsigned long int)255);
  struct _zmsg_t *msg;
  msg=zmsg_new();
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  zmsg_addstr(msg, "PUBLISH");
  zmsg_addmem(msg, (const void *)transmit, size);
  zmsg_send(&msg, self->pipe);
}

// zbeacon_set_interval
// file src/zbeacon_v2.c line 117
void zbeacon_set_interval(struct _zbeacon_t *self, signed int interval)
{
  /* assertion self */
  assert(self != ((struct _zbeacon_t *)NULL));
  zstr_sendm(self->pipe, "INTERVAL");
  zstr_sendf(self->pipe, "%d", interval);
}

// zbeacon_silence
// file src/zbeacon_v2.c line 157
void zbeacon_silence(struct _zbeacon_t *self)
{
  /* assertion self */
  assert(self != ((struct _zbeacon_t *)NULL));
  zstr_send(self->pipe, "SILENCE");
}

// zbeacon_socket
// file src/zbeacon_v2.c line 194
void * zbeacon_socket(struct _zbeacon_t *self)
{
  /* assertion self */
  assert(self != ((struct _zbeacon_t *)NULL));
  return self->pipe;
}

// zbeacon_subscribe
// file src/zbeacon_v2.c line 168
void zbeacon_subscribe(struct _zbeacon_t *self, unsigned char *filter, unsigned long int size)
{
  /* assertion self */
  assert(self != ((struct _zbeacon_t *)NULL));
  /* assertion size <= 255 */
  assert(size <= (unsigned long int)255);
  struct _zmsg_t *msg;
  msg=zmsg_new();
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  zmsg_addstr(msg, "SUBSCRIBE");
  zmsg_addmem(msg, (const void *)filter, size);
  zmsg_send(&msg, self->pipe);
}

// zbeacon_test
// file src/zbeacon.c line 315
void zbeacon_test(_Bool verbose)
{
  printf(" * zbeacon: ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  struct _zactor_t *speaker;
  speaker=zactor_new(zbeacon, (void *)0);
  /* assertion speaker */
  assert(speaker != ((struct _zactor_t *)NULL));
  if(!(verbose == (_Bool)0))
    zstr_sendx((void *)speaker, "VERBOSE", (void *)0);

  zsock_send((void *)speaker, "si", (const void *)"CONFIGURE", 9999);
  char *hostname;
  hostname=zstr_recv((void *)speaker);
  signed long int return_value_zclock_mono_5;
  if(*hostname == 0)
  {
    printf("OK (skipping test, no UDP broadcasting)\n");
    zactor_destroy(&speaker);
    free((void *)hostname);
  }

  else
  {
    free((void *)hostname);
    struct _zactor_t *listener;
    listener=zactor_new(zbeacon, (void *)0);
    /* assertion listener */
    assert(listener != ((struct _zactor_t *)NULL));
    if(!(verbose == (_Bool)0))
      zstr_sendx((void *)listener, "VERBOSE", (void *)0);

    zsock_send((void *)listener, "si", (const void *)"CONFIGURE", 9999);
    hostname=zstr_recv((void *)listener);
    /* assertion *hostname */
    assert(*hostname != 0);
    free((void *)hostname);
    unsigned char announcement[2l] = { (unsigned char)0xCA, (unsigned char)0xFE };
    zsock_send((void *)speaker, "sbi", (const void *)"PUBLISH", (const void *)announcement, 2, 100);
    zsock_send((void *)listener, "sb", (const void *)"SUBSCRIBE", (const void *)"", 0);
    zsock_set_rcvtimeo((void *)listener, 500);
    char *zbeacon_test__1__ipaddress;
    zbeacon_test__1__ipaddress=zstr_recv((void *)listener);
    if(!(zbeacon_test__1__ipaddress == ((char *)NULL)))
    {
      struct _zframe_t *content;
      content=zframe_recv((void *)listener);
      unsigned long int return_value_zframe_size_1;
      return_value_zframe_size_1=zframe_size(content);
      /* assertion zframe_size (content) == 2 */
      assert(return_value_zframe_size_1 == (unsigned long int)2);
      unsigned char *return_value_zframe_data_2;
      return_value_zframe_data_2=zframe_data(content);
      /* assertion zframe_data (content) [0] == 0xCA */
      assert((signed int)return_value_zframe_data_2[(signed long int)0] == 0xCA);
      unsigned char *return_value_zframe_data_3;
      return_value_zframe_data_3=zframe_data(content);
      /* assertion zframe_data (content) [1] == 0xFE */
      assert((signed int)return_value_zframe_data_3[(signed long int)1] == 0xFE);
      zframe_destroy(&content);
      zstr_free(&zbeacon_test__1__ipaddress);
      zstr_sendx((void *)speaker, "SILENCE", (void *)0);
    }

    zactor_destroy(&listener);
    zactor_destroy(&speaker);
    struct _zactor_t *node1;
    node1=zactor_new(zbeacon, (void *)0);
    /* assertion node1 */
    assert(node1 != ((struct _zactor_t *)NULL));
    zsock_send((void *)node1, "si", (const void *)"CONFIGURE", 5670);
    hostname=zstr_recv((void *)node1);
    /* assertion *hostname */
    assert(*hostname != 0);
    free((void *)hostname);
    struct _zactor_t *node2;
    node2=zactor_new(zbeacon, (void *)0);
    /* assertion node2 */
    assert(node2 != ((struct _zactor_t *)NULL));
    zsock_send((void *)node2, "si", (const void *)"CONFIGURE", 5670);
    hostname=zstr_recv((void *)node2);
    /* assertion *hostname */
    assert(*hostname != 0);
    free((void *)hostname);
    struct _zactor_t *node3;
    node3=zactor_new(zbeacon, (void *)0);
    /* assertion node3 */
    assert(node3 != ((struct _zactor_t *)NULL));
    zsock_send((void *)node3, "si", (const void *)"CONFIGURE", 5670);
    hostname=zstr_recv((void *)node3);
    /* assertion *hostname */
    assert(*hostname != 0);
    free((void *)hostname);
    zsock_send((void *)node1, "sbi", (const void *)"PUBLISH", (const void *)"NODE/1", 6, 250);
    zsock_send((void *)node2, "sbi", (const void *)"PUBLISH", (const void *)"NODE/2", 6, 250);
    zsock_send((void *)node3, "sbi", (const void *)"PUBLISH", (const void *)"RANDOM", 6, 250);
    zsock_send((void *)node1, "sb", (const void *)"SUBSCRIBE", (const void *)"NODE", 4);
    struct _zpoller_t *poller;
    poller=zpoller_new((void *)node1, node2, node3, (void *)0);
    /* assertion poller */
    assert(poller != ((struct _zpoller_t *)NULL));
    signed long int stop_at;
    signed long int return_value_zclock_mono_4;
    return_value_zclock_mono_4=zclock_mono();
    stop_at = return_value_zclock_mono_4 + (signed long int)1000;
    do
    {
      return_value_zclock_mono_5=zclock_mono();
      if(return_value_zclock_mono_5 >= stop_at)
        break;

      signed long int timeout;
      signed long int return_value_zclock_mono_6;
      return_value_zclock_mono_6=zclock_mono();
      timeout = (signed long int)(stop_at - return_value_zclock_mono_6);
      if(!(timeout >= 0l))
        timeout = (signed long int)0;

      void *which;
      which=zpoller_wait(poller, (signed int)(timeout * (signed long int)1));
      if(!(which == NULL))
      {
        /* assertion which == node1 */
        assert((struct _zactor_t *)which == node1);
        char *ipaddress;
        char *received;
        zstr_recvx((void *)node1, &ipaddress, &received, (void *)0);
        signed int return_value_strcmp_7;
        return_value_strcmp_7=strcmp(received, "NODE/2");
        /* assertion (!strcmp ((received), ("NODE/2"))) */
        assert(!(return_value_strcmp_7 != 0));
        zstr_free(&ipaddress);
        zstr_free(&received);
      }

    }
    while((_Bool)1);
    zpoller_destroy(&poller);
    zstr_sendx((void *)node1, "UNSUBSCRIBE", (void *)0);
    zstr_sendx((void *)node1, "SILENCE", (void *)0);
    zstr_sendx((void *)node2, "SILENCE", (void *)0);
    zstr_sendx((void *)node3, "SILENCE", (void *)0);
    zactor_destroy(&node1);
    zactor_destroy(&node2);
    zactor_destroy(&node3);
    printf("OK\n");
  }
}

// zbeacon_unsubscribe
// file src/zbeacon_v2.c line 184
void zbeacon_unsubscribe(struct _zbeacon_t *self)
{
  zstr_send(self->pipe, "UNSUBSCRIBE");
}

// zbeacon_v2_test
// file src/zbeacon_v2.c line 499
void zbeacon_v2_test(_Bool verbose)
{
  printf(" * zbeacon (deprecated): ");
  struct _zctx_t *ctx;
  ctx=zctx_new();
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  struct _zbeacon_t *service_beacon;
  service_beacon=zbeacon_new(ctx, 9999);
  signed long int return_value_zclock_mono_13;
  if(service_beacon == ((struct _zbeacon_t *)NULL))
    printf("OK (skipping test, no UDP discovery)\n");

  else
  {
    struct _zsock_t *service;
    service=zsock_new_checked(1, "src/zbeacon_v2.c", (unsigned long int)513);
    /* assertion service */
    assert(service != ((struct _zsock_t *)NULL));
    signed int port_nbr;
    port_nbr=zsock_bind(service, "tcp://127.0.0.1:*");
    unsigned char announcement[2l] = { (unsigned char)(port_nbr >> 8 & 0xFF), (unsigned char)(port_nbr & 0xFF) };
    zbeacon_set_interval(service_beacon, 100);
    zbeacon_publish(service_beacon, announcement, (unsigned long int)2);
    struct _zbeacon_t *client_beacon;
    client_beacon=zbeacon_new(ctx, 9999);
    /* assertion client_beacon */
    assert(client_beacon != ((struct _zbeacon_t *)NULL));
    zbeacon_subscribe(client_beacon, (unsigned char *)(void *)0, (unsigned long int)0);
    void *return_value_zbeacon_socket_1;
    return_value_zbeacon_socket_1=zbeacon_socket(client_beacon);
    zsocket_set_rcvtimeo(return_value_zbeacon_socket_1, 500);
    char *ipaddress;
    void *return_value_zbeacon_socket_2;
    return_value_zbeacon_socket_2=zbeacon_socket(client_beacon);
    ipaddress=zstr_recv(return_value_zbeacon_socket_2);
    if(!(ipaddress == ((char *)NULL)))
    {
      struct _zframe_t *content;
      void *return_value_zbeacon_socket_3;
      return_value_zbeacon_socket_3=zbeacon_socket(client_beacon);
      content=zframe_recv(return_value_zbeacon_socket_3);
      signed int received_port;
      unsigned char *return_value_zframe_data_4;
      return_value_zframe_data_4=zframe_data(content);
      unsigned char *return_value_zframe_data_5;
      return_value_zframe_data_5=zframe_data(content);
      received_port = ((signed int)return_value_zframe_data_4[(signed long int)0] << 8) + (signed int)return_value_zframe_data_5[(signed long int)1];
      /* assertion received_port == port_nbr */
      assert(received_port == port_nbr);
      zframe_destroy(&content);
      zbeacon_silence(service_beacon);
      zstr_free(&ipaddress);
    }

    zbeacon_destroy(&client_beacon);
    zbeacon_destroy(&service_beacon);
    struct _zbeacon_t *node1;
    node1=zbeacon_new(ctx, 5670);
    /* assertion node1 */
    assert(node1 != ((struct _zbeacon_t *)NULL));
    struct _zbeacon_t *node2;
    node2=zbeacon_new(ctx, 5670);
    /* assertion node2 */
    assert(node2 != ((struct _zbeacon_t *)NULL));
    struct _zbeacon_t *node3;
    node3=zbeacon_new(ctx, 5670);
    /* assertion node3 */
    assert(node3 != ((struct _zbeacon_t *)NULL));
    char *return_value_zbeacon_hostname_6;
    return_value_zbeacon_hostname_6=zbeacon_hostname(node1);
    /* assertion *zbeacon_hostname (node1) */
    assert(*return_value_zbeacon_hostname_6 != 0);
    char *return_value_zbeacon_hostname_7;
    return_value_zbeacon_hostname_7=zbeacon_hostname(node2);
    /* assertion *zbeacon_hostname (node2) */
    assert(*return_value_zbeacon_hostname_7 != 0);
    char *return_value_zbeacon_hostname_8;
    return_value_zbeacon_hostname_8=zbeacon_hostname(node3);
    /* assertion *zbeacon_hostname (node3) */
    assert(*return_value_zbeacon_hostname_8 != 0);
    zbeacon_set_interval(node1, 250);
    zbeacon_set_interval(node2, 250);
    zbeacon_set_interval(node3, 250);
    zbeacon_noecho(node1);
    zbeacon_publish(node1, (unsigned char *)"NODE/1", (unsigned long int)6);
    zbeacon_publish(node2, (unsigned char *)"NODE/2", (unsigned long int)6);
    zbeacon_publish(node3, (unsigned char *)"GARBAGE", (unsigned long int)7);
    zbeacon_subscribe(node1, (unsigned char *)"NODE", (unsigned long int)4);
    struct _zpoller_t *poller;
    void *return_value_zbeacon_socket_9;
    return_value_zbeacon_socket_9=zbeacon_socket(node1);
    void *return_value_zbeacon_socket_10;
    return_value_zbeacon_socket_10=zbeacon_socket(node2);
    void *return_value_zbeacon_socket_11;
    return_value_zbeacon_socket_11=zbeacon_socket(node3);
    poller=zpoller_new(return_value_zbeacon_socket_9, return_value_zbeacon_socket_10, return_value_zbeacon_socket_11, (void *)0);
    /* assertion poller */
    assert(poller != ((struct _zpoller_t *)NULL));
    signed long int stop_at;
    signed long int return_value_zclock_mono_12;
    return_value_zclock_mono_12=zclock_mono();
    stop_at = return_value_zclock_mono_12 + (signed long int)1000;
    do
    {
      return_value_zclock_mono_13=zclock_mono();
      if(return_value_zclock_mono_13 >= stop_at)
        break;

      signed long int timeout;
      signed long int return_value_zclock_mono_14;
      return_value_zclock_mono_14=zclock_mono();
      timeout = (signed long int)(stop_at - return_value_zclock_mono_14);
      if(!(timeout >= 0l))
        timeout = (signed long int)0;

      void *which;
      which=zpoller_wait(poller, (signed int)(timeout * (signed long int)1));
      if(!(which == NULL))
      {
        void *return_value_zbeacon_socket_15;
        return_value_zbeacon_socket_15=zbeacon_socket(node1);
        /* assertion which == zbeacon_socket (node1) */
        assert(which == return_value_zbeacon_socket_15);
        char *zbeacon_v2_test__1__3__1__ipaddress;
        char *beacon;
        void *return_value_zbeacon_socket_16;
        return_value_zbeacon_socket_16=zbeacon_socket(node1);
        zstr_recvx(return_value_zbeacon_socket_16, &zbeacon_v2_test__1__3__1__ipaddress, &beacon, (void *)0);
        signed int return_value_strcmp_17;
        return_value_strcmp_17=strcmp(beacon, "NODE/2");
        /* assertion (!strcmp ((beacon), ("NODE/2"))) */
        assert(!(return_value_strcmp_17 != 0));
        zstr_free(&zbeacon_v2_test__1__3__1__ipaddress);
        zstr_free(&beacon);
      }

    }
    while((_Bool)1);
    zpoller_destroy(&poller);
    zbeacon_unsubscribe(node1);
    zbeacon_silence(node1);
    zbeacon_silence(node2);
    zbeacon_silence(node3);
    zbeacon_destroy(&node1);
    zbeacon_destroy(&node2);
    zbeacon_destroy(&node3);
    zsock_destroy_checked(&service, "src/zbeacon_v2.c", (unsigned long int)598);
    zctx_destroy(&ctx);
    printf("OK\n");
  }
}

// zcert_apply
// file src/../include/zcert.h line 86
void zcert_apply(struct _zcert_t *self, void *zocket)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  void *handle;
  handle=zsock_resolve(zocket);
  _Bool return_value_zsys_has_curve_1;
  return_value_zsys_has_curve_1=zsys_has_curve();
  if(!(return_value_zsys_has_curve_1 == (_Bool)0))
  {
    zsock_set_curve_secretkey_bin(handle, self->secret_key);
    zsock_set_curve_publickey_bin(handle, self->public_key);
  }

}

// zcert_destroy
// file src/../include/zcert.h line 33
void zcert_destroy(struct _zcert_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zcert_t **)NULL));
  if(!(*self_p == ((struct _zcert_t *)NULL)))
  {
    struct _zcert_t *self = *self_p;
    zhash_destroy(&self->metadata);
    zconfig_destroy(&self->config);
    free((void *)self);
    *self_p = (struct _zcert_t *)(void *)0;
  }

}

// zcert_dup
// file src/zcert.c line 364
struct _zcert_t * zcert_dup(struct _zcert_t *self)
{
  if(!(self == ((struct _zcert_t *)NULL)))
  {
    struct _zcert_t *copy;
    copy=zcert_new_from(self->public_key, self->secret_key);
    if(!(copy == ((struct _zcert_t *)NULL)))
    {
      zhash_destroy(&copy->metadata);
      copy->metadata=zhash_dup(self->metadata);
      if(copy->metadata == ((struct _zhash_t *)NULL))
        zcert_destroy(&copy);

    }

    return copy;
  }

  else
    return (struct _zcert_t *)(void *)0;
}

// zcert_eq
// file src/zcert.c line 385
_Bool zcert_eq(struct _zcert_t *self, struct _zcert_t *compare)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  /* assertion compare */
  assert(compare != ((struct _zcert_t *)NULL));
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(self->public_txt, compare->public_txt);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(return_value_strcmp_1 == 0)
  {
    return_value_strcmp_2=strcmp(self->secret_txt, compare->secret_txt);
    tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  return tmp_if_expr_3;
}

// zcert_fprint
// file src/zcert.c line 421
void zcert_fprint(struct _zcert_t *self, struct _IO_FILE *file)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  fprintf(file, "metadata\n");
  char *value;
  void *return_value_zhash_first_1;
  return_value_zhash_first_1=zhash_first(self->metadata);
  value = (char *)return_value_zhash_first_1;
  while(!(value == ((char *)NULL)))
  {
    const char *return_value_zhash_cursor_2;
    return_value_zhash_cursor_2=zhash_cursor(self->metadata);
    fprintf(file, "    %s = \"%s\"\n", return_value_zhash_cursor_2, value);
    void *return_value_zhash_next_3;
    return_value_zhash_next_3=zhash_next(self->metadata);
    value = (char *)return_value_zhash_next_3;
  }
  fprintf(file, "curve\n");
  fprintf(file, "    public-key = \"%s\"\n", (const void *)self->public_txt);
  fprintf(file, "    secret-key = \"%s\"\n", (const void *)self->secret_txt);
}

// zcert_load
// file src/zcert.c line 211
struct _zcert_t * zcert_load(const char *filename)
{
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  char filename_secret[256l];
  snprintf(filename_secret, (unsigned long int)256, "%s_secret", filename);
  struct _zconfig_t *root;
  root=zconfig_load(filename_secret);
  if(root == ((struct _zconfig_t *)NULL))
    root=zconfig_load(filename);

  struct _zcert_t *self = (struct _zcert_t *)(void *)0;
  unsigned long int return_value_strlen_6;
  unsigned long int return_value_strlen_1;
  struct _zconfig_t *return_value_zconfig_child_2;
  if(!(root == ((struct _zconfig_t *)NULL)))
  {
    char *public_text;
    public_text=zconfig_get(root, "/curve/public-key", (const char *)(void *)0);
    if(!(public_text == ((char *)NULL)))
    {
      return_value_strlen_6=strlen(public_text);
      if(return_value_strlen_6 == 40ul)
      {
        unsigned char public_key[32l] = { (unsigned char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        unsigned char secret_key[32l] = { (unsigned char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        char *secret_text;
        secret_text=zconfig_get(root, "/curve/secret-key", (const char *)(void *)0);
        zmq_z85_decode(public_key, public_text);
        if(!(secret_text == ((char *)NULL)))
        {
          return_value_strlen_1=strlen(secret_text);
          if(return_value_strlen_1 == 40ul)
            zmq_z85_decode(secret_key, secret_text);

        }

        self=zcert_new_from(public_key, secret_key);
        struct _zconfig_t *metadata;
        metadata=zconfig_locate(root, "/metadata");
        struct _zconfig_t *item;
        struct _zconfig_t *tmp_if_expr_3;
        if(!(metadata == ((struct _zconfig_t *)NULL)))
        {
          return_value_zconfig_child_2=zconfig_child(metadata);
          tmp_if_expr_3 = return_value_zconfig_child_2;
        }

        else
          tmp_if_expr_3 = (struct _zconfig_t *)(void *)0;
        item = tmp_if_expr_3;
        while(!(item == ((struct _zconfig_t *)NULL)))
        {
          char *return_value_zconfig_name_4;
          return_value_zconfig_name_4=zconfig_name(item);
          char *return_value_zconfig_value_5;
          return_value_zconfig_value_5=zconfig_value(item);
          zcert_set_meta(self, return_value_zconfig_name_4, return_value_zconfig_value_5);
          item=zconfig_next(item);
        }
      }

    }

  }

  zconfig_destroy(&root);
  return self;
}

// zcert_meta
// file src/zcert.c line 188
char * zcert_meta(struct _zcert_t *self, const char *name)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  void *return_value_zhash_lookup_1;
  return_value_zhash_lookup_1=zhash_lookup(self->metadata, name);
  return (char *)return_value_zhash_lookup_1;
}

// zcert_meta_keys
// file src/zcert.c line 200
struct _zlist_t * zcert_meta_keys(struct _zcert_t *self)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  struct _zlist_t *return_value_zhash_keys_1;
  return_value_zhash_keys_1=zhash_keys(self->metadata);
  return return_value_zhash_keys_1;
}

// zcert_new
// file src/../include/zcert.h line 25
struct _zcert_t * zcert_new(void)
{
  unsigned char public_key[32l] = { (unsigned char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  unsigned char secret_key[32l] = { (unsigned char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  _Bool return_value_zsys_has_curve_1;
  return_value_zsys_has_curve_1=zsys_has_curve();
  if(!(return_value_zsys_has_curve_1 == (_Bool)0))
  {
    char public_txt[41l];
    char secret_txt[41l];
    signed int rc;
    rc=zmq_curve_keypair(public_txt, secret_txt);
    if(!(rc == 0))
      return (struct _zcert_t *)(void *)0;

    zmq_z85_decode(public_key, public_txt);
    zmq_z85_decode(secret_key, secret_txt);
  }

  struct _zcert_t *return_value_zcert_new_from_2;
  return_value_zcert_new_from_2=zcert_new_from(public_key, secret_key);
  return return_value_zcert_new_from_2;
}

// zcert_new_from
// file src/zcert.c line 79
struct _zcert_t * zcert_new_from(unsigned char *public_key, unsigned char *secret_key)
{
  struct _zcert_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link4(sizeof(struct _zcert_t) /*168ul*/ , "src/zcert.c", (unsigned int)81);
  self = (struct _zcert_t *)return_value_safe_malloc_1;
  if(self == ((struct _zcert_t *)NULL))
    return (struct _zcert_t *)(void *)0;

  else
  {
    /* assertion public_key */
    assert(public_key != ((unsigned char *)NULL));
    /* assertion secret_key */
    assert(secret_key != ((unsigned char *)NULL));
    self->metadata=zhash_new();
    if(!(self->metadata == ((struct _zhash_t *)NULL)))
    {
      zhash_autofree(self->metadata);
      memcpy((void *)self->public_key, (const void *)public_key, (unsigned long int)32);
      memcpy((void *)self->secret_key, (const void *)secret_key, (unsigned long int)32);
      zmq_z85_encode(self->public_txt, self->public_key, (unsigned long int)32);
      zmq_z85_encode(self->secret_txt, self->secret_key, (unsigned long int)32);
    }

    else
      zcert_destroy(&self);
    return self;
  }
}

// zcert_print
// file src/zcert.c line 399
void zcert_print(struct _zcert_t *self)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  zsys_info("zcert: metadata");
  char *value;
  void *return_value_zhash_first_1;
  return_value_zhash_first_1=zhash_first(self->metadata);
  value = (char *)return_value_zhash_first_1;
  while(!(value == ((char *)NULL)))
  {
    const char *return_value_zhash_cursor_2;
    return_value_zhash_cursor_2=zhash_cursor(self->metadata);
    zsys_info("zcert:     %s = \"%s\"", return_value_zhash_cursor_2, value);
    void *return_value_zhash_next_3;
    return_value_zhash_next_3=zhash_next(self->metadata);
    value = (char *)return_value_zhash_next_3;
  }
  zsys_info("zcert: curve");
  zsys_info("zcert:     public-key = \"%s\"", (const void *)self->public_txt);
  zsys_info("zcert:     secret-key = \"%s\"", (const void *)self->secret_txt);
}

// zcert_public_key
// file src/zcert.c line 127
unsigned char * zcert_public_key(struct _zcert_t *self)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  return self->public_key;
}

// zcert_public_txt
// file src/../include/zcert.h line 45
char * zcert_public_txt(struct _zcert_t *self)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  return self->public_txt;
}

// zcert_save
// file src/zcert.c line 277
signed int zcert_save(struct _zcert_t *self, const char *filename)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  zcert_save_public(self, filename);
  char filename_secret[256l];
  snprintf(filename_secret, (unsigned long int)256, "%s_secret", filename);
  signed int rc;
  rc=zcert_save_secret(self, filename_secret);
  return rc;
}

// zcert_save_public
// file src/../include/zcert.h line 76
signed int zcert_save_public(struct _zcert_t *self, const char *filename)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  s_save_metadata_all(self);
  zconfig_set_comment(self->config, "   ZeroMQ CURVE Public Certificate");
  zconfig_set_comment(self->config, "   Exchange securely, or use a secure mechanism to verify the contents");
  zconfig_set_comment(self->config, "   of this file after exchange. Store public certificates in your home");
  zconfig_set_comment(self->config, "   directory, in the .curve subdirectory.");
  zconfig_put(self->config, "/curve/public-key", self->public_txt);
  signed int rc;
  rc=zconfig_save(self->config, filename);
  return rc;
}

// zcert_save_secret
// file src/zcert.c line 320
signed int zcert_save_secret(struct _zcert_t *self, const char *filename)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  s_save_metadata_all(self);
  zconfig_set_comment(self->config, "   ZeroMQ CURVE **Secret** Certificate");
  zconfig_set_comment(self->config, "   DO NOT PROVIDE THIS FILE TO OTHER USERS nor change its permissions.");
  zconfig_put(self->config, "/curve/public-key", self->public_txt);
  zconfig_put(self->config, "/curve/secret-key", self->secret_txt);
  zsys_file_mode_private();
  signed int rc;
  rc=zconfig_save(self->config, filename);
  zsys_file_mode_default();
  return rc;
}

// zcert_secret_key
// file src/zcert.c line 138
unsigned char * zcert_secret_key(struct _zcert_t *self)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  return self->secret_key;
}

// zcert_secret_txt
// file src/zcert.c line 160
char * zcert_secret_txt(struct _zcert_t *self)
{
  /* assertion self */
  assert(self != ((struct _zcert_t *)NULL));
  return self->secret_txt;
}

// zcert_set_meta
// file src/zcert.c line 171
void zcert_set_meta(struct _zcert_t *self, const char *name, const char *format, ...)
{
  void **argptr = (void **)&format;
  char *value;
  value=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  /* assertion value */
  assert(value != ((char *)NULL));
  zhash_insert(self->metadata, name, (void *)value);
  free((void *)value);
}

// zcert_test
// file src/zcert.c line 441
void zcert_test(_Bool verbose)
{
  printf(" * zcert: ");
  zsys_dir_create(".test_zcert");
  struct _zcert_t *cert;
  cert=zcert_new();
  /* assertion cert */
  assert(cert != ((struct _zcert_t *)NULL));
  zcert_set_meta(cert, "email", "ph@imatix.com");
  zcert_set_meta(cert, "name", "Pieter Hintjens");
  zcert_set_meta(cert, "organization", "iMatix Corporation");
  zcert_set_meta(cert, "version", "%d", 1);
  char *return_value_zcert_meta_1;
  return_value_zcert_meta_1=zcert_meta(cert, "email");
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(return_value_zcert_meta_1, "ph@imatix.com");
  /* assertion (!strcmp ((zcert_meta (cert, "email")), ("ph@imatix.com"))) */
  assert(!(return_value_strcmp_2 != 0));
  struct _zlist_t *keys;
  keys=zcert_meta_keys(cert);
  unsigned long int return_value_zlist_size_3;
  return_value_zlist_size_3=zlist_size(keys);
  /* assertion zlist_size (keys) == 4 */
  assert(return_value_zlist_size_3 == (unsigned long int)4);
  zlist_destroy(&keys);
  struct _zcert_t *shadow;
  shadow=zcert_dup(cert);
  _Bool return_value_zcert_eq_4;
  return_value_zcert_eq_4=zcert_eq(cert, shadow);
  /* assertion zcert_eq (cert, shadow) */
  assert(return_value_zcert_eq_4 != (_Bool)0);
  zcert_destroy(&shadow);
  zcert_save(cert, ".test_zcert/mycert.txt");
  _Bool return_value_zsys_file_exists_5;
  return_value_zsys_file_exists_5=zsys_file_exists(".test_zcert/mycert.txt");
  /* assertion zsys_file_exists (".test_zcert" "/mycert.txt") */
  assert(return_value_zsys_file_exists_5 != (_Bool)0);
  _Bool return_value_zsys_file_exists_6;
  return_value_zsys_file_exists_6=zsys_file_exists(".test_zcert/mycert.txt_secret");
  /* assertion zsys_file_exists (".test_zcert" "/mycert.txt_secret") */
  assert(return_value_zsys_file_exists_6 != (_Bool)0);
  shadow=zcert_load(".test_zcert/mycert.txt");
  /* assertion shadow */
  assert(shadow != ((struct _zcert_t *)NULL));
  _Bool return_value_zcert_eq_7;
  return_value_zcert_eq_7=zcert_eq(cert, shadow);
  /* assertion zcert_eq (cert, shadow) */
  assert(return_value_zcert_eq_7 != (_Bool)0);
  zcert_destroy(&shadow);
  signed int rc;
  rc=zsys_file_delete(".test_zcert/mycert.txt_secret");
  /* assertion rc == 0 */
  assert(rc == 0);
  shadow=zcert_load(".test_zcert/mycert.txt");
  char *return_value_zcert_secret_txt_8;
  return_value_zcert_secret_txt_8=zcert_secret_txt(shadow);
  signed int return_value_strcmp_9;
  return_value_strcmp_9=strcmp(return_value_zcert_secret_txt_8, "0000000000000000000000000000000000000000");
  /* assertion (!strcmp ((zcert_secret_txt (shadow)), ("0000000000000000000000000000000000000000"))) */
  assert(!(return_value_strcmp_9 != 0));
  zcert_destroy(&shadow);
  zcert_destroy(&cert);
  struct _zdir_t *dir;
  dir=zdir_new(".test_zcert", (const char *)(void *)0);
  /* assertion dir */
  assert(dir != ((struct _zdir_t *)NULL));
  zdir_remove(dir, (_Bool)1);
  zdir_destroy(&dir);
  printf("OK\n");
}

// zcertstore_destroy
// file src/../include/zcertstore.h line 35
void zcertstore_destroy(struct _zcertstore_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zcertstore_t **)NULL));
  if(!(*self_p == ((struct _zcertstore_t *)NULL)))
  {
    struct _zcertstore_t *self = *self_p;
    zhashx_destroy(&self->certs);
    free((void *)self->location);
    free((void *)self);
    *self_p = (struct _zcertstore_t *)(void *)0;
  }

}

// zcertstore_fprint
// file src/zcertstore.c line 207
void zcertstore_fprint(struct _zcertstore_t *self, struct _IO_FILE *file)
{
  if(!(self->location == ((char *)NULL)))
    fprintf(file, "Certificate store at %s:\n", self->location);

  else
    fprintf(file, "Certificate store\n");
  struct _zcert_t *cert;
  void *return_value_zhashx_first_1;
  return_value_zhashx_first_1=zhashx_first(self->certs);
  cert = (struct _zcert_t *)return_value_zhashx_first_1;
  while(!(cert == ((struct _zcert_t *)NULL)))
  {
    zcert_fprint(cert, file);
    void *return_value_zhashx_next_2;
    return_value_zhashx_next_2=zhashx_next(self->certs);
    cert = (struct _zcert_t *)return_value_zhashx_next_2;
  }
}

// zcertstore_insert
// file src/zcertstore.c line 175
void zcertstore_insert(struct _zcertstore_t *self, struct _zcert_t **cert_p)
{
  signed int rc;
  char *return_value_zcert_public_txt_1;
  return_value_zcert_public_txt_1=zcert_public_txt(*cert_p);
  rc=zhashx_insert(self->certs, (const void *)return_value_zcert_public_txt_1, (void *)*cert_p);
  /* assertion rc == 0 */
  assert(rc == 0);
  *cert_p = (struct _zcert_t *)(void *)0;
}

// zcertstore_lookup
// file src/../include/zcertstore.h line 40
struct _zcert_t * zcertstore_lookup(struct _zcertstore_t *self, const char *public_key)
{
  signed long int return_value_zdir_modified_1;
  unsigned long int return_value_zdir_count_2;
  signed long int return_value_zdir_cursize_4;
  if(!(self->location == ((char *)NULL)))
  {
    struct _zdir_t *dir;
    dir=zdir_new(self->location, (const char *)(void *)0);
    if(!(dir == ((struct _zdir_t *)NULL)))
    {
      return_value_zdir_modified_1=zdir_modified(dir);
      _Bool tmp_if_expr_3;
      if(!(self->modified == return_value_zdir_modified_1))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_zdir_count_2=zdir_count(dir);
        tmp_if_expr_3 = self->count != return_value_zdir_count_2 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_5;
      if(tmp_if_expr_3)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_zdir_cursize_4=zdir_cursize(dir);
        tmp_if_expr_5 = self->cursize != (unsigned long int)return_value_zdir_cursize_4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        s_load_certs_from_disk(self);

    }

    zdir_destroy(&dir);
  }

  void *return_value_zhashx_lookup_6;
  return_value_zhashx_lookup_6=zhashx_lookup(self->certs, (const void *)public_key);
  return (struct _zcert_t *)return_value_zhashx_lookup_6;
}

// zcertstore_new
// file src/../include/zcertstore.h line 30
struct _zcertstore_t * zcertstore_new(const char *location)
{
  struct _zcertstore_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link5(sizeof(struct _zcertstore_t) /*40ul*/ , "src/zcertstore.c", (unsigned int)68);
  self = (struct _zcertstore_t *)return_value_safe_malloc_1;
  if(self == ((struct _zcertstore_t *)NULL))
    return (struct _zcertstore_t *)(void *)0;

  else
  {
    self->certs=zhashx_new();
    if(!(self->certs == ((struct _zhashx_t *)NULL)))
    {
      zhashx_set_destructor(self->certs, (void (*)(void **))zcert_destroy);
      if(!(location == ((const char *)NULL)))
      {
        self->location=strdup(location);
        if(self->location == ((char *)NULL))
        {
          zcertstore_destroy(&self);
          return (struct _zcertstore_t *)(void *)0;
        }

        s_load_certs_from_disk(self);
      }

    }

    else
      zcertstore_destroy(&self);
    return self;
  }
}

// zcertstore_print
// file src/zcertstore.c line 187
void zcertstore_print(struct _zcertstore_t *self)
{
  if(!(self->location == ((char *)NULL)))
    zsys_info("zcertstore: certificates at location=%s:", self->location);

  else
    zsys_info("zcertstore: certificates in memory");
  struct _zcert_t *cert;
  void *return_value_zhashx_first_1;
  return_value_zhashx_first_1=zhashx_first(self->certs);
  cert = (struct _zcert_t *)return_value_zhashx_first_1;
  while(!(cert == ((struct _zcert_t *)NULL)))
  {
    zcert_print(cert);
    void *return_value_zhashx_next_2;
    return_value_zhashx_next_2=zhashx_next(self->certs);
    cert = (struct _zcert_t *)return_value_zhashx_next_2;
  }
}

// zcertstore_test
// file src/zcertstore.c line 226
void zcertstore_test(_Bool verbose)
{
  printf(" * zcertstore: ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  zsys_dir_create(".test_zcertstore");
  struct _zcertstore_t *certstore;
  certstore=zcertstore_new(".test_zcertstore");
  /* assertion certstore */
  assert(certstore != ((struct _zcertstore_t *)NULL));
  struct _zcert_t *cert;
  cert=zcert_new();
  /* assertion cert */
  assert(cert != ((struct _zcert_t *)NULL));
  char *client_key;
  char *return_value_zcert_public_txt_1;
  return_value_zcert_public_txt_1=zcert_public_txt(cert);
  client_key=strdup(return_value_zcert_public_txt_1);
  /* assertion client_key */
  assert(client_key != ((char *)NULL));
  zcert_set_meta(cert, "name", "John Doe");
  zcert_save(cert, ".test_zcertstore/mycert.txt");
  zcert_destroy(&cert);
  cert=zcertstore_lookup(certstore, client_key);
  /* assertion cert */
  assert(cert != ((struct _zcert_t *)NULL));
  char *return_value_zcert_meta_2;
  return_value_zcert_meta_2=zcert_meta(cert, "name");
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(return_value_zcert_meta_2, "John Doe");
  /* assertion (!strcmp ((zcert_meta (cert, "name")), ("John Doe"))) */
  assert(!(return_value_strcmp_3 != 0));
  free((void *)client_key);
  if(!(verbose == (_Bool)0))
    zcertstore_print(certstore);

  zcertstore_destroy(&certstore);
  struct _zdir_t *dir;
  dir=zdir_new(".test_zcertstore", (const char *)(void *)0);
  /* assertion dir */
  assert(dir != ((struct _zdir_t *)NULL));
  zdir_remove(dir, (_Bool)1);
  zdir_destroy(&dir);
  printf("OK\n");
}

// zchunk_append
// file src/zchunk.c line 193
unsigned long int zchunk_append(struct _zchunk_t *self, const void *data, unsigned long int size)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  zdigest_destroy(&self->digest);
  if(!(self->max_size >= self->size + size))
    size = self->max_size - self->size;

  memcpy((void *)(self->data + (signed long int)self->size), data, size);
  self->size = self->size + size;
  return self->size;
}

// zchunk_consume
// file src/zchunk.c line 244
unsigned long int zchunk_consume(struct _zchunk_t *self, struct _zchunk_t *source)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  /* assertion source */
  assert(source != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_2;
  return_value_zchunk_is_2=zchunk_is((void *)source);
  /* assertion zchunk_is (source) */
  assert(return_value_zchunk_is_2 != (_Bool)0);
  unsigned long int size = source->size - source->consumed;
  if(!(self->max_size >= self->size + size))
    size = self->max_size - self->size;

  memcpy((void *)(self->data + (signed long int)self->size), (const void *)(source->data + (signed long int)source->consumed), size);
  source->consumed = source->consumed + size;
  self->size = self->size + size;
  return self->size;
}

// zchunk_data
// file src/zchunk.c line 139
unsigned char * zchunk_data(struct _zchunk_t *self)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  return self->data;
}

// zchunk_destroy
// file src/zchunk.c line 70
void zchunk_destroy(struct _zchunk_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zchunk_t **)NULL));
  if(!(*self_p == ((struct _zchunk_t *)NULL)))
  {
    struct _zchunk_t *self = *self_p;
    _Bool return_value_zchunk_is_1;
    return_value_zchunk_is_1=zchunk_is((void *)self);
    /* assertion zchunk_is (self) */
    assert(return_value_zchunk_is_1 != (_Bool)0);
    if(!(self->data == (unsigned char *)self + (signed long int)sizeof(struct _zchunk_t) /*48l*/ ))
      free((void *)self->data);

    self->tag = 0xDeadBeef;
    zdigest_destroy(&self->digest);
    free((void *)self);
    *self_p = (struct _zchunk_t *)(void *)0;
  }

}

// zchunk_digest
// file src/zchunk.c line 446
const char * zchunk_digest(struct _zchunk_t *self)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  if(self->digest == ((struct _zdigest_t *)NULL))
    self->digest=zdigest_new();

  if(!(self->digest == ((struct _zdigest_t *)NULL)))
  {
    zdigest_update(self->digest, self->data, self->size);
    char *return_value_zdigest_string_1;
    return_value_zdigest_string_1=zdigest_string(self->digest);
    return return_value_zdigest_string_1;
  }

  else
    return (const char *)(void *)0;
}

// zchunk_dup
// file src/zchunk.c line 340
struct _zchunk_t * zchunk_dup(struct _zchunk_t *self)
{
  if(!(self == ((struct _zchunk_t *)NULL)))
  {
    _Bool return_value_zchunk_is_1;
    return_value_zchunk_is_1=zchunk_is((void *)self);
    /* assertion zchunk_is (self) */
    assert(return_value_zchunk_is_1 != (_Bool)0);
    struct _zchunk_t *return_value_zchunk_new_2;
    return_value_zchunk_new_2=zchunk_new((const void *)self->data, self->max_size);
    return return_value_zchunk_new_2;
  }

  else
    return (struct _zchunk_t *)(void *)0;
}

// zchunk_exhausted
// file src/zchunk.c line 270
_Bool zchunk_exhausted(struct _zchunk_t *self)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  /* assertion self->consumed <= self->size */
  assert(self->consumed <= self->size);
  return self->consumed == self->size;
}

// zchunk_extend
// file src/zchunk.c line 213
unsigned long int zchunk_extend(struct _zchunk_t *self, const void *data, unsigned long int size)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  void *return_value_realloc_2;
  if(!(self->max_size >= self->size + size))
  {
    self->max_size = (self->size + size) * (unsigned long int)2;
    if(self->data == (unsigned char *)self + (signed long int)sizeof(struct _zchunk_t) /*48l*/ )
    {
      unsigned char *old_data = self->data;
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(self->max_size);
      self->data = (unsigned char *)return_value_malloc_1;
      memcpy((void *)self->data, (const void *)old_data, self->size);
    }

    else
    {
      return_value_realloc_2=realloc((void *)self->data, self->max_size);
      self->data = (unsigned char *)return_value_realloc_2;
    }
  }

  /* assertion self->size + size <= self->max_size */
  assert(self->size + size <= self->max_size);
  memcpy((void *)(self->data + (signed long int)self->size), data, size);
  self->size = self->size + size;
  return self->size;
}

// zchunk_fill
// file src/zchunk.c line 172
unsigned long int zchunk_fill(struct _zchunk_t *self, unsigned char filler, unsigned long int size)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  zdigest_destroy(&self->digest);
  if(!(self->max_size >= size))
    size = self->max_size;

  memset((void *)self->data, (signed int)filler, size);
  self->size = size;
  return size;
}

// zchunk_fprint
// file src/zchunk.c line 464
void zchunk_fprint(struct _zchunk_t *self, struct _IO_FILE *file)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  fprintf(file, "--------------------------------------\n");
  if(self == ((struct _zchunk_t *)NULL))
    fprintf(file, "NULL");

  else
  {
    /* assertion self */
    assert(self != ((struct _zchunk_t *)NULL));
    signed int is_bin = 0;
    unsigned int char_nbr = (unsigned int)0;
    for( ; !((unsigned long int)char_nbr >= self->size); char_nbr = char_nbr + 1u)
    {
      _Bool tmp_if_expr_2;
      if(!((signed int)self->data[(signed long int)char_nbr] >= 9))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)self->data[(signed long int)char_nbr] > 127 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        is_bin = 1;

    }
    fprintf(file, "[%03d] ", (signed int)self->size);
    char_nbr = (unsigned int)0;
    for( ; !((unsigned long int)char_nbr >= self->size); char_nbr = char_nbr + 1u)
      if(!(is_bin == 0))
      {
        fprintf(file, "%02X", (unsigned char)self->data[(signed long int)char_nbr]);
        if(char_nbr >= 36u)
        {
          fprintf(file, "...");
          break;
        }

      }

      else
      {
        fprintf(file, "%c", self->data[(signed long int)char_nbr]);
        if(char_nbr >= 71u)
        {
          fprintf(file, "...");
          break;
        }

      }
    fprintf(file, "\n");
  }
}

// zchunk_is
// file src/zchunk.c line 521
_Bool zchunk_is(void *self)
{
  /* assertion self */
  assert(self != NULL);
  return ((struct _zchunk_t *)self)->tag == (unsigned int)0x0001cafe;
}

// zchunk_max_size
// file src/zchunk.c line 127
unsigned long int zchunk_max_size(struct _zchunk_t *self)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  return self->max_size;
}

// zchunk_new
// file src/zchunk.c line 46
struct _zchunk_t * zchunk_new(const void *data, unsigned long int size)
{
  struct _zchunk_t *self;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _zchunk_t) /*48ul*/  + size);
  self = (struct _zchunk_t *)return_value_malloc_1;
  if(!(self == ((struct _zchunk_t *)NULL)))
  {
    self->tag = (unsigned int)0x0001cafe;
    self->size = (unsigned long int)0;
    self->max_size = size;
    self->consumed = (unsigned long int)0;
    self->data = (unsigned char *)self + (signed long int)sizeof(struct _zchunk_t) /*48ul*/ ;
    self->digest = (struct _zdigest_t *)(void *)0;
    if(!(data == NULL))
    {
      self->size = size;
      memcpy((void *)self->data, data, self->size);
    }

  }

  return self;
}

// zchunk_pack
// file src/zchunk.c line 421
struct _zframe_t * zchunk_pack(struct _zchunk_t *self)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  struct _zframe_t *return_value_zframe_new_2;
  return_value_zframe_new_2=zframe_new((const void *)self->data, self->max_size);
  return return_value_zframe_new_2;
}

// zchunk_print
// file src/zchunk.c line 508
void zchunk_print(struct _zchunk_t *self)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  zchunk_fprint(self, stderr);
}

// zchunk_read
// file src/zchunk.c line 284
struct _zchunk_t * zchunk_read(struct _IO_FILE *handle, unsigned long int bytes)
{
  /* assertion handle */
  assert(handle != ((struct _IO_FILE *)NULL));
  struct _zchunk_t *self;
  self=zchunk_new((void *)0, bytes);
  if(!(self == ((struct _zchunk_t *)NULL)))
    self->size=fread((void *)self->data, (unsigned long int)1, bytes, handle);

  return self;
}

// zchunk_resize
// file src/zchunk.c line 91
void zchunk_resize(struct _zchunk_t *self, unsigned long int size)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  zdigest_destroy(&self->digest);
  self->max_size = size;
  self->size = (unsigned long int)0;
  void *return_value_malloc_2;
  void *return_value_realloc_3;
  if(self->data == (unsigned char *)self + (signed long int)sizeof(struct _zchunk_t) /*48l*/ )
  {
    return_value_malloc_2=malloc(self->max_size);
    self->data = (unsigned char *)return_value_malloc_2;
  }

  else
  {
    return_value_realloc_3=realloc((void *)self->data, self->max_size);
    self->data = (unsigned char *)return_value_realloc_3;
  }
}

// zchunk_set
// file src/zchunk.c line 152
unsigned long int zchunk_set(struct _zchunk_t *self, const void *data, unsigned long int size)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  zdigest_destroy(&self->digest);
  if(!(self->max_size >= size))
    size = self->max_size;

  if(!(data == NULL))
    memcpy((void *)self->data, data, size);

  self->size = size;
  return size;
}

// zchunk_size
// file src/zchunk.c line 115
unsigned long int zchunk_size(struct _zchunk_t *self)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  return self->size;
}

// zchunk_slurp
// file src/zchunk.c line 317
struct _zchunk_t * zchunk_slurp(const char *filename, unsigned long int maxsize)
{
  unsigned long int size;
  signed long int return_value_zsys_file_size_1;
  return_value_zsys_file_size_1=zsys_file_size(filename);
  size = (unsigned long int)return_value_zsys_file_size_1;
  if((signed long int)size == -1l)
    return (struct _zchunk_t *)(void *)0;

  else
  {
    if(!(maxsize == 0ul) && !(maxsize >= size))
      size = maxsize;

    struct _IO_FILE *handle;
    handle=fopen(filename, "r");
    struct _zchunk_t *chunk;
    chunk=zchunk_read(handle, size);
    /* assertion chunk */
    assert(chunk != ((struct _zchunk_t *)NULL));
    fclose(handle);
    return chunk;
  }
}

// zchunk_strdup
// file src/zchunk.c line 385
char * zchunk_strdup(struct _zchunk_t *self)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  unsigned long int size;
  size=zchunk_size(self);
  char *string;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(size + (unsigned long int)1);
  string = (char *)return_value_malloc_2;
  if(!(string == ((char *)NULL)))
  {
    unsigned char *return_value_zchunk_data_3;
    return_value_zchunk_data_3=zchunk_data(self);
    memcpy((void *)string, (const void *)return_value_zchunk_data_3, size);
    string[(signed long int)size] = (char)0;
  }

  return string;
}

// zchunk_streq
// file src/zchunk.c line 404
_Bool zchunk_streq(struct _zchunk_t *self, const char *string)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  unsigned long int return_value_zchunk_size_2;
  return_value_zchunk_size_2=zchunk_size(self);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(string);
  _Bool tmp_if_expr_7;
  unsigned char *return_value_zchunk_data_4;
  unsigned long int return_value_strlen_5;
  signed int return_value_memcmp_6;
  if(return_value_zchunk_size_2 == return_value_strlen_3)
  {
    return_value_zchunk_data_4=zchunk_data(self);
    return_value_strlen_5=strlen(string);
    return_value_memcmp_6=memcmp((const void *)return_value_zchunk_data_4, (const void *)string, return_value_strlen_5);
    tmp_if_expr_7 = return_value_memcmp_6 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_7 = (_Bool)0;
  if(tmp_if_expr_7)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// zchunk_strhex
// file src/zchunk.c line 356
char * zchunk_strhex(struct _zchunk_t *self)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  unsigned long int size;
  size=zchunk_size(self);
  unsigned char *data;
  data=zchunk_data(self);
  char *hex_str;
  void *return_value_safe_malloc_2;
  return_value_safe_malloc_2=safe_malloc_link6(size * (unsigned long int)2 + (unsigned long int)1, "src/zchunk.c", (unsigned int)366);
  hex_str = (char *)return_value_safe_malloc_2;
  if(hex_str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned int byte_nbr = (unsigned int)0;
    for( ; !((unsigned long int)byte_nbr >= size); byte_nbr = byte_nbr + 1u)
    {
      static const char hex_char[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 0 };
      hex_str[(signed long int)(byte_nbr * (unsigned int)2 + (unsigned int)0)] = hex_char[(signed long int)((signed int)data[(signed long int)byte_nbr] >> 4)];
      hex_str[(signed long int)(byte_nbr * (unsigned int)2 + (unsigned int)1)] = hex_char[(signed long int)((signed int)data[(signed long int)byte_nbr] & 15)];
    }
    hex_str[(signed long int)(size * (unsigned long int)2)] = (char)0;
    return hex_str;
  }
}

// zchunk_test
// file src/zchunk.c line 532
void zchunk_test(_Bool verbose)
{
  printf(" * zchunk: ");
  struct _zchunk_t *chunk;
  chunk=zchunk_new((const void *)"1234567890", (unsigned long int)10);
  /* assertion chunk */
  assert(chunk != ((struct _zchunk_t *)NULL));
  unsigned long int return_value_zchunk_size_1;
  return_value_zchunk_size_1=zchunk_size(chunk);
  /* assertion zchunk_size (chunk) == 10 */
  assert(return_value_zchunk_size_1 == (unsigned long int)10);
  unsigned char *return_value_zchunk_data_2;
  return_value_zchunk_data_2=zchunk_data(chunk);
  signed int return_value_memcmp_3;
  return_value_memcmp_3=memcmp((const void *)return_value_zchunk_data_2, (const void *)"1234567890", (unsigned long int)10);
  /* assertion memcmp (zchunk_data (chunk), "1234567890", 10) == 0 */
  assert(return_value_memcmp_3 == 0);
  zchunk_destroy(&chunk);
  chunk=zchunk_new((void *)0, (unsigned long int)10);
  /* assertion chunk */
  assert(chunk != ((struct _zchunk_t *)NULL));
  zchunk_append(chunk, (const void *)"12345678", (unsigned long int)8);
  zchunk_append(chunk, (const void *)"90ABCDEF", (unsigned long int)8);
  zchunk_append(chunk, (const void *)"GHIJKLMN", (unsigned long int)8);
  unsigned char *return_value_zchunk_data_4;
  return_value_zchunk_data_4=zchunk_data(chunk);
  signed int return_value_memcmp_5;
  return_value_memcmp_5=memcmp((const void *)return_value_zchunk_data_4, (const void *)"1234567890", (unsigned long int)10);
  /* assertion memcmp (zchunk_data (chunk), "1234567890", 10) == 0 */
  assert(return_value_memcmp_5 == 0);
  unsigned long int return_value_zchunk_size_6;
  return_value_zchunk_size_6=zchunk_size(chunk);
  /* assertion zchunk_size (chunk) == 10 */
  assert(return_value_zchunk_size_6 == (unsigned long int)10);
  _Bool return_value_zchunk_streq_7;
  return_value_zchunk_streq_7=zchunk_streq(chunk, "1234567890");
  /* assertion zchunk_streq (chunk, "1234567890") */
  assert(return_value_zchunk_streq_7 != (_Bool)0);
  const char *return_value_zchunk_digest_8;
  return_value_zchunk_digest_8=zchunk_digest(chunk);
  signed int return_value_strcmp_9;
  return_value_strcmp_9=strcmp(return_value_zchunk_digest_8, "01B307ACBA4F54F55AAFC33BB06BBBF6CA803E9A");
  /* assertion (!strcmp ((zchunk_digest (chunk)), ("01B307ACBA4F54F55AAFC33BB06BBBF6CA803E9A"))) */
  assert(!(return_value_strcmp_9 != 0));
  char *string;
  string=zchunk_strdup(chunk);
  signed int return_value_strcmp_10;
  return_value_strcmp_10=strcmp(string, "1234567890");
  /* assertion (!strcmp ((string), ("1234567890"))) */
  assert(!(return_value_strcmp_10 != 0));
  free((void *)string);
  string=zchunk_strhex(chunk);
  signed int return_value_strcmp_11;
  return_value_strcmp_11=strcmp(string, "31323334353637383930");
  /* assertion (!strcmp ((string), ("31323334353637383930"))) */
  assert(!(return_value_strcmp_11 != 0));
  free((void *)string);
  struct _zframe_t *frame;
  frame=zchunk_pack(chunk);
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  struct _zchunk_t *chunk2;
  chunk2=zchunk_unpack(frame);
  /* assertion chunk2 */
  assert(chunk2 != ((struct _zchunk_t *)NULL));
  unsigned char *return_value_zchunk_data_12;
  return_value_zchunk_data_12=zchunk_data(chunk2);
  signed int return_value_memcmp_13;
  return_value_memcmp_13=memcmp((const void *)return_value_zchunk_data_12, (const void *)"1234567890", (unsigned long int)10);
  /* assertion memcmp (zchunk_data (chunk2), "1234567890", 10) == 0 */
  assert(return_value_memcmp_13 == 0);
  zframe_destroy(&frame);
  zchunk_destroy(&chunk2);
  struct _zchunk_t *copy;
  copy=zchunk_dup(chunk);
  /* assertion copy */
  assert(copy != ((struct _zchunk_t *)NULL));
  unsigned char *return_value_zchunk_data_14;
  return_value_zchunk_data_14=zchunk_data(copy);
  signed int return_value_memcmp_15;
  return_value_memcmp_15=memcmp((const void *)return_value_zchunk_data_14, (const void *)"1234567890", (unsigned long int)10);
  /* assertion memcmp (zchunk_data (copy), "1234567890", 10) == 0 */
  assert(return_value_memcmp_15 == 0);
  unsigned long int return_value_zchunk_size_16;
  return_value_zchunk_size_16=zchunk_size(copy);
  /* assertion zchunk_size (copy) == 10 */
  assert(return_value_zchunk_size_16 == (unsigned long int)10);
  zchunk_destroy(&copy);
  zchunk_destroy(&chunk);
  chunk=zchunk_new((void *)0, (unsigned long int)0);
  zchunk_extend(chunk, (const void *)"12345678", (unsigned long int)8);
  zchunk_extend(chunk, (const void *)"90ABCDEF", (unsigned long int)8);
  zchunk_extend(chunk, (const void *)"GHIJKLMN", (unsigned long int)8);
  unsigned long int return_value_zchunk_size_17;
  return_value_zchunk_size_17=zchunk_size(chunk);
  /* assertion zchunk_size (chunk) == 24 */
  assert(return_value_zchunk_size_17 == (unsigned long int)24);
  _Bool return_value_zchunk_streq_18;
  return_value_zchunk_streq_18=zchunk_streq(chunk, "1234567890ABCDEFGHIJKLMN");
  /* assertion zchunk_streq (chunk, "1234567890ABCDEFGHIJKLMN") */
  assert(return_value_zchunk_streq_18 != (_Bool)0);
  zchunk_destroy(&chunk);
  copy=zchunk_new((const void *)"1234567890abcdefghij", (unsigned long int)20);
  /* assertion copy */
  assert(copy != ((struct _zchunk_t *)NULL));
  chunk=zchunk_new((void *)0, (unsigned long int)8);
  /* assertion chunk */
  assert(chunk != ((struct _zchunk_t *)NULL));
  zchunk_consume(chunk, copy);
  _Bool return_value_zchunk_exhausted_19;
  return_value_zchunk_exhausted_19=zchunk_exhausted(copy);
  /* assertion !zchunk_exhausted (copy) */
  assert(!(return_value_zchunk_exhausted_19 != (_Bool)0));
  unsigned char *return_value_zchunk_data_20;
  return_value_zchunk_data_20=zchunk_data(chunk);
  signed int return_value_memcmp_21;
  return_value_memcmp_21=memcmp((const void *)return_value_zchunk_data_20, (const void *)"12345678", (unsigned long int)8);
  /* assertion memcmp (zchunk_data (chunk), "12345678", 8) == 0 */
  assert(return_value_memcmp_21 == 0);
  zchunk_set(chunk, (void *)0, (unsigned long int)0);
  zchunk_consume(chunk, copy);
  _Bool return_value_zchunk_exhausted_22;
  return_value_zchunk_exhausted_22=zchunk_exhausted(copy);
  /* assertion !zchunk_exhausted (copy) */
  assert(!(return_value_zchunk_exhausted_22 != (_Bool)0));
  unsigned char *return_value_zchunk_data_23;
  return_value_zchunk_data_23=zchunk_data(chunk);
  signed int return_value_memcmp_24;
  return_value_memcmp_24=memcmp((const void *)return_value_zchunk_data_23, (const void *)"90abcdef", (unsigned long int)8);
  /* assertion memcmp (zchunk_data (chunk), "90abcdef", 8) == 0 */
  assert(return_value_memcmp_24 == 0);
  zchunk_set(chunk, (void *)0, (unsigned long int)0);
  zchunk_consume(chunk, copy);
  _Bool return_value_zchunk_exhausted_25;
  return_value_zchunk_exhausted_25=zchunk_exhausted(copy);
  /* assertion zchunk_exhausted (copy) */
  assert(return_value_zchunk_exhausted_25 != (_Bool)0);
  unsigned long int return_value_zchunk_size_26;
  return_value_zchunk_size_26=zchunk_size(chunk);
  /* assertion zchunk_size (chunk) == 4 */
  assert(return_value_zchunk_size_26 == (unsigned long int)4);
  unsigned char *return_value_zchunk_data_27;
  return_value_zchunk_data_27=zchunk_data(chunk);
  signed int return_value_memcmp_28;
  return_value_memcmp_28=memcmp((const void *)return_value_zchunk_data_27, (const void *)"ghij", (unsigned long int)4);
  /* assertion memcmp (zchunk_data (chunk), "ghij", 4) == 0 */
  assert(return_value_memcmp_28 == 0);
  zchunk_destroy(&copy);
  zchunk_destroy(&chunk);
  printf("OK\n");
}

// zchunk_unpack
// file src/zchunk.c line 433
struct _zchunk_t * zchunk_unpack(struct _zframe_t *frame)
{
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_is_1;
  return_value_zframe_is_1=zframe_is((void *)frame);
  /* assertion zframe_is (frame) */
  assert(return_value_zframe_is_1 != (_Bool)0);
  unsigned char *return_value_zframe_data_2;
  return_value_zframe_data_2=zframe_data(frame);
  unsigned long int return_value_zframe_size_3;
  return_value_zframe_size_3=zframe_size(frame);
  struct _zchunk_t *return_value_zchunk_new_4;
  return_value_zchunk_new_4=zchunk_new((const void *)return_value_zframe_data_2, return_value_zframe_size_3);
  return return_value_zchunk_new_4;
}

// zchunk_write
// file src/zchunk.c line 299
signed int zchunk_write(struct _zchunk_t *self, struct _IO_FILE *handle)
{
  /* assertion self */
  assert(self != ((struct _zchunk_t *)NULL));
  _Bool return_value_zchunk_is_1;
  return_value_zchunk_is_1=zchunk_is((void *)self);
  /* assertion zchunk_is (self) */
  assert(return_value_zchunk_is_1 != (_Bool)0);
  unsigned long int items;
  items=fwrite((const void *)self->data, (unsigned long int)1, self->size, handle);
  signed int rc = items < self->size ? -1 : 0;
  return rc;
}

// zclock_log
// file src/zclock.c line 193
void zclock_log(const char *format, ...)
{
  signed long int curtime;
  curtime=time((signed long int *)(void *)0);
  struct tm *loctime;
  loctime=localtime(&curtime);
  char formatted[20l];
  strftime(formatted, (unsigned long int)20, "%y-%m-%d %H:%M:%S ", loctime);
  printf("%s", (const void *)formatted);
  void **argptr = (void **)&format;
  vprintf(format, argptr);
  argptr = ((void **)NULL);
  printf("\n");
  fflush(stdout);
}

// zclock_mono
// file src/../include/zclock.h line 36
signed long int zclock_mono(void)
{
  struct timespec ts;
  clock_gettime(1, &ts);
  return (signed long int)((signed long int)ts.tv_sec * (signed long int)1000 + (signed long int)ts.tv_nsec / (signed long int)1000000);
}

// zclock_sleep
// file src/../include/zclock.h line 24
void zclock_sleep(signed int msecs)
{
  struct timespec t;
  t.tv_sec = (signed long int)(msecs / 1000);
  t.tv_nsec = (signed long int)((msecs % 1000) * 1000000);
  nanosleep(&t, (struct timespec *)(void *)0);
}

// zclock_test
// file src/zclock.c line 213
void zclock_test(_Bool verbose)
{
  printf(" * zclock: ");
  signed long int start;
  start=zclock_time();
  zclock_sleep(10);
  signed long int return_value_zclock_time_1;
  return_value_zclock_time_1=zclock_time();
  /* assertion (zclock_time () - start) >= 10 */
  assert(return_value_zclock_time_1 - start >= (signed long int)10);
  start=zclock_mono();
  signed long int usecs;
  usecs=zclock_usecs();
  zclock_sleep(10);
  signed long int return_value_zclock_mono_2;
  return_value_zclock_mono_2=zclock_mono();
  /* assertion (zclock_mono () - start) >= 10 */
  assert(return_value_zclock_mono_2 - start >= (signed long int)10);
  signed long int return_value_zclock_usecs_3;
  return_value_zclock_usecs_3=zclock_usecs();
  /* assertion (zclock_usecs () - usecs) >= 10000 */
  assert(return_value_zclock_usecs_3 - usecs >= (signed long int)10000);
  char *timestr;
  timestr=zclock_timestr();
  if(!(verbose == (_Bool)0))
    puts(timestr);

  free((void *)timestr);
  printf("OK\n");
}

// zclock_time
// file src/zclock.c line 82
signed long int zclock_time(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  return (signed long int)((signed long int)tv.tv_sec * (signed long int)1000 + (signed long int)tv.tv_usec / (signed long int)1000);
}

// zclock_timestr
// file src/../include/zclock.h line 46
char * zclock_timestr(void)
{
  signed long int curtime;
  curtime=time((signed long int *)(void *)0);
  struct tm *loctime;
  loctime=localtime(&curtime);
  char formatted[20l];
  strftime(formatted, (unsigned long int)20, "%Y-%m-%d %H:%M:%S", loctime);
  char *return_value_strdup_1;
  return_value_strdup_1=strdup(formatted);
  return return_value_strdup_1;
}

// zclock_usecs
// file src/zclock.c line 141
signed long int zclock_usecs(void)
{
  struct timespec ts;
  clock_gettime(1, &ts);
  return (signed long int)((signed long int)ts.tv_sec * (signed long int)1000000 + (signed long int)ts.tv_nsec / (signed long int)1000);
}

// zconfig_at_depth
// file src/zconfig.c line 331
struct _zconfig_t * zconfig_at_depth(struct _zconfig_t *self, signed int level)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  while(level >= 1)
    if(!(self->child == ((struct _zconfig_t *)NULL)))
    {
      self = self->child;
      for( ; !(self->next == ((struct _zconfig_t *)NULL)); self = self->next)
        ;
      level = level - 1;
    }

    else
      return (struct _zconfig_t *)(void *)0;
  return self;
}

// zconfig_child
// file src/../include/zconfig.h line 68
struct _zconfig_t * zconfig_child(struct _zconfig_t *self)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  return self->child;
}

// zconfig_chunk_load
// file src/zconfig.c line 588
struct _zconfig_t * zconfig_chunk_load(struct _zchunk_t *chunk)
{
  struct _zconfig_t *self;
  self=zconfig_new("root", (struct _zconfig_t *)(void *)0);
  signed int return_value_isspace_3;
  signed int return_value_s_verify_eoln_4;
  if(self == ((struct _zconfig_t *)NULL))
    return (struct _zconfig_t *)(void *)0;

  else
  {
    _Bool valid = (_Bool)1;
    signed int lineno = 0;
    char *data_ptr;
    unsigned char *return_value_zchunk_data_1;
    return_value_zchunk_data_1=zchunk_data(chunk);
    data_ptr = (char *)return_value_zchunk_data_1;
    unsigned long int remaining;
    remaining=zchunk_size(chunk);
    while(!(remaining == 0ul))
    {
      char *eoln;
      void *return_value_memchr_2;
      return_value_memchr_2=memchr((const void *)data_ptr, 10, remaining);
      eoln = (char *)return_value_memchr_2;
      unsigned long int cur_size;
      if(!(eoln == ((char *)NULL)))
        cur_size = (unsigned long int)(eoln - data_ptr);

      else
        cur_size = remaining;
      if(cur_size >= 1025ul)
        cur_size = (unsigned long int)1024;

      char cur_line[1025l];
      memcpy((void *)cur_line, (const void *)data_ptr, cur_size);
      cur_line[(signed long int)cur_size] = (char)0;
      data_ptr = eoln != ((char *)NULL) ? eoln + (signed long int)1 : (char *)(void *)0;
      remaining = remaining - (cur_size + (unsigned long int)(eoln != ((char *)NULL) ? 1 : 0));
      unsigned long int length;
      length=strlen(cur_line);
      for( ; !(length == 0ul); cur_line[(signed long int)length] = (char)0)
      {
        return_value_isspace_3=isspace((signed int)(unsigned char)cur_line[(signed long int)(length - (unsigned long int)1)]);
        if(return_value_isspace_3 == 0)
          break;

        length = length - 1ul;
      }
      lineno = lineno + 1;
      if((signed int)cur_line[0l] == 35)
      {
        if(self->comments == ((struct _zlist_t *)NULL))
        {
          self->comments=zlist_new();
          /* assertion self->comments */
          assert(self->comments != ((struct _zlist_t *)NULL));
          zlist_autofree(self->comments);
        }

        zlist_append(self->comments, (void *)(cur_line + (signed long int)1));
      }

      char *scanner = cur_line;
      signed int level;
      level=s_collect_level(&scanner, lineno);
      if(level == -1)
      {
        valid = (_Bool)0;
        break;
      }

      char *name;
      name=s_collect_name(&scanner, lineno);
      if(name == ((char *)NULL))
      {
        valid = (_Bool)0;
        break;
      }

      if(!(*name == 0))
      {
        char *value;
        value=s_collect_value(&scanner, lineno);
        if(value == ((char *)NULL))
          valid = (_Bool)0;

        else
        {
          struct _zconfig_t *parent;
          parent=zconfig_at_depth(self, level);
          if(!(parent == ((struct _zconfig_t *)NULL)))
          {
            struct _zconfig_t *item;
            item=zconfig_new(name, parent);
            /* assertion item */
            assert(item != ((struct _zconfig_t *)NULL));
            item->value = value;
          }

          else
          {
            zclock_log("E (zconfig): (%d) indentation error", lineno);
            free((void *)value);
            valid = (_Bool)0;
          }
        }
      }

      else
      {
        return_value_s_verify_eoln_4=s_verify_eoln(scanner, lineno);
        if(!(return_value_s_verify_eoln_4 == 0))
          valid = (_Bool)0;

      }
      free((void *)name);
      if(valid == (_Bool)0)
        break;

    }
    if(valid == (_Bool)0)
      zconfig_destroy(&self);

    return self;
  }
}

// zconfig_chunk_save
// file src/zconfig.c line 824
struct _zchunk_t * zconfig_chunk_save(struct _zconfig_t *self)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  signed int size;
  size=s_config_execute(self, s_config_save, (void *)0, 0);
  struct _zchunk_t *chunk;
  chunk=zchunk_new((void *)0, (unsigned long int)(size + 1));
  if(!(chunk == ((struct _zchunk_t *)NULL)))
  {
    s_config_execute(self, s_config_save, (void *)chunk, 0);
    unsigned char *return_value_zchunk_data_1;
    return_value_zchunk_data_1=zchunk_data(chunk);
    unsigned long int return_value_zchunk_size_2;
    return_value_zchunk_size_2=zchunk_size(chunk);
    return_value_zchunk_data_1[(signed long int)return_value_zchunk_size_2] = (unsigned char)0;
  }

  return chunk;
}

// zconfig_comments
// file src/zconfig.c line 912
struct _zlist_t * zconfig_comments(struct _zconfig_t *self)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  return self->comments;
}

// zconfig_destroy
// file src/../include/zconfig.h line 31
void zconfig_destroy(struct _zconfig_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zconfig_t **)NULL));
  if(!(*self_p == ((struct _zconfig_t *)NULL)))
  {
    struct _zconfig_t *self = *self_p;
    zconfig_destroy(&self->child);
    zconfig_destroy(&self->next);
    zlist_destroy(&self->comments);
    zfile_destroy(&self->file);
    free((void *)self->name);
    free((void *)self->value);
    free((void *)self);
    *self_p = (struct _zconfig_t *)(void *)0;
  }

}

// zconfig_execute
// file src/zconfig.c line 354
signed int zconfig_execute(struct _zconfig_t *self, signed int (*handler)(struct _zconfig_t *, void *, signed int), void *arg)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  signed int return_value_s_config_execute_1;
  return_value_s_config_execute_1=s_config_execute(self, handler, arg, 0);
  return return_value_s_config_execute_1 >= 0 ? 0 : -1;
}

// zconfig_filename
// file src/zconfig.c line 550
const char * zconfig_filename(struct _zconfig_t *self)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  const char *return_value_zfile_filename_1;
  if(!(self->file == ((struct _zfile_t *)NULL)))
  {
    return_value_zfile_filename_1=zfile_filename(self->file, (const char *)(void *)0);
    return return_value_zfile_filename_1;
  }

  else
    return (const char *)(void *)0;
}

// zconfig_fprint
// file src/zconfig.c line 923
void zconfig_fprint(struct _zconfig_t *self, struct _IO_FILE *file)
{
  zconfig_execute(self, s_config_save, (void *)file);
}

// zconfig_get
// file src/../include/zconfig.h line 53
char * zconfig_get(struct _zconfig_t *self, const char *path, const char *default_value)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  struct _zconfig_t *item;
  item=zconfig_locate(self, path);
  char *return_value_zconfig_value_1;
  if(!(item == ((struct _zconfig_t *)NULL)))
  {
    return_value_zconfig_value_1=zconfig_value(item);
    return return_value_zconfig_value_1;
  }

  else
    return (char *)default_value;
}

// zconfig_has_changed
// file src/zconfig.c line 871
_Bool zconfig_has_changed(struct _zconfig_t *self)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  _Bool tmp_if_expr_2;
  _Bool return_value_zfile_has_changed_1;
  if(!(self->file == ((struct _zfile_t *)NULL)))
  {
    return_value_zfile_has_changed_1=zfile_has_changed(self->file);
    tmp_if_expr_2 = return_value_zfile_has_changed_1 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// zconfig_load
// file src/../include/zconfig.h line 101
struct _zconfig_t * zconfig_load(const char *filename)
{
  struct _zconfig_t *self = (struct _zconfig_t *)(void *)0;
  struct _zfile_t *file;
  file=zfile_new((const char *)(void *)0, filename);
  if(file == ((struct _zfile_t *)NULL))
    return (struct _zconfig_t *)(void *)0;

  else
  {
    signed int return_value_zfile_input_2;
    return_value_zfile_input_2=zfile_input(file);
    if(return_value_zfile_input_2 == 0)
    {
      struct _zchunk_t *chunk;
      signed long int return_value_zfile_cursize_1;
      return_value_zfile_cursize_1=zfile_cursize(file);
      chunk=zfile_read(file, (unsigned long int)return_value_zfile_cursize_1, (signed long int)0);
      if(!(chunk == ((struct _zchunk_t *)NULL)))
      {
        self=zconfig_chunk_load(chunk);
        zchunk_destroy(&chunk);
        if(!(self == ((struct _zconfig_t *)NULL)))
          self->file = file;

        zfile_close(file);
        file = (struct _zfile_t *)(void *)0;
      }

    }

    zfile_destroy(&file);
    return self;
  }
}

// zconfig_loadf
// file src/zconfig.c line 508
struct _zconfig_t * zconfig_loadf(const char *format, ...)
{
  void **argptr = (void **)&format;
  char *filename;
  filename=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  if(!(filename == ((char *)NULL)))
  {
    struct _zconfig_t *config;
    config=zconfig_load(filename);
    free((void *)filename);
    return config;
  }

  else
    return (struct _zconfig_t *)(void *)0;
}

// zconfig_locate
// file src/../include/zconfig.h line 76
struct _zconfig_t * zconfig_locate(struct _zconfig_t *self, const char *path)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  if((signed int)*path == 47)
    path = path + 1l;

  const char *slash;
  slash=strchr(path, 47);
  unsigned long int length;
  length=strlen(path);
  if(!(slash == ((const char *)NULL)))
    length = (unsigned long int)(slash - path);

  struct _zconfig_t *child = self->child;
  signed int return_value_memcmp_2;
  struct _zconfig_t *return_value_zconfig_locate_1;
  while(!(child == ((struct _zconfig_t *)NULL)))
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(child->name);
    if(return_value_strlen_3 == length)
    {
      return_value_memcmp_2=memcmp((const void *)child->name, (const void *)path, length);
      if(return_value_memcmp_2 == 0)
      {
        if(!(slash == ((const char *)NULL)))
        {
          return_value_zconfig_locate_1=zconfig_locate(child, slash);
          return return_value_zconfig_locate_1;
        }

        else
          return child;
      }

    }

    child = child->next;
  }
  return (struct _zconfig_t *)(void *)0;
}

// zconfig_name
// file src/../include/zconfig.h line 35
char * zconfig_name(struct _zconfig_t *self)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  return self->name;
}

// zconfig_new
// file src/../include/zconfig.h line 27
struct _zconfig_t * zconfig_new(const char *name, struct _zconfig_t *parent)
{
  struct _zconfig_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link7(sizeof(struct _zconfig_t) /*56ul*/ , "src/zconfig.c", (unsigned int)95);
  self = (struct _zconfig_t *)return_value_safe_malloc_1;
  if(self == ((struct _zconfig_t *)NULL))
    return (struct _zconfig_t *)(void *)0;

  else
  {
    zconfig_set_name(self, name);
    if(!(parent == ((struct _zconfig_t *)NULL)))
    {
      if(!(parent->child == ((struct _zconfig_t *)NULL)))
      {
        struct _zconfig_t *last = parent->child;
        for( ; !(last->next == ((struct _zconfig_t *)NULL)); last = last->next)
          ;
        last->next = self;
      }

      else
        parent->child = self;
    }

    self->parent = parent;
    return self;
  }
}

// zconfig_next
// file src/../include/zconfig.h line 72
struct _zconfig_t * zconfig_next(struct _zconfig_t *self)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  return self->next;
}

// zconfig_print
// file src/zconfig.c line 933
void zconfig_print(struct _zconfig_t *self)
{
  zconfig_fprint(self, stdout);
}

// zconfig_put
// file src/../include/zconfig.h line 43
void zconfig_put(struct _zconfig_t *self, const char *path, const char *value)
{
  if((signed int)*path == 47)
    path = path + 1l;

  const char *slash;
  slash=strchr(path, 47);
  unsigned long int length;
  length=strlen(path);
  if(!(slash == ((const char *)NULL)))
    length = (unsigned long int)(slash - path);

  struct _zconfig_t *child = self->child;
  signed int return_value_memcmp_1;
  while(!(child == ((struct _zconfig_t *)NULL)))
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(child->name);
    if(return_value_strlen_2 == length)
    {
      return_value_memcmp_1=memcmp((const void *)child->name, (const void *)path, length);
      if(return_value_memcmp_1 == 0)
      {
        if(!(slash == ((const char *)NULL)))
          zconfig_put(child, slash + (signed long int)1, value);

        else
          zconfig_set_value(child, "%s", value);
        goto __CPROVER_DUMP_L11;
      }

    }

    child = child->next;
  }
  child=zconfig_new(path, self);
  /* assertion child */
  assert(child != ((struct _zconfig_t *)NULL));
  child->name[(signed long int)length] = (char)0;
  if(!(slash == ((const char *)NULL)))
    zconfig_put(child, slash, value);

  else
    zconfig_set_value(child, "%s", value);

__CPROVER_DUMP_L11:
  ;
}

// zconfig_putf
// file src/zconfig.c line 210
void zconfig_putf(struct _zconfig_t *self, const char *path, const char *format, ...)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  void **argptr = (void **)&format;
  char *value;
  value=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  zconfig_put(self, path, value);
  zstr_free(&value);
}

// zconfig_reload
// file src/zconfig.c line 566
signed int zconfig_reload(struct _zconfig_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zconfig_t **)NULL));
  struct _zconfig_t *self = *self_p;
  if(!(self->file == ((struct _zfile_t *)NULL)))
  {
    struct _zconfig_t *copy;
    const char *return_value_zfile_filename_1;
    return_value_zfile_filename_1=zfile_filename(self->file, (const char *)(void *)0);
    copy=zconfig_load(return_value_zfile_filename_1);
    if(!(copy == ((struct _zconfig_t *)NULL)))
    {
      zconfig_destroy(self_p);
      *self_p = copy;
      return 0;
    }

  }

  return -1;
}

// zconfig_save
// file src/../include/zconfig.h line 106
signed int zconfig_save(struct _zconfig_t *self, const char *filename)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  signed int rc = 0;
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(filename, "-");
  const char *return_value_zconfig_filename_1;
  signed int return_value_strcmp_2;
  if(return_value_strcmp_3 == 0)
    rc=zconfig_execute(self, s_config_save, (void *)stdout);

  else
  {
    struct _IO_FILE *file;
    file=fopen(filename, "w");
    if(!(file == ((struct _IO_FILE *)NULL)))
    {
      rc=zconfig_execute(self, s_config_save, (void *)file);
      fflush(file);
      fclose(file);
      if(!(self->file == ((struct _zfile_t *)NULL)))
      {
        return_value_zconfig_filename_1=zconfig_filename(self);
        return_value_strcmp_2=strcmp(filename, return_value_zconfig_filename_1);
        if(return_value_strcmp_2 == 0)
          zfile_restat(self->file);

      }

    }

    else
      rc = -1;
  }
  return rc;
}

// zconfig_savef
// file src/zconfig.c line 529
signed int zconfig_savef(struct _zconfig_t *self, const char *format, ...)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  void **argptr = (void **)&format;
  char *filename;
  filename=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  if(!(filename == ((char *)NULL)))
  {
    signed int rc;
    rc=zconfig_save(self, filename);
    free((void *)filename);
    return rc;
  }

  else
    return -1;
}

// zconfig_set_comment
// file src/../include/zconfig.h line 91
void zconfig_set_comment(struct _zconfig_t *self, const char *format, ...)
{
  if(!(format == ((const char *)NULL)))
  {
    if(self->comments == ((struct _zlist_t *)NULL))
    {
      self->comments=zlist_new();
      /* assertion self->comments */
      assert(self->comments != ((struct _zlist_t *)NULL));
      zlist_autofree(self->comments);
    }

    void **argptr = (void **)&format;
    char *string;
    string=zsys_vprintf(format, argptr);
    argptr = ((void **)NULL);
    zlist_append(self->comments, (void *)string);
    free((void *)string);
  }

  else
    zlist_destroy(&self->comments);
}

// zconfig_set_name
// file src/zconfig.c line 226
void zconfig_set_name(struct _zconfig_t *self, const char *name)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  free((void *)self->name);
  char *tmp_if_expr_2;
  char *return_value_strdup_1;
  if(!(name == ((const char *)NULL)))
  {
    return_value_strdup_1=strdup(name);
    tmp_if_expr_2 = return_value_strdup_1;
  }

  else
    tmp_if_expr_2 = (char *)(void *)0;
  self->name = tmp_if_expr_2;
}

// zconfig_set_value
// file src/../include/zconfig.h line 64
void zconfig_set_value(struct _zconfig_t *self, const char *format, ...)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  free((void *)self->value);
  if(!(format == ((const char *)NULL)))
  {
    void **argptr = (void **)&format;
    self->value=zsys_vprintf(format, argptr);
    argptr = ((void **)NULL);
  }

  else
    self->value = (char *)(void *)0;
}

// zconfig_str_load
// file src/zconfig.c line 844
struct _zconfig_t * zconfig_str_load(const char *string)
{
  struct _zchunk_t *chunk;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  chunk=zchunk_new((const void *)string, return_value_strlen_1);
  struct _zconfig_t *config;
  config=zconfig_chunk_load(chunk);
  zchunk_destroy(&chunk);
  return config;
}

// zconfig_str_save
// file src/zconfig.c line 857
char * zconfig_str_save(struct _zconfig_t *self)
{
  struct _zchunk_t *chunk;
  chunk=zconfig_chunk_save(self);
  char *string;
  unsigned char *return_value_zchunk_data_1;
  return_value_zchunk_data_1=zchunk_data(chunk);
  string=strdup((char *)return_value_zchunk_data_1);
  zchunk_destroy(&chunk);
  return string;
}

// zconfig_test
// file src/zconfig.c line 943
void zconfig_test(_Bool verbose)
{
  printf(" * zconfig: ");
  zsys_dir_create(".test_zconfig");
  struct _zconfig_t *root;
  root=zconfig_new("root", (struct _zconfig_t *)(void *)0);
  /* assertion root */
  assert(root != ((struct _zconfig_t *)NULL));
  struct _zconfig_t *section;
  struct _zconfig_t *item;
  section=zconfig_new("headers", root);
  /* assertion section */
  assert(section != ((struct _zconfig_t *)NULL));
  item=zconfig_new("email", section);
  /* assertion item */
  assert(item != ((struct _zconfig_t *)NULL));
  zconfig_set_value(item, "some@random.com");
  item=zconfig_new("name", section);
  /* assertion item */
  assert(item != ((struct _zconfig_t *)NULL));
  zconfig_set_value(item, "Justin Kayce");
  zconfig_putf(root, "/curve/secret-key", "%s", (const void *)"Top Secret");
  zconfig_set_comment(root, "   CURVE certificate");
  zconfig_set_comment(root, "   -----------------");
  struct _zlist_t *return_value_zconfig_comments_1;
  return_value_zconfig_comments_1=zconfig_comments(root);
  /* assertion zconfig_comments (root) */
  assert(return_value_zconfig_comments_1 != ((struct _zlist_t *)NULL));
  zconfig_save(root, ".test_zconfig/test.cfg");
  zconfig_destroy(&root);
  root=zconfig_load(".test_zconfig/test.cfg");
  if(!(verbose == (_Bool)0))
    zconfig_save(root, "-");

  const char *return_value_zconfig_filename_2;
  return_value_zconfig_filename_2=zconfig_filename(root);
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(return_value_zconfig_filename_2, ".test_zconfig/test.cfg");
  /* assertion (!strcmp ((zconfig_filename (root)), (".test_zconfig" "/test.cfg"))) */
  assert(!(return_value_strcmp_3 != 0));
  char *email;
  email=zconfig_get(root, "/headers/email", (const char *)(void *)0);
  /* assertion email */
  assert(email != ((char *)NULL));
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(email, "some@random.com");
  /* assertion (!strcmp ((email), ("some@random.com"))) */
  assert(!(return_value_strcmp_4 != 0));
  char *passwd;
  passwd=zconfig_get(root, "/curve/secret-key", (const char *)(void *)0);
  /* assertion passwd */
  assert(passwd != ((char *)NULL));
  signed int return_value_strcmp_5;
  return_value_strcmp_5=strcmp(passwd, "Top Secret");
  /* assertion (!strcmp ((passwd), ("Top Secret"))) */
  assert(!(return_value_strcmp_5 != 0));
  zconfig_savef(root, "%s/%s", (const void *)".test_zconfig", (const void *)"test.cfg");
  _Bool return_value_zconfig_has_changed_6;
  return_value_zconfig_has_changed_6=zconfig_has_changed(root);
  /* assertion !zconfig_has_changed (root) */
  assert(!(return_value_zconfig_has_changed_6 != (_Bool)0));
  signed int rc;
  rc=zconfig_reload(&root);
  /* assertion rc == 0 */
  assert(rc == 0);
  _Bool return_value_zconfig_has_changed_7;
  return_value_zconfig_has_changed_7=zconfig_has_changed(root);
  /* assertion !zconfig_has_changed (root) */
  assert(!(return_value_zconfig_has_changed_7 != (_Bool)0));
  zconfig_destroy(&root);
  root=zconfig_new("root", (struct _zconfig_t *)(void *)0);
  /* assertion root */
  assert(root != ((struct _zconfig_t *)NULL));
  section=zconfig_new("section", root);
  /* assertion section */
  assert(section != ((struct _zconfig_t *)NULL));
  item=zconfig_new("value", section);
  /* assertion item */
  assert(item != ((struct _zconfig_t *)NULL));
  zconfig_set_value(item, "somevalue");
  struct _zconfig_t *search;
  search=zconfig_locate(root, "section/value");
  /* assertion search == item */
  assert(search == item);
  struct _zchunk_t *chunk;
  chunk=zconfig_chunk_save(root);
  unsigned char *return_value_zchunk_data_8;
  return_value_zchunk_data_8=zchunk_data(chunk);
  unsigned long int return_value_strlen_9;
  return_value_strlen_9=strlen((char *)return_value_zchunk_data_8);
  /* assertion strlen ((char *) zchunk_data (chunk)) == 32 */
  assert(return_value_strlen_9 == (unsigned long int)32);
  char *string;
  string=zconfig_str_save(root);
  /* assertion string */
  assert(string != ((char *)NULL));
  unsigned char *return_value_zchunk_data_10;
  return_value_zchunk_data_10=zchunk_data(chunk);
  signed int return_value_strcmp_11;
  return_value_strcmp_11=strcmp(string, (char *)return_value_zchunk_data_10);
  /* assertion (!strcmp ((string), ((char *) zchunk_data (chunk)))) */
  assert(!(return_value_strcmp_11 != 0));
  free((void *)string);
  /* assertion chunk */
  assert(chunk != ((struct _zchunk_t *)NULL));
  zconfig_destroy(&root);
  root=zconfig_chunk_load(chunk);
  /* assertion root */
  assert(root != ((struct _zconfig_t *)NULL));
  char *value;
  value=zconfig_get(root, "/section/value", (const char *)(void *)0);
  /* assertion value */
  assert(value != ((char *)NULL));
  signed int return_value_strcmp_12;
  return_value_strcmp_12=strcmp(value, "somevalue");
  /* assertion (!strcmp ((value), ("somevalue"))) */
  assert(!(return_value_strcmp_12 != 0));
  rc=zconfig_savef(root, "%s/path/that/doesnt/exist/%s", (const void *)".test_zconfig", (const void *)"test.cfg");
  /* assertion rc == -1 */
  assert(rc == -1);
  zconfig_destroy(&root);
  zchunk_destroy(&chunk);
  struct _zdir_t *dir;
  dir=zdir_new(".test_zconfig", (const char *)(void *)0);
  /* assertion dir */
  assert(dir != ((struct _zdir_t *)NULL));
  zdir_remove(dir, (_Bool)1);
  zdir_destroy(&dir);
  printf("OK\n");
}

// zconfig_value
// file src/../include/zconfig.h line 39
char * zconfig_value(struct _zconfig_t *self)
{
  /* assertion self */
  assert(self != ((struct _zconfig_t *)NULL));
  return self->value;
}

// zctx__initialize_underlying
// file src/zctx.c line 264
void zctx__initialize_underlying(struct _zctx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zctx_t *)NULL));
  zmutex_lock(self->mutex);
  if(self->context == NULL)
    self->context=zmq_init(self->iothreads);

  zmutex_unlock(self->mutex);
}

// zctx__socket_destroy
// file src/zctx.c line 329
void zctx__socket_destroy(struct _zctx_t *self, void *zocket)
{
  /* assertion self */
  assert(self != ((struct _zctx_t *)NULL));
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_linger(zocket, self->linger);
  zmq_close(zocket);
  zmutex_lock(self->mutex);
  zlist_remove(self->sockets, zocket);
  zmutex_unlock(self->mutex);
}

// zctx__socket_new
// file src/zctx.c line 278
void * zctx__socket_new(struct _zctx_t *self, signed int type)
{
  /* assertion self */
  assert(self != ((struct _zctx_t *)NULL));
  if(self->context == NULL)
  {
    zctx__initialize_underlying(self);
    if(!(self->context == NULL))
      goto __CPROVER_DUMP_L1;

    return (void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    void *zocket;
    zocket=zmq_socket(self->context, type);
    if(zocket == NULL)
      return (void *)0;

    else
    {
      zsocket_set_sndhwm(zocket, self->sndhwm);
      zsocket_set_rcvhwm(zocket, self->rcvhwm);
      zmutex_lock(self->mutex);
      signed int return_value_zlist_push_1;
      return_value_zlist_push_1=zlist_push(self->sockets, zocket);
      if(!(return_value_zlist_push_1 == 0))
      {
        zmutex_unlock(self->mutex);
        zmq_close(zocket);
        return (void *)0;
      }

      else
      {
        zmutex_unlock(self->mutex);
        return zocket;
      }
    }
  }
}

// zctx__socket_pipe
// file src/zctx.c line 315
void * zctx__socket_pipe(struct _zctx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zctx_t *)NULL));
  void *pipe;
  pipe=zctx__socket_new(self, 0);
  if(!(pipe == NULL))
    zsocket_set_hwm(pipe, self->pipehwm);

  return pipe;
}

// zctx_destroy
// file src/../include/zctx.h line 29
void zctx_destroy(struct _zctx_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zctx_t **)NULL));
  unsigned long int return_value_zlist_size_1;
  void *return_value_zlist_first_2;
  if(!(*self_p == ((struct _zctx_t *)NULL)))
  {
    struct _zctx_t *self = *self_p;
    if(!(self->sockets == ((struct _zlist_t *)NULL)))
      do
      {
        return_value_zlist_size_1=zlist_size(self->sockets);
        if(return_value_zlist_size_1 == 0ul)
          break;

        return_value_zlist_first_2=zlist_first(self->sockets);
        zctx__socket_destroy(self, return_value_zlist_first_2);
      }
      while((_Bool)1);

    zlist_destroy(&self->sockets);
    zmutex_destroy(&self->mutex);
    if(!(self->context == NULL))
    {
      if(self->shadow == (_Bool)0)
        zmq_term(self->context);

    }

    free((void *)self);
    *self_p = (struct _zctx_t *)(void *)0;
  }

}

// zctx_new
// file src/../include/zctx.h line 25
struct _zctx_t * zctx_new(void)
{
  struct _zctx_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link30(sizeof(struct _zctx_t) /*48ul*/ , "src/zctx.c", (unsigned int)69);
  self = (struct _zctx_t *)return_value_safe_malloc_1;
  if(self == ((struct _zctx_t *)NULL))
    return (struct _zctx_t *)(void *)0;

  else
  {
    self->sockets=zlist_new();
    self->mutex=zmutex_new();
    _Bool tmp_if_expr_2;
    if(self->sockets == ((struct _zlist_t *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = !(self->mutex != ((struct _zmutex_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      zctx_destroy(&self);
      return (struct _zctx_t *)(void *)0;
    }

    else
    {
      self->iothreads = 1;
      self->pipehwm = 1000;
      self->sndhwm = 1000;
      self->rcvhwm = 1000;
      zsys_catch_interrupts();
      return self;
    }
  }
}

// zctx_set_iothreads
// file src/zctx.c line 177
void zctx_set_iothreads(struct _zctx_t *self, signed int iothreads)
{
  /* assertion self */
  assert(self != ((struct _zctx_t *)NULL));
  zmutex_lock(self->mutex);
  self->iothreads = iothreads;
  zmutex_unlock(self->mutex);
}

// zctx_set_linger
// file src/zctx.c line 192
void zctx_set_linger(struct _zctx_t *self, signed int linger)
{
  /* assertion self */
  assert(self != ((struct _zctx_t *)NULL));
  zmutex_lock(self->mutex);
  self->linger = linger;
  zmutex_unlock(self->mutex);
}

// zctx_set_pipehwm
// file src/zctx.c line 210
void zctx_set_pipehwm(struct _zctx_t *self, signed int pipehwm)
{
  /* assertion self */
  assert(self != ((struct _zctx_t *)NULL));
  zmutex_lock(self->mutex);
  self->pipehwm = pipehwm;
  zmutex_unlock(self->mutex);
}

// zctx_set_rcvhwm
// file src/zctx.c line 240
void zctx_set_rcvhwm(struct _zctx_t *self, signed int rcvhwm)
{
  /* assertion self */
  assert(self != ((struct _zctx_t *)NULL));
  zmutex_lock(self->mutex);
  self->rcvhwm = rcvhwm;
  zmutex_unlock(self->mutex);
}

// zctx_set_sndhwm
// file src/zctx.c line 225
void zctx_set_sndhwm(struct _zctx_t *self, signed int sndhwm)
{
  /* assertion self */
  assert(self != ((struct _zctx_t *)NULL));
  zmutex_lock(self->mutex);
  self->sndhwm = sndhwm;
  zmutex_unlock(self->mutex);
}

// zctx_shadow
// file src/../include/zctx.h line 33
struct _zctx_t * zctx_shadow(struct _zctx_t *ctx)
{
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  if(ctx->context == NULL)
  {
    zctx__initialize_underlying(ctx);
    if(!(ctx->context == NULL))
      goto __CPROVER_DUMP_L1;

    return (struct _zctx_t *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    struct _zctx_t *self;
    self=zctx_shadow_zmq_ctx(ctx->context);
    if(!(self == ((struct _zctx_t *)NULL)))
    {
      self->pipehwm = ctx->pipehwm;
      self->sndhwm = ctx->sndhwm;
      self->rcvhwm = ctx->rcvhwm;
      self->linger = ctx->linger;
    }

    return self;
  }
}

// zctx_shadow_zmq_ctx
// file src/../include/zctx.h line 38
struct _zctx_t * zctx_shadow_zmq_ctx(void *zmqctx)
{
  /* assertion zmqctx */
  assert(zmqctx != NULL);
  struct _zctx_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link30(sizeof(struct _zctx_t) /*48ul*/ , "src/zctx.c", (unsigned int)152);
  self = (struct _zctx_t *)return_value_safe_malloc_1;
  if(self == ((struct _zctx_t *)NULL))
    return (struct _zctx_t *)(void *)0;

  else
  {
    self->shadow = (_Bool)1;
    self->sockets=zlist_new();
    self->mutex=zmutex_new();
    _Bool tmp_if_expr_2;
    if(self->sockets == ((struct _zlist_t *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = !(self->mutex != ((struct _zmutex_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      zctx_destroy(&self);
      return (struct _zctx_t *)(void *)0;
    }

    else
    {
      self->context = zmqctx;
      self->pipehwm = 1000;
      self->sndhwm = 1000;
      self->rcvhwm = 1000;
      return self;
    }
  }
}

// zctx_test
// file src/zctx.c line 346
void zctx_test(_Bool verbose)
{
  printf(" * zctx (deprecated): ");
  struct _zctx_t *ctx;
  ctx=zctx_new();
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  zctx_destroy(&ctx);
  /* assertion ctx == ((void *)0) */
  assert(ctx == (struct _zctx_t *)(void *)0);
  ctx=zctx_new();
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  zctx_set_iothreads(ctx, 1);
  zctx_set_linger(ctx, 5);
  void *s1;
  s1=zctx__socket_new(ctx, 0);
  /* assertion s1 */
  assert(s1 != NULL);
  void *s2;
  s2=zctx__socket_new(ctx, 5);
  /* assertion s2 */
  assert(s2 != NULL);
  void *s3;
  s3=zctx__socket_new(ctx, 3);
  /* assertion s3 */
  assert(s3 != NULL);
  void *s4;
  s4=zctx__socket_new(ctx, 4);
  /* assertion s4 */
  assert(s4 != NULL);
  void *s5;
  s5=zctx__socket_new(ctx, 1);
  /* assertion s5 */
  assert(s5 != NULL);
  void *s6;
  s6=zctx__socket_new(ctx, 2);
  /* assertion s6 */
  assert(s6 != NULL);
  signed int rc;
  rc=zsocket_connect(s1, "tcp://127.0.0.1:5555");
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsocket_connect(s2, "tcp://127.0.0.1:5555");
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsocket_connect(s3, "tcp://127.0.0.1:5555");
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsocket_connect(s4, "tcp://127.0.0.1:5555");
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsocket_connect(s5, "tcp://127.0.0.1:5555");
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsocket_connect(s6, "tcp://127.0.0.1:5555");
  /* assertion rc == 0 */
  assert(rc == 0);
  void *return_value_zctx_underlying_1;
  return_value_zctx_underlying_1=zctx_underlying(ctx);
  /* assertion zctx_underlying (ctx) */
  assert(return_value_zctx_underlying_1 != NULL);
  zctx_destroy(&ctx);
  printf("OK\n");
}

// zctx_underlying
// file src/zctx.c line 253
void * zctx_underlying(struct _zctx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zctx_t *)NULL));
  return self->context;
}

// zdigest_data
// file src/zdigest.c line 90
unsigned char * zdigest_data(struct _zdigest_t *self)
{
  /* assertion self */
  assert(self != ((struct _zdigest_t *)NULL));
  if(self->final == (_Bool)0)
  {
    sha1_result(&self->context, self->hash);
    self->final = (_Bool)1;
  }

  return self->hash;
}

// zdigest_destroy
// file src/../include/zdigest.h line 29
void zdigest_destroy(struct _zdigest_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zdigest_t **)NULL));
  if(!(*self_p == ((struct _zdigest_t *)NULL)))
  {
    struct _zdigest_t *self = *self_p;
    free((void *)self);
    *self_p = (struct _zdigest_t *)(void *)0;
  }

}

// zdigest_new
// file src/../include/zdigest.h line 25
struct _zdigest_t * zdigest_new(void)
{
  struct _zdigest_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link8(sizeof(struct _zdigest_t) /*168ul*/ , "src/zdigest.c", (unsigned int)50);
  self = (struct _zdigest_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _zdigest_t *)NULL)))
    sha1_init(&self->context);

  return self;
}

// zdigest_size
// file src/zdigest.c line 105
unsigned long int zdigest_size(struct _zdigest_t *self)
{
  /* assertion self */
  assert(self != ((struct _zdigest_t *)NULL));
  return (unsigned long int)20;
}

// zdigest_string
// file src/../include/zdigest.h line 48
char * zdigest_string(struct _zdigest_t *self)
{
  /* assertion self */
  assert(self != ((struct _zdigest_t *)NULL));
  unsigned char *data;
  data=zdigest_data(self);
  char hex_char[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 0 };
  signed int byte_nbr = 0;
  for( ; !(byte_nbr >= 20); byte_nbr = byte_nbr + 1)
  {
    self->string[(signed long int)(byte_nbr * 2 + 0)] = hex_char[(signed long int)((signed int)data[(signed long int)byte_nbr] >> 4)];
    self->string[(signed long int)(byte_nbr * 2 + 1)] = hex_char[(signed long int)((signed int)data[(signed long int)byte_nbr] & 15)];
  }
  self->string[(signed long int)(20 * 2)] = (char)0;
  return self->string;
}

// zdigest_test
// file src/zdigest.c line 137
void zdigest_test(_Bool verbose)
{
  printf(" * zdigest: ");
  unsigned char *buffer;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link8((unsigned long int)1024, "src/zdigest.c", (unsigned int)142);
  buffer = (unsigned char *)return_value_safe_malloc_1;
  memset((void *)buffer, 0xAA, (unsigned long int)1024);
  struct _zdigest_t *digest;
  digest=zdigest_new();
  /* assertion digest */
  assert(digest != ((struct _zdigest_t *)NULL));
  zdigest_update(digest, buffer, (unsigned long int)1024);
  unsigned char *data;
  data=zdigest_data(digest);
  /* assertion data [0] == 0xDE */
  assert((signed int)data[(signed long int)0] == 0xDE);
  /* assertion data [1] == 0xB2 */
  assert((signed int)data[(signed long int)1] == 0xB2);
  /* assertion data [2] == 0x38 */
  assert((signed int)data[(signed long int)2] == 0x38);
  /* assertion data [3] == 0x07 */
  assert((signed int)data[(signed long int)3] == 0x07);
  char *return_value_zdigest_string_2;
  return_value_zdigest_string_2=zdigest_string(digest);
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(return_value_zdigest_string_2, "DEB23807D4FE025E900FE9A9C7D8410C3DDE9671");
  /* assertion (!strcmp ((zdigest_string (digest)), ("DEB23807D4FE025E900FE9A9C7D8410C3DDE9671"))) */
  assert(!(return_value_strcmp_3 != 0));
  zdigest_destroy(&digest);
  free((void *)buffer);
  printf("OK\n");
}

// zdigest_update
// file src/../include/zdigest.h line 33
void zdigest_update(struct _zdigest_t *self, unsigned char *buffer, unsigned long int length)
{
  /* assertion self */
  assert(self != ((struct _zdigest_t *)NULL));
  /* assertion !self->final */
  assert(!(self->final != (_Bool)0));
  sha1_loop(&self->context, buffer, length);
}

// zdir_cache
// file src/zdir.c line 574
struct _zhash_t * zdir_cache(struct _zdir_t *self)
{
  /* assertion self */
  assert(self != ((struct _zdir_t *)NULL));
  struct _zhash_t *cache;
  cache=zhash_new();
  if(cache == ((struct _zhash_t *)NULL))
    return (struct _zhash_t *)(void *)0;

  else
  {
    zhash_autofree(cache);
    char *cache_file;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(self->path);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen("/.cache");
    void *return_value_safe_malloc_3;
    return_value_safe_malloc_3=safe_malloc_link9(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)1, "src/zdir.c", (unsigned int)583);
    cache_file = (char *)return_value_safe_malloc_3;
    if(cache_file == ((char *)NULL))
    {
      zhash_destroy(&cache);
      return (struct _zhash_t *)(void *)0;
    }

    else
    {
      sprintf(cache_file, "%s/.cache", self->path);
      zhash_load(cache, cache_file);
      struct _zfile_t **files;
      files=zdir_flatten(self);
      unsigned int index = (unsigned int)0;
      do
      {
        struct _zfile_t *file = files[(signed long int)index];
        if(file == ((struct _zfile_t *)NULL))
          break;

        const char *filename;
        filename=zfile_filename(file, self->path);
        const char *return_value_zfile_filename_5;
        return_value_zfile_filename_5=zfile_filename(file, self->path);
        void *return_value_zhash_lookup_6;
        return_value_zhash_lookup_6=zhash_lookup(cache, return_value_zfile_filename_5);
        if(return_value_zhash_lookup_6 == NULL)
        {
          signed int rc;
          const char *return_value_zfile_digest_4;
          return_value_zfile_digest_4=zfile_digest(file);
          rc=zhash_insert(cache, filename, (void *)return_value_zfile_digest_4);
          if(!(rc == 0))
          {
            zhash_destroy(&cache);
            break;
          }

        }

        index = index + 1u;
      }
      while((_Bool)1);
      free((void *)files);
      if(!(cache == ((struct _zhash_t *)NULL)))
        zhash_save(cache, cache_file);

      free((void *)cache_file);
      return cache;
    }
  }
}

// zdir_count
// file src/../include/zdir.h line 49
unsigned long int zdir_count(struct _zdir_t *self)
{
  /* assertion self */
  assert(self != ((struct _zdir_t *)NULL));
  return self->count;
}

// zdir_cursize
// file src/../include/zdir.h line 45
signed long int zdir_cursize(struct _zdir_t *self)
{
  /* assertion self */
  assert(self != ((struct _zdir_t *)NULL));
  return self->cursize;
}

// zdir_destroy
// file src/../include/zdir.h line 32
void zdir_destroy(struct _zdir_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zdir_t **)NULL));
  unsigned long int return_value_zlist_size_1;
  unsigned long int return_value_zlist_size_3;
  if(!(*self_p == ((struct _zdir_t *)NULL)))
  {
    struct _zdir_t *self = *self_p;
    if(!(self->subdirs == ((struct _zlist_t *)NULL)))
      do
      {
        return_value_zlist_size_1=zlist_size(self->subdirs);
        if(return_value_zlist_size_1 == 0ul)
          break;

        struct _zdir_t *subdir;
        void *return_value_zlist_pop_2;
        return_value_zlist_pop_2=zlist_pop(self->subdirs);
        subdir = (struct _zdir_t *)return_value_zlist_pop_2;
        zdir_destroy(&subdir);
      }
      while((_Bool)1);

    if(!(self->files == ((struct _zlist_t *)NULL)))
      do
      {
        return_value_zlist_size_3=zlist_size(self->files);
        if(return_value_zlist_size_3 == 0ul)
          break;

        struct _zfile_t *file;
        void *return_value_zlist_pop_4;
        return_value_zlist_pop_4=zlist_pop(self->files);
        file = (struct _zfile_t *)return_value_zlist_pop_4;
        zfile_destroy(&file);
      }
      while((_Bool)1);

    zlist_destroy(&self->subdirs);
    zlist_destroy(&self->files);
    free((void *)self->path);
    free((void *)self);
    *self_p = (struct _zdir_t *)(void *)0;
  }

}

// zdir_diff
// file src/zdir.c line 456
struct _zlist_t * zdir_diff(struct _zdir_t *older, struct _zdir_t *newer, const char *alias)
{
  struct _zlist_t *patches;
  patches=zlist_new();
  const char *return_value_zfile_filename_1;
  const char *return_value_zfile_filename_2;
  _Bool return_value_zfile_is_stable_15;
  signed long int return_value_zfile_cursize_10;
  signed long int return_value_zfile_cursize_11;
  if(patches == ((struct _zlist_t *)NULL))
    return (struct _zlist_t *)(void *)0;

  else
  {
    struct _zfile_t **old_files;
    old_files=zdir_flatten(older);
    struct _zfile_t **new_files;
    new_files=zdir_flatten(newer);
    signed int old_index = 0;
    signed int new_index = 0;
    while((_Bool)1)
    {
      if(old_files[(signed long int)old_index] == ((struct _zfile_t *)NULL))
      {
        if(new_files[(signed long int)new_index] == ((struct _zfile_t *)NULL))
          goto __CPROVER_DUMP_L22;

      }

      struct _zfile_t *old_file = old_files[(signed long int)old_index];
      struct _zfile_t *new_file = new_files[(signed long int)new_index];
      signed int cmp;
      if(old_file == ((struct _zfile_t *)NULL))
        cmp = 1;

      else
        if(new_file == ((struct _zfile_t *)NULL))
          cmp = -1;

        else
        {
          return_value_zfile_filename_1=zfile_filename(old_file, (const char *)(void *)0);
          return_value_zfile_filename_2=zfile_filename(new_file, (const char *)(void *)0);
          cmp=strcmp(return_value_zfile_filename_1, return_value_zfile_filename_2);
        }
      if(cmp >= 1)
      {
        _Bool return_value_zfile_is_stable_4;
        return_value_zfile_is_stable_4=zfile_is_stable(new_file);
        if(!(return_value_zfile_is_stable_4 == (_Bool)0))
        {
          signed int rc;
          struct _zdir_patch_t *return_value_zdir_patch_new_3;
          return_value_zdir_patch_new_3=zdir_patch_new(newer->path, new_file, (enum anonymous_6)ZDIR_PATCH_CREATE, alias);
          rc=zlist_append(patches, (void *)return_value_zdir_patch_new_3);
          if(!(rc == 0))
          {
            zlist_destroy(&patches);
            break;
          }

        }

        old_index = old_index - 1;
      }

      else
        if(!(cmp >= 0))
        {
          _Bool return_value_zfile_is_stable_6;
          return_value_zfile_is_stable_6=zfile_is_stable(old_file);
          if(!(return_value_zfile_is_stable_6 == (_Bool)0))
          {
            signed int zdir_diff__1__1__2__1__rc;
            struct _zdir_patch_t *return_value_zdir_patch_new_5;
            return_value_zdir_patch_new_5=zdir_patch_new(older->path, old_file, (enum anonymous_6)ZDIR_PATCH_DELETE, alias);
            zdir_diff__1__1__2__1__rc=zlist_append(patches, (void *)return_value_zdir_patch_new_5);
            if(!(zdir_diff__1__1__2__1__rc == 0))
            {
              zlist_destroy(&patches);
              break;
            }

          }

          new_index = new_index - 1;
        }

        else
          if(cmp == 0)
          {
            return_value_zfile_is_stable_15=zfile_is_stable(new_file);
            if(!(return_value_zfile_is_stable_15 == (_Bool)0))
            {
              _Bool return_value_zfile_is_stable_14;
              return_value_zfile_is_stable_14=zfile_is_stable(old_file);
              if(!(return_value_zfile_is_stable_14 == (_Bool)0))
              {
                signed long int return_value_zfile_modified_8;
                return_value_zfile_modified_8=zfile_modified(new_file);
                signed long int return_value_zfile_modified_9;
                return_value_zfile_modified_9=zfile_modified(old_file);
                _Bool tmp_if_expr_12;
                if(!(return_value_zfile_modified_8 == return_value_zfile_modified_9))
                  tmp_if_expr_12 = (_Bool)1;

                else
                {
                  return_value_zfile_cursize_10=zfile_cursize(new_file);
                  return_value_zfile_cursize_11=zfile_cursize(old_file);
                  tmp_if_expr_12 = return_value_zfile_cursize_10 != return_value_zfile_cursize_11 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_12)
                {
                  signed int zdir_diff__1__1__3__1__1__rc;
                  struct _zdir_patch_t *return_value_zdir_patch_new_7;
                  return_value_zdir_patch_new_7=zdir_patch_new(newer->path, new_file, (enum anonymous_6)ZDIR_PATCH_CREATE, alias);
                  zdir_diff__1__1__3__1__1__rc=zlist_append(patches, (void *)return_value_zdir_patch_new_7);
                  if(!(zdir_diff__1__1__3__1__1__rc == 0))
                  {
                    zlist_destroy(&patches);
                    break;
                  }

                }

              }

              else
              {
                signed int zdir_diff__1__1__3__2__rc;
                struct _zdir_patch_t *return_value_zdir_patch_new_13;
                return_value_zdir_patch_new_13=zdir_patch_new(newer->path, new_file, (enum anonymous_6)ZDIR_PATCH_CREATE, alias);
                zdir_diff__1__1__3__2__rc=zlist_append(patches, (void *)return_value_zdir_patch_new_13);
                if(!(zdir_diff__1__1__3__2__rc == 0))
                {
                  zlist_destroy(&patches);
                  break;
                }

              }
            }

          }

      old_index = old_index + 1;
      new_index = new_index + 1;
    }

  __CPROVER_DUMP_L22:
    ;
    free((void *)old_files);
    free((void *)new_files);
    return patches;
  }
}

// zdir_flatten
// file src/../include/zdir.h line 131
struct _zfile_t ** zdir_flatten(struct _zdir_t *self)
{
  unsigned long int flat_size;
  if(!(self == ((struct _zdir_t *)NULL)))
    flat_size = self->count + (unsigned long int)1;

  else
    flat_size = (unsigned long int)1;
  struct _zfile_t **files;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link9(sizeof(struct _zfile_t *) /*8ul*/  * flat_size, "src/zdir.c", (unsigned int)327);
  files = (struct _zfile_t **)return_value_safe_malloc_1;
  unsigned int index = (unsigned int)0;
  signed int return_value_s_dir_flatten_2;
  if(!(self == ((struct _zdir_t *)NULL)))
  {
    return_value_s_dir_flatten_2=s_dir_flatten(self, files, (signed int)index);
    index = (unsigned int)return_value_s_dir_flatten_2;
  }

  return files;
}

// zdir_flatten_free
// file src/../include/zdir.h line 136
void zdir_flatten_free(struct _zfile_t ***files_p)
{
  /* assertion files_p */
  assert(files_p != ((struct _zfile_t ***)NULL));
  free((void *)*files_p);
  *files_p = (struct _zfile_t **)(void *)0;
}

// zdir_fprint
// file src/zdir.c line 621
void zdir_fprint(struct _zdir_t *self, struct _IO_FILE *stream, signed int indent)
{
  /* assertion self */
  assert(self != ((struct _zdir_t *)NULL));
  struct _zfile_t **files;
  files=zdir_flatten(self);
  unsigned int index = (unsigned int)0;
  do
  {
    struct _zfile_t *file = files[(signed long int)index];
    if(file == ((struct _zfile_t *)NULL))
      break;

    const char *return_value_zfile_filename_1;
    return_value_zfile_filename_1=zfile_filename(file, (const char *)(void *)0);
    fprintf(stream, "%s\n", return_value_zfile_filename_1);
    index = index + 1u;
  }
  while((_Bool)1);
  zdir_flatten_free(&files);
}

// zdir_list
// file src/zdir.c line 399
struct _zlist_t * zdir_list(struct _zdir_t *self)
{
  struct _zfile_t **files;
  files=zdir_flatten(self);
  struct _zlist_t *list;
  list=zlist_new();
  unsigned long int index;
  if(!(files == ((struct _zfile_t **)NULL)))
  {
    index = (unsigned long int)0;
    for( ; !(files[(signed long int)index] == ((struct _zfile_t *)NULL)); index = index + 1ul)
      zlist_append(list, (void *)files[(signed long int)index]);
  }

  zdir_flatten_free(&files);
  return list;
}

// zdir_modified
// file src/../include/zdir.h line 40
signed long int zdir_modified(struct _zdir_t *self)
{
  /* assertion self */
  assert(self != ((struct _zdir_t *)NULL));
  return self->modified;
}

// zdir_new
// file src/../include/zdir.h line 28
struct _zdir_t * zdir_new(const char *path, const char *parent)
{
  struct _zdir_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link9(sizeof(struct _zdir_t) /*56ul*/ , "src/zdir.c", (unsigned int)115);
  self = (struct _zdir_t *)return_value_safe_malloc_1;
  unsigned long int return_value_strlen_6;
  if(self == ((struct _zdir_t *)NULL))
    return (struct _zdir_t *)(void *)0;

  else
  {
    if(!(parent == ((const char *)NULL)))
    {
      signed int return_value_strcmp_5;
      return_value_strcmp_5=strcmp(parent, "-");
      if(return_value_strcmp_5 == 0)
      {
        self->trimmed = (_Bool)1;
        self->path=strdup(path);
        if(self->path == ((char *)NULL))
        {
          zdir_destroy(&self);
          return (struct _zdir_t *)(void *)0;
        }

      }

      else
      {
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(path);
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(parent);
        void *return_value_safe_malloc_4;
        return_value_safe_malloc_4=safe_malloc_link9(return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)2, "src/zdir.c", (unsigned int)129);
        self->path = (char *)return_value_safe_malloc_4;
        if(!(self->path == ((char *)NULL)))
          sprintf(self->path, "%s/%s", parent, path);

        else
        {
          zdir_destroy(&self);
          return (struct _zdir_t *)(void *)0;
        }
      }
    }

    else
    {
      self->path=strdup(path);
      if(self->path == ((char *)NULL))
      {
        zdir_destroy(&self);
        return (struct _zdir_t *)(void *)0;
      }

    }
    if(!(self->path == ((char *)NULL)))
      self->files=zlist_new();

    if(!(self->files == ((struct _zlist_t *)NULL)))
      self->subdirs=zlist_new();

    if(self->subdirs == ((struct _zlist_t *)NULL))
    {
      zdir_destroy(&self);
      return (struct _zdir_t *)(void *)0;
    }

    else
    {
      unsigned long int return_value_strlen_7;
      return_value_strlen_7=strlen(self->path);
      if((signed int)self->path[-1l + (signed long int)return_value_strlen_7] == 47)
      {
        return_value_strlen_6=strlen(self->path);
        self->path[(signed long int)(return_value_strlen_6 - (unsigned long int)1)] = (char)0;
      }

      struct __dirstream *handle;
      handle=opendir(self->path);
      if(!(handle == ((struct __dirstream *)NULL)))
      {
        signed int dirent_size;
        signed long int return_value_pathconf_8;
        return_value_pathconf_8=pathconf(self->path, 3);
        dirent_size = (signed int)(19ul + (unsigned long int)return_value_pathconf_8 + (unsigned long int)1);
        struct dirent *entry;
        void *return_value_safe_malloc_9;
        return_value_safe_malloc_9=safe_malloc_link9((unsigned long int)dirent_size, "src/zdir.c", (unsigned int)194);
        entry = (struct dirent *)return_value_safe_malloc_9;
        if(entry == ((struct dirent *)NULL))
        {
          zdir_destroy(&self);
          return (struct _zdir_t *)(void *)0;
        }

        struct dirent *result;
        signed int rc;
        rc=readdir_r(handle, entry, &result);
        while(rc == 0 && !(result == ((struct dirent *)NULL)))
        {
          s_posix_populate_entry(self, entry);
          rc=readdir_r(handle, entry, &result);
        }
        free((void *)entry);
        closedir(handle);
      }

      else
      {
        zdir_destroy(&self);
        return (struct _zdir_t *)(void *)0;
      }
      struct _zdir_t *subdir;
      void *return_value_zlist_first_10;
      return_value_zlist_first_10=zlist_first(self->subdirs);
      subdir = (struct _zdir_t *)return_value_zlist_first_10;
      while(!(subdir == ((struct _zdir_t *)NULL)))
      {
        if(!(self->modified >= subdir->modified))
          self->modified = subdir->modified;

        self->cursize = self->cursize + subdir->cursize;
        self->count = self->count + subdir->count;
        void *return_value_zlist_next_11;
        return_value_zlist_next_11=zlist_next(self->subdirs);
        subdir = (struct _zdir_t *)return_value_zlist_next_11;
      }
      struct _zfile_t *file;
      void *return_value_zlist_first_12;
      return_value_zlist_first_12=zlist_first(self->files);
      file = (struct _zfile_t *)return_value_zlist_first_12;
      while(!(file == ((struct _zfile_t *)NULL)))
      {
        signed long int return_value_zfile_modified_13;
        return_value_zfile_modified_13=zfile_modified(file);
        if(!(self->modified >= return_value_zfile_modified_13))
          self->modified=zfile_modified(file);

        signed long int return_value_zfile_cursize_14;
        return_value_zfile_cursize_14=zfile_cursize(file);
        self->cursize = self->cursize + return_value_zfile_cursize_14;
        self->count = self->count + (unsigned long int)1;
        void *return_value_zlist_next_15;
        return_value_zlist_next_15=zlist_next(self->files);
        file = (struct _zfile_t *)return_value_zlist_next_15;
      }
      return self;
    }
  }
}

// zdir_patch_destroy
// file src/../include/zdir_patch.h line 39
void zdir_patch_destroy(struct _zdir_patch_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zdir_patch_t **)NULL));
  if(!(*self_p == ((struct _zdir_patch_t *)NULL)))
  {
    struct _zdir_patch_t *self = *self_p;
    free((void *)self->path);
    free((void *)self->vpath);
    free((void *)self->digest);
    zfile_destroy(&self->file);
    free((void *)self);
    *self_p = (struct _zdir_patch_t *)(void *)0;
  }

}

// zdir_patch_digest
// file src/zdir_patch.c line 190
const char * zdir_patch_digest(struct _zdir_patch_t *self)
{
  /* assertion self */
  assert(self != ((struct _zdir_patch_t *)NULL));
  return self->digest;
}

// zdir_patch_digest_set
// file src/zdir_patch.c line 175
void zdir_patch_digest_set(struct _zdir_patch_t *self)
{
  if((signed int)self->op == ZDIR_PATCH_CREATE)
  {
    if(self->digest == ((char *)NULL))
    {
      const char *return_value_zfile_digest_1;
      return_value_zfile_digest_1=zfile_digest(self->file);
      self->digest=strdup(return_value_zfile_digest_1);
      /* assertion self->digest */
      assert(self->digest != ((char *)NULL));
    }

  }

}

// zdir_patch_dup
// file src/zdir_patch.c line 102
struct _zdir_patch_t * zdir_patch_dup(struct _zdir_patch_t *self)
{
  char *return_value_strdup_2;
  if(!(self == ((struct _zdir_patch_t *)NULL)))
  {
    struct _zdir_patch_t *copy;
    void *return_value_safe_malloc_1;
    return_value_safe_malloc_1=safe_malloc_link10(sizeof(struct _zdir_patch_t) /*40ul*/ , "src/zdir_patch.c", (unsigned int)105);
    copy = (struct _zdir_patch_t *)return_value_safe_malloc_1;
    if(!(copy == ((struct _zdir_patch_t *)NULL)))
    {
      copy->op = self->op;
      copy->path=strdup(self->path);
      if(!(copy->path == ((char *)NULL)))
        copy->file=zfile_dup(self->file);

      if(!(copy->file == ((struct _zfile_t *)NULL)))
        copy->vpath=strdup(self->vpath);

      if(!(copy->vpath == ((char *)NULL)))
      {
        char *tmp_if_expr_3;
        if(!(self->digest == ((char *)NULL)))
        {
          return_value_strdup_2=strdup(self->digest);
          tmp_if_expr_3 = return_value_strdup_2;
        }

        else
          tmp_if_expr_3 = (char *)(void *)0;
        copy->digest = tmp_if_expr_3;
      }

      if(copy->digest == ((char *)NULL))
      {
        if(!((signed int)copy->op == ZDIR_PATCH_DELETE))
          zdir_patch_destroy(&copy);

      }

    }

    return copy;
  }

  else
    return (struct _zdir_patch_t *)(void *)0;
}

// zdir_patch_file
// file src/../include/zdir_patch.h line 53
struct _zfile_t * zdir_patch_file(struct _zdir_patch_t *self)
{
  /* assertion self */
  assert(self != ((struct _zdir_patch_t *)NULL));
  return self->file;
}

// zdir_patch_new
// file src/../include/zdir_patch.h line 35
struct _zdir_patch_t * zdir_patch_new(const char *path, struct _zfile_t *file, enum anonymous_6 op, const char *alias)
{
  struct _zdir_patch_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link10(sizeof(struct _zdir_patch_t) /*40ul*/ , "src/zdir_patch.c", (unsigned int)45);
  self = (struct _zdir_patch_t *)return_value_safe_malloc_1;
  if(self == ((struct _zdir_patch_t *)NULL))
    return (struct _zdir_patch_t *)(void *)0;

  else
  {
    self->path=strdup(path);
    if(!(self->path == ((char *)NULL)))
      self->file=zfile_dup(file);

    if(self->file == ((struct _zfile_t *)NULL))
    {
      zdir_patch_destroy(&self);
      return (struct _zdir_patch_t *)(void *)0;
    }

    else
    {
      self->op = op;
      const char *filename;
      filename=zfile_filename(file, path);
      if(filename == ((const char *)NULL))
      {
        zdir_patch_destroy(&self);
        return (struct _zdir_patch_t *)(void *)0;
      }

      else
      {
        /* assertion *filename != '/' */
        assert((signed int)*filename != 47);
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(alias);
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(filename);
        void *return_value_safe_malloc_4;
        return_value_safe_malloc_4=safe_malloc_link10(return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)2, "src/zdir_patch.c", (unsigned int)65);
        self->vpath = (char *)return_value_safe_malloc_4;
        if(self->vpath == ((char *)NULL))
        {
          zdir_patch_destroy(&self);
          return (struct _zdir_patch_t *)(void *)0;
        }

        else
        {
          unsigned long int return_value_strlen_5;
          return_value_strlen_5=strlen(alias);
          if((signed int)alias[-1l + (signed long int)return_value_strlen_5] == 47)
            sprintf(self->vpath, "%s%s", alias, filename);

          else
            sprintf(self->vpath, "%s/%s", alias, filename);
          return self;
        }
      }
    }
  }
}

// zdir_patch_op
// file src/../include/zdir_patch.h line 57
enum anonymous_6 zdir_patch_op(struct _zdir_patch_t *self)
{
  /* assertion self */
  assert(self != ((struct _zdir_patch_t *)NULL));
  return self->op;
}

// zdir_patch_path
// file src/../include/zdir_patch.h line 49
const char * zdir_patch_path(struct _zdir_patch_t *self)
{
  /* assertion self */
  assert(self != ((struct _zdir_patch_t *)NULL));
  return self->path;
}

// zdir_patch_test
// file src/zdir_patch.c line 201
void zdir_patch_test(_Bool verbose)
{
  printf(" * zdir_patch: ");
  struct _zfile_t *file;
  file=zfile_new(".", "bilbo");
  /* assertion file */
  assert(file != ((struct _zfile_t *)NULL));
  struct _zdir_patch_t *patch;
  patch=zdir_patch_new(".", file, (enum anonymous_6)ZDIR_PATCH_CREATE, "/");
  /* assertion patch */
  assert(patch != ((struct _zdir_patch_t *)NULL));
  zfile_destroy(&file);
  file=zdir_patch_file(patch);
  /* assertion file */
  assert(file != ((struct _zfile_t *)NULL));
  const char *return_value_zfile_filename_1;
  return_value_zfile_filename_1=zfile_filename(file, ".");
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(return_value_zfile_filename_1, "bilbo");
  /* assertion (!strcmp ((zfile_filename (file, ".")), ("bilbo"))) */
  assert(!(return_value_strcmp_2 != 0));
  const char *return_value_zdir_patch_vpath_3;
  return_value_zdir_patch_vpath_3=zdir_patch_vpath(patch);
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(return_value_zdir_patch_vpath_3, "/bilbo");
  /* assertion (!strcmp ((zdir_patch_vpath (patch)), ("/bilbo"))) */
  assert(!(return_value_strcmp_4 != 0));
  zdir_patch_destroy(&patch);
  printf("OK\n");
}

// zdir_patch_vpath
// file src/zdir_patch.c line 164
const char * zdir_patch_vpath(struct _zdir_patch_t *self)
{
  /* assertion self */
  assert(self != ((struct _zdir_patch_t *)NULL));
  return self->vpath;
}

// zdir_path
// file src/zdir.c line 267
const char * zdir_path(struct _zdir_t *self)
{
  return self->path;
}

// zdir_print
// file src/zdir.c line 641
void zdir_print(struct _zdir_t *self, signed int indent)
{
  zdir_fprint(self, stdout, indent);
}

// zdir_remove
// file src/../include/zdir.h line 62
void zdir_remove(struct _zdir_t *self, _Bool force)
{
  if(!(force == (_Bool)0))
  {
    struct _zfile_t *file;
    void *return_value_zlist_pop_1;
    return_value_zlist_pop_1=zlist_pop(self->files);
    file = (struct _zfile_t *)return_value_zlist_pop_1;
    while(!(file == ((struct _zfile_t *)NULL)))
    {
      zfile_remove(file);
      zfile_destroy(&file);
      void *return_value_zlist_pop_2;
      return_value_zlist_pop_2=zlist_pop(self->files);
      file = (struct _zfile_t *)return_value_zlist_pop_2;
    }
    struct _zdir_t *subdir;
    void *return_value_zlist_pop_3;
    return_value_zlist_pop_3=zlist_pop(self->subdirs);
    subdir = (struct _zdir_t *)return_value_zlist_pop_3;
    while(!(subdir == ((struct _zdir_t *)NULL)))
    {
      zdir_remove(subdir, force);
      zdir_destroy(&subdir);
      void *return_value_zlist_pop_4;
      return_value_zlist_pop_4=zlist_pop(self->subdirs);
      subdir = (struct _zdir_t *)return_value_zlist_pop_4;
    }
    self->cursize = (signed long int)0;
    self->count = (unsigned long int)0;
  }

  unsigned long int return_value_zlist_size_6;
  return_value_zlist_size_6=zlist_size(self->files);
  unsigned long int return_value_zlist_size_5;
  if(return_value_zlist_size_6 == 0ul)
  {
    return_value_zlist_size_5=zlist_size(self->subdirs);
    if(return_value_zlist_size_5 == 0ul)
      zsys_dir_delete(self->path);

  }

}

// zdir_resync
// file src/zdir.c line 545
struct _zlist_t * zdir_resync(struct _zdir_t *self, const char *alias)
{
  struct _zlist_t *patches;
  patches=zlist_new();
  if(patches == ((struct _zlist_t *)NULL))
    return (struct _zlist_t *)(void *)0;

  else
  {
    struct _zfile_t **files;
    files=zdir_flatten(self);
    unsigned int index = (unsigned int)0;
    do
    {
      struct _zfile_t *file = files[(signed long int)index];
      if(file == ((struct _zfile_t *)NULL))
        break;

      struct _zdir_patch_t *return_value_zdir_patch_new_1;
      return_value_zdir_patch_new_1=zdir_patch_new(self->path, file, (enum anonymous_6)ZDIR_PATCH_CREATE, alias);
      signed int return_value_zlist_append_2;
      return_value_zlist_append_2=zlist_append(patches, (void *)return_value_zdir_patch_new_1);
      if(!(return_value_zlist_append_2 == 0))
      {
        zlist_destroy(&patches);
        break;
      }

      index = index + 1u;
    }
    while((_Bool)1);
    free((void *)files);
    return patches;
  }
}

// zdir_test
// file src/zdir.c line 933
void zdir_test(_Bool verbose)
{
  printf(" * zdir: ");
  struct _zdir_t *older;
  older=zdir_new(".", (const char *)(void *)0);
  /* assertion older */
  assert(older != ((struct _zdir_t *)NULL));
  if(!(verbose == (_Bool)0))
  {
    printf("\n");
    zdir_print(older, 0);
  }

  struct _zdir_t *newer;
  newer=zdir_new("..", (const char *)(void *)0);
  /* assertion newer */
  assert(newer != ((struct _zdir_t *)NULL));
  struct _zlist_t *patches;
  patches=zdir_diff(older, newer, "/");
  /* assertion patches */
  assert(patches != ((struct _zlist_t *)NULL));
  unsigned long int return_value_zlist_size_1;
  do
  {
    return_value_zlist_size_1=zlist_size(patches);
    if(return_value_zlist_size_1 == 0ul)
      break;

    struct _zdir_patch_t *zdir_test__1__2__patch;
    void *return_value_zlist_pop_2;
    return_value_zlist_pop_2=zlist_pop(patches);
    zdir_test__1__2__patch = (struct _zdir_patch_t *)return_value_zlist_pop_2;
    zdir_patch_destroy(&zdir_test__1__2__patch);
  }
  while((_Bool)1);
  zlist_destroy(&patches);
  zdir_destroy(&older);
  zdir_destroy(&newer);
  struct _zdir_t *nosuch;
  nosuch=zdir_new("does-not-exist", (const char *)(void *)0);
  /* assertion nosuch == ((void *)0) */
  assert(nosuch == (struct _zdir_t *)(void *)0);
  struct _zactor_t *watch;
  watch=zactor_new(zdir_watch, (void *)0);
  /* assertion watch */
  assert(watch != ((struct _zactor_t *)NULL));
  if(!(verbose == (_Bool)0))
  {
    zsock_send((void *)watch, "s", (const void *)"VERBOSE");
    signed int return_value_zsock_wait_3;
    return_value_zsock_wait_3=zsock_wait((void *)watch);
    /* assertion zsock_wait (watch) == 0 */
    assert(return_value_zsock_wait_3 == 0);
  }

  struct _zfile_t *initfile;
  initfile=zfile_new("./zdir-test-dir", "initial_file");
  /* assertion initfile */
  assert(initfile != ((struct _zfile_t *)NULL));
  zfile_output(initfile);
  struct _IO_FILE *return_value_zfile_handle_4;
  return_value_zfile_handle_4=zfile_handle(initfile);
  fprintf(return_value_zfile_handle_4, "initial file\n");
  zfile_close(initfile);
  zfile_destroy(&initfile);
  zclock_sleep(1001);
  zsock_send((void *)watch, "si", (const void *)"TIMEOUT", 100);
  signed int return_value_zsock_wait_5;
  return_value_zsock_wait_5=zsock_wait((void *)watch);
  /* assertion zsock_wait (watch) == 0 */
  assert(return_value_zsock_wait_5 == 0);
  zsock_send((void *)watch, "ss", (const void *)"SUBSCRIBE", (const void *)"zdir-test-dir");
  signed int return_value_zsock_wait_6;
  return_value_zsock_wait_6=zsock_wait((void *)watch);
  /* assertion zsock_wait (watch) == 0 */
  assert(return_value_zsock_wait_6 == 0);
  zsock_send((void *)watch, "ss", (const void *)"UNSUBSCRIBE", (const void *)"zdir-test-dir");
  signed int return_value_zsock_wait_7;
  return_value_zsock_wait_7=zsock_wait((void *)watch);
  /* assertion zsock_wait (watch) == 0 */
  assert(return_value_zsock_wait_7 == 0);
  zsock_send((void *)watch, "ss", (const void *)"SUBSCRIBE", (const void *)"zdir-test-dir");
  signed int return_value_zsock_wait_8;
  return_value_zsock_wait_8=zsock_wait((void *)watch);
  /* assertion zsock_wait (watch) == 0 */
  assert(return_value_zsock_wait_8 == 0);
  struct _zfile_t *newfile;
  newfile=zfile_new("zdir-test-dir", "test_abc");
  zfile_output(newfile);
  struct _IO_FILE *return_value_zfile_handle_9;
  return_value_zfile_handle_9=zfile_handle(newfile);
  fprintf(return_value_zfile_handle_9, "test file\n");
  zfile_close(newfile);
  struct _zpoller_t *watch_poll;
  watch_poll=zpoller_new((void *)watch, (void *)0);
  void *return_value_zpoller_wait_10;
  return_value_zpoller_wait_10=zpoller_wait(watch_poll, 1001);
  /* assertion zpoller_wait (watch_poll, 1001) == watch */
  assert((struct _zactor_t *)return_value_zpoller_wait_10 == watch);
  char *path;
  signed int rc;
  rc=zsock_recv((void *)watch, "sp", &path, &patches);
  /* assertion rc == 0 */
  assert(rc == 0);
  signed int return_value_strcmp_11;
  return_value_strcmp_11=strcmp(path, "zdir-test-dir");
  /* assertion (!strcmp ((path), ("zdir-test-dir"))) */
  assert(!(return_value_strcmp_11 != 0));
  free((void *)path);
  unsigned long int return_value_zlist_size_12;
  return_value_zlist_size_12=zlist_size(patches);
  /* assertion zlist_size (patches) == 1 */
  assert(return_value_zlist_size_12 == (unsigned long int)1);
  struct _zdir_patch_t *patch;
  void *return_value_zlist_pop_13;
  return_value_zlist_pop_13=zlist_pop(patches);
  patch = (struct _zdir_patch_t *)return_value_zlist_pop_13;
  const char *return_value_zdir_patch_path_14;
  return_value_zdir_patch_path_14=zdir_patch_path(patch);
  signed int return_value_strcmp_15;
  return_value_strcmp_15=strcmp(return_value_zdir_patch_path_14, "zdir-test-dir");
  /* assertion (!strcmp ((zdir_patch_path (patch)), ("zdir-test-dir"))) */
  assert(!(return_value_strcmp_15 != 0));
  struct _zfile_t *patch_file;
  patch_file=zdir_patch_file(patch);
  const char *return_value_zfile_filename_16;
  return_value_zfile_filename_16=zfile_filename(patch_file, "");
  signed int return_value_strcmp_17;
  return_value_strcmp_17=strcmp(return_value_zfile_filename_16, "zdir-test-dir/test_abc");
  /* assertion (!strcmp ((zfile_filename (patch_file, "")), ("zdir-test-dir/test_abc"))) */
  assert(!(return_value_strcmp_17 != 0));
  zdir_patch_destroy(&patch);
  zlist_destroy(&patches);
  zfile_remove(newfile);
  zfile_destroy(&newfile);
  void *return_value_zpoller_wait_18;
  return_value_zpoller_wait_18=zpoller_wait(watch_poll, 1001);
  /* assertion zpoller_wait (watch_poll, 1001) == watch */
  assert((struct _zactor_t *)return_value_zpoller_wait_18 == watch);
  rc=zsock_recv((void *)watch, "sp", &path, &patches);
  /* assertion rc == 0 */
  assert(rc == 0);
  signed int return_value_strcmp_19;
  return_value_strcmp_19=strcmp(path, "zdir-test-dir");
  /* assertion (!strcmp ((path), ("zdir-test-dir"))) */
  assert(!(return_value_strcmp_19 != 0));
  free((void *)path);
  unsigned long int return_value_zlist_size_20;
  return_value_zlist_size_20=zlist_size(patches);
  /* assertion zlist_size (patches) == 1 */
  assert(return_value_zlist_size_20 == (unsigned long int)1);
  void *return_value_zlist_pop_21;
  return_value_zlist_pop_21=zlist_pop(patches);
  patch = (struct _zdir_patch_t *)return_value_zlist_pop_21;
  const char *return_value_zdir_patch_path_22;
  return_value_zdir_patch_path_22=zdir_patch_path(patch);
  signed int return_value_strcmp_23;
  return_value_strcmp_23=strcmp(return_value_zdir_patch_path_22, "zdir-test-dir");
  /* assertion (!strcmp ((zdir_patch_path (patch)), ("zdir-test-dir"))) */
  assert(!(return_value_strcmp_23 != 0));
  patch_file=zdir_patch_file(patch);
  const char *return_value_zfile_filename_24;
  return_value_zfile_filename_24=zfile_filename(patch_file, "");
  signed int return_value_strcmp_25;
  return_value_strcmp_25=strcmp(return_value_zfile_filename_24, "zdir-test-dir/test_abc");
  /* assertion (!strcmp ((zfile_filename (patch_file, "")), ("zdir-test-dir/test_abc"))) */
  assert(!(return_value_strcmp_25 != 0));
  zdir_patch_destroy(&patch);
  zlist_destroy(&patches);
  zpoller_destroy(&watch_poll);
  zactor_destroy(&watch);
  struct _zdir_t *testdir;
  testdir=zdir_new("zdir-test-dir", (const char *)(void *)0);
  zdir_remove(testdir, (_Bool)1);
  zdir_destroy(&testdir);
  printf("OK\n");
}

// zdir_watch
// file src/zdir.c line 897
void zdir_watch(struct _zsock_t *pipe, void *unused)
{
  struct _zdir_watch_t *watch;
  watch=s_zdir_watch_new(pipe);
  /* assertion watch */
  assert(watch != ((struct _zdir_watch_t *)NULL));
  watch->loop=zloop_new();
  /* assertion watch->loop */
  assert(watch->loop != ((struct _zloop_t *)NULL));
  watch->subs=zhash_new();
  /* assertion watch->subs */
  assert(watch->subs != ((struct _zhash_t *)NULL));
  zloop_reader(watch->loop, pipe, s_on_command, (void *)watch);
  zloop_reader_set_tolerant(watch->loop, pipe);
  s_zdir_watch_timeout(watch, 250);
  zsock_signal((void *)pipe, (unsigned char)0);
  zloop_start(watch->loop);
  if(!(watch->verbose == (_Bool)0))
    zsys_info("zdir_watch: Complete");

  zsock_signal((void *)watch->pipe, (unsigned char)0);
  s_zdir_watch_destroy(&watch);
}

// zfile_close
// file src/../include/zfile.h line 131
void zfile_close(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  if(!(self->handle == ((struct _IO_FILE *)NULL)))
  {
    fclose(self->handle);
    zfile_restat(self);
    self->handle = ((struct _IO_FILE *)NULL);
    self->eof = (_Bool)0;
  }

}

// zfile_cursize
// file src/../include/zfile.h line 60
signed long int zfile_cursize(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  return self->cursize;
}

// zfile_delete
// file src/zfile.c line 579
signed int zfile_delete(const char *filename)
{
  signed int return_value_zsys_file_delete_1;
  return_value_zsys_file_delete_1=zsys_file_delete(filename);
  return return_value_zsys_file_delete_1;
}

// zfile_destroy
// file src/../include/zfile.h line 34
void zfile_destroy(struct _zfile_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zfile_t **)NULL));
  if(!(*self_p == ((struct _zfile_t *)NULL)))
  {
    struct _zfile_t *self = *self_p;
    zdigest_destroy(&self->digest);
    if(!(self->handle == ((struct _IO_FILE *)NULL)))
      fclose(self->handle);

    free((void *)self->fullname);
    free((void *)self->curline);
    free((void *)self->link);
    free((void *)self);
    *self_p = (struct _zfile_t *)(void *)0;
  }

}

// zfile_digest
// file src/../include/zfile.h line 139
const char * zfile_digest(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  unsigned long int return_value_zchunk_size_2;
  if(self->digest == ((struct _zdigest_t *)NULL))
  {
    signed int return_value_zfile_input_1;
    return_value_zfile_input_1=zfile_input(self);
    if(return_value_zfile_input_1 == -1)
      return (const char *)(void *)0;

    unsigned long int blocksz = (unsigned long int)65535;
    signed long int offset = (signed long int)0;
    self->digest=zdigest_new();
    if(self->digest == ((struct _zdigest_t *)NULL))
      return (const char *)(void *)0;

    struct _zchunk_t *chunk;
    chunk=zfile_read(self, blocksz, offset);
    do
    {
      return_value_zchunk_size_2=zchunk_size(chunk);
      if(return_value_zchunk_size_2 == 0ul)
        break;

      unsigned char *return_value_zchunk_data_3;
      return_value_zchunk_data_3=zchunk_data(chunk);
      unsigned long int return_value_zchunk_size_4;
      return_value_zchunk_size_4=zchunk_size(chunk);
      zdigest_update(self->digest, return_value_zchunk_data_3, return_value_zchunk_size_4);
      zchunk_destroy(&chunk);
      if(!(9223372036854775807ul + -((unsigned long int)offset) >= blocksz))
        return (const char *)(void *)0;

      offset = offset + (signed long int)blocksz;
      chunk=zfile_read(self, blocksz, offset);
    }
    while((_Bool)1);
    zchunk_destroy(&chunk);
    fclose(self->handle);
    self->handle = ((struct _IO_FILE *)NULL);
  }

  char *return_value_zdigest_string_5;
  return_value_zdigest_string_5=zdigest_string(self->digest);
  return return_value_zdigest_string_5;
}

// zfile_dup
// file src/../include/zfile.h line 40
struct _zfile_t * zfile_dup(struct _zfile_t *self)
{
  char *return_value_strdup_2;
  if(!(self == ((struct _zfile_t *)NULL)))
  {
    struct _zfile_t *copy;
    void *return_value_safe_malloc_1;
    return_value_safe_malloc_1=safe_malloc_link11(sizeof(struct _zfile_t) /*80ul*/ , "src/zfile.c", (unsigned int)145);
    copy = (struct _zfile_t *)return_value_safe_malloc_1;
    if(!(copy == ((struct _zfile_t *)NULL)))
      copy->fullname=strdup(self->fullname);

    if(!(copy->fullname == ((char *)NULL)))
    {
      copy->modified = self->modified;
      copy->cursize = self->cursize;
      char *tmp_if_expr_3;
      if(!(self->link == ((char *)NULL)))
      {
        return_value_strdup_2=strdup(self->link);
        tmp_if_expr_3 = return_value_strdup_2;
      }

      else
        tmp_if_expr_3 = (char *)(void *)0;
      copy->link = tmp_if_expr_3;
      copy->mode = self->mode;
    }

    else
      zfile_destroy(&copy);
    return copy;
  }

  else
    return (struct _zfile_t *)(void *)0;
}

// zfile_eof
// file src/zfile.c line 429
_Bool zfile_eof(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  return self->eof;
}

// zfile_exists
// file src/zfile.c line 564
_Bool zfile_exists(const char *filename)
{
  _Bool return_value_zsys_file_exists_1;
  return_value_zsys_file_exists_1=zsys_file_exists(filename);
  return return_value_zsys_file_exists_1;
}

// zfile_filename
// file src/../include/zfile.h line 44
const char * zfile_filename(struct _zfile_t *self, const char *path)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  char *name = self->fullname;
  unsigned long int return_value_strlen_4;
  unsigned long int return_value_strlen_5;
  unsigned long int return_value_strlen_2;
  signed int return_value_memcmp_3;
  if(!(path == ((const char *)NULL)))
  {
    return_value_strlen_4=strlen(self->fullname);
    return_value_strlen_5=strlen(path);
    if(return_value_strlen_4 >= return_value_strlen_5)
    {
      return_value_strlen_2=strlen(path);
      return_value_memcmp_3=memcmp((const void *)self->fullname, (const void *)path, return_value_strlen_2);
      if(return_value_memcmp_3 == 0)
      {
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(path);
        name = name + (signed long int)return_value_strlen_1;
        if((signed int)*name == 47)
          name = name + 1l;

      }

    }

  }

  return name;
}

// zfile_handle
// file src/../include/zfile.h line 135
struct _IO_FILE * zfile_handle(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  return self->handle;
}

// zfile_has_changed
// file src/../include/zfile.h line 92
_Bool zfile_has_changed(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  struct stat stat_buf;
  char *real_name;
  char *tmp_if_expr_1;
  if(!(self->link == ((char *)NULL)))
    tmp_if_expr_1 = self->link;

  else
    tmp_if_expr_1 = self->fullname;
  real_name = tmp_if_expr_1;
  signed int return_value_stat_3;
  return_value_stat_3=stat(real_name, &stat_buf);
  if(return_value_stat_3 == 0)
  {
    _Bool tmp_if_expr_2;
    if(!(stat_buf.st_mtim.tv_sec == self->modified))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = stat_buf.st_size != self->cursize ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return (_Bool)1;

  }

  return (_Bool)0;
}

// zfile_input
// file src/../include/zfile.h line 101
signed int zfile_input(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  if(!(self->handle == ((struct _IO_FILE *)NULL)))
    zfile_close(self);

  char *real_name;
  char *tmp_if_expr_1;
  if(!(self->link == ((char *)NULL)))
    tmp_if_expr_1 = self->link;

  else
    tmp_if_expr_1 = self->fullname;
  real_name = tmp_if_expr_1;
  self->handle=fopen(real_name, "rb");
  if(!(self->handle == ((struct _IO_FILE *)NULL)))
  {
    struct stat stat_buf;
    signed int return_value_stat_2;
    return_value_stat_2=stat(real_name, &stat_buf);
    if(return_value_stat_2 == 0)
      self->cursize = stat_buf.st_size;

    else
      self->cursize = (signed long int)0;
  }

  return self->handle != ((struct _IO_FILE *)NULL) ? 0 : -1;
}

// zfile_is_directory
// file src/zfile.c line 238
_Bool zfile_is_directory(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  return (self->mode & (unsigned int)0170000) == (unsigned int)0040000;
}

// zfile_is_readable
// file src/zfile.c line 263
_Bool zfile_is_readable(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  return (self->mode & (unsigned int)0400) != (unsigned int)0;
}

// zfile_is_regular
// file src/../include/zfile.h line 70
_Bool zfile_is_regular(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  return (self->mode & (unsigned int)0170000) == (unsigned int)0100000;
}

// zfile_is_stable
// file src/../include/zfile.h line 87
_Bool zfile_is_stable(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  return self->stable;
}

// zfile_is_writeable
// file src/zfile.c line 276
_Bool zfile_is_writeable(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  return (self->mode & (unsigned int)0200) != (unsigned int)0;
}

// zfile_mkdir
// file src/zfile.c line 589
signed int zfile_mkdir(const char *pathname)
{
  signed int return_value_zsys_dir_create_1;
  return_value_zsys_dir_create_1=zsys_dir_create(pathname);
  return return_value_zsys_dir_create_1;
}

// zfile_mode
// file src/zfile.c line 574
unsigned int zfile_mode(const char *filename)
{
  signed int return_value_zsys_file_mode_1;
  return_value_zsys_file_mode_1=zsys_file_mode(filename);
  return (unsigned int)return_value_zsys_file_mode_1;
}

// zfile_mode_default
// file src/zfile.c line 604
void zfile_mode_default(void)
{
  zsys_file_mode_default();
}

// zfile_mode_private
// file src/zfile.c line 599
void zfile_mode_private(void)
{
  zsys_file_mode_private();
}

// zfile_modified
// file src/../include/zfile.h line 55
signed long int zfile_modified(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  return self->modified;
}

// zfile_new
// file src/../include/zfile.h line 30
struct _zfile_t * zfile_new(const char *path, const char *name)
{
  struct _zfile_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link11(sizeof(struct _zfile_t) /*80ul*/ , "src/zfile.c", (unsigned int)66);
  self = (struct _zfile_t *)return_value_safe_malloc_1;
  unsigned long int return_value_strlen_9;
  signed int return_value_strcmp_10;
  unsigned long int return_value_strlen_5;
  unsigned long int return_value_strlen_7;
  if(!(self == ((struct _zfile_t *)NULL)))
  {
    if(!(path == ((const char *)NULL)))
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(path);
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(name);
      void *return_value_safe_malloc_4;
      return_value_safe_malloc_4=safe_malloc_link11(return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)2, "src/zfile.c", (unsigned int)71);
      self->fullname = (char *)return_value_safe_malloc_4;
      if(!(self->fullname == ((char *)NULL)))
        sprintf(self->fullname, "%s/%s", path, name);

      else
      {
        zfile_destroy(&self);
        return (struct _zfile_t *)(void *)0;
      }
    }

    else
      self->fullname=strdup(name);
    if(!(self->fullname == ((char *)NULL)))
    {
      unsigned long int return_value_strlen_11;
      return_value_strlen_11=strlen(self->fullname);
      if(return_value_strlen_11 >= 4ul)
      {
        return_value_strlen_9=strlen(self->fullname);
        return_value_strcmp_10=strcmp((self->fullname + (signed long int)return_value_strlen_9) - (signed long int)3, ".ln");
        if(return_value_strcmp_10 == 0)
        {
          struct _IO_FILE *handle;
          handle=fopen(self->fullname, "r");
          if(!(handle == ((struct _IO_FILE *)NULL)))
          {
            char buffer[256l];
            char *return_value_fgets_8;
            return_value_fgets_8=fgets(buffer, 256, handle);
            if(!(return_value_fgets_8 == ((char *)NULL)))
            {
              unsigned long int return_value_strlen_6;
              return_value_strlen_6=strlen(buffer);
              if((signed int)buffer[-1l + (signed long int)return_value_strlen_6] == 10)
              {
                return_value_strlen_5=strlen(buffer);
                buffer[(signed long int)(return_value_strlen_5 - (unsigned long int)1)] = (char)0;
              }

              self->link=strdup(buffer);
              if(!(self->link == ((char *)NULL)))
              {
                return_value_strlen_7=strlen(self->fullname);
                self->fullname[(signed long int)(return_value_strlen_7 - (unsigned long int)3)] = (char)0;
              }

              else
              {
                fclose(handle);
                zfile_destroy(&self);
                return (struct _zfile_t *)(void *)0;
              }
            }

            fclose(handle);
          }

        }

      }

      zfile_restat(self);
    }

    else
      zfile_destroy(&self);
  }

  return self;
}

// zfile_output
// file src/../include/zfile.h line 107
signed int zfile_output(struct _zfile_t *self)
{
  signed int rc;
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  char *file_path;
  file_path=strdup(self->fullname);
  if(file_path == ((char *)NULL))
    return -1;

  else
  {
    char *last_slash;
    last_slash=strrchr(file_path, 47);
    if(!(last_slash == ((char *)NULL)))
      *last_slash = (char)0;

    if(!(self->link == ((char *)NULL)))
    {
      free((void *)self->link);
      self->link = (char *)(void *)0;
    }

    rc=zsys_dir_create(file_path);
    free((void *)file_path);
    if(!(rc == 0))
      return -1;

    else
    {
      if(!(self->handle == ((struct _IO_FILE *)NULL)))
        zfile_close(self);

      self->handle=fopen(self->fullname, "r+b");
      if(self->handle == ((struct _IO_FILE *)NULL))
        self->handle=fopen(self->fullname, "w+b");

      return self->handle != ((struct _IO_FILE *)NULL) ? 0 : -1;
    }
  }
}

// zfile_read
// file src/../include/zfile.h line 113
struct _zchunk_t * zfile_read(struct _zfile_t *self, unsigned long int bytes, signed long int offset)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  /* assertion self->handle */
  assert(self->handle != ((struct _IO_FILE *)NULL));
  if(!(self->cursize >= offset))
    bytes = (unsigned long int)0;

  else
    if(!((unsigned long int)self->cursize + -((unsigned long int)offset) >= bytes))
      bytes = (unsigned long int)(self->cursize - offset);

  signed int return_value_fseek_1;
  return_value_fseek_1=fseek(self->handle, (signed long int)offset, 0);
  unsigned long int return_value_zchunk_size_2;
  if(return_value_fseek_1 == -1)
    return (struct _zchunk_t *)(void *)0;

  else
  {
    self->eof = (_Bool)0;
    struct _zchunk_t *chunk;
    chunk=zchunk_read(self->handle, bytes);
    if(!(chunk == ((struct _zchunk_t *)NULL)))
    {
      return_value_zchunk_size_2=zchunk_size(chunk);
      self->eof = return_value_zchunk_size_2 < bytes;
    }

    return chunk;
  }
}

// zfile_readln
// file src/zfile.c line 457
const char * zfile_readln(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  /* assertion self->handle */
  assert(self->handle != ((struct _IO_FILE *)NULL));
  if(self->curline == ((char *)NULL))
  {
    self->linemax = (unsigned long int)512;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(self->linemax);
    self->curline = (char *)return_value_malloc_1;
  }

  unsigned int char_nbr = (unsigned int)0;
  while((_Bool)1)
  {
    signed int cur_char;
    cur_char=fgetc(self->handle);
    if(cur_char == 13)
      continue;

    else
      if(cur_char == -1 && char_nbr == 0u)
        return (const char *)(void *)0;

      else
        if(cur_char == 10 || cur_char == -1)
          cur_char = 0;

    if((unsigned long int)char_nbr == self->linemax + 18446744073709551615ul)
    {
      self->linemax = self->linemax * (unsigned long int)2;
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)self->curline, self->linemax);
      self->curline = (char *)return_value_realloc_2;
    }

    unsigned int tmp_post_3 = char_nbr;
    char_nbr = char_nbr + 1u;
    self->curline[(signed long int)tmp_post_3] = (char)cur_char;
    if(cur_char == 0)
      break;

  }
  return self->curline;
}

// zfile_remove
// file src/../include/zfile.h line 96
void zfile_remove(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  unsigned long int return_value_strlen_1;
  if(!(self->link == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(self->fullname);
    self->fullname[(signed long int)return_value_strlen_1] = (char)46;
  }

  zfile_close(self);
  zsys_file_delete(self->fullname);
}

// zfile_restat
// file src/../include/zfile.h line 50
void zfile_restat(struct _zfile_t *self)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  struct stat stat_buf;
  char *real_name;
  char *tmp_if_expr_1;
  if(!(self->link == ((char *)NULL)))
    tmp_if_expr_1 = self->link;

  else
    tmp_if_expr_1 = self->fullname;
  real_name = tmp_if_expr_1;
  signed int return_value_stat_3;
  return_value_stat_3=stat(real_name, &stat_buf);
  if(return_value_stat_3 == 0)
  {
    self->cursize = stat_buf.st_size;
    self->modified = stat_buf.st_mtim.tv_sec;
    signed int return_value_zsys_file_mode_2;
    return_value_zsys_file_mode_2=zsys_file_mode(real_name);
    self->mode = (unsigned int)return_value_zsys_file_mode_2;
    self->stable=zsys_file_stable(real_name);
  }

  else
  {
    self->cursize = (signed long int)0;
    self->modified = (signed long int)0;
    self->mode = (unsigned int)0;
    self->stable = (_Bool)0;
  }
  zdigest_destroy(&self->digest);
}

// zfile_rmdir
// file src/zfile.c line 594
signed int zfile_rmdir(const char *pathname)
{
  signed int return_value_zsys_dir_delete_1;
  return_value_zsys_dir_delete_1=zsys_dir_delete(pathname);
  return return_value_zsys_dir_delete_1;
}

// zfile_size
// file src/zfile.c line 569
signed long int zfile_size(const char *filename)
{
  signed long int return_value_zsys_file_size_1;
  return_value_zsys_file_size_1=zsys_file_size(filename);
  return return_value_zsys_file_size_1;
}

// zfile_stable
// file src/zfile.c line 584
_Bool zfile_stable(const char *filename)
{
  _Bool return_value_zsys_file_stable_1;
  return_value_zsys_file_stable_1=zsys_file_stable(filename);
  return return_value_zsys_file_stable_1;
}

// zfile_test
// file src/zfile.c line 614
void zfile_test(_Bool verbose)
{
  printf(" * zfile: ");
  struct _zfile_t *file;
  file=zfile_new((const char *)(void *)0, "bilbo");
  /* assertion file */
  assert(file != ((struct _zfile_t *)NULL));
  const char *return_value_zfile_filename_1;
  return_value_zfile_filename_1=zfile_filename(file, ".");
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(return_value_zfile_filename_1, "bilbo");
  /* assertion (!strcmp ((zfile_filename (file, ".")), ("bilbo"))) */
  assert(!(return_value_strcmp_2 != 0));
  _Bool return_value_zfile_is_readable_3;
  return_value_zfile_is_readable_3=zfile_is_readable(file);
  /* assertion zfile_is_readable (file) == 0 */
  assert((signed int)return_value_zfile_is_readable_3 == 0);
  zfile_destroy(&file);
  file=zfile_new("./this/is/a/test", "bilbo");
  /* assertion file */
  assert(file != ((struct _zfile_t *)NULL));
  signed int rc;
  rc=zfile_output(file);
  /* assertion rc == 0 */
  assert(rc == 0);
  struct _zchunk_t *chunk;
  chunk=zchunk_new((void *)0, (unsigned long int)100);
  /* assertion chunk */
  assert(chunk != ((struct _zchunk_t *)NULL));
  zchunk_fill(chunk, (unsigned char)0, (unsigned long int)100);
  rc=zfile_write(file, chunk, (signed long int)1000000);
  /* assertion rc == 0 */
  assert(rc == 0);
  zchunk_destroy(&chunk);
  zfile_close(file);
  _Bool return_value_zfile_is_readable_4;
  return_value_zfile_is_readable_4=zfile_is_readable(file);
  /* assertion zfile_is_readable (file) */
  assert(return_value_zfile_is_readable_4 != (_Bool)0);
  signed long int return_value_zfile_cursize_5;
  return_value_zfile_cursize_5=zfile_cursize(file);
  /* assertion zfile_cursize (file) == 1000100 */
  assert(return_value_zfile_cursize_5 == (signed long int)1000100);
  _Bool return_value_zfile_is_stable_6;
  return_value_zfile_is_stable_6=zfile_is_stable(file);
  /* assertion !zfile_is_stable (file) */
  assert(!(return_value_zfile_is_stable_6 != (_Bool)0));
  const char *return_value_zfile_digest_7;
  return_value_zfile_digest_7=zfile_digest(file);
  /* assertion zfile_digest (file) */
  assert(return_value_zfile_digest_7 != ((const char *)NULL));
  signed int handle;
  handle=open("./this/is/a/test/bilbo", 01 | 01000 | 0, 0);
  /* assertion handle >= 0 */
  assert(handle >= 0);
  signed long int return_value_write_8;
  return_value_write_8=write(handle, (const void *)"Hello, World\n", (unsigned long int)13);
  rc = (signed int)return_value_write_8;
  /* assertion rc == 13 */
  assert(rc == 13);
  close(handle);
  _Bool return_value_zfile_has_changed_9;
  return_value_zfile_has_changed_9=zfile_has_changed(file);
  /* assertion zfile_has_changed (file) */
  assert(return_value_zfile_has_changed_9 != (_Bool)0);
  zclock_sleep(1001);
  _Bool return_value_zfile_has_changed_10;
  return_value_zfile_has_changed_10=zfile_has_changed(file);
  /* assertion zfile_has_changed (file) */
  assert(return_value_zfile_has_changed_10 != (_Bool)0);
  _Bool return_value_zfile_is_stable_11;
  return_value_zfile_is_stable_11=zfile_is_stable(file);
  /* assertion !zfile_is_stable (file) */
  assert(!(return_value_zfile_is_stable_11 != (_Bool)0));
  zfile_restat(file);
  _Bool return_value_zfile_is_stable_12;
  return_value_zfile_is_stable_12=zfile_is_stable(file);
  /* assertion zfile_is_stable (file) */
  assert(return_value_zfile_is_stable_12 != (_Bool)0);
  const char *return_value_zfile_digest_13;
  return_value_zfile_digest_13=zfile_digest(file);
  signed int return_value_strcmp_14;
  return_value_strcmp_14=strcmp(return_value_zfile_digest_13, "4AB299C8AD6ED14F31923DD94F8B5F5CB89DFB54");
  /* assertion (!strcmp ((zfile_digest (file)), ("4AB299C8AD6ED14F31923DD94F8B5F5CB89DFB54"))) */
  assert(!(return_value_strcmp_14 != 0));
  rc=zfile_input(file);
  /* assertion rc == 0 */
  assert(rc == 0);
  chunk=zfile_read(file, (unsigned long int)1000100, (signed long int)0);
  /* assertion chunk */
  assert(chunk != ((struct _zchunk_t *)NULL));
  unsigned long int return_value_zchunk_size_15;
  return_value_zchunk_size_15=zchunk_size(chunk);
  /* assertion zchunk_size (chunk) == 13 */
  assert(return_value_zchunk_size_15 == (unsigned long int)13);
  zchunk_destroy(&chunk);
  zfile_close(file);
  rc=zfile_input(file);
  /* assertion rc == 0 */
  assert(rc == 0);
  const char *line;
  line=zfile_readln(file);
  signed int return_value_strcmp_16;
  return_value_strcmp_16=strcmp(line, "Hello, World");
  /* assertion (!strcmp ((line), ("Hello, World"))) */
  assert(!(return_value_strcmp_16 != 0));
  line=zfile_readln(file);
  /* assertion line == ((void *)0) */
  assert(line == (const char *)(void *)0);
  zfile_close(file);
  struct _zfile_t *link;
  link=zfile_new("./this/is/a/test", "bilbo.ln");
  /* assertion link */
  assert(link != ((struct _zfile_t *)NULL));
  rc=zfile_output(link);
  /* assertion rc == 0 */
  assert(rc == 0);
  struct _IO_FILE *return_value_zfile_handle_17;
  return_value_zfile_handle_17=zfile_handle(link);
  fprintf(return_value_zfile_handle_17, "./this/is/a/test/bilbo\n");
  zfile_destroy(&link);
  link=zfile_new("./this/is/a/test", "bilbo.ln");
  /* assertion link */
  assert(link != ((struct _zfile_t *)NULL));
  rc=zfile_input(link);
  /* assertion rc == 0 */
  assert(rc == 0);
  chunk=zfile_read(link, (unsigned long int)1000100, (signed long int)0);
  /* assertion chunk */
  assert(chunk != ((struct _zchunk_t *)NULL));
  unsigned long int return_value_zchunk_size_18;
  return_value_zchunk_size_18=zchunk_size(chunk);
  /* assertion zchunk_size (chunk) == 13 */
  assert(return_value_zchunk_size_18 == (unsigned long int)13);
  zchunk_destroy(&chunk);
  zfile_destroy(&link);
  struct _zdir_t *dir;
  dir=zdir_new("./this", (const char *)(void *)0);
  /* assertion dir */
  assert(dir != ((struct _zdir_t *)NULL));
  signed long int return_value_zdir_cursize_19;
  return_value_zdir_cursize_19=zdir_cursize(dir);
  /* assertion zdir_cursize (dir) == 26 */
  assert(return_value_zdir_cursize_19 == (signed long int)26);
  zdir_remove(dir, (_Bool)1);
  signed long int return_value_zdir_cursize_20;
  return_value_zdir_cursize_20=zdir_cursize(dir);
  /* assertion zdir_cursize (dir) == 0 */
  assert(return_value_zdir_cursize_20 == (signed long int)0);
  zdir_destroy(&dir);
  _Bool return_value_zfile_is_readable_21;
  return_value_zfile_is_readable_21=zfile_is_readable(file);
  /* assertion zfile_is_readable (file) */
  assert(return_value_zfile_is_readable_21 != (_Bool)0);
  zfile_restat(file);
  _Bool return_value_zfile_is_readable_22;
  return_value_zfile_is_readable_22=zfile_is_readable(file);
  /* assertion !zfile_is_readable (file) */
  assert(!(return_value_zfile_is_readable_22 != (_Bool)0));
  rc=zfile_input(file);
  /* assertion rc == -1 */
  assert(rc == -1);
  zfile_destroy(&file);
  printf("OK\n");
}

// zfile_write
// file src/zfile.c line 441
signed int zfile_write(struct _zfile_t *self, struct _zchunk_t *chunk, signed long int offset)
{
  /* assertion self */
  assert(self != ((struct _zfile_t *)NULL));
  /* assertion self->handle */
  assert(self->handle != ((struct _IO_FILE *)NULL));
  signed int rc;
  rc=fseek(self->handle, (signed long int)offset, 0);
  if(rc >= 0)
    rc=zchunk_write(chunk, self->handle);

  return rc;
}

// zframe_data
// file src/../include/zframe.h line 66
unsigned char * zframe_data(struct _zframe_t *self)
{
  /* assertion self */
  assert(self != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_is_1;
  return_value_zframe_is_1=zframe_is((void *)self);
  /* assertion zframe_is (self) */
  assert(return_value_zframe_is_1 != (_Bool)0);
  void *return_value_zmq_msg_data_2;
  return_value_zmq_msg_data_2=zmq_msg_data(&self->zmsg);
  return (unsigned char *)return_value_zmq_msg_data_2;
}

// zframe_destroy
// file src/../include/zframe.h line 36
void zframe_destroy(struct _zframe_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zframe_t **)NULL));
  if(!(*self_p == ((struct _zframe_t *)NULL)))
  {
    struct _zframe_t *self = *self_p;
    _Bool return_value_zframe_is_1;
    return_value_zframe_is_1=zframe_is((void *)self);
    /* assertion zframe_is (self) */
    assert(return_value_zframe_is_1 != (_Bool)0);
    zmq_msg_close(&self->zmsg);
    self->tag = 0xDeadBeef;
    free((void *)self);
    *self_p = (struct _zframe_t *)(void *)0;
  }

}

// zframe_dup
// file src/zframe.c line 198
struct _zframe_t * zframe_dup(struct _zframe_t *self)
{
  if(!(self == ((struct _zframe_t *)NULL)))
  {
    _Bool return_value_zframe_is_1;
    return_value_zframe_is_1=zframe_is((void *)self);
    /* assertion zframe_is (self) */
    assert(return_value_zframe_is_1 != (_Bool)0);
    unsigned char *return_value_zframe_data_2;
    return_value_zframe_data_2=zframe_data(self);
    unsigned long int return_value_zframe_size_3;
    return_value_zframe_size_3=zframe_size(self);
    struct _zframe_t *return_value_zframe_new_4;
    return_value_zframe_new_4=zframe_new((const void *)return_value_zframe_data_2, return_value_zframe_size_3);
    return return_value_zframe_new_4;
  }

  else
    return (struct _zframe_t *)(void *)0;
}

// zframe_eq
// file src/zframe.c line 308
_Bool zframe_eq(struct _zframe_t *self, struct _zframe_t *other)
{
  unsigned char *return_value_zframe_data_5;
  unsigned char *return_value_zframe_data_6;
  unsigned long int return_value_zframe_size_7;
  signed int return_value_memcmp_8;
  if(other == ((struct _zframe_t *)NULL) || self == ((struct _zframe_t *)NULL))
    return (_Bool)0;

  else
  {
    _Bool return_value_zframe_is_1;
    return_value_zframe_is_1=zframe_is((void *)self);
    /* assertion zframe_is (self) */
    assert(return_value_zframe_is_1 != (_Bool)0);
    _Bool return_value_zframe_is_2;
    return_value_zframe_is_2=zframe_is((void *)other);
    /* assertion zframe_is (other) */
    assert(return_value_zframe_is_2 != (_Bool)0);
    unsigned long int return_value_zframe_size_3;
    return_value_zframe_size_3=zframe_size(self);
    unsigned long int return_value_zframe_size_4;
    return_value_zframe_size_4=zframe_size(other);
    _Bool tmp_if_expr_9;
    if(return_value_zframe_size_3 == return_value_zframe_size_4)
    {
      return_value_zframe_data_5=zframe_data(self);
      return_value_zframe_data_6=zframe_data(other);
      return_value_zframe_size_7=zframe_size(self);
      return_value_memcmp_8=memcmp((const void *)return_value_zframe_data_5, (const void *)return_value_zframe_data_6, return_value_zframe_size_7);
      tmp_if_expr_9 = return_value_memcmp_8 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_9 = (_Bool)0;
    if(tmp_if_expr_9)
      return (_Bool)1;

    else
      return (_Bool)0;
  }
}

// zframe_fprint
// file src/zframe.c line 422
void zframe_fprint(struct _zframe_t *self, const char *prefix, struct _IO_FILE *file)
{
  /* assertion self */
  assert(self != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_is_1;
  return_value_zframe_is_1=zframe_is((void *)self);
  /* assertion zframe_is (self) */
  assert(return_value_zframe_is_1 != (_Bool)0);
  if(!(prefix == ((const char *)NULL)))
    fprintf(file, "%s", prefix);

  unsigned char *data;
  data=zframe_data(self);
  unsigned long int size;
  size=zframe_size(self);
  signed int is_bin = 0;
  unsigned int char_nbr = (unsigned int)0;
  for( ; !((unsigned long int)char_nbr >= size); char_nbr = char_nbr + 1u)
  {
    _Bool tmp_if_expr_2;
    if(!((signed int)data[(signed long int)char_nbr] >= 9))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)data[(signed long int)char_nbr] > 127 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      is_bin = 1;

  }
  fprintf(file, "[%03d] ", (signed int)size);
  unsigned long int max_size = (unsigned long int)(is_bin != 0 ? 35 : 70);
  const char *ellipsis = "";
  if(!(max_size >= size))
  {
    size = max_size;
    ellipsis = "...";
  }

  char_nbr = (unsigned int)0;
  for( ; !((unsigned long int)char_nbr >= size); char_nbr = char_nbr + 1u)
    if(!(is_bin == 0))
      fprintf(file, "%02X", (unsigned char)data[(signed long int)char_nbr]);

    else
      fprintf(file, "%c", data[(signed long int)char_nbr]);
  fprintf(file, "%s\n", ellipsis);
}

// zframe_from
// file src/zframe.c line 102
struct _zframe_t * zframe_from(const char *string)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  struct _zframe_t *return_value_zframe_new_2;
  return_value_zframe_new_2=zframe_new((const void *)string, return_value_strlen_1);
  return return_value_zframe_new_2;
}

// zframe_is
// file src/../include/zframe.h line 116
_Bool zframe_is(void *self)
{
  /* assertion self */
  assert(self != NULL);
  return ((struct _zframe_t *)self)->tag == (unsigned int)0x0002cafe;
}

// zframe_more
// file src/zframe.c line 280
signed int zframe_more(struct _zframe_t *self)
{
  /* assertion self */
  assert(self != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_is_1;
  return_value_zframe_is_1=zframe_is((void *)self);
  /* assertion zframe_is (self) */
  assert(return_value_zframe_is_1 != (_Bool)0);
  return self->more;
}

// zframe_new
// file src/../include/zframe.h line 32
struct _zframe_t * zframe_new(const void *data, unsigned long int size)
{
  struct _zframe_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link12(sizeof(struct _zframe_t) /*72ul*/ , "src/zframe.c", (unsigned int)48);
  self = (struct _zframe_t *)return_value_safe_malloc_1;
  void *return_value_zmq_msg_data_2;
  if(!(self == ((struct _zframe_t *)NULL)))
  {
    self->tag = (unsigned int)0x0002cafe;
    if(!(size == 0ul))
    {
      zmq_msg_init_size(&self->zmsg, size);
      if(!(data == NULL))
      {
        return_value_zmq_msg_data_2=zmq_msg_data(&self->zmsg);
        memcpy(return_value_zmq_msg_data_2, data, size);
      }

    }

    else
      zmq_msg_init(&self->zmsg);
  }

  return self;
}

// zframe_new_empty
// file src/zframe.c line 68
struct _zframe_t * zframe_new_empty(void)
{
  struct _zframe_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link12(sizeof(struct _zframe_t) /*72ul*/ , "src/zframe.c", (unsigned int)70);
  self = (struct _zframe_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _zframe_t *)NULL)))
  {
    self->tag = (unsigned int)0x0002cafe;
    zmq_msg_init(&self->zmsg);
  }

  return self;
}

// zframe_print
// file src/zframe.c line 348
void zframe_print(struct _zframe_t *self, const char *prefix)
{
  /* assertion self */
  assert(self != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_is_1;
  return_value_zframe_is_1=zframe_is((void *)self);
  /* assertion zframe_is (self) */
  assert(return_value_zframe_is_1 != (_Bool)0);
  unsigned char *data;
  data=zframe_data(self);
  unsigned long int size;
  size=zframe_size(self);
  signed int is_bin = 0;
  unsigned int char_nbr = (unsigned int)0;
  for( ; !((unsigned long int)char_nbr >= size); char_nbr = char_nbr + 1u)
  {
    _Bool tmp_if_expr_2;
    if(!((signed int)data[(signed long int)char_nbr] >= 9))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)data[(signed long int)char_nbr] > 127 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      is_bin = 1;

  }
  char buffer[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  snprintf(buffer, (unsigned long int)30, "%s[%03d] ", prefix != ((const char *)NULL) ? prefix : "", (signed int)size);
  unsigned long int max_size = (unsigned long int)(is_bin != 0 ? 35 : 70);
  const char *ellipsis = "";
  if(!(max_size >= size))
  {
    size = max_size;
    ellipsis = "...";
  }

  char_nbr = (unsigned int)0;
  unsigned long int return_value_strlen_3;
  unsigned long int return_value_strlen_4;
  for( ; !((unsigned long int)char_nbr >= size); char_nbr = char_nbr + 1u)
    if(!(is_bin == 0))
    {
      return_value_strlen_3=strlen(buffer);
      sprintf(buffer + (signed long int)return_value_strlen_3, "%02X", (unsigned char)data[(signed long int)char_nbr]);
    }

    else
    {
      return_value_strlen_4=strlen(buffer);
      sprintf(buffer + (signed long int)return_value_strlen_4, "%c", data[(signed long int)char_nbr]);
    }
  strcat(buffer, ellipsis);
  zsys_debug(buffer);
}

// zframe_recv
// file src/../include/zframe.h line 53
struct _zframe_t * zframe_recv(void *source)
{
  /* assertion source */
  assert(source != NULL);
  void *handle;
  handle=zsock_resolve(source);
  struct _zframe_t *self;
  self=zframe_new((void *)0, (unsigned long int)0);
  if(!(self == ((struct _zframe_t *)NULL)))
  {
    signed int return_value_zmq_recvmsg_1;
    return_value_zmq_recvmsg_1=zmq_recvmsg(handle, &self->zmsg, 0);
    if(!(return_value_zmq_recvmsg_1 >= 0))
    {
      zframe_destroy(&self);
      return (struct _zframe_t *)(void *)0;
    }

    self->more=zsock_rcvmore(handle);
  }

  return self;
}

// zframe_recv_nowait
// file src/zframe.c line 399
struct _zframe_t * zframe_recv_nowait(void *source)
{
  /* assertion source */
  assert(source != NULL);
  void *handle;
  handle=zsock_resolve(source);
  struct _zframe_t *self;
  self=zframe_new((void *)0, (unsigned long int)0);
  if(!(self == ((struct _zframe_t *)NULL)))
  {
    signed int return_value_zmq_recvmsg_1;
    return_value_zmq_recvmsg_1=zmq_recvmsg(handle, &self->zmsg, 1);
    if(!(return_value_zmq_recvmsg_1 >= 0))
    {
      zframe_destroy(&self);
      return (struct _zframe_t *)(void *)0;
    }

    self->more=zsock_rcvmore(handle);
  }

  return self;
}

// zframe_reset
// file src/zframe.c line 331
void zframe_reset(struct _zframe_t *self, const void *data, unsigned long int size)
{
  /* assertion self */
  assert(self != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_is_1;
  return_value_zframe_is_1=zframe_is((void *)self);
  /* assertion zframe_is (self) */
  assert(return_value_zframe_is_1 != (_Bool)0);
  /* assertion data */
  assert(data != NULL);
  zmq_msg_close(&self->zmsg);
  zmq_msg_init_size(&self->zmsg, size);
  void *return_value_zmq_msg_data_2;
  return_value_zmq_msg_data_2=zmq_msg_data(&self->zmsg);
  memcpy(return_value_zmq_msg_data_2, data, size);
}

// zframe_send
// file src/zframe.c line 135
signed int zframe_send(struct _zframe_t **self_p, void *dest, signed int flags)
{
  /* assertion dest */
  assert(dest != NULL);
  /* assertion self_p */
  assert(self_p != ((struct _zframe_t **)NULL));
  void *handle;
  handle=zsock_resolve(dest);
  if(!(*self_p == ((struct _zframe_t *)NULL)))
  {
    struct _zframe_t *self = *self_p;
    _Bool return_value_zframe_is_1;
    return_value_zframe_is_1=zframe_is((void *)self);
    /* assertion zframe_is (self) */
    assert(return_value_zframe_is_1 != (_Bool)0);
    signed int send_flags = (flags & 1) != 0 ? 2 : 0;
    send_flags = send_flags | ((flags & 4) != 0 ? 1 : 0);
    if(!((2 & flags) == 0))
    {
      struct zmq_msg_t copy;
      zmq_msg_init(&copy);
      signed int return_value_zmq_msg_copy_2;
      return_value_zmq_msg_copy_2=zmq_msg_copy(&copy, &self->zmsg);
      if(!(return_value_zmq_msg_copy_2 == 0))
        return -1;

      signed int return_value_zmq_sendmsg_3;
      return_value_zmq_sendmsg_3=zmq_sendmsg(handle, &copy, send_flags);
      if(return_value_zmq_sendmsg_3 == -1)
      {
        zmq_msg_close(&copy);
        return -1;
      }

    }

    else
    {
      signed int return_value_zmq_sendmsg_4;
      return_value_zmq_sendmsg_4=zmq_sendmsg(handle, &self->zmsg, send_flags);
      if(return_value_zmq_sendmsg_4 >= 0)
        zframe_destroy(self_p);

      else
        return -1;
    }
  }

  return 0;
}

// zframe_set_more
// file src/zframe.c line 294
void zframe_set_more(struct _zframe_t *self, signed int more)
{
  /* assertion self */
  assert(self != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_is_1;
  return_value_zframe_is_1=zframe_is((void *)self);
  /* assertion zframe_is (self) */
  assert(return_value_zframe_is_1 != (_Bool)0);
  /* assertion more == 0 || more == 1 */
  assert(more == 0 || more == 1);
  self->more = more;
}

// zframe_size
// file src/../include/zframe.h line 62
unsigned long int zframe_size(struct _zframe_t *self)
{
  /* assertion self */
  assert(self != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_is_1;
  return_value_zframe_is_1=zframe_is((void *)self);
  /* assertion zframe_is (self) */
  assert(return_value_zframe_is_1 != (_Bool)0);
  unsigned long int return_value_zmq_msg_size_2;
  return_value_zmq_msg_size_2=zmq_msg_size(&self->zmsg);
  return return_value_zmq_msg_size_2;
}

// zframe_strdup
// file src/zframe.c line 243
char * zframe_strdup(struct _zframe_t *self)
{
  /* assertion self */
  assert(self != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_is_1;
  return_value_zframe_is_1=zframe_is((void *)self);
  /* assertion zframe_is (self) */
  assert(return_value_zframe_is_1 != (_Bool)0);
  unsigned long int size;
  size=zframe_size(self);
  char *string;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(size + (unsigned long int)1);
  string = (char *)return_value_malloc_2;
  if(!(string == ((char *)NULL)))
  {
    unsigned char *return_value_zframe_data_3;
    return_value_zframe_data_3=zframe_data(self);
    memcpy((void *)string, (const void *)return_value_zframe_data_3, size);
    string[(signed long int)size] = (char)0;
  }

  return string;
}

// zframe_streq
// file src/zframe.c line 262
_Bool zframe_streq(struct _zframe_t *self, const char *string)
{
  /* assertion self */
  assert(self != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_is_1;
  return_value_zframe_is_1=zframe_is((void *)self);
  /* assertion zframe_is (self) */
  assert(return_value_zframe_is_1 != (_Bool)0);
  unsigned long int return_value_zframe_size_2;
  return_value_zframe_size_2=zframe_size(self);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(string);
  _Bool tmp_if_expr_7;
  unsigned char *return_value_zframe_data_4;
  unsigned long int return_value_strlen_5;
  signed int return_value_memcmp_6;
  if(return_value_zframe_size_2 == return_value_strlen_3)
  {
    return_value_zframe_data_4=zframe_data(self);
    return_value_strlen_5=strlen(string);
    return_value_memcmp_6=memcmp((const void *)return_value_zframe_data_4, (const void *)string, return_value_strlen_5);
    tmp_if_expr_7 = return_value_memcmp_6 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_7 = (_Bool)0;
  if(tmp_if_expr_7)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// zframe_strhex
// file src/zframe.c line 214
char * zframe_strhex(struct _zframe_t *self)
{
  /* assertion self */
  assert(self != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_is_1;
  return_value_zframe_is_1=zframe_is((void *)self);
  /* assertion zframe_is (self) */
  assert(return_value_zframe_is_1 != (_Bool)0);
  unsigned long int size;
  size=zframe_size(self);
  unsigned char *data;
  data=zframe_data(self);
  char *hex_str;
  void *return_value_safe_malloc_2;
  return_value_safe_malloc_2=safe_malloc_link12(size * (unsigned long int)2 + (unsigned long int)1, "src/zframe.c", (unsigned int)224);
  hex_str = (char *)return_value_safe_malloc_2;
  if(hex_str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned int byte_nbr = (unsigned int)0;
    for( ; !((unsigned long int)byte_nbr >= size); byte_nbr = byte_nbr + 1u)
    {
      static const char hex_char[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 0 };
      hex_str[(signed long int)(byte_nbr * (unsigned int)2 + (unsigned int)0)] = hex_char[(signed long int)((signed int)data[(signed long int)byte_nbr] >> 4)];
      hex_str[(signed long int)(byte_nbr * (unsigned int)2 + (unsigned int)1)] = hex_char[(signed long int)((signed int)data[(signed long int)byte_nbr] & 15)];
    }
    hex_str[(signed long int)(size * (unsigned long int)2)] = (char)0;
    return hex_str;
  }
}

// zframe_test
// file src/zframe.c line 459
void zframe_test(_Bool verbose)
{
  printf(" * zframe: ");
  signed int rc;
  struct _zframe_t *frame;
  struct _zsock_t *output;
  output=zsock_new_pair_checked("@inproc://zframe.test", "src/zframe.c", (unsigned long int)467);
  /* assertion output */
  assert(output != ((struct _zsock_t *)NULL));
  struct _zsock_t *input;
  input=zsock_new_pair_checked(">inproc://zframe.test", "src/zframe.c", (unsigned long int)469);
  /* assertion input */
  assert(input != ((struct _zsock_t *)NULL));
  signed int frame_nbr = 0;
  for( ; !(frame_nbr >= 5); frame_nbr = frame_nbr + 1)
  {
    frame=zframe_new((const void *)"Hello", (unsigned long int)5);
    /* assertion frame */
    assert(frame != ((struct _zframe_t *)NULL));
    rc=zframe_send(&frame, (void *)output, 1);
    /* assertion rc == 0 */
    assert(rc == 0);
  }
  frame=zframe_new((const void *)"Hello", (unsigned long int)5);
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  frame_nbr = 0;
  for( ; !(frame_nbr >= 5); frame_nbr = frame_nbr + 1)
  {
    rc=zframe_send(&frame, (void *)output, 1 + 2);
    /* assertion rc == 0 */
    assert(rc == 0);
  }
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  struct _zframe_t *copy;
  copy=zframe_dup(frame);
  _Bool return_value_zframe_eq_1;
  return_value_zframe_eq_1=zframe_eq(frame, copy);
  /* assertion zframe_eq (frame, copy) */
  assert(return_value_zframe_eq_1 != (_Bool)0);
  zframe_destroy(&frame);
  _Bool return_value_zframe_eq_2;
  return_value_zframe_eq_2=zframe_eq(frame, copy);
  /* assertion !zframe_eq (frame, copy) */
  assert(!(return_value_zframe_eq_2 != (_Bool)0));
  unsigned long int return_value_zframe_size_3;
  return_value_zframe_size_3=zframe_size(copy);
  /* assertion zframe_size (copy) == 5 */
  assert(return_value_zframe_size_3 == (unsigned long int)5);
  zframe_destroy(&copy);
  _Bool return_value_zframe_eq_4;
  return_value_zframe_eq_4=zframe_eq(frame, copy);
  /* assertion !zframe_eq (frame, copy) */
  assert(!(return_value_zframe_eq_4 != (_Bool)0));
  frame=zframe_new_empty();
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  unsigned long int return_value_zframe_size_5;
  return_value_zframe_size_5=zframe_size(frame);
  /* assertion zframe_size (frame) == 0 */
  assert(return_value_zframe_size_5 == (unsigned long int)0);
  zframe_destroy(&frame);
  frame=zframe_new((const void *)"NOT", (unsigned long int)3);
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  zframe_reset(frame, (const void *)"END", (unsigned long int)3);
  char *string;
  string=zframe_strhex(frame);
  signed int return_value_strcmp_6;
  return_value_strcmp_6=strcmp(string, "454E44");
  /* assertion (!strcmp ((string), ("454E44"))) */
  assert(!(return_value_strcmp_6 != 0));
  free((void *)string);
  string=zframe_strdup(frame);
  signed int return_value_strcmp_7;
  return_value_strcmp_7=strcmp(string, "END");
  /* assertion (!strcmp ((string), ("END"))) */
  assert(!(return_value_strcmp_7 != 0));
  free((void *)string);
  rc=zframe_send(&frame, (void *)output, 0);
  /* assertion rc == 0 */
  assert(rc == 0);
  frame_nbr = 0;
  frame_nbr = 0;
  do
  {
    struct _zframe_t *zframe_test__1__3__1__frame;
    zframe_test__1__3__1__frame=zframe_recv((void *)input);
    _Bool return_value_zframe_streq_8;
    return_value_zframe_streq_8=zframe_streq(zframe_test__1__3__1__frame, "END");
    if(!(return_value_zframe_streq_8 == (_Bool)0))
    {
      zframe_destroy(&zframe_test__1__3__1__frame);
      break;
    }

    signed int return_value_zframe_more_9;
    return_value_zframe_more_9=zframe_more(zframe_test__1__3__1__frame);
    /* assertion zframe_more (frame) */
    assert(return_value_zframe_more_9 != 0);
    zframe_set_more(zframe_test__1__3__1__frame, 0);
    signed int return_value_zframe_more_10;
    return_value_zframe_more_10=zframe_more(zframe_test__1__3__1__frame);
    /* assertion zframe_more (frame) == 0 */
    assert(return_value_zframe_more_10 == 0);
    zframe_destroy(&zframe_test__1__3__1__frame);
    frame_nbr = frame_nbr + 1;
  }
  while((_Bool)1);
  /* assertion frame_nbr == 10 */
  assert(frame_nbr == 10);
  zsock_destroy_checked(&input, "src/zframe.c", (unsigned long int)530);
  zsock_destroy_checked(&output, "src/zframe.c", (unsigned long int)531);
  printf("OK\n");
}

// zgossip
// file src/../include/zgossip.h line 84
void zgossip(struct _zsock_t *pipe, void *args)
{
  struct anonymous_28 *self;
  self=s_server_new(pipe);
  /* assertion self */
  assert(self != ((struct anonymous_28 *)NULL));
  zsock_signal((void *)pipe, (unsigned char)0);
  self->log_prefix = args != NULL ? (char *)args : "";
  engine_set_monitor((struct _server_t *)self, (unsigned long int)1000, s_watch_server_config);
  engine_handle_socket((struct _server_t *)self, (void *)self->pipe, s_server_handle_pipe);
  engine_handle_socket((struct _server_t *)self, (void *)self->router, s_server_handle_protocol);
  zloop_start(self->loop);
  s_server_destroy(&self);
}

// zgossip_msg_command
// file src/zgossip_msg.c line 505
const char * zgossip_msg_command(struct _zgossip_msg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zgossip_msg_t *)NULL));
  switch(self->id)
  {
    case 1:
      return "HELLO";
    case 2:
      return "PUBLISH";
    case 3:
      return "PING";
    case 4:
      return "PONG";
    case 5:
      return "INVALID";
    default:
      return "?";
  }
}

// zgossip_msg_destroy
// file src/zgossip_msg.h line 77
void zgossip_msg_destroy(struct _zgossip_msg_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zgossip_msg_t **)NULL));
  if(!(*self_p == ((struct _zgossip_msg_t *)NULL)))
  {
    struct _zgossip_msg_t *self = *self_p;
    zframe_destroy(&self->routing_id);
    free((void *)self->value);
    free((void *)self);
    *self_p = (struct _zgossip_msg_t *)(void *)0;
  }

}

// zgossip_msg_id
// file src/zgossip_msg.h line 100
signed int zgossip_msg_id(struct _zgossip_msg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zgossip_msg_t *)NULL));
  return self->id;
}

// zgossip_msg_key
// file src/zgossip_msg.h line 108
const char * zgossip_msg_key(struct _zgossip_msg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zgossip_msg_t *)NULL));
  return self->key;
}

// zgossip_msg_new
// file src/zgossip_msg.h line 73
struct _zgossip_msg_t * zgossip_msg_new(void)
{
  struct _zgossip_msg_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link27(sizeof(struct _zgossip_msg_t) /*304ul*/ , "src/zgossip_msg.c", (unsigned int)203);
  self = (struct _zgossip_msg_t *)return_value_safe_malloc_1;
  return self;
}

// zgossip_msg_print
// file src/zgossip_msg.c line 427
void zgossip_msg_print(struct _zgossip_msg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zgossip_msg_t *)NULL));
  switch(self->id)
  {
    case 1:
    {
      zsys_debug("ZGOSSIP_MSG_HELLO:");
      zsys_debug("    version=1");
      break;
    }
    case 2:
    {
      zsys_debug("ZGOSSIP_MSG_PUBLISH:");
      zsys_debug("    version=1");
      zsys_debug("    key='%s'", (const void *)self->key);
      if(!(self->value == ((char *)NULL)))
        zsys_debug("    value='%s'", self->value);

      else
        zsys_debug("    value=");
      zsys_debug("    ttl=%ld", (signed long int)self->ttl);
      break;
    }
    case 3:
    {
      zsys_debug("ZGOSSIP_MSG_PING:");
      zsys_debug("    version=1");
      break;
    }
    case 4:
    {
      zsys_debug("ZGOSSIP_MSG_PONG:");
      zsys_debug("    version=1");
      break;
    }
    case 5:
    {
      zsys_debug("ZGOSSIP_MSG_INVALID:");
      zsys_debug("    version=1");
    }
  }
}

// zgossip_msg_recv
// file src/zgossip_msg.h line 82
signed int zgossip_msg_recv(struct _zgossip_msg_t *self, struct _zsock_t *input)
{
  /* assertion input */
  assert(input != ((struct _zsock_t *)NULL));
  signed int return_value_zsock_type_3;
  return_value_zsock_type_3=zsock_type((void *)input);
  signed int return_value_zsock_rcvmore_1;
  if(return_value_zsock_type_3 == 6)
  {
    zframe_destroy(&self->routing_id);
    self->routing_id=zframe_recv((void *)input);
    _Bool tmp_if_expr_2;
    if(self->routing_id == ((struct _zframe_t *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_zsock_rcvmore_1=zsock_rcvmore((void *)input);
      tmp_if_expr_2 = !(return_value_zsock_rcvmore_1 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
    {
      zsys_warning("zgossip_msg: no routing ID");
      return -1;
    }

  }

  struct zmq_msg_t frame;
  zmq_msg_init(&frame);
  signed int size;
  void *return_value_zsock_resolve_4;
  return_value_zsock_resolve_4=zsock_resolve((void *)input);
  size=zmq_msg_recv(&frame, return_value_zsock_resolve_4, 0);
  void *return_value_zmq_msg_data_5;
  unsigned long int return_value_zmq_msg_size_6;
  unsigned short int signature;
  if(size == -1)
    zsys_warning("zgossip_msg: interrupted");

  else
  {
    return_value_zmq_msg_data_5=zmq_msg_data(&frame);
    self->needle = (unsigned char *)return_value_zmq_msg_data_5;
    return_value_zmq_msg_size_6=zmq_msg_size(&frame);
    self->ceiling = self->needle + (signed long int)return_value_zmq_msg_size_6;
    if(!(self->ceiling >= self->needle + 2l))
      zsys_warning("zgossip_msg: GET_NUMBER2 failed");

    else
    {
      signature = (unsigned short int)(((signed int)(unsigned short int)self->needle[(signed long int)0] << 8) + (signed int)(unsigned short int)self->needle[(signed long int)1]);
      self->needle = self->needle + (signed long int)2;
      if(!((signed int)signature == 43680))
        zsys_warning("zgossip_msg: invalid signature");

      else
        if(!(self->ceiling >= self->needle + 1l))
          zsys_warning("zgossip_msg: GET_NUMBER1 failed");

        else
        {
          self->id = (signed int)*((unsigned char *)self->needle);
          self->needle = self->needle + 1l;
          switch(self->id)
          {
            case 1:
            {
              unsigned char zgossip_msg_recv__1__6__1__version;
              if(!(self->ceiling >= self->needle + 1l))
              {
                zsys_warning("zgossip_msg: GET_NUMBER1 failed");
                goto malformed;
              }

              zgossip_msg_recv__1__6__1__version = *((unsigned char *)self->needle);
              self->needle = self->needle + 1l;
              if(!((signed int)zgossip_msg_recv__1__6__1__version == 1))
              {
                zsys_warning("zgossip_msg: version is invalid");
                goto malformed;
              }

              break;
            }
            case 2:
            {
              unsigned char version;
              if(!(self->ceiling >= self->needle + 1l))
              {
                zsys_warning("zgossip_msg: GET_NUMBER1 failed");
                goto malformed;
              }

              version = *((unsigned char *)self->needle);
              self->needle = self->needle + 1l;
              if(!((signed int)version == 1))
              {
                zsys_warning("zgossip_msg: version is invalid");
                goto malformed;
              }

              unsigned long int string_size;
              if(!(self->ceiling >= self->needle + 1l))
              {
                zsys_warning("zgossip_msg: GET_NUMBER1 failed");
                goto malformed;
              }

              string_size = (unsigned long int)*((unsigned char *)self->needle);
              self->needle = self->needle + 1l;
              if(!(self->ceiling >= self->needle + (signed long int)string_size))
              {
                zsys_warning("zgossip_msg: GET_STRING failed");
                goto malformed;
              }

              memcpy((void *)self->key, (const void *)self->needle, string_size);
              self->key[(signed long int)string_size] = (char)0;
              self->needle = self->needle + (signed long int)string_size;
              unsigned long int zgossip_msg_recv__1__6__4__string_size;
              if(!(self->ceiling >= self->needle + 4l))
              {
                zsys_warning("zgossip_msg: GET_NUMBER4 failed");
                goto malformed;
              }

              zgossip_msg_recv__1__6__4__string_size = (unsigned long int)(((unsigned int)self->needle[(signed long int)0] << 24) + ((unsigned int)self->needle[(signed long int)1] << 16) + ((unsigned int)self->needle[(signed long int)2] << 8) + (unsigned int)self->needle[(signed long int)3]);
              self->needle = self->needle + (signed long int)4;
              if(!(self->ceiling >= self->needle + (signed long int)zgossip_msg_recv__1__6__4__string_size))
              {
                zsys_warning("zgossip_msg: GET_LONGSTR failed");
                goto malformed;
              }

              free((void *)self->value);
              void *return_value_malloc_7;
              return_value_malloc_7=malloc(zgossip_msg_recv__1__6__4__string_size + (unsigned long int)1);
              self->value = (char *)return_value_malloc_7;
              memcpy((void *)self->value, (const void *)self->needle, zgossip_msg_recv__1__6__4__string_size);
              self->value[(signed long int)zgossip_msg_recv__1__6__4__string_size] = (char)0;
              self->needle = self->needle + (signed long int)zgossip_msg_recv__1__6__4__string_size;
              if(!(self->ceiling >= self->needle + 4l))
              {
                zsys_warning("zgossip_msg: GET_NUMBER4 failed");
                goto malformed;
              }

              self->ttl = ((unsigned int)self->needle[(signed long int)0] << 24) + ((unsigned int)self->needle[(signed long int)1] << 16) + ((unsigned int)self->needle[(signed long int)2] << 8) + (unsigned int)self->needle[(signed long int)3];
              self->needle = self->needle + (signed long int)4;
              break;
            }
            case 3:
            {
              unsigned char zgossip_msg_recv__1__6__6__version;
              if(!(self->ceiling >= self->needle + 1l))
              {
                zsys_warning("zgossip_msg: GET_NUMBER1 failed");
                goto malformed;
              }

              zgossip_msg_recv__1__6__6__version = *((unsigned char *)self->needle);
              self->needle = self->needle + 1l;
              if(!((signed int)zgossip_msg_recv__1__6__6__version == 1))
              {
                zsys_warning("zgossip_msg: version is invalid");
                goto malformed;
              }

              break;
            }
            case 4:
            {
              unsigned char zgossip_msg_recv__1__6__7__version;
              if(!(self->ceiling >= self->needle + 1l))
              {
                zsys_warning("zgossip_msg: GET_NUMBER1 failed");
                goto malformed;
              }

              zgossip_msg_recv__1__6__7__version = *((unsigned char *)self->needle);
              self->needle = self->needle + 1l;
              if(!((signed int)zgossip_msg_recv__1__6__7__version == 1))
              {
                zsys_warning("zgossip_msg: version is invalid");
                goto malformed;
              }

              break;
            }
            case 5:
            {
              unsigned char zgossip_msg_recv__1__6__8__version;
              if(!(self->ceiling >= self->needle + 1l))
              {
                zsys_warning("zgossip_msg: GET_NUMBER1 failed");
                goto malformed;
              }

              zgossip_msg_recv__1__6__8__version = *((unsigned char *)self->needle);
              self->needle = self->needle + 1l;
              if(!((signed int)zgossip_msg_recv__1__6__8__version == 1))
              {
                zsys_warning("zgossip_msg: version is invalid");
                goto malformed;
              }

              break;
            }
            default:
            {
              zsys_warning("zgossip_msg: bad message ID");
              goto malformed;
            }
          }
          zmq_msg_close(&frame);
          return 0;
        }
    }
  }

malformed:
  ;
  zsys_warning("zgossip_msg: zgossip_msg malformed message, fail");
  zmq_msg_close(&frame);
  return -1;
}

// zgossip_msg_routing_id
// file src/zgossip_msg.h line 94
struct _zframe_t * zgossip_msg_routing_id(struct _zgossip_msg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zgossip_msg_t *)NULL));
  return self->routing_id;
}

// zgossip_msg_send
// file src/zgossip_msg.h line 86
signed int zgossip_msg_send(struct _zgossip_msg_t *self, struct _zsock_t *output)
{
  /* assertion self */
  assert(self != ((struct _zgossip_msg_t *)NULL));
  /* assertion output */
  assert(output != ((struct _zsock_t *)NULL));
  signed int return_value_zsock_type_1;
  return_value_zsock_type_1=zsock_type((void *)output);
  if(return_value_zsock_type_1 == 6)
    zframe_send(&self->routing_id, (void *)output, 1 + 2);

  unsigned long int frame_size = (unsigned long int)(2 + 1);
  unsigned long int return_value_strlen_2;
  unsigned long int return_value_strlen_3;
  switch(self->id)
  {
    case 1:
    {
      frame_size = frame_size + (unsigned long int)1;
      break;
    }
    case 2:
    {
      frame_size = frame_size + (unsigned long int)1;
      return_value_strlen_2=strlen(self->key);
      frame_size = frame_size + (unsigned long int)1 + return_value_strlen_2;
      frame_size = frame_size + (unsigned long int)4;
      if(!(self->value == ((char *)NULL)))
      {
        return_value_strlen_3=strlen(self->value);
        frame_size = frame_size + return_value_strlen_3;
      }

      frame_size = frame_size + (unsigned long int)4;
      break;
    }
    case 3:
    {
      frame_size = frame_size + (unsigned long int)1;
      break;
    }
    case 4:
    {
      frame_size = frame_size + (unsigned long int)1;
      break;
    }
    case 5:
      frame_size = frame_size + (unsigned long int)1;
  }
  struct zmq_msg_t frame;
  zmq_msg_init_size(&frame, frame_size);
  void *return_value_zmq_msg_data_4;
  return_value_zmq_msg_data_4=zmq_msg_data(&frame);
  self->needle = (unsigned char *)return_value_zmq_msg_data_4;
  self->needle[(signed long int)0] = (unsigned char)((0xAAA0 | 0) >> 8 & 255);
  self->needle[(signed long int)1] = (unsigned char)((0xAAA0 | 0) & 255);
  self->needle = self->needle + (signed long int)2;
  *((unsigned char *)self->needle) = (unsigned char)self->id;
  self->needle = self->needle + 1l;
  unsigned long int nbr_frames = (unsigned long int)1;
  switch(self->id)
  {
    case 1:
    {
      *((unsigned char *)self->needle) = (unsigned char)1;
      self->needle = self->needle + 1l;
      break;
    }
    case 2:
    {
      *((unsigned char *)self->needle) = (unsigned char)1;
      self->needle = self->needle + 1l;
      unsigned long int string_size;
      string_size=strlen(self->key);
      *((unsigned char *)self->needle) = (unsigned char)string_size;
      self->needle = self->needle + 1l;
      memcpy((void *)self->needle, (const void *)self->key, string_size);
      self->needle = self->needle + (signed long int)string_size;
      if(!(self->value == ((char *)NULL)))
      {
        unsigned long int zgossip_msg_send__1__4__4__1__string_size;
        zgossip_msg_send__1__4__4__1__string_size=strlen(self->value);
        self->needle[(signed long int)0] = (unsigned char)(zgossip_msg_send__1__4__4__1__string_size >> 24 & (unsigned long int)255);
        self->needle[(signed long int)1] = (unsigned char)(zgossip_msg_send__1__4__4__1__string_size >> 16 & (unsigned long int)255);
        self->needle[(signed long int)2] = (unsigned char)(zgossip_msg_send__1__4__4__1__string_size >> 8 & (unsigned long int)255);
        self->needle[(signed long int)3] = (unsigned char)(zgossip_msg_send__1__4__4__1__string_size & (unsigned long int)255);
        self->needle = self->needle + (signed long int)4;
        memcpy((void *)self->needle, (const void *)self->value, zgossip_msg_send__1__4__4__1__string_size);
        self->needle = self->needle + (signed long int)zgossip_msg_send__1__4__4__1__string_size;
      }

      else
      {
        self->needle[(signed long int)0] = (unsigned char)(0 >> 24 & 255);
        self->needle[(signed long int)1] = (unsigned char)(0 >> 16 & 255);
        self->needle[(signed long int)2] = (unsigned char)(0 >> 8 & 255);
        self->needle[(signed long int)3] = (unsigned char)(0 & 255);
        self->needle = self->needle + (signed long int)4;
      }
      self->needle[(signed long int)0] = (unsigned char)(self->ttl >> 24 & (unsigned int)255);
      self->needle[(signed long int)1] = (unsigned char)(self->ttl >> 16 & (unsigned int)255);
      self->needle[(signed long int)2] = (unsigned char)(self->ttl >> 8 & (unsigned int)255);
      self->needle[(signed long int)3] = (unsigned char)(self->ttl & (unsigned int)255);
      self->needle = self->needle + (signed long int)4;
      break;
    }
    case 3:
    {
      *((unsigned char *)self->needle) = (unsigned char)1;
      self->needle = self->needle + 1l;
      break;
    }
    case 4:
    {
      *((unsigned char *)self->needle) = (unsigned char)1;
      self->needle = self->needle + 1l;
      break;
    }
    case 5:
    {
      *((unsigned char *)self->needle) = (unsigned char)1;
      self->needle = self->needle + 1l;
    }
  }
  void *return_value_zsock_resolve_5;
  return_value_zsock_resolve_5=zsock_resolve((void *)output);
  nbr_frames = nbr_frames - 1ul;
  zmq_msg_send(&frame, return_value_zsock_resolve_5, nbr_frames != 0ul ? 2 : 0);
  return 0;
}

// zgossip_msg_set_id
// file src/zgossip_msg.h line 102
void zgossip_msg_set_id(struct _zgossip_msg_t *self, signed int id)
{
  self->id = id;
}

// zgossip_msg_set_key
// file src/zgossip_msg.h line 110
void zgossip_msg_set_key(struct _zgossip_msg_t *self, const char *value)
{
  /* assertion self */
  assert(self != ((struct _zgossip_msg_t *)NULL));
  /* assertion value */
  assert(value != ((const char *)NULL));
  if(!(value == self->key))
  {
    strncpy(self->key, value, (unsigned long int)255);
    self->key[(signed long int)255] = (char)0;
  }

}

// zgossip_msg_set_routing_id
// file src/zgossip_msg.h line 96
void zgossip_msg_set_routing_id(struct _zgossip_msg_t *self, struct _zframe_t *routing_id)
{
  if(!(self->routing_id == ((struct _zframe_t *)NULL)))
    zframe_destroy(&self->routing_id);

  self->routing_id=zframe_dup(routing_id);
}

// zgossip_msg_set_ttl
// file src/zgossip_msg.c line 581
void zgossip_msg_set_ttl(struct _zgossip_msg_t *self, unsigned int ttl)
{
  /* assertion self */
  assert(self != ((struct _zgossip_msg_t *)NULL));
  self->ttl = ttl;
}

// zgossip_msg_set_value
// file src/zgossip_msg.h line 116
void zgossip_msg_set_value(struct _zgossip_msg_t *self, const char *value)
{
  /* assertion self */
  assert(self != ((struct _zgossip_msg_t *)NULL));
  /* assertion value */
  assert(value != ((const char *)NULL));
  free((void *)self->value);
  self->value=strdup(value);
}

// zgossip_msg_test
// file src/zgossip_msg.c line 593
signed int zgossip_msg_test(_Bool verbose)
{
  printf(" * zgossip_msg:");
  struct _zgossip_msg_t *self;
  self=zgossip_msg_new();
  /* assertion self */
  assert(self != ((struct _zgossip_msg_t *)NULL));
  zgossip_msg_destroy(&self);
  struct _zsock_t *output;
  output=zsock_new_checked(5, "src/zgossip_msg.c", (unsigned long int)607);
  /* assertion output */
  assert(output != ((struct _zsock_t *)NULL));
  signed int rc;
  rc=zsock_bind(output, "inproc://selftest-zgossip_msg");
  /* assertion rc == 0 */
  assert(rc == 0);
  struct _zsock_t *input;
  input=zsock_new_checked(6, "src/zgossip_msg.c", (unsigned long int)612);
  /* assertion input */
  assert(input != ((struct _zsock_t *)NULL));
  rc=zsock_connect(input, "inproc://selftest-zgossip_msg");
  /* assertion rc == 0 */
  assert(rc == 0);
  signed int instance;
  self=zgossip_msg_new();
  zgossip_msg_set_id(self, 1);
  zgossip_msg_send(self, output);
  zgossip_msg_send(self, output);
  instance = 0;
  for( ; !(instance >= 2); instance = instance + 1)
  {
    zgossip_msg_recv(self, input);
    struct _zframe_t *return_value_zgossip_msg_routing_id_1;
    return_value_zgossip_msg_routing_id_1=zgossip_msg_routing_id(self);
    /* assertion zgossip_msg_routing_id (self) */
    assert(return_value_zgossip_msg_routing_id_1 != ((struct _zframe_t *)NULL));
  }
  zgossip_msg_set_id(self, 2);
  zgossip_msg_set_key(self, "Life is short but Now lasts for ever");
  zgossip_msg_set_value(self, "Life is short but Now lasts for ever");
  zgossip_msg_set_ttl(self, (unsigned int)123);
  zgossip_msg_send(self, output);
  zgossip_msg_send(self, output);
  instance = 0;
  for( ; !(instance >= 2); instance = instance + 1)
  {
    zgossip_msg_recv(self, input);
    struct _zframe_t *return_value_zgossip_msg_routing_id_2;
    return_value_zgossip_msg_routing_id_2=zgossip_msg_routing_id(self);
    /* assertion zgossip_msg_routing_id (self) */
    assert(return_value_zgossip_msg_routing_id_2 != ((struct _zframe_t *)NULL));
    const char *return_value_zgossip_msg_key_3;
    return_value_zgossip_msg_key_3=zgossip_msg_key(self);
    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(return_value_zgossip_msg_key_3, "Life is short but Now lasts for ever");
    /* assertion (!strcmp ((zgossip_msg_key (self)), ("Life is short but Now lasts for ever"))) */
    assert(!(return_value_strcmp_4 != 0));
    const char *return_value_zgossip_msg_value_5;
    return_value_zgossip_msg_value_5=zgossip_msg_value(self);
    signed int return_value_strcmp_6;
    return_value_strcmp_6=strcmp(return_value_zgossip_msg_value_5, "Life is short but Now lasts for ever");
    /* assertion (!strcmp ((zgossip_msg_value (self)), ("Life is short but Now lasts for ever"))) */
    assert(!(return_value_strcmp_6 != 0));
    unsigned int return_value_zgossip_msg_ttl_7;
    return_value_zgossip_msg_ttl_7=zgossip_msg_ttl(self);
    /* assertion zgossip_msg_ttl (self) == 123 */
    assert(return_value_zgossip_msg_ttl_7 == (unsigned int)123);
  }
  zgossip_msg_set_id(self, 3);
  zgossip_msg_send(self, output);
  zgossip_msg_send(self, output);
  instance = 0;
  for( ; !(instance >= 2); instance = instance + 1)
  {
    zgossip_msg_recv(self, input);
    struct _zframe_t *return_value_zgossip_msg_routing_id_8;
    return_value_zgossip_msg_routing_id_8=zgossip_msg_routing_id(self);
    /* assertion zgossip_msg_routing_id (self) */
    assert(return_value_zgossip_msg_routing_id_8 != ((struct _zframe_t *)NULL));
  }
  zgossip_msg_set_id(self, 4);
  zgossip_msg_send(self, output);
  zgossip_msg_send(self, output);
  instance = 0;
  for( ; !(instance >= 2); instance = instance + 1)
  {
    zgossip_msg_recv(self, input);
    struct _zframe_t *return_value_zgossip_msg_routing_id_9;
    return_value_zgossip_msg_routing_id_9=zgossip_msg_routing_id(self);
    /* assertion zgossip_msg_routing_id (self) */
    assert(return_value_zgossip_msg_routing_id_9 != ((struct _zframe_t *)NULL));
  }
  zgossip_msg_set_id(self, 5);
  zgossip_msg_send(self, output);
  zgossip_msg_send(self, output);
  instance = 0;
  for( ; !(instance >= 2); instance = instance + 1)
  {
    zgossip_msg_recv(self, input);
    struct _zframe_t *return_value_zgossip_msg_routing_id_10;
    return_value_zgossip_msg_routing_id_10=zgossip_msg_routing_id(self);
    /* assertion zgossip_msg_routing_id (self) */
    assert(return_value_zgossip_msg_routing_id_10 != ((struct _zframe_t *)NULL));
  }
  zgossip_msg_destroy(&self);
  zsock_destroy_checked(&input, "src/zgossip_msg.c", (unsigned long int)679);
  zsock_destroy_checked(&output, "src/zgossip_msg.c", (unsigned long int)680);
  printf("OK\n");
  return 0;
}

// zgossip_msg_ttl
// file src/zgossip_msg.c line 574
unsigned int zgossip_msg_ttl(struct _zgossip_msg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zgossip_msg_t *)NULL));
  return self->ttl;
}

// zgossip_msg_value
// file src/zgossip_msg.h line 114
const char * zgossip_msg_value(struct _zgossip_msg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zgossip_msg_t *)NULL));
  return self->value;
}

// zgossip_test
// file src/zgossip.c line 421
void zgossip_test(_Bool verbose)
{
  printf(" * zgossip: ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  struct _zactor_t *server;
  server=zactor_new(zgossip, (void *)"server");
  /* assertion server */
  assert(server != ((struct _zactor_t *)NULL));
  if(!(verbose == (_Bool)0))
    zstr_send((void *)server, "VERBOSE");

  zstr_sendx((void *)server, "BIND", (const void *)"inproc://zgossip", (void *)0);
  struct _zsock_t *client;
  client=zsock_new_checked(5, "src/zgossip.c", (unsigned long int)435);
  /* assertion client */
  assert(client != ((struct _zsock_t *)NULL));
  zsock_set_rcvtimeo((void *)client, 2000);
  signed int rc;
  rc=zsock_connect(client, "inproc://zgossip");
  /* assertion rc == 0 */
  assert(rc == 0);
  struct _zgossip_msg_t *message;
  message=zgossip_msg_new();
  zgossip_msg_set_id(message, 1);
  zgossip_msg_send(message, client);
  zgossip_msg_set_id(message, 3);
  zgossip_msg_send(message, client);
  zgossip_msg_recv(message, client);
  signed int return_value_zgossip_msg_id_1;
  return_value_zgossip_msg_id_1=zgossip_msg_id(message);
  /* assertion zgossip_msg_id (message) == 4 */
  assert(return_value_zgossip_msg_id_1 == 4);
  zgossip_msg_destroy(&message);
  zactor_destroy(&server);
  zsock_destroy_checked(&client, "src/zgossip.c", (unsigned long int)454);
  struct _zactor_t *base;
  base=zactor_new(zgossip, (void *)"base");
  /* assertion base */
  assert(base != ((struct _zactor_t *)NULL));
  if(!(verbose == (_Bool)0))
    zstr_send((void *)base, "VERBOSE");

  zstr_sendx((void *)base, "SET", (const void *)"server/timeout", (const void *)"100", (void *)0);
  zstr_sendx((void *)base, "BIND", (const void *)"inproc://base", (void *)0);
  struct _zactor_t *alpha;
  alpha=zactor_new(zgossip, (void *)"alpha");
  /* assertion alpha */
  assert(alpha != ((struct _zactor_t *)NULL));
  zstr_sendx((void *)alpha, "CONNECT", (const void *)"inproc://base", (void *)0);
  zstr_sendx((void *)alpha, "PUBLISH", (const void *)"inproc://alpha-1", (const void *)"service1", (void *)0);
  zstr_sendx((void *)alpha, "PUBLISH", (const void *)"inproc://alpha-2", (const void *)"service2", (void *)0);
  struct _zactor_t *beta;
  beta=zactor_new(zgossip, (void *)"beta");
  /* assertion beta */
  assert(beta != ((struct _zactor_t *)NULL));
  zstr_sendx((void *)beta, "CONNECT", (const void *)"inproc://base", (void *)0);
  zstr_sendx((void *)beta, "PUBLISH", (const void *)"inproc://beta-1", (const void *)"service1", (void *)0);
  zstr_sendx((void *)beta, "PUBLISH", (const void *)"inproc://beta-2", (const void *)"service2", (void *)0);
  zclock_sleep(200);
  zactor_destroy(&base);
  zactor_destroy(&alpha);
  zactor_destroy(&beta);
  printf("OK\n");
}

// zhash_autofree
// file src/zhash.c line 777
void zhash_autofree(struct _zhash_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  self->autofree = (_Bool)1;
}

// zhash_comment
// file src/zhash.c line 503
void zhash_comment(struct _zhash_t *self, const char *format, ...)
{
  if(!(format == ((const char *)NULL)))
  {
    if(self->comments == ((struct _zlist_t *)NULL))
    {
      self->comments=zlist_new();
      if(self->comments == ((struct _zlist_t *)NULL))
        goto __CPROVER_DUMP_L4;

      zlist_autofree(self->comments);
    }

    void **argptr = (void **)&format;
    char *string;
    string=zsys_vprintf(format, argptr);
    argptr = ((void **)NULL);
    if(!(string == ((char *)NULL)))
      zlist_append(self->comments, (void *)string);

    free((void *)string);
  }

  else
    zlist_destroy(&self->comments);

__CPROVER_DUMP_L4:
  ;
}

// zhash_cursor
// file src/zhash.c line 490
const char * zhash_cursor(struct _zhash_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  return self->cursor_key;
}

// zhash_delete
// file src/zhash.c line 297
void zhash_delete(struct _zhash_t *self, const char *key)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  /* assertion key */
  assert(key != ((const char *)NULL));
  struct _item_t_0 *item;
  item=s_item_lookup_link1(self, key);
  if(!(item == ((struct _item_t_0 *)NULL)))
    s_item_destroy_link1(self, item, (_Bool)1);

}

// zhash_destroy
// file src/zhash.c line 90
void zhash_destroy(struct _zhash_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zhash_t **)NULL));
  if(!(*self_p == ((struct _zhash_t *)NULL)))
  {
    struct _zhash_t *self = *self_p;
    unsigned int index = (unsigned int)0;
    for( ; !((unsigned long int)index >= self->limit); index = index + 1u)
    {
      struct _item_t_0 *cur_item = self->items[(signed long int)index];
      while(!(cur_item == ((struct _item_t_0 *)NULL)))
      {
        struct _item_t_0 *next_item = cur_item->next;
        s_item_destroy_link1(self, cur_item, (_Bool)1);
        cur_item = next_item;
      }
    }
    if(!(self->items == ((struct _item_t_0 **)NULL)))
      free((void *)self->items);

    zlist_destroy(&self->comments);
    free((void *)self->filename);
    free((void *)self);
    *self_p = (struct _zhash_t *)(void *)0;
  }

}

// zhash_dup
// file src/zhash.c line 390
struct _zhash_t * zhash_dup(struct _zhash_t *self)
{
  if(self == ((struct _zhash_t *)NULL))
    return (struct _zhash_t *)(void *)0;

  else
  {
    struct _zhash_t *copy;
    copy=zhash_new();
    zhash_autofree(copy);
    if(!(copy == ((struct _zhash_t *)NULL)))
    {
      unsigned int index = (unsigned int)0;
      for( ; !((unsigned long int)index == self->limit); index = index + 1u)
      {
        struct _item_t_0 *item = self->items[(signed long int)index];
        for( ; !(item == ((struct _item_t_0 *)NULL)); item = item->next)
          zhash_insert(copy, item->key, item->value);
      }
    }

    return copy;
  }
}

// zhash_first
// file src/zhash.c line 442
void * zhash_first(struct _zhash_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  self->cursor_index = (unsigned long int)0;
  self->cursor_item = self->items[(signed long int)self->cursor_index];
  void *return_value_zhash_next_1;
  return_value_zhash_next_1=zhash_next(self);
  return return_value_zhash_next_1;
}

// zhash_foreach
// file src/zhash.c line 791
signed int zhash_foreach(struct _zhash_t *self, signed int (*callback)(const char *, void *, void *), void *argument)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  unsigned int index = (unsigned int)0;
  for( ; !((unsigned long int)index >= self->limit); index = index + 1u)
  {
    struct _item_t_0 *item = self->items[(signed long int)index];
    if(!(item == ((struct _item_t_0 *)NULL)))
    {
      struct _item_t_0 *next = item->next;
      signed int rc;
      rc=callback((const char *)item->key, item->value, argument);
      if(!(rc == 0))
        return rc;

      item = next;
    }

  }
  return 0;
}

// zhash_freefn
// file src/zhash.c line 357
void * zhash_freefn(struct _zhash_t *self, const char *key, void (*free_fn)(void *))
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  /* assertion key */
  assert(key != ((const char *)NULL));
  struct _item_t_0 *item;
  item=s_item_lookup_link1(self, key);
  if(!(item == ((struct _item_t_0 *)NULL)))
  {
    item->free_fn = free_fn;
    return item->value;
  }

  else
    return (void *)0;
}

// zhash_insert
// file src/zhash.c line 156
signed int zhash_insert(struct _zhash_t *self, const char *key, void *value)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  /* assertion key */
  assert(key != ((const char *)NULL));
  if(self->size >= (75ul * self->limit) / 100ul)
  {
    unsigned long int new_limit = (self->limit * (unsigned long int)200) / (unsigned long int)100;
    struct _item_t_0 **new_items;
    void *return_value_safe_malloc_1;
    return_value_safe_malloc_1=safe_malloc_link31(sizeof(struct _item_t_0 *) /*8ul*/  * new_limit, "src/zhash.c", (unsigned int)166);
    new_items = (struct _item_t_0 **)return_value_safe_malloc_1;
    if(new_items == ((struct _item_t_0 **)NULL))
      return -1;

    unsigned int index = (unsigned int)0;
    for( ; !((unsigned long int)index == self->limit); index = index + 1u)
    {
      struct _item_t_0 *cur_item = self->items[(signed long int)index];
      while(!(cur_item == ((struct _item_t_0 *)NULL)))
      {
        struct _item_t_0 *next_item = cur_item->next;
        unsigned int new_index;
        new_index=s_item_hash(cur_item->key, new_limit);
        cur_item->index = (unsigned long int)new_index;
        cur_item->next = new_items[(signed long int)new_index];
        new_items[(signed long int)new_index] = cur_item;
        cur_item = next_item;
      }
    }
    free((void *)self->items);
    self->items = new_items;
    self->limit = new_limit;
  }

  struct _item_t_0 *return_value_s_item_insert_2;
  return_value_s_item_insert_2=s_item_insert_link1(self, key, value);
  return return_value_s_item_insert_2 != ((struct _item_t_0 *)NULL) ? 0 : -1;
}

// zhash_keys
// file src/zhash.c line 415
struct _zlist_t * zhash_keys(struct _zhash_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  struct _zlist_t *keys;
  keys=zlist_new();
  if(keys == ((struct _zlist_t *)NULL))
    return (struct _zlist_t *)(void *)0;

  else
  {
    zlist_autofree(keys);
    unsigned int index = (unsigned int)0;
    for( ; !((unsigned long int)index == self->limit); index = index + 1u)
    {
      struct _item_t_0 *item = self->items[(signed long int)index];
      for( ; !(item == ((struct _item_t_0 *)NULL)); item = item->next)
        zlist_append(keys, (void *)item->key);
    }
    return keys;
  }
}

// zhash_load
// file src/zhash.c line 566
signed int zhash_load(struct _zhash_t *self, const char *filename)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  zhash_autofree(self);
  char *filename_copy;
  filename_copy=strdup(filename);
  char *return_value_fgets_2;
  unsigned long int return_value_strlen_3;
  if(!(filename_copy == ((char *)NULL)))
  {
    free((void *)self->filename);
    self->filename = filename_copy;
    self->modified=zsys_file_modified(self->filename);
    struct _IO_FILE *handle;
    handle=fopen(self->filename, "r");
    if(!(handle == ((struct _IO_FILE *)NULL)))
    {
      char *buffer;
      void *return_value_safe_malloc_1;
      return_value_safe_malloc_1=safe_malloc_link31((unsigned long int)1024, "src/zhash.c", (unsigned int)584);
      buffer = (char *)return_value_safe_malloc_1;
      if(!(buffer == ((char *)NULL)))
      {
        do
        {
          return_value_fgets_2=fgets(buffer, 1024, handle);
          if(return_value_fgets_2 == ((char *)NULL))
            break;

          char *equals;
          equals=strchr(buffer, 61);
          if(!(equals == ((char *)NULL)) && !(equals == buffer) && !((signed int)*buffer == 35))
          {
            unsigned long int return_value_strlen_4;
            return_value_strlen_4=strlen(buffer);
            if((signed int)buffer[-1l + (signed long int)return_value_strlen_4] == 10)
            {
              return_value_strlen_3=strlen(buffer);
              buffer[(signed long int)(return_value_strlen_3 - (unsigned long int)1)] = (char)0;
            }

            char *tmp_post_5 = equals;
            equals = equals + 1l;
            *tmp_post_5 = (char)0;
            zhash_update(self, buffer, (void *)equals);
          }

        }
        while((_Bool)1);
        free((void *)buffer);
      }

      else
      {
        fclose(handle);
        return -1;
      }
      fclose(handle);
    }

    else
      return -1;
  }

  else
    return -1;
  return 0;
}

// zhash_lookup
// file src/zhash.c line 312
void * zhash_lookup(struct _zhash_t *self, const char *key)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  /* assertion key */
  assert(key != ((const char *)NULL));
  struct _item_t_0 *item;
  item=s_item_lookup_link1(self, key);
  if(!(item == ((struct _item_t_0 *)NULL)))
    return item->value;

  else
    return (void *)0;
}

// zhash_new
// file src/zhash.c line 73
struct _zhash_t * zhash_new(void)
{
  struct _zhash_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link31(sizeof(struct _zhash_t) /*88ul*/ , "src/zhash.c", (unsigned int)75);
  self = (struct _zhash_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _zhash_t *)NULL)))
  {
    self->limit = (unsigned long int)255;
    void *return_value_safe_malloc_2;
    return_value_safe_malloc_2=safe_malloc_link31(sizeof(struct _item_t_0 *) /*8ul*/  * self->limit, "src/zhash.c", (unsigned int)78);
    self->items = (struct _item_t_0 **)return_value_safe_malloc_2;
    if(self->items == ((struct _item_t_0 **)NULL))
      zhash_destroy(&self);

  }

  return self;
}

// zhash_next
// file src/zhash.c line 461
void * zhash_next(struct _zhash_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  for( ; self->cursor_item == ((struct _item_t_0 *)NULL); self->cursor_item = self->items[(signed long int)self->cursor_index])
    if(!(self->cursor_index >= self->limit + 18446744073709551615ul))
      self->cursor_index = self->cursor_index + 1ul;

    else
      return (void *)0;
  /* assertion self->cursor_item */
  assert(self->cursor_item != ((struct _item_t_0 *)NULL));
  struct _item_t_0 *item = self->cursor_item;
  self->cursor_key = item->key;
  self->cursor_item = self->cursor_item->next;
  return item->value;
}

// zhash_pack
// file src/zhash.c line 672
struct _zframe_t * zhash_pack(struct _zhash_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  unsigned long int frame_size = (unsigned long int)4;
  unsigned int index = (unsigned int)0;
  for( ; !((unsigned long int)index >= self->limit); index = index + 1u)
  {
    struct _item_t_0 *item = self->items[(signed long int)index];
    while(!(item == ((struct _item_t_0 *)NULL)))
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen((char *)item->key);
      frame_size = frame_size + (unsigned long int)1 + return_value_strlen_1;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen((char *)item->value);
      frame_size = frame_size + (unsigned long int)4 + return_value_strlen_2;
      item = item->next;
    }
  }
  struct _zframe_t *frame;
  frame=zframe_new((void *)0, frame_size);
  if(frame == ((struct _zframe_t *)NULL))
    return (struct _zframe_t *)(void *)0;

  else
  {
    unsigned char *needle;
    needle=zframe_data(frame);
    *((unsigned int *)needle)=htonl((unsigned int)self->size);
    needle = needle + (signed long int)4;
    index = (unsigned int)0;
    for( ; !((unsigned long int)index >= self->limit); index = index + 1u)
    {
      struct _item_t_0 *zhash_pack__1__2__1__item = self->items[(signed long int)index];
      while(!(zhash_pack__1__2__1__item == ((struct _item_t_0 *)NULL)))
      {
        unsigned char *tmp_post_3 = needle;
        needle = needle + 1l;
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen((char *)zhash_pack__1__2__1__item->key);
        *tmp_post_3 = (unsigned char)return_value_strlen_4;
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen((char *)zhash_pack__1__2__1__item->key);
        memcpy((void *)needle, (const void *)zhash_pack__1__2__1__item->key, return_value_strlen_5);
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen((char *)zhash_pack__1__2__1__item->key);
        needle = needle + (signed long int)return_value_strlen_6;
        unsigned long int length;
        length=strlen((char *)zhash_pack__1__2__1__item->value);
        *((unsigned int *)needle)=htonl((unsigned int)(unsigned long int)length);
        needle = needle + (signed long int)4;
        unsigned long int return_value_strlen_7;
        return_value_strlen_7=strlen((char *)zhash_pack__1__2__1__item->value);
        memcpy((void *)needle, (const void *)(char *)zhash_pack__1__2__1__item->value, return_value_strlen_7);
        unsigned long int return_value_strlen_8;
        return_value_strlen_8=strlen((char *)zhash_pack__1__2__1__item->value);
        needle = needle + (signed long int)return_value_strlen_8;
        zhash_pack__1__2__1__item = zhash_pack__1__2__1__item->next;
      }
    }
    return frame;
  }
}

// zhash_refresh
// file src/zhash.c line 624
signed int zhash_refresh(struct _zhash_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  _Bool return_value_zsys_file_stable_1;
  if(!(self->filename == ((char *)NULL)))
  {
    signed long int return_value_zsys_file_modified_2;
    return_value_zsys_file_modified_2=zsys_file_modified(self->filename);
    if(!(self->modified >= return_value_zsys_file_modified_2))
    {
      return_value_zsys_file_stable_1=zsys_file_stable(self->filename);
      if(!(return_value_zsys_file_stable_1 == (_Bool)0))
      {
        unsigned int index = (unsigned int)0;
        for( ; !((unsigned long int)index >= self->limit); index = index + 1u)
        {
          struct _item_t_0 *cur_item = self->items[(signed long int)index];
          while(!(cur_item == ((struct _item_t_0 *)NULL)))
          {
            struct _item_t_0 *next_item = cur_item->next;
            s_item_destroy_link1(self, cur_item, (_Bool)1);
            cur_item = next_item;
          }
        }
        zhash_load(self, self->filename);
      }

    }

  }

  return 0;
}

// zhash_rename
// file src/zhash.c line 330
signed int zhash_rename(struct _zhash_t *self, const char *old_key, const char *new_key)
{
  struct _item_t_0 *old_item;
  old_item=s_item_lookup_link1(self, old_key);
  struct _item_t_0 *new_item;
  new_item=s_item_lookup_link1(self, new_key);
  if(new_item == ((struct _item_t_0 *)NULL) && !(old_item == ((struct _item_t_0 *)NULL)))
  {
    s_item_destroy_link1(self, old_item, (_Bool)0);
    free((void *)old_item->key);
    old_item->key=strdup(new_key);
    old_item->index = self->cached_index;
    old_item->next = self->items[(signed long int)self->cached_index];
    self->items[(signed long int)self->cached_index] = old_item;
    self->size = self->size + 1ul;
    return 0;
  }

  else
    return -1;
}

// zhash_save
// file src/zhash.c line 531
signed int zhash_save(struct _zhash_t *self, const char *filename)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  struct _IO_FILE *handle;
  handle=fopen(filename, "w");
  if(handle == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    if(!(self->comments == ((struct _zlist_t *)NULL)))
    {
      char *comment;
      void *return_value_zlist_first_1;
      return_value_zlist_first_1=zlist_first(self->comments);
      comment = (char *)return_value_zlist_first_1;
      while(!(comment == ((char *)NULL)))
      {
        fprintf(handle, "#   %s\n", comment);
        void *return_value_zlist_next_2;
        return_value_zlist_next_2=zlist_next(self->comments);
        comment = (char *)return_value_zlist_next_2;
      }
      fprintf(handle, "\n");
    }

    unsigned int index = (unsigned int)0;
    for( ; !((unsigned long int)index == self->limit); index = index + 1u)
    {
      struct _item_t_0 *item = self->items[(signed long int)index];
      for( ; !(item == ((struct _item_t_0 *)NULL)); item = item->next)
        fprintf(handle, "%s=%s\n", item->key, (char *)item->value);
    }
    fclose(handle);
    return 0;
  }
}

// zhash_size
// file src/zhash.c line 376
unsigned long int zhash_size(struct _zhash_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  return self->size;
}

// zhash_test
// file src/zhash.c line 816
void zhash_test(signed int verbose)
{
  printf(" * zhash: ");
  struct _zhash_t *hash;
  hash=zhash_new();
  /* assertion hash */
  assert(hash != ((struct _zhash_t *)NULL));
  unsigned long int return_value_zhash_size_1;
  return_value_zhash_size_1=zhash_size(hash);
  /* assertion zhash_size (hash) == 0 */
  assert(return_value_zhash_size_1 == (unsigned long int)0);
  void *return_value_zhash_first_2;
  return_value_zhash_first_2=zhash_first(hash);
  /* assertion zhash_first (hash) == ((void *)0) */
  assert(return_value_zhash_first_2 == (void *)0);
  const char *return_value_zhash_cursor_3;
  return_value_zhash_cursor_3=zhash_cursor(hash);
  /* assertion zhash_cursor (hash) == ((void *)0) */
  assert(return_value_zhash_cursor_3 == (const char *)(void *)0);
  signed int rc;
  rc=zhash_insert(hash, "DEADBEEF", (void *)"dead beef");
  char *item;
  void *return_value_zhash_first_4;
  return_value_zhash_first_4=zhash_first(hash);
  item = (char *)return_value_zhash_first_4;
  const char *return_value_zhash_cursor_5;
  return_value_zhash_cursor_5=zhash_cursor(hash);
  signed int return_value_strcmp_6;
  return_value_strcmp_6=strcmp(return_value_zhash_cursor_5, "DEADBEEF");
  /* assertion (!strcmp ((zhash_cursor (hash)), ("DEADBEEF"))) */
  assert(!(return_value_strcmp_6 != 0));
  signed int return_value_strcmp_7;
  return_value_strcmp_7=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_7 != 0));
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zhash_insert(hash, "ABADCAFE", (void *)"a bad cafe");
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zhash_insert(hash, "C0DEDBAD", (void *)"coded bad");
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zhash_insert(hash, "DEADF00D", (void *)"dead food");
  /* assertion rc == 0 */
  assert(rc == 0);
  unsigned long int return_value_zhash_size_8;
  return_value_zhash_size_8=zhash_size(hash);
  /* assertion zhash_size (hash) == 4 */
  assert(return_value_zhash_size_8 == (unsigned long int)4);
  void *return_value_zhash_lookup_9;
  return_value_zhash_lookup_9=zhash_lookup(hash, "DEADBEEF");
  item = (char *)return_value_zhash_lookup_9;
  signed int return_value_strcmp_10;
  return_value_strcmp_10=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_10 != 0));
  void *return_value_zhash_lookup_11;
  return_value_zhash_lookup_11=zhash_lookup(hash, "ABADCAFE");
  item = (char *)return_value_zhash_lookup_11;
  signed int return_value_strcmp_12;
  return_value_strcmp_12=strcmp(item, "a bad cafe");
  /* assertion (!strcmp ((item), ("a bad cafe"))) */
  assert(!(return_value_strcmp_12 != 0));
  void *return_value_zhash_lookup_13;
  return_value_zhash_lookup_13=zhash_lookup(hash, "C0DEDBAD");
  item = (char *)return_value_zhash_lookup_13;
  signed int return_value_strcmp_14;
  return_value_strcmp_14=strcmp(item, "coded bad");
  /* assertion (!strcmp ((item), ("coded bad"))) */
  assert(!(return_value_strcmp_14 != 0));
  void *return_value_zhash_lookup_15;
  return_value_zhash_lookup_15=zhash_lookup(hash, "DEADF00D");
  item = (char *)return_value_zhash_lookup_15;
  signed int return_value_strcmp_16;
  return_value_strcmp_16=strcmp(item, "dead food");
  /* assertion (!strcmp ((item), ("dead food"))) */
  assert(!(return_value_strcmp_16 != 0));
  void *return_value_zhash_lookup_17;
  return_value_zhash_lookup_17=zhash_lookup(hash, "foo");
  item = (char *)return_value_zhash_lookup_17;
  /* assertion item == ((void *)0) */
  assert(item == (char *)(void *)0);
  rc=zhash_insert(hash, "DEADBEEF", (void *)"foo");
  /* assertion rc == -1 */
  assert(rc == -1);
  void *return_value_zhash_lookup_18;
  return_value_zhash_lookup_18=zhash_lookup(hash, "DEADBEEF");
  item = (char *)return_value_zhash_lookup_18;
  signed int return_value_strcmp_19;
  return_value_strcmp_19=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_19 != 0));
  rc=zhash_rename(hash, "DEADBEEF", "LIVEBEEF");
  /* assertion rc == 0 */
  assert(rc == 0);
  void *return_value_zhash_lookup_20;
  return_value_zhash_lookup_20=zhash_lookup(hash, "LIVEBEEF");
  item = (char *)return_value_zhash_lookup_20;
  signed int return_value_strcmp_21;
  return_value_strcmp_21=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_21 != 0));
  rc=zhash_rename(hash, "WHATBEEF", "NONESUCH");
  /* assertion rc == -1 */
  assert(rc == -1);
  rc=zhash_rename(hash, "WHATBEEF", "LIVEBEEF");
  /* assertion rc == -1 */
  assert(rc == -1);
  void *return_value_zhash_lookup_22;
  return_value_zhash_lookup_22=zhash_lookup(hash, "LIVEBEEF");
  item = (char *)return_value_zhash_lookup_22;
  signed int return_value_strcmp_23;
  return_value_strcmp_23=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_23 != 0));
  rc=zhash_rename(hash, "LIVEBEEF", "ABADCAFE");
  /* assertion rc == -1 */
  assert(rc == -1);
  void *return_value_zhash_lookup_24;
  return_value_zhash_lookup_24=zhash_lookup(hash, "LIVEBEEF");
  item = (char *)return_value_zhash_lookup_24;
  signed int return_value_strcmp_25;
  return_value_strcmp_25=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_25 != 0));
  void *return_value_zhash_lookup_26;
  return_value_zhash_lookup_26=zhash_lookup(hash, "ABADCAFE");
  item = (char *)return_value_zhash_lookup_26;
  signed int return_value_strcmp_27;
  return_value_strcmp_27=strcmp(item, "a bad cafe");
  /* assertion (!strcmp ((item), ("a bad cafe"))) */
  assert(!(return_value_strcmp_27 != 0));
  struct _zlist_t *keys;
  keys=zhash_keys(hash);
  unsigned long int return_value_zlist_size_28;
  return_value_zlist_size_28=zlist_size(keys);
  /* assertion zlist_size (keys) == 4 */
  assert(return_value_zlist_size_28 == (unsigned long int)4);
  zlist_destroy(&keys);
  struct _zhash_t *copy;
  copy=zhash_dup(hash);
  unsigned long int return_value_zhash_size_29;
  return_value_zhash_size_29=zhash_size(copy);
  /* assertion zhash_size (copy) == 4 */
  assert(return_value_zhash_size_29 == (unsigned long int)4);
  void *return_value_zhash_lookup_30;
  return_value_zhash_lookup_30=zhash_lookup(copy, "LIVEBEEF");
  item = (char *)return_value_zhash_lookup_30;
  /* assertion item */
  assert(item != ((char *)NULL));
  signed int return_value_strcmp_31;
  return_value_strcmp_31=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_31 != 0));
  zhash_destroy(&copy);
  struct _zframe_t *frame;
  frame=zhash_pack(hash);
  copy=zhash_unpack(frame);
  zframe_destroy(&frame);
  unsigned long int return_value_zhash_size_32;
  return_value_zhash_size_32=zhash_size(copy);
  /* assertion zhash_size (copy) == 4 */
  assert(return_value_zhash_size_32 == (unsigned long int)4);
  void *return_value_zhash_lookup_33;
  return_value_zhash_lookup_33=zhash_lookup(copy, "LIVEBEEF");
  item = (char *)return_value_zhash_lookup_33;
  /* assertion item */
  assert(item != ((char *)NULL));
  signed int return_value_strcmp_34;
  return_value_strcmp_34=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_34 != 0));
  zhash_destroy(&copy);
  zhash_comment(hash, "This is a test file");
  zhash_comment(hash, "Created by %s", (const void *)"czmq_selftest");
  zhash_save(hash, ".cache");
  copy=zhash_new();
  /* assertion copy */
  assert(copy != ((struct _zhash_t *)NULL));
  zhash_load(copy, ".cache");
  void *return_value_zhash_lookup_35;
  return_value_zhash_lookup_35=zhash_lookup(copy, "LIVEBEEF");
  item = (char *)return_value_zhash_lookup_35;
  /* assertion item */
  assert(item != ((char *)NULL));
  signed int return_value_strcmp_36;
  return_value_strcmp_36=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_36 != 0));
  zhash_destroy(&copy);
  zsys_file_delete(".cache");
  zhash_delete(hash, "LIVEBEEF");
  void *return_value_zhash_lookup_37;
  return_value_zhash_lookup_37=zhash_lookup(hash, "LIVEBEEF");
  item = (char *)return_value_zhash_lookup_37;
  /* assertion item == ((void *)0) */
  assert(item == (char *)(void *)0);
  unsigned long int return_value_zhash_size_38;
  return_value_zhash_size_38=zhash_size(hash);
  /* assertion zhash_size (hash) == 3 */
  assert(return_value_zhash_size_38 == (unsigned long int)3);
  /* tag-#anon#lST[lARR100{S8}_S8_'name'|B'exists'] */
struct anonymous_32
{
  // name
  char name[100l];
  // exists
  _Bool exists;
};

/* */
  ;
  struct anonymous_32 testset[200l];
  memset((void *)testset, 0, sizeof(struct anonymous_32 [200l]) /*20200ul*/ );
  signed int testmax = 200;
  signed int testnbr;
  signed int iteration;
  signed long int return_value_time_39;
  return_value_time_39=time((signed long int *)(void *)0);
  srandom((unsigned int)return_value_time_39);
  iteration = 0;
  for( ; !(iteration >= 25000); iteration = iteration + 1)
  {
    signed long int return_value_random_40;
    return_value_random_40=random();
    testnbr = (signed int)((double)((float)testmax * (float)return_value_random_40) / ((double)2147483647 + 1.0));
    if(!(testset[(signed long int)testnbr].exists == (_Bool)0))
    {
      void *return_value_zhash_lookup_41;
      return_value_zhash_lookup_41=zhash_lookup(hash, testset[(signed long int)testnbr].name);
      item = (char *)return_value_zhash_lookup_41;
      /* assertion item */
      assert(item != ((char *)NULL));
      zhash_delete(hash, testset[(signed long int)testnbr].name);
      testset[(signed long int)testnbr].exists = (_Bool)0;
    }

    else
    {
      signed int return_value_rand_42;
      return_value_rand_42=rand();
      signed int return_value_rand_43;
      return_value_rand_43=rand();
      sprintf(testset[(signed long int)testnbr].name, "%x-%x", return_value_rand_42, return_value_rand_43);
      signed int return_value_zhash_insert_44;
      return_value_zhash_insert_44=zhash_insert(hash, testset[(signed long int)testnbr].name, (void *)"");
      if(return_value_zhash_insert_44 == 0)
        testset[(signed long int)testnbr].exists = (_Bool)1;

    }
  }
  iteration = 0;
  void *return_value_zhash_lookup_45;
  for( ; !(iteration >= 10000); iteration = iteration + 1)
  {
    return_value_zhash_lookup_45=zhash_lookup(hash, "DEADBEEFABADCAFE");
    item = (char *)return_value_zhash_lookup_45;
  }
  zhash_destroy(&hash);
  zhash_destroy(&hash);
  /* assertion hash == ((void *)0) */
  assert(hash == (struct _zhash_t *)(void *)0);
  hash=zhash_new();
  /* assertion hash */
  assert(hash != ((struct _zhash_t *)NULL));
  zhash_autofree(hash);
  char value[255l];
  strcpy(value, "This is a string");
  rc=zhash_insert(hash, "key1", (void *)value);
  /* assertion rc == 0 */
  assert(rc == 0);
  strcpy(value, "Inserting with the same key will fail");
  rc=zhash_insert(hash, "key1", (void *)value);
  /* assertion rc == -1 */
  assert(rc == -1);
  strcpy(value, "Ring a ding ding");
  rc=zhash_insert(hash, "key2", (void *)value);
  /* assertion rc == 0 */
  assert(rc == 0);
  void *return_value_zhash_lookup_46;
  return_value_zhash_lookup_46=zhash_lookup(hash, "key1");
  signed int return_value_strcmp_47;
  return_value_strcmp_47=strcmp((char *)return_value_zhash_lookup_46, "This is a string");
  /* assertion (!strcmp (((char *) zhash_lookup (hash, "key1")), ("This is a string"))) */
  assert(!(return_value_strcmp_47 != 0));
  void *return_value_zhash_lookup_48;
  return_value_zhash_lookup_48=zhash_lookup(hash, "key2");
  signed int return_value_strcmp_49;
  return_value_strcmp_49=strcmp((char *)return_value_zhash_lookup_48, "Ring a ding ding");
  /* assertion (!strcmp (((char *) zhash_lookup (hash, "key2")), ("Ring a ding ding"))) */
  assert(!(return_value_strcmp_49 != 0));
  zhash_destroy(&hash);
  printf("OK\n");
}

// zhash_unpack
// file src/zhash.c line 724
struct _zhash_t * zhash_unpack(struct _zframe_t *frame)
{
  struct _zhash_t *self;
  self=zhash_new();
  if(self == ((struct _zhash_t *)NULL))
    return (struct _zhash_t *)(void *)0;

  else
  {
    /* assertion frame */
    assert(frame != ((struct _zframe_t *)NULL));
    unsigned long int return_value_zframe_size_1;
    return_value_zframe_size_1=zframe_size(frame);
    if(!(return_value_zframe_size_1 >= 4ul))
      return self;

    else
    {
      unsigned char *needle;
      needle=zframe_data(frame);
      unsigned char *ceiling;
      unsigned long int return_value_zframe_size_2;
      return_value_zframe_size_2=zframe_size(frame);
      ceiling = needle + (signed long int)return_value_zframe_size_2;
      unsigned long int nbr_items;
      unsigned int return_value_ntohl_3;
      return_value_ntohl_3=ntohl(*((unsigned int *)needle));
      nbr_items = (unsigned long int)return_value_ntohl_3;
      needle = needle + (signed long int)4;
      while(!(nbr_items == 0ul) && !(needle >= ceiling))
      {
        unsigned long int key_size;
        unsigned char *tmp_post_4 = needle;
        needle = needle + 1l;
        key_size = (unsigned long int)*tmp_post_4;
        if(ceiling >= needle + (signed long int)key_size)
        {
          char key[256l];
          memcpy((void *)key, (const void *)needle, key_size);
          key[(signed long int)key_size] = (char)0;
          needle = needle + (signed long int)key_size;
          if(ceiling >= needle + 4l)
          {
            unsigned long int value_size;
            unsigned int return_value_ntohl_5;
            return_value_ntohl_5=ntohl(*((unsigned int *)needle));
            value_size = (unsigned long int)return_value_ntohl_5;
            needle = needle + (signed long int)4;
            if(ceiling >= needle + (signed long int)value_size)
            {
              char *value;
              void *return_value_malloc_6;
              return_value_malloc_6=malloc(value_size + (unsigned long int)1);
              value = (char *)return_value_malloc_6;
              memcpy((void *)value, (const void *)needle, value_size);
              value[(signed long int)value_size] = (char)0;
              needle = needle + (signed long int)value_size;
              signed int return_value_zhash_insert_7;
              return_value_zhash_insert_7=zhash_insert(self, key, (void *)value);
              if(!(return_value_zhash_insert_7 == 0))
              {
                zhash_destroy(&self);
                break;
              }

            }

          }

        }

      }
      if(!(self == ((struct _zhash_t *)NULL)))
        zhash_autofree(self);

      return self;
    }
  }
}

// zhash_update
// file src/zhash.c line 269
void zhash_update(struct _zhash_t *self, const char *key, void *value)
{
  /* assertion self */
  assert(self != ((struct _zhash_t *)NULL));
  /* assertion key */
  assert(key != ((const char *)NULL));
  struct _item_t_0 *item;
  item=s_item_lookup_link1(self, key);
  char *return_value_strdup_1;
  if(!(item == ((struct _item_t_0 *)NULL)))
  {
    if(!(item->free_fn == ((void (*)(void *))NULL)))
      item->free_fn(item->value);

    else
      if(!(self->autofree == (_Bool)0))
        free(item->value);

    if(!(self->autofree == (_Bool)0))
    {
      return_value_strdup_1=strdup((char *)value);
      value = (void *)return_value_strdup_1;
    }

    item->value = value;
  }

  else
    zhash_insert(self, key, value);
}

// zhashx_autofree
// file src/zhashx.c line 1054
void zhashx_autofree(struct _zhashx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  zhashx_set_destructor(self, (void (*)(void **))zstr_free);
  zhashx_set_duplicator(self, (void * (*)(const void *))strdup);
}

// zhashx_comment
// file src/zhashx.c line 633
void zhashx_comment(struct _zhashx_t *self, const char *format, ...)
{
  if(!(format == ((const char *)NULL)))
  {
    if(self->comments == ((struct _zlistx_t *)NULL))
    {
      self->comments=zlistx_new();
      if(self->comments == ((struct _zlistx_t *)NULL))
        goto __CPROVER_DUMP_L4;

      zlistx_set_destructor(self->comments, (void (*)(void **))zstr_free);
    }

    void **argptr = (void **)&format;
    char *string;
    string=zsys_vprintf(format, argptr);
    argptr = ((void **)NULL);
    if(!(string == ((char *)NULL)))
      zlistx_add_end(self->comments, (void *)string);

  }

  else
    zlistx_destroy(&self->comments);

__CPROVER_DUMP_L4:
  ;
}

// zhashx_cursor
// file src/zhashx.c line 619
const void * zhashx_cursor(struct _zhashx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  return self->cursor_key;
}

// zhashx_delete
// file src/zhashx.c line 379
void zhashx_delete(struct _zhashx_t *self, const void *key)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  /* assertion key */
  assert(key != NULL);
  struct _item_t *item;
  item=s_item_lookup(self, key);
  if(!(item == ((struct _item_t *)NULL)))
    s_item_destroy(self, item, (_Bool)1);

}

// zhashx_destroy
// file src/../include/zhashx.h line 55
void zhashx_destroy(struct _zhashx_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zhashx_t **)NULL));
  if(!(*self_p == ((struct _zhashx_t *)NULL)))
  {
    struct _zhashx_t *self = *self_p;
    if(!(self->items == ((struct _item_t **)NULL)))
    {
      s_purge(self);
      free((void *)self->items);
    }

    zlistx_destroy(&self->comments);
    free((void *)self->filename);
    free((void *)self);
    *self_p = (struct _zhashx_t *)(void *)0;
  }

}

// zhashx_dup
// file src/zhashx.c line 917
struct _zhashx_t * zhashx_dup(struct _zhashx_t *self)
{
  if(self == ((struct _zhashx_t *)NULL))
    return (struct _zhashx_t *)(void *)0;

  else
  {
    struct _zhashx_t *copy;
    copy=zhashx_new();
    if(!(copy == ((struct _zhashx_t *)NULL)))
    {
      copy->destructor = self->destructor;
      copy->duplicator = self->duplicator;
      unsigned int index;
      unsigned long int limit = primes[(signed long int)self->prime_index];
      index = (unsigned int)0;
      for( ; !((unsigned long int)index >= limit); index = index + 1u)
      {
        struct _item_t *item = self->items[(signed long int)index];
        while(!(item == ((struct _item_t *)NULL)))
        {
          signed int return_value_zhashx_insert_1;
          return_value_zhashx_insert_1=zhashx_insert(copy, item->key, item->value);
          if(!(return_value_zhashx_insert_1 == 0))
          {
            zhashx_destroy(&copy);
            break;
          }

          item = item->next;
        }
      }
    }

    return copy;
  }
}

// zhashx_dup_v2
// file src/zhashx.c line 1024
struct _zhashx_t * zhashx_dup_v2(struct _zhashx_t *self)
{
  if(self == ((struct _zhashx_t *)NULL))
    return (struct _zhashx_t *)(void *)0;

  else
  {
    struct _zhashx_t *copy;
    copy=zhashx_new();
    if(!(copy == ((struct _zhashx_t *)NULL)))
    {
      zhashx_autofree(copy);
      unsigned int index;
      unsigned long int limit = primes[(signed long int)self->prime_index];
      index = (unsigned int)0;
      for( ; !((unsigned long int)index >= limit); index = index + 1u)
      {
        struct _item_t *item = self->items[(signed long int)index];
        while(!(item == ((struct _item_t *)NULL)))
        {
          signed int return_value_zhashx_insert_1;
          return_value_zhashx_insert_1=zhashx_insert(copy, item->key, item->value);
          if(!(return_value_zhashx_insert_1 == 0))
          {
            zhashx_destroy(&copy);
            break;
          }

          item = item->next;
        }
      }
    }

    return copy;
  }
}

// zhashx_first
// file src/../include/zhashx.h line 122
void * zhashx_first(struct _zhashx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  self->cursor_index = (unsigned long int)0;
  self->cursor_item = self->items[(signed long int)self->cursor_index];
  void *return_value_zhashx_next_1;
  return_value_zhashx_next_1=zhashx_next(self);
  return return_value_zhashx_next_1;
}

// zhashx_foreach
// file src/zhashx.c line 1069
signed int zhashx_foreach(struct _zhashx_t *self, signed int (*callback)(const char *, void *, void *), void *argument)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  unsigned int index;
  unsigned long int limit = primes[(signed long int)self->prime_index];
  index = (unsigned int)0;
  for( ; !((unsigned long int)index >= limit); index = index + 1u)
  {
    struct _item_t *item = self->items[(signed long int)index];
    if(!(item == ((struct _item_t *)NULL)))
    {
      struct _item_t *next = item->next;
      signed int rc;
      rc=callback((const char *)item->key, item->value, argument);
      if(!(rc == 0))
        return rc;

      item = next;
    }

  }
  return 0;
}

// zhashx_freefn
// file src/../include/zhashx.h line 97
void * zhashx_freefn(struct _zhashx_t *self, const void *key, void (*free_fn)(void *))
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  /* assertion key */
  assert(key != NULL);
  struct _item_t *item;
  item=s_item_lookup(self, key);
  if(!(item == ((struct _item_t *)NULL)))
  {
    item->free_fn = free_fn;
    return item->value;
  }

  else
    return (void *)0;
}

// zhashx_insert
// file src/../include/zhashx.h line 61
signed int zhashx_insert(struct _zhashx_t *self, const void *key, void *value)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  /* assertion key */
  assert(key != NULL);
  unsigned long int limit = primes[(signed long int)self->prime_index];
  if(self->size >= (75ul * limit) / 100ul)
  {
    unsigned int new_prime_index = self->prime_index + (unsigned int)5;
    signed int return_value_s_zhashx_rehash_1;
    return_value_s_zhashx_rehash_1=s_zhashx_rehash(self, new_prime_index);
    if(!(return_value_s_zhashx_rehash_1 == 0))
      return -1;

    self->chain_limit = self->chain_limit + (unsigned int)1;
  }

  struct _item_t *return_value_s_item_insert_2;
  return_value_s_item_insert_2=s_item_insert(self, key, value);
  return return_value_s_item_insert_2 != ((struct _item_t *)NULL) ? 0 : -1;
}

// zhashx_keys
// file src/zhashx.c line 509
struct _zlistx_t * zhashx_keys(struct _zhashx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  struct _zlistx_t *keys;
  keys=zlistx_new();
  if(keys == ((struct _zlistx_t *)NULL))
    return (struct _zlistx_t *)(void *)0;

  else
  {
    zlistx_set_destructor(keys, self->key_destructor);
    zlistx_set_duplicator(keys, self->key_duplicator);
    unsigned int index;
    unsigned long int limit = primes[(signed long int)self->prime_index];
    index = (unsigned int)0;
    for( ; !((unsigned long int)index >= limit); index = index + 1u)
    {
      struct _item_t *item = self->items[(signed long int)index];
      while(!(item == ((struct _item_t *)NULL)))
      {
        void *return_value_zlistx_add_end_1;
        return_value_zlistx_add_end_1=zlistx_add_end(keys, (void *)item->key);
        if(return_value_zlistx_add_end_1 == NULL)
        {
          zlistx_destroy(&keys);
          return (struct _zlistx_t *)(void *)0;
        }

        item = item->next;
      }
    }
    return keys;
  }
}

// zhashx_load
// file src/../include/zhashx.h line 156
signed int zhashx_load(struct _zhashx_t *self, const char *filename)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  zhashx_autofree(self);
  char *filename_copy;
  filename_copy=strdup(filename);
  char *return_value_fgets_2;
  unsigned long int return_value_strlen_3;
  if(!(filename_copy == ((char *)NULL)))
  {
    free((void *)self->filename);
    self->filename = filename_copy;
    self->modified=zsys_file_modified(self->filename);
    struct _IO_FILE *handle;
    handle=fopen(self->filename, "r");
    if(!(handle == ((struct _IO_FILE *)NULL)))
    {
      char *buffer;
      void *return_value_safe_malloc_1;
      return_value_safe_malloc_1=safe_malloc_link14((unsigned long int)1024, "src/zhashx.c", (unsigned int)714);
      buffer = (char *)return_value_safe_malloc_1;
      if(!(buffer == ((char *)NULL)))
      {
        do
        {
          return_value_fgets_2=fgets(buffer, 1024, handle);
          if(return_value_fgets_2 == ((char *)NULL))
            break;

          char *equals;
          equals=strchr(buffer, 61);
          if(!(equals == ((char *)NULL)) && !(equals == buffer) && !((signed int)*buffer == 35))
          {
            unsigned long int return_value_strlen_4;
            return_value_strlen_4=strlen(buffer);
            if((signed int)buffer[-1l + (signed long int)return_value_strlen_4] == 10)
            {
              return_value_strlen_3=strlen(buffer);
              buffer[(signed long int)(return_value_strlen_3 - (unsigned long int)1)] = (char)0;
            }

            char *tmp_post_5 = equals;
            equals = equals + 1l;
            *tmp_post_5 = (char)0;
            zhashx_update(self, (const void *)buffer, (void *)equals);
          }

        }
        while((_Bool)1);
        free((void *)buffer);
      }

      else
      {
        fclose(handle);
        return -1;
      }
      fclose(handle);
    }

    else
      return -1;
  }

  else
    return -1;
  return 0;
}

// zhashx_lookup
// file src/../include/zhashx.h line 84
void * zhashx_lookup(struct _zhashx_t *self, const void *key)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  /* assertion key */
  assert(key != NULL);
  struct _item_t *item;
  item=s_item_lookup(self, key);
  if(!(item == ((struct _item_t *)NULL)))
  {
    self->cursor_item = item;
    self->cursor_key = item->key;
    return item->value;
  }

  else
    return (void *)0;
}

// zhashx_new
// file src/../include/zhashx.h line 51
struct _zhashx_t * zhashx_new(void)
{
  struct _zhashx_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link14(sizeof(struct _zhashx_t) /*128ul*/ , "src/zhashx.c", (unsigned int)105);
  self = (struct _zhashx_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _zhashx_t *)NULL)))
  {
    self->prime_index = (unsigned int)0;
    self->chain_limit = (unsigned int)1;
    unsigned long int limit = primes[(signed long int)self->prime_index];
    void *return_value_safe_malloc_2;
    return_value_safe_malloc_2=safe_malloc_link14(sizeof(struct _item_t *) /*8ul*/  * limit, "src/zhashx.c", (unsigned int)110);
    self->items = (struct _item_t **)return_value_safe_malloc_2;
    if(!(self->items == ((struct _item_t **)NULL)))
    {
      self->hasher = s_bernstein_hash;
      self->key_destructor = (void (*)(void **))zstr_free;
      self->key_duplicator = (void * (*)(const void *))strdup;
      self->key_comparator = (signed int (*)(const void *, const void *))strcmp;
    }

    else
      zhashx_destroy(&self);
  }

  return self;
}

// zhashx_next
// file src/../include/zhashx.h line 131
void * zhashx_next(struct _zhashx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  unsigned long int limit = primes[(signed long int)self->prime_index];
  for( ; self->cursor_item == ((struct _item_t *)NULL); self->cursor_item = self->items[(signed long int)self->cursor_index])
    if(!(self->cursor_index >= limit + 18446744073709551615ul))
      self->cursor_index = self->cursor_index + 1ul;

    else
      return (void *)0;
  /* assertion self->cursor_item */
  assert(self->cursor_item != ((struct _item_t *)NULL));
  struct _item_t *item = self->cursor_item;
  self->cursor_key = item->key;
  self->cursor_item = self->cursor_item->next;
  return item->value;
}

// zhashx_pack
// file src/zhashx.c line 803
struct _zframe_t * zhashx_pack(struct _zhashx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  unsigned long int frame_size = (unsigned long int)4;
  unsigned int index;
  unsigned long int limit = primes[(signed long int)self->prime_index];
  index = (unsigned int)0;
  for( ; !((unsigned long int)index >= limit); index = index + 1u)
  {
    struct _item_t *item = self->items[(signed long int)index];
    while(!(item == ((struct _item_t *)NULL)))
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen((char *)item->key);
      frame_size = frame_size + (unsigned long int)1 + return_value_strlen_1;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen((char *)item->value);
      frame_size = frame_size + (unsigned long int)4 + return_value_strlen_2;
      item = item->next;
    }
  }
  struct _zframe_t *frame;
  frame=zframe_new((void *)0, frame_size);
  if(frame == ((struct _zframe_t *)NULL))
    return (struct _zframe_t *)(void *)0;

  else
  {
    unsigned char *needle;
    needle=zframe_data(frame);
    *((unsigned int *)needle)=htonl((unsigned int)(unsigned long int)self->size);
    needle = needle + (signed long int)4;
    index = (unsigned int)0;
    for( ; !((unsigned long int)index >= limit); index = index + 1u)
    {
      struct _item_t *zhashx_pack__1__2__1__item = self->items[(signed long int)index];
      while(!(zhashx_pack__1__2__1__item == ((struct _item_t *)NULL)))
      {
        unsigned char *tmp_post_3 = needle;
        needle = needle + 1l;
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen((char *)zhashx_pack__1__2__1__item->key);
        *tmp_post_3 = (unsigned char)return_value_strlen_4;
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen((char *)zhashx_pack__1__2__1__item->key);
        memcpy((void *)needle, zhashx_pack__1__2__1__item->key, return_value_strlen_5);
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen((char *)zhashx_pack__1__2__1__item->key);
        needle = needle + (signed long int)return_value_strlen_6;
        unsigned long int lenth;
        lenth=strlen((char *)zhashx_pack__1__2__1__item->value);
        *((unsigned int *)needle)=htonl((unsigned int)(unsigned long int)lenth);
        needle = needle + (signed long int)4;
        unsigned long int return_value_strlen_7;
        return_value_strlen_7=strlen((char *)zhashx_pack__1__2__1__item->value);
        memcpy((void *)needle, (const void *)(char *)zhashx_pack__1__2__1__item->value, return_value_strlen_7);
        unsigned long int return_value_strlen_8;
        return_value_strlen_8=strlen((char *)zhashx_pack__1__2__1__item->value);
        needle = needle + (signed long int)return_value_strlen_8;
        zhashx_pack__1__2__1__item = zhashx_pack__1__2__1__item->next;
      }
    }
    return frame;
  }
}

// zhashx_purge
// file src/../include/zhashx.h line 80
void zhashx_purge(struct _zhashx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  s_purge(self);
  if(self->prime_index >= 1u)
  {
    unsigned long int limit = primes[(signed long int)0];
    struct _item_t **items;
    void *return_value_safe_malloc_1;
    return_value_safe_malloc_1=safe_malloc_link14(sizeof(struct _item_t *) /*8ul*/  * limit, "src/zhashx.c", (unsigned int)404);
    items = (struct _item_t **)return_value_safe_malloc_1;
    if(!(items == ((struct _item_t **)NULL)))
    {
      free((void *)self->items);
      self->prime_index = (unsigned int)0;
      self->chain_limit = (unsigned int)1;
      self->items = items;
    }

  }

}

// zhashx_refresh
// file src/../include/zhashx.h line 163
signed int zhashx_refresh(struct _zhashx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  _Bool return_value_zsys_file_stable_1;
  if(!(self->filename == ((char *)NULL)))
  {
    signed long int return_value_zsys_file_modified_2;
    return_value_zsys_file_modified_2=zsys_file_modified(self->filename);
    if(!(self->modified >= return_value_zsys_file_modified_2))
    {
      return_value_zsys_file_stable_1=zsys_file_stable(self->filename);
      if(!(return_value_zsys_file_stable_1 == (_Bool)0))
      {
        unsigned int index;
        unsigned long int limit = primes[(signed long int)self->prime_index];
        index = (unsigned int)0;
        for( ; !((unsigned long int)index >= limit); index = index + 1u)
        {
          struct _item_t *cur_item = self->items[(signed long int)index];
          while(!(cur_item == ((struct _item_t *)NULL)))
          {
            struct _item_t *next_item = cur_item->next;
            s_item_destroy(self, cur_item, (_Bool)1);
            cur_item = next_item;
          }
        }
        zhashx_load(self, self->filename);
      }

    }

  }

  return 0;
}

// zhashx_rename
// file src/zhashx.c line 442
signed int zhashx_rename(struct _zhashx_t *self, const void *old_key, const void *new_key)
{
  struct _item_t *old_item;
  old_item=s_item_lookup(self, old_key);
  struct _item_t *new_item;
  new_item=s_item_lookup(self, new_key);
  if(new_item == ((struct _item_t *)NULL) && !(old_item == ((struct _item_t *)NULL)))
  {
    s_item_destroy(self, old_item, (_Bool)0);
    if(!(self->key_destructor == ((void (*)(void **))NULL)))
      self->key_destructor((void **)&old_item->key);

    if(!(self->key_duplicator == ((void * (*)(const void *))NULL)))
      old_item->key=self->key_duplicator(new_key);

    else
      old_item->key = new_key;
    old_item->index = self->cached_index;
    old_item->next = self->items[(signed long int)self->cached_index];
    self->items[(signed long int)self->cached_index] = old_item;
    self->size = self->size + 1ul;
    self->cursor_item = old_item;
    self->cursor_key = old_item->key;
    return 0;
  }

  else
    return -1;
}

// zhashx_save
// file src/zhashx.c line 660
signed int zhashx_save(struct _zhashx_t *self, const char *filename)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  struct _IO_FILE *handle;
  handle=fopen(filename, "w");
  if(handle == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    if(!(self->comments == ((struct _zlistx_t *)NULL)))
    {
      char *comment;
      void *return_value_zlistx_first_1;
      return_value_zlistx_first_1=zlistx_first(self->comments);
      comment = (char *)return_value_zlistx_first_1;
      while(!(comment == ((char *)NULL)))
      {
        fprintf(handle, "#   %s\n", comment);
        void *return_value_zlistx_next_2;
        return_value_zlistx_next_2=zlistx_next(self->comments);
        comment = (char *)return_value_zlistx_next_2;
      }
      fprintf(handle, "\n");
    }

    unsigned int index;
    unsigned long int limit = primes[(signed long int)self->prime_index];
    index = (unsigned int)0;
    for( ; !((unsigned long int)index >= limit); index = index + 1u)
    {
      struct _item_t *item = self->items[(signed long int)index];
      for( ; !(item == ((struct _item_t *)NULL)); item = item->next)
        fprintf(handle, "%s=%s\n", (char *)item->key, (char *)item->value);
    }
    fclose(handle);
    return 0;
  }
}

// zhashx_set_destructor
// file src/../include/zhashx.h line 208
void zhashx_set_destructor(struct _zhashx_t *self, void (*destructor)(void **))
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  self->destructor = destructor;
}

// zhashx_set_duplicator
// file src/zhashx.c line 960
void zhashx_set_duplicator(struct _zhashx_t *self, void * (*duplicator)(const void *))
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  self->duplicator = duplicator;
}

// zhashx_set_key_comparator
// file src/zhashx.c line 996
void zhashx_set_key_comparator(struct _zhashx_t *self, signed int (*comparator)(const void *, const void *))
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  /* assertion comparator != ((void *)0) */
  assert(comparator != (signed int (*)(const void *, const void *))(void *)0);
  self->key_comparator = comparator;
}

// zhashx_set_key_destructor
// file src/zhashx.c line 972
void zhashx_set_key_destructor(struct _zhashx_t *self, void (*destructor)(void **))
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  self->key_destructor = destructor;
}

// zhashx_set_key_duplicator
// file src/zhashx.c line 984
void zhashx_set_key_duplicator(struct _zhashx_t *self, void * (*duplicator)(const void *))
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  self->key_duplicator = duplicator;
}

// zhashx_set_key_hasher
// file src/zhashx.c line 1009
void zhashx_set_key_hasher(struct _zhashx_t *self, unsigned long int (*hasher)(const void *))
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  self->hasher = hasher;
}

// zhashx_size
// file src/../include/zhashx.h line 101
unsigned long int zhashx_size(struct _zhashx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  return self->size;
}

// zhashx_test
// file src/zhashx.c line 1095
void zhashx_test(signed int verbose)
{
  printf(" * zhashx: ");
  struct _zhashx_t *hash;
  hash=zhashx_new();
  /* assertion hash */
  assert(hash != ((struct _zhashx_t *)NULL));
  unsigned long int return_value_zhashx_size_1;
  return_value_zhashx_size_1=zhashx_size(hash);
  /* assertion zhashx_size (hash) == 0 */
  assert(return_value_zhashx_size_1 == (unsigned long int)0);
  void *return_value_zhashx_first_2;
  return_value_zhashx_first_2=zhashx_first(hash);
  /* assertion zhashx_first (hash) == ((void *)0) */
  assert(return_value_zhashx_first_2 == (void *)0);
  const void *return_value_zhashx_cursor_3;
  return_value_zhashx_cursor_3=zhashx_cursor(hash);
  /* assertion zhashx_cursor (hash) == ((void *)0) */
  assert(return_value_zhashx_cursor_3 == (void *)0);
  signed int rc;
  rc=zhashx_insert(hash, (const void *)"DEADBEEF", (void *)"dead beef");
  char *item;
  void *return_value_zhashx_first_4;
  return_value_zhashx_first_4=zhashx_first(hash);
  item = (char *)return_value_zhashx_first_4;
  const void *return_value_zhashx_cursor_5;
  return_value_zhashx_cursor_5=zhashx_cursor(hash);
  signed int return_value_strcmp_6;
  return_value_strcmp_6=strcmp((char *)return_value_zhashx_cursor_5, "DEADBEEF");
  /* assertion (!strcmp (((char *) zhashx_cursor (hash)), ("DEADBEEF"))) */
  assert(!(return_value_strcmp_6 != 0));
  signed int return_value_strcmp_7;
  return_value_strcmp_7=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_7 != 0));
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zhashx_insert(hash, (const void *)"ABADCAFE", (void *)"a bad cafe");
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zhashx_insert(hash, (const void *)"C0DEDBAD", (void *)"coded bad");
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zhashx_insert(hash, (const void *)"DEADF00D", (void *)"dead food");
  /* assertion rc == 0 */
  assert(rc == 0);
  unsigned long int return_value_zhashx_size_8;
  return_value_zhashx_size_8=zhashx_size(hash);
  /* assertion zhashx_size (hash) == 4 */
  assert(return_value_zhashx_size_8 == (unsigned long int)4);
  void *return_value_zhashx_lookup_9;
  return_value_zhashx_lookup_9=zhashx_lookup(hash, (const void *)"DEADBEEF");
  item = (char *)return_value_zhashx_lookup_9;
  signed int return_value_strcmp_10;
  return_value_strcmp_10=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_10 != 0));
  void *return_value_zhashx_lookup_11;
  return_value_zhashx_lookup_11=zhashx_lookup(hash, (const void *)"ABADCAFE");
  item = (char *)return_value_zhashx_lookup_11;
  signed int return_value_strcmp_12;
  return_value_strcmp_12=strcmp(item, "a bad cafe");
  /* assertion (!strcmp ((item), ("a bad cafe"))) */
  assert(!(return_value_strcmp_12 != 0));
  void *return_value_zhashx_lookup_13;
  return_value_zhashx_lookup_13=zhashx_lookup(hash, (const void *)"C0DEDBAD");
  item = (char *)return_value_zhashx_lookup_13;
  signed int return_value_strcmp_14;
  return_value_strcmp_14=strcmp(item, "coded bad");
  /* assertion (!strcmp ((item), ("coded bad"))) */
  assert(!(return_value_strcmp_14 != 0));
  void *return_value_zhashx_lookup_15;
  return_value_zhashx_lookup_15=zhashx_lookup(hash, (const void *)"DEADF00D");
  item = (char *)return_value_zhashx_lookup_15;
  signed int return_value_strcmp_16;
  return_value_strcmp_16=strcmp(item, "dead food");
  /* assertion (!strcmp ((item), ("dead food"))) */
  assert(!(return_value_strcmp_16 != 0));
  void *return_value_zhashx_lookup_17;
  return_value_zhashx_lookup_17=zhashx_lookup(hash, (const void *)"foo");
  item = (char *)return_value_zhashx_lookup_17;
  /* assertion item == ((void *)0) */
  assert(item == (char *)(void *)0);
  rc=zhashx_insert(hash, (const void *)"DEADBEEF", (void *)"foo");
  /* assertion rc == -1 */
  assert(rc == -1);
  void *return_value_zhashx_lookup_18;
  return_value_zhashx_lookup_18=zhashx_lookup(hash, (const void *)"DEADBEEF");
  item = (char *)return_value_zhashx_lookup_18;
  signed int return_value_strcmp_19;
  return_value_strcmp_19=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_19 != 0));
  rc=zhashx_rename(hash, (const void *)"DEADBEEF", (const void *)"LIVEBEEF");
  /* assertion rc == 0 */
  assert(rc == 0);
  void *return_value_zhashx_lookup_20;
  return_value_zhashx_lookup_20=zhashx_lookup(hash, (const void *)"LIVEBEEF");
  item = (char *)return_value_zhashx_lookup_20;
  signed int return_value_strcmp_21;
  return_value_strcmp_21=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_21 != 0));
  rc=zhashx_rename(hash, (const void *)"WHATBEEF", (const void *)"NONESUCH");
  /* assertion rc == -1 */
  assert(rc == -1);
  rc=zhashx_rename(hash, (const void *)"WHATBEEF", (const void *)"LIVEBEEF");
  /* assertion rc == -1 */
  assert(rc == -1);
  void *return_value_zhashx_lookup_22;
  return_value_zhashx_lookup_22=zhashx_lookup(hash, (const void *)"LIVEBEEF");
  item = (char *)return_value_zhashx_lookup_22;
  signed int return_value_strcmp_23;
  return_value_strcmp_23=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_23 != 0));
  rc=zhashx_rename(hash, (const void *)"LIVEBEEF", (const void *)"ABADCAFE");
  /* assertion rc == -1 */
  assert(rc == -1);
  void *return_value_zhashx_lookup_24;
  return_value_zhashx_lookup_24=zhashx_lookup(hash, (const void *)"LIVEBEEF");
  item = (char *)return_value_zhashx_lookup_24;
  signed int return_value_strcmp_25;
  return_value_strcmp_25=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_25 != 0));
  void *return_value_zhashx_lookup_26;
  return_value_zhashx_lookup_26=zhashx_lookup(hash, (const void *)"ABADCAFE");
  item = (char *)return_value_zhashx_lookup_26;
  signed int return_value_strcmp_27;
  return_value_strcmp_27=strcmp(item, "a bad cafe");
  /* assertion (!strcmp ((item), ("a bad cafe"))) */
  assert(!(return_value_strcmp_27 != 0));
  struct _zlistx_t *keys;
  keys=zhashx_keys(hash);
  unsigned long int return_value_zlistx_size_28;
  return_value_zlistx_size_28=zlistx_size(keys);
  /* assertion zlistx_size (keys) == 4 */
  assert(return_value_zlistx_size_28 == (unsigned long int)4);
  zlistx_destroy(&keys);
  struct _zlistx_t *values;
  values=zhashx_values(hash);
  unsigned long int return_value_zlistx_size_29;
  return_value_zlistx_size_29=zlistx_size(values);
  /* assertion zlistx_size (values) == 4 */
  assert(return_value_zlistx_size_29 == (unsigned long int)4);
  zlistx_destroy(&values);
  struct _zhashx_t *copy;
  copy=zhashx_dup(hash);
  unsigned long int return_value_zhashx_size_30;
  return_value_zhashx_size_30=zhashx_size(copy);
  /* assertion zhashx_size (copy) == 4 */
  assert(return_value_zhashx_size_30 == (unsigned long int)4);
  void *return_value_zhashx_lookup_31;
  return_value_zhashx_lookup_31=zhashx_lookup(copy, (const void *)"LIVEBEEF");
  item = (char *)return_value_zhashx_lookup_31;
  /* assertion item */
  assert(item != ((char *)NULL));
  signed int return_value_strcmp_32;
  return_value_strcmp_32=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_32 != 0));
  zhashx_destroy(&copy);
  struct _zframe_t *frame;
  frame=zhashx_pack(hash);
  copy=zhashx_unpack(frame);
  zframe_destroy(&frame);
  unsigned long int return_value_zhashx_size_33;
  return_value_zhashx_size_33=zhashx_size(copy);
  /* assertion zhashx_size (copy) == 4 */
  assert(return_value_zhashx_size_33 == (unsigned long int)4);
  void *return_value_zhashx_lookup_34;
  return_value_zhashx_lookup_34=zhashx_lookup(copy, (const void *)"LIVEBEEF");
  item = (char *)return_value_zhashx_lookup_34;
  /* assertion item */
  assert(item != ((char *)NULL));
  signed int return_value_strcmp_35;
  return_value_strcmp_35=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_35 != 0));
  zhashx_destroy(&copy);
  zhashx_comment(hash, "This is a test file");
  zhashx_comment(hash, "Created by %s", (const void *)"czmq_selftest");
  zhashx_save(hash, ".cache");
  copy=zhashx_new();
  /* assertion copy */
  assert(copy != ((struct _zhashx_t *)NULL));
  zhashx_load(copy, ".cache");
  void *return_value_zhashx_lookup_36;
  return_value_zhashx_lookup_36=zhashx_lookup(copy, (const void *)"LIVEBEEF");
  item = (char *)return_value_zhashx_lookup_36;
  /* assertion item */
  assert(item != ((char *)NULL));
  signed int return_value_strcmp_37;
  return_value_strcmp_37=strcmp(item, "dead beef");
  /* assertion (!strcmp ((item), ("dead beef"))) */
  assert(!(return_value_strcmp_37 != 0));
  zhashx_destroy(&copy);
  zsys_file_delete(".cache");
  zhashx_delete(hash, (const void *)"LIVEBEEF");
  void *return_value_zhashx_lookup_38;
  return_value_zhashx_lookup_38=zhashx_lookup(hash, (const void *)"LIVEBEEF");
  item = (char *)return_value_zhashx_lookup_38;
  /* assertion item == ((void *)0) */
  assert(item == (char *)(void *)0);
  unsigned long int return_value_zhashx_size_39;
  return_value_zhashx_size_39=zhashx_size(hash);
  /* assertion zhashx_size (hash) == 3 */
  assert(return_value_zhashx_size_39 == (unsigned long int)3);
  /* tag-#anon#lST[lARR100{S8}_S8_'name'|B'exists'] */
struct anonymous_32
{
  // name
  char name[100l];
  // exists
  _Bool exists;
};

/* */
  ;
  struct anonymous_32 testset[200l];
  memset((void *)testset, 0, sizeof(struct anonymous_32 [200l]) /*20200ul*/ );
  signed int testmax = 200;
  signed int testnbr;
  signed int iteration;
  signed long int return_value_time_40;
  return_value_time_40=time((signed long int *)(void *)0);
  srandom((unsigned int)return_value_time_40);
  iteration = 0;
  for( ; !(iteration >= 25000); iteration = iteration + 1)
  {
    signed long int return_value_random_41;
    return_value_random_41=random();
    testnbr = (signed int)((double)((float)testmax * (float)return_value_random_41) / ((double)2147483647 + 1.0));
    if(!(testset[(signed long int)testnbr].exists == (_Bool)0))
    {
      void *return_value_zhashx_lookup_42;
      return_value_zhashx_lookup_42=zhashx_lookup(hash, (const void *)testset[(signed long int)testnbr].name);
      item = (char *)return_value_zhashx_lookup_42;
      /* assertion item */
      assert(item != ((char *)NULL));
      zhashx_delete(hash, (const void *)testset[(signed long int)testnbr].name);
      testset[(signed long int)testnbr].exists = (_Bool)0;
    }

    else
    {
      signed int return_value_rand_43;
      return_value_rand_43=rand();
      signed int return_value_rand_44;
      return_value_rand_44=rand();
      sprintf(testset[(signed long int)testnbr].name, "%x-%x", return_value_rand_43, return_value_rand_44);
      signed int return_value_zhashx_insert_45;
      return_value_zhashx_insert_45=zhashx_insert(hash, (const void *)testset[(signed long int)testnbr].name, (void *)"");
      if(return_value_zhashx_insert_45 == 0)
        testset[(signed long int)testnbr].exists = (_Bool)1;

    }
  }
  iteration = 0;
  void *return_value_zhashx_lookup_46;
  for( ; !(iteration >= 10000); iteration = iteration + 1)
  {
    return_value_zhashx_lookup_46=zhashx_lookup(hash, (const void *)"DEADBEEFABADCAFE");
    item = (char *)return_value_zhashx_lookup_46;
  }
  zhashx_destroy(&hash);
  zhashx_destroy(&hash);
  /* assertion hash == ((void *)0) */
  assert(hash == (struct _zhashx_t *)(void *)0);
  hash=zhashx_new();
  /* assertion hash */
  assert(hash != ((struct _zhashx_t *)NULL));
  zhashx_autofree(hash);
  char value[255l];
  strcpy(value, "This is a string");
  rc=zhashx_insert(hash, (const void *)"key1", (void *)value);
  /* assertion rc == 0 */
  assert(rc == 0);
  strcpy(value, "Ring a ding ding");
  rc=zhashx_insert(hash, (const void *)"key2", (void *)value);
  /* assertion rc == 0 */
  assert(rc == 0);
  void *return_value_zhashx_lookup_47;
  return_value_zhashx_lookup_47=zhashx_lookup(hash, (const void *)"key1");
  signed int return_value_strcmp_48;
  return_value_strcmp_48=strcmp((char *)return_value_zhashx_lookup_47, "This is a string");
  /* assertion (!strcmp (((char *) zhashx_lookup (hash, "key1")), ("This is a string"))) */
  assert(!(return_value_strcmp_48 != 0));
  void *return_value_zhashx_lookup_49;
  return_value_zhashx_lookup_49=zhashx_lookup(hash, (const void *)"key2");
  signed int return_value_strcmp_50;
  return_value_strcmp_50=strcmp((char *)return_value_zhashx_lookup_49, "Ring a ding ding");
  /* assertion (!strcmp (((char *) zhashx_lookup (hash, "key2")), ("Ring a ding ding"))) */
  assert(!(return_value_strcmp_50 != 0));
  zhashx_destroy(&hash);
  printf("OK\n");
}

// zhashx_unpack
// file src/zhashx.c line 856
struct _zhashx_t * zhashx_unpack(struct _zframe_t *frame)
{
  struct _zhashx_t *self;
  self=zhashx_new();
  if(self == ((struct _zhashx_t *)NULL))
    return (struct _zhashx_t *)(void *)0;

  else
  {
    /* assertion frame */
    assert(frame != ((struct _zframe_t *)NULL));
    unsigned long int return_value_zframe_size_1;
    return_value_zframe_size_1=zframe_size(frame);
    if(!(return_value_zframe_size_1 >= 4ul))
      return self;

    else
    {
      unsigned char *needle;
      needle=zframe_data(frame);
      unsigned char *ceiling;
      unsigned long int return_value_zframe_size_2;
      return_value_zframe_size_2=zframe_size(frame);
      ceiling = needle + (signed long int)return_value_zframe_size_2;
      unsigned long int nbr_items;
      unsigned int return_value_ntohl_3;
      return_value_ntohl_3=ntohl(*((unsigned int *)needle));
      nbr_items = (unsigned long int)return_value_ntohl_3;
      needle = needle + (signed long int)4;
      while(!(nbr_items == 0ul) && !(needle >= ceiling))
      {
        unsigned long int key_size;
        unsigned char *tmp_post_4 = needle;
        needle = needle + 1l;
        key_size = (unsigned long int)*tmp_post_4;
        if(ceiling >= needle + (signed long int)key_size)
        {
          char key[256l];
          memcpy((void *)key, (const void *)needle, key_size);
          key[(signed long int)key_size] = (char)0;
          needle = needle + (signed long int)key_size;
          if(ceiling >= needle + 4l)
          {
            unsigned long int value_size;
            unsigned int return_value_ntohl_5;
            return_value_ntohl_5=ntohl(*((unsigned int *)needle));
            value_size = (unsigned long int)return_value_ntohl_5;
            needle = needle + (signed long int)4;
            if(ceiling >= needle + (signed long int)value_size)
            {
              char *value;
              void *return_value_safe_malloc_6;
              return_value_safe_malloc_6=safe_malloc_link14(value_size + (unsigned long int)1, "src/zhashx.c", (unsigned int)884);
              value = (char *)return_value_safe_malloc_6;
              if(value == ((char *)NULL))
              {
                zhashx_destroy(&self);
                return (struct _zhashx_t *)(void *)0;
              }

              memcpy((void *)value, (const void *)needle, value_size);
              value[(signed long int)value_size] = (char)0;
              needle = needle + (signed long int)value_size;
              signed int return_value_zhashx_insert_7;
              return_value_zhashx_insert_7=zhashx_insert(self, (const void *)key, (void *)value);
              if(!(return_value_zhashx_insert_7 == 0))
              {
                zhashx_destroy(&self);
                break;
              }

            }

          }

        }

      }
      if(!(self == ((struct _zhashx_t *)NULL)))
        zhashx_autofree(self);

      return self;
    }
  }
}

// zhashx_update
// file src/../include/zhashx.h line 69
void zhashx_update(struct _zhashx_t *self, const void *key, void *value)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  /* assertion key */
  assert(key != NULL);
  struct _item_t *item;
  item=s_item_lookup(self, key);
  if(!(item == ((struct _item_t *)NULL)))
  {
    if(!(self->destructor == ((void (*)(void **))NULL)))
      self->destructor(&item->value);

    else
      if(!(item->free_fn == ((void (*)(void *))NULL)))
        item->free_fn(item->value);

    if(!(self->duplicator == ((void * (*)(const void *))NULL)))
      item->value=self->duplicator(value);

    else
      item->value = value;
  }

  else
    zhashx_insert(self, key, value);
}

// zhashx_values
// file src/zhashx.c line 537
struct _zlistx_t * zhashx_values(struct _zhashx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zhashx_t *)NULL));
  struct _zlistx_t *values;
  values=zlistx_new();
  if(values == ((struct _zlistx_t *)NULL))
    return (struct _zlistx_t *)(void *)0;

  else
  {
    zlistx_set_destructor(values, self->destructor);
    zlistx_set_duplicator(values, self->duplicator);
    unsigned int index;
    unsigned long int limit = primes[(signed long int)self->prime_index];
    index = (unsigned int)0;
    for( ; !((unsigned long int)index >= limit); index = index + 1u)
    {
      struct _item_t *item = self->items[(signed long int)index];
      while(!(item == ((struct _item_t *)NULL)))
      {
        void *return_value_zlistx_add_end_1;
        return_value_zlistx_add_end_1=zlistx_add_end(values, (void *)item->value);
        if(return_value_zlistx_add_end_1 == NULL)
        {
          zlistx_destroy(&values);
          return (struct _zlistx_t *)(void *)0;
        }

        item = item->next;
      }
    }
    return values;
  }
}

// ziflist_address
// file src/../include/ziflist.h line 54
const char * ziflist_address(struct _ziflist_t *self)
{
  /* assertion self */
  assert(self != ((struct _ziflist_t *)NULL));
  struct anonymous_19 *iface;
  void *return_value_zlistx_item_1;
  return_value_zlistx_item_1=zlistx_item((struct _zlistx_t *)self);
  iface = (struct anonymous_19 *)return_value_zlistx_item_1;
  if(!(iface == ((struct anonymous_19 *)NULL)))
    return iface->address;

  else
    return (const char *)(void *)0;
}

// ziflist_broadcast
// file src/../include/ziflist.h line 58
const char * ziflist_broadcast(struct _ziflist_t *self)
{
  /* assertion self */
  assert(self != ((struct _ziflist_t *)NULL));
  struct anonymous_19 *iface;
  void *return_value_zlistx_item_1;
  return_value_zlistx_item_1=zlistx_item((struct _zlistx_t *)self);
  iface = (struct anonymous_19 *)return_value_zlistx_item_1;
  if(!(iface == ((struct anonymous_19 *)NULL)))
    return iface->broadcast;

  else
    return (const char *)(void *)0;
}

// ziflist_destroy
// file src/../include/ziflist.h line 30
void ziflist_destroy(struct _ziflist_t **self_p)
{
  zlistx_destroy((struct _zlistx_t **)self_p);
}

// ziflist_first
// file src/../include/ziflist.h line 46
const char * ziflist_first(struct _ziflist_t *self)
{
  /* assertion self */
  assert(self != ((struct _ziflist_t *)NULL));
  struct anonymous_19 *iface;
  void *return_value_zlistx_first_1;
  return_value_zlistx_first_1=zlistx_first((struct _zlistx_t *)self);
  iface = (struct anonymous_19 *)return_value_zlistx_first_1;
  if(!(iface == ((struct anonymous_19 *)NULL)))
    return iface->name;

  else
    return (const char *)(void *)0;
}

// ziflist_netmask
// file src/ziflist.c line 353
const char * ziflist_netmask(struct _ziflist_t *self)
{
  /* assertion self */
  assert(self != ((struct _ziflist_t *)NULL));
  struct anonymous_19 *iface;
  void *return_value_zlistx_item_1;
  return_value_zlistx_item_1=zlistx_item((struct _zlistx_t *)self);
  iface = (struct anonymous_19 *)return_value_zlistx_item_1;
  if(!(iface == ((struct anonymous_19 *)NULL)))
    return iface->netmask;

  else
    return (const char *)(void *)0;
}

// ziflist_new
// file src/../include/ziflist.h line 26
struct _ziflist_t * ziflist_new(void)
{
  struct _zlistx_t *list;
  list=zlistx_new();
  struct _ziflist_t *self = (struct _ziflist_t *)list;
  if(!(self == ((struct _ziflist_t *)NULL)))
  {
    zlistx_set_destructor(list, (void (*)(void **))s_interface_destroy);
    ziflist_reload(self);
  }

  return self;
}

// ziflist_next
// file src/../include/ziflist.h line 50
const char * ziflist_next(struct _ziflist_t *self)
{
  /* assertion self */
  assert(self != ((struct _ziflist_t *)NULL));
  struct anonymous_19 *iface;
  void *return_value_zlistx_next_1;
  return_value_zlistx_next_1=zlistx_next((struct _zlistx_t *)self);
  iface = (struct anonymous_19 *)return_value_zlistx_next_1;
  if(!(iface == ((struct anonymous_19 *)NULL)))
    return iface->name;

  else
    return (const char *)(void *)0;
}

// ziflist_print
// file src/ziflist.c line 99
void ziflist_print(struct _ziflist_t *self)
{
  struct anonymous_19 *iface;
  void *return_value_zlistx_first_1;
  return_value_zlistx_first_1=zlistx_first((struct _zlistx_t *)self);
  iface = (struct anonymous_19 *)return_value_zlistx_first_1;
  void *return_value_zlistx_next_2;
  for( ; !(iface == ((struct anonymous_19 *)NULL)); iface = (struct anonymous_19 *)return_value_zlistx_next_2)
  {
    zsys_info(" - interface name : %s", iface->name);
    zsys_info(" - interface address : %s", iface->address);
    zsys_info(" - interface netmask : %s", iface->netmask);
    zsys_info(" - interface broadcast : %s", iface->broadcast);
    return_value_zlistx_next_2=zlistx_next((struct _zlistx_t *)self);
  }
}

// ziflist_reload
// file src/ziflist.c line 145
void ziflist_reload(struct _ziflist_t *self)
{
  /* assertion self */
  assert(self != ((struct _ziflist_t *)NULL));
  struct _zlistx_t *list = (struct _zlistx_t *)self;
  zlistx_purge(list);
  struct ifaddrs *interfaces;
  signed int return_value_getifaddrs_2;
  return_value_getifaddrs_2=getifaddrs(&interfaces);
  _Bool return_value_s_valid_flags_1;
  if(return_value_getifaddrs_2 == 0)
  {
    struct ifaddrs *interface = interfaces;
    while(!(interface == ((struct ifaddrs *)NULL)))
    {
      if(!(interface->ifa_ifu.ifu_broadaddr == ((struct sockaddr *)NULL)))
      {
        if(!(interface->ifa_addr == ((struct sockaddr *)NULL)))
        {
          if((signed int)interface->ifa_addr->sa_family == 2)
          {
            return_value_s_valid_flags_1=s_valid_flags((signed short int)interface->ifa_flags);
            if(!(return_value_s_valid_flags_1 == (_Bool)0))
            {
              struct sockaddr_in address = *((struct sockaddr_in *)interface->ifa_addr);
              struct sockaddr_in netmask = *((struct sockaddr_in *)interface->ifa_netmask);
              struct sockaddr_in broadcast = *((struct sockaddr_in *)interface->ifa_ifu.ifu_broadaddr);
              if(address.sin_addr.s_addr == broadcast.sin_addr.s_addr)
                broadcast.sin_addr.s_addr = broadcast.sin_addr.s_addr | ~netmask.sin_addr.s_addr;

              struct anonymous_19 *item;
              item=s_interface_new(interface->ifa_name, address, netmask, broadcast);
              if(!(item == ((struct anonymous_19 *)NULL)))
                zlistx_add_end(list, (void *)item);

            }

          }

        }

      }

      interface = interface->ifa_next;
    }
  }

  freeifaddrs(interfaces);
}

// ziflist_size
// file src/ziflist.c line 282
unsigned long int ziflist_size(struct _ziflist_t *self)
{
  /* assertion self */
  assert(self != ((struct _ziflist_t *)NULL));
  unsigned long int return_value_zlistx_size_1;
  return_value_zlistx_size_1=zlistx_size((struct _zlistx_t *)self);
  return return_value_zlistx_size_1;
}

// ziflist_test
// file src/ziflist.c line 368
void ziflist_test(_Bool verbose)
{
  printf(" * ziflist: ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  struct _ziflist_t *iflist;
  iflist=ziflist_new();
  /* assertion iflist */
  assert(iflist != ((struct _ziflist_t *)NULL));
  unsigned long int items;
  items=ziflist_size(iflist);
  if(!(verbose == (_Bool)0))
  {
    const char *name;
    name=ziflist_first(iflist);
    while(!(name == ((const char *)NULL)))
    {
      const char *return_value_ziflist_address_1;
      return_value_ziflist_address_1=ziflist_address(iflist);
      const char *return_value_ziflist_netmask_2;
      return_value_ziflist_netmask_2=ziflist_netmask(iflist);
      const char *return_value_ziflist_broadcast_3;
      return_value_ziflist_broadcast_3=ziflist_broadcast(iflist);
      printf(" - name=%s address=%s netmask=%s broadcast=%s\n", name, return_value_ziflist_address_1, return_value_ziflist_netmask_2, return_value_ziflist_broadcast_3);
      name=ziflist_next(iflist);
    }
  }

  ziflist_reload(iflist);
  unsigned long int return_value_ziflist_size_4;
  return_value_ziflist_size_4=ziflist_size(iflist);
  /* assertion items == ziflist_size (iflist) */
  assert(items == return_value_ziflist_size_4);
  ziflist_destroy(&iflist);
  printf("OK\n");
}

// zlist_append
// file src/zlist.c line 173
signed int zlist_append(struct _zlist_t *self, void *item)
{
  char *return_value_strdup_2;
  if(item == NULL)
    return -1;

  else
  {
    struct _node_t_0 *node;
    void *return_value_safe_malloc_1;
    return_value_safe_malloc_1=safe_malloc_link32(sizeof(struct _node_t_0) /*24ul*/ , "src/zlist.c", (unsigned int)179);
    node = (struct _node_t_0 *)return_value_safe_malloc_1;
    if(node == ((struct _node_t_0 *)NULL))
      return -1;

    else
    {
      if(!(self->autofree == (_Bool)0))
      {
        return_value_strdup_2=strdup((char *)item);
        item = (void *)return_value_strdup_2;
      }

      node->item = item;
      if(!(self->tail == ((struct _node_t_0 *)NULL)))
        self->tail->next = node;

      else
        self->head = node;
      self->tail = node;
      node->next = (struct _node_t_0 *)(void *)0;
      self->size = self->size + 1ul;
      self->cursor = (struct _node_t_0 *)(void *)0;
      return 0;
    }
  }
}

// zlist_autofree
// file src/zlist.c line 472
void zlist_autofree(struct _zlist_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlist_t *)NULL));
  self->autofree = (_Bool)1;
}

// zlist_comparefn
// file src/zlist.c line 430
void zlist_comparefn(struct _zlist_t *self, signed int (*fn)(void *, void *))
{
  /* assertion self */
  assert(self != ((struct _zlist_t *)NULL));
  self->compare_fn = fn;
}

// zlist_destroy
// file src/zlist.c line 66
void zlist_destroy(struct _zlist_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zlist_t **)NULL));
  if(!(*self_p == ((struct _zlist_t *)NULL)))
  {
    struct _zlist_t *self = *self_p;
    zlist_purge(self);
    free((void *)self);
    *self_p = (struct _zlist_t *)(void *)0;
  }

}

// zlist_dup
// file src/zlist.c line 328
struct _zlist_t * zlist_dup(struct _zlist_t *self)
{
  if(self == ((struct _zlist_t *)NULL))
    return (struct _zlist_t *)(void *)0;

  else
  {
    struct _zlist_t *copy;
    copy=zlist_new();
    if(!(copy == ((struct _zlist_t *)NULL)))
    {
      struct _node_t_0 *node = self->head;
      for( ; !(node == ((struct _node_t_0 *)NULL)); node = node->next)
      {
        signed int return_value_zlist_append_1;
        return_value_zlist_append_1=zlist_append(copy, node->item);
        if(return_value_zlist_append_1 == -1)
        {
          zlist_destroy(&copy);
          break;
        }

      }
    }

    return copy;
  }
}

// zlist_exists
// file src/zlist.c line 257
_Bool zlist_exists(struct _zlist_t *self, void *item)
{
  /* assertion self */
  assert(self != ((struct _zlist_t *)NULL));
  /* assertion item */
  assert(item != NULL);
  struct _node_t_0 *node = self->head;
  for( ; !(node == ((struct _node_t_0 *)NULL)); node = node->next)
    if(!(self->compare_fn == ((signed int (*)(void *, void *))NULL)))
    {
      signed int return_value;
      return_value=self->compare_fn(node->item, item);
      if(return_value == 0)
        return (_Bool)1;

    }

    else
      if(node->item == item)
        return (_Bool)1;

  return (_Bool)0;
}

// zlist_first
// file src/zlist.c line 83
void * zlist_first(struct _zlist_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlist_t *)NULL));
  self->cursor = self->head;
  if(!(self->cursor == ((struct _node_t_0 *)NULL)))
    return self->cursor->item;

  else
    return (void *)0;
}

// zlist_freefn
// file src/zlist.c line 445
void * zlist_freefn(struct _zlist_t *self, void *item, void (*fn)(void *), _Bool at_tail)
{
  struct _node_t_0 *node = self->head;
  if(!(at_tail == (_Bool)0))
    node = self->tail;

  for( ; !(node == ((struct _node_t_0 *)NULL)); node = node->next)
    if(node->item == item)
    {
      node->free_fn = fn;
      return item;
    }

  return (void *)0;
}

// zlist_head
// file src/zlist.c line 134
void * zlist_head(struct _zlist_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlist_t *)NULL));
  void *tmp_if_expr_1;
  if(!(self->head == ((struct _node_t_0 *)NULL)))
    tmp_if_expr_1 = self->head->item;

  else
    tmp_if_expr_1 = (void *)0;
  return tmp_if_expr_1;
}

// zlist_item
// file src/zlist.c line 158
void * zlist_item(struct _zlist_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlist_t *)NULL));
  if(!(self->cursor == ((struct _node_t_0 *)NULL)))
    return self->cursor->item;

  else
    return (void *)0;
}

// zlist_last
// file src/zlist.c line 118
void * zlist_last(struct _zlist_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlist_t *)NULL));
  self->cursor = self->tail;
  if(!(self->cursor == ((struct _node_t_0 *)NULL)))
    return self->cursor->item;

  else
    return (void *)0;
}

// zlist_new
// file src/zlist.c line 55
struct _zlist_t * zlist_new(void)
{
  struct _zlist_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link32(sizeof(struct _zlist_t) /*48ul*/ , "src/zlist.c", (unsigned int)57);
  self = (struct _zlist_t *)return_value_safe_malloc_1;
  return self;
}

// zlist_next
// file src/zlist.c line 99
void * zlist_next(struct _zlist_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlist_t *)NULL));
  if(!(self->cursor == ((struct _node_t_0 *)NULL)))
    self->cursor = self->cursor->next;

  else
    self->cursor = self->head;
  if(!(self->cursor == ((struct _node_t_0 *)NULL)))
    return self->cursor->item;

  else
    return (void *)0;
}

// zlist_pop
// file src/zlist.c line 234
void * zlist_pop(struct _zlist_t *self)
{
  struct _node_t_0 *node = self->head;
  void *item = (void *)0;
  if(!(node == ((struct _node_t_0 *)NULL)))
  {
    item = node->item;
    self->head = node->next;
    if(self->tail == node)
      self->tail = (struct _node_t_0 *)(void *)0;

    free((void *)node);
    self->size = self->size - 1ul;
  }

  self->cursor = (struct _node_t_0 *)(void *)0;
  return item;
}

// zlist_purge
// file src/zlist.c line 351
void zlist_purge(struct _zlist_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlist_t *)NULL));
  struct _node_t_0 *node = self->head;
  while(!(node == ((struct _node_t_0 *)NULL)))
  {
    struct _node_t_0 *next = node->next;
    if(!(self->autofree == (_Bool)0))
      free(node->item);

    else
      if(!(node->free_fn == ((void (*)(void *))NULL)))
        node->free_fn(node->item);

    free((void *)node);
    node = next;
  }
  self->head = (struct _node_t_0 *)(void *)0;
  self->tail = (struct _node_t_0 *)(void *)0;
  self->cursor = (struct _node_t_0 *)(void *)0;
  self->size = (unsigned long int)0;
}

// zlist_push
// file src/zlist.c line 207
signed int zlist_push(struct _zlist_t *self, void *item)
{
  struct _node_t_0 *node;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link32(sizeof(struct _node_t_0) /*24ul*/ , "src/zlist.c", (unsigned int)210);
  node = (struct _node_t_0 *)return_value_safe_malloc_1;
  char *return_value_strdup_2;
  if(node == ((struct _node_t_0 *)NULL))
    return -1;

  else
  {
    if(!(self->autofree == (_Bool)0))
    {
      return_value_strdup_2=strdup((char *)item);
      item = (void *)return_value_strdup_2;
    }

    node->item = item;
    node->next = self->head;
    self->head = node;
    if(self->tail == ((struct _node_t_0 *)NULL))
      self->tail = node;

    self->size = self->size + 1ul;
    self->cursor = (struct _node_t_0 *)(void *)0;
    return 0;
  }
}

// zlist_remove
// file src/zlist.c line 285
void zlist_remove(struct _zlist_t *self, void *item)
{
  struct _node_t_0 *node;
  struct _node_t_0 *prev = (struct _node_t_0 *)(void *)0;
  node = self->head;
  for( ; !(node == ((struct _node_t_0 *)NULL)); node = node->next)
  {
    if(!(self->compare_fn == ((signed int (*)(void *, void *))NULL)))
    {
      signed int return_value;
      return_value=self->compare_fn(node->item, item);
      if(return_value == 0)
        break;

    }

    else
      if(node->item == item)
        break;

    prev = node;
  }
  if(!(node == ((struct _node_t_0 *)NULL)))
  {
    if(!(prev == ((struct _node_t_0 *)NULL)))
      prev->next = node->next;

    else
      self->head = node->next;
    if(node->next == ((struct _node_t_0 *)NULL))
      self->tail = prev;

    if(self->cursor == node)
      self->cursor = prev;

    if(!(node->free_fn == ((void (*)(void *))NULL)))
      node->free_fn(node->item);

    free((void *)node);
    self->size = self->size - 1ul;
  }

}

// zlist_size
// file src/zlist.c line 377
unsigned long int zlist_size(struct _zlist_t *self)
{
  return self->size;
}

// zlist_sort
// file src/zlist.c line 388
void zlist_sort(struct _zlist_t *self, signed int (*compare)(void *, void *))
{
  if(compare == ((signed int (*)(void *, void *))NULL))
  {
    if(!(self->compare_fn == ((signed int (*)(void *, void *))NULL)))
      compare = self->compare_fn;

  }

  unsigned long int gap = self->size;
  _Bool swapped = (_Bool)0;
  unsigned long int tmp_post_1;
  while(gap >= 2ul || !(swapped == (_Bool)0))
  {
    if(gap >= 2ul)
      gap = (unsigned long int)((double)gap / 1.3);

    struct _node_t_0 *base = self->head;
    struct _node_t_0 *test = self->head;
    unsigned long int jump = gap;
    do
    {
      tmp_post_1 = jump;
      jump = jump - 1ul;
      if(tmp_post_1 == 0ul)
        break;

      test = test->next;
    }
    while((_Bool)1);
    swapped = (_Bool)0;
    if(!(base == ((struct _node_t_0 *)NULL)) && !(test == ((struct _node_t_0 *)NULL)))
    {
      signed int return_value;
      return_value=compare(base->item, test->item);
      if(return_value >= 1)
      {
        void *item = base->item;
        base->item = test->item;
        test->item = item;
        swapped = (_Bool)1;
      }

      base = base->next;
      test = test->next;
    }

  }
}

// zlist_tail
// file src/zlist.c line 146
void * zlist_tail(struct _zlist_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlist_t *)NULL));
  void *tmp_if_expr_1;
  if(!(self->tail == ((struct _node_t_0 *)NULL)))
    tmp_if_expr_1 = self->tail->item;

  else
    tmp_if_expr_1 = (void *)0;
  return tmp_if_expr_1;
}

// zlist_test
// file src/zlist.c line 497
void zlist_test(signed int verbose)
{
  printf(" * zlist: ");
  struct _zlist_t *list;
  list=zlist_new();
  /* assertion list */
  assert(list != ((struct _zlist_t *)NULL));
  unsigned long int return_value_zlist_size_1;
  return_value_zlist_size_1=zlist_size(list);
  /* assertion zlist_size (list) == 0 */
  assert(return_value_zlist_size_1 == (unsigned long int)0);
  char *cheese = "boursin";
  char *bread = "baguette";
  char *wine = "bordeaux";
  zlist_append(list, (void *)cheese);
  unsigned long int return_value_zlist_size_2;
  return_value_zlist_size_2=zlist_size(list);
  /* assertion zlist_size (list) == 1 */
  assert(return_value_zlist_size_2 == (unsigned long int)1);
  _Bool return_value_zlist_exists_3;
  return_value_zlist_exists_3=zlist_exists(list, (void *)cheese);
  /* assertion zlist_exists (list, cheese) */
  assert(return_value_zlist_exists_3 != (_Bool)0);
  _Bool return_value_zlist_exists_4;
  return_value_zlist_exists_4=zlist_exists(list, (void *)bread);
  /* assertion !zlist_exists (list, bread) */
  assert(!(return_value_zlist_exists_4 != (_Bool)0));
  _Bool return_value_zlist_exists_5;
  return_value_zlist_exists_5=zlist_exists(list, (void *)wine);
  /* assertion !zlist_exists (list, wine) */
  assert(!(return_value_zlist_exists_5 != (_Bool)0));
  zlist_append(list, (void *)bread);
  unsigned long int return_value_zlist_size_6;
  return_value_zlist_size_6=zlist_size(list);
  /* assertion zlist_size (list) == 2 */
  assert(return_value_zlist_size_6 == (unsigned long int)2);
  _Bool return_value_zlist_exists_7;
  return_value_zlist_exists_7=zlist_exists(list, (void *)cheese);
  /* assertion zlist_exists (list, cheese) */
  assert(return_value_zlist_exists_7 != (_Bool)0);
  _Bool return_value_zlist_exists_8;
  return_value_zlist_exists_8=zlist_exists(list, (void *)bread);
  /* assertion zlist_exists (list, bread) */
  assert(return_value_zlist_exists_8 != (_Bool)0);
  _Bool return_value_zlist_exists_9;
  return_value_zlist_exists_9=zlist_exists(list, (void *)wine);
  /* assertion !zlist_exists (list, wine) */
  assert(!(return_value_zlist_exists_9 != (_Bool)0));
  zlist_append(list, (void *)wine);
  unsigned long int return_value_zlist_size_10;
  return_value_zlist_size_10=zlist_size(list);
  /* assertion zlist_size (list) == 3 */
  assert(return_value_zlist_size_10 == (unsigned long int)3);
  _Bool return_value_zlist_exists_11;
  return_value_zlist_exists_11=zlist_exists(list, (void *)cheese);
  /* assertion zlist_exists (list, cheese) */
  assert(return_value_zlist_exists_11 != (_Bool)0);
  _Bool return_value_zlist_exists_12;
  return_value_zlist_exists_12=zlist_exists(list, (void *)bread);
  /* assertion zlist_exists (list, bread) */
  assert(return_value_zlist_exists_12 != (_Bool)0);
  _Bool return_value_zlist_exists_13;
  return_value_zlist_exists_13=zlist_exists(list, (void *)wine);
  /* assertion zlist_exists (list, wine) */
  assert(return_value_zlist_exists_13 != (_Bool)0);
  void *return_value_zlist_head_14;
  return_value_zlist_head_14=zlist_head(list);
  /* assertion zlist_head (list) == cheese */
  assert((char *)return_value_zlist_head_14 == cheese);
  void *return_value_zlist_next_15;
  return_value_zlist_next_15=zlist_next(list);
  /* assertion zlist_next (list) == cheese */
  assert((char *)return_value_zlist_next_15 == cheese);
  void *return_value_zlist_first_16;
  return_value_zlist_first_16=zlist_first(list);
  /* assertion zlist_first (list) == cheese */
  assert((char *)return_value_zlist_first_16 == cheese);
  void *return_value_zlist_tail_17;
  return_value_zlist_tail_17=zlist_tail(list);
  /* assertion zlist_tail (list) == wine */
  assert((char *)return_value_zlist_tail_17 == wine);
  void *return_value_zlist_next_18;
  return_value_zlist_next_18=zlist_next(list);
  /* assertion zlist_next (list) == bread */
  assert((char *)return_value_zlist_next_18 == bread);
  void *return_value_zlist_first_19;
  return_value_zlist_first_19=zlist_first(list);
  /* assertion zlist_first (list) == cheese */
  assert((char *)return_value_zlist_first_19 == cheese);
  void *return_value_zlist_next_20;
  return_value_zlist_next_20=zlist_next(list);
  /* assertion zlist_next (list) == bread */
  assert((char *)return_value_zlist_next_20 == bread);
  void *return_value_zlist_next_21;
  return_value_zlist_next_21=zlist_next(list);
  /* assertion zlist_next (list) == wine */
  assert((char *)return_value_zlist_next_21 == wine);
  void *return_value_zlist_next_22;
  return_value_zlist_next_22=zlist_next(list);
  /* assertion zlist_next (list) == ((void *)0) */
  assert(return_value_zlist_next_22 == (void *)0);
  void *return_value_zlist_next_23;
  return_value_zlist_next_23=zlist_next(list);
  /* assertion zlist_next (list) == cheese */
  assert((char *)return_value_zlist_next_23 == cheese);
  unsigned long int return_value_zlist_size_24;
  return_value_zlist_size_24=zlist_size(list);
  /* assertion zlist_size (list) == 3 */
  assert(return_value_zlist_size_24 == (unsigned long int)3);
  zlist_remove(list, (void *)wine);
  unsigned long int return_value_zlist_size_25;
  return_value_zlist_size_25=zlist_size(list);
  /* assertion zlist_size (list) == 2 */
  assert(return_value_zlist_size_25 == (unsigned long int)2);
  void *return_value_zlist_first_26;
  return_value_zlist_first_26=zlist_first(list);
  /* assertion zlist_first (list) == cheese */
  assert((char *)return_value_zlist_first_26 == cheese);
  zlist_remove(list, (void *)cheese);
  unsigned long int return_value_zlist_size_27;
  return_value_zlist_size_27=zlist_size(list);
  /* assertion zlist_size (list) == 1 */
  assert(return_value_zlist_size_27 == (unsigned long int)1);
  void *return_value_zlist_first_28;
  return_value_zlist_first_28=zlist_first(list);
  /* assertion zlist_first (list) == bread */
  assert((char *)return_value_zlist_first_28 == bread);
  zlist_remove(list, (void *)bread);
  unsigned long int return_value_zlist_size_29;
  return_value_zlist_size_29=zlist_size(list);
  /* assertion zlist_size (list) == 0 */
  assert(return_value_zlist_size_29 == (unsigned long int)0);
  zlist_append(list, (void *)cheese);
  zlist_append(list, (void *)bread);
  void *return_value_zlist_last_30;
  return_value_zlist_last_30=zlist_last(list);
  /* assertion zlist_last (list) == bread */
  assert((char *)return_value_zlist_last_30 == bread);
  zlist_remove(list, (void *)bread);
  void *return_value_zlist_last_31;
  return_value_zlist_last_31=zlist_last(list);
  /* assertion zlist_last (list) == cheese */
  assert((char *)return_value_zlist_last_31 == cheese);
  zlist_remove(list, (void *)cheese);
  void *return_value_zlist_last_32;
  return_value_zlist_last_32=zlist_last(list);
  /* assertion zlist_last (list) == ((void *)0) */
  assert(return_value_zlist_last_32 == (void *)0);
  zlist_push(list, (void *)cheese);
  unsigned long int return_value_zlist_size_33;
  return_value_zlist_size_33=zlist_size(list);
  /* assertion zlist_size (list) == 1 */
  assert(return_value_zlist_size_33 == (unsigned long int)1);
  void *return_value_zlist_first_34;
  return_value_zlist_first_34=zlist_first(list);
  /* assertion zlist_first (list) == cheese */
  assert((char *)return_value_zlist_first_34 == cheese);
  zlist_push(list, (void *)bread);
  unsigned long int return_value_zlist_size_35;
  return_value_zlist_size_35=zlist_size(list);
  /* assertion zlist_size (list) == 2 */
  assert(return_value_zlist_size_35 == (unsigned long int)2);
  void *return_value_zlist_first_36;
  return_value_zlist_first_36=zlist_first(list);
  /* assertion zlist_first (list) == bread */
  assert((char *)return_value_zlist_first_36 == bread);
  void *return_value_zlist_item_37;
  return_value_zlist_item_37=zlist_item(list);
  /* assertion zlist_item (list) == bread */
  assert((char *)return_value_zlist_item_37 == bread);
  zlist_append(list, (void *)wine);
  unsigned long int return_value_zlist_size_38;
  return_value_zlist_size_38=zlist_size(list);
  /* assertion zlist_size (list) == 3 */
  assert(return_value_zlist_size_38 == (unsigned long int)3);
  void *return_value_zlist_first_39;
  return_value_zlist_first_39=zlist_first(list);
  /* assertion zlist_first (list) == bread */
  assert((char *)return_value_zlist_first_39 == bread);
  struct _zlist_t *sub_list;
  sub_list=zlist_dup(list);
  /* assertion sub_list */
  assert(sub_list != ((struct _zlist_t *)NULL));
  unsigned long int return_value_zlist_size_40;
  return_value_zlist_size_40=zlist_size(sub_list);
  /* assertion zlist_size (sub_list) == 3 */
  assert(return_value_zlist_size_40 == (unsigned long int)3);
  zlist_sort(list, s_compare);
  char *item;
  void *return_value_zlist_pop_41;
  return_value_zlist_pop_41=zlist_pop(list);
  item = (char *)return_value_zlist_pop_41;
  /* assertion item == bread */
  assert(item == bread);
  void *return_value_zlist_pop_42;
  return_value_zlist_pop_42=zlist_pop(list);
  item = (char *)return_value_zlist_pop_42;
  /* assertion item == wine */
  assert(item == wine);
  void *return_value_zlist_pop_43;
  return_value_zlist_pop_43=zlist_pop(list);
  item = (char *)return_value_zlist_pop_43;
  /* assertion item == cheese */
  assert(item == cheese);
  unsigned long int return_value_zlist_size_44;
  return_value_zlist_size_44=zlist_size(list);
  /* assertion zlist_size (list) == 0 */
  assert(return_value_zlist_size_44 == (unsigned long int)0);
  unsigned long int return_value_zlist_size_45;
  return_value_zlist_size_45=zlist_size(sub_list);
  /* assertion zlist_size (sub_list) == 3 */
  assert(return_value_zlist_size_45 == (unsigned long int)3);
  zlist_push(list, (void *)sub_list);
  struct _zlist_t *sub_list_2;
  sub_list_2=zlist_dup(sub_list);
  zlist_append(list, (void *)sub_list_2);
  void *return_value_zlist_freefn_46;
  return_value_zlist_freefn_46=zlist_freefn(list, (void *)sub_list, s_zlist_free, (_Bool)0);
  /* assertion zlist_freefn (list, sub_list, &s_zlist_free, 0) == sub_list */
  assert((struct _zlist_t *)return_value_zlist_freefn_46 == sub_list);
  void *return_value_zlist_freefn_47;
  return_value_zlist_freefn_47=zlist_freefn(list, (void *)sub_list_2, s_zlist_free, (_Bool)1);
  /* assertion zlist_freefn (list, sub_list_2, &s_zlist_free, 1) == sub_list_2 */
  assert((struct _zlist_t *)return_value_zlist_freefn_47 == sub_list_2);
  zlist_destroy(&list);
  list=zlist_new();
  /* assertion list */
  assert(list != ((struct _zlist_t *)NULL));
  zlist_autofree(list);
  zlist_comparefn(list, s_compare);
  zlist_push(list, (void *)bread);
  zlist_append(list, (void *)cheese);
  unsigned long int return_value_zlist_size_48;
  return_value_zlist_size_48=zlist_size(list);
  /* assertion zlist_size (list) == 2 */
  assert(return_value_zlist_size_48 == (unsigned long int)2);
  zlist_append(list, (void *)wine);
  _Bool return_value_zlist_exists_49;
  return_value_zlist_exists_49=zlist_exists(list, (void *)wine);
  /* assertion zlist_exists (list, wine) */
  assert(return_value_zlist_exists_49 != (_Bool)0);
  zlist_remove(list, (void *)wine);
  _Bool return_value_zlist_exists_50;
  return_value_zlist_exists_50=zlist_exists(list, (void *)wine);
  /* assertion !zlist_exists (list, wine) */
  assert(!(return_value_zlist_exists_50 != (_Bool)0));
  void *return_value_zlist_first_51;
  return_value_zlist_first_51=zlist_first(list);
  signed int return_value_strcmp_52;
  return_value_strcmp_52=strcmp((const char *)return_value_zlist_first_51, bread);
  /* assertion (!strcmp (((const char *) zlist_first (list)), (bread))) */
  assert(!(return_value_strcmp_52 != 0));
  void *return_value_zlist_pop_53;
  return_value_zlist_pop_53=zlist_pop(list);
  item = (char *)return_value_zlist_pop_53;
  signed int return_value_strcmp_54;
  return_value_strcmp_54=strcmp(item, bread);
  /* assertion (!strcmp ((item), (bread))) */
  assert(!(return_value_strcmp_54 != 0));
  free((void *)item);
  void *return_value_zlist_pop_55;
  return_value_zlist_pop_55=zlist_pop(list);
  item = (char *)return_value_zlist_pop_55;
  signed int return_value_strcmp_56;
  return_value_strcmp_56=strcmp(item, cheese);
  /* assertion (!strcmp ((item), (cheese))) */
  assert(!(return_value_strcmp_56 != 0));
  free((void *)item);
  zlist_destroy(&list);
  /* assertion list == ((void *)0) */
  assert(list == (struct _zlist_t *)(void *)0);
  printf("OK\n");
}

// zlistx_add_end
// file src/../include/zlistx.h line 42
void * zlistx_add_end(struct _zlistx_t *self, void *item)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  /* assertion item */
  assert(item != NULL);
  if(!(self->duplicator == ((void * (*)(const void *))NULL)))
  {
    item=self->duplicator(item);
    return (void *)0;
  }

  else
  {
    struct _node_t *node;
    node=s_node_new(item);
    if(!(node == ((struct _node_t *)NULL)))
    {
      s_node_relink(node, self->head->prev, self->head);
      self->cursor = self->head;
      self->size = self->size + 1ul;
      return (void *)node;
    }

    else
      return (void *)0;
  }
}

// zlistx_add_start
// file src/zlistx.c line 150
void * zlistx_add_start(struct _zlistx_t *self, void *item)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  /* assertion item */
  assert(item != NULL);
  if(!(self->duplicator == ((void * (*)(const void *))NULL)))
  {
    item=self->duplicator(item);
    return (void *)0;
  }

  else
  {
    struct _node_t *node;
    node=s_node_new(item);
    if(!(node == ((struct _node_t *)NULL)))
    {
      s_node_relink(node, self->head, self->head->next);
      self->cursor = self->head;
      self->size = self->size + 1ul;
      return (void *)node;
    }

    else
      return (void *)0;
  }
}

// zlistx_cursor
// file src/zlistx.c line 284
void * zlistx_cursor(struct _zlistx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  struct _node_t *tmp_if_expr_1;
  if(self->cursor == self->head)
    tmp_if_expr_1 = (struct _node_t *)(void *)0;

  else
    tmp_if_expr_1 = self->cursor;
  return (void *)tmp_if_expr_1;
}

// zlistx_delete
// file src/zlistx.c line 387
signed int zlistx_delete(struct _zlistx_t *self, void *handle)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  void *item;
  item=zlistx_detach(self, handle);
  if(!(item == NULL))
  {
    if(!(self->destructor == ((void (*)(void **))NULL)))
      self->destructor(&item);

    return 0;
  }

  else
    return -1;
}

// zlistx_destroy
// file src/../include/zlistx.h line 30
void zlistx_destroy(struct _zlistx_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zlistx_t **)NULL));
  if(!(*self_p == ((struct _zlistx_t *)NULL)))
  {
    struct _zlistx_t *self = *self_p;
    zlistx_purge(self);
    free((void *)self->head);
    free((void *)self);
    *self_p = (struct _zlistx_t *)(void *)0;
  }

}

// zlistx_detach
// file src/zlistx.c line 338
void * zlistx_detach(struct _zlistx_t *self, void *handle)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  struct _node_t *node = (struct _node_t *)handle;
  if(node == ((struct _node_t *)NULL))
  {
    struct _node_t *tmp_if_expr_1;
    if(self->head->next == self->head)
      tmp_if_expr_1 = (struct _node_t *)(void *)0;

    else
      tmp_if_expr_1 = self->head->next;
    node = tmp_if_expr_1;
  }

  if(!(node == ((struct _node_t *)NULL)))
  {
    if(self->cursor == node)
      self->cursor = self->cursor->prev;

    /* assertion node->tag == 0x0006cafe */
    assert(node->tag == (unsigned int)0x0006cafe);
    s_node_relink(node, node->prev, node->next);
    node->tag = 0xDeadBeef;
    void *item = node->item;
    free((void *)node);
    self->size = self->size - 1ul;
    return item;
  }

  else
  {
    /* assertion self->size == 0 */
    assert(self->size == (unsigned long int)0);
    return (void *)0;
  }
}

// zlistx_detach_cur
// file src/zlistx.c line 373
void * zlistx_detach_cur(struct _zlistx_t *self)
{
  void *return_value_zlistx_cursor_1;
  return_value_zlistx_cursor_1=zlistx_cursor(self);
  void *return_value_zlistx_detach_2;
  return_value_zlistx_detach_2=zlistx_detach(self, return_value_zlistx_cursor_1);
  return return_value_zlistx_detach_2;
}

// zlistx_dup
// file src/zlistx.c line 567
struct _zlistx_t * zlistx_dup(struct _zlistx_t *self)
{
  if(self == ((struct _zlistx_t *)NULL))
    return (struct _zlistx_t *)(void *)0;

  else
  {
    struct _zlistx_t *copy;
    copy=zlistx_new();
    if(!(copy == ((struct _zlistx_t *)NULL)))
    {
      copy->destructor = self->destructor;
      copy->duplicator = self->duplicator;
      copy->comparator = self->comparator;
      struct _node_t *node = self->head->next;
      for( ; !(node == self->head); node = node->next)
      {
        void *return_value_zlistx_add_end_1;
        return_value_zlistx_add_end_1=zlistx_add_end(copy, node->item);
        if(return_value_zlistx_add_end_1 == NULL)
        {
          zlistx_destroy(&copy);
          break;
        }

      }
    }

    return copy;
  }
}

// zlistx_find
// file src/zlistx.c line 312
void * zlistx_find(struct _zlistx_t *self, void *item)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  /* assertion item */
  assert(item != NULL);
  struct _node_t *node = self->head->next;
  if(!(node == self->head))
  {
    signed int return_value;
    return_value=self->comparator(node->item, item);
    if(return_value == 0)
    {
      self->cursor = node;
      return (void *)node;
    }

    node = node->next;
  }

  return (void *)0;
}

// zlistx_first
// file src/../include/zlistx.h line 51
void * zlistx_first(struct _zlistx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  self->cursor = self->head->next;
  void *tmp_if_expr_1;
  if(self->cursor == self->head)
    tmp_if_expr_1 = (void *)0;

  else
    tmp_if_expr_1 = self->cursor->item;
  return tmp_if_expr_1;
}

// zlistx_handle_item
// file src/zlistx.c line 295
void * zlistx_handle_item(void *handle)
{
  if(handle == NULL)
    return (void *)0;

  else
  {
    struct _node_t *node = (struct _node_t *)handle;
    /* assertion node->tag == 0x0006cafe */
    assert(node->tag == (unsigned int)0x0006cafe);
    return node->item;
  }
}

// zlistx_insert
// file src/zlistx.c line 503
void * zlistx_insert(struct _zlistx_t *self, void *item, _Bool low_value)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  if(!(self->duplicator == ((void * (*)(const void *))NULL)))
  {
    item=self->duplicator(item);
    return (void *)0;
  }

  else
  {
    struct _node_t *node;
    node=s_node_new(item);
    if(!(node == ((struct _node_t *)NULL)))
    {
      zlistx_reorder(self, (void *)node, low_value);
      self->cursor = self->head;
      self->size = self->size + 1ul;
    }

    return (void *)node;
  }
}

// zlistx_item
// file src/../include/zlistx.h line 73
void * zlistx_item(struct _zlistx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  void *tmp_if_expr_1;
  if(self->cursor == self->head)
    tmp_if_expr_1 = (void *)0;

  else
    tmp_if_expr_1 = self->cursor->item;
  return tmp_if_expr_1;
}

// zlistx_last
// file src/zlistx.c line 259
void * zlistx_last(struct _zlistx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  self->cursor = self->head->prev;
  void *tmp_if_expr_1;
  if(self->cursor == self->head)
    tmp_if_expr_1 = (void *)0;

  else
    tmp_if_expr_1 = self->cursor->item;
  return tmp_if_expr_1;
}

// zlistx_move_end
// file src/zlistx.c line 425
void zlistx_move_end(struct _zlistx_t *self, void *handle)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  /* assertion handle */
  assert(handle != NULL);
  struct _node_t *node = (struct _node_t *)handle;
  /* assertion node->tag == 0x0006cafe */
  assert(node->tag == (unsigned int)0x0006cafe);
  struct _node_t *prev = self->head->prev;
  if(!(node == prev))
  {
    s_node_relink(node, node->prev, node->next);
    s_node_relink(node, prev, prev->next);
  }

}

// zlistx_move_start
// file src/zlistx.c line 405
void zlistx_move_start(struct _zlistx_t *self, void *handle)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  /* assertion handle */
  assert(handle != NULL);
  struct _node_t *node = (struct _node_t *)handle;
  /* assertion node->tag == 0x0006cafe */
  assert(node->tag == (unsigned int)0x0006cafe);
  struct _node_t *next = self->head->next;
  if(!(node == next))
  {
    s_node_relink(node, node->prev, node->next);
    s_node_relink(node, next->prev, next);
  }

}

// zlistx_new
// file src/../include/zlistx.h line 25
struct _zlistx_t * zlistx_new(void)
{
  struct _zlistx_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link16(sizeof(struct _zlistx_t) /*56ul*/ , "src/zlistx.c", (unsigned int)111);
  self = (struct _zlistx_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _zlistx_t *)NULL)))
  {
    self->head=s_node_new((void *)0);
    if(!(self->head == ((struct _node_t *)NULL)))
    {
      self->cursor = self->head;
      self->comparator = s_comparator;
    }

    else
      zlistx_destroy(&self);
  }

  return self;
}

// zlistx_next
// file src/../include/zlistx.h line 57
void * zlistx_next(struct _zlistx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  self->cursor = self->cursor->next;
  void *tmp_if_expr_1;
  if(self->cursor == self->head)
    tmp_if_expr_1 = (void *)0;

  else
    tmp_if_expr_1 = self->cursor->item;
  return tmp_if_expr_1;
}

// zlistx_prev
// file src/zlistx.c line 246
void * zlistx_prev(struct _zlistx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  self->cursor = self->cursor->prev;
  void *tmp_if_expr_1;
  if(self->cursor == self->head)
    tmp_if_expr_1 = (void *)0;

  else
    tmp_if_expr_1 = self->cursor->item;
  return tmp_if_expr_1;
}

// zlistx_purge
// file src/../include/zlistx.h line 125
void zlistx_purge(struct _zlistx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  unsigned long int return_value_zlistx_size_1;
  do
  {
    return_value_zlistx_size_1=zlistx_size(self);
    if(!(return_value_zlistx_size_1 >= 1ul))
      break;

    zlistx_delete(self, (void *)0);
  }
  while((_Bool)1);
}

// zlistx_reorder
// file src/zlistx.c line 528
void zlistx_reorder(struct _zlistx_t *self, void *handle, _Bool low_value)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  /* assertion handle */
  assert(handle != NULL);
  struct _node_t *node = (struct _node_t *)handle;
  /* assertion node->tag == 0x0006cafe */
  assert(node->tag == (unsigned int)0x0006cafe);
  s_node_relink(node, node->prev, node->next);
  if(!(low_value == (_Bool)0))
  {
    struct _node_t *next = self->head->next;
    if(!(next == self->head))
    {
      signed int return_value;
      return_value=self->comparator(node->item, next->item);
      if(return_value >= 1)
        next = next->next;

    }

    s_node_relink(node, next->prev, next);
  }

  else
  {
    struct _node_t *prev = self->head->prev;
    if(!(prev == self->head))
    {
      signed int return_value_1;
      return_value_1=self->comparator(prev->item, node->item);
      if(return_value_1 >= 1)
        prev = prev->prev;

    }

    s_node_relink(node, prev, prev->next);
  }
}

// zlistx_set_comparator
// file src/zlistx.c line 622
void zlistx_set_comparator(struct _zlistx_t *self, signed int (*comparator)(const void *, const void *))
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  self->comparator = comparator;
}

// zlistx_set_destructor
// file src/../include/zlistx.h line 158
void zlistx_set_destructor(struct _zlistx_t *self, void (*destructor)(void **))
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  self->destructor = destructor;
}

// zlistx_set_duplicator
// file src/../include/zlistx.h line 163
void zlistx_set_duplicator(struct _zlistx_t *self, void * (*duplicator)(const void *))
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  self->duplicator = duplicator;
}

// zlistx_size
// file src/../include/zlistx.h line 46
unsigned long int zlistx_size(struct _zlistx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  return self->size;
}

// zlistx_sort
// file src/zlistx.c line 460
void zlistx_sort(struct _zlistx_t *self)
{
  /* assertion self */
  assert(self != ((struct _zlistx_t *)NULL));
  unsigned long int gap = self->size;
  _Bool swapped = (_Bool)0;
  unsigned long int tmp_post_1;
  while(gap >= 2ul || !(swapped == (_Bool)0))
  {
    gap = (unsigned long int)((double)gap / 1.3);
    struct _node_t *base = self->head->next;
    struct _node_t *test = self->head->next;
    unsigned long int jump = gap;
    do
    {
      tmp_post_1 = jump;
      jump = jump - 1ul;
      if(tmp_post_1 == 0ul)
        break;

      test = test->next;
    }
    while((_Bool)1);
    swapped = (_Bool)0;
    if(!(base == self->head))
    {
      if(!(test == self->head))
      {
        signed int return_value;
        return_value=self->comparator(base->item, test->item);
        if(return_value >= 1)
        {
          void *item = base->item;
          base->item = test->item;
          test->item = item;
          swapped = (_Bool)1;
        }

        base = base->next;
        test = test->next;
      }

    }

  }
}

// zlistx_test
// file src/zlistx.c line 633
void zlistx_test(signed int verbose)
{
  printf(" * zlistx: ");
  struct _zlistx_t *list;
  list=zlistx_new();
  /* assertion list */
  assert(list != ((struct _zlistx_t *)NULL));
  unsigned long int return_value_zlistx_size_1;
  return_value_zlistx_size_1=zlistx_size(list);
  /* assertion zlistx_size (list) == 0 */
  assert(return_value_zlistx_size_1 == (unsigned long int)0);
  void *return_value_zlistx_first_2;
  return_value_zlistx_first_2=zlistx_first(list);
  /* assertion zlistx_first (list) == ((void *)0) */
  assert(return_value_zlistx_first_2 == (void *)0);
  void *return_value_zlistx_last_3;
  return_value_zlistx_last_3=zlistx_last(list);
  /* assertion zlistx_last (list) == ((void *)0) */
  assert(return_value_zlistx_last_3 == (void *)0);
  void *return_value_zlistx_next_4;
  return_value_zlistx_next_4=zlistx_next(list);
  /* assertion zlistx_next (list) == ((void *)0) */
  assert(return_value_zlistx_next_4 == (void *)0);
  void *return_value_zlistx_prev_5;
  return_value_zlistx_prev_5=zlistx_prev(list);
  /* assertion zlistx_prev (list) == ((void *)0) */
  assert(return_value_zlistx_prev_5 == (void *)0);
  void *return_value_zlistx_find_6;
  return_value_zlistx_find_6=zlistx_find(list, (void *)"hello");
  /* assertion zlistx_find (list, "hello") == ((void *)0) */
  assert(return_value_zlistx_find_6 == (void *)0);
  signed int return_value_zlistx_delete_7;
  return_value_zlistx_delete_7=zlistx_delete(list, (void *)0);
  /* assertion zlistx_delete (list, ((void *)0)) == -1 */
  assert(return_value_zlistx_delete_7 == -1);
  void *return_value_zlistx_detach_8;
  return_value_zlistx_detach_8=zlistx_detach(list, (void *)0);
  /* assertion zlistx_detach (list, ((void *)0)) == ((void *)0) */
  assert(return_value_zlistx_detach_8 == (void *)0);
  signed int return_value_zlistx_delete_9;
  return_value_zlistx_delete_9=zlistx_delete(list, (void *)0);
  /* assertion zlistx_delete (list, ((void *)0)) == -1 */
  assert(return_value_zlistx_delete_9 == -1);
  void *return_value_zlistx_detach_10;
  return_value_zlistx_detach_10=zlistx_detach(list, (void *)0);
  /* assertion zlistx_detach (list, ((void *)0)) == ((void *)0) */
  assert(return_value_zlistx_detach_10 == (void *)0);
  zlistx_purge(list);
  zlistx_sort(list);
  zlistx_set_destructor(list, (void (*)(void **))zstr_free);
  zlistx_set_duplicator(list, (void * (*)(const void *))strdup);
  zlistx_set_comparator(list, (signed int (*)(const void *, const void *))strcmp);
  void *return_value_zlistx_next_11;
  return_value_zlistx_next_11=zlistx_next(list);
  /* assertion zlistx_next (list) == ((void *)0) */
  assert(return_value_zlistx_next_11 == (void *)0);
  zlistx_add_end(list, (void *)"world");
  void *return_value_zlistx_next_12;
  return_value_zlistx_next_12=zlistx_next(list);
  signed int return_value_strcmp_13;
  return_value_strcmp_13=strcmp((char *)return_value_zlistx_next_12, "world");
  /* assertion (!strcmp (((char *) zlistx_next (list)), ("world"))) */
  assert(!(return_value_strcmp_13 != 0));
  zlistx_add_end(list, (void *)"hello");
  void *return_value_zlistx_prev_14;
  return_value_zlistx_prev_14=zlistx_prev(list);
  signed int return_value_strcmp_15;
  return_value_strcmp_15=strcmp((char *)return_value_zlistx_prev_14, "hello");
  /* assertion (!strcmp (((char *) zlistx_prev (list)), ("hello"))) */
  assert(!(return_value_strcmp_15 != 0));
  zlistx_sort(list);
  unsigned long int return_value_zlistx_size_16;
  return_value_zlistx_size_16=zlistx_size(list);
  /* assertion zlistx_size (list) == 2 */
  assert(return_value_zlistx_size_16 == (unsigned long int)2);
  void *handle;
  handle=zlistx_find(list, (void *)"hello");
  char *item1;
  void *return_value_zlistx_item_17;
  return_value_zlistx_item_17=zlistx_item(list);
  item1 = (char *)return_value_zlistx_item_17;
  char *item2;
  void *return_value_zlistx_handle_item_18;
  return_value_zlistx_handle_item_18=zlistx_handle_item(handle);
  item2 = (char *)return_value_zlistx_handle_item_18;
  /* assertion item1 == item2 */
  assert(item1 == item2);
  signed int return_value_strcmp_19;
  return_value_strcmp_19=strcmp(item1, "hello");
  /* assertion (!strcmp ((item1), ("hello"))) */
  assert(!(return_value_strcmp_19 != 0));
  zlistx_delete(list, handle);
  unsigned long int return_value_zlistx_size_20;
  return_value_zlistx_size_20=zlistx_size(list);
  /* assertion zlistx_size (list) == 1 */
  assert(return_value_zlistx_size_20 == (unsigned long int)1);
  char *string;
  void *return_value_zlistx_detach_21;
  return_value_zlistx_detach_21=zlistx_detach(list, (void *)0);
  string = (char *)return_value_zlistx_detach_21;
  signed int return_value_strcmp_22;
  return_value_strcmp_22=strcmp(string, "world");
  /* assertion (!strcmp ((string), ("world"))) */
  assert(!(return_value_strcmp_22 != 0));
  free((void *)string);
  unsigned long int return_value_zlistx_size_23;
  return_value_zlistx_size_23=zlistx_size(list);
  /* assertion zlistx_size (list) == 0 */
  assert(return_value_zlistx_size_23 == (unsigned long int)0);
  zlistx_add_start(list, (void *)"five");
  zlistx_add_end(list, (void *)"six");
  zlistx_add_start(list, (void *)"four");
  zlistx_add_end(list, (void *)"seven");
  zlistx_add_start(list, (void *)"three");
  zlistx_add_end(list, (void *)"eight");
  zlistx_add_start(list, (void *)"two");
  zlistx_add_end(list, (void *)"nine");
  zlistx_add_start(list, (void *)"one");
  zlistx_add_end(list, (void *)"ten");
  unsigned long int return_value_zlistx_size_24;
  return_value_zlistx_size_24=zlistx_size(list);
  /* assertion zlistx_size (list) == 10 */
  assert(return_value_zlistx_size_24 == (unsigned long int)10);
  void *return_value_zlistx_last_25;
  return_value_zlistx_last_25=zlistx_last(list);
  signed int return_value_strcmp_26;
  return_value_strcmp_26=strcmp((char *)return_value_zlistx_last_25, "ten");
  /* assertion (!strcmp (((char *) zlistx_last (list)), ("ten"))) */
  assert(!(return_value_strcmp_26 != 0));
  void *return_value_zlistx_prev_27;
  return_value_zlistx_prev_27=zlistx_prev(list);
  signed int return_value_strcmp_28;
  return_value_strcmp_28=strcmp((char *)return_value_zlistx_prev_27, "nine");
  /* assertion (!strcmp (((char *) zlistx_prev (list)), ("nine"))) */
  assert(!(return_value_strcmp_28 != 0));
  void *return_value_zlistx_prev_29;
  return_value_zlistx_prev_29=zlistx_prev(list);
  signed int return_value_strcmp_30;
  return_value_strcmp_30=strcmp((char *)return_value_zlistx_prev_29, "eight");
  /* assertion (!strcmp (((char *) zlistx_prev (list)), ("eight"))) */
  assert(!(return_value_strcmp_30 != 0));
  void *return_value_zlistx_prev_31;
  return_value_zlistx_prev_31=zlistx_prev(list);
  signed int return_value_strcmp_32;
  return_value_strcmp_32=strcmp((char *)return_value_zlistx_prev_31, "seven");
  /* assertion (!strcmp (((char *) zlistx_prev (list)), ("seven"))) */
  assert(!(return_value_strcmp_32 != 0));
  void *return_value_zlistx_prev_33;
  return_value_zlistx_prev_33=zlistx_prev(list);
  signed int return_value_strcmp_34;
  return_value_strcmp_34=strcmp((char *)return_value_zlistx_prev_33, "six");
  /* assertion (!strcmp (((char *) zlistx_prev (list)), ("six"))) */
  assert(!(return_value_strcmp_34 != 0));
  void *return_value_zlistx_prev_35;
  return_value_zlistx_prev_35=zlistx_prev(list);
  signed int return_value_strcmp_36;
  return_value_strcmp_36=strcmp((char *)return_value_zlistx_prev_35, "five");
  /* assertion (!strcmp (((char *) zlistx_prev (list)), ("five"))) */
  assert(!(return_value_strcmp_36 != 0));
  void *return_value_zlistx_first_37;
  return_value_zlistx_first_37=zlistx_first(list);
  signed int return_value_strcmp_38;
  return_value_strcmp_38=strcmp((char *)return_value_zlistx_first_37, "one");
  /* assertion (!strcmp (((char *) zlistx_first (list)), ("one"))) */
  assert(!(return_value_strcmp_38 != 0));
  void *return_value_zlistx_next_39;
  return_value_zlistx_next_39=zlistx_next(list);
  signed int return_value_strcmp_40;
  return_value_strcmp_40=strcmp((char *)return_value_zlistx_next_39, "two");
  /* assertion (!strcmp (((char *) zlistx_next (list)), ("two"))) */
  assert(!(return_value_strcmp_40 != 0));
  void *return_value_zlistx_next_41;
  return_value_zlistx_next_41=zlistx_next(list);
  signed int return_value_strcmp_42;
  return_value_strcmp_42=strcmp((char *)return_value_zlistx_next_41, "three");
  /* assertion (!strcmp (((char *) zlistx_next (list)), ("three"))) */
  assert(!(return_value_strcmp_42 != 0));
  void *return_value_zlistx_next_43;
  return_value_zlistx_next_43=zlistx_next(list);
  signed int return_value_strcmp_44;
  return_value_strcmp_44=strcmp((char *)return_value_zlistx_next_43, "four");
  /* assertion (!strcmp (((char *) zlistx_next (list)), ("four"))) */
  assert(!(return_value_strcmp_44 != 0));
  zlistx_sort(list);
  void *return_value_zlistx_first_45;
  return_value_zlistx_first_45=zlistx_first(list);
  signed int return_value_strcmp_46;
  return_value_strcmp_46=strcmp((char *)return_value_zlistx_first_45, "eight");
  /* assertion (!strcmp (((char *) zlistx_first (list)), ("eight"))) */
  assert(!(return_value_strcmp_46 != 0));
  void *return_value_zlistx_last_47;
  return_value_zlistx_last_47=zlistx_last(list);
  signed int return_value_strcmp_48;
  return_value_strcmp_48=strcmp((char *)return_value_zlistx_last_47, "two");
  /* assertion (!strcmp (((char *) zlistx_last (list)), ("two"))) */
  assert(!(return_value_strcmp_48 != 0));
  handle=zlistx_find(list, (void *)"six");
  zlistx_move_start(list, handle);
  void *return_value_zlistx_first_49;
  return_value_zlistx_first_49=zlistx_first(list);
  signed int return_value_strcmp_50;
  return_value_strcmp_50=strcmp((char *)return_value_zlistx_first_49, "six");
  /* assertion (!strcmp (((char *) zlistx_first (list)), ("six"))) */
  assert(!(return_value_strcmp_50 != 0));
  zlistx_move_end(list, handle);
  void *return_value_zlistx_last_51;
  return_value_zlistx_last_51=zlistx_last(list);
  signed int return_value_strcmp_52;
  return_value_strcmp_52=strcmp((char *)return_value_zlistx_last_51, "six");
  /* assertion (!strcmp (((char *) zlistx_last (list)), ("six"))) */
  assert(!(return_value_strcmp_52 != 0));
  zlistx_sort(list);
  void *return_value_zlistx_last_53;
  return_value_zlistx_last_53=zlistx_last(list);
  signed int return_value_strcmp_54;
  return_value_strcmp_54=strcmp((char *)return_value_zlistx_last_53, "two");
  /* assertion (!strcmp (((char *) zlistx_last (list)), ("two"))) */
  assert(!(return_value_strcmp_54 != 0));
  struct _zlistx_t *copy;
  copy=zlistx_dup(list);
  /* assertion copy */
  assert(copy != ((struct _zlistx_t *)NULL));
  unsigned long int return_value_zlistx_size_55;
  return_value_zlistx_size_55=zlistx_size(copy);
  /* assertion zlistx_size (copy) == 10 */
  assert(return_value_zlistx_size_55 == (unsigned long int)10);
  void *return_value_zlistx_first_56;
  return_value_zlistx_first_56=zlistx_first(copy);
  signed int return_value_strcmp_57;
  return_value_strcmp_57=strcmp((char *)return_value_zlistx_first_56, "eight");
  /* assertion (!strcmp (((char *) zlistx_first (copy)), ("eight"))) */
  assert(!(return_value_strcmp_57 != 0));
  void *return_value_zlistx_last_58;
  return_value_zlistx_last_58=zlistx_last(copy);
  signed int return_value_strcmp_59;
  return_value_strcmp_59=strcmp((char *)return_value_zlistx_last_58, "two");
  /* assertion (!strcmp (((char *) zlistx_last (copy)), ("two"))) */
  assert(!(return_value_strcmp_59 != 0));
  zlistx_destroy(&copy);
  void *return_value_zlistx_first_60;
  return_value_zlistx_first_60=zlistx_first(list);
  string = (char *)return_value_zlistx_first_60;
  signed int return_value_strcmp_61;
  return_value_strcmp_61=strcmp(string, "eight");
  /* assertion (!strcmp ((string), ("eight"))) */
  assert(!(return_value_strcmp_61 != 0));
  void *return_value_zlistx_next_62;
  return_value_zlistx_next_62=zlistx_next(list);
  string = (char *)return_value_zlistx_next_62;
  signed int return_value_strcmp_63;
  return_value_strcmp_63=strcmp(string, "five");
  /* assertion (!strcmp ((string), ("five"))) */
  assert(!(return_value_strcmp_63 != 0));
  void *return_value_zlistx_cursor_64;
  return_value_zlistx_cursor_64=zlistx_cursor(list);
  zlistx_delete(list, return_value_zlistx_cursor_64);
  void *return_value_zlistx_next_65;
  return_value_zlistx_next_65=zlistx_next(list);
  string = (char *)return_value_zlistx_next_65;
  signed int return_value_strcmp_66;
  return_value_strcmp_66=strcmp(string, "four");
  /* assertion (!strcmp ((string), ("four"))) */
  assert(!(return_value_strcmp_66 != 0));
  zlistx_purge(list);
  zlistx_destroy(&list);
  printf("OK\n");
}

// zloop_destroy
// file src/../include/zloop.h line 42
void zloop_destroy(struct _zloop_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zloop_t **)NULL));
  void *return_value_zlistx_first_1;
  if(!(*self_p == ((struct _zloop_t *)NULL)))
  {
    struct _zloop_t *self = *self_p;
    do
    {
      return_value_zlistx_first_1=zlistx_first(self->zombies);
      if(return_value_zlistx_first_1 == NULL)
        break;

      signed long int timer_id;
      void *return_value_zlistx_detach_2;
      return_value_zlistx_detach_2=zlistx_detach(self->zombies, (void *)0);
      timer_id = (unsigned char *)return_value_zlistx_detach_2 - (unsigned char *)(void *)0;
      s_timer_remove(self, (signed int)timer_id);
    }
    while((_Bool)1);
    zlistx_destroy(&self->zombies);
    zlistx_destroy(&self->readers);
    zlistx_destroy(&self->pollers);
    zlistx_destroy(&self->timers);
    zlistx_destroy(&self->tickets);
    free((void *)self->pollset);
    free((void *)self->readact);
    free((void *)self->pollact);
    free((void *)self);
    *self_p = (struct _zloop_t *)(void *)0;
  }

}

// zloop_ignore_interrupts
// file src/zloop.c line 705
void zloop_ignore_interrupts(struct _zloop_t *self)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  self->ignore_interrupts = (_Bool)1;
}

// zloop_new
// file src/../include/zloop.h line 38
struct _zloop_t * zloop_new(void)
{
  struct _zloop_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link17(sizeof(struct _zloop_t) /*104ul*/ , "src/zloop.c", (unsigned int)329);
  self = (struct _zloop_t *)return_value_safe_malloc_1;
  if(self == ((struct _zloop_t *)NULL))
    return (struct _zloop_t *)(void *)0;

  else
  {
    self->readers=zlistx_new();
    if(!(self->readers == ((struct _zlistx_t *)NULL)))
      self->pollers=zlistx_new();

    if(!(self->pollers == ((struct _zlistx_t *)NULL)))
      self->timers=zlistx_new();

    if(!(self->timers == ((struct _zlistx_t *)NULL)))
      self->zombies=zlistx_new();

    if(!(self->zombies == ((struct _zlistx_t *)NULL)))
      self->tickets=zlistx_new();

    if(!(self->tickets == ((struct _zlistx_t *)NULL)))
    {
      self->last_timer_id = 0;
      zlistx_set_destructor(self->readers, (void (*)(void **))s_reader_destroy);
      zlistx_set_destructor(self->pollers, (void (*)(void **))s_poller_destroy);
      zlistx_set_destructor(self->timers, (void (*)(void **))s_timer_destroy);
      zlistx_set_comparator(self->timers, (signed int (*)(const void *, const void *))s_timer_comparator);
      zlistx_set_destructor(self->tickets, (void (*)(void **))s_ticket_destroy);
      zlistx_set_comparator(self->tickets, (signed int (*)(const void *, const void *))s_ticket_comparator);
    }

    else
      zloop_destroy(&self);
    return self;
  }
}

// zloop_poller
// file src/zloop.c line 467
signed int zloop_poller(struct _zloop_t *self, struct zmq_pollitem_t *item, signed int (*handler)(struct _zloop_t *, struct zmq_pollitem_t *, void *), void *arg)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  signed int return_value_zsock_type_1;
  char *return_value_zsys_sockname_2;
  signed int return_value_strcmp_3;
  if(!(item->socket == NULL))
  {
    return_value_zsock_type_1=zsock_type(item->socket);
    return_value_zsys_sockname_2=zsys_sockname(return_value_zsock_type_1);
    return_value_strcmp_3=strcmp(return_value_zsys_sockname_2, "UNKNOWN");
    if(return_value_strcmp_3 == 0)
      return -1;

  }

  struct _s_poller_t *poller;
  poller=s_poller_new(item, handler, arg);
  signed int return_value_zsock_type_4;
  char *return_value_zsys_sockname_5;
  if(!(poller == ((struct _s_poller_t *)NULL)))
  {
    poller->list_handle=zlistx_add_end(self->pollers, (void *)poller);
    if(poller->list_handle == NULL)
    {
      s_poller_destroy(&poller);
      return -1;
    }

    self->need_rebuild = (_Bool)1;
    if(!(self->verbose == (_Bool)0))
    {
      char *tmp_if_expr_6;
      if(!(item->socket == NULL))
      {
        return_value_zsock_type_4=zsock_type(item->socket);
        return_value_zsys_sockname_5=zsys_sockname(return_value_zsock_type_4);
        tmp_if_expr_6 = return_value_zsys_sockname_5;
      }

      else
        tmp_if_expr_6 = "FD";
      zsys_debug("zloop: register %s poller (%p, %d)", tmp_if_expr_6, item->socket, item->fd);
    }

    return 0;
  }

  else
    return -1;
}

// zloop_poller_end
// file src/zloop.c line 500
void zloop_poller_end(struct _zloop_t *self, struct zmq_pollitem_t *item)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  struct _s_poller_t *poller;
  void *return_value_zlistx_first_1;
  return_value_zlistx_first_1=zlistx_first(self->pollers);
  poller = (struct _s_poller_t *)return_value_zlistx_first_1;
  while(!(poller == ((struct _s_poller_t *)NULL)))
  {
    _Bool zloop_poller_end__1__1__match = (_Bool)0;
    if(!(item->socket == NULL))
    {
      if(item->socket == poller->item.socket)
        zloop_poller_end__1__1__match = (_Bool)1;

    }

    else
      if(item->fd == poller->item.fd)
        zloop_poller_end__1__1__match = (_Bool)1;

    if(!(zloop_poller_end__1__1__match == (_Bool)0))
    {
      zlistx_delete(self->pollers, poller->list_handle);
      self->need_rebuild = (_Bool)1;
    }

    void *return_value_zlistx_next_2;
    return_value_zlistx_next_2=zlistx_next(self->pollers);
    poller = (struct _s_poller_t *)return_value_zlistx_next_2;
  }
  signed int return_value_zsock_type_3;
  char *return_value_zsys_sockname_4;
  if(!(self->verbose == (_Bool)0))
  {
    char *tmp_if_expr_5;
    if(!(item->socket == NULL))
    {
      return_value_zsock_type_3=zsock_type(item->socket);
      return_value_zsys_sockname_4=zsys_sockname(return_value_zsock_type_3);
      tmp_if_expr_5 = return_value_zsys_sockname_4;
    }

    else
      tmp_if_expr_5 = "FD";
    zsys_debug("zloop: cancel %s poller (%p, %d)", tmp_if_expr_5, item->socket, item->fd);
  }

}

// zloop_poller_set_tolerant
// file src/zloop.c line 534
void zloop_poller_set_tolerant(struct _zloop_t *self, struct zmq_pollitem_t *item)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  struct _s_poller_t *poller;
  void *return_value_zlistx_first_1;
  return_value_zlistx_first_1=zlistx_first(self->pollers);
  poller = (struct _s_poller_t *)return_value_zlistx_first_1;
  while(!(poller == ((struct _s_poller_t *)NULL)))
  {
    _Bool zloop_poller_set_tolerant__1__1__match = (_Bool)0;
    if(!(item->socket == NULL))
    {
      if(item->socket == poller->item.socket)
        zloop_poller_set_tolerant__1__1__match = (_Bool)1;

    }

    else
      if(item->fd == poller->item.fd)
        zloop_poller_set_tolerant__1__1__match = (_Bool)1;

    if(!(zloop_poller_set_tolerant__1__1__match == (_Bool)0))
      poller->tolerant = (_Bool)1;

    void *return_value_zlistx_next_2;
    return_value_zlistx_next_2=zlistx_next(self->pollers);
    poller = (struct _s_poller_t *)return_value_zlistx_next_2;
  }
}

// zloop_reader
// file src/../include/zloop.h line 49
signed int zloop_reader(struct _zloop_t *self, struct _zsock_t *sock, signed int (*handler)(struct _zloop_t *, struct _zsock_t *, void *), void *arg)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  /* assertion sock */
  assert(sock != ((struct _zsock_t *)NULL));
  struct _s_reader_t *reader;
  reader=s_reader_new(sock, handler, arg);
  const char *return_value_zsock_type_str_1;
  if(!(reader == ((struct _s_reader_t *)NULL)))
  {
    reader->list_handle=zlistx_add_end(self->readers, (void *)reader);
    if(reader->list_handle == NULL)
    {
      s_reader_destroy(&reader);
      return -1;
    }

    self->need_rebuild = (_Bool)1;
    if(!(self->verbose == (_Bool)0))
    {
      return_value_zsock_type_str_1=zsock_type_str(sock);
      zsys_debug("zloop: register %s reader", return_value_zsock_type_str_1);
    }

    return 0;
  }

  else
    return -1;
}

// zloop_reader_end
// file src/../include/zloop.h line 54
void zloop_reader_end(struct _zloop_t *self, struct _zsock_t *sock)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  /* assertion sock */
  assert(sock != ((struct _zsock_t *)NULL));
  struct _s_reader_t *reader;
  void *return_value_zlistx_first_1;
  return_value_zlistx_first_1=zlistx_first(self->readers);
  reader = (struct _s_reader_t *)return_value_zlistx_first_1;
  while(!(reader == ((struct _s_reader_t *)NULL)))
  {
    if(reader->sock == sock)
    {
      zlistx_delete(self->readers, reader->list_handle);
      self->need_rebuild = (_Bool)1;
    }

    void *return_value_zlistx_next_2;
    return_value_zlistx_next_2=zlistx_next(self->readers);
    reader = (struct _s_reader_t *)return_value_zlistx_next_2;
  }
  const char *return_value_zsock_type_str_3;
  if(!(self->verbose == (_Bool)0))
  {
    return_value_zsock_type_str_3=zsock_type_str(sock);
    zsys_debug("zloop: cancel %s reader", return_value_zsock_type_str_3);
  }

}

// zloop_reader_set_tolerant
// file src/../include/zloop.h line 59
void zloop_reader_set_tolerant(struct _zloop_t *self, struct _zsock_t *sock)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  /* assertion sock */
  assert(sock != ((struct _zsock_t *)NULL));
  struct _s_reader_t *reader;
  void *return_value_zlistx_first_1;
  return_value_zlistx_first_1=zlistx_first(self->readers);
  reader = (struct _s_reader_t *)return_value_zlistx_first_1;
  while(!(reader == ((struct _s_reader_t *)NULL)))
  {
    if(reader->sock == sock)
      reader->tolerant = (_Bool)1;

    void *return_value_zlistx_next_2;
    return_value_zlistx_next_2=zlistx_next(self->readers);
    reader = (struct _s_reader_t *)return_value_zlistx_next_2;
  }
}

// zloop_set_max_timers
// file src/zloop.c line 720
void zloop_set_max_timers(struct _zloop_t *self, unsigned long int max_timers)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  self->max_timers = max_timers;
}

// zloop_set_ticket_delay
// file src/../include/zloop.h line 118
void zloop_set_ticket_delay(struct _zloop_t *self, unsigned long int ticket_delay)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  self->ticket_delay = ticket_delay;
}

// zloop_set_verbose
// file src/zloop.c line 693
void zloop_set_verbose(struct _zloop_t *self, _Bool verbose)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  self->verbose = verbose;
}

// zloop_start
// file src/../include/zloop.h line 137
signed int zloop_start(struct _zloop_t *self)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  signed int rc = 0;
  const char *return_value_zsock_type_str_10;
  signed int return_value_zmq_errno_11;
  const char *return_value_zmq_strerror_12;
  const char *return_value_zsock_type_str_15;
  signed int return_value_zsock_type_17;
  char *return_value_zsys_sockname_18;
  signed int return_value_zmq_errno_20;
  const char *return_value_zmq_strerror_21;
  signed int return_value_zsock_type_24;
  char *return_value_zsys_sockname_25;
  void *return_value_zlistx_first_28;
  while((_Bool)1)
  {
    if(self->ignore_interrupts == (_Bool)0)
    {
      if(!(zsys_interrupted == 0))
        goto __CPROVER_DUMP_L52;

    }

    if(!(self->need_rebuild == (_Bool)0))
    {
      rc=s_rebuild_pollset(self);
      if(!(rc == 0))
        break;

    }

    signed long int return_value_s_tickless_1;
    return_value_s_tickless_1=s_tickless(self);
    rc=zmq_poll(self->pollset, (signed int)self->poll_size, return_value_s_tickless_1);
    _Bool tmp_if_expr_2;
    if(rc == -1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (!(self->ignore_interrupts != (_Bool)0) ? (zsys_interrupted != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      if(!(self->verbose == (_Bool)0))
        zsys_debug("zloop: interrupted");

      rc = 0;
      break;
    }

    signed long int time_now;
    time_now=zclock_mono();
    struct _s_timer_t *timer;
    void *return_value_zlistx_first_3;
    return_value_zlistx_first_3=zlistx_first(self->timers);
    timer = (struct _s_timer_t *)return_value_zlistx_first_3;
    while(!(timer == ((struct _s_timer_t *)NULL)))
    {
      if(time_now >= timer->when)
      {
        if(!(self->verbose == (_Bool)0))
          zsys_debug("zloop: call timer handler id=%d", timer->timer_id);

        rc=timer->handler(self, timer->timer_id, timer->arg);
        if(rc == -1)
          break;

        _Bool tmp_if_expr_4;
        if(!(timer->times == 0ul))
        {
          timer->times = timer->times - 1ul;
          tmp_if_expr_4 = timer->times == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
          zlistx_delete(self->timers, timer->list_handle);

        else
          timer->when = timer->when + (signed long int)timer->delay;
      }

      void *return_value_zlistx_next_5;
      return_value_zlistx_next_5=zlistx_next(self->timers);
      timer = (struct _s_timer_t *)return_value_zlistx_next_5;
    }
    struct _s_ticket_t *ticket;
    void *return_value_zlistx_first_6;
    return_value_zlistx_first_6=zlistx_first(self->tickets);
    ticket = (struct _s_ticket_t *)return_value_zlistx_first_6;
    if(!(ticket == ((struct _s_ticket_t *)NULL)))
    {
      if(time_now >= ticket->when)
      {
        if(!(self->verbose == (_Bool)0))
          zsys_debug("zloop: call ticket handler");

        signed int return_value;
        return_value=ticket->handler(self, 0, ticket->arg);
        if(!(return_value == -1))
        {
          zlistx_delete(self->tickets, ticket->list_handle);
          void *return_value_zlistx_next_7;
          return_value_zlistx_next_7=zlistx_next(self->tickets);
          ticket = (struct _s_ticket_t *)return_value_zlistx_next_7;
        }

      }

    }

    void *return_value_zlistx_last_8;
    return_value_zlistx_last_8=zlistx_last(self->tickets);
    ticket = (struct _s_ticket_t *)return_value_zlistx_last_8;
    while(!(ticket == ((struct _s_ticket_t *)NULL)))
    {
      if(ticket->deleted == (_Bool)0)
        break;

      zlistx_delete(self->tickets, ticket->list_handle);
      void *return_value_zlistx_last_9;
      return_value_zlistx_last_9=zlistx_last(self->tickets);
      ticket = (struct _s_ticket_t *)return_value_zlistx_last_9;
    }
    unsigned long int item_nbr = (unsigned long int)0;
    for( ; rc >= 0 && !(item_nbr >= self->poll_size); item_nbr = item_nbr + 1ul)
    {
      struct _s_reader_t *reader = &self->readact[(signed long int)item_nbr];
      if(!(reader->handler == ((signed int (*)(struct _zloop_t *, struct _zsock_t *, void *))NULL)))
      {
        _Bool tmp_if_expr_14;
        if(!((4 & (signed int)(self->pollset + (signed long int)item_nbr)->revents) == 0))
          tmp_if_expr_14 = !(reader->tolerant != (_Bool)0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_14 = (_Bool)0;
        if(tmp_if_expr_14)
        {
          if(!(self->verbose == (_Bool)0))
          {
            return_value_zsock_type_str_10=zsock_type_str(reader->sock);
            return_value_zmq_errno_11=zmq_errno();
            return_value_zmq_strerror_12=zmq_strerror(return_value_zmq_errno_11);
            zsys_warning("zloop: can't read %s socket: %s", return_value_zsock_type_str_10, return_value_zmq_strerror_12);
          }

          signed int tmp_post_13 = reader->errors;
          reader->errors = reader->errors + 1;
          if(!(tmp_post_13 == 0))
          {
            zloop_reader_end(self, reader->sock);
            (self->pollset + (signed long int)item_nbr)->revents = (signed short int)0;
          }

        }

        else
          reader->errors = 0;
        if(!((self->pollset + (signed long int)item_nbr)->revents == 0))
        {
          if(!(self->verbose == (_Bool)0))
          {
            return_value_zsock_type_str_15=zsock_type_str(reader->sock);
            zsys_debug("zloop: call %s socket handler", return_value_zsock_type_str_15);
          }

          rc=reader->handler(self, reader->sock, reader->arg);
          _Bool tmp_if_expr_16;
          if(rc == -1)
            tmp_if_expr_16 = (_Bool)1;

          else
            tmp_if_expr_16 = self->need_rebuild != (_Bool)0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_16)
            break;

        }

      }

      else
      {
        struct _s_poller_t *poller = &self->pollact[(signed long int)item_nbr];
        /* assertion self->pollset [item_nbr].socket == poller->item.socket */
        assert((self->pollset + (signed long int)item_nbr)->socket == poller->item.socket);
        _Bool tmp_if_expr_23;
        if(!((4 & (signed int)(self->pollset + (signed long int)item_nbr)->revents) == 0))
          tmp_if_expr_23 = !(poller->tolerant != (_Bool)0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_23 = (_Bool)0;
        if(tmp_if_expr_23)
        {
          if(!(self->verbose == (_Bool)0))
          {
            char *tmp_if_expr_19;
            if(!(poller->item.socket == NULL))
            {
              return_value_zsock_type_17=zsock_type(poller->item.socket);
              return_value_zsys_sockname_18=zsys_sockname(return_value_zsock_type_17);
              tmp_if_expr_19 = return_value_zsys_sockname_18;
            }

            else
              tmp_if_expr_19 = "FD";
            return_value_zmq_errno_20=zmq_errno();
            return_value_zmq_strerror_21=zmq_strerror(return_value_zmq_errno_20);
            zsys_warning("zloop: can't poll %s socket (%p, %d): %s", tmp_if_expr_19, poller->item.socket, poller->item.fd, return_value_zmq_strerror_21);
          }

          signed int tmp_post_22 = poller->errors;
          poller->errors = poller->errors + 1;
          if(!(tmp_post_22 == 0))
          {
            zloop_poller_end(self, &poller->item);
            (self->pollset + (signed long int)item_nbr)->revents = (signed short int)0;
          }

        }

        else
          poller->errors = 0;
        if(!((self->pollset + (signed long int)item_nbr)->revents == 0))
        {
          if(!(self->verbose == (_Bool)0))
          {
            char *tmp_if_expr_26;
            if(!(poller->item.socket == NULL))
            {
              return_value_zsock_type_24=zsock_type(poller->item.socket);
              return_value_zsys_sockname_25=zsys_sockname(return_value_zsock_type_24);
              tmp_if_expr_26 = return_value_zsys_sockname_25;
            }

            else
              tmp_if_expr_26 = "FD";
            zsys_debug("zloop: call %s socket handler (%p, %d)", tmp_if_expr_26, poller->item.socket, poller->item.fd);
          }

          rc=poller->handler(self, &self->pollset[(signed long int)item_nbr], poller->arg);
          _Bool tmp_if_expr_27;
          if(rc == -1)
            tmp_if_expr_27 = (_Bool)1;

          else
            tmp_if_expr_27 = self->need_rebuild != (_Bool)0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_27)
            break;

        }

      }
    }
    do
    {
      return_value_zlistx_first_28=zlistx_first(self->zombies);
      if(return_value_zlistx_first_28 == NULL)
        break;

      signed long int timer_id;
      void *return_value_zlistx_detach_29;
      return_value_zlistx_detach_29=zlistx_detach(self->zombies, (void *)0);
      timer_id = (unsigned char *)return_value_zlistx_detach_29 - (unsigned char *)(void *)0;
      s_timer_remove(self, (signed int)timer_id);
    }
    while((_Bool)1);
    if(rc == -1)
      break;

  }

__CPROVER_DUMP_L52:
  ;
  self->terminated = (_Bool)1;
  return rc;
}

// zloop_test
// file src/zloop.c line 908
void zloop_test(_Bool verbose)
{
  printf(" * zloop: ");
  signed int rc = 0;
  struct _zsock_t *output;
  output=zsock_new_checked(0, "src/zloop.c", (unsigned long int)914);
  /* assertion output */
  assert(output != ((struct _zsock_t *)NULL));
  zsock_bind(output, "inproc://zloop.test");
  struct _zsock_t *input;
  input=zsock_new_checked(0, "src/zloop.c", (unsigned long int)918);
  /* assertion input */
  assert(input != ((struct _zsock_t *)NULL));
  zsock_connect(input, "inproc://zloop.test");
  struct _zloop_t *loop;
  loop=zloop_new();
  /* assertion loop */
  assert(loop != ((struct _zloop_t *)NULL));
  zloop_set_verbose(loop, verbose);
  signed int timer_id;
  timer_id=zloop_timer(loop, (unsigned long int)1000, (unsigned long int)1, s_timer_event, (void *)0);
  zloop_timer(loop, (unsigned long int)5, (unsigned long int)1, s_cancel_timer_event, (void *)&timer_id);
  zloop_timer(loop, (unsigned long int)20, (unsigned long int)1, s_timer_event, (void *)output);
  zloop_set_ticket_delay(loop, (unsigned long int)10000);
  void *ticket1;
  ticket1=zloop_ticket(loop, s_timer_event, (void *)0);
  void *ticket2;
  ticket2=zloop_ticket(loop, s_timer_event, (void *)0);
  void *ticket3;
  ticket3=zloop_ticket(loop, s_timer_event, (void *)0);
  rc=zloop_reader(loop, input, s_socket_event, (void *)0);
  /* assertion rc == 0 */
  assert(rc == 0);
  zloop_reader_set_tolerant(loop, input);
  zloop_start(loop);
  zloop_ticket_delete(loop, ticket1);
  zloop_ticket_delete(loop, ticket2);
  zloop_ticket_delete(loop, ticket3);
  zloop_destroy(&loop);
  loop=zloop_new();
  _Bool timer_event_called = (_Bool)0;
  zloop_timer(loop, (unsigned long int)1, (unsigned long int)1, s_timer_event3, (void *)&timer_event_called);
  zsys_interrupted = 1;
  zloop_start(loop);
  /* assertion !timer_event_called */
  assert(!(timer_event_called != (_Bool)0));
  zloop_ignore_interrupts(loop);
  zloop_start(loop);
  /* assertion timer_event_called */
  assert(timer_event_called != (_Bool)0);
  zsys_interrupted = 0;
  zloop_destroy(&loop);
  /* assertion loop == ((void *)0) */
  assert(loop == (struct _zloop_t *)(void *)0);
  zsock_destroy_checked(&input, "src/zloop.c", (unsigned long int)972);
  zsock_destroy_checked(&output, "src/zloop.c", (unsigned long int)973);
  printf("OK\n");
}

// zloop_ticket
// file src/../include/zloop.h line 102
void * zloop_ticket(struct _zloop_t *self, signed int (*handler)(struct _zloop_t *, signed int, void *), void *arg)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  /* assertion self->ticket_delay > 0 */
  assert(self->ticket_delay > (unsigned long int)0);
  struct _s_ticket_t *ticket;
  ticket=s_ticket_new(self->ticket_delay, handler, arg);
  if(!(ticket == ((struct _s_ticket_t *)NULL)))
  {
    ticket->list_handle=zlistx_add_end(self->tickets, (void *)ticket);
    if(ticket->list_handle == NULL)
      s_ticket_destroy(&ticket);

  }

  return (void *)ticket;
}

// zloop_ticket_delete
// file src/../include/zloop.h line 113
void zloop_ticket_delete(struct _zloop_t *self, void *handle)
{
  struct _s_ticket_t *ticket = (struct _s_ticket_t *)handle;
  /* assertion ticket->tag == 0x0007cafe */
  assert(ticket->tag == (unsigned int)0x0007cafe);
  ticket->deleted = (_Bool)1;
  zlistx_move_end(self->tickets, ticket->list_handle);
}

// zloop_ticket_reset
// file src/../include/zloop.h line 107
void zloop_ticket_reset(struct _zloop_t *self, void *handle)
{
  struct _s_ticket_t *ticket = (struct _s_ticket_t *)handle;
  /* assertion ticket->tag == 0x0007cafe */
  assert(ticket->tag == (unsigned int)0x0007cafe);
  signed long int return_value_zclock_mono_1;
  return_value_zclock_mono_1=zclock_mono();
  ticket->when = (signed long int)((unsigned long int)return_value_zclock_mono_1 + ticket->delay);
  zlistx_move_end(self->tickets, ticket->list_handle);
}

// zloop_timer
// file src/../include/zloop.h line 85
signed int zloop_timer(struct _zloop_t *self, unsigned long int delay, unsigned long int times, signed int (*handler)(struct _zloop_t *, signed int, void *), void *arg)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  unsigned long int return_value_zlistx_size_1;
  if(!(self->max_timers == 0ul))
  {
    return_value_zlistx_size_1=zlistx_size(self->timers);
    if(return_value_zlistx_size_1 == self->max_timers)
    {
      zsys_error("zloop: timer limit reached (max=%d)", self->max_timers);
      return -1;
    }

  }

  signed int timer_id;
  timer_id=s_next_timer_id(self);
  struct _s_timer_t *timer;
  timer=s_timer_new(timer_id, delay, times, handler, arg);
  if(!(timer == ((struct _s_timer_t *)NULL)))
  {
    timer->list_handle=zlistx_add_end(self->timers, (void *)timer);
    if(timer->list_handle == NULL)
    {
      s_timer_destroy(&timer);
      return -1;
    }

    if(!(self->verbose == (_Bool)0))
      zsys_debug("zloop: register timer id=%d delay=%d times=%d", timer_id, (signed int)delay, (signed int)times);

    return timer_id;
  }

  else
    return -1;
}

// zloop_timer_end
// file src/../include/zloop.h line 90
signed int zloop_timer_end(struct _zloop_t *self, signed int timer_id)
{
  /* assertion self */
  assert(self != ((struct _zloop_t *)NULL));
  void *return_value_zlistx_add_end_1;
  if(!(self->terminated == (_Bool)0))
    s_timer_remove(self, timer_id);

  else
  {
    return_value_zlistx_add_end_1=zlistx_add_end(self->zombies, (void *)((unsigned char *)(void *)0 + (signed long int)timer_id));
    if(return_value_zlistx_add_end_1 == NULL)
      return -1;

  }
  if(!(self->verbose == (_Bool)0))
    zsys_debug("zloop: cancel timer id=%d", timer_id);

  return 0;
}

// zmonitor
// file src/zmonitor.c line 285
void zmonitor(struct _zsock_t *pipe, void *sock)
{
  struct anonymous_25 *self;
  self=s_self_new_link2(pipe, sock);
  /* assertion self */
  assert(self != ((struct anonymous_25 *)NULL));
  zsock_signal((void *)pipe, (unsigned char)0);
  _Bool return_value_zpoller_terminated_2;
  while(self->terminated == (_Bool)0)
  {
    struct _zsock_t *which;
    void *return_value_zpoller_wait_1;
    return_value_zpoller_wait_1=zpoller_wait(self->poller, -1);
    which = (struct _zsock_t *)return_value_zpoller_wait_1;
    if(which == self->pipe)
      s_self_handle_pipe_link2(self);

    else
      if(which == self->sink)
        s_self_handle_sink(self);

      else
      {
        return_value_zpoller_terminated_2=zpoller_terminated(self->poller);
        if(!(return_value_zpoller_terminated_2 == (_Bool)0))
          break;

      }
  }
  s_self_destroy_link2(&self);
}

// zmonitor_destroy
// file src/zmonitor_v2.c line 87
void zmonitor_destroy(struct _zmonitor_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zmonitor_t **)NULL));
  if(!(*self_p == ((struct _zmonitor_t *)NULL)))
  {
    struct _zmonitor_t *self = *self_p;
    if(!(self->socket == NULL))
      zmq_socket_monitor(self->socket, (const char *)(void *)0, 0);

    if(!(self->pipe == NULL))
    {
      zstr_send(self->pipe, "TERMINATE");
      char *reply;
      reply=zstr_recv(self->pipe);
      zstr_free(&reply);
    }

    free((void *)self);
    *self_p = (struct _zmonitor_t *)(void *)0;
  }

}

// zmonitor_new
// file src/zmonitor_v2.c line 50
struct _zmonitor_t * zmonitor_new(struct _zctx_t *ctx, void *socket, signed int events)
{
  struct _zmonitor_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link33(sizeof(struct _zmonitor_t) /*16ul*/ , "src/zmonitor_v2.c", (unsigned int)52);
  self = (struct _zmonitor_t *)return_value_safe_malloc_1;
  if(self == ((struct _zmonitor_t *)NULL))
    return (struct _zmonitor_t *)(void *)0;

  else
  {
    /* assertion ctx */
    assert(ctx != ((struct _zctx_t *)NULL));
    self->pipe=zthread_fork(ctx, s_agent_task_link2, (void *)0);
    if(!(self->pipe == NULL))
    {
      self->socket = socket;
      char *monitor_endpoint;
      void *return_value_safe_malloc_2;
      return_value_safe_malloc_2=safe_malloc_link33((unsigned long int)100, "src/zmonitor_v2.c", (unsigned int)63);
      monitor_endpoint = (char *)return_value_safe_malloc_2;
      sprintf(monitor_endpoint, "inproc://zmonitor-%p", self->socket);
      signed int rc;
      rc=zmq_socket_monitor(self->socket, monitor_endpoint, events);
      /* assertion rc == 0 */
      assert(rc == 0);
      zstr_sendf(self->pipe, "%s", monitor_endpoint);
      free((void *)monitor_endpoint);
      char *status;
      status=zstr_recv(self->pipe);
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(status, "OK");
      if(!(return_value_strcmp_3 == 0))
        zmonitor_destroy(&self);

      zstr_free(&status);
    }

    else
      zmonitor_destroy(&self);
    return self;
  }
}

// zmonitor_recv
// file src/zmonitor_v2.c line 111
struct _zmsg_t * zmonitor_recv(struct _zmonitor_t *self)
{
  zsocket_set_rcvtimeo(self->pipe, 500);
  struct _zmsg_t *return_value_zmsg_recv_1;
  return_value_zmsg_recv_1=zmsg_recv(self->pipe);
  return return_value_zmsg_recv_1;
}

// zmonitor_set_verbose
// file src/zmonitor_v2.c line 133
void zmonitor_set_verbose(struct _zmonitor_t *self, _Bool verbose)
{
  /* assertion self */
  assert(self != ((struct _zmonitor_t *)NULL));
  zstr_sendm(self->pipe, "VERBOSE");
  zstr_sendf(self->pipe, "%d", verbose);
}

// zmonitor_socket
// file src/zmonitor_v2.c line 122
void * zmonitor_socket(struct _zmonitor_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmonitor_t *)NULL));
  return self->pipe;
}

// zmonitor_test
// file src/zmonitor.c line 324
void zmonitor_test(_Bool verbose)
{
  printf(" * zmonitor: ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  struct _zsock_t *client;
  client=zsock_new_checked(5, "src/zmonitor.c", (unsigned long int)332);
  /* assertion client */
  assert(client != ((struct _zsock_t *)NULL));
  struct _zactor_t *clientmon;
  clientmon=zactor_new(zmonitor, (void *)client);
  /* assertion clientmon */
  assert(clientmon != ((struct _zactor_t *)NULL));
  if(!(verbose == (_Bool)0))
    zstr_sendx((void *)clientmon, "VERBOSE", (void *)0);

  zstr_sendx((void *)clientmon, "LISTEN", (const void *)"LISTENING", (const void *)"ACCEPTED", (void *)0);
  zstr_sendx((void *)clientmon, "START", (void *)0);
  zsock_wait((void *)clientmon);
  struct _zsock_t *server;
  server=zsock_new_checked(5, "src/zmonitor.c", (unsigned long int)342);
  /* assertion server */
  assert(server != ((struct _zsock_t *)NULL));
  struct _zactor_t *servermon;
  servermon=zactor_new(zmonitor, (void *)server);
  /* assertion servermon */
  assert(servermon != ((struct _zactor_t *)NULL));
  if(!(verbose == (_Bool)0))
    zstr_sendx((void *)servermon, "VERBOSE", (void *)0);

  zstr_sendx((void *)servermon, "LISTEN", (const void *)"CONNECTED", (const void *)"DISCONNECTED", (void *)0);
  zstr_sendx((void *)servermon, "START", (void *)0);
  zsock_wait((void *)servermon);
  zmq_poll((struct zmq_pollitem_t *)(void *)0, 0, (signed long int)200);
  signed int port_nbr;
  port_nbr=zsock_bind(client, "tcp://127.0.0.1:*");
  /* assertion port_nbr != -1 */
  assert(port_nbr != -1);
  s_assert_event(clientmon, "LISTENING");
  zsock_connect(server, "tcp://127.0.0.1:%d", port_nbr);
  s_assert_event(servermon, "CONNECTED");
  s_assert_event(clientmon, "ACCEPTED");
  zactor_destroy(&clientmon);
  zactor_destroy(&servermon);
  zsock_destroy_checked(&client, "src/zmonitor.c", (unsigned long int)369);
  zsock_destroy_checked(&server, "src/zmonitor.c", (unsigned long int)370);
  printf("OK\n");
}

// zmonitor_v2_test
// file src/zmonitor_v2.c line 346
void zmonitor_v2_test(_Bool verbose)
{
  printf(" * zmonitor (deprecated): ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  struct _zctx_t *ctx;
  ctx=zctx_new();
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  _Bool result;
  void *sink;
  sink=zsocket_new(ctx, 7);
  /* assertion sink */
  assert(sink != NULL);
  struct _zmonitor_t *sinkmon;
  sinkmon=zmonitor_new(ctx, sink, 0x0008 | 0x0020);
  /* assertion sinkmon */
  assert(sinkmon != ((struct _zmonitor_t *)NULL));
  zmonitor_set_verbose(sinkmon, verbose);
  signed int port_nbr;
  port_nbr=zsocket_bind(sink, "tcp://127.0.0.1:*");
  /* assertion port_nbr != -1 */
  assert(port_nbr != -1);
  result=s_check_event(sinkmon, 0x0008);
  /* assertion result */
  assert(result != (_Bool)0);
  void *source;
  source=zsocket_new(ctx, 8);
  /* assertion source */
  assert(source != NULL);
  struct _zmonitor_t *sourcemon;
  sourcemon=zmonitor_new(ctx, source, 0x0001 | 0x0200);
  /* assertion sourcemon */
  assert(sourcemon != ((struct _zmonitor_t *)NULL));
  zmonitor_set_verbose(sourcemon, verbose);
  zsocket_connect(source, "tcp://127.0.0.1:%d", port_nbr);
  result=s_check_event(sourcemon, 0x0001);
  /* assertion result */
  assert(result != (_Bool)0);
  result=s_check_event(sinkmon, 0x0020);
  /* assertion result */
  assert(result != (_Bool)0);
  zmonitor_destroy(&sinkmon);
  zmonitor_destroy(&sourcemon);
  zctx_destroy(&ctx);
  printf("OK\n");
}

// zmsg_add
// file src/zmsg.c line 912
signed int zmsg_add(struct _zmsg_t *self, struct _zframe_t *frame)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  unsigned long int return_value_zframe_size_1;
  return_value_zframe_size_1=zframe_size(frame);
  self->content_size = self->content_size + return_value_zframe_size_1;
  signed int return_value_zlist_append_2;
  return_value_zlist_append_2=zlist_append(self->frames, (void *)frame);
  return return_value_zlist_append_2;
}

// zmsg_addmem
// file src/zmsg.c line 288
signed int zmsg_addmem(struct _zmsg_t *self, const void *src, unsigned long int size)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  struct _zframe_t *frame;
  frame=zframe_new(src, size);
  if(!(frame == ((struct _zframe_t *)NULL)))
  {
    self->content_size = self->content_size + size;
    signed int return_value_zlist_append_2;
    return_value_zlist_append_2=zlist_append(self->frames, (void *)frame);
    return return_value_zlist_append_2;
  }

  else
    return -1;
}

// zmsg_addmsg
// file src/zmsg.c line 434
signed int zmsg_addmsg(struct _zmsg_t *self, struct _zmsg_t **msg_p)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  /* assertion msg_p */
  assert(msg_p != ((struct _zmsg_t **)NULL));
  struct _zmsg_t *msg = *msg_p;
  unsigned char *data;
  unsigned long int len;
  len=zmsg_encode(msg, &data);
  signed int r;
  r=zmsg_addmem(self, (const void *)data, len);
  if(r == 0)
  {
    zmsg_destroy(&msg);
    *msg_p = (struct _zmsg_t *)(void *)0;
  }

  free((void *)data);
  return r;
}

// zmsg_addstr
// file src/../include/zmsg.h line 101
signed int zmsg_addstr(struct _zmsg_t *self, const char *string)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  /* assertion string */
  assert(string != ((const char *)NULL));
  unsigned long int len;
  len=strlen(string);
  struct _zframe_t *frame;
  frame=zframe_new((const void *)string, len);
  if(!(frame == ((struct _zframe_t *)NULL)))
  {
    self->content_size = self->content_size + len;
    signed int return_value_zlist_append_2;
    return_value_zlist_append_2=zlist_append(self->frames, (void *)frame);
    return return_value_zlist_append_2;
  }

  else
    return -1;
}

// zmsg_addstrf
// file src/../include/zmsg.h line 111
signed int zmsg_addstrf(struct _zmsg_t *self, const char *format, ...)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  /* assertion format */
  assert(format != ((const char *)NULL));
  void **argptr = (void **)&format;
  char *string;
  string=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  if(string == ((char *)NULL))
    return -1;

  else
  {
    unsigned long int len;
    len=strlen(string);
    struct _zframe_t *frame;
    frame=zframe_new((const void *)string, len);
    free((void *)string);
    if(!(frame == ((struct _zframe_t *)NULL)))
    {
      self->content_size = self->content_size + len;
      signed int return_value_zlist_append_2;
      return_value_zlist_append_2=zlist_append(self->frames, (void *)frame);
      return return_value_zlist_append_2;
    }

    else
      return -1;
  }
}

// zmsg_append
// file src/../include/zmsg.h line 76
signed int zmsg_append(struct _zmsg_t *self, struct _zframe_t **frame_p)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  /* assertion frame_p */
  assert(frame_p != ((struct _zframe_t **)NULL));
  struct _zframe_t *frame = *frame_p;
  *frame_p = (struct _zframe_t *)(void *)0;
  unsigned long int return_value_zframe_size_2;
  return_value_zframe_size_2=zframe_size(frame);
  self->content_size = self->content_size + return_value_zframe_size_2;
  signed int return_value_zlist_append_3;
  return_value_zlist_append_3=zlist_append(self->frames, (void *)frame);
  return return_value_zlist_append_3;
}

// zmsg_content_size
// file src/zmsg.c line 198
unsigned long int zmsg_content_size(struct _zmsg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  return self->content_size;
}

// zmsg_decode
// file src/zmsg.c line 663
struct _zmsg_t * zmsg_decode(const unsigned char *buffer, unsigned long int buffer_size)
{
  struct _zmsg_t *self;
  self=zmsg_new();
  if(self == ((struct _zmsg_t *)NULL))
    return (struct _zmsg_t *)(void *)0;

  else
  {
    const unsigned char *source = buffer;
    const unsigned char *limit = buffer + (signed long int)buffer_size;
    while(!(source >= limit))
    {
      unsigned long int frame_size;
      const unsigned char *tmp_post_1 = source;
      source = source + 1l;
      frame_size = (unsigned long int)*tmp_post_1;
      if(frame_size == 255ul)
      {
        if(!(limit + -4l >= source))
        {
          zmsg_destroy(&self);
          break;
        }

        frame_size = (unsigned long int)(((signed int)source[(signed long int)0] << 24) + ((signed int)source[(signed long int)1] << 16) + ((signed int)source[(signed long int)2] << 8) + (signed int)source[(signed long int)3]);
        source = source + (signed long int)4;
      }

      if(!(limit + -((signed long int)frame_size) >= source))
      {
        zmsg_destroy(&self);
        break;
      }

      struct _zframe_t *frame;
      frame=zframe_new((const void *)source, frame_size);
      if(!(frame == ((struct _zframe_t *)NULL)))
      {
        signed int return_value_zmsg_append_2;
        return_value_zmsg_append_2=zmsg_append(self, &frame);
        if(!(return_value_zmsg_append_2 == 0))
        {
          zmsg_destroy(&self);
          break;
        }

        source = source + (signed long int)frame_size;
      }

      else
      {
        zmsg_destroy(&self);
        break;
      }
    }
    return self;
  }
}

// zmsg_destroy
// file src/../include/zmsg.h line 30
void zmsg_destroy(struct _zmsg_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zmsg_t **)NULL));
  void *return_value_zlist_pop_2;
  if(!(*self_p == ((struct _zmsg_t *)NULL)))
  {
    struct _zmsg_t *self = *self_p;
    _Bool return_value_zmsg_is_1;
    return_value_zmsg_is_1=zmsg_is((void *)self);
    /* assertion zmsg_is (self) */
    assert(return_value_zmsg_is_1 != (_Bool)0);
    struct _zframe_t *frame;
    do
    {
      return_value_zlist_pop_2=zlist_pop(self->frames);
      frame = (struct _zframe_t *)return_value_zlist_pop_2;
      if(frame == ((struct _zframe_t *)NULL))
        break;

      zframe_destroy(&frame);
    }
    while((_Bool)1);
    zlist_destroy(&self->frames);
    self->tag = 0xDeadBeef;
    free((void *)self);
    *self_p = (struct _zmsg_t *)(void *)0;
  }

}

// zmsg_dup
// file src/zmsg.c line 710
struct _zmsg_t * zmsg_dup(struct _zmsg_t *self)
{
  if(!(self == ((struct _zmsg_t *)NULL)))
  {
    _Bool return_value_zmsg_is_1;
    return_value_zmsg_is_1=zmsg_is((void *)self);
    /* assertion zmsg_is (self) */
    assert(return_value_zmsg_is_1 != (_Bool)0);
    struct _zmsg_t *copy;
    copy=zmsg_new();
    if(!(copy == ((struct _zmsg_t *)NULL)))
    {
      struct _zframe_t *frame;
      frame=zmsg_first(self);
      while(!(frame == ((struct _zframe_t *)NULL)))
      {
        unsigned char *return_value_zframe_data_2;
        return_value_zframe_data_2=zframe_data(frame);
        unsigned long int return_value_zframe_size_3;
        return_value_zframe_size_3=zframe_size(frame);
        signed int return_value_zmsg_addmem_4;
        return_value_zmsg_addmem_4=zmsg_addmem(copy, (const void *)return_value_zframe_data_2, return_value_zframe_size_3);
        if(!(return_value_zmsg_addmem_4 == 0))
        {
          zmsg_destroy(&copy);
          break;
        }

        frame=zmsg_next(self);
      }
    }

    return copy;
  }

  else
    return (struct _zmsg_t *)(void *)0;
}

// zmsg_encode
// file src/zmsg.c line 611
unsigned long int zmsg_encode(struct _zmsg_t *self, unsigned char **buffer)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  unsigned long int buffer_size = (unsigned long int)0;
  struct _zframe_t *frame;
  frame=zmsg_first(self);
  while(!(frame == ((struct _zframe_t *)NULL)))
  {
    unsigned long int frame_size;
    frame_size=zframe_size(frame);
    if(!(frame_size >= 255ul))
      buffer_size = buffer_size + frame_size + (unsigned long int)1;

    else
      buffer_size = buffer_size + frame_size + (unsigned long int)1 + (unsigned long int)4;
    frame=zmsg_next(self);
  }
  void *return_value_safe_malloc_2;
  return_value_safe_malloc_2=safe_malloc_link19(buffer_size, "src/zmsg.c", (unsigned int)627);
  *buffer = (unsigned char *)return_value_safe_malloc_2;
  if(!(*buffer == ((unsigned char *)NULL)))
  {
    unsigned char *dest = *buffer;
    frame=zmsg_first(self);
    while(!(frame == ((struct _zframe_t *)NULL)))
    {
      unsigned long int zmsg_encode__1__2__1__frame_size;
      zmsg_encode__1__2__1__frame_size=zframe_size(frame);
      if(!(zmsg_encode__1__2__1__frame_size >= 255ul))
      {
        unsigned char *tmp_post_3 = dest;
        dest = dest + 1l;
        *tmp_post_3 = (unsigned char)zmsg_encode__1__2__1__frame_size;
        unsigned char *return_value_zframe_data_4;
        return_value_zframe_data_4=zframe_data(frame);
        memcpy((void *)dest, (const void *)return_value_zframe_data_4, zmsg_encode__1__2__1__frame_size);
        dest = dest + (signed long int)zmsg_encode__1__2__1__frame_size;
      }

      else
      {
        unsigned char *tmp_post_5 = dest;
        dest = dest + 1l;
        *tmp_post_5 = (unsigned char)0xFF;
        unsigned char *tmp_post_6 = dest;
        dest = dest + 1l;
        *tmp_post_6 = (unsigned char)(zmsg_encode__1__2__1__frame_size >> 24 & (unsigned long int)255);
        unsigned char *tmp_post_7 = dest;
        dest = dest + 1l;
        *tmp_post_7 = (unsigned char)(zmsg_encode__1__2__1__frame_size >> 16 & (unsigned long int)255);
        unsigned char *tmp_post_8 = dest;
        dest = dest + 1l;
        *tmp_post_8 = (unsigned char)(zmsg_encode__1__2__1__frame_size >> 8 & (unsigned long int)255);
        unsigned char *tmp_post_9 = dest;
        dest = dest + 1l;
        *tmp_post_9 = (unsigned char)(zmsg_encode__1__2__1__frame_size & (unsigned long int)255);
        unsigned char *return_value_zframe_data_10;
        return_value_zframe_data_10=zframe_data(frame);
        memcpy((void *)dest, (const void *)return_value_zframe_data_10, zmsg_encode__1__2__1__frame_size);
        dest = dest + (signed long int)zmsg_encode__1__2__1__frame_size;
      }
      frame=zmsg_next(self);
    }
    /* assertion (dest - *buffer) == buffer_size */
    assert((unsigned long int)(dest - *buffer) == buffer_size);
  }

  return buffer_size;
}

// zmsg_eq
// file src/zmsg.c line 760
_Bool zmsg_eq(struct _zmsg_t *self, struct _zmsg_t *other)
{
  if(other == ((struct _zmsg_t *)NULL) || self == ((struct _zmsg_t *)NULL))
    return (_Bool)0;

  else
  {
    unsigned long int return_value_zlist_size_1;
    return_value_zlist_size_1=zlist_size(self->frames);
    unsigned long int return_value_zlist_size_2;
    return_value_zlist_size_2=zlist_size(other->frames);
    if(!(return_value_zlist_size_1 == return_value_zlist_size_2))
      return (_Bool)0;

    else
    {
      struct _zframe_t *self_frame;
      void *return_value_zlist_first_3;
      return_value_zlist_first_3=zlist_first(self->frames);
      self_frame = (struct _zframe_t *)return_value_zlist_first_3;
      struct _zframe_t *other_frame;
      void *return_value_zlist_first_4;
      return_value_zlist_first_4=zlist_first(other->frames);
      other_frame = (struct _zframe_t *)return_value_zlist_first_4;
      while(!(other_frame == ((struct _zframe_t *)NULL)) && !(self_frame == ((struct _zframe_t *)NULL)))
      {
        _Bool return_value_zframe_eq_5;
        return_value_zframe_eq_5=zframe_eq(self_frame, other_frame);
        if(return_value_zframe_eq_5 == (_Bool)0)
          return (_Bool)0;

        void *return_value_zlist_next_6;
        return_value_zlist_next_6=zlist_next(self->frames);
        self_frame = (struct _zframe_t *)return_value_zlist_next_6;
        void *return_value_zlist_next_7;
        return_value_zlist_next_7=zlist_next(other->frames);
        other_frame = (struct _zframe_t *)return_value_zlist_next_7;
      }
      return (_Bool)1;
    }
  }
}

// zmsg_first
// file src/zmsg.c line 495
struct _zframe_t * zmsg_first(struct _zmsg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  void *return_value_zlist_first_2;
  return_value_zlist_first_2=zlist_first(self->frames);
  return (struct _zframe_t *)return_value_zlist_first_2;
}

// zmsg_fprint
// file src/zmsg.c line 928
void zmsg_fprint(struct _zmsg_t *self, struct _IO_FILE *file)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  fprintf(file, "--------------------------------------\n");
  signed int tmp_post_2;
  if(self == ((struct _zmsg_t *)NULL))
    fprintf(file, "NULL");

  else
  {
    struct _zframe_t *frame;
    frame=zmsg_first(self);
    signed int frame_nbr = 0;
    while(!(frame == ((struct _zframe_t *)NULL)))
    {
      tmp_post_2 = frame_nbr;
      frame_nbr = frame_nbr + 1;
      if(tmp_post_2 >= 10)
        break;

      zframe_fprint(frame, (const char *)(void *)0, file);
      frame=zmsg_next(self);
    }
  }
}

// zmsg_is
// file src/zmsg.c line 817
_Bool zmsg_is(void *self)
{
  /* assertion self */
  assert(self != NULL);
  return ((struct _zmsg_t *)self)->tag == (unsigned int)0x0003cafe;
}

// zmsg_last
// file src/zmsg.c line 520
struct _zframe_t * zmsg_last(struct _zmsg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  void *return_value_zlist_last_2;
  return_value_zlist_last_2=zlist_last(self->frames);
  return (struct _zframe_t *)return_value_zlist_last_2;
}

// zmsg_load
// file src/zmsg.c line 561
struct _zmsg_t * zmsg_load(struct _zmsg_t *self, struct _IO_FILE *file)
{
  /* assertion file */
  assert(file != ((struct _IO_FILE *)NULL));
  if(self == ((struct _zmsg_t *)NULL))
    self=zmsg_new();

  if(self == ((struct _zmsg_t *)NULL))
    return (struct _zmsg_t *)(void *)0;

  else
  {
    while((_Bool)1)
    {
      unsigned long int frame_size;
      unsigned long int rc;
      rc=fread((void *)&frame_size, sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1, file);
      if(rc == 1ul)
      {
        struct _zframe_t *frame;
        frame=zframe_new((void *)0, frame_size);
        if(frame == ((struct _zframe_t *)NULL))
        {
          zmsg_destroy(&self);
          return (struct _zmsg_t *)(void *)0;
        }

        unsigned char *return_value_zframe_data_1;
        return_value_zframe_data_1=zframe_data(frame);
        rc=fread((void *)return_value_zframe_data_1, frame_size, (unsigned long int)1, file);
        if(frame_size >= 1ul && !(rc == 1ul))
        {
          zframe_destroy(&frame);
          zmsg_destroy(&self);
          return (struct _zmsg_t *)(void *)0;
        }

        signed int return_value_zmsg_append_2;
        return_value_zmsg_append_2=zmsg_append(self, &frame);
        if(return_value_zmsg_append_2 == -1)
        {
          zmsg_destroy(&self);
          return (struct _zmsg_t *)(void *)0;
        }

      }

      else
        break;
    }
    unsigned long int return_value_zmsg_size_3;
    return_value_zmsg_size_3=zmsg_size(self);
    if(return_value_zmsg_size_3 == 0ul)
    {
      zmsg_destroy(&self);
      self = (struct _zmsg_t *)(void *)0;
    }

    return self;
  }
}

// zmsg_new
// file src/../include/zmsg.h line 26
struct _zmsg_t * zmsg_new(void)
{
  struct _zmsg_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link19(sizeof(struct _zmsg_t) /*24ul*/ , "src/zmsg.c", (unsigned int)57);
  self = (struct _zmsg_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _zmsg_t *)NULL)))
  {
    self->tag = (unsigned int)0x0003cafe;
    self->frames=zlist_new();
    if(self->frames == ((struct _zlist_t *)NULL))
      zmsg_destroy(&self);

  }

  return self;
}

// zmsg_new_signal
// file src/zmsg.c line 786
struct _zmsg_t * zmsg_new_signal(unsigned char status)
{
  struct _zmsg_t *self;
  self=zmsg_new();
  signed long int signal_value = 0x7766554433221100L + (signed long int)status;
  signed int return_value_zmsg_addmem_1;
  return_value_zmsg_addmem_1=zmsg_addmem(self, (const void *)&signal_value, (unsigned long int)8);
  if(!(return_value_zmsg_addmem_1 == 0))
    zmsg_destroy(&self);

  return self;
}

// zmsg_next
// file src/zmsg.c line 508
struct _zframe_t * zmsg_next(struct _zmsg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  void *return_value_zlist_next_2;
  return_value_zlist_next_2=zlist_next(self->frames);
  return (struct _zframe_t *)return_value_zlist_next_2;
}

// zmsg_pop
// file src/../include/zmsg.h line 81
struct _zframe_t * zmsg_pop(struct _zmsg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  struct _zframe_t *frame;
  void *return_value_zlist_pop_2;
  return_value_zlist_pop_2=zlist_pop(self->frames);
  frame = (struct _zframe_t *)return_value_zlist_pop_2;
  unsigned long int return_value_zframe_size_3;
  if(!(frame == ((struct _zframe_t *)NULL)))
  {
    return_value_zframe_size_3=zframe_size(frame);
    self->content_size = self->content_size - return_value_zframe_size_3;
  }

  return frame;
}

// zmsg_popmsg
// file src/zmsg.c line 459
struct _zmsg_t * zmsg_popmsg(struct _zmsg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  struct _zframe_t *frame;
  frame=zmsg_pop(self);
  if(frame == ((struct _zframe_t *)NULL))
    return (struct _zmsg_t *)(void *)0;

  else
  {
    unsigned long int len;
    len=zframe_size(frame);
    unsigned char *data;
    data=zframe_data(frame);
    struct _zmsg_t *msg;
    msg=zmsg_decode(data, len);
    zframe_destroy(&frame);
    return msg;
  }
}

// zmsg_popstr
// file src/../include/zmsg.h line 117
char * zmsg_popstr(struct _zmsg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  struct _zframe_t *frame;
  void *return_value_zlist_pop_2;
  return_value_zlist_pop_2=zlist_pop(self->frames);
  frame = (struct _zframe_t *)return_value_zlist_pop_2;
  char *string = (char *)(void *)0;
  if(!(frame == ((struct _zframe_t *)NULL)))
  {
    unsigned long int return_value_zframe_size_3;
    return_value_zframe_size_3=zframe_size(frame);
    self->content_size = self->content_size - return_value_zframe_size_3;
    string=zframe_strdup(frame);
    zframe_destroy(&frame);
  }

  return string;
}

// zmsg_prepend
// file src/zmsg.c line 214
signed int zmsg_prepend(struct _zmsg_t *self, struct _zframe_t **frame_p)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  /* assertion frame_p */
  assert(frame_p != ((struct _zframe_t **)NULL));
  struct _zframe_t *frame = *frame_p;
  *frame_p = (struct _zframe_t *)(void *)0;
  unsigned long int return_value_zframe_size_2;
  return_value_zframe_size_2=zframe_size(frame);
  self->content_size = self->content_size + return_value_zframe_size_2;
  signed int return_value_zlist_push_3;
  return_value_zlist_push_3=zlist_push(self->frames, (void *)frame);
  return return_value_zlist_push_3;
}

// zmsg_print
// file src/zmsg.c line 737
void zmsg_print(struct _zmsg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  if(self == ((struct _zmsg_t *)NULL))
    zsys_debug("(NULL)");

  else
  {
    struct _zframe_t *frame;
    frame=zmsg_first(self);
    while(!(frame == ((struct _zframe_t *)NULL)))
    {
      zframe_print(frame, (const char *)(void *)0);
      frame=zmsg_next(self);
    }
  }
}

// zmsg_push
// file src/zmsg.c line 896
signed int zmsg_push(struct _zmsg_t *self, struct _zframe_t *frame)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  unsigned long int return_value_zframe_size_1;
  return_value_zframe_size_1=zframe_size(frame);
  self->content_size = self->content_size + return_value_zframe_size_1;
  signed int return_value_zlist_push_2;
  return_value_zlist_push_2=zlist_push(self->frames, (void *)frame);
  return return_value_zlist_push_2;
}

// zmsg_pushmem
// file src/zmsg.c line 269
signed int zmsg_pushmem(struct _zmsg_t *self, const void *src, unsigned long int size)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  struct _zframe_t *frame;
  frame=zframe_new(src, size);
  if(!(frame == ((struct _zframe_t *)NULL)))
  {
    self->content_size = self->content_size + size;
    signed int return_value_zlist_push_2;
    return_value_zlist_push_2=zlist_push(self->frames, (void *)frame);
    return return_value_zlist_push_2;
  }

  else
    return -1;
}

// zmsg_pushstr
// file src/zmsg.c line 308
signed int zmsg_pushstr(struct _zmsg_t *self, const char *string)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  /* assertion string */
  assert(string != ((const char *)NULL));
  unsigned long int len;
  len=strlen(string);
  struct _zframe_t *frame;
  frame=zframe_new((const void *)string, len);
  if(!(frame == ((struct _zframe_t *)NULL)))
  {
    self->content_size = self->content_size + len;
    signed int return_value_zlist_push_2;
    return_value_zlist_push_2=zlist_push(self->frames, (void *)frame);
    return return_value_zlist_push_2;
  }

  else
    return -1;
}

// zmsg_pushstrf
// file src/zmsg.c line 352
signed int zmsg_pushstrf(struct _zmsg_t *self, const char *format, ...)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  /* assertion format */
  assert(format != ((const char *)NULL));
  void **argptr = (void **)&format;
  char *string;
  string=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  if(string == ((char *)NULL))
    return -1;

  else
  {
    unsigned long int len;
    len=strlen(string);
    struct _zframe_t *frame;
    frame=zframe_new((const void *)string, len);
    free((void *)string);
    if(!(frame == ((struct _zframe_t *)NULL)))
    {
      self->content_size = self->content_size + len;
      signed int return_value_zlist_push_2;
      return_value_zlist_push_2=zlist_push(self->frames, (void *)frame);
      return return_value_zlist_push_2;
    }

    else
      return -1;
  }
}

// zmsg_recv
// file src/../include/zmsg.h line 38
struct _zmsg_t * zmsg_recv(void *source)
{
  /* assertion source */
  assert(source != NULL);
  struct _zmsg_t *self;
  self=zmsg_new();
  if(self == ((struct _zmsg_t *)NULL))
    return (struct _zmsg_t *)(void *)0;

  else
  {
    void *handle;
    handle=zsock_resolve(source);
    while((_Bool)1)
    {
      struct _zframe_t *frame;
      frame=zframe_recv(handle);
      if(frame == ((struct _zframe_t *)NULL))
      {
        zmsg_destroy(&self);
        break;
      }

      signed int return_value_zmsg_append_1;
      return_value_zmsg_append_1=zmsg_append(self, &frame);
      if(!(return_value_zmsg_append_1 == 0))
      {
        zmsg_destroy(&self);
        break;
      }

      signed int return_value_zsock_rcvmore_2;
      return_value_zsock_rcvmore_2=zsock_rcvmore(handle);
      if(return_value_zsock_rcvmore_2 == 0)
        break;

    }
    return self;
  }
}

// zmsg_recv_nowait
// file src/zmsg.c line 849
struct _zmsg_t * zmsg_recv_nowait(void *source)
{
  /* assertion source */
  assert(source != NULL);
  struct _zmsg_t *self;
  self=zmsg_new();
  if(self == ((struct _zmsg_t *)NULL))
    return (struct _zmsg_t *)(void *)0;

  else
  {
    void *handle;
    handle=zsock_resolve(source);
    while((_Bool)1)
    {
      struct _zframe_t *frame;
      frame=zframe_recv_nowait(handle);
      if(frame == ((struct _zframe_t *)NULL))
      {
        zmsg_destroy(&self);
        break;
      }

      signed int return_value_zmsg_append_1;
      return_value_zmsg_append_1=zmsg_append(self, &frame);
      if(!(return_value_zmsg_append_1 == 0))
      {
        zmsg_destroy(&self);
        break;
      }

      signed int return_value_zsock_rcvmore_2;
      return_value_zsock_rcvmore_2=zsock_rcvmore(source);
      if(return_value_zsock_rcvmore_2 == 0)
        break;

    }
    return self;
  }
}

// zmsg_remove
// file src/zmsg.c line 480
void zmsg_remove(struct _zmsg_t *self, struct _zframe_t *frame)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  unsigned long int return_value_zframe_size_2;
  return_value_zframe_size_2=zframe_size(frame);
  self->content_size = self->content_size - return_value_zframe_size_2;
  zlist_remove(self->frames, (void *)frame);
}

// zmsg_save
// file src/zmsg.c line 536
signed int zmsg_save(struct _zmsg_t *self, struct _IO_FILE *file)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  /* assertion file */
  assert(file != ((struct _IO_FILE *)NULL));
  struct _zframe_t *frame;
  frame=zmsg_first(self);
  while(!(frame == ((struct _zframe_t *)NULL)))
  {
    unsigned long int frame_size;
    frame_size=zframe_size(frame);
    unsigned long int return_value_fwrite_2;
    return_value_fwrite_2=fwrite((const void *)&frame_size, sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1, file);
    if(!(return_value_fwrite_2 == 1ul))
      return -1;

    unsigned char *return_value_zframe_data_3;
    return_value_zframe_data_3=zframe_data(frame);
    unsigned long int return_value_fwrite_4;
    return_value_fwrite_4=fwrite((const void *)return_value_zframe_data_3, frame_size, (unsigned long int)1, file);
    if(!(return_value_fwrite_4 == 1ul))
      return -1;

    frame=zmsg_next(self);
  }
  return 0;
}

// zmsg_send
// file src/../include/zmsg.h line 45
signed int zmsg_send(struct _zmsg_t **self_p, void *dest)
{
  /* assertion self_p */
  assert(self_p != ((struct _zmsg_t **)NULL));
  /* assertion dest */
  assert(dest != NULL);
  struct _zmsg_t *self = *self_p;
  signed int rc = 0;
  void *handle;
  handle=zsock_resolve(dest);
  if(!(self == ((struct _zmsg_t *)NULL)))
  {
    _Bool return_value_zmsg_is_1;
    return_value_zmsg_is_1=zmsg_is((void *)self);
    /* assertion zmsg_is (self) */
    assert(return_value_zmsg_is_1 != (_Bool)0);
    struct _zframe_t *frame;
    void *return_value_zlist_pop_2;
    return_value_zlist_pop_2=zlist_pop(self->frames);
    frame = (struct _zframe_t *)return_value_zlist_pop_2;
    while(!(frame == ((struct _zframe_t *)NULL)))
    {
      unsigned long int return_value_zlist_size_3;
      return_value_zlist_size_3=zlist_size(self->frames);
      rc=zframe_send(&frame, handle, return_value_zlist_size_3 != 0ul ? 1 : 0);
      if(!(rc == 0))
        break;

      void *return_value_zlist_pop_4;
      return_value_zlist_pop_4=zlist_pop(self->frames);
      frame = (struct _zframe_t *)return_value_zlist_pop_4;
    }
    if(rc == 0)
      zmsg_destroy(self_p);

  }

  return rc;
}

// zmsg_sendm
// file src/zmsg.c line 158
signed int zmsg_sendm(struct _zmsg_t **self_p, void *dest)
{
  /* assertion self_p */
  assert(self_p != ((struct _zmsg_t **)NULL));
  /* assertion dest */
  assert(dest != NULL);
  struct _zmsg_t *self = *self_p;
  signed int rc = 0;
  void *handle;
  handle=zsock_resolve(dest);
  if(!(self == ((struct _zmsg_t *)NULL)))
  {
    _Bool return_value_zmsg_is_1;
    return_value_zmsg_is_1=zmsg_is((void *)self);
    /* assertion zmsg_is (self) */
    assert(return_value_zmsg_is_1 != (_Bool)0);
    struct _zframe_t *frame;
    void *return_value_zlist_pop_2;
    return_value_zlist_pop_2=zlist_pop(self->frames);
    frame = (struct _zframe_t *)return_value_zlist_pop_2;
    while(!(frame == ((struct _zframe_t *)NULL)))
    {
      rc=zframe_send(&frame, handle, 1);
      if(!(rc == 0))
        break;

      void *return_value_zlist_pop_3;
      return_value_zlist_pop_3=zlist_pop(self->frames);
      frame = (struct _zframe_t *)return_value_zlist_pop_3;
    }
    if(rc == 0)
      zmsg_destroy(self_p);

  }

  return rc;
}

// zmsg_signal
// file src/zmsg.c line 800
signed int zmsg_signal(struct _zmsg_t *self)
{
  unsigned long int return_value_zmsg_size_3;
  return_value_zmsg_size_3=zmsg_size(self);
  unsigned long int return_value_zmsg_content_size_2;
  if(return_value_zmsg_size_3 == 1ul)
  {
    return_value_zmsg_content_size_2=zmsg_content_size(self);
    if(return_value_zmsg_content_size_2 == 8ul)
    {
      struct _zframe_t *frame;
      frame=zmsg_first(self);
      signed long int signal_value;
      unsigned char *return_value_zframe_data_1;
      return_value_zframe_data_1=zframe_data(frame);
      signal_value = *((signed long int *)return_value_zframe_data_1);
      if((0xFFFFFFFFFFFFFF00L & (unsigned long int)signal_value) == 8603657889541918976ul)
        return (signed int)(signal_value & (signed long int)255);

    }

  }

  return -1;
}

// zmsg_size
// file src/zmsg.c line 185
unsigned long int zmsg_size(struct _zmsg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  _Bool return_value_zmsg_is_1;
  return_value_zmsg_is_1=zmsg_is((void *)self);
  /* assertion zmsg_is (self) */
  assert(return_value_zmsg_is_1 != (_Bool)0);
  unsigned long int return_value_zlist_size_2;
  return_value_zlist_size_2=zlist_size(self->frames);
  return return_value_zlist_size_2;
}

// zmsg_test
// file src/zmsg.c line 951
void zmsg_test(_Bool verbose)
{
  printf(" * zmsg: ");
  signed int rc = 0;
  struct _zsock_t *output;
  output=zsock_new_pair_checked("@inproc://zmsg.test", "src/zmsg.c", (unsigned long int)958);
  /* assertion output */
  assert(output != ((struct _zsock_t *)NULL));
  struct _zsock_t *input;
  input=zsock_new_pair_checked(">inproc://zmsg.test", "src/zmsg.c", (unsigned long int)960);
  /* assertion input */
  assert(input != ((struct _zsock_t *)NULL));
  struct _zmsg_t *msg;
  msg=zmsg_new();
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  struct _zframe_t *frame;
  frame=zframe_new((const void *)"Hello", (unsigned long int)5);
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  zmsg_prepend(msg, &frame);
  unsigned long int return_value_zmsg_size_1;
  return_value_zmsg_size_1=zmsg_size(msg);
  /* assertion zmsg_size (msg) == 1 */
  assert(return_value_zmsg_size_1 == (unsigned long int)1);
  unsigned long int return_value_zmsg_content_size_2;
  return_value_zmsg_content_size_2=zmsg_content_size(msg);
  /* assertion zmsg_content_size (msg) == 5 */
  assert(return_value_zmsg_content_size_2 == (unsigned long int)5);
  rc=zmsg_send(&msg, (void *)output);
  /* assertion msg == ((void *)0) */
  assert(msg == (struct _zmsg_t *)(void *)0);
  /* assertion rc == 0 */
  assert(rc == 0);
  msg=zmsg_recv((void *)input);
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  unsigned long int return_value_zmsg_size_3;
  return_value_zmsg_size_3=zmsg_size(msg);
  /* assertion zmsg_size (msg) == 1 */
  assert(return_value_zmsg_size_3 == (unsigned long int)1);
  unsigned long int return_value_zmsg_content_size_4;
  return_value_zmsg_content_size_4=zmsg_content_size(msg);
  /* assertion zmsg_content_size (msg) == 5 */
  assert(return_value_zmsg_content_size_4 == (unsigned long int)5);
  zmsg_destroy(&msg);
  msg=zmsg_new();
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  rc=zmsg_addmem(msg, (const void *)"Frame0", (unsigned long int)6);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)"Frame1", (unsigned long int)6);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)"Frame2", (unsigned long int)6);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)"Frame3", (unsigned long int)6);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)"Frame4", (unsigned long int)6);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)"Frame5", (unsigned long int)6);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)"Frame6", (unsigned long int)6);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)"Frame7", (unsigned long int)6);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)"Frame8", (unsigned long int)6);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)"Frame9", (unsigned long int)6);
  /* assertion rc == 0 */
  assert(rc == 0);
  struct _zmsg_t *copy;
  copy=zmsg_dup(msg);
  /* assertion copy */
  assert(copy != ((struct _zmsg_t *)NULL));
  rc=zmsg_send(&copy, (void *)output);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_send(&msg, (void *)output);
  /* assertion rc == 0 */
  assert(rc == 0);
  copy=zmsg_recv((void *)input);
  /* assertion copy */
  assert(copy != ((struct _zmsg_t *)NULL));
  unsigned long int return_value_zmsg_size_5;
  return_value_zmsg_size_5=zmsg_size(copy);
  /* assertion zmsg_size (copy) == 10 */
  assert(return_value_zmsg_size_5 == (unsigned long int)10);
  unsigned long int return_value_zmsg_content_size_6;
  return_value_zmsg_content_size_6=zmsg_content_size(copy);
  /* assertion zmsg_content_size (copy) == 60 */
  assert(return_value_zmsg_content_size_6 == (unsigned long int)60);
  zmsg_destroy(&copy);
  msg=zmsg_recv((void *)input);
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  unsigned long int return_value_zmsg_size_7;
  return_value_zmsg_size_7=zmsg_size(msg);
  /* assertion zmsg_size (msg) == 10 */
  assert(return_value_zmsg_size_7 == (unsigned long int)10);
  unsigned long int return_value_zmsg_content_size_8;
  return_value_zmsg_content_size_8=zmsg_content_size(msg);
  /* assertion zmsg_content_size (msg) == 60 */
  assert(return_value_zmsg_content_size_8 == (unsigned long int)60);
  struct _IO_FILE *file;
  file=fopen("zmsg.test", "w");
  /* assertion file */
  assert(file != ((struct _IO_FILE *)NULL));
  fclose(file);
  file=fopen("zmsg.test", "r");
  struct _zmsg_t *null_msg;
  null_msg=zmsg_load((struct _zmsg_t *)(void *)0, file);
  /* assertion null_msg == ((void *)0) */
  assert(null_msg == (struct _zmsg_t *)(void *)0);
  fclose(file);
  remove("zmsg.test");
  file=fopen("zmsg.test", "w");
  /* assertion file */
  assert(file != ((struct _IO_FILE *)NULL));
  rc=zmsg_save(msg, file);
  /* assertion rc == 0 */
  assert(rc == 0);
  fclose(file);
  file=fopen("zmsg.test", "r");
  rc=zmsg_save(msg, file);
  /* assertion rc == -1 */
  assert(rc == -1);
  fclose(file);
  zmsg_destroy(&msg);
  file=fopen("zmsg.test", "r");
  msg=zmsg_load((struct _zmsg_t *)(void *)0, file);
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  fclose(file);
  remove("zmsg.test");
  unsigned long int return_value_zmsg_size_9;
  return_value_zmsg_size_9=zmsg_size(msg);
  /* assertion zmsg_size (msg) == 10 */
  assert(return_value_zmsg_size_9 == (unsigned long int)10);
  unsigned long int return_value_zmsg_content_size_10;
  return_value_zmsg_content_size_10=zmsg_content_size(msg);
  /* assertion zmsg_content_size (msg) == 60 */
  assert(return_value_zmsg_content_size_10 == (unsigned long int)60);
  signed int frame_nbr = 0;
  for( ; !(frame_nbr >= 8); frame_nbr = frame_nbr + 1)
  {
    zmsg_first(msg);
    frame=zmsg_next(msg);
    zmsg_remove(msg, frame);
    zframe_destroy(&frame);
  }
  unsigned long int return_value_zmsg_size_11;
  return_value_zmsg_size_11=zmsg_size(msg);
  /* assertion zmsg_size (msg) == 2 */
  assert(return_value_zmsg_size_11 == (unsigned long int)2);
  frame=zmsg_last(msg);
  _Bool return_value_zframe_streq_12;
  return_value_zframe_streq_12=zframe_streq(frame, "Frame9");
  /* assertion zframe_streq (frame, "Frame9") */
  assert(return_value_zframe_streq_12 != (_Bool)0);
  unsigned long int return_value_zmsg_content_size_13;
  return_value_zmsg_content_size_13=zmsg_content_size(msg);
  /* assertion zmsg_content_size (msg) == 12 */
  assert(return_value_zmsg_content_size_13 == (unsigned long int)12);
  frame=zframe_new((const void *)"Address", (unsigned long int)7);
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  zmsg_prepend(msg, &frame);
  unsigned long int return_value_zmsg_size_14;
  return_value_zmsg_size_14=zmsg_size(msg);
  /* assertion zmsg_size (msg) == 3 */
  assert(return_value_zmsg_size_14 == (unsigned long int)3);
  rc=zmsg_addstr(msg, "Body");
  /* assertion rc == 0 */
  assert(rc == 0);
  unsigned long int return_value_zmsg_size_15;
  return_value_zmsg_size_15=zmsg_size(msg);
  /* assertion zmsg_size (msg) == 4 */
  assert(return_value_zmsg_size_15 == (unsigned long int)4);
  frame=zmsg_pop(msg);
  zframe_destroy(&frame);
  unsigned long int return_value_zmsg_size_16;
  return_value_zmsg_size_16=zmsg_size(msg);
  /* assertion zmsg_size (msg) == 3 */
  assert(return_value_zmsg_size_16 == (unsigned long int)3);
  char *body;
  body=zmsg_popstr(msg);
  signed int return_value_strcmp_17;
  return_value_strcmp_17=strcmp(body, "Frame0");
  /* assertion (!strcmp ((body), ("Frame0"))) */
  assert(!(return_value_strcmp_17 != 0));
  free((void *)body);
  zmsg_destroy(&msg);
  msg=zmsg_new();
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  unsigned char *blank;
  void *return_value_safe_malloc_18;
  return_value_safe_malloc_18=safe_malloc_link19((unsigned long int)100000, "src/zmsg.c", (unsigned int)1085);
  blank = (unsigned char *)return_value_safe_malloc_18;
  /* assertion blank */
  assert(blank != ((unsigned char *)NULL));
  rc=zmsg_addmem(msg, (const void *)blank, (unsigned long int)0);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)blank, (unsigned long int)1);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)blank, (unsigned long int)253);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)blank, (unsigned long int)254);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)blank, (unsigned long int)255);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)blank, (unsigned long int)256);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)blank, (unsigned long int)65535);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)blank, (unsigned long int)65536);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmsg_addmem(msg, (const void *)blank, (unsigned long int)65537);
  /* assertion rc == 0 */
  assert(rc == 0);
  free((void *)blank);
  unsigned long int return_value_zmsg_size_19;
  return_value_zmsg_size_19=zmsg_size(msg);
  /* assertion zmsg_size (msg) == 9 */
  assert(return_value_zmsg_size_19 == (unsigned long int)9);
  unsigned char *buffer;
  unsigned long int buffer_size;
  buffer_size=zmsg_encode(msg, &buffer);
  zmsg_destroy(&msg);
  msg=zmsg_decode(buffer, buffer_size);
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  free((void *)buffer);
  zmsg_destroy(&msg);
  msg=zmsg_new();
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  struct _zmsg_t *submsg;
  submsg=zmsg_new();
  zmsg_pushstr(msg, "matr");
  zmsg_pushstr(submsg, "joska");
  rc=zmsg_addmsg(msg, &submsg);
  /* assertion rc == 0 */
  assert(rc == 0);
  /* assertion submsg == ((void *)0) */
  assert(submsg == (struct _zmsg_t *)(void *)0);
  submsg=zmsg_popmsg(msg);
  /* assertion submsg == ((void *)0) */
  assert(submsg == (struct _zmsg_t *)(void *)0);
  submsg=zmsg_popmsg(msg);
  /* assertion submsg */
  assert(submsg != ((struct _zmsg_t *)NULL));
  body=zmsg_popstr(submsg);
  signed int return_value_strcmp_20;
  return_value_strcmp_20=strcmp(body, "joska");
  /* assertion (!strcmp ((body), ("joska"))) */
  assert(!(return_value_strcmp_20 != 0));
  free((void *)body);
  zmsg_destroy(&submsg);
  frame=zmsg_pop(msg);
  /* assertion frame == ((void *)0) */
  assert(frame == (struct _zframe_t *)(void *)0);
  zmsg_destroy(&msg);
  msg=zmsg_new();
  zmsg_addstr(msg, "One");
  zmsg_addstr(msg, "Two");
  zmsg_addstr(msg, "Three");
  struct _zmsg_t *msg_other;
  msg_other=zmsg_new();
  zmsg_addstr(msg_other, "One");
  zmsg_addstr(msg_other, "Two");
  zmsg_addstr(msg_other, "One-Hundred");
  struct _zmsg_t *msg_dup;
  msg_dup=zmsg_dup(msg);
  struct _zmsg_t *empty_msg;
  empty_msg=zmsg_new();
  struct _zmsg_t *empty_msg_2;
  empty_msg_2=zmsg_new();
  _Bool return_value_zmsg_eq_21;
  return_value_zmsg_eq_21=zmsg_eq(msg, msg_dup);
  /* assertion zmsg_eq (msg, msg_dup) */
  assert(return_value_zmsg_eq_21 != (_Bool)0);
  _Bool return_value_zmsg_eq_22;
  return_value_zmsg_eq_22=zmsg_eq(msg, msg_other);
  /* assertion !zmsg_eq (msg, msg_other) */
  assert(!(return_value_zmsg_eq_22 != (_Bool)0));
  _Bool return_value_zmsg_eq_23;
  return_value_zmsg_eq_23=zmsg_eq(empty_msg, empty_msg_2);
  /* assertion zmsg_eq (empty_msg, empty_msg_2) */
  assert(return_value_zmsg_eq_23 != (_Bool)0);
  _Bool return_value_zmsg_eq_24;
  return_value_zmsg_eq_24=zmsg_eq(msg, (struct _zmsg_t *)(void *)0);
  /* assertion !zmsg_eq (msg, ((void *)0)) */
  assert(!(return_value_zmsg_eq_24 != (_Bool)0));
  _Bool return_value_zmsg_eq_25;
  return_value_zmsg_eq_25=zmsg_eq((struct _zmsg_t *)(void *)0, empty_msg);
  /* assertion !zmsg_eq (((void *)0), empty_msg) */
  assert(!(return_value_zmsg_eq_25 != (_Bool)0));
  _Bool return_value_zmsg_eq_26;
  return_value_zmsg_eq_26=zmsg_eq((struct _zmsg_t *)(void *)0, (struct _zmsg_t *)(void *)0);
  /* assertion !zmsg_eq (((void *)0), ((void *)0)) */
  assert(!(return_value_zmsg_eq_26 != (_Bool)0));
  zmsg_destroy(&msg);
  zmsg_destroy(&msg_other);
  zmsg_destroy(&msg_dup);
  zmsg_destroy(&empty_msg);
  zmsg_destroy(&empty_msg_2);
  msg=zmsg_new_signal((unsigned char)0);
  signed int return_value_zmsg_signal_27;
  return_value_zmsg_signal_27=zmsg_signal(msg);
  /* assertion zmsg_signal (msg) == 0 */
  assert(return_value_zmsg_signal_27 == 0);
  zmsg_destroy(&msg);
  msg=zmsg_new_signal((unsigned char)-1);
  signed int return_value_zmsg_signal_28;
  return_value_zmsg_signal_28=zmsg_signal(msg);
  /* assertion zmsg_signal (msg) == 255 */
  assert(return_value_zmsg_signal_28 == 255);
  zmsg_destroy(&msg);
  msg=zmsg_new();
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  unsigned long int return_value_zmsg_size_29;
  return_value_zmsg_size_29=zmsg_size(msg);
  /* assertion zmsg_size (msg) == 0 */
  assert(return_value_zmsg_size_29 == (unsigned long int)0);
  struct _zframe_t *return_value_zmsg_unwrap_30;
  return_value_zmsg_unwrap_30=zmsg_unwrap(msg);
  /* assertion zmsg_unwrap (msg) == ((void *)0) */
  assert(return_value_zmsg_unwrap_30 == (struct _zframe_t *)(void *)0);
  struct _zframe_t *return_value_zmsg_first_31;
  return_value_zmsg_first_31=zmsg_first(msg);
  /* assertion zmsg_first (msg) == ((void *)0) */
  assert(return_value_zmsg_first_31 == (struct _zframe_t *)(void *)0);
  struct _zframe_t *return_value_zmsg_last_32;
  return_value_zmsg_last_32=zmsg_last(msg);
  /* assertion zmsg_last (msg) == ((void *)0) */
  assert(return_value_zmsg_last_32 == (struct _zframe_t *)(void *)0);
  struct _zframe_t *return_value_zmsg_next_33;
  return_value_zmsg_next_33=zmsg_next(msg);
  /* assertion zmsg_next (msg) == ((void *)0) */
  assert(return_value_zmsg_next_33 == (struct _zframe_t *)(void *)0);
  struct _zframe_t *return_value_zmsg_pop_34;
  return_value_zmsg_pop_34=zmsg_pop(msg);
  /* assertion zmsg_pop (msg) == ((void *)0) */
  assert(return_value_zmsg_pop_34 == (struct _zframe_t *)(void *)0);
  signed int return_value_zmsg_send_35;
  return_value_zmsg_send_35=zmsg_send(&msg, (void *)output);
  /* assertion zmsg_send (&msg, output) == 0 */
  assert(return_value_zmsg_send_35 == 0);
  /* assertion !msg */
  assert(!(msg != ((struct _zmsg_t *)NULL)));
  zsock_destroy_checked(&input, "src/zmsg.c", (unsigned long int)1181);
  zsock_destroy_checked(&output, "src/zmsg.c", (unsigned long int)1182);
  printf("OK\n");
}

// zmsg_unwrap
// file src/zmsg.c line 830
struct _zframe_t * zmsg_unwrap(struct _zmsg_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  struct _zframe_t *frame;
  frame=zmsg_pop(self);
  struct _zframe_t *empty;
  empty=zmsg_first(self);
  unsigned long int return_value_zframe_size_1;
  if(!(empty == ((struct _zframe_t *)NULL)))
  {
    return_value_zframe_size_1=zframe_size(empty);
    if(return_value_zframe_size_1 == 0ul)
    {
      empty=zmsg_pop(self);
      zframe_destroy(&empty);
    }

  }

  return frame;
}

// zmsg_wrap
// file src/zmsg.c line 880
void zmsg_wrap(struct _zmsg_t *self, struct _zframe_t *frame)
{
  /* assertion self */
  assert(self != ((struct _zmsg_t *)NULL));
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  signed int return_value_zmsg_pushmem_1;
  return_value_zmsg_pushmem_1=zmsg_pushmem(self, (const void *)"", (unsigned long int)0);
  if(return_value_zmsg_pushmem_1 == 0)
    zmsg_push(self, frame);

}

// zmutex_destroy
// file src/../include/zmutex.h line 28
void zmutex_destroy(struct _zmutex_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zmutex_t **)NULL));
  if(!(*self_p == ((struct _zmutex_t *)NULL)))
  {
    struct _zmutex_t *self = *self_p;
    pthread_mutex_destroy(&self->mutex);
    free((void *)self);
    *self_p = (struct _zmutex_t *)(void *)0;
  }

}

// zmutex_lock
// file src/../include/zmutex.h line 32
void zmutex_lock(struct _zmutex_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmutex_t *)NULL));
  pthread_mutex_lock(&self->mutex);
}

// zmutex_new
// file src/../include/zmutex.h line 24
struct _zmutex_t * zmutex_new(void)
{
  struct _zmutex_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link34(sizeof(struct _zmutex_t) /*40ul*/ , "src/zmutex.c", (unsigned int)44);
  self = (struct _zmutex_t *)return_value_safe_malloc_1;
  if(self == ((struct _zmutex_t *)NULL))
    return (struct _zmutex_t *)(void *)0;

  else
  {
    signed int return_value_pthread_mutex_init_2;
    return_value_pthread_mutex_init_2=pthread_mutex_init(&self->mutex, (const union anonymous_4 *)(void *)0);
    if(!(return_value_pthread_mutex_init_2 == 0))
    {
      free((void *)self);
      return (struct _zmutex_t *)(void *)0;
    }

    else
      return self;
  }
}

// zmutex_test
// file src/zmutex.c line 135
void zmutex_test(_Bool verbose)
{
  printf(" * zmutex (deprecated): ");
  struct _zmutex_t *mutex;
  mutex=zmutex_new();
  /* assertion mutex */
  assert(mutex != ((struct _zmutex_t *)NULL));
  zmutex_lock(mutex);
  zmutex_unlock(mutex);
  zmutex_destroy(&mutex);
  printf("OK\n");
}

// zmutex_try_lock
// file src/zmutex.c line 117
signed int zmutex_try_lock(struct _zmutex_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmutex_t *)NULL));
  signed int rc;
  rc=pthread_mutex_trylock(&self->mutex);
  return rc == 16 ? 0 : 1;
}

// zmutex_unlock
// file src/../include/zmutex.h line 36
void zmutex_unlock(struct _zmutex_t *self)
{
  /* assertion self */
  assert(self != ((struct _zmutex_t *)NULL));
  pthread_mutex_unlock(&self->mutex);
}

// zpoller_add
// file src/../include/zpoller.h line 34
signed int zpoller_add(struct _zpoller_t *self, void *reader)
{
  /* assertion self */
  assert(self != ((struct _zpoller_t *)NULL));
  /* assertion reader */
  assert(reader != NULL);
  signed int rc;
  rc=zlist_append(self->reader_list, reader);
  self->need_rebuild = (_Bool)1;
  return rc;
}

// zpoller_destroy
// file src/../include/zpoller.h line 29
void zpoller_destroy(struct _zpoller_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zpoller_t **)NULL));
  if(!(*self_p == ((struct _zpoller_t *)NULL)))
  {
    struct _zpoller_t *self = *self_p;
    zlist_destroy(&self->reader_list);
    free((void *)self->poll_readers);
    free((void *)self->poll_set);
    free((void *)self);
    *self_p = (struct _zpoller_t *)(void *)0;
  }

}

// zpoller_expired
// file src/zpoller.c line 210
_Bool zpoller_expired(struct _zpoller_t *self)
{
  /* assertion self */
  assert(self != ((struct _zpoller_t *)NULL));
  return self->expired;
}

// zpoller_ignore_interrupts
// file src/zpoller.c line 234
void zpoller_ignore_interrupts(struct _zpoller_t *self)
{
  /* assertion self */
  assert(self != ((struct _zpoller_t *)NULL));
  self->ignore_interrupts = (_Bool)1;
}

// zpoller_new
// file src/../include/zpoller.h line 25
struct _zpoller_t * zpoller_new(void *reader, ...)
{
  struct _zpoller_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link20(sizeof(struct _zpoller_t) /*40ul*/ , "src/zpoller.c", (unsigned int)49);
  self = (struct _zpoller_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _zpoller_t *)NULL)))
  {
    self->reader_list=zlist_new();
    if(!(self->reader_list == ((struct _zlist_t *)NULL)))
    {
      self->need_rebuild = (_Bool)1;
      __builtin_va_list args;
      va_start(args, reader);
      while(!(reader == NULL))
      {
        signed int return_value_zlist_append_2;
        return_value_zlist_append_2=zlist_append(self->reader_list, reader);
        if(!(return_value_zlist_append_2 == 0))
        {
          zpoller_destroy(&self);
          break;
        }

        reader=va_arg(args, __typeof__(reader));
      }
      va_end(args);
    }

    else
      zpoller_destroy(&self);
  }

  return self;
}

// zpoller_remove
// file src/zpoller.c line 112
signed int zpoller_remove(struct _zpoller_t *self, void *reader)
{
  /* assertion self */
  assert(self != ((struct _zpoller_t *)NULL));
  /* assertion reader */
  assert(reader != NULL);
  zlist_remove(self->reader_list, reader);
  self->need_rebuild = (_Bool)1;
  return 0;
}

// zpoller_terminated
// file src/../include/zpoller.h line 62
_Bool zpoller_terminated(struct _zpoller_t *self)
{
  /* assertion self */
  assert(self != ((struct _zpoller_t *)NULL));
  return self->terminated;
}

// zpoller_test
// file src/zpoller.c line 244
void zpoller_test(_Bool verbose)
{
  printf(" * zpoller: ");
  struct _zsock_t *vent;
  vent=zsock_new_checked(8, "src/zpoller.c", (unsigned long int)250);
  /* assertion vent */
  assert(vent != ((struct _zsock_t *)NULL));
  signed int port_nbr;
  port_nbr=zsock_bind(vent, "tcp://127.0.0.1:*");
  /* assertion port_nbr != -1 */
  assert(port_nbr != -1);
  struct _zsock_t *sink;
  sink=zsock_new_checked(7, "src/zpoller.c", (unsigned long int)254);
  /* assertion sink */
  assert(sink != ((struct _zsock_t *)NULL));
  signed int rc;
  rc=zsock_connect(sink, "tcp://127.0.0.1:%d", port_nbr);
  /* assertion rc != -1 */
  assert(rc != -1);
  struct _zsock_t *bowl;
  bowl=zsock_new_checked(7, "src/zpoller.c", (unsigned long int)258);
  /* assertion bowl */
  assert(bowl != ((struct _zsock_t *)NULL));
  struct _zsock_t *dish;
  dish=zsock_new_checked(7, "src/zpoller.c", (unsigned long int)260);
  /* assertion dish */
  assert(dish != ((struct _zsock_t *)NULL));
  struct _zpoller_t *poller;
  poller=zpoller_new((void *)bowl, dish, (void *)0);
  /* assertion poller */
  assert(poller != ((struct _zpoller_t *)NULL));
  rc=zpoller_add(poller, (void *)sink);
  /* assertion rc == 0 */
  assert(rc == 0);
  zstr_send((void *)vent, "Hello, World");
  struct _zsock_t *which;
  void *return_value_zpoller_wait_1;
  return_value_zpoller_wait_1=zpoller_wait(poller, -1);
  which = (struct _zsock_t *)return_value_zpoller_wait_1;
  /* assertion which == sink */
  assert(which == sink);
  _Bool return_value_zpoller_expired_2;
  return_value_zpoller_expired_2=zpoller_expired(poller);
  /* assertion zpoller_expired (poller) == 0 */
  assert((signed int)return_value_zpoller_expired_2 == 0);
  _Bool return_value_zpoller_terminated_3;
  return_value_zpoller_terminated_3=zpoller_terminated(poller);
  /* assertion zpoller_terminated (poller) == 0 */
  assert((signed int)return_value_zpoller_terminated_3 == 0);
  char *message;
  message=zstr_recv((void *)which);
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(message, "Hello, World");
  /* assertion (!strcmp ((message), ("Hello, World"))) */
  assert(!(return_value_strcmp_4 != 0));
  zstr_free(&message);
  rc=zpoller_remove(poller, (void *)sink);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsock_connect(bowl, "tcp://127.0.0.1:%d", port_nbr);
  /* assertion rc != -1 */
  assert(rc != -1);
  signed int fd;
  fd=zsock_fd((void *)bowl);
  rc=zpoller_add(poller, (void *)&fd);
  /* assertion rc != -1 */
  assert(rc != -1);
  zstr_send((void *)vent, "Hello again, world");
  void *return_value_zpoller_wait_5;
  return_value_zpoller_wait_5=zpoller_wait(poller, 500);
  /* assertion zpoller_wait (poller, 500) == &fd */
  assert((signed int *)return_value_zpoller_wait_5 == &fd);
  zsys_interrupted = 1;
  zpoller_wait(poller, 0);
  _Bool return_value_zpoller_terminated_6;
  return_value_zpoller_terminated_6=zpoller_terminated(poller);
  /* assertion zpoller_terminated (poller) */
  assert(return_value_zpoller_terminated_6 != (_Bool)0);
  zpoller_ignore_interrupts(poller);
  zpoller_wait(poller, 0);
  _Bool return_value_zpoller_terminated_7;
  return_value_zpoller_terminated_7=zpoller_terminated(poller);
  /* assertion !zpoller_terminated (poller) */
  assert(!(return_value_zpoller_terminated_7 != (_Bool)0));
  zsys_interrupted = 0;
  zpoller_destroy(&poller);
  zsock_destroy_checked(&vent, "src/zpoller.c", (unsigned long int)308);
  zsock_destroy_checked(&sink, "src/zpoller.c", (unsigned long int)309);
  zsock_destroy_checked(&bowl, "src/zpoller.c", (unsigned long int)310);
  zsock_destroy_checked(&dish, "src/zpoller.c", (unsigned long int)311);
  printf("OK\n");
}

// zpoller_wait
// file src/../include/zpoller.h line 52
void * zpoller_wait(struct _zpoller_t *self, signed int timeout)
{
  self->expired = (_Bool)0;
  if(self->ignore_interrupts == (_Bool)0 && !(zsys_interrupted == 0))
  {
    self->terminated = (_Bool)1;
    return (void *)0;
  }

  else
    self->terminated = (_Bool)0;
  if(!(self->need_rebuild == (_Bool)0))
    s_rebuild_poll_set(self);

  signed int rc;
  rc=zmq_poll(self->poll_set, (signed int)self->poll_size, (signed long int)(timeout * 1));
  if(rc >= 1)
  {
    unsigned int reader = (unsigned int)0;
    reader = (unsigned int)0;
    for( ; !((unsigned long int)reader >= self->poll_size); reader = reader + 1u)
      if(!((1 & (signed int)(self->poll_set + (signed long int)reader)->revents) == 0))
        return self->poll_readers[(signed long int)reader];

  }

  else
  {
    _Bool tmp_if_expr_1;
    if(rc == -1)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (!(self->ignore_interrupts != (_Bool)0) ? (zsys_interrupted != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      self->terminated = (_Bool)1;

    else
      if(rc == 0)
        self->expired = (_Bool)1;

  }
  return (void *)0;
}

// zproxy
// file src/zproxy.c line 220
void zproxy(struct _zsock_t *pipe, void *unused)
{
  struct anonymous_35 *self;
  self=s_self_new_link3(pipe);
  /* assertion self */
  assert(self != ((struct anonymous_35 *)NULL));
  zsock_signal((void *)pipe, (unsigned char)0);
  while(self->terminated == (_Bool)0)
  {
    struct _zsock_t *which;
    void *return_value_zpoller_wait_1;
    return_value_zpoller_wait_1=zpoller_wait(self->poller, -1);
    which = (struct _zsock_t *)return_value_zpoller_wait_1;
    _Bool return_value_zpoller_terminated_2;
    return_value_zpoller_terminated_2=zpoller_terminated(self->poller);
    if(!(return_value_zpoller_terminated_2 == (_Bool)0))
      break;

    else
      if(which == self->pipe)
        s_self_handle_pipe_link3(self);

      else
        if(which == self->frontend)
          s_self_switch(self, self->frontend, self->backend);

        else
          if(which == self->backend)
            s_self_switch(self, self->backend, self->frontend);

  }
  s_self_destroy_link3(&self);
}

// zproxy_capture
// file src/zproxy_v2.c line 96
void zproxy_capture(struct _zproxy_t *self, const char *endpoint)
{
  /* assertion self */
  assert(self != ((struct _zproxy_t *)NULL));
  zstr_sendm(self->pipe, "CAPTURE");
  zstr_send(self->pipe, endpoint);
  zsocket_wait(self->pipe);
}

// zproxy_destroy
// file src/zproxy_v2.c line 75
void zproxy_destroy(struct _zproxy_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zproxy_t **)NULL));
  if(!(*self_p == ((struct _zproxy_t *)NULL)))
  {
    struct _zproxy_t *self = *self_p;
    if(!(self->pipe == NULL))
    {
      zstr_send(self->pipe, "STOP");
      zsocket_wait(self->pipe);
    }

    free((void *)self);
    *self_p = (struct _zproxy_t *)(void *)0;
  }

}

// zproxy_new
// file src/zproxy_v2.c line 51
struct _zproxy_t * zproxy_new(struct _zctx_t *ctx, void *frontend, void *backend)
{
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  struct _zproxy_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link35(sizeof(struct _zproxy_t) /*32ul*/ , "src/zproxy_v2.c", (unsigned int)54);
  self = (struct _zproxy_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _zproxy_t *)NULL)))
  {
    self->ctx = ctx;
    self->frontend = frontend;
    self->backend = backend;
    self->pipe=zthread_fork(ctx, s_proxy_task, (void *)self);
    if(!(self->pipe == NULL))
      zsocket_wait(self->pipe);

    else
      zproxy_destroy(&self);
  }

  return self;
}

// zproxy_pause
// file src/zproxy_v2.c line 112
void zproxy_pause(struct _zproxy_t *self)
{
  /* assertion self */
  assert(self != ((struct _zproxy_t *)NULL));
  zstr_send(self->pipe, "PAUSE");
  zsocket_wait(self->pipe);
}

// zproxy_resume
// file src/zproxy_v2.c line 124
void zproxy_resume(struct _zproxy_t *self)
{
  /* assertion self */
  assert(self != ((struct _zproxy_t *)NULL));
  zstr_send(self->pipe, "RESUME");
  zsocket_wait(self->pipe);
}

// zproxy_test
// file src/zproxy.c line 249
void zproxy_test(_Bool verbose)
{
  printf(" * zproxy: ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  struct _zactor_t *proxy;
  proxy=zactor_new(zproxy, (void *)0);
  /* assertion proxy */
  assert(proxy != ((struct _zactor_t *)NULL));
  if(!(verbose == (_Bool)0))
  {
    zstr_sendx((void *)proxy, "VERBOSE", (void *)0);
    zsock_wait((void *)proxy);
  }

  zstr_sendx((void *)proxy, "FRONTEND", (const void *)"PULL", (const void *)"inproc://frontend", (void *)0);
  zsock_wait((void *)proxy);
  zstr_sendx((void *)proxy, "BACKEND", (const void *)"PUSH", (const void *)"inproc://backend", (void *)0);
  zsock_wait((void *)proxy);
  struct _zsock_t *faucet;
  faucet=zsock_new_push_checked(">inproc://frontend", "src/zproxy.c", (unsigned long int)269);
  /* assertion faucet */
  assert(faucet != ((struct _zsock_t *)NULL));
  struct _zsock_t *sink;
  sink=zsock_new_pull_checked(">inproc://backend", "src/zproxy.c", (unsigned long int)271);
  /* assertion sink */
  assert(sink != ((struct _zsock_t *)NULL));
  char *hello;
  char *world;
  zstr_sendx((void *)faucet, "Hello", (const void *)"World", (void *)0);
  zstr_recvx((void *)sink, &hello, &world, (void *)0);
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(hello, "Hello");
  /* assertion (!strcmp ((hello), ("Hello"))) */
  assert(!(return_value_strcmp_1 != 0));
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(world, "World");
  /* assertion (!strcmp ((world), ("World"))) */
  assert(!(return_value_strcmp_2 != 0));
  zstr_free(&hello);
  zstr_free(&world);
  zstr_sendx((void *)proxy, "PAUSE", (void *)0);
  zsock_wait((void *)proxy);
  zstr_sendx((void *)faucet, "Hello", (const void *)"World", (void *)0);
  zsock_set_rcvtimeo((void *)sink, 100);
  zstr_recvx((void *)sink, &hello, &world, (void *)0);
  /* assertion !hello && !world */
  assert(!(hello != ((char *)NULL)) && !(world != ((char *)NULL)));
  zstr_sendx((void *)proxy, "RESUME", (void *)0);
  zsock_wait((void *)proxy);
  zstr_recvx((void *)sink, &hello, &world, (void *)0);
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(hello, "Hello");
  /* assertion (!strcmp ((hello), ("Hello"))) */
  assert(!(return_value_strcmp_3 != 0));
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(world, "World");
  /* assertion (!strcmp ((world), ("World"))) */
  assert(!(return_value_strcmp_4 != 0));
  zstr_free(&hello);
  zstr_free(&world);
  struct _zsock_t *capture;
  capture=zsock_new_pull_checked("inproc://capture", "src/zproxy.c", (unsigned long int)300);
  /* assertion capture */
  assert(capture != ((struct _zsock_t *)NULL));
  zstr_sendx((void *)proxy, "CAPTURE", (const void *)"inproc://capture", (void *)0);
  zsock_wait((void *)proxy);
  zstr_sendx((void *)faucet, "Hello", (const void *)"World", (void *)0);
  zstr_recvx((void *)sink, &hello, &world, (void *)0);
  signed int return_value_strcmp_5;
  return_value_strcmp_5=strcmp(hello, "Hello");
  /* assertion (!strcmp ((hello), ("Hello"))) */
  assert(!(return_value_strcmp_5 != 0));
  signed int return_value_strcmp_6;
  return_value_strcmp_6=strcmp(world, "World");
  /* assertion (!strcmp ((world), ("World"))) */
  assert(!(return_value_strcmp_6 != 0));
  zstr_free(&hello);
  zstr_free(&world);
  zstr_recvx((void *)capture, &hello, &world, (void *)0);
  signed int return_value_strcmp_7;
  return_value_strcmp_7=strcmp(hello, "Hello");
  /* assertion (!strcmp ((hello), ("Hello"))) */
  assert(!(return_value_strcmp_7 != 0));
  signed int return_value_strcmp_8;
  return_value_strcmp_8=strcmp(world, "World");
  /* assertion (!strcmp ((world), ("World"))) */
  assert(!(return_value_strcmp_8 != 0));
  zstr_free(&hello);
  zstr_free(&world);
  zsock_destroy_checked(&faucet, "src/zproxy.c", (unsigned long int)319);
  zsock_destroy_checked(&sink, "src/zproxy.c", (unsigned long int)320);
  zsock_destroy_checked(&capture, "src/zproxy.c", (unsigned long int)321);
  zactor_destroy(&proxy);
  printf("OK\n");
}

// zproxy_v2_test
// file src/zproxy_v2.c line 234
void zproxy_v2_test(_Bool verbose)
{
  printf(" * zproxy (deprecated): ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  struct _zctx_t *ctx;
  ctx=zctx_new();
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  void *frontend;
  frontend=zsocket_new(ctx, 7);
  /* assertion frontend */
  assert(frontend != NULL);
  signed int rc;
  rc=zsocket_bind(frontend, "inproc://frontend");
  /* assertion rc == 0 */
  assert(rc == 0);
  void *backend;
  backend=zsocket_new(ctx, 8);
  /* assertion backend */
  assert(backend != NULL);
  rc=zsocket_bind(backend, "inproc://backend");
  /* assertion rc == 0 */
  assert(rc == 0);
  struct _zproxy_t *proxy;
  proxy=zproxy_new(ctx, frontend, backend);
  /* assertion proxy */
  assert(proxy != ((struct _zproxy_t *)NULL));
  void *faucet;
  faucet=zsocket_new(ctx, 8);
  /* assertion faucet */
  assert(faucet != NULL);
  rc=zsocket_connect(faucet, "inproc://frontend");
  /* assertion rc == 0 */
  assert(rc == 0);
  void *sink;
  sink=zsocket_new(ctx, 7);
  /* assertion sink */
  assert(sink != NULL);
  rc=zsocket_connect(sink, "inproc://backend");
  /* assertion rc == 0 */
  assert(rc == 0);
  zstr_send(faucet, "Hello");
  char *string;
  string=zstr_recv(sink);
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(string, "Hello");
  /* assertion (!strcmp ((string), ("Hello"))) */
  assert(!(return_value_strcmp_1 != 0));
  zstr_free(&string);
  zproxy_pause(proxy);
  zstr_send(faucet, "World");
  zproxy_resume(proxy);
  string=zstr_recv(sink);
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(string, "World");
  /* assertion (!strcmp ((string), ("World"))) */
  assert(!(return_value_strcmp_2 != 0));
  zstr_free(&string);
  void *capture;
  capture=zsocket_new(ctx, 7);
  /* assertion capture */
  assert(capture != NULL);
  rc=zsocket_bind(capture, "inproc://capture");
  /* assertion rc == 0 */
  assert(rc == 0);
  zproxy_capture(proxy, "inproc://capture");
  zstr_send(faucet, "Hello");
  string=zstr_recv(sink);
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(string, "Hello");
  /* assertion (!strcmp ((string), ("Hello"))) */
  assert(!(return_value_strcmp_3 != 0));
  zstr_free(&string);
  string=zstr_recv(capture);
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(string, "Hello");
  /* assertion (!strcmp ((string), ("Hello"))) */
  assert(!(return_value_strcmp_4 != 0));
  zstr_free(&string);
  zproxy_destroy(&proxy);
  zctx_destroy(&ctx);
  printf("OK\n");
}

// zrex_destroy
// file src/../include/zrex.h line 31
void zrex_destroy(struct _zrex_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zrex_t **)NULL));
  if(!(*self_p == ((struct _zrex_t *)NULL)))
  {
    struct _zrex_t *self = *self_p;
    zstr_free(&self->hit_set);
    free((void *)self);
    *self_p = (struct _zrex_t *)(void *)0;
  }

}

// zrex_eq
// file src/zrex.c line 179
_Bool zrex_eq(struct _zrex_t *self, const char *text, const char *expression)
{
  /* assertion self */
  assert(self != ((struct _zrex_t *)NULL));
  /* assertion text */
  assert(text != ((const char *)NULL));
  /* assertion expression */
  assert(expression != ((const char *)NULL));
  signed int return_value_slre_compile_1;
  return_value_slre_compile_1=slre_compile(&self->slre, expression);
  self->valid = return_value_slre_compile_1 == 1;
  if(self->valid == (_Bool)0)
    self->strerror = self->slre.err_str;

  /* assertion self->slre.num_caps < 100 */
  assert(self->slre.num_caps < 100);
  _Bool return_value_zrex_matches_2;
  if(!(self->valid == (_Bool)0))
  {
    return_value_zrex_matches_2=zrex_matches(self, text);
    return return_value_zrex_matches_2;
  }

  else
    return (_Bool)0;
}

// zrex_fetch
// file src/zrex.c line 238
signed int zrex_fetch(struct _zrex_t *self, const char **string_p, ...)
{
  /* assertion self */
  assert(self != ((struct _zrex_t *)NULL));
  __builtin_va_list args;
  va_start(args, string_p);
  unsigned int index = (unsigned int)0;
  while(!(string_p == ((const char **)NULL)))
  {
    index = index + 1u;
    *string_p=zrex_hit(self, index);
    string_p=va_arg(args, __typeof__(string_p));
  }
  va_end(args);
  return (signed int)index;
}

// zrex_hit
// file src/zrex.c line 220
const char * zrex_hit(struct _zrex_t *self, unsigned int index)
{
  /* assertion self */
  assert(self != ((struct _zrex_t *)NULL));
  if(!(index >= self->hits))
    return self->hit[(signed long int)index];

  else
    return (const char *)(void *)0;
}

// zrex_hits
// file src/zrex.c line 206
signed int zrex_hits(struct _zrex_t *self)
{
  /* assertion self */
  assert(self != ((struct _zrex_t *)NULL));
  return (signed int)self->hits;
}

// zrex_matches
// file src/../include/zrex.h line 44
_Bool zrex_matches(struct _zrex_t *self, const char *text)
{
  /* assertion self */
  assert(self != ((struct _zrex_t *)NULL));
  /* assertion text */
  assert(text != ((const char *)NULL));
  self->hits = (unsigned int)0;
  _Bool matches;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(text);
  signed int return_value_slre_match_2;
  return_value_slre_match_2=slre_match(&self->slre, text, return_value_strlen_1, self->caps);
  matches = return_value_slre_match_2 != 0;
  if(!(matches == (_Bool)0))
  {
    self->hits = (unsigned int)(self->slre.num_caps + 1);
    if(self->hits >= 101u)
      self->hits = (unsigned int)100;

    unsigned int index;
    unsigned long int hit_set_len = (unsigned long int)0;
    index = (unsigned int)0;
    for( ; !(index >= self->hits); index = index + 1u)
      hit_set_len = hit_set_len + self->caps[(signed long int)index].len + (unsigned long int)1;
    if(!(self->hit_set_len >= hit_set_len))
    {
      zstr_free(&self->hit_set);
      void *return_value_safe_malloc_3;
      return_value_safe_malloc_3=safe_malloc_link22(hit_set_len, "src/zrex.c", (unsigned int)156);
      self->hit_set = (char *)return_value_safe_malloc_3;
      self->hit_set_len = hit_set_len;
    }

    /* assertion self->hit_set */
    assert(self->hit_set != ((char *)NULL));
    char *hit_set_ptr = self->hit_set;
    index = (unsigned int)0;
    for( ; !(index >= self->hits); index = index + 1u)
    {
      memcpy((void *)hit_set_ptr, (const void *)self->caps[(signed long int)index].ptr, self->caps[(signed long int)index].len);
      self->hit[(signed long int)index] = hit_set_ptr;
      hit_set_ptr = hit_set_ptr + (signed long int)(self->caps[(signed long int)index].len + (unsigned long int)1);
    }
  }

  return matches;
}

// zrex_new
// file src/../include/zrex.h line 27
struct _zrex_t * zrex_new(const char *expression)
{
  struct _zrex_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link22(sizeof(struct _zrex_t) /*2976ul*/ , "src/zrex.c", (unsigned int)74);
  self = (struct _zrex_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _zrex_t *)NULL)))
  {
    self->strerror = "No error";
    if(!(expression == ((const char *)NULL)))
    {
      signed int return_value_slre_compile_2;
      return_value_slre_compile_2=slre_compile(&self->slre, expression);
      self->valid = return_value_slre_compile_2 == 1;
      if(self->valid == (_Bool)0)
        self->strerror = self->slre.err_str;

      /* assertion self->slre.num_caps < 100 */
      assert(self->slre.num_caps < 100);
    }

  }

  return self;
}

// zrex_strerror
// file src/zrex.c line 120
const char * zrex_strerror(struct _zrex_t *self)
{
  /* assertion self */
  assert(self != ((struct _zrex_t *)NULL));
  return self->strerror;
}

// zrex_test
// file src/zrex.c line 257
void zrex_test(_Bool verbose)
{
  printf(" * zrex: ");
  struct _zrex_t *rex;
  rex=zrex_new("\\d+-\\d+-\\d+");
  /* assertion rex */
  assert(rex != ((struct _zrex_t *)NULL));
  _Bool return_value_zrex_valid_1;
  return_value_zrex_valid_1=zrex_valid(rex);
  /* assertion zrex_valid (rex) */
  assert(return_value_zrex_valid_1 != (_Bool)0);
  _Bool matches;
  matches=zrex_matches(rex, "123-456-789");
  /* assertion matches */
  assert(matches != (_Bool)0);
  signed int return_value_zrex_hits_2;
  return_value_zrex_hits_2=zrex_hits(rex);
  /* assertion zrex_hits (rex) == 1 */
  assert(return_value_zrex_hits_2 == 1);
  const char *return_value_zrex_hit_3;
  return_value_zrex_hit_3=zrex_hit(rex, (unsigned int)0);
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(return_value_zrex_hit_3, "123-456-789");
  /* assertion (!strcmp ((zrex_hit (rex, 0)), ("123-456-789"))) */
  assert(!(return_value_strcmp_4 != 0));
  const char *return_value_zrex_hit_5;
  return_value_zrex_hit_5=zrex_hit(rex, (unsigned int)1);
  /* assertion zrex_hit (rex, 1) == ((void *)0) */
  assert(return_value_zrex_hit_5 == (const char *)(void *)0);
  zrex_destroy(&rex);
  rex=zrex_new("(\\d+)-(\\d+)-(\\d+)");
  /* assertion rex */
  assert(rex != ((struct _zrex_t *)NULL));
  _Bool return_value_zrex_valid_6;
  return_value_zrex_valid_6=zrex_valid(rex);
  /* assertion zrex_valid (rex) */
  assert(return_value_zrex_valid_6 != (_Bool)0);
  matches=zrex_matches(rex, "123-456-ABC");
  /* assertion !matches */
  assert(!(matches != (_Bool)0));
  matches=zrex_matches(rex, "123-456-789");
  /* assertion matches */
  assert(matches != (_Bool)0);
  signed int return_value_zrex_hits_7;
  return_value_zrex_hits_7=zrex_hits(rex);
  /* assertion zrex_hits (rex) == 4 */
  assert(return_value_zrex_hits_7 == 4);
  const char *return_value_zrex_hit_8;
  return_value_zrex_hit_8=zrex_hit(rex, (unsigned int)0);
  signed int return_value_strcmp_9;
  return_value_strcmp_9=strcmp(return_value_zrex_hit_8, "123-456-789");
  /* assertion (!strcmp ((zrex_hit (rex, 0)), ("123-456-789"))) */
  assert(!(return_value_strcmp_9 != 0));
  const char *return_value_zrex_hit_10;
  return_value_zrex_hit_10=zrex_hit(rex, (unsigned int)1);
  signed int return_value_strcmp_11;
  return_value_strcmp_11=strcmp(return_value_zrex_hit_10, "123");
  /* assertion (!strcmp ((zrex_hit (rex, 1)), ("123"))) */
  assert(!(return_value_strcmp_11 != 0));
  const char *return_value_zrex_hit_12;
  return_value_zrex_hit_12=zrex_hit(rex, (unsigned int)2);
  signed int return_value_strcmp_13;
  return_value_strcmp_13=strcmp(return_value_zrex_hit_12, "456");
  /* assertion (!strcmp ((zrex_hit (rex, 2)), ("456"))) */
  assert(!(return_value_strcmp_13 != 0));
  const char *return_value_zrex_hit_14;
  return_value_zrex_hit_14=zrex_hit(rex, (unsigned int)3);
  signed int return_value_strcmp_15;
  return_value_strcmp_15=strcmp(return_value_zrex_hit_14, "789");
  /* assertion (!strcmp ((zrex_hit (rex, 3)), ("789"))) */
  assert(!(return_value_strcmp_15 != 0));
  zrex_destroy(&rex);
  rex=zrex_new((const char *)(void *)0);
  /* assertion rex */
  assert(rex != ((struct _zrex_t *)NULL));
  char *input = "Mechanism: CURVE";
  matches=zrex_eq(rex, input, "Version: (.+)");
  /* assertion !matches */
  assert(!(matches != (_Bool)0));
  signed int return_value_zrex_hits_16;
  return_value_zrex_hits_16=zrex_hits(rex);
  /* assertion zrex_hits (rex) == 0 */
  assert(return_value_zrex_hits_16 == 0);
  matches=zrex_eq(rex, input, "Mechanism: (.+)");
  /* assertion matches */
  assert(matches != (_Bool)0);
  signed int return_value_zrex_hits_17;
  return_value_zrex_hits_17=zrex_hits(rex);
  /* assertion zrex_hits (rex) == 2 */
  assert(return_value_zrex_hits_17 == 2);
  const char *mechanism;
  zrex_fetch(rex, &mechanism, (void *)0);
  const char *return_value_zrex_hit_18;
  return_value_zrex_hit_18=zrex_hit(rex, (unsigned int)1);
  signed int return_value_strcmp_19;
  return_value_strcmp_19=strcmp(return_value_zrex_hit_18, "CURVE");
  /* assertion (!strcmp ((zrex_hit (rex, 1)), ("CURVE"))) */
  assert(!(return_value_strcmp_19 != 0));
  signed int return_value_strcmp_20;
  return_value_strcmp_20=strcmp(mechanism, "CURVE");
  /* assertion (!strcmp ((mechanism), ("CURVE"))) */
  assert(!(return_value_strcmp_20 != 0));
  zrex_destroy(&rex);
  printf("OK\n");
}

// zrex_valid
// file src/zrex.c line 109
_Bool zrex_valid(struct _zrex_t *self)
{
  /* assertion self */
  assert(self != ((struct _zrex_t *)NULL));
  return self->valid;
}

// zsock_affinity
// file src/zsock_option.c line 882
signed int zsock_affinity(void *self)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int affinity;
  unsigned long int option_len = sizeof(unsigned long int) /*8ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 4, (void *)&affinity, &option_len);
  return (signed int)affinity;
}

// zsock_attach
// file src/../include/zsock.h line 156
signed int zsock_attach(struct _zsock_t *self, const char *endpoints, _Bool serverish)
{
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  unsigned long int return_value_strlen_1;
  if(endpoints == ((const char *)NULL))
    return 0;

  else
  {
    char endpoint[256l];
    while(!(*endpoints == 0))
    {
      const char *delimiter;
      delimiter=strchr(endpoints, 44);
      if(delimiter == ((const char *)NULL))
      {
        return_value_strlen_1=strlen(endpoints);
        delimiter = endpoints + (signed long int)return_value_strlen_1;
      }

      if(delimiter - endpoints >= 256l)
        return -1;

      memcpy((void *)endpoint, (const void *)endpoints, (unsigned long int)(delimiter - endpoints));
      endpoint[delimiter - endpoints] = (char)0;
      signed int rc;
      if((signed int)endpoint[0l] == 64)
        rc=zsock_bind(self, "%s", endpoint + (signed long int)1);

      else
        if((signed int)endpoint[0l] == 62)
          rc=zsock_connect(self, "%s", endpoint + (signed long int)1);

        else
          if(!(serverish == (_Bool)0))
            rc=zsock_bind(self, "%s", (const void *)endpoint);

          else
            rc=zsock_connect(self, "%s", (const void *)endpoint);
      if(rc == -1)
        return -1;

      if((signed int)*delimiter == 0)
        break;

      endpoints = delimiter + (signed long int)1;
    }
    return 0;
  }
}

// zsock_backlog
// file src/zsock_option.c line 1224
signed int zsock_backlog(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int backlog;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 19, (void *)&backlog, &option_len);
  return backlog;
}

// zsock_bind
// file src/../include/zsock.h line 126
signed int zsock_bind(struct _zsock_t *self, const char *format, ...)
{
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is((void *)self);
  /* assertion zsock_is (self) */
  assert(return_value_zsock_is_1 != (_Bool)0);
  void **argptr = (void **)&format;
  char *endpoint;
  endpoint=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  const char *return_value_zrex_hit_3;
  _Bool return_value_zrex_eq_14;
  signed int return_value_atoi_6;
  signed int return_value_atoi_8;
  signed long int return_value_random_10;
  signed int tmp_post_12;
  if(endpoint == ((char *)NULL))
    return -1;

  else
  {
    signed int rc;
    struct _zrex_t *rex;
    rex=zrex_new((const char *)(void *)0);
    _Bool return_value_zrex_eq_15;
    return_value_zrex_eq_15=zrex_eq(rex, endpoint, "^tcp://.*:(\\d+)_");
    if(!(return_value_zrex_eq_15 == (_Bool)0))
    {
      signed int return_value_zrex_hits_2;
      return_value_zrex_hits_2=zrex_hits(rex);
      /* assertion zrex_hits (rex) == 2 */
      assert(return_value_zrex_hits_2 == 2);
      signed int return_value_zmq_bind_4;
      return_value_zmq_bind_4=zmq_bind(self->handle, endpoint);
      if(return_value_zmq_bind_4 == 0)
      {
        return_value_zrex_hit_3=zrex_hit(rex, (unsigned int)1);
        rc=atoi(return_value_zrex_hit_3);
      }

      else
        rc = -1;
    }

    else
    {
      return_value_zrex_eq_14=zrex_eq(rex, endpoint, "^(tcp://.*):([*!])(\\[(\\d+)?-(\\d+)?\\])?_");
      if(!(return_value_zrex_eq_14 == (_Bool)0))
      {
        signed int return_value_zrex_hits_5;
        return_value_zrex_hits_5=zrex_hits(rex);
        /* assertion zrex_hits (rex) == 6 */
        assert(return_value_zrex_hits_5 == 6);
        const char *hostname;
        const char *opcode;
        const char *group;
        const char *first_str;
        const char *last_str;
        zrex_fetch(rex, &hostname, &opcode, &group, &first_str, &last_str, (void *)0);
        signed int first;
        signed int tmp_if_expr_7;
        if(!(*first_str == 0))
        {
          return_value_atoi_6=atoi(first_str);
          tmp_if_expr_7 = return_value_atoi_6;
        }

        else
          tmp_if_expr_7 = 0xc000;
        first = tmp_if_expr_7;
        signed int last;
        signed int tmp_if_expr_9;
        if(!(*last_str == 0))
        {
          return_value_atoi_8=atoi(last_str);
          tmp_if_expr_9 = return_value_atoi_8;
        }

        else
          tmp_if_expr_9 = 0xffff;
        last = tmp_if_expr_9;
        signed int attempts = (last - first) + 1;
        signed int port = first;
        signed int return_value_strcmp_11;
        return_value_strcmp_11=strcmp(opcode, "!");
        if(return_value_strcmp_11 == 0)
        {
          return_value_random_10=random();
          port = port + (signed int)((double)((float)attempts * (float)return_value_random_10) / ((double)2147483647 + 1.0));
        }

        rc = -1;
        while(rc == -1)
        {
          tmp_post_12 = attempts;
          attempts = attempts - 1;
          if(tmp_post_12 == 0)
            break;

          free((void *)endpoint);
          endpoint=zsys_sprintf("%s:%d", hostname, port);
          if(endpoint == ((char *)NULL))
            break;

          signed int return_value_zmq_bind_13;
          return_value_zmq_bind_13=zmq_bind(self->handle, endpoint);
          if(return_value_zmq_bind_13 == 0)
            rc = port;

          port = port + 1;
          if(!(last >= port))
            port = first;

        }
      }

      else
        rc=zmq_bind(self->handle, endpoint);
    }
    if(rc >= 0)
    {
      free((void *)self->endpoint);
      self->endpoint = endpoint;
    }

    else
      free((void *)endpoint);
    zrex_destroy(&rex);
    return rc;
  }
}

// zsock_brecv
// file src/zsock.c line 1267
signed int zsock_brecv(void *selfish, const char *picture, ...)
{
  /* assertion selfish */
  assert(selfish != NULL);
  /* assertion picture */
  assert(picture != ((const char *)NULL));
  struct zmq_msg_t msg;
  zmq_msg_init(&msg);
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(selfish);
  signed int return_value_zmq_msg_recv_2;
  return_value_zmq_msg_recv_2=zmq_msg_recv(&msg, return_value_zsock_resolve_1, 0);
  unsigned long int return_value_zuuid_size_11;
  if(return_value_zmq_msg_recv_2 == -1)
    return -1;

  else
  {
    struct _zsock_t *self = (struct _zsock_t *)selfish;
    _Bool return_value_zactor_is_3;
    return_value_zactor_is_3=zactor_is(selfish);
    if(!(return_value_zactor_is_3 == (_Bool)0))
      self=zactor_sock((struct _zactor_t *)selfish);

    if(self->cache == ((char *)NULL))
    {
      void *return_value_malloc_4;
      return_value_malloc_4=malloc((unsigned long int)512);
      self->cache = (char *)return_value_malloc_4;
      self->cache_size = (unsigned long int)512;
    }

    unsigned int cache_used = (unsigned int)0;
    unsigned char *needle;
    void *return_value_zmq_msg_data_5;
    return_value_zmq_msg_data_5=zmq_msg_data(&msg);
    needle = (unsigned char *)return_value_zmq_msg_data_5;
    unsigned char *ceiling;
    unsigned long int return_value_zmq_msg_size_6;
    return_value_zmq_msg_size_6=zmq_msg_size(&msg);
    ceiling = needle + (signed long int)return_value_zmq_msg_size_6;
    __builtin_va_list argptr;
    va_start(argptr, picture);
    const char *picptr = picture;
    for( ; !(*picptr == 0); picptr = picptr + 1l)
      if((signed int)*picptr == 49)
      {
        unsigned char *number1_p;
        number1_p=va_arg(argptr, __typeof__(number1_p));
        if(!(ceiling >= needle + 1l))
          goto malformed;

        *number1_p = *((unsigned char *)needle);
        needle = needle + 1l;
      }

      else
        if((signed int)*picptr == 50)
        {
          unsigned short int *number2_p;
          number2_p=va_arg(argptr, __typeof__(number2_p));
          if(!(ceiling >= needle + 2l))
            goto malformed;

          *number2_p = (unsigned short int)(((signed int)(unsigned short int)needle[(signed long int)0] << 8) + (signed int)(unsigned short int)needle[(signed long int)1]);
          needle = needle + (signed long int)2;
        }

        else
          if((signed int)*picptr == 52)
          {
            unsigned int *number4_p;
            number4_p=va_arg(argptr, __typeof__(number4_p));
            if(!(ceiling >= needle + 4l))
              goto malformed;

            *number4_p = ((unsigned int)needle[(signed long int)0] << 24) + ((unsigned int)needle[(signed long int)1] << 16) + ((unsigned int)needle[(signed long int)2] << 8) + (unsigned int)needle[(signed long int)3];
            needle = needle + (signed long int)4;
          }

          else
            if((signed int)*picptr == 56)
            {
              unsigned long int *number8_p;
              number8_p=va_arg(argptr, __typeof__(number8_p));
              if(!(ceiling >= needle + 8l))
                goto malformed;

              *number8_p = ((unsigned long int)needle[(signed long int)0] << 56) + ((unsigned long int)needle[(signed long int)1] << 48) + ((unsigned long int)needle[(signed long int)2] << 40) + ((unsigned long int)needle[(signed long int)3] << 32) + ((unsigned long int)needle[(signed long int)4] << 24) + ((unsigned long int)needle[(signed long int)5] << 16) + ((unsigned long int)needle[(signed long int)6] << 8) + (unsigned long int)needle[(signed long int)7];
              needle = needle + (signed long int)8;
            }

            else
              if((signed int)*picptr == 112)
              {
                void **pointer_p;
                pointer_p=va_arg(argptr, __typeof__(pointer_p));
                memcpy((void *)pointer_p, (const void *)needle, sizeof(void *) /*8ul*/ );
                needle = needle + (signed long int)sizeof(void *) /*8ul*/ ;
              }

              else
                if((signed int)*picptr == 115)
                {
                  char **string_p;
                  string_p=va_arg(argptr, __typeof__(string_p));
                  unsigned int string_size;
                  if(!(ceiling >= needle + 1l))
                    goto malformed;

                  string_size = (unsigned int)*((unsigned char *)needle);
                  needle = needle + 1l;
                  if(!(ceiling >= needle + (signed long int)string_size))
                    goto malformed;

                  if(!(self->cache_size >= (unsigned long int)(string_size + cache_used)))
                  {
                    puts("REALLOC");
                    self->cache_size = self->cache_size * (unsigned long int)2;
                    void *return_value_realloc_7;
                    return_value_realloc_7=realloc((void *)self->cache, self->cache_size);
                    self->cache = (char *)return_value_realloc_7;
                    /* assertion self->cache */
                    assert(self->cache != ((char *)NULL));
                  }

                  *string_p = self->cache + (signed long int)cache_used;
                  memcpy((void *)*string_p, (const void *)needle, (unsigned long int)string_size);
                  cache_used = cache_used + string_size;
                  unsigned int tmp_post_8 = cache_used;
                  cache_used = cache_used + 1u;
                  self->cache[(signed long int)tmp_post_8] = (char)0;
                  needle = needle + (signed long int)string_size;
                }

                else
                  if((signed int)*picptr == 83)
                  {
                    char **zsock_brecv__1__2__7__string_p;
                    zsock_brecv__1__2__7__string_p=va_arg(argptr, __typeof__(zsock_brecv__1__2__7__string_p));
                    unsigned long int zsock_brecv__1__2__7__string_size;
                    if(!(ceiling >= needle + 4l))
                      goto malformed;

                    zsock_brecv__1__2__7__string_size = (unsigned long int)(((unsigned int)needle[(signed long int)0] << 24) + ((unsigned int)needle[(signed long int)1] << 16) + ((unsigned int)needle[(signed long int)2] << 8) + (unsigned int)needle[(signed long int)3]);
                    needle = needle + (signed long int)4;
                    if(zsock_brecv__1__2__7__string_size >= 1048577ul || !(ceiling >= needle + (signed long int)zsock_brecv__1__2__7__string_size))
                      goto malformed;

                    void *return_value_malloc_9;
                    return_value_malloc_9=malloc(zsock_brecv__1__2__7__string_size + (unsigned long int)1);
                    *zsock_brecv__1__2__7__string_p = (char *)return_value_malloc_9;
                    /* assertion string_p */
                    assert(zsock_brecv__1__2__7__string_p != ((char **)NULL));
                    memcpy((void *)*zsock_brecv__1__2__7__string_p, (const void *)needle, zsock_brecv__1__2__7__string_size);
                    (*zsock_brecv__1__2__7__string_p)[(signed long int)zsock_brecv__1__2__7__string_size] = (char)0;
                    needle = needle + (signed long int)zsock_brecv__1__2__7__string_size;
                  }

                  else
                    if((signed int)*picptr == 99)
                    {
                      struct _zchunk_t **chunk_p;
                      chunk_p=va_arg(argptr, __typeof__(chunk_p));
                      unsigned long int chunk_size;
                      if(!(ceiling >= needle + 4l))
                        goto malformed;

                      chunk_size = (unsigned long int)(((unsigned int)needle[(signed long int)0] << 24) + ((unsigned int)needle[(signed long int)1] << 16) + ((unsigned int)needle[(signed long int)2] << 8) + (unsigned int)needle[(signed long int)3]);
                      needle = needle + (signed long int)4;
                      if(chunk_size >= 1048577ul || !(ceiling >= needle + (signed long int)chunk_size))
                        goto malformed;

                      *chunk_p=zchunk_new((const void *)needle, chunk_size);
                      needle = needle + (signed long int)chunk_size;
                    }

                    else
                      if((signed int)*picptr == 117)
                      {
                        struct _zuuid_t **uuid_p;
                        uuid_p=va_arg(argptr, __typeof__(uuid_p));
                        *uuid_p=zuuid_new();
                        unsigned long int return_value_zuuid_size_10;
                        return_value_zuuid_size_10=zuuid_size(*uuid_p);
                        _Bool tmp_if_expr_12;
                        if(return_value_zuuid_size_10 >= 1048577ul)
                          tmp_if_expr_12 = (_Bool)1;

                        else
                        {
                          return_value_zuuid_size_11=zuuid_size(*uuid_p);
                          tmp_if_expr_12 = needle + (signed long int)return_value_zuuid_size_11 > ceiling ? (_Bool)1 : (_Bool)0;
                        }
                        if(tmp_if_expr_12)
                          goto malformed;

                        zuuid_set(*uuid_p, needle);
                        unsigned long int return_value_zuuid_size_13;
                        return_value_zuuid_size_13=zuuid_size(*uuid_p);
                        needle = needle + (signed long int)return_value_zuuid_size_13;
                      }

                      else
                        if((signed int)*picptr == 102)
                        {
                          struct _zframe_t **frame_p;
                          frame_p=va_arg(argptr, __typeof__(frame_p));
                          signed int return_value_zsock_rcvmore_14;
                          return_value_zsock_rcvmore_14=zsock_rcvmore((void *)self);
                          if(return_value_zsock_rcvmore_14 == 0)
                            goto malformed;

                          *frame_p=zframe_recv((void *)self);
                        }

                        else
                          if((signed int)*picptr == 109)
                          {
                            if(!(picptr[1l] == 0))
                            {
                              zsys_error("zsock_brecv: 'm' (zmsg) only valid at end of picptr");
                              /* assertion 0 */
                              assert(0 != 0);
                            }

                            struct _zmsg_t **msg_p;
                            msg_p=va_arg(argptr, __typeof__(msg_p));
                            signed int return_value_zsock_rcvmore_15;
                            return_value_zsock_rcvmore_15=zsock_rcvmore((void *)self);
                            if(return_value_zsock_rcvmore_15 == 0)
                              goto malformed;

                            *msg_p=zmsg_recv((void *)self);
                          }

                          else
                          {
                            zsys_error("zsock_brecv: invalid picptr element '%c'", *picptr);
                            /* assertion 0 */
                            assert(0 != 0);
                          }
    va_end(argptr);
    zmq_msg_close(&msg);
    return 0;

  malformed:
    ;
    zmq_msg_close(&msg);
    return -1;
  }
}

// zsock_bsend
// file src/zsock.c line 1075
signed int zsock_bsend(void *self, const char *picture, ...)
{
  /* assertion self */
  assert(self != NULL);
  /* assertion picture */
  assert(picture != ((const char *)NULL));
  unsigned long int frame_size = (unsigned long int)0;
  struct _zframe_t *frames[32l];
  unsigned long int nbr_frames = (unsigned long int)0;
  __builtin_va_list argptr;
  va_start(argptr, picture);
  const char *picptr = picture;
  unsigned long int return_value_strlen_1;
  unsigned long int return_value_strlen_3;
  unsigned long int return_value_zchunk_size_5;
  for( ; !(*picptr == 0); picptr = picptr + 1l)
    if((signed int)*picptr == 49)
    {
      (void)va_arg(argptr, __typeof__(*((signed int *)0)));
      frame_size = frame_size + (unsigned long int)1;
    }

    else
      if((signed int)*picptr == 50)
      {
        (void)va_arg(argptr, __typeof__(*((signed int *)0)));
        frame_size = frame_size + (unsigned long int)2;
      }

      else
        if((signed int)*picptr == 52)
        {
          (void)va_arg(argptr, __typeof__(*((unsigned int *)0)));
          frame_size = frame_size + (unsigned long int)4;
        }

        else
          if((signed int)*picptr == 56)
          {
            (void)va_arg(argptr, __typeof__(*((unsigned long int *)0)));
            frame_size = frame_size + (unsigned long int)8;
          }

          else
            if((signed int)*picptr == 115)
            {
              char *zsock_bsend__1__1__5__string;
              zsock_bsend__1__1__5__string=va_arg(argptr, __typeof__(zsock_bsend__1__1__5__string));
              unsigned long int tmp_if_expr_2;
              if(!(zsock_bsend__1__1__5__string == ((char *)NULL)))
              {
                return_value_strlen_1=strlen(zsock_bsend__1__1__5__string);
                tmp_if_expr_2 = return_value_strlen_1;
              }

              else
                tmp_if_expr_2 = (unsigned long int)0;
              frame_size = frame_size + (unsigned long int)1 + tmp_if_expr_2;
            }

            else
              if((signed int)*picptr == 83)
              {
                char *zsock_bsend__1__1__6__string;
                zsock_bsend__1__1__6__string=va_arg(argptr, __typeof__(zsock_bsend__1__1__6__string));
                unsigned long int tmp_if_expr_4;
                if(!(zsock_bsend__1__1__6__string == ((char *)NULL)))
                {
                  return_value_strlen_3=strlen(zsock_bsend__1__1__6__string);
                  tmp_if_expr_4 = return_value_strlen_3;
                }

                else
                  tmp_if_expr_4 = (unsigned long int)0;
                frame_size = frame_size + (unsigned long int)4 + tmp_if_expr_4;
              }

              else
                if((signed int)*picptr == 99)
                {
                  struct _zchunk_t *zsock_bsend__1__1__7__chunk;
                  zsock_bsend__1__1__7__chunk=va_arg(argptr, __typeof__(zsock_bsend__1__1__7__chunk));
                  unsigned long int tmp_if_expr_6;
                  if(!(zsock_bsend__1__1__7__chunk == ((struct _zchunk_t *)NULL)))
                  {
                    return_value_zchunk_size_5=zchunk_size(zsock_bsend__1__1__7__chunk);
                    tmp_if_expr_6 = return_value_zchunk_size_5;
                  }

                  else
                    tmp_if_expr_6 = (unsigned long int)0;
                  frame_size = frame_size + (unsigned long int)4 + tmp_if_expr_6;
                }

                else
                  if((signed int)*picptr == 112)
                  {
                    (void)va_arg(argptr, __typeof__(*((void **)0)));
                    frame_size = frame_size + sizeof(void *) /*8ul*/ ;
                  }

                  else
                    if((signed int)*picptr == 102)
                    {
                      struct _zframe_t *zsock_bsend__1__1__9__frame;
                      zsock_bsend__1__1__9__frame=va_arg(argptr, __typeof__(zsock_bsend__1__1__9__frame));
                      /* assertion nbr_frames < 32 - 1 */
                      assert(nbr_frames < (unsigned long int)(32 - 1));
                      unsigned long int tmp_post_7 = nbr_frames;
                      nbr_frames = nbr_frames + 1ul;
                      frames[(signed long int)tmp_post_7] = zsock_bsend__1__1__9__frame;
                    }

                    else
                      if((signed int)*picptr == 117)
                      {
                        struct _zuuid_t *zsock_bsend__1__1__10__uuid;
                        zsock_bsend__1__1__10__uuid=va_arg(argptr, __typeof__(zsock_bsend__1__1__10__uuid));
                        unsigned long int return_value_zuuid_size_8;
                        return_value_zuuid_size_8=zuuid_size(zsock_bsend__1__1__10__uuid);
                        frame_size = frame_size + return_value_zuuid_size_8;
                      }

                      else
                        if((signed int)*picptr == 109)
                        {
                          if(!(picptr[1l] == 0))
                          {
                            zsys_error("zsock_bsend: 'm' (zmsg) only valid at end of picptr");
                            /* assertion 0 */
                            assert(0 != 0);
                          }

                          struct _zmsg_t *msg;
                          msg=va_arg(argptr, __typeof__(msg));
                          if(!(msg == ((struct _zmsg_t *)NULL)))
                          {
                            struct _zframe_t *frame;
                            frame=zmsg_first(msg);
                            while(!(frame == ((struct _zframe_t *)NULL)))
                            {
                              /* assertion nbr_frames < 32 - 1 */
                              assert(nbr_frames < (unsigned long int)(32 - 1));
                              unsigned long int tmp_post_9 = nbr_frames;
                              nbr_frames = nbr_frames + 1ul;
                              frames[(signed long int)tmp_post_9] = frame;
                              frame=zmsg_next(msg);
                            }
                          }

                          else
                          {
                            unsigned long int tmp_post_10 = nbr_frames;
                            nbr_frames = nbr_frames + 1ul;
                            frames[(signed long int)tmp_post_10]=zframe_new_empty();
                          }
                        }

                        else
                        {
                          zsys_error("zsock_bsend: invalid picptr element '%c'", *picptr);
                          /* assertion 0 */
                          assert(0 != 0);
                        }
  va_end(argptr);
  struct zmq_msg_t zsock_bsend__1__msg;
  zmq_msg_init_size(&zsock_bsend__1__msg, frame_size);
  unsigned char *needle;
  void *return_value_zmq_msg_data_11;
  return_value_zmq_msg_data_11=zmq_msg_data(&zsock_bsend__1__msg);
  needle = (unsigned char *)return_value_zmq_msg_data_11;
  va_start(argptr, picture);
  picptr = picture;
  for( ; !(*picptr == 0); picptr = picptr + 1l)
    if((signed int)*picptr == 49)
    {
      signed int number1;
      number1=va_arg(argptr, __typeof__(number1));
      *((unsigned char *)needle) = (unsigned char)number1;
      needle = needle + 1l;
    }

    else
      if((signed int)*picptr == 50)
      {
        signed int number2;
        number2=va_arg(argptr, __typeof__(number2));
        needle[(signed long int)0] = (unsigned char)(number2 >> 8 & 255);
        needle[(signed long int)1] = (unsigned char)(number2 & 255);
        needle = needle + (signed long int)2;
      }

      else
        if((signed int)*picptr == 52)
        {
          unsigned int number4;
          number4=va_arg(argptr, __typeof__(number4));
          needle[(signed long int)0] = (unsigned char)(number4 >> 24 & (unsigned int)255);
          needle[(signed long int)1] = (unsigned char)(number4 >> 16 & (unsigned int)255);
          needle[(signed long int)2] = (unsigned char)(number4 >> 8 & (unsigned int)255);
          needle[(signed long int)3] = (unsigned char)(number4 & (unsigned int)255);
          needle = needle + (signed long int)4;
        }

        else
          if((signed int)*picptr == 56)
          {
            unsigned long int number8;
            number8=va_arg(argptr, __typeof__(number8));
            needle[(signed long int)0] = (unsigned char)(number8 >> 56 & (unsigned long int)255);
            needle[(signed long int)1] = (unsigned char)(number8 >> 48 & (unsigned long int)255);
            needle[(signed long int)2] = (unsigned char)(number8 >> 40 & (unsigned long int)255);
            needle[(signed long int)3] = (unsigned char)(number8 >> 32 & (unsigned long int)255);
            needle[(signed long int)4] = (unsigned char)(number8 >> 24 & (unsigned long int)255);
            needle[(signed long int)5] = (unsigned char)(number8 >> 16 & (unsigned long int)255);
            needle[(signed long int)6] = (unsigned char)(number8 >> 8 & (unsigned long int)255);
            needle[(signed long int)7] = (unsigned char)(number8 & (unsigned long int)255);
            needle = needle + (signed long int)8;
          }

          else
            if((signed int)*picptr == 112)
            {
              void *pointer;
              pointer=va_arg(argptr, __typeof__(pointer));
              memcpy((void *)needle, (const void *)&pointer, sizeof(void *) /*8ul*/ );
              needle = needle + (signed long int)sizeof(void *) /*8ul*/ ;
            }

            else
              if((signed int)*picptr == 115)
              {
                char *string;
                string=va_arg(argptr, __typeof__(string));
                if(string == ((char *)NULL))
                  string = "";

                unsigned long int string_size;
                string_size=strlen(string);
                *((unsigned char *)needle) = (unsigned char)string_size;
                needle = needle + 1l;
                memcpy((void *)needle, (const void *)string, string_size);
                needle = needle + (signed long int)string_size;
              }

              else
                if((signed int)*picptr == 83)
                {
                  char *zsock_bsend__1__2__7__string;
                  zsock_bsend__1__2__7__string=va_arg(argptr, __typeof__(zsock_bsend__1__2__7__string));
                  if(zsock_bsend__1__2__7__string == ((char *)NULL))
                    zsock_bsend__1__2__7__string = "";

                  unsigned long int zsock_bsend__1__2__7__string_size;
                  zsock_bsend__1__2__7__string_size=strlen(zsock_bsend__1__2__7__string);
                  needle[(signed long int)0] = (unsigned char)(zsock_bsend__1__2__7__string_size >> 24 & (unsigned long int)255);
                  needle[(signed long int)1] = (unsigned char)(zsock_bsend__1__2__7__string_size >> 16 & (unsigned long int)255);
                  needle[(signed long int)2] = (unsigned char)(zsock_bsend__1__2__7__string_size >> 8 & (unsigned long int)255);
                  needle[(signed long int)3] = (unsigned char)(zsock_bsend__1__2__7__string_size & (unsigned long int)255);
                  needle = needle + (signed long int)4;
                  memcpy((void *)needle, (const void *)zsock_bsend__1__2__7__string, zsock_bsend__1__2__7__string_size);
                  needle = needle + (signed long int)zsock_bsend__1__2__7__string_size;
                }

                else
                  if((signed int)*picptr == 99)
                  {
                    struct _zchunk_t *chunk;
                    chunk=va_arg(argptr, __typeof__(chunk));
                    if(!(chunk == ((struct _zchunk_t *)NULL)))
                    {
                      unsigned long int return_value_zchunk_size_12;
                      return_value_zchunk_size_12=zchunk_size(chunk);
                      needle[(signed long int)0] = (unsigned char)(return_value_zchunk_size_12 >> 24 & (unsigned long int)255);
                      unsigned long int return_value_zchunk_size_13;
                      return_value_zchunk_size_13=zchunk_size(chunk);
                      needle[(signed long int)1] = (unsigned char)(return_value_zchunk_size_13 >> 16 & (unsigned long int)255);
                      unsigned long int return_value_zchunk_size_14;
                      return_value_zchunk_size_14=zchunk_size(chunk);
                      needle[(signed long int)2] = (unsigned char)(return_value_zchunk_size_14 >> 8 & (unsigned long int)255);
                      unsigned long int return_value_zchunk_size_15;
                      return_value_zchunk_size_15=zchunk_size(chunk);
                      needle[(signed long int)3] = (unsigned char)(return_value_zchunk_size_15 & (unsigned long int)255);
                      needle = needle + (signed long int)4;
                      unsigned char *return_value_zchunk_data_16;
                      return_value_zchunk_data_16=zchunk_data(chunk);
                      unsigned long int return_value_zchunk_size_17;
                      return_value_zchunk_size_17=zchunk_size(chunk);
                      memcpy((void *)needle, (const void *)return_value_zchunk_data_16, return_value_zchunk_size_17);
                      unsigned long int return_value_zchunk_size_18;
                      return_value_zchunk_size_18=zchunk_size(chunk);
                      needle = needle + (signed long int)return_value_zchunk_size_18;
                    }

                  }

                  else
                    if((signed int)*picptr == 117)
                    {
                      struct _zuuid_t *uuid;
                      uuid=va_arg(argptr, __typeof__(uuid));
                      if(!(uuid == ((struct _zuuid_t *)NULL)))
                      {
                        const unsigned char *return_value_zuuid_data_19;
                        return_value_zuuid_data_19=zuuid_data(uuid);
                        unsigned long int return_value_zuuid_size_20;
                        return_value_zuuid_size_20=zuuid_size(uuid);
                        memcpy((void *)needle, (const void *)return_value_zuuid_data_19, return_value_zuuid_size_20);
                        unsigned long int return_value_zuuid_size_21;
                        return_value_zuuid_size_21=zuuid_size(uuid);
                        needle = needle + (signed long int)return_value_zuuid_size_21;
                      }

                    }

  va_end(argptr);
  void *handle;
  handle=zsock_resolve(self);
  zmq_msg_send(&zsock_bsend__1__msg, handle, nbr_frames != 0ul ? 2 : 0);
  unsigned int frame_nbr = (unsigned int)0;
  for( ; !((unsigned long int)frame_nbr >= nbr_frames); frame_nbr = frame_nbr + 1u)
  {
    _Bool more = (unsigned long int)frame_nbr < nbr_frames - (unsigned long int)1;
    zframe_send(&frames[(signed long int)frame_nbr], handle, 2 + (more != (_Bool)0 ? 1 : 0));
  }
  return 0;
}

// zsock_connect
// file src/../include/zsock.h line 141
signed int zsock_connect(struct _zsock_t *self, const char *format, ...)
{
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is((void *)self);
  /* assertion zsock_is (self) */
  assert(return_value_zsock_is_1 != (_Bool)0);
  void **argptr = (void **)&format;
  char *endpoint;
  endpoint=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  if(endpoint == ((char *)NULL))
    return -1;

  else
  {
    signed int rc;
    rc=zmq_connect(self->handle, endpoint);
    free((void *)endpoint);
    return rc;
  }
}

// zsock_curve_publickey
// file src/zsock_option.c line 405
char * zsock_curve_publickey(void *self)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int option_len = (unsigned long int)(40 + 1);
  char *curve_publickey;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link24(option_len, "src/zsock_option.c", (unsigned int)410);
  curve_publickey = (char *)return_value_safe_malloc_1;
  void *return_value_zsock_resolve_2;
  return_value_zsock_resolve_2=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_2, 48, (void *)curve_publickey, &option_len);
  return (char *)curve_publickey;
}

// zsock_curve_secretkey
// file src/zsock_option.c line 452
char * zsock_curve_secretkey(void *self)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int option_len = (unsigned long int)(40 + 1);
  char *curve_secretkey;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link24(option_len, "src/zsock_option.c", (unsigned int)457);
  curve_secretkey = (char *)return_value_safe_malloc_1;
  void *return_value_zsock_resolve_2;
  return_value_zsock_resolve_2=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_2, 49, (void *)curve_secretkey, &option_len);
  return (char *)curve_secretkey;
}

// zsock_curve_server
// file src/zsock_option.c line 358
signed int zsock_curve_server(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int curve_server;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 47, (void *)&curve_server, &option_len);
  return curve_server;
}

// zsock_curve_serverkey
// file src/zsock_option.c line 499
char * zsock_curve_serverkey(void *self)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int option_len = (unsigned long int)(40 + 1);
  char *curve_serverkey;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link24(option_len, "src/zsock_option.c", (unsigned int)504);
  curve_serverkey = (char *)return_value_safe_malloc_1;
  void *return_value_zsock_resolve_2;
  return_value_zsock_resolve_2=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_2, 50, (void *)curve_serverkey, &option_len);
  return (char *)curve_serverkey;
}

// zsock_destroy
// file src/../include/zsock.h line 42
void zsock_destroy(struct _zsock_t **self_p)
{
  zsock_destroy_checked(self_p, (const char *)(void *)0, (unsigned long int)0);
}

// zsock_destroy_checked
// file src/../include/zsock.h line 336
void zsock_destroy_checked(struct _zsock_t **self_p, const char *filename, unsigned long int line_nbr)
{
  /* assertion self_p */
  assert(self_p != ((struct _zsock_t **)NULL));
  if(!(*self_p == ((struct _zsock_t *)NULL)))
  {
    struct _zsock_t *self = *self_p;
    _Bool return_value_zsock_is_1;
    return_value_zsock_is_1=zsock_is((void *)self);
    /* assertion zsock_is (self) */
    assert(return_value_zsock_is_1 != (_Bool)0);
    self->tag = 0xDeadBeef;
    signed int rc;
    rc=zsys_close(self->handle, filename, line_nbr);
    /* assertion rc == 0 */
    assert(rc == 0);
    free((void *)self->endpoint);
    free((void *)self->cache);
    free((void *)self);
    *self_p = (struct _zsock_t *)(void *)0;
  }

}

// zsock_disconnect
// file src/zsock.c line 530
signed int zsock_disconnect(struct _zsock_t *self, const char *format, ...)
{
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is((void *)self);
  /* assertion zsock_is (self) */
  assert(return_value_zsock_is_1 != (_Bool)0);
  void **argptr = (void **)&format;
  char *endpoint;
  endpoint=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  if(endpoint == ((char *)NULL))
    return -1;

  else
  {
    signed int rc;
    rc=zmq_disconnect(self->handle, endpoint);
    free((void *)endpoint);
    return rc;
  }
}

// zsock_endpoint
// file src/zsock.c line 454
const char * zsock_endpoint(struct _zsock_t *self)
{
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  return self->endpoint;
}

// zsock_events
// file src/../include/zsock_option.h line 71
signed int zsock_events(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int events;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 15, (void *)&events, &option_len);
  return events;
}

// zsock_fd
// file src/../include/zsock_option.h line 70
signed int zsock_fd(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int fd;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 14, (void *)&fd, &option_len);
  return fd;
}

// zsock_flush
// file src/zsock.c line 1478
void zsock_flush(void *self)
{
  signed int return_value_zsock_rcvmore_1;
  return_value_zsock_rcvmore_1=zsock_rcvmore(self);
  if(!(return_value_zsock_rcvmore_1 == 0))
  {
    struct _zmsg_t *msg;
    msg=zmsg_recv(self);
    zmsg_destroy(&msg);
  }

}

// zsock_gssapi_plaintext
// file src/zsock_option.c line 565
signed int zsock_gssapi_plaintext(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int gssapi_plaintext;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 65, (void *)&gssapi_plaintext, &option_len);
  return gssapi_plaintext;
}

// zsock_gssapi_principal
// file src/zsock_option.c line 598
char * zsock_gssapi_principal(void *self)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int option_len = (unsigned long int)255;
  char *gssapi_principal;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link24(option_len, "src/zsock_option.c", (unsigned int)603);
  gssapi_principal = (char *)return_value_safe_malloc_1;
  void *return_value_zsock_resolve_2;
  return_value_zsock_resolve_2=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_2, 63, (void *)gssapi_principal, &option_len);
  return (char *)gssapi_principal;
}

// zsock_gssapi_server
// file src/zsock_option.c line 532
signed int zsock_gssapi_server(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int gssapi_server;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 62, (void *)&gssapi_server, &option_len);
  return gssapi_server;
}

// zsock_gssapi_service_principal
// file src/zsock_option.c line 631
char * zsock_gssapi_service_principal(void *self)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int option_len = (unsigned long int)255;
  char *gssapi_service_principal;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link24(option_len, "src/zsock_option.c", (unsigned int)636);
  gssapi_service_principal = (char *)return_value_safe_malloc_1;
  void *return_value_zsock_resolve_2;
  return_value_zsock_resolve_2=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_2, 64, (void *)gssapi_service_principal, &option_len);
  return (char *)gssapi_service_principal;
}

// zsock_identity
// file src/zsock_option.c line 960
char * zsock_identity(void *self)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int option_len = (unsigned long int)255;
  char *identity;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link24(option_len, "src/zsock_option.c", (unsigned int)965);
  identity = (char *)return_value_safe_malloc_1;
  void *return_value_zsock_resolve_2;
  return_value_zsock_resolve_2=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_2, 5, (void *)identity, &option_len);
  return (char *)identity;
}

// zsock_immediate
// file src/zsock_option.c line 697
signed int zsock_immediate(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int immediate;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 39, (void *)&immediate, &option_len);
  return immediate;
}

// zsock_ipv4only
// file src/zsock_option.c line 749
signed int zsock_ipv4only(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int ipv4only;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 31, (void *)&ipv4only, &option_len);
  return ipv4only;
}

// zsock_ipv6
// file src/zsock_option.c line 664
signed int zsock_ipv6(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int ipv6;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 42, (void *)&ipv6, &option_len);
  return ipv6;
}

// zsock_is
// file src/../include/zsock.h line 297
_Bool zsock_is(void *self)
{
  /* assertion self */
  assert(self != NULL);
  return ((struct _zsock_t *)self)->tag == (unsigned int)0x0004cafe;
}

// zsock_last_endpoint
// file src/zsock_option.c line 1613
char * zsock_last_endpoint(void *self)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int option_len = (unsigned long int)255;
  char *last_endpoint;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link24(option_len, "src/zsock_option.c", (unsigned int)1618);
  last_endpoint = (char *)return_value_safe_malloc_1;
  void *return_value_zsock_resolve_2;
  return_value_zsock_resolve_2=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_2, 32, (void *)last_endpoint, &option_len);
  return (char *)last_endpoint;
}

// zsock_linger
// file src/zsock_option.c line 1125
signed int zsock_linger(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int linger;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 17, (void *)&linger, &option_len);
  return linger;
}

// zsock_maxmsgsize
// file src/zsock_option.c line 1258
signed int zsock_maxmsgsize(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed long int maxmsgsize;
  unsigned long int option_len = sizeof(signed long int) /*8ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 22, (void *)&maxmsgsize, &option_len);
  return (signed int)maxmsgsize;
}

// zsock_mechanism
// file src/zsock_option.c line 226
signed int zsock_mechanism(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int mechanism;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 43, (void *)&mechanism, &option_len);
  return mechanism;
}

// zsock_multicast_hops
// file src/zsock_option.c line 1291
signed int zsock_multicast_hops(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int multicast_hops;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 25, (void *)&multicast_hops, &option_len);
  return multicast_hops;
}

// zsock_new
// file src/zsock.c line 73
struct _zsock_t * zsock_new(signed int type)
{
  struct _zsock_t *return_value_zsock_new_checked_1;
  return_value_zsock_new_checked_1=zsock_new_checked(type, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_checked_1;
}

// zsock_new_checked
// file src/../include/zsock.h line 333
struct _zsock_t * zsock_new_checked(signed int type, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link23(sizeof(struct _zsock_t) /*48ul*/ , "src/zsock.c", (unsigned int)61);
  self = (struct _zsock_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _zsock_t *)NULL)))
  {
    self->tag = (unsigned int)0x0004cafe;
    self->handle=zsys_socket(type, filename, line_nbr);
    self->type = type;
    if(self->handle == NULL)
      zsock_destroy(&self);

  }

  return self;
}

// zsock_new_dealer
// file src/zsock.c line 207
struct _zsock_t * zsock_new_dealer(const char *endpoints)
{
  struct _zsock_t *return_value_zsock_new_dealer_checked_1;
  return_value_zsock_new_dealer_checked_1=zsock_new_dealer_checked(endpoints, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_dealer_checked_1;
}

// zsock_new_dealer_checked
// file src/zsock.c line 197
struct _zsock_t * zsock_new_dealer_checked(const char *endpoints, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *sock;
  sock=zsock_new_checked(5, filename, line_nbr);
  signed int return_value_zsock_attach_1;
  if(!(sock == ((struct _zsock_t *)NULL)))
  {
    return_value_zsock_attach_1=zsock_attach(sock, endpoints, (_Bool)0);
    if(!(return_value_zsock_attach_1 == 0))
      zsock_destroy(&sock);

  }

  return sock;
}

// zsock_new_pair
// file src/zsock.c line 329
struct _zsock_t * zsock_new_pair(const char *endpoints)
{
  struct _zsock_t *return_value_zsock_new_pair_checked_1;
  return_value_zsock_new_pair_checked_1=zsock_new_pair_checked(endpoints, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_pair_checked_1;
}

// zsock_new_pair_checked
// file src/../include/zsock.h line 369
struct _zsock_t * zsock_new_pair_checked(const char *endpoints, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *sock;
  sock=zsock_new_checked(0, filename, line_nbr);
  signed int return_value_zsock_attach_1;
  if(!(sock == ((struct _zsock_t *)NULL)))
  {
    return_value_zsock_attach_1=zsock_attach(sock, endpoints, (_Bool)0);
    if(!(return_value_zsock_attach_1 == 0))
      zsock_destroy(&sock);

  }

  return sock;
}

// zsock_new_pub
// file src/zsock.c line 125
struct _zsock_t * zsock_new_pub(const char *endpoints)
{
  struct _zsock_t *return_value_zsock_new_pub_checked_1;
  return_value_zsock_new_pub_checked_1=zsock_new_pub_checked(endpoints, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_pub_checked_1;
}

// zsock_new_pub_checked
// file src/zsock.c line 115
struct _zsock_t * zsock_new_pub_checked(const char *endpoints, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *sock;
  sock=zsock_new_checked(1, filename, line_nbr);
  signed int return_value_zsock_attach_1;
  if(!(sock == ((struct _zsock_t *)NULL)))
  {
    return_value_zsock_attach_1=zsock_attach(sock, endpoints, (_Bool)1);
    if(!(return_value_zsock_attach_1 == 0))
      zsock_destroy(&sock);

  }

  return sock;
}

// zsock_new_pull
// file src/zsock.c line 264
struct _zsock_t * zsock_new_pull(const char *endpoints)
{
  struct _zsock_t *return_value_zsock_new_pull_checked_1;
  return_value_zsock_new_pull_checked_1=zsock_new_pull_checked(endpoints, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_pull_checked_1;
}

// zsock_new_pull_checked
// file src/../include/zsock.h line 360
struct _zsock_t * zsock_new_pull_checked(const char *endpoints, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *sock;
  sock=zsock_new_checked(7, filename, line_nbr);
  signed int return_value_zsock_attach_1;
  if(!(sock == ((struct _zsock_t *)NULL)))
  {
    return_value_zsock_attach_1=zsock_attach(sock, endpoints, (_Bool)1);
    if(!(return_value_zsock_attach_1 == 0))
      zsock_destroy(&sock);

  }

  return sock;
}

// zsock_new_push
// file src/zsock.c line 245
struct _zsock_t * zsock_new_push(const char *endpoints)
{
  struct _zsock_t *return_value_zsock_new_push_checked_1;
  return_value_zsock_new_push_checked_1=zsock_new_push_checked(endpoints, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_push_checked_1;
}

// zsock_new_push_checked
// file src/../include/zsock.h line 357
struct _zsock_t * zsock_new_push_checked(const char *endpoints, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *sock;
  sock=zsock_new_checked(8, filename, line_nbr);
  signed int return_value_zsock_attach_1;
  if(!(sock == ((struct _zsock_t *)NULL)))
  {
    return_value_zsock_attach_1=zsock_attach(sock, endpoints, (_Bool)0);
    if(!(return_value_zsock_attach_1 == 0))
      zsock_destroy(&sock);

  }

  return sock;
}

// zsock_new_rep
// file src/zsock.c line 188
struct _zsock_t * zsock_new_rep(const char *endpoints)
{
  struct _zsock_t *return_value_zsock_new_rep_checked_1;
  return_value_zsock_new_rep_checked_1=zsock_new_rep_checked(endpoints, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_rep_checked_1;
}

// zsock_new_rep_checked
// file src/zsock.c line 178
struct _zsock_t * zsock_new_rep_checked(const char *endpoints, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *sock;
  sock=zsock_new_checked(4, filename, line_nbr);
  signed int return_value_zsock_attach_1;
  if(!(sock == ((struct _zsock_t *)NULL)))
  {
    return_value_zsock_attach_1=zsock_attach(sock, endpoints, (_Bool)1);
    if(!(return_value_zsock_attach_1 == 0))
      zsock_destroy(&sock);

  }

  return sock;
}

// zsock_new_req
// file src/zsock.c line 169
struct _zsock_t * zsock_new_req(const char *endpoints)
{
  struct _zsock_t *return_value_zsock_new_req_checked_1;
  return_value_zsock_new_req_checked_1=zsock_new_req_checked(endpoints, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_req_checked_1;
}

// zsock_new_req_checked
// file src/zsock.c line 159
struct _zsock_t * zsock_new_req_checked(const char *endpoints, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *sock;
  sock=zsock_new_checked(3, filename, line_nbr);
  signed int return_value_zsock_attach_1;
  if(!(sock == ((struct _zsock_t *)NULL)))
  {
    return_value_zsock_attach_1=zsock_attach(sock, endpoints, (_Bool)0);
    if(!(return_value_zsock_attach_1 == 0))
      zsock_destroy(&sock);

  }

  return sock;
}

// zsock_new_router
// file src/zsock.c line 226
struct _zsock_t * zsock_new_router(const char *endpoints)
{
  struct _zsock_t *return_value_zsock_new_router_checked_1;
  return_value_zsock_new_router_checked_1=zsock_new_router_checked(endpoints, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_router_checked_1;
}

// zsock_new_router_checked
// file src/zsock.c line 216
struct _zsock_t * zsock_new_router_checked(const char *endpoints, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *sock;
  sock=zsock_new_checked(6, filename, line_nbr);
  signed int return_value_zsock_attach_1;
  if(!(sock == ((struct _zsock_t *)NULL)))
  {
    return_value_zsock_attach_1=zsock_attach(sock, endpoints, (_Bool)1);
    if(!(return_value_zsock_attach_1 == 0))
      zsock_destroy(&sock);

  }

  return sock;
}

// zsock_new_stream
// file src/zsock.c line 352
struct _zsock_t * zsock_new_stream(const char *endpoints)
{
  struct _zsock_t *return_value_zsock_new_stream_checked_1;
  return_value_zsock_new_stream_checked_1=zsock_new_stream_checked(endpoints, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_stream_checked_1;
}

// zsock_new_stream_checked
// file src/zsock.c line 338
struct _zsock_t * zsock_new_stream_checked(const char *endpoints, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *sock;
  sock=zsock_new_checked(11, filename, line_nbr);
  signed int return_value_zsock_attach_1;
  if(!(sock == ((struct _zsock_t *)NULL)))
  {
    return_value_zsock_attach_1=zsock_attach(sock, endpoints, (_Bool)0);
    if(!(return_value_zsock_attach_1 == 0))
      zsock_destroy(&sock);

  }

  return sock;
}

// zsock_new_sub
// file src/zsock.c line 150
struct _zsock_t * zsock_new_sub(const char *endpoints, const char *subscribe)
{
  struct _zsock_t *return_value_zsock_new_sub_checked_1;
  return_value_zsock_new_sub_checked_1=zsock_new_sub_checked(endpoints, subscribe, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_sub_checked_1;
}

// zsock_new_sub_checked
// file src/zsock.c line 135
struct _zsock_t * zsock_new_sub_checked(const char *endpoints, const char *subscribe, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *sock;
  sock=zsock_new_checked(2, filename, line_nbr);
  if(!(sock == ((struct _zsock_t *)NULL)))
  {
    signed int return_value_zsock_attach_1;
    return_value_zsock_attach_1=zsock_attach(sock, endpoints, (_Bool)0);
    if(return_value_zsock_attach_1 == 0)
    {
      if(!(subscribe == ((const char *)NULL)))
        zsock_set_subscribe((void *)sock, subscribe);

    }

    else
      zsock_destroy(&sock);
  }

  return sock;
}

// zsock_new_xpub
// file src/zsock.c line 287
struct _zsock_t * zsock_new_xpub(const char *endpoints)
{
  struct _zsock_t *return_value_zsock_new_xpub_checked_1;
  return_value_zsock_new_xpub_checked_1=zsock_new_xpub_checked(endpoints, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_xpub_checked_1;
}

// zsock_new_xpub_checked
// file src/zsock.c line 273
struct _zsock_t * zsock_new_xpub_checked(const char *endpoints, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *sock;
  sock=zsock_new_checked(9, filename, line_nbr);
  signed int return_value_zsock_attach_1;
  if(!(sock == ((struct _zsock_t *)NULL)))
  {
    return_value_zsock_attach_1=zsock_attach(sock, endpoints, (_Bool)1);
    if(!(return_value_zsock_attach_1 == 0))
      zsock_destroy(&sock);

  }

  return sock;
}

// zsock_new_xsub
// file src/zsock.c line 310
struct _zsock_t * zsock_new_xsub(const char *endpoints)
{
  struct _zsock_t *return_value_zsock_new_xsub_checked_1;
  return_value_zsock_new_xsub_checked_1=zsock_new_xsub_checked(endpoints, (const char *)(void *)0, (unsigned long int)0);
  return return_value_zsock_new_xsub_checked_1;
}

// zsock_new_xsub_checked
// file src/zsock.c line 296
struct _zsock_t * zsock_new_xsub_checked(const char *endpoints, const char *filename, unsigned long int line_nbr)
{
  struct _zsock_t *sock;
  sock=zsock_new_checked(10, filename, line_nbr);
  signed int return_value_zsock_attach_1;
  if(!(sock == ((struct _zsock_t *)NULL)))
  {
    return_value_zsock_attach_1=zsock_attach(sock, endpoints, (_Bool)0);
    if(!(return_value_zsock_attach_1 == 0))
      zsock_destroy(&sock);

  }

  return sock;
}

// zsock_option_test
// file src/zsock_option.c line 3206
void zsock_option_test(_Bool verbose)
{
  printf(" * zsock_option: ");
  struct _zsock_t *self;
  self=zsock_new_checked(5, "src/zsock_option.c", (unsigned long int)3214);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_tos((void *)self, 1);
  signed int return_value_zsock_tos_1;
  return_value_zsock_tos_1=zsock_tos((void *)self);
  /* assertion zsock_tos (self) == 1 */
  assert(return_value_zsock_tos_1 == 1);
  zsock_tos((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3219);
  self=zsock_new_checked(6, "src/zsock_option.c", (unsigned long int)3222);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_router_handover((void *)self, 1);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3225);
  self=zsock_new_checked(6, "src/zsock_option.c", (unsigned long int)3228);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_router_mandatory((void *)self, 1);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3231);
  self=zsock_new_checked(5, "src/zsock_option.c", (unsigned long int)3234);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_probe_router((void *)self, 1);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3237);
  self=zsock_new_checked(3, "src/zsock_option.c", (unsigned long int)3240);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_req_relaxed((void *)self, 1);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3243);
  self=zsock_new_checked(3, "src/zsock_option.c", (unsigned long int)3246);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_req_correlate((void *)self, 1);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3249);
  self=zsock_new_checked(8, "src/zsock_option.c", (unsigned long int)3252);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_conflate((void *)self, 1);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3255);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3258);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_zap_domain((void *)self, "test");
  char *zap_domain;
  zap_domain=zsock_zap_domain((void *)self);
  /* assertion zap_domain */
  assert(zap_domain != ((char *)NULL));
  free((void *)zap_domain);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3264);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3267);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_mechanism((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3270);
  self=zsock_new_checked(1, "src/zsock_option.c", (unsigned long int)3273);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_plain_server((void *)self, 1);
  signed int return_value_zsock_plain_server_2;
  return_value_zsock_plain_server_2=zsock_plain_server((void *)self);
  /* assertion zsock_plain_server (self) == 1 */
  assert(return_value_zsock_plain_server_2 == 1);
  zsock_plain_server((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3278);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3281);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_plain_username((void *)self, "test");
  char *plain_username;
  plain_username=zsock_plain_username((void *)self);
  /* assertion plain_username */
  assert(plain_username != ((char *)NULL));
  free((void *)plain_username);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3287);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3290);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_plain_password((void *)self, "test");
  char *plain_password;
  plain_password=zsock_plain_password((void *)self);
  /* assertion plain_password */
  assert(plain_password != ((char *)NULL));
  free((void *)plain_password);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3296);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3299);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_ipv6((void *)self, 1);
  signed int return_value_zsock_ipv6_3;
  return_value_zsock_ipv6_3=zsock_ipv6((void *)self);
  /* assertion zsock_ipv6 (self) == 1 */
  assert(return_value_zsock_ipv6_3 == 1);
  zsock_ipv6((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3304);
  self=zsock_new_checked(5, "src/zsock_option.c", (unsigned long int)3307);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_immediate((void *)self, 1);
  signed int return_value_zsock_immediate_4;
  return_value_zsock_immediate_4=zsock_immediate((void *)self);
  /* assertion zsock_immediate (self) == 1 */
  assert(return_value_zsock_immediate_4 == 1);
  zsock_immediate((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3312);
  self=zsock_new_checked(6, "src/zsock_option.c", (unsigned long int)3315);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_router_raw((void *)self, 1);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3318);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3321);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_ipv4only((void *)self, 1);
  signed int return_value_zsock_ipv4only_5;
  return_value_zsock_ipv4only_5=zsock_ipv4only((void *)self);
  /* assertion zsock_ipv4only (self) == 1 */
  assert(return_value_zsock_ipv4only_5 == 1);
  zsock_ipv4only((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3326);
  self=zsock_new_checked(1, "src/zsock_option.c", (unsigned long int)3329);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_delay_attach_on_connect((void *)self, 1);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3332);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3335);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_type((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3338);
  self=zsock_new_checked(1, "src/zsock_option.c", (unsigned long int)3341);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_sndhwm((void *)self, 1);
  signed int return_value_zsock_sndhwm_6;
  return_value_zsock_sndhwm_6=zsock_sndhwm((void *)self);
  /* assertion zsock_sndhwm (self) == 1 */
  assert(return_value_zsock_sndhwm_6 == 1);
  zsock_sndhwm((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3346);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3349);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_rcvhwm((void *)self, 1);
  signed int return_value_zsock_rcvhwm_7;
  return_value_zsock_rcvhwm_7=zsock_rcvhwm((void *)self);
  /* assertion zsock_rcvhwm (self) == 1 */
  assert(return_value_zsock_rcvhwm_7 == 1);
  zsock_rcvhwm((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3354);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3357);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_affinity((void *)self, 1);
  signed int return_value_zsock_affinity_8;
  return_value_zsock_affinity_8=zsock_affinity((void *)self);
  /* assertion zsock_affinity (self) == 1 */
  assert(return_value_zsock_affinity_8 == 1);
  zsock_affinity((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3362);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3365);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_subscribe((void *)self, "test");
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3368);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3371);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_unsubscribe((void *)self, "test");
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3374);
  self=zsock_new_checked(5, "src/zsock_option.c", (unsigned long int)3377);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_identity((void *)self, "test");
  char *identity;
  identity=zsock_identity((void *)self);
  /* assertion identity */
  assert(identity != ((char *)NULL));
  free((void *)identity);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3383);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3386);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_rate((void *)self, 1);
  signed int return_value_zsock_rate_9;
  return_value_zsock_rate_9=zsock_rate((void *)self);
  /* assertion zsock_rate (self) == 1 */
  assert(return_value_zsock_rate_9 == 1);
  zsock_rate((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3391);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3394);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_recovery_ivl((void *)self, 1);
  signed int return_value_zsock_recovery_ivl_10;
  return_value_zsock_recovery_ivl_10=zsock_recovery_ivl((void *)self);
  /* assertion zsock_recovery_ivl (self) == 1 */
  assert(return_value_zsock_recovery_ivl_10 == 1);
  zsock_recovery_ivl((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3399);
  self=zsock_new_checked(1, "src/zsock_option.c", (unsigned long int)3402);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_sndbuf((void *)self, 1);
  signed int return_value_zsock_sndbuf_11;
  return_value_zsock_sndbuf_11=zsock_sndbuf((void *)self);
  /* assertion zsock_sndbuf (self) == 1 */
  assert(return_value_zsock_sndbuf_11 == 1);
  zsock_sndbuf((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3407);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3410);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_rcvbuf((void *)self, 1);
  signed int return_value_zsock_rcvbuf_12;
  return_value_zsock_rcvbuf_12=zsock_rcvbuf((void *)self);
  /* assertion zsock_rcvbuf (self) == 1 */
  assert(return_value_zsock_rcvbuf_12 == 1);
  zsock_rcvbuf((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3415);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3418);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_linger((void *)self, 1);
  signed int return_value_zsock_linger_13;
  return_value_zsock_linger_13=zsock_linger((void *)self);
  /* assertion zsock_linger (self) == 1 */
  assert(return_value_zsock_linger_13 == 1);
  zsock_linger((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3423);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3426);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_reconnect_ivl((void *)self, 1);
  signed int return_value_zsock_reconnect_ivl_14;
  return_value_zsock_reconnect_ivl_14=zsock_reconnect_ivl((void *)self);
  /* assertion zsock_reconnect_ivl (self) == 1 */
  assert(return_value_zsock_reconnect_ivl_14 == 1);
  zsock_reconnect_ivl((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3431);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3434);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_reconnect_ivl_max((void *)self, 1);
  signed int return_value_zsock_reconnect_ivl_max_15;
  return_value_zsock_reconnect_ivl_max_15=zsock_reconnect_ivl_max((void *)self);
  /* assertion zsock_reconnect_ivl_max (self) == 1 */
  assert(return_value_zsock_reconnect_ivl_max_15 == 1);
  zsock_reconnect_ivl_max((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3439);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3442);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_backlog((void *)self, 1);
  signed int return_value_zsock_backlog_16;
  return_value_zsock_backlog_16=zsock_backlog((void *)self);
  /* assertion zsock_backlog (self) == 1 */
  assert(return_value_zsock_backlog_16 == 1);
  zsock_backlog((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3447);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3450);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_maxmsgsize((void *)self, 1);
  signed int return_value_zsock_maxmsgsize_17;
  return_value_zsock_maxmsgsize_17=zsock_maxmsgsize((void *)self);
  /* assertion zsock_maxmsgsize (self) == 1 */
  assert(return_value_zsock_maxmsgsize_17 == 1);
  zsock_maxmsgsize((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3455);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3458);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_multicast_hops((void *)self, 1);
  signed int return_value_zsock_multicast_hops_18;
  return_value_zsock_multicast_hops_18=zsock_multicast_hops((void *)self);
  /* assertion zsock_multicast_hops (self) == 1 */
  assert(return_value_zsock_multicast_hops_18 == 1);
  zsock_multicast_hops((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3463);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3466);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_rcvtimeo((void *)self, 1);
  signed int return_value_zsock_rcvtimeo_19;
  return_value_zsock_rcvtimeo_19=zsock_rcvtimeo((void *)self);
  /* assertion zsock_rcvtimeo (self) == 1 */
  assert(return_value_zsock_rcvtimeo_19 == 1);
  zsock_rcvtimeo((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3471);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3474);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_sndtimeo((void *)self, 1);
  signed int return_value_zsock_sndtimeo_20;
  return_value_zsock_sndtimeo_20=zsock_sndtimeo((void *)self);
  /* assertion zsock_sndtimeo (self) == 1 */
  assert(return_value_zsock_sndtimeo_20 == 1);
  zsock_sndtimeo((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3479);
  self=zsock_new_checked(9, "src/zsock_option.c", (unsigned long int)3482);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_xpub_verbose((void *)self, 1);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3485);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3488);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_tcp_keepalive((void *)self, 1);
  signed int return_value_zsock_tcp_keepalive_21;
  return_value_zsock_tcp_keepalive_21=zsock_tcp_keepalive((void *)self);
  /* assertion zsock_tcp_keepalive (self) == 1 */
  assert(return_value_zsock_tcp_keepalive_21 == 1);
  zsock_tcp_keepalive((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3493);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3496);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_tcp_keepalive_idle((void *)self, 1);
  signed int return_value_zsock_tcp_keepalive_idle_22;
  return_value_zsock_tcp_keepalive_idle_22=zsock_tcp_keepalive_idle((void *)self);
  /* assertion zsock_tcp_keepalive_idle (self) == 1 */
  assert(return_value_zsock_tcp_keepalive_idle_22 == 1);
  zsock_tcp_keepalive_idle((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3501);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3504);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_tcp_keepalive_cnt((void *)self, 1);
  signed int return_value_zsock_tcp_keepalive_cnt_23;
  return_value_zsock_tcp_keepalive_cnt_23=zsock_tcp_keepalive_cnt((void *)self);
  /* assertion zsock_tcp_keepalive_cnt (self) == 1 */
  assert(return_value_zsock_tcp_keepalive_cnt_23 == 1);
  zsock_tcp_keepalive_cnt((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3509);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3512);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_tcp_keepalive_intvl((void *)self, 1);
  signed int return_value_zsock_tcp_keepalive_intvl_24;
  return_value_zsock_tcp_keepalive_intvl_24=zsock_tcp_keepalive_intvl((void *)self);
  /* assertion zsock_tcp_keepalive_intvl (self) == 1 */
  assert(return_value_zsock_tcp_keepalive_intvl_24 == 1);
  zsock_tcp_keepalive_intvl((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3517);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3520);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_set_tcp_accept_filter((void *)self, "127.0.0.1");
  char *tcp_accept_filter;
  tcp_accept_filter=zsock_tcp_accept_filter((void *)self);
  /* assertion tcp_accept_filter */
  assert(tcp_accept_filter != ((char *)NULL));
  free((void *)tcp_accept_filter);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3526);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3529);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_rcvmore((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3532);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3535);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_fd((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3538);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3541);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  zsock_events((void *)self);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3544);
  self=zsock_new_checked(2, "src/zsock_option.c", (unsigned long int)3547);
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  char *last_endpoint;
  last_endpoint=zsock_last_endpoint((void *)self);
  /* assertion last_endpoint */
  assert(last_endpoint != ((char *)NULL));
  free((void *)last_endpoint);
  zsock_destroy_checked(&self, "src/zsock_option.c", (unsigned long int)3552);
  printf("OK\n");
}

// zsock_plain_password
// file src/zsock_option.c line 325
char * zsock_plain_password(void *self)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int option_len = (unsigned long int)255;
  char *plain_password;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link24(option_len, "src/zsock_option.c", (unsigned int)330);
  plain_password = (char *)return_value_safe_malloc_1;
  void *return_value_zsock_resolve_2;
  return_value_zsock_resolve_2=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_2, 46, (void *)plain_password, &option_len);
  return (char *)plain_password;
}

// zsock_plain_server
// file src/zsock_option.c line 259
signed int zsock_plain_server(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int plain_server;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 44, (void *)&plain_server, &option_len);
  return plain_server;
}

// zsock_plain_username
// file src/zsock_option.c line 292
char * zsock_plain_username(void *self)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int option_len = (unsigned long int)255;
  char *plain_username;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link24(option_len, "src/zsock_option.c", (unsigned int)297);
  plain_username = (char *)return_value_safe_malloc_1;
  void *return_value_zsock_resolve_2;
  return_value_zsock_resolve_2=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_2, 45, (void *)plain_username, &option_len);
  return (char *)plain_username;
}

// zsock_rate
// file src/zsock_option.c line 993
signed int zsock_rate(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int rate;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 8, (void *)&rate, &option_len);
  return rate;
}

// zsock_rcvbuf
// file src/zsock_option.c line 1092
signed int zsock_rcvbuf(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int rcvbuf;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 12, (void *)&rcvbuf, &option_len);
  return rcvbuf;
}

// zsock_rcvhwm
// file src/zsock_option.c line 848
signed int zsock_rcvhwm(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int rcvhwm;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 24, (void *)&rcvhwm, &option_len);
  return rcvhwm;
}

// zsock_rcvmore
// file src/../include/zsock_option.h line 69
signed int zsock_rcvmore(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int rcvmore;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 13, (void *)&rcvmore, &option_len);
  return rcvmore;
}

// zsock_rcvtimeo
// file src/zsock_option.c line 1324
signed int zsock_rcvtimeo(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int rcvtimeo;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 27, (void *)&rcvtimeo, &option_len);
  return rcvtimeo;
}

// zsock_reconnect_ivl
// file src/zsock_option.c line 1158
signed int zsock_reconnect_ivl(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int reconnect_ivl;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 18, (void *)&reconnect_ivl, &option_len);
  return reconnect_ivl;
}

// zsock_reconnect_ivl_max
// file src/zsock_option.c line 1191
signed int zsock_reconnect_ivl_max(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int reconnect_ivl_max;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 21, (void *)&reconnect_ivl_max, &option_len);
  return reconnect_ivl_max;
}

// zsock_recovery_ivl
// file src/zsock_option.c line 1026
signed int zsock_recovery_ivl(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int recovery_ivl;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 9, (void *)&recovery_ivl, &option_len);
  return recovery_ivl;
}

// zsock_recv
// file src/../include/zsock.h line 224
signed int zsock_recv(void *self, const char *picture, ...)
{
  void **argptr = (void **)&picture;
  signed int rc;
  rc=zsock_vrecv(self, picture, argptr);
  argptr = ((void **)NULL);
  return rc;
}

// zsock_resolve
// file src/../include/zsock.h line 304
void * zsock_resolve(void *self)
{
  /* assertion self */
  assert(self != NULL);
  _Bool return_value_zsock_is_3;
  return_value_zsock_is_3=zsock_is(self);
  _Bool return_value_zactor_is_2;
  void *return_value_zactor_resolve_1;
  if(!(return_value_zsock_is_3 == (_Bool)0))
    return ((struct _zsock_t *)self)->handle;

  else
  {
    return_value_zactor_is_2=zactor_is(self);
    if(!(return_value_zactor_is_2 == (_Bool)0))
    {
      return_value_zactor_resolve_1=zactor_resolve(self);
      return return_value_zactor_resolve_1;
    }

  }
  signed int sock_type = -1;
  unsigned int sock_type_size = (unsigned int)sizeof(unsigned int) /*4ul*/ ;
  signed int rc;
  rc=getsockopt(*((signed int *)self), 1, 3, (void *)(char *)&sock_type, &sock_type_size);
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  if(rc == 0)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    if(rc == -1)
    {
      return_value___errno_location_4=__errno_location();
      tmp_if_expr_5 = *return_value___errno_location_4 == 88 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_5 = (_Bool)0;
    tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_6)
    return (void *)0;

  else
    return self;
}

// zsock_send
// file src/../include/zsock.h line 189
signed int zsock_send(void *self, const char *picture, ...)
{
  void **argptr = (void **)&picture;
  signed int rc;
  rc=zsock_vsend(self, picture, argptr);
  argptr = ((void **)NULL);
  return rc;
}

// zsock_set_affinity
// file src/zsock_option.c line 866
void zsock_set_affinity(void *self, signed int affinity)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int value = (unsigned long int)affinity;
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 4, (const void *)&value, sizeof(unsigned long int) /*8ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_backlog
// file src/zsock_option.c line 1209
void zsock_set_backlog(void *self, signed int backlog)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 19, (const void *)&backlog, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_conflate
// file src/zsock_option.c line 170
void zsock_set_conflate(void *self, signed int conflate)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zsock_type_7;
  return_value_zsock_type_7=zsock_type(self);
  signed int return_value_zsock_type_6;
  signed int return_value_zsock_type_5;
  signed int return_value_zsock_type_4;
  signed int return_value_zsock_type_3;
  if(!(return_value_zsock_type_7 == 8))
  {
    return_value_zsock_type_6=zsock_type(self);
    if(!(return_value_zsock_type_6 == 7))
    {
      return_value_zsock_type_5=zsock_type(self);
      if(!(return_value_zsock_type_5 == 1))
      {
        return_value_zsock_type_4=zsock_type(self);
        if(!(return_value_zsock_type_4 == 2))
        {
          return_value_zsock_type_3=zsock_type(self);
          if(!(return_value_zsock_type_3 == 5))
          {
            signed int return_value_zsock_type_1;
            return_value_zsock_type_1=zsock_type(self);
            char *return_value_zsys_sockname_2;
            return_value_zsys_sockname_2=zsys_sockname(return_value_zsock_type_1);
            printf("ZMQ_CONFLATE is not valid on %s sockets\n", return_value_zsys_sockname_2);
            /* assertion 0 */
            assert(0 != 0);
          }

        }

      }

    }

  }

  signed int rc;
  void *return_value_zsock_resolve_8;
  return_value_zsock_resolve_8=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_8, 54, (const void *)&conflate, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_10;
  signed int return_value_zmq_errno_9;
  if(rc == 0)
    tmp_if_expr_10 = (_Bool)1;

  else
  {
    return_value_zmq_errno_9=zmq_errno();
    tmp_if_expr_10 = return_value_zmq_errno_9 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_10);
}

// zsock_set_curve_publickey
// file src/zsock_option.c line 376
void zsock_set_curve_publickey(void *self, const char *curve_publickey)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(curve_publickey);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 48, (const void *)curve_publickey, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsock_set_curve_publickey_bin
// file src/../include/zsock_option.h line 88
void zsock_set_curve_publickey_bin(void *self, const unsigned char *curve_publickey)
{
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 48, (const void *)curve_publickey, (unsigned long int)32);
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_curve_secretkey
// file src/zsock_option.c line 423
void zsock_set_curve_secretkey(void *self, const char *curve_secretkey)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(curve_secretkey);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 49, (const void *)curve_secretkey, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsock_set_curve_secretkey_bin
// file src/../include/zsock_option.h line 90
void zsock_set_curve_secretkey_bin(void *self, const unsigned char *curve_secretkey)
{
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 49, (const void *)curve_secretkey, (unsigned long int)32);
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_curve_server
// file src/../include/zsock_option.h line 86
void zsock_set_curve_server(void *self, signed int curve_server)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 47, (const void *)&curve_server, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_curve_serverkey
// file src/../include/zsock_option.h line 91
void zsock_set_curve_serverkey(void *self, const char *curve_serverkey)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(curve_serverkey);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 50, (const void *)curve_serverkey, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsock_set_curve_serverkey_bin
// file src/zsock_option.c line 485
void zsock_set_curve_serverkey_bin(void *self, const unsigned char *curve_serverkey)
{
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 50, (const void *)curve_serverkey, (unsigned long int)32);
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_delay_attach_on_connect
// file src/zsock_option.c line 767
void zsock_set_delay_attach_on_connect(void *self, signed int delay_attach_on_connect)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 39, (const void *)&delay_attach_on_connect, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_gssapi_plaintext
// file src/zsock_option.c line 550
void zsock_set_gssapi_plaintext(void *self, signed int gssapi_plaintext)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 65, (const void *)&gssapi_plaintext, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_gssapi_principal
// file src/zsock_option.c line 583
void zsock_set_gssapi_principal(void *self, const char *gssapi_principal)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(gssapi_principal);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 63, (const void *)gssapi_principal, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsock_set_gssapi_server
// file src/zsock_option.c line 517
void zsock_set_gssapi_server(void *self, signed int gssapi_server)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 62, (const void *)&gssapi_server, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_gssapi_service_principal
// file src/zsock_option.c line 616
void zsock_set_gssapi_service_principal(void *self, const char *gssapi_service_principal)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(gssapi_service_principal);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 64, (const void *)gssapi_service_principal, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsock_set_identity
// file src/zsock_option.c line 938
void zsock_set_identity(void *self, const char *identity)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zsock_type_6;
  return_value_zsock_type_6=zsock_type(self);
  signed int return_value_zsock_type_5;
  signed int return_value_zsock_type_4;
  signed int return_value_zsock_type_3;
  if(!(return_value_zsock_type_6 == 3))
  {
    return_value_zsock_type_5=zsock_type(self);
    if(!(return_value_zsock_type_5 == 4))
    {
      return_value_zsock_type_4=zsock_type(self);
      if(!(return_value_zsock_type_4 == 5))
      {
        return_value_zsock_type_3=zsock_type(self);
        if(!(return_value_zsock_type_3 == 6))
        {
          signed int return_value_zsock_type_1;
          return_value_zsock_type_1=zsock_type(self);
          char *return_value_zsys_sockname_2;
          return_value_zsys_sockname_2=zsys_sockname(return_value_zsock_type_1);
          printf("ZMQ_IDENTITY is not valid on %s sockets\n", return_value_zsys_sockname_2);
          /* assertion 0 */
          assert(0 != 0);
        }

      }

    }

  }

  signed int rc;
  void *return_value_zsock_resolve_7;
  return_value_zsock_resolve_7=zsock_resolve(self);
  unsigned long int return_value_strlen_8;
  return_value_strlen_8=strlen(identity);
  rc=zmq_setsockopt(return_value_zsock_resolve_7, 5, (const void *)identity, return_value_strlen_8);
  _Bool tmp_if_expr_10;
  signed int return_value_zmq_errno_9;
  if(rc == 0)
    tmp_if_expr_10 = (_Bool)1;

  else
  {
    return_value_zmq_errno_9=zmq_errno();
    tmp_if_expr_10 = return_value_zmq_errno_9 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_10);
}

// zsock_set_immediate
// file src/zsock_option.c line 682
void zsock_set_immediate(void *self, signed int immediate)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 39, (const void *)&immediate, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_ipv4only
// file src/zsock_option.c line 734
void zsock_set_ipv4only(void *self, signed int ipv4only)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 31, (const void *)&ipv4only, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_ipv6
// file src/zsock_option.c line 649
void zsock_set_ipv6(void *self, signed int ipv6)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 42, (const void *)&ipv6, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_linger
// file src/zsock_option.c line 1110
void zsock_set_linger(void *self, signed int linger)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 17, (const void *)&linger, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_maxmsgsize
// file src/zsock_option.c line 1242
void zsock_set_maxmsgsize(void *self, signed int maxmsgsize)
{
  /* assertion self */
  assert(self != NULL);
  signed long int value = (signed long int)maxmsgsize;
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 22, (const void *)&value, sizeof(signed long int) /*8ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_multicast_hops
// file src/zsock_option.c line 1276
void zsock_set_multicast_hops(void *self, signed int multicast_hops)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 25, (const void *)&multicast_hops, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_plain_password
// file src/../include/zsock_option.h line 85
void zsock_set_plain_password(void *self, const char *plain_password)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(plain_password);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 46, (const void *)plain_password, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsock_set_plain_server
// file src/../include/zsock_option.h line 83
void zsock_set_plain_server(void *self, signed int plain_server)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 44, (const void *)&plain_server, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_plain_username
// file src/../include/zsock_option.h line 84
void zsock_set_plain_username(void *self, const char *plain_username)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(plain_username);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 45, (const void *)plain_username, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsock_set_probe_router
// file src/zsock_option.c line 111
void zsock_set_probe_router(void *self, signed int probe_router)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zsock_type_5;
  return_value_zsock_type_5=zsock_type(self);
  signed int return_value_zsock_type_4;
  signed int return_value_zsock_type_3;
  if(!(return_value_zsock_type_5 == 6))
  {
    return_value_zsock_type_4=zsock_type(self);
    if(!(return_value_zsock_type_4 == 5))
    {
      return_value_zsock_type_3=zsock_type(self);
      if(!(return_value_zsock_type_3 == 3))
      {
        signed int return_value_zsock_type_1;
        return_value_zsock_type_1=zsock_type(self);
        char *return_value_zsys_sockname_2;
        return_value_zsys_sockname_2=zsys_sockname(return_value_zsock_type_1);
        printf("ZMQ_PROBE_ROUTER is not valid on %s sockets\n", return_value_zsys_sockname_2);
        /* assertion 0 */
        assert(0 != 0);
      }

    }

  }

  signed int rc;
  void *return_value_zsock_resolve_6;
  return_value_zsock_resolve_6=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_6, 51, (const void *)&probe_router, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_8;
  signed int return_value_zmq_errno_7;
  if(rc == 0)
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    return_value_zmq_errno_7=zmq_errno();
    tmp_if_expr_8 = return_value_zmq_errno_7 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_8);
}

// zsock_set_rate
// file src/zsock_option.c line 978
void zsock_set_rate(void *self, signed int rate)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 8, (const void *)&rate, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_rcvbuf
// file src/zsock_option.c line 1077
void zsock_set_rcvbuf(void *self, signed int rcvbuf)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 12, (const void *)&rcvbuf, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_rcvhwm
// file src/../include/zsock_option.h line 103
void zsock_set_rcvhwm(void *self, signed int rcvhwm)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 24, (const void *)&rcvhwm, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_rcvtimeo
// file src/../include/zsock_option.h line 118
void zsock_set_rcvtimeo(void *self, signed int rcvtimeo)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 27, (const void *)&rcvtimeo, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_reconnect_ivl
// file src/zsock_option.c line 1143
void zsock_set_reconnect_ivl(void *self, signed int reconnect_ivl)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 18, (const void *)&reconnect_ivl, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_reconnect_ivl_max
// file src/zsock_option.c line 1176
void zsock_set_reconnect_ivl_max(void *self, signed int reconnect_ivl_max)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 21, (const void *)&reconnect_ivl_max, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_recovery_ivl
// file src/zsock_option.c line 1011
void zsock_set_recovery_ivl(void *self, signed int recovery_ivl)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 9, (const void *)&recovery_ivl, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_req_correlate
// file src/zsock_option.c line 151
void zsock_set_req_correlate(void *self, signed int req_correlate)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zsock_type_3;
  return_value_zsock_type_3=zsock_type(self);
  if(!(return_value_zsock_type_3 == 3))
  {
    signed int return_value_zsock_type_1;
    return_value_zsock_type_1=zsock_type(self);
    char *return_value_zsys_sockname_2;
    return_value_zsys_sockname_2=zsys_sockname(return_value_zsock_type_1);
    printf("ZMQ_REQ_CORRELATE is not valid on %s sockets\n", return_value_zsys_sockname_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  void *return_value_zsock_resolve_4;
  return_value_zsock_resolve_4=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_4, 52, (const void *)&req_correlate, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_6;
  signed int return_value_zmq_errno_5;
  if(rc == 0)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_zmq_errno_5=zmq_errno();
    tmp_if_expr_6 = return_value_zmq_errno_5 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_6);
}

// zsock_set_req_relaxed
// file src/zsock_option.c line 132
void zsock_set_req_relaxed(void *self, signed int req_relaxed)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zsock_type_3;
  return_value_zsock_type_3=zsock_type(self);
  if(!(return_value_zsock_type_3 == 3))
  {
    signed int return_value_zsock_type_1;
    return_value_zsock_type_1=zsock_type(self);
    char *return_value_zsys_sockname_2;
    return_value_zsys_sockname_2=zsys_sockname(return_value_zsock_type_1);
    printf("ZMQ_REQ_RELAXED is not valid on %s sockets\n", return_value_zsys_sockname_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  void *return_value_zsock_resolve_4;
  return_value_zsock_resolve_4=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_4, 53, (const void *)&req_relaxed, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_6;
  signed int return_value_zmq_errno_5;
  if(rc == 0)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_zmq_errno_5=zmq_errno();
    tmp_if_expr_6 = return_value_zmq_errno_5 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_6);
}

// zsock_set_router_handover
// file src/zsock_option.c line 73
void zsock_set_router_handover(void *self, signed int router_handover)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zsock_type_3;
  return_value_zsock_type_3=zsock_type(self);
  if(!(return_value_zsock_type_3 == 6))
  {
    signed int return_value_zsock_type_1;
    return_value_zsock_type_1=zsock_type(self);
    char *return_value_zsys_sockname_2;
    return_value_zsys_sockname_2=zsys_sockname(return_value_zsock_type_1);
    printf("ZMQ_ROUTER_HANDOVER is not valid on %s sockets\n", return_value_zsys_sockname_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  void *return_value_zsock_resolve_4;
  return_value_zsock_resolve_4=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_4, 56, (const void *)&router_handover, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_6;
  signed int return_value_zmq_errno_5;
  if(rc == 0)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_zmq_errno_5=zmq_errno();
    tmp_if_expr_6 = return_value_zmq_errno_5 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_6);
}

// zsock_set_router_mandatory
// file src/zsock_option.c line 92
void zsock_set_router_mandatory(void *self, signed int router_mandatory)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zsock_type_3;
  return_value_zsock_type_3=zsock_type(self);
  if(!(return_value_zsock_type_3 == 6))
  {
    signed int return_value_zsock_type_1;
    return_value_zsock_type_1=zsock_type(self);
    char *return_value_zsys_sockname_2;
    return_value_zsys_sockname_2=zsys_sockname(return_value_zsock_type_1);
    printf("ZMQ_ROUTER_MANDATORY is not valid on %s sockets\n", return_value_zsys_sockname_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  void *return_value_zsock_resolve_4;
  return_value_zsock_resolve_4=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_4, 33, (const void *)&router_mandatory, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_6;
  signed int return_value_zmq_errno_5;
  if(rc == 0)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_zmq_errno_5=zmq_errno();
    tmp_if_expr_6 = return_value_zmq_errno_5 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_6);
}

// zsock_set_router_raw
// file src/zsock_option.c line 715
void zsock_set_router_raw(void *self, signed int router_raw)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zsock_type_3;
  return_value_zsock_type_3=zsock_type(self);
  if(!(return_value_zsock_type_3 == 6))
  {
    signed int return_value_zsock_type_1;
    return_value_zsock_type_1=zsock_type(self);
    char *return_value_zsys_sockname_2;
    return_value_zsys_sockname_2=zsys_sockname(return_value_zsock_type_1);
    printf("ZMQ_ROUTER_RAW is not valid on %s sockets\n", return_value_zsys_sockname_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  void *return_value_zsock_resolve_4;
  return_value_zsock_resolve_4=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_4, 41, (const void *)&router_raw, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_6;
  signed int return_value_zmq_errno_5;
  if(rc == 0)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_zmq_errno_5=zmq_errno();
    tmp_if_expr_6 = return_value_zmq_errno_5 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_6);
}

// zsock_set_sndbuf
// file src/zsock_option.c line 1044
void zsock_set_sndbuf(void *self, signed int sndbuf)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 11, (const void *)&sndbuf, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_sndhwm
// file src/../include/zsock_option.h line 102
void zsock_set_sndhwm(void *self, signed int sndhwm)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 23, (const void *)&sndhwm, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_sndtimeo
// file src/../include/zsock_option.h line 119
void zsock_set_sndtimeo(void *self, signed int sndtimeo)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 28, (const void *)&sndtimeo, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_subscribe
// file src/../include/zsock_option.h line 105
void zsock_set_subscribe(void *self, const char *subscribe)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zsock_type_3;
  return_value_zsock_type_3=zsock_type(self);
  if(!(return_value_zsock_type_3 == 2))
  {
    signed int return_value_zsock_type_1;
    return_value_zsock_type_1=zsock_type(self);
    char *return_value_zsys_sockname_2;
    return_value_zsys_sockname_2=zsys_sockname(return_value_zsock_type_1);
    printf("ZMQ_SUBSCRIBE is not valid on %s sockets\n", return_value_zsys_sockname_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  void *return_value_zsock_resolve_4;
  return_value_zsock_resolve_4=zsock_resolve(self);
  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen(subscribe);
  rc=zmq_setsockopt(return_value_zsock_resolve_4, 6, (const void *)subscribe, return_value_strlen_5);
  _Bool tmp_if_expr_7;
  signed int return_value_zmq_errno_6;
  if(rc == 0)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_zmq_errno_6=zmq_errno();
    tmp_if_expr_7 = return_value_zmq_errno_6 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_7);
}

// zsock_set_tcp_accept_filter
// file src/zsock_option.c line 1526
void zsock_set_tcp_accept_filter(void *self, const char *tcp_accept_filter)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(tcp_accept_filter);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 38, (const void *)tcp_accept_filter, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsock_set_tcp_keepalive
// file src/zsock_option.c line 1394
void zsock_set_tcp_keepalive(void *self, signed int tcp_keepalive)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 34, (const void *)&tcp_keepalive, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_tcp_keepalive_cnt
// file src/zsock_option.c line 1460
void zsock_set_tcp_keepalive_cnt(void *self, signed int tcp_keepalive_cnt)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 35, (const void *)&tcp_keepalive_cnt, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_tcp_keepalive_idle
// file src/zsock_option.c line 1427
void zsock_set_tcp_keepalive_idle(void *self, signed int tcp_keepalive_idle)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 36, (const void *)&tcp_keepalive_idle, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_tcp_keepalive_intvl
// file src/zsock_option.c line 1493
void zsock_set_tcp_keepalive_intvl(void *self, signed int tcp_keepalive_intvl)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 37, (const void *)&tcp_keepalive_intvl, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_tos
// file src/zsock_option.c line 40
void zsock_set_tos(void *self, signed int tos)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 57, (const void *)&tos, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsock_set_unbounded
// file src/../include/zsock.h line 271
void zsock_set_unbounded(void *self)
{
  zsock_set_sndhwm(self, 0);
  zsock_set_rcvhwm(self, 0);
}

// zsock_set_unsubscribe
// file src/zsock_option.c line 919
void zsock_set_unsubscribe(void *self, const char *unsubscribe)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zsock_type_3;
  return_value_zsock_type_3=zsock_type(self);
  if(!(return_value_zsock_type_3 == 2))
  {
    signed int return_value_zsock_type_1;
    return_value_zsock_type_1=zsock_type(self);
    char *return_value_zsys_sockname_2;
    return_value_zsys_sockname_2=zsys_sockname(return_value_zsock_type_1);
    printf("ZMQ_UNSUBSCRIBE is not valid on %s sockets\n", return_value_zsys_sockname_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  void *return_value_zsock_resolve_4;
  return_value_zsock_resolve_4=zsock_resolve(self);
  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen(unsubscribe);
  rc=zmq_setsockopt(return_value_zsock_resolve_4, 7, (const void *)unsubscribe, return_value_strlen_5);
  _Bool tmp_if_expr_7;
  signed int return_value_zmq_errno_6;
  if(rc == 0)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_zmq_errno_6=zmq_errno();
    tmp_if_expr_7 = return_value_zmq_errno_6 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_7);
}

// zsock_set_xpub_verbose
// file src/zsock_option.c line 1375
void zsock_set_xpub_verbose(void *self, signed int xpub_verbose)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zsock_type_3;
  return_value_zsock_type_3=zsock_type(self);
  if(!(return_value_zsock_type_3 == 9))
  {
    signed int return_value_zsock_type_1;
    return_value_zsock_type_1=zsock_type(self);
    char *return_value_zsys_sockname_2;
    return_value_zsys_sockname_2=zsys_sockname(return_value_zsock_type_1);
    printf("ZMQ_XPUB_VERBOSE is not valid on %s sockets\n", return_value_zsys_sockname_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  void *return_value_zsock_resolve_4;
  return_value_zsock_resolve_4=zsock_resolve(self);
  rc=zmq_setsockopt(return_value_zsock_resolve_4, 40, (const void *)&xpub_verbose, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_6;
  signed int return_value_zmq_errno_5;
  if(rc == 0)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_zmq_errno_5=zmq_errno();
    tmp_if_expr_6 = return_value_zmq_errno_5 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_6);
}

// zsock_set_zap_domain
// file src/../include/zsock_option.h line 82
void zsock_set_zap_domain(void *self, const char *zap_domain)
{
  /* assertion self */
  assert(self != NULL);
  signed int rc;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(zap_domain);
  rc=zmq_setsockopt(return_value_zsock_resolve_1, 55, (const void *)zap_domain, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsock_signal
// file src/../include/zsock.h line 279
signed int zsock_signal(void *self, unsigned char status)
{
  /* assertion self */
  assert(self != NULL);
  struct _zmsg_t *msg;
  msg=zmsg_new_signal(status);
  signed int return_value_zmsg_send_1;
  return_value_zmsg_send_1=zmsg_send(&msg, self);
  return return_value_zmsg_send_1;
}

// zsock_sndbuf
// file src/zsock_option.c line 1059
signed int zsock_sndbuf(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int sndbuf;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 11, (void *)&sndbuf, &option_len);
  return sndbuf;
}

// zsock_sndhwm
// file src/zsock_option.c line 815
signed int zsock_sndhwm(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int sndhwm;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 23, (void *)&sndhwm, &option_len);
  return sndhwm;
}

// zsock_sndtimeo
// file src/zsock_option.c line 1357
signed int zsock_sndtimeo(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int sndtimeo;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 28, (void *)&sndtimeo, &option_len);
  return sndtimeo;
}

// zsock_tcp_accept_filter
// file src/zsock_option.c line 1541
char * zsock_tcp_accept_filter(void *self)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int option_len = (unsigned long int)255;
  char *tcp_accept_filter;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link24(option_len, "src/zsock_option.c", (unsigned int)1546);
  tcp_accept_filter = (char *)return_value_safe_malloc_1;
  void *return_value_zsock_resolve_2;
  return_value_zsock_resolve_2=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_2, 38, (void *)tcp_accept_filter, &option_len);
  return (char *)tcp_accept_filter;
}

// zsock_tcp_keepalive
// file src/zsock_option.c line 1409
signed int zsock_tcp_keepalive(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int tcp_keepalive;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 34, (void *)&tcp_keepalive, &option_len);
  return tcp_keepalive;
}

// zsock_tcp_keepalive_cnt
// file src/zsock_option.c line 1475
signed int zsock_tcp_keepalive_cnt(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int tcp_keepalive_cnt;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 35, (void *)&tcp_keepalive_cnt, &option_len);
  return tcp_keepalive_cnt;
}

// zsock_tcp_keepalive_idle
// file src/zsock_option.c line 1442
signed int zsock_tcp_keepalive_idle(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int tcp_keepalive_idle;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 36, (void *)&tcp_keepalive_idle, &option_len);
  return tcp_keepalive_idle;
}

// zsock_tcp_keepalive_intvl
// file src/zsock_option.c line 1508
signed int zsock_tcp_keepalive_intvl(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int tcp_keepalive_intvl;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 37, (void *)&tcp_keepalive_intvl, &option_len);
  return tcp_keepalive_intvl;
}

// zsock_test
// file src/zsock.c line 1540
void zsock_test(_Bool verbose)
{
  printf(" * zsock: ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  struct _zsock_t *writer;
  writer=zsock_new_push("@tcp://127.0.0.1:5560");
  /* assertion writer */
  assert(writer != ((struct _zsock_t *)NULL));
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve((void *)writer);
  /* assertion zsock_resolve (writer) != writer */
  assert((struct _zsock_t *)return_value_zsock_resolve_1 != writer);
  const char *return_value_zsock_type_str_2;
  return_value_zsock_type_str_2=zsock_type_str(writer);
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(return_value_zsock_type_str_2, "PUSH");
  /* assertion (!strcmp ((zsock_type_str (writer)), ("PUSH"))) */
  assert(!(return_value_strcmp_3 != 0));
  signed int rc;
  rc=zsock_unbind(writer, "tcp://127.0.0.1:%d", 5560);
  /* assertion rc == 0 */
  assert(rc == 0);
  zclock_sleep(100);
  rc=zsock_bind(writer, "tcp://127.0.0.1:%d", 5560);
  /* assertion rc == 5560 */
  assert(rc == 5560);
  const char *return_value_zsock_endpoint_4;
  return_value_zsock_endpoint_4=zsock_endpoint(writer);
  signed int return_value_strcmp_5;
  return_value_strcmp_5=strcmp(return_value_zsock_endpoint_4, "tcp://127.0.0.1:5560");
  /* assertion (!strcmp ((zsock_endpoint (writer)), ("tcp://127.0.0.1:5560"))) */
  assert(!(return_value_strcmp_5 != 0));
  struct _zsock_t *reader;
  reader=zsock_new_pull(">tcp://127.0.0.1:5560");
  /* assertion reader */
  assert(reader != ((struct _zsock_t *)NULL));
  void *return_value_zsock_resolve_6;
  return_value_zsock_resolve_6=zsock_resolve((void *)reader);
  /* assertion zsock_resolve (reader) != reader */
  assert((struct _zsock_t *)return_value_zsock_resolve_6 != reader);
  const char *return_value_zsock_type_str_7;
  return_value_zsock_type_str_7=zsock_type_str(reader);
  signed int return_value_strcmp_8;
  return_value_strcmp_8=strcmp(return_value_zsock_type_str_7, "PULL");
  /* assertion (!strcmp ((zsock_type_str (reader)), ("PULL"))) */
  assert(!(return_value_strcmp_8 != 0));
  zstr_send((void *)writer, "Hello, World");
  struct _zmsg_t *msg;
  msg=zmsg_recv((void *)reader);
  /* assertion msg */
  assert(msg != ((struct _zmsg_t *)NULL));
  char *string;
  string=zmsg_popstr(msg);
  signed int return_value_strcmp_9;
  return_value_strcmp_9=strcmp(string, "Hello, World");
  /* assertion (!strcmp ((string), ("Hello, World"))) */
  assert(!(return_value_strcmp_9 != 0));
  free((void *)string);
  zmsg_destroy(&msg);
  signed int fd;
  fd=zsock_fd((void *)reader);
  void *return_value_zsock_resolve_10;
  return_value_zsock_resolve_10=zsock_resolve((void *)&fd);
  /* assertion zsock_resolve ((void *) &fd) == ((void *)0) */
  assert(return_value_zsock_resolve_10 == (void *)0);
  signed int port;
  port=zsock_bind(writer, "tcp://127.0.0.1:*");
  /* assertion port >= 0xc000 && port <= 0xffff */
  assert(port >= 0xc000 && port <= 0xffff);
  port=zsock_bind(writer, "tcp://127.0.0.1:*[50000-]");
  /* assertion port >= 50000 && port <= 0xffff */
  assert(port >= 50000 && port <= 0xffff);
  port=zsock_bind(writer, "tcp://127.0.0.1:*[-50001]");
  /* assertion port >= 0xc000 && port <= 50001 */
  assert(port >= 0xc000 && port <= 50001);
  port=zsock_bind(writer, "tcp://127.0.0.1:*[60000-60050]");
  /* assertion port >= 60000 && port <= 60050 */
  assert(port >= 60000 && port <= 60050);
  port=zsock_bind(writer, "tcp://127.0.0.1:!");
  /* assertion port >= 0xc000 && port <= 0xffff */
  assert(port >= 0xc000 && port <= 0xffff);
  port=zsock_bind(writer, "tcp://127.0.0.1:![50000-]");
  /* assertion port >= 50000 && port <= 0xffff */
  assert(port >= 50000 && port <= 0xffff);
  port=zsock_bind(writer, "tcp://127.0.0.1:![-50001]");
  /* assertion port >= 0xc000 && port <= 50001 */
  assert(port >= 0xc000 && port <= 50001);
  port=zsock_bind(writer, "tcp://127.0.0.1:![60000-60050]");
  /* assertion port >= 60000 && port <= 60050 */
  assert(port >= 60000 && port <= 60050);
  struct _zsock_t *server;
  server=zsock_new(5);
  /* assertion server */
  assert(server != ((struct _zsock_t *)NULL));
  rc=zsock_attach(server, "@inproc://myendpoint,tcp://127.0.0.1:5556,inproc://others", (_Bool)1);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsock_attach(server, "", (_Bool)0);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsock_attach(server, (const char *)(void *)0, (_Bool)1);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsock_attach(server, ">a,@b, c,, ", (_Bool)0);
  /* assertion rc == -1 */
  assert(rc == -1);
  zsock_destroy(&server);
  rc=zsock_bind(writer, "inproc://test.%s", (const void *)"writer");
  /* assertion rc == 0 */
  assert(rc == 0);
  const char *return_value_zsock_endpoint_11;
  return_value_zsock_endpoint_11=zsock_endpoint(writer);
  signed int return_value_strcmp_12;
  return_value_strcmp_12=strcmp(return_value_zsock_endpoint_11, "inproc://test.writer");
  /* assertion (!strcmp ((zsock_endpoint (writer)), ("inproc://test.writer"))) */
  assert(!(return_value_strcmp_12 != 0));
  rc=zsock_connect(reader, "txp://127.0.0.1:5560");
  /* assertion rc == -1 */
  assert(rc == -1);
  rc=zsock_signal((void *)writer, (unsigned char)123);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsock_wait((void *)reader);
  /* assertion rc == 123 */
  assert(rc == 123);
  unsigned char number1 = (unsigned char)123;
  unsigned short int number2 = (unsigned short int)(123 * 123);
  unsigned int number4 = (unsigned int)(123 * 123 * 123);
  unsigned long int number8 = (unsigned long int)(123 * 123 * 123 * 123);
  struct _zchunk_t *chunk;
  chunk=zchunk_new((const void *)"HELLO", (unsigned long int)5);
  /* assertion chunk */
  assert(chunk != ((struct _zchunk_t *)NULL));
  struct _zframe_t *frame;
  frame=zframe_new((const void *)"WORLD", (unsigned long int)5);
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  struct _zhashx_t *hash;
  hash=zhashx_new();
  /* assertion hash */
  assert(hash != ((struct _zhashx_t *)NULL));
  struct _zuuid_t *uuid;
  uuid=zuuid_new();
  /* assertion uuid */
  assert(uuid != ((struct _zuuid_t *)NULL));
  zhashx_autofree(hash);
  zhashx_insert(hash, (const void *)"1", (void *)"value A");
  zhashx_insert(hash, (const void *)"2", (void *)"value B");
  char *original = "pointer";
  zsock_send((void *)writer, "i1248zsbcfUhp", -12345, number1, number2, number4, number8, (const void *)"This is a string", (const void *)"ABCDE", 5, chunk, frame, uuid, hash, original);
  char *uuid_str;
  const char *return_value_zuuid_str_13;
  return_value_zuuid_str_13=zuuid_str(uuid);
  uuid_str=strdup(return_value_zuuid_str_13);
  zchunk_destroy(&chunk);
  zframe_destroy(&frame);
  zuuid_destroy(&uuid);
  zhashx_destroy(&hash);
  signed int integer;
  unsigned char *data;
  unsigned long int size;
  char *pointer;
  number1 = (unsigned char)0;
  number2 = (unsigned short int)number1;
  number4 = (unsigned int)number2;
  number8 = (unsigned long int)number4;
  rc=zsock_recv((void *)reader, "i1248zsbcfUhp", &integer, &number1, &number2, &number4, &number8, &string, &data, &size, &chunk, &frame, &uuid, &hash, &pointer);
  /* assertion rc == 0 */
  assert(rc == 0);
  /* assertion integer == -12345 */
  assert(integer == -12345);
  /* assertion number1 == 123 */
  assert((signed int)number1 == 123);
  /* assertion number2 == 123 * 123 */
  assert((signed int)number2 == 123 * 123);
  /* assertion number4 == 123 * 123 * 123 */
  assert(number4 == (unsigned int)(123 * 123 * 123));
  /* assertion number8 == 123 * 123 * 123 * 123 */
  assert(number8 == (unsigned long int)(123 * 123 * 123 * 123));
  signed int return_value_strcmp_14;
  return_value_strcmp_14=strcmp(string, "This is a string");
  /* assertion (!strcmp ((string), ("This is a string"))) */
  assert(!(return_value_strcmp_14 != 0));
  signed int return_value_memcmp_15;
  return_value_memcmp_15=memcmp((const void *)data, (const void *)"ABCDE", (unsigned long int)5);
  /* assertion memcmp (data, "ABCDE", 5) == 0 */
  assert(return_value_memcmp_15 == 0);
  /* assertion size == 5 */
  assert(size == (unsigned long int)5);
  unsigned char *return_value_zchunk_data_16;
  return_value_zchunk_data_16=zchunk_data(chunk);
  signed int return_value_memcmp_17;
  return_value_memcmp_17=memcmp((const void *)return_value_zchunk_data_16, (const void *)"HELLO", (unsigned long int)5);
  /* assertion memcmp (zchunk_data (chunk), "HELLO", 5) == 0 */
  assert(return_value_memcmp_17 == 0);
  unsigned long int return_value_zchunk_size_18;
  return_value_zchunk_size_18=zchunk_size(chunk);
  /* assertion zchunk_size (chunk) == 5 */
  assert(return_value_zchunk_size_18 == (unsigned long int)5);
  const char *return_value_zuuid_str_19;
  return_value_zuuid_str_19=zuuid_str(uuid);
  signed int return_value_strcmp_20;
  return_value_strcmp_20=strcmp(uuid_str, return_value_zuuid_str_19);
  /* assertion (!strcmp ((uuid_str), (zuuid_str (uuid)))) */
  assert(!(return_value_strcmp_20 != 0));
  unsigned char *return_value_zframe_data_21;
  return_value_zframe_data_21=zframe_data(frame);
  signed int return_value_memcmp_22;
  return_value_memcmp_22=memcmp((const void *)return_value_zframe_data_21, (const void *)"WORLD", (unsigned long int)5);
  /* assertion memcmp (zframe_data (frame), "WORLD", 5) == 0 */
  assert(return_value_memcmp_22 == 0);
  unsigned long int return_value_zframe_size_23;
  return_value_zframe_size_23=zframe_size(frame);
  /* assertion zframe_size (frame) == 5 */
  assert(return_value_zframe_size_23 == (unsigned long int)5);
  char *value;
  void *return_value_zhashx_lookup_24;
  return_value_zhashx_lookup_24=zhashx_lookup(hash, (const void *)"1");
  value = (char *)return_value_zhashx_lookup_24;
  signed int return_value_strcmp_25;
  return_value_strcmp_25=strcmp(value, "value A");
  /* assertion (!strcmp ((value), ("value A"))) */
  assert(!(return_value_strcmp_25 != 0));
  void *return_value_zhashx_lookup_26;
  return_value_zhashx_lookup_26=zhashx_lookup(hash, (const void *)"2");
  value = (char *)return_value_zhashx_lookup_26;
  signed int return_value_strcmp_27;
  return_value_strcmp_27=strcmp(value, "value B");
  /* assertion (!strcmp ((value), ("value B"))) */
  assert(!(return_value_strcmp_27 != 0));
  /* assertion original == pointer */
  assert(original == pointer);
  free((void *)string);
  free((void *)data);
  free((void *)uuid_str);
  zframe_destroy(&frame);
  zchunk_destroy(&chunk);
  zhashx_destroy(&hash);
  zsock_send((void *)writer, "i", -1);
  zsock_recv((void *)reader, "izsbcfp", &integer, &string, &data, &size, &chunk, &frame, &pointer);
  /* assertion integer == -1 */
  assert(integer == -1);
  /* assertion string == ((void *)0) */
  assert(string == (char *)(void *)0);
  /* assertion data == ((void *)0) */
  assert(data == (unsigned char *)(void *)0);
  /* assertion size == 0 */
  assert(size == (unsigned long int)0);
  /* assertion chunk == ((void *)0) */
  assert(chunk == (struct _zchunk_t *)(void *)0);
  /* assertion frame == ((void *)0) */
  assert(frame == (struct _zframe_t *)(void *)0);
  /* assertion pointer == ((void *)0) */
  assert(pointer == (char *)(void *)0);
  msg=zmsg_new();
  zmsg_addstr(msg, "frame 1");
  zmsg_addstr(msg, "frame 2");
  zsock_send((void *)writer, "szm", (const void *)"header", msg);
  zmsg_destroy(&msg);
  zsock_recv((void *)reader, "szm", &string, &msg);
  signed int return_value_strcmp_28;
  return_value_strcmp_28=strcmp("header", string);
  /* assertion (!strcmp (("header"), (string))) */
  assert(!(return_value_strcmp_28 != 0));
  unsigned long int return_value_zmsg_size_29;
  return_value_zmsg_size_29=zmsg_size(msg);
  /* assertion zmsg_size (msg) == 2 */
  assert(return_value_zmsg_size_29 == (unsigned long int)2);
  struct _zframe_t *return_value_zmsg_first_30;
  return_value_zmsg_first_30=zmsg_first(msg);
  _Bool return_value_zframe_streq_31;
  return_value_zframe_streq_31=zframe_streq(return_value_zmsg_first_30, "frame 1");
  /* assertion zframe_streq (zmsg_first (msg), "frame 1") */
  assert(return_value_zframe_streq_31 != (_Bool)0);
  struct _zframe_t *return_value_zmsg_next_32;
  return_value_zmsg_next_32=zmsg_next(msg);
  _Bool return_value_zframe_streq_33;
  return_value_zframe_streq_33=zframe_streq(return_value_zmsg_next_32, "frame 2");
  /* assertion zframe_streq (zmsg_next (msg), "frame 2") */
  assert(return_value_zframe_streq_33 != (_Bool)0);
  zstr_free(&string);
  zmsg_destroy(&msg);
  chunk=zchunk_new((const void *)"HELLO", (unsigned long int)5);
  /* assertion chunk */
  assert(chunk != ((struct _zchunk_t *)NULL));
  frame=zframe_new((const void *)"WORLD", (unsigned long int)5);
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  zsock_send((void *)writer, "izsbcfp", -12345, (const void *)"This is a string", (const void *)"ABCDE", 5, chunk, frame, original);
  zframe_destroy(&frame);
  zchunk_destroy(&chunk);
  zsock_recv((void *)reader, "izsbcfp", &integer, (void *)0, (void *)0, (void *)0, &chunk, (void *)0, (void *)0);
  /* assertion integer == -12345 */
  assert(integer == -12345);
  unsigned char *return_value_zchunk_data_34;
  return_value_zchunk_data_34=zchunk_data(chunk);
  signed int return_value_memcmp_35;
  return_value_memcmp_35=memcmp((const void *)return_value_zchunk_data_34, (const void *)"HELLO", (unsigned long int)5);
  /* assertion memcmp (zchunk_data (chunk), "HELLO", 5) == 0 */
  assert(return_value_memcmp_35 == 0);
  unsigned long int return_value_zchunk_size_36;
  return_value_zchunk_size_36=zchunk_size(chunk);
  /* assertion zchunk_size (chunk) == 5 */
  assert(return_value_zchunk_size_36 == (unsigned long int)5);
  zchunk_destroy(&chunk);
  frame=zframe_new((const void *)"Hello", (unsigned long int)5);
  chunk=zchunk_new((const void *)"World", (unsigned long int)5);
  msg=zmsg_new();
  zmsg_addstr(msg, "Hello");
  zmsg_addstr(msg, "World");
  zsock_bsend((void *)writer, "1248sSpcfm", number1, number2, number4, number8, (const void *)"Hello, World", (const void *)"Goodbye cruel World!", original, chunk, frame, msg);
  zchunk_destroy(&chunk);
  zframe_destroy(&frame);
  zmsg_destroy(&msg);
  number1 = (unsigned char)0;
  number2 = (unsigned short int)number1;
  number4 = (unsigned int)number2;
  number8 = (unsigned long int)number4;
  char *longstr;
  zsock_brecv((void *)reader, "1248sSpcfm", &number1, &number2, &number4, &number8, &string, &longstr, &pointer, &chunk, &frame, &msg);
  /* assertion number1 == 123 */
  assert((signed int)number1 == 123);
  /* assertion number2 == 123 * 123 */
  assert((signed int)number2 == 123 * 123);
  /* assertion number4 == 123 * 123 * 123 */
  assert(number4 == (unsigned int)(123 * 123 * 123));
  /* assertion number8 == 123 * 123 * 123 * 123 */
  assert(number8 == (unsigned long int)(123 * 123 * 123 * 123));
  signed int return_value_strcmp_37;
  return_value_strcmp_37=strcmp(string, "Hello, World");
  /* assertion (!strcmp ((string), ("Hello, World"))) */
  assert(!(return_value_strcmp_37 != 0));
  signed int return_value_strcmp_38;
  return_value_strcmp_38=strcmp(longstr, "Goodbye cruel World!");
  /* assertion (!strcmp ((longstr), ("Goodbye cruel World!"))) */
  assert(!(return_value_strcmp_38 != 0));
  /* assertion pointer == original */
  assert(pointer == original);
  zstr_free(&longstr);
  zchunk_destroy(&chunk);
  zframe_destroy(&frame);
  zmsg_destroy(&msg);
  zsock_bsend((void *)writer, "1111sS4", 0xAA, 0xA0, 0x02, 0x01, (const void *)"key", (const void *)"value", 1234);
  struct _zgossip_msg_t *gossip;
  gossip=zgossip_msg_new();
  zgossip_msg_recv(gossip, reader);
  signed int return_value_zgossip_msg_id_39;
  return_value_zgossip_msg_id_39=zgossip_msg_id(gossip);
  /* assertion zgossip_msg_id (gossip) == 2 */
  assert(return_value_zgossip_msg_id_39 == 2);
  zgossip_msg_destroy(&gossip);
  zsock_destroy(&reader);
  zsock_destroy(&writer);
  printf("OK\n");
}

// zsock_tos
// file src/zsock_option.c line 55
signed int zsock_tos(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int tos;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 57, (void *)&tos, &option_len);
  return tos;
}

// zsock_type
// file src/../include/zsock_option.h line 47
signed int zsock_type(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int type;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  void *return_value_zsock_resolve_1;
  return_value_zsock_resolve_1=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_1, 16, (void *)&type, &option_len);
  return type;
}

// zsock_type_str
// file src/../include/zsock.h line 160
const char * zsock_type_str(struct _zsock_t *self)
{
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  char *return_value_zsys_sockname_1;
  return_value_zsys_sockname_1=zsys_sockname(self->type);
  return return_value_zsys_sockname_1;
}

// zsock_unbind
// file src/../include/zsock.h line 136
signed int zsock_unbind(struct _zsock_t *self, const char *format, ...)
{
  /* assertion self */
  assert(self != ((struct _zsock_t *)NULL));
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is((void *)self);
  /* assertion zsock_is (self) */
  assert(return_value_zsock_is_1 != (_Bool)0);
  void **argptr = (void **)&format;
  char *endpoint;
  endpoint=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  if(endpoint == ((char *)NULL))
    return -1;

  else
  {
    signed int rc;
    rc=zmq_unbind(self->handle, endpoint);
    free((void *)endpoint);
    return rc;
  }
}

// zsock_vrecv
// file src/zsock.c line 788
signed int zsock_vrecv(void *self, const char *picture, __builtin_va_list argptr)
{
  /* assertion self */
  assert(self != NULL);
  /* assertion picture */
  assert(picture != ((const char *)NULL));
  struct _zmsg_t *msg;
  msg=zmsg_recv(self);
  signed int return_value_atoi_2;
  signed int return_value_atoi_4;
  signed long int return_value_atol_6;
  signed long int return_value_atol_8;
  signed long long int return_value_atoll_10;
  signed long int return_value_atol_12;
  unsigned char *return_value_zframe_data_16;
  unsigned long int return_value_zframe_size_17;
  unsigned char *return_value_zframe_data_19;
  unsigned long int return_value_zframe_size_21;
  if(msg == ((struct _zmsg_t *)NULL))
    return -1;

  else
  {
    signed int return_value_zmsg_signal_1;
    return_value_zmsg_signal_1=zmsg_signal(msg);
    if(return_value_zmsg_signal_1 >= 0)
    {
      zmsg_destroy(&msg);
      return -1;
    }

    else
    {
      signed int rc = 0;
      for( ; !(*picture == 0); picture = picture + 1l)
        if((signed int)*picture == 105)
        {
          char *string;
          string=zmsg_popstr(msg);
          signed int *int_p;
          int_p=va_arg(argptr, __typeof__(int_p));
          if(!(int_p == ((signed int *)NULL)))
          {
            signed int tmp_if_expr_3;
            if(!(string == ((char *)NULL)))
            {
              return_value_atoi_2=atoi(string);
              tmp_if_expr_3 = return_value_atoi_2;
            }

            else
              tmp_if_expr_3 = 0;
            *int_p = tmp_if_expr_3;
          }

          free((void *)string);
        }

        else
          if((signed int)*picture == 49)
          {
            char *zsock_vrecv__1__2__2__string;
            zsock_vrecv__1__2__2__string=zmsg_popstr(msg);
            unsigned char *uint8_p;
            uint8_p=va_arg(argptr, __typeof__(uint8_p));
            if(!(uint8_p == ((unsigned char *)NULL)))
            {
              signed int tmp_if_expr_5;
              if(!(zsock_vrecv__1__2__2__string == ((char *)NULL)))
              {
                return_value_atoi_4=atoi(zsock_vrecv__1__2__2__string);
                tmp_if_expr_5 = (signed int)(unsigned char)return_value_atoi_4;
              }

              else
                tmp_if_expr_5 = 0;
              *uint8_p = (unsigned char)tmp_if_expr_5;
            }

            free((void *)zsock_vrecv__1__2__2__string);
          }

          else
            if((signed int)*picture == 50)
            {
              char *zsock_vrecv__1__2__3__string;
              zsock_vrecv__1__2__3__string=zmsg_popstr(msg);
              unsigned short int *uint16_p;
              uint16_p=va_arg(argptr, __typeof__(uint16_p));
              if(!(uint16_p == ((unsigned short int *)NULL)))
              {
                signed int tmp_if_expr_7;
                if(!(zsock_vrecv__1__2__3__string == ((char *)NULL)))
                {
                  return_value_atol_6=atol(zsock_vrecv__1__2__3__string);
                  tmp_if_expr_7 = (signed int)(unsigned short int)return_value_atol_6;
                }

                else
                  tmp_if_expr_7 = 0;
                *uint16_p = (unsigned short int)tmp_if_expr_7;
              }

              free((void *)zsock_vrecv__1__2__3__string);
            }

            else
              if((signed int)*picture == 52)
              {
                char *zsock_vrecv__1__2__4__string;
                zsock_vrecv__1__2__4__string=zmsg_popstr(msg);
                unsigned int *uint32_p;
                uint32_p=va_arg(argptr, __typeof__(uint32_p));
                if(!(uint32_p == ((unsigned int *)NULL)))
                {
                  unsigned int tmp_if_expr_9;
                  if(!(zsock_vrecv__1__2__4__string == ((char *)NULL)))
                  {
                    return_value_atol_8=atol(zsock_vrecv__1__2__4__string);
                    tmp_if_expr_9 = (unsigned int)return_value_atol_8;
                  }

                  else
                    tmp_if_expr_9 = (unsigned int)0;
                  *uint32_p = tmp_if_expr_9;
                }

                free((void *)zsock_vrecv__1__2__4__string);
              }

              else
                if((signed int)*picture == 56)
                {
                  char *zsock_vrecv__1__2__5__string;
                  zsock_vrecv__1__2__5__string=zmsg_popstr(msg);
                  unsigned long int *uint64_p;
                  uint64_p=va_arg(argptr, __typeof__(uint64_p));
                  if(!(uint64_p == ((unsigned long int *)NULL)))
                  {
                    unsigned long int tmp_if_expr_11;
                    if(!(zsock_vrecv__1__2__5__string == ((char *)NULL)))
                    {
                      return_value_atoll_10=atoll(zsock_vrecv__1__2__5__string);
                      tmp_if_expr_11 = (unsigned long int)return_value_atoll_10;
                    }

                    else
                      tmp_if_expr_11 = (unsigned long int)0;
                    *uint64_p = tmp_if_expr_11;
                  }

                  free((void *)zsock_vrecv__1__2__5__string);
                }

                else
                  if((signed int)*picture == 117)
                  {
                    char *zsock_vrecv__1__2__6__string;
                    zsock_vrecv__1__2__6__string=zmsg_popstr(msg);
                    unsigned int *uint_p;
                    uint_p=va_arg(argptr, __typeof__(uint_p));
                    if(!(uint_p == ((unsigned int *)NULL)))
                    {
                      unsigned int tmp_if_expr_13;
                      if(!(zsock_vrecv__1__2__6__string == ((char *)NULL)))
                      {
                        return_value_atol_12=atol(zsock_vrecv__1__2__6__string);
                        tmp_if_expr_13 = (unsigned int)return_value_atol_12;
                      }

                      else
                        tmp_if_expr_13 = (unsigned int)0;
                      *uint_p = tmp_if_expr_13;
                    }

                    free((void *)zsock_vrecv__1__2__6__string);
                  }

                  else
                    if((signed int)*picture == 115)
                    {
                      char *zsock_vrecv__1__2__7__string;
                      zsock_vrecv__1__2__7__string=zmsg_popstr(msg);
                      char **string_p;
                      string_p=va_arg(argptr, __typeof__(string_p));
                      if(!(string_p == ((char **)NULL)))
                        *string_p = zsock_vrecv__1__2__7__string;

                      else
                        free((void *)zsock_vrecv__1__2__7__string);
                    }

                    else
                      if((signed int)*picture == 98)
                      {
                        struct _zframe_t *frame;
                        frame=zmsg_pop(msg);
                        unsigned char **data_p;
                        data_p=va_arg(argptr, __typeof__(data_p));
                        unsigned long int *size;
                        size=va_arg(argptr, __typeof__(size));
                        if(!(data_p == ((unsigned char **)NULL)))
                        {
                          if(!(frame == ((struct _zframe_t *)NULL)))
                          {
                            *size=zframe_size(frame);
                            void *return_value_malloc_14;
                            return_value_malloc_14=malloc(*size);
                            *data_p = (unsigned char *)return_value_malloc_14;
                            unsigned char *return_value_zframe_data_15;
                            return_value_zframe_data_15=zframe_data(frame);
                            memcpy((void *)*data_p, (const void *)return_value_zframe_data_15, *size);
                          }

                          else
                          {
                            *data_p = (unsigned char *)(void *)0;
                            *size = (unsigned long int)0;
                          }
                        }

                        zframe_destroy(&frame);
                      }

                      else
                        if((signed int)*picture == 99)
                        {
                          struct _zframe_t *zsock_vrecv__1__2__9__frame;
                          zsock_vrecv__1__2__9__frame=zmsg_pop(msg);
                          struct _zchunk_t **chunk_p;
                          chunk_p=va_arg(argptr, __typeof__(chunk_p));
                          if(!(chunk_p == ((struct _zchunk_t **)NULL)))
                          {
                            if(!(zsock_vrecv__1__2__9__frame == ((struct _zframe_t *)NULL)))
                            {
                              return_value_zframe_data_16=zframe_data(zsock_vrecv__1__2__9__frame);
                              return_value_zframe_size_17=zframe_size(zsock_vrecv__1__2__9__frame);
                              *chunk_p=zchunk_new((const void *)return_value_zframe_data_16, return_value_zframe_size_17);
                            }

                            else
                              *chunk_p = (struct _zchunk_t *)(void *)0;
                          }

                          zframe_destroy(&zsock_vrecv__1__2__9__frame);
                        }

                        else
                          if((signed int)*picture == 102)
                          {
                            struct _zframe_t *zsock_vrecv__1__2__10__frame;
                            zsock_vrecv__1__2__10__frame=zmsg_pop(msg);
                            struct _zframe_t **frame_p;
                            frame_p=va_arg(argptr, __typeof__(frame_p));
                            if(!(frame_p == ((struct _zframe_t **)NULL)))
                              *frame_p = zsock_vrecv__1__2__10__frame;

                            else
                              zframe_destroy(&zsock_vrecv__1__2__10__frame);
                          }

                          else
                            if((signed int)*picture == 85)
                            {
                              struct _zframe_t *zsock_vrecv__1__2__11__frame;
                              zsock_vrecv__1__2__11__frame=zmsg_pop(msg);
                              struct _zuuid_t **uuid_p;
                              uuid_p=va_arg(argptr, __typeof__(uuid_p));
                              if(!(uuid_p == ((struct _zuuid_t **)NULL)))
                              {
                                if(!(zsock_vrecv__1__2__11__frame == ((struct _zframe_t *)NULL)))
                                {
                                  *uuid_p=zuuid_new();
                                  unsigned char *return_value_zframe_data_18;
                                  return_value_zframe_data_18=zframe_data(zsock_vrecv__1__2__11__frame);
                                  zuuid_set(*uuid_p, return_value_zframe_data_18);
                                }

                                else
                                  *uuid_p = (struct _zuuid_t *)(void *)0;
                              }

                              zframe_destroy(&zsock_vrecv__1__2__11__frame);
                            }

                            else
                              if((signed int)*picture == 112)
                              {
                                struct _zframe_t *zsock_vrecv__1__2__12__frame;
                                zsock_vrecv__1__2__12__frame=zmsg_pop(msg);
                                void **pointer_p;
                                pointer_p=va_arg(argptr, __typeof__(pointer_p));
                                if(!(pointer_p == ((void **)NULL)))
                                {
                                  if(!(zsock_vrecv__1__2__12__frame == ((struct _zframe_t *)NULL)))
                                  {
                                    unsigned long int return_value_zframe_size_20;
                                    return_value_zframe_size_20=zframe_size(zsock_vrecv__1__2__12__frame);
                                    if(return_value_zframe_size_20 == sizeof(void *) /*8ul*/ )
                                    {
                                      return_value_zframe_data_19=zframe_data(zsock_vrecv__1__2__12__frame);
                                      *pointer_p = *((void **)return_value_zframe_data_19);
                                    }

                                    else
                                      rc = -1;
                                  }

                                  else
                                    *pointer_p = (void *)0;
                                }

                                zframe_destroy(&zsock_vrecv__1__2__12__frame);
                              }

                              else
                                if((signed int)*picture == 104)
                                {
                                  struct _zframe_t *zsock_vrecv__1__2__13__frame;
                                  zsock_vrecv__1__2__13__frame=zmsg_pop(msg);
                                  struct _zhashx_t **hash_p;
                                  hash_p=va_arg(argptr, __typeof__(hash_p));
                                  if(!(hash_p == ((struct _zhashx_t **)NULL)))
                                  {
                                    if(!(zsock_vrecv__1__2__13__frame == ((struct _zframe_t *)NULL)))
                                      *hash_p=zhashx_unpack(zsock_vrecv__1__2__13__frame);

                                    else
                                      *hash_p = (struct _zhashx_t *)(void *)0;
                                  }

                                  zframe_destroy(&zsock_vrecv__1__2__13__frame);
                                }

                                else
                                  if((signed int)*picture == 109)
                                  {
                                    struct _zmsg_t **zmsg_p;
                                    zmsg_p=va_arg(argptr, __typeof__(zmsg_p));
                                    if(!(zmsg_p == ((struct _zmsg_t **)NULL)))
                                    {
                                      *zmsg_p=zmsg_new();
                                      struct _zframe_t *zsock_vrecv__1__2__14__1__frame;
                                      do
                                      {
                                        zsock_vrecv__1__2__14__1__frame=zmsg_pop(msg);
                                        if(zsock_vrecv__1__2__14__1__frame == ((struct _zframe_t *)NULL))
                                          break;

                                        zmsg_append(*zmsg_p, &zsock_vrecv__1__2__14__1__frame);
                                      }
                                      while((_Bool)1);
                                    }

                                  }

                                  else
                                    if((signed int)*picture == 122)
                                    {
                                      struct _zframe_t *zsock_vrecv__1__2__15__frame;
                                      zsock_vrecv__1__2__15__frame=zmsg_pop(msg);
                                      if(!(zsock_vrecv__1__2__15__frame == ((struct _zframe_t *)NULL)))
                                      {
                                        return_value_zframe_size_21=zframe_size(zsock_vrecv__1__2__15__frame);
                                        if(!(return_value_zframe_size_21 == 0ul))
                                          rc = -1;

                                      }

                                      zframe_destroy(&zsock_vrecv__1__2__15__frame);
                                    }

                                    else
                                    {
                                      zsys_error("zsock: invalid picture element '%c'", *picture);
                                      /* assertion 0 */
                                      assert(0 != 0);
                                    }
      zmsg_destroy(&msg);
      return rc;
    }
  }
}

// zsock_vsend
// file src/zsock.c line 657
signed int zsock_vsend(void *self, const char *picture, __builtin_va_list argptr)
{
  /* assertion self */
  assert(self != NULL);
  /* assertion picture */
  assert(picture != ((const char *)NULL));
  struct _zmsg_t *msg;
  msg=zmsg_new();
  signed int return_value_gcc_builtin_va_arg_1;
  signed int return_value_gcc_builtin_va_arg_2;
  signed int return_value_gcc_builtin_va_arg_3;
  unsigned int return_value_gcc_builtin_va_arg_4;
  unsigned long int return_value_gcc_builtin_va_arg_5;
  unsigned int return_value_gcc_builtin_va_arg_6;
  char *return_value_gcc_builtin_va_arg_7;
  while(!(*picture == 0))
  {
    if((signed int)*picture == 105)
    {
      return_value_gcc_builtin_va_arg_1=va_arg(argptr, __typeof__(return_value_gcc_builtin_va_arg_1));
      zmsg_addstrf(msg, "%d", return_value_gcc_builtin_va_arg_1);
    }

    else
      if((signed int)*picture == 49)
      {
        return_value_gcc_builtin_va_arg_2=va_arg(argptr, __typeof__(return_value_gcc_builtin_va_arg_2));
        zmsg_addstrf(msg, "%u", (unsigned char)return_value_gcc_builtin_va_arg_2);
      }

      else
        if((signed int)*picture == 50)
        {
          return_value_gcc_builtin_va_arg_3=va_arg(argptr, __typeof__(return_value_gcc_builtin_va_arg_3));
          zmsg_addstrf(msg, "%u", (unsigned short int)return_value_gcc_builtin_va_arg_3);
        }

        else
          if((signed int)*picture == 52)
          {
            return_value_gcc_builtin_va_arg_4=va_arg(argptr, __typeof__(return_value_gcc_builtin_va_arg_4));
            zmsg_addstrf(msg, "%u", return_value_gcc_builtin_va_arg_4);
          }

          else
            if((signed int)*picture == 56)
            {
              return_value_gcc_builtin_va_arg_5=va_arg(argptr, __typeof__(return_value_gcc_builtin_va_arg_5));
              zmsg_addstrf(msg, "%lu", return_value_gcc_builtin_va_arg_5);
            }

            else
              if((signed int)*picture == 117)
              {
                return_value_gcc_builtin_va_arg_6=va_arg(argptr, __typeof__(return_value_gcc_builtin_va_arg_6));
                zmsg_addstrf(msg, "%ud", return_value_gcc_builtin_va_arg_6);
              }

              else
                if((signed int)*picture == 115)
                {
                  return_value_gcc_builtin_va_arg_7=va_arg(argptr, __typeof__(return_value_gcc_builtin_va_arg_7));
                  zmsg_addstr(msg, return_value_gcc_builtin_va_arg_7);
                }

                else
                  if((signed int)*picture == 98)
                  {
                    unsigned char *data;
                    data=va_arg(argptr, __typeof__(data));
                    signed int return_value_gcc_builtin_va_arg_8;
                    return_value_gcc_builtin_va_arg_8=va_arg(argptr, __typeof__(return_value_gcc_builtin_va_arg_8));
                    zmsg_addmem(msg, (const void *)data, (unsigned long int)return_value_gcc_builtin_va_arg_8);
                  }

                  else
                    if((signed int)*picture == 99)
                    {
                      struct _zchunk_t *chunk;
                      chunk=va_arg(argptr, __typeof__(chunk));
                      _Bool return_value_zchunk_is_9;
                      return_value_zchunk_is_9=zchunk_is((void *)chunk);
                      /* assertion zchunk_is (chunk) */
                      assert(return_value_zchunk_is_9 != (_Bool)0);
                      unsigned char *return_value_zchunk_data_10;
                      return_value_zchunk_data_10=zchunk_data(chunk);
                      unsigned long int return_value_zchunk_size_11;
                      return_value_zchunk_size_11=zchunk_size(chunk);
                      zmsg_addmem(msg, (const void *)return_value_zchunk_data_10, return_value_zchunk_size_11);
                    }

                    else
                      if((signed int)*picture == 102)
                      {
                        struct _zframe_t *frame;
                        frame=va_arg(argptr, __typeof__(frame));
                        _Bool return_value_zframe_is_12;
                        return_value_zframe_is_12=zframe_is((void *)frame);
                        /* assertion zframe_is (frame) */
                        assert(return_value_zframe_is_12 != (_Bool)0);
                        unsigned char *return_value_zframe_data_13;
                        return_value_zframe_data_13=zframe_data(frame);
                        unsigned long int return_value_zframe_size_14;
                        return_value_zframe_size_14=zframe_size(frame);
                        zmsg_addmem(msg, (const void *)return_value_zframe_data_13, return_value_zframe_size_14);
                      }

                      else
                        if((signed int)*picture == 85)
                        {
                          struct _zuuid_t *uuid;
                          uuid=va_arg(argptr, __typeof__(uuid));
                          const unsigned char *return_value_zuuid_data_15;
                          return_value_zuuid_data_15=zuuid_data(uuid);
                          unsigned long int return_value_zuuid_size_16;
                          return_value_zuuid_size_16=zuuid_size(uuid);
                          zmsg_addmem(msg, (const void *)return_value_zuuid_data_15, return_value_zuuid_size_16);
                        }

                        else
                          if((signed int)*picture == 112)
                          {
                            void *pointer;
                            pointer=va_arg(argptr, __typeof__(pointer));
                            zmsg_addmem(msg, (const void *)&pointer, sizeof(void *) /*8ul*/ );
                          }

                          else
                            if((signed int)*picture == 104)
                            {
                              struct _zhashx_t *hash;
                              hash=va_arg(argptr, __typeof__(hash));
                              struct _zframe_t *zsock_vsend__1__1__6__frame;
                              zsock_vsend__1__1__6__frame=zhashx_pack(hash);
                              zmsg_append(msg, &zsock_vsend__1__1__6__frame);
                            }

                            else
                              if((signed int)*picture == 109)
                              {
                                struct _zframe_t *zsock_vsend__1__1__7__frame;
                                struct _zmsg_t *zmsg;
                                zmsg=va_arg(argptr, __typeof__(zmsg));
                                zsock_vsend__1__1__7__frame=zmsg_first(zmsg);
                                while(!(zsock_vsend__1__1__7__frame == ((struct _zframe_t *)NULL)))
                                {
                                  struct _zframe_t *frame_dup;
                                  frame_dup=zframe_dup(zsock_vsend__1__1__7__frame);
                                  zmsg_append(msg, &frame_dup);
                                  zsock_vsend__1__1__7__frame=zmsg_next(zmsg);
                                }
                              }

                              else
                                if((signed int)*picture == 122)
                                  zmsg_addmem(msg, (void *)0, (unsigned long int)0);

                                else
                                {
                                  zsys_error("zsock: invalid picture element '%c'", *picture);
                                  /* assertion 0 */
                                  assert(0 != 0);
                                }
    picture = picture + 1l;
  }
  signed int return_value_zmsg_send_17;
  return_value_zmsg_send_17=zmsg_send(&msg, self);
  return return_value_zmsg_send_17;
}

// zsock_wait
// file src/../include/zsock.h line 286
signed int zsock_wait(void *self)
{
  /* assertion self */
  assert(self != NULL);
  while((_Bool)1)
  {
    struct _zmsg_t *msg;
    msg=zmsg_recv(self);
    if(msg == ((struct _zmsg_t *)NULL))
      return -1;

    signed int rc;
    rc=zmsg_signal(msg);
    zmsg_destroy(&msg);
    if(rc >= 0)
      return rc;

  }
  return -1;
}

// zsock_zap_domain
// file src/zsock_option.c line 208
char * zsock_zap_domain(void *self)
{
  /* assertion self */
  assert(self != NULL);
  unsigned long int option_len = (unsigned long int)255;
  char *zap_domain;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link24(option_len, "src/zsock_option.c", (unsigned int)213);
  zap_domain = (char *)return_value_safe_malloc_1;
  void *return_value_zsock_resolve_2;
  return_value_zsock_resolve_2=zsock_resolve(self);
  zmq_getsockopt(return_value_zsock_resolve_2, 55, (void *)zap_domain, &option_len);
  return (char *)zap_domain;
}

// zsocket_affinity
// file src/zsockopt.c line 961
signed int zsocket_affinity(void *zocket)
{
  unsigned long int affinity;
  unsigned long int option_len = sizeof(unsigned long int) /*8ul*/ ;
  zmq_getsockopt(zocket, 4, (void *)&affinity, &option_len);
  return (signed int)affinity;
}

// zsocket_backlog
// file src/zsockopt.c line 1336
signed int zsocket_backlog(void *zocket)
{
  signed int backlog;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 19, (void *)&backlog, &option_len);
  return backlog;
}

// zsocket_bind
// file src/../include/zsocket.h line 47
signed int zsocket_bind(void *self, const char *format, ...)
{
  char endpoint[260l];
  void **argptr = (void **)&format;
  signed int endpoint_size;
  endpoint_size=vsnprintf(endpoint, (unsigned long int)256, format, argptr);
  argptr = ((void **)NULL);
  _Bool tmp_if_expr_3;
  if((signed int)endpoint[(signed long int)(endpoint_size + -2)] == 58)
    tmp_if_expr_3 = (signed int)endpoint[(signed long int)(endpoint_size - 1)] == 42 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  char *return_value_strrchr_2;
  if(tmp_if_expr_3)
  {
    signed int port = 0xc000;
    while(!(port >= 65536))
    {
      sprintf((endpoint + (signed long int)endpoint_size) - (signed long int)1, "%d", port);
      signed int return_value_zmq_bind_1;
      return_value_zmq_bind_1=zmq_bind(self, endpoint);
      if(return_value_zmq_bind_1 == 0)
        return port;

      port = port + 1;
    }
    return -1;
  }

  else
  {
    signed int zsocket_bind__1__2__port;
    zsocket_bind__1__2__port=zmq_bind(self, endpoint);
    if(zsocket_bind__1__2__port == 0)
    {
      return_value_strrchr_2=strrchr(endpoint, 58);
      zsocket_bind__1__2__port=atoi(return_value_strrchr_2 + (signed long int)1);
    }

    else
      zsocket_bind__1__2__port = -1;
    return zsocket_bind__1__2__port;
  }
}

// zsocket_connect
// file src/../include/zsocket.h line 58
signed int zsocket_connect(void *self, const char *format, ...)
{
  char endpoint[256l];
  void **argptr = (void **)&format;
  vsnprintf(endpoint, (unsigned long int)256, format, argptr);
  argptr = ((void **)NULL);
  signed int return_value_zmq_connect_1;
  return_value_zmq_connect_1=zmq_connect(self, endpoint);
  return return_value_zmq_connect_1;
}

// zsocket_curve_publickey
// file src/zsockopt.c line 442
char * zsocket_curve_publickey(void *zocket)
{
  unsigned long int option_len = (unsigned long int)(40 + 1);
  char *curve_publickey;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link36(option_len, "src/zsockopt.c", (unsigned int)446);
  curve_publickey = (char *)return_value_safe_malloc_1;
  zmq_getsockopt(zocket, 48, (void *)curve_publickey, &option_len);
  return (char *)curve_publickey;
}

// zsocket_curve_secretkey
// file src/zsockopt.c line 492
char * zsocket_curve_secretkey(void *zocket)
{
  unsigned long int option_len = (unsigned long int)(40 + 1);
  char *curve_secretkey;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link36(option_len, "src/zsockopt.c", (unsigned int)496);
  curve_secretkey = (char *)return_value_safe_malloc_1;
  zmq_getsockopt(zocket, 49, (void *)curve_secretkey, &option_len);
  return (char *)curve_secretkey;
}

// zsocket_curve_server
// file src/zsockopt.c line 392
signed int zsocket_curve_server(void *zocket)
{
  signed int curve_server;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 47, (void *)&curve_server, &option_len);
  return curve_server;
}

// zsocket_curve_serverkey
// file src/zsockopt.c line 542
char * zsocket_curve_serverkey(void *zocket)
{
  unsigned long int option_len = (unsigned long int)(40 + 1);
  char *curve_serverkey;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link36(option_len, "src/zsockopt.c", (unsigned int)546);
  curve_serverkey = (char *)return_value_safe_malloc_1;
  zmq_getsockopt(zocket, 50, (void *)curve_serverkey, &option_len);
  return (char *)curve_serverkey;
}

// zsocket_destroy
// file src/../include/zsocket.h line 39
void zsocket_destroy(struct _zctx_t *ctx, void *self)
{
  if(!(self == NULL))
    zctx__socket_destroy(ctx, self);

}

// zsocket_disconnect
// file src/zsocket.c line 135
signed int zsocket_disconnect(void *self, const char *format, ...)
{
  char endpoint[256l];
  void **argptr = (void **)&format;
  vsnprintf(endpoint, (unsigned long int)256, format, argptr);
  argptr = ((void **)NULL);
  signed int return_value_zmq_disconnect_1;
  return_value_zmq_disconnect_1=zmq_disconnect(self, endpoint);
  return return_value_zmq_disconnect_1;
}

// zsocket_events
// file src/zsockopt.c line 1737
signed int zsocket_events(void *zocket)
{
  signed int events;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 15, (void *)&events, &option_len);
  return events;
}

// zsocket_fd
// file src/zsockopt.c line 1719
signed int zsocket_fd(void *zocket)
{
  signed int fd;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 14, (void *)&fd, &option_len);
  return (signed int)fd;
}

// zsocket_gssapi_plaintext
// file src/zsockopt.c line 614
signed int zsocket_gssapi_plaintext(void *zocket)
{
  signed int gssapi_plaintext;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 65, (void *)&gssapi_plaintext, &option_len);
  return gssapi_plaintext;
}

// zsocket_gssapi_principal
// file src/zsockopt.c line 650
char * zsocket_gssapi_principal(void *zocket)
{
  unsigned long int option_len = (unsigned long int)255;
  char *gssapi_principal;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link36(option_len, "src/zsockopt.c", (unsigned int)654);
  gssapi_principal = (char *)return_value_safe_malloc_1;
  zmq_getsockopt(zocket, 63, (void *)gssapi_principal, &option_len);
  return (char *)gssapi_principal;
}

// zsocket_gssapi_server
// file src/zsockopt.c line 578
signed int zsocket_gssapi_server(void *zocket)
{
  signed int gssapi_server;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 62, (void *)&gssapi_server, &option_len);
  return gssapi_server;
}

// zsocket_gssapi_service_principal
// file src/zsockopt.c line 686
char * zsocket_gssapi_service_principal(void *zocket)
{
  unsigned long int option_len = (unsigned long int)255;
  char *gssapi_service_principal;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link36(option_len, "src/zsockopt.c", (unsigned int)690);
  gssapi_service_principal = (char *)return_value_safe_malloc_1;
  zmq_getsockopt(zocket, 64, (void *)gssapi_service_principal, &option_len);
  return (char *)gssapi_service_principal;
}

// zsocket_identity
// file src/zsockopt.c line 1048
char * zsocket_identity(void *zocket)
{
  unsigned long int option_len = (unsigned long int)255;
  char *identity;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link36(option_len, "src/zsockopt.c", (unsigned int)1052);
  identity = (char *)return_value_safe_malloc_1;
  zmq_getsockopt(zocket, 5, (void *)identity, &option_len);
  return (char *)identity;
}

// zsocket_immediate
// file src/zsockopt.c line 758
signed int zsocket_immediate(void *zocket)
{
  signed int immediate;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 39, (void *)&immediate, &option_len);
  return immediate;
}

// zsocket_ipv4only
// file src/zsockopt.c line 816
signed int zsocket_ipv4only(void *zocket)
{
  signed int ipv4only;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 31, (void *)&ipv4only, &option_len);
  return ipv4only;
}

// zsocket_ipv6
// file src/zsockopt.c line 722
signed int zsocket_ipv6(void *zocket)
{
  signed int ipv6;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 42, (void *)&ipv6, &option_len);
  return ipv6;
}

// zsocket_last_endpoint
// file src/zsockopt.c line 1755
char * zsocket_last_endpoint(void *zocket)
{
  unsigned long int option_len = (unsigned long int)255;
  char *last_endpoint;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link36(option_len, "src/zsockopt.c", (unsigned int)1759);
  last_endpoint = (char *)return_value_safe_malloc_1;
  zmq_getsockopt(zocket, 32, (void *)last_endpoint, &option_len);
  return (char *)last_endpoint;
}

// zsocket_linger
// file src/zsockopt.c line 1228
signed int zsocket_linger(void *zocket)
{
  signed int linger;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 17, (void *)&linger, &option_len);
  return linger;
}

// zsocket_maxmsgsize
// file src/zsockopt.c line 1373
signed int zsocket_maxmsgsize(void *zocket)
{
  signed long int maxmsgsize;
  unsigned long int option_len = sizeof(signed long int) /*8ul*/ ;
  zmq_getsockopt(zocket, 22, (void *)&maxmsgsize, &option_len);
  return (signed int)maxmsgsize;
}

// zsocket_mechanism
// file src/zsockopt.c line 248
signed int zsocket_mechanism(void *zocket)
{
  signed int mechanism;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 43, (void *)&mechanism, &option_len);
  return mechanism;
}

// zsocket_multicast_hops
// file src/zsockopt.c line 1409
signed int zsocket_multicast_hops(void *zocket)
{
  signed int multicast_hops;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 25, (void *)&multicast_hops, &option_len);
  return multicast_hops;
}

// zsocket_new
// file src/../include/zsocket.h line 35
void * zsocket_new(struct _zctx_t *ctx, signed int type)
{
  void *self;
  self=zctx__socket_new(ctx, type);
  return self;
}

// zsocket_plain_password
// file src/zsockopt.c line 356
char * zsocket_plain_password(void *zocket)
{
  unsigned long int option_len = (unsigned long int)255;
  char *plain_password;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link36(option_len, "src/zsockopt.c", (unsigned int)360);
  plain_password = (char *)return_value_safe_malloc_1;
  zmq_getsockopt(zocket, 46, (void *)plain_password, &option_len);
  return (char *)plain_password;
}

// zsocket_plain_server
// file src/zsockopt.c line 284
signed int zsocket_plain_server(void *zocket)
{
  signed int plain_server;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 44, (void *)&plain_server, &option_len);
  return plain_server;
}

// zsocket_plain_username
// file src/zsockopt.c line 320
char * zsocket_plain_username(void *zocket)
{
  unsigned long int option_len = (unsigned long int)255;
  char *plain_username;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link36(option_len, "src/zsockopt.c", (unsigned int)324);
  plain_username = (char *)return_value_safe_malloc_1;
  zmq_getsockopt(zocket, 45, (void *)plain_username, &option_len);
  return (char *)plain_username;
}

// zsocket_poll
// file src/zsocket.c line 155
_Bool zsocket_poll(void *self, signed int msecs)
{
  struct zmq_pollitem_t items[1l] = { { .socket=self, .fd=0, .events=(signed short int)1, .revents=(signed short int)0 } };
  signed int rc;
  rc=zmq_poll(items, 1, (signed long int)msecs);
  _Bool tmp_if_expr_1;
  if(!(rc == -1))
    tmp_if_expr_1 = ((signed int)items[(signed long int)0].revents & 1) != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return tmp_if_expr_1;
}

// zsocket_rate
// file src/zsockopt.c line 1084
signed int zsocket_rate(void *zocket)
{
  signed int rate;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 8, (void *)&rate, &option_len);
  return rate;
}

// zsocket_rcvbuf
// file src/zsockopt.c line 1192
signed int zsocket_rcvbuf(void *zocket)
{
  signed int rcvbuf;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 12, (void *)&rcvbuf, &option_len);
  return rcvbuf;
}

// zsocket_rcvhwm
// file src/zsockopt.c line 924
signed int zsocket_rcvhwm(void *zocket)
{
  signed int rcvhwm;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 24, (void *)&rcvhwm, &option_len);
  return rcvhwm;
}

// zsocket_rcvmore
// file src/../include/zsockopt.h line 69
signed int zsocket_rcvmore(void *zocket)
{
  signed int rcvmore;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 13, (void *)&rcvmore, &option_len);
  return rcvmore;
}

// zsocket_rcvtimeo
// file src/zsockopt.c line 1445
signed int zsocket_rcvtimeo(void *zocket)
{
  signed int rcvtimeo;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 27, (void *)&rcvtimeo, &option_len);
  return rcvtimeo;
}

// zsocket_reconnect_ivl
// file src/zsockopt.c line 1264
signed int zsocket_reconnect_ivl(void *zocket)
{
  signed int reconnect_ivl;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 18, (void *)&reconnect_ivl, &option_len);
  return reconnect_ivl;
}

// zsocket_reconnect_ivl_max
// file src/zsockopt.c line 1300
signed int zsocket_reconnect_ivl_max(void *zocket)
{
  signed int reconnect_ivl_max;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 21, (void *)&reconnect_ivl_max, &option_len);
  return reconnect_ivl_max;
}

// zsocket_recovery_ivl
// file src/zsockopt.c line 1120
signed int zsocket_recovery_ivl(void *zocket)
{
  signed int recovery_ivl;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 9, (void *)&recovery_ivl, &option_len);
  return recovery_ivl;
}

// zsocket_sendmem
// file src/zsocket.c line 179
signed int zsocket_sendmem(void *self, const void *data, unsigned long int size, signed int flags)
{
  /* assertion self */
  assert(self != NULL);
  /* assertion size == 0 || data */
  assert(size == (unsigned long int)0 || data != NULL);
  signed int snd_flags = (flags & 1) != 0 ? 2 : 0;
  snd_flags = snd_flags | ((flags & 4) != 0 ? 1 : 0);
  struct zmq_msg_t msg;
  zmq_msg_init_size(&msg, size);
  void *return_value_zmq_msg_data_1;
  return_value_zmq_msg_data_1=zmq_msg_data(&msg);
  memcpy(return_value_zmq_msg_data_1, data, size);
  signed int return_value_zmq_sendmsg_2;
  return_value_zmq_sendmsg_2=zmq_sendmsg(self, &msg, snd_flags);
  if(return_value_zmq_sendmsg_2 == -1)
  {
    zmq_msg_close(&msg);
    return -1;
  }

  else
    return 0;
}

// zsocket_set_affinity
// file src/zsockopt.c line 942
void zsocket_set_affinity(void *zocket, signed int affinity)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_affinity () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  unsigned long int value = (unsigned long int)affinity;
  signed int rc;
  rc=zmq_setsockopt(zocket, 4, (const void *)&value, sizeof(unsigned long int) /*8ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_backlog
// file src/zsockopt.c line 1318
void zsocket_set_backlog(void *zocket, signed int backlog)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_backlog () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 19, (const void *)&backlog, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_conflate
// file src/zsockopt.c line 186
void zsocket_set_conflate(void *zocket, signed int conflate)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_conflate () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int return_value_zsocket_type_7;
  return_value_zsocket_type_7=zsocket_type(zocket);
  signed int return_value_zsocket_type_6;
  signed int return_value_zsocket_type_5;
  signed int return_value_zsocket_type_4;
  signed int return_value_zsocket_type_3;
  if(!(return_value_zsocket_type_7 == 8))
  {
    return_value_zsocket_type_6=zsocket_type(zocket);
    if(!(return_value_zsocket_type_6 == 7))
    {
      return_value_zsocket_type_5=zsocket_type(zocket);
      if(!(return_value_zsocket_type_5 == 1))
      {
        return_value_zsocket_type_4=zsocket_type(zocket);
        if(!(return_value_zsocket_type_4 == 2))
        {
          return_value_zsocket_type_3=zsocket_type(zocket);
          if(!(return_value_zsocket_type_3 == 5))
          {
            const char *return_value_zsocket_type_str_2;
            return_value_zsocket_type_str_2=zsocket_type_str(zocket);
            printf("ZMQ_CONFLATE is not valid on %s sockets\n", return_value_zsocket_type_str_2);
            /* assertion 0 */
            assert(0 != 0);
          }

        }

      }

    }

  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 54, (const void *)&conflate, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_9;
  signed int return_value_zmq_errno_8;
  if(rc == 0)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_zmq_errno_8=zmq_errno();
    tmp_if_expr_9 = return_value_zmq_errno_8 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_9);
}

// zsocket_set_curve_publickey
// file src/zsockopt.c line 410
void zsocket_set_curve_publickey(void *zocket, const char *curve_publickey)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_curve_publickey () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(curve_publickey);
  rc=zmq_setsockopt(zocket, 48, (const void *)curve_publickey, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsocket_set_curve_publickey_bin
// file src/zsockopt.c line 428
void zsocket_set_curve_publickey_bin(void *zocket, const unsigned char *curve_publickey)
{
  signed int rc;
  rc=zmq_setsockopt(zocket, 48, (const void *)curve_publickey, (unsigned long int)32);
  _Bool tmp_if_expr_2;
  signed int return_value_zmq_errno_1;
  if(rc == 0)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_zmq_errno_1=zmq_errno();
    tmp_if_expr_2 = return_value_zmq_errno_1 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_2);
}

// zsocket_set_curve_secretkey
// file src/zsockopt.c line 460
void zsocket_set_curve_secretkey(void *zocket, const char *curve_secretkey)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_curve_secretkey () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(curve_secretkey);
  rc=zmq_setsockopt(zocket, 49, (const void *)curve_secretkey, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsocket_set_curve_secretkey_bin
// file src/zsockopt.c line 478
void zsocket_set_curve_secretkey_bin(void *zocket, const unsigned char *curve_secretkey)
{
  signed int rc;
  rc=zmq_setsockopt(zocket, 49, (const void *)curve_secretkey, (unsigned long int)32);
  _Bool tmp_if_expr_2;
  signed int return_value_zmq_errno_1;
  if(rc == 0)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_zmq_errno_1=zmq_errno();
    tmp_if_expr_2 = return_value_zmq_errno_1 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_2);
}

// zsocket_set_curve_server
// file src/../include/zsockopt.h line 86
void zsocket_set_curve_server(void *zocket, signed int curve_server)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_curve_server () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 47, (const void *)&curve_server, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_curve_serverkey
// file src/../include/zsockopt.h line 91
void zsocket_set_curve_serverkey(void *zocket, const char *curve_serverkey)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_curve_serverkey () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(curve_serverkey);
  rc=zmq_setsockopt(zocket, 50, (const void *)curve_serverkey, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsocket_set_curve_serverkey_bin
// file src/zsockopt.c line 528
void zsocket_set_curve_serverkey_bin(void *zocket, const unsigned char *curve_serverkey)
{
  signed int rc;
  rc=zmq_setsockopt(zocket, 50, (const void *)curve_serverkey, (unsigned long int)32);
  _Bool tmp_if_expr_2;
  signed int return_value_zmq_errno_1;
  if(rc == 0)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_zmq_errno_1=zmq_errno();
    tmp_if_expr_2 = return_value_zmq_errno_1 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_2);
}

// zsocket_set_delay_attach_on_connect
// file src/zsockopt.c line 834
void zsocket_set_delay_attach_on_connect(void *zocket, signed int delay_attach_on_connect)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_delay_attach_on_connect () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 39, (const void *)&delay_attach_on_connect, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_gssapi_plaintext
// file src/zsockopt.c line 596
void zsocket_set_gssapi_plaintext(void *zocket, signed int gssapi_plaintext)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_gssapi_plaintext () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 65, (const void *)&gssapi_plaintext, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_gssapi_principal
// file src/zsockopt.c line 632
void zsocket_set_gssapi_principal(void *zocket, const char *gssapi_principal)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_gssapi_principal () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(gssapi_principal);
  rc=zmq_setsockopt(zocket, 63, (const void *)gssapi_principal, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsocket_set_gssapi_server
// file src/zsockopt.c line 560
void zsocket_set_gssapi_server(void *zocket, signed int gssapi_server)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_gssapi_server () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 62, (const void *)&gssapi_server, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_gssapi_service_principal
// file src/zsockopt.c line 668
void zsocket_set_gssapi_service_principal(void *zocket, const char *gssapi_service_principal)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_gssapi_service_principal () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(gssapi_service_principal);
  rc=zmq_setsockopt(zocket, 64, (const void *)gssapi_service_principal, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsocket_set_hwm
// file src/../include/zsocket.h line 104
void zsocket_set_hwm(void *self, signed int hwm)
{
  zsocket_set_sndhwm(self, hwm);
  zsocket_set_rcvhwm(self, hwm);
}

// zsocket_set_identity
// file src/zsockopt.c line 1023
void zsocket_set_identity(void *zocket, const char *identity)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_identity () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int return_value_zsocket_type_6;
  return_value_zsocket_type_6=zsocket_type(zocket);
  signed int return_value_zsocket_type_5;
  signed int return_value_zsocket_type_4;
  signed int return_value_zsocket_type_3;
  if(!(return_value_zsocket_type_6 == 3))
  {
    return_value_zsocket_type_5=zsocket_type(zocket);
    if(!(return_value_zsocket_type_5 == 4))
    {
      return_value_zsocket_type_4=zsocket_type(zocket);
      if(!(return_value_zsocket_type_4 == 5))
      {
        return_value_zsocket_type_3=zsocket_type(zocket);
        if(!(return_value_zsocket_type_3 == 6))
        {
          const char *return_value_zsocket_type_str_2;
          return_value_zsocket_type_str_2=zsocket_type_str(zocket);
          printf("ZMQ_IDENTITY is not valid on %s sockets\n", return_value_zsocket_type_str_2);
          /* assertion 0 */
          assert(0 != 0);
        }

      }

    }

  }

  signed int rc;
  unsigned long int return_value_strlen_7;
  return_value_strlen_7=strlen(identity);
  rc=zmq_setsockopt(zocket, 5, (const void *)identity, return_value_strlen_7);
  _Bool tmp_if_expr_9;
  signed int return_value_zmq_errno_8;
  if(rc == 0)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_zmq_errno_8=zmq_errno();
    tmp_if_expr_9 = return_value_zmq_errno_8 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_9);
}

// zsocket_set_immediate
// file src/zsockopt.c line 740
void zsocket_set_immediate(void *zocket, signed int immediate)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_immediate () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 39, (const void *)&immediate, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_ipv4only
// file src/zsockopt.c line 798
void zsocket_set_ipv4only(void *zocket, signed int ipv4only)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_ipv4only () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 31, (const void *)&ipv4only, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_ipv6
// file src/zsockopt.c line 704
void zsocket_set_ipv6(void *zocket, signed int ipv6)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_ipv6 () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 42, (const void *)&ipv6, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_linger
// file src/../include/zsockopt.h line 112
void zsocket_set_linger(void *zocket, signed int linger)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_linger () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 17, (const void *)&linger, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_maxmsgsize
// file src/zsockopt.c line 1354
void zsocket_set_maxmsgsize(void *zocket, signed int maxmsgsize)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_maxmsgsize () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed long int value = (signed long int)maxmsgsize;
  signed int rc;
  rc=zmq_setsockopt(zocket, 22, (const void *)&value, sizeof(signed long int) /*8ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_multicast_hops
// file src/zsockopt.c line 1391
void zsocket_set_multicast_hops(void *zocket, signed int multicast_hops)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_multicast_hops () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 25, (const void *)&multicast_hops, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_plain_password
// file src/../include/zsockopt.h line 85
void zsocket_set_plain_password(void *zocket, const char *plain_password)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_plain_password () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(plain_password);
  rc=zmq_setsockopt(zocket, 46, (const void *)plain_password, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsocket_set_plain_server
// file src/../include/zsockopt.h line 83
void zsocket_set_plain_server(void *zocket, signed int plain_server)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_plain_server () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 44, (const void *)&plain_server, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_plain_username
// file src/../include/zsockopt.h line 84
void zsocket_set_plain_username(void *zocket, const char *plain_username)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_plain_username () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(plain_username);
  rc=zmq_setsockopt(zocket, 45, (const void *)plain_username, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsocket_set_probe_router
// file src/zsockopt.c line 118
void zsocket_set_probe_router(void *zocket, signed int probe_router)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_probe_router () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int return_value_zsocket_type_5;
  return_value_zsocket_type_5=zsocket_type(zocket);
  signed int return_value_zsocket_type_4;
  signed int return_value_zsocket_type_3;
  if(!(return_value_zsocket_type_5 == 6))
  {
    return_value_zsocket_type_4=zsocket_type(zocket);
    if(!(return_value_zsocket_type_4 == 5))
    {
      return_value_zsocket_type_3=zsocket_type(zocket);
      if(!(return_value_zsocket_type_3 == 3))
      {
        const char *return_value_zsocket_type_str_2;
        return_value_zsocket_type_str_2=zsocket_type_str(zocket);
        printf("ZMQ_PROBE_ROUTER is not valid on %s sockets\n", return_value_zsocket_type_str_2);
        /* assertion 0 */
        assert(0 != 0);
      }

    }

  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 51, (const void *)&probe_router, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_7;
  signed int return_value_zmq_errno_6;
  if(rc == 0)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_zmq_errno_6=zmq_errno();
    tmp_if_expr_7 = return_value_zmq_errno_6 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_7);
}

// zsocket_set_rate
// file src/zsockopt.c line 1066
void zsocket_set_rate(void *zocket, signed int rate)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_rate () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 8, (const void *)&rate, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_rcvbuf
// file src/zsockopt.c line 1174
void zsocket_set_rcvbuf(void *zocket, signed int rcvbuf)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_rcvbuf () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 12, (const void *)&rcvbuf, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_rcvhwm
// file src/../include/zsockopt.h line 103
void zsocket_set_rcvhwm(void *zocket, signed int rcvhwm)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_rcvhwm () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 24, (const void *)&rcvhwm, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_rcvtimeo
// file src/../include/zsockopt.h line 118
void zsocket_set_rcvtimeo(void *zocket, signed int rcvtimeo)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_rcvtimeo () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 27, (const void *)&rcvtimeo, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_reconnect_ivl
// file src/zsockopt.c line 1246
void zsocket_set_reconnect_ivl(void *zocket, signed int reconnect_ivl)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_reconnect_ivl () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 18, (const void *)&reconnect_ivl, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_reconnect_ivl_max
// file src/zsockopt.c line 1282
void zsocket_set_reconnect_ivl_max(void *zocket, signed int reconnect_ivl_max)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_reconnect_ivl_max () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 21, (const void *)&reconnect_ivl_max, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_recovery_ivl
// file src/zsockopt.c line 1102
void zsocket_set_recovery_ivl(void *zocket, signed int recovery_ivl)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_recovery_ivl () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 9, (const void *)&recovery_ivl, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_req_correlate
// file src/zsockopt.c line 164
void zsocket_set_req_correlate(void *zocket, signed int req_correlate)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_req_correlate () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int return_value_zsocket_type_3;
  return_value_zsocket_type_3=zsocket_type(zocket);
  if(!(return_value_zsocket_type_3 == 3))
  {
    const char *return_value_zsocket_type_str_2;
    return_value_zsocket_type_str_2=zsocket_type_str(zocket);
    printf("ZMQ_REQ_CORRELATE is not valid on %s sockets\n", return_value_zsocket_type_str_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 52, (const void *)&req_correlate, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_5;
  signed int return_value_zmq_errno_4;
  if(rc == 0)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_zmq_errno_4=zmq_errno();
    tmp_if_expr_5 = return_value_zmq_errno_4 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_5);
}

// zsocket_set_req_relaxed
// file src/zsockopt.c line 142
void zsocket_set_req_relaxed(void *zocket, signed int req_relaxed)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_req_relaxed () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int return_value_zsocket_type_3;
  return_value_zsocket_type_3=zsocket_type(zocket);
  if(!(return_value_zsocket_type_3 == 3))
  {
    const char *return_value_zsocket_type_str_2;
    return_value_zsocket_type_str_2=zsocket_type_str(zocket);
    printf("ZMQ_REQ_RELAXED is not valid on %s sockets\n", return_value_zsocket_type_str_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 53, (const void *)&req_relaxed, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_5;
  signed int return_value_zmq_errno_4;
  if(rc == 0)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_zmq_errno_4=zmq_errno();
    tmp_if_expr_5 = return_value_zmq_errno_4 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_5);
}

// zsocket_set_router_handover
// file src/zsockopt.c line 74
void zsocket_set_router_handover(void *zocket, signed int router_handover)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_router_handover () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int return_value_zsocket_type_3;
  return_value_zsocket_type_3=zsocket_type(zocket);
  if(!(return_value_zsocket_type_3 == 6))
  {
    const char *return_value_zsocket_type_str_2;
    return_value_zsocket_type_str_2=zsocket_type_str(zocket);
    printf("ZMQ_ROUTER_HANDOVER is not valid on %s sockets\n", return_value_zsocket_type_str_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 56, (const void *)&router_handover, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_5;
  signed int return_value_zmq_errno_4;
  if(rc == 0)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_zmq_errno_4=zmq_errno();
    tmp_if_expr_5 = return_value_zmq_errno_4 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_5);
}

// zsocket_set_router_mandatory
// file src/zsockopt.c line 96
void zsocket_set_router_mandatory(void *zocket, signed int router_mandatory)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_router_mandatory () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int return_value_zsocket_type_3;
  return_value_zsocket_type_3=zsocket_type(zocket);
  if(!(return_value_zsocket_type_3 == 6))
  {
    const char *return_value_zsocket_type_str_2;
    return_value_zsocket_type_str_2=zsocket_type_str(zocket);
    printf("ZMQ_ROUTER_MANDATORY is not valid on %s sockets\n", return_value_zsocket_type_str_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 33, (const void *)&router_mandatory, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_5;
  signed int return_value_zmq_errno_4;
  if(rc == 0)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_zmq_errno_4=zmq_errno();
    tmp_if_expr_5 = return_value_zmq_errno_4 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_5);
}

// zsocket_set_router_raw
// file src/zsockopt.c line 776
void zsocket_set_router_raw(void *zocket, signed int router_raw)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_router_raw () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int return_value_zsocket_type_3;
  return_value_zsocket_type_3=zsocket_type(zocket);
  if(!(return_value_zsocket_type_3 == 6))
  {
    const char *return_value_zsocket_type_str_2;
    return_value_zsocket_type_str_2=zsocket_type_str(zocket);
    printf("ZMQ_ROUTER_RAW is not valid on %s sockets\n", return_value_zsocket_type_str_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 41, (const void *)&router_raw, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_5;
  signed int return_value_zmq_errno_4;
  if(rc == 0)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_zmq_errno_4=zmq_errno();
    tmp_if_expr_5 = return_value_zmq_errno_4 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_5);
}

// zsocket_set_sndbuf
// file src/zsockopt.c line 1138
void zsocket_set_sndbuf(void *zocket, signed int sndbuf)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_sndbuf () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 11, (const void *)&sndbuf, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_sndhwm
// file src/../include/zsockopt.h line 102
void zsocket_set_sndhwm(void *zocket, signed int sndhwm)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_sndhwm () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 23, (const void *)&sndhwm, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_sndtimeo
// file src/zsockopt.c line 1463
void zsocket_set_sndtimeo(void *zocket, signed int sndtimeo)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_sndtimeo () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 28, (const void *)&sndtimeo, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_subscribe
// file src/zsockopt.c line 979
void zsocket_set_subscribe(void *zocket, const char *subscribe)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_subscribe () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int return_value_zsocket_type_3;
  return_value_zsocket_type_3=zsocket_type(zocket);
  if(!(return_value_zsocket_type_3 == 2))
  {
    const char *return_value_zsocket_type_str_2;
    return_value_zsocket_type_str_2=zsocket_type_str(zocket);
    printf("ZMQ_SUBSCRIBE is not valid on %s sockets\n", return_value_zsocket_type_str_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(subscribe);
  rc=zmq_setsockopt(zocket, 6, (const void *)subscribe, return_value_strlen_4);
  _Bool tmp_if_expr_6;
  signed int return_value_zmq_errno_5;
  if(rc == 0)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_zmq_errno_5=zmq_errno();
    tmp_if_expr_6 = return_value_zmq_errno_5 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_6);
}

// zsocket_set_tcp_accept_filter
// file src/zsockopt.c line 1665
void zsocket_set_tcp_accept_filter(void *zocket, const char *tcp_accept_filter)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_tcp_accept_filter () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(tcp_accept_filter);
  rc=zmq_setsockopt(zocket, 38, (const void *)tcp_accept_filter, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsocket_set_tcp_keepalive
// file src/zsockopt.c line 1521
void zsocket_set_tcp_keepalive(void *zocket, signed int tcp_keepalive)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_tcp_keepalive () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 34, (const void *)&tcp_keepalive, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_tcp_keepalive_cnt
// file src/zsockopt.c line 1593
void zsocket_set_tcp_keepalive_cnt(void *zocket, signed int tcp_keepalive_cnt)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_tcp_keepalive_cnt () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 35, (const void *)&tcp_keepalive_cnt, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_tcp_keepalive_idle
// file src/zsockopt.c line 1557
void zsocket_set_tcp_keepalive_idle(void *zocket, signed int tcp_keepalive_idle)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_tcp_keepalive_idle () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 36, (const void *)&tcp_keepalive_idle, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_tcp_keepalive_intvl
// file src/zsockopt.c line 1629
void zsocket_set_tcp_keepalive_intvl(void *zocket, signed int tcp_keepalive_intvl)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_tcp_keepalive_intvl () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 37, (const void *)&tcp_keepalive_intvl, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_tos
// file src/zsockopt.c line 38
void zsocket_set_tos(void *zocket, signed int tos)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_tos () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 57, (const void *)&tos, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_3;
  signed int return_value_zmq_errno_2;
  if(rc == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zmq_errno_2=zmq_errno();
    tmp_if_expr_3 = return_value_zmq_errno_2 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_3);
}

// zsocket_set_unsubscribe
// file src/zsockopt.c line 1001
void zsocket_set_unsubscribe(void *zocket, const char *unsubscribe)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_unsubscribe () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int return_value_zsocket_type_3;
  return_value_zsocket_type_3=zsocket_type(zocket);
  if(!(return_value_zsocket_type_3 == 2))
  {
    const char *return_value_zsocket_type_str_2;
    return_value_zsocket_type_str_2=zsocket_type_str(zocket);
    printf("ZMQ_UNSUBSCRIBE is not valid on %s sockets\n", return_value_zsocket_type_str_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(unsubscribe);
  rc=zmq_setsockopt(zocket, 7, (const void *)unsubscribe, return_value_strlen_4);
  _Bool tmp_if_expr_6;
  signed int return_value_zmq_errno_5;
  if(rc == 0)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_zmq_errno_5=zmq_errno();
    tmp_if_expr_6 = return_value_zmq_errno_5 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_6);
}

// zsocket_set_xpub_verbose
// file src/zsockopt.c line 1499
void zsocket_set_xpub_verbose(void *zocket, signed int xpub_verbose)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_xpub_verbose () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int return_value_zsocket_type_3;
  return_value_zsocket_type_3=zsocket_type(zocket);
  if(!(return_value_zsocket_type_3 == 9))
  {
    const char *return_value_zsocket_type_str_2;
    return_value_zsocket_type_str_2=zsocket_type_str(zocket);
    printf("ZMQ_XPUB_VERBOSE is not valid on %s sockets\n", return_value_zsocket_type_str_2);
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  rc=zmq_setsockopt(zocket, 40, (const void *)&xpub_verbose, sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_5;
  signed int return_value_zmq_errno_4;
  if(rc == 0)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_zmq_errno_4=zmq_errno();
    tmp_if_expr_5 = return_value_zmq_errno_4 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_5);
}

// zsocket_set_zap_domain
// file src/../include/zsockopt.h line 82
void zsocket_set_zap_domain(void *zocket, const char *zap_domain)
{
  _Bool return_value_zsock_is_1;
  return_value_zsock_is_1=zsock_is(zocket);
  if(!(return_value_zsock_is_1 == (_Bool)0))
  {
    printf("Please use zsock_set_zap_domain () on zsock_t instances\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  signed int rc;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(zap_domain);
  rc=zmq_setsockopt(zocket, 55, (const void *)zap_domain, return_value_strlen_2);
  _Bool tmp_if_expr_4;
  signed int return_value_zmq_errno_3;
  if(rc == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_zmq_errno_3=zmq_errno();
    tmp_if_expr_4 = return_value_zmq_errno_3 == 156384712 + 53 ? (_Bool)1 : (_Bool)0;
  }
  /* assertion rc == 0 || zmq_errno () == (156384712 + 53) */
  assert(tmp_if_expr_4);
}

// zsocket_signal
// file src/../include/zsocket.h line 85
signed int zsocket_signal(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zstr_send_1;
  return_value_zstr_send_1=zstr_send(self, "");
  return return_value_zstr_send_1;
}

// zsocket_sndbuf
// file src/zsockopt.c line 1156
signed int zsocket_sndbuf(void *zocket)
{
  signed int sndbuf;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 11, (void *)&sndbuf, &option_len);
  return sndbuf;
}

// zsocket_sndhwm
// file src/zsockopt.c line 888
signed int zsocket_sndhwm(void *zocket)
{
  signed int sndhwm;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 23, (void *)&sndhwm, &option_len);
  return sndhwm;
}

// zsocket_sndtimeo
// file src/zsockopt.c line 1481
signed int zsocket_sndtimeo(void *zocket)
{
  signed int sndtimeo;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 28, (void *)&sndtimeo, &option_len);
  return sndtimeo;
}

// zsocket_tcp_accept_filter
// file src/zsockopt.c line 1683
char * zsocket_tcp_accept_filter(void *zocket)
{
  unsigned long int option_len = (unsigned long int)255;
  char *tcp_accept_filter;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link36(option_len, "src/zsockopt.c", (unsigned int)1687);
  tcp_accept_filter = (char *)return_value_safe_malloc_1;
  zmq_getsockopt(zocket, 38, (void *)tcp_accept_filter, &option_len);
  return (char *)tcp_accept_filter;
}

// zsocket_tcp_keepalive
// file src/zsockopt.c line 1539
signed int zsocket_tcp_keepalive(void *zocket)
{
  signed int tcp_keepalive;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 34, (void *)&tcp_keepalive, &option_len);
  return tcp_keepalive;
}

// zsocket_tcp_keepalive_cnt
// file src/zsockopt.c line 1611
signed int zsocket_tcp_keepalive_cnt(void *zocket)
{
  signed int tcp_keepalive_cnt;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 35, (void *)&tcp_keepalive_cnt, &option_len);
  return tcp_keepalive_cnt;
}

// zsocket_tcp_keepalive_idle
// file src/zsockopt.c line 1575
signed int zsocket_tcp_keepalive_idle(void *zocket)
{
  signed int tcp_keepalive_idle;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 36, (void *)&tcp_keepalive_idle, &option_len);
  return tcp_keepalive_idle;
}

// zsocket_tcp_keepalive_intvl
// file src/zsockopt.c line 1647
signed int zsocket_tcp_keepalive_intvl(void *zocket)
{
  signed int tcp_keepalive_intvl;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 37, (void *)&tcp_keepalive_intvl, &option_len);
  return tcp_keepalive_intvl;
}

// zsocket_test
// file src/zsocket.c line 248
void zsocket_test(_Bool verbose)
{
  printf(" * zsocket (deprecated): ");
  struct _zctx_t *ctx;
  ctx=zctx_new();
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  char *interf = "127.0.0.1";
  char *domain = "localhost";
  signed int service = 5560;
  void *writer;
  writer=zsocket_new(ctx, 8);
  /* assertion writer */
  assert(writer != NULL);
  void *reader;
  reader=zsocket_new(ctx, 7);
  /* assertion reader */
  assert(reader != NULL);
  const char *return_value_zsocket_type_str_1;
  return_value_zsocket_type_str_1=zsocket_type_str(writer);
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(return_value_zsocket_type_str_1, "PUSH");
  /* assertion (!strcmp ((zsocket_type_str (writer)), ("PUSH"))) */
  assert(!(return_value_strcmp_2 != 0));
  const char *return_value_zsocket_type_str_3;
  return_value_zsocket_type_str_3=zsocket_type_str(reader);
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(return_value_zsocket_type_str_3, "PULL");
  /* assertion (!strcmp ((zsocket_type_str (reader)), ("PULL"))) */
  assert(!(return_value_strcmp_4 != 0));
  signed int rc;
  rc=zsocket_bind(writer, "tcp://%s:%d", interf, service);
  /* assertion rc == service */
  assert(rc == service);
  rc=zsocket_unbind(writer, "tcp://%s:%d", interf, service);
  /* assertion rc == 0 */
  assert(rc == 0);
  zclock_sleep(100);
  rc=zsocket_bind(writer, "tcp://%s:%d", interf, service);
  /* assertion rc == service */
  assert(rc == service);
  rc=zsocket_connect(reader, "tcp://%s:%d", domain, service);
  /* assertion rc == 0 */
  assert(rc == 0);
  zstr_send(writer, "HELLO");
  char *message;
  message=zstr_recv(reader);
  /* assertion message */
  assert(message != ((char *)NULL));
  signed int return_value_strcmp_5;
  return_value_strcmp_5=strcmp(message, "HELLO");
  /* assertion (!strcmp ((message), ("HELLO"))) */
  assert(!(return_value_strcmp_5 != 0));
  free((void *)message);
  signed int port;
  port=zsocket_bind(writer, "tcp://%s:*", interf);
  /* assertion port >= 0xc000 && port <= 0xffff */
  assert(port >= 0xc000 && port <= 0xffff);
  _Bool return_value_zsocket_poll_6;
  return_value_zsocket_poll_6=zsocket_poll(writer, 100);
  /* assertion zsocket_poll (writer, 100) == 0 */
  assert((signed int)return_value_zsocket_poll_6 == 0);
  rc=zsocket_connect(reader, "txp://%s:%d", domain, service);
  /* assertion rc == -1 */
  assert(rc == -1);
  rc=zsocket_sendmem(writer, (const void *)"ABC", (unsigned long int)3, 1);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsocket_sendmem(writer, (const void *)"DEFG", (unsigned long int)4, 0);
  /* assertion rc == 0 */
  assert(rc == 0);
  struct _zframe_t *frame;
  frame=zframe_recv(reader);
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_streq_7;
  return_value_zframe_streq_7=zframe_streq(frame, "ABC");
  /* assertion zframe_streq (frame, "ABC") */
  assert(return_value_zframe_streq_7 != (_Bool)0);
  signed int return_value_zframe_more_8;
  return_value_zframe_more_8=zframe_more(frame);
  /* assertion zframe_more (frame) */
  assert(return_value_zframe_more_8 != 0);
  zframe_destroy(&frame);
  frame=zframe_recv(reader);
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  _Bool return_value_zframe_streq_9;
  return_value_zframe_streq_9=zframe_streq(frame, "DEFG");
  /* assertion zframe_streq (frame, "DEFG") */
  assert(return_value_zframe_streq_9 != (_Bool)0);
  signed int return_value_zframe_more_10;
  return_value_zframe_more_10=zframe_more(frame);
  /* assertion !zframe_more (frame) */
  assert(!(return_value_zframe_more_10 != 0));
  zframe_destroy(&frame);
  rc=zsocket_signal(writer);
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsocket_wait(reader);
  /* assertion rc == 0 */
  assert(rc == 0);
  zsocket_destroy(ctx, reader);
  zsocket_destroy(ctx, writer);
  zctx_destroy(&ctx);
  printf("OK\n");
}

// zsocket_tos
// file src/zsockopt.c line 56
signed int zsocket_tos(void *zocket)
{
  signed int tos;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 57, (void *)&tos, &option_len);
  return tos;
}

// zsocket_type
// file src/../include/zsockopt.h line 47
signed int zsocket_type(void *zocket)
{
  signed int type;
  unsigned long int option_len = sizeof(signed int) /*4ul*/ ;
  zmq_getsockopt(zocket, 16, (void *)&type, &option_len);
  return type;
}

// zsocket_type_str
// file src/zsocket.c line 167
const char * zsocket_type_str(void *self)
{
  /* assertion self */
  assert(self != NULL);
  signed int return_value_zsocket_type_1;
  return_value_zsocket_type_1=zsocket_type(self);
  char *return_value_zsys_sockname_2;
  return_value_zsys_sockname_2=zsys_sockname(return_value_zsocket_type_1);
  return return_value_zsys_sockname_2;
}

// zsocket_unbind
// file src/../include/zsocket.h line 53
signed int zsocket_unbind(void *self, const char *format, ...)
{
  char endpoint[256l];
  void **argptr = (void **)&format;
  vsnprintf(endpoint, (unsigned long int)256, format, argptr);
  argptr = ((void **)NULL);
  signed int return_value_zmq_unbind_1;
  return_value_zmq_unbind_1=zmq_unbind(self, endpoint);
  return return_value_zmq_unbind_1;
}

// zsocket_wait
// file src/../include/zsocket.h line 90
signed int zsocket_wait(void *self)
{
  /* assertion self */
  assert(self != NULL);
  char *message;
  message=zstr_recv(self);
  if(!(message == ((char *)NULL)))
  {
    free((void *)message);
    return 0;
  }

  else
    return -1;
}

// zsocket_zap_domain
// file src/zsockopt.c line 230
char * zsocket_zap_domain(void *zocket)
{
  unsigned long int option_len = (unsigned long int)255;
  char *zap_domain;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link36(option_len, "src/zsockopt.c", (unsigned int)234);
  zap_domain = (char *)return_value_safe_malloc_1;
  zmq_getsockopt(zocket, 55, (void *)zap_domain, &option_len);
  return (char *)zap_domain;
}

// zsockopt_test
// file src/zsockopt.c line 3483
void zsockopt_test(_Bool verbose)
{
  printf(" * zsockopt (deprecated): ");
  struct _zctx_t *ctx;
  ctx=zctx_new();
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  void *zocket;
  zocket=zsocket_new(ctx, 5);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_tos(zocket, 1);
  signed int return_value_zsocket_tos_1;
  return_value_zsocket_tos_1=zsocket_tos(zocket);
  /* assertion zsocket_tos (zocket) == 1 */
  assert(return_value_zsocket_tos_1 == 1);
  zsocket_tos(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 6);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_router_handover(zocket, 1);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 6);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_router_mandatory(zocket, 1);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 5);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_probe_router(zocket, 1);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 3);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_req_relaxed(zocket, 1);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 3);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_req_correlate(zocket, 1);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 8);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_conflate(zocket, 1);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_zap_domain(zocket, "test");
  char *zap_domain;
  zap_domain=zsocket_zap_domain(zocket);
  /* assertion zap_domain */
  assert(zap_domain != ((char *)NULL));
  free((void *)zap_domain);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_mechanism(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 1);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_plain_server(zocket, 1);
  signed int return_value_zsocket_plain_server_2;
  return_value_zsocket_plain_server_2=zsocket_plain_server(zocket);
  /* assertion zsocket_plain_server (zocket) == 1 */
  assert(return_value_zsocket_plain_server_2 == 1);
  zsocket_plain_server(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_plain_username(zocket, "test");
  char *plain_username;
  plain_username=zsocket_plain_username(zocket);
  /* assertion plain_username */
  assert(plain_username != ((char *)NULL));
  free((void *)plain_username);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_plain_password(zocket, "test");
  char *plain_password;
  plain_password=zsocket_plain_password(zocket);
  /* assertion plain_password */
  assert(plain_password != ((char *)NULL));
  free((void *)plain_password);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_ipv6(zocket, 1);
  signed int return_value_zsocket_ipv6_3;
  return_value_zsocket_ipv6_3=zsocket_ipv6(zocket);
  /* assertion zsocket_ipv6 (zocket) == 1 */
  assert(return_value_zsocket_ipv6_3 == 1);
  zsocket_ipv6(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 5);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_immediate(zocket, 1);
  signed int return_value_zsocket_immediate_4;
  return_value_zsocket_immediate_4=zsocket_immediate(zocket);
  /* assertion zsocket_immediate (zocket) == 1 */
  assert(return_value_zsocket_immediate_4 == 1);
  zsocket_immediate(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 6);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_router_raw(zocket, 1);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_ipv4only(zocket, 1);
  signed int return_value_zsocket_ipv4only_5;
  return_value_zsocket_ipv4only_5=zsocket_ipv4only(zocket);
  /* assertion zsocket_ipv4only (zocket) == 1 */
  assert(return_value_zsocket_ipv4only_5 == 1);
  zsocket_ipv4only(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 1);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_delay_attach_on_connect(zocket, 1);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_type(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 1);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_sndhwm(zocket, 1);
  signed int return_value_zsocket_sndhwm_6;
  return_value_zsocket_sndhwm_6=zsocket_sndhwm(zocket);
  /* assertion zsocket_sndhwm (zocket) == 1 */
  assert(return_value_zsocket_sndhwm_6 == 1);
  zsocket_sndhwm(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_rcvhwm(zocket, 1);
  signed int return_value_zsocket_rcvhwm_7;
  return_value_zsocket_rcvhwm_7=zsocket_rcvhwm(zocket);
  /* assertion zsocket_rcvhwm (zocket) == 1 */
  assert(return_value_zsocket_rcvhwm_7 == 1);
  zsocket_rcvhwm(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_affinity(zocket, 1);
  signed int return_value_zsocket_affinity_8;
  return_value_zsocket_affinity_8=zsocket_affinity(zocket);
  /* assertion zsocket_affinity (zocket) == 1 */
  assert(return_value_zsocket_affinity_8 == 1);
  zsocket_affinity(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_subscribe(zocket, "test");
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_unsubscribe(zocket, "test");
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 5);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_identity(zocket, "test");
  char *identity;
  identity=zsocket_identity(zocket);
  /* assertion identity */
  assert(identity != ((char *)NULL));
  free((void *)identity);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_rate(zocket, 1);
  signed int return_value_zsocket_rate_9;
  return_value_zsocket_rate_9=zsocket_rate(zocket);
  /* assertion zsocket_rate (zocket) == 1 */
  assert(return_value_zsocket_rate_9 == 1);
  zsocket_rate(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_recovery_ivl(zocket, 1);
  signed int return_value_zsocket_recovery_ivl_10;
  return_value_zsocket_recovery_ivl_10=zsocket_recovery_ivl(zocket);
  /* assertion zsocket_recovery_ivl (zocket) == 1 */
  assert(return_value_zsocket_recovery_ivl_10 == 1);
  zsocket_recovery_ivl(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 1);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_sndbuf(zocket, 1);
  signed int return_value_zsocket_sndbuf_11;
  return_value_zsocket_sndbuf_11=zsocket_sndbuf(zocket);
  /* assertion zsocket_sndbuf (zocket) == 1 */
  assert(return_value_zsocket_sndbuf_11 == 1);
  zsocket_sndbuf(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_rcvbuf(zocket, 1);
  signed int return_value_zsocket_rcvbuf_12;
  return_value_zsocket_rcvbuf_12=zsocket_rcvbuf(zocket);
  /* assertion zsocket_rcvbuf (zocket) == 1 */
  assert(return_value_zsocket_rcvbuf_12 == 1);
  zsocket_rcvbuf(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_linger(zocket, 1);
  signed int return_value_zsocket_linger_13;
  return_value_zsocket_linger_13=zsocket_linger(zocket);
  /* assertion zsocket_linger (zocket) == 1 */
  assert(return_value_zsocket_linger_13 == 1);
  zsocket_linger(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_reconnect_ivl(zocket, 1);
  signed int return_value_zsocket_reconnect_ivl_14;
  return_value_zsocket_reconnect_ivl_14=zsocket_reconnect_ivl(zocket);
  /* assertion zsocket_reconnect_ivl (zocket) == 1 */
  assert(return_value_zsocket_reconnect_ivl_14 == 1);
  zsocket_reconnect_ivl(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_reconnect_ivl_max(zocket, 1);
  signed int return_value_zsocket_reconnect_ivl_max_15;
  return_value_zsocket_reconnect_ivl_max_15=zsocket_reconnect_ivl_max(zocket);
  /* assertion zsocket_reconnect_ivl_max (zocket) == 1 */
  assert(return_value_zsocket_reconnect_ivl_max_15 == 1);
  zsocket_reconnect_ivl_max(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_backlog(zocket, 1);
  signed int return_value_zsocket_backlog_16;
  return_value_zsocket_backlog_16=zsocket_backlog(zocket);
  /* assertion zsocket_backlog (zocket) == 1 */
  assert(return_value_zsocket_backlog_16 == 1);
  zsocket_backlog(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_maxmsgsize(zocket, 1);
  signed int return_value_zsocket_maxmsgsize_17;
  return_value_zsocket_maxmsgsize_17=zsocket_maxmsgsize(zocket);
  /* assertion zsocket_maxmsgsize (zocket) == 1 */
  assert(return_value_zsocket_maxmsgsize_17 == 1);
  zsocket_maxmsgsize(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_multicast_hops(zocket, 1);
  signed int return_value_zsocket_multicast_hops_18;
  return_value_zsocket_multicast_hops_18=zsocket_multicast_hops(zocket);
  /* assertion zsocket_multicast_hops (zocket) == 1 */
  assert(return_value_zsocket_multicast_hops_18 == 1);
  zsocket_multicast_hops(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_rcvtimeo(zocket, 1);
  signed int return_value_zsocket_rcvtimeo_19;
  return_value_zsocket_rcvtimeo_19=zsocket_rcvtimeo(zocket);
  /* assertion zsocket_rcvtimeo (zocket) == 1 */
  assert(return_value_zsocket_rcvtimeo_19 == 1);
  zsocket_rcvtimeo(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_sndtimeo(zocket, 1);
  signed int return_value_zsocket_sndtimeo_20;
  return_value_zsocket_sndtimeo_20=zsocket_sndtimeo(zocket);
  /* assertion zsocket_sndtimeo (zocket) == 1 */
  assert(return_value_zsocket_sndtimeo_20 == 1);
  zsocket_sndtimeo(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 9);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_xpub_verbose(zocket, 1);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_tcp_keepalive(zocket, 1);
  signed int return_value_zsocket_tcp_keepalive_21;
  return_value_zsocket_tcp_keepalive_21=zsocket_tcp_keepalive(zocket);
  /* assertion zsocket_tcp_keepalive (zocket) == 1 */
  assert(return_value_zsocket_tcp_keepalive_21 == 1);
  zsocket_tcp_keepalive(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_tcp_keepalive_idle(zocket, 1);
  signed int return_value_zsocket_tcp_keepalive_idle_22;
  return_value_zsocket_tcp_keepalive_idle_22=zsocket_tcp_keepalive_idle(zocket);
  /* assertion zsocket_tcp_keepalive_idle (zocket) == 1 */
  assert(return_value_zsocket_tcp_keepalive_idle_22 == 1);
  zsocket_tcp_keepalive_idle(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_tcp_keepalive_cnt(zocket, 1);
  signed int return_value_zsocket_tcp_keepalive_cnt_23;
  return_value_zsocket_tcp_keepalive_cnt_23=zsocket_tcp_keepalive_cnt(zocket);
  /* assertion zsocket_tcp_keepalive_cnt (zocket) == 1 */
  assert(return_value_zsocket_tcp_keepalive_cnt_23 == 1);
  zsocket_tcp_keepalive_cnt(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_tcp_keepalive_intvl(zocket, 1);
  signed int return_value_zsocket_tcp_keepalive_intvl_24;
  return_value_zsocket_tcp_keepalive_intvl_24=zsocket_tcp_keepalive_intvl(zocket);
  /* assertion zsocket_tcp_keepalive_intvl (zocket) == 1 */
  assert(return_value_zsocket_tcp_keepalive_intvl_24 == 1);
  zsocket_tcp_keepalive_intvl(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_set_tcp_accept_filter(zocket, "127.0.0.1");
  char *tcp_accept_filter;
  tcp_accept_filter=zsocket_tcp_accept_filter(zocket);
  /* assertion tcp_accept_filter */
  assert(tcp_accept_filter != ((char *)NULL));
  free((void *)tcp_accept_filter);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_rcvmore(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_fd(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  zsocket_events(zocket);
  zsocket_destroy(ctx, zocket);
  zocket=zsocket_new(ctx, 2);
  /* assertion zocket */
  assert(zocket != NULL);
  char *last_endpoint;
  last_endpoint=zsocket_last_endpoint(zocket);
  /* assertion last_endpoint */
  assert(last_endpoint != ((char *)NULL));
  free((void *)last_endpoint);
  zsocket_destroy(ctx, zocket);
  zctx_destroy(&ctx);
  printf("OK\n");
}

// zstr_free
// file src/../include/zstr.h line 70
void zstr_free(char **string_p)
{
  /* assertion string_p */
  assert(string_p != ((char **)NULL));
  free((void *)*string_p);
  *string_p = (char *)(void *)0;
}

// zstr_recv
// file src/../include/zstr.h line 26
char * zstr_recv(void *source)
{
  /* assertion source */
  assert(source != NULL);
  void *handle;
  handle=zsock_resolve(source);
  struct zmq_msg_t message;
  zmq_msg_init(&message);
  signed int return_value_zmq_recvmsg_1;
  return_value_zmq_recvmsg_1=zmq_recvmsg(handle, &message, 0);
  if(!(return_value_zmq_recvmsg_1 >= 0))
    return (char *)(void *)0;

  else
  {
    unsigned long int size;
    size=zmq_msg_size(&message);
    char *string;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(size + (unsigned long int)1);
    string = (char *)return_value_malloc_2;
    if(!(string == ((char *)NULL)))
    {
      void *return_value_zmq_msg_data_3;
      return_value_zmq_msg_data_3=zmq_msg_data(&message);
      memcpy((void *)string, return_value_zmq_msg_data_3, size);
      string[(signed long int)size] = (char)0;
    }

    zmq_msg_close(&message);
    return string;
  }
}

// zstr_recv_nowait
// file src/zstr.c line 239
char * zstr_recv_nowait(void *dest)
{
  /* assertion dest */
  assert(dest != NULL);
  void *handle;
  handle=zsock_resolve(dest);
  struct zmq_msg_t message;
  zmq_msg_init(&message);
  signed int return_value_zmq_recvmsg_1;
  return_value_zmq_recvmsg_1=zmq_recvmsg(handle, &message, 1);
  if(!(return_value_zmq_recvmsg_1 >= 0))
    return (char *)(void *)0;

  else
  {
    unsigned long int size;
    size=zmq_msg_size(&message);
    char *string;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(size + (unsigned long int)1);
    string = (char *)return_value_malloc_2;
    if(!(string == ((char *)NULL)))
    {
      void *return_value_zmq_msg_data_3;
      return_value_zmq_msg_data_3=zmq_msg_data(&message);
      memcpy((void *)string, return_value_zmq_msg_data_3, size);
      string[(signed long int)size] = (char)0;
    }

    zmq_msg_close(&message);
    return string;
  }
}

// zstr_recvx
// file src/../include/zstr.h line 65
signed int zstr_recvx(void *source, char **string_p, ...)
{
  /* assertion source */
  assert(source != NULL);
  void *handle;
  handle=zsock_resolve(source);
  struct _zmsg_t *msg;
  msg=zmsg_recv(handle);
  if(msg == ((struct _zmsg_t *)NULL))
    return -1;

  else
  {
    signed int return_value_zmsg_signal_1;
    return_value_zmsg_signal_1=zmsg_signal(msg);
    if(return_value_zmsg_signal_1 >= 0)
    {
      zmsg_destroy(&msg);
      return -1;
    }

    else
    {
      signed int count = 0;
      __builtin_va_list args;
      va_start(args, string_p);
      for( ; !(string_p == ((char **)NULL)); count = count + 1)
      {
        *string_p=zmsg_popstr(msg);
        string_p=va_arg(args, __typeof__(string_p));
      }
      va_end(args);
      zmsg_destroy(&msg);
      return count;
    }
  }
}

// zstr_send
// file src/../include/zstr.h line 33
signed int zstr_send(void *dest, const char *string)
{
  /* assertion dest */
  assert(dest != NULL);
  signed int return_value_s_send_string_1;
  return_value_s_send_string_1=s_send_string(dest, (_Bool)0, string != ((const char *)NULL) ? (char *)string : "");
  return return_value_s_send_string_1;
}

// zstr_sendf
// file src/../include/zstr.h line 44
signed int zstr_sendf(void *dest, const char *format, ...)
{
  /* assertion dest */
  assert(dest != NULL);
  /* assertion format */
  assert(format != ((const char *)NULL));
  void **argptr = (void **)&format;
  char *string;
  string=zsys_vprintf(format, argptr);
  if(string == ((char *)NULL))
    return -1;

  else
  {
    argptr = ((void **)NULL);
    signed int rc;
    rc=s_send_string(dest, (_Bool)0, string);
    free((void *)string);
    return rc;
  }
}

// zstr_sendfm
// file src/../include/zstr.h line 50
signed int zstr_sendfm(void *dest, const char *format, ...)
{
  /* assertion dest */
  assert(dest != NULL);
  /* assertion format */
  assert(format != ((const char *)NULL));
  void **argptr = (void **)&format;
  char *string;
  string=zsys_vprintf(format, argptr);
  if(string == ((char *)NULL))
    return -1;

  else
  {
    argptr = ((void **)NULL);
    signed int rc;
    rc=s_send_string(dest, (_Bool)1, string);
    free((void *)string);
    return rc;
  }
}

// zstr_sendm
// file src/../include/zstr.h line 38
signed int zstr_sendm(void *dest, const char *string)
{
  /* assertion dest */
  assert(dest != NULL);
  /* assertion string */
  assert(string != ((const char *)NULL));
  signed int return_value_s_send_string_1;
  return_value_s_send_string_1=s_send_string(dest, (_Bool)1, (char *)string);
  return return_value_s_send_string_1;
}

// zstr_sendx
// file src/../include/zstr.h line 55
signed int zstr_sendx(void *dest, const char *string, ...)
{
  struct _zmsg_t *msg;
  msg=zmsg_new();
  if(msg == ((struct _zmsg_t *)NULL))
    return -1;

  else
  {
    __builtin_va_list args;
    va_start(args, string);
    while(!(string == ((const char *)NULL)))
    {
      zmsg_addstr(msg, string);
      string=va_arg(args, __typeof__(string));
    }
    va_end(args);
    signed int return_value_zmsg_send_1;
    return_value_zmsg_send_1=zmsg_send(&msg, dest);
    return return_value_zmsg_send_1;
  }
}

// zstr_test
// file src/zstr.c line 264
void zstr_test(_Bool verbose)
{
  printf(" * zstr: ");
  struct _zsock_t *output;
  output=zsock_new_pair_checked("@inproc://zstr.test", "src/zstr.c", (unsigned long int)270);
  /* assertion output */
  assert(output != ((struct _zsock_t *)NULL));
  struct _zsock_t *input;
  input=zsock_new_pair_checked(">inproc://zstr.test", "src/zstr.c", (unsigned long int)272);
  /* assertion input */
  assert(input != ((struct _zsock_t *)NULL));
  signed int string_nbr = 0;
  for( ; !(string_nbr >= 10); string_nbr = string_nbr + 1)
    zstr_sendf((void *)output, "this is string %d", string_nbr);
  zstr_sendx((void *)output, "This", (const void *)"is", (const void *)"almost", (const void *)"the", (const void *)"very", (const void *)"END", (void *)0);
  string_nbr = 0;
  string_nbr = 0;
  do
  {
    char *string;
    string=zstr_recv((void *)input);
    /* assertion string */
    assert(string != ((char *)NULL));
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(string, "END");
    if(return_value_strcmp_1 == 0)
    {
      zstr_free(&string);
      break;
    }

    zstr_free(&string);
    string_nbr = string_nbr + 1;
  }
  while((_Bool)1);
  /* assertion string_nbr == 15 */
  assert(string_nbr == 15);
  zsock_destroy_checked(&input, "src/zstr.c", (unsigned long int)294);
  zsock_destroy_checked(&output, "src/zstr.c", (unsigned long int)295);
  printf("OK\n");
}

// zsys_catch_interrupts
// file src/zsys.c line 483
void zsys_catch_interrupts(void)
{
  char *return_value_getenv_1;
  return_value_getenv_1=getenv("ZSYS_SIGHANDLER");
  _Bool tmp_if_expr_4;
  char *return_value_getenv_2;
  signed int return_value_strcmp_3;
  if(return_value_getenv_1 == ((char *)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_getenv_2=getenv("ZSYS_SIGHANDLER");
    return_value_strcmp_3=strcmp(return_value_getenv_2, "false");
    tmp_if_expr_4 = return_value_strcmp_3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
  {
    if(!(handle_signals == (_Bool)0))
      zsys_handler_set(s_signal_handler);

  }

}

// zsys_close
// file src/../include/zsys.h line 54
signed int zsys_close(void *handle, const char *filename, unsigned long int line_nbr)
{
  pthread_mutex_lock(&s_mutex);
  if(!(s_sockref_list == ((struct _zlist_t *)NULL)))
  {
    struct anonymous_18 *sockref;
    void *return_value_zlist_first_1;
    return_value_zlist_first_1=zlist_first(s_sockref_list);
    sockref = (struct anonymous_18 *)return_value_zlist_first_1;
    while(!(sockref == ((struct anonymous_18 *)NULL)))
    {
      if(sockref->handle == handle)
      {
        zlist_remove(s_sockref_list, (void *)sockref);
        free((void *)sockref);
        break;
      }

      void *return_value_zlist_next_2;
      return_value_zlist_next_2=zlist_next(s_sockref_list);
      sockref = (struct anonymous_18 *)return_value_zlist_next_2;
    }
  }

  s_open_sockets = s_open_sockets - 1ul;
  zmq_close(handle);
  pthread_mutex_unlock(&s_mutex);
  return 0;
}

// zsys_create_pipe
// file src/../include/zsys.h line 65
struct _zsock_t * zsys_create_pipe(struct _zsock_t **backend_p)
{
  struct _zsock_t *frontend;
  frontend=zsock_new_checked(0, "src/zsys.c", (unsigned long int)378);
  struct _zsock_t *backend;
  backend=zsock_new_checked(0, "src/zsys.c", (unsigned long int)379);
  if(backend == ((struct _zsock_t *)NULL) || frontend == ((struct _zsock_t *)NULL))
  {
    zsock_destroy_checked(&frontend, "src/zsys.c", (unsigned long int)381);
    zsock_destroy_checked(&backend, "src/zsys.c", (unsigned long int)382);
    return frontend;
  }

  else
  {
    unsigned long int return_value_zsys_pipehwm_1;
    return_value_zsys_pipehwm_1=zsys_pipehwm();
    zsock_set_sndhwm((void *)frontend, (signed int)return_value_zsys_pipehwm_1);
    unsigned long int return_value_zsys_pipehwm_2;
    return_value_zsys_pipehwm_2=zsys_pipehwm();
    zsock_set_sndhwm((void *)backend, (signed int)return_value_zsys_pipehwm_2);
    char endpoint[32l];
    while((_Bool)1)
    {
      signed long int return_value_random_3;
      return_value_random_3=random();
      signed long int return_value_random_4;
      return_value_random_4=random();
      sprintf(endpoint, "inproc://pipe-%04x-%04x", (signed int)((double)((float)0x10000 * (float)return_value_random_3) / ((double)2147483647 + 1.0)), (signed int)((double)((float)0x10000 * (float)return_value_random_4) / ((double)2147483647 + 1.0)));
      signed int return_value_zsock_bind_5;
      return_value_zsock_bind_5=zsock_bind(frontend, "%s", (const void *)endpoint);
      if(return_value_zsock_bind_5 == 0)
        break;

    }
    signed int rc;
    rc=zsock_connect(backend, "%s", (const void *)endpoint);
    /* assertion rc != -1 */
    assert(rc != -1);
    *backend_p = backend;
    return frontend;
  }
}

// zsys_daemonize
// file src/zsys.c line 994
signed int zsys_daemonize(const char *workdir)
{
  unsigned int file_mask = (unsigned int)027;
  signed int fork_result;
  fork_result=fork();
  if(!(fork_result >= 0))
    return -1;

  else
    if(fork_result >= 1)
      exit(0);

  signed int return_value_zsys_dir_change_1;
  if(!(workdir == ((const char *)NULL)))
  {
    return_value_zsys_dir_change_1=zsys_dir_change(workdir);
    if(!(return_value_zsys_dir_change_1 == 0))
    {
      zsys_error("cannot chdir to '%s'", workdir);
      return -1;
    }

  }

  signed int file_handle;
  signed long int return_value_sysconf_2;
  return_value_sysconf_2=sysconf(4);
  file_handle = (signed int)return_value_sysconf_2;
  while(!(file_handle == 0))
  {
    signed int tmp_post_3 = file_handle;
    file_handle = file_handle - 1;
    close(tmp_post_3);
  }
  umask(file_mask);
  file_handle=open("/dev/null", 02);
  signed int fh_stdout;
  fh_stdout=dup(file_handle);
  signed int fh_stderr;
  fh_stderr=dup(file_handle);
  /* assertion fh_stdout */
  assert(fh_stdout != 0);
  /* assertion fh_stderr */
  assert(fh_stderr != 0);
  signal(1, (void (*)(signed int))1);
  return 0;
}

// zsys_debug
// file src/../include/zsys.h line 329
void zsys_debug(const char *format, ...)
{
  void **argptr = (void **)&format;
  char *string;
  string=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  s_log((char)68, string);
  free((void *)string);
}

// zsys_dir_change
// file src/zsys.c line 686
signed int zsys_dir_change(const char *pathname)
{
  /* assertion pathname */
  assert(pathname != ((const char *)NULL));
  signed int return_value_chdir_1;
  return_value_chdir_1=chdir(pathname);
  return return_value_chdir_1;
  return -1;
}

// zsys_dir_create
// file src/../include/zsys.h line 113
signed int zsys_dir_create(const char *pathname, ...)
{
  void **argptr = (void **)&pathname;
  char *formatted;
  formatted=zsys_vprintf(pathname, argptr);
  argptr = ((void **)NULL);
  if(formatted == ((char *)NULL))
    return -1;

  else
  {
    char *slash;
    slash=strchr(formatted + (signed long int)1, 47);
    while((_Bool)1)
    {
      if(!(slash == ((char *)NULL)))
        *slash = (char)0;

      signed int mode;
      mode=zsys_file_mode(formatted);
      if(mode == -1)
      {
        signed int return_value_mkdir_1;
        return_value_mkdir_1=mkdir(formatted, (unsigned int)0775);
        if(!(return_value_mkdir_1 == 0))
        {
          free((void *)formatted);
          return -1;
        }

      }

      if(slash == ((char *)NULL))
        break;

      *slash = (char)47;
      slash=strchr(slash + (signed long int)1, 47);
    }
    free((void *)formatted);
    return 0;
  }
}

// zsys_dir_delete
// file src/../include/zsys.h line 117
signed int zsys_dir_delete(const char *pathname, ...)
{
  void **argptr = (void **)&pathname;
  char *formatted;
  formatted=zsys_vprintf(pathname, argptr);
  argptr = ((void **)NULL);
  if(formatted == ((char *)NULL))
    return -1;

  else
  {
    signed int rc;
    rc=rmdir(formatted);
    free((void *)formatted);
    return rc;
  }
}

// zsys_error
// file src/../include/zsys.h line 313
void zsys_error(const char *format, ...)
{
  void **argptr = (void **)&format;
  char *string;
  string=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  s_log((char)69, string);
  free((void *)string);
}

// zsys_file_delete
// file src/../include/zsys.h line 104
signed int zsys_file_delete(const char *filename)
{
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  signed int return_value_unlink_1;
  return_value_unlink_1=unlink(filename);
  return return_value_unlink_1;
}

// zsys_file_exists
// file src/../include/zsys.h line 86
_Bool zsys_file_exists(const char *filename)
{
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  signed int return_value_zsys_file_mode_1;
  return_value_zsys_file_mode_1=zsys_file_mode(filename);
  return return_value_zsys_file_mode_1 != -1;
}

// zsys_file_mode
// file src/../include/zsys.h line 100
signed int zsys_file_mode(const char *filename)
{
  struct stat stat_buf;
  signed int return_value_stat_1;
  return_value_stat_1=stat((char *)filename, &stat_buf);
  if(return_value_stat_1 == 0)
    return (signed int)stat_buf.st_mode;

  else
    return -1;
}

// zsys_file_mode_default
// file src/../include/zsys.h line 131
void zsys_file_mode_default(void)
{
  if(!(s_old_mask == 0u))
    umask(s_old_mask);

}

// zsys_file_mode_private
// file src/../include/zsys.h line 126
void zsys_file_mode_private(void)
{
  s_old_mask=umask((unsigned int)(0200 >> 3 | (0200 >> 3) >> 3 | 0400 >> 3 | (0400 >> 3) >> 3));
}

// zsys_file_modified
// file src/../include/zsys.h line 94
signed long int zsys_file_modified(const char *filename)
{
  struct stat stat_buf;
  signed int return_value_stat_1;
  return_value_stat_1=stat(filename, &stat_buf);
  if(return_value_stat_1 == 0)
    return stat_buf.st_mtim.tv_sec;

  else
    return (signed long int)0;
}

// zsys_file_size
// file src/../include/zsys.h line 90
signed long int zsys_file_size(const char *filename)
{
  struct stat stat_buf;
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  signed int return_value_stat_1;
  return_value_stat_1=stat((char *)filename, &stat_buf);
  if(return_value_stat_1 == 0)
    return stat_buf.st_size;

  else
    return (signed long int)-1;
}

// zsys_file_stable
// file src/../include/zsys.h line 108
_Bool zsys_file_stable(const char *filename)
{
  struct stat stat_buf;
  signed int return_value_stat_2;
  return_value_stat_2=stat(filename, &stat_buf);
  if(return_value_stat_2 == 0)
  {
    signed long int age;
    signed long int return_value_zclock_time_1;
    return_value_zclock_time_1=zclock_time();
    age = (signed long int)(return_value_zclock_time_1 - stat_buf.st_mtim.tv_sec * (signed long int)1000);
    return age > (signed long int)1000;
  }

  else
    return (_Bool)0;
}

// zsys_handler_reset
// file src/zsys.c line 457
void zsys_handler_reset(void)
{
  if(s_first_time == (_Bool)0 && !(handle_signals == (_Bool)0))
  {
    sigaction(2, &sigint_default, (struct sigaction *)(void *)0);
    sigaction(15, &sigterm_default, (struct sigaction *)(void *)0);
    sigint_default.__sigaction_handler.sa_handler = (void (*)(signed int))(void *)0;
    sigterm_default.__sigaction_handler.sa_handler = (void (*)(signed int))(void *)0;
    s_first_time = (_Bool)1;
  }

}

// zsys_handler_set
// file src/zsys.c line 416
void zsys_handler_set(void (*handler_fn)(signed int))
{
  if(handler_fn == ((void (*)(signed int))NULL))
  {
    zsys_handler_reset();
    handle_signals = (_Bool)0;
  }

  else
  {
    handle_signals = (_Bool)1;
    if(!(s_first_time == (_Bool)0))
    {
      sigaction(2, (struct sigaction *)(void *)0, &sigint_default);
      sigaction(15, (struct sigaction *)(void *)0, &sigterm_default);
      s_first_time = (_Bool)0;
    }

    struct sigaction action;
    action.__sigaction_handler.sa_handler = handler_fn;
    action.sa_flags = 0;
    sigemptyset(&action.sa_mask);
    sigaction(2, &action, (struct sigaction *)(void *)0);
    sigaction(15, &action, (struct sigaction *)(void *)0);
  }
}

// zsys_has_curve
// file src/../include/zsys.h line 205
_Bool zsys_has_curve(void)
{
  signed int return_value_zmq_has_1;
  return_value_zmq_has_1=zmq_has("curve");
  return return_value_zmq_has_1 != 0;
}

// zsys_hostname
// file src/zsys.c line 972
char * zsys_hostname(void)
{
  char hostname[1025l];
  gethostname(hostname, (unsigned long int)1025);
  hostname[(signed long int)(1025 - 1)] = (char)0;
  struct hostent *host;
  host=gethostbyname(hostname);
  _Bool tmp_if_expr_2;
  if(!(host == ((struct hostent *)NULL)))
    tmp_if_expr_2 = host->h_name != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  char *return_value_strdup_1;
  if(tmp_if_expr_2)
  {
    return_value_strdup_1=strdup(host->h_name);
    return return_value_strdup_1;
  }

  else
    return (char *)(void *)0;
}

// zsys_info
// file src/../include/zsys.h line 325
void zsys_info(const char *format, ...)
{
  void **argptr = (void **)&format;
  char *string;
  string=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  s_log((char)73, string);
  free((void *)string);
}

// zsys_init
// file src/zsys.c line 121
void * zsys_init(void)
{
  char *return_value_getenv_1;
  signed int return_value_atoi_2;
  char *return_value_getenv_4;
  signed int return_value_atoi_5;
  char *return_value_getenv_7;
  signed int return_value_atoi_8;
  char *return_value_getenv_10;
  signed int return_value_atoi_11;
  char *return_value_getenv_13;
  signed int return_value_atoi_14;
  char *return_value_getenv_16;
  signed int return_value_atoi_17;
  char *return_value_getenv_19;
  char *return_value_getenv_21;
  signed int return_value_strcmp_22;
  char *return_value_getenv_26;
  signed int return_value_strcmp_27;
  char *return_value_getenv_32;
  char *return_value_getenv_34;
  char *return_value_getenv_36;
  if(!(s_initialized == (_Bool)0))
  {
    /* assertion s_process_ctx */
    assert(s_process_ctx != NULL);
    return s_process_ctx;
  }

  else
  {
    char *return_value_getenv_3;
    return_value_getenv_3=getenv("ZSYS_IO_THREADS");
    if(!(return_value_getenv_3 == ((char *)NULL)))
    {
      return_value_getenv_1=getenv("ZSYS_IO_THREADS");
      return_value_atoi_2=atoi(return_value_getenv_1);
      s_io_threads = (unsigned long int)return_value_atoi_2;
    }

    char *return_value_getenv_6;
    return_value_getenv_6=getenv("ZSYS_MAX_SOCKETS");
    if(!(return_value_getenv_6 == ((char *)NULL)))
    {
      return_value_getenv_4=getenv("ZSYS_MAX_SOCKETS");
      return_value_atoi_5=atoi(return_value_getenv_4);
      s_max_sockets = (unsigned long int)return_value_atoi_5;
    }

    char *return_value_getenv_9;
    return_value_getenv_9=getenv("ZSYS_LINGER");
    if(!(return_value_getenv_9 == ((char *)NULL)))
    {
      return_value_getenv_7=getenv("ZSYS_LINGER");
      return_value_atoi_8=atoi(return_value_getenv_7);
      s_linger = (unsigned long int)return_value_atoi_8;
    }

    char *return_value_getenv_12;
    return_value_getenv_12=getenv("ZSYS_SNDHWM");
    if(!(return_value_getenv_12 == ((char *)NULL)))
    {
      return_value_getenv_10=getenv("ZSYS_SNDHWM");
      return_value_atoi_11=atoi(return_value_getenv_10);
      s_sndhwm = (unsigned long int)return_value_atoi_11;
    }

    char *return_value_getenv_15;
    return_value_getenv_15=getenv("ZSYS_RCVHWM");
    if(!(return_value_getenv_15 == ((char *)NULL)))
    {
      return_value_getenv_13=getenv("ZSYS_RCVHWM");
      return_value_atoi_14=atoi(return_value_getenv_13);
      s_rcvhwm = (unsigned long int)return_value_atoi_14;
    }

    char *return_value_getenv_18;
    return_value_getenv_18=getenv("ZSYS_PIPEHWM");
    if(!(return_value_getenv_18 == ((char *)NULL)))
    {
      return_value_getenv_16=getenv("ZSYS_PIPEHWM");
      return_value_atoi_17=atoi(return_value_getenv_16);
      s_pipehwm = (unsigned long int)return_value_atoi_17;
    }

    char *return_value_getenv_20;
    return_value_getenv_20=getenv("ZSYS_IPV6");
    if(!(return_value_getenv_20 == ((char *)NULL)))
    {
      return_value_getenv_19=getenv("ZSYS_IPV6");
      s_ipv6=atoi(return_value_getenv_19);
    }

    char *return_value_getenv_25;
    return_value_getenv_25=getenv("ZSYS_LOGSTREAM");
    if(!(return_value_getenv_25 == ((char *)NULL)))
    {
      char *return_value_getenv_23;
      return_value_getenv_23=getenv("ZSYS_LOGSTREAM");
      signed int return_value_strcmp_24;
      return_value_strcmp_24=strcmp(return_value_getenv_23, "stdout");
      if(return_value_strcmp_24 == 0)
        s_logstream = stdout;

      else
      {
        return_value_getenv_21=getenv("ZSYS_LOGSTREAM");
        return_value_strcmp_22=strcmp(return_value_getenv_21, "stderr");
        if(return_value_strcmp_22 == 0)
          s_logstream = stderr;

      }
    }

    else
      s_logstream = stdout;
    char *return_value_getenv_30;
    return_value_getenv_30=getenv("ZSYS_LOGSYSTEM");
    if(!(return_value_getenv_30 == ((char *)NULL)))
    {
      char *return_value_getenv_28;
      return_value_getenv_28=getenv("ZSYS_LOGSYSTEM");
      signed int return_value_strcmp_29;
      return_value_strcmp_29=strcmp(return_value_getenv_28, "true");
      if(return_value_strcmp_29 == 0)
        s_logsystem = (_Bool)1;

      else
      {
        return_value_getenv_26=getenv("ZSYS_LOGSYSTEM");
        return_value_strcmp_27=strcmp(return_value_getenv_26, "false");
        if(return_value_strcmp_27 == 0)
          s_logsystem = (_Bool)0;

      }
    }

    zsys_catch_interrupts();
    pthread_mutex_init(&s_mutex, (const union anonymous_4 *)(void *)0);
    s_sockref_list=zlist_new();
    if(s_sockref_list == ((struct _zlist_t *)NULL))
    {
      zsys_shutdown();
      return (void *)0;
    }

    else
    {
      signed long int return_value_time_31;
      return_value_time_31=time((signed long int *)(void *)0);
      srandom((unsigned int)return_value_time_31);
      atexit(zsys_shutdown);
      /* assertion !s_process_ctx */
      assert(!(s_process_ctx != NULL));
      s_process_ctx=zmq_init((signed int)s_io_threads);
      zmq_ctx_set(s_process_ctx, 2, (signed int)s_max_sockets);
      s_initialized = (_Bool)1;
      char *return_value_getenv_33;
      return_value_getenv_33=getenv("ZSYS_INTERFACE");
      if(!(return_value_getenv_33 == ((char *)NULL)))
      {
        return_value_getenv_32=getenv("ZSYS_INTERFACE");
        zsys_set_interface(return_value_getenv_32);
      }

      char *return_value_getenv_35;
      return_value_getenv_35=getenv("ZSYS_LOGIDENT");
      if(!(return_value_getenv_35 == ((char *)NULL)))
      {
        return_value_getenv_34=getenv("ZSYS_LOGIDENT");
        zsys_set_logident(return_value_getenv_34);
      }

      char *return_value_getenv_37;
      return_value_getenv_37=getenv("ZSYS_LOGSENDER");
      if(!(return_value_getenv_37 == ((char *)NULL)))
      {
        return_value_getenv_36=getenv("ZSYS_LOGSENDER");
        zsys_set_logsender(return_value_getenv_36);
      }

      return s_process_ctx;
    }
  }
}

// zsys_interface
// file src/../include/zsys.h line 282
const char * zsys_interface(void)
{
  return s_interface != ((char *)NULL) ? s_interface : "";
}

// zsys_notice
// file src/../include/zsys.h line 321
void zsys_notice(const char *format, ...)
{
  void **argptr = (void **)&format;
  char *string;
  string=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  s_log((char)78, string);
  free((void *)string);
}

// zsys_pipehwm
// file src/zsys.c line 1296
unsigned long int zsys_pipehwm(void)
{
  return s_pipehwm;
}

// zsys_run_as
// file src/zsys.c line 1046
signed int zsys_run_as(const char *lockfile, const char *group, const char *user)
{
  unsigned int return_value_geteuid_3;
  return_value_geteuid_3=geteuid();
  signed int return_value_seteuid_4;
  return_value_seteuid_4=seteuid(return_value_geteuid_3);
  if(!(return_value_seteuid_4 == 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    zsys_error("cannot set effective user id: %s", return_value_strerror_2);
    return -1;
  }

  if(!(lockfile == ((const char *)NULL)))
  {
    signed int handle;
    handle=open(lockfile, 02 | 0100, 0640);
    if(!(handle >= 0))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      char *return_value_strerror_6;
      return_value_strerror_6=strerror(*return_value___errno_location_5);
      zsys_error("cannot open lockfile '%s': %s", lockfile, return_value_strerror_6);
      return -1;
    }

    else
    {
      struct flock filelock;
      filelock.l_type = (signed short int)1;
      filelock.l_whence = (signed short int)0;
      filelock.l_start = (signed long int)0;
      filelock.l_len = (signed long int)0;
      filelock.l_pid=getpid();
      signed int return_value_fcntl_9;
      return_value_fcntl_9=fcntl(handle, 6, &filelock);
      if(!(return_value_fcntl_9 == 0))
      {
        signed int *return_value___errno_location_7;
        return_value___errno_location_7=__errno_location();
        char *return_value_strerror_8;
        return_value_strerror_8=strerror(*return_value___errno_location_7);
        zsys_error("cannot get lock: %s", return_value_strerror_8);
        return -1;
      }

    }
    char pid_buffer[10l];
    signed int return_value_getpid_10;
    return_value_getpid_10=getpid();
    snprintf(pid_buffer, sizeof(char [10l]) /*10ul*/ , "%6d\n", return_value_getpid_10);
    unsigned long int return_value_strlen_13;
    return_value_strlen_13=strlen(pid_buffer);
    signed long int return_value_write_14;
    return_value_write_14=write(handle, (const void *)pid_buffer, return_value_strlen_13);
    unsigned long int return_value_strlen_15;
    return_value_strlen_15=strlen(pid_buffer);
    if(!((unsigned long int)return_value_write_14 == return_value_strlen_15))
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      char *return_value_strerror_12;
      return_value_strerror_12=strerror(*return_value___errno_location_11);
      zsys_error("cannot write to lockfile: %s", return_value_strerror_12);
      close(handle);
      return -1;
    }

  }

  signed int return_value_setgid_18;
  if(!(group == ((const char *)NULL)))
  {
    zsys_info("running under group '%s'", group);
    struct group *grpbuf = (struct group *)(void *)0;
    grpbuf=getgrnam(group);
    _Bool tmp_if_expr_19;
    if(grpbuf == ((struct group *)NULL))
      tmp_if_expr_19 = (_Bool)1;

    else
    {
      return_value_setgid_18=setgid(grpbuf->gr_gid);
      tmp_if_expr_19 = return_value_setgid_18 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_19)
    {
      signed int *return_value___errno_location_16;
      return_value___errno_location_16=__errno_location();
      char *return_value_strerror_17;
      return_value_strerror_17=strerror(*return_value___errno_location_16);
      zsys_error("could not switch group: %s", return_value_strerror_17);
      return -1;
    }

  }

  signed int return_value_setuid_22;
  if(!(user == ((const char *)NULL)))
  {
    zsys_info("running under user '%s'", user);
    struct passwd *pwdbuf = (struct passwd *)(void *)0;
    pwdbuf=getpwnam(user);
    _Bool tmp_if_expr_23;
    if(pwdbuf == ((struct passwd *)NULL))
      tmp_if_expr_23 = (_Bool)1;

    else
    {
      return_value_setuid_22=setuid(pwdbuf->pw_uid);
      tmp_if_expr_23 = return_value_setuid_22 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_23)
    {
      signed int *return_value___errno_location_20;
      return_value___errno_location_20=__errno_location();
      char *return_value_strerror_21;
      return_value_strerror_21=strerror(*return_value___errno_location_20);
      zsys_error("could not switch user: %s", return_value_strerror_21);
      return -1;
    }

  }

  else
  {
    unsigned int return_value_getuid_26;
    return_value_getuid_26=getuid();
    signed int return_value_setuid_27;
    return_value_setuid_27=setuid(return_value_getuid_26);
    if(!(return_value_setuid_27 == 0))
    {
      signed int *return_value___errno_location_24;
      return_value___errno_location_24=__errno_location();
      char *return_value_strerror_25;
      return_value_strerror_25=strerror(*return_value___errno_location_24);
      zsys_error("cannot set real user id: %s", return_value_strerror_25);
      return -1;
    }

  }
  return 0;
}

// zsys_set_interface
// file src/zsys.c line 1329
void zsys_set_interface(const char *value)
{
  zsys_init();
  free((void *)s_interface);
  s_interface=strdup(value);
  /* assertion s_interface */
  assert(s_interface != ((char *)NULL));
}

// zsys_set_io_threads
// file src/zsys.c line 1158
void zsys_set_io_threads(unsigned long int io_threads)
{
  zsys_init();
  pthread_mutex_lock(&s_mutex);
  if(!(s_open_sockets == 0ul))
    zsys_error("zsys_io_threads() is not valid after creating sockets");

  /* assertion s_open_sockets == 0 */
  assert(s_open_sockets == (unsigned long int)0);
  zmq_term(s_process_ctx);
  s_io_threads = io_threads;
  s_process_ctx=zmq_init((signed int)s_io_threads);
  zmq_ctx_set(s_process_ctx, 2, (signed int)s_max_sockets);
  pthread_mutex_unlock(&s_mutex);
}

// zsys_set_ipv6
// file src/zsys.c line 1311
void zsys_set_ipv6(signed int ipv6)
{
  zsys_init();
  pthread_mutex_lock(&s_mutex);
  s_ipv6 = ipv6;
  pthread_mutex_unlock(&s_mutex);
}

// zsys_set_linger
// file src/zsys.c line 1232
void zsys_set_linger(unsigned long int linger)
{
  zsys_init();
  pthread_mutex_lock(&s_mutex);
  s_linger = linger;
  pthread_mutex_unlock(&s_mutex);
}

// zsys_set_logident
// file src/zsys.c line 1354
void zsys_set_logident(const char *value)
{
  zsys_init();
  free((void *)s_logident);
  s_logident=strdup(value);
  if(!(s_logsystem == (_Bool)0))
    openlog(s_logident, 0x01, 1 << 3);

  /* assertion s_logident */
  assert(s_logident != ((char *)NULL));
}

// zsys_set_logsender
// file src/zsys.c line 1392
void zsys_set_logsender(const char *endpoint)
{
  zsys_init();
  if(!(endpoint == ((const char *)NULL)))
  {
    if(s_logsender == ((struct _zsock_t *)NULL))
    {
      s_logsender=zsock_new_pub_checked((const char *)(void *)0, "src/zsys.c", (unsigned long int)1398);
      /* assertion s_logsender */
      assert(s_logsender != ((struct _zsock_t *)NULL));
    }

    signed int rc;
    rc=zsock_attach(s_logsender, endpoint, (_Bool)1);
    /* assertion rc == 0 */
    assert(rc == 0);
  }

  else
    if(!(s_logsender == ((struct _zsock_t *)NULL)))
      zsock_destroy_checked(&s_logsender, "src/zsys.c", (unsigned long int)1407);

}

// zsys_set_logstream
// file src/../include/zsys.h line 294
void zsys_set_logstream(struct _IO_FILE *stream)
{
  zsys_init();
  s_logstream = stream;
}

// zsys_set_logsystem
// file src/zsys.c line 1417
void zsys_set_logsystem(_Bool logsystem)
{
  zsys_init();
  s_logsystem = logsystem;
  if(!(s_logsystem == (_Bool)0))
    openlog(s_logident, 0x01, 1 << 3);

}

// zsys_set_max_sockets
// file src/../include/zsys.h line 220
void zsys_set_max_sockets(unsigned long int max_sockets)
{
  zsys_init();
  pthread_mutex_lock(&s_mutex);
  if(!(s_open_sockets == 0ul))
    zsys_error("zsys_max_sockets() is not valid after creating sockets");

  /* assertion s_open_sockets == 0 */
  assert(s_open_sockets == (unsigned long int)0);
  unsigned long int tmp_if_expr_2;
  unsigned long int return_value_zsys_socket_limit_1;
  if(!(max_sockets == 0ul))
    tmp_if_expr_2 = max_sockets;

  else
  {
    return_value_zsys_socket_limit_1=zsys_socket_limit();
    tmp_if_expr_2 = return_value_zsys_socket_limit_1;
  }
  s_max_sockets = tmp_if_expr_2;
  pthread_mutex_unlock(&s_mutex);
}

// zsys_set_pipehwm
// file src/zsys.c line 1283
void zsys_set_pipehwm(unsigned long int pipehwm)
{
  zsys_init();
  pthread_mutex_lock(&s_mutex);
  s_pipehwm = pipehwm;
  pthread_mutex_unlock(&s_mutex);
}

// zsys_set_rcvhwm
// file src/zsys.c line 1266
void zsys_set_rcvhwm(unsigned long int rcvhwm)
{
  zsys_init();
  pthread_mutex_lock(&s_mutex);
  s_rcvhwm = rcvhwm;
  pthread_mutex_unlock(&s_mutex);
}

// zsys_set_sndhwm
// file src/zsys.c line 1249
void zsys_set_sndhwm(unsigned long int sndhwm)
{
  zsys_init();
  pthread_mutex_lock(&s_mutex);
  s_sndhwm = sndhwm;
  pthread_mutex_unlock(&s_mutex);
}

// zsys_shutdown
// file src/zsys.c line 204
void zsys_shutdown(void)
{
  if(!(s_initialized == (_Bool)0))
  {
    s_initialized = (_Bool)0;
    pthread_mutex_lock(&s_mutex);
    unsigned long int busy = s_open_sockets;
    pthread_mutex_unlock(&s_mutex);
    if(!(busy == 0ul))
      zclock_sleep(200);

    if(!(s_logsender == ((struct _zsock_t *)NULL)))
      zsock_destroy_checked(&s_logsender, "src/zsys.c", (unsigned long int)225);

    pthread_mutex_lock(&s_mutex);
    struct anonymous_18 *sockref;
    void *return_value_zlist_pop_1;
    return_value_zlist_pop_1=zlist_pop(s_sockref_list);
    sockref = (struct anonymous_18 *)return_value_zlist_pop_1;
    while(!(sockref == ((struct anonymous_18 *)NULL)))
    {
      /* assertion sockref->filename */
      assert(sockref->filename != ((const char *)NULL));
      char *return_value_zsys_sockname_2;
      return_value_zsys_sockname_2=zsys_sockname(sockref->type);
      zsys_error("dangling '%s' socket created at %s:%d", return_value_zsys_sockname_2, sockref->filename, (signed int)sockref->line_nbr);
      zmq_close(sockref->handle);
      free((void *)sockref);
      void *return_value_zlist_pop_3;
      return_value_zlist_pop_3=zlist_pop(s_sockref_list);
      sockref = (struct anonymous_18 *)return_value_zlist_pop_3;
    }
    zlist_destroy(&s_sockref_list);
    pthread_mutex_unlock(&s_mutex);
    if(s_open_sockets == 0ul)
      zmq_term(s_process_ctx);

    else
      zsys_error("dangling sockets: cannot terminate ZMQ safely");
    pthread_mutex_destroy(&s_mutex);
    free((void *)s_interface);
    free((void *)s_logident);
    closelog();
  }

}

// zsys_socket
// file src/../include/zsys.h line 48
void * zsys_socket(signed int type, const char *filename, unsigned long int line_nbr)
{
  zsys_init();
  pthread_mutex_lock(&s_mutex);
  void *handle;
  handle=zmq_socket(s_process_ctx, type);
  if(!(handle == NULL))
  {
    zsock_set_linger(handle, (signed int)s_linger);
    zsock_set_sndhwm(handle, (signed int)s_sndhwm);
    zsock_set_rcvhwm(handle, (signed int)s_rcvhwm);
    zsock_set_ipv6(handle, s_ipv6);
    if(!(filename == ((const char *)NULL)))
    {
      struct anonymous_18 *sockref;
      void *return_value_safe_malloc_1;
      return_value_safe_malloc_1=safe_malloc_link25(sizeof(struct anonymous_18) /*32ul*/ , "src/zsys.c", (unsigned int)300);
      sockref = (struct anonymous_18 *)return_value_safe_malloc_1;
      if(!(sockref == ((struct anonymous_18 *)NULL)))
      {
        sockref->handle = handle;
        sockref->type = type;
        sockref->filename = filename;
        sockref->line_nbr = line_nbr;
        zlist_append(s_sockref_list, (void *)sockref);
      }

      else
      {
        zmq_close(handle);
        pthread_mutex_unlock(&s_mutex);
        return (void *)0;
      }
    }

    s_open_sockets = s_open_sockets + 1ul;
  }

  pthread_mutex_unlock(&s_mutex);
  return handle;
}

// zsys_socket_error
// file src/../include/zsys.h line 178
void zsys_socket_error(const char *reason)
{
  signed int *return_value___errno_location_3;
  return_value___errno_location_3=__errno_location();
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  if(*return_value___errno_location_3 == 11)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value___errno_location_4=__errno_location();
    tmp_if_expr_5 = *return_value___errno_location_4 == 100 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int *return_value___errno_location_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value___errno_location_6=__errno_location();
    tmp_if_expr_7 = *return_value___errno_location_6 == 113 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_9;
  signed int *return_value___errno_location_8;
  if(tmp_if_expr_7)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value___errno_location_8=__errno_location();
    tmp_if_expr_9 = *return_value___errno_location_8 == 101 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_11;
  signed int *return_value___errno_location_10;
  if(tmp_if_expr_9)
    tmp_if_expr_11 = (_Bool)1;

  else
  {
    return_value___errno_location_10=__errno_location();
    tmp_if_expr_11 = *return_value___errno_location_10 == 4 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_13;
  signed int *return_value___errno_location_12;
  if(tmp_if_expr_11)
    tmp_if_expr_13 = (_Bool)1;

  else
  {
    return_value___errno_location_12=__errno_location();
    tmp_if_expr_13 = *return_value___errno_location_12 == 32 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_15;
  signed int *return_value___errno_location_14;
  if(tmp_if_expr_13)
    tmp_if_expr_15 = (_Bool)1;

  else
  {
    return_value___errno_location_14=__errno_location();
    tmp_if_expr_15 = *return_value___errno_location_14 == 104 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_17;
  signed int *return_value___errno_location_16;
  if(tmp_if_expr_15)
    tmp_if_expr_17 = (_Bool)1;

  else
  {
    return_value___errno_location_16=__errno_location();
    tmp_if_expr_17 = *return_value___errno_location_16 == 92 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_19;
  signed int *return_value___errno_location_18;
  if(tmp_if_expr_17)
    tmp_if_expr_19 = (_Bool)1;

  else
  {
    return_value___errno_location_18=__errno_location();
    tmp_if_expr_19 = *return_value___errno_location_18 == 112 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_21;
  signed int *return_value___errno_location_20;
  if(tmp_if_expr_19)
    tmp_if_expr_21 = (_Bool)1;

  else
  {
    return_value___errno_location_20=__errno_location();
    tmp_if_expr_21 = *return_value___errno_location_20 == 95 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_23;
  signed int *return_value___errno_location_22;
  if(tmp_if_expr_21)
    tmp_if_expr_23 = (_Bool)1;

  else
  {
    return_value___errno_location_22=__errno_location();
    tmp_if_expr_23 = *return_value___errno_location_22 == 11 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_25;
  signed int *return_value___errno_location_24;
  if(tmp_if_expr_23)
    tmp_if_expr_25 = (_Bool)1;

  else
  {
    return_value___errno_location_24=__errno_location();
    tmp_if_expr_25 = *return_value___errno_location_24 == 71 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_27;
  signed int *return_value___errno_location_26;
  if(tmp_if_expr_25)
    tmp_if_expr_27 = (_Bool)1;

  else
  {
    return_value___errno_location_26=__errno_location();
    tmp_if_expr_27 = *return_value___errno_location_26 == 64 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_27)
    goto __CPROVER_DUMP_L27;

  else
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    zsys_error("(UDP) error '%s' on %s", return_value_strerror_2, reason);
    /* assertion 0 */
    assert(0 != 0);
  }

__CPROVER_DUMP_L27:
  ;
}

// zsys_socket_limit
// file src/zsys.c line 1201
unsigned long int zsys_socket_limit(void)
{
  unsigned long int socket_limit;
  signed int return_value_zmq_ctx_get_1;
  if(!(s_process_ctx == NULL))
  {
    return_value_zmq_ctx_get_1=zmq_ctx_get(s_process_ctx, 3);
    socket_limit = (unsigned long int)return_value_zmq_ctx_get_1;
  }

  else
  {
    void *ctx;
    ctx=zmq_init(1);
    signed int return_value_zmq_ctx_get_2;
    return_value_zmq_ctx_get_2=zmq_ctx_get(ctx, 3);
    socket_limit = (unsigned long int)return_value_zmq_ctx_get_2;
    zmq_term(ctx);
  }
  if(socket_limit >= 65536ul)
    socket_limit = (unsigned long int)65535;

  return socket_limit;
}

// zsys_sockname
// file src/../include/zsys.h line 59
char * zsys_sockname(signed int socktype)
{
  char *type_names[12l] = { "PAIR", "PUB", "SUB", "REQ", "REP", "DEALER", "ROUTER", "PULL", "PUSH", "XPUB", "XSUB", "STREAM" };
  /* assertion 0 == 0 */
  assert(0 == 0);
  /* assertion socktype >= 0 && socktype <= 11 */
  assert(socktype >= 0 && socktype <= 11);
  return type_names[(signed long int)socktype];
}

// zsys_sprintf
// file src/../include/zsys.h line 142
char * zsys_sprintf(const char *format, ...)
{
  void **argptr = (void **)&format;
  char *string;
  string=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  return string;
}

// zsys_test
// file src/zsys.c line 1579
void zsys_test(_Bool verbose)
{
  printf(" * zsys: ");
  if(!(verbose == (_Bool)0))
    printf("\n");

  zsys_catch_interrupts();
  signed int rc;
  _Bool return_value_zsys_has_curve_1;
  return_value_zsys_has_curve_1=zsys_has_curve();
  rc = (signed int)return_value_zsys_has_curve_1;
  if(!(verbose == (_Bool)0))
  {
    char *hostname;
    hostname=zsys_hostname();
    zsys_info("host name is %s", hostname);
    free((void *)hostname);
    unsigned long int return_value_zsys_socket_limit_2;
    return_value_zsys_socket_limit_2=zsys_socket_limit();
    zsys_info("system limit is %zu ZeroMQ sockets", return_value_zsys_socket_limit_2);
  }

  zsys_set_io_threads((unsigned long int)1);
  zsys_set_max_sockets((unsigned long int)0);
  zsys_set_linger((unsigned long int)0);
  zsys_set_sndhwm((unsigned long int)1000);
  zsys_set_rcvhwm((unsigned long int)1000);
  zsys_set_pipehwm((unsigned long int)2500);
  unsigned long int return_value_zsys_pipehwm_3;
  return_value_zsys_pipehwm_3=zsys_pipehwm();
  /* assertion zsys_pipehwm () == 2500 */
  assert(return_value_zsys_pipehwm_3 == (unsigned long int)2500);
  zsys_set_ipv6(0);
  struct _zsock_t *pipe_back;
  struct _zsock_t *pipe_front;
  pipe_front=zsys_create_pipe(&pipe_back);
  zstr_send((void *)pipe_front, "Hello");
  char *string;
  string=zstr_recv((void *)pipe_back);
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(string, "Hello");
  /* assertion (!strcmp ((string), ("Hello"))) */
  assert(!(return_value_strcmp_4 != 0));
  free((void *)string);
  zsock_destroy_checked(&pipe_back, "src/zsys.c", (unsigned long int)1613);
  zsock_destroy_checked(&pipe_front, "src/zsys.c", (unsigned long int)1614);
  rc=zsys_file_delete("nosuchfile");
  /* assertion rc == -1 */
  assert(rc == -1);
  _Bool rc_bool;
  rc_bool=zsys_file_exists("nosuchfile");
  /* assertion rc_bool != 1 */
  assert((signed int)rc_bool != 1);
  signed long int return_value_zsys_file_size_5;
  return_value_zsys_file_size_5=zsys_file_size("nosuchfile");
  rc = (signed int)return_value_zsys_file_size_5;
  /* assertion rc == -1 */
  assert(rc == -1);
  signed long int when;
  when=zsys_file_modified(".");
  /* assertion when > 0 */
  assert(when > (signed long int)0);
  signed int mode;
  mode=zsys_file_mode(".");
  /* assertion ((((mode)) & 0170000) == (0040000)) */
  assert((mode & 0170000) == 0040000);
  /* assertion mode & 0400 */
  assert((mode & 0400) != 0);
  /* assertion mode & 0200 */
  assert((mode & 0200) != 0);
  zsys_file_mode_private();
  rc=zsys_dir_create("%s/%s", (const void *)".", (const void *)".testsys/subdir");
  /* assertion rc == 0 */
  assert(rc == 0);
  when=zsys_file_modified("./.testsys/subdir");
  /* assertion when > 0 */
  assert(when > (signed long int)0);
  _Bool return_value_zsys_file_stable_6;
  return_value_zsys_file_stable_6=zsys_file_stable("./.testsys/subdir");
  /* assertion !zsys_file_stable ("./.testsys/subdir") */
  assert(!(return_value_zsys_file_stable_6 != (_Bool)0));
  rc=zsys_dir_delete("%s/%s", (const void *)".", (const void *)".testsys/subdir");
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zsys_dir_delete("%s/%s", (const void *)".", (const void *)".testsys");
  /* assertion rc == 0 */
  assert(rc == 0);
  zsys_file_mode_default();
  signed int return_value_zsys_dir_change_7;
  return_value_zsys_dir_change_7=zsys_dir_change(".");
  /* assertion zsys_dir_change (".") == 0 */
  assert(return_value_zsys_dir_change_7 == 0);
  signed int major;
  signed int minor;
  signed int patch;
  zsys_version(&major, &minor, &patch);
  /* assertion major == 3 */
  assert(major == 3);
  /* assertion minor == 0 */
  assert(minor == 0);
  /* assertion patch == 2 */
  assert(patch == 2);
  string=zsys_sprintf("%s %02x", (const void *)"Hello", 16);
  signed int return_value_strcmp_8;
  return_value_strcmp_8=strcmp(string, "Hello 10");
  /* assertion (!strcmp ((string), ("Hello 10"))) */
  assert(!(return_value_strcmp_8 != 0));
  free((void *)string);
  char *str64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890,.";
  signed int num10 = 1234567890;
  string=zsys_sprintf("%s%s%s%s%d", str64, str64, str64, str64, num10);
  unsigned long int return_value_strlen_9;
  return_value_strlen_9=strlen(string);
  /* assertion strlen (string) == (4 * 64 + 10) */
  assert(return_value_strlen_9 == (unsigned long int)(4 * 64 + 10));
  free((void *)string);
  zsys_set_logident("czmq_selftest");
  zsys_set_logsender("inproc://logging");
  void *logger;
  logger=zsys_socket(2, (const char *)(void *)0, (unsigned long int)0);
  /* assertion logger */
  assert(logger != NULL);
  rc=zmq_connect(logger, "inproc://logging");
  /* assertion rc == 0 */
  assert(rc == 0);
  rc=zmq_setsockopt(logger, 6, (const void *)"", (unsigned long int)0);
  /* assertion rc == 0 */
  assert(rc == 0);
  if(!(verbose == (_Bool)0))
  {
    zsys_error("This is an %s message", (const void *)"error");
    zsys_warning("This is a %s message", (const void *)"warning");
    zsys_notice("This is a %s message", (const void *)"notice");
    zsys_info("This is a %s message", (const void *)"info");
    zsys_debug("This is a %s message", (const void *)"debug");
    zsys_set_logident("hello, world");
    zsys_info("This is a %s message", (const void *)"info");
    zsys_debug("This is a %s message", (const void *)"debug");
    char *received;
    received=zstr_recv(logger);
    /* assertion received */
    assert(received != ((char *)NULL));
    zstr_free(&received);
  }

  zsys_close(logger, (const char *)(void *)0, (unsigned long int)0);
  printf("OK\n");
}

// zsys_udp_close
// file src/../include/zsys.h line 160
signed int zsys_udp_close(signed int handle)
{
  signed int return_value_close_1;
  return_value_close_1=close(handle);
  return return_value_close_1;
}

// zsys_udp_new
// file src/../include/zsys.h line 155
signed int zsys_udp_new(_Bool routable)
{
  /* assertion !routable */
  assert(!(routable != (_Bool)0));
  signed int udpsock;
  udpsock=socket(2, 2, 17);
  if(udpsock == -1)
  {
    zsys_socket_error("socket");
    return -1;
  }

  else
  {
    signed int on = 1;
    signed int return_value_setsockopt_1;
    return_value_setsockopt_1=setsockopt(udpsock, 1, 6, (const void *)(char *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(return_value_setsockopt_1 == -1)
      zsys_socket_error("setsockopt (SO_BROADCAST)");

    signed int return_value_setsockopt_2;
    return_value_setsockopt_2=setsockopt(udpsock, 1, 2, (const void *)(char *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(return_value_setsockopt_2 == -1)
      zsys_socket_error("setsockopt (SO_REUSEADDR)");

    signed int return_value_setsockopt_3;
    return_value_setsockopt_3=setsockopt(udpsock, 1, 15, (const void *)(char *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(return_value_setsockopt_3 == -1)
      zsys_socket_error("setsockopt (SO_REUSEPORT)");

    return udpsock;
  }
}

// zsys_udp_recv
// file src/../include/zsys.h line 172
struct _zframe_t * zsys_udp_recv(signed int udpsock, char *peername)
{
  char buffer[255l];
  struct sockaddr_in address;
  unsigned int address_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed long int size;
  size=recvfrom(udpsock, (void *)buffer, (unsigned long int)255, 0, (struct sockaddr *)&address, &address_len);
  if(size == -1l)
    zsys_socket_error("recvfrom");

  inet_ntop(2, (const void *)&address.sin_addr, peername, address_len);
  struct _zframe_t *return_value_zframe_new_1;
  return_value_zframe_new_1=zframe_new((const void *)buffer, (unsigned long int)size);
  return return_value_zframe_new_1;
}

// zsys_udp_send
// file src/../include/zsys.h line 166
signed int zsys_udp_send(signed int udpsock, struct _zframe_t *frame, struct sockaddr_in *address)
{
  /* assertion frame */
  assert(frame != ((struct _zframe_t *)NULL));
  /* assertion address */
  assert(address != ((struct sockaddr_in *)NULL));
  unsigned char *return_value_zframe_data_3;
  return_value_zframe_data_3=zframe_data(frame);
  unsigned long int return_value_zframe_size_4;
  return_value_zframe_size_4=zframe_size(frame);
  signed long int return_value_sendto_5;
  return_value_sendto_5=sendto(udpsock, (const void *)(char *)return_value_zframe_data_3, (unsigned long int)(signed int)return_value_zframe_size_4, 0, (struct sockaddr *)address, (unsigned int)(signed int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(return_value_sendto_5 == -1l)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    zsys_debug("zsys_udp_send: failed, reason=%s", return_value_strerror_2);
    return -1;
  }

  else
    return 0;
}

// zsys_version
// file src/zsys.c line 735
void zsys_version(signed int *major, signed int *minor, signed int *patch)
{
  if(!(major == ((signed int *)NULL)))
    *major = 3;

  if(!(minor == ((signed int *)NULL)))
    *minor = 0;

  if(!(patch == ((signed int *)NULL)))
    *patch = 2;

}

// zsys_vprintf
// file src/../include/zsys.h line 148
char * zsys_vprintf(const char *format, void **argptr)
{
  signed int size = 256;
  char *string;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)size);
  string = (char *)return_value_malloc_1;
  if(string == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    void **my_argptr = (void **)argptr;
    signed int required;
    required=vsnprintf(string, (unsigned long int)size, format, my_argptr);
    my_argptr = ((void **)NULL);
    if(required >= size)
    {
      size = required + 1;
      free((void *)string);
      void *return_value_malloc_2;
      return_value_malloc_2=malloc((unsigned long int)size);
      string = (char *)return_value_malloc_2;
      if(!(string == ((char *)NULL)))
      {
        my_argptr = (void **)argptr;
        vsnprintf(string, (unsigned long int)size, format, my_argptr);
        my_argptr = ((void **)NULL);
      }

    }

    return string;
  }
}

// zsys_warning
// file src/../include/zsys.h line 317
void zsys_warning(const char *format, ...)
{
  void **argptr = (void **)&format;
  char *string;
  string=zsys_vprintf(format, argptr);
  argptr = ((void **)NULL);
  s_log((char)87, string);
  free((void *)string);
}

// zthread_fork
// file src/../include/zthread.h line 39
void * zthread_fork(struct _zctx_t *ctx, void (*thread_fn)(void *, struct _zctx_t *, void *), void *args)
{
  struct anonymous_21 *shim = (struct anonymous_21 *)(void *)0;
  void *pipe;
  pipe=zctx__socket_pipe(ctx);
  if(!(pipe == NULL))
    zsocket_bind(pipe, "inproc://zctx-pipe-%p", pipe);

  else
    return (void *)0;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link37(sizeof(struct anonymous_21) /*40ul*/ , "src/zthread.c", (unsigned int)178);
  shim = (struct anonymous_21 *)return_value_safe_malloc_1;
  if(!(shim == ((struct anonymous_21 *)NULL)))
  {
    shim->attached = thread_fn;
    shim->args = args;
    shim->ctx=zctx_shadow(ctx);
    if(shim->ctx == ((struct _zctx_t *)NULL))
    {
      zctx__socket_destroy(ctx, pipe);
      return (void *)0;
    }

  }

  else
    return (void *)0;
  shim->pipe=zctx__socket_pipe(shim->ctx);
  if(shim->pipe == NULL)
  {
    zctx__socket_destroy(ctx, pipe);
    return (void *)0;
  }

  else
  {
    zsocket_connect(shim->pipe, "inproc://zctx-pipe-%p", pipe);
    s_thread_start(shim);
    return pipe;
  }
}

// zthread_new
// file src/zthread.c line 147
signed int zthread_new(void * (*thread_fn)(void *), void *args)
{
  struct anonymous_21 *shim;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link37(sizeof(struct anonymous_21) /*40ul*/ , "src/zthread.c", (unsigned int)150);
  shim = (struct anonymous_21 *)return_value_safe_malloc_1;
  if(!(shim == ((struct anonymous_21 *)NULL)))
  {
    shim->detached = thread_fn;
    shim->args = args;
    s_thread_start(shim);
    return 0;
  }

  else
    return -1;
}

// zthread_test
// file src/zthread.c line 237
void zthread_test(_Bool verbose)
{
  printf(" * zthread (deprecated): ");
  struct _zctx_t *ctx;
  ctx=zctx_new();
  /* assertion ctx */
  assert(ctx != ((struct _zctx_t *)NULL));
  signed int rc = 0;
  rc=zthread_new(s_test_detached, (void *)0);
  /* assertion rc == 0 */
  assert(rc == 0);
  zclock_sleep(100);
  void *pipe;
  pipe=zthread_fork(ctx, s_test_attached, (void *)0);
  /* assertion pipe */
  assert(pipe != NULL);
  zstr_send(pipe, "ping");
  char *pong;
  pong=zstr_recv(pipe);
  /* assertion pong */
  assert(pong != ((char *)NULL));
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(pong, "pong");
  /* assertion (!strcmp ((pong), ("pong"))) */
  assert(!(return_value_strcmp_1 != 0));
  zstr_free(&pong);
  zctx_destroy(&ctx);
  printf("OK\n");
}

// zuuid_data
// file src/../include/zuuid.h line 48
const unsigned char * zuuid_data(struct _zuuid_t *self)
{
  /* assertion self */
  assert(self != ((struct _zuuid_t *)NULL));
  return self->uuid;
}

// zuuid_destroy
// file src/../include/zuuid.h line 31
void zuuid_destroy(struct _zuuid_t **self_p)
{
  /* assertion self_p */
  assert(self_p != ((struct _zuuid_t **)NULL));
  if(!(*self_p == ((struct _zuuid_t *)NULL)))
  {
    struct _zuuid_t *self = *self_p;
    free((void *)self->str_canonical);
    free((void *)self);
    *self_p = (struct _zuuid_t *)(void *)0;
  }

}

// zuuid_dup
// file src/zuuid.c line 272
struct _zuuid_t * zuuid_dup(struct _zuuid_t *self)
{
  const unsigned char *return_value_zuuid_data_1;
  struct _zuuid_t *return_value_zuuid_new_from_2;
  if(!(self == ((struct _zuuid_t *)NULL)))
  {
    return_value_zuuid_data_1=zuuid_data(self);
    return_value_zuuid_new_from_2=zuuid_new_from(return_value_zuuid_data_1);
    return return_value_zuuid_new_from_2;
  }

  else
    return (struct _zuuid_t *)(void *)0;
}

// zuuid_eq
// file src/zuuid.c line 249
_Bool zuuid_eq(struct _zuuid_t *self, const unsigned char *compare)
{
  /* assertion self */
  assert(self != ((struct _zuuid_t *)NULL));
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)self->uuid, (const void *)compare, (unsigned long int)16);
  return return_value_memcmp_1 == 0;
}

// zuuid_export
// file src/zuuid.c line 238
void zuuid_export(struct _zuuid_t *self, unsigned char *target)
{
  /* assertion self */
  assert(self != ((struct _zuuid_t *)NULL));
  memcpy((void *)target, (const void *)self->uuid, (unsigned long int)16);
}

// zuuid_neq
// file src/zuuid.c line 260
_Bool zuuid_neq(struct _zuuid_t *self, const unsigned char *compare)
{
  /* assertion self */
  assert(self != ((struct _zuuid_t *)NULL));
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)self->uuid, (const void *)compare, (unsigned long int)16);
  return return_value_memcmp_1 != 0;
}

// zuuid_new
// file src/../include/zuuid.h line 27
struct _zuuid_t * zuuid_new(void)
{
  struct _zuuid_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link26(sizeof(struct _zuuid_t) /*64ul*/ , "src/zuuid.c", (unsigned int)42);
  self = (struct _zuuid_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _zuuid_t *)NULL)))
  {
    unsigned char uuid[16l];
    signed int fd;
    fd=open("/dev/urandom", 00);
    if(!(fd == -1))
    {
      signed long int bytes_read;
      bytes_read=read(fd, (void *)uuid, (unsigned long int)16);
      /* assertion bytes_read == 16 */
      assert(bytes_read == (signed long int)16);
      close(fd);
      zuuid_set(self, uuid);
    }

    else
      /* assertion 0 */
      assert(0 != 0);
  }

  return self;
}

// zuuid_new_from
// file src/zuuid.c line 109
struct _zuuid_t * zuuid_new_from(const unsigned char *source)
{
  struct _zuuid_t *self;
  void *return_value_safe_malloc_1;
  return_value_safe_malloc_1=safe_malloc_link26(sizeof(struct _zuuid_t) /*64ul*/ , "src/zuuid.c", (unsigned int)111);
  self = (struct _zuuid_t *)return_value_safe_malloc_1;
  if(!(self == ((struct _zuuid_t *)NULL)))
    zuuid_set(self, source);

  return self;
}

// zuuid_set
// file src/../include/zuuid.h line 39
void zuuid_set(struct _zuuid_t *self, const unsigned char *source)
{
  /* assertion self */
  assert(self != ((struct _zuuid_t *)NULL));
  memcpy((void *)self->uuid, (const void *)source, (unsigned long int)16);
  char hex_char[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 0 };
  signed int byte_nbr = 0;
  for( ; !(byte_nbr >= 16); byte_nbr = byte_nbr + 1)
  {
    unsigned int val = (unsigned int)self->uuid[(signed long int)byte_nbr];
    self->str[(signed long int)(byte_nbr * 2 + 0)] = hex_char[(signed long int)(val >> 4)];
    self->str[(signed long int)(byte_nbr * 2 + 1)] = hex_char[(signed long int)(val & (unsigned int)15)];
  }
  self->str[(signed long int)(16 * 2)] = (char)0;
  zstr_free(&self->str_canonical);
}

// zuuid_set_str
// file src/zuuid.c line 143
signed int zuuid_set_str(struct _zuuid_t *self, const char *source)
{
  /* assertion self */
  assert(self != ((struct _zuuid_t *)NULL));
  /* assertion source */
  assert(source != ((const char *)NULL));
  unsigned int byte_nbr = (unsigned int)0;
  while(!(*source == 0))
  {
    _Bool tmp_if_expr_4;
    if((signed int)*source == 45)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)*source == 123 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_5;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = (signed int)*source == 125 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      source = source + 1l;

    else
    {
      unsigned int value;
      signed int return_value_sscanf_1;
      return_value_sscanf_1=sscanf(source, "%02x", &value);
      if(!(return_value_sscanf_1 == 1))
        return -1;

      if(!(byte_nbr >= 16u))
      {
        self->uuid[(signed long int)byte_nbr] = (unsigned char)value;
        const char *tmp_post_2 = source;
        source = source + 1l;
        self->str[(signed long int)(byte_nbr * (unsigned int)2 + (unsigned int)0)] = *tmp_post_2;
        const char *tmp_post_3 = source;
        source = source + 1l;
        self->str[(signed long int)(byte_nbr * (unsigned int)2 + (unsigned int)1)] = *tmp_post_3;
        byte_nbr = byte_nbr + 1u;
      }

      else
        return -1;
    }
  }
  zstr_free(&self->str_canonical);
  return 0;
}

// zuuid_size
// file src/../include/zuuid.h line 52
unsigned long int zuuid_size(struct _zuuid_t *self)
{
  /* assertion self */
  assert(self != ((struct _zuuid_t *)NULL));
  return (unsigned long int)16;
}

// zuuid_str
// file src/../include/zuuid.h line 56
const char * zuuid_str(struct _zuuid_t *self)
{
  /* assertion self */
  assert(self != ((struct _zuuid_t *)NULL));
  return self->str;
}

// zuuid_str_canonical
// file src/zuuid.c line 211
const char * zuuid_str_canonical(struct _zuuid_t *self)
{
  /* assertion self */
  assert(self != ((struct _zuuid_t *)NULL));
  void *return_value_safe_malloc_1;
  if(self->str_canonical == ((char *)NULL))
  {
    return_value_safe_malloc_1=safe_malloc_link26((unsigned long int)(8 + 4 + 4 + 4 + 12 + 5), "src/zuuid.c", (unsigned int)215);
    self->str_canonical = (char *)return_value_safe_malloc_1;
  }

  *self->str_canonical = (char)0;
  strncat(self->str_canonical, self->str, (unsigned long int)8);
  strcat(self->str_canonical, "-");
  strncat(self->str_canonical, self->str + (signed long int)8, (unsigned long int)4);
  strcat(self->str_canonical, "-");
  strncat(self->str_canonical, self->str + (signed long int)12, (unsigned long int)4);
  strcat(self->str_canonical, "-");
  strncat(self->str_canonical, self->str + (signed long int)16, (unsigned long int)4);
  strcat(self->str_canonical, "-");
  strncat(self->str_canonical, self->str + (signed long int)20, (unsigned long int)12);
  signed int char_nbr = 0;
  signed int return_value_tolower_2;
  for( ; !(char_nbr >= 36); char_nbr = char_nbr + 1)
  {
    return_value_tolower_2=tolower((signed int)self->str_canonical[(signed long int)char_nbr]);
    self->str_canonical[(signed long int)char_nbr] = (char)return_value_tolower_2;
  }
  return self->str_canonical;
}

// zuuid_test
// file src/zuuid.c line 285
void zuuid_test(_Bool verbose)
{
  printf(" * zuuid: ");
  /* assertion 16 == 16 */
  assert(16 == 16);
  /* assertion (16 * 2) == 32 */
  assert(16 * 2 == 32);
  struct _zuuid_t *uuid;
  uuid=zuuid_new();
  /* assertion uuid */
  assert(uuid != ((struct _zuuid_t *)NULL));
  unsigned long int return_value_zuuid_size_1;
  return_value_zuuid_size_1=zuuid_size(uuid);
  /* assertion zuuid_size (uuid) == 16 */
  assert(return_value_zuuid_size_1 == (unsigned long int)16);
  const char *return_value_zuuid_str_2;
  return_value_zuuid_str_2=zuuid_str(uuid);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(return_value_zuuid_str_2);
  /* assertion strlen (zuuid_str (uuid)) == (16 * 2) */
  assert(return_value_strlen_3 == (unsigned long int)(16 * 2));
  struct _zuuid_t *copy;
  copy=zuuid_dup(uuid);
  const char *return_value_zuuid_str_4;
  return_value_zuuid_str_4=zuuid_str(uuid);
  const char *return_value_zuuid_str_5;
  return_value_zuuid_str_5=zuuid_str(copy);
  signed int return_value_strcmp_6;
  return_value_strcmp_6=strcmp(return_value_zuuid_str_4, return_value_zuuid_str_5);
  /* assertion (!strcmp ((zuuid_str (uuid)), (zuuid_str (copy)))) */
  assert(!(return_value_strcmp_6 != 0));
  const char *myuuid = "8CB3E9A9649B4BEF8DE225E9C2CEBB38";
  const char *myuuid2 = "8CB3E9A9-649B-4BEF-8DE2-25E9C2CEBB38";
  const char *myuuid3 = "{8CB3E9A9-649B-4BEF-8DE2-25E9C2CEBB38}";
  const char *myuuid4 = "8CB3E9A9649B4BEF8DE225E9C2CEBB3838";
  signed int rc;
  rc=zuuid_set_str(uuid, myuuid);
  /* assertion rc == 0 */
  assert(rc == 0);
  const char *return_value_zuuid_str_7;
  return_value_zuuid_str_7=zuuid_str(uuid);
  signed int return_value_strcmp_8;
  return_value_strcmp_8=strcmp(return_value_zuuid_str_7, myuuid);
  /* assertion (!strcmp ((zuuid_str (uuid)), (myuuid))) */
  assert(!(return_value_strcmp_8 != 0));
  rc=zuuid_set_str(uuid, myuuid2);
  /* assertion rc == 0 */
  assert(rc == 0);
  const char *return_value_zuuid_str_9;
  return_value_zuuid_str_9=zuuid_str(uuid);
  signed int return_value_strcmp_10;
  return_value_strcmp_10=strcmp(return_value_zuuid_str_9, myuuid);
  /* assertion (!strcmp ((zuuid_str (uuid)), (myuuid))) */
  assert(!(return_value_strcmp_10 != 0));
  rc=zuuid_set_str(uuid, myuuid3);
  /* assertion rc == 0 */
  assert(rc == 0);
  const char *return_value_zuuid_str_11;
  return_value_zuuid_str_11=zuuid_str(uuid);
  signed int return_value_strcmp_12;
  return_value_strcmp_12=strcmp(return_value_zuuid_str_11, myuuid);
  /* assertion (!strcmp ((zuuid_str (uuid)), (myuuid))) */
  assert(!(return_value_strcmp_12 != 0));
  rc=zuuid_set_str(uuid, myuuid4);
  /* assertion rc == -1 */
  assert(rc == -1);
  unsigned char copy_uuid[16l];
  zuuid_export(uuid, copy_uuid);
  zuuid_set(uuid, copy_uuid);
  const char *return_value_zuuid_str_13;
  return_value_zuuid_str_13=zuuid_str(uuid);
  signed int return_value_strcmp_14;
  return_value_strcmp_14=strcmp(return_value_zuuid_str_13, myuuid);
  /* assertion (!strcmp ((zuuid_str (uuid)), (myuuid))) */
  assert(!(return_value_strcmp_14 != 0));
  const char *return_value_zuuid_str_canonical_15;
  return_value_zuuid_str_canonical_15=zuuid_str_canonical(uuid);
  signed int return_value_strcmp_16;
  return_value_strcmp_16=strcmp(return_value_zuuid_str_canonical_15, "8cb3e9a9-649b-4bef-8de2-25e9c2cebb38");
  /* assertion (!strcmp ((zuuid_str_canonical (uuid)), ("8cb3e9a9-649b-4bef-8de2-25e9c2cebb38"))) */
  assert(!(return_value_strcmp_16 != 0));
  zuuid_destroy(&uuid);
  zuuid_destroy(&copy);
  printf("OK\n");
}

