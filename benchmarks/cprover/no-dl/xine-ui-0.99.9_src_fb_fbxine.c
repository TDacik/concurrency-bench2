// tag-#anon#ST[*{S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32}_S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32_'set_parameters'||*{S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32}_S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32_'get_parameters'||*{*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_()->*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_}_*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_()->*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#__'get_param_descr'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'get_help'|]
// file /usr/include/xine.h line 834
struct anonymous_10;

// tag-#anon#ST[*{SYM#tag-lirc_config#}_SYM#tag-lirc_config#_'config'||S32'fd'||U32'_pad0'||U64'thread'|]
// file main.h line 94
struct anonymous_15;

// tag-#anon#ST[*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_'post'||*{S8}_S8_'name'|]
// file main.h line 46
struct anonymous_14;

// tag-#anon#ST[*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_'post'||*{SYM#tag-#anon#ST[*{S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32}_S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32_'set_parameters'||*{S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32}_S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32_'get_parameters'||*{*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_()->*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_}_*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_()->*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#__'get_param_descr'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'get_help'|]#}_SYM#tag-#anon#ST[*{S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32}_S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32_'set_parameters'||*{S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32}_S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32_'get_parameters'||*{*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_()->*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_}_*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_()->*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#__'get_param_descr'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'get_help'|]#_'api'||*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_'descr'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'param'||*{S8}_S8_'param_data'||S32'x'||S32'y'||S32'readonly'||U32'_pad0'||*{*{S8}_S8_}_*{S8}_S8__'properties_names'|]
// file post.c line 29
struct anonymous_13;

// tag-#anon#ST[*{SYM#tag-xine_stream_s#}_SYM#tag-xine_stream_s#_'stream'||*{V}_V_'data'||S32'data_length'||S32'type'||SYM#tag-timeval#'tv'|]
// file /usr/include/xine.h line 1847
struct anonymous_2;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_7;

// tag-#anon#ST[BF{U8}_U8_'cb'||BF{U8}_U8_'cr'||BF{U8}_U8_'y'||BF{U8}_U8_'foo'|]
// file osd.c line 46
struct anonymous_18;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_3;

// tag-#anon#ST[S32'enabled'||S32'timeout'||*{SYM#tag-xine_osd_s#}_SYM#tag-xine_osd_s#_'sinfo'||S32'sinfo_visible'||U32'_pad0'||ARR2{*{SYM#tag-xine_osd_s#}_SYM#tag-xine_osd_s#_}_*{SYM#tag-xine_osd_s#}_SYM#tag-xine_osd_s#__'bar'||S32'bar_visible'||U32'_pad1'||*{SYM#tag-xine_osd_s#}_SYM#tag-xine_osd_s#_'status'||S32'status_visible'||U32'_pad2'||*{SYM#tag-xine_osd_s#}_SYM#tag-xine_osd_s#_'info'||S32'info_visible'||U32'_pad3'|]
// file main.h line 109
struct anonymous_16;

// tag-#anon#ST[S32'fd'||U32'_pad0'||U64'thread'|]
// file stdctl.c line 46
struct anonymous_6;

// tag-#anon#ST[S32'set'||S32'arg'|]
// file actions.h line 213
struct anonymous;

// tag-#anon#ST[S32'set'||U32'_pad0'||*{S8}_S8_'arg'|]
// file actions.h line 218
struct anonymous_0;

// tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]
// file /usr/include/xine.h line 829
struct anonymous_9;

// tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]
// file /usr/include/xine.h line 816
struct anonymous_11;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'set'||S32'arg'|]#'numeric'||SYM#tag-#anon#ST[S32'set'||U32'_pad0'||*{S8}_S8_'arg'|]#'alphanum'|]
// file actions.h line 211
struct anonymous_1;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_4;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_5;

// tag-#anon#cST[*{S8}_S8_'description'||*{S8}_S8_'name'||S32'action'||U32'_pad0'|]
// file actions.c line 50
struct anonymous_17;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-fbxine
// file main.h line 52
struct fbxine;

// tag-fbxine_callback
// file callback.h line 24
struct fbxine_callback;

// tag-lirc_code
// file /usr/include/lirc/lirc_client.h line 47
struct lirc_code;

// tag-lirc_config
// file /usr/include/lirc/lirc_client.h line 53
struct lirc_config;

// tag-lirc_config_entry
// file /usr/include/lirc/lirc_client.h line 55
struct lirc_config_entry;

// tag-lirc_list
// file /usr/include/lirc/lirc_client.h line 42
struct lirc_list;

// tag-option
// file ../../src/common/getopt.h line 83
struct option;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-utsname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 48
struct utsname;

// tag-xine_audio_port_s
// file /usr/include/xine.h line 83
struct xine_audio_port_s;

// tag-xine_cfg_entry_s
// file /usr/include/xine.h line 1563
struct xine_cfg_entry_s;

// tag-xine_event_queue_s
// file /usr/include/xine.h line 2132
struct xine_event_queue_s;

// tag-xine_osd_s
// file /usr/include/xine.h line 2209
struct xine_osd_s;

// tag-xine_post_in_s
// file /usr/include/xine.h line 680
struct xine_post_in_s;

// tag-xine_post_out_s
// file /usr/include/xine.h line 681
struct xine_post_out_s;

// tag-xine_post_s
// file /usr/include/xine.h line 627
struct xine_post_s;

// tag-xine_s
// file /usr/include/xine.h line 81
struct xine_s;

// tag-xine_speeds_s
// file osd.c line 97
struct xine_speeds_s;

// tag-xine_status_s
// file osd.c line 87
struct xine_status_s;

// tag-xine_stream_s
// file /usr/include/xine.h line 82
struct xine_stream_s;

// tag-xine_video_port_s
// file /usr/include/xine.h line 84
struct xine_video_port_s;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pplugin_retrieve_parameters
// file post.c line 45
static signed int __pplugin_retrieve_parameters(struct anonymous_13 *pobj);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __strsep_1c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c(char **__s, char __reject);
// __strsep_1c_link1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c_link1(char **__s_link1, char __reject_link1);
// __strsep_1c_link2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c_link2(char **__s_link2, char __reject_link2);
// __strsep_1c_link3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c_link3(char **__s_link3, char __reject_link3);
// __strsep_2c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c(char **__s, char __reject1, char __reject2);
// __strsep_2c_link1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c_link1(char **__s_link1, char __reject1_link1, char __reject2_link1);
// __strsep_2c_link2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c_link2(char **__s_link2, char __reject1_link2, char __reject2_link2);
// __strsep_2c_link3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c_link3(char **__s_link3, char __reject1_link3, char __reject2_link3);
// __strsep_3c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c(char **__s, char __reject1, char __reject2, char __reject3);
// __strsep_3c_link1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c_link1(char **__s_link1, char __reject1_link1, char __reject2_link1, char __reject3_link1);
// __strsep_3c_link2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c_link2(char **__s_link2, char __reject1_link2, char __reject2_link2, char __reject3_link2);
// __strsep_3c_link3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c_link3(char **__s_link3, char __reject1_link3, char __reject2_link3, char __reject3_link3);
// __strsep_g
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1179
extern char * __strsep_g(char **, const char *);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 412
extern signed int __xstat(signed int, const char *, struct stat *);
// _applugin_rewire
// file post.c line 451
static void _applugin_rewire(void);
// _applugin_rewire_from_post_elements
// file post.c line 351
static void _applugin_rewire_from_post_elements(struct anonymous_14 **post_elements, signed int post_elements_num);
// _applugin_unwire
// file post.c line 311
static void _applugin_unwire(void);
// _mkdir_safe
// file utils.c line 140
static signed int _mkdir_safe(char *path);
// _osd_get_speed_sym
// file osd.c line 149
static const char * _osd_get_speed_sym(signed int speed);
// _osd_get_status_sym
// file osd.c line 160
static const char * _osd_get_status_sym(signed int status);
// _pplugin_join_deinterlace_and_post_elements
// file post.c line 382
static struct anonymous_14 ** _pplugin_join_deinterlace_and_post_elements(signed int *post_elements_num);
// _pplugin_join_visualization_and_post_elements
// file post.c line 409
static struct anonymous_14 ** _pplugin_join_visualization_and_post_elements(signed int *post_elements_num);
// _pplugin_update_parameter
// file post.c line 87
static void _pplugin_update_parameter(struct anonymous_13 *pobj);
// _vpplugin_rewire
// file post.c line 437
static void _vpplugin_rewire(void);
// _vpplugin_rewire_from_post_elements
// file post.c line 320
static void _vpplugin_rewire_from_post_elements(struct anonymous_14 **post_elements, signed int post_elements_num);
// _vpplugin_unwire
// file post.c line 302
static void _vpplugin_unwire(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// action_pause
// file actions.c line 326
static void action_pause(void);
// action_play
// file actions.c line 356
static void action_play(void);
// action_seek_relative
// file actions.c line 384
static void action_seek_relative(signed int off_sec);
// applugin_parse_and_store_post
// file post.h line 28
void applugin_parse_and_store_post(const char *post_chain);
// applugin_rewire_posts
// file post.h line 26
void applugin_rewire_posts(void);
// atoa
// file utils.c line 89
char * atoa(char *str);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// change_audio_channel
// file actions.c line 406
static void change_audio_channel(void *data);
// change_spu
// file actions.c line 424
static void change_spu(void *data);
// change_zoom
// file actions.c line 443
static void change_zoom(signed int zoom_dx, signed int zoom_dy);
// check_version
// file main.c line 86
static signed int check_version(void);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// config_mrl
// file ../../src/common/config_wrapper.h line 30
void config_mrl(const char *mrl);
// config_update
// file config_wrapper.c line 44
static void config_update(struct xine_cfg_entry_s *entry, signed int type, signed int min, signed int max, signed int value, char *string);
// config_update_bool
// file config_wrapper.c line 108
void config_update_bool(const char *key, signed int value);
// config_update_enum
// file config_wrapper.c line 99
void config_update_enum(const char *key, signed int value);
// config_update_num
// file config_wrapper.c line 117
void config_update_num(const char *key, signed int value);
// config_update_range
// file config_wrapper.c line 77
void config_update_range(const char *key, signed int min, signed int max);
// config_update_string
// file config_wrapper.c line 86
void config_update_string(const char *key, char *string);
// default_command_action
// file actions.c line 315
signed int default_command_action(char *action_name);
// default_key_action
// file keys.c line 60
static signed int default_key_action(signed int key);
// do_action
// file actions.c line 462
void do_action(signed int action);
// do_getc
// file keys.c line 48
static signed int do_getc(void);
// dump_cpu_infos
// file dump.c line 63
void dump_cpu_infos(void);
// dump_error
// file dump.c line 97
void dump_error(const char *msg);
// dump_host_info
// file dump.c line 40
void dump_host_info(void);
// dump_info
// file dump.c line 105
void dump_info(const char *msg);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// event_listener
// file main.c line 99
static void event_listener(void *user_data, const struct anonymous_2 *event);
// execve
// file /usr/include/unistd.h line 551
extern signed int execve(const char *, char * const *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_audio
// file main.c line 166
static void exit_audio(void);
// exit_keyboard
// file keys.c line 119
static void exit_keyboard(void);
// exit_lirc
// file lirc.c line 71
static void exit_lirc(void);
// exit_stdctl
// file stdctl.c line 160
static void exit_stdctl(void);
// exit_stream
// file main.c line 194
static void exit_stream(void);
// exit_video
// file main.c line 133
static void exit_video(void);
// exit_xine
// file main.c line 219
static void exit_xine(void);
// extract_mrls
// file options.c line 47
static void extract_mrls(signed int num_mrls, char **mrls);
// fbxine_do_abort
// file callback.h line 35
void fbxine_do_abort(void);
// fbxine_do_callbacks
// file callback.c line 39
static void fbxine_do_callbacks(struct fbxine_callback *callback);
// fbxine_do_exit
// file callback.h line 34
void fbxine_do_exit(void);
// fbxine_exit
// file main.c line 246
void fbxine_exit(void);
// fbxine_init
// file main.c line 255
static signed int fbxine_init(signed int argc, char **argv);
// fbxine_init_keyboard
// file keys.h line 26
signed int fbxine_init_keyboard(void);
// fbxine_init_lirc
// file lirc.c line 79
signed int fbxine_init_lirc(void);
// fbxine_init_stdctl
// file stdctl.h line 35
void fbxine_init_stdctl(void);
// fbxine_keyboard_loop
// file keys.c line 107
static void * fbxine_keyboard_loop(void *dummy);
// fbxine_register_abort
// file callback.h line 32
void fbxine_register_abort(struct fbxine_callback *callback, void (*func)(void));
// fbxine_register_abort::func_object
//
void func_object(void);
// fbxine_register_callback
// file callback.c line 30
static void fbxine_register_callback(struct fbxine_callback **top, struct fbxine_callback *callback, void (*func)(void));
// fbxine_register_callback::func_object
//
void func_object(void);
// fbxine_register_exit
// file callback.h line 30
void fbxine_register_exit(struct fbxine_callback *callback, void (*func)(void));
// fbxine_register_exit::func_object
//
void func_object(void);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// get_bool_value
// file utils.c line 192
signed int get_bool_value(const char *val);
// get_last_double_semicolon
// file utils.c line 212
const char * get_last_double_semicolon(const char *str);
// get_pos_length
// file actions.c line 334
signed int get_pos_length(struct xine_stream_s *stream, signed int *pos, signed int *time, signed int *length);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file ../../src/common/getopt.h line 140
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// init_audio
// file main.c line 171
static signed int init_audio(void);
// init_stream
// file main.c line 201
static signed int init_stream(void);
// init_video
// file main.c line 138
static signed int init_video(void);
// init_xine
// file main.c line 224
static signed int init_xine(void);
// install_abort
// file main.c line 310
static void install_abort(void);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// is_a_dir
// file utils.c line 321
signed int is_a_dir(char *filename);
// is_a_file
// file utils.c line 330
signed int is_a_file(char *filename);
// is_downloadable
// file utils.c line 314
signed int is_downloadable(char *filename);
// is_ipv6_last_double_semicolon
// file utils.c line 230
signed int is_ipv6_last_double_semicolon(const char *str);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// lirc_code2char
// file /usr/include/lirc/lirc_client.h line 89
signed int lirc_code2char(struct lirc_config *, char *, char **);
// lirc_deinit
// file /usr/include/lirc/lirc_client.h line 78
signed int lirc_deinit(void);
// lirc_freeconfig
// file /usr/include/lirc/lirc_client.h line 81
void lirc_freeconfig(struct lirc_config *);
// lirc_init
// file /usr/include/lirc/lirc_client.h line 77
signed int lirc_init(char *, signed int);
// lirc_loop
// file lirc.c line 39
static void * lirc_loop(void *dummy);
// lirc_nextcode
// file /usr/include/lirc/lirc_client.h line 88
signed int lirc_nextcode(char **);
// lirc_readconfig
// file /usr/include/lirc/lirc_client.h line 80
signed int lirc_readconfig(char *, struct lirc_config **, signed int (*)(char *));
// load_config
// file main.c line 67
static void load_config(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mkdir_safe
// file utils.c line 168
signed int mkdir_safe(char *path);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// open_and_play
// file main.c line 113
static signed int open_and_play(const char *mrl);
// osd_deinit
// file osd.h line 33
void osd_deinit(void);
// osd_display_audio_lang
// file osd.h line 35
void osd_display_audio_lang(void);
// osd_display_info
// file osd.h line 39
void osd_display_info(char *info, ...);
// osd_display_spu_lang
// file osd.h line 34
void osd_display_spu_lang(void);
// osd_display_zoom
// file osd.h line 36
void osd_display_zoom(void);
// osd_draw_bar
// file osd.c line 456
void osd_draw_bar(char *title, signed int min, signed int max, signed int val, signed int type);
// osd_init
// file osd.h line 32
void osd_init(void);
// osd_loop
// file osd.c line 113
static void * osd_loop(void *dummy);
// osd_stream_infos
// file osd.h line 41
void osd_stream_infos(void);
// osd_stream_position
// file osd.h line 38
void osd_stream_position(void);
// osd_update_status
// file osd.h line 37
void osd_update_status(void);
// parse_options
// file options.h line 28
signed int parse_options(signed int argc, char **argv);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// play
// file actions.c line 350
static signed int play(struct xine_stream_s *stream, signed int start_pos, signed int start_time_in_secs, signed int update_mmk);
// post_deinterlace
// file post.h line 29
void post_deinterlace(void);
// post_deinterlace_init
// file post.h line 30
void post_deinterlace_init(const char *deinterlace_post);
// pplugin_parse_and_load
// file post.c line 94
static struct anonymous_14 ** pplugin_parse_and_load(signed int plugin_type, const char *pchain, signed int *post_elements_num);
// pplugin_parse_and_store_post
// file post.c line 263
static void pplugin_parse_and_store_post(signed int plugin_type, const char *post_chain);
// print_banner
// file options.c line 64
static void print_banner(void);
// print_usage
// file options.c line 76
static void print_usage(void);
// print_version
// file options.c line 58
static void print_version(void);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_4 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_4 *, union anonymous_5 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_5 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_5 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_testcancel
// file /usr/include/pthread.h line 520
extern void pthread_testcancel(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reset_zoom
// file actions.c line 453
static void reset_zoom(void);
// seek_relative_thread
// file actions.c line 361
static void * seek_relative_thread(void *data);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_7 *, struct anonymous_7 *, struct anonymous_7 *, struct timeval *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strcasecmp
// file /usr/include/strings.h line 116
extern signed int strcasecmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlcat
// file ../../src/common/utils.h line 84
unsigned long int strlcat(char *dst, const char *src, unsigned long int siz);
// strlcpy
// file ../../src/common/utils.h line 88
unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// uname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 81
extern signed int uname(struct utsname *);
// vpplugin_parse_and_store_post
// file post.h line 27
void vpplugin_parse_and_store_post(const char *post_chain);
// vpplugin_rewire_posts
// file post.h line 25
void vpplugin_rewire_posts(void);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// wait_for_exit
// file main.c line 241
static void wait_for_exit(void);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// xine_check_version
// file /usr/include/xine.h line 100
signed int xine_check_version(signed int, signed int, signed int);
// xine_close
// file /usr/include/xine.h line 255
void xine_close(struct xine_stream_s *);
// xine_close_audio_driver
// file /usr/include/xine.h line 151
void xine_close_audio_driver(struct xine_s *, struct xine_audio_port_s *);
// xine_close_video_driver
// file /usr/include/xine.h line 152
void xine_close_video_driver(struct xine_s *, struct xine_video_port_s *);
// xine_config_load
// file /usr/include/xine.h line 1711
void xine_config_load(struct xine_s *, const char *);
// xine_config_lookup_entry
// file /usr/include/xine.h line 1687
signed int xine_config_lookup_entry(struct xine_s *, const char *, struct xine_cfg_entry_s *);
// xine_config_register_string
// file /usr/include/xine.h line 1616
const char * xine_config_register_string(struct xine_s *, const char *, const char *, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
// xine_config_update_entry
// file /usr/include/xine.h line 1696
void xine_config_update_entry(struct xine_s *, const struct xine_cfg_entry_s *);
// xine_dispose
// file /usr/include/xine.h line 267
void xine_dispose(struct xine_stream_s *);
// xine_engine_set_param
// file /usr/include/xine.h line 272
void xine_engine_set_param(struct xine_s *, signed int, signed int);
// xine_event_create_listener_thread
// file /usr/include/xine.h line 2164
void xine_event_create_listener_thread(struct xine_event_queue_s *, void (*)(void *, const struct anonymous_2 *), void *);
// xine_event_dispose_queue
// file /usr/include/xine.h line 2142
void xine_event_dispose_queue(struct xine_event_queue_s *);
// xine_event_new_queue
// file /usr/include/xine.h line 2141
struct xine_event_queue_s * xine_event_new_queue(struct xine_stream_s *);
// xine_event_send
// file /usr/include/xine.h line 2174
void xine_event_send(struct xine_stream_s *, const struct anonymous_2 *);
// xine_exit
// file /usr/include/xine.h line 173
void xine_exit(struct xine_s *);
// xine_get_audio_lang
// file /usr/include/xine.h line 933
signed int xine_get_audio_lang(struct xine_stream_s *, signed int, char *);
// xine_get_audio_source
// file /usr/include/xine.h line 766
struct xine_post_out_s * xine_get_audio_source(struct xine_stream_s *);
// xine_get_homedir
// file /usr/include/xine/xineutils.h line 164
const char * xine_get_homedir(void);
// xine_get_meta_info
// file /usr/include/xine.h line 964
const char * xine_get_meta_info(struct xine_stream_s *, signed int);
// xine_get_param
// file /usr/include/xine.h line 282
signed int xine_get_param(struct xine_stream_s *, signed int);
// xine_get_pos_length
// file /usr/include/xine.h line 950
signed int xine_get_pos_length(struct xine_stream_s *, signed int *, signed int *, signed int *);
// xine_get_spu_lang
// file /usr/include/xine.h line 935
signed int xine_get_spu_lang(struct xine_stream_s *, signed int, char *);
// xine_get_status
// file /usr/include/xine.h line 905
signed int xine_get_status(struct xine_stream_s *);
// xine_get_stream_info
// file /usr/include/xine.h line 963
unsigned int xine_get_stream_info(struct xine_stream_s *, signed int);
// xine_get_version
// file /usr/include/xine.h line 96
void xine_get_version(signed int *, signed int *, signed int *);
// xine_get_video_source
// file /usr/include/xine.h line 765
struct xine_post_out_s * xine_get_video_source(struct xine_stream_s *);
// xine_init
// file /usr/include/xine.h line 129
void xine_init(struct xine_s *);
// xine_list_audio_output_plugins
// file /usr/include/xine.h line 1155
const char * const * xine_list_audio_output_plugins(struct xine_s *);
// xine_list_video_output_plugins
// file /usr/include/xine.h line 1156
const char * const * xine_list_video_output_plugins(struct xine_s *);
// xine_new
// file /usr/include/xine.h line 118
struct xine_s * xine_new(void);
// xine_open
// file /usr/include/xine.h line 231
signed int xine_open(struct xine_stream_s *, const char *);
// xine_open_audio_driver
// file /usr/include/xine.h line 146
struct xine_audio_port_s * xine_open_audio_driver(struct xine_s *, const char *, void *);
// xine_open_video_driver
// file /usr/include/xine.h line 148
struct xine_video_port_s * xine_open_video_driver(struct xine_s *, const char *, signed int, void *);
// xine_osd_clear
// file /usr/include/xine.h line 2247
void xine_osd_clear(struct xine_osd_s *);
// xine_osd_draw_rect
// file /usr/include/xine.h line 2218
void xine_osd_draw_rect(struct xine_osd_s *, signed int, signed int, signed int, signed int, signed int, signed int);
// xine_osd_draw_text
// file /usr/include/xine.h line 2222
void xine_osd_draw_text(struct xine_osd_s *, signed int, signed int, const char *, signed int);
// xine_osd_free
// file /usr/include/xine.h line 2305
void xine_osd_free(struct xine_osd_s *);
// xine_osd_get_capabilities
// file /usr/include/xine.h line 2213
unsigned int xine_osd_get_capabilities(struct xine_osd_s *);
// xine_osd_get_text_size
// file /usr/include/xine.h line 2229
void xine_osd_get_text_size(struct xine_osd_s *, const char *, signed int *, signed int *);
// xine_osd_hide
// file /usr/include/xine.h line 2245
void xine_osd_hide(struct xine_osd_s *, signed long int);
// xine_osd_new
// file /usr/include/xine.h line 2211
struct xine_osd_s * xine_osd_new(struct xine_stream_s *, signed int, signed int, signed int, signed int);
// xine_osd_set_font
// file /usr/include/xine.h line 2233
signed int xine_osd_set_font(struct xine_osd_s *, const char *, signed int);
// xine_osd_set_palette
// file /usr/include/xine.h line 2269
void xine_osd_set_palette(struct xine_osd_s *, const unsigned int *, const unsigned char *);
// xine_osd_set_position
// file /usr/include/xine.h line 2242
void xine_osd_set_position(struct xine_osd_s *, signed int, signed int);
// xine_osd_set_text_palette
// file /usr/include/xine.h line 2263
void xine_osd_set_text_palette(struct xine_osd_s *, signed int, signed int);
// xine_osd_show
// file /usr/include/xine.h line 2243
void xine_osd_show(struct xine_osd_s *, signed long int);
// xine_osd_show_unscaled
// file /usr/include/xine.h line 2244
void xine_osd_show_unscaled(struct xine_osd_s *, signed long int);
// xine_play
// file /usr/include/xine.h line 243
signed int xine_play(struct xine_stream_s *, signed int, signed int);
// xine_post_dispose
// file /usr/include/xine.h line 773
void xine_post_dispose(struct xine_s *, struct xine_post_s *);
// xine_post_init
// file /usr/include/xine.h line 660
struct xine_post_s * xine_post_init(struct xine_s *, const char *, signed int, struct xine_audio_port_s **, struct xine_video_port_s **);
// xine_post_input
// file /usr/include/xine.h line 729
struct xine_post_in_s * xine_post_input(struct xine_post_s *, const char *);
// xine_post_list_outputs
// file /usr/include/xine.h line 726
const char * const * xine_post_list_outputs(struct xine_post_s *);
// xine_post_output
// file /usr/include/xine.h line 732
struct xine_post_out_s * xine_post_output(struct xine_post_s *, const char *);
// xine_post_wire
// file /usr/include/xine.h line 738
signed int xine_post_wire(struct xine_post_out_s *, struct xine_post_in_s *);
// xine_post_wire_audio_port
// file /usr/include/xine.h line 760
signed int xine_post_wire_audio_port(struct xine_post_out_s *, struct xine_audio_port_s *);
// xine_post_wire_video_port
// file /usr/include/xine.h line 749
signed int xine_post_wire_video_port(struct xine_post_out_s *, struct xine_video_port_s *);
// xine_set_param
// file /usr/include/xine.h line 281
void xine_set_param(struct xine_stream_s *, signed int, signed int);
// xine_stdctl_loop
// file stdctl.c line 53
static void * xine_stdctl_loop(void *dummy);
// xine_stream_new
// file /usr/include/xine.h line 191
struct xine_stream_s * xine_stream_new(struct xine_s *, struct xine_audio_port_s *, struct xine_video_port_s *);
// xine_system
// file utils.c line 44
signed int xine_system(signed int dont_run_as_root, char *command);
// xine_usec_sleep
// file /usr/include/xine/xineutils.h line 185
void xine_usec_sleep(unsigned int);

struct anonymous_10
{
  // set_parameters
  signed int (*set_parameters)(struct xine_post_s *, void *);
  // get_parameters
  signed int (*get_parameters)(struct xine_post_s *, void *);
  // get_param_descr
  struct anonymous_9 * (*get_param_descr)(void);
  // get_help
  char * (*get_help)(void);
};

struct anonymous_15
{
  // config
  struct lirc_config *config;
  // fd
  signed int fd;
  // thread
  unsigned long int thread;
};

struct anonymous_14
{
  // post
  struct xine_post_s *post;
  // name
  char *name;
};

struct anonymous_13
{
  // post
  struct xine_post_s *post;
  // api
  struct anonymous_10 *api;
  // descr
  struct anonymous_9 *descr;
  // param
  struct anonymous_11 *param;
  // param_data
  char *param_data;
  // x
  signed int x;
  // y
  signed int y;
  // readonly
  signed int readonly;
  // properties_names
  char **properties_names;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct anonymous_2
{
  // stream
  struct xine_stream_s *stream;
  // data
  void *data;
  // data_length
  signed int data_length;
  // type
  signed int type;
  // tv
  struct timeval tv;
};

struct anonymous_7
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_18
{
  // cb
  unsigned char cb : 8;
  // cr
  unsigned char cr : 8;
  // y
  unsigned char y : 8;
  // foo
  unsigned char foo : 8;
} __attribute__ ((__packed__));

struct anonymous_3
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_16
{
  // enabled
  signed int enabled;
  // timeout
  signed int timeout;
  // sinfo
  struct xine_osd_s *sinfo;
  // sinfo_visible
  signed int sinfo_visible;
  // bar
  struct xine_osd_s *bar[2l];
  // bar_visible
  signed int bar_visible;
  // status
  struct xine_osd_s *status;
  // status_visible
  signed int status_visible;
  // info
  struct xine_osd_s *info;
  // info_visible
  signed int info_visible;
};

struct anonymous_6
{
  // fd
  signed int fd;
  // thread
  unsigned long int thread;
};

struct anonymous
{
  // set
  signed int set;
  // arg
  signed int arg;
};

struct anonymous_0
{
  // set
  signed int set;
  // arg
  char *arg;
};

struct anonymous_9
{
  // struct_size
  signed int struct_size;
  // parameter
  struct anonymous_11 *parameter;
};

struct anonymous_11
{
  // type
  signed int type;
  // name
  const char *name;
  // size
  signed int size;
  // offset
  signed int offset;
  // enum_values
  char **enum_values;
  // range_min
  double range_min;
  // range_max
  double range_max;
  // readonly
  signed int readonly;
  // description
  const char *description;
};

struct anonymous_1
{
  // numeric
  struct anonymous numeric;
  // alphanum
  struct anonymous_0 alphanum;
};

union anonymous_4
{
  // __data
  struct anonymous_3 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_5
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_17
{
  // description
  char *description;
  // name
  char *name;
  // action
  signed int action;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct fbxine
{
  // stream
  struct xine_stream_s *stream;
  // video_port
  struct xine_video_port_s *video_port;
  // audio_port
  struct xine_audio_port_s *audio_port;
  // event_queue
  struct xine_event_queue_s *event_queue;
  // tty_fd
  signed int tty_fd;
  // ti_save
  struct termios ti_save;
  // ti_cur
  struct termios ti_cur;
  // ignore_status
  signed int ignore_status;
  // mrl
  char *mrl[1024l];
  // num_mrls
  signed int num_mrls;
  // current_mrl
  signed int current_mrl;
  // audio_port_id
  const char *audio_port_id;
  // video_port_id
  const char *video_port_id;
  // audio_channel
  signed int audio_channel;
  // screen_width
  signed int screen_width;
  // screen_height
  signed int screen_height;
  // debug
  signed int debug;
  // ignore_next
  signed int ignore_next;
  // post_video_elements
  struct anonymous_14 **post_video_elements;
  // post_video_elements_num
  signed int post_video_elements_num;
  // post_video_enable
  signed int post_video_enable;
  // post_audio_elements
  struct anonymous_14 **post_audio_elements;
  // post_audio_elements_num
  signed int post_audio_elements_num;
  // post_audio_enable
  signed int post_audio_enable;
  // deinterlace_plugin
  char *deinterlace_plugin;
  // deinterlace_elements
  struct anonymous_14 **deinterlace_elements;
  // deinterlace_elements_num
  signed int deinterlace_elements_num;
  // deinterlace_enable
  signed int deinterlace_enable;
  // lirc
  struct anonymous_15 lirc;
  // mutex
  union anonymous_5 mutex;
  // exit_cond
  union anonymous_4 exit_cond;
  // keyboard_thread
  unsigned long int keyboard_thread;
  // osd_thread
  unsigned long int osd_thread;
  // osd
  struct anonymous_16 osd;
};

struct fbxine_callback
{
  // next
  struct fbxine_callback *next;
  // func
  void (*func)(void);
};

struct lirc_code
{
  // remote
  char *remote;
  // button
  char *button;
  // next
  struct lirc_code *next;
};

struct lirc_config
{
  // current_mode
  char *current_mode;
  // next
  struct lirc_config_entry *next;
  // first
  struct lirc_config_entry *first;
  // sockfd
  signed int sockfd;
};

struct lirc_config_entry
{
  // prog
  char *prog;
  // code
  struct lirc_code *code;
  // rep_delay
  unsigned int rep_delay;
  // rep
  unsigned int rep;
  // config
  struct lirc_list *config;
  // change_mode
  char *change_mode;
  // flags
  unsigned int flags;
  // mode
  char *mode;
  // next_config
  struct lirc_list *next_config;
  // next_code
  struct lirc_code *next_code;
  // next
  struct lirc_config_entry *next;
};

struct lirc_list
{
  // string
  char *string;
  // next
  struct lirc_list *next;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct utsname
{
  // sysname
  char sysname[65l];
  // nodename
  char nodename[65l];
  // release
  char release[65l];
  // version
  char version[65l];
  // machine
  char machine[65l];
  // domainname
  char domainname[65l];
};

struct xine_cfg_entry_s
{
  // key
  const char *key;
  // type
  signed int type;
  // exp_level
  signed int exp_level;
  // unknown_value
  char *unknown_value;
  // str_value
  char *str_value;
  // str_default
  char *str_default;
  // num_value
  signed int num_value;
  // num_default
  signed int num_default;
  // range_min
  signed int range_min;
  // range_max
  signed int range_max;
  // enum_values
  char **enum_values;
  // description
  const char *description;
  // help
  const char *help;
  // callback
  void (*callback)(void *, struct xine_cfg_entry_s *);
  // callback_data
  void *callback_data;
};

struct xine_post_in_s
{
  // name
  const char *name;
  // data
  void *data;
  // type
  signed int type;
};

struct xine_post_out_s
{
  // name
  const char *name;
  // data
  void *data;
  // rewire
  signed int (*rewire)(struct xine_post_out_s *, void *);
  // type
  signed int type;
};

struct xine_post_s
{
  // audio_input
  struct xine_audio_port_s **audio_input;
  // video_input
  struct xine_video_port_s **video_input;
  // type
  signed int type;
};

struct xine_speeds_s
{
  // symbol
  char symbol[4l];
  // speed
  signed int speed;
};

struct xine_status_s
{
  // symbol
  char symbol[4l];
  // status
  signed int status;
};


// __xineui_global_config_file
// file globals.c line 36
char *__xineui_global_config_file;
// __xineui_global_lirc_enable
// file globals.c line 47
signed int __xineui_global_lirc_enable;
// __xineui_global_verbosity
// file globals.c line 41
signed int __xineui_global_verbosity;
// __xineui_global_xine_instance
// file globals.c line 31
struct xine_s *__xineui_global_xine_instance;
// default_actions
// file actions.c line 55
static struct anonymous_17 default_actions[120l] = { { .description="Select next sub picture (subtitle) channel.", .name="SpuNext",
    .action=6 },
    { .description="Select previous sub picture (subtitle) channel.", .name="SpuPrior",
    .action=7 },
    { .description="Select default sub picture (subtitle) channel.", .name="SpuDefault",
    .action=8 },
    { .description="Select next audio channel.", .name="AudioChannelNext",
    .action=11 },
    { .description="Select previous audio channel.", .name="AudioChannelPrior",
    .action=12 },
    { .description="Set default audio channel.", .name="AudioChannelDefault",
    .action=13 },
    { .description="Playback pause toggle.", .name="Pause",
    .action=15 },
    { .description="Aspect ratio values toggle.", .name="ToggleAspectRatio",
    .action=19 },
    { .description="Display stream information using OSD.", .name="OSDStreamInfos",
    .action=85 },
    { .description="Display information using OSD.", .name="OSDWriteText",
    .action=86 },
    { .description="Interlaced mode toggle.", .name="ToggleInterleave",
    .action=21 },
    { .description="Quit the program.", .name="Quit", .action=22 },
    { .description="Start playback.", .name="Play", .action=23 },
    { .description="Visibility toggle of the setup window.", .name="SetupShow",
    .action=75 },
    { .description="Stop playback.", .name="Stop", .action=24 },
    { .description="Select and play next mrl in the playlist.", .name="NextMrl",
    .action=25 },
    { .description="Select and play previous mrl in the playlist.", .name="PriorMrl",
    .action=26 },
    { .description="Visibility toggle of the event sender window.", .name="EventSenderShow",
    .action=27 },
    { .description="Edit selected mediamark.", .name="MediamarkEditor",
    .action=81 },
    { .description="Eject the current medium.", .name="Eject",
    .action=28 },
    { .description="Set position to numeric-argument%% of current stream.", .name="SetPosition%",
    .action=29 },
    { .description="Set position to beginning of current stream.", .name="SetPosition0%",
    .action=30 },
    { .description="Set position to 10%% of current stream.", .name="SetPosition10%",
    .action=31 },
    { .description="Set position to 20%% of current stream.", .name="SetPosition20%",
    .action=32 },
    { .description="Set position to 30%% of current stream.", .name="SetPosition30%",
    .action=33 },
    { .description="Set position to 40%% of current stream.", .name="SetPosition40%",
    .action=34 },
    { .description="Set position to 50%% of current stream.", .name="SetPosition50%",
    .action=35 },
    { .description="Set position to 60%% of current stream.", .name="SetPosition60%",
    .action=36 },
    { .description="Set position to 70%% of current stream.", .name="SetPosition70%",
    .action=37 },
    { .description="Set position to 80%% of current stream.", .name="SetPosition80%",
    .action=38 },
    { .description="Set position to 90%% of current stream.", .name="SetPosition90%",
    .action=39 },
    { .description="Enter the number 0.", .name="Number0", .action=1144 },
    { .description="Enter the number 1.", .name="Number1", .action=1145 },
    { .description="Enter the number 2.", .name="Number2", .action=1146 },
    { .description="Enter the number 3.", .name="Number3", .action=1147 },
    { .description="Enter the number 4.", .name="Number4", .action=1148 },
    { .description="Enter the number 5.", .name="Number5", .action=1149 },
    { .description="Enter the number 6.", .name="Number6", .action=1150 },
    { .description="Enter the number 7.", .name="Number7", .action=1151 },
    { .description="Enter the number 8.", .name="Number8", .action=1152 },
    { .description="Enter the number 9.", .name="Number9", .action=1153 },
    { .description="Add 10 to the next entered number.", .name="Number10add",
    .action=1154 },
    { .description="Set position back by numeric argument in current stream.", .name="SeekRelative-",
    .action=40 },
    { .description="Set position to -60 seconds in current stream.", .name="SeekRelative-60",
    .action=44 },
    { .description="Set position forward by numeric argument in current stream.", .name="SeekRelative+",
    .action=41 },
    { .description="Set position to +60 seconds in current stream.", .name="SeekRelative+60",
    .action=45 },
    { .description="Set position to -30 seconds in current stream.", .name="SeekRelative-30",
    .action=46 },
    { .description="Set position to +30 seconds in current stream.", .name="SeekRelative+30",
    .action=47 },
    { .description="Set position to -15 seconds in current stream.", .name="SeekRelative-15",
    .action=48 },
    { .description="Set position to +15 seconds in current stream.", .name="SeekRelative+15",
    .action=49 },
    { .description="Set position to -7 seconds in current stream.", .name="SeekRelative-7",
    .action=52 },
    { .description="Set position to +7 seconds in current stream.", .name="SeekRelative+7",
    .action=53 },
    { .description="Audio muting toggle.", .name="Mute", .action=55 },
    { .description="Change audio syncing.", .name="AudioVideoDecay+", .action=56 },
    { .description="Change audio syncing.", .name="AudioVideoDecay-", .action=57 },
    { .description="Reset audio video syncing offset.", .name="AudioVideoDecayReset",
    .action=58 },
    { .description="Increment playback speed.", .name="SpeedFaster",
    .action=59 },
    { .description="Decrement playback speed.", .name="SpeedSlower",
    .action=60 },
    { .description="Reset playback speed.", .name="SpeedReset", .action=61 },
    { .description="Increment audio volume.", .name="Volume+",
    .action=62 },
    { .description="Decrement audio volume.", .name="Volume-",
    .action=63 },
    { .description="Take a snapshot (Internal image fetch and save).", .name="Snapshot",
    .action=64 },
    { .description="Jump to Menu.", .name="Menu", .action=1127 },
    { .description="Jump to Title Menu.", .name="TitleMenu", .action=1128 },
    { .description="Jump to Root Menu.", .name="RootMenu", .action=1129 },
    { .description="Jump to Subpicture Menu.", .name="SubpictureMenu",
    .action=1130 },
    { .description="Jump to Audio Menu.", .name="AudioMenu", .action=1131 },
    { .description="Jump to Angle Menu.", .name="AngleMenu", .action=1132 },
    { .description="Jump to Part Menu.", .name="PartMenu", .action=1133 },
    { .description="Up event.", .name="EventUp", .action=1134 },
    { .description="Down event.", .name="EventDown", .action=1135 },
    { .description="Left event.", .name="EventLeft", .action=1136 },
    { .description="Right event.", .name="EventRight", .action=1137 },
    { .description="Previous event.", .name="EventPrior", .action=1140 },
    { .description="Next event.", .name="EventNext", .action=1139 },
    { .description="Previous angle event.", .name="EventAnglePrior", .action=1142 },
    { .description="Next angle event.", .name="EventAngleNext", .action=1141 },
    { .description="Select event.", .name="EventSelect", .action=1138 },
    { .description="Zoom in.", .name="ZoomIn", .action=67 },
    { .description="Zoom out.", .name="ZoomOut", .action=68 },
    { .description="Reset zooming.", .name="ZoomReset", .action=73 },
    { .description="Loop mode toggle.", .name="ToggleLoopMode", .action=82 },
    { .description="VDR Red button", .name="VDRButtonRed", .action=1324 },
    { .description="VDR Green button", .name="VDRButtonGreen", .action=1325 },
    { .description="VDR Yellow button", .name="VDRButtonYellow", .action=1326 },
    { .description="VDR Blue button", .name="VDRButtonBlue", .action=1327 },
    { .description="VDR Play", .name="VDRPlay", .action=1328 },
    { .description="VDR Pause", .name="VDRPause", .action=1329 },
    { .description="VDR Stop", .name="VDRStop", .action=1330 },
    { .description="VDR Record", .name="VDRRecord", .action=1331 },
    { .description="VDR Fast forward", .name="VDRFastFwd", .action=1332 },
    { .description="VDR Fast rewind", .name="VDRFastRew", .action=1333 },
    { .description="VDR Power", .name="VDRPower", .action=1334 },
    { .description="VDR Channel +", .name="VDRChannelPlus", .action=1335 },
    { .description="VDR Channel -", .name="VDRChannelMinus", .action=1336 },
    { .description="VDR Schedule menu", .name="VDRSchedule", .action=1337 },
    { .description="VDR Channel menu", .name="VDRChannels", .action=1338 },
    { .description="VDR Timers menu", .name="VDRTimers", .action=1339 },
    { .description="VDR Recordings menu", .name="VDRRecordings", .action=1340 },
    { .description="VDR Setup menu", .name="VDRSetup", .action=1341 },
    { .description="VDR Command menu", .name="VDRCommands", .action=1342 },
    { .description="VDR Command back", .name="VDRBack", .action=1343 },
    { .description="VDR User command 0", .name="VDRUser0", .action=1360 },
    { .description="VDR User command 1", .name="VDRUser1", .action=1344 },
    { .description="VDR User command 2", .name="VDRUser2", .action=1345 },
    { .description="VDR User command 3", .name="VDRUser3", .action=1346 },
    { .description="VDR User command 4", .name="VDRUser4", .action=1347 },
    { .description="VDR User command 5", .name="VDRUser5", .action=1348 },
    { .description="VDR User command 6", .name="VDRUser6", .action=1349 },
    { .description="VDR User command 7", .name="VDRUser7", .action=1350 },
    { .description="VDR User command 8", .name="VDRUser8", .action=1351 },
    { .description="VDR User command 9", .name="VDRUser9", .action=1352 },
    { .description="VDR Volume +", .name="VDRVolumePlus", .action=1353 },
    { .description="VDR Volume -", .name="VDRVolumeMinus", .action=1354 },
    { .description="VDR Mute audio", .name="VDRMute", .action=1355 },
    { .description="VDR Audio menu", .name="VDRAudio", .action=1356 },
    { .description="VDR Command info", .name="VDRInfo", .action=1357 },
    { .description="VDR Previous channel", .name="VDRChannelPrevious", .action=1358 },
    { .description="VDR Subtitles menu", .name="VDRSubtitles", .action=1359 },
    { .description=((char *)NULL), .name=((char *)NULL), .action=0 } };
// environ
// file /usr/include/unistd.h line 545
extern char **environ;
// fbxine
// file main.c line 46
struct fbxine fbxine = { .stream=((struct xine_stream_s *)NULL), .video_port=((struct xine_video_port_s *)NULL),
    .audio_port=((struct xine_audio_port_s *)NULL),
    .event_queue=((struct xine_event_queue_s *)NULL),
    .tty_fd=-1,
    .ti_save={ .c_iflag=0u, .c_oflag=0u, .c_cflag=0u, .c_lflag=0u,
    .c_line=0, .c_cc={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .c_ispeed=0u,
    .c_ospeed=0u }, .ti_cur={ .c_iflag=0u, .c_oflag=0u, .c_cflag=0u, .c_lflag=0u,
    .c_line=0, .c_cc={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .c_ispeed=0u,
    .c_ospeed=0u },
    .ignore_status=0,
    .mrl={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .num_mrls=0,
    .current_mrl=0, .audio_port_id=((const char *)NULL), .video_port_id="fb",
    .audio_channel=0, .screen_width=0,
    .screen_height=0, .debug=0, .ignore_next=0,
    .post_video_elements=(struct anonymous_14 **)(void *)0, .post_video_elements_num=0,
    .post_video_enable=1, .post_audio_elements=(struct anonymous_14 **)(void *)0,
    .post_audio_elements_num=0,
    .post_audio_enable=1, .deinterlace_plugin=(char *)(void *)0,
    .deinterlace_elements=(struct anonymous_14 **)(void *)0,
    .deinterlace_elements_num=0,
    .deinterlace_enable=0, .lirc={ .config=((struct lirc_config *)NULL), .fd=0, .thread=0ul },
    .mutex={ .__data={ .__lock=0, .__count=0u, .__owner=0, .__nusers=0u, .__kind=0,
    .__spins=0, .__elision=0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } },
    .exit_cond={ .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } },
    .keyboard_thread=0ul,
    .osd_thread=0ul, .osd={ .enabled=0, .timeout=0, .sinfo=((struct xine_osd_s *)NULL), .sinfo_visible=0,
    .bar={ ((struct xine_osd_s *)NULL), ((struct xine_osd_s *)NULL) }, .bar_visible=0,
    .status=((struct xine_osd_s *)NULL), .status_visible=0,
    .info=((struct xine_osd_s *)NULL), .info_visible=0 } };
// fbxine_fifo_abort
// file callback.c line 28
static struct fbxine_callback *fbxine_fifo_abort = ((struct fbxine_callback *)NULL);
// fbxine_fifo_exit
// file callback.c line 27
static struct fbxine_callback *fbxine_fifo_exit = ((struct fbxine_callback *)NULL);
// gParameter
// file actions.c line 44
struct anonymous_1 gParameter = { .numeric={ .set=0, .arg=0 }, .alphanum={ .set=0, .arg=(char *)(void *)0 } };
// no_lirc
// file options.c line 43
signed int no_lirc;
// optarg
// file ../../src/common/getopt.h line 36
extern char *optarg;
// opterr
// file ../../src/common/getopt.h line 55
extern signed int opterr;
// optind
// file ../../src/common/getopt.h line 50
extern signed int optind;
// pplugins
// file options.c line 44
char **pplugins = (char **)(void *)0;
// pplugins_num
// file options.c line 45
signed int pplugins_num = 0;
// stdctl
// file options.c line 42
signed int stdctl;
// stdctl_link1
// file stdctl.c line 51
static struct anonymous_6 stdctl_link1;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// textpalettes_color
// file osd.c line 53
static const struct anonymous_18 textpalettes_color[22l] = { { .cb=0x00, .cr=0x00, .y=0x00, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0x60, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0x70, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0x80, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0x80, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0x80, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0x80, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0xa0, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0xc0, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0xe0, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0xff, .foo=0 },
    { .cb=0x00, .cr=0x00, .y=0x00, .foo=0 },
    { .cb=0xe0, .cr=0x80, .y=0x80, .foo=0 },
    { .cb=0xc0, .cr=0x80, .y=0x80, .foo=0 },
    { .cb=0xa0, .cr=0x80, .y=0x60, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0x40, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0x20, .foo=0 },
    { .cb=0x80, .cr=0x80, .y=0x00, .foo=0 },
    { .cb=0x60, .cr=0x84, .y=0x40, .foo=0 },
    { .cb=0x40, .cr=0x88, .y=0xd0, .foo=0 },
    { .cb=0x00, .cr=0x8a, .y=0xe0, .foo=0 },
    { .cb=0x00, .cr=0x90, .y=0xff, .foo=0 } };
// textpalettes_trans
// file osd.c line 80
static const unsigned char textpalettes_trans[22l] = { (const unsigned char)0, (const unsigned char)8, (const unsigned char)9, (const unsigned char)10, (const unsigned char)11, (const unsigned char)12, (const unsigned char)13, (const unsigned char)14, (const unsigned char)15, (const unsigned char)15, (const unsigned char)15, (const unsigned char)0, (const unsigned char)8, (const unsigned char)9, (const unsigned char)10, (const unsigned char)11, (const unsigned char)12, (const unsigned char)13, (const unsigned char)14, (const unsigned char)15, (const unsigned char)15, (const unsigned char)15 };
// xine_speeds
// file osd.c line 100
static struct xine_speeds_s xine_speeds[6l] = { { .symbol={ '<', 0, 0, 0 }, .speed=0 }, { .symbol={ '@', '@', '>', 0 }, .speed=1 },
    { .symbol={ '@', '>', 0, 0 }, .speed=2 },
    { .symbol={ '>', 0, 0, 0 }, .speed=4 }, { .symbol={ '>', '_', 0, 0 }, .speed=8 },
    { .symbol={ '>', '_', '_', 0 }, .speed=16 } };
// xine_status
// file osd.c line 90
static struct xine_status_s xine_status[4l] = { { .symbol={ -40, 0, 0, 0 }, .status=0 },
    { .symbol={ '}', 0, 0, 0 }, .status=1 },
    { .symbol={ '>', 0, 0, 0 }, .status=2 },
    { .symbol={ '{', 0, 0, 0 }, .status=3 } };

// __pplugin_retrieve_parameters
// file post.c line 45
static signed int __pplugin_retrieve_parameters(struct anonymous_13 *pobj)
{
  struct xine_post_in_s *input_api;
  struct xine_post_in_s *return_value_xine_post_input_5;
  return_value_xine_post_input_5=xine_post_input(pobj->post, "parameters");
  input_api = (struct xine_post_in_s *)return_value_xine_post_input_5;
  void *return_value_malloc_2;
  void *return_value_realloc_3;
  if(!(input_api == ((struct xine_post_in_s *)NULL)))
  {
    struct anonymous_10 *post_api;
    struct anonymous_9 *api_descr;
    struct anonymous_11 *parm;
    signed int pnum = 0;
    post_api = (struct anonymous_10 *)input_api->data;
    api_descr=post_api->get_param_descr();
    parm = api_descr->parameter;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)api_descr->struct_size);
    pobj->param_data = (char *)return_value_malloc_1;
    if(!(parm->type == 0))
    {
      post_api->get_parameters(pobj->post, (void *)pobj->param_data);
      if(pnum == 0)
      {
        return_value_malloc_2=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)2);
        pobj->properties_names = (char **)return_value_malloc_2;
      }

      else
      {
        return_value_realloc_3=realloc((void *)pobj->properties_names, sizeof(char *) /*8ul*/  * (unsigned long int)(pnum + 2));
        pobj->properties_names = (char **)return_value_realloc_3;
      }
      char *return_value___strdup_4;
      return_value___strdup_4=__strdup(parm->name);
      pobj->properties_names[(signed long int)pnum] = return_value___strdup_4;
      pobj->properties_names[(signed long int)(pnum + 1)] = (char *)(void *)0;
      pnum = pnum + 1;
      parm = parm + 1l;
    }

    pobj->api = post_api;
    pobj->descr = api_descr;
    pobj->param = api_descr->parameter;
    return 1;
  }

  return 0;
}

// __strsep_1c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c(char **__s, char __reject)
{
  char *__retval = *__s;
  char *return_value___builtin_strchr_2;
  char *tmp_post_1;
  if(!(__retval == ((char *)NULL)))
  {
    return_value___builtin_strchr_2=__builtin_strchr(__retval, (signed int)__reject);
    *__s = return_value___builtin_strchr_2;
    if(!(*__s == ((char *)NULL)))
    {
      tmp_post_1 = *__s;
      *__s = *__s + 1l;
      *tmp_post_1 = (char)0;
    }

  }

  return __retval;
}

// __strsep_1c_link1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c_link1(char **__s_link1, char __reject_link1)
{
  char *__retval_link1 = *__s_link1;
  char *return_value___builtin_strchr_2_link1;
  char *tmp_post_1_link1;
  if(!(__retval_link1 == ((char *)NULL)))
  {
    return_value___builtin_strchr_2_link1=__builtin_strchr(__retval_link1, (signed int)__reject_link1);
    *__s_link1 = return_value___builtin_strchr_2_link1;
    if(!(*__s_link1 == ((char *)NULL)))
    {
      tmp_post_1_link1 = *__s_link1;
      *__s_link1 = *__s_link1 + 1l;
      *tmp_post_1_link1 = (char)0;
    }

  }

  return __retval_link1;
}

// __strsep_1c_link2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c_link2(char **__s_link2, char __reject_link2)
{
  char *__retval_link2 = *__s_link2;
  char *return_value___builtin_strchr_2_link2;
  char *tmp_post_1_link2;
  if(!(__retval_link2 == ((char *)NULL)))
  {
    return_value___builtin_strchr_2_link2=__builtin_strchr(__retval_link2, (signed int)__reject_link2);
    *__s_link2 = return_value___builtin_strchr_2_link2;
    if(!(*__s_link2 == ((char *)NULL)))
    {
      tmp_post_1_link2 = *__s_link2;
      *__s_link2 = *__s_link2 + 1l;
      *tmp_post_1_link2 = (char)0;
    }

  }

  return __retval_link2;
}

// __strsep_1c_link3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c_link3(char **__s_link3, char __reject_link3)
{
  char *__retval_link3 = *__s_link3;
  char *return_value___builtin_strchr_2_link3;
  char *tmp_post_1_link3;
  if(!(__retval_link3 == ((char *)NULL)))
  {
    return_value___builtin_strchr_2_link3=__builtin_strchr(__retval_link3, (signed int)__reject_link3);
    *__s_link3 = return_value___builtin_strchr_2_link3;
    if(!(*__s_link3 == ((char *)NULL)))
    {
      tmp_post_1_link3 = *__s_link3;
      *__s_link3 = *__s_link3 + 1l;
      *tmp_post_1_link3 = (char)0;
    }

  }

  return __retval_link3;
}

// __strsep_2c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c(char **__s, char __reject1, char __reject2)
{
  char *__retval = *__s;
  _Bool tmp_if_expr_2;
  char *tmp_post_1;
  if(!(__retval == ((char *)NULL)))
  {
    char *__cp = __retval;
    for( ; (_Bool)1; __cp = __cp + 1l)
    {
      if((signed int)*__cp == 0)
      {
        __cp = (char *)(void *)0;
        break;
      }

      if(*__cp == __reject1)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = *__cp == __reject2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        tmp_post_1 = __cp;
        __cp = __cp + 1l;
        *tmp_post_1 = (char)0;
        break;
      }

    }
    *__s = __cp;
  }

  return __retval;
}

// __strsep_2c_link1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c_link1(char **__s_link1, char __reject1_link1, char __reject2_link1)
{
  char *__retval_link1 = *__s_link1;
  _Bool tmp_if_expr_2_link1;
  char *tmp_post_1_link1;
  if(!(__retval_link1 == ((char *)NULL)))
  {
    char *__cp_link1 = __retval_link1;
    for( ; (_Bool)1; __cp_link1 = __cp_link1 + 1l)
    {
      if((signed int)*__cp_link1 == 0)
      {
        __cp_link1 = (char *)(void *)0;
        break;
      }

      if(*__cp_link1 == __reject1_link1)
        tmp_if_expr_2_link1 = (_Bool)1;

      else
        tmp_if_expr_2_link1 = *__cp_link1 == __reject2_link1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2_link1)
      {
        tmp_post_1_link1 = __cp_link1;
        __cp_link1 = __cp_link1 + 1l;
        *tmp_post_1_link1 = (char)0;
        break;
      }

    }
    *__s_link1 = __cp_link1;
  }

  return __retval_link1;
}

// __strsep_2c_link2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c_link2(char **__s_link2, char __reject1_link2, char __reject2_link2)
{
  char *__retval_link2 = *__s_link2;
  _Bool tmp_if_expr_2_link2;
  char *tmp_post_1_link2;
  if(!(__retval_link2 == ((char *)NULL)))
  {
    char *__cp_link2 = __retval_link2;
    for( ; (_Bool)1; __cp_link2 = __cp_link2 + 1l)
    {
      if((signed int)*__cp_link2 == 0)
      {
        __cp_link2 = (char *)(void *)0;
        break;
      }

      if(*__cp_link2 == __reject1_link2)
        tmp_if_expr_2_link2 = (_Bool)1;

      else
        tmp_if_expr_2_link2 = *__cp_link2 == __reject2_link2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2_link2)
      {
        tmp_post_1_link2 = __cp_link2;
        __cp_link2 = __cp_link2 + 1l;
        *tmp_post_1_link2 = (char)0;
        break;
      }

    }
    *__s_link2 = __cp_link2;
  }

  return __retval_link2;
}

// __strsep_2c_link3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c_link3(char **__s_link3, char __reject1_link3, char __reject2_link3)
{
  char *__retval_link3 = *__s_link3;
  _Bool tmp_if_expr_2_link3;
  char *tmp_post_1_link3;
  if(!(__retval_link3 == ((char *)NULL)))
  {
    char *__cp_link3 = __retval_link3;
    for( ; (_Bool)1; __cp_link3 = __cp_link3 + 1l)
    {
      if((signed int)*__cp_link3 == 0)
      {
        __cp_link3 = (char *)(void *)0;
        break;
      }

      if(*__cp_link3 == __reject1_link3)
        tmp_if_expr_2_link3 = (_Bool)1;

      else
        tmp_if_expr_2_link3 = *__cp_link3 == __reject2_link3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2_link3)
      {
        tmp_post_1_link3 = __cp_link3;
        __cp_link3 = __cp_link3 + 1l;
        *tmp_post_1_link3 = (char)0;
        break;
      }

    }
    *__s_link3 = __cp_link3;
  }

  return __retval_link3;
}

// __strsep_3c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c(char **__s, char __reject1, char __reject2, char __reject3)
{
  char *__retval = *__s;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  char *tmp_post_1;
  if(!(__retval == ((char *)NULL)))
  {
    char *__cp = __retval;
    for( ; (_Bool)1; __cp = __cp + 1l)
    {
      if((signed int)*__cp == 0)
      {
        __cp = (char *)(void *)0;
        break;
      }

      if(*__cp == __reject1)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = *__cp == __reject2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = *__cp == __reject3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
      {
        tmp_post_1 = __cp;
        __cp = __cp + 1l;
        *tmp_post_1 = (char)0;
        break;
      }

    }
    *__s = __cp;
  }

  return __retval;
}

// __strsep_3c_link1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c_link1(char **__s_link1, char __reject1_link1, char __reject2_link1, char __reject3_link1)
{
  char *__retval_link1 = *__s_link1;
  _Bool tmp_if_expr_2_link1;
  _Bool tmp_if_expr_3_link1;
  char *tmp_post_1_link1;
  if(!(__retval_link1 == ((char *)NULL)))
  {
    char *__cp_link1 = __retval_link1;
    for( ; (_Bool)1; __cp_link1 = __cp_link1 + 1l)
    {
      if((signed int)*__cp_link1 == 0)
      {
        __cp_link1 = (char *)(void *)0;
        break;
      }

      if(*__cp_link1 == __reject1_link1)
        tmp_if_expr_2_link1 = (_Bool)1;

      else
        tmp_if_expr_2_link1 = *__cp_link1 == __reject2_link1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2_link1)
        tmp_if_expr_3_link1 = (_Bool)1;

      else
        tmp_if_expr_3_link1 = *__cp_link1 == __reject3_link1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3_link1)
      {
        tmp_post_1_link1 = __cp_link1;
        __cp_link1 = __cp_link1 + 1l;
        *tmp_post_1_link1 = (char)0;
        break;
      }

    }
    *__s_link1 = __cp_link1;
  }

  return __retval_link1;
}

// __strsep_3c_link2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c_link2(char **__s_link2, char __reject1_link2, char __reject2_link2, char __reject3_link2)
{
  char *__retval_link2 = *__s_link2;
  _Bool tmp_if_expr_2_link2;
  _Bool tmp_if_expr_3_link2;
  char *tmp_post_1_link2;
  if(!(__retval_link2 == ((char *)NULL)))
  {
    char *__cp_link2 = __retval_link2;
    for( ; (_Bool)1; __cp_link2 = __cp_link2 + 1l)
    {
      if((signed int)*__cp_link2 == 0)
      {
        __cp_link2 = (char *)(void *)0;
        break;
      }

      if(*__cp_link2 == __reject1_link2)
        tmp_if_expr_2_link2 = (_Bool)1;

      else
        tmp_if_expr_2_link2 = *__cp_link2 == __reject2_link2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2_link2)
        tmp_if_expr_3_link2 = (_Bool)1;

      else
        tmp_if_expr_3_link2 = *__cp_link2 == __reject3_link2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3_link2)
      {
        tmp_post_1_link2 = __cp_link2;
        __cp_link2 = __cp_link2 + 1l;
        *tmp_post_1_link2 = (char)0;
        break;
      }

    }
    *__s_link2 = __cp_link2;
  }

  return __retval_link2;
}

// __strsep_3c_link3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c_link3(char **__s_link3, char __reject1_link3, char __reject2_link3, char __reject3_link3)
{
  char *__retval_link3 = *__s_link3;
  _Bool tmp_if_expr_2_link3;
  _Bool tmp_if_expr_3_link3;
  char *tmp_post_1_link3;
  if(!(__retval_link3 == ((char *)NULL)))
  {
    char *__cp_link3 = __retval_link3;
    for( ; (_Bool)1; __cp_link3 = __cp_link3 + 1l)
    {
      if((signed int)*__cp_link3 == 0)
      {
        __cp_link3 = (char *)(void *)0;
        break;
      }

      if(*__cp_link3 == __reject1_link3)
        tmp_if_expr_2_link3 = (_Bool)1;

      else
        tmp_if_expr_2_link3 = *__cp_link3 == __reject2_link3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2_link3)
        tmp_if_expr_3_link3 = (_Bool)1;

      else
        tmp_if_expr_3_link3 = *__cp_link3 == __reject3_link3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3_link3)
      {
        tmp_post_1_link3 = __cp_link3;
        __cp_link3 = __cp_link3 + 1l;
        *tmp_post_1_link3 = (char)0;
        break;
      }

    }
    *__s_link3 = __cp_link3;
  }

  return __retval_link3;
}

// _applugin_rewire
// file post.c line 451
static void _applugin_rewire(void)
{
  signed int post_elements_num;
  static struct anonymous_14 **post_elements;
  post_elements=_pplugin_join_visualization_and_post_elements(&post_elements_num);
  if(!(post_elements == ((struct anonymous_14 **)NULL)))
  {
    _applugin_rewire_from_post_elements(post_elements, post_elements_num);
    free((void *)post_elements);
  }

}

// _applugin_rewire_from_post_elements
// file post.c line 351
static void _applugin_rewire_from_post_elements(struct anonymous_14 **post_elements, signed int post_elements_num)
{
  if(!(post_elements_num == 0))
  {
    struct xine_post_out_s *ao_source;
    signed int i = 0;
    i = post_elements_num - 1;
    for( ; i >= 0; i = i - 1)
    {
      const char * const *outs;
      outs=xine_post_list_outputs(post_elements[(signed long int)i]->post);
      const struct xine_post_out_s *ao_out;
      ao_out=xine_post_output(post_elements[(signed long int)i]->post, (char *)*outs);
      if(i == post_elements_num + -1)
        xine_post_wire_audio_port((struct xine_post_out_s *)ao_out, fbxine.audio_port);

      else
      {
        const struct xine_post_in_s *ao_in;
        ao_in=xine_post_input(post_elements[(signed long int)(i + 1)]->post, "audio");
        if(ao_in == ((const struct xine_post_in_s *)NULL))
          ao_in=xine_post_input(post_elements[(signed long int)(i + 1)]->post, "audio in");

        xine_post_wire((struct xine_post_out_s *)ao_out, (struct xine_post_in_s *)ao_in);
      }
    }
    ao_source=xine_get_audio_source(fbxine.stream);
    xine_post_wire_audio_port(ao_source, post_elements[(signed long int)0]->post->audio_input[(signed long int)0]);
  }

}

// _applugin_unwire
// file post.c line 311
static void _applugin_unwire(void)
{
  struct xine_post_out_s *ao_source;
  ao_source=xine_get_audio_source(fbxine.stream);
  xine_post_wire_audio_port(ao_source, fbxine.audio_port);
}

// _mkdir_safe
// file utils.c line 140
static signed int _mkdir_safe(char *path)
{
  struct stat pstat;
  if(path == ((char *)NULL))
    return 0;

  else
  {
    signed int return_value_stat_5;
    return_value_stat_5=stat(path, &pstat);
    if(!(return_value_stat_5 >= 0))
    {
      signed int return_value_mkdir_3;
      return_value_mkdir_3=mkdir(path, (unsigned int)0755);
      if(!(return_value_mkdir_3 >= 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        fprintf(stderr, "mkdir(%s) failed: %s\n", path, return_value_strerror_2);
        return 0;
      }

    }

    else
      if(!((61440u & pstat.st_mode) == 16384u))
      {
        fprintf(stderr, "%s is not a directory.\n", path);
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = 17;
        return 0;
      }

    return 1;
  }
}

// _osd_get_speed_sym
// file osd.c line 149
static const char * _osd_get_speed_sym(signed int speed)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= 6ul); i = i + 1)
    if(speed == xine_speeds[(signed long int)i].speed)
      return xine_speeds[(signed long int)i].symbol;

  return (const char *)(void *)0;
}

// _osd_get_status_sym
// file osd.c line 160
static const char * _osd_get_status_sym(signed int status)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= 4ul); i = i + 1)
    if(status == xine_status[(signed long int)i].status)
      return xine_status[(signed long int)i].symbol;

  return (const char *)(void *)0;
}

// _pplugin_join_deinterlace_and_post_elements
// file post.c line 382
static struct anonymous_14 ** _pplugin_join_deinterlace_and_post_elements(signed int *post_elements_num)
{
  struct anonymous_14 **post_elements;
  signed int i = 0;
  signed int j = 0;
  *post_elements_num = 0;
  if(!(fbxine.post_video_enable == 0))
    *post_elements_num = *post_elements_num + fbxine.post_video_elements_num;

  if(!(fbxine.deinterlace_enable == 0))
    *post_elements_num = *post_elements_num + fbxine.deinterlace_elements_num;

  if(*post_elements_num == 0)
    return (struct anonymous_14 **)(void *)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_14 *) /*8ul*/  * (unsigned long int)*post_elements_num);
    post_elements = (struct anonymous_14 **)return_value_malloc_1;
    i = 0;
    for( ; !(fbxine.deinterlace_enable == 0) && !(i >= fbxine.deinterlace_elements_num); i = i + 1)
      post_elements[(signed long int)(i + j)] = fbxine.deinterlace_elements[(signed long int)i];
    j = 0;
    for( ; !(fbxine.post_video_enable == 0) && !(j >= fbxine.post_video_elements_num); j = j + 1)
      post_elements[(signed long int)(i + j)] = fbxine.post_video_elements[(signed long int)j];
    return post_elements;
  }
}

// _pplugin_join_visualization_and_post_elements
// file post.c line 409
static struct anonymous_14 ** _pplugin_join_visualization_and_post_elements(signed int *post_elements_num)
{
  struct anonymous_14 **post_elements;
  signed int i = 0;
  signed int j = 0;
  *post_elements_num = 0;
  if(!(fbxine.post_audio_enable == 0))
    *post_elements_num = *post_elements_num + fbxine.post_audio_elements_num;

  if(*post_elements_num == 0)
    return (struct anonymous_14 **)(void *)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_14 *) /*8ul*/  * (unsigned long int)*post_elements_num);
    post_elements = (struct anonymous_14 **)return_value_malloc_1;
    j = 0;
    for( ; !(fbxine.post_audio_enable == 0) && !(j >= fbxine.post_audio_elements_num); j = j + 1)
      post_elements[(signed long int)(i + j)] = fbxine.post_audio_elements[(signed long int)j];
    return post_elements;
  }
}

// _pplugin_update_parameter
// file post.c line 87
static void _pplugin_update_parameter(struct anonymous_13 *pobj)
{
  pobj->api->set_parameters(pobj->post, (void *)pobj->param_data);
  pobj->api->get_parameters(pobj->post, (void *)pobj->param_data);
}

// _vpplugin_rewire
// file post.c line 437
static void _vpplugin_rewire(void)
{
  signed int post_elements_num;
  static struct anonymous_14 **post_elements;
  post_elements=_pplugin_join_deinterlace_and_post_elements(&post_elements_num);
  if(!(post_elements == ((struct anonymous_14 **)NULL)))
  {
    _vpplugin_rewire_from_post_elements(post_elements, post_elements_num);
    free((void *)post_elements);
  }

}

// _vpplugin_rewire_from_post_elements
// file post.c line 320
static void _vpplugin_rewire_from_post_elements(struct anonymous_14 **post_elements, signed int post_elements_num)
{
  if(!(post_elements_num == 0))
  {
    struct xine_post_out_s *vo_source;
    signed int i = 0;
    i = post_elements_num - 1;
    for( ; i >= 0; i = i - 1)
    {
      const char * const *outs;
      outs=xine_post_list_outputs(post_elements[(signed long int)i]->post);
      const struct xine_post_out_s *vo_out;
      vo_out=xine_post_output(post_elements[(signed long int)i]->post, (char *)*outs);
      if(i == post_elements_num + -1)
        xine_post_wire_video_port((struct xine_post_out_s *)vo_out, fbxine.video_port);

      else
      {
        const struct xine_post_in_s *vo_in;
        vo_in=xine_post_input(post_elements[(signed long int)(i + 1)]->post, "video");
        if(vo_in == ((const struct xine_post_in_s *)NULL))
          vo_in=xine_post_input(post_elements[(signed long int)(i + 1)]->post, "video in");

        xine_post_wire((struct xine_post_out_s *)vo_out, (struct xine_post_in_s *)vo_in);
      }
    }
    vo_source=xine_get_video_source(fbxine.stream);
    xine_post_wire_video_port(vo_source, post_elements[(signed long int)0]->post->video_input[(signed long int)0]);
  }

}

// _vpplugin_unwire
// file post.c line 302
static void _vpplugin_unwire(void)
{
  struct xine_post_out_s *vo_source;
  vo_source=xine_get_video_source(fbxine.stream);
  xine_post_wire_video_port(vo_source, fbxine.video_port);
}

// action_pause
// file actions.c line 326
static void action_pause(void)
{
  signed int return_value_xine_get_param_1;
  return_value_xine_get_param_1=xine_get_param(fbxine.stream, 1);
  xine_set_param(fbxine.stream, 1, return_value_xine_get_param_1 == 0 ? 4 : 0);
  osd_update_status();
}

// action_play
// file actions.c line 356
static void action_play(void)
{
  play(fbxine.stream, 0, 0, 0);
}

// action_seek_relative
// file actions.c line 384
static void action_seek_relative(signed int off_sec)
{
  signed int err;
  _Bool tmp_if_expr_2;
  unsigned int return_value_xine_get_stream_info_1;
  if(!(fbxine.ignore_next == 0))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_xine_get_stream_info_1=xine_get_stream_info(fbxine.stream, 1);
    tmp_if_expr_2 = !(return_value_xine_get_stream_info_1 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  signed int return_value_xine_get_status_3;
  if(tmp_if_expr_2)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_xine_get_status_3=xine_get_status(fbxine.stream);
    tmp_if_expr_4 = return_value_xine_get_status_3 != 2 ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr_4)
  {
    fbxine.ignore_next = 1;
    static unsigned long int seek_thread;
    err=pthread_create(&seek_thread, ((const union pthread_attr_t *)NULL), seek_relative_thread, (void *)(signed long int)off_sec);
    if(!(err == 0))
    {
      fprintf(stderr, "Failed to create action_seek_relative thread.\n");
      abort();
    }

  }

}

// applugin_parse_and_store_post
// file post.h line 28
void applugin_parse_and_store_post(const char *post_chain)
{
  pplugin_parse_and_store_post(0x020000, post_chain);
}

// applugin_rewire_posts
// file post.h line 26
void applugin_rewire_posts(void)
{
  _applugin_unwire();
  _applugin_rewire();
}

// atoa
// file utils.c line 89
char * atoa(char *str)
{
  char *pbuf;
  signed int quote = 0;
  signed int dblquote = 0;
  pbuf = str;
  for( ; (signed int)*pbuf == 32; pbuf = pbuf + 1l)
    ;
  if((signed int)*pbuf == 39)
    quote = 1;

  else
    if((signed int)*pbuf == 34)
      dblquote = 1;

  pbuf = str;
  for( ; !((signed int)*pbuf == 0); pbuf = pbuf + 1l)
    ;
  if(!(str >= pbuf))
    pbuf = pbuf - 1l;

  for( ; !(str >= pbuf); pbuf = pbuf - 1l)
  {
    if(!((signed int)*pbuf == 13))
    {
      if(!((signed int)*pbuf == 10))
        break;

    }

    *pbuf = (char)0;
  }
  for( ; !(str >= pbuf); pbuf = pbuf - 1l)
  {
    if(!((signed int)*pbuf == 32))
      break;

    *pbuf = (char)0;
  }
  _Bool tmp_if_expr_1;
  if(!(quote == 0))
    tmp_if_expr_1 = (signed int)*pbuf == 39 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    if(!(dblquote == 0))
      tmp_if_expr_2 = (signed int)*pbuf == 34 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    *pbuf = (char)0;
    pbuf = pbuf - 1l;
  }

  pbuf = str;
  for( ; (_Bool)1; pbuf = pbuf + 1l)
    if(!((signed int)*pbuf == 32))
    {
      if(!((signed int)*pbuf == 9))
        goto __CPROVER_DUMP_L20;

    }


__CPROVER_DUMP_L20:
  ;
  _Bool tmp_if_expr_4;
  if(!(quote == 0))
    tmp_if_expr_4 = (signed int)*pbuf == 39 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_4)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    if(!(dblquote == 0))
      tmp_if_expr_5 = (signed int)*pbuf == 34 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_6)
    pbuf = pbuf + 1l;

  return pbuf;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// change_audio_channel
// file actions.c line 406
static void change_audio_channel(void *data)
{
  signed int dir = (signed int)(signed long int)data;
  signed int channel;
  channel=xine_get_param(fbxine.stream, 3);
  if(dir == 1)
    channel = channel + 1;

  else
    if(dir == 2)
      channel = channel - 1;

    else
      if(dir == 3)
        channel = -1;

  xine_set_param(fbxine.stream, 3, channel);
  osd_display_audio_lang();
}

// change_spu
// file actions.c line 424
static void change_spu(void *data)
{
  signed int dir = (signed int)(signed long int)data;
  signed int channel;
  channel=xine_get_param(fbxine.stream, 4);
  if(dir == 1)
    channel = channel + 1;

  else
    if(dir == 2)
      channel = channel - 1;

    else
      if(dir == 3)
        channel = -1;

  xine_set_param(fbxine.stream, 4, channel);
  osd_display_spu_lang();
}

// change_zoom
// file actions.c line 443
static void change_zoom(signed int zoom_dx, signed int zoom_dy)
{
  signed int return_value_xine_get_param_1;
  return_value_xine_get_param_1=xine_get_param(fbxine.stream, 0x01000008);
  xine_set_param(fbxine.stream, 0x01000008, return_value_xine_get_param_1 + zoom_dx);
  signed int return_value_xine_get_param_2;
  return_value_xine_get_param_2=xine_get_param(fbxine.stream, 0x0100000d);
  xine_set_param(fbxine.stream, 0x0100000d, return_value_xine_get_param_2 + zoom_dy);
  osd_display_zoom();
}

// check_version
// file main.c line 86
static signed int check_version(void)
{
  signed int major;
  signed int minor;
  signed int sub;
  signed int return_value_xine_check_version_1;
  return_value_xine_check_version_1=xine_check_version(1, 0, 0);
  if(!(return_value_xine_check_version_1 == 0))
    return 1;

  else
  {
    xine_get_version(&major, &minor, &sub);
    fprintf(stderr, "Require at least xine library version 1.0.0, found %d.%d.%d.\n", major, minor, sub);
    return 0;
  }
}

// config_mrl
// file ../../src/common/config_wrapper.h line 30
void config_mrl(const char *mrl)
{
  struct xine_cfg_entry_s entry;
  char *key;
  char *config;
  char *_mrl;
  signed int return_value_xine_config_lookup_entry_1;
  return_value_xine_config_lookup_entry_1=xine_config_lookup_entry(__xineui_global_xine_instance, "misc.implicit_config", &entry);
  unsigned long int return_value_strlen_4;
  char *tmp_statement_expression_5;
  unsigned long int return_value_strlen_9;
  char *tmp_post_8;
  unsigned long int return_value_strlen_13;
  signed long int return_value_strtol_10;
  signed int return_value_get_bool_value_11;
  if(entry.num_value == 0 || return_value_xine_config_lookup_entry_1 == 0 || !(entry.type == 5))
    fprintf(stderr, "You tried to change the configuration with a cfg: MRL.\nThis is not allowed unless you enable the 'misc.implicit_config' setting after reading and understanding its help text.");

  else
  {
    char *return_value___strdup_2;
    return_value___strdup_2=__strdup(mrl);
    _mrl = return_value___strdup_2;
    char *return_value___builtin_strchr_3;
    return_value___builtin_strchr_3=__builtin_strchr(_mrl, 47);
    config = return_value___builtin_strchr_3;
    if(!(config == ((char *)NULL)))
    {
      return_value_strlen_4=strlen(config);
      if(!(return_value_strlen_4 == 0ul))
        config = config + 1l;

    }

    do
    {
      char __r0;
      char __r1;
      char __r2;
      char *return_value___strsep_g_6;
      return_value___strsep_g_6=__strsep_g(&config, ",");
      tmp_statement_expression_5 = return_value___strsep_g_6;
      key = tmp_statement_expression_5;
      if(key == ((char *)NULL))
        break;

      char *str_value;
      char *return_value___builtin_strchr_7;
      return_value___builtin_strchr_7=__builtin_strchr(key, 58);
      str_value = return_value___builtin_strchr_7;
      if(!(str_value == ((char *)NULL)))
      {
        return_value_strlen_9=strlen(str_value);
        if(!(return_value_strlen_9 == 0ul))
        {
          tmp_post_8 = str_value;
          str_value = str_value + 1l;
          *tmp_post_8 = (char)0;
        }

      }

      if(!(str_value == ((char *)NULL)))
      {
        return_value_strlen_13=strlen(str_value);
        if(!(return_value_strlen_13 == 0ul))
        {
          signed int return_value_xine_config_lookup_entry_12;
          return_value_xine_config_lookup_entry_12=xine_config_lookup_entry(__xineui_global_xine_instance, key, &entry);
          if(!(return_value_xine_config_lookup_entry_12 == 0))
          {
            if(entry.exp_level >= 30)
            {
              fprintf(stderr, "For security reason, you're not allowed to change the configuration entry named '%s'.", entry.key);
              break;
            }

            switch(entry.type)
            {
              case 2:
              {
                config_update(&entry, entry.type, 0, 0, 0, str_value);
                break;
              }
              case 1:

              case 3:

              case 4:
              {
                return_value_strtol_10=strtol(str_value, &str_value, 10);
                config_update(&entry, entry.type == 1 ? 4 : entry.type, 0, 0, (signed int)return_value_strtol_10, (char *)(void *)0);
                break;
              }
              case 5:
              {
                return_value_get_bool_value_11=get_bool_value(str_value);
                config_update(&entry, entry.type, 0, 0, return_value_get_bool_value_11, (char *)(void *)0);
                break;
              }
              case 0:

              default:
                fprintf(stderr, "WOW, key %s isn't registered\n", key);
            }
          }

        }

      }

    }
    while((_Bool)1);
    free((void *)_mrl);
  }
}

// config_update
// file config_wrapper.c line 44
static void config_update(struct xine_cfg_entry_s *entry, signed int type, signed int min, signed int max, signed int value, char *string)
{
  switch(type)
  {
    case 0:
    {
      fprintf(stderr, "Config key '%s' isn't registered yet.\n", entry->key);
      goto __CPROVER_DUMP_L7;
    }
    case 1:
    {
      entry->range_min = min;
      entry->range_max = max;
      break;
    }
    case 2:
    {
      entry->str_value = string;
      break;
    }
    case 3:

    case 4:

    case 5:
    {
      entry->num_value = value;
      break;
    }
    default:
    {
      fprintf(stderr, "Unknown config type %d\n", type);
      goto __CPROVER_DUMP_L7;
    }
  }
  xine_config_update_entry(__xineui_global_xine_instance, entry);

__CPROVER_DUMP_L7:
  ;
}

// config_update_bool
// file config_wrapper.c line 108
void config_update_bool(const char *key, signed int value)
{
  struct xine_cfg_entry_s entry;
  signed int return_value_xine_config_lookup_entry_1;
  return_value_xine_config_lookup_entry_1=xine_config_lookup_entry(__xineui_global_xine_instance, key, &entry);
  if(!(return_value_xine_config_lookup_entry_1 == 0))
    config_update(&entry, 5, 0, 0, value > 0 ? 1 : 0, (char *)(void *)0);

  else
    fprintf(stderr, "WOW, bool key %s isn't registered\n", key);
}

// config_update_enum
// file config_wrapper.c line 99
void config_update_enum(const char *key, signed int value)
{
  struct xine_cfg_entry_s entry;
  signed int return_value_xine_config_lookup_entry_1;
  return_value_xine_config_lookup_entry_1=xine_config_lookup_entry(__xineui_global_xine_instance, key, &entry);
  if(!(return_value_xine_config_lookup_entry_1 == 0))
    config_update(&entry, 3, 0, 0, value, (char *)(void *)0);

  else
    fprintf(stderr, "WOW, enum key %s isn't registered\n", key);
}

// config_update_num
// file config_wrapper.c line 117
void config_update_num(const char *key, signed int value)
{
  struct xine_cfg_entry_s entry;
  signed int return_value_xine_config_lookup_entry_1;
  return_value_xine_config_lookup_entry_1=xine_config_lookup_entry(__xineui_global_xine_instance, key, &entry);
  if(!(return_value_xine_config_lookup_entry_1 == 0))
    config_update(&entry, 4, 0, 0, value, (char *)(void *)0);

  else
    fprintf(stderr, "WOW, num key %s isn't registered\n", key);
}

// config_update_range
// file config_wrapper.c line 77
void config_update_range(const char *key, signed int min, signed int max)
{
  struct xine_cfg_entry_s entry;
  signed int return_value_xine_config_lookup_entry_1;
  return_value_xine_config_lookup_entry_1=xine_config_lookup_entry(__xineui_global_xine_instance, key, &entry);
  if(!(return_value_xine_config_lookup_entry_1 == 0))
    config_update(&entry, 1, min, max, 0, (char *)(void *)0);

  else
    fprintf(stderr, "WOW, range key %s isn't registered\n", key);
}

// config_update_string
// file config_wrapper.c line 86
void config_update_string(const char *key, char *string)
{
  struct xine_cfg_entry_s entry;
  signed int return_value_xine_config_lookup_entry_1;
  return_value_xine_config_lookup_entry_1=xine_config_lookup_entry(__xineui_global_xine_instance, key, &entry);
  if(!(string == ((char *)NULL)) && !(return_value_xine_config_lookup_entry_1 == 0))
    config_update(&entry, 2, 0, 0, 0, string);

  else
    if(string == ((char *)NULL))
      fprintf(stderr, "string is NULL\n");

    else
      fprintf(stderr, "WOW, string key %s isn't registered\n", key);
}

// default_command_action
// file actions.c line 315
signed int default_command_action(char *action_name)
{
  signed int i = 0;
  signed int return_value_strcasecmp_1;
  for( ; !(default_actions[(signed long int)i].name == ((char *)NULL)); i = i + 1)
  {
    return_value_strcasecmp_1=strcasecmp(default_actions[(signed long int)i].name, action_name);
    if(return_value_strcasecmp_1 == 0)
      return default_actions[(signed long int)i].action;

  }
  return 0;
}

// default_key_action
// file keys.c line 60
static signed int default_key_action(signed int key)
{
  if(!(key == 2117425947))
  {
    if(key == 2117491483)
      goto __CPROVER_DUMP_L2;

    if(key == 4283163)
      goto __CPROVER_DUMP_L3;

    if(key == 4348699)
      goto __CPROVER_DUMP_L4;

    if(key == 4414235)
      goto __CPROVER_DUMP_L5;

    if(key == 4479771)
      goto __CPROVER_DUMP_L6;

    if(key == 13)
      goto __CPROVER_DUMP_L7;

    if(key == 27 || key == 81 || key == 113)
      goto __CPROVER_DUMP_L8;

    if(key == 109)
      goto __CPROVER_DUMP_L9;

    if(key == 111)
      goto __CPROVER_DUMP_L10;

    if(key == 106)
      goto __CPROVER_DUMP_L11;

    if(key == 32 || key == 112)
      goto __CPROVER_DUMP_L12;

    if(key == 115)
      goto __CPROVER_DUMP_L13;

    if(key == 47)
      goto __CPROVER_DUMP_L14;

    if(key == 42)
      goto __CPROVER_DUMP_L15;

    if(key == 75)
      goto __CPROVER_DUMP_L16;

    if(key == 74)
      goto __CPROVER_DUMP_L17;

    if(key == 72)
      goto __CPROVER_DUMP_L18;

    if(key == 76)
      goto __CPROVER_DUMP_L19;

    if(key == 77)
      goto __CPROVER_DUMP_L20;

    if(key == 83)
      goto __CPROVER_DUMP_L21;

    if(key == 105)
      goto __CPROVER_DUMP_L22;

    if(key == 122)
      goto __CPROVER_DUMP_L23;

    if(key == 90)
      goto __CPROVER_DUMP_L24;

    if(key == 26)
      goto __CPROVER_DUMP_L25;

  }

  else
  {
    return 43;

  __CPROVER_DUMP_L2:
    ;
    return 42;

  __CPROVER_DUMP_L3:
    ;
    return 45;

  __CPROVER_DUMP_L4:
    ;
    return 44;

  __CPROVER_DUMP_L5:
    ;
    return 51;

  __CPROVER_DUMP_L6:
    ;
    return 50;

  __CPROVER_DUMP_L7:
    ;
    return 23;

  __CPROVER_DUMP_L8:
    ;
    return 22;

  __CPROVER_DUMP_L9:
    ;
    return 55;

  __CPROVER_DUMP_L10:
    ;
    return 85;

  __CPROVER_DUMP_L11:
    ;
    return 88;

  __CPROVER_DUMP_L12:
    ;
    return 15;

  __CPROVER_DUMP_L13:
    ;
    return 24;

  __CPROVER_DUMP_L14:
    ;
    return 63;

  __CPROVER_DUMP_L15:
    ;
    return 62;

  __CPROVER_DUMP_L16:
    ;
    return 1134;

  __CPROVER_DUMP_L17:
    ;
    return 1135;

  __CPROVER_DUMP_L18:
    ;
    return 1136;

  __CPROVER_DUMP_L19:
    ;
    return 1137;

  __CPROVER_DUMP_L20:
    ;
    return 1127;

  __CPROVER_DUMP_L21:
    ;
    return 1138;

  __CPROVER_DUMP_L22:
    ;
    return 21;

  __CPROVER_DUMP_L23:
    ;
    return 67;

  __CPROVER_DUMP_L24:
    ;
    return 68;

  __CPROVER_DUMP_L25:
    ;
    return 73;
  }
  return 0;
}

// do_action
// file actions.c line 462
void do_action(signed int action)
{
  if(!((0x400 & action) == 0))
  {
    struct anonymous_2 xine_event;
    xine_event.type = action & ~0x400;
    xine_event.data_length = 0;
    xine_event.data = NULL;
    xine_event.stream = fbxine.stream;
    gettimeofday(&xine_event.tv, (struct timezone *)(void *)0);
    xine_event_send(fbxine.stream, &xine_event);
    goto __CPROVER_DUMP_L31;
  }

  switch(action)
  {
    case 42:
    {
      action_seek_relative(-600);
      break;
    }
    case 43:
    {
      action_seek_relative(600);
      break;
    }
    case 44:
    {
      action_seek_relative(-60);
      break;
    }
    case 45:
    {
      action_seek_relative(60);
      break;
    }
    case 47:
    {
      action_seek_relative(30);
      break;
    }
    case 46:
    {
      action_seek_relative(-30);
      break;
    }
    case 49:
    {
      action_seek_relative(15);
      break;
    }
    case 48:
    {
      action_seek_relative(-15);
      break;
    }
    case 51:
    {
      action_seek_relative(10);
      break;
    }
    case 50:
    {
      action_seek_relative(-10);
      break;
    }
    case 52:
    {
      action_seek_relative(-7);
      break;
    }
    case 53:
    {
      action_seek_relative(7);
      break;
    }
    case 11:
    {
      change_audio_channel((void *)1);
      break;
    }
    case 12:
    {
      change_audio_channel((void *)2);
      break;
    }
    case 13:
    {
      change_audio_channel((void *)3);
      break;
    }
    case 6:
    {
      change_spu((void *)1);
      break;
    }
    case 7:
    {
      change_spu((void *)2);
      break;
    }
    case 8:
    {
      change_spu((void *)3);
      break;
    }
    case 85:
    {
      osd_stream_infos();
      break;
    }
    case 86:
    {
      if(!(gParameter.alphanum.set == 0))
        osd_display_info("%s", gParameter.alphanum.arg);

      else
        osd_display_info("No text to display!");
      break;
    }
    case 15:
    {
      action_pause();
      break;
    }
    case 23:
    {
      action_play();
      break;
    }
    case 22:
    {
      fbxine_exit();
      break;
    }
    case 67:
    {
      change_zoom(5, 5);
      break;
    }
    case 68:
    {
      change_zoom(-5, -5);
      break;
    }
    case 73:
    {
      reset_zoom();
      break;
    }
    case 21:
    {
      fbxine.deinterlace_enable = (signed int)!(fbxine.deinterlace_enable != 0);
      osd_display_info("Deinterlace: %s", fbxine.deinterlace_enable != 0 ? "enabled" : "disabled");
      post_deinterlace();
    }
  }

__CPROVER_DUMP_L31:
  ;
}

// do_getc
// file keys.c line 48
static signed int do_getc(void)
{
  unsigned char c[4l];
  signed int n;
  signed int i;
  signed int k;
  signed long int return_value_read_1;
  return_value_read_1=read(fbxine.tty_fd, (void *)c, (unsigned long int)4);
  n = (signed int)return_value_read_1;
  k = 0;
  i = 0;
  for( ; !(i >= n); i = i + 1)
    k = k | (signed int)c[(signed long int)i] << (i << 3);
  return k;
}

// dump_cpu_infos
// file dump.c line 63
void dump_cpu_infos(void)
{
  struct _IO_FILE *stream;
  char buffer[2048l];
  stream=fopen("/proc/cpuinfo", "r");
  unsigned long int return_value_fread_1;
  char *tmp_statement_expression_2;
  unsigned long int return_value_strlen_4;
  signed int *return_value___errno_location_5;
  char *return_value_strerror_6;
  if(!(stream == ((struct _IO_FILE *)NULL)))
  {
    printf("   CPU information:\n");
    printf("   ---------------\n");
    memset((void *)&buffer, 0, sizeof(char [2048l]) /*2048ul*/ );
    do
    {
      return_value_fread_1=fread((void *)&buffer, (unsigned long int)1, (unsigned long int)2047, stream);
      if(return_value_fread_1 == 0ul)
        break;

      char *p;
      char *pp = buffer;
      do
      {
        char __r0;
        char __r1;
        char __r2;
        char *return_value___strsep_g_3;
        return_value___strsep_g_3=__strsep_g(&pp, "\n");
        tmp_statement_expression_2 = return_value___strsep_g_3;
        p = tmp_statement_expression_2;
        if(p == ((char *)NULL))
          break;

        if(!(p == ((char *)NULL)))
        {
          return_value_strlen_4=strlen(p);
          if(!(return_value_strlen_4 == 0ul))
            printf("\t%s\n", p);

        }

      }
      while((_Bool)1);
      memset((void *)&buffer, 0, sizeof(char [2048l]) /*2048ul*/ );
    }
    while((_Bool)1);
    printf("   -------\n");
    fclose(stream);
  }

  else
  {
    return_value___errno_location_5=__errno_location();
    return_value_strerror_6=strerror(*return_value___errno_location_5);
    printf("   Unable to open '/proc/cpuinfo': '%s'.\n", return_value_strerror_6);
  }
}

// dump_error
// file dump.c line 97
void dump_error(const char *msg)
{
  if(!(__xineui_global_verbosity == 0))
  {
    fprintf(stderr, "%s", (const void *)"\n---------------------- (ERROR) ----------------------\n");
    fputs(msg, stderr);
    fprintf(stderr, "%s", (const void *)"\n------------------ (END OF ERROR) -------------------\n\n");
  }

}

// dump_host_info
// file dump.c line 40
void dump_host_info(void)
{
  struct utsname uts;
  signed int return_value_uname_3;
  return_value_uname_3=uname(&uts);
  if(return_value_uname_3 == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    printf("uname() failed: %s\n", return_value_strerror_2);
  }

  else
  {
    printf("   Platform information:\n");
    printf("   --------------------\n");
    printf("        system name     : %s\n", (const void *)uts.sysname);
    printf("        node name       : %s\n", (const void *)uts.nodename);
    printf("        release         : %s\n", (const void *)uts.release);
    printf("        version         : %s\n", (const void *)uts.version);
    printf("        machine         : %s\n", (const void *)uts.machine);
  }
}

// dump_info
// file dump.c line 105
void dump_info(const char *msg)
{
  if(!(__xineui_global_verbosity == 0))
  {
    fprintf(stderr, "%s", (const void *)"\n---------------------- (INFO) ----------------------\n");
    fputs(msg, stderr);
    fprintf(stderr, "%s", (const void *)"\n------------------- (END OF INFO) ------------------\n\n");
  }

}

// event_listener
// file main.c line 99
static void event_listener(void *user_data, const struct anonymous_2 *event)
{
  if(event->type == 1)
  {
    pthread_mutex_lock(&fbxine.mutex);
    pthread_cond_signal(&fbxine.exit_cond);
    pthread_mutex_unlock(&fbxine.mutex);
  }

}

// exit_audio
// file main.c line 166
static void exit_audio(void)
{
  xine_close_audio_driver(__xineui_global_xine_instance, fbxine.audio_port);
}

// exit_keyboard
// file keys.c line 119
static void exit_keyboard(void)
{
  if(!(fbxine.keyboard_thread == 0ul))
    pthread_cancel(fbxine.keyboard_thread);

  tcsetattr(fbxine.tty_fd, 0, &fbxine.ti_save);
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(fbxine.tty_fd, (unsigned long int)0x4B3A, 0x00);
  if(return_value_ioctl_1 == -1)
    perror("Failed to set /dev/tty to text mode");

  close(fbxine.tty_fd);
}

// exit_lirc
// file lirc.c line 71
static void exit_lirc(void)
{
  pthread_cancel(fbxine.lirc.thread);
  lirc_freeconfig(fbxine.lirc.config);
  lirc_deinit();
}

// exit_stdctl
// file stdctl.c line 160
static void exit_stdctl(void)
{
  pthread_cancel(stdctl_link1.thread);
  pthread_join(stdctl_link1.thread, (void **)(void *)0);
}

// exit_stream
// file main.c line 194
static void exit_stream(void)
{
  xine_close(fbxine.stream);
  xine_event_dispose_queue(fbxine.event_queue);
  xine_dispose(fbxine.stream);
}

// exit_video
// file main.c line 133
static void exit_video(void)
{
  xine_close_video_driver(__xineui_global_xine_instance, fbxine.video_port);
}

// exit_xine
// file main.c line 219
static void exit_xine(void)
{
  xine_exit(__xineui_global_xine_instance);
}

// extract_mrls
// file options.c line 47
static void extract_mrls(signed int num_mrls, char **mrls)
{
  signed int i = 0;
  for( ; !(i >= num_mrls); i = i + 1)
    fbxine.mrl[(signed long int)i] = mrls[(signed long int)i];
  fbxine.num_mrls = num_mrls;
  fbxine.current_mrl = 0;
}

// fbxine_do_abort
// file callback.h line 35
void fbxine_do_abort(void)
{
  struct fbxine_callback *tmp = fbxine_fifo_abort;
  fbxine_fifo_abort = ((struct fbxine_callback *)NULL);
  fbxine_do_callbacks(tmp);
  exit(1);
}

// fbxine_do_callbacks
// file callback.c line 39
static void fbxine_do_callbacks(struct fbxine_callback *callback)
{
  if(!(callback == ((struct fbxine_callback *)NULL)))
  {
    callback->func();
    callback = callback->next;
  }

}

// fbxine_do_exit
// file callback.h line 34
void fbxine_do_exit(void)
{
  struct fbxine_callback *tmp = fbxine_fifo_exit;
  fbxine_fifo_exit = ((struct fbxine_callback *)NULL);
  fbxine_do_callbacks(tmp);
}

// fbxine_exit
// file main.c line 246
void fbxine_exit(void)
{
  osd_deinit();
  pthread_mutex_lock(&fbxine.mutex);
  fbxine.current_mrl = fbxine.num_mrls;
  pthread_cond_signal(&fbxine.exit_cond);
  pthread_mutex_unlock(&fbxine.mutex);
}

// fbxine_init
// file main.c line 255
static signed int fbxine_init(signed int argc, char **argv)
{
  signed int return_value_check_version_1;
  return_value_check_version_1=check_version();
  signed int return_value_fbxine_init_keyboard_4;
  if(return_value_check_version_1 == 0)
    return 0;

  else
  {
    signed int return_value_init_xine_2;
    return_value_init_xine_2=init_xine();
    if(return_value_init_xine_2 == 0)
      return 0;

    else
    {
      signed int return_value_parse_options_3;
      return_value_parse_options_3=parse_options(argc, argv);
      if(return_value_parse_options_3 == 0 || return_value_parse_options_3 == -1)
        return 0;

      if(!(stdctl == 0))
        fbxine_init_stdctl();

      else
      {
        return_value_fbxine_init_keyboard_4=fbxine_init_keyboard();
        if(return_value_fbxine_init_keyboard_4 == 0)
          return 0;

      }
      signed int return_value_init_video_5;
      return_value_init_video_5=init_video();
      if(return_value_init_video_5 == 0)
        return 0;

      else
      {
        signed int return_value_init_audio_6;
        return_value_init_audio_6=init_audio();
        if(return_value_init_audio_6 == 0)
          return 0;

        else
        {
          signed int return_value_init_stream_7;
          return_value_init_stream_7=init_stream();
          if(return_value_init_stream_7 == 0)
            return 0;

          else
          {
            if(no_lirc == 0)
              fbxine_init_lirc();

            if(!(pplugins_num == 0))
            {
              char **plugin = pplugins;
              for( ; !(*plugin == ((char *)NULL)); plugin = plugin + 1l)
              {
                vpplugin_parse_and_store_post((const char *)*plugin);
                applugin_parse_and_store_post((const char *)*plugin);
                printf("1\n");
              }
              vpplugin_rewire_posts();
              applugin_rewire_posts();
            }

            post_deinterlace_init((const char *)(void *)0);
            if(!(fbxine.deinterlace_enable == 0))
              post_deinterlace();

            osd_init();
            fbxine.osd.enabled = 1;
            return 1;
          }
        }
      }
    }
  }
}

// fbxine_init_keyboard
// file keys.h line 26
signed int fbxine_init_keyboard(void)
{
  static struct fbxine_callback exit_callback;
  fbxine_register_exit(&exit_callback, (void (*)(void))exit_keyboard);
  fbxine_register_abort(&exit_callback, (void (*)(void))exit_keyboard);
  signed int return_value_isatty_1;
  return_value_isatty_1=isatty(0);
  if(!(return_value_isatty_1 == 0))
    fbxine.tty_fd=dup(0);

  else
    fbxine.tty_fd=open("/dev/tty", 02);
  if(fbxine.tty_fd == -1)
  {
    perror("Failed to open /dev/tty");
    return 0;
  }

  else
  {
    fcntl(fbxine.tty_fd, 2, 1);
    signed int return_value_ioctl_2;
    return_value_ioctl_2=ioctl(fbxine.tty_fd, (unsigned long int)0x4B3A, 0x01);
    if(return_value_ioctl_2 == -1)
      perror("Failed to set /dev/tty to graphics mode");

    tcgetattr(fbxine.tty_fd, &fbxine.ti_save);
    fbxine.ti_cur = fbxine.ti_save;
    fbxine.ti_cur.c_cc[(signed long int)6] = (unsigned char)1;
    fbxine.ti_cur.c_cc[(signed long int)5] = (unsigned char)0;
    fbxine.ti_cur.c_iflag = fbxine.ti_cur.c_iflag & (unsigned int)~(0000001 | 0000002 | 0000010 | 0000040 | 0000100 | 0000200 | 0000400 | 0002000);
    fbxine.ti_cur.c_lflag = fbxine.ti_cur.c_lflag & (unsigned int)~(0000010 | 0000100 | 0000001 | 0000002);
    signed int return_value_tcsetattr_3;
    return_value_tcsetattr_3=tcsetattr(fbxine.tty_fd, 2, &fbxine.ti_cur);
    if(return_value_tcsetattr_3 == -1)
    {
      perror("Failed to change terminal attributes");
      close(fbxine.tty_fd);
      return 0;
    }

    else
    {
      pthread_create(&fbxine.keyboard_thread, ((const union pthread_attr_t *)NULL), fbxine_keyboard_loop, NULL);
      return 1;
    }
  }
}

// fbxine_init_lirc
// file lirc.c line 79
signed int fbxine_init_lirc(void)
{
  fbxine.lirc.fd=lirc_init("xine", 0);
  if(fbxine.lirc.fd == -1)
    return 0;

  else
  {
    signed int return_value_lirc_readconfig_1;
    return_value_lirc_readconfig_1=lirc_readconfig(((char *)NULL), &fbxine.lirc.config, ((signed int (*)(char *))NULL));
    if(!(return_value_lirc_readconfig_1 == 0))
      return 0;

    else
    {
      static struct fbxine_callback exit_callback;
      fbxine_register_exit(&exit_callback, (void (*)(void))exit_lirc);
      pthread_create(&fbxine.lirc.thread, ((const union pthread_attr_t *)NULL), lirc_loop, NULL);
      return 1;
    }
  }
}

// fbxine_init_stdctl
// file stdctl.h line 35
void fbxine_init_stdctl(void)
{
  stdctl_link1.fd = 0;
  static struct fbxine_callback exit_callback;
  fbxine_register_exit(&exit_callback, (void (*)(void))exit_stdctl);
  pthread_create(&stdctl_link1.thread, (const union pthread_attr_t *)(void *)0, xine_stdctl_loop, (void *)0);
}

// fbxine_keyboard_loop
// file keys.c line 107
static void * fbxine_keyboard_loop(void *dummy)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  pthread_detach(return_value_pthread_self_1);
  do
  {
    pthread_testcancel();
    signed int return_value_do_getc_2;
    return_value_do_getc_2=do_getc();
    signed int return_value_default_key_action_3;
    return_value_default_key_action_3=default_key_action(return_value_do_getc_2);
    do_action(return_value_default_key_action_3);
  }
  while((_Bool)1);
  pthread_exit((void *)0);
}

// fbxine_register_abort
// file callback.h line 32
void fbxine_register_abort(struct fbxine_callback *callback, void (*func)(void))
{
  fbxine_register_callback(&fbxine_fifo_abort, callback, func);
}

// fbxine_register_callback
// file callback.c line 30
static void fbxine_register_callback(struct fbxine_callback **top, struct fbxine_callback *callback, void (*func)(void))
{
  callback->next = *top;
  *top = callback;
  callback->func = func;
}

// fbxine_register_exit
// file callback.h line 30
void fbxine_register_exit(struct fbxine_callback *callback, void (*func)(void))
{
  fbxine_register_callback(&fbxine_fifo_exit, callback, func);
}

// get_bool_value
// file utils.c line 192
signed int get_bool_value(const char *val)
{
  signed int i;
  if(!(val == ((const char *)NULL)))
  {
    i = 0;
    for( ; !((unsigned long int)i >= 8ul); i = i + 1)
    {
      signed int return_value_strcasecmp_1;
      /* tag-#anon#clST[lARR7{S8}_S8_'str'||S8'value'|] */
struct anonymous_8
{
  // str
  char str[7l];
  // value
  char value;
};

/* */
      ;
      static struct anonymous_8 bools[8l] = { { .str={ '1', 0, 0, 0, 0, 0, 0 }, .value=(char)1 },
    { .str={ 't', 'r', 'u', 'e', 0, 0, 0 }, .value=(char)1 },
    { .str={ 'y', 'e', 's', 0, 0, 0, 0 }, .value=(char)1 },
    { .str={ 'o', 'n', 0, 0, 0, 0, 0 }, .value=(char)1 },
    { .str={ '0', 0, 0, 0, 0, 0, 0 }, .value=(char)0 },
    { .str={ 'f', 'a', 'l', 's', 'e', 0, 0 }, .value=(char)0 },
    { .str={ 'n', 'o', 0, 0, 0, 0, 0 }, .value=(char)0 },
    { .str={ 'o', 'f', 'f', 0, 0, 0, 0 }, .value=(char)0 } };
      return_value_strcasecmp_1=strcasecmp(bools[(signed long int)i].str, val);
      if(return_value_strcasecmp_1 == 0)
        return (signed int)bools[(signed long int)i].value;

    }
  }

  return 0;
}

// get_last_double_semicolon
// file utils.c line 212
const char * get_last_double_semicolon(const char *str)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  if(!(str == ((const char *)NULL)))
  {
    return_value_strlen_1=strlen(str);
    len = (signed int)return_value_strlen_1;
    if(!(len == 0))
    {
      const char *p = str + (signed long int)(len - 1);
      for( ; !(str >= p); p = p - 1l)
        if((signed int)*p == 58)
        {
          if((signed int)p[-1l] == 58)
            return p - (signed long int)1;

        }

    }

  }

  return (const char *)(void *)0;
}

// get_pos_length
// file actions.c line 334
signed int get_pos_length(struct xine_stream_s *stream, signed int *pos, signed int *time, signed int *length)
{
  signed int t = 0;
  signed int ret = 0;
  signed int return_value_xine_get_status_2;
  _Bool tmp_if_expr_1;
  if(!(stream == ((struct xine_stream_s *)NULL)))
  {
    return_value_xine_get_status_2=xine_get_status(stream);
    if(return_value_xine_get_status_2 == 2)
      do
      {
        ret=xine_get_pos_length(stream, pos, time, length);
        if(!(ret == 0))
          tmp_if_expr_1 = (_Bool)1;

        else
        {
          t = t + 1;
          tmp_if_expr_1 = 10 < t ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_1)
          break;

        xine_usec_sleep((unsigned int)100000);
      }
      while((_Bool)1);

  }

  return ret;
}

// init_audio
// file main.c line 171
static signed int init_audio(void)
{
  static struct fbxine_callback exit_callback;
  fbxine_register_exit(&exit_callback, (void (*)(void))exit_audio);
  if(fbxine.audio_port_id == ((const char *)NULL))
    fbxine.audio_port_id=xine_config_register_string(__xineui_global_xine_instance, "audio.driver", "oss", "audio driver to use", ((const char *)NULL), 20, ((void (*)(void *, struct xine_cfg_entry_s *))NULL), NULL);

  fbxine.audio_port=xine_open_audio_driver(__xineui_global_xine_instance, fbxine.audio_port_id, NULL);
  if(fbxine.audio_port == ((struct xine_audio_port_s *)NULL))
  {
    fprintf(stderr, "Audio port failed.\n");
    return 0;
  }

  else
    return 1;
}

// init_stream
// file main.c line 201
static signed int init_stream(void)
{
  static struct fbxine_callback exit_callback;
  fbxine_register_exit(&exit_callback, (void (*)(void))exit_stream);
  fbxine.stream=xine_stream_new(__xineui_global_xine_instance, fbxine.audio_port, fbxine.video_port);
  xine_set_param(fbxine.stream, 11, __xineui_global_verbosity);
  fbxine.event_queue=xine_event_new_queue(fbxine.stream);
  xine_event_create_listener_thread(fbxine.event_queue, event_listener, (void *)0);
  return 1;
}

// init_video
// file main.c line 138
static signed int init_video(void)
{
  static struct fbxine_callback exit_callback;
  fbxine_register_exit(&exit_callback, (void (*)(void))exit_video);
  signed int tmp_statement_expression_3;
  unsigned long int init_video__1__1____s1_len;
  unsigned long int init_video__1__1____s2_len;
  signed int return_value___builtin_strcmp_4;
  return_value___builtin_strcmp_4=__builtin_strcmp(fbxine.video_port_id, "dxr3");
  tmp_statement_expression_3 = return_value___builtin_strcmp_4;
  signed int tmp_statement_expression_1;
  if(tmp_statement_expression_3 == 0)
    fbxine.video_port=xine_open_video_driver(__xineui_global_xine_instance, fbxine.video_port_id, 1, (void *)0);

  else
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(fbxine.video_port_id, "none");
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    if(tmp_statement_expression_1 == 0)
      fbxine.video_port=xine_open_video_driver(__xineui_global_xine_instance, fbxine.video_port_id, 0, (void *)0);

    else
      fbxine.video_port=xine_open_video_driver(__xineui_global_xine_instance, fbxine.video_port_id, 3, (void *)0);
  }
  if(fbxine.video_port == ((struct xine_video_port_s *)NULL))
  {
    fprintf(stderr, "Video port failed.\n");
    return 0;
  }

  else
    return 1;
}

// init_xine
// file main.c line 224
static signed int init_xine(void)
{
  static struct fbxine_callback exit_callback;
  fbxine_register_exit(&exit_callback, (void (*)(void))exit_xine);
  __xineui_global_xine_instance=xine_new();
  if(__xineui_global_xine_instance == ((struct xine_s *)NULL))
  {
    fprintf(stderr, "Failed to call xine_new.\n");
    return 0;
  }

  else
  {
    load_config();
    xine_init(__xineui_global_xine_instance);
    return 1;
  }
}

// install_abort
// file main.c line 310
static void install_abort(void)
{
  unsigned long int i = (unsigned long int)0;
  static const signed int trapped[11l] = { 2, 3, 4, 8, 9, 7, 11, 31, 13, 15, 16 };
  for( ; !(i >= 11ul); i = i + 1ul)
    signal(trapped[(signed long int)i], (void (*)(signed int))fbxine_do_abort);
}

// is_a_dir
// file utils.c line 321
signed int is_a_dir(char *filename)
{
  struct stat pstat;
  signed int return_value_stat_1;
  return_value_stat_1=stat(filename, &pstat);
  if(!(return_value_stat_1 >= 0))
    return 0;

  else
    return (signed int)((pstat.st_mode & (unsigned int)0170000) == (unsigned int)0040000);
}

// is_a_file
// file utils.c line 330
signed int is_a_file(char *filename)
{
  struct stat pstat;
  signed int return_value_stat_1;
  return_value_stat_1=stat(filename, &pstat);
  if(!(return_value_stat_1 >= 0))
    return 0;

  else
    return (signed int)((pstat.st_mode & (unsigned int)0170000) == (unsigned int)0100000);
}

// is_downloadable
// file utils.c line 314
signed int is_downloadable(char *filename)
{
  signed int return_value_strncasecmp_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strncasecmp_2;
  if(!(filename == ((char *)NULL)))
  {
    return_value_strncasecmp_1=strncasecmp(filename, "http://", (unsigned long int)7);
    if(return_value_strncasecmp_1 == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strncasecmp_2=strncasecmp(filename, "ftp://", (unsigned long int)6);
      tmp_if_expr_3 = !(return_value_strncasecmp_2 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_3)
      goto __CPROVER_DUMP_L3;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    return 0;
  }
}

// is_ipv6_last_double_semicolon
// file utils.c line 230
signed int is_ipv6_last_double_semicolon(const char *str)
{
  unsigned long int return_value_strlen_3;
  const unsigned short int **return_value___ctype_b_loc_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  if(!(str == ((const char *)NULL)))
  {
    return_value_strlen_3=strlen(str);
    if(!(return_value_strlen_3 == 0ul))
    {
      const char *d_semic;
      d_semic=get_last_double_semicolon(str);
      if(!(d_semic == ((const char *)NULL)))
      {
        const char *bracketl = (const char *)(void *)0;
        const char *bracketr = (const char *)(void *)0;
        const char *p = d_semic + (signed long int)2;
        for( ; !(*p == 0); p = p + 1l)
        {
          if(!(bracketr == ((const char *)NULL)))
            break;

          if((signed int)*p == 93)
            bracketr = p;

        }
        if(!(bracketr == ((const char *)NULL)))
        {
          p = d_semic;
          for( ; bracketl == ((const char *)NULL) && p >= str; p = p - 1l)
            if((signed int)*p == 91)
              bracketl = p;

          if(!(bracketl == ((const char *)NULL)))
          {
            p = d_semic + (signed long int)2;
            for( ; !(*p == 0); p = p + 1l)
              switch((signed int)*p)
              {
                case 58:

                case 46:
                  break;
                case 93:
                {
                  p = d_semic;
                  for( ; p >= str; p = p - 1l)
                    switch((signed int)*p)
                    {
                      case 58:
                        break;
                      case 46:
                        return 0;
                      case 91:
                        return 1;
                      default:
                      {
                        return_value___ctype_b_loc_1=__ctype_b_loc();
                        if((4096 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*p]) == 0)
                          return 0;

                      }
                    }
                  break;
                }
                default:
                {
                  return_value___ctype_b_loc_2=__ctype_b_loc();
                  if((4096 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*p]) == 0)
                    return 0;

                }
              }
          }

        }

      }

    }

  }

  return 0;
}

// lirc_loop
// file lirc.c line 39
static void * lirc_loop(void *dummy)
{
  char *code;
  char *c;
  signed int k;
  signed int ret;
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  pthread_detach(return_value_pthread_self_1);
  signed int return_value_lirc_nextcode_2;
  do
  {
    return_value_lirc_nextcode_2=lirc_nextcode(&code);
    if(!(return_value_lirc_nextcode_2 == 0))
      break;

    pthread_testcancel();
    if(!(code == ((char *)NULL)))
    {
      do
      {
        ret=lirc_code2char(fbxine.lirc.config, code, &c);
        if(c == ((char *)NULL) || !(ret == 0))
          break;

        k=default_command_action(c);
        if(!(k == 0))
          do_action(k);

      }
      while((_Bool)1);
      free((void *)code);
      if(ret == -1)
        break;

    }

  }
  while((_Bool)1);
  pthread_exit(NULL);
}

// load_config
// file main.c line 67
static void load_config(void)
{
  __xineui_global_config_file=getenv("XINERC");
  if(__xineui_global_config_file == ((char *)NULL))
  {
    const char *return_value_xine_get_homedir_1;
    return_value_xine_get_homedir_1=xine_get_homedir();
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(return_value_xine_get_homedir_1);
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(".xine");
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen("config");
    void *return_value_malloc_5;
    return_value_malloc_5=malloc(return_value_strlen_2 + return_value_strlen_3 + return_value_strlen_4 + (unsigned long int)3);
    __xineui_global_config_file = (char *)return_value_malloc_5;
    const char *return_value_xine_get_homedir_6;
    return_value_xine_get_homedir_6=xine_get_homedir();
    sprintf(__xineui_global_config_file, "%s/%s", return_value_xine_get_homedir_6, (const void *)".xine");
    mkdir(__xineui_global_config_file, (unsigned int)0755);
    unsigned long int return_value_strlen_7;
    return_value_strlen_7=strlen(__xineui_global_config_file);
    sprintf(__xineui_global_config_file + (signed long int)return_value_strlen_7, "/%s", (const void *)"config");
  }

  xine_config_load(__xineui_global_xine_instance, __xineui_global_config_file);
  xine_engine_set_param(__xineui_global_xine_instance, 1, __xineui_global_verbosity);
}

// main
// file main.c line 327
signed int main(signed int argc, char **argv)
{
  signed int exit_code = 1;
  install_abort();
  pthread_mutex_lock(&fbxine.mutex);
  signed int return_value_fbxine_init_2;
  return_value_fbxine_init_2=fbxine_init(argc, argv);
  if(!(return_value_fbxine_init_2 == 0))
  {
    while(!(fbxine.current_mrl >= fbxine.num_mrls))
    {
      signed int return_value_open_and_play_1;
      return_value_open_and_play_1=open_and_play(fbxine.mrl[(signed long int)fbxine.current_mrl]);
      if(!(return_value_open_and_play_1 == 0))
      {
        wait_for_exit();
        xine_close(fbxine.stream);
      }

      fbxine.current_mrl = fbxine.current_mrl + 1;
    }
    exit_code = 0;
  }

  fbxine_do_exit();
  pthread_mutex_unlock(&fbxine.mutex);
  return exit_code;
}

// mkdir_safe
// file utils.c line 168
signed int mkdir_safe(char *path)
{
  char *p;
  char *pp;
  char buf[4352l];
  char buf2[4352l];
  char *tmp_statement_expression_1;
  unsigned long int return_value_strlen_5;
  if(path == ((char *)NULL))
    return 0;

  else
  {
    memset((void *)&buf, 0, sizeof(char [4352l]) /*4352ul*/ );
    memset((void *)&buf2, 0, sizeof(char [4352l]) /*4352ul*/ );
    strcpy(buf, path);
    pp = buf;
    do
    {
      char __r0;
      char __r1;
      char __r2;
      char *return_value___strsep_g_2;
      return_value___strsep_g_2=__strsep_g(&pp, "/");
      tmp_statement_expression_1 = return_value___strsep_g_2;
      p = tmp_statement_expression_1;
      if(p == ((char *)NULL))
        break;

      if(!(p == ((char *)NULL)))
      {
        return_value_strlen_5=strlen(p);
        if(!(return_value_strlen_5 == 0ul))
        {
          unsigned long int return_value_strlen_3;
          return_value_strlen_3=strlen(buf2);
          sprintf(buf2 + (signed long int)return_value_strlen_3, "/%s", p);
          signed int return_value__mkdir_safe_4;
          return_value__mkdir_safe_4=_mkdir_safe(buf2);
          if(return_value__mkdir_safe_4 == 0)
            return 0;

        }

      }

    }
    while((_Bool)1);
    return 1;
  }
}

// open_and_play
// file main.c line 113
static signed int open_and_play(const char *mrl)
{
  signed int return_value_strncasecmp_1;
  return_value_strncasecmp_1=strncasecmp(mrl, "cfg:/", (unsigned long int)5);
  _Bool tmp_if_expr_4;
  signed int return_value_xine_play_3;
  if(return_value_strncasecmp_1 == 0)
  {
    config_mrl(mrl);
    return 0;
  }

  else
  {
    signed int return_value_xine_open_2;
    return_value_xine_open_2=xine_open(fbxine.stream, fbxine.mrl[(signed long int)fbxine.current_mrl]);
    if(return_value_xine_open_2 == 0)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_xine_play_3=xine_play(fbxine.stream, 0, 0);
      tmp_if_expr_4 = !(return_value_xine_play_3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      fprintf(stderr, "Unable to open MRL '%s'\n", fbxine.mrl[(signed long int)fbxine.current_mrl]);
      return 0;
    }

    else
      return 1;
  }
}

// osd_deinit
// file osd.h line 33
void osd_deinit(void)
{
  pthread_cancel(fbxine.osd_thread);
  if(!(fbxine.osd.sinfo_visible == 0))
  {
    fbxine.osd.sinfo_visible = 0;
    xine_osd_hide(fbxine.osd.sinfo, (signed long int)0);
  }

  if(!(fbxine.osd.bar_visible == 0))
  {
    fbxine.osd.bar_visible = 0;
    xine_osd_hide(fbxine.osd.bar[(signed long int)0], (signed long int)0);
    xine_osd_hide(fbxine.osd.bar[(signed long int)1], (signed long int)0);
  }

  if(!(fbxine.osd.status_visible == 0))
  {
    fbxine.osd.status_visible = 0;
    xine_osd_hide(fbxine.osd.status, (signed long int)0);
  }

  if(!(fbxine.osd.info_visible == 0))
  {
    fbxine.osd.info_visible = 0;
    xine_osd_hide(fbxine.osd.info, (signed long int)0);
  }

  xine_osd_free(fbxine.osd.sinfo);
  xine_osd_free(fbxine.osd.bar[(signed long int)0]);
  xine_osd_free(fbxine.osd.bar[(signed long int)1]);
  xine_osd_free(fbxine.osd.status);
  xine_osd_free(fbxine.osd.info);
}

// osd_display_audio_lang
// file osd.h line 35
void osd_display_audio_lang(void)
{
  char buffer[32l];
  char lang_buffer[32l];
  char *lang = (char *)(void *)0;
  signed int channel;
  channel=xine_get_param(fbxine.stream, 3);
  signed int return_value_xine_get_audio_lang_1;
  if(!(channel == -2))
  {
    if(channel == -1)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    lang = "off";
    goto __CPROVER_DUMP_L7;

  __CPROVER_DUMP_L2:
    ;
    return_value_xine_get_audio_lang_1=xine_get_audio_lang(fbxine.stream, channel, &lang_buffer[(signed long int)0]);
    if(return_value_xine_get_audio_lang_1 == 0)
      lang = "auto";

    else
      lang = lang_buffer;
    goto __CPROVER_DUMP_L7;
  }
  signed int return_value_xine_get_audio_lang_2;
  return_value_xine_get_audio_lang_2=xine_get_audio_lang(fbxine.stream, channel, &lang_buffer[(signed long int)0]);
  if(return_value_xine_get_audio_lang_2 == 0)
    sprintf(lang_buffer, "%3d", channel);

  lang = lang_buffer;
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
  sprintf(buffer, "Audio Channel: %s", lang);
  osd_display_info("%s", (const void *)buffer);
}

// osd_display_info
// file osd.h line 39
void osd_display_info(char *info, ...)
{
  if(!(fbxine.osd.enabled == 0))
  {
    void **args;
    char *buf;
    signed int n;
    signed int size = 100;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)size);
    buf = (char *)return_value_malloc_1;
    if(!(buf == ((char *)NULL)))
    {
      while((_Bool)1)
      {
        args = (void **)&info;
        n=vsnprintf(buf, (unsigned long int)size, info, args);
        args = ((void **)NULL);
        if(n >= 0 && !(n >= size))
          break;

        if(n >= 0)
          size = n + 1;

        else
          size = size * 2;
        void *return_value_realloc_2;
        return_value_realloc_2=realloc((void *)buf, (unsigned long int)size);
        buf = (char *)return_value_realloc_2;
        if(buf == ((char *)NULL))
          goto __CPROVER_DUMP_L9;

      }
      xine_osd_clear(fbxine.osd.info);
      xine_osd_draw_text(fbxine.osd.info, 0, 0, buf, 0 * 11);
      xine_osd_set_position(fbxine.osd.info, 20, 10 + 30);
      unsigned int return_value_xine_osd_get_capabilities_3;
      return_value_xine_osd_get_capabilities_3=xine_osd_get_capabilities(fbxine.osd.info);
      if(!((2u & return_value_xine_osd_get_capabilities_3) == 0u))
        xine_osd_show_unscaled(fbxine.osd.info, (signed long int)0);

      else
        xine_osd_show(fbxine.osd.info, (signed long int)0);
      fbxine.osd.info_visible = fbxine.osd.timeout;
      do
      {
        free((void *)buf);
        buf = (char *)(void *)0;
      }
      while((_Bool)0);
    }

  }


__CPROVER_DUMP_L9:
  ;
}

// osd_display_spu_lang
// file osd.h line 34
void osd_display_spu_lang(void)
{
  char buffer[32l];
  char lang_buffer[32l];
  char *lang = (char *)(void *)0;
  signed int channel;
  channel=xine_get_param(fbxine.stream, 4);
  signed int return_value_xine_get_spu_lang_1;
  if(!(channel == -2))
  {
    if(channel == -1)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    lang = "off";
    goto __CPROVER_DUMP_L7;

  __CPROVER_DUMP_L2:
    ;
    return_value_xine_get_spu_lang_1=xine_get_spu_lang(fbxine.stream, channel, &lang_buffer[(signed long int)0]);
    if(return_value_xine_get_spu_lang_1 == 0)
      lang = "auto";

    else
      lang = lang_buffer;
    goto __CPROVER_DUMP_L7;
  }
  signed int return_value_xine_get_spu_lang_2;
  return_value_xine_get_spu_lang_2=xine_get_spu_lang(fbxine.stream, channel, &lang_buffer[(signed long int)0]);
  if(return_value_xine_get_spu_lang_2 == 0)
    sprintf(lang_buffer, "%3d", channel);

  lang = lang_buffer;
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
  sprintf(buffer, "Subtitles: %s", lang);
  osd_display_info("%s", (const void *)buffer);
}

// osd_display_zoom
// file osd.h line 36
void osd_display_zoom(void)
{
  signed int return_value_xine_get_param_1;
  return_value_xine_get_param_1=xine_get_param(fbxine.stream, 0x01000008);
  signed int return_value_xine_get_param_2;
  return_value_xine_get_param_2=xine_get_param(fbxine.stream, 0x0100000d);
  osd_draw_bar("Zoom Setting", 0, 200, (return_value_xine_get_param_1 + return_value_xine_get_param_2) / 2, 3);
}

// osd_draw_bar
// file osd.c line 456
void osd_draw_bar(char *title, signed int min, signed int max, signed int val, signed int type)
{
  if(!(fbxine.osd.enabled == 0))
  {
    unsigned int width;
    unsigned int height;
    signed int bar_color[40l];
    signed int i;
    signed int x;
    float _val = (float)(signed int)val;
    float _min = (float)(signed int)min;
    float _max = (float)(signed int)max;
    signed int pos;
    if(min >= max)
      _max = (float)(signed int)(min + 1);

    if(min >= max)
      _min = (float)(signed int)(max - 1);

    if(!(max >= val))
      _val = (float)(signed int)max;

    if(!(val >= min))
      _val = (float)(signed int)min;

    pos = (signed int)((float)(signed int)(_val + -_min) / ((_max + -_min) / (float)40));
    xine_osd_clear(fbxine.osd.bar[(signed long int)0]);
    xine_osd_clear(fbxine.osd.bar[(signed long int)1]);
    memset((void *)&bar_color, 0 * 11 + 7, sizeof(signed int) /*4ul*/  * (unsigned long int)40);
    switch(type)
    {
      case 1:

      case 4:
      {
        if(!(pos == 0))
          memset((void *)bar_color, 0 * 11 + 21, sizeof(signed int) /*4ul*/  * (unsigned long int)pos);

        goto __CPROVER_DUMP_L8;
      }
      case 2:

      case 3:
        if(!(pos == 0))
          bar_color[(signed long int)(pos - 1)] = 0 * 11 + 21;

      default:
      {

      __CPROVER_DUMP_L8:
        ;
        if(type == 1 || type == 2)
        {
          x = 3;
          xine_osd_draw_rect(fbxine.osd.bar[(signed long int)0], x, 2, x + 3, 25 - 2, 0 * 11 + 9, 1);
          x = x + 8;
          i = 0;
          for( ; !(i >= 40); x = x + 8)
          {
            xine_osd_draw_rect(fbxine.osd.bar[(signed long int)0], x, 6, x + 3, 25 - 2, bar_color[(signed long int)i], 1);
            i = i + 1;
          }
          xine_osd_draw_rect(fbxine.osd.bar[(signed long int)0], x, 2, x + 3, 25 - 2, 0 * 11 + 9, 1);
        }

        else
          if(type == 3)
          {
            x = 3;
            xine_osd_draw_rect(fbxine.osd.bar[(signed long int)0], x, 2, x + 3, 25 - 2, 0 * 11 + 9, 1);
            x = x + 8;
            i = 0;
            for( ; !(i >= 40); x = x + 8)
            {
              if(i == pos + -1)
                xine_osd_draw_rect(fbxine.osd.bar[(signed long int)0], x, 2, x + 3, 25 - 2, bar_color[(signed long int)i], 1);

              else
                xine_osd_draw_rect(fbxine.osd.bar[(signed long int)0], x, 6, x + 3, 25 - 6, bar_color[(signed long int)i], 1);
              i = i + 1;
            }
            xine_osd_draw_rect(fbxine.osd.bar[(signed long int)0], x, 2, x + 3, 25 - 2, 0 * 11 + 9, 1);
          }

          else
            if(type == 4)
            {
              signed int y = 25 - 4;
              signed int step = y / 20;
              x = 11;
              i = 0;
              for( ; !(i >= 40); x = x + 8)
              {
                xine_osd_draw_rect(fbxine.osd.bar[(signed long int)0], x, y, x + 3, 25 - 2, bar_color[(signed long int)i], 1);
                if(i % 2 == 0)
                  y = y - step;

                i = i + 1;
              }
            }

        if(!(title == ((char *)NULL)))
        {
          signed int tw;
          signed int th;
          xine_osd_get_text_size(fbxine.osd.bar[(signed long int)1], title, &tw, &th);
          xine_osd_draw_text(fbxine.osd.bar[(signed long int)1], 336 - tw >> 1, 0, title, 0 * 11);
        }

        unsigned int return_value_xine_osd_get_capabilities_3;
        return_value_xine_osd_get_capabilities_3=xine_osd_get_capabilities(fbxine.osd.bar[(signed long int)0]);
        if(!((2u & return_value_xine_osd_get_capabilities_3) == 0u))
        {
          signed int return_value_xine_get_param_1;
          return_value_xine_get_param_1=xine_get_param(fbxine.stream, 0x0100000f);
          width = (unsigned int)return_value_xine_get_param_1;
          signed int return_value_xine_get_param_2;
          return_value_xine_get_param_2=xine_get_param(fbxine.stream, 0x01000010);
          height = (unsigned int)return_value_xine_get_param_2;
        }

        else
        {
          width=xine_get_stream_info(fbxine.stream, 2);
          height=xine_get_stream_info(fbxine.stream, 3);
        }
        x = (signed int)(width - (unsigned int)336 >> 1);
        xine_osd_set_position(fbxine.osd.bar[(signed long int)0], x >= 0 ? x : 0, (signed int)((height - (unsigned int)25) - (unsigned int)40));
        xine_osd_set_position(fbxine.osd.bar[(signed long int)1], x >= 0 ? x : 0, (signed int)((height - (unsigned int)(25 * 2)) - (unsigned int)40));
        unsigned int return_value_xine_osd_get_capabilities_4;
        return_value_xine_osd_get_capabilities_4=xine_osd_get_capabilities(fbxine.osd.bar[(signed long int)0]);
        if(!((2u & return_value_xine_osd_get_capabilities_4) == 0u))
        {
          xine_osd_show_unscaled(fbxine.osd.bar[(signed long int)0], (signed long int)0);
          if(!(title == ((char *)NULL)))
            xine_osd_show_unscaled(fbxine.osd.bar[(signed long int)1], (signed long int)0);

        }

        else
        {
          xine_osd_show(fbxine.osd.bar[(signed long int)0], (signed long int)0);
          if(!(title == ((char *)NULL)))
            xine_osd_show(fbxine.osd.bar[(signed long int)1], (signed long int)0);

        }
        fbxine.osd.bar_visible = fbxine.osd.timeout;
      }
    }
  }

}

// osd_init
// file osd.h line 32
void osd_init(void)
{
  signed int fonth = 20;
  fbxine.osd.sinfo=xine_osd_new(fbxine.stream, 0, 0, 900, fonth * 6 + 5 * 3);
  xine_osd_set_font(fbxine.osd.sinfo, "sans", fonth);
  xine_osd_set_text_palette(fbxine.osd.sinfo, 0, 0 * 11);
  fbxine.osd.bar[(signed long int)0]=xine_osd_new(fbxine.stream, 0, 0, 336 + 1, 25 + 1);
  xine_osd_set_palette(fbxine.osd.bar[(signed long int)0], (unsigned int *)textpalettes_color, textpalettes_trans);
  fbxine.osd.bar[(signed long int)1]=xine_osd_new(fbxine.stream, 0, 0, 336 + 1, 25 + 1);
  xine_osd_set_font(fbxine.osd.bar[(signed long int)1], "sans", fonth);
  xine_osd_set_text_palette(fbxine.osd.bar[(signed long int)1], 0, 0 * 11);
  fbxine.osd.status=xine_osd_new(fbxine.stream, 0, 0, 300, fonth + (fonth >> 1));
  xine_osd_set_font(fbxine.osd.status, "cetus", fonth);
  xine_osd_set_text_palette(fbxine.osd.status, 0, 0 * 11);
  fbxine.osd.info=xine_osd_new(fbxine.stream, 0, 0, 2048, fonth + (fonth >> 1));
  xine_osd_set_font(fbxine.osd.info, "sans", fonth);
  xine_osd_set_text_palette(fbxine.osd.info, 0, 0 * 11);
  fbxine.osd.timeout = 3;
  pthread_create(&fbxine.osd_thread, ((const union pthread_attr_t *)NULL), osd_loop, NULL);
}

// osd_loop
// file osd.c line 113
static void * osd_loop(void *dummy)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  pthread_detach(return_value_pthread_self_1);
  while((_Bool)1)
  {
    sleep((unsigned int)1);
    if(!(fbxine.osd.sinfo_visible == 0))
    {
      fbxine.osd.sinfo_visible = fbxine.osd.sinfo_visible - 1;
      if(fbxine.osd.sinfo_visible == 0)
        xine_osd_hide(fbxine.osd.sinfo, (signed long int)0);

    }

    if(!(fbxine.osd.status_visible == 0))
    {
      fbxine.osd.status_visible = fbxine.osd.status_visible - 1;
      if(fbxine.osd.status_visible == 0)
        xine_osd_hide(fbxine.osd.status, (signed long int)0);

    }

    if(!(fbxine.osd.info_visible == 0))
    {
      fbxine.osd.info_visible = fbxine.osd.info_visible - 1;
      if(fbxine.osd.info_visible == 0)
        xine_osd_hide(fbxine.osd.info, (signed long int)0);

    }

    if(!(fbxine.osd.bar_visible == 0))
    {
      fbxine.osd.bar_visible = fbxine.osd.bar_visible - 1;
      if(fbxine.osd.bar_visible == 0)
      {
        xine_osd_hide(fbxine.osd.bar[(signed long int)0], (signed long int)0);
        xine_osd_hide(fbxine.osd.bar[(signed long int)1], (signed long int)0);
      }

    }

  }
  pthread_exit((void *)0);
}

// osd_stream_infos
// file osd.h line 41
void osd_stream_infos(void)
{
  signed int return_value_xine_get_audio_lang_3;
  unsigned long int return_value_strlen_4;
  unsigned long int return_value_strlen_5;
  signed int return_value_xine_get_spu_lang_8;
  unsigned long int return_value_strlen_9;
  signed int return_value_xine_get_param_11;
  if(!(fbxine.osd.enabled == 0))
  {
    unsigned int width;
    unsigned int vwidth;
    unsigned int vheight;
    unsigned int asrate;
    const char *vcodec;
    const char *acodec;
    char buffer[256l];
    signed int x;
    signed int y;
    signed int w;
    signed int h;
    signed int osdw;
    signed int playedtime;
    signed int totaltime;
    signed int pos;
    signed int audiochannel;
    signed int spuchannel;
    signed int len;
    vcodec=xine_get_meta_info(fbxine.stream, 6);
    acodec=xine_get_meta_info(fbxine.stream, 7);
    vwidth=xine_get_stream_info(fbxine.stream, 2);
    vheight=xine_get_stream_info(fbxine.stream, 3);
    asrate=xine_get_stream_info(fbxine.stream, 13);
    audiochannel=xine_get_param(fbxine.stream, 3);
    spuchannel=xine_get_param(fbxine.stream, 4);
    signed int return_value_get_pos_length_1;
    return_value_get_pos_length_1=get_pos_length(fbxine.stream, &pos, &playedtime, &totaltime);
    if(!(return_value_get_pos_length_1 == 0))
    {
      playedtime = playedtime / 1000;
      totaltime = totaltime / 1000;
      xine_osd_clear(fbxine.osd.sinfo);
      x = 0;
      y = x;
      xine_osd_get_text_size(fbxine.osd.sinfo, buffer, &osdw, &h);
      if(!(vcodec == ((const char *)NULL)) && !(vheight == 0u) && !(vwidth == 0u))
      {
        sprintf(buffer, "%s: %dX%d", vcodec, vwidth, vheight);
        xine_osd_draw_text(fbxine.osd.sinfo, x, y, buffer, 0 * 11);
        xine_osd_get_text_size(fbxine.osd.sinfo, buffer, &w, &h);
        if(!(osdw >= w))
          osdw = w;

        y = y + h;
      }

      if(!(acodec == ((const char *)NULL)) && !(asrate == 0u))
      {
        sprintf(buffer, "%s: %dHz", acodec, asrate);
        xine_osd_draw_text(fbxine.osd.sinfo, x, y, buffer, 0 * 11);
        xine_osd_get_text_size(fbxine.osd.sinfo, buffer, &w, &h);
        if(!(osdw >= w))
          osdw = w;

        y = y + h;
      }

      strlcpy(buffer, "Audio: ", sizeof(char [256l]) /*256ul*/ );
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(buffer);
      len = (signed int)return_value_strlen_2;
      if(!(audiochannel == -2))
      {
        if(audiochannel == -1)
          goto __CPROVER_DUMP_L7;

      }

      else
      {
        strlcat(buffer, "off", sizeof(char [256l]) /*256ul*/ );
        goto __CPROVER_DUMP_L11;

      __CPROVER_DUMP_L7:
        ;
        return_value_xine_get_audio_lang_3=xine_get_audio_lang(fbxine.stream, audiochannel, &buffer[(signed long int)len]);
        if(return_value_xine_get_audio_lang_3 == 0)
          strlcat(buffer, "auto", sizeof(char [256l]) /*256ul*/ );

        goto __CPROVER_DUMP_L11;
      }
      signed int return_value_xine_get_audio_lang_6;
      return_value_xine_get_audio_lang_6=xine_get_audio_lang(fbxine.stream, audiochannel, &buffer[(signed long int)len]);
      if(return_value_xine_get_audio_lang_6 == 0)
      {
        return_value_strlen_4=strlen(buffer);
        return_value_strlen_5=strlen(buffer);
        snprintf(buffer + (signed long int)return_value_strlen_4, sizeof(char [256l]) /*256ul*/  - return_value_strlen_5, "%3d", audiochannel);
      }

      goto __CPROVER_DUMP_L11;

    __CPROVER_DUMP_L11:
      ;
      strlcat(buffer, ", Spu: ", sizeof(char [256l]) /*256ul*/ );
      unsigned long int return_value_strlen_7;
      return_value_strlen_7=strlen(buffer);
      len = (signed int)return_value_strlen_7;
      if(!(spuchannel == -2))
      {
        if(spuchannel == -1)
          goto __CPROVER_DUMP_L13;

      }

      else
      {
        strlcat(buffer, "off", sizeof(char [256l]) /*256ul*/ );
        goto __CPROVER_DUMP_L17;

      __CPROVER_DUMP_L13:
        ;
        return_value_xine_get_spu_lang_8=xine_get_spu_lang(fbxine.stream, spuchannel, &buffer[(signed long int)len]);
        if(return_value_xine_get_spu_lang_8 == 0)
          strlcat(buffer, "auto", sizeof(char [256l]) /*256ul*/ );

        goto __CPROVER_DUMP_L17;
      }
      signed int return_value_xine_get_spu_lang_10;
      return_value_xine_get_spu_lang_10=xine_get_spu_lang(fbxine.stream, spuchannel, &buffer[(signed long int)len]);
      if(return_value_xine_get_spu_lang_10 == 0)
      {
        return_value_strlen_9=strlen(buffer);
        sprintf(buffer + (signed long int)return_value_strlen_9, "%3d", spuchannel);
      }

      goto __CPROVER_DUMP_L17;

    __CPROVER_DUMP_L17:
      ;
      strlcat(buffer, ".", sizeof(char [256l]) /*256ul*/ );
      xine_osd_draw_text(fbxine.osd.sinfo, x, y, buffer, 0 * 11);
      xine_osd_get_text_size(fbxine.osd.sinfo, buffer, &w, &h);
      if(!(osdw >= w))
        osdw = w;

      y = y + h;
      if(!(totaltime == 0))
      {
        sprintf(buffer, "%d:%.2d:%.2d (%.0f%%) of %d:%.2d:%.2d", playedtime / 3600, (playedtime % 3600) / 60, playedtime % 60, ((float)playedtime / (float)totaltime) * (float)100, totaltime / 3600, (totaltime % 3600) / 60, totaltime % 60);
        xine_osd_draw_text(fbxine.osd.sinfo, x, y, buffer, 0 * 11);
        xine_osd_get_text_size(fbxine.osd.sinfo, buffer, &w, &h);
        if(!(osdw >= w))
          osdw = w;

        osd_stream_position();
      }

      unsigned int return_value_xine_osd_get_capabilities_12;
      return_value_xine_osd_get_capabilities_12=xine_osd_get_capabilities(fbxine.osd.sinfo);
      if(!((2u & return_value_xine_osd_get_capabilities_12) == 0u))
      {
        return_value_xine_get_param_11=xine_get_param(fbxine.stream, 0x0100000f);
        width = (unsigned int)return_value_xine_get_param_11;
      }

      else
        width = vwidth;
      x = (signed int)((width - (unsigned int)osdw) - (unsigned int)40);
      xine_osd_set_position(fbxine.osd.sinfo, x >= 0 ? x : 0, 15);
      unsigned int return_value_xine_osd_get_capabilities_13;
      return_value_xine_osd_get_capabilities_13=xine_osd_get_capabilities(fbxine.osd.sinfo);
      if(!((2u & return_value_xine_osd_get_capabilities_13) == 0u))
        xine_osd_show_unscaled(fbxine.osd.sinfo, (signed long int)0);

      else
        xine_osd_show(fbxine.osd.sinfo, (signed long int)0);
      fbxine.osd.sinfo_visible = fbxine.osd.timeout;
    }

  }

}

// osd_stream_position
// file osd.h line 38
void osd_stream_position(void)
{
  signed int pos;
  signed int return_value_get_pos_length_1;
  return_value_get_pos_length_1=get_pos_length(fbxine.stream, &pos, (signed int *)(void *)0, (signed int *)(void *)0);
  if(!(return_value_get_pos_length_1 == 0))
    osd_draw_bar("Position in Stream", 0, 65535, pos, 3);

}

// osd_update_status
// file osd.h line 37
void osd_update_status(void)
{
  const char *return_value__osd_get_status_sym_1;
  const char *return_value__osd_get_speed_sym_3;
  if(!(fbxine.osd.enabled == 0))
  {
    signed int status;
    char buffer[256l];
    status=xine_get_status(fbxine.stream);
    xine_osd_clear(fbxine.osd.status);
    memset((void *)&buffer, 0, sizeof(char [256l]) /*256ul*/ );
    switch(status)
    {
      case 0:

      case 1:
      {
        return_value__osd_get_status_sym_1=_osd_get_status_sym(status);
        strcpy(buffer, return_value__osd_get_status_sym_1);
        break;
      }
      case 2:
      {
        signed int speed;
        speed=xine_get_param(fbxine.stream, 1);
        signed int secs;
        signed int return_value_get_pos_length_4;
        return_value_get_pos_length_4=get_pos_length(fbxine.stream, (signed int *)(void *)0, &secs, (signed int *)(void *)0);
        if(!(return_value_get_pos_length_4 == 0))
        {
          secs = secs / 1000;
          const char *return_value__osd_get_speed_sym_2;
          return_value__osd_get_speed_sym_2=_osd_get_speed_sym(speed);
          sprintf(buffer, "%s %02d:%02d:%02d", return_value__osd_get_speed_sym_2, secs / (60 * 60), (secs / 60) % 60, secs % 60);
        }

        else
        {
          return_value__osd_get_speed_sym_3=_osd_get_speed_sym(speed);
          strcpy(buffer, return_value__osd_get_speed_sym_3);
        }
        break;
      }
      case 3:
        ;
    }
    xine_osd_draw_text(fbxine.osd.status, 0, 0, buffer, 0 * 11);
    xine_osd_set_position(fbxine.osd.status, 20, 10);
    unsigned int return_value_xine_osd_get_capabilities_5;
    return_value_xine_osd_get_capabilities_5=xine_osd_get_capabilities(fbxine.osd.status);
    if(!((2u & return_value_xine_osd_get_capabilities_5) == 0u))
      xine_osd_show_unscaled(fbxine.osd.status, (signed long int)0);

    else
      xine_osd_show(fbxine.osd.status, (signed long int)0);
    fbxine.osd.status_visible = fbxine.osd.timeout;
  }

}

// parse_options
// file options.h line 28
signed int parse_options(signed int argc, char **argv)
{
  struct option long_options[12l] = { { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name="debug", .has_arg=0, .flag=((signed int *)NULL), .val=100 },
    { .name="audio-channel", .has_arg=1, .flag=((signed int *)NULL), .val=97 },
    { .name="audio-driver", .has_arg=1, .flag=((signed int *)NULL), .val=65 },
    { .name="video-driver", .has_arg=1, .flag=((signed int *)NULL), .val=86 },
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=118 },
    { .name="no-lirc", .has_arg=0, .flag=((signed int *)NULL), .val=76 },
    { .name="stdctl", .has_arg=2, .flag=((signed int *)NULL), .val=5000 },
    { .name="post", .has_arg=1, .flag=((signed int *)NULL), .val=1008 },
    { .name="deinterlace", .has_arg=0, .flag=((signed int *)NULL), .val=68 },
    { .name="verbose", .has_arg=2, .flag=((signed int *)NULL), .val=1005 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
  const char *short_options = "?hda:qA:V:LvD";
  signed int c = 63;
  signed int option_index = 0;
  opterr = 0;
  char *return_value___strdup_1;
  char *return_value___strdup_2;
  void *return_value_malloc_3;
  void *return_value_realloc_4;
  signed long int return_value_strtol_5;
  do
  {
    c=getopt_long(argc, argv, short_options, long_options, &option_index);
    if(c == -1)
      break;

    switch(c)
    {
      case 68:
      {
        fbxine.deinterlace_enable = 1;
        break;
      }
      case 97:
      {
        sscanf(optarg, "%i", &fbxine.audio_channel);
        break;
      }
      case 100:
      {
        fbxine.debug = 1;
        break;
      }
      case 65:
      {
        if(optarg == ((char *)NULL))
        {
          fprintf(stderr, "Audio driver id is required for -A option.\n");
          return -1;
        }

        return_value___strdup_1=__strdup(optarg);
        fbxine.audio_port_id = return_value___strdup_1;
        break;
      }
      case 86:
      {
        if(optarg == ((char *)NULL))
        {
          fprintf(stderr, "Video driver id is required for -V option.\n");
          return -1;
        }

        return_value___strdup_2=__strdup(optarg);
        fbxine.video_port_id = return_value___strdup_2;
        break;
      }
      case 118:
      {
        print_version();
        return 0;
      }
      case 76:
      {
        no_lirc = 1;
        break;
      }
      case 5000:
      {
        stdctl = 1;
        break;
      }
      case 1008:
      {
        if(pplugins_num == 0)
        {
          return_value_malloc_3=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)2);
          pplugins = (char **)return_value_malloc_3;
        }

        else
        {
          return_value_realloc_4=realloc((void *)pplugins, sizeof(char *) /*8ul*/  * (unsigned long int)(pplugins_num + 2));
          pplugins = (char **)return_value_realloc_4;
        }
        pplugins[(signed long int)pplugins_num] = optarg;
        pplugins_num = pplugins_num + 1;
        pplugins[(signed long int)pplugins_num] = (char *)(void *)0;
        break;
      }
      case 1005:
      {
        if(optarg == ((char *)NULL))
          __xineui_global_verbosity = 1;

        else
        {
          return_value_strtol_5=strtol(optarg, &optarg, 10);
          __xineui_global_verbosity = (signed int)return_value_strtol_5;
        }
        break;
      }
      case 104:

      case 63:
      {
        print_usage();
        return 0;
      }
      default:
      {
        print_usage();
        fprintf(stderr, "Invalid argument %d.\n", c);
        return -1;
      }
    }
  }
  while((_Bool)1);
  if(argc == optind)
  {
    fprintf(stderr, "You should specify at least one MRL.\n");
    return -1;
  }

  else
  {
    extract_mrls(argc - optind, &argv[(signed long int)optind]);
    return 1;
  }
}

// play
// file actions.c line 350
static signed int play(struct xine_stream_s *stream, signed int start_pos, signed int start_time_in_secs, signed int update_mmk)
{
  signed int return_value_xine_play_1;
  return_value_xine_play_1=xine_play(stream, start_pos, start_time_in_secs * 1000);
  return return_value_xine_play_1;
}

// post_deinterlace
// file post.h line 29
void post_deinterlace(void)
{
  if(fbxine.deinterlace_elements_num == 0)
    xine_set_param(fbxine.stream, 0x01000000, fbxine.deinterlace_enable);

  else
  {
    _vpplugin_unwire();
    _vpplugin_rewire();
  }
}

// post_deinterlace_init
// file post.h line 30
void post_deinterlace_init(const char *deinterlace_post)
{
  struct anonymous_14 **posts = (struct anonymous_14 **)(void *)0;
  signed int num;
  fbxine.deinterlace_plugin = "tvtime:method=Linear,cheap_mode=1,pulldown=0,use_progressive_frame_flag=1";
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(!(deinterlace_post == ((const char *)NULL)))
  {
    return_value_strlen_1=strlen(deinterlace_post);
    tmp_if_expr_2 = return_value_strlen_1 != 0ul ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  posts=pplugin_parse_and_load(0, tmp_if_expr_2 ? deinterlace_post : fbxine.deinterlace_plugin, &num);
  if(!(posts == ((struct anonymous_14 **)NULL)))
  {
    fbxine.deinterlace_elements = posts;
    fbxine.deinterlace_elements_num = num;
  }

}

// pplugin_parse_and_load
// file post.c line 94
static struct anonymous_14 ** pplugin_parse_and_load(signed int plugin_type, const char *pchain, signed int *post_elements_num)
{
  struct anonymous_14 **post_elements = (struct anonymous_14 **)(void *)0;
  *post_elements_num = 0;
  unsigned long int return_value_strlen_23;
  char *tmp_statement_expression_2;
  unsigned long int return_value_strlen_22;
  char *tmp_post_5;
  unsigned long int return_value_strlen_7;
  void *return_value_malloc_8;
  void *return_value_realloc_9;
  char *tmp_statement_expression_12;
  unsigned long int return_value_strlen_20;
  char *tmp_post_14;
  signed int return_value_strcasecmp_15;
  signed long int return_value_strtol_17;
  if(!(pchain == ((const char *)NULL)))
  {
    return_value_strlen_23=strlen(pchain);
    if(!(return_value_strlen_23 == 0ul))
    {
      char *p;
      char *post_chain;
      char *ppost_chain;
      char *return_value___strdup_1;
      return_value___strdup_1=__strdup(pchain);
      post_chain = return_value___strdup_1;
      ppost_chain = post_chain;
      do
      {
        char pplugin_parse_and_load__1__1__2____r0;
        char pplugin_parse_and_load__1__1__2____r1;
        char pplugin_parse_and_load__1__1__2____r2;
        char *return_value___strsep_g_3;
        return_value___strsep_g_3=__strsep_g(&ppost_chain, ";");
        tmp_statement_expression_2 = return_value___strsep_g_3;
        p = tmp_statement_expression_2;
        if(p == ((char *)NULL))
          break;

        if(!(p == ((char *)NULL)))
        {
          return_value_strlen_22=strlen(p);
          if(!(return_value_strlen_22 == 0ul))
          {
            char *plugin;
            char *args = (char *)(void *)0;
            struct xine_post_s *post;
            for( ; (signed int)*p == 32; p = p + 1l)
              ;
            char *return_value___strdup_4;
            return_value___strdup_4=__strdup(p);
            plugin = return_value___strdup_4;
            char *return_value___builtin_strchr_6;
            return_value___builtin_strchr_6=__builtin_strchr(plugin, 58);
            p = return_value___builtin_strchr_6;
            if(!(p == ((char *)NULL)))
            {
              tmp_post_5 = p;
              p = p + 1l;
              *tmp_post_5 = (char)0;
            }

            if(!(p == ((char *)NULL)))
            {
              return_value_strlen_7=strlen(p);
              if(return_value_strlen_7 >= 2ul)
                args = p;

            }

            post=xine_post_init(__xineui_global_xine_instance, plugin, 0, &fbxine.audio_port, &fbxine.video_port);
            if(!(post == ((struct xine_post_s *)NULL)) && !(plugin_type == 0))
            {
              if(!(post->type == plugin_type))
              {
                xine_post_dispose(__xineui_global_xine_instance, post);
                post = (struct xine_post_s *)(void *)0;
              }

            }

            if(!(post == ((struct xine_post_s *)NULL)))
            {
              struct anonymous_13 pobj;
              if(*post_elements_num == 0)
              {
                return_value_malloc_8=malloc(sizeof(struct anonymous_14 *) /*8ul*/  * (unsigned long int)2);
                post_elements = (struct anonymous_14 **)return_value_malloc_8;
              }

              else
              {
                return_value_realloc_9=realloc((void *)post_elements, sizeof(struct anonymous_14 *) /*8ul*/  * (unsigned long int)(*post_elements_num + 2));
                post_elements = (struct anonymous_14 **)return_value_realloc_9;
              }
              void *return_value_malloc_10;
              return_value_malloc_10=malloc(sizeof(struct anonymous_14) /*16ul*/ );
              post_elements[(signed long int)*post_elements_num] = (struct anonymous_14 *)return_value_malloc_10;
              post_elements[(signed long int)*post_elements_num]->post = post;
              char *return_value___strdup_11;
              return_value___strdup_11=__strdup(plugin);
              post_elements[(signed long int)*post_elements_num]->name = return_value___strdup_11;
              *post_elements_num = *post_elements_num + 1;
              post_elements[(signed long int)*post_elements_num] = (struct anonymous_14 *)(void *)0;
              memset((void *)&pobj, 0, sizeof(struct anonymous_13) /*64ul*/ );
              pobj.post = post;
              signed int return_value___pplugin_retrieve_parameters_21;
              return_value___pplugin_retrieve_parameters_21=__pplugin_retrieve_parameters(&pobj);
              if(!(return_value___pplugin_retrieve_parameters_21 == 0))
              {
                signed int i;
                if(!(pobj.properties_names == ((char **)NULL)) && !(args == ((char *)NULL)))
                {
                  char *param;
                  do
                  {
                    char __r0;
                    char __r1;
                    char __r2;
                    char *return_value___strsep_g_13;
                    return_value___strsep_g_13=__strsep_g(&args, ",");
                    tmp_statement_expression_12 = return_value___strsep_g_13;
                    param = tmp_statement_expression_12;
                    if(param == ((char *)NULL))
                      break;

                    p = param;
                    for( ; !((signed int)*p == 0); p = p + 1l)
                      if((signed int)*p == 61)
                        break;

                    if(!(p == ((char *)NULL)))
                    {
                      return_value_strlen_20=strlen(p);
                      if(!(return_value_strlen_20 == 0ul))
                      {
                        signed int param_num = 0;
                        tmp_post_14 = p;
                        p = p + 1l;
                        *tmp_post_14 = (char)0;
                        for( ; !(pobj.properties_names[(signed long int)param_num] == ((char *)NULL)); param_num = param_num + 1)
                        {
                          return_value_strcasecmp_15=strcasecmp(pobj.properties_names[(signed long int)param_num], param);
                          if(return_value_strcasecmp_15 == 0)
                            break;

                        }
                        if(!(pobj.properties_names[(signed long int)param_num] == ((char *)NULL)))
                        {
                          pobj.param = pobj.descr->parameter;
                          pobj.param = pobj.param + (signed long int)param_num;
                          pobj.readonly = pobj.param->readonly;
                          switch(pobj.param->type)
                          {
                            case 1:
                            {
                              if(pobj.readonly == 0)
                              {
                                if(!(pobj.param->enum_values == ((char **)NULL)))
                                {
                                  char **values = pobj.param->enum_values;
                                  signed int pplugin_parse_and_load__1__1__3__1__3__2__1__2__1__1__1__1__1__i = 0;
                                  while(!(values[(signed long int)pplugin_parse_and_load__1__1__3__1__3__2__1__2__1__1__1__1__1__i] == ((char *)NULL)))
                                  {
                                    signed int return_value_strcasecmp_16;
                                    return_value_strcasecmp_16=strcasecmp(values[(signed long int)pplugin_parse_and_load__1__1__3__1__3__2__1__2__1__1__1__1__1__i], p);
                                    if(return_value_strcasecmp_16 == 0)
                                    {
                                      *((signed int *)(pobj.param_data + (signed long int)pobj.param->offset)) = pplugin_parse_and_load__1__1__3__1__3__2__1__2__1__1__1__1__1__i;
                                      break;
                                    }

                                    pplugin_parse_and_load__1__1__3__1__3__2__1__2__1__1__1__1__1__i = pplugin_parse_and_load__1__1__3__1__3__2__1__2__1__1__1__1__1__i + 1;
                                  }
                                  if(values[(signed long int)pplugin_parse_and_load__1__1__3__1__3__2__1__2__1__1__1__1__1__i] == ((char *)NULL))
                                  {
                                    return_value_strtol_17=strtol(p, &p, 10);
                                    *((signed int *)(pobj.param_data + (signed long int)pobj.param->offset)) = (signed int)return_value_strtol_17;
                                  }

                                }

                                else
                                {
                                  signed long int return_value_strtol_18;
                                  return_value_strtol_18=strtol(p, &p, 10);
                                  *((signed int *)(pobj.param_data + (signed long int)pobj.param->offset)) = (signed int)return_value_strtol_18;
                                }
                                _pplugin_update_parameter(&pobj);
                              }

                              break;
                            }
                            case 2:
                            {
                              if(pobj.readonly == 0)
                              {
                                *((double *)(pobj.param_data + (signed long int)pobj.param->offset))=strtod(p, &p);
                                _pplugin_update_parameter(&pobj);
                              }

                              break;
                            }
                            case 3:

                            case 4:
                            {
                              if(pobj.readonly == 0)
                              {
                                if(pobj.param->type == 3)
                                {
                                  signed int maxlen = (signed int)((unsigned long int)pobj.param->size / sizeof(char) /*1ul*/ );
                                  strlcpy((char *)(pobj.param_data + (signed long int)pobj.param->offset), p, (unsigned long int)maxlen);
                                  _pplugin_update_parameter(&pobj);
                                }

                                else
                                  fprintf(stderr, "parameter type POST_PARAM_TYPE_STRING not supported yet.\n");
                              }

                              break;
                            }
                            case 5:
                            {
                              if(pobj.readonly == 0)
                                fprintf(stderr, "parameter type POST_PARAM_TYPE_STRINGLIST not supported yet.\n");

                              break;
                            }
                            case 6:
                              if(pobj.readonly == 0)
                              {
                                signed long int return_value_strtol_19;
                                return_value_strtol_19=strtol(p, &p, 10);
                                *((signed int *)(pobj.param_data + (signed long int)pobj.param->offset)) = (signed int)return_value_strtol_19 != 0 ? 1 : 0;
                                _pplugin_update_parameter(&pobj);
                              }

                          }
                        }

                      }

                    }

                  }
                  while((_Bool)1);
                  i = 0;
                  for( ; !(pobj.properties_names[(signed long int)i] == ((char *)NULL)); i = i + 1)
                    free((void *)pobj.properties_names[(signed long int)i]);
                  free((void *)pobj.properties_names);
                }

                free((void *)pobj.param_data);
              }

            }

            free((void *)plugin);
          }

        }

      }
      while((_Bool)1);
      free((void *)post_chain);
    }

  }

  return post_elements;
}

// pplugin_parse_and_store_post
// file post.c line 263
static void pplugin_parse_and_store_post(signed int plugin_type, const char *post_chain)
{
  struct anonymous_14 ***_post_elements = plugin_type == 0x010000 ? &fbxine.post_video_elements : &fbxine.post_audio_elements;
  signed int *_post_elements_num = plugin_type == 0x010000 ? &fbxine.post_video_elements_num : &fbxine.post_audio_elements_num;
  struct anonymous_14 **posts = (struct anonymous_14 **)(void *)0;
  signed int num;
  posts=pplugin_parse_and_load(plugin_type, post_chain, &num);
  if(!(posts == ((struct anonymous_14 **)NULL)))
  {
    if(!(*_post_elements_num == 0))
    {
      signed int i;
      signed int ptot = *_post_elements_num + num;
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)*_post_elements, sizeof(struct anonymous_14 *) /*8ul*/  * (unsigned long int)(ptot + 1));
      *_post_elements = (struct anonymous_14 **)return_value_realloc_1;
      i = *_post_elements_num;
      for( ; !(i >= ptot); i = i + 1)
        (*_post_elements)[(signed long int)i] = posts[(signed long int)(i - *_post_elements_num)];
      (*_post_elements)[(signed long int)i] = (struct anonymous_14 *)(void *)0;
      *_post_elements_num = *_post_elements_num + num;
    }

    else
    {
      *_post_elements = posts;
      *_post_elements_num = num;
    }
  }

}

// print_banner
// file options.c line 64
static void print_banner(void)
{
  signed int major;
  signed int minor;
  signed int sub;
  print_version();
  xine_get_version(&major, &minor, &sub);
  printf("Built with xine library %d.%d.%d. Found xine library version: %d.%d.%d.\n", 1, 2, 6, major, minor, sub);
}

// print_usage
// file options.c line 76
static void print_usage(void)
{
  const char * const *driver_id;
  printf("Usage: fbxine [options] <MRL> ...\n\n  -v, --version                  Display version.\n      --verbose [=level]         Set verbosity level. Default is 1.\n  -V, --video-driver <drv>       Select video driver:\n");
  driver_id=xine_list_video_output_plugins(__xineui_global_xine_instance);
  const char * const *tmp_post_1;
  while(!(*driver_id == ((const char *)NULL)))
  {
    tmp_post_1 = driver_id;
    driver_id = driver_id + 1l;
    printf("                                   '%s'\n", *tmp_post_1);
  }
  printf("\n  -A, --audio-driver <drv>       Select audio driver:\n");
  driver_id=xine_list_audio_output_plugins(__xineui_global_xine_instance);
  const char * const *tmp_post_2;
  while(!(*driver_id == ((const char *)NULL)))
  {
    tmp_post_2 = driver_id;
    driver_id = driver_id + 1l;
    printf("                                    '%s'\n", *tmp_post_2);
  }
  printf("\n  -a, --audio-channel <number>   Select audio channel.\n");
  printf("  -L, --no-lirc                  Turn off LIRC support.\n");
  printf("  -D, --deinterlace              Deinterlace video output. One or more post plugin\n                                 can be specified, with optional parameters.\n                                 Syntax is the same as --post option.\n      --stdctl                   Turn on controlling xine over STDIN.\n      --post <plugin>[:parameter=value][,...]\n                                 Load a post plugin.\n                                 Parameters are comma separated.\n                                 This option can be used more than one time.\n  -d, --debug                    Print debug messages.\n\nExamples of valid MRL:s (media resource locators):\n  File:  'path/foo.vob'\n         '/path/foo.vob'\n         'file://path/foo.vob'\n         'fifo://[[mpeg1|mpeg2]:/]path/foo'\n         'stdin://[mpeg1|mpeg2]' or '-' (mpeg2 only)\n  DVD:   'dvd://VTS_01_2.VOB'\n  VCD:   'vcd://<track number>'\n\n");
  print_banner();
}

// print_version
// file options.c line 58
static void print_version(void)
{
  printf("fbxine %s is a frame buffer interface for the xine library.\n", (const void *)"0.99.9");
}

// reset_zoom
// file actions.c line 453
static void reset_zoom(void)
{
  xine_set_param(fbxine.stream, 0x01000008, 100);
  xine_set_param(fbxine.stream, 0x0100000d, 100);
  osd_display_zoom();
}

// seek_relative_thread
// file actions.c line 361
static void * seek_relative_thread(void *data)
{
  signed int sec;
  signed int off_sec = (signed int)(signed long int)data;
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  pthread_detach(return_value_pthread_self_1);
  signed int return_value_get_pos_length_2;
  return_value_get_pos_length_2=get_pos_length(fbxine.stream, ((signed int *)NULL), &sec, ((signed int *)NULL));
  if(!(return_value_get_pos_length_2 == 0))
  {
    sec = sec / 1000;
    if(!(off_sec + sec >= 0))
      sec = 0;

    else
      sec = sec + off_sec;
    play(fbxine.stream, 0, sec, 1);
    osd_stream_position();
  }

  fbxine.ignore_next = 0;
  pthread_exit(NULL);
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat_1;
  return_value___xstat_1=__xstat(1, __path, __statbuf);
  return return_value___xstat_1;
}

// strlcat
// file ../../src/common/utils.h line 84
unsigned long int strlcat(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  unsigned long int dlen;
  unsigned long int tmp_post_1;
  do
  {
    tmp_post_1 = n;
    n = n - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    if((signed int)*d == 0)
      break;

    d = d + 1l;
  }
  while((_Bool)1);
  dlen = (unsigned long int)(d - dst);
  n = siz - dlen;
  unsigned long int return_value_strlen_2;
  char *tmp_post_3;
  if(n == 0ul)
  {
    return_value_strlen_2=strlen(s);
    return dlen + return_value_strlen_2;
  }

  else
  {
    for( ; !((signed int)*s == 0); s = s + 1l)
      if(!(n == 1ul))
      {
        tmp_post_3 = d;
        d = d + 1l;
        *tmp_post_3 = *s;
        n = n - 1ul;
      }

    *d = (char)0;
    return dlen + (unsigned long int)(s - src);
  }
}

// strlcpy
// file ../../src/common/utils.h line 88
unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  char *tmp_post_1;
  const char *tmp_post_2;
  if(!(n == 0ul))
    do
    {
      n = n - 1ul;
      if(n == 0ul)
        break;

      tmp_post_1 = d;
      d = d + 1l;
      tmp_post_2 = s;
      s = s + 1l;
      *tmp_post_1 = *tmp_post_2;
      if((signed int)*tmp_post_1 == 0)
        break;

    }
    while((_Bool)1);

  const char *tmp_post_3;
  if(n == 0ul)
  {
    if(!(siz == 0ul))
      *d = (char)0;

    do
    {
      tmp_post_3 = s;
      s = s + 1l;
      if(*tmp_post_3 == 0)
        break;

    }
    while((_Bool)1);
  }

  return (unsigned long int)((s - src) - (signed long int)1);
}

// vpplugin_parse_and_store_post
// file post.h line 27
void vpplugin_parse_and_store_post(const char *post_chain)
{
  pplugin_parse_and_store_post(0x010000, post_chain);
}

// vpplugin_rewire_posts
// file post.h line 25
void vpplugin_rewire_posts(void)
{
  _vpplugin_unwire();
  _vpplugin_rewire();
}

// wait_for_exit
// file main.c line 241
static void wait_for_exit(void)
{
  pthread_cond_wait(&fbxine.exit_cond, &fbxine.mutex);
}

// xine_stdctl_loop
// file stdctl.c line 53
static void * xine_stdctl_loop(void *dummy)
{
  char c[255l];
  signed int len;
  signed int k;
  struct anonymous_7 set;
  struct timeval tv;
  signed int secs;
  signed int last_secs;
  char *params;
  last_secs = -1;
  params = (char *)(void *)0;
  while((_Bool)1)
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_7) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&set)->fds_bits[(signed long int)(stdctl_link1.fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->fds_bits[(signed long int)(stdctl_link1.fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << stdctl_link1.fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    tv.tv_sec = (signed long int)0;
    tv.tv_usec = (signed long int)500000;
    select(stdctl_link1.fd + 1, &set, (struct anonymous_7 *)(void *)0, (struct anonymous_7 *)(void *)0, &tv);
    if(!((set.fds_bits[(signed long int)(stdctl_link1.fd / 8)] & (signed long int)(1UL << stdctl_link1.fd % 8)) == 0l))
    {
      signed long int return_value_read_1;
      return_value_read_1=read(stdctl_link1.fd, (void *)&c, (unsigned long int)255);
      len = (signed int)return_value_read_1;
      if(len >= 1)
      {
        c[(signed long int)(len - 1)] = (char)0;
        gParameter.alphanum.set = 0;
        char *return_value___builtin_strchr_2;
        return_value___builtin_strchr_2=__builtin_strchr(c, 36);
        params = return_value___builtin_strchr_2;
        if(!(params == ((char *)NULL)))
        {
          *params = (char)0;
          params = params + 1l;
          gParameter.alphanum.set = 1;
          gParameter.alphanum.arg = params;
        }

        gParameter.numeric.set = 0;
        char *return_value___builtin_strchr_3;
        return_value___builtin_strchr_3=__builtin_strchr(c, 35);
        params = return_value___builtin_strchr_3;
        if(!(params == ((char *)NULL)))
        {
          *params = (char)0;
          params = params + 1l;
          gParameter.numeric.set = 1;
          gParameter.numeric.arg=atoi(params);
        }

        k=default_command_action(c);
        if(!(k == 0))
          do_action(k);

      }

    }

    signed int return_value_get_pos_length_4;
    return_value_get_pos_length_4=get_pos_length(fbxine.stream, (signed int *)(void *)0, &secs, (signed int *)(void *)0);
    if(!(return_value_get_pos_length_4 == 0))
    {
      secs = secs / 1000;
      if(!(secs == last_secs))
      {
        fprintf(stdout, "time: %d\n", secs);
        fflush(stdout);
        last_secs = secs;
      }

    }

  }
  pthread_exit((void *)0);
}

// xine_system
// file utils.c line 44
signed int xine_system(signed int dont_run_as_root, char *command)
{
  signed int pid;
  signed int status;
  if(!(dont_run_as_root == 0))
  {
    unsigned int return_value_getuid_1;
    return_value_getuid_1=getuid();
    if(return_value_getuid_1 == 0u)
      return -1;

  }

  if(command == ((char *)NULL))
    return 1;

  else
  {
    pid=fork();
    if(pid == -1)
      return -1;

    else
    {
      if(pid == 0)
      {
        char *argv[4l];
        argv[(signed long int)0] = "sh";
        argv[(signed long int)1] = "-c";
        argv[(signed long int)2] = command;
        argv[(signed long int)3] = ((char *)NULL);
        execve("/bin/sh", argv, environ);
        exit(127);
      }

      do
      {
        signed int return_value_waitpid_3;
        return_value_waitpid_3=waitpid(pid, &status, 0);
        /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_12
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
        ;
        if(return_value_waitpid_3 == -1)
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          if(!(*return_value___errno_location_2 == 4))
            return -1;

        }

        else
          return (((union anonymous_12){ .__in=status }).__i & 0xff00) >> 8;
      }
      while((_Bool)1);
      return -1;
    }
  }
}

