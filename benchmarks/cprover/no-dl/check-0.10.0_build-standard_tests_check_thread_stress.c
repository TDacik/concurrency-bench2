// tag-#anon#ST[*{V(SYM#tag-sigval#)->V}_V(SYM#tag-sigval#)->V_'_function'||*{SYM#tag-pthread_attr_t#}_SYM#tag-pthread_attr_t#_'_attribute'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 327
struct anonymous_7;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_10;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_6;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_0;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#}_SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#_'__cancel_jmp_buf'||ARR4{*{V}_V_}_*{V}_V__'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous_15;

// tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous_14;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_2;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_5;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_4;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_12;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_3;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_9;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous;

// tag-#anon#UN[ARR12{S32}_S32_'_pad'||S32'_tid'||SYM#tag-#anon#ST[*{V(SYM#tag-sigval#)->V}_V(SYM#tag-sigval#)->V_'_function'||*{SYM#tag-pthread_attr_t#}_SYM#tag-pthread_attr_t#_'_attribute'|]#'_sigev_thread'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 319
union anonymous_8;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_11;

// tag-#anon#UN[SYM#tag-CtxMsg#'ctx_msg'||SYM#tag-FailMsg#'fail_msg'||SYM#tag-LocMsg#'loc_msg'||SYM#tag-DurationMsg#'duration_msg'|]
// file ../../src/check_pack.h line 55
union anonymous_13;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_16;

// tag-CtxMsg
// file ../../src/check_pack.h line 34
struct CtxMsg;

// tag-DurationMsg
// file ../../src/check_pack.h line 50
struct DurationMsg;

// tag-FailMsg
// file ../../src/check_pack.h line 45
struct FailMsg;

// tag-Fixture
// file ../../src/check_impl.h line 53
struct Fixture;

// tag-List
// file ../../src/check_list.h line 24
struct List;

// tag-LocMsg
// file ../../src/check_pack.h line 39
struct LocMsg;

// tag-Log
// file ../../src/check_impl.h line 109
struct Log;

// tag-RcvMsg
// file ../../src/check_pack.h line 63
struct RcvMsg;

// tag-SRunner
// file ../../src/check.h line 819
struct SRunner;

// tag-Suite
// file ../../src/check.h line 115
struct Suite;

// tag-TCase
// file ../../src/check.h line 100
struct TCase;

// tag-TF
// file ../../src/check_impl.h line 37
struct TF;

// tag-TestResult
// file ../../src/check.h line 824
struct TestResult;

// tag-TestStats
// file ../../src/check_impl.h line 70
struct TestStats;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-ck_msg_type
// file ../../src/check_pack.h line 25
enum ck_msg_type { CK_MSG_CTX=0, CK_MSG_FAIL=1, CK_MSG_LOC=2, CK_MSG_DURATION=3, CK_MSG_LAST=4 };

// tag-ck_result_ctx
// file ../../src/check.h line 829
enum ck_result_ctx { CK_CTX_INVALID=0, CK_CTX_SETUP=1, CK_CTX_TEST=2, CK_CTX_TEARDOWN=3 };

// tag-cl_event
// file ../../src/check_impl.h line 94
enum cl_event { CLINITLOG_SR=0, CLENDLOG_SR=1, CLSTART_SR=2, CLSTART_S=3, CLEND_SR=4, CLEND_S=5, CLSTART_T=6, CLEND_T=7 };

// tag-fork_status
// file ../../src/check.h line 1184
enum fork_status { CK_FORK_GETENV=0, CK_FORK=1, CK_NOFORK=2 };

// tag-itimerspec
// file /usr/include/time.h line 161
struct itimerspec;

// tag-print_output
// file ../src/check.h line 799
enum print_output { CK_SILENT=0, CK_MINIMAL=1, CK_NORMAL=2, CK_VERBOSE=3, CK_ENV=4, CK_SUBUNIT=5, CK_LAST=6 };

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigevent
// file /usr/include/time.h line 168
struct sigevent;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-test_result
// file ../../src/check.h line 787
enum test_result { CK_TEST_RESULT_INVALID=0, CK_PASS=1, CK_FAILURE=2, CK_ERROR=3 };

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous_15 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous_15 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous_15 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// _ck_assert_failed
// file ../src/check.h line 419
void _ck_assert_failed(const char *file, signed int line, const char *expr, ...);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// _mark_point
// file ../src/check.h line 782
void _mark_point(const char *file, signed int line);
// _setjmp
// file /usr/include/setjmp.h line 63
extern signed int _setjmp(struct __jmp_buf_tag *);
// _tcase_add_test
// file ../src/check.h line 274
void _tcase_add_test(struct TCase *tc, void (*fn)(signed int), const char *name, signed int _signal, signed int allowed_exit_value, signed int start, signed int end);
// _tcase_add_test::fn_object
//
void fn_object(signed int);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// check_fork
// file ../../src/check_run.c line 791
signed int check_fork(void);
// check_get_clockid
// file ../../src/check.c line 522
signed int check_get_clockid(void);
// check_list_add_end
// file ../../src/check_list.h line 42
void check_list_add_end(struct List *lp, void *val);
// check_list_add_front
// file ../../src/check_list.h line 38
void check_list_add_front(struct List *lp, void *val);
// check_list_advance
// file ../../src/check_list.h line 48
void check_list_advance(struct List *lp);
// check_list_apply
// file ../../src/check_list.h line 53
void check_list_apply(struct List *lp, void (*fp)(void *));
// check_list_apply::fp_object
//
void fp_object(void *);
// check_list_at_end
// file ../../src/check_list.h line 30
signed int check_list_at_end(struct List *lp);
// check_list_create
// file ../../src/check_list.h line 27
struct List * check_list_create(void);
// check_list_free
// file ../../src/check_list.h line 51
void check_list_free(struct List *lp);
// check_list_front
// file ../../src/check_list.h line 33
void check_list_front(struct List *lp);
// check_list_val
// file ../../src/check_list.h line 45
void * check_list_val(struct List *lp);
// check_type
// file ../../src/check_pack.c line 285
static void check_type(signed int type, const char *file, signed int line);
// check_waitpid_and_exit
// file ../../src/check_run.c line 808
void check_waitpid_and_exit(signed int pid);
// ck_do_nothing
// file ../../lib/libcompat.c line 4
void ck_do_nothing(void);
// ck_strdup_printf
// file ../../src/check_str.h line 40
char * ck_strdup_printf(const char *fmt, ...);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// construct_test_result
// file ../../src/check_msg.c line 167
static struct TestResult * construct_test_result(struct RcvMsg *rmsg, signed int waserror);
// cur_fork_status
// file ../../src/check.c line 509
enum fork_status cur_fork_status(void);
// emalloc
// file ../../src/check_error.h line 36
void * emalloc(unsigned long int n);
// eprintf
// file ../../src/check_error.h line 33
void eprintf(const char *fmt, const char *file, signed int line, ...);
// erealloc
// file ../../src/check_error.c line 68
void * erealloc(void *ptr, unsigned long int n);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_msg
// file ../../src/check_run.c line 676
static char * exit_msg(signed int exitval);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fixture_create
// file ../../src/check.c line 197
static struct Fixture * fixture_create(void (*fun)(void), signed int ischecked);
// fixture_create::fun_object
//
void fun_object(void);
// floor
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 184
extern double floor(double);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprint_xml_esc
// file ../../src/check_print.h line 25
void fprint_xml_esc(struct _IO_FILE *file, const char *str);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_env_printmode
// file ../../src/check_print.h line 29
enum print_output get_env_printmode(void);
// get_pipe
// file ../../src/check_msg.c line 68
static struct _IO_FILE * get_pipe(void);
// get_result
// file ../../src/check_pack.c line 336
static signed int get_result(char *buf, struct RcvMsg *rmsg);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getpgrp
// file /usr/include/unistd.h line 634
extern signed int getpgrp(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// killpg
// file /usr/include/signal.h line 134
extern signed int killpg(signed int, signed int);
// lfile_lfun
// file ../../src/check_log.c line 227
void lfile_lfun(struct SRunner *sr, struct _IO_FILE *file, enum print_output printmode, void *obj, enum cl_event evt);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log_srunner_end
// file ../../src/check_log.c line 136
void log_srunner_end(struct SRunner *sr);
// log_srunner_start
// file ../../src/check_log.c line 131
void log_srunner_start(struct SRunner *sr);
// log_suite_end
// file ../../src/check_log.c line 146
void log_suite_end(struct SRunner *sr, struct Suite *s);
// log_suite_start
// file ../../src/check_log.c line 141
void log_suite_start(struct SRunner *sr, struct Suite *s);
// log_test_end
// file ../../src/check_log.c line 159
void log_test_end(struct SRunner *sr, struct TestResult *tr);
// log_test_start
// file ../../src/check_log.c line 151
void log_test_start(struct SRunner *sr, struct TCase *tc, struct TF *tfun);
// longjmp
// file /usr/include/setjmp.h line 74
extern void longjmp(struct __jmp_buf_tag *, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// maybe_grow
// file ../../src/check_list.c line 45
static void maybe_grow(struct List *lp);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkstemp
// file /usr/include/stdlib.h line 619
extern signed int mkstemp(char *);
// non_pass
// file ../../src/check.c line 435
static signed int non_pass(signed int val);
// open_tmp_file
// file ../../src/check_msg.c line 227
struct _IO_FILE * open_tmp_file(char **name);
// pack
// file ../../src/check_pack.c line 98
signed int pack(enum ck_msg_type type, char **buf, union anonymous_13 *msg);
// pack_ctx
// file ../../src/check_pack.c line 207
static signed int pack_ctx(char **buf, struct CtxMsg *cmsg);
// pack_duration
// file ../../src/check_pack.c line 226
static signed int pack_duration(char **buf, struct DurationMsg *cmsg);
// pack_fail
// file ../../src/check_pack.c line 266
static signed int pack_fail(char **buf, struct FailMsg *fmsg);
// pack_int
// file ../../src/check_pack.c line 128
static void pack_int(char **buf, signed int val);
// pack_loc
// file ../../src/check_pack.c line 245
static signed int pack_loc(char **buf, struct LocMsg *lmsg);
// pack_str
// file ../../src/check_pack.c line 155
static void pack_str(char **buf, const char *val);
// pack_type
// file ../../src/check_pack.c line 196
static void pack_type(char **buf, enum ck_msg_type type);
// pass_msg
// file ../../src/check_run.c line 437
static char * pass_msg(void);
// percent_passed
// file ../../src/check_str.c line 126
static signed int percent_passed(struct TestStats *t);
// ppack
// file ../../src/check_pack.h line 81
void ppack(struct _IO_FILE *fdes, enum ck_msg_type type, union anonymous_13 *msg);
// ppack::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// ppack_cleanup
// file ../../src/check_pack.c line 293
static void ppack_cleanup(void *mutex);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_16 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_16 *);
// punpack
// file ../../src/check_pack.h line 82
struct RcvMsg * punpack(struct _IO_FILE *fdes);
// rcvmsg_create
// file ../../src/check_pack.c line 401
static struct RcvMsg * rcvmsg_create(void);
// rcvmsg_free
// file ../../src/check_pack.h line 75
void rcvmsg_free(struct RcvMsg *rmsg);
// rcvmsg_update_ctx
// file ../../src/check_pack.c line 423
static void rcvmsg_update_ctx(struct RcvMsg *rmsg, enum ck_result_ctx ctx);
// rcvmsg_update_loc
// file ../../src/check_pack.c line 433
static void rcvmsg_update_loc(struct RcvMsg *rmsg, const char *file, signed int line);
// read_buf
// file ../../src/check_pack.c line 322
static signed int read_buf(struct _IO_FILE *fdes, signed int size, char *buf);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// receive_result_info_fork
// file ../../src/check_run.c line 514
static struct TestResult * receive_result_info_fork(const char *tcname, const char *tname, signed int iter, signed int status, signed int expected_signal, signed char allowed_exit_value);
// receive_result_info_nofork
// file ../../src/check_run.c line 401
static struct TestResult * receive_result_info_nofork(const char *tcname, const char *tname, signed int iter, signed int duration);
// receive_test_result
// file ../../src/check_msg.c line 120
struct TestResult * receive_test_result(signed int waserror);
// reset_rcv_fixture
// file ../../src/check_pack.c line 395
static void reset_rcv_fixture(struct RcvMsg *rmsg);
// reset_rcv_test
// file ../../src/check_pack.c line 389
static void reset_rcv_test(struct RcvMsg *rmsg);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// send_ctx_info
// file ../../src/check_msg.h line 29
void send_ctx_info(enum ck_result_ctx ctx);
// send_duration_info
// file ../../src/check_msg.c line 94
void send_duration_info(signed int duration);
// send_failure_info
// file ../../src/check_msg.h line 27
void send_failure_info(const char *msg);
// send_loc_info
// file ../../src/check_msg.h line 28
void send_loc_info(const char *file, signed int line);
// sendinfo
// file ../../tests/check_thread_stress.c line 13
static void * sendinfo(void *userdata);
// set_fork_info
// file ../../src/check_run.c line 538
static void set_fork_info(struct TestResult *tr, signed int status, signed int signal_expected, signed char allowed_exit_value);
// set_fork_status
// file ../../src/check.c line 501
void set_fork_status(enum fork_status fstat);
// set_nofork_info
// file ../../src/check_run.c line 424
static void set_nofork_info(struct TestResult *tr);
// setpgid
// file /usr/include/unistd.h line 646
extern signed int setpgid(signed int, signed int);
// setup_messaging
// file ../../src/check_msg.c line 208
void setup_messaging(void);
// setup_pipe
// file ../../src/check_msg.c line 288
static void setup_pipe(void);
// sig_handler
// file ../../src/check_run.c line 102
static void sig_handler(signed int sig_nr);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// signal_error_msg
// file ../../src/check_run.c line 652
static char * signal_error_msg(signed int signal_received, signed int signal_expected);
// signal_msg
// file ../../src/check_run.c line 636
static char * signal_msg(signed int signal);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sr_stat_str
// file ../../src/check_str.h line 38
char * sr_stat_str(struct SRunner *sr);
// srunner_add_failure
// file ../../src/check_run.c line 247
static void srunner_add_failure(struct SRunner *sr, struct TestResult *tr);
// srunner_add_suite
// file ../../src/check.c line 352
void srunner_add_suite(struct SRunner *sr, struct Suite *s);
// srunner_create
// file ../src/check.h line 920
struct SRunner * srunner_create(struct Suite *s);
// srunner_end_logging
// file ../../src/check_log.c line 532
void srunner_end_logging(struct SRunner *sr);
// srunner_failures
// file ../../src/check.c line 397
struct TestResult ** srunner_failures(struct SRunner *sr);
// srunner_fork_status
// file ../../src/check_run.c line 696
enum fork_status srunner_fork_status(struct SRunner *sr);
// srunner_fprint
// file ../../src/check_print.h line 28
void srunner_fprint(struct _IO_FILE *file, struct SRunner *sr, enum print_output print_mode);
// srunner_fprint_results
// file ../../src/check_print.c line 74
static void srunner_fprint_results(struct _IO_FILE *file, struct SRunner *sr, enum print_output print_mode);
// srunner_fprint_summary
// file ../../src/check_print.c line 55
static void srunner_fprint_summary(struct _IO_FILE *file, struct SRunner *sr, enum print_output print_mode);
// srunner_free
// file ../src/check.h line 946
void srunner_free(struct SRunner *sr);
// srunner_has_log
// file ../../src/check_log.c line 52
signed int srunner_has_log(struct SRunner *sr);
// srunner_has_tap
// file ../../src/check_log.c line 97
signed int srunner_has_tap(struct SRunner *sr);
// srunner_has_xml
// file ../../src/check_log.c line 74
signed int srunner_has_xml(struct SRunner *sr);
// srunner_init_logging
// file ../../src/check_log.c line 501
void srunner_init_logging(struct SRunner *sr, enum print_output print_mode);
// srunner_iterate_suites
// file ../../src/check_run.c line 161
static void srunner_iterate_suites(struct SRunner *sr, const char *sname, const char *tcname, enum print_output print_mode);
// srunner_iterate_tcase_tfuns
// file ../../src/check_run.c line 202
static void srunner_iterate_tcase_tfuns(struct SRunner *sr, struct TCase *tc);
// srunner_log_fname
// file ../../src/check_log.c line 57
const char * srunner_log_fname(struct SRunner *sr);
// srunner_ntests_failed
// file ../src/check.h line 997
signed int srunner_ntests_failed(struct SRunner *sr);
// srunner_ntests_run
// file ../../src/check.c line 392
signed int srunner_ntests_run(struct SRunner *sr);
// srunner_open_file
// file ../../src/check_log.c line 448
static struct _IO_FILE * srunner_open_file(const char *filename);
// srunner_open_lfile
// file ../../src/check_log.c line 468
struct _IO_FILE * srunner_open_lfile(struct SRunner *sr);
// srunner_open_tapfile
// file ../../src/check_log.c line 490
struct _IO_FILE * srunner_open_tapfile(struct SRunner *sr);
// srunner_open_xmlfile
// file ../../src/check_log.c line 479
struct _IO_FILE * srunner_open_xmlfile(struct SRunner *sr);
// srunner_print
// file ../../src/check_print.c line 39
void srunner_print(struct SRunner *sr, enum print_output print_mode);
// srunner_register_lfun
// file ../../src/check_log.c line 113
void srunner_register_lfun(struct SRunner *sr, struct _IO_FILE *lfile, signed int close, void (*lfun)(struct SRunner *, struct _IO_FILE *, enum print_output, void *, enum cl_event), enum print_output printmode);
// srunner_register_lfun::lfun_object
//
void lfun_object(struct SRunner *, struct _IO_FILE *, enum print_output, void *, enum cl_event);
// srunner_results
// file ../../src/check.c line 418
struct TestResult ** srunner_results(struct SRunner *sr);
// srunner_run
// file ../../src/check_run.c line 744
void srunner_run(struct SRunner *sr, const char *sname, const char *tcname, enum print_output print_mode);
// srunner_run_all
// file ../src/check.h line 963
void srunner_run_all(struct SRunner *sr, enum print_output print_mode);
// srunner_run_end
// file ../../src/check_run.c line 152
static void srunner_run_end(struct SRunner *sr, enum print_output print_mode);
// srunner_run_init
// file ../../src/check_run.c line 144
static void srunner_run_init(struct SRunner *sr, enum print_output print_mode);
// srunner_run_setup
// file ../../src/check_run.c line 258
static struct TestResult * srunner_run_setup(struct List *fixture_list, enum fork_status fork_usage, const char *test_name, const char *setup_name);
// srunner_run_tcase
// file ../../src/check_run.c line 369
static void srunner_run_tcase(struct SRunner *sr, struct TCase *tc);
// srunner_run_teardown
// file ../../src/check_run.c line 330
static void srunner_run_teardown(struct List *fixture_list, enum fork_status fork_usage);
// srunner_run_unchecked_setup
// file ../../src/check_run.c line 304
static signed int srunner_run_unchecked_setup(struct SRunner *sr, struct TCase *tc);
// srunner_run_unchecked_teardown
// file ../../src/check_run.c line 359
static void srunner_run_unchecked_teardown(struct SRunner *sr, struct TCase *tc);
// srunner_send_evt
// file ../../src/check_log.c line 164
static void srunner_send_evt(struct SRunner *sr, void *obj, enum cl_event evt);
// srunner_set_fork_status
// file ../../src/check_run.c line 724
void srunner_set_fork_status(struct SRunner *sr, enum fork_status fstat);
// srunner_set_log
// file ../../src/check_log.c line 45
void srunner_set_log(struct SRunner *sr, const char *fname);
// srunner_set_tap
// file ../../src/check_log.c line 90
void srunner_set_tap(struct SRunner *sr, const char *fname);
// srunner_set_xml
// file ../../src/check_log.c line 67
void srunner_set_xml(struct SRunner *sr, const char *fname);
// srunner_tap_fname
// file ../../src/check_log.c line 102
const char * srunner_tap_fname(struct SRunner *sr);
// srunner_xml_fname
// file ../../src/check_log.c line 79
const char * srunner_xml_fname(struct SRunner *sr);
// stdout_lfun
// file ../../src/check_log.c line 179
void stdout_lfun(struct SRunner *sr, struct _IO_FILE *file, enum print_output printmode, void *obj, enum cl_event evt);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strsignal
// file /usr/include/string.h line 563
extern char * strsignal(signed int);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// subunit_lfun
// file ../../src/check_log.c line 384
void subunit_lfun(struct SRunner *sr, struct _IO_FILE *file, enum print_output printmode, void *obj, enum cl_event evt);
// subunit_test_error
// file /usr/include/subunit/child.h line 61
extern void subunit_test_error(const char *, const char *);
// subunit_test_fail
// file /usr/include/subunit/child.h line 50
extern void subunit_test_fail(const char *, const char *);
// subunit_test_pass
// file /usr/include/subunit/child.h line 40
extern void subunit_test_pass(const char *);
// subunit_test_start
// file /usr/include/subunit/child.h line 30
extern void subunit_test_start(const char *);
// suite_add_tcase
// file ../src/check.h line 155
void suite_add_tcase(struct Suite *s, struct TCase *tc);
// suite_create
// file ../src/check.h line 131
struct Suite * suite_create(const char *name);
// suite_free
// file ../../src/check.c line 91
static void suite_free(struct Suite *s);
// suite_tcase
// file ../../src/check.c line 72
signed int suite_tcase(struct Suite *s, const char *tcname);
// tap_lfun
// file ../../src/check_log.c line 339
void tap_lfun(struct SRunner *sr, struct _IO_FILE *file, enum print_output printmode, void *obj, enum cl_event evt);
// tcase_add_checked_fixture
// file ../../src/check.c line 213
void tcase_add_checked_fixture(struct TCase *tc, void (*setup)(void), void (*teardown)(void));
// tcase_add_checked_fixture::setup_object
//
void setup_object(void);
// tcase_add_checked_fixture::teardown_object
//
void teardown_object(void);
// tcase_add_fixture
// file ../../src/check.c line 218
static void tcase_add_fixture(struct TCase *tc, void (*setup)(void), void (*teardown)(void), signed int ischecked);
// tcase_add_fixture::setup_object
//
void setup_object(void);
// tcase_add_fixture::teardown_object
//
void teardown_object(void);
// tcase_add_unchecked_fixture
// file ../../src/check.c line 208
void tcase_add_unchecked_fixture(struct TCase *tc, void (*setup)(void), void (*teardown)(void));
// tcase_add_unchecked_fixture::setup_object
//
void setup_object(void);
// tcase_add_unchecked_fixture::teardown_object
//
void teardown_object(void);
// tcase_create
// file ../src/check.h line 170
struct TCase * tcase_create(const char *name);
// tcase_fn_start
// file ../src/check.h line 359
void tcase_fn_start(const char *fname, const char *file, signed int line);
// tcase_free
// file ../../src/check.c line 157
static void tcase_free(struct TCase *tc);
// tcase_run_checked_setup
// file ../../src/check_run.c line 322
static struct TestResult * tcase_run_checked_setup(struct SRunner *sr, struct TCase *tc);
// tcase_run_checked_teardown
// file ../../src/check_run.c line 364
static void tcase_run_checked_teardown(struct TCase *tc);
// tcase_run_tfun_fork
// file ../../src/check_run.c line 443
static struct TestResult * tcase_run_tfun_fork(struct SRunner *sr, struct TCase *tc, struct TF *tfun, signed int i);
// tcase_run_tfun_nofork
// file ../../src/check_run.c line 378
static struct TestResult * tcase_run_tfun_nofork(struct SRunner *sr, struct TCase *tc, struct TF *tfun, signed int i);
// tcase_set_timeout
// file ../../src/check.c line 243
void tcase_set_timeout(struct TCase *tc, double timeout);
// teardown_messaging
// file ../../src/check_msg.c line 213
void teardown_messaging(void);
// teardown_pipe
// file ../../src/check_msg.c line 303
static void teardown_pipe(void);
// test_stress_forks
// file ../../tests/check_thread_stress.c line 38
static void test_stress_forks(signed int _i);
// test_stress_threads
// file ../../tests/check_thread_stress.c line 25
static void test_stress_threads(signed int _i);
// timer_create
// file /usr/include/time.h line 363
extern signed int timer_create(signed int, struct sigevent *, void ** restrict );
// timer_delete
// file /usr/include/time.h line 368
extern signed int timer_delete(void *);
// timer_settime
// file /usr/include/time.h line 371
extern signed int timer_settime(void *, signed int, struct itimerspec *, struct itimerspec *);
// tr_create
// file ../../src/check.c line 440
struct TestResult * tr_create(void);
// tr_ctx
// file ../../src/check.c line 489
enum ck_result_ctx tr_ctx(struct TestResult *tr);
// tr_fprint
// file ../../src/check_print.h line 26
void tr_fprint(struct _IO_FILE *file, struct TestResult *tr, enum print_output print_mode);
// tr_free
// file ../../src/check.c line 461
void tr_free(struct TestResult *tr);
// tr_init
// file ../../src/check.c line 449
static void tr_init(struct TestResult *tr);
// tr_lfile
// file ../../src/check.c line 479
const char * tr_lfile(struct TestResult *tr);
// tr_lno
// file ../../src/check.c line 474
signed int tr_lno(struct TestResult *tr);
// tr_msg
// file ../../src/check.c line 469
const char * tr_msg(struct TestResult *tr);
// tr_rtype
// file ../../src/check.c line 484
signed int tr_rtype(struct TestResult *tr);
// tr_set_loc_by_ctx
// file ../../src/check_msg.c line 148
static void tr_set_loc_by_ctx(struct TestResult *tr, enum ck_result_ctx ctx, struct RcvMsg *rmsg);
// tr_short_str
// file ../../src/check_str.h line 32
char * tr_short_str(struct TestResult *tr);
// tr_str
// file ../../src/check_str.h line 26
char * tr_str(struct TestResult *tr);
// tr_tcname
// file ../../src/check.c line 494
const char * tr_tcname(struct TestResult *tr);
// tr_type_str
// file ../../src/check_str.c line 107
static const char * tr_type_str(struct TestResult *tr);
// tr_xmlprint
// file ../../src/check_print.h line 27
void tr_xmlprint(struct _IO_FILE *file, struct TestResult *tr, enum print_output print_mode);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// upack
// file ../../src/check_pack.c line 110
signed int upack(char *buf, union anonymous_13 *msg, enum ck_msg_type *type);
// upack_ctx
// file ../../src/check_pack.c line 221
static void upack_ctx(char **buf, struct CtxMsg *cmsg);
// upack_duration
// file ../../src/check_pack.c line 240
static void upack_duration(char **buf, struct DurationMsg *cmsg);
// upack_fail
// file ../../src/check_pack.c line 280
static void upack_fail(char **buf, struct FailMsg *fmsg);
// upack_int
// file ../../src/check_pack.c line 141
static signed int upack_int(char **buf);
// upack_loc
// file ../../src/check_pack.c line 260
static void upack_loc(char **buf, struct LocMsg *lmsg);
// upack_str
// file ../../src/check_pack.c line 173
static char * upack_str(char **buf);
// upack_type
// file ../../src/check_pack.c line 201
static enum ck_msg_type upack_type(char **buf);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// waserror
// file ../../src/check_run.c line 684
static signed int waserror(signed int status, signed int signal_expected);
// xml_lfun
// file ../../src/check_log.c line 266
void xml_lfun(struct SRunner *sr, struct _IO_FILE *file, enum print_output printmode, void *obj, enum cl_event evt);

struct anonymous_7
{
  // _function
  void (*_function)(union sigval);
  // _attribute
  union pthread_attr_t *_attribute;
};

struct anonymous_10
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_6
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_0
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_14
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous_15
{
  // __cancel_jmp_buf
  struct anonymous_14 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous_2
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_5
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_4
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_3
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_9
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_11
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_2 _kill;
  // _timer
  struct anonymous_3 _timer;
  // _rt
  struct anonymous_4 _rt;
  // _sigchld
  struct anonymous_5 _sigchld;
  // _sigfault
  struct anonymous_6 _sigfault;
  // _sigpoll
  struct anonymous_9 _sigpoll;
  // _sigsys
  struct anonymous_10 _sigsys;
};

struct anonymous_12
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_11 _sifields;
};

union anonymous
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_12 *, void *);
};

union anonymous_8
{
  // _pad
  signed int _pad[12l];
  // _tid
  signed int _tid;
  // _sigev_thread
  struct anonymous_7 _sigev_thread;
};

struct CtxMsg
{
  // ctx
  enum ck_result_ctx ctx;
};

struct FailMsg
{
  // msg
  char *msg;
};

struct LocMsg
{
  // line
  signed int line;
  // file
  char *file;
};

struct DurationMsg
{
  // duration
  signed int duration;
};

union anonymous_13
{
  // ctx_msg
  struct CtxMsg ctx_msg;
  // fail_msg
  struct FailMsg fail_msg;
  // loc_msg
  struct LocMsg loc_msg;
  // duration_msg
  struct DurationMsg duration_msg;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_16
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct Fixture
{
  // ischecked
  signed int ischecked;
  // fun
  void (*fun)(void);
};

struct List
{
  // n_elts
  unsigned int n_elts;
  // max_elts
  unsigned int max_elts;
  // current
  signed int current;
  // last
  signed int last;
  // data
  void **data;
};

struct Log
{
  // lfile
  struct _IO_FILE *lfile;
  // lfun
  void (*lfun)(struct SRunner *, struct _IO_FILE *, enum print_output, void *, enum cl_event);
  // close
  signed int close;
  // mode
  enum print_output mode;
};

struct RcvMsg
{
  // lastctx
  enum ck_result_ctx lastctx;
  // failctx
  enum ck_result_ctx failctx;
  // fixture_file
  char *fixture_file;
  // fixture_line
  signed int fixture_line;
  // test_file
  char *test_file;
  // test_line
  signed int test_line;
  // msg
  char *msg;
  // duration
  signed int duration;
};

struct SRunner
{
  // slst
  struct List *slst;
  // stats
  struct TestStats *stats;
  // resultlst
  struct List *resultlst;
  // log_fname
  const char *log_fname;
  // xml_fname
  const char *xml_fname;
  // tap_fname
  const char *tap_fname;
  // loglst
  struct List *loglst;
  // fstat
  enum fork_status fstat;
};

struct Suite
{
  // name
  const char *name;
  // tclst
  struct List *tclst;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct TCase
{
  // name
  const char *name;
  // timeout
  struct timespec timeout;
  // tflst
  struct List *tflst;
  // unch_sflst
  struct List *unch_sflst;
  // unch_tflst
  struct List *unch_tflst;
  // ch_sflst
  struct List *ch_sflst;
  // ch_tflst
  struct List *ch_tflst;
};

struct TF
{
  // fn
  void (*fn)(signed int);
  // loop_start
  signed int loop_start;
  // loop_end
  signed int loop_end;
  // name
  const char *name;
  // signal
  signed int signal;
  // allowed_exit_value
  signed char allowed_exit_value;
};

struct TestResult
{
  // rtype
  enum test_result rtype;
  // ctx
  enum ck_result_ctx ctx;
  // file
  char *file;
  // line
  signed int line;
  // iter
  signed int iter;
  // duration
  signed int duration;
  // tcname
  const char *tcname;
  // tname
  const char *tname;
  // msg
  char *msg;
};

struct TestStats
{
  // n_checked
  signed int n_checked;
  // n_failed
  signed int n_failed;
  // n_errors
  signed int n_errors;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous_0 __saved_mask;
};

struct itimerspec
{
  // it_interval
  struct timespec it_interval;
  // it_value
  struct timespec it_value;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous __sigaction_handler;
  // sa_mask
  struct anonymous_0 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sigevent
{
  // sigev_value
  union sigval sigev_value;
  // sigev_signo
  signed int sigev_signo;
  // sigev_notify
  signed int sigev_notify;
  // _sigev_un
  union anonymous_8 _sigev_un;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// _fstat
// file ../../src/check.c line 499
static enum fork_status _fstat = (enum fork_status)1;
// alarm_received
// file ../../src/check_run.c line 97
static signed int alarm_received;
// check_major_version
// file ../../src/check.c line 47
signed int check_major_version = 0;
// check_micro_version
// file ../../src/check.c line 49
signed int check_micro_version = 0;
// check_minor_version
// file ../../src/check.c line 48
signed int check_minor_version = 10;
// ck_mutex_lock
// file ../../src/check_pack.c line 292
static union anonymous_16 ck_mutex_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// error_jmp_buffer
// file ../../src/check_error.c line 35
struct __jmp_buf_tag error_jmp_buffer[1l];
// group_pid
// file ../../src/check_run.c line 98
static signed int group_pid;
// pftab
// file ../../src/check_pack.c line 84
static signed int (*pftab[4l])(char **, union anonymous_13 *);
// pftab
// file ../../src/check_pack.c line 84
static signed int (*pftab[4l])(char **, union anonymous_13 *) = { (signed int (*)(char **, union anonymous_13 *))pack_ctx,
    (signed int (*)(char **, union anonymous_13 *))pack_fail,
    (signed int (*)(char **, union anonymous_13 *))pack_loc,
    (signed int (*)(char **, union anonymous_13 *))pack_duration };
// s
// file ../../tests/check_thread_stress.c line 7
struct Suite *s;
// send_file1
// file ../../src/check_msg.c line 57
static struct _IO_FILE *send_file1;
// send_file1_name
// file ../../src/check_msg.c line 58
static char *send_file1_name;
// send_file2
// file ../../src/check_msg.c line 59
static struct _IO_FILE *send_file2;
// send_file2_name
// file ../../src/check_msg.c line 60
static char *send_file2_name;
// sigint_old_action
// file ../../src/check_run.c line 99
static struct sigaction sigint_old_action;
// sigterm_old_action
// file ../../src/check_run.c line 100
static struct sigaction sigterm_old_action;
// sr
// file ../../tests/check_thread_stress.c line 9
struct SRunner *sr;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// tc
// file ../../tests/check_thread_stress.c line 8
struct TCase *tc;
// upftab
// file ../../src/check_pack.c line 91
static void (*upftab[4l])(char **, union anonymous_13 *);
// upftab
// file ../../src/check_pack.c line 91
static void (*upftab[4l])(char **, union anonymous_13 *) = { (void (*)(char **, union anonymous_13 *))upack_ctx,
    (void (*)(char **, union anonymous_13 *))upack_fail,
    (void (*)(char **, union anonymous_13 *))upack_loc,
    (void (*)(char **, union anonymous_13 *))upack_duration };

// _ck_assert_failed
// file ../src/check.h line 419
void _ck_assert_failed(const char *file, signed int line, const char *expr, ...)
{
  const char *msg;
  __builtin_va_list ap;
  char buf[8192l];
  const char *to_send;
  send_loc_info(file, line);
  va_start(ap, expr);
  char *return_value_gcc_builtin_va_arg_1;
  return_value_gcc_builtin_va_arg_1=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_1));
  msg = (const char *)return_value_gcc_builtin_va_arg_1;
  if(!(msg == ((const char *)NULL)))
  {
    vsnprintf(buf, (unsigned long int)8192, msg, ap);
    to_send = buf;
  }

  else
    to_send = expr;
  va_end(ap);
  send_failure_info(to_send);
  enum fork_status return_value_cur_fork_status_2;
  return_value_cur_fork_status_2=cur_fork_status();
  if((signed int)return_value_cur_fork_status_2 == CK_FORK)
    _exit(1);

  else
    longjmp(error_jmp_buffer, 1);
}

// _mark_point
// file ../src/check.h line 782
void _mark_point(const char *file, signed int line)
{
  send_loc_info(file, line);
}

// _tcase_add_test
// file ../src/check.h line 274
void _tcase_add_test(struct TCase *tc, void (*fn)(signed int), const char *name, signed int _signal, signed int allowed_exit_value, signed int start, signed int end)
{
  struct TF *tf;
  if(!(fn == ((void (*)(signed int))NULL)) && !(name == ((const char *)NULL)) && !(tc == ((struct TCase *)NULL)))
  {
    void *return_value_emalloc_1;
    return_value_emalloc_1=emalloc(sizeof(struct TF) /*32ul*/ );
    tf = (struct TF *)return_value_emalloc_1;
    tf->fn = fn;
    tf->loop_start = start;
    tf->loop_end = end;
    tf->signal = _signal;
    tf->allowed_exit_value = (signed char)(0xFF & allowed_exit_value);
    tf->name = name;
    check_list_add_end(tc->tflst, (void *)tf);
  }

}

// check_fork
// file ../../src/check_run.c line 791
signed int check_fork(void)
{
  signed int pid;
  pid=fork();
  if(pid >= 0)
    setpgid(pid, group_pid);

  return pid;
}

// check_get_clockid
// file ../../src/check.c line 522
signed int check_get_clockid(void)
{
  static signed int clockid = -1;
  if(clockid == -1)
  {
    void *timerid;
    signed int return_value_timer_create_1;
    return_value_timer_create_1=timer_create(1, (struct sigevent *)(void *)0, &timerid);
    if(return_value_timer_create_1 == 0)
    {
      timer_delete(timerid);
      clockid = 1;
    }

    else
      clockid = 0;
  }

  return clockid;
}

// check_list_add_end
// file ../../src/check_list.h line 42
void check_list_add_end(struct List *lp, void *val)
{
  if(!(lp == ((struct List *)NULL)))
  {
    maybe_grow(lp);
    lp->last = lp->last + 1;
    lp->n_elts = lp->n_elts + 1u;
    lp->current = lp->last;
    lp->data[(signed long int)lp->current] = val;
  }

}

// check_list_add_front
// file ../../src/check_list.h line 38
void check_list_add_front(struct List *lp, void *val)
{
  if(!(lp == ((struct List *)NULL)))
  {
    maybe_grow(lp);
    memmove((void *)(lp->data + (signed long int)1), (const void *)lp->data, (unsigned long int)lp->n_elts * sizeof(void *) /*8ul*/ );
    lp->last = lp->last + 1;
    lp->n_elts = lp->n_elts + 1u;
    lp->current = 0;
    lp->data[(signed long int)lp->current] = val;
  }

}

// check_list_advance
// file ../../src/check_list.h line 48
void check_list_advance(struct List *lp)
{
  if(!(lp == ((struct List *)NULL)))
  {
    signed int return_value_check_list_at_end_1;
    return_value_check_list_at_end_1=check_list_at_end(lp);
    if(return_value_check_list_at_end_1 == 0)
      lp->current = lp->current + 1;

  }

}

// check_list_apply
// file ../../src/check_list.h line 53
void check_list_apply(struct List *lp, void (*fp)(void *))
{
  void *return_value_check_list_val_2;
  if(!(fp == ((void (*)(void *))NULL)) && !(lp == ((struct List *)NULL)))
  {
    check_list_front(lp);
    signed int return_value_check_list_at_end_1;
    return_value_check_list_at_end_1=check_list_at_end(lp);
    if(return_value_check_list_at_end_1 == 0)
    {
      return_value_check_list_val_2=check_list_val(lp);
      fp(return_value_check_list_val_2);
      check_list_advance(lp);
    }

  }

}

// check_list_at_end
// file ../../src/check_list.h line 30
signed int check_list_at_end(struct List *lp)
{
  if(lp->current == -1)
    return 1;

  else
    return (signed int)(lp->current > lp->last);
}

// check_list_create
// file ../../src/check_list.h line 27
struct List * check_list_create(void)
{
  struct List *lp;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc(sizeof(struct List) /*24ul*/ );
  lp = (struct List *)return_value_emalloc_1;
  lp->n_elts = (unsigned int)0;
  lp->max_elts = (unsigned int)1;
  void *return_value_emalloc_2;
  return_value_emalloc_2=emalloc(sizeof(void *) /*8ul*/  * (unsigned long int)1);
  lp->data = (void **)return_value_emalloc_2;
  lp->last = -1;
  lp->current = lp->last;
  return lp;
}

// check_list_free
// file ../../src/check_list.h line 51
void check_list_free(struct List *lp)
{
  if(!(lp == ((struct List *)NULL)))
  {
    free((void *)lp->data);
    free((void *)lp);
  }

}

// check_list_front
// file ../../src/check_list.h line 33
void check_list_front(struct List *lp)
{
  if(!(lp->current == -1))
    lp->current = 0;

}

// check_list_val
// file ../../src/check_list.h line 45
void * check_list_val(struct List *lp)
{
  _Bool tmp_if_expr_1;
  if(lp == ((struct List *)NULL))
    return (void *)0;

  else
  {
    if(lp->current == -1)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = lp->current > lp->last ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return (void *)0;

    else
      return lp->data[(signed long int)lp->current];
  }
}

// check_type
// file ../../src/check_pack.c line 285
static void check_type(signed int type, const char *file, signed int line)
{
  if(type >= CK_MSG_LAST || !(type >= 0))
    eprintf("Bad message type arg %d", file, line, type);

}

// check_waitpid_and_exit
// file ../../src/check_run.c line 808
void check_waitpid_and_exit(signed int pid)
{
  signed int pid_w;
  signed int status;
  if(pid >= 1)
  {
    do
      pid_w=waitpid(pid, &status, 0);
    while(pid_w == -1);
    signed int return_value_waserror_1;
    return_value_waserror_1=waserror(status, 0);
    if(!(return_value_waserror_1 == 0))
      exit(1);

  }

  exit(0);
}

// ck_do_nothing
// file ../../lib/libcompat.c line 4
void ck_do_nothing(void)
{
  /* assertion 0 */
  assert(0 != 0);
  exit(1);
}

// ck_strdup_printf
// file ../../src/check_str.h line 40
char * ck_strdup_printf(const char *fmt, ...)
{
  signed int n;
  unsigned long int size = (unsigned long int)100;
  char *p;
  void **ap;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc(size);
  p = (char *)return_value_emalloc_1;
  while((_Bool)1)
  {
    ap = (void **)&fmt;
    n=vsnprintf(p, size, fmt, ap);
    ap = ((void **)NULL);
    if(n >= 0 && !(n >= (signed int)size))
      return p;

    if(n >= 0)
      size = (unsigned long int)n + (unsigned long int)1;

    else
      size = size * (unsigned long int)2;
    void *return_value_erealloc_2;
    return_value_erealloc_2=erealloc((void *)p, size);
    p = (char *)return_value_erealloc_2;
  }
}

// construct_test_result
// file ../../src/check_msg.c line 167
static struct TestResult * construct_test_result(struct RcvMsg *rmsg, signed int waserror)
{
  struct TestResult *tr;
  if(rmsg == ((struct RcvMsg *)NULL))
    return (struct TestResult *)(void *)0;

  else
  {
    tr=tr_create();
    if(!(rmsg->msg == ((char *)NULL)) || !(waserror == 0))
    {
      if(!((signed int)rmsg->failctx == CK_CTX_INVALID))
        tr->ctx = rmsg->failctx;

      else
        tr->ctx = rmsg->lastctx;
      tr->msg = rmsg->msg;
      rmsg->msg = (char *)(void *)0;
      tr_set_loc_by_ctx(tr, tr->ctx, rmsg);
    }

    else
      if((signed int)rmsg->lastctx == CK_CTX_SETUP)
      {
        tr->ctx = (enum ck_result_ctx)CK_CTX_SETUP;
        tr->msg = (char *)(void *)0;
        tr_set_loc_by_ctx(tr, (enum ck_result_ctx)CK_CTX_SETUP, rmsg);
      }

      else
      {
        tr->ctx = (enum ck_result_ctx)CK_CTX_TEST;
        tr->msg = (char *)(void *)0;
        tr->duration = rmsg->duration;
        tr_set_loc_by_ctx(tr, (enum ck_result_ctx)CK_CTX_TEST, rmsg);
      }
    return tr;
  }
}

// cur_fork_status
// file ../../src/check.c line 509
enum fork_status cur_fork_status(void)
{
  return _fstat;
}

// emalloc
// file ../../src/check_error.h line 36
void * emalloc(unsigned long int n)
{
  void *p;
  p=malloc(n);
  if(p == NULL)
    eprintf("malloc of %u bytes failed:", "../../src/check_error.c", 64 - 2, n);

  return p;
}

// eprintf
// file ../../src/check_error.h line 33
void eprintf(const char *fmt, const char *file, signed int line, ...)
{
  void **args;
  fflush(stderr);
  fprintf(stderr, "%s:%d: ", file, line);
  args = (void **)&line;
  vfprintf(stderr, fmt, args);
  args = ((void **)NULL);
  unsigned long int return_value_strlen_3;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!((signed int)*fmt == 0))
  {
    return_value_strlen_3=strlen(fmt);
    if((signed int)fmt[-1l + (signed long int)return_value_strlen_3] == 58)
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      fprintf(stderr, " %s", return_value_strerror_2);
    }

  }

  fprintf(stderr, "\n");
  exit(2);
}

// erealloc
// file ../../src/check_error.c line 68
void * erealloc(void *ptr, unsigned long int n)
{
  void *p;
  p=realloc(ptr, n);
  if(p == NULL)
    eprintf("realloc of %u bytes failed:", "../../src/check_error.c", 74 - 2, n);

  return p;
}

// exit_msg
// file ../../src/check_run.c line 676
static char * exit_msg(signed int exitval)
{
  char *msg;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc((unsigned long int)100);
  msg = (char *)return_value_emalloc_1;
  snprintf(msg, (unsigned long int)100, "Early exit with return value %d", exitval);
  return msg;
}

// fixture_create
// file ../../src/check.c line 197
static struct Fixture * fixture_create(void (*fun)(void), signed int ischecked)
{
  struct Fixture *f;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc(sizeof(struct Fixture) /*16ul*/ );
  f = (struct Fixture *)return_value_emalloc_1;
  f->fun = fun;
  f->ischecked = ischecked;
  return f;
}

// fprint_xml_esc
// file ../../src/check_print.h line 25
void fprint_xml_esc(struct _IO_FILE *file, const char *str)
{
  for( ; !((signed int)*str == 0); str = str + 1l)
    switch((signed int)*str)
    {
      case 34:
      {
        fputs("&quot;", file);
        break;
      }
      case 39:
      {
        fputs("&apos;", file);
        break;
      }
      case 60:
      {
        fputs("&lt;", file);
        break;
      }
      case 62:
      {
        fputs("&gt;", file);
        break;
      }
      case 38:
      {
        fputs("&amp;", file);
        break;
      }
      default:
        fputc((signed int)*str, file);
    }
}

// get_env_printmode
// file ../../src/check_print.h line 29
enum print_output get_env_printmode(void)
{
  char *env;
  env=getenv("CK_VERBOSITY");
  if(env == ((char *)NULL))
    return (enum print_output)CK_NORMAL;

  else
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(env, "silent");
    if(return_value_strcmp_1 == 0)
      return (enum print_output)CK_SILENT;

    else
    {
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(env, "minimal");
      if(return_value_strcmp_2 == 0)
        return (enum print_output)CK_MINIMAL;

      else
      {
        signed int return_value_strcmp_3;
        return_value_strcmp_3=strcmp(env, "verbose");
        if(return_value_strcmp_3 == 0)
          return (enum print_output)CK_VERBOSE;

        else
          return (enum print_output)CK_NORMAL;
      }
    }
  }
}

// get_pipe
// file ../../src/check_msg.c line 68
static struct _IO_FILE * get_pipe(void)
{
  if(!(send_file2 == ((struct _IO_FILE *)NULL)))
    return send_file2;

  else
    if(!(send_file1 == ((struct _IO_FILE *)NULL)))
      return send_file1;

    else
    {
      eprintf("No messaging setup", "../../src/check_msg.c", 80);
      return (struct _IO_FILE *)(void *)0;
    }
}

// get_result
// file ../../src/check_pack.c line 336
static signed int get_result(char *buf, struct RcvMsg *rmsg)
{
  enum ck_msg_type type;
  union anonymous_13 msg;
  signed int n;
  n=upack(buf, &msg, &type);
  if(n == -1)
    eprintf("Error in call to upack", "../../src/check_pack.c", 344 - 2);

  if((signed int)type == CK_MSG_CTX)
  {
    struct CtxMsg *cmsg = (struct CtxMsg *)&msg;
    rcvmsg_update_ctx(rmsg, cmsg->ctx);
  }

  else
    if((signed int)type == CK_MSG_LOC)
    {
      struct LocMsg *lmsg = (struct LocMsg *)&msg;
      if((signed int)rmsg->failctx == CK_CTX_INVALID)
        rcvmsg_update_loc(rmsg, lmsg->file, lmsg->line);

      free((void *)lmsg->file);
    }

    else
      if((signed int)type == CK_MSG_FAIL)
      {
        struct FailMsg *fmsg = (struct FailMsg *)&msg;
        if(rmsg->msg == ((char *)NULL))
        {
          rmsg->msg=strdup(fmsg->msg);
          rmsg->failctx = rmsg->lastctx;
        }

        free((void *)fmsg->msg);
      }

      else
        if((signed int)type == CK_MSG_DURATION)
        {
          struct DurationMsg *get_result__1__4__cmsg = (struct DurationMsg *)&msg;
          rmsg->duration = get_result__1__4__cmsg->duration;
        }

        else
          check_type((signed int)type, "../../src/check_pack.c", 384);
  return n;
}

// lfile_lfun
// file ../../src/check_log.c line 227
void lfile_lfun(struct SRunner *sr, struct _IO_FILE *file, enum print_output printmode, void *obj, enum cl_event evt)
{
  struct TestResult *tr;
  struct Suite *lfile_lfun__1__s;
  switch((signed int)evt)
  {
    case CLINITLOG_SR:
      break;
    case CLENDLOG_SR:
      break;
    case CLSTART_SR:
      break;
    case CLSTART_S:
    {
      lfile_lfun__1__s = (struct Suite *)obj;
      fprintf(file, "Running suite %s\n", lfile_lfun__1__s->name);
      break;
    }
    case CLEND_SR:
    {
      fprintf(file, "Results for all suites run:\n");
      srunner_fprint(file, sr, (enum print_output)CK_MINIMAL);
      break;
    }
    case CLEND_S:
      break;
    case CLSTART_T:
      break;
    case CLEND_T:
    {
      tr = (struct TestResult *)obj;
      tr_fprint(file, tr, (enum print_output)CK_VERBOSE);
      break;
    }
    default:
      eprintf("Bad event type received in lfile_lfun", "../../src/check_log.c", 260);
  }
}

// log_srunner_end
// file ../../src/check_log.c line 136
void log_srunner_end(struct SRunner *sr)
{
  srunner_send_evt(sr, (void *)0, (enum cl_event)CLEND_SR);
}

// log_srunner_start
// file ../../src/check_log.c line 131
void log_srunner_start(struct SRunner *sr)
{
  srunner_send_evt(sr, (void *)0, (enum cl_event)CLSTART_SR);
}

// log_suite_end
// file ../../src/check_log.c line 146
void log_suite_end(struct SRunner *sr, struct Suite *s)
{
  srunner_send_evt(sr, (void *)s, (enum cl_event)CLEND_S);
}

// log_suite_start
// file ../../src/check_log.c line 141
void log_suite_start(struct SRunner *sr, struct Suite *s)
{
  srunner_send_evt(sr, (void *)s, (enum cl_event)CLSTART_S);
}

// log_test_end
// file ../../src/check_log.c line 159
void log_test_end(struct SRunner *sr, struct TestResult *tr)
{
  srunner_send_evt(sr, (void *)tr, (enum cl_event)CLEND_T);
}

// log_test_start
// file ../../src/check_log.c line 151
void log_test_start(struct SRunner *sr, struct TCase *tc, struct TF *tfun)
{
  char buffer[100l];
  snprintf(buffer, (unsigned long int)99, "%s:%s", tc->name, tfun->name);
  srunner_send_evt(sr, (void *)buffer, (enum cl_event)CLSTART_T);
}

// main
// file ../../tests/check_thread_stress.c line 57
signed int main(void)
{
  signed int nf;
  s=suite_create("ForkThreadStress");
  tc=tcase_create("ForkThreadStress");
  sr=srunner_create(s);
  suite_add_tcase(s, tc);
  _tcase_add_test(tc, test_stress_threads, "test_stress_threads", 0, 0, 0, 100);
  _tcase_add_test(tc, test_stress_forks, "test_stress_forks", 0, 0, 0, 100);
  srunner_run_all(sr, (enum print_output)CK_VERBOSE);
  nf=srunner_ntests_failed(sr);
  srunner_free(sr);
  return nf != 0 ? 1 : 0;
}

// maybe_grow
// file ../../src/check_list.c line 45
static void maybe_grow(struct List *lp)
{
  if(lp->n_elts >= lp->max_elts)
  {
    lp->max_elts = lp->max_elts * (unsigned int)2;
    void *return_value_erealloc_1;
    return_value_erealloc_1=erealloc((void *)lp->data, (unsigned long int)lp->max_elts * sizeof(void *) /*8ul*/ );
    lp->data = (void **)return_value_erealloc_1;
  }

}

// non_pass
// file ../../src/check.c line 435
static signed int non_pass(signed int val)
{
  return (signed int)(val != CK_PASS);
}

// open_tmp_file
// file ../../src/check_msg.c line 227
struct _IO_FILE * open_tmp_file(char **name)
{
  struct _IO_FILE *file = (struct _IO_FILE *)(void *)0;
  *name = (char *)(void *)0;
  signed int fd = -1;
  const char *tmp_dir;
  tmp_dir=getenv("TEMP");
  if(tmp_dir == ((const char *)NULL))
    tmp_dir = ".";

  *name=ck_strdup_printf("%s/check_XXXXXX", tmp_dir);
  fd=mkstemp(*name);
  if(fd >= 0)
  {
    file=fdopen(fd, "w+b");
    signed int return_value_unlink_1;
    return_value_unlink_1=unlink(*name);
    if(file == ((struct _IO_FILE *)NULL) || return_value_unlink_1 == 0)
    {
      free((void *)*name);
      *name = (char *)(void *)0;
    }

  }

  return file;
}

// pack
// file ../../src/check_pack.c line 98
signed int pack(enum ck_msg_type type, char **buf, union anonymous_13 *msg)
{
  if(buf == ((char **)NULL))
    return -1;

  else
    if(msg == ((union anonymous_13 *)NULL))
      return 0;

    else
    {
      check_type((signed int)type, "../../src/check_pack.c", 105);
      signed int return_value;
      return_value=pftab[(signed long int)type](buf, msg);
      return return_value;
    }
}

// pack_ctx
// file ../../src/check_pack.c line 207
static signed int pack_ctx(char **buf, struct CtxMsg *cmsg)
{
  char *ptr;
  signed int len = 4 + 4;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc((unsigned long int)len);
  ptr = (char *)return_value_emalloc_1;
  *buf = ptr;
  pack_type(&ptr, (enum ck_msg_type)CK_MSG_CTX);
  pack_int(&ptr, (signed int)cmsg->ctx);
  return len;
}

// pack_duration
// file ../../src/check_pack.c line 226
static signed int pack_duration(char **buf, struct DurationMsg *cmsg)
{
  char *ptr;
  signed int len = 4 + 4;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc((unsigned long int)len);
  ptr = (char *)return_value_emalloc_1;
  *buf = ptr;
  pack_type(&ptr, (enum ck_msg_type)CK_MSG_DURATION);
  pack_int(&ptr, cmsg->duration);
  return len;
}

// pack_fail
// file ../../src/check_pack.c line 266
static signed int pack_fail(char **buf, struct FailMsg *fmsg)
{
  char *ptr;
  signed int len;
  unsigned long int tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(!(fmsg->msg == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(fmsg->msg);
    tmp_if_expr_2 = return_value_strlen_1;
  }

  else
    tmp_if_expr_2 = (unsigned long int)0;
  len = (signed int)((unsigned long int)(4 + 4) + tmp_if_expr_2);
  void *return_value_emalloc_3;
  return_value_emalloc_3=emalloc((unsigned long int)len);
  ptr = (char *)return_value_emalloc_3;
  *buf = ptr;
  pack_type(&ptr, (enum ck_msg_type)CK_MSG_FAIL);
  pack_str(&ptr, fmsg->msg);
  return len;
}

// pack_int
// file ../../src/check_pack.c line 128
static void pack_int(char **buf, signed int val)
{
  unsigned char *ubuf = (unsigned char *)*buf;
  unsigned int uval = (unsigned int)val;
  ubuf[(signed long int)0] = (unsigned char)(uval >> 24 & (unsigned int)0xFF);
  ubuf[(signed long int)1] = (unsigned char)(uval >> 16 & (unsigned int)0xFF);
  ubuf[(signed long int)2] = (unsigned char)(uval >> 8 & (unsigned int)0xFF);
  ubuf[(signed long int)3] = (unsigned char)(uval & (unsigned int)0xFF);
  *buf = *buf + (signed long int)4;
}

// pack_loc
// file ../../src/check_pack.c line 245
static signed int pack_loc(char **buf, struct LocMsg *lmsg)
{
  char *ptr;
  signed int len;
  unsigned long int tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(!(lmsg->file == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(lmsg->file);
    tmp_if_expr_2 = return_value_strlen_1;
  }

  else
    tmp_if_expr_2 = (unsigned long int)0;
  len = (signed int)((unsigned long int)(4 + 4) + tmp_if_expr_2 + (unsigned long int)4);
  void *return_value_emalloc_3;
  return_value_emalloc_3=emalloc((unsigned long int)len);
  ptr = (char *)return_value_emalloc_3;
  *buf = ptr;
  pack_type(&ptr, (enum ck_msg_type)CK_MSG_LOC);
  pack_str(&ptr, lmsg->file);
  pack_int(&ptr, lmsg->line);
  return len;
}

// pack_str
// file ../../src/check_pack.c line 155
static void pack_str(char **buf, const char *val)
{
  signed int strsz;
  unsigned long int return_value_strlen_1;
  if(val == ((const char *)NULL))
    strsz = 0;

  else
  {
    return_value_strlen_1=strlen(val);
    strsz = (signed int)return_value_strlen_1;
  }
  pack_int(buf, strsz);
  if(strsz >= 1)
  {
    memcpy((void *)*buf, (const void *)val, (unsigned long int)strsz);
    *buf = *buf + (signed long int)strsz;
  }

}

// pack_type
// file ../../src/check_pack.c line 196
static void pack_type(char **buf, enum ck_msg_type type)
{
  pack_int(buf, (signed int)type);
}

// pass_msg
// file ../../src/check_run.c line 437
static char * pass_msg(void)
{
  char *return_value_strdup_1;
  return_value_strdup_1=strdup("Passed");
  return return_value_strdup_1;
}

// percent_passed
// file ../../src/check_str.c line 126
static signed int percent_passed(struct TestStats *t)
{
  _Bool tmp_if_expr_1;
  if(t->n_failed == 0)
    tmp_if_expr_1 = t->n_errors == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    return 100;

  else
    if(t->n_checked == 0)
      return 0;

    else
      return (signed int)(((float)(t->n_checked - (t->n_failed + t->n_errors)) / (float)t->n_checked) * (float)100);
}

// ppack
// file ../../src/check_pack.h line 81
void ppack(struct _IO_FILE *fdes, enum ck_msg_type type, union anonymous_13 *msg)
{
  char *buf = (char *)(void *)0;
  signed int n;
  signed long int r;
  n=pack(type, &buf, msg);
  if(n >= 4097)
    eprintf("Message string too long", "../../src/check_pack.c", 308 - 2);

  do
  {
    struct anonymous_15 __cancel_buf;
    void (*__cancel_routine)(void *) = ppack_cleanup;
    void *__cancel_arg = (void *)&ck_mutex_lock;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pthread_mutex_lock(&ck_mutex_lock);
      unsigned long int return_value_fwrite_1;
      return_value_fwrite_1=fwrite((const void *)buf, (unsigned long int)1, (unsigned long int)n, fdes);
      r = (signed long int)return_value_fwrite_1;
      fflush(fdes);
      pthread_mutex_unlock(&ck_mutex_lock);

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
  }
  while((_Bool)0);
  if(!(r == (signed long int)n))
    eprintf("Error in call to fwrite:", "../../src/check_pack.c", 317 - 2);

  free((void *)buf);
}

// ppack_cleanup
// file ../../src/check_pack.c line 293
static void ppack_cleanup(void *mutex)
{
  pthread_mutex_unlock((union anonymous_16 *)mutex);
}

// punpack
// file ../../src/check_pack.h line 82
struct RcvMsg * punpack(struct _IO_FILE *fdes)
{
  signed int nread;
  signed int nparse;
  signed int n;
  char *buf;
  struct RcvMsg *rmsg;
  rmsg=rcvmsg_create();
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc((unsigned long int)8192);
  buf = (char *)return_value_emalloc_1;
  nread=read_buf(fdes, 8192, buf);
  nparse = nread;
  while(nparse >= 1)
  {
    n=get_result(buf, rmsg);
    nparse = nparse - n;
    memmove((void *)buf, (const void *)(buf + (signed long int)n), (unsigned long int)nparse);
    if(nread >= 1)
    {
      nread=read_buf(fdes, n, buf + (signed long int)nparse);
      nparse = nparse + nread;
    }

  }
  free((void *)buf);
  if((signed int)rmsg->lastctx == CK_CTX_INVALID)
  {
    free((void *)rmsg);
    rmsg = (struct RcvMsg *)(void *)0;
  }

  return rmsg;
}

// rcvmsg_create
// file ../../src/check_pack.c line 401
static struct RcvMsg * rcvmsg_create(void)
{
  struct RcvMsg *rmsg;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc(sizeof(struct RcvMsg) /*56ul*/ );
  rmsg = (struct RcvMsg *)return_value_emalloc_1;
  rmsg->lastctx = (enum ck_result_ctx)CK_CTX_INVALID;
  rmsg->failctx = (enum ck_result_ctx)CK_CTX_INVALID;
  rmsg->msg = (char *)(void *)0;
  rmsg->duration = -1;
  reset_rcv_test(rmsg);
  reset_rcv_fixture(rmsg);
  return rmsg;
}

// rcvmsg_free
// file ../../src/check_pack.h line 75
void rcvmsg_free(struct RcvMsg *rmsg)
{
  free((void *)rmsg->fixture_file);
  free((void *)rmsg->test_file);
  free((void *)rmsg->msg);
  free((void *)rmsg);
}

// rcvmsg_update_ctx
// file ../../src/check_pack.c line 423
static void rcvmsg_update_ctx(struct RcvMsg *rmsg, enum ck_result_ctx ctx)
{
  if(!((signed int)rmsg->lastctx == CK_CTX_INVALID))
  {
    free((void *)rmsg->fixture_file);
    reset_rcv_fixture(rmsg);
  }

  rmsg->lastctx = ctx;
}

// rcvmsg_update_loc
// file ../../src/check_pack.c line 433
static void rcvmsg_update_loc(struct RcvMsg *rmsg, const char *file, signed int line)
{
  if((signed int)rmsg->lastctx == CK_CTX_TEST)
  {
    free((void *)rmsg->test_file);
    rmsg->test_line = line;
    rmsg->test_file=strdup(file);
  }

  else
  {
    free((void *)rmsg->fixture_file);
    rmsg->fixture_line = line;
    rmsg->fixture_file=strdup(file);
  }
}

// read_buf
// file ../../src/check_pack.c line 322
static signed int read_buf(struct _IO_FILE *fdes, signed int size, char *buf)
{
  signed int n;
  unsigned long int return_value_fread_1;
  return_value_fread_1=fread((void *)buf, (unsigned long int)1, (unsigned long int)size, fdes);
  n = (signed int)return_value_fread_1;
  signed int return_value_ferror_2;
  return_value_ferror_2=ferror(fdes);
  if(!(return_value_ferror_2 == 0))
    eprintf("Error in call to fread:", "../../src/check_pack.c", 330 - 4);

  return n;
}

// receive_result_info_fork
// file ../../src/check_run.c line 514
static struct TestResult * receive_result_info_fork(const char *tcname, const char *tname, signed int iter, signed int status, signed int expected_signal, signed char allowed_exit_value)
{
  struct TestResult *tr;
  signed int return_value_waserror_1;
  return_value_waserror_1=waserror(status, expected_signal);
  tr=receive_test_result(return_value_waserror_1);
  if(tr == ((struct TestResult *)NULL))
    eprintf("Failed to receive test result", "../../src/check_run.c", 525);

  else
  {
    tr->tcname = tcname;
    tr->tname = tname;
    tr->iter = iter;
    set_fork_info(tr, status, expected_signal, allowed_exit_value);
  }
  return tr;
}

// receive_result_info_nofork
// file ../../src/check_run.c line 401
static struct TestResult * receive_result_info_nofork(const char *tcname, const char *tname, signed int iter, signed int duration)
{
  struct TestResult *tr;
  tr=receive_test_result(0);
  if(tr == ((struct TestResult *)NULL))
    eprintf("Failed to receive test result", "../../src/check_run.c", 410);

  else
  {
    tr->tcname = tcname;
    tr->tname = tname;
    tr->iter = iter;
    tr->duration = duration;
    set_nofork_info(tr);
  }
  return tr;
}

// receive_test_result
// file ../../src/check_msg.c line 120
struct TestResult * receive_test_result(signed int waserror)
{
  struct _IO_FILE *fp;
  struct RcvMsg *rmsg;
  struct TestResult *result;
  fp=get_pipe();
  if(fp == ((struct _IO_FILE *)NULL))
    eprintf("Error in call to get_pipe", "../../src/check_msg.c", 129 - 2);

  rewind(fp);
  rmsg=punpack(fp);
  if(rmsg == ((struct RcvMsg *)NULL))
    eprintf("Error in call to punpack", "../../src/check_msg.c", 137 - 4);

  teardown_pipe();
  setup_pipe();
  result=construct_test_result(rmsg, waserror);
  rcvmsg_free(rmsg);
  return result;
}

// reset_rcv_fixture
// file ../../src/check_pack.c line 395
static void reset_rcv_fixture(struct RcvMsg *rmsg)
{
  rmsg->fixture_line = -1;
  rmsg->fixture_file = (char *)(void *)0;
}

// reset_rcv_test
// file ../../src/check_pack.c line 389
static void reset_rcv_test(struct RcvMsg *rmsg)
{
  rmsg->test_line = -1;
  rmsg->test_file = (char *)(void *)0;
}

// send_ctx_info
// file ../../src/check_msg.h line 29
void send_ctx_info(enum ck_result_ctx ctx)
{
  struct CtxMsg cmsg;
  cmsg.ctx = ctx;
  struct _IO_FILE *return_value_get_pipe_1;
  return_value_get_pipe_1=get_pipe();
  ppack(return_value_get_pipe_1, (enum ck_msg_type)CK_MSG_CTX, (union anonymous_13 *)&cmsg);
}

// send_duration_info
// file ../../src/check_msg.c line 94
void send_duration_info(signed int duration)
{
  struct DurationMsg dmsg;
  dmsg.duration = duration;
  struct _IO_FILE *return_value_get_pipe_1;
  return_value_get_pipe_1=get_pipe();
  ppack(return_value_get_pipe_1, (enum ck_msg_type)CK_MSG_DURATION, (union anonymous_13 *)&dmsg);
}

// send_failure_info
// file ../../src/check_msg.h line 27
void send_failure_info(const char *msg)
{
  struct FailMsg fmsg;
  fmsg.msg=strdup(msg);
  struct _IO_FILE *return_value_get_pipe_1;
  return_value_get_pipe_1=get_pipe();
  ppack(return_value_get_pipe_1, (enum ck_msg_type)CK_MSG_FAIL, (union anonymous_13 *)&fmsg);
  free((void *)fmsg.msg);
}

// send_loc_info
// file ../../src/check_msg.h line 28
void send_loc_info(const char *file, signed int line)
{
  struct LocMsg lmsg;
  lmsg.file=strdup(file);
  lmsg.line = line;
  struct _IO_FILE *return_value_get_pipe_1;
  return_value_get_pipe_1=get_pipe();
  ppack(return_value_get_pipe_1, (enum ck_msg_type)CK_MSG_LOC, (union anonymous_13 *)&lmsg);
  free((void *)lmsg.file);
}

// sendinfo
// file ../../tests/check_thread_stress.c line 13
static void * sendinfo(void *userdata)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= 999u); i = i + 1u)
    _mark_point("../../tests/check_thread_stress.c", 18);
  return (void *)0;
}

// set_fork_info
// file ../../src/check_run.c line 538
static void set_fork_info(struct TestResult *tr, signed int status, signed int signal_expected, signed char allowed_exit_value)
{
  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_1
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  signed int was_sig = (signed int)((signed int)(signed char)((((union anonymous_1){ .__in=status }).__i & 0x7f) + 1) >> 1 > 0);
  signed int was_exit = (signed int)((((union anonymous_1){ .__in=status }).__i & 0x7f) == 0);
  signed char exit_status = (signed char)((((union anonymous_1){ .__in=status }).__i & 0xff00) >> 8);
  signed int signal_received = ((union anonymous_1){ .__in=status }).__i & 0x7f;
  if(!(was_sig == 0))
  {
    if(signal_expected == signal_received)
    {
      if(!(alarm_received == 0))
      {
        tr->rtype = (enum test_result)CK_ERROR;
        if(!(tr->msg == ((char *)NULL)))
          free((void *)tr->msg);

        tr->msg=signal_error_msg(signal_received, signal_expected);
      }

      else
      {
        tr->rtype = (enum test_result)CK_PASS;
        if(!(tr->msg == ((char *)NULL)))
          free((void *)tr->msg);

        tr->msg=pass_msg();
      }
    }

    else
      if(!(signal_expected == 0))
      {
        tr->rtype = (enum test_result)CK_ERROR;
        if(!(tr->msg == ((char *)NULL)))
          free((void *)tr->msg);

        tr->msg=signal_error_msg(signal_received, signal_expected);
      }

      else
      {
        tr->rtype = (enum test_result)CK_ERROR;
        if(!(tr->msg == ((char *)NULL)))
          free((void *)tr->msg);

        tr->msg=signal_msg(signal_received);
      }
  }

  else
    if(signal_expected == 0)
    {
      if(exit_status == allowed_exit_value && !(was_exit == 0))
      {
        tr->rtype = (enum test_result)CK_PASS;
        if(!(tr->msg == ((char *)NULL)))
          free((void *)tr->msg);

        tr->msg=pass_msg();
      }

      else
        if(!(was_exit == 0) && !(exit_status == allowed_exit_value))
        {
          if(tr->msg == ((char *)NULL))
          {
            tr->rtype = (enum test_result)CK_ERROR;
            tr->msg=exit_msg((signed int)exit_status);
          }

          else
            tr->rtype = (enum test_result)CK_FAILURE;
        }

    }

    else
      if(!(was_exit == 0))
      {
        if(!(tr->msg == ((char *)NULL)))
          free((void *)tr->msg);

        tr->msg=exit_msg((signed int)exit_status);
        if(exit_status == allowed_exit_value)
          tr->rtype = (enum test_result)CK_FAILURE;

        else
          tr->rtype = (enum test_result)CK_FAILURE;
      }

}

// set_fork_status
// file ../../src/check.c line 501
void set_fork_status(enum fork_status fstat)
{
  if((signed int)fstat == CK_FORK_GETENV || (signed int)fstat == CK_FORK || (signed int)fstat == CK_NOFORK)
    _fstat = fstat;

  else
    eprintf("Bad status in set_fork_status", "../../src/check.c", 506);
}

// set_nofork_info
// file ../../src/check_run.c line 424
static void set_nofork_info(struct TestResult *tr)
{
  if(tr->msg == ((char *)NULL))
  {
    tr->rtype = (enum test_result)CK_PASS;
    tr->msg=pass_msg();
  }

  else
    tr->rtype = (enum test_result)CK_FAILURE;
}

// setup_messaging
// file ../../src/check_msg.c line 208
void setup_messaging(void)
{
  setup_pipe();
}

// setup_pipe
// file ../../src/check_msg.c line 288
static void setup_pipe(void)
{
  if(send_file1 == ((struct _IO_FILE *)NULL))
    send_file1=open_tmp_file(&send_file1_name);

  else
    if(send_file2 == ((struct _IO_FILE *)NULL))
      send_file2=open_tmp_file(&send_file2_name);

    else
      eprintf("Only one nesting of suite runs supported", "../../src/check_msg.c", 300);
}

// sig_handler
// file ../../src/check_run.c line 102
static void sig_handler(signed int sig_nr)
{
  signed int own_group_pid;
  signed int child_sig;
  switch(sig_nr)
  {
    case 14:
    {
      alarm_received = 1;
      killpg(group_pid, 9);
      break;
    }
    case 15:

    case 2:
    {
      child_sig = 15;
      if(sig_nr == 2)
      {
        child_sig = 9;
        sigaction(2, &sigint_old_action, (struct sigaction *)(void *)0);
      }

      else
        sigaction(15, &sigterm_old_action, (struct sigaction *)(void *)0);
      killpg(group_pid, child_sig);
      own_group_pid=getpgrp();
      killpg(own_group_pid, sig_nr);
      break;
    }
    default:
      eprintf("Unhandled signal: %d", "../../src/check_run.c", 136, sig_nr);
  }
}

// signal_error_msg
// file ../../src/check_run.c line 652
static char * signal_error_msg(signed int signal_received, signed int signal_expected)
{
  char *sig_r_str;
  char *sig_e_str;
  char *msg;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc((unsigned long int)100);
  msg = (char *)return_value_emalloc_1;
  char *return_value_strsignal_2;
  return_value_strsignal_2=strsignal(signal_received);
  sig_r_str=strdup(return_value_strsignal_2);
  char *return_value_strsignal_3;
  return_value_strsignal_3=strsignal(signal_expected);
  sig_e_str=strdup(return_value_strsignal_3);
  if(!(alarm_received == 0))
    snprintf(msg, (unsigned long int)100, "Test timeout expired, expected signal %d (%s)", signal_expected, sig_e_str);

  else
    snprintf(msg, (unsigned long int)100, "Received signal %d (%s), expected %d (%s)", signal_received, sig_r_str, signal_expected, sig_e_str);
  free((void *)sig_r_str);
  free((void *)sig_e_str);
  return msg;
}

// signal_msg
// file ../../src/check_run.c line 636
static char * signal_msg(signed int signal)
{
  char *msg;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc((unsigned long int)100);
  msg = (char *)return_value_emalloc_1;
  if(!(alarm_received == 0))
    snprintf(msg, (unsigned long int)100, "Test timeout expired");

  else
  {
    char *return_value_strsignal_2;
    return_value_strsignal_2=strsignal(signal);
    snprintf(msg, (unsigned long int)100, "Received signal %d (%s)", signal, return_value_strsignal_2);
  }
  return msg;
}

// sr_stat_str
// file ../../src/check_str.h line 38
char * sr_stat_str(struct SRunner *sr)
{
  char *str;
  struct TestStats *ts = sr->stats;
  signed int return_value_percent_passed_1;
  return_value_percent_passed_1=percent_passed(ts);
  str=ck_strdup_printf("%d%%: Checks: %d, Failures: %d, Errors: %d", return_value_percent_passed_1, ts->n_checked, ts->n_failed, ts->n_errors);
  return str;
}

// srunner_add_failure
// file ../../src/check_run.c line 247
static void srunner_add_failure(struct SRunner *sr, struct TestResult *tr)
{
  check_list_add_end(sr->resultlst, (void *)tr);
  sr->stats->n_checked = sr->stats->n_checked + 1;
  if((signed int)tr->rtype == CK_FAILURE)
    sr->stats->n_failed = sr->stats->n_failed + 1;

  else
    if((signed int)tr->rtype == CK_ERROR)
      sr->stats->n_errors = sr->stats->n_errors + 1;

}

// srunner_add_suite
// file ../../src/check.c line 352
void srunner_add_suite(struct SRunner *sr, struct Suite *s)
{
  if(!(s == ((struct Suite *)NULL)))
    check_list_add_end(sr->slst, (void *)s);

}

// srunner_create
// file ../src/check.h line 920
struct SRunner * srunner_create(struct Suite *s)
{
  struct SRunner *srunner_create__1__sr;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc(sizeof(struct SRunner) /*64ul*/ );
  srunner_create__1__sr = (struct SRunner *)return_value_emalloc_1;
  srunner_create__1__sr->slst=check_list_create();
  if(!(s == ((struct Suite *)NULL)))
    check_list_add_end(srunner_create__1__sr->slst, (void *)s);

  void *return_value_emalloc_2;
  return_value_emalloc_2=emalloc(sizeof(struct TestStats) /*12ul*/ );
  srunner_create__1__sr->stats = (struct TestStats *)return_value_emalloc_2;
  srunner_create__1__sr->stats->n_errors = 0;
  srunner_create__1__sr->stats->n_failed = srunner_create__1__sr->stats->n_errors;
  srunner_create__1__sr->stats->n_checked = srunner_create__1__sr->stats->n_failed;
  srunner_create__1__sr->resultlst=check_list_create();
  srunner_create__1__sr->log_fname = (const char *)(void *)0;
  srunner_create__1__sr->xml_fname = (const char *)(void *)0;
  srunner_create__1__sr->tap_fname = (const char *)(void *)0;
  srunner_create__1__sr->loglst = (struct List *)(void *)0;
  srunner_create__1__sr->fstat = (enum fork_status)CK_FORK_GETENV;
  return srunner_create__1__sr;
}

// srunner_end_logging
// file ../../src/check_log.c line 532
void srunner_end_logging(struct SRunner *sr)
{
  struct List *l;
  signed int rval;
  srunner_send_evt(sr, (void *)0, (enum cl_event)CLENDLOG_SR);
  l = sr->loglst;
  check_list_front(l);
  signed int return_value_check_list_at_end_1;
  do
  {
    return_value_check_list_at_end_1=check_list_at_end(l);
    if(!(return_value_check_list_at_end_1 == 0))
      break;

    struct Log *lg;
    void *return_value_check_list_val_2;
    return_value_check_list_val_2=check_list_val(l);
    lg = (struct Log *)return_value_check_list_val_2;
    if(!(lg->close == 0))
    {
      rval=fclose(lg->lfile);
      if(!(rval == 0))
        eprintf("Error in call to fclose while closing log file:", "../../src/check_log.c", 549 - 2);

    }

    free((void *)lg);
    check_list_advance(l);
  }
  while((_Bool)1);
  check_list_free(l);
  sr->loglst = (struct List *)(void *)0;
}

// srunner_failures
// file ../../src/check.c line 397
struct TestResult ** srunner_failures(struct SRunner *sr)
{
  signed int i = 0;
  struct TestResult **trarray;
  struct List *rlst;
  signed int return_value_srunner_ntests_failed_1;
  return_value_srunner_ntests_failed_1=srunner_ntests_failed(sr);
  void *return_value_emalloc_2;
  return_value_emalloc_2=emalloc(sizeof(struct TestResult *) /*8ul*/  * (unsigned long int)return_value_srunner_ntests_failed_1);
  trarray = (struct TestResult **)return_value_emalloc_2;
  rlst = sr->resultlst;
  check_list_front(rlst);
  signed int return_value_check_list_at_end_3;
  signed int tmp_post_5;
  do
  {
    return_value_check_list_at_end_3=check_list_at_end(rlst);
    if(!(return_value_check_list_at_end_3 == 0))
      break;

    struct TestResult *tr;
    void *return_value_check_list_val_4;
    return_value_check_list_val_4=check_list_val(rlst);
    tr = (struct TestResult *)return_value_check_list_val_4;
    signed int return_value_non_pass_6;
    return_value_non_pass_6=non_pass((signed int)tr->rtype);
    if(!(return_value_non_pass_6 == 0))
    {
      tmp_post_5 = i;
      i = i + 1;
      trarray[(signed long int)tmp_post_5] = tr;
    }

    check_list_advance(rlst);
  }
  while((_Bool)1);
  return trarray;
}

// srunner_fork_status
// file ../../src/check_run.c line 696
enum fork_status srunner_fork_status(struct SRunner *sr)
{
  if((signed int)sr->fstat == CK_FORK_GETENV)
  {
    char *env;
    env=getenv("CK_FORK");
    if(env == ((char *)NULL))
      return (enum fork_status)CK_FORK;

    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(env, "no");
    if(return_value_strcmp_1 == 0)
      return (enum fork_status)CK_NOFORK;

    else
      return (enum fork_status)CK_FORK;
  }

  else
    return sr->fstat;
}

// srunner_fprint
// file ../../src/check_print.h line 28
void srunner_fprint(struct _IO_FILE *file, struct SRunner *sr, enum print_output print_mode)
{
  if((signed int)print_mode == CK_ENV)
    print_mode=get_env_printmode();

  srunner_fprint_summary(file, sr, print_mode);
  srunner_fprint_results(file, sr, print_mode);
}

// srunner_fprint_results
// file ../../src/check_print.c line 74
static void srunner_fprint_results(struct _IO_FILE *file, struct SRunner *sr, enum print_output print_mode)
{
  struct List *resultlst;
  signed int return_value_check_list_at_end_1;
  if(!((signed int)print_mode == CK_SUBUNIT))
  {
    resultlst = sr->resultlst;
    check_list_front(resultlst);
    do
    {
      return_value_check_list_at_end_1=check_list_at_end(resultlst);
      if(!(return_value_check_list_at_end_1 == 0))
        break;

      struct TestResult *tr;
      void *return_value_check_list_val_2;
      return_value_check_list_val_2=check_list_val(resultlst);
      tr = (struct TestResult *)return_value_check_list_val_2;
      tr_fprint(file, tr, print_mode);
      check_list_advance(resultlst);
    }
    while((_Bool)1);
    goto __CPROVER_DUMP_L4;
  }


__CPROVER_DUMP_L4:
  ;
}

// srunner_fprint_summary
// file ../../src/check_print.c line 55
static void srunner_fprint_summary(struct _IO_FILE *file, struct SRunner *sr, enum print_output print_mode)
{
  if(!((signed int)print_mode == CK_SUBUNIT))
  {
    if((signed int)print_mode >= CK_MINIMAL)
    {
      char *str;
      str=sr_stat_str(sr);
      fprintf(file, "%s\n", str);
      free((void *)str);
    }

  }

}

// srunner_free
// file ../src/check.h line 946
void srunner_free(struct SRunner *sr)
{
  struct List *l;
  struct TestResult *tr;
  signed int return_value_check_list_at_end_1;
  signed int return_value_check_list_at_end_3;
  if(!(sr == ((struct SRunner *)NULL)))
  {
    free((void *)sr->stats);
    l = sr->slst;
    check_list_front(l);
    do
    {
      return_value_check_list_at_end_1=check_list_at_end(l);
      if(!(return_value_check_list_at_end_1 == 0))
        break;

      void *return_value_check_list_val_2;
      return_value_check_list_val_2=check_list_val(l);
      suite_free((struct Suite *)return_value_check_list_val_2);
      check_list_advance(l);
    }
    while((_Bool)1);
    check_list_free(sr->slst);
    l = sr->resultlst;
    check_list_front(l);
    do
    {
      return_value_check_list_at_end_3=check_list_at_end(l);
      if(!(return_value_check_list_at_end_3 == 0))
        break;

      void *return_value_check_list_val_4;
      return_value_check_list_val_4=check_list_val(l);
      tr = (struct TestResult *)return_value_check_list_val_4;
      tr_free(tr);
      check_list_advance(l);
    }
    while((_Bool)1);
    check_list_free(sr->resultlst);
    free((void *)sr);
  }

}

// srunner_has_log
// file ../../src/check_log.c line 52
signed int srunner_has_log(struct SRunner *sr)
{
  const char *return_value_srunner_log_fname_1;
  return_value_srunner_log_fname_1=srunner_log_fname(sr);
  return (signed int)(return_value_srunner_log_fname_1 != (const char *)(void *)0);
}

// srunner_has_tap
// file ../../src/check_log.c line 97
signed int srunner_has_tap(struct SRunner *sr)
{
  const char *return_value_srunner_tap_fname_1;
  return_value_srunner_tap_fname_1=srunner_tap_fname(sr);
  return (signed int)(return_value_srunner_tap_fname_1 != (const char *)(void *)0);
}

// srunner_has_xml
// file ../../src/check_log.c line 74
signed int srunner_has_xml(struct SRunner *sr)
{
  const char *return_value_srunner_xml_fname_1;
  return_value_srunner_xml_fname_1=srunner_xml_fname(sr);
  return (signed int)(return_value_srunner_xml_fname_1 != (const char *)(void *)0);
}

// srunner_init_logging
// file ../../src/check_log.c line 501
void srunner_init_logging(struct SRunner *sr, enum print_output print_mode)
{
  struct _IO_FILE *f;
  sr->loglst=check_list_create();
  if(!((signed int)print_mode == CK_SUBUNIT))
    srunner_register_lfun(sr, stdout, 0, stdout_lfun, print_mode);

  else
    srunner_register_lfun(sr, stdout, 0, subunit_lfun, print_mode);
  f=srunner_open_lfile(sr);
  if(!(f == ((struct _IO_FILE *)NULL)))
    srunner_register_lfun(sr, f, (signed int)(f != stdout), lfile_lfun, print_mode);

  f=srunner_open_xmlfile(sr);
  if(!(f == ((struct _IO_FILE *)NULL)))
    srunner_register_lfun(sr, f, (signed int)(f != stdout), xml_lfun, print_mode);

  f=srunner_open_tapfile(sr);
  if(!(f == ((struct _IO_FILE *)NULL)))
    srunner_register_lfun(sr, f, (signed int)(f != stdout), tap_lfun, print_mode);

  srunner_send_evt(sr, (void *)0, (enum cl_event)CLINITLOG_SR);
}

// srunner_iterate_suites
// file ../../src/check_run.c line 161
static void srunner_iterate_suites(struct SRunner *sr, const char *sname, const char *tcname, enum print_output print_mode)
{
  struct List *slst;
  struct List *tcl;
  struct TCase *srunner_iterate_suites__1__tc;
  slst = sr->slst;
  check_list_front(slst);
  signed int return_value_check_list_at_end_1;
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  signed int return_value_suite_tcase_5;
  signed int return_value_check_list_at_end_8;
  signed int return_value_strcmp_10;
  do
  {
    return_value_check_list_at_end_1=check_list_at_end(slst);
    if(!(return_value_check_list_at_end_1 == 0))
      break;

    struct Suite *srunner_iterate_suites__1__1__1__s;
    void *return_value_check_list_val_2;
    return_value_check_list_val_2=check_list_val(slst);
    srunner_iterate_suites__1__1__1__s = (struct Suite *)return_value_check_list_val_2;
    if(!(sname == ((const char *)NULL)))
    {
      return_value_strcmp_3=strcmp(sname, srunner_iterate_suites__1__1__1__s->name);
      tmp_if_expr_4 = return_value_strcmp_3 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      if(!(tcname == ((const char *)NULL)))
      {
        return_value_suite_tcase_5=suite_tcase(srunner_iterate_suites__1__1__1__s, tcname);
        tmp_if_expr_6 = !(return_value_suite_tcase_5 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_6 = (_Bool)0;
      tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_7)
    {
      log_suite_start(sr, srunner_iterate_suites__1__1__1__s);
      tcl = srunner_iterate_suites__1__1__1__s->tclst;
      check_list_front(tcl);
      do
      {
        return_value_check_list_at_end_8=check_list_at_end(tcl);
        if(!(return_value_check_list_at_end_8 == 0))
          break;

        void *return_value_check_list_val_9;
        return_value_check_list_val_9=check_list_val(tcl);
        srunner_iterate_suites__1__tc = (struct TCase *)return_value_check_list_val_9;
        if(!(tcname == ((const char *)NULL)))
        {
          return_value_strcmp_10=strcmp(tcname, srunner_iterate_suites__1__tc->name);
          if(return_value_strcmp_10 == 0)
            goto __CPROVER_DUMP_L10;

        }

        else
        {

        __CPROVER_DUMP_L10:
          ;
          srunner_run_tcase(sr, srunner_iterate_suites__1__tc);
        }
        check_list_advance(tcl);
      }
      while((_Bool)1);
      log_suite_end(sr, srunner_iterate_suites__1__1__1__s);
    }

    check_list_advance(slst);
  }
  while((_Bool)1);
}

// srunner_iterate_tcase_tfuns
// file ../../src/check_run.c line 202
static void srunner_iterate_tcase_tfuns(struct SRunner *sr, struct TCase *tc)
{
  struct List *tfl;
  struct TF *tfun;
  struct TestResult *tr = (struct TestResult *)(void *)0;
  tfl = tc->tflst;
  check_list_front(tfl);
  signed int return_value_check_list_at_end_1;
  do
  {
    return_value_check_list_at_end_1=check_list_at_end(tfl);
    if(!(return_value_check_list_at_end_1 == 0))
      break;

    signed int i;
    void *return_value_check_list_val_2;
    return_value_check_list_val_2=check_list_val(tfl);
    tfun = (struct TF *)return_value_check_list_val_2;
    i = tfun->loop_start;
    for( ; !(i >= tfun->loop_end); i = i + 1)
    {
      log_test_start(sr, tc, tfun);
      enum fork_status return_value_srunner_fork_status_3;
      return_value_srunner_fork_status_3=srunner_fork_status(sr);
      switch((signed int)return_value_srunner_fork_status_3)
      {
        case CK_FORK:
        {
          tr=tcase_run_tfun_fork(sr, tc, tfun, i);
          break;
        }
        case CK_NOFORK:
        {
          tr=tcase_run_tfun_nofork(sr, tc, tfun, i);
          break;
        }
        case CK_FORK_GETENV:

        default:
          eprintf("Bad fork status in SRunner", "../../src/check_run.c", 235);
      }
      if(!(tr == ((struct TestResult *)NULL)))
      {
        srunner_add_failure(sr, tr);
        log_test_end(sr, tr);
      }

    }
    check_list_advance(tfl);
  }
  while((_Bool)1);
}

// srunner_log_fname
// file ../../src/check_log.c line 57
const char * srunner_log_fname(struct SRunner *sr)
{
  if(!(sr->log_fname == ((const char *)NULL)))
    return sr->log_fname;

  else
  {
    char *return_value_getenv_1;
    return_value_getenv_1=getenv("CK_LOG_FILE_NAME");
    return return_value_getenv_1;
  }
}

// srunner_ntests_failed
// file ../src/check.h line 997
signed int srunner_ntests_failed(struct SRunner *sr)
{
  return sr->stats->n_failed + sr->stats->n_errors;
}

// srunner_ntests_run
// file ../../src/check.c line 392
signed int srunner_ntests_run(struct SRunner *sr)
{
  return sr->stats->n_checked;
}

// srunner_open_file
// file ../../src/check_log.c line 448
static struct _IO_FILE * srunner_open_file(const char *filename)
{
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(filename, "-");
  if(return_value_strcmp_1 == 0)
    f = stdout;

  else
  {
    f=fopen(filename, "w");
    if(f == ((struct _IO_FILE *)NULL))
      eprintf("Error in call to fopen while opening file %s:", "../../src/check_log.c", 462 - 2, filename);

  }
  return f;
}

// srunner_open_lfile
// file ../../src/check_log.c line 468
struct _IO_FILE * srunner_open_lfile(struct SRunner *sr)
{
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  signed int return_value_srunner_has_log_2;
  return_value_srunner_has_log_2=srunner_has_log(sr);
  if(!(return_value_srunner_has_log_2 == 0))
  {
    const char *return_value_srunner_log_fname_1;
    return_value_srunner_log_fname_1=srunner_log_fname(sr);
    f=srunner_open_file(return_value_srunner_log_fname_1);
  }

  return f;
}

// srunner_open_tapfile
// file ../../src/check_log.c line 490
struct _IO_FILE * srunner_open_tapfile(struct SRunner *sr)
{
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  signed int return_value_srunner_has_tap_2;
  return_value_srunner_has_tap_2=srunner_has_tap(sr);
  if(!(return_value_srunner_has_tap_2 == 0))
  {
    const char *return_value_srunner_tap_fname_1;
    return_value_srunner_tap_fname_1=srunner_tap_fname(sr);
    f=srunner_open_file(return_value_srunner_tap_fname_1);
  }

  return f;
}

// srunner_open_xmlfile
// file ../../src/check_log.c line 479
struct _IO_FILE * srunner_open_xmlfile(struct SRunner *sr)
{
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  signed int return_value_srunner_has_xml_2;
  return_value_srunner_has_xml_2=srunner_has_xml(sr);
  if(!(return_value_srunner_has_xml_2 == 0))
  {
    const char *return_value_srunner_xml_fname_1;
    return_value_srunner_xml_fname_1=srunner_xml_fname(sr);
    f=srunner_open_file(return_value_srunner_xml_fname_1);
  }

  return f;
}

// srunner_print
// file ../../src/check_print.c line 39
void srunner_print(struct SRunner *sr, enum print_output print_mode)
{
  srunner_fprint(stdout, sr, print_mode);
}

// srunner_register_lfun
// file ../../src/check_log.c line 113
void srunner_register_lfun(struct SRunner *sr, struct _IO_FILE *lfile, signed int close, void (*lfun)(struct SRunner *, struct _IO_FILE *, enum print_output, void *, enum cl_event), enum print_output printmode)
{
  struct Log *l;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc(sizeof(struct Log) /*24ul*/ );
  l = (struct Log *)return_value_emalloc_1;
  if((signed int)printmode == CK_ENV)
    printmode=get_env_printmode();

  l->lfile = lfile;
  l->lfun = lfun;
  l->close = close;
  l->mode = printmode;
  check_list_add_end(sr->loglst, (void *)l);
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// srunner_results
// file ../../src/check.c line 418
struct TestResult ** srunner_results(struct SRunner *sr)
{
  signed int i = 0;
  struct TestResult **trarray;
  struct List *rlst;
  signed int return_value_srunner_ntests_run_1;
  return_value_srunner_ntests_run_1=srunner_ntests_run(sr);
  void *return_value_emalloc_2;
  return_value_emalloc_2=emalloc(sizeof(struct TestResult *) /*8ul*/  * (unsigned long int)return_value_srunner_ntests_run_1);
  trarray = (struct TestResult **)return_value_emalloc_2;
  rlst = sr->resultlst;
  check_list_front(rlst);
  signed int return_value_check_list_at_end_3;
  signed int tmp_post_4;
  do
  {
    return_value_check_list_at_end_3=check_list_at_end(rlst);
    if(!(return_value_check_list_at_end_3 == 0))
      break;

    tmp_post_4 = i;
    i = i + 1;
    void *return_value_check_list_val_5;
    return_value_check_list_val_5=check_list_val(rlst);
    trarray[(signed long int)tmp_post_4] = (struct TestResult *)return_value_check_list_val_5;
    check_list_advance(rlst);
  }
  while((_Bool)1);
  return trarray;
}

// srunner_run
// file ../../src/check_run.c line 744
void srunner_run(struct SRunner *sr, const char *sname, const char *tcname, enum print_output print_mode)
{
  if(tcname == ((const char *)NULL))
    tcname=getenv("CK_RUN_CASE");

  if(sname == ((const char *)NULL))
    sname=getenv("CK_RUN_SUITE");

  if(!(sr == ((struct SRunner *)NULL)))
  {
    if((signed int)print_mode >= CK_LAST)
      eprintf("Bad print_mode argument to srunner_run_all: %d", "../../src/check_run.c", 766, print_mode);

    static struct sigaction sigalarm_new_action;
    memset((void *)&sigalarm_new_action, 0, sizeof(struct sigaction) /*152ul*/ );
    sigalarm_new_action.__sigaction_handler.sa_handler = sig_handler;
    static struct sigaction sigalarm_old_action;
    sigaction(14, &sigalarm_new_action, &sigalarm_old_action);
    static struct sigaction sigint_new_action;
    memset((void *)&sigint_new_action, 0, sizeof(struct sigaction) /*152ul*/ );
    sigint_new_action.__sigaction_handler.sa_handler = sig_handler;
    sigaction(2, &sigint_new_action, &sigint_old_action);
    static struct sigaction sigterm_new_action;
    memset((void *)&sigterm_new_action, 0, sizeof(struct sigaction) /*152ul*/ );
    sigterm_new_action.__sigaction_handler.sa_handler = sig_handler;
    sigaction(15, &sigterm_new_action, &sigterm_old_action);
    srunner_run_init(sr, print_mode);
    srunner_iterate_suites(sr, sname, tcname, print_mode);
    srunner_run_end(sr, print_mode);
    sigaction(14, &sigalarm_old_action, (struct sigaction *)(void *)0);
    sigaction(2, &sigint_old_action, (struct sigaction *)(void *)0);
    sigaction(15, &sigterm_old_action, (struct sigaction *)(void *)0);
  }

}

// srunner_run_all
// file ../src/check.h line 963
void srunner_run_all(struct SRunner *sr, enum print_output print_mode)
{
  srunner_run(sr, (const char *)(void *)0, (const char *)(void *)0, print_mode);
}

// srunner_run_end
// file ../../src/check_run.c line 152
static void srunner_run_end(struct SRunner *sr, enum print_output print_mode)
{
  log_srunner_end(sr);
  srunner_end_logging(sr);
  teardown_messaging();
  set_fork_status((enum fork_status)CK_FORK);
}

// srunner_run_init
// file ../../src/check_run.c line 144
static void srunner_run_init(struct SRunner *sr, enum print_output print_mode)
{
  enum fork_status return_value_srunner_fork_status_1;
  return_value_srunner_fork_status_1=srunner_fork_status(sr);
  set_fork_status(return_value_srunner_fork_status_1);
  setup_messaging();
  srunner_init_logging(sr, print_mode);
  log_srunner_start(sr);
}

// srunner_run_setup
// file ../../src/check_run.c line 258
static struct TestResult * srunner_run_setup(struct List *fixture_list, enum fork_status fork_usage, const char *test_name, const char *setup_name)
{
  struct TestResult *tr = (struct TestResult *)(void *)0;
  struct Fixture *setup_fixture;
  if((signed int)fork_usage == CK_FORK)
    send_ctx_info((enum ck_result_ctx)CK_CTX_SETUP);

  check_list_front(fixture_list);
  signed int return_value_check_list_at_end_1;
  do
  {
    return_value_check_list_at_end_1=check_list_at_end(fixture_list);
    if(!(return_value_check_list_at_end_1 == 0))
      break;

    void *return_value_check_list_val_2;
    return_value_check_list_val_2=check_list_val(fixture_list);
    setup_fixture = (struct Fixture *)return_value_check_list_val_2;
    if((signed int)fork_usage == CK_NOFORK)
    {
      send_ctx_info((enum ck_result_ctx)CK_CTX_SETUP);
      signed int return_value__setjmp_3;
      return_value__setjmp_3=_setjmp(error_jmp_buffer);
      if(return_value__setjmp_3 == 0)
        setup_fixture->fun();

      tr=receive_result_info_nofork(test_name, setup_name, 0, -1);
      if(!((signed int)tr->rtype == CK_PASS))
        break;

      free((void *)tr->file);
      free((void *)tr->msg);
      free((void *)tr);
      tr = (struct TestResult *)(void *)0;
    }

    else
      setup_fixture->fun();
    check_list_advance(fixture_list);
  }
  while((_Bool)1);
  return tr;
}

// srunner_run_tcase
// file ../../src/check_run.c line 369
static void srunner_run_tcase(struct SRunner *sr, struct TCase *tc)
{
  signed int return_value_srunner_run_unchecked_setup_1;
  return_value_srunner_run_unchecked_setup_1=srunner_run_unchecked_setup(sr, tc);
  if(!(return_value_srunner_run_unchecked_setup_1 == 0))
  {
    srunner_iterate_tcase_tfuns(sr, tc);
    srunner_run_unchecked_teardown(sr, tc);
  }

}

// srunner_run_teardown
// file ../../src/check_run.c line 330
static void srunner_run_teardown(struct List *fixture_list, enum fork_status fork_usage)
{
  struct Fixture *fixture;
  check_list_front(fixture_list);
  signed int return_value_check_list_at_end_1;
  return_value_check_list_at_end_1=check_list_at_end(fixture_list);
  if(return_value_check_list_at_end_1 == 0)
  {
    void *return_value_check_list_val_2;
    return_value_check_list_val_2=check_list_val(fixture_list);
    fixture = (struct Fixture *)return_value_check_list_val_2;
    send_ctx_info((enum ck_result_ctx)CK_CTX_TEARDOWN);
    if((signed int)fork_usage == CK_NOFORK)
    {
      signed int return_value__setjmp_3;
      return_value__setjmp_3=_setjmp(error_jmp_buffer);
      if(return_value__setjmp_3 == 0)
        fixture->fun();

      else
        goto __CPROVER_DUMP_L6;
    }

    else
      fixture->fun();
    check_list_advance(fixture_list);
  }


__CPROVER_DUMP_L6:
  ;
}

// srunner_run_unchecked_setup
// file ../../src/check_run.c line 304
static signed int srunner_run_unchecked_setup(struct SRunner *sr, struct TCase *tc)
{
  struct TestResult *tr = (struct TestResult *)(void *)0;
  signed int rval = 1;
  set_fork_status((enum fork_status)CK_NOFORK);
  tr=srunner_run_setup(tc->unch_sflst, (enum fork_status)CK_NOFORK, tc->name, "unchecked_setup");
  enum fork_status return_value_srunner_fork_status_1;
  return_value_srunner_fork_status_1=srunner_fork_status(sr);
  set_fork_status(return_value_srunner_fork_status_1);
  if(!(tr == ((struct TestResult *)NULL)))
  {
    if(!((signed int)tr->rtype == CK_PASS))
    {
      srunner_add_failure(sr, tr);
      rval = 0;
    }

  }

  return rval;
}

// srunner_run_unchecked_teardown
// file ../../src/check_run.c line 359
static void srunner_run_unchecked_teardown(struct SRunner *sr, struct TCase *tc)
{
  enum fork_status return_value_srunner_fork_status_1;
  return_value_srunner_fork_status_1=srunner_fork_status(sr);
  srunner_run_teardown(tc->unch_tflst, return_value_srunner_fork_status_1);
}

// srunner_send_evt
// file ../../src/check_log.c line 164
static void srunner_send_evt(struct SRunner *sr, void *obj, enum cl_event evt)
{
  struct List *l;
  struct Log *lg;
  l = sr->loglst;
  check_list_front(l);
  signed int return_value_check_list_at_end_1;
  return_value_check_list_at_end_1=check_list_at_end(l);
  if(return_value_check_list_at_end_1 == 0)
  {
    void *return_value_check_list_val_2;
    return_value_check_list_val_2=check_list_val(l);
    lg = (struct Log *)return_value_check_list_val_2;
    fflush(lg->lfile);
    lg->lfun(sr, lg->lfile, lg->mode, obj, evt);
    fflush(lg->lfile);
    check_list_advance(l);
  }

}

// srunner_set_fork_status
// file ../../src/check_run.c line 724
void srunner_set_fork_status(struct SRunner *sr, enum fork_status fstat)
{
  sr->fstat = fstat;
}

// srunner_set_log
// file ../../src/check_log.c line 45
void srunner_set_log(struct SRunner *sr, const char *fname)
{
  if(sr->log_fname == ((const char *)NULL))
    sr->log_fname = fname;

}

// srunner_set_tap
// file ../../src/check_log.c line 90
void srunner_set_tap(struct SRunner *sr, const char *fname)
{
  if(sr->tap_fname == ((const char *)NULL))
    sr->tap_fname = fname;

}

// srunner_set_xml
// file ../../src/check_log.c line 67
void srunner_set_xml(struct SRunner *sr, const char *fname)
{
  if(sr->xml_fname == ((const char *)NULL))
    sr->xml_fname = fname;

}

// srunner_tap_fname
// file ../../src/check_log.c line 102
const char * srunner_tap_fname(struct SRunner *sr)
{
  if(!(sr->tap_fname == ((const char *)NULL)))
    return sr->tap_fname;

  else
  {
    char *return_value_getenv_1;
    return_value_getenv_1=getenv("CK_TAP_LOG_FILE_NAME");
    return return_value_getenv_1;
  }
}

// srunner_xml_fname
// file ../../src/check_log.c line 79
const char * srunner_xml_fname(struct SRunner *sr)
{
  if(!(sr->xml_fname == ((const char *)NULL)))
    return sr->xml_fname;

  else
  {
    char *return_value_getenv_1;
    return_value_getenv_1=getenv("CK_XML_LOG_FILE_NAME");
    return return_value_getenv_1;
  }
}

// stdout_lfun
// file ../../src/check_log.c line 179
void stdout_lfun(struct SRunner *sr, struct _IO_FILE *file, enum print_output printmode, void *obj, enum cl_event evt)
{
  struct Suite *stdout_lfun__1__s;
  switch((signed int)evt)
  {
    case CLINITLOG_SR:
      break;
    case CLENDLOG_SR:
      break;
    case CLSTART_SR:
    {
      if((signed int)printmode >= 1)
        fprintf(file, "Running suite(s):");

      break;
    }
    case CLSTART_S:
    {
      stdout_lfun__1__s = (struct Suite *)obj;
      if((signed int)printmode >= 1)
        fprintf(file, " %s\n", stdout_lfun__1__s->name);

      break;
    }
    case CLEND_SR:
    {
      if((signed int)printmode >= 1)
        srunner_fprint(file, sr, printmode);

      break;
    }
    case CLEND_S:
      break;
    case CLSTART_T:
      break;
    case CLEND_T:
      break;
    default:
      eprintf("Bad event type received in stdout_lfun", "../../src/check_log.c", 221);
  }
}

// subunit_lfun
// file ../../src/check_log.c line 384
void subunit_lfun(struct SRunner *sr, struct _IO_FILE *file, enum print_output printmode, void *obj, enum cl_event evt)
{
  struct TestResult *tr;
  const char *name;
  switch((signed int)evt)
  {
    case CLINITLOG_SR:
      break;
    case CLENDLOG_SR:
      break;
    case CLSTART_SR:
      break;
    case CLSTART_S:
      break;
    case CLEND_SR:
    {
      if((signed int)printmode >= 1)
      {
        fprintf(file, "\n");
        srunner_fprint(file, sr, printmode);
      }

      break;
    }
    case CLEND_S:
      break;
    case CLSTART_T:
    {
      name = (const char *)obj;
      subunit_test_start(name);
      break;
    }
    case CLEND_T:
    {
      tr = (struct TestResult *)obj;
      char *subunit_lfun__1__1__2__name;
      subunit_lfun__1__1__2__name=ck_strdup_printf("%s:%s", tr->tcname, tr->tname);
      char *msg;
      msg=tr_short_str(tr);
      switch((signed int)tr->rtype)
      {
        case CK_PASS:
        {
          subunit_test_pass(subunit_lfun__1__1__2__name);
          break;
        }
        case CK_FAILURE:
        {
          subunit_test_fail(subunit_lfun__1__1__2__name, msg);
          break;
        }
        case CK_ERROR:
        {
          subunit_test_error(subunit_lfun__1__1__2__name, msg);
          break;
        }
        case CK_TEST_RESULT_INVALID:

        default:
        {
          eprintf("Bad result type in subunit_lfun", "../../src/check_log.c", 435);
          free((void *)subunit_lfun__1__1__2__name);
          free((void *)msg);
        }
      }
      break;
    }
    default:
      eprintf("Bad event type received in subunit_lfun", "../../src/check_log.c", 443);
  }
}

// suite_add_tcase
// file ../src/check.h line 155
void suite_add_tcase(struct Suite *s, struct TCase *tc)
{
  if(!(s == ((struct Suite *)NULL)) && !(tc == ((struct TCase *)NULL)))
    check_list_add_end(s->tclst, (void *)tc);

}

// suite_create
// file ../src/check.h line 131
struct Suite * suite_create(const char *name)
{
  struct Suite *suite_create__1__s;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc(sizeof(struct Suite) /*16ul*/ );
  suite_create__1__s = (struct Suite *)return_value_emalloc_1;
  if(name == ((const char *)NULL))
    suite_create__1__s->name = "";

  else
    suite_create__1__s->name = name;
  suite_create__1__s->tclst=check_list_create();
  return suite_create__1__s;
}

// suite_free
// file ../../src/check.c line 91
static void suite_free(struct Suite *s)
{
  struct List *l;
  signed int return_value_check_list_at_end_1;
  if(!(s == ((struct Suite *)NULL)))
  {
    l = s->tclst;
    check_list_front(l);
    do
    {
      return_value_check_list_at_end_1=check_list_at_end(l);
      if(!(return_value_check_list_at_end_1 == 0))
        break;

      void *return_value_check_list_val_2;
      return_value_check_list_val_2=check_list_val(l);
      tcase_free((struct TCase *)return_value_check_list_val_2);
      check_list_advance(l);
    }
    while((_Bool)1);
    check_list_free(s->tclst);
    free((void *)s);
  }

}

// suite_tcase
// file ../../src/check.c line 72
signed int suite_tcase(struct Suite *s, const char *tcname)
{
  struct List *l;
  struct TCase *suite_tcase__1__tc;
  signed int return_value_check_list_at_end_1;
  if(s == ((struct Suite *)NULL))
    return 0;

  else
  {
    l = s->tclst;
    check_list_front(l);
    do
    {
      return_value_check_list_at_end_1=check_list_at_end(l);
      if(!(return_value_check_list_at_end_1 == 0))
        break;

      void *return_value_check_list_val_2;
      return_value_check_list_val_2=check_list_val(l);
      suite_tcase__1__tc = (struct TCase *)return_value_check_list_val_2;
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(tcname, suite_tcase__1__tc->name);
      if(return_value_strcmp_3 == 0)
        return 1;

      check_list_advance(l);
    }
    while((_Bool)1);
    return 0;
  }
}

// tap_lfun
// file ../../src/check_log.c line 339
void tap_lfun(struct SRunner *sr, struct _IO_FILE *file, enum print_output printmode, void *obj, enum cl_event evt)
{
  struct TestResult *tr;
  switch((signed int)evt)
  {    static signed int num_tests_run = 0;
    case CLINITLOG_SR:
    {
      num_tests_run = 0;
      break;
    }
    case CLENDLOG_SR:
    {
      fprintf(file, "1..%d\n", num_tests_run);
      fflush(file);
      break;
    }
    case CLSTART_SR:
      break;
    case CLSTART_S:
      break;
    case CLEND_SR:
      break;
    case CLEND_S:
      break;
    case CLSTART_T:
      break;
    case CLEND_T:
    {
      num_tests_run = num_tests_run + 1;
      tr = (struct TestResult *)obj;
      fprintf(file, "%s %d - %s:%s:%s: %s\n", (signed int)tr->rtype == CK_PASS ? "ok" : "not ok", num_tests_run, tr->file, tr->tcname, tr->tname, tr->msg);
      fflush(file);
      break;
    }
    default:
      eprintf("Bad event type received in tap_lfun", "../../src/check_log.c", 379);
  }
}

// tcase_add_checked_fixture
// file ../../src/check.c line 213
void tcase_add_checked_fixture(struct TCase *tc, void (*setup)(void), void (*teardown)(void))
{
  tcase_add_fixture(tc, setup, teardown, 1);
}

// tcase_add_fixture
// file ../../src/check.c line 218
static void tcase_add_fixture(struct TCase *tc, void (*setup)(void), void (*teardown)(void), signed int ischecked)
{
  struct Fixture *return_value_fixture_create_1;
  struct Fixture *return_value_fixture_create_2;
  if(!(setup == ((void (*)(void))NULL)))
  {
    if(!(ischecked == 0))
    {
      return_value_fixture_create_1=fixture_create(setup, ischecked);
      check_list_add_end(tc->ch_sflst, (void *)return_value_fixture_create_1);
    }

    else
    {
      return_value_fixture_create_2=fixture_create(setup, ischecked);
      check_list_add_end(tc->unch_sflst, (void *)return_value_fixture_create_2);
    }
  }

  struct Fixture *return_value_fixture_create_3;
  struct Fixture *return_value_fixture_create_4;
  if(!(teardown == ((void (*)(void))NULL)))
  {
    if(!(ischecked == 0))
    {
      return_value_fixture_create_3=fixture_create(teardown, ischecked);
      check_list_add_front(tc->ch_tflst, (void *)return_value_fixture_create_3);
    }

    else
    {
      return_value_fixture_create_4=fixture_create(teardown, ischecked);
      check_list_add_front(tc->unch_tflst, (void *)return_value_fixture_create_4);
    }
  }

}

// tcase_add_unchecked_fixture
// file ../../src/check.c line 208
void tcase_add_unchecked_fixture(struct TCase *tc, void (*setup)(void), void (*teardown)(void))
{
  tcase_add_fixture(tc, setup, teardown, 0);
}

// tcase_create
// file ../src/check.h line 170
struct TCase * tcase_create(const char *name)
{
  char *env;
  double timeout_sec = (double)4;
  struct TCase *tcase_create__1__tc;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc(sizeof(struct TCase) /*64ul*/ );
  tcase_create__1__tc = (struct TCase *)return_value_emalloc_1;
  if(name == ((const char *)NULL))
    tcase_create__1__tc->name = "";

  else
    tcase_create__1__tc->name = name;
  env=getenv("CK_DEFAULT_TIMEOUT");
  if(!(env == ((char *)NULL)))
  {
    char *tcase_create__1__1__endptr = (char *)(void *)0;
    double tmp;
    tmp=strtod(env, &tcase_create__1__1__endptr);
    if(tmp >= 0.000000 && !(tcase_create__1__1__endptr == env))
    {
      if((signed int)*tcase_create__1__1__endptr == 0)
        timeout_sec = tmp;

    }

  }

  env=getenv("CK_TIMEOUT_MULTIPLIER");
  if(!(env == ((char *)NULL)))
  {
    char *endptr = (char *)(void *)0;
    double tcase_create__1__2__tmp;
    tcase_create__1__2__tmp=strtod(env, &endptr);
    if(tcase_create__1__2__tmp >= 0.000000 && !(endptr == env))
    {
      if((signed int)*endptr == 0)
        timeout_sec = timeout_sec * tcase_create__1__2__tmp;

    }

  }

  double return_value_floor_2;
  return_value_floor_2=floor(timeout_sec);
  tcase_create__1__tc->timeout.tv_sec = (signed long int)return_value_floor_2;
  double return_value_floor_3;
  return_value_floor_3=floor(timeout_sec);
  tcase_create__1__tc->timeout.tv_nsec = (signed long int)((timeout_sec - return_value_floor_3) * (double)1000000000);
  tcase_create__1__tc->tflst=check_list_create();
  tcase_create__1__tc->unch_sflst=check_list_create();
  tcase_create__1__tc->ch_sflst=check_list_create();
  tcase_create__1__tc->unch_tflst=check_list_create();
  tcase_create__1__tc->ch_tflst=check_list_create();
  return tcase_create__1__tc;
}

// tcase_fn_start
// file ../src/check.h line 359
void tcase_fn_start(const char *fname, const char *file, signed int line)
{
  send_ctx_info((enum ck_result_ctx)CK_CTX_TEST);
  send_loc_info(file, line);
}

// tcase_free
// file ../../src/check.c line 157
static void tcase_free(struct TCase *tc)
{
  check_list_apply(tc->tflst, free);
  check_list_apply(tc->unch_sflst, free);
  check_list_apply(tc->ch_sflst, free);
  check_list_apply(tc->unch_tflst, free);
  check_list_apply(tc->ch_tflst, free);
  check_list_free(tc->tflst);
  check_list_free(tc->unch_sflst);
  check_list_free(tc->ch_sflst);
  check_list_free(tc->unch_tflst);
  check_list_free(tc->ch_tflst);
  free((void *)tc);
}

// tcase_run_checked_setup
// file ../../src/check_run.c line 322
static struct TestResult * tcase_run_checked_setup(struct SRunner *sr, struct TCase *tc)
{
  struct TestResult *tr;
  enum fork_status return_value_srunner_fork_status_1;
  return_value_srunner_fork_status_1=srunner_fork_status(sr);
  tr=srunner_run_setup(tc->ch_sflst, return_value_srunner_fork_status_1, tc->name, "checked_setup");
  return tr;
}

// tcase_run_checked_teardown
// file ../../src/check_run.c line 364
static void tcase_run_checked_teardown(struct TCase *tc)
{
  srunner_run_teardown(tc->ch_tflst, (enum fork_status)CK_NOFORK);
}

// tcase_run_tfun_fork
// file ../../src/check_run.c line 443
static struct TestResult * tcase_run_tfun_fork(struct SRunner *sr, struct TCase *tc, struct TF *tfun, signed int i)
{
  signed int pid_w;
  signed int pid;
  signed int status = 0;
  struct timespec ts_start = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 };
  struct timespec ts_end = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 };
  void *timerid;
  struct itimerspec timer_spec;
  struct TestResult *tr;
  pid=fork();
  if(pid == -1)
    eprintf("Error in call to fork:", "../../src/check_run.c", 458 - 2);

  if(pid == 0)
  {
    setpgid(0, 0);
    group_pid=getpgrp();
    tr=tcase_run_checked_setup(sr, tc);
    free((void *)tr);
    signed int return_value_check_get_clockid_1;
    return_value_check_get_clockid_1=check_get_clockid();
    clock_gettime(return_value_check_get_clockid_1, &ts_start);
    tfun->fn(i);
    signed int return_value_check_get_clockid_2;
    return_value_check_get_clockid_2=check_get_clockid();
    clock_gettime(return_value_check_get_clockid_2, &ts_end);
    tcase_run_checked_teardown(tc);
    send_duration_info((signed int)(((ts_end.tv_sec - ts_start.tv_sec) * (signed long int)1000000 + ts_end.tv_nsec / (signed long int)1000) - ts_start.tv_nsec / (signed long int)1000));
    exit(0);
  }

  else
    group_pid = pid;
  alarm_received = 0;
  signed int return_value_check_get_clockid_4;
  return_value_check_get_clockid_4=check_get_clockid();
  signed int return_value_timer_create_5;
  return_value_timer_create_5=timer_create(return_value_check_get_clockid_4, (struct sigevent *)(void *)0, &timerid);
  if(return_value_timer_create_5 == 0)
  {
    timer_spec.it_value = tc->timeout;
    timer_spec.it_interval.tv_sec = (signed long int)0;
    timer_spec.it_interval.tv_nsec = (signed long int)0;
    signed int return_value_timer_settime_3;
    return_value_timer_settime_3=timer_settime(timerid, 0, &timer_spec, (struct itimerspec *)(void *)0);
    if(return_value_timer_settime_3 == 0)
      do
        pid_w=waitpid(pid, &status, 0);
      while(pid_w == -1);

    else
      eprintf("Error in call to timer_settime:", "../../src/check_run.c", 497);
    timer_delete(timerid);
  }

  else
    eprintf("Error in call to timer_create:", "../../src/check_run.c", 505);
  killpg(pid, 9);
  struct TestResult *return_value_receive_result_info_fork_6;
  return_value_receive_result_info_fork_6=receive_result_info_fork(tc->name, tfun->name, i, status, tfun->signal, tfun->allowed_exit_value);
  return return_value_receive_result_info_fork_6;
}

// tcase_run_tfun_nofork
// file ../../src/check_run.c line 378
static struct TestResult * tcase_run_tfun_nofork(struct SRunner *sr, struct TCase *tc, struct TF *tfun, signed int i)
{
  struct TestResult *tr;
  struct timespec ts_start = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 };
  struct timespec ts_end = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 };
  tr=tcase_run_checked_setup(sr, tc);
  if(tr == ((struct TestResult *)NULL))
  {
    signed int return_value_check_get_clockid_1;
    return_value_check_get_clockid_1=check_get_clockid();
    clock_gettime(return_value_check_get_clockid_1, &ts_start);
    signed int return_value__setjmp_2;
    return_value__setjmp_2=_setjmp(error_jmp_buffer);
    if(return_value__setjmp_2 == 0)
      tfun->fn(i);

    signed int return_value_check_get_clockid_3;
    return_value_check_get_clockid_3=check_get_clockid();
    clock_gettime(return_value_check_get_clockid_3, &ts_end);
    tcase_run_checked_teardown(tc);
    struct TestResult *return_value_receive_result_info_nofork_4;
    return_value_receive_result_info_nofork_4=receive_result_info_nofork(tc->name, tfun->name, i, (signed int)(((ts_end.tv_sec - ts_start.tv_sec) * (signed long int)1000000 + ts_end.tv_nsec / (signed long int)1000) - ts_start.tv_nsec / (signed long int)1000));
    return return_value_receive_result_info_nofork_4;
  }

  return tr;
}

// tcase_set_timeout
// file ../../src/check.c line 243
void tcase_set_timeout(struct TCase *tc, double timeout)
{
  if(timeout >= 0.000000)
  {
    char *env;
    env=getenv("CK_TIMEOUT_MULTIPLIER");
    if(!(env == ((char *)NULL)))
    {
      char *endptr = (char *)(void *)0;
      double tmp;
      tmp=strtod(env, &endptr);
      if(tmp >= 0.000000 && !(endptr == env))
      {
        if((signed int)*endptr == 0)
          timeout = timeout * tmp;

      }

    }

    double return_value_floor_1;
    return_value_floor_1=floor(timeout);
    tc->timeout.tv_sec = (signed long int)return_value_floor_1;
    double return_value_floor_2;
    return_value_floor_2=floor(timeout);
    tc->timeout.tv_nsec = (signed long int)((timeout - return_value_floor_2) * (double)1000000000);
  }

}

// teardown_messaging
// file ../../src/check_msg.c line 213
void teardown_messaging(void)
{
  teardown_pipe();
}

// teardown_pipe
// file ../../src/check_msg.c line 303
static void teardown_pipe(void)
{
  if(!(send_file2 == ((struct _IO_FILE *)NULL)))
  {
    fclose(send_file2);
    send_file2 = ((struct _IO_FILE *)NULL);
    if(!(send_file2_name == ((char *)NULL)))
    {
      unlink(send_file2_name);
      free((void *)send_file2_name);
      send_file2_name = (char *)(void *)0;
    }

  }

  else
    if(!(send_file1 == ((struct _IO_FILE *)NULL)))
    {
      fclose(send_file1);
      send_file1 = ((struct _IO_FILE *)NULL);
      if(!(send_file1_name == ((char *)NULL)))
      {
        unlink(send_file1_name);
        free((void *)send_file1_name);
        send_file1_name = (char *)(void *)0;
      }

    }

    else
      eprintf("No messaging setup", "../../src/check_msg.c", 329);
}

// test_stress_forks
// file ../../tests/check_thread_stress.c line 38
static void test_stress_forks(signed int _i)
{
  tcase_fn_start("test_stress_forks", "../../tests/check_thread_stress.c", 38);
  signed int cpid;
  cpid=fork();
  if(cpid == 0)
  {
    sendinfo((void *)0x1);
    exit(0);
  }

  else
    sendinfo((void *)0x2);
}

// test_stress_threads
// file ../../tests/check_thread_stress.c line 25
static void test_stress_threads(signed int _i)
{
  tcase_fn_start("test_stress_threads", "../../tests/check_thread_stress.c", 25);
  unsigned long int a;
  unsigned long int b;
  pthread_create(&a, (const union pthread_attr_t *)(void *)0, sendinfo, (void *)0xa);
  pthread_create(&b, (const union pthread_attr_t *)(void *)0, sendinfo, (void *)0xb);
  pthread_join(a, (void **)(void *)0);
  pthread_join(b, (void **)(void *)0);
}

// tr_create
// file ../../src/check.c line 440
struct TestResult * tr_create(void)
{
  struct TestResult *tr;
  void *return_value_emalloc_1;
  return_value_emalloc_1=emalloc(sizeof(struct TestResult) /*56ul*/ );
  tr = (struct TestResult *)return_value_emalloc_1;
  tr_init(tr);
  return tr;
}

// tr_ctx
// file ../../src/check.c line 489
enum ck_result_ctx tr_ctx(struct TestResult *tr)
{
  return tr->ctx;
}

// tr_fprint
// file ../../src/check_print.h line 26
void tr_fprint(struct _IO_FILE *file, struct TestResult *tr, enum print_output print_mode)
{
  if((signed int)print_mode == CK_ENV)
    print_mode=get_env_printmode();

  _Bool tmp_if_expr_1;
  if((signed int)print_mode >= CK_VERBOSE)
    tmp_if_expr_1 = (signed int)tr->rtype == CK_PASS ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = ((signed int)tr->rtype != CK_PASS ? ((signed int)print_mode >= CK_NORMAL ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    char *trstr;
    trstr=tr_str(tr);
    fprintf(file, "%s\n", trstr);
    free((void *)trstr);
  }

}

// tr_free
// file ../../src/check.c line 461
void tr_free(struct TestResult *tr)
{
  free((void *)tr->file);
  free((void *)tr->msg);
  free((void *)tr);
}

// tr_init
// file ../../src/check.c line 449
static void tr_init(struct TestResult *tr)
{
  tr->ctx = (enum ck_result_ctx)CK_CTX_INVALID;
  tr->line = -1;
  tr->rtype = (enum test_result)CK_TEST_RESULT_INVALID;
  tr->msg = (char *)(void *)0;
  tr->file = (char *)(void *)0;
  tr->tcname = (const char *)(void *)0;
  tr->tname = (const char *)(void *)0;
  tr->duration = -1;
}

// tr_lfile
// file ../../src/check.c line 479
const char * tr_lfile(struct TestResult *tr)
{
  return tr->file;
}

// tr_lno
// file ../../src/check.c line 474
signed int tr_lno(struct TestResult *tr)
{
  return tr->line;
}

// tr_msg
// file ../../src/check.c line 469
const char * tr_msg(struct TestResult *tr)
{
  return tr->msg;
}

// tr_rtype
// file ../../src/check.c line 484
signed int tr_rtype(struct TestResult *tr)
{
  return (signed int)tr->rtype;
}

// tr_set_loc_by_ctx
// file ../../src/check_msg.c line 148
static void tr_set_loc_by_ctx(struct TestResult *tr, enum ck_result_ctx ctx, struct RcvMsg *rmsg)
{
  if((signed int)ctx == CK_CTX_TEST)
  {
    tr->file = rmsg->test_file;
    tr->line = rmsg->test_line;
    rmsg->test_file = (char *)(void *)0;
    rmsg->test_line = -1;
  }

  else
  {
    tr->file = rmsg->fixture_file;
    tr->line = rmsg->fixture_line;
    rmsg->fixture_file = (char *)(void *)0;
    rmsg->fixture_line = -1;
  }
}

// tr_short_str
// file ../../src/check_str.h line 32
char * tr_short_str(struct TestResult *tr)
{
  const char *exact_msg;
  char *rstr;
  exact_msg = (signed int)tr->rtype == CK_ERROR ? "(after this point) " : "";
  rstr=ck_strdup_printf("%s:%d: %s%s", tr->file, tr->line, exact_msg, tr->msg);
  return rstr;
}

// tr_str
// file ../../src/check_str.h line 26
char * tr_str(struct TestResult *tr)
{
  const char *exact_msg;
  char *rstr;
  exact_msg = (signed int)tr->rtype == CK_ERROR ? "(after this point) " : "";
  const char *return_value_tr_type_str_1;
  return_value_tr_type_str_1=tr_type_str(tr);
  rstr=ck_strdup_printf("%s:%d:%s:%s:%s:%d: %s%s", tr->file, tr->line, return_value_tr_type_str_1, tr->tcname, tr->tname, tr->iter, exact_msg, tr->msg);
  return rstr;
}

// tr_tcname
// file ../../src/check.c line 494
const char * tr_tcname(struct TestResult *tr)
{
  return tr->tcname;
}

// tr_type_str
// file ../../src/check_str.c line 107
static const char * tr_type_str(struct TestResult *tr)
{
  const char *str = (const char *)(void *)0;
  if((signed int)tr->ctx == CK_CTX_TEST)
  {
    if((signed int)tr->rtype == CK_PASS)
      str = "P";

    else
      if((signed int)tr->rtype == CK_FAILURE)
        str = "F";

      else
        if((signed int)tr->rtype == CK_ERROR)
          str = "E";

  }

  else
    str = "S";
  return str;
}

// tr_xmlprint
// file ../../src/check_print.h line 27
void tr_xmlprint(struct _IO_FILE *file, struct TestResult *tr, enum print_output print_mode)
{
  char result[10l];
  char *path_name = (char *)(void *)0;
  char *file_name = (char *)(void *)0;
  char *slash = (char *)(void *)0;
  switch((signed int)tr->rtype)
  {
    case CK_PASS:
    {
      snprintf(result, sizeof(char [10l]) /*10ul*/ , "%s", (const void *)"success");
      break;
    }
    case CK_FAILURE:
    {
      snprintf(result, sizeof(char [10l]) /*10ul*/ , "%s", (const void *)"failure");
      break;
    }
    case CK_ERROR:
    {
      snprintf(result, sizeof(char [10l]) /*10ul*/ , "%s", (const void *)"error");
      break;
    }
    case CK_TEST_RESULT_INVALID:

    default:
      abort();
  }
  if(!(tr->file == ((char *)NULL)))
  {
    slash=strrchr(tr->file, 47);
    if(slash == ((char *)NULL))
      slash=strrchr(tr->file, 92);

    if(slash == ((char *)NULL))
    {
      path_name=strdup(".");
      file_name = tr->file;
    }

    else
    {
      path_name=strdup(tr->file);
      path_name[slash - tr->file] = (char)0;
      file_name = slash + (signed long int)1;
    }
  }

  fprintf(file, "    <test result=\"%s\">\n", (const void *)result);
  fprintf(file, "      <path>%s</path>\n", path_name == (char *)(void *)0 ? "" : path_name);
  fprintf(file, "      <fn>%s:%d</fn>\n", file_name == (char *)(void *)0 ? "" : file_name, tr->line);
  fprintf(file, "      <id>%s</id>\n", tr->tname);
  fprintf(file, "      <iteration>%d</iteration>\n", tr->iter);
  signed int tmp_if_expr_1;
  if(!(tr->duration >= 0))
    tmp_if_expr_1 = -1;

  else
    tmp_if_expr_1 = tr->duration / 1000000;
  signed int tmp_if_expr_2;
  if(!(tr->duration >= 0))
    tmp_if_expr_2 = 0;

  else
    tmp_if_expr_2 = tr->duration % 1000000;
  fprintf(file, "      <duration>%d.%06d</duration>\n", tmp_if_expr_1, tmp_if_expr_2);
  fprintf(file, "      <description>");
  fprint_xml_esc(file, tr->tcname);
  fprintf(file, "</description>\n");
  fprintf(file, "      <message>");
  fprint_xml_esc(file, tr->msg);
  fprintf(file, "</message>\n");
  fprintf(file, "    </test>\n");
  free((void *)path_name);
}

// upack
// file ../../src/check_pack.c line 110
signed int upack(char *buf, union anonymous_13 *msg, enum ck_msg_type *type)
{
  char *obuf;
  if(buf == ((char *)NULL))
    return -1;

  else
  {
    obuf = buf;
    *type=upack_type(&buf);
    check_type((signed int)*type, "../../src/check_pack.c", 121);
    upftab[(signed long int)*type](&buf, msg);
    return (signed int)(buf - obuf);
  }
}

// upack_ctx
// file ../../src/check_pack.c line 221
static void upack_ctx(char **buf, struct CtxMsg *cmsg)
{
  signed int return_value_upack_int_1;
  return_value_upack_int_1=upack_int(buf);
  cmsg->ctx = (enum ck_result_ctx)return_value_upack_int_1;
}

// upack_duration
// file ../../src/check_pack.c line 240
static void upack_duration(char **buf, struct DurationMsg *cmsg)
{
  cmsg->duration=upack_int(buf);
}

// upack_fail
// file ../../src/check_pack.c line 280
static void upack_fail(char **buf, struct FailMsg *fmsg)
{
  fmsg->msg=upack_str(buf);
}

// upack_int
// file ../../src/check_pack.c line 141
static signed int upack_int(char **buf)
{
  unsigned char *ubuf = (unsigned char *)*buf;
  unsigned int uval = (unsigned int)((signed int)ubuf[(signed long int)0] << 24 | (signed int)ubuf[(signed long int)1] << 16 | (signed int)ubuf[(signed long int)2] << 8 | (signed int)ubuf[(signed long int)3]);
  *buf = *buf + (signed long int)4;
  return (signed int)uval;
}

// upack_loc
// file ../../src/check_pack.c line 260
static void upack_loc(char **buf, struct LocMsg *lmsg)
{
  lmsg->file=upack_str(buf);
  lmsg->line=upack_int(buf);
}

// upack_str
// file ../../src/check_pack.c line 173
static char * upack_str(char **buf)
{
  char *val;
  signed int strsz;
  strsz=upack_int(buf);
  if(strsz >= 1)
  {
    void *return_value_emalloc_1;
    return_value_emalloc_1=emalloc((unsigned long int)(strsz + 1));
    val = (char *)return_value_emalloc_1;
    memcpy((void *)val, (const void *)*buf, (unsigned long int)strsz);
    val[(signed long int)strsz] = (char)0;
    *buf = *buf + (signed long int)strsz;
  }

  else
  {
    void *return_value_emalloc_2;
    return_value_emalloc_2=emalloc((unsigned long int)1);
    val = (char *)return_value_emalloc_2;
    *val = (char)0;
  }
  return val;
}

// upack_type
// file ../../src/check_pack.c line 201
static enum ck_msg_type upack_type(char **buf)
{
  signed int return_value_upack_int_1;
  return_value_upack_int_1=upack_int(buf);
  return (enum ck_msg_type)return_value_upack_int_1;
}

// waserror
// file ../../src/check_run.c line 684
static signed int waserror(signed int status, signed int signal_expected)
{
  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_1
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  signed int was_sig = (signed int)((signed int)(signed char)((((union anonymous_1){ .__in=status }).__i & 0x7f) + 1) >> 1 > 0);
  signed int was_exit = (signed int)((((union anonymous_1){ .__in=status }).__i & 0x7f) == 0);
  signed int exit_status = (((union anonymous_1){ .__in=status }).__i & 0xff00) >> 8;
  signed int signal_received = ((union anonymous_1){ .__in=status }).__i & 0x7f;
  return (signed int)(was_sig != 0 && signal_received != signal_expected || was_exit != 0 && exit_status != 0);
}

// xml_lfun
// file ../../src/check_log.c line 266
void xml_lfun(struct SRunner *sr, struct _IO_FILE *file, enum print_output printmode, void *obj, enum cl_event evt)
{
  struct TestResult *tr;
  struct Suite *xml_lfun__1__s;
  static struct timespec ts_start = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 };
  static char t[(signed long int)sizeof(char [20l]) /*20l*/ ] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  if((signed int)t[0l] == 0)
  {
    struct timeval inittv;
    struct tm now;
    gettimeofday(&inittv, (struct timezone *)(void *)0);
    signed int return_value_check_get_clockid_1;
    return_value_check_get_clockid_1=check_get_clockid();
    clock_gettime(return_value_check_get_clockid_1, &ts_start);
    struct tm *return_value_localtime_r_2;
    return_value_localtime_r_2=localtime_r((const signed long int *)&inittv.tv_sec, &now);
    if(!(return_value_localtime_r_2 == ((struct tm *)NULL)))
      strftime(t, sizeof(char [20l]) /*20ul*/ , "%Y-%m-%d %H:%M:%S", &now);

  }

  switch((signed int)evt)
  {
    case CLINITLOG_SR:
    {
      fprintf(file, "<?xml version=\"1.0\"?>\n");
      fprintf(file, "<?xml-stylesheet type=\"text/xsl\" href=\"http://check.sourceforge.net/xml/check_unittest.xslt\"?>\n");
      fprintf(file, "<testsuites xmlns=\"http://check.sourceforge.net/ns\">\n");
      fprintf(file, "  <datetime>%s</datetime>\n", (const void *)t);
      break;
    }
    case CLENDLOG_SR:
    {
      struct timespec ts_end = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 };
      unsigned long int duration;
      signed int return_value_check_get_clockid_3;
      return_value_check_get_clockid_3=check_get_clockid();
      clock_gettime(return_value_check_get_clockid_3, &ts_end);
      duration = (unsigned long int)(((ts_end.tv_sec - ts_start.tv_sec) * (signed long int)1000000 + ts_end.tv_nsec / (signed long int)1000) - ts_start.tv_nsec / (signed long int)1000);
      fprintf(file, "  <duration>%lu.%06lu</duration>\n", duration / (unsigned long int)1000000, duration % (unsigned long int)1000000);
      fprintf(file, "</testsuites>\n");
      break;
    }
    case CLSTART_SR:
      break;
    case CLSTART_S:
    {
      xml_lfun__1__s = (struct Suite *)obj;
      fprintf(file, "  <suite>\n");
      fprintf(file, "    <title>");
      fprint_xml_esc(file, xml_lfun__1__s->name);
      fprintf(file, "</title>\n");
      break;
    }
    case CLEND_SR:
      break;
    case CLEND_S:
    {
      fprintf(file, "  </suite>\n");
      break;
    }
    case CLSTART_T:
      break;
    case CLEND_T:
    {
      tr = (struct TestResult *)obj;
      tr_xmlprint(file, tr, (enum print_output)CK_VERBOSE);
      break;
    }
    default:
      eprintf("Bad event type received in xml_lfun", "../../src/check_log.c", 334);
  }
}

