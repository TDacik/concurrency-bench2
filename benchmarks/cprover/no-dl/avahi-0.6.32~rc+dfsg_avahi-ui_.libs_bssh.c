// #anon_enum_ATK_LAYER_INVALID=0_ATK_LAYER_BACKGROUND=1_ATK_LAYER_CANVAS=2_ATK_LAYER_WIDGET=3_ATK_LAYER_MDI=4_ATK_LAYER_POPUP=5_ATK_LAYER_OVERLAY=6_ATK_LAYER_WINDOW=7
// file /usr/include/atk-1.0/atk/atkobject.h line 376
enum anonymous_25 { ATK_LAYER_INVALID=0, ATK_LAYER_BACKGROUND=1, ATK_LAYER_CANVAS=2, ATK_LAYER_WIDGET=3, ATK_LAYER_MDI=4, ATK_LAYER_POPUP=5, ATK_LAYER_OVERLAY=6, ATK_LAYER_WINDOW=7 };

// #anon_enum_ATK_ROLE_INVALID=0_ATK_ROLE_ACCEL_LABEL=1_ATK_ROLE_ALERT=2_ATK_ROLE_ANIMATION=3_ATK_ROLE_ARROW=4_ATK_ROLE_CALENDAR=5_ATK_ROLE_CANVAS=6_ATK_ROLE_CHECK_BOX=7_ATK_ROLE_CHECK_MENU_ITEM=8_ATK_ROLE_COLOR_CHOOSER=9_ATK_ROLE_COLUMN_HEADER=10_ATK_ROLE_COMBO_BOX=11_ATK_ROLE_DATE_EDITOR=12_ATK_ROLE_DESKTOP_ICON=13_ATK_ROLE_DESKTOP_FRAME=14_ATK_ROLE_DIAL=15_ATK_ROLE_DIALOG=16_ATK_ROLE_DIRECTORY_PANE=17_ATK_ROLE_DRAWING_AREA=18_ATK_ROLE_FILE_CHOOSER=19_ATK_ROLE_FILLER=20_ATK_ROLE_FONT_CHOOSER=21_ATK_ROLE_FRAME=22_ATK_ROLE_GLASS_PANE=23_ATK_ROLE_HTML_CONTAINER=24_ATK_ROLE_ICON=25_ATK_ROLE_IMAGE=26_ATK_ROLE_INTERNAL_FRAME=27_ATK_ROLE_LABEL=28_ATK_ROLE_LAYERED_PANE=29_ATK_ROLE_LIST=30_ATK_ROLE_LIST_ITEM=31_ATK_ROLE_MENU=32_ATK_ROLE_MENU_BAR=33_ATK_ROLE_MENU_ITEM=34_ATK_ROLE_OPTION_PANE=35_ATK_ROLE_PAGE_TAB=36_ATK_ROLE_PAGE_TAB_LIST=37_ATK_ROLE_PANEL=38_ATK_ROLE_PASSWORD_TEXT=39_ATK_ROLE_POPUP_MENU=40_ATK_ROLE_PROGRESS_BAR=41_ATK_ROLE_PUSH_BUTTON=42_ATK_ROLE_RADIO_BUTTON=43_ATK_ROLE_RADIO_MENU_ITEM=44_ATK_ROLE_ROOT_PANE=45_ATK_ROLE_ROW_HEADER=46_ATK_ROLE_SCROLL_BAR=47_ATK_ROLE_SCROLL_PANE=48_ATK_ROLE_SEPARATOR=49_ATK_ROLE_SLIDER=50_ATK_ROLE_SPLIT_PANE=51_ATK_ROLE_SPIN_BUTTON=52_ATK_ROLE_STATUSBAR=53_ATK_ROLE_TABLE=54_ATK_ROLE_TABLE_CELL=55_ATK_ROLE_TABLE_COLUMN_HEADER=56_ATK_ROLE_TABLE_ROW_HEADER=57_ATK_ROLE_TEAR_OFF_MENU_ITEM=58_ATK_ROLE_TERMINAL=59_ATK_ROLE_TEXT=60_ATK_ROLE_TOGGLE_BUTTON=61_ATK_ROLE_TOOL_BAR=62_ATK_ROLE_TOOL_TIP=63_ATK_ROLE_TREE=64_ATK_ROLE_TREE_TABLE=65_ATK_ROLE_UNKNOWN=66_ATK_ROLE_VIEWPORT=67_ATK_ROLE_WINDOW=68_ATK_ROLE_HEADER=69_ATK_ROLE_FOOTER=70_ATK_ROLE_PARAGRAPH=71_ATK_ROLE_RULER=72_ATK_ROLE_APPLICATION=73_ATK_ROLE_AUTOCOMPLETE=74_ATK_ROLE_EDITBAR=75_ATK_ROLE_EMBEDDED=76_ATK_ROLE_ENTRY=77_ATK_ROLE_CHART=78_ATK_ROLE_CAPTION=79_ATK_ROLE_DOCUMENT_FRAME=80_ATK_ROLE_HEADING=81_ATK_ROLE_PAGE=82_ATK_ROLE_SECTION=83_ATK_ROLE_REDUNDANT_OBJECT=84_ATK_ROLE_FORM=85_ATK_ROLE_LINK=86_ATK_ROLE_INPUT_METHOD_WINDOW=87_ATK_ROLE_TABLE_ROW=88_ATK_ROLE_TREE_ITEM=89_ATK_ROLE_DOCUMENT_SPREADSHEET=90_ATK_ROLE_DOCUMENT_PRESENTATION=91_ATK_ROLE_DOCUMENT_TEXT=92_ATK_ROLE_DOCUMENT_WEB=93_ATK_ROLE_DOCUMENT_EMAIL=94_ATK_ROLE_COMMENT=95_ATK_ROLE_LIST_BOX=96_ATK_ROLE_GROUPING=97_ATK_ROLE_IMAGE_MAP=98_ATK_ROLE_NOTIFICATION=99_ATK_ROLE_INFO_BAR=100_ATK_ROLE_LEVEL_BAR=101_ATK_ROLE_TITLE_BAR=102_ATK_ROLE_BLOCK_QUOTE=103_ATK_ROLE_AUDIO=104_ATK_ROLE_VIDEO=105_ATK_ROLE_DEFINITION=106_ATK_ROLE_ARTICLE=107_ATK_ROLE_LANDMARK=108_ATK_ROLE_LOG=109_ATK_ROLE_MARQUEE=110_ATK_ROLE_MATH=111_ATK_ROLE_RATING=112_ATK_ROLE_TIMER=113_ATK_ROLE_DESCRIPTION_LIST=114_ATK_ROLE_DESCRIPTION_TERM=115_ATK_ROLE_DESCRIPTION_VALUE=116_ATK_ROLE_STATIC=117_ATK_ROLE_MATH_FRACTION=118_ATK_ROLE_MATH_ROOT=119_ATK_ROLE_SUBSCRIPT=120_ATK_ROLE_SUPERSCRIPT=121_ATK_ROLE_LAST_DEFINED=122
// file /usr/include/atk-1.0/atk/atkobject.h line 232
enum anonymous_24 { ATK_ROLE_INVALID=0, ATK_ROLE_ACCEL_LABEL=1, ATK_ROLE_ALERT=2, ATK_ROLE_ANIMATION=3, ATK_ROLE_ARROW=4, ATK_ROLE_CALENDAR=5, ATK_ROLE_CANVAS=6, ATK_ROLE_CHECK_BOX=7, ATK_ROLE_CHECK_MENU_ITEM=8, ATK_ROLE_COLOR_CHOOSER=9, ATK_ROLE_COLUMN_HEADER=10, ATK_ROLE_COMBO_BOX=11, ATK_ROLE_DATE_EDITOR=12, ATK_ROLE_DESKTOP_ICON=13, ATK_ROLE_DESKTOP_FRAME=14, ATK_ROLE_DIAL=15, ATK_ROLE_DIALOG=16, ATK_ROLE_DIRECTORY_PANE=17, ATK_ROLE_DRAWING_AREA=18, ATK_ROLE_FILE_CHOOSER=19, ATK_ROLE_FILLER=20, ATK_ROLE_FONT_CHOOSER=21, ATK_ROLE_FRAME=22, ATK_ROLE_GLASS_PANE=23, ATK_ROLE_HTML_CONTAINER=24, ATK_ROLE_ICON=25, ATK_ROLE_IMAGE=26, ATK_ROLE_INTERNAL_FRAME=27, ATK_ROLE_LABEL=28, ATK_ROLE_LAYERED_PANE=29, ATK_ROLE_LIST=30, ATK_ROLE_LIST_ITEM=31, ATK_ROLE_MENU=32, ATK_ROLE_MENU_BAR=33, ATK_ROLE_MENU_ITEM=34, ATK_ROLE_OPTION_PANE=35, ATK_ROLE_PAGE_TAB=36, ATK_ROLE_PAGE_TAB_LIST=37, ATK_ROLE_PANEL=38, ATK_ROLE_PASSWORD_TEXT=39, ATK_ROLE_POPUP_MENU=40, ATK_ROLE_PROGRESS_BAR=41, ATK_ROLE_PUSH_BUTTON=42, ATK_ROLE_RADIO_BUTTON=43, ATK_ROLE_RADIO_MENU_ITEM=44, ATK_ROLE_ROOT_PANE=45, ATK_ROLE_ROW_HEADER=46, ATK_ROLE_SCROLL_BAR=47, ATK_ROLE_SCROLL_PANE=48, ATK_ROLE_SEPARATOR=49, ATK_ROLE_SLIDER=50, ATK_ROLE_SPLIT_PANE=51, ATK_ROLE_SPIN_BUTTON=52, ATK_ROLE_STATUSBAR=53, ATK_ROLE_TABLE=54, ATK_ROLE_TABLE_CELL=55, ATK_ROLE_TABLE_COLUMN_HEADER=56, ATK_ROLE_TABLE_ROW_HEADER=57, ATK_ROLE_TEAR_OFF_MENU_ITEM=58, ATK_ROLE_TERMINAL=59, ATK_ROLE_TEXT=60, ATK_ROLE_TOGGLE_BUTTON=61, ATK_ROLE_TOOL_BAR=62, ATK_ROLE_TOOL_TIP=63, ATK_ROLE_TREE=64, ATK_ROLE_TREE_TABLE=65, ATK_ROLE_UNKNOWN=66, ATK_ROLE_VIEWPORT=67, ATK_ROLE_WINDOW=68, ATK_ROLE_HEADER=69, ATK_ROLE_FOOTER=70, ATK_ROLE_PARAGRAPH=71, ATK_ROLE_RULER=72, ATK_ROLE_APPLICATION=73, ATK_ROLE_AUTOCOMPLETE=74, ATK_ROLE_EDITBAR=75, ATK_ROLE_EMBEDDED=76, ATK_ROLE_ENTRY=77, ATK_ROLE_CHART=78, ATK_ROLE_CAPTION=79, ATK_ROLE_DOCUMENT_FRAME=80, ATK_ROLE_HEADING=81, ATK_ROLE_PAGE=82, ATK_ROLE_SECTION=83, ATK_ROLE_REDUNDANT_OBJECT=84, ATK_ROLE_FORM=85, ATK_ROLE_LINK=86, ATK_ROLE_INPUT_METHOD_WINDOW=87, ATK_ROLE_TABLE_ROW=88, ATK_ROLE_TREE_ITEM=89, ATK_ROLE_DOCUMENT_SPREADSHEET=90, ATK_ROLE_DOCUMENT_PRESENTATION=91, ATK_ROLE_DOCUMENT_TEXT=92, ATK_ROLE_DOCUMENT_WEB=93, ATK_ROLE_DOCUMENT_EMAIL=94, ATK_ROLE_COMMENT=95, ATK_ROLE_LIST_BOX=96, ATK_ROLE_GROUPING=97, ATK_ROLE_IMAGE_MAP=98, ATK_ROLE_NOTIFICATION=99, ATK_ROLE_INFO_BAR=100, ATK_ROLE_LEVEL_BAR=101, ATK_ROLE_TITLE_BAR=102, ATK_ROLE_BLOCK_QUOTE=103, ATK_ROLE_AUDIO=104, ATK_ROLE_VIDEO=105, ATK_ROLE_DEFINITION=106, ATK_ROLE_ARTICLE=107, ATK_ROLE_LANDMARK=108, ATK_ROLE_LOG=109, ATK_ROLE_MARQUEE=110, ATK_ROLE_MATH=111, ATK_ROLE_RATING=112, ATK_ROLE_TIMER=113, ATK_ROLE_DESCRIPTION_LIST=114, ATK_ROLE_DESCRIPTION_TERM=115, ATK_ROLE_DESCRIPTION_VALUE=116, ATK_ROLE_STATIC=117, ATK_ROLE_MATH_FRACTION=118, ATK_ROLE_MATH_ROOT=119, ATK_ROLE_SUBSCRIPT=120, ATK_ROLE_SUPERSCRIPT=121, ATK_ROLE_LAST_DEFINED=122 };

// #anon_enum_AVAHI_BROWSER_NEW=0_AVAHI_BROWSER_REMOVE=1_AVAHI_BROWSER_CACHE_EXHAUSTED=2_AVAHI_BROWSER_ALL_FOR_NOW=3_AVAHI_BROWSER_FAILURE=4
// file ../avahi-common/defs.h line 284
enum anonymous_14 { AVAHI_BROWSER_NEW=0, AVAHI_BROWSER_REMOVE=1, AVAHI_BROWSER_CACHE_EXHAUSTED=2, AVAHI_BROWSER_ALL_FOR_NOW=3, AVAHI_BROWSER_FAILURE=4 };

// #anon_enum_AVAHI_CLIENT_IGNORE_USER_CONFIG=1_AVAHI_CLIENT_NO_FAIL=2
// file client.h line 48
enum anonymous_39 { AVAHI_CLIENT_IGNORE_USER_CONFIG=1, AVAHI_CLIENT_NO_FAIL=2 };

// #anon_enum_AVAHI_CLIENT_S_REGISTERING=1_AVAHI_CLIENT_S_RUNNING=2_AVAHI_CLIENT_S_COLLISION=3_AVAHI_CLIENT_FAILURE=100_AVAHI_CLIENT_CONNECTING=101
// file client.h line 40
enum anonymous_11 { AVAHI_CLIENT_S_REGISTERING=1, AVAHI_CLIENT_S_RUNNING=2, AVAHI_CLIENT_S_COLLISION=3, AVAHI_CLIENT_FAILURE=100, AVAHI_CLIENT_CONNECTING=101 };

// #anon_enum_AVAHI_DOMAIN_BROWSER_BROWSE=0_AVAHI_DOMAIN_BROWSER_BROWSE_DEFAULT=1_AVAHI_DOMAIN_BROWSER_REGISTER=2_AVAHI_DOMAIN_BROWSER_REGISTER_DEFAULT=3_AVAHI_DOMAIN_BROWSER_BROWSE_LEGACY=4_AVAHI_DOMAIN_BROWSER_MAX=5
// file ../avahi-common/defs.h line 303
enum anonymous_43 { AVAHI_DOMAIN_BROWSER_BROWSE=0, AVAHI_DOMAIN_BROWSER_BROWSE_DEFAULT=1, AVAHI_DOMAIN_BROWSER_REGISTER=2, AVAHI_DOMAIN_BROWSER_REGISTER_DEFAULT=3, AVAHI_DOMAIN_BROWSER_BROWSE_LEGACY=4, AVAHI_DOMAIN_BROWSER_MAX=5 };

// #anon_enum_AVAHI_ENTRY_GROUP_UNCOMMITED=0_AVAHI_ENTRY_GROUP_REGISTERING=1_AVAHI_ENTRY_GROUP_ESTABLISHED=2_AVAHI_ENTRY_GROUP_COLLISION=3_AVAHI_ENTRY_GROUP_FAILURE=4
// file ../avahi-common/defs.h line 230
enum anonymous_40 { AVAHI_ENTRY_GROUP_UNCOMMITED=0, AVAHI_ENTRY_GROUP_REGISTERING=1, AVAHI_ENTRY_GROUP_ESTABLISHED=2, AVAHI_ENTRY_GROUP_COLLISION=3, AVAHI_ENTRY_GROUP_FAILURE=4 };

// #anon_enum_AVAHI_LOOKUP_RESULT_CACHED=1_AVAHI_LOOKUP_RESULT_WIDE_AREA=2_AVAHI_LOOKUP_RESULT_MULTICAST=4_AVAHI_LOOKUP_RESULT_LOCAL=8_AVAHI_LOOKUP_RESULT_OUR_OWN=16_AVAHI_LOOKUP_RESULT_STATIC=32
// file ../avahi-common/defs.h line 270
enum anonymous_13 { AVAHI_LOOKUP_RESULT_CACHED=1, AVAHI_LOOKUP_RESULT_WIDE_AREA=2, AVAHI_LOOKUP_RESULT_MULTICAST=4, AVAHI_LOOKUP_RESULT_LOCAL=8, AVAHI_LOOKUP_RESULT_OUR_OWN=16, AVAHI_LOOKUP_RESULT_STATIC=32 };

// #anon_enum_AVAHI_LOOKUP_USE_WIDE_AREA=1_AVAHI_LOOKUP_USE_MULTICAST=2_AVAHI_LOOKUP_NO_TXT=4_AVAHI_LOOKUP_NO_ADDRESS=8
// file ../avahi-common/defs.h line 260
enum anonymous_44 { AVAHI_LOOKUP_USE_WIDE_AREA=1, AVAHI_LOOKUP_USE_MULTICAST=2, AVAHI_LOOKUP_NO_TXT=4, AVAHI_LOOKUP_NO_ADDRESS=8 };

// #anon_enum_AVAHI_PUBLISH_UNIQUE=1_AVAHI_PUBLISH_NO_PROBE=2_AVAHI_PUBLISH_NO_ANNOUNCE=4_AVAHI_PUBLISH_ALLOW_MULTIPLE=8_AVAHI_PUBLISH_NO_REVERSE=16_AVAHI_PUBLISH_NO_COOKIE=32_AVAHI_PUBLISH_UPDATE=64_AVAHI_PUBLISH_USE_WIDE_AREA=128_AVAHI_PUBLISH_USE_MULTICAST=256
// file ../avahi-common/defs.h line 243
enum anonymous_41 { AVAHI_PUBLISH_UNIQUE=1, AVAHI_PUBLISH_NO_PROBE=2, AVAHI_PUBLISH_NO_ANNOUNCE=4, AVAHI_PUBLISH_ALLOW_MULTIPLE=8, AVAHI_PUBLISH_NO_REVERSE=16, AVAHI_PUBLISH_NO_COOKIE=32, AVAHI_PUBLISH_UPDATE=64, AVAHI_PUBLISH_USE_WIDE_AREA=128, AVAHI_PUBLISH_USE_MULTICAST=256 };

// #anon_enum_AVAHI_RESOLVER_FOUND=0_AVAHI_RESOLVER_FAILURE=1
// file ../avahi-common/defs.h line 293
enum anonymous_12 { AVAHI_RESOLVER_FOUND=0, AVAHI_RESOLVER_FAILURE=1 };

// #anon_enum_AVAHI_WATCH_IN=1_AVAHI_WATCH_OUT=4_AVAHI_WATCH_ERR=8_AVAHI_WATCH_HUP=16
// file ../avahi-common/watch.h line 42
enum anonymous { AVAHI_WATCH_IN=1, AVAHI_WATCH_OUT=4, AVAHI_WATCH_ERR=8, AVAHI_WATCH_HUP=16 };

// #anon_enum_COMMAND_HELP=0_COMMAND_SSH=1_COMMAND_VNC=2_COMMAND_SHELL=3
// file bssh.c line 41
enum anonymous_9 { COMMAND_HELP=0, COMMAND_SSH=1, COMMAND_VNC=2, COMMAND_SHELL=3 };

// #anon_enum_DBUS_BUS_SESSION=0_DBUS_BUS_SYSTEM=1_DBUS_BUS_STARTER=2
// file /usr/include/dbus-1.0/dbus/dbus-shared.h line 56
enum anonymous_45 { DBUS_BUS_SESSION=0, DBUS_BUS_SYSTEM=1, DBUS_BUS_STARTER=2 };

// #anon_enum_DBUS_DISPATCH_DATA_REMAINS=0_DBUS_DISPATCH_COMPLETE=1_DBUS_DISPATCH_NEED_MEMORY=2
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 79
enum anonymous_27 { DBUS_DISPATCH_DATA_REMAINS=0, DBUS_DISPATCH_COMPLETE=1, DBUS_DISPATCH_NEED_MEMORY=2 };

// #anon_enum_DBUS_HANDLER_RESULT_HANDLED=0_DBUS_HANDLER_RESULT_NOT_YET_HANDLED=1_DBUS_HANDLER_RESULT_NEED_MEMORY=2
// file /usr/include/dbus-1.0/dbus/dbus-shared.h line 66
enum anonymous_42 { DBUS_HANDLER_RESULT_HANDLED=0, DBUS_HANDLER_RESULT_NOT_YET_HANDLED=1, DBUS_HANDLER_RESULT_NEED_MEMORY=2 };

// #anon_enum_GDK_CROSSING_NORMAL=0_GDK_CROSSING_GRAB=1_GDK_CROSSING_UNGRAB=2_GDK_CROSSING_GTK_GRAB=3_GDK_CROSSING_GTK_UNGRAB=4_GDK_CROSSING_STATE_CHANGED=5_GDK_CROSSING_TOUCH_BEGIN=6_GDK_CROSSING_TOUCH_END=7_GDK_CROSSING_DEVICE_SWITCH=8
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 467
enum anonymous_49 { GDK_CROSSING_NORMAL=0, GDK_CROSSING_GRAB=1, GDK_CROSSING_UNGRAB=2, GDK_CROSSING_GTK_GRAB=3, GDK_CROSSING_GTK_UNGRAB=4, GDK_CROSSING_STATE_CHANGED=5, GDK_CROSSING_TOUCH_BEGIN=6, GDK_CROSSING_TOUCH_END=7, GDK_CROSSING_DEVICE_SWITCH=8 };

// #anon_enum_GDK_NOTHING=-1_GDK_DELETE=0_GDK_DESTROY=1_GDK_EXPOSE=2_GDK_MOTION_NOTIFY=3_GDK_BUTTON_PRESS=4_GDK_2BUTTON_PRESS=5_GDK_DOUBLE_BUTTON_PRESS=5_GDK_3BUTTON_PRESS=6_GDK_TRIPLE_BUTTON_PRESS=6_GDK_BUTTON_RELEASE=7_GDK_KEY_PRESS=8_GDK_KEY_RELEASE=9_GDK_ENTER_NOTIFY=10_GDK_LEAVE_NOTIFY=11_GDK_FOCUS_CHANGE=12_GDK_CONFIGURE=13_GDK_MAP=14_GDK_UNMAP=15_GDK_PROPERTY_NOTIFY=16_GDK_SELECTION_CLEAR=17_GDK_SELECTION_REQUEST=18_GDK_SELECTION_NOTIFY=19_GDK_PROXIMITY_IN=20_GDK_PROXIMITY_OUT=21_GDK_DRAG_ENTER=22_GDK_DRAG_LEAVE=23_GDK_DRAG_MOTION=24_GDK_DRAG_STATUS=25_GDK_DROP_START=26_GDK_DROP_FINISHED=27_GDK_CLIENT_EVENT=28_GDK_VISIBILITY_NOTIFY=29_GDK_SCROLL=31_GDK_WINDOW_STATE=32_GDK_SETTING=33_GDK_OWNER_CHANGE=34_GDK_GRAB_BROKEN=35_GDK_DAMAGE=36_GDK_TOUCH_BEGIN=37_GDK_TOUCH_UPDATE=38_GDK_TOUCH_END=39_GDK_TOUCH_CANCEL=40_GDK_TOUCHPAD_SWIPE=41_GDK_TOUCHPAD_PINCH=42_GDK_EVENT_LAST=43
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 295
enum anonymous_46 { GDK_NOTHING=-1, GDK_DELETE=0, GDK_DESTROY=1, GDK_EXPOSE=2, GDK_MOTION_NOTIFY=3, GDK_BUTTON_PRESS=4, GDK_2BUTTON_PRESS=5, GDK_DOUBLE_BUTTON_PRESS=5, GDK_3BUTTON_PRESS=6, GDK_TRIPLE_BUTTON_PRESS=6, GDK_BUTTON_RELEASE=7, GDK_KEY_PRESS=8, GDK_KEY_RELEASE=9, GDK_ENTER_NOTIFY=10, GDK_LEAVE_NOTIFY=11, GDK_FOCUS_CHANGE=12, GDK_CONFIGURE=13, GDK_MAP=14, GDK_UNMAP=15, GDK_PROPERTY_NOTIFY=16, GDK_SELECTION_CLEAR=17, GDK_SELECTION_REQUEST=18, GDK_SELECTION_NOTIFY=19, GDK_PROXIMITY_IN=20, GDK_PROXIMITY_OUT=21, GDK_DRAG_ENTER=22, GDK_DRAG_LEAVE=23, GDK_DRAG_MOTION=24, GDK_DRAG_STATUS=25, GDK_DROP_START=26, GDK_DROP_FINISHED=27, GDK_CLIENT_EVENT=28, GDK_VISIBILITY_NOTIFY=29, GDK_SCROLL=31, GDK_WINDOW_STATE=32, GDK_SETTING=33, GDK_OWNER_CHANGE=34, GDK_GRAB_BROKEN=35, GDK_DAMAGE=36, GDK_TOUCH_BEGIN=37, GDK_TOUCH_UPDATE=38, GDK_TOUCH_END=39, GDK_TOUCH_CANCEL=40, GDK_TOUCHPAD_SWIPE=41, GDK_TOUCHPAD_PINCH=42, GDK_EVENT_LAST=43 };

// #anon_enum_GDK_NOTIFY_ANCESTOR=0_GDK_NOTIFY_VIRTUAL=1_GDK_NOTIFY_INFERIOR=2_GDK_NOTIFY_NONLINEAR=3_GDK_NOTIFY_NONLINEAR_VIRTUAL=4_GDK_NOTIFY_UNKNOWN=5
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 438
enum anonymous_50 { GDK_NOTIFY_ANCESTOR=0, GDK_NOTIFY_VIRTUAL=1, GDK_NOTIFY_INFERIOR=2, GDK_NOTIFY_NONLINEAR=3, GDK_NOTIFY_NONLINEAR_VIRTUAL=4, GDK_NOTIFY_UNKNOWN=5 };

// #anon_enum_GDK_OWNER_CHANGE_NEW_OWNER=0_GDK_OWNER_CHANGE_DESTROY=1_GDK_OWNER_CHANGE_CLOSE=2
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 545
enum anonymous_51 { GDK_OWNER_CHANGE_NEW_OWNER=0, GDK_OWNER_CHANGE_DESTROY=1, GDK_OWNER_CHANGE_CLOSE=2 };

// #anon_enum_GDK_SCROLL_UP=0_GDK_SCROLL_DOWN=1_GDK_SCROLL_LEFT=2_GDK_SCROLL_RIGHT=3_GDK_SCROLL_SMOOTH=4
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 408
enum anonymous_48 { GDK_SCROLL_UP=0, GDK_SCROLL_DOWN=1, GDK_SCROLL_LEFT=2, GDK_SCROLL_RIGHT=3, GDK_SCROLL_SMOOTH=4 };

// #anon_enum_GDK_SETTING_ACTION_NEW=0_GDK_SETTING_ACTION_CHANGED=1_GDK_SETTING_ACTION_DELETED=2
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 530
enum anonymous_53 { GDK_SETTING_ACTION_NEW=0, GDK_SETTING_ACTION_CHANGED=1, GDK_SETTING_ACTION_DELETED=2 };

// #anon_enum_GDK_VISIBILITY_UNOBSCURED=0_GDK_VISIBILITY_PARTIAL=1_GDK_VISIBILITY_FULLY_OBSCURED=2
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 353
enum anonymous_47 { GDK_VISIBILITY_UNOBSCURED=0, GDK_VISIBILITY_PARTIAL=1, GDK_VISIBILITY_FULLY_OBSCURED=2 };

// #anon_enum_GDK_WINDOW_STATE_WITHDRAWN=1_GDK_WINDOW_STATE_ICONIFIED=2_GDK_WINDOW_STATE_MAXIMIZED=4_GDK_WINDOW_STATE_STICKY=8_GDK_WINDOW_STATE_FULLSCREEN=16_GDK_WINDOW_STATE_ABOVE=32_GDK_WINDOW_STATE_BELOW=64_GDK_WINDOW_STATE_FOCUSED=128_GDK_WINDOW_STATE_TILED=256
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 508
enum anonymous_52 { GDK_WINDOW_STATE_WITHDRAWN=1, GDK_WINDOW_STATE_ICONIFIED=2, GDK_WINDOW_STATE_MAXIMIZED=4, GDK_WINDOW_STATE_STICKY=8, GDK_WINDOW_STATE_FULLSCREEN=16, GDK_WINDOW_STATE_ABOVE=32, GDK_WINDOW_STATE_BELOW=64, GDK_WINDOW_STATE_FOCUSED=128, GDK_WINDOW_STATE_TILED=256 };

// #anon_enum_GDK_X_CURSOR=0_GDK_ARROW=2_GDK_BASED_ARROW_DOWN=4_GDK_BASED_ARROW_UP=6_GDK_BOAT=8_GDK_BOGOSITY=10_GDK_BOTTOM_LEFT_CORNER=12_GDK_BOTTOM_RIGHT_CORNER=14_GDK_BOTTOM_SIDE=16_GDK_BOTTOM_TEE=18_GDK_BOX_SPIRAL=20_GDK_CENTER_PTR=22_GDK_CIRCLE=24_GDK_CLOCK=26_GDK_COFFEE_MUG=28_GDK_CROSS=30_GDK_CROSS_REVERSE=32_GDK_CROSSHAIR=34_GDK_DIAMOND_CROSS=36_GDK_DOT=38_GDK_DOTBOX=40_GDK_DOUBLE_ARROW=42_GDK_DRAFT_LARGE=44_GDK_DRAFT_SMALL=46_GDK_DRAPED_BOX=48_GDK_EXCHANGE=50_GDK_FLEUR=52_GDK_GOBBLER=54_GDK_GUMBY=56_GDK_HAND1=58_GDK_HAND2=60_GDK_HEART=62_GDK_ICON=64_GDK_IRON_CROSS=66_GDK_LEFT_PTR=68_GDK_LEFT_SIDE=70_GDK_LEFT_TEE=72_GDK_LEFTBUTTON=74_GDK_LL_ANGLE=76_GDK_LR_ANGLE=78_GDK_MAN=80_GDK_MIDDLEBUTTON=82_GDK_MOUSE=84_GDK_PENCIL=86_GDK_PIRATE=88_GDK_PLUS=90_GDK_QUESTION_ARROW=92_GDK_RIGHT_PTR=94_GDK_RIGHT_SIDE=96_GDK_RIGHT_TEE=98_GDK_RIGHTBUTTON=100_GDK_RTL_LOGO=102_GDK_SAILBOAT=104_GDK_SB_DOWN_ARROW=106_GDK_SB_H_DOUBLE_ARROW=108_GDK_SB_LEFT_ARROW=110_GDK_SB_RIGHT_ARROW=112_GDK_SB_UP_ARROW=114_GDK_SB_V_DOUBLE_ARROW=116_GDK_SHUTTLE=118_GDK_SIZING=120_GDK_SPIDER=122_GDK_SPRAYCAN=124_GDK_STAR=126_GDK_TARGET=128_GDK_TCROSS=130_GDK_TOP_LEFT_ARROW=132_GDK_TOP_LEFT_CORNER=134_GDK_TOP_RIGHT_CORNER=136_GDK_TOP_SIDE=138_GDK_TOP_TEE=140_GDK_TREK=142_GDK_UL_ANGLE=144_GDK_UMBRELLA=146_GDK_UR_ANGLE=148_GDK_WATCH=150_GDK_XTERM=152_GDK_LAST_CURSOR=153_GDK_BLANK_CURSOR=-2_GDK_CURSOR_IS_PIXMAP=-1
// file /usr/include/gtk-3.0/gdk/gdkcursor.h line 134
enum anonymous_34 { GDK_X_CURSOR=0, GDK_ARROW=2, GDK_BASED_ARROW_DOWN=4, GDK_BASED_ARROW_UP=6, GDK_BOAT=8, GDK_BOGOSITY=10, GDK_BOTTOM_LEFT_CORNER=12, GDK_BOTTOM_RIGHT_CORNER=14, GDK_BOTTOM_SIDE=16, GDK_BOTTOM_TEE=18, GDK_BOX_SPIRAL=20, GDK_CENTER_PTR=22, GDK_CIRCLE=24, GDK_CLOCK=26, GDK_COFFEE_MUG=28, GDK_CROSS=30, GDK_CROSS_REVERSE=32, GDK_CROSSHAIR=34, GDK_DIAMOND_CROSS=36, GDK_DOT=38, GDK_DOTBOX=40, GDK_DOUBLE_ARROW=42, GDK_DRAFT_LARGE=44, GDK_DRAFT_SMALL=46, GDK_DRAPED_BOX=48, GDK_EXCHANGE=50, GDK_FLEUR=52, GDK_GOBBLER=54, GDK_GUMBY=56, GDK_HAND1=58, GDK_HAND2=60, GDK_HEART=62, GDK_ICON=64, GDK_IRON_CROSS=66, GDK_LEFT_PTR=68, GDK_LEFT_SIDE=70, GDK_LEFT_TEE=72, GDK_LEFTBUTTON=74, GDK_LL_ANGLE=76, GDK_LR_ANGLE=78, GDK_MAN=80, GDK_MIDDLEBUTTON=82, GDK_MOUSE=84, GDK_PENCIL=86, GDK_PIRATE=88, GDK_PLUS=90, GDK_QUESTION_ARROW=92, GDK_RIGHT_PTR=94, GDK_RIGHT_SIDE=96, GDK_RIGHT_TEE=98, GDK_RIGHTBUTTON=100, GDK_RTL_LOGO=102, GDK_SAILBOAT=104, GDK_SB_DOWN_ARROW=106, GDK_SB_H_DOUBLE_ARROW=108, GDK_SB_LEFT_ARROW=110, GDK_SB_RIGHT_ARROW=112, GDK_SB_UP_ARROW=114, GDK_SB_V_DOUBLE_ARROW=116, GDK_SHUTTLE=118, GDK_SIZING=120, GDK_SPIDER=122, GDK_SPRAYCAN=124, GDK_STAR=126, GDK_TARGET=128, GDK_TCROSS=130, GDK_TOP_LEFT_ARROW=132, GDK_TOP_LEFT_CORNER=134, GDK_TOP_RIGHT_CORNER=136, GDK_TOP_SIDE=138, GDK_TOP_TEE=140, GDK_TREK=142, GDK_UL_ANGLE=144, GDK_UMBRELLA=146, GDK_UR_ANGLE=148, GDK_WATCH=150, GDK_XTERM=152, GDK_LAST_CURSOR=153, GDK_BLANK_CURSOR=-2, GDK_CURSOR_IS_PIXMAP=-1 };

// #anon_enum_GTK_BUTTONS_NONE=0_GTK_BUTTONS_OK=1_GTK_BUTTONS_CLOSE=2_GTK_BUTTONS_CANCEL=3_GTK_BUTTONS_YES_NO=4_GTK_BUTTONS_OK_CANCEL=5
// file /usr/include/gtk-3.0/gtk/gtkmessagedialog.h line 85
enum anonymous_17 { GTK_BUTTONS_NONE=0, GTK_BUTTONS_OK=1, GTK_BUTTONS_CLOSE=2, GTK_BUTTONS_CANCEL=3, GTK_BUTTONS_YES_NO=4, GTK_BUTTONS_OK_CANCEL=5 };

// #anon_enum_GTK_DIALOG_MODAL=1_GTK_DIALOG_DESTROY_WITH_PARENT=2_GTK_DIALOG_USE_HEADER_BAR=4
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 49
enum anonymous_30 { GTK_DIALOG_MODAL=1, GTK_DIALOG_DESTROY_WITH_PARENT=2, GTK_DIALOG_USE_HEADER_BAR=4 };

// #anon_enum_GTK_DIR_TAB_FORWARD=0_GTK_DIR_TAB_BACKWARD=1_GTK_DIR_UP=2_GTK_DIR_DOWN=3_GTK_DIR_LEFT=4_GTK_DIR_RIGHT=5
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 166
enum anonymous_22 { GTK_DIR_TAB_FORWARD=0, GTK_DIR_TAB_BACKWARD=1, GTK_DIR_UP=2, GTK_DIR_DOWN=3, GTK_DIR_LEFT=4, GTK_DIR_RIGHT=5 };

// #anon_enum_GTK_DRAG_RESULT_SUCCESS=0_GTK_DRAG_RESULT_NO_TARGET=1_GTK_DRAG_RESULT_USER_CANCELLED=2_GTK_DRAG_RESULT_TIMEOUT_EXPIRED=3_GTK_DRAG_RESULT_GRAB_BROKEN=4_GTK_DRAG_RESULT_ERROR=5
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 788
enum anonymous_23 { GTK_DRAG_RESULT_SUCCESS=0, GTK_DRAG_RESULT_NO_TARGET=1, GTK_DRAG_RESULT_USER_CANCELLED=2, GTK_DRAG_RESULT_TIMEOUT_EXPIRED=3, GTK_DRAG_RESULT_GRAB_BROKEN=4, GTK_DRAG_RESULT_ERROR=5 };

// #anon_enum_GTK_ICON_SIZE_INVALID=0_GTK_ICON_SIZE_MENU=1_GTK_ICON_SIZE_SMALL_TOOLBAR=2_GTK_ICON_SIZE_LARGE_TOOLBAR=3_GTK_ICON_SIZE_BUTTON=4_GTK_ICON_SIZE_DND=5_GTK_ICON_SIZE_DIALOG=6
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 188
enum anonymous_32 { GTK_ICON_SIZE_INVALID=0, GTK_ICON_SIZE_MENU=1, GTK_ICON_SIZE_SMALL_TOOLBAR=2, GTK_ICON_SIZE_LARGE_TOOLBAR=3, GTK_ICON_SIZE_BUTTON=4, GTK_ICON_SIZE_DND=5, GTK_ICON_SIZE_DIALOG=6 };

// #anon_enum_GTK_MESSAGE_INFO=0_GTK_MESSAGE_WARNING=1_GTK_MESSAGE_QUESTION=2_GTK_MESSAGE_ERROR=3_GTK_MESSAGE_OTHER=4
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 277
enum anonymous_29 { GTK_MESSAGE_INFO=0, GTK_MESSAGE_WARNING=1, GTK_MESSAGE_QUESTION=2, GTK_MESSAGE_ERROR=3, GTK_MESSAGE_OTHER=4 };

// #anon_enum_GTK_ORIENTATION_HORIZONTAL=0_GTK_ORIENTATION_VERTICAL=1
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 341
enum anonymous_16 { GTK_ORIENTATION_HORIZONTAL=0, GTK_ORIENTATION_VERTICAL=1 };

// #anon_enum_GTK_POLICY_ALWAYS=0_GTK_POLICY_AUTOMATIC=1_GTK_POLICY_NEVER=2_GTK_POLICY_EXTERNAL=3
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 136
enum anonymous_2 { GTK_POLICY_ALWAYS=0, GTK_POLICY_AUTOMATIC=1, GTK_POLICY_NEVER=2, GTK_POLICY_EXTERNAL=3 };

// #anon_enum_GTK_RC_FG=1_GTK_RC_BG=2_GTK_RC_TEXT=4_GTK_RC_BASE=8
// file /usr/include/gtk-3.0/gtk/deprecated/gtkrc.h line 57
enum anonymous_33 { GTK_RC_FG=1, GTK_RC_BG=2, GTK_RC_TEXT=4, GTK_RC_BASE=8 };

// #anon_enum_GTK_SELECTION_NONE=0_GTK_SELECTION_SINGLE=1_GTK_SELECTION_BROWSE=2_GTK_SELECTION_MULTIPLE=3
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 453
enum anonymous_1 { GTK_SELECTION_NONE=0, GTK_SELECTION_SINGLE=1, GTK_SELECTION_BROWSE=2, GTK_SELECTION_MULTIPLE=3 };

// #anon_enum_GTK_SHADOW_NONE=0_GTK_SHADOW_IN=1_GTK_SHADOW_OUT=2_GTK_SHADOW_ETCHED_IN=3_GTK_SHADOW_ETCHED_OUT=4
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 475
enum anonymous_5 { GTK_SHADOW_NONE=0, GTK_SHADOW_IN=1, GTK_SHADOW_OUT=2, GTK_SHADOW_ETCHED_IN=3, GTK_SHADOW_ETCHED_OUT=4 };

// #anon_enum_GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH=0_GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT=1_GTK_SIZE_REQUEST_CONSTANT_SIZE=2
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 824
enum anonymous_21 { GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH=0, GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT=1, GTK_SIZE_REQUEST_CONSTANT_SIZE=2 };

// #anon_enum_GTK_STATE_FLAG_NORMAL=0_GTK_STATE_FLAG_ACTIVE=1_GTK_STATE_FLAG_PRELIGHT=2_GTK_STATE_FLAG_SELECTED=4_GTK_STATE_FLAG_INSENSITIVE=8_GTK_STATE_FLAG_INCONSISTENT=16_GTK_STATE_FLAG_FOCUSED=32_GTK_STATE_FLAG_BACKDROP=64_GTK_STATE_FLAG_DIR_LTR=128_GTK_STATE_FLAG_DIR_RTL=256_GTK_STATE_FLAG_LINK=512_GTK_STATE_FLAG_VISITED=1024_GTK_STATE_FLAG_CHECKED=2048
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 865
enum anonymous_19 { GTK_STATE_FLAG_NORMAL=0, GTK_STATE_FLAG_ACTIVE=1, GTK_STATE_FLAG_PRELIGHT=2, GTK_STATE_FLAG_SELECTED=4, GTK_STATE_FLAG_INSENSITIVE=8, GTK_STATE_FLAG_INCONSISTENT=16, GTK_STATE_FLAG_FOCUSED=32, GTK_STATE_FLAG_BACKDROP=64, GTK_STATE_FLAG_DIR_LTR=128, GTK_STATE_FLAG_DIR_RTL=256, GTK_STATE_FLAG_LINK=512, GTK_STATE_FLAG_VISITED=1024, GTK_STATE_FLAG_CHECKED=2048 };

// #anon_enum_GTK_STATE_NORMAL=0_GTK_STATE_ACTIVE=1_GTK_STATE_PRELIGHT=2_GTK_STATE_SELECTED=3_GTK_STATE_INSENSITIVE=4_GTK_STATE_INCONSISTENT=5_GTK_STATE_FOCUSED=6
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 508
enum anonymous_18 { GTK_STATE_NORMAL=0, GTK_STATE_ACTIVE=1, GTK_STATE_PRELIGHT=2, GTK_STATE_SELECTED=3, GTK_STATE_INSENSITIVE=4, GTK_STATE_INCONSISTENT=5, GTK_STATE_FOCUSED=6 };

// #anon_enum_GTK_TEXT_DIR_NONE=0_GTK_TEXT_DIR_LTR=1_GTK_TEXT_DIR_RTL=2
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 225
enum anonymous_20 { GTK_TEXT_DIR_NONE=0, GTK_TEXT_DIR_LTR=1, GTK_TEXT_DIR_RTL=2 };

// #anon_enum_GTK_WIDGET_HELP_TOOLTIP=0_GTK_WIDGET_HELP_WHATS_THIS=1
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 48
enum anonymous_26 { GTK_WIDGET_HELP_TOOLTIP=0, GTK_WIDGET_HELP_WHATS_THIS=1 };

// #anon_enum_G_CONNECT_AFTER=1_G_CONNECT_SWAPPED=2
// file /usr/include/glib-2.0/gobject/gsignal.h line 155
enum anonymous_7 { G_CONNECT_AFTER=1, G_CONNECT_SWAPPED=2 };

// #anon_enum_G_LOG_FLAG_RECURSION=1_G_LOG_FLAG_FATAL=2_G_LOG_LEVEL_ERROR=4_G_LOG_LEVEL_CRITICAL=8_G_LOG_LEVEL_WARNING=16_G_LOG_LEVEL_MESSAGE=32_G_LOG_LEVEL_INFO=64_G_LOG_LEVEL_DEBUG=128_G_LOG_LEVEL_MASK=-4
// file /usr/include/glib-2.0/glib/gmessages.h line 51
enum anonymous_10 { G_LOG_FLAG_RECURSION=1, G_LOG_FLAG_FATAL=2, G_LOG_LEVEL_ERROR=4, G_LOG_LEVEL_CRITICAL=8, G_LOG_LEVEL_WARNING=16, G_LOG_LEVEL_MESSAGE=32, G_LOG_LEVEL_INFO=64, G_LOG_LEVEL_DEBUG=128, G_LOG_LEVEL_MASK=-4 };

// #anon_enum_G_PARAM_READABLE=1_G_PARAM_WRITABLE=2_G_PARAM_READWRITE=3_G_PARAM_CONSTRUCT=4_G_PARAM_CONSTRUCT_ONLY=8_G_PARAM_LAX_VALIDATION=16_G_PARAM_STATIC_NAME=32_G_PARAM_PRIVATE=32_G_PARAM_STATIC_NICK=64_G_PARAM_STATIC_BLURB=128_G_PARAM_EXPLICIT_NOTIFY=1073741824_G_PARAM_DEPRECATED=-2147483648
// file /usr/include/glib-2.0/gobject/gparam.h line 150
enum anonymous_35 { G_PARAM_READABLE=1, G_PARAM_WRITABLE=2, G_PARAM_READWRITE=3, G_PARAM_CONSTRUCT=4, G_PARAM_CONSTRUCT_ONLY=8, G_PARAM_LAX_VALIDATION=16, G_PARAM_STATIC_NAME=32, G_PARAM_PRIVATE=32, G_PARAM_STATIC_NICK=64, G_PARAM_STATIC_BLURB=128, G_PARAM_EXPLICIT_NOTIFY=1073741824, G_PARAM_DEPRECATED=-2147483648 };

// #anon_enum_G_TYPE_FLAG_ABSTRACT=16_G_TYPE_FLAG_VALUE_ABSTRACT=32
// file /usr/include/glib-2.0/gobject/gtype.h line 993
enum anonymous_3 { G_TYPE_FLAG_ABSTRACT=16, G_TYPE_FLAG_VALUE_ABSTRACT=32 };

// #anon_enum_PANGO_ELLIPSIZE_NONE=0_PANGO_ELLIPSIZE_START=1_PANGO_ELLIPSIZE_MIDDLE=2_PANGO_ELLIPSIZE_END=3
// file /usr/include/pango-1.0/pango/pango-layout.h line 90
enum anonymous_0 { PANGO_ELLIPSIZE_NONE=0, PANGO_ELLIPSIZE_START=1, PANGO_ELLIPSIZE_MIDDLE=2, PANGO_ELLIPSIZE_END=3 };

// #anon_enum_STATE_INIT=0_STATE_PREPARING=1_STATE_PREPARED=2_STATE_RUNNING=3_STATE_RAN=4_STATE_DISPATCHING=5_STATE_DISPATCHED=6_STATE_QUIT=7_STATE_FAILURE=8
// file simple-watch.c line 84
enum anonymous_31 { STATE_INIT=0, STATE_PREPARING=1, STATE_PREPARED=2, STATE_RUNNING=3, STATE_RAN=4, STATE_DISPATCHING=5, STATE_DISPATCHED=6, STATE_QUIT=7, STATE_FAILURE=8 };

// tag-#anon#ST[*{S8}_S8_'dptr'||S32'dsize'||U32'_pad0'|]
// file /usr/include/gdbm.h line 56
struct anonymous_37;

// tag-#anon#ST[*{SYM#tag-DBusConnection#}_SYM#tag-DBusConnection#_'connection'||*{cSYM#tag-AvahiPoll#}_cSYM#tag-AvahiPoll#_'poll_api'||*{SYM#tag-AvahiTimeout#}_SYM#tag-AvahiTimeout#_'dispatch_timeout'||S32'ref'||U32'_pad0'|]
// file ../avahi-common/dbus-watch-glue.c line 61
struct anonymous_28;

// tag-#anon#ST[ARR10{S32}_S32_'dummy'|]
// file /usr/include/gdbm.h line 63
struct anonymous_36;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_8;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_38;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}_V_'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous_54;

// tag-#anon#UN[SYM#tag-AvahiIPv6Address#'ipv6'||SYM#tag-AvahiIPv4Address#'ipv4'||ARR1{U8}_U8_'data'|]
// file ../avahi-common/address.h line 73
union anonymous_15;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_6;

// tag-AvahiAddress
// file ../avahi-common/address.h line 70
struct AvahiAddress;

// tag-AvahiAddressResolver
// file lookup.h line 242
struct AvahiAddressResolver;

// tag-AvahiAllocator
// file malloc.h line 75
struct AvahiAllocator;

// tag-AvahiClient
// file client.h line 37
struct AvahiClient;

// tag-AvahiDomainBrowser
// file lookup.h line 44
struct AvahiDomainBrowser;

// tag-AvahiEntryGroup
// file publish.h line 43
struct AvahiEntryGroup;

// tag-AvahiGLibPoll
// file ../avahi-glib/glib-watch.h line 36
struct AvahiGLibPoll;

// tag-AvahiGLibPoll_link1
// file glib-watch.h line 36
struct AvahiGLibPoll;

// tag-AvahiHostNameResolver
// file lookup.h line 211
struct AvahiHostNameResolver;

// tag-AvahiIPv4Address
// file ../avahi-common/address.h line 60
struct AvahiIPv4Address;

// tag-AvahiIPv6Address
// file ../avahi-common/address.h line 65
struct AvahiIPv6Address;

// tag-AvahiPoll
// file ../avahi-common/watch.h line 39
struct AvahiPoll_1;

// tag-AvahiPoll_link1
// file ../avahi-common/watch.h line 39
struct AvahiPoll_0;

// tag-AvahiPoll_link2
// file ../avahi-common/watch.h line 39
struct AvahiPoll;

// tag-AvahiRList
// file rlist.h line 30
struct AvahiRList;

// tag-AvahiRecordBrowser
// file lookup.h line 276
struct AvahiRecordBrowser;

// tag-AvahiServiceBrowser
// file lookup.h line 78
struct AvahiServiceBrowser;

// tag-AvahiServiceResolver
// file lookup.h line 157
struct AvahiServiceResolver;

// tag-AvahiServiceTypeBrowser
// file lookup.h line 123
struct AvahiServiceTypeBrowser;

// tag-AvahiSimplePoll
// file simple-watch.h line 34
struct AvahiSimplePoll_0;

// tag-AvahiSimplePoll_link1
// file simple-watch.h line 34
struct AvahiSimplePoll;

// tag-AvahiStringList
// file ../avahi-common/strlst.h line 40
struct AvahiStringList;

// tag-AvahiThreadedPoll
// file thread-watch.h line 32
struct AvahiThreadedPoll_0;

// tag-AvahiThreadedPoll_link1
// file thread-watch.h line 32
struct AvahiThreadedPoll;

// tag-AvahiTimeout
// file ../avahi-common/watch.h line 36
struct AvahiTimeout_1;

// tag-AvahiTimeout_link1
// file ../avahi-common/watch.h line 36
struct AvahiTimeout_0;

// tag-AvahiTimeout_link2
// file ../avahi-common/watch.h line 36
struct AvahiTimeout;

// tag-AvahiWatch
// file ../avahi-common/watch.h line 33
struct AvahiWatch_1;

// tag-AvahiWatch_link1
// file ../avahi-common/watch.h line 33
struct AvahiWatch;

// tag-AvahiWatch_link2
// file ../avahi-common/watch.h line 33
struct AvahiWatch_0;

// tag-Config
// file bssh.c line 48
struct Config;

// tag-DBusConnection
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 51
struct DBusConnection;

// tag-DBusError
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 43
struct DBusError;

// tag-DBusMessage
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 44
struct DBusMessage;

// tag-DBusMessageIter
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 46
struct DBusMessageIter;

// tag-DBusTimeout
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 45
struct DBusTimeout;

// tag-DBusWatch
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 43
struct DBusWatch;

// tag-TimeoutData
// file ../avahi-common/dbus-watch-glue.c line 196
struct TimeoutData;

// tag-_AtkObject
// file /usr/include/atk-1.0/atk/atkobject.h line 440
struct _AtkObject;

// tag-_AtkRelationSet
// file /usr/include/atk-1.0/atk/atkobject.h line 442
struct _AtkRelationSet;

// tag-_AuiServiceDialog
// file avahi-ui.h line 53
struct _AuiServiceDialog;

// tag-_AuiServiceDialogClass
// file avahi-ui.h line 41
struct _AuiServiceDialogClass;

// tag-_AuiServiceDialogPrivate
// file avahi-ui.h line 40
struct _AuiServiceDialogPrivate;

// tag-_GArray
// file /usr/include/glib-2.0/glib/garray.h line 37
struct _GArray;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GHashTable
// file /usr/include/glib-2.0/glib/ghash.h line 37
struct _GHashTable;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GMainContext
// file /usr/include/glib-2.0/glib/gmain.h line 48
struct _GMainContext;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GObjectClass
// file /usr/include/glib-2.0/gobject/gobject.h line 188
struct _GObjectClass;

// tag-_GObjectConstructParam
// file /usr/include/glib-2.0/gobject/gobject.h line 191
struct _GObjectConstructParam;

// tag-_GParamSpec
// file /usr/include/glib-2.0/gobject/gparam.h line 193
struct _GParamSpec;

// tag-_GPollFD
// file /usr/include/glib-2.0/glib/gpoll.h line 58
struct _GPollFD;

// tag-_GPtrArray
// file /usr/include/glib-2.0/glib/garray.h line 39
struct _GPtrArray;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GSource
// file /usr/include/glib-2.0/glib/gmain.h line 64
struct _GSource;

// tag-_GSourceCallbackFuncs
// file /usr/include/glib-2.0/glib/gmain.h line 77
struct _GSourceCallbackFuncs;

// tag-_GSourceFuncs
// file /usr/include/glib-2.0/glib/gmain.h line 130
struct _GSourceFuncs;

// tag-_GSourcePrivate
// file /usr/include/glib-2.0/glib/gmain.h line 65
struct _GSourcePrivate;

// tag-_GTimeVal
// file /usr/include/glib-2.0/glib/gtypes.h line 449
struct _GTimeVal;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GdkAtom
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 102
struct _GdkAtom;

// tag-_GdkColor
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 132
struct _GdkColor;

// tag-_GdkCursor
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 134
struct _GdkCursor;

// tag-_GdkDevice
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 136
struct _GdkDevice;

// tag-_GdkDragContext
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 137
struct _GdkDragContext;

// tag-_GdkEvent
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 147
union _GdkEvent;

// tag-_GdkEventAny
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 123
struct _GdkEventAny;

// tag-_GdkEventButton
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 127
struct _GdkEventButton;

// tag-_GdkEventConfigure
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 133
struct _GdkEventConfigure;

// tag-_GdkEventCrossing
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 132
struct _GdkEventCrossing;

// tag-_GdkEventDND
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 138
struct _GdkEventDND;

// tag-_GdkEventExpose
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 124
struct _GdkEventExpose;

// tag-_GdkEventFocus
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 131
struct _GdkEventFocus;

// tag-_GdkEventGrabBroken
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 141
struct _GdkEventGrabBroken;

// tag-_GdkEventKey
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 130
struct _GdkEventKey;

// tag-_GdkEventMotion
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 126
struct _GdkEventMotion;

// tag-_GdkEventOwnerChange
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 136
struct _GdkEventOwnerChange;

// tag-_GdkEventProperty
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 134
struct _GdkEventProperty;

// tag-_GdkEventProximity
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 137
struct _GdkEventProximity;

// tag-_GdkEventScroll
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 129
struct _GdkEventScroll;

// tag-_GdkEventSelection
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 135
struct _GdkEventSelection;

// tag-_GdkEventSequence
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 145
struct _GdkEventSequence;

// tag-_GdkEventSetting
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 140
struct _GdkEventSetting;

// tag-_GdkEventTouch
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 128
struct _GdkEventTouch;

// tag-_GdkEventTouchpadPinch
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 143
struct _GdkEventTouchpadPinch;

// tag-_GdkEventTouchpadSwipe
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 142
struct _GdkEventTouchpadSwipe;

// tag-_GdkEventVisibility
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 125
struct _GdkEventVisibility;

// tag-_GdkEventWindowState
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 139
struct _GdkEventWindowState;

// tag-_GdkScreen
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 142
struct _GdkScreen;

// tag-_GdkVisual
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 135
struct _GdkVisual;

// tag-_GdkWindow
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 143
struct _GdkWindow;

// tag-_GtkAdjustment
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 34
struct _GtkAdjustment;

// tag-_GtkAdjustmentPrivate
// file /usr/include/gtk-3.0/gtk/gtkadjustment.h line 45
struct _GtkAdjustmentPrivate;

// tag-_GtkBin
// file /usr/include/gtk-3.0/gtk/gtkbin.h line 46
struct _GtkBin;

// tag-_GtkBinClass
// file /usr/include/gtk-3.0/gtk/gtkbin.h line 48
struct _GtkBinClass;

// tag-_GtkBinPrivate
// file /usr/include/gtk-3.0/gtk/gtkbin.h line 47
struct _GtkBinPrivate;

// tag-_GtkBox
// file /usr/include/gtk-3.0/gtk/gtkbox.h line 47
struct _GtkBox;

// tag-_GtkBoxPrivate
// file /usr/include/gtk-3.0/gtk/gtkbox.h line 48
struct _GtkBoxPrivate;

// tag-_GtkButton
// file /usr/include/gtk-3.0/gtk/gtkbutton.h line 46
struct _GtkButton;

// tag-_GtkButtonBox
// file /usr/include/gtk-3.0/gtk/gtkbbox.h line 45
struct _GtkButtonBox;

// tag-_GtkButtonBoxPrivate
// file /usr/include/gtk-3.0/gtk/gtkbbox.h line 46
struct _GtkButtonBoxPrivate;

// tag-_GtkButtonPrivate
// file /usr/include/gtk-3.0/gtk/gtkbutton.h line 47
struct _GtkButtonPrivate;

// tag-_GtkCellRenderer
// file /usr/include/gtk-3.0/gtk/gtkcellrenderer.h line 80
struct _GtkCellRenderer;

// tag-_GtkCellRendererPrivate
// file /usr/include/gtk-3.0/gtk/gtkcellrenderer.h line 81
struct _GtkCellRendererPrivate;

// tag-_GtkContainer
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 46
struct _GtkContainer;

// tag-_GtkContainerClass
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 48
struct _GtkContainerClass;

// tag-_GtkContainerPrivate
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 47
struct _GtkContainerPrivate;

// tag-_GtkDialog
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 99
struct _GtkDialog;

// tag-_GtkDialogClass
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 101
struct _GtkDialogClass;

// tag-_GtkDialogPrivate
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 100
struct _GtkDialogPrivate;

// tag-_GtkEditable
// file /usr/include/gtk-3.0/gtk/gtkeditable.h line 43
struct _GtkEditable;

// tag-_GtkEntry
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 70
struct _GtkEntry;

// tag-_GtkEntryPrivate
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 71
struct _GtkEntryPrivate;

// tag-_GtkLabel
// file /usr/include/gtk-3.0/gtk/gtklabel.h line 48
struct _GtkLabel;

// tag-_GtkLabelPrivate
// file /usr/include/gtk-3.0/gtk/gtklabel.h line 49
struct _GtkLabelPrivate;

// tag-_GtkListStore
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 40
struct _GtkListStore;

// tag-_GtkListStorePrivate
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 41
struct _GtkListStorePrivate;

// tag-_GtkMisc
// file /usr/include/gtk-3.0/gtk/deprecated/gtkmisc.h line 46
struct _GtkMisc;

// tag-_GtkMiscPrivate
// file /usr/include/gtk-3.0/gtk/deprecated/gtkmisc.h line 47
struct _GtkMiscPrivate;

// tag-_GtkProgressBar
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 44
struct _GtkProgressBar;

// tag-_GtkProgressBarPrivate
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 45
struct _GtkProgressBarPrivate;

// tag-_GtkRcStyle
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 39
struct _GtkRcStyle;

// tag-_GtkScrolledWindow
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 45
struct _GtkScrolledWindow;

// tag-_GtkScrolledWindowPrivate
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 46
struct _GtkScrolledWindowPrivate;

// tag-_GtkSelectionData
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 41
struct _GtkSelectionData;

// tag-_GtkStyle
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 43
struct _GtkStyle;

// tag-_GtkTooltip
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 45
struct _GtkTooltip;

// tag-_GtkTreeIter
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 39
struct _GtkTreeIter;

// tag-_GtkTreeModel
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 42
struct _GtkTreeModel;

// tag-_GtkTreePath
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 40
struct _GtkTreePath;

// tag-_GtkTreeSelection
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 64
struct _GtkTreeSelection;

// tag-_GtkTreeSelectionPrivate
// file /usr/include/gtk-3.0/gtk/gtktreeselection.h line 37
struct _GtkTreeSelectionPrivate;

// tag-_GtkTreeView
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 61
struct _GtkTreeView;

// tag-_GtkTreeViewColumn
// file /usr/include/gtk-3.0/gtk/gtktreeviewcolumn.h line 41
struct _GtkTreeViewColumn;

// tag-_GtkTreeViewColumnPrivate
// file /usr/include/gtk-3.0/gtk/gtktreeviewcolumn.h line 43
struct _GtkTreeViewColumnPrivate;

// tag-_GtkTreeViewPrivate
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 63
struct _GtkTreeViewPrivate;

// tag-_GtkWidget
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 46
struct _GtkWidget;

// tag-_GtkWidgetClass
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 67
struct _GtkWidgetClass;

// tag-_GtkWidgetClassPrivate
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 68
struct _GtkWidgetClassPrivate;

// tag-_GtkWidgetPath
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 47
struct _GtkWidgetPath;

// tag-_GtkWidgetPrivate
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 66
struct _GtkWidgetPrivate;

// tag-_GtkWindow
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 48
struct _GtkWindow;

// tag-_GtkWindowClass
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 47
struct _GtkWindowClass;

// tag-_GtkWindowPrivate
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 46
struct _GtkWindowPrivate;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_PangoFontDescription
// file /usr/include/pango-1.0/pango/pango-font.h line 40
struct _PangoFontDescription;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_cairo
// file /usr/include/cairo/cairo.h line 124
struct _cairo;

// tag-_cairo_pattern
// file /usr/include/cairo/cairo.h line 220
struct _cairo_pattern;

// tag-_cairo_rectangle_int
// file /usr/include/cairo/cairo.h line 475
struct _cairo_rectangle_int;

// tag-_cairo_region
// file /usr/include/cairo/cairo.h line 3049
struct _cairo_region;

// tag-error_map
// file ../avahi-common/dbus.c line 93
struct error_map;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __atomic_load_8
// file avahi-ui.c line 169 function aui_service_dialog_get_type
signed int __atomic_load_8(void);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// add_timeout
// file ../avahi-common/dbus-watch-glue.c line 254
static unsigned int add_timeout(struct DBusTimeout *dbus_timeout, void *userdata);
// add_timeout_link1
// file ../avahi-common/dbus-watch-glue.c line 254
static unsigned int add_timeout_link1(struct DBusTimeout *dbus_timeout_link1, void *userdata_link1);
// add_watch
// file ../avahi-common/dbus-watch-glue.c line 165
static unsigned int add_watch(struct DBusWatch *dbus_watch, void *userdata);
// add_watch_link1
// file ../avahi-common/dbus-watch-glue.c line 165
static unsigned int add_watch_link1(struct DBusWatch *dbus_watch_link1, void *userdata_link1);
// address_get_size
// file address.c line 35
static unsigned long int address_get_size(const struct AvahiAddress *a);
// address_get_size_link1
// file address.c line 35
static unsigned long int address_get_size_link1(const struct AvahiAddress *a_link1);
// address_get_size_link1_link1
// file address.c line 35
static unsigned long int address_get_size_link1_link1(const struct AvahiAddress *a_link1_link1);
// address_get_size_link2
// file address.c line 35
static unsigned long int address_get_size_link2(const struct AvahiAddress *a_link2);
// address_get_size_link3
// file address.c line 35
static unsigned long int address_get_size_link3(const struct AvahiAddress *a_link3);
// append_rdata
// file entrygroup.c line 348
static signed int append_rdata(struct DBusMessage *message, const void *rdata, unsigned long int size);
// append_rdata_link1
// file entrygroup.c line 348
static signed int append_rdata_link1(struct DBusMessage *message_link1, const void *rdata_link1, unsigned long int size_link1);
// append_string_list
// file entrygroup.c line 363
static signed int append_string_list(struct DBusMessage *message, struct AvahiStringList *txt);
// append_string_list_link1
// file entrygroup.c line 363
static signed int append_string_list_link1(struct DBusMessage *message_link1, struct AvahiStringList *txt_link1);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// aui_service_dialog_class_init
// file avahi-ui.c line 171
static void aui_service_dialog_class_init(struct _AuiServiceDialogClass *klass);
// aui_service_dialog_class_intern_init
// file avahi-ui.c line 169
static void aui_service_dialog_class_intern_init(void *klass);
// aui_service_dialog_finalize
// file avahi-ui.c line 788
static void aui_service_dialog_finalize(struct _GObject *object);
// aui_service_dialog_get_address
// file avahi-ui.h line 128
const struct AvahiAddress * aui_service_dialog_get_address(struct _AuiServiceDialog *d);
// aui_service_dialog_get_address_family
// file avahi-ui.c line 1397
signed int aui_service_dialog_get_address_family(struct _AuiServiceDialog *d);
// aui_service_dialog_get_browse_service_types
// file avahi-ui.c line 1262
const char * const * aui_service_dialog_get_browse_service_types(struct _AuiServiceDialog *d);
// aui_service_dialog_get_domain
// file avahi-ui.c line 1306
const char * aui_service_dialog_get_domain(struct _AuiServiceDialog *d);
// aui_service_dialog_get_host_name
// file avahi-ui.h line 134
const char * aui_service_dialog_get_host_name(struct _AuiServiceDialog *d);
// aui_service_dialog_get_port
// file avahi-ui.h line 131
unsigned short int aui_service_dialog_get_port(struct _AuiServiceDialog *d);
// aui_service_dialog_get_property
// file avahi-ui.c line 1441
static void aui_service_dialog_get_property(struct _GObject *object, unsigned int prop_id, struct _GValue *value, struct _GParamSpec *pspec);
// aui_service_dialog_get_resolve_host_name
// file avahi-ui.c line 1384
signed int aui_service_dialog_get_resolve_host_name(struct _AuiServiceDialog *d);
// aui_service_dialog_get_resolve_service
// file avahi-ui.c line 1372
signed int aui_service_dialog_get_resolve_service(struct _AuiServiceDialog *d);
// aui_service_dialog_get_service_name
// file avahi-ui.h line 121
const char * aui_service_dialog_get_service_name(struct _AuiServiceDialog *d);
// aui_service_dialog_get_service_type
// file avahi-ui.h line 115
const char * aui_service_dialog_get_service_type(struct _AuiServiceDialog *d);
// aui_service_dialog_get_txt_data
// file avahi-ui.h line 137
const struct AvahiStringList * aui_service_dialog_get_txt_data(struct _AuiServiceDialog *d);
// aui_service_dialog_get_type
// file avahi-ui.h line 59
unsigned long int aui_service_dialog_get_type(void);
// aui_service_dialog_init
// file avahi-ui.c line 1080
static void aui_service_dialog_init(struct _AuiServiceDialog *d);
// aui_service_dialog_new
// file avahi-ui.h line 72
struct _GtkWidget * aui_service_dialog_new(const char *title, struct _GtkWindow *parent, const char *first_button_text, ...);
// aui_service_dialog_new_valist
// file avahi-ui.c line 248
struct _GtkWidget * aui_service_dialog_new_valist(const char *title, struct _GtkWindow *parent, const char *first_button_text, __builtin_va_list varargs);
// aui_service_dialog_set_address_family
// file avahi-ui.c line 1390
void aui_service_dialog_set_address_family(struct _AuiServiceDialog *d, signed int proto);
// aui_service_dialog_set_browse_service_types
// file avahi-ui.h line 90
void aui_service_dialog_set_browse_service_types(struct _AuiServiceDialog *d, const char *type, ...);
// aui_service_dialog_set_browse_service_typesv
// file avahi-ui.c line 1245
void aui_service_dialog_set_browse_service_typesv(struct _AuiServiceDialog *d, const char * const *types);
// aui_service_dialog_set_domain
// file avahi-ui.h line 103
void aui_service_dialog_set_domain(struct _AuiServiceDialog *d, const char *domain);
// aui_service_dialog_set_property
// file avahi-ui.c line 1403
static void aui_service_dialog_set_property(struct _GObject *object, unsigned int prop_id, const struct _GValue *value, struct _GParamSpec *pspec);
// aui_service_dialog_set_resolve_host_name
// file avahi-ui.h line 160
void aui_service_dialog_set_resolve_host_name(struct _AuiServiceDialog *d, signed int resolve);
// aui_service_dialog_set_resolve_service
// file avahi-ui.h line 149
void aui_service_dialog_set_resolve_service(struct _AuiServiceDialog *d, signed int resolve);
// aui_service_dialog_set_service_name
// file avahi-ui.c line 1312
void aui_service_dialog_set_service_name(struct _AuiServiceDialog *d, const char *name);
// aui_service_dialog_set_service_type
// file avahi-ui.c line 1325
void aui_service_dialog_set_service_type(struct _AuiServiceDialog *d, const char *stype);
// aui_service_dialog_set_service_type_name
// file avahi-ui.h line 96
void aui_service_dialog_set_service_type_name(struct _AuiServiceDialog *d, const char *type, const char *name);
// avahi_address_cmp
// file address.c line 46
signed int avahi_address_cmp(const struct AvahiAddress *a, const struct AvahiAddress *b);
// avahi_address_parse
// file ../avahi-common/address.h line 95
struct AvahiAddress * avahi_address_parse(const char *s, signed int proto, struct AvahiAddress *ret_addr);
// avahi_address_resolver_event
// file internal.h line 166
enum anonymous_42 avahi_address_resolver_event(struct AvahiClient *client, enum anonymous_12 event, struct DBusMessage *message);
// avahi_address_resolver_free
// file lookup.h line 269
signed int avahi_address_resolver_free(struct AvahiAddressResolver *r);
// avahi_address_resolver_get_client
// file resolver.c line 755
struct AvahiClient * avahi_address_resolver_get_client(struct AvahiAddressResolver *r);
// avahi_address_resolver_new
// file resolver.c line 642
struct AvahiAddressResolver * avahi_address_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const struct AvahiAddress *a, enum anonymous_44 flags, void (*callback)(struct AvahiAddressResolver *, signed int, signed int, enum anonymous_12, const struct AvahiAddress *, const char *, enum anonymous_13, void *), void *userdata);
// avahi_address_resolver_new::callback_link1_object
//
void callback_link1_object(struct AvahiAddressResolver *, signed int, signed int, enum anonymous_12, const struct AvahiAddress *, const char *, enum anonymous_13, void *);
// avahi_address_resolver_new::callback_object
//
void callback_object(struct AvahiAddressResolver *, signed int, signed int, enum anonymous_12, const struct AvahiAddress *, const char *, enum anonymous_13, void *);
// avahi_address_snprint
// file ../avahi-common/address.h line 90
char * avahi_address_snprint(char *s, unsigned long int length, const struct AvahiAddress *a);
// avahi_af_to_proto
// file address.c line 137
signed int avahi_af_to_proto(signed int af);
// avahi_age
// file timeval.c line 76
signed long int avahi_age(struct timeval *a);
// avahi_alternative_host_name
// file alternative.c line 51
char * avahi_alternative_host_name(const char *s);
// avahi_alternative_service_name
// file alternative.c line 117
char * avahi_alternative_service_name(const char *s);
// avahi_client_errno
// file client.c line 790
signed int avahi_client_errno(struct AvahiClient *client);
// avahi_client_free
// file client.c line 625
void avahi_client_free(struct AvahiClient *client);
// avahi_client_get_domain_name
// file client.c line 742
const char * avahi_client_get_domain_name(struct AvahiClient *client);
// avahi_client_get_host_name
// file client.c line 756
const char * avahi_client_get_host_name(struct AvahiClient *client);
// avahi_client_get_host_name_fqdn
// file client.c line 770
const char * avahi_client_get_host_name_fqdn(struct AvahiClient *client);
// avahi_client_get_local_service_cookie
// file client.c line 846
unsigned int avahi_client_get_local_service_cookie(struct AvahiClient *client);
// avahi_client_get_state
// file client.c line 784
enum anonymous_11 avahi_client_get_state(struct AvahiClient *client);
// avahi_client_get_string_reply_and_block
// file client.c line 672
static char * avahi_client_get_string_reply_and_block(struct AvahiClient *client, const char *method, const char *param);
// avahi_client_get_string_reply_and_block_link1
// file client.c line 672
static char * avahi_client_get_string_reply_and_block_link1(struct AvahiClient *client_link1, const char *method_link1, const char *param_link1);
// avahi_client_get_version_string
// file client.c line 728
const char * avahi_client_get_version_string(struct AvahiClient *client);
// avahi_client_is_connected
// file client.c line 896
signed int avahi_client_is_connected(struct AvahiClient *client);
// avahi_client_new
// file client.c line 478
struct AvahiClient * avahi_client_new(const struct AvahiPoll_1 *poll_api, enum anonymous_39 flags, void (*callback)(struct AvahiClient *, enum anonymous_11, void *), void *userdata, signed int *ret_error);
// avahi_client_new::callback_link1_object
//
void callback_link1_object(struct AvahiClient *, enum anonymous_11, void *);
// avahi_client_new::callback_object
//
void callback_object(struct AvahiClient *, enum anonymous_11, void *);
// avahi_client_set_dbus_error
// file client.c line 51
signed int avahi_client_set_dbus_error(struct AvahiClient *client, struct DBusError *error);
// avahi_client_set_errno
// file client.c line 45
signed int avahi_client_set_errno(struct AvahiClient *client, signed int error);
// avahi_client_set_host_name
// file client.c line 905
signed int avahi_client_set_host_name(struct AvahiClient *client, const char *name);
// avahi_client_simple_method_call
// file client.c line 797
signed int avahi_client_simple_method_call(struct AvahiClient *client, const char *path, const char *interface, const char *method);
// avahi_dbus_bus_get
// file client.c line 445
static struct DBusConnection * avahi_dbus_bus_get(struct DBusError *error);
// avahi_dbus_bus_get_link1
// file client.c line 445
static struct DBusConnection * avahi_dbus_bus_get_link1(struct DBusError *error_link1);
// avahi_dbus_connection_glue
// file ../avahi-common/dbus-watch-glue.h line 29
signed int avahi_dbus_connection_glue(struct DBusConnection *c, const struct AvahiPoll_1 *poll_api);
// avahi_domain_browser_event
// file internal.h line 159
enum anonymous_42 avahi_domain_browser_event(struct AvahiClient *client, enum anonymous_14 event, struct DBusMessage *message);
// avahi_domain_browser_free
// file lookup.h line 71
signed int avahi_domain_browser_free(struct AvahiDomainBrowser *b);
// avahi_domain_browser_get_client
// file browser.c line 234
struct AvahiClient * avahi_domain_browser_get_client(struct AvahiDomainBrowser *b);
// avahi_domain_browser_new
// file browser.c line 104
struct AvahiDomainBrowser * avahi_domain_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous_43 btype, enum anonymous_44 flags, void (*callback)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous_14, const char *, enum anonymous_13, void *), void *userdata);
// avahi_domain_browser_new::callback_link1_object
//
void callback_link1_object(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous_14, const char *, enum anonymous_13, void *);
// avahi_domain_browser_new::callback_object
//
void callback_object(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous_14, const char *, enum anonymous_13, void *);
// avahi_domain_equal
// file ../avahi-common/domain.h line 62
signed int avahi_domain_equal(const char *a, const char *b);
// avahi_domain_hash
// file domain.c line 424
unsigned int avahi_domain_hash(const char *s);
// avahi_elapse_time
// file ../avahi-common/timeval.h line 50
struct timeval * avahi_elapse_time(struct timeval *tv, unsigned int msec, unsigned int jitter);
// avahi_entry_group_add_address
// file entrygroup.c line 721
signed int avahi_entry_group_add_address(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, const struct AvahiAddress *a);
// avahi_entry_group_add_record
// file entrygroup.c line 808
signed int avahi_entry_group_add_record(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, unsigned short int clazz, unsigned short int type, unsigned int ttl, const void *rdata, unsigned long int size);
// avahi_entry_group_add_service
// file entrygroup.c line 496
signed int avahi_entry_group_add_service(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, ...);
// avahi_entry_group_add_service_strlst
// file entrygroup.c line 402
signed int avahi_entry_group_add_service_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, struct AvahiStringList *txt);
// avahi_entry_group_add_service_subtype
// file entrygroup.c line 522
signed int avahi_entry_group_add_service_subtype(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, const char *type, const char *domain, const char *subtype);
// avahi_entry_group_commit
// file entrygroup.c line 253
signed int avahi_entry_group_commit(struct AvahiEntryGroup *group);
// avahi_entry_group_free
// file publish.h line 60
signed int avahi_entry_group_free(struct AvahiEntryGroup *group);
// avahi_entry_group_get_client
// file entrygroup.c line 290
struct AvahiClient * avahi_entry_group_get_client(struct AvahiEntryGroup *group);
// avahi_entry_group_get_state
// file entrygroup.c line 281
signed int avahi_entry_group_get_state(struct AvahiEntryGroup *group);
// avahi_entry_group_is_empty
// file entrygroup.c line 296
signed int avahi_entry_group_is_empty(struct AvahiEntryGroup *group);
// avahi_entry_group_new
// file entrygroup.c line 101
struct AvahiEntryGroup * avahi_entry_group_new(struct AvahiClient *client, void (*callback)(struct AvahiEntryGroup *, enum anonymous_40, void *), void *userdata);
// avahi_entry_group_new::callback_link1_object
//
void callback_link1_object(struct AvahiEntryGroup *, enum anonymous_40, void *);
// avahi_entry_group_new::callback_object
//
void callback_object(struct AvahiEntryGroup *, enum anonymous_40, void *);
// avahi_entry_group_reset
// file entrygroup.c line 267
signed int avahi_entry_group_reset(struct AvahiEntryGroup *group);
// avahi_entry_group_set_state
// file internal.h line 157
void avahi_entry_group_set_state(struct AvahiEntryGroup *group, enum anonymous_40 state);
// avahi_entry_group_update_service_txt
// file entrygroup.c line 611
signed int avahi_entry_group_update_service_txt(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, const char *type, const char *domain, ...);
// avahi_entry_group_update_service_txt_strlst
// file entrygroup.c line 633
signed int avahi_entry_group_update_service_txt_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, const char *type, const char *domain, struct AvahiStringList *txt);
// avahi_error_dbus_to_number
// file ../avahi-common/dbus.h line 112
signed int avahi_error_dbus_to_number(const char *s);
// avahi_error_number_to_dbus
// file ../avahi-common/dbus.c line 133
const char * avahi_error_number_to_dbus(signed int error);
// avahi_escape_label
// file domain.c line 116
char * avahi_escape_label(const char *src, unsigned long int src_length, char **ret_name, unsigned long int *ret_size);
// avahi_free
// file ../avahi-common/malloc.h line 42
void avahi_free(void *p);
// avahi_get_type_from_subtype
// file domain.c line 306
const char * avahi_get_type_from_subtype(const char *t);
// avahi_glib_allocator
// file glib-malloc.c line 41
const struct AvahiAllocator * avahi_glib_allocator(void);
// avahi_glib_poll_free
// file glib-watch.c line 386
void avahi_glib_poll_free(struct AvahiGLibPoll *g);
// avahi_glib_poll_get
// file glib-watch.c line 398
const struct AvahiPoll * avahi_glib_poll_get(struct AvahiGLibPoll *g);
// avahi_glib_poll_new
// file glib-watch.c line 347
struct AvahiGLibPoll * avahi_glib_poll_new(struct _GMainContext *context, signed int priority);
// avahi_host_name_resolver_event
// file internal.h line 165
enum anonymous_42 avahi_host_name_resolver_event(struct AvahiClient *client, enum anonymous_12 event, struct DBusMessage *message);
// avahi_host_name_resolver_free
// file lookup.h line 239
signed int avahi_host_name_resolver_free(struct AvahiHostNameResolver *r);
// avahi_host_name_resolver_get_client
// file resolver.c line 558
struct AvahiClient * avahi_host_name_resolver_get_client(struct AvahiHostNameResolver *r);
// avahi_host_name_resolver_new
// file resolver.c line 424
struct AvahiHostNameResolver * avahi_host_name_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, signed int aprotocol, enum anonymous_44 flags, void (*callback)(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous_12, const char *, const struct AvahiAddress *, enum anonymous_13, void *), void *userdata);
// avahi_host_name_resolver_new::callback_link1_object
//
void callback_link1_object(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous_12, const char *, const struct AvahiAddress *, enum anonymous_13, void *);
// avahi_host_name_resolver_new::callback_object
//
void callback_object(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous_12, const char *, const struct AvahiAddress *, enum anonymous_13, void *);
// avahi_init_i18n
// file ../avahi-common/i18n.h line 51
void avahi_init_i18n(void);
// avahi_is_valid_domain_name
// file domain.c line 369
signed int avahi_is_valid_domain_name(const char *t);
// avahi_is_valid_fqdn
// file domain.c line 575
signed int avahi_is_valid_fqdn(const char *t);
// avahi_is_valid_host_name
// file domain.h line 103
signed int avahi_is_valid_host_name(const char *t);
// avahi_is_valid_service_name
// file domain.h line 100
signed int avahi_is_valid_service_name(const char *t);
// avahi_is_valid_service_subtype
// file domain.c line 363
signed int avahi_is_valid_service_subtype(const char *t);
// avahi_is_valid_service_type_generic
// file domain.c line 254
signed int avahi_is_valid_service_type_generic(const char *t);
// avahi_is_valid_service_type_strict
// file domain.c line 274
signed int avahi_is_valid_service_type_strict(const char *t);
// avahi_malloc
// file ../avahi-common/malloc.h line 36
void * avahi_malloc(unsigned long int size);
// avahi_malloc0
// file malloc.c line 113
void * avahi_malloc0(unsigned long int size);
// avahi_memdup
// file malloc.c line 248
void * avahi_memdup(const void *s, unsigned long int l);
// avahi_new_internal
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal(unsigned int n, unsigned long int k);
// avahi_new_internal_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link1(unsigned int n_link1, unsigned long int k_link1);
// avahi_new_internal_link1_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link1(unsigned int n_link1_link1, unsigned long int k_link1_link1);
// avahi_new_internal_link1_link1_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link1_link1(unsigned int n_link1_link1_link1, unsigned long int k_link1_link1_link1);
// avahi_new_internal_link1_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link2(unsigned int n_link1_link2, unsigned long int k_link1_link2);
// avahi_new_internal_link1_link2_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link1_link2_link1(unsigned int n_link1_link2_link1, unsigned long int k_link1_link2_link1);
// avahi_new_internal_link1_link3
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link3(unsigned int n_link1_link3, unsigned long int k_link1_link3);
// avahi_new_internal_link1_link4
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link4(unsigned int n_link1_link4, unsigned long int k_link1_link4);
// avahi_new_internal_link2
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link2(unsigned int n_link2, unsigned long int k_link2);
// avahi_new_internal_link2_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link1(unsigned int n_link2_link1, unsigned long int k_link2_link1);
// avahi_new_internal_link2_link1_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link1_link1(unsigned int n_link2_link1_link1, unsigned long int k_link2_link1_link1);
// avahi_new_internal_link2_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link2(unsigned int n_link2_link2, unsigned long int k_link2_link2);
// avahi_new_internal_link2_link2_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link2_link2_link1(unsigned int n_link2_link2_link1, unsigned long int k_link2_link2_link1);
// avahi_new_internal_link2_link3
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link3(unsigned int n_link2_link3, unsigned long int k_link2_link3);
// avahi_new_internal_link2_link4
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link4(unsigned int n_link2_link4, unsigned long int k_link2_link4);
// avahi_new_internal_link3
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link3(unsigned int n_link3, unsigned long int k_link3);
// avahi_new_internal_link3_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link1(unsigned int n_link3_link1, unsigned long int k_link3_link1);
// avahi_new_internal_link3_link1_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link1_link1(unsigned int n_link3_link1_link1, unsigned long int k_link3_link1_link1);
// avahi_new_internal_link3_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link2(unsigned int n_link3_link2, unsigned long int k_link3_link2);
// avahi_new_internal_link3_link2_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link3_link2_link1(unsigned int n_link3_link2_link1, unsigned long int k_link3_link2_link1);
// avahi_new_internal_link3_link3
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link3(unsigned int n_link3_link3, unsigned long int k_link3_link3);
// avahi_new_internal_link3_link4
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link4(unsigned int n_link3_link4, unsigned long int k_link3_link4);
// avahi_new_internal_link4
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link4(unsigned int n_link4, unsigned long int k_link4);
// avahi_new_internal_link4_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link1(unsigned int n_link4_link1, unsigned long int k_link4_link1);
// avahi_new_internal_link4_link1_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link1_link1(unsigned int n_link4_link1_link1, unsigned long int k_link4_link1_link1);
// avahi_new_internal_link4_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link2(unsigned int n_link4_link2, unsigned long int k_link4_link2);
// avahi_new_internal_link4_link2_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link4_link2_link1(unsigned int n_link4_link2_link1, unsigned long int k_link4_link2_link1);
// avahi_new_internal_link4_link3
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link3(unsigned int n_link4_link3, unsigned long int k_link4_link3);
// avahi_new_internal_link4_link4
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link4(unsigned int n_link4_link4, unsigned long int k_link4_link4);
// avahi_new_internal_link5
// file malloc.h line 48
static inline void * avahi_new_internal_link5(unsigned int n_link5, unsigned long int k_link5);
// avahi_new_internal_link5_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link5_link1(unsigned int n_link5_link1, unsigned long int k_link5_link1);
// avahi_new_internal_link5_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link5_link2(unsigned int n_link5_link2, unsigned long int k_link5_link2);
// avahi_new_internal_link6
// file malloc.h line 48
static inline void * avahi_new_internal_link6(unsigned int n_link6, unsigned long int k_link6);
// avahi_new_internal_link6_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link6_link1(unsigned int n_link6_link1, unsigned long int k_link6_link1);
// avahi_new_internal_link7
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link7(unsigned int n_link7, unsigned long int k_link7);
// avahi_new_internal_link8
// file malloc.h line 48
static inline void * avahi_new_internal_link8(unsigned int n_link8, unsigned long int k_link8);
// avahi_normalize_name
// file ../avahi-common/domain.h line 50
char * avahi_normalize_name(const char *s, char *ret_s, unsigned long int size);
// avahi_normalize_name_strdup
// file domain.c line 219
char * avahi_normalize_name_strdup(const char *s);
// avahi_nss_support
// file ../avahi-client/client.h line 111
signed int avahi_nss_support(void);
// avahi_proto_to_af
// file address.c line 127
signed int avahi_proto_to_af(signed int proto);
// avahi_proto_to_string
// file address.c line 147
const char * avahi_proto_to_string(signed int proto);
// avahi_realloc
// file malloc.c line 146
void * avahi_realloc(void *p, unsigned long int size);
// avahi_record_browser_event
// file internal.h line 162
enum anonymous_42 avahi_record_browser_event(struct AvahiClient *client, enum anonymous_14 event, struct DBusMessage *message);
// avahi_record_browser_free
// file lookup.h line 308
signed int avahi_record_browser_free(struct AvahiRecordBrowser *b);
// avahi_record_browser_get_client
// file browser.c line 903
struct AvahiClient * avahi_record_browser_get_client(struct AvahiRecordBrowser *b);
// avahi_record_browser_new
// file browser.c line 786
struct AvahiRecordBrowser * avahi_record_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, unsigned short int clazz, unsigned short int type, enum anonymous_44 flags, void (*callback)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous_14, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous_13, void *), void *userdata);
// avahi_record_browser_new::callback_link1_object
//
void callback_link1_object(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous_14, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous_13, void *);
// avahi_record_browser_new::callback_object
//
void callback_object(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous_14, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous_13, void *);
// avahi_reverse_lookup_name
// file address.c line 67
char * avahi_reverse_lookup_name(const struct AvahiAddress *a, char *ret_s, unsigned long int length);
// avahi_rlist_prepend
// file rlist.c line 29
struct AvahiRList * avahi_rlist_prepend(struct AvahiRList *r, void *data);
// avahi_rlist_remove
// file rlist.c line 41
struct AvahiRList * avahi_rlist_remove(struct AvahiRList *r, void *data);
// avahi_rlist_remove_by_link
// file rlist.c line 55
struct AvahiRList * avahi_rlist_remove_by_link(struct AvahiRList *r, struct AvahiRList *n);
// avahi_service_browser_event
// file internal.h line 161
enum anonymous_42 avahi_service_browser_event(struct AvahiClient *client, enum anonymous_14 event, struct DBusMessage *message);
// avahi_service_browser_free
// file lookup.h line 117
signed int avahi_service_browser_free(struct AvahiServiceBrowser *b);
// avahi_service_browser_get_client
// file browser.c line 686
struct AvahiClient * avahi_service_browser_get_client(struct AvahiServiceBrowser *b);
// avahi_service_browser_new
// file browser.c line 564
struct AvahiServiceBrowser * avahi_service_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *type, const char *domain, enum anonymous_44 flags, void (*callback)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous_14, const char *, const char *, const char *, enum anonymous_13, void *), void *userdata);
// avahi_service_browser_new::callback_link1_object
//
void callback_link1_object(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous_14, const char *, const char *, const char *, enum anonymous_13, void *);
// avahi_service_browser_new::callback_object
//
void callback_object(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous_14, const char *, const char *, const char *, enum anonymous_13, void *);
// avahi_service_name_join
// file domain.c line 440
signed int avahi_service_name_join(char *p, unsigned long int size, const char *name, const char *type, const char *domain);
// avahi_service_name_split
// file domain.c line 496
signed int avahi_service_name_split(const char *p, char *name, unsigned long int name_size, char *type, unsigned long int type_size, char *domain, unsigned long int domain_size);
// avahi_service_resolver_event
// file internal.h line 164
enum anonymous_42 avahi_service_resolver_event(struct AvahiClient *client, enum anonymous_12 event, struct DBusMessage *message);
// avahi_service_resolver_free
// file lookup.h line 205
signed int avahi_service_resolver_free(struct AvahiServiceResolver *r);
// avahi_service_resolver_get_client
// file resolver.c line 318
struct AvahiClient * avahi_service_resolver_get_client(struct AvahiServiceResolver *r);
// avahi_service_resolver_new
// file resolver.c line 179
struct AvahiServiceResolver * avahi_service_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, const char *type, const char *domain, signed int aprotocol, enum anonymous_44 flags, void (*callback)(struct AvahiServiceResolver *, signed int, signed int, enum anonymous_12, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous_13, void *), void *userdata);
// avahi_service_resolver_new::callback_link1_object
//
void callback_link1_object(struct AvahiServiceResolver *, signed int, signed int, enum anonymous_12, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous_13, void *);
// avahi_service_resolver_new::callback_object
//
void callback_object(struct AvahiServiceResolver *, signed int, signed int, enum anonymous_12, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous_13, void *);
// avahi_service_type_browser_event
// file internal.h line 160
enum anonymous_42 avahi_service_type_browser_event(struct AvahiClient *client, enum anonymous_14 event, struct DBusMessage *message);
// avahi_service_type_browser_free
// file lookup.h line 150
signed int avahi_service_type_browser_free(struct AvahiServiceTypeBrowser *b);
// avahi_service_type_browser_get_client
// file browser.c line 465
struct AvahiClient * avahi_service_type_browser_get_client(struct AvahiServiceTypeBrowser *b);
// avahi_service_type_browser_new
// file browser.c line 350
struct AvahiServiceTypeBrowser * avahi_service_type_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous_44 flags, void (*callback)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous_14, const char *, const char *, enum anonymous_13, void *), void *userdata);
// avahi_service_type_browser_new::callback_link1_object
//
void callback_link1_object(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous_14, const char *, const char *, enum anonymous_13, void *);
// avahi_service_type_browser_new::callback_object
//
void callback_object(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous_14, const char *, const char *, enum anonymous_13, void *);
// avahi_set_allocator
// file malloc.c line 196
void avahi_set_allocator(const struct AvahiAllocator *a);
// avahi_simple_poll_dispatch
// file simple-watch.c line 547
signed int avahi_simple_poll_dispatch(struct AvahiSimplePoll_0 *s);
// avahi_simple_poll_free
// file simple-watch.c line 367
void avahi_simple_poll_free(struct AvahiSimplePoll_0 *s);
// avahi_simple_poll_get
// file simple-watch.c line 620
const struct AvahiPoll_1 * avahi_simple_poll_get(struct AvahiSimplePoll_0 *s);
// avahi_simple_poll_iterate
// file simple-watch.c line 596
signed int avahi_simple_poll_iterate(struct AvahiSimplePoll_0 *s, signed int timeout);
// avahi_simple_poll_loop
// file simple-watch.c line 640
signed int avahi_simple_poll_loop(struct AvahiSimplePoll_0 *s);
// avahi_simple_poll_new
// file simple-watch.c line 318
struct AvahiSimplePoll_0 * avahi_simple_poll_new(void);
// avahi_simple_poll_prepare
// file simple-watch.c line 450
signed int avahi_simple_poll_prepare(struct AvahiSimplePoll_0 *s, signed int timeout);
// avahi_simple_poll_quit
// file simple-watch.c line 611
void avahi_simple_poll_quit(struct AvahiSimplePoll_0 *s);
// avahi_simple_poll_run
// file simple-watch.c line 518
signed int avahi_simple_poll_run(struct AvahiSimplePoll_0 *s);
// avahi_simple_poll_set_func
// file simple-watch.c line 630
void avahi_simple_poll_set_func(struct AvahiSimplePoll_0 *s, signed int (*func)(struct pollfd *, unsigned int, signed int, void *), void *userdata);
// avahi_simple_poll_set_func::func_link1_link1_object
//
signed int func_link1_link1_object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_set_func::func_link1_object
//
signed int func_link1_object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_set_func::func_link2_object
//
signed int func_link2_object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_set_func::func_link3_object
//
signed int func_link3_object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_set_func::func_object
//
signed int func_object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_wakeup
// file simple-watch.c line 97
void avahi_simple_poll_wakeup(struct AvahiSimplePoll_0 *s);
// avahi_strdup
// file ../avahi-common/malloc.h line 66
char * avahi_strdup(const char *s);
// avahi_strdup_printf
// file malloc.c line 235
char * avahi_strdup_printf(const char *fmt, ...);
// avahi_strdup_vprintf
// file malloc.c line 200
char * avahi_strdup_vprintf(const char *fmt, void **ap);
// avahi_strerror
// file error.c line 27
const char * avahi_strerror(signed int error);
// avahi_string_list_add
// file ../avahi-common/strlst.h line 73
struct AvahiStringList * avahi_string_list_add(struct AvahiStringList *l, const char *text);
// avahi_string_list_add_anonymous
// file strlst.c line 34
struct AvahiStringList * avahi_string_list_add_anonymous(struct AvahiStringList *l, unsigned long int size);
// avahi_string_list_add_arbitrary
// file ../avahi-common/strlst.h line 85
struct AvahiStringList * avahi_string_list_add_arbitrary(struct AvahiStringList *l, const unsigned char *text, unsigned long int size);
// avahi_string_list_add_many
// file strlst.c line 255
struct AvahiStringList * avahi_string_list_add_many(struct AvahiStringList *r, ...);
// avahi_string_list_add_many_va
// file strlst.c line 265
struct AvahiStringList * avahi_string_list_add_many_va(struct AvahiStringList *r, __builtin_va_list va);
// avahi_string_list_add_pair
// file strlst.c line 395
struct AvahiStringList * avahi_string_list_add_pair(struct AvahiStringList *l, const char *key, const char *value);
// avahi_string_list_add_pair_arbitrary
// file strlst.c line 404
struct AvahiStringList * avahi_string_list_add_pair_arbitrary(struct AvahiStringList *l, const char *key, const unsigned char *value, unsigned long int size);
// avahi_string_list_add_printf
// file strlst.c line 366
struct AvahiStringList * avahi_string_list_add_printf(struct AvahiStringList *l, const char *format, ...);
// avahi_string_list_add_vprintf
// file strlst.c line 326
struct AvahiStringList * avahi_string_list_add_vprintf(struct AvahiStringList *l, const char *format, void **va);
// avahi_string_list_copy
// file strlst.c line 293
struct AvahiStringList * avahi_string_list_copy(const struct AvahiStringList *l);
// avahi_string_list_equal
// file strlst.c line 235
signed int avahi_string_list_equal(const struct AvahiStringList *a, const struct AvahiStringList *b);
// avahi_string_list_find
// file strlst.c line 378
struct AvahiStringList * avahi_string_list_find(struct AvahiStringList *l, const char *key);
// avahi_string_list_free
// file ../avahi-common/strlst.h line 64
void avahi_string_list_free(struct AvahiStringList *l);
// avahi_string_list_get_next
// file strlst.c line 469
struct AvahiStringList * avahi_string_list_get_next(struct AvahiStringList *l);
// avahi_string_list_get_pair
// file ../avahi-common/strlst.h line 160
signed int avahi_string_list_get_pair(struct AvahiStringList *l, char **key, char **value, unsigned long int *size);
// avahi_string_list_get_service_cookie
// file strlst.c line 484
unsigned int avahi_string_list_get_service_cookie(struct AvahiStringList *l);
// avahi_string_list_get_size
// file strlst.c line 479
unsigned long int avahi_string_list_get_size(struct AvahiStringList *l);
// avahi_string_list_get_text
// file strlst.c line 474
unsigned char * avahi_string_list_get_text(struct AvahiStringList *l);
// avahi_string_list_length
// file strlst.c line 317
unsigned int avahi_string_list_length(const struct AvahiStringList *l);
// avahi_string_list_new
// file strlst.c line 274
struct AvahiStringList * avahi_string_list_new(const char *txt, ...);
// avahi_string_list_new_from_array
// file strlst.c line 305
struct AvahiStringList * avahi_string_list_new_from_array(const char **array, signed int length);
// avahi_string_list_new_va
// file ../avahi-common/strlst.h line 55
struct AvahiStringList * avahi_string_list_new_va(void **va);
// avahi_string_list_parse
// file strlst.c line 69
signed int avahi_string_list_parse(const void *data, unsigned long int size, struct AvahiStringList **ret);
// avahi_string_list_reverse
// file ../avahi-common/strlst.h line 130
struct AvahiStringList * avahi_string_list_reverse(struct AvahiStringList *l);
// avahi_string_list_serialize
// file strlst.c line 168
unsigned long int avahi_string_list_serialize(struct AvahiStringList *l, void *data, unsigned long int size);
// avahi_string_list_to_string
// file strlst.c line 131
char * avahi_string_list_to_string(struct AvahiStringList *l);
// avahi_strndup
// file malloc.c line 175
char * avahi_strndup(const char *s, unsigned long int max);
// avahi_threaded_poll_free
// file thread-watch.c line 107
void avahi_threaded_poll_free(struct AvahiThreadedPoll_0 *p);
// avahi_threaded_poll_get
// file thread-watch.c line 123
const struct AvahiPoll_1 * avahi_threaded_poll_get(struct AvahiThreadedPoll_0 *p);
// avahi_threaded_poll_lock
// file thread-watch.c line 170
void avahi_threaded_poll_lock(struct AvahiThreadedPoll_0 *p);
// avahi_threaded_poll_new
// file thread-watch.c line 77
struct AvahiThreadedPoll_0 * avahi_threaded_poll_new(void);
// avahi_threaded_poll_quit
// file thread-watch.c line 161
void avahi_threaded_poll_quit(struct AvahiThreadedPoll_0 *p);
// avahi_threaded_poll_start
// file thread-watch.c line 129
signed int avahi_threaded_poll_start(struct AvahiThreadedPoll_0 *p);
// avahi_threaded_poll_stop
// file thread-watch.c line 142
signed int avahi_threaded_poll_stop(struct AvahiThreadedPoll_0 *p);
// avahi_threaded_poll_unlock
// file thread-watch.c line 179
void avahi_threaded_poll_unlock(struct AvahiThreadedPoll_0 *p);
// avahi_timeval_add
// file timeval.c line 59
struct timeval * avahi_timeval_add(struct timeval *a, signed long int usec);
// avahi_timeval_compare
// file timeval.c line 30
signed int avahi_timeval_compare(struct timeval *a, struct timeval *b);
// avahi_timeval_diff
// file timeval.c line 49
signed long int avahi_timeval_diff(struct timeval *a, struct timeval *b);
// avahi_unescape_label
// file domain.c line 41
char * avahi_unescape_label(const char **name, char *dest, unsigned long int size);
// avahi_utf8_valid
// file utf8.h line 29
const char * avahi_utf8_valid(const char *str);
// avahi_xdg_config_open
// file xdg-config.h line 25
struct _IO_FILE * avahi_xdg_config_open(const char *filename);
// bind_textdomain_codeset
// file /usr/include/libintl.h line 91
extern char * bind_textdomain_codeset(const char *, const char *);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// browse_callback
// file avahi-ui.c line 400
static void browse_callback(struct AvahiServiceBrowser *b, signed int interface, signed int protocol, enum anonymous_14 event, const char *name, const char *type, const char *domain, enum anonymous_13 flags, void *userdata);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// calloc_glue
// file glib-malloc.c line 37
static void * calloc_glue(unsigned long int nmemb, unsigned long int size);
// check_func
// file glib-watch.c line 291
static signed int check_func(struct _GSource *source);
// check_version
// file client.c line 351
static signed int check_version(struct AvahiClient *client, signed int *ret_error);
// check_version_link1
// file client.c line 351
static signed int check_version_link1(struct AvahiClient *client_link1, signed int *ret_error_link1);
// cleanup_timeouts
// file simple-watch.c line 304
static void cleanup_timeouts(struct AvahiSimplePoll_0 *s, signed int all);
// cleanup_timeouts_link1
// file simple-watch.c line 304
static void cleanup_timeouts_link1(struct AvahiSimplePoll_0 *s_link1, signed int all_link1);
// cleanup_timeouts_link1_link1
// file simple-watch.c line 304
static void cleanup_timeouts_link1_link1(struct AvahiSimplePoll *s_link2, signed int all_link1_link1);
// cleanup_timeouts_link1_link2
// file simple-watch.c line 304
static void cleanup_timeouts_link1_link2(struct AvahiSimplePoll_0 *s_link1_link1, signed int all_link1_link2);
// cleanup_timeouts_link2
// file glib-watch.c line 216
static void cleanup_timeouts_link2(struct AvahiGLibPoll *g, signed int all_link2);
// cleanup_timeouts_link3
// file simple-watch.c line 304
static void cleanup_timeouts_link3(struct AvahiSimplePoll_0 *s_link3, signed int all_link3);
// cleanup_watches
// file simple-watch.c line 230
static void cleanup_watches(struct AvahiSimplePoll_0 *s, signed int all);
// cleanup_watches_link1
// file simple-watch.c line 230
static void cleanup_watches_link1(struct AvahiSimplePoll_0 *s_link1, signed int all_link1);
// cleanup_watches_link1_link1
// file simple-watch.c line 230
static void cleanup_watches_link1_link1(struct AvahiSimplePoll *s_link2, signed int all_link1_link1);
// cleanup_watches_link1_link2
// file simple-watch.c line 230
static void cleanup_watches_link1_link2(struct AvahiSimplePoll_0 *s_link1_link1, signed int all_link1_link2);
// cleanup_watches_link2
// file glib-watch.c line 79
static void cleanup_watches_link2(struct AvahiGLibPoll *g, signed int all_link2);
// cleanup_watches_link3
// file simple-watch.c line 230
static void cleanup_watches_link3(struct AvahiSimplePoll_0 *s_link3, signed int all_link3);
// clear_wakeup
// file simple-watch.c line 105
static void clear_wakeup(struct AvahiSimplePoll_0 *s);
// clear_wakeup_link1
// file simple-watch.c line 105
static void clear_wakeup_link1(struct AvahiSimplePoll_0 *s_link1);
// clear_wakeup_link1_link1
// file simple-watch.c line 105
static void clear_wakeup_link1_link1(struct AvahiSimplePoll_0 *s_link1_link1);
// clear_wakeup_link2
// file simple-watch.c line 105
static void clear_wakeup_link2(struct AvahiSimplePoll *s_link2);
// clear_wakeup_link3
// file simple-watch.c line 105
static void clear_wakeup_link3(struct AvahiSimplePoll_0 *s_link3);
// client_callback
// file avahi-ui.c line 318
static void client_callback(struct AvahiClient *c, enum anonymous_11 state, void *userdata);
// client_set_state
// file client.c line 58
static void client_set_state(struct AvahiClient *client, enum anonymous_11 state);
// client_set_state_link1
// file client.c line 58
static void client_set_state_link1(struct AvahiClient *client_link1, enum anonymous_11 state_link1);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connection_data_ref
// file ../avahi-common/dbus-watch-glue.c line 68
static struct anonymous_28 * connection_data_ref(struct anonymous_28 *d);
// connection_data_ref_link1
// file ../avahi-common/dbus-watch-glue.c line 68
static struct anonymous_28 * connection_data_ref_link1(struct anonymous_28 *d_link1);
// connection_data_unref
// file ../avahi-common/dbus-watch-glue.c line 76
static void connection_data_unref(struct anonymous_28 *d);
// connection_data_unref_link1
// file ../avahi-common/dbus-watch-glue.c line 76
static void connection_data_unref_link1(struct anonymous_28 *d_link1);
// dbus_bus_add_match
// file /usr/include/dbus-1.0/dbus/dbus-bus.h line 83
void dbus_bus_add_match(struct DBusConnection *, const char *, struct DBusError *);
// dbus_bus_get_private
// file /usr/include/dbus-1.0/dbus/dbus-bus.h line 43
struct DBusConnection * dbus_bus_get_private(enum anonymous_45, struct DBusError *);
// dbus_connection_add_filter
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 295
unsigned int dbus_connection_add_filter(struct DBusConnection *, enum anonymous_42 (*)(struct DBusConnection *, struct DBusMessage *, void *), void *, void (*)(void *));
// dbus_connection_close
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 183
void dbus_connection_close(struct DBusConnection *);
// dbus_connection_dispatch
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 220
enum anonymous_27 dbus_connection_dispatch(struct DBusConnection *);
// dbus_connection_get_dispatch_status
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 218
enum anonymous_27 dbus_connection_get_dispatch_status(struct DBusConnection *);
// dbus_connection_get_is_connected
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 185
unsigned int dbus_connection_get_is_connected(struct DBusConnection *);
// dbus_connection_ref
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 179
struct DBusConnection * dbus_connection_ref(struct DBusConnection *);
// dbus_connection_send_with_reply_and_block
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 233
struct DBusMessage * dbus_connection_send_with_reply_and_block(struct DBusConnection *, struct DBusMessage *, signed int, struct DBusError *);
// dbus_connection_set_dispatch_status_function
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 257
void dbus_connection_set_dispatch_status_function(struct DBusConnection *, void (*)(struct DBusConnection *, enum anonymous_27, void *), void *, void (*)(void *));
// dbus_connection_set_exit_on_disconnect
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 197
void dbus_connection_set_exit_on_disconnect(struct DBusConnection *, unsigned int);
// dbus_connection_set_timeout_functions
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 245
unsigned int dbus_connection_set_timeout_functions(struct DBusConnection *, unsigned int (*)(struct DBusTimeout *, void *), void (*)(struct DBusTimeout *, void *), void (*)(struct DBusTimeout *, void *), void *, void (*)(void *));
// dbus_connection_set_watch_functions
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 238
unsigned int dbus_connection_set_watch_functions(struct DBusConnection *, unsigned int (*)(struct DBusWatch *, void *), void (*)(struct DBusWatch *, void *), void (*)(struct DBusWatch *, void *), void *, void (*)(void *));
// dbus_connection_unref
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 181
void dbus_connection_unref(struct DBusConnection *);
// dbus_error_free
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 67
void dbus_error_free(struct DBusError *);
// dbus_error_init
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 65
void dbus_error_init(struct DBusError *);
// dbus_error_is_set
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 84
unsigned int dbus_error_is_set(const struct DBusError *);
// dbus_message_append_args
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 189
unsigned int dbus_message_append_args(struct DBusMessage *, signed int, ...);
// dbus_message_get_args
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 197
unsigned int dbus_message_get_args(struct DBusMessage *, struct DBusError *, signed int, ...);
// dbus_message_get_interface
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 113
const char * dbus_message_get_interface(struct DBusMessage *);
// dbus_message_get_member
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 121
const char * dbus_message_get_member(struct DBusMessage *);
// dbus_message_get_path
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 105
const char * dbus_message_get_path(struct DBusMessage *);
// dbus_message_is_signal
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 152
unsigned int dbus_message_is_signal(struct DBusMessage *, const char *, const char *);
// dbus_message_iter_append_fixed_array
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 253
unsigned int dbus_message_iter_append_fixed_array(struct DBusMessageIter *, signed int, const void *, signed int);
// dbus_message_iter_close_container
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 263
unsigned int dbus_message_iter_close_container(struct DBusMessageIter *, struct DBusMessageIter *);
// dbus_message_iter_get_arg_type
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 220
signed int dbus_message_iter_get_arg_type(struct DBusMessageIter *);
// dbus_message_iter_get_basic
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 227
void dbus_message_iter_get_basic(struct DBusMessageIter *, void *);
// dbus_message_iter_get_element_type
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 222
signed int dbus_message_iter_get_element_type(struct DBusMessageIter *);
// dbus_message_iter_get_fixed_array
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 240
void dbus_message_iter_get_fixed_array(struct DBusMessageIter *, void *, signed int *);
// dbus_message_iter_init
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 211
unsigned int dbus_message_iter_init(struct DBusMessage *, struct DBusMessageIter *);
// dbus_message_iter_init_append
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 246
void dbus_message_iter_init_append(struct DBusMessage *, struct DBusMessageIter *);
// dbus_message_iter_next
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 216
unsigned int dbus_message_iter_next(struct DBusMessageIter *);
// dbus_message_iter_open_container
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 258
unsigned int dbus_message_iter_open_container(struct DBusMessageIter *, signed int, const char *, struct DBusMessageIter *);
// dbus_message_iter_recurse
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 224
void dbus_message_iter_recurse(struct DBusMessageIter *, struct DBusMessageIter *);
// dbus_message_new_method_call
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 72
struct DBusMessage * dbus_message_new_method_call(const char *, const char *, const char *, const char *);
// dbus_message_unref
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 98
void dbus_message_unref(struct DBusMessage *);
// dbus_timeout_get_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 482
void * dbus_timeout_get_data(struct DBusTimeout *);
// dbus_timeout_get_enabled
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 490
unsigned int dbus_timeout_get_enabled(struct DBusTimeout *);
// dbus_timeout_get_interval
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 480
signed int dbus_timeout_get_interval(struct DBusTimeout *);
// dbus_timeout_handle
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 488
unsigned int dbus_timeout_handle(struct DBusTimeout *);
// dbus_timeout_set_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 484
void dbus_timeout_set_data(struct DBusTimeout *, void *, void (*)(void *));
// dbus_watch_get_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 461
void * dbus_watch_get_data(struct DBusWatch *);
// dbus_watch_get_enabled
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 470
unsigned int dbus_watch_get_enabled(struct DBusWatch *);
// dbus_watch_get_flags
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 459
unsigned int dbus_watch_get_flags(struct DBusWatch *);
// dbus_watch_get_unix_fd
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 455
signed int dbus_watch_get_unix_fd(struct DBusWatch *);
// dbus_watch_handle
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 467
unsigned int dbus_watch_handle(struct DBusWatch *, unsigned int);
// dbus_watch_set_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 463
void dbus_watch_set_data(struct DBusWatch *, void *, void (*)(void *));
// defer_timeout_callback
// file browser.c line 83
static void defer_timeout_callback(struct AvahiTimeout_1 *t, void *userdata);
// defer_timeout_callback_link1
// file browser.c line 83
static void defer_timeout_callback_link1(struct AvahiTimeout_1 *t_link1, void *userdata_link1);
// destroy_timeout
// file simple-watch.c line 296
static void destroy_timeout(struct AvahiTimeout_1 *t);
// destroy_timeout_link1
// file simple-watch.c line 296
static void destroy_timeout_link1(struct AvahiTimeout_1 *t_link1);
// destroy_timeout_link1_link1
// file simple-watch.c line 296
static void destroy_timeout_link1_link1(struct AvahiTimeout_0 *t_link1_link1);
// destroy_timeout_link1_link2
// file simple-watch.c line 296
static void destroy_timeout_link1_link2(struct AvahiTimeout_1 *t_link1_link2);
// destroy_timeout_link2
// file glib-watch.c line 209
static void destroy_timeout_link2(struct AvahiTimeout *t_link2);
// destroy_timeout_link3
// file simple-watch.c line 296
static void destroy_timeout_link3(struct AvahiTimeout_1 *t_link3);
// destroy_watch
// file simple-watch.c line 218
static void destroy_watch(struct AvahiWatch_1 *w);
// destroy_watch_link1
// file simple-watch.c line 218
static void destroy_watch_link1(struct AvahiWatch_1 *w_link1);
// destroy_watch_link1_link1
// file simple-watch.c line 218
static void destroy_watch_link1_link1(struct AvahiWatch *w_link1_link1);
// destroy_watch_link1_link2
// file simple-watch.c line 218
static void destroy_watch_link1_link2(struct AvahiWatch_1 *w_link1_link2);
// destroy_watch_link2
// file glib-watch.c line 68
static void destroy_watch_link2(struct AvahiWatch_0 *w_link2);
// destroy_watch_link3
// file simple-watch.c line 218
static void destroy_watch_link3(struct AvahiWatch_1 *w_link3);
// dgettext
// file /usr/include/libintl.h line 44
extern char * dgettext(const char *, const char *);
// dispatch_func
// file glib-watch.c line 316
static signed int dispatch_func(struct _GSource *source, signed int (*callback)(void *), void *userdata);
// dispatch_func::callback_object
//
signed int callback_object(void *);
// dispatch_status
// file ../avahi-common/dbus-watch-glue.c line 310
static void dispatch_status(struct DBusConnection *connection, enum anonymous_27 new_status, void *userdata);
// dispatch_status_link1
// file ../avahi-common/dbus-watch-glue.c line 310
static void dispatch_status_link1(struct DBusConnection *connection_link1, enum anonymous_27 new_status_link1, void *userdata_link1);
// dispatch_timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 97
static void dispatch_timeout_callback(struct AvahiTimeout_1 *t, void *userdata);
// dispatch_timeout_callback_link1
// file ../avahi-common/dbus-watch-glue.c line 97
static void dispatch_timeout_callback_link1(struct AvahiTimeout_1 *t_link1, void *userdata_link1);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// domain_browse_callback
// file avahi-ui.c line 559
static void domain_browse_callback(struct AvahiDomainBrowser *b, signed int interface, signed int protocol, enum anonymous_14 event, const char *name, enum anonymous_13 flags, void *userdata);
// domain_browser_ref
// file browser.c line 77
static void domain_browser_ref(struct AvahiDomainBrowser *db);
// domain_browser_ref_link1
// file browser.c line 77
static void domain_browser_ref_link1(struct AvahiDomainBrowser *db_link1);
// domain_button_clicked
// file avahi-ui.c line 959
static void domain_button_clicked(struct _GtkButton *button, void *user_data);
// domain_entry_changed_callback
// file avahi-ui.c line 953
static void domain_entry_changed_callback(struct _GtkEditable *editable, void *user_data);
// domain_make_default_selection
// file avahi-ui.c line 540
static void domain_make_default_selection(struct _AuiServiceDialog *d, const char *name, struct _GtkTreeIter *iter);
// domain_pulse_callback
// file avahi-ui.c line 311
static signed int domain_pulse_callback(void *data);
// domain_row_activated_callback
// file avahi-ui.c line 933
static void domain_row_activated_callback(struct _GtkTreeView *tree_view, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data);
// domain_selection_changed_callback
// file avahi-ui.c line 940
static void domain_selection_changed_callback(struct _GtkTreeSelection *selection, void *user_data);
// drop_incomplete_utf8
// file alternative.c line 34
static void drop_incomplete_utf8(char *c);
// drop_incomplete_utf8_link1
// file alternative.c line 34
static void drop_incomplete_utf8_link1(char *c_link1);
// drop_incomplete_utf8_link1_link1
// file alternative.c line 34
static void drop_incomplete_utf8_link1_link1(char *c_link1_link1);
// drop_incomplete_utf8_link2
// file alternative.c line 34
static void drop_incomplete_utf8_link2(char *c_link2);
// drop_incomplete_utf8_link3
// file alternative.c line 34
static void drop_incomplete_utf8_link3(char *c_link3);
// entry_group_simple_method_call
// file entrygroup.c line 188
static signed int entry_group_simple_method_call(struct AvahiEntryGroup *group, const char *method);
// entry_group_simple_method_call_link1
// file entrygroup.c line 188
static signed int entry_group_simple_method_call_link1(struct AvahiEntryGroup *group_link1, const char *method_link1);
// execlp
// file /usr/include/unistd.h line 584
extern signed int execlp(const char *, const char *, ...);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// filter_func
// file client.c line 103
static enum anonymous_42 filter_func(struct DBusConnection *bus, struct DBusMessage *message, void *userdata);
// filter_func_link1
// file client.c line 103
static enum anonymous_42 filter_func_link1(struct DBusConnection *bus_link1, struct DBusMessage *message_link1, void *userdata_link1);
// find_next_timeout
// file simple-watch.c line 425
static struct AvahiTimeout_1 * find_next_timeout(struct AvahiSimplePoll_0 *s);
// find_next_timeout_link1
// file simple-watch.c line 425
static struct AvahiTimeout_1 * find_next_timeout_link1(struct AvahiSimplePoll_0 *s_link1);
// find_next_timeout_link1_link1
// file simple-watch.c line 425
static struct AvahiTimeout_0 * find_next_timeout_link1_link1(struct AvahiSimplePoll *s_link2);
// find_next_timeout_link1_link2
// file simple-watch.c line 425
static struct AvahiTimeout_1 * find_next_timeout_link1_link2(struct AvahiSimplePoll_0 *s_link1_link1);
// find_next_timeout_link2
// file glib-watch.c line 230
static struct AvahiTimeout * find_next_timeout_link2(struct AvahiGLibPoll *g);
// find_next_timeout_link3
// file simple-watch.c line 425
static struct AvahiTimeout_1 * find_next_timeout_link3(struct AvahiSimplePoll_0 *s_link3);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// g_assertion_message_expr
// file /usr/include/glib-2.0/glib/gtestutils.h line 302
extern void g_assertion_message_expr(const char *, const char *, signed int, const char *, const char *);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_hash_table_insert
// file /usr/include/glib-2.0/glib/ghash.h line 67
extern signed int g_hash_table_insert(struct _GHashTable *, void *, void *);
// g_hash_table_lookup
// file /usr/include/glib-2.0/glib/ghash.h line 88
extern void * g_hash_table_lookup(struct _GHashTable *, const void *);
// g_hash_table_new_full
// file /usr/include/glib-2.0/glib/ghash.h line 60
extern struct _GHashTable * g_hash_table_new_full(unsigned int (*)(const void *), signed int (*)(const void *, const void *), void (*)(void *), void (*)(void *));
// g_hash_table_unref
// file /usr/include/glib-2.0/glib/ghash.h line 144
extern void g_hash_table_unref(struct _GHashTable *);
// g_idle_add
// file /usr/include/glib-2.0/glib/gmain.h line 584
extern unsigned int g_idle_add(signed int (*)(void *), void *);
// g_intern_static_string
// file /usr/include/glib-2.0/glib/gquark.h line 64
extern const char * g_intern_static_string(const char *);
// g_list_free
// file /usr/include/glib-2.0/glib/glist.h line 51
extern void g_list_free(struct _GList *);
// g_log
// file /usr/include/glib-2.0/glib/gmessages.h line 101
extern void g_log(const char *, enum anonymous_10, const char *, ...);
// g_main_context_default
// file /usr/include/glib-2.0/glib/gmain.h line 312
extern struct _GMainContext * g_main_context_default(void);
// g_main_context_ref
// file /usr/include/glib-2.0/glib/gmain.h line 308
extern struct _GMainContext * g_main_context_ref(struct _GMainContext *);
// g_main_context_unref
// file /usr/include/glib-2.0/glib/gmain.h line 310
extern void g_main_context_unref(struct _GMainContext *);
// g_malloc
// file /usr/include/glib-2.0/glib/gmem.h line 78
extern void * g_malloc(unsigned long int);
// g_malloc0
// file /usr/include/glib-2.0/glib/gmem.h line 80
extern void * g_malloc0(unsigned long int);
// g_malloc0_n
// file /usr/include/glib-2.0/glib/gmem.h line 96
extern void * g_malloc0_n(unsigned long int, unsigned long int);
// g_malloc_n
// file /usr/include/glib-2.0/glib/gmem.h line 93
extern void * g_malloc_n(unsigned long int, unsigned long int);
// g_object_class_install_property
// file /usr/include/glib-2.0/gobject/gobject.h line 389
extern void g_object_class_install_property(struct _GObjectClass *, unsigned int, struct _GParamSpec *);
// g_object_new
// file /usr/include/glib-2.0/gobject/gobject.h line 420
extern void * g_object_new(unsigned long int, const char *, ...);
// g_object_unref
// file /usr/include/glib-2.0/gobject/gobject.h line 480
extern void g_object_unref(void *);
// g_once_init_enter
// file /usr/include/glib-2.0/glib/gthread.h line 232
extern signed int g_once_init_enter(volatile void *);
// g_once_init_leave
// file /usr/include/glib-2.0/glib/gthread.h line 234
extern void g_once_init_leave(volatile void *, unsigned long int);
// g_param_spec_boolean
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 995
extern struct _GParamSpec * g_param_spec_boolean(const char *, const char *, const char *, signed int, enum anonymous_35);
// g_param_spec_int
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1001
extern struct _GParamSpec * g_param_spec_int(const char *, const char *, const char *, signed int, signed int, signed int, enum anonymous_35);
// g_param_spec_pointer
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1103
extern struct _GParamSpec * g_param_spec_pointer(const char *, const char *, const char *, enum anonymous_35);
// g_param_spec_string
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1085
extern struct _GParamSpec * g_param_spec_string(const char *, const char *, const char *, const char *, enum anonymous_35);
// g_param_spec_uint
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1009
extern struct _GParamSpec * g_param_spec_uint(const char *, const char *, const char *, unsigned int, unsigned int, unsigned int, enum anonymous_35);
// g_print
// file /usr/include/glib-2.0/glib/gmessages.h line 265
extern void g_print(const char *, ...);
// g_realloc
// file /usr/include/glib-2.0/glib/gmem.h line 82
extern void * g_realloc(void *, unsigned long int);
// g_return_if_fail_warning
// file /usr/include/glib-2.0/glib/gmessages.h line 124
extern void g_return_if_fail_warning(const char *, const char *, const char *);
// g_signal_connect_data
// file /usr/include/glib-2.0/gobject/gsignal.h line 388
extern unsigned long int g_signal_connect_data(void *, const char *, void (*)(void), void *, void (*)(void *, struct _GClosure *), enum anonymous_7);
// g_signal_lookup
// file /usr/include/glib-2.0/gobject/gsignal.h line 331
extern unsigned int g_signal_lookup(const char *, unsigned long int);
// g_signal_stop_emission
// file /usr/include/glib-2.0/gobject/gsignal.h line 353
extern void g_signal_stop_emission(void *, unsigned int, unsigned int);
// g_snprintf
// file /usr/include/glib-2.0/glib/gutils.h line 201
extern signed int g_snprintf(char *, unsigned long int, const char *, ...);
// g_source_add_poll
// file /usr/include/glib-2.0/glib/gmain.h line 498
extern void g_source_add_poll(struct _GSource *, struct _GPollFD *);
// g_source_attach
// file /usr/include/glib-2.0/glib/gmain.h line 426
extern unsigned int g_source_attach(struct _GSource *, struct _GMainContext *);
// g_source_destroy
// file /usr/include/glib-2.0/glib/gmain.h line 429
extern void g_source_destroy(struct _GSource *);
// g_source_get_current_time
// file /usr/include/glib-2.0/glib/gmain.h line 512
extern void g_source_get_current_time(struct _GSource *, struct _GTimeVal *);
// g_source_new
// file /usr/include/glib-2.0/glib/gmain.h line 418
extern struct _GSource * g_source_new(struct _GSourceFuncs *, unsigned int);
// g_source_remove
// file /usr/include/glib-2.0/glib/gmain.h line 545
extern signed int g_source_remove(unsigned int);
// g_source_remove_poll
// file /usr/include/glib-2.0/glib/gmain.h line 501
extern void g_source_remove_poll(struct _GSource *, struct _GPollFD *);
// g_source_set_can_recurse
// file /usr/include/glib-2.0/glib/gmain.h line 437
extern void g_source_set_can_recurse(struct _GSource *, signed int);
// g_source_set_priority
// file /usr/include/glib-2.0/glib/gmain.h line 432
extern void g_source_set_priority(struct _GSource *, signed int);
// g_source_unref
// file /usr/include/glib-2.0/glib/gmain.h line 423
extern void g_source_unref(struct _GSource *);
// g_str_equal
// file /usr/include/glib-2.0/glib/ghash.h line 154
extern signed int g_str_equal(const void *, const void *);
// g_str_has_suffix
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 137
extern signed int g_str_has_suffix(const char *, const char *);
// g_str_hash
// file /usr/include/glib-2.0/glib/ghash.h line 157
extern unsigned int g_str_hash(const void *);
// g_strdup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 216
extern char * g_strdup(const char *);
// g_strdup_printf
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 218
extern char * g_strdup_printf(const char *, ...);
// g_strdupv
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 283
extern char ** g_strdupv(char **);
// g_strfreev
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 281
extern void g_strfreev(char **);
// g_timeout_add
// file /usr/include/glib-2.0/glib/gmain.h line 560
extern unsigned int g_timeout_add(unsigned int, signed int (*)(void *), void *);
// g_type_check_class_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2177
extern struct _GTypeClass * g_type_check_class_cast(struct _GTypeClass *, unsigned long int);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// g_type_check_instance_is_a
// file /usr/include/glib-2.0/gobject/gtype.h line 2171
extern signed int g_type_check_instance_is_a(struct _GTypeInstance *, unsigned long int);
// g_type_class_adjust_private_offset
// file /usr/include/glib-2.0/gobject/gtype.h line 1302
extern void g_type_class_adjust_private_offset(void *, signed int *);
// g_type_class_peek_parent
// file /usr/include/glib-2.0/gobject/gtype.h line 709
extern void * g_type_class_peek_parent(void *);
// g_type_name
// file /usr/include/glib-2.0/gobject/gtype.h line 685
extern const char * g_type_name(unsigned long int);
// g_type_register_static_simple
// file /usr/include/glib-2.0/gobject/gtype.h line 1259
extern unsigned long int g_type_register_static_simple(unsigned long int, const char *, unsigned int, void (*)(void *, void *), unsigned int, void (*)(struct _GTypeInstance *, void *), enum anonymous_3);
// g_value_get_boolean
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 197
extern signed int g_value_get_boolean(const struct _GValue *);
// g_value_get_int
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 202
extern signed int g_value_get_int(const struct _GValue *);
// g_value_get_pointer
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 252
extern void * g_value_get_pointer(const struct _GValue *);
// g_value_get_string
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 245
extern const char * g_value_get_string(const struct _GValue *);
// g_value_set_boolean
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 194
extern void g_value_set_boolean(struct _GValue *, signed int);
// g_value_set_int
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 199
extern void g_value_set_int(struct _GValue *, signed int);
// g_value_set_pointer
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 249
extern void g_value_set_pointer(struct _GValue *, void *);
// g_value_set_string
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 239
extern void g_value_set_string(struct _GValue *, const char *);
// g_value_set_uint
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 204
extern void g_value_set_uint(struct _GValue *, unsigned int);
// gdbm_close
// file /usr/include/gdbm.h line 86
extern void gdbm_close(struct anonymous_36 *);
// gdbm_fetch
// file /usr/include/gdbm.h line 88
extern struct anonymous_37 gdbm_fetch(struct anonymous_36 *, struct anonymous_37);
// gdbm_firstkey
// file /usr/include/gdbm.h line 90
extern struct anonymous_37 gdbm_firstkey(struct anonymous_36 *);
// gdbm_nextkey
// file /usr/include/gdbm.h line 91
extern struct anonymous_37 gdbm_nextkey(struct anonymous_36 *, struct anonymous_37);
// gdbm_open
// file /usr/include/gdbm.h line 85
extern struct anonymous_36 * gdbm_open(char *, signed int, signed int, signed int, void (*)());
// gdk_cursor_new
// file /usr/include/gtk-3.0/gdk/gdkcursor.h line 228
extern struct _GdkCursor * gdk_cursor_new(enum anonymous_34);
// gdk_window_set_cursor
// file /usr/include/gtk-3.0/gdk/gdkwindow.h line 784
extern void gdk_window_set_cursor(struct _GdkWindow *, struct _GdkCursor *);
// get_default_response
// file avahi-ui.c line 128
static signed int get_default_response(struct _GtkDialog *dlg);
// get_domain_name
// file avahi-ui.c line 670
static const char * get_domain_name(struct _AuiServiceDialog *d);
// get_server_state
// file client.c line 305
static signed int get_server_state(struct AvahiClient *client, signed int *ret_error);
// get_server_state_link1
// file client.c line 305
static signed int get_server_state_link1(struct AvahiClient *client_link1, signed int *ret_error_link1);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gtk_box_get_type
// file /usr/include/gtk-3.0/gtk/gtkbox.h line 78
extern unsigned long int gtk_box_get_type(void);
// gtk_box_new
// file /usr/include/gtk-3.0/gtk/gtkbox.h line 80
extern struct _GtkWidget * gtk_box_new(enum anonymous_16, signed int);
// gtk_box_pack_end
// file /usr/include/gtk-3.0/gtk/gtkbox.h line 90
extern void gtk_box_pack_end(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_box_pack_start
// file /usr/include/gtk-3.0/gtk/gtkbox.h line 84
extern void gtk_box_pack_start(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_button_box_get_type
// file /usr/include/gtk-3.0/gtk/gtkbbox.h line 104
extern unsigned long int gtk_button_box_get_type(void);
// gtk_button_box_set_child_secondary
// file /usr/include/gtk-3.0/gtk/gtkbbox.h line 116
extern void gtk_button_box_set_child_secondary(struct _GtkButtonBox *, struct _GtkWidget *, signed int);
// gtk_button_get_type
// file /usr/include/gtk-3.0/gtk/gtkbutton.h line 94
extern unsigned long int gtk_button_get_type(void);
// gtk_button_new_with_mnemonic
// file /usr/include/gtk-3.0/gtk/gtkbutton.h line 105
extern struct _GtkWidget * gtk_button_new_with_mnemonic(const char *);
// gtk_button_set_image
// file /usr/include/gtk-3.0/gtk/gtkbutton.h line 151
extern void gtk_button_set_image(struct _GtkButton *, struct _GtkWidget *);
// gtk_cell_renderer_text_new
// file /usr/include/gtk-3.0/gtk/gtkcellrenderertext.h line 69
extern struct _GtkCellRenderer * gtk_cell_renderer_text_new(void);
// gtk_container_add
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 149
extern void gtk_container_add(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_get_children
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 169
extern struct _GList * gtk_container_get_children(struct _GtkContainer *);
// gtk_container_get_type
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 142
extern unsigned long int gtk_container_get_type(void);
// gtk_container_set_border_width
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 144
extern void gtk_container_set_border_width(struct _GtkContainer *, unsigned int);
// gtk_dialog_add_button
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 162
extern struct _GtkWidget * gtk_dialog_add_button(struct _GtkDialog *, const char *, signed int);
// gtk_dialog_get_action_area
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 205
extern struct _GtkWidget * gtk_dialog_get_action_area(struct _GtkDialog *);
// gtk_dialog_get_content_area
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 207
extern struct _GtkWidget * gtk_dialog_get_content_area(struct _GtkDialog *);
// gtk_dialog_get_response_for_widget
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 181
extern signed int gtk_dialog_get_response_for_widget(struct _GtkDialog *, struct _GtkWidget *);
// gtk_dialog_get_type
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 146
extern unsigned long int gtk_dialog_get_type(void);
// gtk_dialog_new
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 148
extern struct _GtkWidget * gtk_dialog_new(void);
// gtk_dialog_response
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 197
extern void gtk_dialog_response(struct _GtkDialog *, signed int);
// gtk_dialog_run
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 202
extern signed int gtk_dialog_run(struct _GtkDialog *);
// gtk_dialog_set_default_response
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 175
extern void gtk_dialog_set_default_response(struct _GtkDialog *, signed int);
// gtk_dialog_set_response_sensitive
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 171
extern void gtk_dialog_set_response_sensitive(struct _GtkDialog *, signed int, signed int);
// gtk_entry_get_text
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 257
extern const char * gtk_entry_get_text(struct _GtkEntry *);
// gtk_entry_get_type
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 175
extern unsigned long int gtk_entry_get_type(void);
// gtk_entry_new
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 177
extern struct _GtkWidget * gtk_entry_new(void);
// gtk_entry_set_activates_default
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 233
extern void gtk_entry_set_activates_default(struct _GtkEntry *, signed int);
// gtk_entry_set_max_length
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 225
extern void gtk_entry_set_max_length(struct _GtkEntry *, signed int);
// gtk_entry_set_text
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 253
extern void gtk_entry_set_text(struct _GtkEntry *, const char *);
// gtk_image_new_from_icon_name
// file /usr/include/gtk-3.0/gtk/gtkimage.h line 130
extern struct _GtkWidget * gtk_image_new_from_icon_name(const char *, enum anonymous_32);
// gtk_init
// file /usr/include/gtk-3.0/gtk/gtkmain.h line 101
extern void gtk_init(signed int *, char ***);
// gtk_label_get_type
// file /usr/include/gtk-3.0/gtk/gtklabel.h line 91
extern unsigned long int gtk_label_get_type(void);
// gtk_label_new
// file /usr/include/gtk-3.0/gtk/gtklabel.h line 93
extern struct _GtkWidget * gtk_label_new(const char *);
// gtk_label_set_ellipsize
// file /usr/include/gtk-3.0/gtk/gtklabel.h line 144
extern void gtk_label_set_ellipsize(struct _GtkLabel *, enum anonymous_0);
// gtk_label_set_markup
// file /usr/include/gtk-3.0/gtk/gtklabel.h line 112
extern void gtk_label_set_markup(struct _GtkLabel *, const char *);
// gtk_list_store_append
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 129
extern void gtk_list_store_append(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_clear
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 132
extern void gtk_list_store_clear(struct _GtkListStore *);
// gtk_list_store_get_type
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 65
extern unsigned long int gtk_list_store_get_type(void);
// gtk_list_store_new
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 67
extern struct _GtkListStore * gtk_list_store_new(signed int, ...);
// gtk_list_store_remove
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 99
extern signed int gtk_list_store_remove(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_set
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 85
extern void gtk_list_store_set(struct _GtkListStore *, struct _GtkTreeIter *, ...);
// gtk_message_dialog_new
// file /usr/include/gtk-3.0/gtk/gtkmessagedialog.h line 99
extern struct _GtkWidget * gtk_message_dialog_new(struct _GtkWindow *, enum anonymous_30, enum anonymous_29, enum anonymous_17, const char *, ...);
// gtk_misc_get_type
// file /usr/include/gtk-3.0/gtk/deprecated/gtkmisc.h line 70
extern unsigned long int gtk_misc_get_type(void);
// gtk_misc_set_alignment
// file /usr/include/gtk-3.0/gtk/deprecated/gtkmisc.h line 72
extern void gtk_misc_set_alignment(struct _GtkMisc *, float, float);
// gtk_progress_bar_get_type
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 69
extern unsigned long int gtk_progress_bar_get_type(void);
// gtk_progress_bar_new
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 71
extern struct _GtkWidget * gtk_progress_bar_new(void);
// gtk_progress_bar_pulse
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 74
extern void gtk_progress_bar_pulse(struct _GtkProgressBar *);
// gtk_progress_bar_set_pulse_step
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 83
extern void gtk_progress_bar_set_pulse_step(struct _GtkProgressBar *, double);
// gtk_progress_bar_set_text
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 76
extern void gtk_progress_bar_set_text(struct _GtkProgressBar *, const char *);
// gtk_scrolled_window_get_type
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 146
extern unsigned long int gtk_scrolled_window_get_type(void);
// gtk_scrolled_window_new
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 148
extern struct _GtkWidget * gtk_scrolled_window_new(struct _GtkAdjustment *, struct _GtkAdjustment *);
// gtk_scrolled_window_set_policy
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 165
extern void gtk_scrolled_window_set_policy(struct _GtkScrolledWindow *, enum anonymous_2, enum anonymous_2);
// gtk_scrolled_window_set_shadow_type
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 181
extern void gtk_scrolled_window_set_shadow_type(struct _GtkScrolledWindow *, enum anonymous_5);
// gtk_tree_model_get
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 364
extern void gtk_tree_model_get(struct _GtkTreeModel *, struct _GtkTreeIter *, ...);
// gtk_tree_model_get_iter_first
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 322
extern signed int gtk_tree_model_get_iter_first(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_get_path
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 325
extern struct _GtkTreePath * gtk_tree_model_get_path(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_get_type
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 299
extern unsigned long int gtk_tree_model_get_type(void);
// gtk_tree_model_iter_next
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 336
extern signed int gtk_tree_model_iter_next(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_path_free
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 225
extern void gtk_tree_path_free(struct _GtkTreePath *);
// gtk_tree_selection_get_selected
// file /usr/include/gtk-3.0/gtk/gtktreeselection.h line 130
extern signed int gtk_tree_selection_get_selected(struct _GtkTreeSelection *, struct _GtkTreeModel **, struct _GtkTreeIter *);
// gtk_tree_selection_select_iter
// file /usr/include/gtk-3.0/gtk/gtktreeselection.h line 149
extern void gtk_tree_selection_select_iter(struct _GtkTreeSelection *, struct _GtkTreeIter *);
// gtk_tree_selection_set_mode
// file /usr/include/gtk-3.0/gtk/gtktreeselection.h line 110
extern void gtk_tree_selection_set_mode(struct _GtkTreeSelection *, enum anonymous_1);
// gtk_tree_view_append_column
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 258
extern signed int gtk_tree_view_append_column(struct _GtkTreeView *, struct _GtkTreeViewColumn *);
// gtk_tree_view_column_new_with_attributes
// file /usr/include/gtk-3.0/gtk/gtktreeviewcolumn.h line 111
extern struct _GtkTreeViewColumn * gtk_tree_view_column_new_with_attributes(const char *, struct _GtkCellRenderer *, ...);
// gtk_tree_view_column_set_expand
// file /usr/include/gtk-3.0/gtk/gtktreeviewcolumn.h line 194
extern void gtk_tree_view_column_set_expand(struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_column_set_visible
// file /usr/include/gtk-3.0/gtk/gtktreeviewcolumn.h line 148
extern void gtk_tree_view_column_set_visible(struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_get_column
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 285
extern struct _GtkTreeViewColumn * gtk_tree_view_get_column(struct _GtkTreeView *, signed int);
// gtk_tree_view_get_selection
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 219
extern struct _GtkTreeSelection * gtk_tree_view_get_selection(struct _GtkTreeView *);
// gtk_tree_view_get_type
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 206
extern unsigned long int gtk_tree_view_get_type(void);
// gtk_tree_view_new_with_model
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 210
extern struct _GtkWidget * gtk_tree_view_new_with_model(struct _GtkTreeModel *);
// gtk_tree_view_set_cursor
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 347
extern void gtk_tree_view_set_cursor(struct _GtkTreeView *, struct _GtkTreePath *, struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_set_headers_visible
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 236
extern void gtk_tree_view_set_headers_visible(struct _GtkTreeView *, signed int);
// gtk_tree_view_set_search_column
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 446
extern void gtk_tree_view_set_search_column(struct _GtkTreeView *, signed int);
// gtk_widget_destroy
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 619
extern void gtk_widget_destroy(struct _GtkWidget *);
// gtk_widget_get_type
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 613
extern unsigned long int gtk_widget_get_type(void);
// gtk_widget_get_window
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 907
extern struct _GdkWindow * gtk_widget_get_window(struct _GtkWidget *);
// gtk_widget_grab_default
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 793
extern void gtk_widget_grab_default(struct _GtkWidget *);
// gtk_widget_grab_focus
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 783
extern void gtk_widget_grab_focus(struct _GtkWidget *);
// gtk_widget_hide
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 628
extern void gtk_widget_hide(struct _GtkWidget *);
// gtk_widget_set_sensitive
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 833
extern void gtk_widget_set_sensitive(struct _GtkWidget *, signed int);
// gtk_widget_show
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 626
extern void gtk_widget_show(struct _GtkWidget *);
// gtk_widget_show_all
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 632
extern void gtk_widget_show_all(struct _GtkWidget *);
// gtk_window_get_default_widget
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 185
extern struct _GtkWidget * gtk_window_get_default_widget(struct _GtkWindow *);
// gtk_window_get_type
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 145
extern unsigned long int gtk_window_get_type(void);
// gtk_window_present
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 370
extern void gtk_window_present(struct _GtkWindow *);
// gtk_window_set_default_size
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 419
extern void gtk_window_set_default_size(struct _GtkWindow *, signed int, signed int);
// gtk_window_set_title
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 149
extern void gtk_window_set_title(struct _GtkWindow *, const char *);
// gtk_window_set_transient_for
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 190
extern void gtk_window_set_transient_for(struct _GtkWindow *, struct _GtkWindow *);
// help
// file bssh.c line 53
static void help(struct _IO_FILE *f, const char *argv0);
// if_indextoname
// file /usr/include/net/if.h line 194
extern char * if_indextoname(unsigned int, char *);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init
// file ../avahi-utils/stdb.c line 46
static signed int init(void);
// init_server
// file client.c line 431
static signed int init_server(struct AvahiClient *client, signed int *ret_error);
// init_server_link1
// file client.c line 431
static signed int init_server_link1(struct AvahiClient *client_link1, signed int *ret_error_link1);
// is_valid_domain_suffix
// file avahi-ui.c line 919
static signed int is_valid_domain_suffix(const char *n);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// malloc_glue
// file glib-malloc.c line 29
static void * malloc_glue(unsigned long int l);
// map_events_from_glib
// file glib-watch.c line 101
static enum anonymous map_events_from_glib(unsigned short int events);
// map_events_to_glib
// file glib-watch.c line 93
static unsigned short int map_events_to_glib(enum anonymous events);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// oom
// file malloc.c line 44
static void oom(void);
// oom_link1
// file malloc.c line 44
static void oom_link1(void);
// oom_link1_link1
// file malloc.c line 44
static void oom_link1_link1(void);
// oom_link2
// file malloc.c line 44
static void oom_link2(void);
// oom_link3
// file malloc.c line 44
static void oom_link3(void);
// parse_command_line
// file bssh.c line 64
static signed int parse_command_line(struct Config *c, signed int argc, char **argv);
// parse_domain_file
// file browser.c line 58
static void parse_domain_file(struct AvahiDomainBrowser *b);
// parse_domain_file_link1
// file browser.c line 58
static void parse_domain_file_link1(struct AvahiDomainBrowser *b_link1);
// parse_environment
// file browser.c line 41
static void parse_environment(struct AvahiDomainBrowser *b);
// parse_environment_link1
// file browser.c line 41
static void parse_environment_link1(struct AvahiDomainBrowser *b_link1);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// poll_func
// file thread-watch.c line 48
static signed int poll_func(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata);
// poll_func_link1
// file thread-watch.c line 48
static signed int poll_func_link1(struct pollfd *ufds_link1, unsigned int nfds_link1, signed int timeout_link1, void *userdata_link1);
// poll_func_link1_link1
// file thread-watch.c line 48
static signed int poll_func_link1_link1(struct pollfd *ufds_link1_link1, unsigned int nfds_link1_link1, signed int timeout_link1_link1, void *userdata_link1_link1);
// poll_func_link2
// file thread-watch.c line 48
static signed int poll_func_link2(struct pollfd *ufds_link2, unsigned int nfds_link2, signed int timeout_link2, void *userdata_link2);
// poll_func_link3
// file thread-watch.c line 48
static signed int poll_func_link3(struct pollfd *ufds_link3, unsigned int nfds_link3, signed int timeout_link3, void *userdata_link3);
// prepare_func
// file glib-watch.c line 255
static signed int prepare_func(struct _GSource *source, signed int *timeout);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_equal
// file /usr/include/pthread.h line 280
extern signed int pthread_equal(unsigned long int, unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_6 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_6 *, const union anonymous_38 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_6 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_6 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_8 *, struct anonymous_8 *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realloc_glue
// file glib-malloc.c line 33
static void * realloc_glue(void *p, unsigned long int l);
// rebuild
// file simple-watch.c line 385
static signed int rebuild(struct AvahiSimplePoll_0 *s);
// rebuild_link1
// file simple-watch.c line 385
static signed int rebuild_link1(struct AvahiSimplePoll_0 *s_link1);
// rebuild_link1_link1
// file simple-watch.c line 385
static signed int rebuild_link1_link1(struct AvahiSimplePoll_0 *s_link1_link1);
// rebuild_link2
// file simple-watch.c line 385
static signed int rebuild_link2(struct AvahiSimplePoll *s_link2);
// rebuild_link3
// file simple-watch.c line 385
static signed int rebuild_link3(struct AvahiSimplePoll_0 *s_link3);
// remove_pollfd
// file simple-watch.c line 194
static void remove_pollfd(struct AvahiWatch_1 *w);
// remove_pollfd_link1
// file simple-watch.c line 194
static void remove_pollfd_link1(struct AvahiWatch_1 *w_link1);
// remove_pollfd_link1_link1
// file simple-watch.c line 194
static void remove_pollfd_link1_link1(struct AvahiWatch_1 *w_link1_link1);
// remove_pollfd_link2
// file simple-watch.c line 194
static void remove_pollfd_link2(struct AvahiWatch *w_link2);
// remove_pollfd_link3
// file simple-watch.c line 194
static void remove_pollfd_link3(struct AvahiWatch_1 *w_link3);
// remove_timeout
// file ../avahi-common/dbus-watch-glue.c line 286
static void remove_timeout(struct DBusTimeout *dbus_timeout, void *userdata);
// remove_timeout_link1
// file ../avahi-common/dbus-watch-glue.c line 286
static void remove_timeout_link1(struct DBusTimeout *dbus_timeout_link1, void *userdata_link1);
// remove_watch
// file ../avahi-common/dbus-watch-glue.c line 174
static void remove_watch(struct DBusWatch *dbus_watch, void *userdata);
// remove_watch_link1
// file ../avahi-common/dbus-watch-glue.c line 174
static void remove_watch_link1(struct DBusWatch *dbus_watch_link1, void *userdata_link1);
// request_dispatch
// file ../avahi-common/dbus-watch-glue.c line 86
static void request_dispatch(struct anonymous_28 *d, signed int enable);
// request_dispatch_link1
// file ../avahi-common/dbus-watch-glue.c line 86
static void request_dispatch_link1(struct anonymous_28 *d_link1, signed int enable_link1);
// resolve_callback
// file avahi-ui.c line 335
static void resolve_callback(struct AvahiServiceResolver *r, signed int interface, signed int protocol, enum anonymous_12 event, const char *name, const char *type, const char *domain, const char *host_name, const struct AvahiAddress *a, unsigned short int port, struct AvahiStringList *txt, enum anonymous_13 flags, void *userdata);
// response_callback
// file avahi-ui.c line 859
static void response_callback(struct _GtkDialog *dialog, signed int response, void *user_data);
// restart_browsing
// file avahi-ui.c line 1207
static void restart_browsing(struct _AuiServiceDialog *d);
// retrieve_state
// file entrygroup.c line 52
static signed int retrieve_state(struct AvahiEntryGroup *group);
// retrieve_state_link1
// file entrygroup.c line 52
static signed int retrieve_state_link1(struct AvahiEntryGroup *group_link1);
// service_pulse_callback
// file avahi-ui.c line 304
static signed int service_pulse_callback(void *data);
// service_row_activated_callback
// file avahi-ui.c line 842
static void service_row_activated_callback(struct _GtkTreeView *tree_view, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data);
// service_selection_changed_callback
// file avahi-ui.c line 848
static void service_selection_changed_callback(struct _GtkTreeSelection *selection, void *user_data);
// set_nonblock
// file simple-watch.c line 118
static signed int set_nonblock(signed int fd);
// set_nonblock_link1
// file simple-watch.c line 118
static signed int set_nonblock_link1(signed int fd_link1);
// set_nonblock_link1_link1
// file simple-watch.c line 118
static signed int set_nonblock_link1_link1(signed int fd_link1_link1);
// set_nonblock_link2
// file simple-watch.c line 118
static signed int set_nonblock_link2(signed int fd_link2);
// set_nonblock_link3
// file simple-watch.c line 118
static signed int set_nonblock_link3(signed int fd_link3);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_8 *);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// start_callback
// file avahi-ui.c line 695
static signed int start_callback(void *data);
// start_timeout_callback
// file glib-watch.c line 246
static void start_timeout_callback(struct AvahiTimeout *t);
// stdb_getent
// file ../avahi-utils/stdb.c line 168
char * stdb_getent(void);
// stdb_lookup
// file ../avahi-utils/stdb.h line 25
const char * stdb_lookup(const char *name);
// stdb_setent
// file ../avahi-utils/stdb.c line 209
void stdb_setent(void);
// stdb_shutdown
// file ../avahi-utils/stdb.c line 148
void stdb_shutdown(void);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlcpy
// file domain.c line 482
static unsigned long int strlcpy(char *dest, const char *src, unsigned long int n);
// strlcpy_link1
// file domain.c line 482
static unsigned long int strlcpy_link1(char *dest_link1, const char *src_link1, unsigned long int n_link1);
// strlcpy_link1_link1
// file domain.c line 482
static unsigned long int strlcpy_link1_link1(char *dest_link1_link1, const char *src_link1_link1, unsigned long int n_link1_link1);
// strlcpy_link2
// file domain.c line 482
static unsigned long int strlcpy_link2(char *dest_link2, const char *src_link2, unsigned long int n_link2);
// strlcpy_link3
// file domain.c line 482
static unsigned long int strlcpy_link3(char *dest_link3, const char *src_link3, unsigned long int n_link3);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok_r
// file /usr/include/string.h line 358
extern char * strtok_r(char *, const char *, char ** restrict );
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// system_poll
// file simple-watch.c line 626
static signed int system_poll(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata);
// system_poll_link1
// file simple-watch.c line 626
static signed int system_poll_link1(struct pollfd *ufds_link1, unsigned int nfds_link1, signed int timeout_link1, void *userdata_link1);
// system_poll_link1_link1
// file simple-watch.c line 626
static signed int system_poll_link1_link1(struct pollfd *ufds_link1_link1, unsigned int nfds_link1_link1, signed int timeout_link1_link1, void *userdata_link1_link1);
// system_poll_link2
// file simple-watch.c line 626
static signed int system_poll_link2(struct pollfd *ufds_link2, unsigned int nfds_link2, signed int timeout_link2, void *userdata_link2);
// system_poll_link3
// file simple-watch.c line 626
static signed int system_poll_link3(struct pollfd *ufds_link3, unsigned int nfds_link3, signed int timeout_link3, void *userdata_link3);
// textdomain
// file /usr/include/libintl.h line 82
extern char * textdomain(const char *);
// thread
// file thread-watch.c line 62
static void * thread(void *userdata);
// thread_link1
// file thread-watch.c line 62
static void * thread_link1(void *userdata_link1);
// thread_link1_link1
// file thread-watch.c line 62
static void * thread_link1_link1(void *userdata_link1_link1);
// thread_link2
// file thread-watch.c line 62
static void * thread_link2(void *userdata_link2);
// thread_link3
// file thread-watch.c line 62
static void * thread_link3(void *userdata_link3);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 237
static void timeout_callback(struct AvahiTimeout_1 *avahi_timeout, void *userdata);
// timeout_callback_link1
// file simple-watch.c line 441
static void timeout_callback_link1(struct AvahiTimeout_1 *t);
// timeout_callback_link1_link1
// file simple-watch.c line 441
static void timeout_callback_link1_link1(struct AvahiTimeout_1 *t_link1_link1);
// timeout_callback_link2
// file simple-watch.c line 441
static void timeout_callback_link2(struct AvahiTimeout_1 *t_link1);
// timeout_callback_link2_link1
// file ../avahi-common/dbus-watch-glue.c line 237
static void timeout_callback_link2_link1(struct AvahiTimeout_1 *avahi_timeout_link1, void *userdata_link1);
// timeout_callback_link3
// file simple-watch.c line 441
static void timeout_callback_link3(struct AvahiTimeout_0 *t_link2);
// timeout_callback_link4
// file simple-watch.c line 441
static void timeout_callback_link4(struct AvahiTimeout_1 *t_link3);
// timeout_data_ref
// file ../avahi-common/dbus-watch-glue.c line 203
static struct TimeoutData * timeout_data_ref(struct TimeoutData *t);
// timeout_data_ref_link1
// file ../avahi-common/dbus-watch-glue.c line 203
static struct TimeoutData * timeout_data_ref_link1(struct TimeoutData *t_link1);
// timeout_data_unref
// file ../avahi-common/dbus-watch-glue.c line 211
static void timeout_data_unref(struct TimeoutData *t);
// timeout_data_unref_link1
// file ../avahi-common/dbus-watch-glue.c line 211
static void timeout_data_unref_link1(struct TimeoutData *t_link1);
// timeout_free
// file simple-watch.c line 284
static void timeout_free(struct AvahiTimeout_1 *t);
// timeout_free_link1
// file simple-watch.c line 284
static void timeout_free_link1(struct AvahiTimeout_1 *t_link1);
// timeout_free_link1_link1
// file simple-watch.c line 284
static void timeout_free_link1_link1(struct AvahiTimeout_0 *t_link1_link1);
// timeout_free_link1_link2
// file simple-watch.c line 284
static void timeout_free_link1_link2(struct AvahiTimeout_1 *t_link1_link2);
// timeout_free_link2
// file glib-watch.c line 201
static void timeout_free_link2(struct AvahiTimeout *t_link2);
// timeout_free_link3
// file simple-watch.c line 284
static void timeout_free_link3(struct AvahiTimeout_1 *t_link3);
// timeout_new
// file simple-watch.c line 244
static struct AvahiTimeout_1 * timeout_new(const struct AvahiPoll_1 *api, struct timeval *tv, void (*callback)(struct AvahiTimeout_1 *, void *), void *userdata);
// timeout_new_link1
// file simple-watch.c line 244
static struct AvahiTimeout_1 * timeout_new_link1(const struct AvahiPoll_1 *api_link1, struct timeval *tv_link1, void (*callback_link1)(struct AvahiTimeout_1 *, void *), void *userdata_link1);
// timeout_new_link1_link1
// file simple-watch.c line 244
static struct AvahiTimeout_0 * timeout_new_link1_link1(const struct AvahiPoll_0 *api_link1_link1, struct timeval *tv_link1_link1, void (*callback_link1_link1)(struct AvahiTimeout_0 *, void *), void *userdata_link1_link1);
// timeout_new_link1_link2
// file simple-watch.c line 244
static struct AvahiTimeout_1 * timeout_new_link1_link2(const struct AvahiPoll_1 *api_link1_link2, struct timeval *tv_link1_link2, void (*callback_link1_link2)(struct AvahiTimeout_1 *, void *), void *userdata_link1_link2);
// timeout_new_link2
// file glib-watch.c line 166
static struct AvahiTimeout * timeout_new_link2(const struct AvahiPoll *api_link2, struct timeval *tv_link2, void (*callback_link2)(struct AvahiTimeout *, void *), void *userdata_link2);
// timeout_new_link3
// file simple-watch.c line 244
static struct AvahiTimeout_1 * timeout_new_link3(const struct AvahiPoll_1 *api_link3, struct timeval *tv_link3, void (*callback_link3)(struct AvahiTimeout_1 *, void *), void *userdata_link3);
// timeout_new::callback_link1_link1_object
//
void callback_link1_link1_object(struct AvahiTimeout_0 *, void *);
// timeout_new::callback_link1_link2_object
//
void callback_link1_link2_object(struct AvahiTimeout_1 *, void *);
// timeout_new::callback_link1_object
//
void callback_link1_object(struct AvahiTimeout_1 *, void *);
// timeout_new::callback_link2_object
//
void callback_link2_object(struct AvahiTimeout *, void *);
// timeout_new::callback_link3_object
//
void callback_link3_object(struct AvahiTimeout_1 *, void *);
// timeout_new::callback_object
//
void callback_object(struct AvahiTimeout_1 *, void *);
// timeout_toggled
// file ../avahi-common/dbus-watch-glue.c line 300
static void timeout_toggled(struct DBusTimeout *dbus_timeout, void *userdata);
// timeout_toggled_link1
// file ../avahi-common/dbus-watch-glue.c line 300
static void timeout_toggled_link1(struct DBusTimeout *dbus_timeout_link1, void *userdata_link1);
// timeout_update
// file simple-watch.c line 273
static void timeout_update(struct AvahiTimeout_1 *t, struct timeval *tv);
// timeout_update_link1
// file simple-watch.c line 273
static void timeout_update_link1(struct AvahiTimeout_1 *t_link1, struct timeval *tv_link1);
// timeout_update_link1_link1
// file simple-watch.c line 273
static void timeout_update_link1_link1(struct AvahiTimeout_0 *t_link1_link1, struct timeval *tv_link1_link1);
// timeout_update_link1_link2
// file simple-watch.c line 273
static void timeout_update_link1_link2(struct AvahiTimeout_1 *t_link1_link2, struct timeval *tv_link1_link2);
// timeout_update_link2
// file glib-watch.c line 193
static void timeout_update_link2(struct AvahiTimeout *t_link2, struct timeval *tv_link2);
// timeout_update_link3
// file simple-watch.c line 273
static void timeout_update_link3(struct AvahiTimeout_1 *t_link3, struct timeval *tv_link3);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// translate_avahi_to_dbus
// file ../avahi-common/dbus-watch-glue.c line 46
static unsigned int translate_avahi_to_dbus(enum anonymous e);
// translate_avahi_to_dbus_link1
// file ../avahi-common/dbus-watch-glue.c line 46
static unsigned int translate_avahi_to_dbus_link1(enum anonymous e_link1);
// translate_dbus_to_avahi
// file ../avahi-common/dbus-watch-glue.c line 31
static enum anonymous translate_dbus_to_avahi(unsigned int f);
// translate_dbus_to_avahi_link1
// file ../avahi-common/dbus-watch-glue.c line 31
static enum anonymous translate_dbus_to_avahi_link1(unsigned int f_link1);
// update_timeout
// file ../avahi-common/dbus-watch-glue.c line 223
static void update_timeout(struct TimeoutData *timeout);
// update_timeout_link1
// file ../avahi-common/dbus-watch-glue.c line 223
static void update_timeout_link1(struct TimeoutData *timeout_link1);
// update_watch
// file ../avahi-common/dbus-watch-glue.c line 125
static unsigned int update_watch(const struct AvahiPoll_1 *poll_api, struct DBusWatch *dbus_watch);
// update_watch_link1
// file ../avahi-common/dbus-watch-glue.c line 125
static unsigned int update_watch_link1(const struct AvahiPoll_1 *poll_api_link1, struct DBusWatch *dbus_watch_link1);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// watch_callback
// file ../avahi-common/dbus-watch-glue.c line 115
static void watch_callback(struct AvahiWatch_1 *avahi_watch, signed int fd, enum anonymous events, void *userdata);
// watch_callback_link1
// file ../avahi-common/dbus-watch-glue.c line 115
static void watch_callback_link1(struct AvahiWatch_1 *avahi_watch_link1, signed int fd_link1, enum anonymous events_link1, void *userdata_link1);
// watch_free
// file simple-watch.c line 203
static void watch_free(struct AvahiWatch_1 *w);
// watch_free_link1
// file simple-watch.c line 203
static void watch_free_link1(struct AvahiWatch_1 *w_link1);
// watch_free_link1_link1
// file simple-watch.c line 203
static void watch_free_link1_link1(struct AvahiWatch *w_link1_link1);
// watch_free_link1_link2
// file simple-watch.c line 203
static void watch_free_link1_link2(struct AvahiWatch_1 *w_link1_link2);
// watch_free_link2
// file glib-watch.c line 153
static void watch_free_link2(struct AvahiWatch_0 *w_link2);
// watch_free_link3
// file simple-watch.c line 203
static void watch_free_link3(struct AvahiWatch_1 *w_link3);
// watch_get_events
// file simple-watch.c line 184
static enum anonymous watch_get_events(struct AvahiWatch_1 *w);
// watch_get_events_link1
// file simple-watch.c line 184
static enum anonymous watch_get_events_link1(struct AvahiWatch_1 *w_link1);
// watch_get_events_link1_link1
// file simple-watch.c line 184
static enum anonymous watch_get_events_link1_link1(struct AvahiWatch *w_link1_link1);
// watch_get_events_link1_link2
// file simple-watch.c line 184
static enum anonymous watch_get_events_link1_link2(struct AvahiWatch_1 *w_link1_link2);
// watch_get_events_link2
// file glib-watch.c line 146
static enum anonymous watch_get_events_link2(struct AvahiWatch_0 *w_link2);
// watch_get_events_link3
// file simple-watch.c line 184
static enum anonymous watch_get_events_link3(struct AvahiWatch_1 *w_link3);
// watch_new
// file simple-watch.c line 132
static struct AvahiWatch_1 * watch_new(const struct AvahiPoll_1 *api, signed int fd, enum anonymous event, void (*callback)(struct AvahiWatch_1 *, signed int, enum anonymous, void *), void *userdata);
// watch_new_link1
// file simple-watch.c line 132
static struct AvahiWatch_1 * watch_new_link1(const struct AvahiPoll_1 *api_link1, signed int fd_link1, enum anonymous event_link1, void (*callback_link1)(struct AvahiWatch_1 *, signed int, enum anonymous, void *), void *userdata_link1);
// watch_new_link1_link1
// file simple-watch.c line 132
static struct AvahiWatch * watch_new_link1_link1(const struct AvahiPoll_0 *api_link1_link1, signed int fd_link1_link1, enum anonymous event_link2, void (*callback_link1_link1)(struct AvahiWatch *, signed int, enum anonymous, void *), void *userdata_link1_link1);
// watch_new_link1_link2
// file simple-watch.c line 132
static struct AvahiWatch_1 * watch_new_link1_link2(const struct AvahiPoll_1 *api_link1_link2, signed int fd_link1_link2, enum anonymous event_link1_link1, void (*callback_link1_link2)(struct AvahiWatch_1 *, signed int, enum anonymous, void *), void *userdata_link1_link2);
// watch_new_link2
// file glib-watch.c line 109
static struct AvahiWatch_0 * watch_new_link2(const struct AvahiPoll *api_link2, signed int fd_link2, enum anonymous events, void (*callback_link2)(struct AvahiWatch_0 *, signed int, enum anonymous, void *), void *userdata_link2);
// watch_new_link3
// file simple-watch.c line 132
static struct AvahiWatch_1 * watch_new_link3(const struct AvahiPoll_1 *api_link3, signed int fd_link3, enum anonymous event_link3, void (*callback_link3)(struct AvahiWatch_1 *, signed int, enum anonymous, void *), void *userdata_link3);
// watch_new::callback_link1_link1_object
//
void callback_link1_link1_object(struct AvahiWatch *, signed int, enum anonymous, void *);
// watch_new::callback_link1_link2_object
//
void callback_link1_link2_object(struct AvahiWatch_1 *, signed int, enum anonymous, void *);
// watch_new::callback_link1_object
//
void callback_link1_object(struct AvahiWatch_1 *, signed int, enum anonymous, void *);
// watch_new::callback_link2_object
//
void callback_link2_object(struct AvahiWatch_0 *, signed int, enum anonymous, void *);
// watch_new::callback_link3_object
//
void callback_link3_object(struct AvahiWatch_1 *, signed int, enum anonymous, void *);
// watch_new::callback_object
//
void callback_object(struct AvahiWatch_1 *, signed int, enum anonymous, void *);
// watch_toggled
// file ../avahi-common/dbus-watch-glue.c line 187
static void watch_toggled(struct DBusWatch *dbus_watch, void *userdata);
// watch_toggled_link1
// file ../avahi-common/dbus-watch-glue.c line 187
static void watch_toggled_link1(struct DBusWatch *dbus_watch_link1, void *userdata_link1);
// watch_update
// file simple-watch.c line 168
static void watch_update(struct AvahiWatch_1 *w, enum anonymous events);
// watch_update_link1
// file simple-watch.c line 168
static void watch_update_link1(struct AvahiWatch_1 *w_link1, enum anonymous events_link1);
// watch_update_link1_link1
// file simple-watch.c line 168
static void watch_update_link1_link1(struct AvahiWatch *w_link1_link1, enum anonymous events_link1_link1);
// watch_update_link1_link2
// file simple-watch.c line 168
static void watch_update_link1_link2(struct AvahiWatch_1 *w_link1_link2, enum anonymous events_link1_link2);
// watch_update_link2
// file glib-watch.c line 139
static void watch_update_link2(struct AvahiWatch_0 *w_link2, enum anonymous events_link2);
// watch_update_link3
// file simple-watch.c line 168
static void watch_update_link3(struct AvahiWatch_1 *w_link3, enum anonymous events_link3);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// xcalloc
// file malloc.c line 89
static void * xcalloc(unsigned long int nmemb, unsigned long int size);
// xcalloc_link1
// file malloc.c line 89
static void * xcalloc_link1(unsigned long int nmemb_link1, unsigned long int size_link1);
// xcalloc_link1_link1
// file malloc.c line 89
static void * xcalloc_link1_link1(unsigned long int nmemb_link1_link1, unsigned long int size_link1_link1);
// xcalloc_link2
// file malloc.c line 89
static void * xcalloc_link2(unsigned long int nmemb_link2, unsigned long int size_link2);
// xcalloc_link3
// file malloc.c line 89
static void * xcalloc_link3(unsigned long int nmemb_link3, unsigned long int size_link3);
// xmalloc
// file malloc.c line 62
static void * xmalloc(unsigned long int size);
// xmalloc_link1
// file malloc.c line 62
static void * xmalloc_link1(unsigned long int size_link1);
// xmalloc_link1_link1
// file malloc.c line 62
static void * xmalloc_link1_link1(unsigned long int size_link1_link1);
// xmalloc_link2
// file malloc.c line 62
static void * xmalloc_link2(unsigned long int size_link2);
// xmalloc_link3
// file malloc.c line 62
static void * xmalloc_link3(unsigned long int size_link3);
// xrealloc
// file malloc.c line 75
static void * xrealloc(void *p, unsigned long int size);
// xrealloc_link1
// file malloc.c line 75
static void * xrealloc_link1(void *p_link1, unsigned long int size_link1);
// xrealloc_link1_link1
// file malloc.c line 75
static void * xrealloc_link1_link1(void *p_link1_link1, unsigned long int size_link1_link1);
// xrealloc_link2
// file malloc.c line 75
static void * xrealloc_link2(void *p_link2, unsigned long int size_link2);
// xrealloc_link3
// file malloc.c line 75
static void * xrealloc_link3(void *p_link3, unsigned long int size_link3);

struct anonymous_37
{
  // dptr
  char *dptr;
  // dsize
  signed int dsize;
};

struct anonymous_28
{
  // connection
  struct DBusConnection *connection;
  // poll_api
  const struct AvahiPoll_1 *poll_api;
  // dispatch_timeout
  struct AvahiTimeout_1 *dispatch_timeout;
  // ref
  signed int ref;
};

struct anonymous_36
{
  // dummy
  signed int dummy[10l];
};

struct anonymous_8
{
  // __val
  unsigned long int __val[16l];
};

union anonymous_38
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_54
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

struct AvahiIPv6Address
{
  // address
  unsigned char address[16l];
};

struct AvahiIPv4Address
{
  // address
  unsigned int address;
};

union anonymous_15
{
  // ipv6
  struct AvahiIPv6Address ipv6;
  // ipv4
  struct AvahiIPv4Address ipv4;
  // data
  unsigned char data[1l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_6
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct AvahiAddress
{
  // proto
  signed int proto;
  // data
  union anonymous_15 data;
};

struct AvahiAddressResolver
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiAddressResolver *, signed int, signed int, enum anonymous_12, const struct AvahiAddress *, const char *, enum anonymous_13, void *);
  // userdata
  void *userdata;
  // address_resolvers_next
  struct AvahiAddressResolver *address_resolvers_next;
  // address_resolvers_prev
  struct AvahiAddressResolver *address_resolvers_prev;
  // address
  struct AvahiAddress address;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiAllocator
{
  // malloc
  void * (*malloc)(unsigned long int);
  // free
  void (*free)(void *);
  // realloc
  void * (*realloc)(void *, unsigned long int);
  // calloc
  void * (*calloc)(unsigned long int, unsigned long int);
};

struct AvahiClient
{
  // poll_api
  const struct AvahiPoll_1 *poll_api;
  // bus
  struct DBusConnection *bus;
  // error
  signed int error;
  // state
  enum anonymous_11 state;
  // flags
  enum anonymous_39 flags;
  // version_string
  char *version_string;
  // host_name
  char *host_name;
  // host_name_fqdn
  char *host_name_fqdn;
  // domain_name
  char *domain_name;
  // local_service_cookie
  unsigned int local_service_cookie;
  // local_service_cookie_valid
  signed int local_service_cookie_valid;
  // callback
  void (*callback)(struct AvahiClient *, enum anonymous_11, void *);
  // userdata
  void *userdata;
  // groups
  struct AvahiEntryGroup *groups;
  // domain_browsers
  struct AvahiDomainBrowser *domain_browsers;
  // service_browsers
  struct AvahiServiceBrowser *service_browsers;
  // service_type_browsers
  struct AvahiServiceTypeBrowser *service_type_browsers;
  // service_resolvers
  struct AvahiServiceResolver *service_resolvers;
  // host_name_resolvers
  struct AvahiHostNameResolver *host_name_resolvers;
  // address_resolvers
  struct AvahiAddressResolver *address_resolvers;
  // record_browsers
  struct AvahiRecordBrowser *record_browsers;
};

struct AvahiDomainBrowser
{
  // ref
  signed int ref;
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous_14, const char *, enum anonymous_13, void *);
  // userdata
  void *userdata;
  // domain_browsers_next
  struct AvahiDomainBrowser *domain_browsers_next;
  // domain_browsers_prev
  struct AvahiDomainBrowser *domain_browsers_prev;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
  // defer_timeout
  struct AvahiTimeout_1 *defer_timeout;
  // static_browse_domains
  struct AvahiStringList *static_browse_domains;
};

struct AvahiEntryGroup
{
  // path
  char *path;
  // state
  enum anonymous_40 state;
  // state_valid
  signed int state_valid;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiEntryGroup *, enum anonymous_40, void *);
  // userdata
  void *userdata;
  // groups_next
  struct AvahiEntryGroup *groups_next;
  // groups_prev
  struct AvahiEntryGroup *groups_prev;
};

struct _GSource
{
  // callback_data
  void *callback_data;
  // callback_funcs
  struct _GSourceCallbackFuncs *callback_funcs;
  // source_funcs
  const struct _GSourceFuncs *source_funcs;
  // ref_count
  unsigned int ref_count;
  // context
  struct _GMainContext *context;
  // priority
  signed int priority;
  // flags
  unsigned int flags;
  // source_id
  unsigned int source_id;
  // poll_fds
  struct _GSList *poll_fds;
  // prev
  struct _GSource *prev;
  // next
  struct _GSource *next;
  // name
  char *name;
  // priv
  struct _GSourcePrivate *priv;
};

struct AvahiPoll
{
  // userdata
  void *userdata;
  // watch_new
  struct AvahiWatch_0 * (*watch_new)(const struct AvahiPoll *, signed int, enum anonymous, void (*)(struct AvahiWatch_0 *, signed int, enum anonymous, void *), void *);
  // watch_update
  void (*watch_update)(struct AvahiWatch_0 *, enum anonymous);
  // watch_get_events
  enum anonymous (*watch_get_events)(struct AvahiWatch_0 *);
  // watch_free
  void (*watch_free)(struct AvahiWatch_0 *);
  // timeout_new
  struct AvahiTimeout * (*timeout_new)(const struct AvahiPoll *, struct timeval *, void (*)(struct AvahiTimeout *, void *), void *);
  // timeout_update
  void (*timeout_update)(struct AvahiTimeout *, struct timeval *);
  // timeout_free
  void (*timeout_free)(struct AvahiTimeout *);
};

struct AvahiGLibPoll
{
  // source
  struct _GSource source;
  // api
  struct AvahiPoll api;
  // context
  struct _GMainContext *context;
  // timeout_req_cleanup
  signed int timeout_req_cleanup;
  // watch_req_cleanup
  signed int watch_req_cleanup;
  // watches
  struct AvahiWatch_0 *watches;
  // timeouts
  struct AvahiTimeout *timeouts;
};

struct AvahiHostNameResolver
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous_12, const char *, const struct AvahiAddress *, enum anonymous_13, void *);
  // userdata
  void *userdata;
  // host_name_resolvers_next
  struct AvahiHostNameResolver *host_name_resolvers_next;
  // host_name_resolvers_prev
  struct AvahiHostNameResolver *host_name_resolvers_prev;
  // host_name
  char *host_name;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiPoll_1
{
  // userdata
  void *userdata;
  // watch_new
  struct AvahiWatch_1 * (*watch_new)(const struct AvahiPoll_1 *, signed int, enum anonymous, void (*)(struct AvahiWatch_1 *, signed int, enum anonymous, void *), void *);
  // watch_update
  void (*watch_update)(struct AvahiWatch_1 *, enum anonymous);
  // watch_get_events
  enum anonymous (*watch_get_events)(struct AvahiWatch_1 *);
  // watch_free
  void (*watch_free)(struct AvahiWatch_1 *);
  // timeout_new
  struct AvahiTimeout_1 * (*timeout_new)(const struct AvahiPoll_1 *, struct timeval *, void (*)(struct AvahiTimeout_1 *, void *), void *);
  // timeout_update
  void (*timeout_update)(struct AvahiTimeout_1 *, struct timeval *);
  // timeout_free
  void (*timeout_free)(struct AvahiTimeout_1 *);
};

struct AvahiPoll_0
{
  // userdata
  void *userdata;
  // watch_new
  struct AvahiWatch * (*watch_new)(const struct AvahiPoll_0 *, signed int, enum anonymous, void (*)(struct AvahiWatch *, signed int, enum anonymous, void *), void *);
  // watch_update
  void (*watch_update)(struct AvahiWatch *, enum anonymous);
  // watch_get_events
  enum anonymous (*watch_get_events)(struct AvahiWatch *);
  // watch_free
  void (*watch_free)(struct AvahiWatch *);
  // timeout_new
  struct AvahiTimeout_0 * (*timeout_new)(const struct AvahiPoll_0 *, struct timeval *, void (*)(struct AvahiTimeout_0 *, void *), void *);
  // timeout_update
  void (*timeout_update)(struct AvahiTimeout_0 *, struct timeval *);
  // timeout_free
  void (*timeout_free)(struct AvahiTimeout_0 *);
};

struct AvahiRList
{
  // rlist_next
  struct AvahiRList *rlist_next;
  // rlist_prev
  struct AvahiRList *rlist_prev;
  // data
  void *data;
};

struct AvahiRecordBrowser
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous_14, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous_13, void *);
  // userdata
  void *userdata;
  // record_browsers_next
  struct AvahiRecordBrowser *record_browsers_next;
  // record_browsers_prev
  struct AvahiRecordBrowser *record_browsers_prev;
  // name
  char *name;
  // clazz
  unsigned short int clazz;
  // type
  unsigned short int type;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiServiceBrowser
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous_14, const char *, const char *, const char *, enum anonymous_13, void *);
  // userdata
  void *userdata;
  // service_browsers_next
  struct AvahiServiceBrowser *service_browsers_next;
  // service_browsers_prev
  struct AvahiServiceBrowser *service_browsers_prev;
  // type
  char *type;
  // domain
  char *domain;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiServiceResolver
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiServiceResolver *, signed int, signed int, enum anonymous_12, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous_13, void *);
  // userdata
  void *userdata;
  // service_resolvers_next
  struct AvahiServiceResolver *service_resolvers_next;
  // service_resolvers_prev
  struct AvahiServiceResolver *service_resolvers_prev;
  // name
  char *name;
  // type
  char *type;
  // domain
  char *domain;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiServiceTypeBrowser
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous_14, const char *, const char *, enum anonymous_13, void *);
  // userdata
  void *userdata;
  // service_type_browsers_next
  struct AvahiServiceTypeBrowser *service_type_browsers_next;
  // service_type_browsers_prev
  struct AvahiServiceTypeBrowser *service_type_browsers_prev;
  // domain
  char *domain;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiSimplePoll_0
{
  // api
  struct AvahiPoll_1 api;
  // poll_func
  signed int (*poll_func)(struct pollfd *, unsigned int, signed int, void *);
  // poll_func_userdata
  void *poll_func_userdata;
  // pollfds
  struct pollfd *pollfds;
  // n_pollfds
  signed int n_pollfds;
  // max_pollfds
  signed int max_pollfds;
  // rebuild_pollfds
  signed int rebuild_pollfds;
  // watch_req_cleanup
  signed int watch_req_cleanup;
  // timeout_req_cleanup
  signed int timeout_req_cleanup;
  // quit
  signed int quit;
  // events_valid
  signed int events_valid;
  // n_watches
  signed int n_watches;
  // watches
  struct AvahiWatch_1 *watches;
  // timeouts
  struct AvahiTimeout_1 *timeouts;
  // wakeup_pipe
  signed int wakeup_pipe[2l];
  // wakeup_issued
  signed int wakeup_issued;
  // prepared_timeout
  signed int prepared_timeout;
  // state
  enum anonymous_31 state;
};

struct AvahiSimplePoll
{
  // api
  struct AvahiPoll_0 api;
  // poll_func
  signed int (*poll_func)(struct pollfd *, unsigned int, signed int, void *);
  // poll_func_userdata
  void *poll_func_userdata;
  // pollfds
  struct pollfd *pollfds;
  // n_pollfds
  signed int n_pollfds;
  // max_pollfds
  signed int max_pollfds;
  // rebuild_pollfds
  signed int rebuild_pollfds;
  // watch_req_cleanup
  signed int watch_req_cleanup;
  // timeout_req_cleanup
  signed int timeout_req_cleanup;
  // quit
  signed int quit;
  // events_valid
  signed int events_valid;
  // n_watches
  signed int n_watches;
  // watches
  struct AvahiWatch *watches;
  // timeouts
  struct AvahiTimeout_0 *timeouts;
  // wakeup_pipe
  signed int wakeup_pipe[2l];
  // wakeup_issued
  signed int wakeup_issued;
  // prepared_timeout
  signed int prepared_timeout;
  // state
  enum anonymous_31 state;
};

struct AvahiStringList
{
  // next
  struct AvahiStringList *next;
  // size
  unsigned long int size;
  // text
  unsigned char text[1l];
};

struct AvahiThreadedPoll_0
{
  // simple_poll
  struct AvahiSimplePoll_0 *simple_poll;
  // thread_id
  unsigned long int thread_id;
  // mutex
  union anonymous_6 mutex;
  // thread_running
  signed int thread_running;
  // retval
  signed int retval;
};

struct AvahiThreadedPoll
{
  // simple_poll
  struct AvahiSimplePoll *simple_poll;
  // thread_id
  unsigned long int thread_id;
  // mutex
  union anonymous_6 mutex;
  // thread_running
  signed int thread_running;
  // retval
  signed int retval;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct AvahiTimeout_1
{
  // simple_poll
  struct AvahiSimplePoll_0 *simple_poll;
  // dead
  signed int dead;
  // enabled
  signed int enabled;
  // expiry
  struct timeval expiry;
  // callback
  void (*callback)(struct AvahiTimeout_1 *, void *);
  // userdata
  void *userdata;
  // timeouts_next
  struct AvahiTimeout_1 *timeouts_next;
  // timeouts_prev
  struct AvahiTimeout_1 *timeouts_prev;
};

struct AvahiTimeout_0
{
  // simple_poll
  struct AvahiSimplePoll *simple_poll;
  // dead
  signed int dead;
  // enabled
  signed int enabled;
  // expiry
  struct timeval expiry;
  // callback
  void (*callback)(struct AvahiTimeout_0 *, void *);
  // userdata
  void *userdata;
  // timeouts_next
  struct AvahiTimeout_0 *timeouts_next;
  // timeouts_prev
  struct AvahiTimeout_0 *timeouts_prev;
};

struct AvahiTimeout
{
  // glib_poll
  struct AvahiGLibPoll *glib_poll;
  // dead
  signed int dead;
  // enabled
  signed int enabled;
  // expiry
  struct timeval expiry;
  // callback
  void (*callback)(struct AvahiTimeout *, void *);
  // userdata
  void *userdata;
  // timeouts_next
  struct AvahiTimeout *timeouts_next;
  // timeouts_prev
  struct AvahiTimeout *timeouts_prev;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

struct AvahiWatch_1
{
  // simple_poll
  struct AvahiSimplePoll_0 *simple_poll;
  // dead
  signed int dead;
  // idx
  signed int idx;
  // pollfd
  struct pollfd pollfd;
  // callback
  void (*callback)(struct AvahiWatch_1 *, signed int, enum anonymous, void *);
  // userdata
  void *userdata;
  // watches_next
  struct AvahiWatch_1 *watches_next;
  // watches_prev
  struct AvahiWatch_1 *watches_prev;
};

struct AvahiWatch
{
  // simple_poll
  struct AvahiSimplePoll *simple_poll;
  // dead
  signed int dead;
  // idx
  signed int idx;
  // pollfd
  struct pollfd pollfd;
  // callback
  void (*callback)(struct AvahiWatch *, signed int, enum anonymous, void *);
  // userdata
  void *userdata;
  // watches_next
  struct AvahiWatch *watches_next;
  // watches_prev
  struct AvahiWatch *watches_prev;
};

struct _GPollFD
{
  // fd
  signed int fd;
  // events
  unsigned short int events;
  // revents
  unsigned short int revents;
};

struct AvahiWatch_0
{
  // glib_poll
  struct AvahiGLibPoll *glib_poll;
  // dead
  signed int dead;
  // pollfd
  struct _GPollFD pollfd;
  // pollfd_added
  signed int pollfd_added;
  // callback
  void (*callback)(struct AvahiWatch_0 *, signed int, enum anonymous, void *);
  // userdata
  void *userdata;
  // watches_next
  struct AvahiWatch_0 *watches_next;
  // watches_prev
  struct AvahiWatch_0 *watches_prev;
};

struct Config
{
  // domain
  char *domain;
  // command
  enum anonymous_9 command;
};

struct DBusError
{
  // name
  const char *name;
  // message
  const char *message;
  // dummy1
  unsigned int dummy1 : 1;
  // dummy2
  unsigned int dummy2 : 1;
  // dummy3
  unsigned int dummy3 : 1;
  // dummy4
  unsigned int dummy4 : 1;
  // dummy5
  unsigned int dummy5 : 1;
  // padding1
  void *padding1;
};

struct DBusMessageIter
{
  // dummy1
  void *dummy1;
  // dummy2
  void *dummy2;
  // dummy3
  unsigned int dummy3;
  // dummy4
  signed int dummy4;
  // dummy5
  signed int dummy5;
  // dummy6
  signed int dummy6;
  // dummy7
  signed int dummy7;
  // dummy8
  signed int dummy8;
  // dummy9
  signed int dummy9;
  // dummy10
  signed int dummy10;
  // dummy11
  signed int dummy11;
  // pad1
  signed int pad1;
  // pad2
  signed int pad2;
  // pad3
  void *pad3;
};

struct TimeoutData
{
  // poll_api
  const struct AvahiPoll_1 *poll_api;
  // avahi_timeout
  struct AvahiTimeout_1 *avahi_timeout;
  // dbus_timeout
  struct DBusTimeout *dbus_timeout;
  // ref
  signed int ref;
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _AtkObject
{
  // parent
  struct _GObject parent;
  // description
  char *description;
  // name
  char *name;
  // accessible_parent
  struct _AtkObject *accessible_parent;
  // role
  enum anonymous_24 role;
  // relation_set
  struct _AtkRelationSet *relation_set;
  // layer
  enum anonymous_25 layer;
};

struct _AtkRelationSet
{
  // parent
  struct _GObject parent;
  // relations
  struct _GPtrArray *relations;
};

struct _GtkWidget
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkWidgetPrivate *priv;
};

struct _GtkContainer
{
  // widget
  struct _GtkWidget widget;
  // priv
  struct _GtkContainerPrivate *priv;
};

struct _GtkBin
{
  // container
  struct _GtkContainer container;
  // priv
  struct _GtkBinPrivate *priv;
};

struct _GtkWindow
{
  // bin
  struct _GtkBin bin;
  // priv
  struct _GtkWindowPrivate *priv;
};

struct _GtkDialog
{
  // window
  struct _GtkWindow window;
  // priv
  struct _GtkDialogPrivate *priv;
};

struct _AuiServiceDialog
{
  // parent_instance
  struct _GtkDialog parent_instance;
  // priv
  struct _AuiServiceDialogPrivate *priv;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GObjectClass
{
  // g_type_class
  struct _GTypeClass g_type_class;
  // construct_properties
  struct _GSList *construct_properties;
  // constructor
  struct _GObject * (*constructor)(unsigned long int, unsigned int, struct _GObjectConstructParam *);
  // set_property
  void (*set_property)(struct _GObject *, unsigned int, const struct _GValue *, struct _GParamSpec *);
  // get_property
  void (*get_property)(struct _GObject *, unsigned int, struct _GValue *, struct _GParamSpec *);
  // dispose
  void (*dispose)(struct _GObject *);
  // finalize
  void (*finalize)(struct _GObject *);
  // dispatch_properties_changed
  void (*dispatch_properties_changed)(struct _GObject *, unsigned int, struct _GParamSpec **);
  // notify
  void (*notify)(struct _GObject *, struct _GParamSpec *);
  // constructed
  void (*constructed)(struct _GObject *);
  // flags
  unsigned long int flags;
  // pdummy
  void *pdummy[6l];
};

struct _GtkWidgetClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // activate_signal
  unsigned int activate_signal;
  // dispatch_child_properties_changed
  void (*dispatch_child_properties_changed)(struct _GtkWidget *, unsigned int, struct _GParamSpec **);
  // destroy
  void (*destroy)(struct _GtkWidget *);
  // show
  void (*show)(struct _GtkWidget *);
  // show_all
  void (*show_all)(struct _GtkWidget *);
  // hide
  void (*hide)(struct _GtkWidget *);
  // map
  void (*map)(struct _GtkWidget *);
  // unmap
  void (*unmap)(struct _GtkWidget *);
  // realize
  void (*realize)(struct _GtkWidget *);
  // unrealize
  void (*unrealize)(struct _GtkWidget *);
  // size_allocate
  void (*size_allocate)(struct _GtkWidget *, struct _cairo_rectangle_int *);
  // state_changed
  void (*state_changed)(struct _GtkWidget *, enum anonymous_18);
  // state_flags_changed
  void (*state_flags_changed)(struct _GtkWidget *, enum anonymous_19);
  // parent_set
  void (*parent_set)(struct _GtkWidget *, struct _GtkWidget *);
  // hierarchy_changed
  void (*hierarchy_changed)(struct _GtkWidget *, struct _GtkWidget *);
  // style_set
  void (*style_set)(struct _GtkWidget *, struct _GtkStyle *);
  // direction_changed
  void (*direction_changed)(struct _GtkWidget *, enum anonymous_20);
  // grab_notify
  void (*grab_notify)(struct _GtkWidget *, signed int);
  // child_notify
  void (*child_notify)(struct _GtkWidget *, struct _GParamSpec *);
  // draw
  signed int (*draw)(struct _GtkWidget *, struct _cairo *);
  // get_request_mode
  enum anonymous_21 (*get_request_mode)(struct _GtkWidget *);
  // get_preferred_height
  void (*get_preferred_height)(struct _GtkWidget *, signed int *, signed int *);
  // get_preferred_width_for_height
  void (*get_preferred_width_for_height)(struct _GtkWidget *, signed int, signed int *, signed int *);
  // get_preferred_width
  void (*get_preferred_width)(struct _GtkWidget *, signed int *, signed int *);
  // get_preferred_height_for_width
  void (*get_preferred_height_for_width)(struct _GtkWidget *, signed int, signed int *, signed int *);
  // mnemonic_activate
  signed int (*mnemonic_activate)(struct _GtkWidget *, signed int);
  // grab_focus
  void (*grab_focus)(struct _GtkWidget *);
  // focus
  signed int (*focus)(struct _GtkWidget *, enum anonymous_22);
  // move_focus
  void (*move_focus)(struct _GtkWidget *, enum anonymous_22);
  // keynav_failed
  signed int (*keynav_failed)(struct _GtkWidget *, enum anonymous_22);
  // event
  signed int (*event)(struct _GtkWidget *, union _GdkEvent *);
  // button_press_event
  signed int (*button_press_event)(struct _GtkWidget *, struct _GdkEventButton *);
  // button_release_event
  signed int (*button_release_event)(struct _GtkWidget *, struct _GdkEventButton *);
  // scroll_event
  signed int (*scroll_event)(struct _GtkWidget *, struct _GdkEventScroll *);
  // motion_notify_event
  signed int (*motion_notify_event)(struct _GtkWidget *, struct _GdkEventMotion *);
  // delete_event
  signed int (*delete_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // destroy_event
  signed int (*destroy_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // key_press_event
  signed int (*key_press_event)(struct _GtkWidget *, struct _GdkEventKey *);
  // key_release_event
  signed int (*key_release_event)(struct _GtkWidget *, struct _GdkEventKey *);
  // enter_notify_event
  signed int (*enter_notify_event)(struct _GtkWidget *, struct _GdkEventCrossing *);
  // leave_notify_event
  signed int (*leave_notify_event)(struct _GtkWidget *, struct _GdkEventCrossing *);
  // configure_event
  signed int (*configure_event)(struct _GtkWidget *, struct _GdkEventConfigure *);
  // focus_in_event
  signed int (*focus_in_event)(struct _GtkWidget *, struct _GdkEventFocus *);
  // focus_out_event
  signed int (*focus_out_event)(struct _GtkWidget *, struct _GdkEventFocus *);
  // map_event
  signed int (*map_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // unmap_event
  signed int (*unmap_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // property_notify_event
  signed int (*property_notify_event)(struct _GtkWidget *, struct _GdkEventProperty *);
  // selection_clear_event
  signed int (*selection_clear_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // selection_request_event
  signed int (*selection_request_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // selection_notify_event
  signed int (*selection_notify_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // proximity_in_event
  signed int (*proximity_in_event)(struct _GtkWidget *, struct _GdkEventProximity *);
  // proximity_out_event
  signed int (*proximity_out_event)(struct _GtkWidget *, struct _GdkEventProximity *);
  // visibility_notify_event
  signed int (*visibility_notify_event)(struct _GtkWidget *, struct _GdkEventVisibility *);
  // window_state_event
  signed int (*window_state_event)(struct _GtkWidget *, struct _GdkEventWindowState *);
  // damage_event
  signed int (*damage_event)(struct _GtkWidget *, struct _GdkEventExpose *);
  // grab_broken_event
  signed int (*grab_broken_event)(struct _GtkWidget *, struct _GdkEventGrabBroken *);
  // selection_get
  void (*selection_get)(struct _GtkWidget *, struct _GtkSelectionData *, unsigned int, unsigned int);
  // selection_received
  void (*selection_received)(struct _GtkWidget *, struct _GtkSelectionData *, unsigned int);
  // drag_begin
  void (*drag_begin)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_end
  void (*drag_end)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_data_get
  void (*drag_data_get)(struct _GtkWidget *, struct _GdkDragContext *, struct _GtkSelectionData *, unsigned int, unsigned int);
  // drag_data_delete
  void (*drag_data_delete)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_leave
  void (*drag_leave)(struct _GtkWidget *, struct _GdkDragContext *, unsigned int);
  // drag_motion
  signed int (*drag_motion)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, unsigned int);
  // drag_drop
  signed int (*drag_drop)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, unsigned int);
  // drag_data_received
  void (*drag_data_received)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, struct _GtkSelectionData *, unsigned int, unsigned int);
  // drag_failed
  signed int (*drag_failed)(struct _GtkWidget *, struct _GdkDragContext *, enum anonymous_23);
  // popup_menu
  signed int (*popup_menu)(struct _GtkWidget *);
  // show_help
  signed int (*show_help)(struct _GtkWidget *, enum anonymous_26);
  // get_accessible
  struct _AtkObject * (*get_accessible)(struct _GtkWidget *);
  // screen_changed
  void (*screen_changed)(struct _GtkWidget *, struct _GdkScreen *);
  // can_activate_accel
  signed int (*can_activate_accel)(struct _GtkWidget *, unsigned int);
  // composited_changed
  void (*composited_changed)(struct _GtkWidget *);
  // query_tooltip
  signed int (*query_tooltip)(struct _GtkWidget *, signed int, signed int, signed int, struct _GtkTooltip *);
  // compute_expand
  void (*compute_expand)(struct _GtkWidget *, signed int *, signed int *);
  // adjust_size_request
  void (*adjust_size_request)(struct _GtkWidget *, enum anonymous_16, signed int *, signed int *);
  // adjust_size_allocation
  void (*adjust_size_allocation)(struct _GtkWidget *, enum anonymous_16, signed int *, signed int *, signed int *, signed int *);
  // style_updated
  void (*style_updated)(struct _GtkWidget *);
  // touch_event
  signed int (*touch_event)(struct _GtkWidget *, struct _GdkEventTouch *);
  // get_preferred_height_and_baseline_for_width
  void (*get_preferred_height_and_baseline_for_width)(struct _GtkWidget *, signed int, signed int *, signed int *, signed int *, signed int *);
  // adjust_baseline_request
  void (*adjust_baseline_request)(struct _GtkWidget *, signed int *, signed int *);
  // adjust_baseline_allocation
  void (*adjust_baseline_allocation)(struct _GtkWidget *, signed int *);
  // queue_draw_region
  void (*queue_draw_region)(struct _GtkWidget *, const struct _cairo_region *);
  // priv
  struct _GtkWidgetClassPrivate *priv;
  // _gtk_reserved6
  void (*_gtk_reserved6)(void);
  // _gtk_reserved7
  void (*_gtk_reserved7)(void);
};

struct _GtkContainerClass
{
  // parent_class
  struct _GtkWidgetClass parent_class;
  // add
  void (*add)(struct _GtkContainer *, struct _GtkWidget *);
  // remove
  void (*remove)(struct _GtkContainer *, struct _GtkWidget *);
  // check_resize
  void (*check_resize)(struct _GtkContainer *);
  // forall
  void (*forall)(struct _GtkContainer *, signed int, void (*)(struct _GtkWidget *, void *), void *);
  // set_focus_child
  void (*set_focus_child)(struct _GtkContainer *, struct _GtkWidget *);
  // child_type
  unsigned long int (*child_type)(struct _GtkContainer *);
  // composite_name
  char * (*composite_name)(struct _GtkContainer *, struct _GtkWidget *);
  // set_child_property
  void (*set_child_property)(struct _GtkContainer *, struct _GtkWidget *, unsigned int, const struct _GValue *, struct _GParamSpec *);
  // get_child_property
  void (*get_child_property)(struct _GtkContainer *, struct _GtkWidget *, unsigned int, struct _GValue *, struct _GParamSpec *);
  // get_path_for_child
  struct _GtkWidgetPath * (*get_path_for_child)(struct _GtkContainer *, struct _GtkWidget *);
  // _handle_border_width
  unsigned int _handle_border_width : 1;
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
  // _gtk_reserved5
  void (*_gtk_reserved5)(void);
  // _gtk_reserved6
  void (*_gtk_reserved6)(void);
  // _gtk_reserved7
  void (*_gtk_reserved7)(void);
  // _gtk_reserved8
  void (*_gtk_reserved8)(void);
};

struct _GtkBinClass
{
  // parent_class
  struct _GtkContainerClass parent_class;
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
};

struct _GtkWindowClass
{
  // parent_class
  struct _GtkBinClass parent_class;
  // set_focus
  void (*set_focus)(struct _GtkWindow *, struct _GtkWidget *);
  // activate_focus
  void (*activate_focus)(struct _GtkWindow *);
  // activate_default
  void (*activate_default)(struct _GtkWindow *);
  // keys_changed
  void (*keys_changed)(struct _GtkWindow *);
  // enable_debugging
  signed int (*enable_debugging)(struct _GtkWindow *, signed int);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
};

struct _GtkDialogClass
{
  // parent_class
  struct _GtkWindowClass parent_class;
  // response
  void (*response)(struct _GtkDialog *, signed int);
  // close
  void (*close)(struct _GtkDialog *);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
};

struct _AuiServiceDialogClass
{
  // parent_class
  struct _GtkDialogClass parent_class;
  // _aui_reserved1
  void (*_aui_reserved1)(void);
  // _aui_reserved2
  void (*_aui_reserved2)(void);
  // _aui_reserved3
  void (*_aui_reserved3)(void);
  // _aui_reserved4
  void (*_aui_reserved4)(void);
};

struct _AuiServiceDialogPrivate
{
  // glib_poll
  struct AvahiGLibPoll *glib_poll;
  // client
  struct AvahiClient *client;
  // browsers
  struct AvahiServiceBrowser **browsers;
  // resolver
  struct AvahiServiceResolver *resolver;
  // domain_browser
  struct AvahiDomainBrowser *domain_browser;
  // browse_service_types
  char **browse_service_types;
  // service_type
  char *service_type;
  // domain
  char *domain;
  // service_name
  char *service_name;
  // address_family
  signed int address_family;
  // address
  struct AvahiAddress address;
  // host_name
  char *host_name;
  // txt_data
  struct AvahiStringList *txt_data;
  // port
  unsigned short int port;
  // resolve_service
  signed int resolve_service;
  // resolve_service_done
  signed int resolve_service_done;
  // resolve_host_name
  signed int resolve_host_name;
  // resolve_host_name_done
  signed int resolve_host_name_done;
  // domain_label
  struct _GtkWidget *domain_label;
  // domain_button
  struct _GtkWidget *domain_button;
  // service_tree_view
  struct _GtkWidget *service_tree_view;
  // service_progress_bar
  struct _GtkWidget *service_progress_bar;
  // service_list_store
  struct _GtkListStore *service_list_store;
  // domain_list_store
  struct _GtkListStore *domain_list_store;
  // service_type_names
  struct _GHashTable *service_type_names;
  // service_pulse_timeout
  unsigned int service_pulse_timeout;
  // domain_pulse_timeout
  unsigned int domain_pulse_timeout;
  // start_idle
  unsigned int start_idle;
  // common_interface
  signed int common_interface;
  // common_protocol
  signed int common_protocol;
  // domain_dialog
  struct _GtkWidget *domain_dialog;
  // domain_entry
  struct _GtkWidget *domain_entry;
  // domain_tree_view
  struct _GtkWidget *domain_tree_view;
  // domain_progress_bar
  struct _GtkWidget *domain_progress_bar;
  // domain_ok_button
  struct _GtkWidget *domain_ok_button;
  // forward_response_id
  signed int forward_response_id;
};

struct _GArray
{
  // data
  char *data;
  // len
  unsigned int len;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GObjectConstructParam
{
  // pspec
  struct _GParamSpec *pspec;
  // value
  struct _GValue *value;
};

struct _GParamSpec
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // name
  const char *name;
  // flags
  enum anonymous_35 flags;
  // value_type
  unsigned long int value_type;
  // owner_type
  unsigned long int owner_type;
  // _nick
  char *_nick;
  // _blurb
  char *_blurb;
  // qdata
  struct _GData *qdata;
  // ref_count
  unsigned int ref_count;
  // param_id
  unsigned int param_id;
};

struct _GPtrArray
{
  // pdata
  void **pdata;
  // len
  unsigned int len;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GSourceCallbackFuncs
{
  // ref
  void (*ref)(void *);
  // unref
  void (*unref)(void *);
  // get
  void (*get)(void *, struct _GSource *, signed int (**)(void *), void **);
};

struct _GSourceFuncs
{
  // prepare
  signed int (*prepare)(struct _GSource *, signed int *);
  // check
  signed int (*check)(struct _GSource *);
  // dispatch
  signed int (*dispatch)(struct _GSource *, signed int (*)(void *), void *);
  // finalize
  void (*finalize)(struct _GSource *);
  // closure_callback
  signed int (*closure_callback)(void *);
  // closure_marshal
  void (*closure_marshal)(void);
};

struct _GTimeVal
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous_54 data[2l];
};

struct _GdkColor
{
  // pixel
  unsigned int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GdkEventAny
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
};

struct _cairo_rectangle_int
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventExpose
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // area
  struct _cairo_rectangle_int area;
  // region
  struct _cairo_region *region;
  // count
  signed int count;
};

struct _GdkEventVisibility
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // state
  enum anonymous_47 state;
};

struct _GdkEventMotion
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // is_hint
  signed short int is_hint;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventButton
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventTouch
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // sequence
  struct _GdkEventSequence *sequence;
  // emulating_pointer
  signed int emulating_pointer;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventScroll
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // state
  unsigned int state;
  // direction
  enum anonymous_48 direction;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // delta_x
  double delta_x;
  // delta_y
  double delta_y;
};

struct _GdkEventKey
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // state
  unsigned int state;
  // keyval
  unsigned int keyval;
  // length
  signed int length;
  // string
  char *string;
  // hardware_keycode
  unsigned short int hardware_keycode;
  // group
  unsigned char group;
  // is_modifier
  unsigned int is_modifier : 1;
};

struct _GdkEventCrossing
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // subwindow
  struct _GdkWindow *subwindow;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // mode
  enum anonymous_49 mode;
  // detail
  enum anonymous_50 detail;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct _GdkEventFocus
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // in
  signed short int in;
};

struct _GdkEventConfigure
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventProperty
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // atom
  struct _GdkAtom *atom;
  // time
  unsigned int time;
  // state
  unsigned int state;
};

struct _GdkEventSelection
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // property
  struct _GdkAtom *property;
  // time
  unsigned int time;
  // requestor
  struct _GdkWindow *requestor;
};

struct _GdkEventOwnerChange
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // owner
  struct _GdkWindow *owner;
  // reason
  enum anonymous_51 reason;
  // selection
  struct _GdkAtom *selection;
  // time
  unsigned int time;
  // selection_time
  unsigned int selection_time;
};

struct _GdkEventProximity
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // device
  struct _GdkDevice *device;
};

struct _GdkEventDND
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // context
  struct _GdkDragContext *context;
  // time
  unsigned int time;
  // x_root
  signed short int x_root;
  // y_root
  signed short int y_root;
};

struct _GdkEventWindowState
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // changed_mask
  enum anonymous_52 changed_mask;
  // new_window_state
  enum anonymous_52 new_window_state;
};

struct _GdkEventSetting
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // action
  enum anonymous_53 action;
  // name
  char *name;
};

struct _GdkEventGrabBroken
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // keyboard
  signed int keyboard;
  // implicit
  signed int implicit;
  // grab_window
  struct _GdkWindow *grab_window;
};

struct _GdkEventTouchpadSwipe
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // phase
  signed char phase;
  // n_fingers
  signed char n_fingers;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // dx
  double dx;
  // dy
  double dy;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // state
  unsigned int state;
};

struct _GdkEventTouchpadPinch
{
  // type
  enum anonymous_46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // phase
  signed char phase;
  // n_fingers
  signed char n_fingers;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // dx
  double dx;
  // dy
  double dy;
  // angle_delta
  double angle_delta;
  // scale
  double scale;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // state
  unsigned int state;
};

union _GdkEvent
{
  // type
  enum anonymous_46 type;
  // any
  struct _GdkEventAny any;
  // expose
  struct _GdkEventExpose expose;
  // visibility
  struct _GdkEventVisibility visibility;
  // motion
  struct _GdkEventMotion motion;
  // button
  struct _GdkEventButton button;
  // touch
  struct _GdkEventTouch touch;
  // scroll
  struct _GdkEventScroll scroll;
  // key
  struct _GdkEventKey key;
  // crossing
  struct _GdkEventCrossing crossing;
  // focus_change
  struct _GdkEventFocus focus_change;
  // configure
  struct _GdkEventConfigure configure;
  // property
  struct _GdkEventProperty property;
  // selection
  struct _GdkEventSelection selection;
  // owner_change
  struct _GdkEventOwnerChange owner_change;
  // proximity
  struct _GdkEventProximity proximity;
  // dnd
  struct _GdkEventDND dnd;
  // window_state
  struct _GdkEventWindowState window_state;
  // setting
  struct _GdkEventSetting setting;
  // grab_broken
  struct _GdkEventGrabBroken grab_broken;
  // touchpad_swipe
  struct _GdkEventTouchpadSwipe touchpad_swipe;
  // touchpad_pinch
  struct _GdkEventTouchpadPinch touchpad_pinch;
};

struct _GtkAdjustment
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkAdjustmentPrivate *priv;
};

struct _GtkBox
{
  // container
  struct _GtkContainer container;
  // priv
  struct _GtkBoxPrivate *priv;
};

struct _GtkButton
{
  // bin
  struct _GtkBin bin;
  // priv
  struct _GtkButtonPrivate *priv;
};

struct _GtkButtonBox
{
  // box
  struct _GtkBox box;
  // priv
  struct _GtkButtonBoxPrivate *priv;
};

struct _GtkCellRenderer
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkCellRendererPrivate *priv;
};

struct _GtkEntry
{
  // parent_instance
  struct _GtkWidget parent_instance;
  // priv
  struct _GtkEntryPrivate *priv;
};

struct _GtkMisc
{
  // widget
  struct _GtkWidget widget;
  // priv
  struct _GtkMiscPrivate *priv;
};

struct _GtkLabel
{
  // misc
  struct _GtkMisc misc;
  // priv
  struct _GtkLabelPrivate *priv;
};

struct _GtkListStore
{
  // parent
  struct _GObject parent;
  // priv
  struct _GtkListStorePrivate *priv;
};

struct _GtkProgressBar
{
  // parent
  struct _GtkWidget parent;
  // priv
  struct _GtkProgressBarPrivate *priv;
};

struct _GtkRcStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // bg_pixmap_name
  char *bg_pixmap_name[5l];
  // font_desc
  struct _PangoFontDescription *font_desc;
  // color_flags
  enum anonymous_33 color_flags[5l];
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // rc_properties
  struct _GArray *rc_properties;
  // rc_style_lists
  struct _GSList *rc_style_lists;
  // icon_factories
  struct _GSList *icon_factories;
  // engine_specified
  unsigned int engine_specified : 1;
};

struct _GtkScrolledWindow
{
  // container
  struct _GtkBin container;
  // priv
  struct _GtkScrolledWindowPrivate *priv;
};

struct _GtkStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // light
  struct _GdkColor light[5l];
  // dark
  struct _GdkColor dark[5l];
  // mid
  struct _GdkColor mid[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // text_aa
  struct _GdkColor text_aa[5l];
  // black
  struct _GdkColor black;
  // white
  struct _GdkColor white;
  // font_desc
  struct _PangoFontDescription *font_desc;
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // background
  struct _cairo_pattern *background[5l];
  // attach_count
  signed int attach_count;
  // visual
  struct _GdkVisual *visual;
  // private_font_desc
  struct _PangoFontDescription *private_font_desc;
  // rc_style
  struct _GtkRcStyle *rc_style;
  // styles
  struct _GSList *styles;
  // property_cache
  struct _GArray *property_cache;
  // icon_factories
  struct _GSList *icon_factories;
};

struct _GtkTreeIter
{
  // stamp
  signed int stamp;
  // user_data
  void *user_data;
  // user_data2
  void *user_data2;
  // user_data3
  void *user_data3;
};

struct _GtkTreeSelection
{
  // parent
  struct _GObject parent;
  // priv
  struct _GtkTreeSelectionPrivate *priv;
};

struct _GtkTreeView
{
  // parent
  struct _GtkContainer parent;
  // priv
  struct _GtkTreeViewPrivate *priv;
};

struct _GtkTreeViewColumn
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkTreeViewColumnPrivate *priv;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct error_map
{
  // dbus_error
  const char *dbus_error;
  // avahi_error
  signed int avahi_error;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// AuiServiceDialog_private_offset
// file avahi-ui.c line 169
static signed int AuiServiceDialog_private_offset;
// allocator
// file malloc.c line 40
static const struct AvahiAllocator *allocator = (const struct AvahiAllocator *)(void *)0;
// allocator_link1
// file malloc.c line 40
static const struct AvahiAllocator *allocator_link1 = (const struct AvahiAllocator *)(void *)0;
// allocator_link1_link1
// file malloc.c line 40
static const struct AvahiAllocator *allocator_link1_link1 = (const struct AvahiAllocator *)(void *)0;
// allocator_link2
// file malloc.c line 40
static const struct AvahiAllocator *allocator_link2 = (const struct AvahiAllocator *)(void *)0;
// allocator_link3
// file malloc.c line 40
static const struct AvahiAllocator *allocator_link3 = (const struct AvahiAllocator *)(void *)0;
// aui_service_dialog_parent_class
// file avahi-ui.c line 169
static void *aui_service_dialog_parent_class = (void *)0;
// buffer
// file ../avahi-utils/stdb.c line 43
static char *buffer = (char *)(void *)0;
// enum_key
// file ../avahi-utils/stdb.c line 44
static char *enum_key = (char *)(void *)0;
// error_map
// file ../avahi-common/dbus.c line 98
static struct error_map error_map[15l] = { { .dbus_error="org.freedesktop.DBus.Error.Failed", .avahi_error=-1 },
    { .dbus_error="org.freedesktop.DBus.Error.NoMemory", .avahi_error=-24 },
    { .dbus_error="org.freedesktop.DBus.Error.ServiceUnknown", .avahi_error=-26 },
    { .dbus_error="org.freedesktop.DBus.Error.BadAddress", .avahi_error=-26 },
    { .dbus_error="org.freedesktop.DBus.Error.NotSupported", .avahi_error=-49 },
    { .dbus_error="org.freedesktop.DBus.Error.LimitsExceeded", .avahi_error=-17 },
    { .dbus_error="org.freedesktop.DBus.Error.AccessDenied", .avahi_error=-20 },
    { .dbus_error="org.freedesktop.DBus.Error.AuthFailed", .avahi_error=-20 },
    { .dbus_error="org.freedesktop.DBus.Error.NoServer", .avahi_error=-26 },
    { .dbus_error="org.freedesktop.DBus.Error.Timeout", .avahi_error=-15 },
    { .dbus_error="org.freedesktop.DBus.Error.NoNetwork", .avahi_error=-5 },
    { .dbus_error="org.freedesktop.DBus.Error.Disconnected", .avahi_error=-23 },
    { .dbus_error="org.freedesktop.DBus.Error.InvalidArgs", .avahi_error=-51 },
    { .dbus_error="org.freedesktop.DBus.Error.TimedOut", .avahi_error=-15 },
    { .dbus_error=(const char *)(void *)0, .avahi_error=0 } };
// error_map_link1
// file ../avahi-common/dbus.c line 98
static struct error_map error_map_link1[15l] = { { .dbus_error="org.freedesktop.DBus.Error.Failed", .avahi_error=-1 },
    { .dbus_error="org.freedesktop.DBus.Error.NoMemory", .avahi_error=-24 },
    { .dbus_error="org.freedesktop.DBus.Error.ServiceUnknown", .avahi_error=-26 },
    { .dbus_error="org.freedesktop.DBus.Error.BadAddress", .avahi_error=-26 },
    { .dbus_error="org.freedesktop.DBus.Error.NotSupported", .avahi_error=-49 },
    { .dbus_error="org.freedesktop.DBus.Error.LimitsExceeded", .avahi_error=-17 },
    { .dbus_error="org.freedesktop.DBus.Error.AccessDenied", .avahi_error=-20 },
    { .dbus_error="org.freedesktop.DBus.Error.AuthFailed", .avahi_error=-20 },
    { .dbus_error="org.freedesktop.DBus.Error.NoServer", .avahi_error=-26 },
    { .dbus_error="org.freedesktop.DBus.Error.Timeout", .avahi_error=-15 },
    { .dbus_error="org.freedesktop.DBus.Error.NoNetwork", .avahi_error=-5 },
    { .dbus_error="org.freedesktop.DBus.Error.Disconnected", .avahi_error=-23 },
    { .dbus_error="org.freedesktop.DBus.Error.InvalidArgs", .avahi_error=-51 },
    { .dbus_error="org.freedesktop.DBus.Error.TimedOut", .avahi_error=-15 },
    { .dbus_error=(const char *)(void *)0, .avahi_error=0 } };
// gdbm_file
// file ../avahi-utils/stdb.c line 38
static struct anonymous_36 *gdbm_file = (struct anonymous_36 *)(void *)0;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// table
// file ../avahi-common/dbus.c line 31
static const char * const table[54l] = { "org.freedesktop.Avahi.Success", "org.freedesktop.Avahi.Failure", "org.freedesktop.Avahi.BadStateError", "org.freedesktop.Avahi.InvalidHostNameError",
    "org.freedesktop.Avahi.InvalidDomainNameError",
    "org.freedesktop.Avahi.NoNetworkError", "org.freedesktop.Avahi.InvalidTTLError",
    "org.freedesktop.Avahi.IsPatternError", "org.freedesktop.Avahi.CollisionError", "org.freedesktop.Avahi.InvalidRecordError",
    "org.freedesktop.Avahi.InvalidServiceNameError",
    "org.freedesktop.Avahi.InvalidServiceTypeError",
    "org.freedesktop.Avahi.InvalidPortError",
    "org.freedesktop.Avahi.InvalidKeyError",
    "org.freedesktop.Avahi.InvalidAddressError",
    "org.freedesktop.Avahi.TimeoutError", "org.freedesktop.Avahi.TooManyClientsError",
    "org.freedesktop.Avahi.TooManyObjectsError",
    "org.freedesktop.Avahi.TooManyEntriesError",
    "org.freedesktop.Avahi.OSError", "org.freedesktop.DBus.Error.AccessDenied",
    "org.freedesktop.Avahi.InvalidOperationError",
    "org.freedesktop.Avahi.DBusError", "org.freedesktop.Avahi.DisconnectedError",
    "org.freedesktop.Avahi.NoMemoryError", "org.freedesktop.Avahi.InvalidObjectError",
    "org.freedesktop.Avahi.NoDaemonError", "org.freedesktop.Avahi.InvalidInterfaceError",
    "org.freedesktop.Avahi.InvalidInterfaceProtocolError",
    "org.freedesktop.Avahi.InvalidFlagsError",
    "org.freedesktop.Avahi.NotFoundError", "org.freedesktop.Avahi.InvalidConfigurationError",
    "org.freedesktop.Avahi.VersionMismatchError",
    "org.freedesktop.Avahi.InvalidServiceSubtypeError",
    "org.freedesktop.Avahi.InvalidPacketError",
    "org.freedesktop.Avahi.InvalidDNSErrorError",
    "org.freedesktop.Avahi.DNSFORMERR", "org.freedesktop.Avahi.DNSSERVFAIL", "org.freedesktop.Avahi.DNSNXDOMAIN", "org.freedesktop.Avahi.DNSNOTIMP", "org.freedesktop.Avahi.DNSREFUSED", "org.freedesktop.Avahi.DNSYXDOMAIN", "org.freedesktop.Avahi.DNSYXRRSET", "org.freedesktop.Avahi.DNSNXRRSET", "org.freedesktop.Avahi.DNSNOTAUTH", "org.freedesktop.Avahi.DNSNOTZONE", "org.freedesktop.Avahi.InvalidRDataError",
    "org.freedesktop.Avahi.InvalidDNSClassError",
    "org.freedesktop.Avahi.InvalidDNSTypeError",
    "org.freedesktop.Avahi.NotSupportedError",
    "org.freedesktop.Avahi.NotPermittedError",
    "org.freedesktop.Avahi.InvalidArgumentError",
    "org.freedesktop.Avahi.IsEmptyError", "org.freedesktop.Avahi.NoChangeError" };
// table_link1
// file ../avahi-common/dbus.c line 31
static const char * const table_link1[54l] = { "org.freedesktop.Avahi.Success", "org.freedesktop.Avahi.Failure", "org.freedesktop.Avahi.BadStateError", "org.freedesktop.Avahi.InvalidHostNameError",
    "org.freedesktop.Avahi.InvalidDomainNameError",
    "org.freedesktop.Avahi.NoNetworkError", "org.freedesktop.Avahi.InvalidTTLError",
    "org.freedesktop.Avahi.IsPatternError", "org.freedesktop.Avahi.CollisionError", "org.freedesktop.Avahi.InvalidRecordError",
    "org.freedesktop.Avahi.InvalidServiceNameError",
    "org.freedesktop.Avahi.InvalidServiceTypeError",
    "org.freedesktop.Avahi.InvalidPortError",
    "org.freedesktop.Avahi.InvalidKeyError",
    "org.freedesktop.Avahi.InvalidAddressError",
    "org.freedesktop.Avahi.TimeoutError", "org.freedesktop.Avahi.TooManyClientsError",
    "org.freedesktop.Avahi.TooManyObjectsError",
    "org.freedesktop.Avahi.TooManyEntriesError",
    "org.freedesktop.Avahi.OSError", "org.freedesktop.DBus.Error.AccessDenied",
    "org.freedesktop.Avahi.InvalidOperationError",
    "org.freedesktop.Avahi.DBusError", "org.freedesktop.Avahi.DisconnectedError",
    "org.freedesktop.Avahi.NoMemoryError", "org.freedesktop.Avahi.InvalidObjectError",
    "org.freedesktop.Avahi.NoDaemonError", "org.freedesktop.Avahi.InvalidInterfaceError",
    "org.freedesktop.Avahi.InvalidInterfaceProtocolError",
    "org.freedesktop.Avahi.InvalidFlagsError",
    "org.freedesktop.Avahi.NotFoundError", "org.freedesktop.Avahi.InvalidConfigurationError",
    "org.freedesktop.Avahi.VersionMismatchError",
    "org.freedesktop.Avahi.InvalidServiceSubtypeError",
    "org.freedesktop.Avahi.InvalidPacketError",
    "org.freedesktop.Avahi.InvalidDNSErrorError",
    "org.freedesktop.Avahi.DNSFORMERR", "org.freedesktop.Avahi.DNSSERVFAIL", "org.freedesktop.Avahi.DNSNXDOMAIN", "org.freedesktop.Avahi.DNSNOTIMP", "org.freedesktop.Avahi.DNSREFUSED", "org.freedesktop.Avahi.DNSYXDOMAIN", "org.freedesktop.Avahi.DNSYXRRSET", "org.freedesktop.Avahi.DNSNXRRSET", "org.freedesktop.Avahi.DNSNOTAUTH", "org.freedesktop.Avahi.DNSNOTZONE", "org.freedesktop.Avahi.InvalidRDataError",
    "org.freedesktop.Avahi.InvalidDNSClassError",
    "org.freedesktop.Avahi.InvalidDNSTypeError",
    "org.freedesktop.Avahi.NotSupportedError",
    "org.freedesktop.Avahi.NotPermittedError",
    "org.freedesktop.Avahi.InvalidArgumentError",
    "org.freedesktop.Avahi.IsEmptyError", "org.freedesktop.Avahi.NoChangeError" };

// add_timeout
// file ../avahi-common/dbus-watch-glue.c line 254
static unsigned int add_timeout(struct DBusTimeout *dbus_timeout, void *userdata)
{
  struct TimeoutData *timeout;
  struct anonymous_28 *d = (struct anonymous_28 *)userdata;
  struct timeval tv;
  unsigned int b;
  /* assertion dbus_timeout */
  assert(dbus_timeout != ((struct DBusTimeout *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous_28 *)NULL));
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link4((unsigned int)1, sizeof(struct TimeoutData) /*32ul*/ );
  timeout = (struct TimeoutData *)return_value_avahi_new_internal_1;
  signed int return_value_dbus_timeout_get_interval_2;
  if(timeout == ((struct TimeoutData *)NULL))
    return (unsigned int)0;

  else
  {
    timeout->dbus_timeout = dbus_timeout;
    timeout->poll_api = d->poll_api;
    timeout->ref = 1;
    b=dbus_timeout_get_enabled(dbus_timeout);
    if(!(b == 0u))
    {
      return_value_dbus_timeout_get_interval_2=dbus_timeout_get_interval(dbus_timeout);
      avahi_elapse_time(&tv, (unsigned int)return_value_dbus_timeout_get_interval_2, (unsigned int)0);
    }

    timeout->avahi_timeout=d->poll_api->timeout_new(d->poll_api, b != 0u ? &tv : (struct timeval *)(void *)0, timeout_callback, (void *)timeout);
    if(timeout->avahi_timeout == ((struct AvahiTimeout_1 *)NULL))
    {
      avahi_free((void *)timeout);
      return (unsigned int)0;
    }

    else
    {
      dbus_timeout_set_data(dbus_timeout, (void *)timeout, (void (*)(void *))timeout_data_unref);
      return (unsigned int)1;
    }
  }
}

// add_timeout_link1
// file ../avahi-common/dbus-watch-glue.c line 254
static unsigned int add_timeout_link1(struct DBusTimeout *dbus_timeout_link1, void *userdata_link1)
{
  struct TimeoutData *timeout_link1;
  struct anonymous_28 *d_link1 = (struct anonymous_28 *)userdata_link1;
  struct timeval tv_link1;
  unsigned int b_link1;
  /* assertion dbus_timeout */
  assert(dbus_timeout_link1 != ((struct DBusTimeout *)NULL));
  /* assertion d */
  assert(d_link1 != ((struct anonymous_28 *)NULL));
  void *return_value_avahi_new_internal_1_link1;
  return_value_avahi_new_internal_1_link1=avahi_new_internal_link4_link2_link1((unsigned int)1, sizeof(struct TimeoutData) /*32ul*/ );
  timeout_link1 = (struct TimeoutData *)return_value_avahi_new_internal_1_link1;
  signed int return_value_dbus_timeout_get_interval_2_link1;
  if(timeout_link1 == ((struct TimeoutData *)NULL))
    return (unsigned int)0;

  else
  {
    timeout_link1->dbus_timeout = dbus_timeout_link1;
    timeout_link1->poll_api = d_link1->poll_api;
    timeout_link1->ref = 1;
    b_link1=dbus_timeout_get_enabled(dbus_timeout_link1);
    if(!(b_link1 == 0u))
    {
      return_value_dbus_timeout_get_interval_2_link1=dbus_timeout_get_interval(dbus_timeout_link1);
      avahi_elapse_time(&tv_link1, (unsigned int)return_value_dbus_timeout_get_interval_2_link1, (unsigned int)0);
    }

    timeout_link1->avahi_timeout=d_link1->poll_api->timeout_new(d_link1->poll_api, b_link1 != 0u ? &tv_link1 : (struct timeval *)(void *)0, timeout_callback_link2_link1, (void *)timeout_link1);
    if(timeout_link1->avahi_timeout == ((struct AvahiTimeout_1 *)NULL))
    {
      avahi_free((void *)timeout_link1);
      return (unsigned int)0;
    }

    else
    {
      dbus_timeout_set_data(dbus_timeout_link1, (void *)timeout_link1, (void (*)(void *))timeout_data_unref_link1);
      return (unsigned int)1;
    }
  }
}

// add_watch
// file ../avahi-common/dbus-watch-glue.c line 165
static unsigned int add_watch(struct DBusWatch *dbus_watch, void *userdata)
{
  struct anonymous_28 *d = (struct anonymous_28 *)userdata;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous_28 *)NULL));
  unsigned int return_value_update_watch_1;
  return_value_update_watch_1=update_watch(d->poll_api, dbus_watch);
  return return_value_update_watch_1;
}

// add_watch_link1
// file ../avahi-common/dbus-watch-glue.c line 165
static unsigned int add_watch_link1(struct DBusWatch *dbus_watch_link1, void *userdata_link1)
{
  struct anonymous_28 *d_link1 = (struct anonymous_28 *)userdata_link1;
  /* assertion dbus_watch */
  assert(dbus_watch_link1 != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d_link1 != ((struct anonymous_28 *)NULL));
  unsigned int return_value_update_watch_1_link1;
  return_value_update_watch_1_link1=update_watch_link1(d_link1->poll_api, dbus_watch_link1);
  return return_value_update_watch_1_link1;
}

// address_get_size
// file address.c line 35
static unsigned long int address_get_size(const struct AvahiAddress *a)
{
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  if(a->proto == 0)
    return (unsigned long int)4;

  else
    if(a->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// address_get_size_link1
// file address.c line 35
static unsigned long int address_get_size_link1(const struct AvahiAddress *a_link1)
{
  /* assertion a */
  assert(a_link1 != ((const struct AvahiAddress *)NULL));
  if(a_link1->proto == 0)
    return (unsigned long int)4;

  else
    if(a_link1->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// address_get_size_link1_link1
// file address.c line 35
static unsigned long int address_get_size_link1_link1(const struct AvahiAddress *a_link1_link1)
{
  /* assertion a */
  assert(a_link1_link1 != ((const struct AvahiAddress *)NULL));
  if(a_link1_link1->proto == 0)
    return (unsigned long int)4;

  else
    if(a_link1_link1->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// address_get_size_link2
// file address.c line 35
static unsigned long int address_get_size_link2(const struct AvahiAddress *a_link2)
{
  /* assertion a */
  assert(a_link2 != ((const struct AvahiAddress *)NULL));
  if(a_link2->proto == 0)
    return (unsigned long int)4;

  else
    if(a_link2->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// address_get_size_link3
// file address.c line 35
static unsigned long int address_get_size_link3(const struct AvahiAddress *a_link3)
{
  /* assertion a */
  assert(a_link3 != ((const struct AvahiAddress *)NULL));
  if(a_link3->proto == 0)
    return (unsigned long int)4;

  else
    if(a_link3->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// append_rdata
// file entrygroup.c line 348
static signed int append_rdata(struct DBusMessage *message, const void *rdata, unsigned long int size)
{
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_message_iter_init_append(message, &iter);
  unsigned int return_value_dbus_message_iter_open_container_1;
  return_value_dbus_message_iter_open_container_1=dbus_message_iter_open_container(&iter, (signed int)97, "y", &sub);
  _Bool tmp_if_expr_3;
  unsigned int return_value_dbus_message_iter_append_fixed_array_2;
  if(return_value_dbus_message_iter_open_container_1 == 0u)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_dbus_message_iter_append_fixed_array_2=dbus_message_iter_append_fixed_array(&sub, (signed int)121, (const void *)&rdata, (signed int)size);
    tmp_if_expr_3 = !(return_value_dbus_message_iter_append_fixed_array_2 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_message_iter_close_container_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_dbus_message_iter_close_container_4=dbus_message_iter_close_container(&iter, &sub);
    tmp_if_expr_5 = !(return_value_dbus_message_iter_close_container_4 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return -1;

  else
    return 0;
}

// append_rdata_link1
// file entrygroup.c line 348
static signed int append_rdata_link1(struct DBusMessage *message_link1, const void *rdata_link1, unsigned long int size_link1)
{
  struct DBusMessageIter iter_link1;
  struct DBusMessageIter sub_link1;
  /* assertion message */
  assert(message_link1 != ((struct DBusMessage *)NULL));
  dbus_message_iter_init_append(message_link1, &iter_link1);
  unsigned int return_value_dbus_message_iter_open_container_1_link1;
  return_value_dbus_message_iter_open_container_1_link1=dbus_message_iter_open_container(&iter_link1, (signed int)97, "y", &sub_link1);
  _Bool tmp_if_expr_3_link1;
  unsigned int return_value_dbus_message_iter_append_fixed_array_2_link1;
  if(return_value_dbus_message_iter_open_container_1_link1 == 0u)
    tmp_if_expr_3_link1 = (_Bool)1;

  else
  {
    return_value_dbus_message_iter_append_fixed_array_2_link1=dbus_message_iter_append_fixed_array(&sub_link1, (signed int)121, (const void *)&rdata_link1, (signed int)size_link1);
    tmp_if_expr_3_link1 = !(return_value_dbus_message_iter_append_fixed_array_2_link1 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5_link1;
  unsigned int return_value_dbus_message_iter_close_container_4_link1;
  if(tmp_if_expr_3_link1)
    tmp_if_expr_5_link1 = (_Bool)1;

  else
  {
    return_value_dbus_message_iter_close_container_4_link1=dbus_message_iter_close_container(&iter_link1, &sub_link1);
    tmp_if_expr_5_link1 = !(return_value_dbus_message_iter_close_container_4_link1 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5_link1)
    return -1;

  else
    return 0;
}

// append_string_list
// file entrygroup.c line 363
static signed int append_string_list(struct DBusMessage *message, struct AvahiStringList *txt)
{
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  signed int r = -1;
  struct AvahiStringList *p;
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_message_iter_init_append(message, &iter);
  txt=avahi_string_list_reverse(txt);
  unsigned int return_value_dbus_message_iter_open_container_1;
  return_value_dbus_message_iter_open_container_1=dbus_message_iter_open_container(&iter, (signed int)97, "ay", &sub);
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_message_iter_append_fixed_array_3;
  _Bool tmp_if_expr_6;
  unsigned int return_value_dbus_message_iter_close_container_5;
  unsigned int return_value_dbus_message_iter_close_container_7;
  if(!(return_value_dbus_message_iter_open_container_1 == 0u))
  {
    p = txt;
    for( ; !(p == ((struct AvahiStringList *)NULL)); p = p->next)
    {
      struct DBusMessageIter sub2;
      const unsigned char *data = p->text;
      unsigned int return_value_dbus_message_iter_open_container_2;
      return_value_dbus_message_iter_open_container_2=dbus_message_iter_open_container(&sub, (signed int)97, "y", &sub2);
      if(return_value_dbus_message_iter_open_container_2 == 0u)
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_dbus_message_iter_append_fixed_array_3=dbus_message_iter_append_fixed_array(&sub2, (signed int)121, (const void *)&data, (signed int)p->size);
        tmp_if_expr_4 = !(return_value_dbus_message_iter_append_fixed_array_3 != 0u) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_dbus_message_iter_close_container_5=dbus_message_iter_close_container(&sub, &sub2);
        tmp_if_expr_6 = !(return_value_dbus_message_iter_close_container_5 != 0u) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        goto fail;

    }
    return_value_dbus_message_iter_close_container_7=dbus_message_iter_close_container(&iter, &sub);
    if(!(return_value_dbus_message_iter_close_container_7 == 0u))
      r = 0;

  }


fail:
  ;
  txt=avahi_string_list_reverse(txt);
  return r;
}

// append_string_list_link1
// file entrygroup.c line 363
static signed int append_string_list_link1(struct DBusMessage *message_link1, struct AvahiStringList *txt_link1)
{
  struct DBusMessageIter iter_link1;
  struct DBusMessageIter sub_link1;
  signed int r_link1 = -1;
  struct AvahiStringList *p_link1;
  /* assertion message */
  assert(message_link1 != ((struct DBusMessage *)NULL));
  dbus_message_iter_init_append(message_link1, &iter_link1);
  txt_link1=avahi_string_list_reverse(txt_link1);
  unsigned int return_value_dbus_message_iter_open_container_1_link1;
  return_value_dbus_message_iter_open_container_1_link1=dbus_message_iter_open_container(&iter_link1, (signed int)97, "ay", &sub_link1);
  _Bool tmp_if_expr_4_link1;
  unsigned int return_value_dbus_message_iter_append_fixed_array_3_link1;
  _Bool tmp_if_expr_6_link1;
  unsigned int return_value_dbus_message_iter_close_container_5_link1;
  unsigned int return_value_dbus_message_iter_close_container_7_link1;
  if(!(return_value_dbus_message_iter_open_container_1_link1 == 0u))
  {
    p_link1 = txt_link1;
    for( ; !(p_link1 == ((struct AvahiStringList *)NULL)); p_link1 = p_link1->next)
    {
      struct DBusMessageIter sub2_link1;
      const unsigned char *data_link1 = p_link1->text;
      unsigned int return_value_dbus_message_iter_open_container_2_link1;
      return_value_dbus_message_iter_open_container_2_link1=dbus_message_iter_open_container(&sub_link1, (signed int)97, "y", &sub2_link1);
      if(return_value_dbus_message_iter_open_container_2_link1 == 0u)
        tmp_if_expr_4_link1 = (_Bool)1;

      else
      {
        return_value_dbus_message_iter_append_fixed_array_3_link1=dbus_message_iter_append_fixed_array(&sub2_link1, (signed int)121, (const void *)&data_link1, (signed int)p_link1->size);
        tmp_if_expr_4_link1 = !(return_value_dbus_message_iter_append_fixed_array_3_link1 != 0u) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4_link1)
        tmp_if_expr_6_link1 = (_Bool)1;

      else
      {
        return_value_dbus_message_iter_close_container_5_link1=dbus_message_iter_close_container(&sub_link1, &sub2_link1);
        tmp_if_expr_6_link1 = !(return_value_dbus_message_iter_close_container_5_link1 != 0u) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6_link1)
        goto fail;

    }
    return_value_dbus_message_iter_close_container_7_link1=dbus_message_iter_close_container(&iter_link1, &sub_link1);
    if(!(return_value_dbus_message_iter_close_container_7_link1 == 0u))
      r_link1 = 0;

  }


fail:
  ;
  txt_link1=avahi_string_list_reverse(txt_link1);
  return r_link1;
}

// aui_service_dialog_class_init
// file avahi-ui.c line 171
static void aui_service_dialog_class_init(struct _AuiServiceDialogClass *klass)
{
  struct _GObjectClass *object_class;
  avahi_init_i18n();
  object_class = (struct _GObjectClass *)klass;
  object_class->finalize = aui_service_dialog_finalize;
  object_class->set_property = aui_service_dialog_set_property;
  object_class->get_property = aui_service_dialog_get_property;
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("avahi", "Browse Service Types");
  char *return_value_dgettext_2;
  return_value_dgettext_2=dgettext("avahi", "A NULL terminated list of service types to browse for");
  struct _GParamSpec *return_value_g_param_spec_pointer_3;
  return_value_g_param_spec_pointer_3=g_param_spec_pointer("browse_service_types", return_value_dgettext_1, return_value_dgettext_2, (enum anonymous_35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)1, return_value_g_param_spec_pointer_3);
  char *return_value_dgettext_4;
  return_value_dgettext_4=dgettext("avahi", "Domain");
  char *return_value_dgettext_5;
  return_value_dgettext_5=dgettext("avahi", "The domain to browse in, or NULL for the default domain");
  struct _GParamSpec *return_value_g_param_spec_string_6;
  return_value_g_param_spec_string_6=g_param_spec_string("domain", return_value_dgettext_4, return_value_dgettext_5, (const char *)(void *)0, (enum anonymous_35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)2, return_value_g_param_spec_string_6);
  char *return_value_dgettext_7;
  return_value_dgettext_7=dgettext("avahi", "Service Type");
  char *return_value_dgettext_8;
  return_value_dgettext_8=dgettext("avahi", "The service type of the selected service");
  struct _GParamSpec *return_value_g_param_spec_string_9;
  return_value_g_param_spec_string_9=g_param_spec_string("service_type", return_value_dgettext_7, return_value_dgettext_8, (const char *)(void *)0, (enum anonymous_35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)3, return_value_g_param_spec_string_9);
  char *return_value_dgettext_10;
  return_value_dgettext_10=dgettext("avahi", "Service Name");
  char *return_value_dgettext_11;
  return_value_dgettext_11=dgettext("avahi", "The service name of the selected service");
  struct _GParamSpec *return_value_g_param_spec_string_12;
  return_value_g_param_spec_string_12=g_param_spec_string("service_name", return_value_dgettext_10, return_value_dgettext_11, (const char *)(void *)0, (enum anonymous_35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)4, return_value_g_param_spec_string_12);
  char *return_value_dgettext_13;
  return_value_dgettext_13=dgettext("avahi", "Address");
  char *return_value_dgettext_14;
  return_value_dgettext_14=dgettext("avahi", "The address of the resolved service");
  struct _GParamSpec *return_value_g_param_spec_pointer_15;
  return_value_g_param_spec_pointer_15=g_param_spec_pointer("address", return_value_dgettext_13, return_value_dgettext_14, (enum anonymous_35)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)5, return_value_g_param_spec_pointer_15);
  char *return_value_dgettext_16;
  return_value_dgettext_16=dgettext("avahi", "Port");
  char *return_value_dgettext_17;
  return_value_dgettext_17=dgettext("avahi", "The IP port number of the resolved service");
  struct _GParamSpec *return_value_g_param_spec_uint_18;
  return_value_g_param_spec_uint_18=g_param_spec_uint("port", return_value_dgettext_16, return_value_dgettext_17, (unsigned int)0, (unsigned int)0xFFFF, (unsigned int)0, (enum anonymous_35)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)6, return_value_g_param_spec_uint_18);
  char *return_value_dgettext_19;
  return_value_dgettext_19=dgettext("avahi", "Host Name");
  char *return_value_dgettext_20;
  return_value_dgettext_20=dgettext("avahi", "The host name of the resolved service");
  struct _GParamSpec *return_value_g_param_spec_string_21;
  return_value_g_param_spec_string_21=g_param_spec_string("host_name", return_value_dgettext_19, return_value_dgettext_20, (const char *)(void *)0, (enum anonymous_35)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)7, return_value_g_param_spec_string_21);
  char *return_value_dgettext_22;
  return_value_dgettext_22=dgettext("avahi", "TXT Data");
  char *return_value_dgettext_23;
  return_value_dgettext_23=dgettext("avahi", "The TXT data of the resolved service");
  struct _GParamSpec *return_value_g_param_spec_pointer_24;
  return_value_g_param_spec_pointer_24=g_param_spec_pointer("txt_data", return_value_dgettext_22, return_value_dgettext_23, (enum anonymous_35)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)8, return_value_g_param_spec_pointer_24);
  char *return_value_dgettext_25;
  return_value_dgettext_25=dgettext("avahi", "Resolve Service");
  char *return_value_dgettext_26;
  return_value_dgettext_26=dgettext("avahi", "Resolve the selected service automatically before returning");
  struct _GParamSpec *return_value_g_param_spec_boolean_27;
  return_value_g_param_spec_boolean_27=g_param_spec_boolean("resolve_service", return_value_dgettext_25, return_value_dgettext_26, (signed int)!(0 != 0), (enum anonymous_35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)9, return_value_g_param_spec_boolean_27);
  char *return_value_dgettext_28;
  return_value_dgettext_28=dgettext("avahi", "Resolve Service Host Name");
  char *return_value_dgettext_29;
  return_value_dgettext_29=dgettext("avahi", "Resolve the host name of the selected service automatically before returning");
  struct _GParamSpec *return_value_g_param_spec_boolean_30;
  return_value_g_param_spec_boolean_30=g_param_spec_boolean("resolve_host_name", return_value_dgettext_28, return_value_dgettext_29, (signed int)!(0 != 0), (enum anonymous_35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)10, return_value_g_param_spec_boolean_30);
  char *return_value_dgettext_31;
  return_value_dgettext_31=dgettext("avahi", "Address family");
  char *return_value_dgettext_32;
  return_value_dgettext_32=dgettext("avahi", "The address family for host name resolution");
  struct _GParamSpec *return_value_g_param_spec_int_33;
  return_value_g_param_spec_int_33=g_param_spec_int("address_family", return_value_dgettext_31, return_value_dgettext_32, -1, 1, -1, (enum anonymous_35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)11, return_value_g_param_spec_int_33);
}

// aui_service_dialog_class_intern_init
// file avahi-ui.c line 169
static void aui_service_dialog_class_intern_init(void *klass)
{
  aui_service_dialog_parent_class=g_type_class_peek_parent(klass);
  if(!(AuiServiceDialog_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &AuiServiceDialog_private_offset);

  aui_service_dialog_class_init((struct _AuiServiceDialogClass *)klass);
}

// aui_service_dialog_finalize
// file avahi-ui.c line 788
static void aui_service_dialog_finalize(struct _GObject *object)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  if(d->priv->domain_pulse_timeout >= 1u)
    g_source_remove(d->priv->domain_pulse_timeout);

  if(d->priv->service_pulse_timeout >= 1u)
    g_source_remove(d->priv->service_pulse_timeout);

  if(d->priv->start_idle >= 1u)
    g_source_remove(d->priv->start_idle);

  g_free((void *)d->priv->host_name);
  g_free((void *)d->priv->domain);
  g_free((void *)d->priv->service_name);
  avahi_string_list_free(d->priv->txt_data);
  g_strfreev(d->priv->browse_service_types);
  if(!(d->priv->domain_browser == ((struct AvahiDomainBrowser *)NULL)))
    avahi_domain_browser_free(d->priv->domain_browser);

  if(!(d->priv->resolver == ((struct AvahiServiceResolver *)NULL)))
    avahi_service_resolver_free(d->priv->resolver);

  if(!(d->priv->browsers == ((struct AvahiServiceBrowser **)NULL)))
  {
    struct AvahiServiceBrowser **sb = d->priv->browsers;
    for( ; !(*sb == ((struct AvahiServiceBrowser *)NULL)); sb = sb + 1l)
      avahi_service_browser_free(*sb);
    g_free((void *)d->priv->browsers);
  }

  if(!(d->priv->client == ((struct AvahiClient *)NULL)))
    avahi_client_free(d->priv->client);

  if(!(d->priv->glib_poll == ((struct AvahiGLibPoll *)NULL)))
    avahi_glib_poll_free(d->priv->glib_poll);

  if(!(d->priv->service_list_store == ((struct _GtkListStore *)NULL)))
    g_object_unref((void *)d->priv->service_list_store);

  if(!(d->priv->domain_list_store == ((struct _GtkListStore *)NULL)))
    g_object_unref((void *)d->priv->domain_list_store);

  if(!(d->priv->service_type_names == ((struct _GHashTable *)NULL)))
    g_hash_table_unref(d->priv->service_type_names);

  g_free((void *)d->priv);
  d->priv = (struct _AuiServiceDialogPrivate *)(void *)0;
  struct _GTypeClass *return_value_g_type_check_class_cast_3;
  return_value_g_type_check_class_cast_3=g_type_check_class_cast((struct _GTypeClass *)aui_service_dialog_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast_3)->finalize(object);
}

// aui_service_dialog_get_address
// file avahi-ui.h line 128
const struct AvahiAddress * aui_service_dialog_get_address(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_address", "AUI_IS_SERVICE_DIALOG(d)");
      return (const struct AvahiAddress *)(void *)0;
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_3;
  do
  {
    if(!(d->priv->resolve_service_done == 0))
      tmp_if_expr_3 = d->priv->resolve_host_name_done != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_address", "d->priv->resolve_service_done && d->priv->resolve_host_name_done");
      return (const struct AvahiAddress *)(void *)0;
    }

  }
  while((_Bool)0);
  return &d->priv->address;
}

// aui_service_dialog_get_address_family
// file avahi-ui.c line 1397
signed int aui_service_dialog_get_address_family(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_address_family", "AUI_IS_SERVICE_DIALOG(d)");
      return -1;
    }

  }
  while((_Bool)0);
  return d->priv->address_family;
}

// aui_service_dialog_get_browse_service_types
// file avahi-ui.c line 1262
const char * const * aui_service_dialog_get_browse_service_types(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_browse_service_types", "AUI_IS_SERVICE_DIALOG(d)");
      return (const char * const *)(void *)0;
    }

  }
  while((_Bool)0);
  return (const char * const *)d->priv->browse_service_types;
}

// aui_service_dialog_get_domain
// file avahi-ui.c line 1306
const char * aui_service_dialog_get_domain(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_domain", "AUI_IS_SERVICE_DIALOG(d)");
      return (const char *)(void *)0;
    }

  }
  while((_Bool)0);
  return d->priv->domain;
}

// aui_service_dialog_get_host_name
// file avahi-ui.h line 134
const char * aui_service_dialog_get_host_name(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_host_name", "AUI_IS_SERVICE_DIALOG(d)");
      return (const char *)(void *)0;
    }

  }
  while((_Bool)0);
  do
    if(d->priv->resolve_service_done == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_host_name", "d->priv->resolve_service_done");
      return (const char *)(void *)0;
    }

  while((_Bool)0);
  return d->priv->host_name;
}

// aui_service_dialog_get_port
// file avahi-ui.h line 131
unsigned short int aui_service_dialog_get_port(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_port", "AUI_IS_SERVICE_DIALOG(d)");
      return (unsigned short int)0;
    }

  }
  while((_Bool)0);
  do
    if(d->priv->resolve_service_done == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_port", "d->priv->resolve_service_done");
      return (unsigned short int)0;
    }

  while((_Bool)0);
  return d->priv->port;
}

// aui_service_dialog_get_property
// file avahi-ui.c line 1441
static void aui_service_dialog_get_property(struct _GObject *object, unsigned int prop_id, struct _GValue *value, struct _GParamSpec *pspec)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  const char * const *return_value_aui_service_dialog_get_browse_service_types_3;
  const char *return_value_aui_service_dialog_get_domain_4;
  const char *return_value_aui_service_dialog_get_service_type_5;
  const char *return_value_aui_service_dialog_get_service_name_6;
  const struct AvahiAddress *return_value_aui_service_dialog_get_address_7;
  unsigned short int return_value_aui_service_dialog_get_port_8;
  const char *return_value_aui_service_dialog_get_host_name_9;
  const struct AvahiStringList *return_value_aui_service_dialog_get_txt_data_10;
  signed int return_value_aui_service_dialog_get_resolve_service_11;
  signed int return_value_aui_service_dialog_get_resolve_host_name_12;
  signed int return_value_aui_service_dialog_get_address_family_13;
  switch(prop_id)
  {
    case (unsigned int)1:
    {
      return_value_aui_service_dialog_get_browse_service_types_3=aui_service_dialog_get_browse_service_types(d);
      g_value_set_pointer(value, (void *)return_value_aui_service_dialog_get_browse_service_types_3);
      break;
    }
    case (unsigned int)2:
    {
      return_value_aui_service_dialog_get_domain_4=aui_service_dialog_get_domain(d);
      g_value_set_string(value, return_value_aui_service_dialog_get_domain_4);
      break;
    }
    case (unsigned int)3:
    {
      return_value_aui_service_dialog_get_service_type_5=aui_service_dialog_get_service_type(d);
      g_value_set_string(value, return_value_aui_service_dialog_get_service_type_5);
      break;
    }
    case (unsigned int)4:
    {
      return_value_aui_service_dialog_get_service_name_6=aui_service_dialog_get_service_name(d);
      g_value_set_string(value, return_value_aui_service_dialog_get_service_name_6);
      break;
    }
    case (unsigned int)5:
    {
      return_value_aui_service_dialog_get_address_7=aui_service_dialog_get_address(d);
      g_value_set_pointer(value, (void *)return_value_aui_service_dialog_get_address_7);
      break;
    }
    case (unsigned int)6:
    {
      return_value_aui_service_dialog_get_port_8=aui_service_dialog_get_port(d);
      g_value_set_uint(value, (unsigned int)return_value_aui_service_dialog_get_port_8);
      break;
    }
    case (unsigned int)7:
    {
      return_value_aui_service_dialog_get_host_name_9=aui_service_dialog_get_host_name(d);
      g_value_set_string(value, return_value_aui_service_dialog_get_host_name_9);
      break;
    }
    case (unsigned int)8:
    {
      return_value_aui_service_dialog_get_txt_data_10=aui_service_dialog_get_txt_data(d);
      g_value_set_pointer(value, (void *)return_value_aui_service_dialog_get_txt_data_10);
      break;
    }
    case (unsigned int)9:
    {
      return_value_aui_service_dialog_get_resolve_service_11=aui_service_dialog_get_resolve_service(d);
      g_value_set_boolean(value, return_value_aui_service_dialog_get_resolve_service_11);
      break;
    }
    case (unsigned int)10:
    {
      return_value_aui_service_dialog_get_resolve_host_name_12=aui_service_dialog_get_resolve_host_name(d);
      g_value_set_boolean(value, return_value_aui_service_dialog_get_resolve_host_name_12);
      break;
    }
    case (unsigned int)11:
    {
      return_value_aui_service_dialog_get_address_family_13=aui_service_dialog_get_address_family(d);
      g_value_set_int(value, return_value_aui_service_dialog_get_address_family_13);
      break;
    }
    default:
      do
      {
        struct _GObject *_glib__object = (struct _GObject *)object;
        struct _GParamSpec *_glib__pspec = (struct _GParamSpec *)pspec;
        unsigned int _glib__property_id = prop_id;
        const char *return_value_g_type_name_14;
        return_value_g_type_name_14=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__pspec)->g_class)->g_type);
        const char *return_value_g_type_name_15;
        return_value_g_type_name_15=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__object)->g_class)->g_type);
        g_log((char *)0, (enum anonymous_10)G_LOG_LEVEL_WARNING, "%s:%d: invalid %s id %u for \"%s\" of type '%s' in '%s'", (const void *)"avahi-ui.c", 1490, (const void *)"property", _glib__property_id, _glib__pspec->name, return_value_g_type_name_14, return_value_g_type_name_15);
      }
      while((_Bool)0);
  }
}

// aui_service_dialog_get_resolve_host_name
// file avahi-ui.c line 1384
signed int aui_service_dialog_get_resolve_host_name(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_resolve_host_name", "AUI_IS_SERVICE_DIALOG(d)");
      return 0;
    }

  }
  while((_Bool)0);
  return d->priv->resolve_host_name;
}

// aui_service_dialog_get_resolve_service
// file avahi-ui.c line 1372
signed int aui_service_dialog_get_resolve_service(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_resolve_service", "AUI_IS_SERVICE_DIALOG(d)");
      return 0;
    }

  }
  while((_Bool)0);
  return d->priv->resolve_service;
}

// aui_service_dialog_get_service_name
// file avahi-ui.h line 121
const char * aui_service_dialog_get_service_name(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_service_name", "AUI_IS_SERVICE_DIALOG(d)");
      return (const char *)(void *)0;
    }

  }
  while((_Bool)0);
  return d->priv->service_name;
}

// aui_service_dialog_get_service_type
// file avahi-ui.h line 115
const char * aui_service_dialog_get_service_type(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_service_type", "AUI_IS_SERVICE_DIALOG(d)");
      return (const char *)(void *)0;
    }

  }
  while((_Bool)0);
  return d->priv->service_type;
}

// aui_service_dialog_get_txt_data
// file avahi-ui.h line 137
const struct AvahiStringList * aui_service_dialog_get_txt_data(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_txt_data", "AUI_IS_SERVICE_DIALOG(d)");
      return (const struct AvahiStringList *)(void *)0;
    }

  }
  while((_Bool)0);
  do
    if(d->priv->resolve_service_done == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_txt_data", "d->priv->resolve_service_done");
      return (const struct AvahiStringList *)(void *)0;
    }

  while((_Bool)0);
  return d->priv->txt_data;
}

// aui_service_dialog_get_type
// file avahi-ui.h line 59
unsigned long int aui_service_dialog_get_type(void)
{
  _Bool tmp_statement_expression_3;
  void *tmp_statement_expression_4;
  signed int return_value___atomic_load_8_5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  return_value___atomic_load_8_5=__atomic_load_8(&g_define_type_id__volatile, 5);
  tmp_statement_expression_4 = (void *)return_value___atomic_load_8_5;
  _Bool tmp_if_expr_7;
  signed int return_value_g_once_init_enter_6;
  if(tmp_statement_expression_4 == NULL)
  {
    return_value_g_once_init_enter_6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr_7 = return_value_g_once_init_enter_6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_7 = (_Bool)0;
  tmp_statement_expression_3 = tmp_if_expr_7;
  if(tmp_statement_expression_3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_dialog_get_type_1;
    return_value_gtk_dialog_get_type_1=gtk_dialog_get_type();
    const char *return_value_g_intern_static_string_2;
    return_value_g_intern_static_string_2=g_intern_static_string("AuiServiceDialog");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_dialog_get_type_1, return_value_g_intern_static_string_2, (unsigned int)sizeof(struct _AuiServiceDialogClass) /*1152ul*/ , (void (*)(void *, void *))aui_service_dialog_class_intern_init, (unsigned int)sizeof(struct _AuiServiceDialog) /*72ul*/ , (void (*)(struct _GTypeInstance *, void *))aui_service_dialog_init, (enum anonymous_3)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// aui_service_dialog_init
// file avahi-ui.c line 1080
static void aui_service_dialog_init(struct _AuiServiceDialog *d)
{
  struct _GtkWidget *vbox;
  struct _GtkWidget *vbox2;
  struct _GtkWidget *scrolled_window;
  struct _GtkCellRenderer *renderer;
  struct _GtkTreeViewColumn *column;
  struct _GtkTreeSelection *selection;
  struct _AuiServiceDialogPrivate *p;
  void *return_value_g_malloc_n_1;
  return_value_g_malloc_n_1=g_malloc_n((unsigned long int)1, sizeof(struct _AuiServiceDialogPrivate) /*264ul*/ );
  d->priv = (struct _AuiServiceDialogPrivate *)return_value_g_malloc_n_1;
  p = d->priv;
  p->host_name = (char *)(void *)0;
  p->domain = (char *)(void *)0;
  p->service_name = (char *)(void *)0;
  p->service_type = (char *)(void *)0;
  p->txt_data = (struct AvahiStringList *)(void *)0;
  p->browse_service_types = (char **)(void *)0;
  memset((void *)&p->address, 0, sizeof(struct AvahiAddress) /*20ul*/ );
  p->port = (unsigned short int)0;
  p->resolve_service = (signed int)!(0 != 0);
  p->resolve_host_name = p->resolve_service;
  p->resolve_service_done = 0;
  p->resolve_host_name_done = p->resolve_service_done;
  p->address_family = -1;
  p->glib_poll = (struct AvahiGLibPoll *)(void *)0;
  p->client = (struct AvahiClient *)(void *)0;
  p->browsers = (struct AvahiServiceBrowser **)(void *)0;
  p->resolver = (struct AvahiServiceResolver *)(void *)0;
  p->domain_browser = (struct AvahiDomainBrowser *)(void *)0;
  p->service_pulse_timeout = (unsigned int)0;
  p->domain_pulse_timeout = (unsigned int)0;
  p->start_idle = (unsigned int)0;
  p->common_interface = -1;
  p->common_protocol = -1;
  p->domain_dialog = (struct _GtkWidget *)(void *)0;
  p->domain_entry = (struct _GtkWidget *)(void *)0;
  p->domain_tree_view = (struct _GtkWidget *)(void *)0;
  p->domain_progress_bar = (struct _GtkWidget *)(void *)0;
  p->domain_ok_button = (struct _GtkWidget *)(void *)0;
  p->forward_response_id = -1;
  p->domain_list_store = (struct _GtkListStore *)(void *)0;
  p->service_list_store = p->domain_list_store;
  p->service_type_names = (struct _GHashTable *)(void *)0;
  unsigned long int return_value_gtk_container_get_type_2;
  return_value_gtk_container_get_type_2=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_3;
  return_value_g_type_check_instance_cast_3=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_container_get_type_2);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_3, (unsigned int)5);
  vbox=gtk_box_new((enum anonymous_16)GTK_ORIENTATION_VERTICAL, 8);
  unsigned long int return_value_gtk_container_get_type_4;
  return_value_gtk_container_get_type_4=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
  return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_container_get_type_4);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_5, (unsigned int)8);
  unsigned long int return_value_gtk_dialog_get_type_6;
  return_value_gtk_dialog_get_type_6=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_7;
  return_value_g_type_check_instance_cast_7=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_6);
  struct _GtkWidget *return_value_gtk_dialog_get_content_area_8;
  return_value_gtk_dialog_get_content_area_8=gtk_dialog_get_content_area((struct _GtkDialog *)return_value_g_type_check_instance_cast_7);
  unsigned long int return_value_gtk_box_get_type_9;
  return_value_gtk_box_get_type_9=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_get_content_area_8, return_value_gtk_box_get_type_9);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_10, vbox, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  char *return_value_dgettext_11;
  return_value_dgettext_11=dgettext("avahi", "Initializing...");
  p->domain_label=gtk_label_new(return_value_dgettext_11);
  unsigned long int return_value_gtk_label_get_type_12;
  return_value_gtk_label_get_type_12=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_13;
  return_value_g_type_check_instance_cast_13=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_label, return_value_gtk_label_get_type_12);
  gtk_label_set_ellipsize((struct _GtkLabel *)return_value_g_type_check_instance_cast_13, (enum anonymous_0)!(0 != 0));
  unsigned long int return_value_gtk_misc_get_type_14;
  return_value_gtk_misc_get_type_14=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_15;
  return_value_g_type_check_instance_cast_15=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_label, return_value_gtk_misc_get_type_14);
  gtk_misc_set_alignment((struct _GtkMisc *)return_value_g_type_check_instance_cast_15, (float)0, (float)0.5);
  unsigned long int return_value_gtk_box_get_type_16;
  return_value_gtk_box_get_type_16=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_17;
  return_value_g_type_check_instance_cast_17=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type_16);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_17, p->domain_label, 0, 0, (unsigned int)0);
  vbox2=gtk_box_new((enum anonymous_16)GTK_ORIENTATION_VERTICAL, 8);
  unsigned long int return_value_gtk_box_get_type_18;
  return_value_gtk_box_get_type_18=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_19;
  return_value_g_type_check_instance_cast_19=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type_18);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_19, vbox2, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  scrolled_window=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
  unsigned long int return_value_gtk_scrolled_window_get_type_20;
  return_value_gtk_scrolled_window_get_type_20=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_21;
  return_value_g_type_check_instance_cast_21=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type_20);
  gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_21, (enum anonymous_2)GTK_POLICY_AUTOMATIC, (enum anonymous_2)GTK_POLICY_AUTOMATIC);
  unsigned long int return_value_gtk_scrolled_window_get_type_22;
  return_value_gtk_scrolled_window_get_type_22=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_23;
  return_value_g_type_check_instance_cast_23=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type_22);
  gtk_scrolled_window_set_shadow_type((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_23, (enum anonymous_5)GTK_SHADOW_ETCHED_IN);
  unsigned long int return_value_gtk_box_get_type_24;
  return_value_gtk_box_get_type_24=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_25;
  return_value_g_type_check_instance_cast_25=g_type_check_instance_cast((struct _GTypeInstance *)vbox2, return_value_gtk_box_get_type_24);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_25, scrolled_window, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  p->service_list_store=gtk_list_store_new(6, (unsigned long int)(6 << 2), (unsigned long int)(6 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2));
  unsigned long int return_value_gtk_tree_model_get_type_26;
  return_value_gtk_tree_model_get_type_26=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_27;
  return_value_g_type_check_instance_cast_27=g_type_check_instance_cast((struct _GTypeInstance *)p->service_list_store, return_value_gtk_tree_model_get_type_26);
  p->service_tree_view=gtk_tree_view_new_with_model((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_27);
  unsigned long int return_value_gtk_tree_view_get_type_28;
  return_value_gtk_tree_view_get_type_28=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_29;
  return_value_g_type_check_instance_cast_29=g_type_check_instance_cast((struct _GTypeInstance *)p->service_tree_view, return_value_gtk_tree_view_get_type_28);
  gtk_tree_view_set_headers_visible((struct _GtkTreeView *)return_value_g_type_check_instance_cast_29, 0);
  g_signal_connect_data((void *)p->service_tree_view, "row-activated", (void (*)(void))service_row_activated_callback, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_7)0);
  unsigned long int return_value_gtk_tree_view_get_type_30;
  return_value_gtk_tree_view_get_type_30=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_31;
  return_value_g_type_check_instance_cast_31=g_type_check_instance_cast((struct _GTypeInstance *)p->service_tree_view, return_value_gtk_tree_view_get_type_30);
  selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast_31);
  gtk_tree_selection_set_mode(selection, (enum anonymous_1)GTK_SELECTION_BROWSE);
  g_signal_connect_data((void *)selection, "changed", (void (*)(void))service_selection_changed_callback, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_7)0);
  renderer=gtk_cell_renderer_text_new();
  char *return_value_dgettext_32;
  return_value_dgettext_32=dgettext("avahi", "Location");
  column=gtk_tree_view_column_new_with_attributes(return_value_dgettext_32, renderer, (const void *)"text", 4, (void *)0);
  gtk_tree_view_column_set_visible(column, 0);
  unsigned long int return_value_gtk_tree_view_get_type_33;
  return_value_gtk_tree_view_get_type_33=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_34;
  return_value_g_type_check_instance_cast_34=g_type_check_instance_cast((struct _GTypeInstance *)p->service_tree_view, return_value_gtk_tree_view_get_type_33);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_34, column);
  renderer=gtk_cell_renderer_text_new();
  char *return_value_dgettext_35;
  return_value_dgettext_35=dgettext("avahi", "Name");
  column=gtk_tree_view_column_new_with_attributes(return_value_dgettext_35, renderer, (const void *)"text", 3, (void *)0);
  gtk_tree_view_column_set_expand(column, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_tree_view_get_type_36;
  return_value_gtk_tree_view_get_type_36=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_37;
  return_value_g_type_check_instance_cast_37=g_type_check_instance_cast((struct _GTypeInstance *)p->service_tree_view, return_value_gtk_tree_view_get_type_36);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_37, column);
  renderer=gtk_cell_renderer_text_new();
  char *return_value_dgettext_38;
  return_value_dgettext_38=dgettext("avahi", "Type");
  column=gtk_tree_view_column_new_with_attributes(return_value_dgettext_38, renderer, (const void *)"text", 5, (void *)0);
  gtk_tree_view_column_set_visible(column, 0);
  unsigned long int return_value_gtk_tree_view_get_type_39;
  return_value_gtk_tree_view_get_type_39=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_40;
  return_value_g_type_check_instance_cast_40=g_type_check_instance_cast((struct _GTypeInstance *)p->service_tree_view, return_value_gtk_tree_view_get_type_39);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_40, column);
  unsigned long int return_value_gtk_tree_view_get_type_41;
  return_value_gtk_tree_view_get_type_41=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_42;
  return_value_g_type_check_instance_cast_42=g_type_check_instance_cast((struct _GTypeInstance *)p->service_tree_view, return_value_gtk_tree_view_get_type_41);
  gtk_tree_view_set_search_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_42, 3);
  unsigned long int return_value_gtk_container_get_type_43;
  return_value_gtk_container_get_type_43=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_44;
  return_value_g_type_check_instance_cast_44=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_container_get_type_43);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_44, p->service_tree_view);
  p->service_progress_bar=gtk_progress_bar_new();
  unsigned long int return_value_gtk_progress_bar_get_type_45;
  return_value_gtk_progress_bar_get_type_45=gtk_progress_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_46;
  return_value_g_type_check_instance_cast_46=g_type_check_instance_cast((struct _GTypeInstance *)p->service_progress_bar, return_value_gtk_progress_bar_get_type_45);
  char *return_value_dgettext_47;
  return_value_dgettext_47=dgettext("avahi", "Browsing...");
  gtk_progress_bar_set_text((struct _GtkProgressBar *)return_value_g_type_check_instance_cast_46, return_value_dgettext_47);
  unsigned long int return_value_gtk_progress_bar_get_type_48;
  return_value_gtk_progress_bar_get_type_48=gtk_progress_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_49;
  return_value_g_type_check_instance_cast_49=g_type_check_instance_cast((struct _GTypeInstance *)p->service_progress_bar, return_value_gtk_progress_bar_get_type_48);
  gtk_progress_bar_set_pulse_step((struct _GtkProgressBar *)return_value_g_type_check_instance_cast_49, 0.1);
  unsigned long int return_value_gtk_box_get_type_50;
  return_value_gtk_box_get_type_50=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_51;
  return_value_g_type_check_instance_cast_51=g_type_check_instance_cast((struct _GTypeInstance *)vbox2, return_value_gtk_box_get_type_50);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast_51, p->service_progress_bar, 0, 0, (unsigned int)0);
  char *return_value_dgettext_52;
  return_value_dgettext_52=dgettext("avahi", "_Domain...");
  p->domain_button=gtk_button_new_with_mnemonic(return_value_dgettext_52);
  unsigned long int return_value_gtk_button_get_type_53;
  return_value_gtk_button_get_type_53=gtk_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_54;
  return_value_g_type_check_instance_cast_54=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_button, return_value_gtk_button_get_type_53);
  struct _GtkWidget *return_value_gtk_image_new_from_icon_name_55;
  return_value_gtk_image_new_from_icon_name_55=gtk_image_new_from_icon_name("network-workgroup", (enum anonymous_32)GTK_ICON_SIZE_BUTTON);
  gtk_button_set_image((struct _GtkButton *)return_value_g_type_check_instance_cast_54, return_value_gtk_image_new_from_icon_name_55);
  g_signal_connect_data((void *)p->domain_button, "clicked", (void (*)(void))domain_button_clicked, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_7)0);
  unsigned long int return_value_gtk_dialog_get_type_56;
  return_value_gtk_dialog_get_type_56=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_57;
  return_value_g_type_check_instance_cast_57=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_56);
  struct _GtkWidget *return_value_gtk_dialog_get_action_area_58;
  return_value_gtk_dialog_get_action_area_58=gtk_dialog_get_action_area((struct _GtkDialog *)return_value_g_type_check_instance_cast_57);
  unsigned long int return_value_gtk_box_get_type_59;
  return_value_gtk_box_get_type_59=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_60;
  return_value_g_type_check_instance_cast_60=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_get_action_area_58, return_value_gtk_box_get_type_59);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_60, p->domain_button, 0, (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_dialog_get_type_61;
  return_value_gtk_dialog_get_type_61=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_62;
  return_value_g_type_check_instance_cast_62=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_61);
  struct _GtkWidget *return_value_gtk_dialog_get_action_area_63;
  return_value_gtk_dialog_get_action_area_63=gtk_dialog_get_action_area((struct _GtkDialog *)return_value_g_type_check_instance_cast_62);
  unsigned long int return_value_gtk_button_box_get_type_64;
  return_value_gtk_button_box_get_type_64=gtk_button_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_65;
  return_value_g_type_check_instance_cast_65=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_get_action_area_63, return_value_gtk_button_box_get_type_64);
  gtk_button_box_set_child_secondary((struct _GtkButtonBox *)return_value_g_type_check_instance_cast_65, p->domain_button, (signed int)!(0 != 0));
  gtk_widget_show(p->domain_button);
  unsigned long int return_value_gtk_dialog_get_type_66;
  return_value_gtk_dialog_get_type_66=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_67;
  return_value_g_type_check_instance_cast_67=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_66);
  gtk_dialog_set_default_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_67, -3);
  gtk_widget_grab_focus(p->service_tree_view);
  unsigned long int return_value_gtk_window_get_type_68;
  return_value_gtk_window_get_type_68=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_69;
  return_value_g_type_check_instance_cast_69=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type_68);
  gtk_window_set_default_size((struct _GtkWindow *)return_value_g_type_check_instance_cast_69, 400, 300);
  gtk_widget_show_all(vbox);
  p->glib_poll=avahi_glib_poll_new((struct _GMainContext *)(void *)0, 0);
  p->service_pulse_timeout=g_timeout_add((unsigned int)100, service_pulse_callback, (void *)d);
  p->start_idle=g_idle_add(start_callback, (void *)d);
  g_signal_connect_data((void *)d, "response", (void (*)(void))response_callback, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_7)0);
}

// aui_service_dialog_new
// file avahi-ui.h line 72
struct _GtkWidget * aui_service_dialog_new(const char *title, struct _GtkWindow *parent, const char *first_button_text, ...)
{
  struct _GtkWidget *w;
  void **varargs = (void **)&first_button_text;
  w=aui_service_dialog_new_valist(title, parent, first_button_text, varargs);
  varargs = ((void **)NULL);
  return w;
}

// aui_service_dialog_new_valist
// file avahi-ui.c line 248
struct _GtkWidget * aui_service_dialog_new_valist(const char *title, struct _GtkWindow *parent, const char *first_button_text, __builtin_va_list varargs)
{
  const char *button_text;
  signed int dr;
  struct _GtkWidget *w;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  void *return_value_g_object_new_2;
  return_value_g_object_new_2=g_object_new(return_value_aui_service_dialog_get_type_1, "title", title, (void *)0);
  w = (struct _GtkWidget *)return_value_g_object_new_2;
  unsigned long int return_value_gtk_window_get_type_3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  if(!(parent == ((struct _GtkWindow *)NULL)))
  {
    return_value_gtk_window_get_type_3=gtk_window_get_type();
    return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_window_get_type_3);
    gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast_4, parent);
  }

  button_text = first_button_text;
  while(!(button_text == ((const char *)NULL)))
  {
    signed int response_id;
    response_id=va_arg(varargs, __typeof__(response_id));
    unsigned long int return_value_gtk_dialog_get_type_5;
    return_value_gtk_dialog_get_type_5=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
    return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type_5);
    gtk_dialog_add_button((struct _GtkDialog *)return_value_g_type_check_instance_cast_6, button_text, response_id);
    button_text=va_arg(varargs, __typeof__(button_text));
  }
  unsigned long int return_value_gtk_dialog_get_type_7;
  return_value_gtk_dialog_get_type_7=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type_7);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast_8, -3, 0);
  unsigned long int return_value_gtk_dialog_get_type_9;
  return_value_gtk_dialog_get_type_9=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type_9);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast_10, -5, 0);
  unsigned long int return_value_gtk_dialog_get_type_11;
  return_value_gtk_dialog_get_type_11=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type_11);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast_12, -8, 0);
  unsigned long int return_value_gtk_dialog_get_type_13;
  return_value_gtk_dialog_get_type_13=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type_13);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast_14, -10, 0);
  unsigned long int return_value_gtk_dialog_get_type_17;
  return_value_gtk_dialog_get_type_17=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type_17);
  dr=get_default_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_18);
  unsigned long int return_value_gtk_dialog_get_type_15;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  if(!(dr == -1))
  {
    return_value_gtk_dialog_get_type_15=gtk_dialog_get_type();
    return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type_15);
    gtk_dialog_set_default_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_16, dr);
  }

  return w;
}

// aui_service_dialog_set_address_family
// file avahi-ui.c line 1390
void aui_service_dialog_set_address_family(struct _AuiServiceDialog *d, signed int proto)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_address_family", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L10;
    }

  }
  while((_Bool)0);
  do
    if(!(proto == 0) && !(proto == 1) && !(proto == -1))
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_address_family", "proto == AVAHI_PROTO_UNSPEC || proto == AVAHI_PROTO_INET || proto == AVAHI_PROTO_INET6");
      goto __CPROVER_DUMP_L10;
    }

  while((_Bool)0);
  d->priv->address_family = proto;

__CPROVER_DUMP_L10:
  ;
}

// aui_service_dialog_set_browse_service_types
// file avahi-ui.h line 90
void aui_service_dialog_set_browse_service_types(struct _AuiServiceDialog *d, const char *type, ...)
{
  __builtin_va_list ap;
  const char *t;
  unsigned int u;
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_browse_service_types", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L15;
    }

  }
  while((_Bool)0);
  do
    if(type == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_browse_service_types", "type");
      goto __CPROVER_DUMP_L15;
    }

  while((_Bool)0);
  g_strfreev(d->priv->browse_service_types);
  va_start(ap, type);
  u = (unsigned int)1;
  const char *return_value_gcc_builtin_va_arg_3;
  do
  {
    return_value_gcc_builtin_va_arg_3=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_3));
    if(return_value_gcc_builtin_va_arg_3 == ((const char *)NULL))
      break;

    u = u + 1u;
  }
  while((_Bool)1);
  va_end(ap);
  void *return_value_g_malloc0_n_4;
  return_value_g_malloc0_n_4=g_malloc0_n((unsigned long int)(u + (unsigned int)1), sizeof(char *) /*8ul*/ );
  d->priv->browse_service_types = (char **)return_value_g_malloc0_n_4;
  d->priv->browse_service_types[(signed long int)0]=g_strdup(type);
  va_start(ap, type);
  u = (unsigned int)1;
  do
  {
    t=va_arg(ap, __typeof__(t));
    if(t == ((const char *)NULL))
      break;

    d->priv->browse_service_types[(signed long int)u]=g_strdup(t);
    u = u + 1u;
  }
  while((_Bool)1);
  va_end(ap);
  if(!(*d->priv->browse_service_types == ((char *)NULL)))
  {
    if(!(d->priv->browse_service_types[1l] == ((char *)NULL)))
    {
      unsigned long int return_value_gtk_tree_view_get_type_5;
      return_value_gtk_tree_view_get_type_5=gtk_tree_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
      return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type_5);
      struct _GtkTreeViewColumn *return_value_gtk_tree_view_get_column_7;
      return_value_gtk_tree_view_get_column_7=gtk_tree_view_get_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_6, 2);
      gtk_tree_view_column_set_visible(return_value_gtk_tree_view_get_column_7, (signed int)!(0 != 0));
    }

  }

  restart_browsing(d);

__CPROVER_DUMP_L15:
  ;
}

// aui_service_dialog_set_browse_service_typesv
// file avahi-ui.c line 1245
void aui_service_dialog_set_browse_service_typesv(struct _AuiServiceDialog *d, const char * const *types)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_browse_service_typesv", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L13;
    }

  }
  while((_Bool)0);
  do
    if(types == ((const char * const *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_browse_service_typesv", "types");
      goto __CPROVER_DUMP_L13;
    }

  while((_Bool)0);
  do
    if(*types == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_browse_service_typesv", "*types");
      goto __CPROVER_DUMP_L13;
    }

  while((_Bool)0);
  g_strfreev(d->priv->browse_service_types);
  d->priv->browse_service_types=g_strdupv((char **)types);
  if(!(*d->priv->browse_service_types == ((char *)NULL)))
  {
    if(!(d->priv->browse_service_types[1l] == ((char *)NULL)))
    {
      unsigned long int return_value_gtk_tree_view_get_type_3;
      return_value_gtk_tree_view_get_type_3=gtk_tree_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
      return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type_3);
      struct _GtkTreeViewColumn *return_value_gtk_tree_view_get_column_5;
      return_value_gtk_tree_view_get_column_5=gtk_tree_view_get_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_4, 2);
      gtk_tree_view_column_set_visible(return_value_gtk_tree_view_get_column_5, (signed int)!(0 != 0));
    }

  }

  restart_browsing(d);

__CPROVER_DUMP_L13:
  ;
}

// aui_service_dialog_set_domain
// file avahi-ui.h line 103
void aui_service_dialog_set_domain(struct _AuiServiceDialog *d, const char *domain)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_domain", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L14;
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_4;
  signed int return_value_is_valid_domain_suffix_3;
  do
  {
    if(domain == ((const char *)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_is_valid_domain_suffix_3=is_valid_domain_suffix(domain);
      tmp_if_expr_4 = return_value_is_valid_domain_suffix_3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_4)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_domain", "!domain || is_valid_domain_suffix(domain)");
      goto __CPROVER_DUMP_L14;
    }

  }
  while((_Bool)0);
  g_free((void *)d->priv->domain);
  char *tmp_if_expr_6;
  char *return_value_avahi_normalize_name_strdup_5;
  if(!(domain == ((const char *)NULL)))
  {
    return_value_avahi_normalize_name_strdup_5=avahi_normalize_name_strdup(domain);
    tmp_if_expr_6 = return_value_avahi_normalize_name_strdup_5;
  }

  else
    tmp_if_expr_6 = (char *)(void *)0;
  d->priv->domain = tmp_if_expr_6;
  restart_browsing(d);

__CPROVER_DUMP_L14:
  ;
}

// aui_service_dialog_set_property
// file avahi-ui.c line 1403
static void aui_service_dialog_set_property(struct _GObject *object, unsigned int prop_id, const struct _GValue *value, struct _GParamSpec *pspec)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  void *return_value_g_value_get_pointer_3;
  const char *return_value_g_value_get_string_4;
  const char *return_value_g_value_get_string_5;
  const char *return_value_g_value_get_string_6;
  signed int return_value_g_value_get_boolean_7;
  signed int return_value_g_value_get_boolean_8;
  signed int return_value_g_value_get_int_9;
  switch(prop_id)
  {
    case (unsigned int)1:
    {
      return_value_g_value_get_pointer_3=g_value_get_pointer(value);
      aui_service_dialog_set_browse_service_typesv(d, (const char * const *)return_value_g_value_get_pointer_3);
      break;
    }
    case (unsigned int)2:
    {
      return_value_g_value_get_string_4=g_value_get_string(value);
      aui_service_dialog_set_domain(d, return_value_g_value_get_string_4);
      break;
    }
    case (unsigned int)3:
    {
      return_value_g_value_get_string_5=g_value_get_string(value);
      aui_service_dialog_set_service_type(d, return_value_g_value_get_string_5);
      break;
    }
    case (unsigned int)4:
    {
      return_value_g_value_get_string_6=g_value_get_string(value);
      aui_service_dialog_set_service_name(d, return_value_g_value_get_string_6);
      break;
    }
    case (unsigned int)9:
    {
      return_value_g_value_get_boolean_7=g_value_get_boolean(value);
      aui_service_dialog_set_resolve_service(d, return_value_g_value_get_boolean_7);
      break;
    }
    case (unsigned int)10:
    {
      return_value_g_value_get_boolean_8=g_value_get_boolean(value);
      aui_service_dialog_set_resolve_host_name(d, return_value_g_value_get_boolean_8);
      break;
    }
    case (unsigned int)11:
    {
      return_value_g_value_get_int_9=g_value_get_int(value);
      aui_service_dialog_set_address_family(d, return_value_g_value_get_int_9);
      break;
    }
    default:
      do
      {
        struct _GObject *_glib__object = (struct _GObject *)object;
        struct _GParamSpec *_glib__pspec = (struct _GParamSpec *)pspec;
        unsigned int _glib__property_id = prop_id;
        const char *return_value_g_type_name_10;
        return_value_g_type_name_10=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__pspec)->g_class)->g_type);
        const char *return_value_g_type_name_11;
        return_value_g_type_name_11=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__object)->g_class)->g_type);
        g_log((char *)0, (enum anonymous_10)G_LOG_LEVEL_WARNING, "%s:%d: invalid %s id %u for \"%s\" of type '%s' in '%s'", (const void *)"avahi-ui.c", 1436, (const void *)"property", _glib__property_id, _glib__pspec->name, return_value_g_type_name_10, return_value_g_type_name_11);
      }
      while((_Bool)0);
  }
}

// aui_service_dialog_set_resolve_host_name
// file avahi-ui.h line 160
void aui_service_dialog_set_resolve_host_name(struct _AuiServiceDialog *d, signed int resolve)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_resolve_host_name", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  d->priv->resolve_host_name = resolve;

__CPROVER_DUMP_L8:
  ;
}

// aui_service_dialog_set_resolve_service
// file avahi-ui.h line 149
void aui_service_dialog_set_resolve_service(struct _AuiServiceDialog *d, signed int resolve)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_resolve_service", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  d->priv->resolve_service = resolve;

__CPROVER_DUMP_L8:
  ;
}

// aui_service_dialog_set_service_name
// file avahi-ui.c line 1312
void aui_service_dialog_set_service_name(struct _AuiServiceDialog *d, const char *name)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_service_name", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  g_free((void *)d->priv->service_name);
  d->priv->service_name=g_strdup(name);

__CPROVER_DUMP_L8:
  ;
}

// aui_service_dialog_set_service_type
// file avahi-ui.c line 1325
void aui_service_dialog_set_service_type(struct _AuiServiceDialog *d, const char *stype)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_service_type", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  g_free((void *)d->priv->service_type);
  d->priv->service_type=g_strdup(stype);

__CPROVER_DUMP_L8:
  ;
}

// aui_service_dialog_set_service_type_name
// file avahi-ui.h line 96
void aui_service_dialog_set_service_type_name(struct _AuiServiceDialog *d, const char *type, const char *name)
{
  struct _GtkTreeModel *m = (struct _GtkTreeModel *)(void *)0;
  struct _GtkTreeIter iter;
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_service_type_name", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L17;
    }

  }
  while((_Bool)0);
  do
    if(type == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_service_type_name", "NULL != type");
      goto __CPROVER_DUMP_L17;
    }

  while((_Bool)0);
  do
    if(name == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_service_type_name", "NULL != name");
      goto __CPROVER_DUMP_L17;
    }

  while((_Bool)0);
  if(d->priv->service_type_names == ((struct _GHashTable *)NULL))
    d->priv->service_type_names=g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);

  char *return_value_g_strdup_3;
  return_value_g_strdup_3=g_strdup(type);
  char *return_value_g_strdup_4;
  return_value_g_strdup_4=g_strdup(name);
  g_hash_table_insert(d->priv->service_type_names, (void *)return_value_g_strdup_3, (void *)return_value_g_strdup_4);
  unsigned long int return_value_gtk_tree_model_get_type_5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  if(!(d->priv->service_list_store == ((struct _GtkListStore *)NULL)))
  {
    return_value_gtk_tree_model_get_type_5=gtk_tree_model_get_type();
    return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_tree_model_get_type_5);
    m = (struct _GtkTreeModel *)return_value_g_type_check_instance_cast_6;
  }

  signed int return_value_gtk_tree_model_get_iter_first_9;
  signed int return_value_g_str_equal_8;
  signed int return_value_gtk_tree_model_iter_next_7;
  if(!(m == ((struct _GtkTreeModel *)NULL)))
  {
    return_value_gtk_tree_model_get_iter_first_9=gtk_tree_model_get_iter_first(m, &iter);
    if(!(return_value_gtk_tree_model_get_iter_first_9 == 0))
      do
      {
        char *stored_type = (char *)(void *)0;
        gtk_tree_model_get(m, &iter, 2, &stored_type, -1);
        if(!(stored_type == ((char *)NULL)))
        {
          return_value_g_str_equal_8=g_str_equal((const void *)stored_type, (const void *)type);
          if(!(return_value_g_str_equal_8 == 0))
            gtk_list_store_set(d->priv->service_list_store, &iter, 5, name, -1);

        }

        return_value_gtk_tree_model_iter_next_7=gtk_tree_model_iter_next(m, &iter);
      }
      while(!(return_value_gtk_tree_model_iter_next_7 == 0));

  }


__CPROVER_DUMP_L17:
  ;
}

// avahi_address_cmp
// file address.c line 46
signed int avahi_address_cmp(const struct AvahiAddress *a, const struct AvahiAddress *b)
{
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  /* assertion b */
  assert(b != ((const struct AvahiAddress *)NULL));
  if(!(a->proto == b->proto))
    return -1;

  else
  {
    unsigned long int return_value_address_get_size_1;
    return_value_address_get_size_1=address_get_size(a);
    signed int return_value_memcmp_2;
    return_value_memcmp_2=memcmp((const void *)a->data.data, (const void *)b->data.data, return_value_address_get_size_1);
    return return_value_memcmp_2;
  }
}

// avahi_address_parse
// file ../avahi-common/address.h line 95
struct AvahiAddress * avahi_address_parse(const char *s, signed int proto, struct AvahiAddress *ret_addr)
{
  /* assertion ret_addr */
  assert(ret_addr != ((struct AvahiAddress *)NULL));
  /* assertion s */
  assert(s != ((const char *)NULL));
  if(proto == -1)
  {
    signed int return_value_inet_pton_2;
    return_value_inet_pton_2=inet_pton(2, s, (void *)ret_addr->data.data);
    if(!(return_value_inet_pton_2 >= 1))
    {
      signed int return_value_inet_pton_1;
      return_value_inet_pton_1=inet_pton(10, s, (void *)ret_addr->data.data);
      if(!(return_value_inet_pton_1 >= 1))
        return (struct AvahiAddress *)(void *)0;

      else
        ret_addr->proto = 1;
    }

    else
      ret_addr->proto = 0;
  }

  else
  {
    signed int return_value_avahi_proto_to_af_3;
    return_value_avahi_proto_to_af_3=avahi_proto_to_af(proto);
    signed int return_value_inet_pton_4;
    return_value_inet_pton_4=inet_pton(return_value_avahi_proto_to_af_3, s, (void *)ret_addr->data.data);
    if(!(return_value_inet_pton_4 >= 1))
      return (struct AvahiAddress *)(void *)0;

    ret_addr->proto = proto;
  }
  return ret_addr;
}

// avahi_address_resolver_event
// file internal.h line 166
enum anonymous_42 avahi_address_resolver_event(struct AvahiClient *client, enum anonymous_12 event, struct DBusMessage *message)
{
  struct AvahiAddressResolver *r = (struct AvahiAddressResolver *)(void *)0;
  struct DBusError error;
  const char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  signed int interface;
  signed int protocol;
  signed int aprotocol;
  unsigned int flags;
  char *name;
  char *address;
  struct AvahiAddress a;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  struct AvahiAddress *return_value_avahi_address_parse_5;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  signed int return_value_avahi_error_dbus_to_number_9;
  if(!(path == ((const char *)NULL)))
  {
    r = client->address_resolvers;
    for( ; !(r == ((struct AvahiAddressResolver *)NULL)); r = r->address_resolvers_next)
    {
      return_value_strcmp_1=strcmp(r->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(r == ((struct AvahiAddressResolver *)NULL))
      goto fail;

    switch((signed int)event)
    {
      case AVAHI_RESOLVER_FOUND:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)105, &aprotocol, (signed int)115, &address, (signed int)115, &name, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        /* assertion address */
        assert(address != ((char *)NULL));
        return_value_avahi_address_parse_5=avahi_address_parse(address, (signed int)aprotocol, &a);
        if(return_value_avahi_address_parse_5 == ((struct AvahiAddress *)NULL))
        {
          fprintf(stderr, "Failed to parse address\n");
          goto fail;
        }

        r->callback(r, (signed int)interface, (signed int)protocol, (enum anonymous_12)AVAHI_RESOLVER_FOUND, &a, name, (enum anonymous_13)flags, r->userdata);
      }
      case AVAHI_RESOLVER_FAILURE:
      {
        return_value_dbus_message_get_args_6=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_6 == 0u)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
          tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_9=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(r->client, return_value_avahi_error_dbus_to_number_9);
        r->callback(r, r->interface, r->protocol, event, &r->address, (const char *)(void *)0, (enum anonymous_13)0, r->userdata);
      }
    }
    return (enum anonymous_42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous_42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_address_resolver_free
// file lookup.h line 269
signed int avahi_address_resolver_free(struct AvahiAddressResolver *r)
{
  struct AvahiClient *client;
  signed int ret = 0;
  /* assertion r */
  assert(r != ((struct AvahiAddressResolver *)NULL));
  client = r->client;
  signed int return_value_avahi_client_is_connected_1;
  if(!(r->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      ret=avahi_client_simple_method_call(client, r->path, "org.freedesktop.Avahi.AddressResolver", "Free");

  }

  do
  {
    struct AvahiAddressResolver **_head = &client->address_resolvers;
    struct AvahiAddressResolver *_item = r;
    /* assertion _item */
    assert(_item != ((struct AvahiAddressResolver *)NULL));
    if(!(_item->address_resolvers_next == ((struct AvahiAddressResolver *)NULL)))
      _item->address_resolvers_next->address_resolvers_prev = _item->address_resolvers_prev;

    if(!(_item->address_resolvers_prev == ((struct AvahiAddressResolver *)NULL)))
      _item->address_resolvers_prev->address_resolvers_next = _item->address_resolvers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->address_resolvers_next;
    }
    _item->address_resolvers_prev = (struct AvahiAddressResolver *)(void *)0;
    _item->address_resolvers_next = _item->address_resolvers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)r->path);
  avahi_free((void *)r);
  return ret;
}

// avahi_address_resolver_get_client
// file resolver.c line 755
struct AvahiClient * avahi_address_resolver_get_client(struct AvahiAddressResolver *r)
{
  /* assertion r */
  assert(r != ((struct AvahiAddressResolver *)NULL));
  return r->client;
}

// avahi_address_resolver_new
// file resolver.c line 642
struct AvahiAddressResolver * avahi_address_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const struct AvahiAddress *a, enum anonymous_44 flags, void (*callback)(struct AvahiAddressResolver *, signed int, signed int, enum anonymous_12, const struct AvahiAddress *, const char *, enum anonymous_13, void *), void *userdata)
{
  struct DBusError error;
  struct AvahiAddressResolver *r = (struct AvahiAddressResolver *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  char *path;
  char addr[40l];
  char *address = addr;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  dbus_error_init(&error);
  char *return_value_avahi_address_snprint_1;
  return_value_avahi_address_snprint_1=avahi_address_snprint(addr, sizeof(char [40l]) /*40ul*/ , a);
  void *return_value_avahi_new_internal_3;
  unsigned int return_value_dbus_message_append_args_4;
  _Bool tmp_if_expr_6;
  unsigned int return_value_dbus_error_is_set_5;
  unsigned int return_value_dbus_message_get_args_7;
  _Bool tmp_if_expr_9;
  unsigned int return_value_dbus_error_is_set_8;
  if(return_value_avahi_address_snprint_1 == ((char *)NULL))
  {
    avahi_client_set_errno(client, -14);
    return (struct AvahiAddressResolver *)(void *)0;
  }

  else
  {
    signed int return_value_avahi_client_is_connected_2;
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(client);
    if(return_value_avahi_client_is_connected_2 == 0)
      avahi_client_set_errno(client, -2);

    else
    {
      return_value_avahi_new_internal_3=avahi_new_internal_link3((unsigned int)1, sizeof(struct AvahiAddressResolver) /*80ul*/ );
      r = (struct AvahiAddressResolver *)return_value_avahi_new_internal_3;
      if(r == ((struct AvahiAddressResolver *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        r->client = client;
        r->callback = callback;
        r->userdata = userdata;
        r->path = (char *)(void *)0;
        r->interface = interface;
        r->protocol = protocol;
        r->address = *a;
        do
        {
          struct AvahiAddressResolver **_head = &client->address_resolvers;
          struct AvahiAddressResolver *_item = r;
          /* assertion _item */
          assert(_item != ((struct AvahiAddressResolver *)NULL));
          _item->address_resolvers_next = *_head;
          if(!(_item->address_resolvers_next == ((struct AvahiAddressResolver *)NULL)))
            _item->address_resolvers_next->address_resolvers_prev = _item;

          _item->address_resolvers_prev = (struct AvahiAddressResolver *)(void *)0;
          *_head = _item;
        }
        while((_Bool)0);
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "AddressResolverNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args_4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &address, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args_4 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr_6 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_5=dbus_error_is_set(&error);
              tmp_if_expr_6 = return_value_dbus_error_is_set_5 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_6)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args_7=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args_7 == 0u)
                tmp_if_expr_9 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set_8=dbus_error_is_set(&error);
                tmp_if_expr_9 = return_value_dbus_error_is_set_8 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr_9)
                avahi_client_set_errno(client, -22);

              else
              {
                r->path=avahi_strdup(path);
                if(r->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return r;
                }
              }
            }
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_10;
    return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_10 == 0u))
    {
      avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(r == ((struct AvahiAddressResolver *)NULL)))
      avahi_address_resolver_free(r);

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return (struct AvahiAddressResolver *)(void *)0;
  }
}

// avahi_address_snprint
// file ../avahi-common/address.h line 90
char * avahi_address_snprint(char *s, unsigned long int length, const struct AvahiAddress *a)
{
  /* assertion s */
  assert(s != ((char *)NULL));
  /* assertion length */
  assert(length != 0ul);
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  signed int return_value_avahi_proto_to_af_1;
  return_value_avahi_proto_to_af_1=avahi_proto_to_af(a->proto);
  const char *return_value_inet_ntop_2;
  return_value_inet_ntop_2=inet_ntop(return_value_avahi_proto_to_af_1, (const void *)a->data.data, s, (unsigned int)length);
  if(return_value_inet_ntop_2 == ((const char *)NULL))
    return (char *)(void *)0;

  else
    return s;
}

// avahi_af_to_proto
// file address.c line 137
signed int avahi_af_to_proto(signed int af)
{
  if(af == 2)
    return 0;

  else
    if(af == 10)
      return 1;

    else
    {
      /* assertion af == 0 */
      assert(af == 0);
      return -1;
    }
}

// avahi_age
// file timeval.c line 76
signed long int avahi_age(struct timeval *a)
{
  struct timeval now;
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  gettimeofday(&now, (struct timezone *)(void *)0);
  signed long int return_value_avahi_timeval_diff_1;
  return_value_avahi_timeval_diff_1=avahi_timeval_diff(&now, a);
  return return_value_avahi_timeval_diff_1;
}

// avahi_alternative_host_name
// file alternative.c line 51
char * avahi_alternative_host_name(const char *s)
{
  const char *e;
  char *r;
  /* assertion s */
  assert(s != ((const char *)NULL));
  signed int return_value_avahi_is_valid_host_name_1;
  return_value_avahi_is_valid_host_name_1=avahi_is_valid_host_name(s);
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_5;
  if(return_value_avahi_is_valid_host_name_1 == 0)
    return (char *)(void *)0;

  else
  {
    e=strrchr(s, 45);
    if(!(e == ((const char *)NULL)))
    {
      const char *p;
      e = e + 1l;
      p = e;
      for( ; !(*p == 0); p = p + 1l)
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*p]) == 0)
        {
          e = (const char *)(void *)0;
          break;
        }

      }
      if(!(e == ((const char *)NULL)))
      {
        if((signed int)*e == 48)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)*e == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
          e = (const char *)(void *)0;

      }

    }

    if(!(e == ((const char *)NULL)))
    {
      char *avahi_alternative_host_name__1__2__c;
      char *m;
      unsigned long int l;
      signed int n;
      signed int return_value_atoi_4;
      return_value_atoi_4=atoi(e);
      n = return_value_atoi_4 + 1;
      m=avahi_strdup_printf("%i", n);
      if(m == ((char *)NULL))
        return (char *)(void *)0;

      l = (unsigned long int)((e - s) - (signed long int)1);
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(m);
      if(l >= 63ul + -return_value_strlen_6 + 18446744073709551615ul)
      {
        return_value_strlen_5=strlen(m);
        l = ((unsigned long int)(64 - 1) - return_value_strlen_5) - (unsigned long int)1;
      }

      avahi_alternative_host_name__1__2__c=avahi_strndup(s, l);
      if(avahi_alternative_host_name__1__2__c == ((char *)NULL))
      {
        avahi_free((void *)m);
        return (char *)(void *)0;
      }

      drop_incomplete_utf8(avahi_alternative_host_name__1__2__c);
      r=avahi_strdup_printf("%s-%s", avahi_alternative_host_name__1__2__c, m);
      avahi_free((void *)avahi_alternative_host_name__1__2__c);
      avahi_free((void *)m);
    }

    else
    {
      char *c;
      c=avahi_strndup(s, (unsigned long int)((64 - 1) - 2));
      if(c == ((char *)NULL))
        return (char *)(void *)0;

      drop_incomplete_utf8(c);
      r=avahi_strdup_printf("%s-2", c);
      avahi_free((void *)c);
    }
    signed int return_value_avahi_is_valid_host_name_7;
    return_value_avahi_is_valid_host_name_7=avahi_is_valid_host_name(r);
    /* assertion avahi_is_valid_host_name(r) */
    assert(return_value_avahi_is_valid_host_name_7 != 0);
    return r;
  }
}

// avahi_alternative_service_name
// file alternative.c line 117
char * avahi_alternative_service_name(const char *s)
{
  const char *e;
  char *r;
  /* assertion s */
  assert(s != ((const char *)NULL));
  signed int return_value_avahi_is_valid_service_name_1;
  return_value_avahi_is_valid_service_name_1=avahi_is_valid_service_name(s);
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_5;
  if(return_value_avahi_is_valid_service_name_1 == 0)
    return (char *)(void *)0;

  else
  {
    e=strstr(s, " #");
    if(!(e == ((const char *)NULL)))
    {
      const char *n;
      const char *p;
      e = e + (signed long int)2;
      do
      {
        n=strstr(e, " #");
        if(n == ((const char *)NULL))
          break;

        e = n + (signed long int)2;
      }
      while((_Bool)1);
      p = e;
      for( ; !(*p == 0); p = p + 1l)
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*p]) == 0)
        {
          e = (const char *)(void *)0;
          break;
        }

      }
      if(!(e == ((const char *)NULL)))
      {
        if((signed int)*e == 48)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)*e == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
          e = (const char *)(void *)0;

      }

    }

    if(!(e == ((const char *)NULL)))
    {
      char *c;
      char *m;
      unsigned long int l;
      signed int avahi_alternative_service_name__1__2__n;
      signed int return_value_atoi_4;
      return_value_atoi_4=atoi(e);
      avahi_alternative_service_name__1__2__n = return_value_atoi_4 + 1;
      m=avahi_strdup_printf("%i", avahi_alternative_service_name__1__2__n);
      if(m == ((char *)NULL))
        return (char *)(void *)0;

      l = (unsigned long int)((e - s) - (signed long int)2);
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(m);
      if(l >= 63ul + -return_value_strlen_6 + 18446744073709551614ul)
      {
        return_value_strlen_5=strlen(m);
        l = ((unsigned long int)(64 - 1) - return_value_strlen_5) - (unsigned long int)2;
      }

      c=avahi_strndup(s, l);
      if(c == ((char *)NULL))
      {
        avahi_free((void *)m);
        return (char *)(void *)0;
      }

      drop_incomplete_utf8(c);
      r=avahi_strdup_printf("%s #%s", c, m);
      avahi_free((void *)c);
      avahi_free((void *)m);
    }

    else
    {
      char *avahi_alternative_service_name__1__3__c;
      avahi_alternative_service_name__1__3__c=avahi_strndup(s, (unsigned long int)((64 - 1) - 3));
      if(avahi_alternative_service_name__1__3__c == ((char *)NULL))
        return (char *)(void *)0;

      drop_incomplete_utf8(avahi_alternative_service_name__1__3__c);
      r=avahi_strdup_printf("%s #2", avahi_alternative_service_name__1__3__c);
      avahi_free((void *)avahi_alternative_service_name__1__3__c);
    }
    signed int return_value_avahi_is_valid_service_name_7;
    return_value_avahi_is_valid_service_name_7=avahi_is_valid_service_name(r);
    /* assertion avahi_is_valid_service_name(r) */
    assert(return_value_avahi_is_valid_service_name_7 != 0);
    return r;
  }
}

// avahi_client_errno
// file client.c line 790
signed int avahi_client_errno(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  return client->error;
}

// avahi_client_free
// file client.c line 625
void avahi_client_free(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  if(!(client->bus == ((struct DBusConnection *)NULL)))
    dbus_connection_close(client->bus);

  while(!(client->groups == ((struct AvahiEntryGroup *)NULL)))
    avahi_entry_group_free(client->groups);
  while(!(client->domain_browsers == ((struct AvahiDomainBrowser *)NULL)))
    avahi_domain_browser_free(client->domain_browsers);
  while(!(client->service_browsers == ((struct AvahiServiceBrowser *)NULL)))
    avahi_service_browser_free(client->service_browsers);
  while(!(client->service_type_browsers == ((struct AvahiServiceTypeBrowser *)NULL)))
    avahi_service_type_browser_free(client->service_type_browsers);
  while(!(client->service_resolvers == ((struct AvahiServiceResolver *)NULL)))
    avahi_service_resolver_free(client->service_resolvers);
  while(!(client->host_name_resolvers == ((struct AvahiHostNameResolver *)NULL)))
    avahi_host_name_resolver_free(client->host_name_resolvers);
  while(!(client->address_resolvers == ((struct AvahiAddressResolver *)NULL)))
    avahi_address_resolver_free(client->address_resolvers);
  while(!(client->record_browsers == ((struct AvahiRecordBrowser *)NULL)))
    avahi_record_browser_free(client->record_browsers);
  if(!(client->bus == ((struct DBusConnection *)NULL)))
    dbus_connection_unref(client->bus);

  avahi_free((void *)client->version_string);
  avahi_free((void *)client->host_name);
  avahi_free((void *)client->host_name_fqdn);
  avahi_free((void *)client->domain_name);
  avahi_free((void *)client);
}

// avahi_client_get_domain_name
// file client.c line 742
const char * avahi_client_get_domain_name(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected_1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->domain_name == ((char *)NULL))
      client->domain_name=avahi_client_get_string_reply_and_block(client, "GetDomainName", (const char *)(void *)0);

    return client->domain_name;
  }
}

// avahi_client_get_host_name
// file client.c line 756
const char * avahi_client_get_host_name(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected_1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->host_name == ((char *)NULL))
      client->host_name=avahi_client_get_string_reply_and_block(client, "GetHostName", (const char *)(void *)0);

    return client->host_name;
  }
}

// avahi_client_get_host_name_fqdn
// file client.c line 770
const char * avahi_client_get_host_name_fqdn(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected_1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->host_name_fqdn == ((char *)NULL))
      client->host_name_fqdn=avahi_client_get_string_reply_and_block(client, "GetHostNameFqdn", (const char *)(void *)0);

    return client->host_name_fqdn;
  }
}

// avahi_client_get_local_service_cookie
// file client.c line 846
unsigned int avahi_client_get_local_service_cookie(struct AvahiClient *client)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  _Bool tmp_if_expr_3;
  unsigned int return_value_dbus_error_is_set_2;
  unsigned int return_value_dbus_message_get_args_4;
  _Bool tmp_if_expr_6;
  unsigned int return_value_dbus_error_is_set_5;
  if(return_value_avahi_client_is_connected_1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (unsigned int)0;
  }

  else
    if(!(client->local_service_cookie_valid == 0))
      return client->local_service_cookie;

    else
    {
      dbus_error_init(&error);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetLocalServiceCookie");
      if(message == ((struct DBusMessage *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_2=dbus_error_is_set(&error);
          tmp_if_expr_3 = return_value_dbus_error_is_set_2 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr_3)
        {
          return_value_dbus_message_get_args_4=dbus_message_get_args(reply, &error, (signed int)117, &client->local_service_cookie, (signed int)0);
          if(return_value_dbus_message_get_args_4 == 0u)
            tmp_if_expr_6 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_5=dbus_error_is_set(&error);
            tmp_if_expr_6 = return_value_dbus_error_is_set_5 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr_6)
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            client->local_service_cookie_valid = 1;
            return client->local_service_cookie;
          }

        }

      }

    fail:
      ;
      if(!(message == ((struct DBusMessage *)NULL)))
        dbus_message_unref(message);

      if(!(reply == ((struct DBusMessage *)NULL)))
        dbus_message_unref(reply);

      unsigned int return_value_dbus_error_is_set_7;
      return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
      if(!(return_value_dbus_error_is_set_7 == 0u))
      {
        avahi_client_set_dbus_error(client, &error);
        dbus_error_free(&error);
      }

      return (unsigned int)0;
    }
}

// avahi_client_get_state
// file client.c line 784
enum anonymous_11 avahi_client_get_state(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  return client->state;
}

// avahi_client_get_string_reply_and_block
// file client.c line 672
static char * avahi_client_get_string_reply_and_block(struct AvahiClient *client, const char *method, const char *param)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *ret;
  char *n;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion method */
  assert(method != ((const char *)NULL));
  dbus_error_init(&error);
  message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", method);
  _Bool tmp_if_expr_3;
  unsigned int return_value_dbus_error_is_set_2;
  unsigned int return_value_dbus_message_get_args_4;
  _Bool tmp_if_expr_6;
  unsigned int return_value_dbus_error_is_set_5;
  if(message == ((struct DBusMessage *)NULL))
    avahi_client_set_errno(client, -24);

  else
  {
    if(!(param == ((const char *)NULL)))
    {
      unsigned int return_value_dbus_message_append_args_1;
      return_value_dbus_message_append_args_1=dbus_message_append_args(message, (signed int)115, &param, (signed int)0);
      if(return_value_dbus_message_append_args_1 == 0u)
      {
        avahi_client_set_errno(client, -24);
        goto fail;
      }

    }

    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_2=dbus_error_is_set(&error);
      tmp_if_expr_3 = return_value_dbus_error_is_set_2 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_3)
    {
      return_value_dbus_message_get_args_4=dbus_message_get_args(reply, &error, (signed int)115, &ret, (signed int)0);
      if(return_value_dbus_message_get_args_4 == 0u)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_5=dbus_error_is_set(&error);
        tmp_if_expr_6 = return_value_dbus_error_is_set_5 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_6)
      {
        n=avahi_strdup(ret);
        if(n == ((char *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          dbus_message_unref(message);
          dbus_message_unref(reply);
          return n;
        }
      }

    }

  }

fail:
  ;
  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  unsigned int return_value_dbus_error_is_set_7;
  return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_7 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  return (char *)(void *)0;
}

// avahi_client_get_string_reply_and_block_link1
// file client.c line 672
static char * avahi_client_get_string_reply_and_block_link1(struct AvahiClient *client_link1, const char *method_link1, const char *param_link1)
{
  struct DBusMessage *message_link1 = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply_link1 = (struct DBusMessage *)(void *)0;
  struct DBusError error_link1;
  char *ret_link1;
  char *n_link1;
  /* assertion client */
  assert(client_link1 != ((struct AvahiClient *)NULL));
  /* assertion method */
  assert(method_link1 != ((const char *)NULL));
  dbus_error_init(&error_link1);
  message_link1=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", method_link1);
  _Bool tmp_if_expr_3_link1;
  unsigned int return_value_dbus_error_is_set_2_link1;
  unsigned int return_value_dbus_message_get_args_4_link1;
  _Bool tmp_if_expr_6_link1;
  unsigned int return_value_dbus_error_is_set_5_link1;
  if(message_link1 == ((struct DBusMessage *)NULL))
    avahi_client_set_errno(client_link1, -24);

  else
  {
    if(!(param_link1 == ((const char *)NULL)))
    {
      unsigned int return_value_dbus_message_append_args_1_link1;
      return_value_dbus_message_append_args_1_link1=dbus_message_append_args(message_link1, (signed int)115, &param_link1, (signed int)0);
      if(return_value_dbus_message_append_args_1_link1 == 0u)
      {
        avahi_client_set_errno(client_link1, -24);
        goto fail;
      }

    }

    reply_link1=dbus_connection_send_with_reply_and_block(client_link1->bus, message_link1, -1, &error_link1);
    if(reply_link1 == ((struct DBusMessage *)NULL))
      tmp_if_expr_3_link1 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_2_link1=dbus_error_is_set(&error_link1);
      tmp_if_expr_3_link1 = return_value_dbus_error_is_set_2_link1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_3_link1)
    {
      return_value_dbus_message_get_args_4_link1=dbus_message_get_args(reply_link1, &error_link1, (signed int)115, &ret_link1, (signed int)0);
      if(return_value_dbus_message_get_args_4_link1 == 0u)
        tmp_if_expr_6_link1 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_5_link1=dbus_error_is_set(&error_link1);
        tmp_if_expr_6_link1 = return_value_dbus_error_is_set_5_link1 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_6_link1)
      {
        n_link1=avahi_strdup(ret_link1);
        if(n_link1 == ((char *)NULL))
          avahi_client_set_errno(client_link1, -24);

        else
        {
          dbus_message_unref(message_link1);
          dbus_message_unref(reply_link1);
          return n_link1;
        }
      }

    }

  }

fail:
  ;
  if(!(message_link1 == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message_link1);

  if(!(reply_link1 == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply_link1);

  unsigned int return_value_dbus_error_is_set_7_link1;
  return_value_dbus_error_is_set_7_link1=dbus_error_is_set(&error_link1);
  if(!(return_value_dbus_error_is_set_7_link1 == 0u))
  {
    avahi_client_set_dbus_error(client_link1, &error_link1);
    dbus_error_free(&error_link1);
  }

  return (char *)(void *)0;
}

// avahi_client_get_version_string
// file client.c line 728
const char * avahi_client_get_version_string(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected_1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->version_string == ((char *)NULL))
      client->version_string=avahi_client_get_string_reply_and_block(client, "GetVersionString", (const char *)(void *)0);

    return client->version_string;
  }
}

// avahi_client_is_connected
// file client.c line 896
signed int avahi_client_is_connected(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  _Bool tmp_if_expr_2;
  unsigned int return_value_dbus_connection_get_is_connected_1;
  if(!(client->bus == ((struct DBusConnection *)NULL)))
  {
    return_value_dbus_connection_get_is_connected_1=dbus_connection_get_is_connected(client->bus);
    tmp_if_expr_2 = return_value_dbus_connection_get_is_connected_1 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_2)
  {
    if((signed int)client->state == AVAHI_CLIENT_S_RUNNING)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)client->state == AVAHI_CLIENT_S_REGISTERING ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)client->state == AVAHI_CLIENT_S_COLLISION ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  return (signed int)tmp_if_expr_5;
}

// avahi_client_new
// file client.c line 478
struct AvahiClient * avahi_client_new(const struct AvahiPoll_1 *poll_api, enum anonymous_39 flags, void (*callback)(struct AvahiClient *, enum anonymous_11, void *), void *userdata, signed int *ret_error)
{
  struct AvahiClient *client = (struct AvahiClient *)(void *)0;
  struct DBusError error;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  avahi_init_i18n();
  dbus_error_init(&error);
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal((unsigned int)1, sizeof(struct AvahiClient) /*152ul*/ );
  client = (struct AvahiClient *)return_value_avahi_new_internal_1;
  _Bool tmp_if_expr_3;
  unsigned int return_value_dbus_error_is_set_2;
  signed int return_value_avahi_dbus_connection_glue_4;
  unsigned int return_value_dbus_connection_add_filter_5;
  unsigned int return_value_dbus_error_is_set_6;
  unsigned int return_value_dbus_error_is_set_7;
  unsigned int return_value_dbus_error_is_set_8;
  _Bool tmp_if_expr_11;
  unsigned int return_value_dbus_error_is_set_10;
  if(client == ((struct AvahiClient *)NULL))
  {
    if(!(ret_error == ((signed int *)NULL)))
      *ret_error = -24;

  }

  else
  {
    client->poll_api = poll_api;
    client->error = 0;
    client->callback = callback;
    client->userdata = userdata;
    client->state = (enum anonymous_11)-1;
    client->flags = flags;
    client->host_name = (char *)(void *)0;
    client->host_name_fqdn = (char *)(void *)0;
    client->domain_name = (char *)(void *)0;
    client->version_string = (char *)(void *)0;
    client->local_service_cookie_valid = 0;
    do
      client->groups = (struct AvahiEntryGroup *)(void *)0;
    while((_Bool)0);
    do
      client->domain_browsers = (struct AvahiDomainBrowser *)(void *)0;
    while((_Bool)0);
    do
      client->service_browsers = (struct AvahiServiceBrowser *)(void *)0;
    while((_Bool)0);
    do
      client->service_type_browsers = (struct AvahiServiceTypeBrowser *)(void *)0;
    while((_Bool)0);
    do
      client->service_resolvers = (struct AvahiServiceResolver *)(void *)0;
    while((_Bool)0);
    do
      client->host_name_resolvers = (struct AvahiHostNameResolver *)(void *)0;
    while((_Bool)0);
    do
      client->address_resolvers = (struct AvahiAddressResolver *)(void *)0;
    while((_Bool)0);
    do
      client->record_browsers = (struct AvahiRecordBrowser *)(void *)0;
    while((_Bool)0);
    client->bus=avahi_dbus_bus_get(&error);
    if(client->bus == ((struct DBusConnection *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_2=dbus_error_is_set(&error);
      tmp_if_expr_3 = return_value_dbus_error_is_set_2 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
    {
      if(!(ret_error == ((signed int *)NULL)))
        *ret_error = -22;

    }

    else
    {
      return_value_avahi_dbus_connection_glue_4=avahi_dbus_connection_glue(client->bus, poll_api);
      if(!(return_value_avahi_dbus_connection_glue_4 >= 0))
      {
        if(!(ret_error == ((signed int *)NULL)))
          *ret_error = -24;

      }

      else
      {
        return_value_dbus_connection_add_filter_5=dbus_connection_add_filter(client->bus, filter_func, (void *)client, (void (*)(void *))(void *)0);
        if(return_value_dbus_connection_add_filter_5 == 0u)
        {
          if(!(ret_error == ((signed int *)NULL)))
            *ret_error = -24;

        }

        else
        {
          dbus_bus_add_match(client->bus, "type='signal', interface='org.freedesktop.Avahi.Server', sender='org.freedesktop.Avahi', path='/'", &error);
          return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
          if(return_value_dbus_error_is_set_6 == 0u)
          {
            dbus_bus_add_match(client->bus, "type='signal', interface='org.freedesktop.DBus', sender='org.freedesktop.DBus', path='/org/freedesktop/DBus'", &error);
            return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
            if(return_value_dbus_error_is_set_7 == 0u)
            {
              dbus_bus_add_match(client->bus, "type='signal', interface='org.freedesktop.DBus.Local'", &error);
              return_value_dbus_error_is_set_8=dbus_error_is_set(&error);
              if(return_value_dbus_error_is_set_8 == 0u)
              {
                message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.DBus.Peer", "Ping");
                if(!(message == ((struct DBusMessage *)NULL)))
                {
                  reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
                  if(reply == ((struct DBusMessage *)NULL))
                    tmp_if_expr_11 = (_Bool)1;

                  else
                  {
                    return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
                    tmp_if_expr_11 = return_value_dbus_error_is_set_10 != 0u ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_11)
                  {
                    dbus_error_free(&error);
                    if((AVAHI_CLIENT_NO_FAIL & (signed int)flags) == 0)
                    {
                      if(!(ret_error == ((signed int *)NULL)))
                        *ret_error = -26;

                      goto fail;
                    }

                    client_set_state(client, (enum anonymous_11)AVAHI_CLIENT_CONNECTING);
                  }

                  else
                  {
                    signed int return_value_init_server_9;
                    return_value_init_server_9=init_server(client, ret_error);
                    if(!(return_value_init_server_9 >= 0))
                      goto fail;

                  }
                  dbus_message_unref(message);
                  if(!(reply == ((struct DBusMessage *)NULL)))
                    dbus_message_unref(reply);

                  return client;
                }

              }

            }

          }

        }
      }
    }
  }

fail:
  ;
  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  if(!(client == ((struct AvahiClient *)NULL)))
    avahi_client_free(client);

  unsigned int return_value_dbus_error_is_set_13;
  return_value_dbus_error_is_set_13=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_13 == 0u))
  {
    if(!(ret_error == ((signed int *)NULL)))
    {
      signed int return_value_strcmp_12;
      return_value_strcmp_12=strcmp(error.name, "org.freedesktop.DBus.Error.FileNotFound");
      if(return_value_strcmp_12 == 0)
        *ret_error = -26;

      else
        *ret_error=avahi_error_dbus_to_number(error.name);
    }

    dbus_error_free(&error);
  }

  return (struct AvahiClient *)(void *)0;
}

// avahi_client_set_dbus_error
// file client.c line 51
signed int avahi_client_set_dbus_error(struct AvahiClient *client, struct DBusError *error)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion error */
  assert(error != ((struct DBusError *)NULL));
  signed int return_value_avahi_error_dbus_to_number_1;
  return_value_avahi_error_dbus_to_number_1=avahi_error_dbus_to_number(error->name);
  signed int return_value_avahi_client_set_errno_2;
  return_value_avahi_client_set_errno_2=avahi_client_set_errno(client, return_value_avahi_error_dbus_to_number_1);
  return return_value_avahi_client_set_errno_2;
}

// avahi_client_set_errno
// file client.c line 45
signed int avahi_client_set_errno(struct AvahiClient *client, signed int error)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  client->error = error;
  return client->error;
}

// avahi_client_set_host_name
// file client.c line 905
signed int avahi_client_set_host_name(struct AvahiClient *client, const char *name)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected_2;
  return_value_avahi_client_is_connected_2=avahi_client_is_connected(client);
  signed int return_value_avahi_client_set_errno_1;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_2 == 0)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "SetHostName");
    if(message == ((struct DBusMessage *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)115, &name, (signed int)0);
      if(return_value_dbus_message_append_args_3 == 0u)
        avahi_client_set_errno(client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
          tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr_5)
        {
          return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args_6 == 0u)
            tmp_if_expr_8 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
            tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr_8)
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            avahi_free((void *)client->host_name);
            client->host_name = (char *)(void *)0;
            avahi_free((void *)client->host_name_fqdn);
            client->host_name_fqdn = (char *)(void *)0;
            return 0;
          }

        }

      }
    }

  fail:
    ;
    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    unsigned int return_value_dbus_error_is_set_9;
    return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_9 == 0u))
    {
      avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    return client->error;
  }
}

// avahi_client_simple_method_call
// file client.c line 797
signed int avahi_client_simple_method_call(struct AvahiClient *client, const char *path, const char *interface, const char *method)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  dbus_error_init(&error);
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion path */
  assert(path != ((const char *)NULL));
  /* assertion interface */
  assert(interface != ((const char *)NULL));
  /* assertion method */
  assert(method != ((const char *)NULL));
  message=dbus_message_new_method_call("org.freedesktop.Avahi", path, interface, method);
  _Bool tmp_if_expr_2;
  unsigned int return_value_dbus_error_is_set_1;
  unsigned int return_value_dbus_message_get_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  if(message == ((struct DBusMessage *)NULL))
    r=avahi_client_set_errno(client, -24);

  else
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_1=dbus_error_is_set(&error);
      tmp_if_expr_2 = return_value_dbus_error_is_set_1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      r=avahi_client_set_errno(client, -22);

    else
    {
      return_value_dbus_message_get_args_3=dbus_message_get_args(reply, &error, (signed int)0);
      if(return_value_dbus_message_get_args_3 == 0u)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
        tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        r=avahi_client_set_errno(client, -22);

      else
      {
        dbus_message_unref(message);
        dbus_message_unref(reply);
        return 0;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_6;
  return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_6 == 0u))
  {
    r=avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return r;
}

// avahi_dbus_bus_get
// file client.c line 445
static struct DBusConnection * avahi_dbus_bus_get(struct DBusError *error)
{
  struct DBusConnection *c;
  c=dbus_bus_get_private((enum anonymous_45)DBUS_BUS_SYSTEM, error);
  if(c == ((struct DBusConnection *)NULL))
    return (struct DBusConnection *)(void *)0;

  else
  {
    dbus_connection_set_exit_on_disconnect(c, (unsigned int)0);
    return c;
  }
}

// avahi_dbus_bus_get_link1
// file client.c line 445
static struct DBusConnection * avahi_dbus_bus_get_link1(struct DBusError *error_link1)
{
  struct DBusConnection *c_link1;
  c_link1=dbus_bus_get_private((enum anonymous_45)DBUS_BUS_SYSTEM, error_link1);
  if(c_link1 == ((struct DBusConnection *)NULL))
    return (struct DBusConnection *)(void *)0;

  else
  {
    dbus_connection_set_exit_on_disconnect(c_link1, (unsigned int)0);
    return c_link1;
  }
}

// avahi_dbus_connection_glue
// file ../avahi-common/dbus-watch-glue.h line 29
signed int avahi_dbus_connection_glue(struct DBusConnection *c, const struct AvahiPoll_1 *poll_api)
{
  struct anonymous_28 *d = (struct anonymous_28 *)(void *)0;
  /* assertion c */
  assert(c != ((struct DBusConnection *)NULL));
  /* assertion poll_api */
  assert(poll_api != ((const struct AvahiPoll_1 *)NULL));
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link4((unsigned int)1, sizeof(struct anonymous_28) /*32ul*/ );
  d = (struct anonymous_28 *)return_value_avahi_new_internal_1;
  struct anonymous_28 *return_value_connection_data_ref_2;
  unsigned int return_value_dbus_connection_set_watch_functions_3;
  struct anonymous_28 *return_value_connection_data_ref_4;
  unsigned int return_value_dbus_connection_set_timeout_functions_5;
  struct anonymous_28 *return_value_connection_data_ref_6;
  enum anonymous_27 return_value_dbus_connection_get_dispatch_status_7;
  if(!(d == ((struct anonymous_28 *)NULL)))
  {
    d->poll_api = poll_api;
    d->connection = c;
    d->ref = 1;
    d->dispatch_timeout=poll_api->timeout_new(poll_api, (struct timeval *)(void *)0, dispatch_timeout_callback, (void *)d);
    return_value_connection_data_ref_2=connection_data_ref(d);
    return_value_dbus_connection_set_watch_functions_3=dbus_connection_set_watch_functions(c, add_watch, remove_watch, watch_toggled, (void *)return_value_connection_data_ref_2, (void (*)(void *))connection_data_unref);
    return_value_connection_data_ref_4=connection_data_ref(d);
    return_value_dbus_connection_set_timeout_functions_5=dbus_connection_set_timeout_functions(c, add_timeout, remove_timeout, timeout_toggled, (void *)return_value_connection_data_ref_4, (void (*)(void *))connection_data_unref);
    return_value_connection_data_ref_6=connection_data_ref(d);
    dbus_connection_set_dispatch_status_function(c, dispatch_status, (void *)return_value_connection_data_ref_6, (void (*)(void *))connection_data_unref);
    return_value_dbus_connection_get_dispatch_status_7=dbus_connection_get_dispatch_status(c);
    if((signed int)return_value_dbus_connection_get_dispatch_status_7 == DBUS_DISPATCH_DATA_REMAINS)
      request_dispatch(d, 1);

    connection_data_unref(d);
    return 0;
  }

  else
  {

  fail:
    ;
    if(!(d == ((struct anonymous_28 *)NULL)))
    {
      d->poll_api->timeout_free(d->dispatch_timeout);
      avahi_free((void *)d);
    }

    return -1;
  }
}

// avahi_domain_browser_event
// file internal.h line 159
enum anonymous_42 avahi_domain_browser_event(struct AvahiClient *client, enum anonymous_14 event, struct DBusMessage *message)
{
  struct AvahiDomainBrowser *db = (struct AvahiDomainBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *domain = (char *)(void *)0;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  struct AvahiStringList *l;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_5;
  _Bool tmp_if_expr_7;
  unsigned int return_value_dbus_error_is_set_6;
  signed int return_value_avahi_error_dbus_to_number_8;
  signed int return_value_avahi_domain_equal_9;
  if(!(path == ((const char *)NULL)))
  {
    db = client->domain_browsers;
    for( ; !(db == ((struct AvahiDomainBrowser *)NULL)); db = db->domain_browsers_next)
    {
      return_value_strcmp_1=strcmp(db->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(db == ((struct AvahiDomainBrowser *)NULL))
      goto fail;

    interface = db->interface;
    protocol = db->protocol;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &domain, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args_5=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_5 == 0u)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
          tmp_if_expr_7 = return_value_dbus_error_is_set_6 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_8=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(db->client, return_value_avahi_error_dbus_to_number_8);
      }
    }
    if(!(domain == ((char *)NULL)))
    {
      l = db->static_browse_domains;
      for( ; !(l == ((struct AvahiStringList *)NULL)); l = l->next)
      {
        return_value_avahi_domain_equal_9=avahi_domain_equal((char *)l->text, domain);
        if(!(return_value_avahi_domain_equal_9 == 0))
          return (enum anonymous_42)DBUS_HANDLER_RESULT_HANDLED;

      }
    }

    db->callback(db, (signed int)interface, (signed int)protocol, event, domain, (enum anonymous_13)flags, db->userdata);
    return (enum anonymous_42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous_42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_domain_browser_free
// file lookup.h line 71
signed int avahi_domain_browser_free(struct AvahiDomainBrowser *b)
{
  struct AvahiClient *client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  /* assertion b->ref >= 1 */
  assert(b->ref >= 1);
  b->ref = b->ref - 1;
  signed int return_value_avahi_client_is_connected_1;
  if(b->ref >= 1)
    return 0;

  else
  {
    client = b->client;
    if(!(b->path == ((char *)NULL)))
    {
      return_value_avahi_client_is_connected_1=avahi_client_is_connected(b->client);
      if(!(return_value_avahi_client_is_connected_1 == 0))
        r=avahi_client_simple_method_call(client, b->path, "org.freedesktop.Avahi.DomainBrowser", "Free");

    }

    do
    {
      struct AvahiDomainBrowser **_head = &client->domain_browsers;
      struct AvahiDomainBrowser *_item = b;
      /* assertion _item */
      assert(_item != ((struct AvahiDomainBrowser *)NULL));
      if(!(_item->domain_browsers_next == ((struct AvahiDomainBrowser *)NULL)))
        _item->domain_browsers_next->domain_browsers_prev = _item->domain_browsers_prev;

      if(!(_item->domain_browsers_prev == ((struct AvahiDomainBrowser *)NULL)))
        _item->domain_browsers_prev->domain_browsers_next = _item->domain_browsers_next;

      else
      {
        /* assertion *_head == _item */
        assert(*_head == _item);
        *_head = _item->domain_browsers_next;
      }
      _item->domain_browsers_prev = (struct AvahiDomainBrowser *)(void *)0;
      _item->domain_browsers_next = _item->domain_browsers_prev;
    }
    while((_Bool)0);
    if(!(b->defer_timeout == ((struct AvahiTimeout_1 *)NULL)))
      b->client->poll_api->timeout_free(b->defer_timeout);

    avahi_string_list_free(b->static_browse_domains);
    avahi_free((void *)b->path);
    avahi_free((void *)b);
    return r;
  }
}

// avahi_domain_browser_get_client
// file browser.c line 234
struct AvahiClient * avahi_domain_browser_get_client(struct AvahiDomainBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  return b->client;
}

// avahi_domain_browser_new
// file browser.c line 104
struct AvahiDomainBrowser * avahi_domain_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous_43 btype, enum anonymous_44 flags, void (*callback)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous_14, const char *, enum anonymous_13, void *), void *userdata)
{
  struct AvahiDomainBrowser *db = (struct AvahiDomainBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_interface;
  signed int i_protocol;
  signed int bt;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous_14, const char *, enum anonymous_13, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    return_value_avahi_new_internal_2=avahi_new_internal_link2((unsigned int)1, sizeof(struct AvahiDomainBrowser) /*80ul*/ );
    db = (struct AvahiDomainBrowser *)return_value_avahi_new_internal_2;
    if(db == ((struct AvahiDomainBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      db->ref = 1;
      db->client = client;
      db->callback = callback;
      db->userdata = userdata;
      db->path = (char *)(void *)0;
      db->interface = interface;
      db->protocol = protocol;
      db->static_browse_domains = (struct AvahiStringList *)(void *)0;
      db->defer_timeout = (struct AvahiTimeout_1 *)(void *)0;
      do
      {
        struct AvahiDomainBrowser **_head = &client->domain_browsers;
        struct AvahiDomainBrowser *_item = db;
        /* assertion _item */
        assert(_item != ((struct AvahiDomainBrowser *)NULL));
        _item->domain_browsers_next = *_head;
        if(!(_item->domain_browsers_next == ((struct AvahiDomainBrowser *)NULL)))
          _item->domain_browsers_next->domain_browsers_prev = _item;

        _item->domain_browsers_prev = (struct AvahiDomainBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      if((AVAHI_CLIENT_IGNORE_USER_CONFIG & (signed int)client->flags) == 0)
      {
        parse_environment(db);
        parse_domain_file(db);
      }

      db->static_browse_domains=avahi_string_list_reverse(db->static_browse_domains);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "DomainBrowserNew");
      if(message == ((struct DBusMessage *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        i_interface = (signed int)interface;
        i_protocol = (signed int)protocol;
        u_flags = (unsigned int)flags;
        bt = (signed int)btype;
        return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &domain, (signed int)105, &bt, (signed int)117, &u_flags, (signed int)0);
        if(return_value_dbus_message_append_args_3 == 0u)
          avahi_client_set_errno(client, -24);

        else
        {
          reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
          if(reply == ((struct DBusMessage *)NULL))
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
            tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_5)
            avahi_client_set_errno(client, -22);

          else
          {
            return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
            if(return_value_dbus_message_get_args_6 == 0u)
              tmp_if_expr_8 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
              tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(path == ((char *)NULL) || tmp_if_expr_8)
              avahi_client_set_errno(client, -22);

            else
            {
              db->path=avahi_strdup(path);
              if(db->path == ((char *)NULL))
                avahi_client_set_errno(client, -24);

              else
              {
                if(!(db->static_browse_domains == ((struct AvahiStringList *)NULL)))
                {
                  if((signed int)btype == AVAHI_DOMAIN_BROWSER_BROWSE)
                  {
                    struct timeval tv = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
                    db->defer_timeout=client->poll_api->timeout_new(client->poll_api, &tv, defer_timeout_callback, (void *)db);
                    if(db->defer_timeout == ((struct AvahiTimeout_1 *)NULL))
                      avahi_client_set_errno(client, -24);

                  }

                }

                dbus_message_unref(message);
                dbus_message_unref(reply);
                return db;
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_9;
  return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(db == ((struct AvahiDomainBrowser *)NULL)))
    avahi_domain_browser_free(db);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiDomainBrowser *)(void *)0;
}

// avahi_domain_equal
// file ../avahi-common/domain.h line 62
signed int avahi_domain_equal(const char *a, const char *b)
{
  /* assertion a */
  assert(a != ((const char *)NULL));
  /* assertion b */
  assert(b != ((const char *)NULL));
  if(a == b)
    return 1;

  else
  {
    do
    {
      char ca[64l];
      char cb[64l];
      char *r;
      r=avahi_unescape_label(&a, ca, sizeof(char [64l]) /*64ul*/ );
      /* assertion r */
      assert(r != ((char *)NULL));
      r=avahi_unescape_label(&b, cb, sizeof(char [64l]) /*64ul*/ );
      /* assertion r */
      assert(r != ((char *)NULL));
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(ca, cb);
      if(!(return_value_strcasecmp_1 == 0))
        return 0;

      if(*a == 0)
      {
        if(*b == 0)
          return 1;

      }

    }
    while((_Bool)1);
    return 1;
  }
}

// avahi_domain_hash
// file domain.c line 424
unsigned int avahi_domain_hash(const char *s)
{
  unsigned int hash = (unsigned int)0;
  signed int return_value_tolower_1;
  while(!(*s == 0))
  {
    char c[64l];
    char *p;
    char *r;
    r=avahi_unescape_label(&s, c, sizeof(char [64l]) /*64ul*/ );
    /* assertion r */
    assert(r != ((char *)NULL));
    p = c;
    for( ; !(*p == 0); p = p + 1l)
    {
      return_value_tolower_1=tolower((signed int)*p);
      hash = (unsigned int)31 * hash + (unsigned int)return_value_tolower_1;
    }
  }
  return hash;
}

// avahi_elapse_time
// file ../avahi-common/timeval.h line 50
struct timeval * avahi_elapse_time(struct timeval *tv, unsigned int msec, unsigned int jitter)
{
  /* assertion tv */
  assert(tv != ((struct timeval *)NULL));
  gettimeofday(tv, (struct timezone *)(void *)0);
  if(!(msec == 0u))
    avahi_timeval_add(tv, (signed long int)msec * (signed long int)1000);

  if(!(jitter == 0u))
  {
    signed long int now;
    signed int r;
    now=time((signed long int *)(void *)0);
    static union anonymous_6 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
    pthread_mutex_lock(&mutex);
    static signed int last_rand;
    static signed long int timestamp = (signed long int)0;
    if(now >= 10l + timestamp)
    {
      timestamp = now;
      last_rand=rand();
    }

    r = last_rand;
    pthread_mutex_unlock(&mutex);
    avahi_timeval_add(tv, (signed long int)(((double)jitter * 1000.0 * (double)r) / ((double)2147483647 + 1.0)));
  }

  return tv;
}

// avahi_entry_group_add_address
// file entrygroup.c line 721
signed int avahi_entry_group_add_address(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, const struct AvahiAddress *a)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  char s_address[40l];
  char *p_address = s_address;
  /* assertion name */
  assert(name != ((const char *)NULL));
  client = group->client;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  char *return_value_avahi_address_snprint_4;
  unsigned int return_value_dbus_message_append_args_5;
  _Bool tmp_if_expr_7;
  unsigned int return_value_dbus_error_is_set_6;
  unsigned int return_value_dbus_message_get_args_8;
  _Bool tmp_if_expr_10;
  unsigned int return_value_dbus_error_is_set_9;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddAddress");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_avahi_address_snprint_4=avahi_address_snprint(s_address, sizeof(char [40l]) /*40ul*/ , a);
      if(return_value_avahi_address_snprint_4 == ((char *)NULL))
        r=avahi_client_set_errno(client, -14);

      else
      {
        return_value_dbus_message_append_args_5=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &p_address, (signed int)0);
        if(return_value_dbus_message_append_args_5 == 0u)
          r=avahi_client_set_errno(group->client, -24);

        else
        {
          reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
          if(reply == ((struct DBusMessage *)NULL))
            tmp_if_expr_7 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
            tmp_if_expr_7 = return_value_dbus_error_is_set_6 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_7)
            r=avahi_client_set_errno(client, -22);

          else
          {
            return_value_dbus_message_get_args_8=dbus_message_get_args(reply, &error, (signed int)0);
            if(return_value_dbus_message_get_args_8 == 0u)
              tmp_if_expr_10 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
              tmp_if_expr_10 = return_value_dbus_error_is_set_9 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_10)
              r=avahi_client_set_errno(client, -22);

            else
            {
              dbus_message_unref(message);
              dbus_message_unref(reply);
              return 0;
            }
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_11;
    return_value_dbus_error_is_set_11=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_11 == 0u))
    {
      r=avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_add_record
// file entrygroup.c line 808
signed int avahi_entry_group_add_record(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, unsigned short int clazz, unsigned short int type, unsigned int ttl, const void *rdata, unsigned long int size)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion name */
  assert(name != ((const char *)NULL));
  client = group->client;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  unsigned int return_value_dbus_message_append_args_4;
  _Bool tmp_if_expr_6;
  signed int return_value_append_rdata_5;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  unsigned int return_value_dbus_message_get_args_9;
  _Bool tmp_if_expr_11;
  unsigned int return_value_dbus_error_is_set_10;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddRecord");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args_4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)113, &clazz, (signed int)113, &type, (signed int)117, &ttl, (signed int)0);
      if(return_value_dbus_message_append_args_4 == 0u)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_append_rdata_5=append_rdata(message, rdata, size);
        tmp_if_expr_6 = return_value_append_rdata_5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
          tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          r=avahi_client_set_errno(client, -22);

        else
        {
          return_value_dbus_message_get_args_9=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args_9 == 0u)
            tmp_if_expr_11 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
            tmp_if_expr_11 = return_value_dbus_error_is_set_10 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_11)
            r=avahi_client_set_errno(client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_12;
    return_value_dbus_error_is_set_12=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_12 == 0u))
    {
      r=avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_add_service
// file entrygroup.c line 496
signed int avahi_entry_group_add_service(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, ...)
{
  void **va;
  signed int r;
  struct AvahiStringList *txt;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  va = (void **)&port;
  txt=avahi_string_list_new_va(va);
  r=avahi_entry_group_add_service_strlst(group, interface, protocol, flags, name, type, domain, host, port, txt);
  avahi_string_list_free(txt);
  va = ((void **)NULL);
  return r;
}

// avahi_entry_group_add_service_strlst
// file entrygroup.c line 402
signed int avahi_entry_group_add_service_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, struct AvahiStringList *txt)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  client = group->client;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  unsigned int return_value_dbus_message_append_args_4;
  _Bool tmp_if_expr_6;
  signed int return_value_append_string_list_5;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  unsigned int return_value_dbus_message_get_args_9;
  _Bool tmp_if_expr_11;
  unsigned int return_value_dbus_error_is_set_10;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    if(host == ((const char *)NULL))
      host = "";

    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddService");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args_4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)115, &host, (signed int)113, &port, (signed int)0);
      if(return_value_dbus_message_append_args_4 == 0u)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_append_string_list_5=append_string_list(message, txt);
        tmp_if_expr_6 = return_value_append_string_list_5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
          tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          r=avahi_client_set_errno(client, -22);

        else
        {
          return_value_dbus_message_get_args_9=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args_9 == 0u)
            tmp_if_expr_11 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
            tmp_if_expr_11 = return_value_dbus_error_is_set_10 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_11)
            r=avahi_client_set_errno(client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_12;
    return_value_dbus_error_is_set_12=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_12 == 0u))
    {
      r=avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_add_service_subtype
// file entrygroup.c line 522
signed int avahi_entry_group_add_service_subtype(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, const char *type, const char *domain, const char *subtype)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  /* assertion subtype */
  assert(subtype != ((const char *)NULL));
  client = group->client;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  unsigned int return_value_dbus_message_append_args_4;
  _Bool tmp_if_expr_6;
  unsigned int return_value_dbus_error_is_set_5;
  unsigned int return_value_dbus_message_get_args_7;
  _Bool tmp_if_expr_9;
  unsigned int return_value_dbus_error_is_set_8;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddServiceSubtype");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args_4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)115, &subtype, (signed int)0);
      if(return_value_dbus_message_append_args_4 == 0u)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_5=dbus_error_is_set(&error);
          tmp_if_expr_6 = return_value_dbus_error_is_set_5 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
          r=avahi_client_set_errno(client, -22);

        else
        {
          return_value_dbus_message_get_args_7=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args_7 == 0u)
            tmp_if_expr_9 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_8=dbus_error_is_set(&error);
            tmp_if_expr_9 = return_value_dbus_error_is_set_8 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_9)
            r=avahi_client_set_errno(client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_10;
    return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_10 == 0u))
    {
      r=avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_commit
// file entrygroup.c line 253
signed int avahi_entry_group_commit(struct AvahiEntryGroup *group)
{
  signed int ret;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    ret=entry_group_simple_method_call(group, "Commit");
    if(!(ret >= 0))
      return ret;

    else
    {
      group->state_valid = 0;
      return ret;
    }
  }
}

// avahi_entry_group_free
// file publish.h line 60
signed int avahi_entry_group_free(struct AvahiEntryGroup *group)
{
  struct AvahiClient *client = group->client;
  signed int r = 0;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  signed int return_value_avahi_client_is_connected_1;
  if(!(group->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      r=entry_group_simple_method_call(group, "Free");

  }

  do
  {
    struct AvahiEntryGroup **_head = &client->groups;
    struct AvahiEntryGroup *_item = group;
    /* assertion _item */
    assert(_item != ((struct AvahiEntryGroup *)NULL));
    if(!(_item->groups_next == ((struct AvahiEntryGroup *)NULL)))
      _item->groups_next->groups_prev = _item->groups_prev;

    if(!(_item->groups_prev == ((struct AvahiEntryGroup *)NULL)))
      _item->groups_prev->groups_next = _item->groups_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->groups_next;
    }
    _item->groups_prev = (struct AvahiEntryGroup *)(void *)0;
    _item->groups_next = _item->groups_prev;
  }
  while((_Bool)0);
  avahi_free((void *)group->path);
  avahi_free((void *)group);
  return r;
}

// avahi_entry_group_get_client
// file entrygroup.c line 290
struct AvahiClient * avahi_entry_group_get_client(struct AvahiEntryGroup *group)
{
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  return group->client;
}

// avahi_entry_group_get_state
// file entrygroup.c line 281
signed int avahi_entry_group_get_state(struct AvahiEntryGroup *group)
{
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  if(!(group->state_valid == 0))
    return (signed int)group->state;

  else
  {
    signed int return_value_retrieve_state_1;
    return_value_retrieve_state_1=retrieve_state(group);
    return return_value_retrieve_state_1;
  }
}

// avahi_entry_group_is_empty
// file entrygroup.c line 296
signed int avahi_entry_group_is_empty(struct AvahiEntryGroup *group)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  signed int b;
  struct AvahiClient *client;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  client = group->client;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "IsEmpty");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(client, -24);

    else
    {
      reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
      if(reply == ((struct DBusMessage *)NULL))
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
        tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        r=avahi_client_set_errno(client, -22);

      else
      {
        return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)98, &b, (signed int)0);
        if(return_value_dbus_message_get_args_6 == 0u)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
          tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          r=avahi_client_set_errno(client, -22);

        else
        {
          dbus_message_unref(message);
          dbus_message_unref(reply);
          return (signed int)!(!(b != 0));
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_9;
    return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_9 == 0u))
    {
      r=avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_new
// file entrygroup.c line 101
struct AvahiEntryGroup * avahi_entry_group_new(struct AvahiClient *client, void (*callback)(struct AvahiEntryGroup *, enum anonymous_40, void *), void *userdata)
{
  struct AvahiEntryGroup *group = (struct AvahiEntryGroup *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int state;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  unsigned int return_value_dbus_message_get_args_5;
  _Bool tmp_if_expr_7;
  unsigned int return_value_dbus_error_is_set_6;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal_2=avahi_new_internal_link1((unsigned int)1, sizeof(struct AvahiEntryGroup) /*56ul*/ );
    group = (struct AvahiEntryGroup *)return_value_avahi_new_internal_2;
    if(group == ((struct AvahiEntryGroup *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      group->client = client;
      group->callback = callback;
      group->userdata = userdata;
      group->state_valid = 0;
      group->path = (char *)(void *)0;
      do
      {
        struct AvahiEntryGroup **_head = &client->groups;
        struct AvahiEntryGroup *_item = group;
        /* assertion _item */
        assert(_item != ((struct AvahiEntryGroup *)NULL));
        _item->groups_next = *_head;
        if(!(_item->groups_next == ((struct AvahiEntryGroup *)NULL)))
          _item->groups_next->groups_prev = _item;

        _item->groups_prev = (struct AvahiEntryGroup *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "EntryGroupNew");
      if(message == ((struct DBusMessage *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          avahi_client_set_errno(client, -22);

        else
        {
          return_value_dbus_message_get_args_5=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
          if(return_value_dbus_message_get_args_5 == 0u)
            tmp_if_expr_7 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
            tmp_if_expr_7 = return_value_dbus_error_is_set_6 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_7)
            avahi_client_set_errno(client, -22);

          else
          {
            group->path=avahi_strdup(path);
            if(group->path == ((char *)NULL))
              avahi_client_set_errno(client, -24);

            else
            {
              state=retrieve_state(group);
              if(!(state >= 0))
                avahi_client_set_errno(client, state);

              else
              {
                avahi_entry_group_set_state(group, (enum anonymous_40)state);
                dbus_message_unref(message);
                dbus_message_unref(reply);
                return group;
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_8;
  return_value_dbus_error_is_set_8=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_8 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(group == ((struct AvahiEntryGroup *)NULL)))
    avahi_entry_group_free(group);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiEntryGroup *)(void *)0;
}

// avahi_entry_group_reset
// file entrygroup.c line 267
signed int avahi_entry_group_reset(struct AvahiEntryGroup *group)
{
  signed int ret;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    ret=entry_group_simple_method_call(group, "Reset");
    if(!(ret >= 0))
      return ret;

    else
    {
      group->state_valid = 0;
      return ret;
    }
  }
}

// avahi_entry_group_set_state
// file internal.h line 157
void avahi_entry_group_set_state(struct AvahiEntryGroup *group, enum anonymous_40 state)
{
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  if(!(group->state_valid == 0))
  {
    if(group->state == state)
      goto __CPROVER_DUMP_L2;

  }

  group->state = state;
  group->state_valid = 1;
  if(!(group->callback == ((void (*)(struct AvahiEntryGroup *, enum anonymous_40, void *))NULL)))
    group->callback(group, state, group->userdata);


__CPROVER_DUMP_L2:
  ;
}

// avahi_entry_group_update_service_txt
// file entrygroup.c line 611
signed int avahi_entry_group_update_service_txt(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, const char *type, const char *domain, ...)
{
  void **va;
  signed int r;
  struct AvahiStringList *txt;
  va = (void **)&domain;
  txt=avahi_string_list_new_va(va);
  r=avahi_entry_group_update_service_txt_strlst(group, interface, protocol, flags, name, type, domain, txt);
  avahi_string_list_free(txt);
  va = ((void **)NULL);
  return r;
}

// avahi_entry_group_update_service_txt_strlst
// file entrygroup.c line 633
signed int avahi_entry_group_update_service_txt_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous_41 flags, const char *name, const char *type, const char *domain, struct AvahiStringList *txt)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  client = group->client;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_client_is_connected_2;
  if(group->path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected_2=avahi_client_is_connected(group->client);
    tmp_if_expr_3 = !(return_value_avahi_client_is_connected_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno_1;
  unsigned int return_value_dbus_message_append_args_4;
  _Bool tmp_if_expr_6;
  signed int return_value_append_string_list_5;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  unsigned int return_value_dbus_message_get_args_9;
  _Bool tmp_if_expr_11;
  unsigned int return_value_dbus_error_is_set_10;
  if(tmp_if_expr_3)
  {
    return_value_avahi_client_set_errno_1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno_1;
  }

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "UpdateServiceTxt");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args_4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)0);
      if(return_value_dbus_message_append_args_4 == 0u)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_append_string_list_5=append_string_list(message, txt);
        tmp_if_expr_6 = return_value_append_string_list_5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
          tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          r=avahi_client_set_errno(client, -22);

        else
        {
          return_value_dbus_message_get_args_9=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args_9 == 0u)
            tmp_if_expr_11 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
            tmp_if_expr_11 = return_value_dbus_error_is_set_10 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_11)
            r=avahi_client_set_errno(client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_12;
    return_value_dbus_error_is_set_12=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_12 == 0u))
    {
      r=avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_error_dbus_to_number
// file ../avahi-common/dbus.h line 112
signed int avahi_error_dbus_to_number(const char *s)
{
  signed int e;
  struct error_map *m;
  /* assertion s */
  assert(s != ((const char *)NULL));
  e = -1;
  signed int return_value_strcmp_1;
  for( ; e >= -53; e = e - 1)
  {
    return_value_strcmp_1=strcmp(s, table[(signed long int)-e]);
    if(return_value_strcmp_1 == 0)
      return e;

  }
  m = error_map;
  signed int return_value_strcmp_2;
  for( ; !(m->dbus_error == ((const char *)NULL)); m = m + 1l)
  {
    return_value_strcmp_2=strcmp(m->dbus_error, s);
    if(return_value_strcmp_2 == 0)
      return m->avahi_error;

  }
  return -22;
}

// avahi_error_number_to_dbus
// file ../avahi-common/dbus.c line 133
const char * avahi_error_number_to_dbus(signed int error)
{
  /* assertion error > AVAHI_ERR_MAX */
  assert(error > -54);
  /* assertion error < 1 */
  assert(error < 1);
  return table[(signed long int)-error];
}

// avahi_escape_label
// file domain.c line 116
char * avahi_escape_label(const char *src, unsigned long int src_length, char **ret_name, unsigned long int *ret_size)
{
  char *r;
  /* assertion src */
  assert(src != ((const char *)NULL));
  /* assertion ret_name */
  assert(ret_name != ((char **)NULL));
  /* assertion *ret_name */
  assert(*ret_name != ((char *)NULL));
  /* assertion ret_size */
  assert(ret_size != ((unsigned long int *)NULL));
  /* assertion *ret_size > 0 */
  assert(*ret_size > (unsigned long int)0);
  r = *ret_name;
  _Bool tmp_if_expr_15;
  char *tmp_post_1;
  char *tmp_post_2;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_13;
  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_5;
  char *tmp_post_6;
  char *tmp_post_7;
  for( ; src_length >= 1ul; src = src + 1l)
  {
    if((signed int)*src == 46)
      tmp_if_expr_15 = (_Bool)1;

    else
      tmp_if_expr_15 = (signed int)*src == 92 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_15)
    {
      if(!(*ret_size >= 3ul))
        return (char *)(void *)0;

      tmp_post_1 = *ret_name;
      *ret_name = *ret_name + 1l;
      *tmp_post_1 = (char)92;
      tmp_post_2 = *ret_name;
      *ret_name = *ret_name + 1l;
      *tmp_post_2 = *src;
      *ret_size = *ret_size - (unsigned long int)2;
    }

    else
    {
      if((signed int)*src == 95)
        tmp_if_expr_8 = (_Bool)1;

      else
        tmp_if_expr_8 = (signed int)*src == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_8)
        tmp_if_expr_10 = (_Bool)1;

      else
      {
        if((signed int)*src >= 48)
          tmp_if_expr_9 = (signed int)*src <= 57 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_9 = (_Bool)0;
        tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_10)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        if((signed int)*src >= 97)
          tmp_if_expr_11 = (signed int)*src <= 122 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_11 = (_Bool)0;
        tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
        tmp_if_expr_14 = (_Bool)1;

      else
      {
        if((signed int)*src >= 65)
          tmp_if_expr_13 = (signed int)*src <= 90 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_13 = (_Bool)0;
        tmp_if_expr_14 = tmp_if_expr_13 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_14)
      {
        if(!(*ret_size >= 2ul))
          return (char *)(void *)0;

        tmp_post_3 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post_3 = *src;
        *ret_size = *ret_size - 1ul;
      }

      else
      {
        if(!(*ret_size >= 5ul))
          return (char *)(void *)0;

        tmp_post_4 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post_4 = (char)92;
        tmp_post_5 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post_5 = (char)(48 + (signed int)(char)((signed int)(unsigned char)*src / 100));
        tmp_post_6 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post_6 = (char)(48 + (signed int)(char)(((signed int)(unsigned char)*src / 10) % 10));
        tmp_post_7 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post_7 = (char)(48 + (signed int)(char)((signed int)(unsigned char)*src % 10));
        *ret_size = *ret_size - (unsigned long int)4;
      }
    }
    src_length = src_length - 1ul;
  }
  *(*ret_name) = (char)0;
  return r;
}

// avahi_free
// file ../avahi-common/malloc.h line 42
void avahi_free(void *p)
{
  if(!(p == NULL))
  {
    if(allocator == ((const struct AvahiAllocator *)NULL))
      free(p);

    else
    {
      /* assertion allocator->free */
      assert(allocator->free != ((void (*)(void *))NULL));
      allocator->free(p);
    }
  }

}

// avahi_get_type_from_subtype
// file domain.c line 306
const char * avahi_get_type_from_subtype(const char *t)
{
  char label[64l];
  const char *ret;
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  _Bool tmp_if_expr_2;
  if(return_value_strlen_1 >= 1014ul)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_10;
  signed int return_value_strcasecmp_12;
  if(tmp_if_expr_2)
    return (const char *)(void *)0;

  else
  {
    char *return_value_avahi_unescape_label_3;
    return_value_avahi_unescape_label_3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label_3 == ((char *)NULL))
      return (const char *)(void *)0;

    else
    {
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(label);
      if(!(return_value_strlen_4 >= 3ul))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        return (const char *)(void *)0;

      else
        if(*t == 0)
          return (const char *)(void *)0;

        else
        {
          char *return_value_avahi_unescape_label_6;
          return_value_avahi_unescape_label_6=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
          if(return_value_avahi_unescape_label_6 == ((char *)NULL))
            return (const char *)(void *)0;

          else
          {
            signed int return_value_strcasecmp_7;
            return_value_strcasecmp_7=strcasecmp(label, "_sub");
            if(!(return_value_strcasecmp_7 == 0))
              return (const char *)(void *)0;

            else
              if(*t == 0)
                return (const char *)(void *)0;

              else
              {
                ret = t;
                char *return_value_avahi_unescape_label_8;
                return_value_avahi_unescape_label_8=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
                if(return_value_avahi_unescape_label_8 == ((char *)NULL))
                  return (const char *)(void *)0;

                else
                {
                  unsigned long int return_value_strlen_9;
                  return_value_strlen_9=strlen(label);
                  if(!(return_value_strlen_9 >= 3ul))
                    tmp_if_expr_10 = (_Bool)1;

                  else
                    tmp_if_expr_10 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_10)
                    return (const char *)(void *)0;

                  else
                    if(*t == 0)
                      return (const char *)(void *)0;

                    else
                    {
                      char *return_value_avahi_unescape_label_11;
                      return_value_avahi_unescape_label_11=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
                      if(return_value_avahi_unescape_label_11 == ((char *)NULL))
                        return (const char *)(void *)0;

                      else
                      {
                        signed int return_value_strcasecmp_13;
                        return_value_strcasecmp_13=strcasecmp(label, "_tcp");
                        if(!(return_value_strcasecmp_13 == 0))
                        {
                          return_value_strcasecmp_12=strcasecmp(label, "_udp");
                          if(return_value_strcasecmp_12 == 0)
                            goto __CPROVER_DUMP_L18;

                          return (const char *)(void *)0;
                        }

                        else
                        {

                        __CPROVER_DUMP_L18:
                          ;
                          if(!(*t == 0))
                            return (const char *)(void *)0;

                          else
                            return ret;
                        }
                      }
                    }
                }
              }
          }
        }
    }
  }
}

// avahi_glib_allocator
// file glib-malloc.c line 41
const struct AvahiAllocator * avahi_glib_allocator(void)
{
  static struct AvahiAllocator avahi_glib_allocator__1__allocator;
  static signed int allocator_initialized = 0;
  if(allocator_initialized == 0)
  {
    avahi_glib_allocator__1__allocator.malloc = malloc_glue;
    avahi_glib_allocator__1__allocator.free = g_free;
    avahi_glib_allocator__1__allocator.realloc = realloc_glue;
    avahi_glib_allocator__1__allocator.calloc = calloc_glue;
    allocator_initialized = 1;
  }

  return &avahi_glib_allocator__1__allocator;
}

// avahi_glib_poll_free
// file glib-watch.c line 386
void avahi_glib_poll_free(struct AvahiGLibPoll *g)
{
  struct _GSource *s = &g->source;
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  cleanup_watches_link2(g, 1);
  cleanup_timeouts_link2(g, 1);
  g_main_context_unref(g->context);
  g_source_destroy(s);
  g_source_unref(s);
}

// avahi_glib_poll_get
// file glib-watch.c line 398
const struct AvahiPoll * avahi_glib_poll_get(struct AvahiGLibPoll *g)
{
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  return &g->api;
}

// avahi_glib_poll_new
// file glib-watch.c line 347
struct AvahiGLibPoll * avahi_glib_poll_new(struct _GMainContext *context, signed int priority)
{
  struct AvahiGLibPoll *g;
  struct _GSource *return_value_g_source_new_1;
  static struct _GSourceFuncs source_funcs = { .prepare=prepare_func, .check=check_func, .dispatch=dispatch_func,
    .finalize=(void (*)(struct _GSource *))(void *)0, .closure_callback=(signed int (*)(void *))(void *)0,
    .closure_marshal=(void (*)(void))(void *)0 };
  return_value_g_source_new_1=g_source_new(&source_funcs, (unsigned int)sizeof(struct AvahiGLibPoll) /*192ul*/ );
  g = (struct AvahiGLibPoll *)return_value_g_source_new_1;
  struct _GMainContext *tmp_if_expr_3;
  struct _GMainContext *return_value_g_main_context_default_2;
  if(!(context == ((struct _GMainContext *)NULL)))
    tmp_if_expr_3 = context;

  else
  {
    return_value_g_main_context_default_2=g_main_context_default();
    tmp_if_expr_3 = return_value_g_main_context_default_2;
  }
  g->context = tmp_if_expr_3;
  g_main_context_ref(g->context);
  g->api.userdata = (void *)g;
  g->api.watch_new = watch_new_link2;
  g->api.watch_free = watch_free_link2;
  g->api.watch_update = watch_update_link2;
  g->api.watch_get_events = watch_get_events_link2;
  g->api.timeout_new = timeout_new_link2;
  g->api.timeout_free = timeout_free_link2;
  g->api.timeout_update = timeout_update_link2;
  g->watch_req_cleanup = 0;
  g->timeout_req_cleanup = 0;
  do
    g->watches = (struct AvahiWatch_0 *)(void *)0;
  while((_Bool)0);
  do
    g->timeouts = (struct AvahiTimeout *)(void *)0;
  while((_Bool)0);
  g_source_attach(&g->source, g->context);
  g_source_set_priority(&g->source, priority);
  g_source_set_can_recurse(&g->source, 0);
  return g;
}

// avahi_host_name_resolver_event
// file internal.h line 165
enum anonymous_42 avahi_host_name_resolver_event(struct AvahiClient *client, enum anonymous_12 event, struct DBusMessage *message)
{
  struct AvahiHostNameResolver *r = (struct AvahiHostNameResolver *)(void *)0;
  struct DBusError error;
  const char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  signed int interface;
  signed int protocol;
  signed int aprotocol;
  unsigned int flags;
  char *name;
  char *address;
  struct AvahiAddress a;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  struct AvahiAddress *return_value_avahi_address_parse_5;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  signed int return_value_avahi_error_dbus_to_number_9;
  if(!(path == ((const char *)NULL)))
  {
    r = client->host_name_resolvers;
    for( ; !(r == ((struct AvahiHostNameResolver *)NULL)); r = r->host_name_resolvers_next)
    {
      return_value_strcmp_1=strcmp(r->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(r == ((struct AvahiHostNameResolver *)NULL))
      goto fail;

    switch((signed int)event)
    {
      case AVAHI_RESOLVER_FOUND:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)105, &aprotocol, (signed int)115, &address, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        /* assertion address */
        assert(address != ((char *)NULL));
        return_value_avahi_address_parse_5=avahi_address_parse(address, (signed int)aprotocol, &a);
        if(return_value_avahi_address_parse_5 == ((struct AvahiAddress *)NULL))
        {
          fprintf(stderr, "Failed to parse address\n");
          goto fail;
        }

        r->callback(r, (signed int)interface, (signed int)protocol, (enum anonymous_12)AVAHI_RESOLVER_FOUND, name, &a, (enum anonymous_13)flags, r->userdata);
      }
      case AVAHI_RESOLVER_FAILURE:
      {
        return_value_dbus_message_get_args_6=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_6 == 0u)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
          tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_9=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(r->client, return_value_avahi_error_dbus_to_number_9);
        r->callback(r, r->interface, r->protocol, event, r->host_name, (const struct AvahiAddress *)(void *)0, (enum anonymous_13)0, r->userdata);
      }
    }
    return (enum anonymous_42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous_42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_host_name_resolver_free
// file lookup.h line 239
signed int avahi_host_name_resolver_free(struct AvahiHostNameResolver *r)
{
  signed int ret = 0;
  struct AvahiClient *client;
  /* assertion r */
  assert(r != ((struct AvahiHostNameResolver *)NULL));
  client = r->client;
  signed int return_value_avahi_client_is_connected_1;
  if(!(r->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      ret=avahi_client_simple_method_call(client, r->path, "org.freedesktop.Avahi.HostNameResolver", "Free");

  }

  do
  {
    struct AvahiHostNameResolver **_head = &client->host_name_resolvers;
    struct AvahiHostNameResolver *_item = r;
    /* assertion _item */
    assert(_item != ((struct AvahiHostNameResolver *)NULL));
    if(!(_item->host_name_resolvers_next == ((struct AvahiHostNameResolver *)NULL)))
      _item->host_name_resolvers_next->host_name_resolvers_prev = _item->host_name_resolvers_prev;

    if(!(_item->host_name_resolvers_prev == ((struct AvahiHostNameResolver *)NULL)))
      _item->host_name_resolvers_prev->host_name_resolvers_next = _item->host_name_resolvers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->host_name_resolvers_next;
    }
    _item->host_name_resolvers_prev = (struct AvahiHostNameResolver *)(void *)0;
    _item->host_name_resolvers_next = _item->host_name_resolvers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)r->path);
  avahi_free((void *)r->host_name);
  avahi_free((void *)r);
  return ret;
}

// avahi_host_name_resolver_get_client
// file resolver.c line 558
struct AvahiClient * avahi_host_name_resolver_get_client(struct AvahiHostNameResolver *r)
{
  /* assertion r */
  assert(r != ((struct AvahiHostNameResolver *)NULL));
  return r->client;
}

// avahi_host_name_resolver_new
// file resolver.c line 424
struct AvahiHostNameResolver * avahi_host_name_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, signed int aprotocol, enum anonymous_44 flags, void (*callback)(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous_12, const char *, const struct AvahiAddress *, enum anonymous_13, void *), void *userdata)
{
  struct DBusError error;
  struct AvahiHostNameResolver *r = (struct AvahiHostNameResolver *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int i_interface;
  signed int i_protocol;
  signed int i_aprotocol;
  unsigned int u_flags;
  char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal_2=avahi_new_internal_link3((unsigned int)1, sizeof(struct AvahiHostNameResolver) /*64ul*/ );
    r = (struct AvahiHostNameResolver *)return_value_avahi_new_internal_2;
    if(r == ((struct AvahiHostNameResolver *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      r->client = client;
      r->callback = callback;
      r->userdata = userdata;
      r->path = (char *)(void *)0;
      r->interface = interface;
      r->protocol = protocol;
      r->host_name = (char *)(void *)0;
      do
      {
        struct AvahiHostNameResolver **_head = &client->host_name_resolvers;
        struct AvahiHostNameResolver *_item = r;
        /* assertion _item */
        assert(_item != ((struct AvahiHostNameResolver *)NULL));
        _item->host_name_resolvers_next = *_head;
        if(!(_item->host_name_resolvers_next == ((struct AvahiHostNameResolver *)NULL)))
          _item->host_name_resolvers_next->host_name_resolvers_prev = _item;

        _item->host_name_resolvers_prev = (struct AvahiHostNameResolver *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      r->host_name=avahi_strdup(name);
      if(r->host_name == ((char *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "HostNameResolverNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          i_aprotocol = (signed int)aprotocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &name, (signed int)105, &i_aprotocol, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args_3 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr_5 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
              tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_5)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args_6 == 0u)
                tmp_if_expr_8 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
                tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr_8)
                avahi_client_set_errno(client, -22);

              else
              {
                r->path=avahi_strdup(path);
                if(r->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return r;
                }
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_9;
  return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(r == ((struct AvahiHostNameResolver *)NULL)))
    avahi_host_name_resolver_free(r);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiHostNameResolver *)(void *)0;
}

// avahi_init_i18n
// file ../avahi-common/i18n.h line 51
void avahi_init_i18n(void)
{
  static signed int done = 0;
  if(done == 0)
  {
    bindtextdomain("avahi", "/usr/share/locale");
    bind_textdomain_codeset("avahi", "UTF-8");
    done = 1;
  }

}

// avahi_is_valid_domain_name
// file domain.c line 369
signed int avahi_is_valid_domain_name(const char *t)
{
  signed int is_first = 1;
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  if(return_value_strlen_1 >= 1014ul)
    return 0;

  else
  {
    do
    {
      char label[64l];
      char *return_value_avahi_unescape_label_2;
      return_value_avahi_unescape_label_2=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
      if(return_value_avahi_unescape_label_2 == ((char *)NULL))
        return 0;

      if(!(is_first == 0))
      {
        if((signed int)label[0l] == 0)
        {
          if((signed int)*t == 0)
            return 1;

        }

      }

      is_first = 0;
      if((signed int)label[0l] == 0)
        return 0;

    }
    while(!(*t == 0));
    return 1;
  }
}

// avahi_is_valid_fqdn
// file domain.c line 575
signed int avahi_is_valid_fqdn(const char *t)
{
  char label[64l];
  char normalized[1014l];
  const char *k = t;
  struct AvahiAddress a;
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  if(return_value_strlen_1 >= 1014ul)
    return 0;

  else
  {
    signed int return_value_avahi_is_valid_domain_name_2;
    return_value_avahi_is_valid_domain_name_2=avahi_is_valid_domain_name(t);
    if(return_value_avahi_is_valid_domain_name_2 == 0)
      return 0;

    else
    {
      char *return_value_avahi_unescape_label_3;
      return_value_avahi_unescape_label_3=avahi_unescape_label(&k, label, sizeof(char [64l]) /*64ul*/ );
      if(return_value_avahi_unescape_label_3 == ((char *)NULL))
        return 0;

      else
        if(k == ((const char *)NULL) || (signed int)label[0l] == 0)
          return 0;

        else
        {
          char *return_value_avahi_unescape_label_4;
          return_value_avahi_unescape_label_4=avahi_unescape_label(&k, label, sizeof(char [64l]) /*64ul*/ );
          if(return_value_avahi_unescape_label_4 == ((char *)NULL))
            return 0;

          else
            if(k == ((const char *)NULL) || (signed int)label[0l] == 0)
              return 0;

            else
            {
              char *return_value_avahi_normalize_name_5;
              return_value_avahi_normalize_name_5=avahi_normalize_name(t, normalized, sizeof(char [1014l]) /*1014ul*/ );
              if(return_value_avahi_normalize_name_5 == ((char *)NULL))
                return 0;

              else
              {
                struct AvahiAddress *return_value_avahi_address_parse_6;
                return_value_avahi_address_parse_6=avahi_address_parse(normalized, -1, &a);
                if(!(return_value_avahi_address_parse_6 == ((struct AvahiAddress *)NULL)))
                  return 0;

                else
                  return 1;
              }
            }
        }
    }
  }
}

// avahi_is_valid_host_name
// file domain.h line 103
signed int avahi_is_valid_host_name(const char *t)
{
  char label[64l];
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  _Bool tmp_if_expr_2;
  if(return_value_strlen_1 >= 1014ul)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    return 0;

  else
  {
    char *return_value_avahi_unescape_label_3;
    return_value_avahi_unescape_label_3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label_3 == ((char *)NULL))
      return 0;

    else
    {
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(label);
      if(!(return_value_strlen_4 >= 1ul))
        return 0;

      else
        if(!(*t == 0))
          return 0;

        else
          return 1;
    }
  }
}

// avahi_is_valid_service_name
// file domain.h line 100
signed int avahi_is_valid_service_name(const char *t)
{
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  _Bool tmp_if_expr_2;
  if(return_value_strlen_1 >= 64ul)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    return 0;

  else
    return 1;
}

// avahi_is_valid_service_subtype
// file domain.c line 363
signed int avahi_is_valid_service_subtype(const char *t)
{
  /* assertion t */
  assert(t != ((const char *)NULL));
  const char *return_value_avahi_get_type_from_subtype_1;
  return_value_avahi_get_type_from_subtype_1=avahi_get_type_from_subtype(t);
  return (signed int)!(!(return_value_avahi_get_type_from_subtype_1 != ((const char *)NULL)));
}

// avahi_is_valid_service_type_generic
// file domain.c line 254
signed int avahi_is_valid_service_type_generic(const char *t)
{
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  _Bool tmp_if_expr_2;
  if(return_value_strlen_1 >= 1014ul)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_2)
    return 0;

  else
  {
    do
    {
      char label[64l];
      char *return_value_avahi_unescape_label_3;
      return_value_avahi_unescape_label_3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
      if(return_value_avahi_unescape_label_3 == ((char *)NULL))
        return 0;

      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(label);
      if(!(return_value_strlen_4 >= 3ul))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        return 0;

    }
    while(!(*t == 0));
    return 1;
  }
}

// avahi_is_valid_service_type_strict
// file domain.c line 274
signed int avahi_is_valid_service_type_strict(const char *t)
{
  char label[64l];
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  _Bool tmp_if_expr_2;
  if(return_value_strlen_1 >= 1014ul)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  signed int return_value_strcasecmp_7;
  if(tmp_if_expr_2)
    return 0;

  else
  {
    char *return_value_avahi_unescape_label_3;
    return_value_avahi_unescape_label_3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label_3 == ((char *)NULL))
      return 0;

    else
    {
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(label);
      if(!(return_value_strlen_4 >= 3ul))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        return 0;

      else
        if(*t == 0)
          return 0;

        else
        {
          char *return_value_avahi_unescape_label_6;
          return_value_avahi_unescape_label_6=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
          if(return_value_avahi_unescape_label_6 == ((char *)NULL))
            return 0;

          else
          {
            signed int return_value_strcasecmp_8;
            return_value_strcasecmp_8=strcasecmp(label, "_tcp");
            if(!(return_value_strcasecmp_8 == 0))
            {
              return_value_strcasecmp_7=strcasecmp(label, "_udp");
              if(return_value_strcasecmp_7 == 0)
                goto __CPROVER_DUMP_L10;

              return 0;
            }

            else
            {

            __CPROVER_DUMP_L10:
              ;
              if(!(*t == 0))
                return 0;

              else
                return 1;
            }
          }
        }
    }
  }
}

// avahi_malloc
// file ../avahi-common/malloc.h line 36
void * avahi_malloc(unsigned long int size)
{
  void *return_value_xmalloc_1;
  if(!(size >= 1ul))
    return (void *)0;

  else
    if(allocator == ((const struct AvahiAllocator *)NULL))
    {
      return_value_xmalloc_1=xmalloc(size);
      return return_value_xmalloc_1;
    }

    else
    {
      /* assertion allocator->malloc */
      assert(allocator->malloc != ((void * (*)(unsigned long int))NULL));
      void *return_value;
      return_value=allocator->malloc(size);
      return return_value;
    }
}

// avahi_malloc0
// file malloc.c line 113
void * avahi_malloc0(unsigned long int size)
{
  void *p;
  void *return_value_xcalloc_1;
  void *return_value;
  if(!(size >= 1ul))
    return (void *)0;

  else
    if(allocator == ((const struct AvahiAllocator *)NULL))
    {
      return_value_xcalloc_1=xcalloc((unsigned long int)1, size);
      return return_value_xcalloc_1;
    }

    else
      if(!(allocator->calloc == ((void * (*)(unsigned long int, unsigned long int))NULL)))
      {
        return_value=allocator->calloc((unsigned long int)1, size);
        return return_value;
      }

      else
      {
        /* assertion allocator->malloc */
        assert(allocator->malloc != ((void * (*)(unsigned long int))NULL));
        p=allocator->malloc(size);
        if(!(p == NULL))
          memset(p, 0, size);

        return p;
      }
}

// avahi_memdup
// file malloc.c line 248
void * avahi_memdup(const void *s, unsigned long int l)
{
  void *p;
  /* assertion s */
  assert(s != NULL);
  p=avahi_malloc(l);
  if(p == NULL)
    return (void *)0;

  else
  {
    memcpy(p, s, l);
    return p;
  }
}

// avahi_new_internal
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal(unsigned int n, unsigned long int k)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n < (unsigned long int)0x7fffffff / k);
  void *return_value_avahi_malloc_1;
  return_value_avahi_malloc_1=avahi_malloc((unsigned long int)n * k);
  return return_value_avahi_malloc_1;
}

// avahi_new_internal_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link1(unsigned int n_link1, unsigned long int k_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link1 < (unsigned long int)0x7fffffff / k_link1);
  void *return_value_avahi_malloc_1_link1;
  return_value_avahi_malloc_1_link1=avahi_malloc((unsigned long int)n_link1 * k_link1);
  return return_value_avahi_malloc_1_link1;
}

// avahi_new_internal_link1_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link1(unsigned int n_link1_link1, unsigned long int k_link1_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link1_link1 < (unsigned long int)0x7fffffff / k_link1_link1);
  void *return_value_avahi_malloc_1_link1_link1;
  return_value_avahi_malloc_1_link1_link1=avahi_malloc((unsigned long int)n_link1_link1 * k_link1_link1);
  return return_value_avahi_malloc_1_link1_link1;
}

// avahi_new_internal_link1_link1_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link1_link1(unsigned int n_link1_link1_link1, unsigned long int k_link1_link1_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link1_link1_link1 < (unsigned long int)0x7fffffff / k_link1_link1_link1);
  void *return_value_avahi_malloc_1_link1_link1_link1;
  return_value_avahi_malloc_1_link1_link1_link1=avahi_malloc((unsigned long int)n_link1_link1_link1 * k_link1_link1_link1);
  return return_value_avahi_malloc_1_link1_link1_link1;
}

// avahi_new_internal_link1_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link2(unsigned int n_link1_link2, unsigned long int k_link1_link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link1_link2 < (unsigned long int)0x7fffffff / k_link1_link2);
  void *return_value_avahi_malloc_1_link1_link2;
  return_value_avahi_malloc_1_link1_link2=avahi_malloc((unsigned long int)n_link1_link2 * k_link1_link2);
  return return_value_avahi_malloc_1_link1_link2;
}

// avahi_new_internal_link1_link2_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link1_link2_link1(unsigned int n_link1_link2_link1, unsigned long int k_link1_link2_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link1_link2_link1 < (unsigned long int)0x7fffffff / k_link1_link2_link1);
  void *return_value_avahi_malloc_1_link1_link2_link1;
  return_value_avahi_malloc_1_link1_link2_link1=avahi_malloc((unsigned long int)n_link1_link2_link1 * k_link1_link2_link1);
  return return_value_avahi_malloc_1_link1_link2_link1;
}

// avahi_new_internal_link1_link3
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link3(unsigned int n_link1_link3, unsigned long int k_link1_link3)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link1_link3 < (unsigned long int)0x7fffffff / k_link1_link3);
  void *return_value_avahi_malloc_1_link1_link3;
  return_value_avahi_malloc_1_link1_link3=avahi_malloc((unsigned long int)n_link1_link3 * k_link1_link3);
  return return_value_avahi_malloc_1_link1_link3;
}

// avahi_new_internal_link1_link4
// file malloc.h line 48
static inline void * avahi_new_internal_link1_link4(unsigned int n_link1_link4, unsigned long int k_link1_link4)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link1_link4 < (unsigned long int)0x7fffffff / k_link1_link4);
  void *return_value_avahi_malloc_1_link1_link4;
  return_value_avahi_malloc_1_link1_link4=avahi_malloc((unsigned long int)n_link1_link4 * k_link1_link4);
  return return_value_avahi_malloc_1_link1_link4;
}

// avahi_new_internal_link2
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link2(unsigned int n_link2, unsigned long int k_link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link2 < (unsigned long int)0x7fffffff / k_link2);
  void *return_value_avahi_malloc_1_link2;
  return_value_avahi_malloc_1_link2=avahi_malloc((unsigned long int)n_link2 * k_link2);
  return return_value_avahi_malloc_1_link2;
}

// avahi_new_internal_link2_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link1(unsigned int n_link2_link1, unsigned long int k_link2_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link2_link1 < (unsigned long int)0x7fffffff / k_link2_link1);
  void *return_value_avahi_malloc_1_link2_link1;
  return_value_avahi_malloc_1_link2_link1=avahi_malloc((unsigned long int)n_link2_link1 * k_link2_link1);
  return return_value_avahi_malloc_1_link2_link1;
}

// avahi_new_internal_link2_link1_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link1_link1(unsigned int n_link2_link1_link1, unsigned long int k_link2_link1_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link2_link1_link1 < (unsigned long int)0x7fffffff / k_link2_link1_link1);
  void *return_value_avahi_malloc_1_link2_link1_link1;
  return_value_avahi_malloc_1_link2_link1_link1=avahi_malloc((unsigned long int)n_link2_link1_link1 * k_link2_link1_link1);
  return return_value_avahi_malloc_1_link2_link1_link1;
}

// avahi_new_internal_link2_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link2(unsigned int n_link2_link2, unsigned long int k_link2_link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link2_link2 < (unsigned long int)0x7fffffff / k_link2_link2);
  void *return_value_avahi_malloc_1_link2_link2;
  return_value_avahi_malloc_1_link2_link2=avahi_malloc((unsigned long int)n_link2_link2 * k_link2_link2);
  return return_value_avahi_malloc_1_link2_link2;
}

// avahi_new_internal_link2_link2_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link2_link2_link1(unsigned int n_link2_link2_link1, unsigned long int k_link2_link2_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link2_link2_link1 < (unsigned long int)0x7fffffff / k_link2_link2_link1);
  void *return_value_avahi_malloc_1_link2_link2_link1;
  return_value_avahi_malloc_1_link2_link2_link1=avahi_malloc((unsigned long int)n_link2_link2_link1 * k_link2_link2_link1);
  return return_value_avahi_malloc_1_link2_link2_link1;
}

// avahi_new_internal_link2_link3
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link3(unsigned int n_link2_link3, unsigned long int k_link2_link3)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link2_link3 < (unsigned long int)0x7fffffff / k_link2_link3);
  void *return_value_avahi_malloc_1_link2_link3;
  return_value_avahi_malloc_1_link2_link3=avahi_malloc((unsigned long int)n_link2_link3 * k_link2_link3);
  return return_value_avahi_malloc_1_link2_link3;
}

// avahi_new_internal_link2_link4
// file malloc.h line 48
static inline void * avahi_new_internal_link2_link4(unsigned int n_link2_link4, unsigned long int k_link2_link4)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link2_link4 < (unsigned long int)0x7fffffff / k_link2_link4);
  void *return_value_avahi_malloc_1_link2_link4;
  return_value_avahi_malloc_1_link2_link4=avahi_malloc((unsigned long int)n_link2_link4 * k_link2_link4);
  return return_value_avahi_malloc_1_link2_link4;
}

// avahi_new_internal_link3
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link3(unsigned int n_link3, unsigned long int k_link3)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link3 < (unsigned long int)0x7fffffff / k_link3);
  void *return_value_avahi_malloc_1_link3;
  return_value_avahi_malloc_1_link3=avahi_malloc((unsigned long int)n_link3 * k_link3);
  return return_value_avahi_malloc_1_link3;
}

// avahi_new_internal_link3_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link1(unsigned int n_link3_link1, unsigned long int k_link3_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link3_link1 < (unsigned long int)0x7fffffff / k_link3_link1);
  void *return_value_avahi_malloc_1_link3_link1;
  return_value_avahi_malloc_1_link3_link1=avahi_malloc((unsigned long int)n_link3_link1 * k_link3_link1);
  return return_value_avahi_malloc_1_link3_link1;
}

// avahi_new_internal_link3_link1_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link1_link1(unsigned int n_link3_link1_link1, unsigned long int k_link3_link1_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link3_link1_link1 < (unsigned long int)0x7fffffff / k_link3_link1_link1);
  void *return_value_avahi_malloc_1_link3_link1_link1;
  return_value_avahi_malloc_1_link3_link1_link1=avahi_malloc((unsigned long int)n_link3_link1_link1 * k_link3_link1_link1);
  return return_value_avahi_malloc_1_link3_link1_link1;
}

// avahi_new_internal_link3_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link2(unsigned int n_link3_link2, unsigned long int k_link3_link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link3_link2 < (unsigned long int)0x7fffffff / k_link3_link2);
  void *return_value_avahi_malloc_1_link3_link2;
  return_value_avahi_malloc_1_link3_link2=avahi_malloc((unsigned long int)n_link3_link2 * k_link3_link2);
  return return_value_avahi_malloc_1_link3_link2;
}

// avahi_new_internal_link3_link2_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link3_link2_link1(unsigned int n_link3_link2_link1, unsigned long int k_link3_link2_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link3_link2_link1 < (unsigned long int)0x7fffffff / k_link3_link2_link1);
  void *return_value_avahi_malloc_1_link3_link2_link1;
  return_value_avahi_malloc_1_link3_link2_link1=avahi_malloc((unsigned long int)n_link3_link2_link1 * k_link3_link2_link1);
  return return_value_avahi_malloc_1_link3_link2_link1;
}

// avahi_new_internal_link3_link3
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link3(unsigned int n_link3_link3, unsigned long int k_link3_link3)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link3_link3 < (unsigned long int)0x7fffffff / k_link3_link3);
  void *return_value_avahi_malloc_1_link3_link3;
  return_value_avahi_malloc_1_link3_link3=avahi_malloc((unsigned long int)n_link3_link3 * k_link3_link3);
  return return_value_avahi_malloc_1_link3_link3;
}

// avahi_new_internal_link3_link4
// file malloc.h line 48
static inline void * avahi_new_internal_link3_link4(unsigned int n_link3_link4, unsigned long int k_link3_link4)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link3_link4 < (unsigned long int)0x7fffffff / k_link3_link4);
  void *return_value_avahi_malloc_1_link3_link4;
  return_value_avahi_malloc_1_link3_link4=avahi_malloc((unsigned long int)n_link3_link4 * k_link3_link4);
  return return_value_avahi_malloc_1_link3_link4;
}

// avahi_new_internal_link4
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link4(unsigned int n_link4, unsigned long int k_link4)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link4 < (unsigned long int)0x7fffffff / k_link4);
  void *return_value_avahi_malloc_1_link4;
  return_value_avahi_malloc_1_link4=avahi_malloc((unsigned long int)n_link4 * k_link4);
  return return_value_avahi_malloc_1_link4;
}

// avahi_new_internal_link4_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link1(unsigned int n_link4_link1, unsigned long int k_link4_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link4_link1 < (unsigned long int)0x7fffffff / k_link4_link1);
  void *return_value_avahi_malloc_1_link4_link1;
  return_value_avahi_malloc_1_link4_link1=avahi_malloc((unsigned long int)n_link4_link1 * k_link4_link1);
  return return_value_avahi_malloc_1_link4_link1;
}

// avahi_new_internal_link4_link1_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link1_link1(unsigned int n_link4_link1_link1, unsigned long int k_link4_link1_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link4_link1_link1 < (unsigned long int)0x7fffffff / k_link4_link1_link1);
  void *return_value_avahi_malloc_1_link4_link1_link1;
  return_value_avahi_malloc_1_link4_link1_link1=avahi_malloc((unsigned long int)n_link4_link1_link1 * k_link4_link1_link1);
  return return_value_avahi_malloc_1_link4_link1_link1;
}

// avahi_new_internal_link4_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link2(unsigned int n_link4_link2, unsigned long int k_link4_link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link4_link2 < (unsigned long int)0x7fffffff / k_link4_link2);
  void *return_value_avahi_malloc_1_link4_link2;
  return_value_avahi_malloc_1_link4_link2=avahi_malloc((unsigned long int)n_link4_link2 * k_link4_link2);
  return return_value_avahi_malloc_1_link4_link2;
}

// avahi_new_internal_link4_link2_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link4_link2_link1(unsigned int n_link4_link2_link1, unsigned long int k_link4_link2_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link4_link2_link1 < (unsigned long int)0x7fffffff / k_link4_link2_link1);
  void *return_value_avahi_malloc_1_link4_link2_link1;
  return_value_avahi_malloc_1_link4_link2_link1=avahi_malloc((unsigned long int)n_link4_link2_link1 * k_link4_link2_link1);
  return return_value_avahi_malloc_1_link4_link2_link1;
}

// avahi_new_internal_link4_link3
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link3(unsigned int n_link4_link3, unsigned long int k_link4_link3)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link4_link3 < (unsigned long int)0x7fffffff / k_link4_link3);
  void *return_value_avahi_malloc_1_link4_link3;
  return_value_avahi_malloc_1_link4_link3=avahi_malloc((unsigned long int)n_link4_link3 * k_link4_link3);
  return return_value_avahi_malloc_1_link4_link3;
}

// avahi_new_internal_link4_link4
// file malloc.h line 48
static inline void * avahi_new_internal_link4_link4(unsigned int n_link4_link4, unsigned long int k_link4_link4)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link4_link4 < (unsigned long int)0x7fffffff / k_link4_link4);
  void *return_value_avahi_malloc_1_link4_link4;
  return_value_avahi_malloc_1_link4_link4=avahi_malloc((unsigned long int)n_link4_link4 * k_link4_link4);
  return return_value_avahi_malloc_1_link4_link4;
}

// avahi_new_internal_link5
// file malloc.h line 48
static inline void * avahi_new_internal_link5(unsigned int n_link5, unsigned long int k_link5)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link5 < (unsigned long int)0x7fffffff / k_link5);
  void *return_value_avahi_malloc_1_link5;
  return_value_avahi_malloc_1_link5=avahi_malloc((unsigned long int)n_link5 * k_link5);
  return return_value_avahi_malloc_1_link5;
}

// avahi_new_internal_link5_link1
// file malloc.h line 48
static inline void * avahi_new_internal_link5_link1(unsigned int n_link5_link1, unsigned long int k_link5_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link5_link1 < (unsigned long int)0x7fffffff / k_link5_link1);
  void *return_value_avahi_malloc_1_link5_link1;
  return_value_avahi_malloc_1_link5_link1=avahi_malloc((unsigned long int)n_link5_link1 * k_link5_link1);
  return return_value_avahi_malloc_1_link5_link1;
}

// avahi_new_internal_link5_link2
// file malloc.h line 48
static inline void * avahi_new_internal_link5_link2(unsigned int n_link5_link2, unsigned long int k_link5_link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link5_link2 < (unsigned long int)0x7fffffff / k_link5_link2);
  void *return_value_avahi_malloc_1_link5_link2;
  return_value_avahi_malloc_1_link5_link2=avahi_malloc((unsigned long int)n_link5_link2 * k_link5_link2);
  return return_value_avahi_malloc_1_link5_link2;
}

// avahi_new_internal_link6
// file malloc.h line 48
static inline void * avahi_new_internal_link6(unsigned int n_link6, unsigned long int k_link6)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link6 < (unsigned long int)0x7fffffff / k_link6);
  void *return_value_avahi_malloc_1_link6;
  return_value_avahi_malloc_1_link6=avahi_malloc((unsigned long int)n_link6 * k_link6);
  return return_value_avahi_malloc_1_link6;
}

// avahi_new_internal_link6_link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link6_link1(unsigned int n_link6_link1, unsigned long int k_link6_link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link6_link1 < (unsigned long int)0x7fffffff / k_link6_link1);
  void *return_value_avahi_malloc_1_link6_link1;
  return_value_avahi_malloc_1_link6_link1=avahi_malloc((unsigned long int)n_link6_link1 * k_link6_link1);
  return return_value_avahi_malloc_1_link6_link1;
}

// avahi_new_internal_link7
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal_link7(unsigned int n_link7, unsigned long int k_link7)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link7 < (unsigned long int)0x7fffffff / k_link7);
  void *return_value_avahi_malloc_1_link7;
  return_value_avahi_malloc_1_link7=avahi_malloc((unsigned long int)n_link7 * k_link7);
  return return_value_avahi_malloc_1_link7;
}

// avahi_new_internal_link8
// file malloc.h line 48
static inline void * avahi_new_internal_link8(unsigned int n_link8, unsigned long int k_link8)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n_link8 < (unsigned long int)0x7fffffff / k_link8);
  void *return_value_avahi_malloc_1_link8;
  return_value_avahi_malloc_1_link8=avahi_malloc((unsigned long int)n_link8 * k_link8);
  return return_value_avahi_malloc_1_link8;
}

// avahi_normalize_name
// file ../avahi-common/domain.h line 50
char * avahi_normalize_name(const char *s, char *ret_s, unsigned long int size)
{
  signed int empty = 1;
  char *r;
  /* assertion s */
  assert(s != ((const char *)NULL));
  /* assertion ret_s */
  assert(ret_s != ((char *)NULL));
  /* assertion size > 0 */
  assert(size > (unsigned long int)0);
  r = ret_s;
  *ret_s = (char)0;
  char *tmp_post_2;
  while(!(*s == 0))
  {
    char label[64l];
    char *return_value_avahi_unescape_label_1;
    return_value_avahi_unescape_label_1=avahi_unescape_label(&s, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label_1 == ((char *)NULL))
      return (char *)(void *)0;

    if((signed int)label[0l] == 0)
    {
      if((signed int)*s == 0)
      {
        if(!(empty == 0))
          return ret_s;

      }

      return (char *)(void *)0;
    }

    if(empty == 0)
    {
      if(!(size >= 1ul))
        return (char *)(void *)0;

      tmp_post_2 = r;
      r = r + 1l;
      *tmp_post_2 = (char)46;
      size = size - 1ul;
    }

    else
      empty = 0;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(label);
    avahi_escape_label(label, return_value_strlen_3, &r, &size);
  }
  return ret_s;
}

// avahi_normalize_name_strdup
// file domain.c line 219
char * avahi_normalize_name_strdup(const char *s)
{
  char t[1014l];
  /* assertion s */
  assert(s != ((const char *)NULL));
  char *return_value_avahi_normalize_name_1;
  return_value_avahi_normalize_name_1=avahi_normalize_name(s, t, sizeof(char [1014l]) /*1014ul*/ );
  if(return_value_avahi_normalize_name_1 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *return_value_avahi_strdup_2;
    return_value_avahi_strdup_2=avahi_strdup(t);
    return return_value_avahi_strdup_2;
  }
}

// avahi_nss_support
// file ../avahi-client/client.h line 111
signed int avahi_nss_support(void)
{
  signed int b = 0;
  static const char * const libs[4l] = { "libnss_mdns.so.2", "libnss_mdns4.so.2", "libnss_mdns6.so.2", (const char *)(void *)0 };
  const char * const *l = libs;
  for( ; !(*l == ((const char *)NULL)); l = l + 1l)
  {
    void *dl;
    dl=dlopen(*l, 0x00001);
    if(!(dl == NULL))
    {
      b = 1;
      dlclose(dl);
      break;
    }

  }
  return b;
}

// avahi_proto_to_af
// file address.c line 127
signed int avahi_proto_to_af(signed int proto)
{
  if(proto == 0)
    return 2;

  else
    if(proto == 1)
      return 10;

    else
    {
      /* assertion proto == AVAHI_PROTO_UNSPEC */
      assert(proto == -1);
      return 0;
    }
}

// avahi_proto_to_string
// file address.c line 147
const char * avahi_proto_to_string(signed int proto)
{
  if(proto == 0)
    return "IPv4";

  else
    if(proto == 1)
      return "IPv6";

    else
    {
      /* assertion proto == AVAHI_PROTO_UNSPEC */
      assert(proto == -1);
      return "UNSPEC";
    }
}

// avahi_realloc
// file malloc.c line 146
void * avahi_realloc(void *p, unsigned long int size)
{
  void *return_value_xrealloc_1;
  if(size == 0ul)
  {
    avahi_free(p);
    return (void *)0;
  }

  else
    if(allocator == ((const struct AvahiAllocator *)NULL))
    {
      return_value_xrealloc_1=xrealloc(p, size);
      return return_value_xrealloc_1;
    }

    else
    {
      /* assertion allocator->realloc */
      assert(allocator->realloc != ((void * (*)(void *, unsigned long int))NULL));
      void *return_value;
      return_value=allocator->realloc(p, size);
      return return_value;
    }
}

// avahi_record_browser_event
// file internal.h line 162
enum anonymous_42 avahi_record_browser_event(struct AvahiClient *client, enum anonymous_14 event, struct DBusMessage *message)
{
  struct AvahiRecordBrowser *b = (struct AvahiRecordBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *name;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  unsigned short int clazz;
  unsigned short int type;
  void *rdata = (void *)0;
  signed int rdata_size = 0;
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  signed int j;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  signed int return_value_dbus_message_iter_get_arg_type_5;
  _Bool tmp_if_expr_7;
  signed int return_value_dbus_message_iter_get_element_type_6;
  signed int return_value_dbus_message_iter_get_arg_type_8;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_9;
  _Bool tmp_if_expr_11;
  unsigned int return_value_dbus_error_is_set_10;
  signed int return_value_avahi_error_dbus_to_number_12;
  if(!(path == ((const char *)NULL)))
  {
    b = client->record_browsers;
    for( ; !(b == ((struct AvahiRecordBrowser *)NULL)); b = b->record_browsers_next)
    {
      return_value_strcmp_1=strcmp(b->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(b == ((struct AvahiRecordBrowser *)NULL))
      goto fail;

    interface = b->interface;
    protocol = b->protocol;
    clazz = b->clazz;
    type = b->type;
    name = b->name;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)113, &clazz, (signed int)113, &type, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        dbus_message_iter_init(message, &iter);
        j = 0;
        for( ; !(j >= 5); j = j + 1)
          dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type_5=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type_5 == 97))
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_dbus_message_iter_get_element_type_6=dbus_message_iter_get_element_type(&iter);
          tmp_if_expr_7 = return_value_dbus_message_iter_get_element_type_6 != (signed int)121 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
          goto fail;

        dbus_message_iter_recurse(&iter, &sub);
        dbus_message_iter_get_fixed_array(&sub, (void *)&rdata, &rdata_size);
        dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type_8=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type_8 == 117))
          goto fail;

        dbus_message_iter_get_basic(&iter, (void *)&flags);
        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args_9=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_9 == 0u)
          tmp_if_expr_11 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_10=dbus_error_is_set(&error);
          tmp_if_expr_11 = return_value_dbus_error_is_set_10 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_11)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_12=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(b->client, return_value_avahi_error_dbus_to_number_12);
      }
    }
    b->callback(b, (signed int)interface, (signed int)protocol, event, name, clazz, type, rdata, (unsigned long int)rdata_size, (enum anonymous_13)flags, b->userdata);
    return (enum anonymous_42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous_42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_record_browser_free
// file lookup.h line 308
signed int avahi_record_browser_free(struct AvahiRecordBrowser *b)
{
  struct AvahiClient *client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiRecordBrowser *)NULL));
  client = b->client;
  signed int return_value_avahi_client_is_connected_1;
  if(!(b->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(b->client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      r=avahi_client_simple_method_call(client, b->path, "org.freedesktop.Avahi.RecordBrowser", "Free");

  }

  do
  {
    struct AvahiRecordBrowser **_head = &b->client->record_browsers;
    struct AvahiRecordBrowser *_item = b;
    /* assertion _item */
    assert(_item != ((struct AvahiRecordBrowser *)NULL));
    if(!(_item->record_browsers_next == ((struct AvahiRecordBrowser *)NULL)))
      _item->record_browsers_next->record_browsers_prev = _item->record_browsers_prev;

    if(!(_item->record_browsers_prev == ((struct AvahiRecordBrowser *)NULL)))
      _item->record_browsers_prev->record_browsers_next = _item->record_browsers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->record_browsers_next;
    }
    _item->record_browsers_prev = (struct AvahiRecordBrowser *)(void *)0;
    _item->record_browsers_next = _item->record_browsers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)b->path);
  avahi_free((void *)b->name);
  avahi_free((void *)b);
  return r;
}

// avahi_record_browser_get_client
// file browser.c line 903
struct AvahiClient * avahi_record_browser_get_client(struct AvahiRecordBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiRecordBrowser *)NULL));
  return b->client;
}

// avahi_record_browser_new
// file browser.c line 786
struct AvahiRecordBrowser * avahi_record_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, unsigned short int clazz, unsigned short int type, enum anonymous_44 flags, void (*callback)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous_14, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous_13, void *), void *userdata)
{
  struct AvahiRecordBrowser *b = (struct AvahiRecordBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_protocol;
  signed int i_interface;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous_14, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous_13, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal_2=avahi_new_internal_link2((unsigned int)1, sizeof(struct AvahiRecordBrowser) /*72ul*/ );
    b = (struct AvahiRecordBrowser *)return_value_avahi_new_internal_2;
    if(b == ((struct AvahiRecordBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      b->client = client;
      b->callback = callback;
      b->userdata = userdata;
      b->path = (char *)(void *)0;
      b->name = (char *)(void *)0;
      b->clazz = clazz;
      b->type = type;
      b->interface = interface;
      b->protocol = protocol;
      do
      {
        struct AvahiRecordBrowser **_head = &client->record_browsers;
        struct AvahiRecordBrowser *_item = b;
        /* assertion _item */
        assert(_item != ((struct AvahiRecordBrowser *)NULL));
        _item->record_browsers_next = *_head;
        if(!(_item->record_browsers_next == ((struct AvahiRecordBrowser *)NULL)))
          _item->record_browsers_next->record_browsers_prev = _item;

        _item->record_browsers_prev = (struct AvahiRecordBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      b->name=avahi_strdup(name);
      if(b->name == ((char *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "RecordBrowserNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &name, (signed int)113, &clazz, (signed int)113, &type, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args_3 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr_5 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
              tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_5)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args_6 == 0u)
                tmp_if_expr_8 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
                tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr_8)
                avahi_client_set_errno(client, -22);

              else
              {
                b->path=avahi_strdup(path);
                if(b->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return b;
                }
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_9;
  return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(b == ((struct AvahiRecordBrowser *)NULL)))
    avahi_record_browser_free(b);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiRecordBrowser *)(void *)0;
}

// avahi_reverse_lookup_name
// file address.c line 67
char * avahi_reverse_lookup_name(const struct AvahiAddress *a, char *ret_s, unsigned long int length)
{
  /* assertion ret_s */
  assert(ret_s != ((char *)NULL));
  /* assertion length > 0 */
  assert(length > (unsigned long int)0);
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  if(a->proto == 0)
  {
    unsigned int n;
    n=ntohl(a->data.ipv4.address);
    snprintf(ret_s, length, "%u.%u.%u.%u.in-addr.arpa", n & (unsigned int)0xFF, n >> 8 & (unsigned int)0xFF, n >> 16 & (unsigned int)0xFF, n >> 24);
  }

  else
  {
    /* assertion a->proto == AVAHI_PROTO_INET6 */
    assert(a->proto == 1);
    snprintf(ret_s, length, "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.ip6.arpa", (signed int)a->data.ipv6.address[(signed long int)15] & 0xF, (signed int)a->data.ipv6.address[(signed long int)15] >> 4, (signed int)a->data.ipv6.address[(signed long int)14] & 0xF, (signed int)a->data.ipv6.address[(signed long int)14] >> 4, (signed int)a->data.ipv6.address[(signed long int)13] & 0xF, (signed int)a->data.ipv6.address[(signed long int)13] >> 4, (signed int)a->data.ipv6.address[(signed long int)12] & 0xF, (signed int)a->data.ipv6.address[(signed long int)12] >> 4, (signed int)a->data.ipv6.address[(signed long int)11] & 0xF, (signed int)a->data.ipv6.address[(signed long int)11] >> 4, (signed int)a->data.ipv6.address[(signed long int)10] & 0xF, (signed int)a->data.ipv6.address[(signed long int)10] >> 4, (signed int)a->data.ipv6.address[(signed long int)9] & 0xF, (signed int)a->data.ipv6.address[(signed long int)9] >> 4, (signed int)a->data.ipv6.address[(signed long int)8] & 0xF, (signed int)a->data.ipv6.address[(signed long int)8] >> 4, (signed int)a->data.ipv6.address[(signed long int)7] & 0xF, (signed int)a->data.ipv6.address[(signed long int)7] >> 4, (signed int)a->data.ipv6.address[(signed long int)6] & 0xF, (signed int)a->data.ipv6.address[(signed long int)6] >> 4, (signed int)a->data.ipv6.address[(signed long int)5] & 0xF, (signed int)a->data.ipv6.address[(signed long int)5] >> 4, (signed int)a->data.ipv6.address[(signed long int)4] & 0xF, (signed int)a->data.ipv6.address[(signed long int)4] >> 4, (signed int)a->data.ipv6.address[(signed long int)3] & 0xF, (signed int)a->data.ipv6.address[(signed long int)3] >> 4, (signed int)a->data.ipv6.address[(signed long int)2] & 0xF, (signed int)a->data.ipv6.address[(signed long int)2] >> 4, (signed int)a->data.ipv6.address[(signed long int)1] & 0xF, (signed int)a->data.ipv6.address[(signed long int)1] >> 4, (signed int)a->data.ipv6.address[(signed long int)0] & 0xF, (signed int)a->data.ipv6.address[(signed long int)0] >> 4);
  }
  return ret_s;
}

// avahi_rlist_prepend
// file rlist.c line 29
struct AvahiRList * avahi_rlist_prepend(struct AvahiRList *r, void *data)
{
  struct AvahiRList *n;
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link4_link1((unsigned int)1, sizeof(struct AvahiRList) /*24ul*/ );
  n = (struct AvahiRList *)return_value_avahi_new_internal_1;
  if(n == ((struct AvahiRList *)NULL))
    return (struct AvahiRList *)(void *)0;

  else
  {
    n->data = data;
    do
    {
      struct AvahiRList **_head = &r;
      struct AvahiRList *_item = n;
      /* assertion _item */
      assert(_item != ((struct AvahiRList *)NULL));
      _item->rlist_next = *_head;
      if(!(_item->rlist_next == ((struct AvahiRList *)NULL)))
        _item->rlist_next->rlist_prev = _item;

      _item->rlist_prev = (struct AvahiRList *)(void *)0;
      *_head = _item;
    }
    while((_Bool)0);
    return r;
  }
}

// avahi_rlist_remove
// file rlist.c line 41
struct AvahiRList * avahi_rlist_remove(struct AvahiRList *r, void *data)
{
  struct AvahiRList *n = r;
  for( ; !(n == ((struct AvahiRList *)NULL)); n = n->rlist_next)
    if(n->data == data)
    {
      do
      {
        struct AvahiRList **_head = &r;
        struct AvahiRList *_item = n;
        /* assertion _item */
        assert(_item != ((struct AvahiRList *)NULL));
        if(!(_item->rlist_next == ((struct AvahiRList *)NULL)))
          _item->rlist_next->rlist_prev = _item->rlist_prev;

        if(!(_item->rlist_prev == ((struct AvahiRList *)NULL)))
          _item->rlist_prev->rlist_next = _item->rlist_next;

        else
        {
          /* assertion *_head == _item */
          assert(*_head == _item);
          *_head = _item->rlist_next;
        }
        _item->rlist_prev = (struct AvahiRList *)(void *)0;
        _item->rlist_next = _item->rlist_prev;
      }
      while((_Bool)0);
      avahi_free((void *)n);
      break;
    }

  return r;
}

// avahi_rlist_remove_by_link
// file rlist.c line 55
struct AvahiRList * avahi_rlist_remove_by_link(struct AvahiRList *r, struct AvahiRList *n)
{
  /* assertion n */
  assert(n != ((struct AvahiRList *)NULL));
  do
  {
    struct AvahiRList **_head = &r;
    struct AvahiRList *_item = n;
    /* assertion _item */
    assert(_item != ((struct AvahiRList *)NULL));
    if(!(_item->rlist_next == ((struct AvahiRList *)NULL)))
      _item->rlist_next->rlist_prev = _item->rlist_prev;

    if(!(_item->rlist_prev == ((struct AvahiRList *)NULL)))
      _item->rlist_prev->rlist_next = _item->rlist_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->rlist_next;
    }
    _item->rlist_prev = (struct AvahiRList *)(void *)0;
    _item->rlist_next = _item->rlist_prev;
  }
  while((_Bool)0);
  avahi_free((void *)n);
  return r;
}

// avahi_service_browser_event
// file internal.h line 161
enum anonymous_42 avahi_service_browser_event(struct AvahiClient *client, enum anonymous_14 event, struct DBusMessage *message)
{
  struct AvahiServiceBrowser *b = (struct AvahiServiceBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *name = (char *)(void *)0;
  char *type;
  char *domain;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_5;
  _Bool tmp_if_expr_7;
  unsigned int return_value_dbus_error_is_set_6;
  signed int return_value_avahi_error_dbus_to_number_8;
  if(!(path == ((const char *)NULL)))
  {
    b = client->service_browsers;
    for( ; !(b == ((struct AvahiServiceBrowser *)NULL)); b = b->service_browsers_next)
    {
      return_value_strcmp_1=strcmp(b->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(b == ((struct AvahiServiceBrowser *)NULL))
      goto fail;

    type = b->type;
    domain = b->domain;
    interface = b->interface;
    protocol = b->protocol;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args_5=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_5 == 0u)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
          tmp_if_expr_7 = return_value_dbus_error_is_set_6 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_8=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(b->client, return_value_avahi_error_dbus_to_number_8);
      }
    }
    b->callback(b, (signed int)interface, (signed int)protocol, event, name, type, domain, (enum anonymous_13)flags, b->userdata);
    return (enum anonymous_42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous_42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_service_browser_free
// file lookup.h line 117
signed int avahi_service_browser_free(struct AvahiServiceBrowser *b)
{
  struct AvahiClient *client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiServiceBrowser *)NULL));
  client = b->client;
  signed int return_value_avahi_client_is_connected_1;
  if(!(b->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(b->client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      r=avahi_client_simple_method_call(client, b->path, "org.freedesktop.Avahi.ServiceBrowser", "Free");

  }

  do
  {
    struct AvahiServiceBrowser **_head = &b->client->service_browsers;
    struct AvahiServiceBrowser *_item = b;
    /* assertion _item */
    assert(_item != ((struct AvahiServiceBrowser *)NULL));
    if(!(_item->service_browsers_next == ((struct AvahiServiceBrowser *)NULL)))
      _item->service_browsers_next->service_browsers_prev = _item->service_browsers_prev;

    if(!(_item->service_browsers_prev == ((struct AvahiServiceBrowser *)NULL)))
      _item->service_browsers_prev->service_browsers_next = _item->service_browsers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->service_browsers_next;
    }
    _item->service_browsers_prev = (struct AvahiServiceBrowser *)(void *)0;
    _item->service_browsers_next = _item->service_browsers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)b->path);
  avahi_free((void *)b->type);
  avahi_free((void *)b->domain);
  avahi_free((void *)b);
  return r;
}

// avahi_service_browser_get_client
// file browser.c line 686
struct AvahiClient * avahi_service_browser_get_client(struct AvahiServiceBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiServiceBrowser *)NULL));
  return b->client;
}

// avahi_service_browser_new
// file browser.c line 564
struct AvahiServiceBrowser * avahi_service_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *type, const char *domain, enum anonymous_44 flags, void (*callback)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous_14, const char *, const char *, const char *, enum anonymous_13, void *), void *userdata)
{
  struct AvahiServiceBrowser *b = (struct AvahiServiceBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_protocol;
  signed int i_interface;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous_14, const char *, const char *, const char *, enum anonymous_13, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    return_value_avahi_new_internal_2=avahi_new_internal_link2((unsigned int)1, sizeof(struct AvahiServiceBrowser) /*72ul*/ );
    b = (struct AvahiServiceBrowser *)return_value_avahi_new_internal_2;
    if(b == ((struct AvahiServiceBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      b->client = client;
      b->callback = callback;
      b->userdata = userdata;
      b->path = (char *)(void *)0;
      b->domain = (char *)(void *)0;
      b->type = b->domain;
      b->interface = interface;
      b->protocol = protocol;
      do
      {
        struct AvahiServiceBrowser **_head = &client->service_browsers;
        struct AvahiServiceBrowser *_item = b;
        /* assertion _item */
        assert(_item != ((struct AvahiServiceBrowser *)NULL));
        _item->service_browsers_next = *_head;
        if(!(_item->service_browsers_next == ((struct AvahiServiceBrowser *)NULL)))
          _item->service_browsers_next->service_browsers_prev = _item;

        _item->service_browsers_prev = (struct AvahiServiceBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      b->type=avahi_strdup(type);
      if(b->type == ((char *)NULL))
        avahi_client_set_errno(client, -24);

      else
        if(!(domain == ((const char *)NULL)))
        {
          if(*domain == 0)
            goto __CPROVER_DUMP_L7;

          b->domain=avahi_strdup(domain);
          if(!(b->domain == ((char *)NULL)))
            goto __CPROVER_DUMP_L7;

          avahi_client_set_errno(client, -24);
        }

        else
        {

        __CPROVER_DUMP_L7:
          ;
          message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "ServiceBrowserNew");
          if(message == ((struct DBusMessage *)NULL))
            avahi_client_set_errno(client, -24);

          else
          {
            i_interface = (signed int)interface;
            i_protocol = (signed int)protocol;
            u_flags = (unsigned int)flags;
            return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &type, (signed int)115, &domain, (signed int)117, &u_flags, (signed int)0);
            if(return_value_dbus_message_append_args_3 == 0u)
              avahi_client_set_errno(client, -24);

            else
            {
              reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
              if(reply == ((struct DBusMessage *)NULL))
                tmp_if_expr_5 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
                tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_5)
                avahi_client_set_errno(client, -22);

              else
              {
                return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
                if(return_value_dbus_message_get_args_6 == 0u)
                  tmp_if_expr_8 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
                  tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(path == ((char *)NULL) || tmp_if_expr_8)
                  avahi_client_set_errno(client, -22);

                else
                {
                  b->path=avahi_strdup(path);
                  if(b->path == ((char *)NULL))
                    avahi_client_set_errno(client, -24);

                  else
                  {
                    dbus_message_unref(message);
                    dbus_message_unref(reply);
                    return b;
                  }
                }
              }
            }
          }
        }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_9;
  return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(b == ((struct AvahiServiceBrowser *)NULL)))
    avahi_service_browser_free(b);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiServiceBrowser *)(void *)0;
}

// avahi_service_name_join
// file domain.c line 440
signed int avahi_service_name_join(char *p, unsigned long int size, const char *name, const char *type, const char *domain)
{
  char escaped_name[256l];
  char normalized_type[1014l];
  char normalized_domain[1014l];
  /* assertion p */
  assert(p != ((char *)NULL));
  signed int return_value_avahi_is_valid_service_name_1;
  char *tmp_if_expr_7;
  if(!(name == ((const char *)NULL)))
  {
    return_value_avahi_is_valid_service_name_1=avahi_is_valid_service_name(name);
    if(!(return_value_avahi_is_valid_service_name_1 == 0))
      goto __CPROVER_DUMP_L1;

    return -10;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    signed int return_value_avahi_is_valid_service_type_generic_2;
    return_value_avahi_is_valid_service_type_generic_2=avahi_is_valid_service_type_generic(type);
    if(return_value_avahi_is_valid_service_type_generic_2 == 0)
      return -11;

    else
    {
      signed int return_value_avahi_is_valid_domain_name_3;
      return_value_avahi_is_valid_domain_name_3=avahi_is_valid_domain_name(domain);
      if(return_value_avahi_is_valid_domain_name_3 == 0)
        return -4;

      else
      {
        if(!(name == ((const char *)NULL)))
        {
          unsigned long int l = sizeof(char [256l]) /*256ul*/ ;
          char *e = escaped_name;
          char *r;
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(name);
          r=avahi_escape_label(name, return_value_strlen_4, &e, &l);
          /* assertion r */
          assert(r != ((char *)NULL));
        }

        char *return_value_avahi_normalize_name_5;
        return_value_avahi_normalize_name_5=avahi_normalize_name(type, normalized_type, sizeof(char [1014l]) /*1014ul*/ );
        if(return_value_avahi_normalize_name_5 == ((char *)NULL))
          return -11;

        else
        {
          char *return_value_avahi_normalize_name_6;
          return_value_avahi_normalize_name_6=avahi_normalize_name(domain, normalized_domain, sizeof(char [1014l]) /*1014ul*/ );
          if(return_value_avahi_normalize_name_6 == ((char *)NULL))
            return -4;

          else
          {
            if(!(name == ((const char *)NULL)))
              tmp_if_expr_7 = escaped_name;

            else
              tmp_if_expr_7 = "";
            snprintf(p, size, "%s%s%s.%s", tmp_if_expr_7, name != ((const char *)NULL) ? "." : "", (const void *)normalized_type, (const void *)normalized_domain);
            return 0;
          }
        }
      }
    }
  }
}

// avahi_service_name_split
// file domain.c line 496
signed int avahi_service_name_split(const char *p, char *name, unsigned long int name_size, char *type, unsigned long int type_size, char *domain, unsigned long int domain_size)
{
  /* #anon_enum_NAME=0_TYPE=1_DOMAIN=2 */
enum anonymous_4 { NAME=0, TYPE=1, DOMAIN=2 };

/* */
  ;
  enum anonymous_4 state;
  signed int type_empty = 1;
  signed int domain_empty = 1;
  /* assertion p */
  assert(p != ((const char *)NULL));
  /* assertion type */
  assert(type != ((char *)NULL));
  /* assertion type_size > 0 */
  assert(type_size > (unsigned long int)0);
  /* assertion domain */
  assert(domain != ((char *)NULL));
  /* assertion domain_size > 0 */
  assert(domain_size > (unsigned long int)0);
  if(!(name == ((char *)NULL)))
  {
    /* assertion name_size > 0 */
    assert(name_size > (unsigned long int)0);
    *name = (char)0;
    state = (enum anonymous_4)NAME;
  }

  else
    state = (enum anonymous_4)TYPE;
  *domain = (char)0;
  *type = *domain;
  char *tmp_post_2;
  char *tmp_post_5;
  unsigned long int return_value_strlen_6;
  char *return_value_avahi_escape_label_7;
  while(!(*p == 0))
  {
    char buf[64l];
    char *return_value_avahi_unescape_label_1;
    return_value_avahi_unescape_label_1=avahi_unescape_label(&p, buf, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label_1 == ((char *)NULL))
      return -1;

    switch((signed int)state)
    {
      case NAME:
      {
        strlcpy(name, buf, name_size);
        state = (enum anonymous_4)TYPE;
        break;
      }
      case TYPE:
      {
        if((signed int)buf[0l] == 95)
        {
          if(type_empty == 0)
          {
            if(type_size == 0ul)
              return -24;

            tmp_post_2 = type;
            type = type + 1l;
            *tmp_post_2 = (char)46;
            type_size = type_size - 1ul;
          }

          else
            type_empty = 0;
          unsigned long int return_value_strlen_3;
          return_value_strlen_3=strlen(buf);
          char *return_value_avahi_escape_label_4;
          return_value_avahi_escape_label_4=avahi_escape_label(buf, return_value_strlen_3, &type, &type_size);
          if(return_value_avahi_escape_label_4 == ((char *)NULL))
            return -24;

          break;
        }

        state = (enum anonymous_4)DOMAIN;
      }
      case DOMAIN:
      {
        if(domain_empty == 0)
        {
          if(domain_size == 0ul)
            return -24;

          tmp_post_5 = domain;
          domain = domain + 1l;
          *tmp_post_5 = (char)46;
          domain_size = domain_size - 1ul;
        }

        else
          domain_empty = 0;
        return_value_strlen_6=strlen(buf);
        return_value_avahi_escape_label_7=avahi_escape_label(buf, return_value_strlen_6, &domain, &domain_size);
        if(return_value_avahi_escape_label_7 == ((char *)NULL))
          return -24;

      }
    }
  }
  return 0;
}

// avahi_service_resolver_event
// file internal.h line 164
enum anonymous_42 avahi_service_resolver_event(struct AvahiClient *client, enum anonymous_12 event, struct DBusMessage *message)
{
  struct AvahiServiceResolver *r = (struct AvahiServiceResolver *)(void *)0;
  struct DBusError error;
  const char *path;
  struct AvahiStringList *strlst = (struct AvahiStringList *)(void *)0;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  signed int j;
  signed int interface;
  signed int protocol;
  signed int aprotocol;
  unsigned int flags;
  char *name;
  char *type;
  char *domain;
  char *host;
  char *address;
  unsigned short int port;
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  struct AvahiAddress a;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  signed int return_value_dbus_message_iter_get_arg_type_5;
  _Bool tmp_if_expr_7;
  signed int return_value_dbus_message_iter_get_element_type_6;
  signed int return_value_dbus_message_iter_get_arg_type_9;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_10;
  _Bool tmp_if_expr_12;
  unsigned int return_value_dbus_error_is_set_11;
  signed int return_value_avahi_error_dbus_to_number_13;
  if(!(path == ((const char *)NULL)))
  {
    r = client->service_resolvers;
    for( ; !(r == ((struct AvahiServiceResolver *)NULL)); r = r->service_resolvers_next)
    {
      return_value_strcmp_1=strcmp(r->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(r == ((struct AvahiServiceResolver *)NULL))
      goto fail;

    switch((signed int)event)
    {
      case AVAHI_RESOLVER_FOUND:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)115, &host, (signed int)105, &aprotocol, (signed int)115, &address, (signed int)113, &port, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        dbus_message_iter_init(message, &iter);
        j = 0;
        for( ; !(j >= 9); j = j + 1)
          dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type_5=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type_5 == 97))
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_dbus_message_iter_get_element_type_6=dbus_message_iter_get_element_type(&iter);
          tmp_if_expr_7 = return_value_dbus_message_iter_get_element_type_6 != (signed int)97 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          fprintf(stderr, "Error parsing service resolving message\n");
          goto fail;
        }

        strlst = (struct AvahiStringList *)(void *)0;
        dbus_message_iter_recurse(&iter, &sub);
        do
        {
          struct DBusMessageIter sub2;
          signed int at;
          const unsigned char *k;
          signed int n;
          at=dbus_message_iter_get_arg_type(&sub);
          if(at == 0)
            break;

          /* assertion at == ((int) 'a') */
          assert(at == (signed int)97);
          signed int return_value_dbus_message_iter_get_element_type_8;
          return_value_dbus_message_iter_get_element_type_8=dbus_message_iter_get_element_type(&sub);
          if(!(return_value_dbus_message_iter_get_element_type_8 == 121))
          {
            fprintf(stderr, "Error parsing service resolving message\n");
            goto fail;
          }

          dbus_message_iter_recurse(&sub, &sub2);
          k = (const unsigned char *)(void *)0;
          n = 0;
          dbus_message_iter_get_fixed_array(&sub2, (void *)&k, &n);
          if(n >= 1 && !(k == ((const unsigned char *)NULL)))
            strlst=avahi_string_list_add_arbitrary(strlst, k, (unsigned long int)n);

          dbus_message_iter_next(&sub);
        }
        while((_Bool)1);
        dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type_9=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type_9 == 117))
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        dbus_message_iter_get_basic(&iter, (void *)&flags);
        /* assertion address */
        assert(address != ((char *)NULL));
        if((signed int)*address == 0)
          address = (char *)(void *)0;

        else
          avahi_address_parse(address, (signed int)aprotocol, &a);
        r->callback(r, (signed int)interface, (signed int)protocol, (enum anonymous_12)AVAHI_RESOLVER_FOUND, name, type, domain, host, address != ((char *)NULL) ? &a : (struct AvahiAddress *)(void *)0, port, strlst, (enum anonymous_13)flags, r->userdata);
      }
      case AVAHI_RESOLVER_FAILURE:
      {
        return_value_dbus_message_get_args_10=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_10 == 0u)
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_11=dbus_error_is_set(&error);
          tmp_if_expr_12 = return_value_dbus_error_is_set_11 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_12)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_13=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(r->client, return_value_avahi_error_dbus_to_number_13);
        r->callback(r, r->interface, r->protocol, event, r->name, r->type, r->domain, (const char *)(void *)0, (const struct AvahiAddress *)(void *)0, (unsigned short int)0, (struct AvahiStringList *)(void *)0, (enum anonymous_13)0, r->userdata);
      }
    }
    return (enum anonymous_42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    avahi_string_list_free(strlst);
    return (enum anonymous_42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_service_resolver_free
// file lookup.h line 205
signed int avahi_service_resolver_free(struct AvahiServiceResolver *r)
{
  struct AvahiClient *client;
  signed int ret = 0;
  /* assertion r */
  assert(r != ((struct AvahiServiceResolver *)NULL));
  client = r->client;
  signed int return_value_avahi_client_is_connected_1;
  if(!(r->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      ret=avahi_client_simple_method_call(client, r->path, "org.freedesktop.Avahi.ServiceResolver", "Free");

  }

  do
  {
    struct AvahiServiceResolver **_head = &client->service_resolvers;
    struct AvahiServiceResolver *_item = r;
    /* assertion _item */
    assert(_item != ((struct AvahiServiceResolver *)NULL));
    if(!(_item->service_resolvers_next == ((struct AvahiServiceResolver *)NULL)))
      _item->service_resolvers_next->service_resolvers_prev = _item->service_resolvers_prev;

    if(!(_item->service_resolvers_prev == ((struct AvahiServiceResolver *)NULL)))
      _item->service_resolvers_prev->service_resolvers_next = _item->service_resolvers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->service_resolvers_next;
    }
    _item->service_resolvers_prev = (struct AvahiServiceResolver *)(void *)0;
    _item->service_resolvers_next = _item->service_resolvers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)r->path);
  avahi_free((void *)r->name);
  avahi_free((void *)r->type);
  avahi_free((void *)r->domain);
  avahi_free((void *)r);
  return ret;
}

// avahi_service_resolver_get_client
// file resolver.c line 318
struct AvahiClient * avahi_service_resolver_get_client(struct AvahiServiceResolver *r)
{
  /* assertion r */
  assert(r != ((struct AvahiServiceResolver *)NULL));
  return r->client;
}

// avahi_service_resolver_new
// file resolver.c line 179
struct AvahiServiceResolver * avahi_service_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, const char *type, const char *domain, signed int aprotocol, enum anonymous_44 flags, void (*callback)(struct AvahiServiceResolver *, signed int, signed int, enum anonymous_12, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous_13, void *), void *userdata)
{
  struct DBusError error;
  struct AvahiServiceResolver *r = (struct AvahiServiceResolver *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int i_interface;
  signed int i_protocol;
  signed int i_aprotocol;
  unsigned int u_flags;
  char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  if(domain == ((const char *)NULL))
    domain = "";

  if(name == ((const char *)NULL))
    name = "";

  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal_2=avahi_new_internal_link3((unsigned int)1, sizeof(struct AvahiServiceResolver) /*80ul*/ );
    r = (struct AvahiServiceResolver *)return_value_avahi_new_internal_2;
    if(r == ((struct AvahiServiceResolver *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      r->client = client;
      r->callback = callback;
      r->userdata = userdata;
      r->path = (char *)(void *)0;
      r->domain = (char *)(void *)0;
      r->type = r->domain;
      r->name = r->type;
      r->interface = interface;
      r->protocol = protocol;
      do
      {
        struct AvahiServiceResolver **_head = &client->service_resolvers;
        struct AvahiServiceResolver *_item = r;
        /* assertion _item */
        assert(_item != ((struct AvahiServiceResolver *)NULL));
        _item->service_resolvers_next = *_head;
        if(!(_item->service_resolvers_next == ((struct AvahiServiceResolver *)NULL)))
          _item->service_resolvers_next->service_resolvers_prev = _item;

        _item->service_resolvers_prev = (struct AvahiServiceResolver *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      if(!(name == ((const char *)NULL)))
      {
        if(*name == 0)
          goto __CPROVER_DUMP_L7;

        r->name=avahi_strdup(name);
        if(!(r->name == ((char *)NULL)))
          goto __CPROVER_DUMP_L7;

        avahi_client_set_errno(client, -24);
      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        r->type=avahi_strdup(type);
        if(r->type == ((char *)NULL))
          avahi_client_set_errno(client, -24);

        else
          if(!(domain == ((const char *)NULL)))
          {
            if(*domain == 0)
              goto __CPROVER_DUMP_L9;

            r->domain=avahi_strdup(domain);
            if(!(r->domain == ((char *)NULL)))
              goto __CPROVER_DUMP_L9;

            avahi_client_set_errno(client, -24);
          }

          else
          {

          __CPROVER_DUMP_L9:
            ;
            message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "ServiceResolverNew");
            if(message == ((struct DBusMessage *)NULL))
              avahi_client_set_errno(client, -24);

            else
            {
              i_interface = (signed int)interface;
              i_protocol = (signed int)protocol;
              i_aprotocol = (signed int)aprotocol;
              u_flags = (unsigned int)flags;
              return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)105, &i_aprotocol, (signed int)117, &u_flags, (signed int)0);
              if(return_value_dbus_message_append_args_3 == 0u)
                avahi_client_set_errno(client, -24);

              else
              {
                reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
                if(reply == ((struct DBusMessage *)NULL))
                  tmp_if_expr_5 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
                  tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_5)
                  avahi_client_set_errno(client, -22);

                else
                {
                  return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
                  if(return_value_dbus_message_get_args_6 == 0u)
                    tmp_if_expr_8 = (_Bool)1;

                  else
                  {
                    return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
                    tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
                  }
                  if(path == ((char *)NULL) || tmp_if_expr_8)
                    avahi_client_set_errno(client, -22);

                  else
                  {
                    r->path=avahi_strdup(path);
                    if(r->path == ((char *)NULL))
                      avahi_client_set_errno(client, -24);

                    else
                    {
                      dbus_message_unref(message);
                      dbus_message_unref(reply);
                      return r;
                    }
                  }
                }
              }
            }
          }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_9;
  return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(r == ((struct AvahiServiceResolver *)NULL)))
    avahi_service_resolver_free(r);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiServiceResolver *)(void *)0;
}

// avahi_service_type_browser_event
// file internal.h line 160
enum anonymous_42 avahi_service_type_browser_event(struct AvahiClient *client, enum anonymous_14 event, struct DBusMessage *message)
{
  struct AvahiServiceTypeBrowser *b = (struct AvahiServiceTypeBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *domain;
  char *type = (char *)(void *)0;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp_1;
  unsigned int return_value_dbus_message_get_args_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_dbus_error_is_set_3;
  char *etxt;
  unsigned int return_value_dbus_message_get_args_5;
  _Bool tmp_if_expr_7;
  unsigned int return_value_dbus_error_is_set_6;
  signed int return_value_avahi_error_dbus_to_number_8;
  if(!(path == ((const char *)NULL)))
  {
    b = client->service_type_browsers;
    for( ; !(b == ((struct AvahiServiceTypeBrowser *)NULL)); b = b->service_type_browsers_next)
    {
      return_value_strcmp_1=strcmp(b->path, path);
      if(return_value_strcmp_1 == 0)
        break;

    }
    if(b == ((struct AvahiServiceTypeBrowser *)NULL))
      goto fail;

    domain = b->domain;
    interface = b->interface;
    protocol = b->protocol;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args_2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &type, (signed int)115, &domain, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args_2 == 0u)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_3=dbus_error_is_set(&error);
          tmp_if_expr_4 = return_value_dbus_error_is_set_3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args_5=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args_5 == 0u)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
          tmp_if_expr_7 = return_value_dbus_error_is_set_6 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number_8=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(b->client, return_value_avahi_error_dbus_to_number_8);
      }
    }
    b->callback(b, (signed int)interface, (signed int)protocol, event, type, domain, (enum anonymous_13)flags, b->userdata);
    return (enum anonymous_42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous_42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_service_type_browser_free
// file lookup.h line 150
signed int avahi_service_type_browser_free(struct AvahiServiceTypeBrowser *b)
{
  struct AvahiClient *client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiServiceTypeBrowser *)NULL));
  client = b->client;
  signed int return_value_avahi_client_is_connected_1;
  if(!(b->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected_1=avahi_client_is_connected(b->client);
    if(!(return_value_avahi_client_is_connected_1 == 0))
      r=avahi_client_simple_method_call(client, b->path, "org.freedesktop.Avahi.ServiceTypeBrowser", "Free");

  }

  do
  {
    struct AvahiServiceTypeBrowser **_head = &b->client->service_type_browsers;
    struct AvahiServiceTypeBrowser *_item = b;
    /* assertion _item */
    assert(_item != ((struct AvahiServiceTypeBrowser *)NULL));
    if(!(_item->service_type_browsers_next == ((struct AvahiServiceTypeBrowser *)NULL)))
      _item->service_type_browsers_next->service_type_browsers_prev = _item->service_type_browsers_prev;

    if(!(_item->service_type_browsers_prev == ((struct AvahiServiceTypeBrowser *)NULL)))
      _item->service_type_browsers_prev->service_type_browsers_next = _item->service_type_browsers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->service_type_browsers_next;
    }
    _item->service_type_browsers_prev = (struct AvahiServiceTypeBrowser *)(void *)0;
    _item->service_type_browsers_next = _item->service_type_browsers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)b->path);
  avahi_free((void *)b->domain);
  avahi_free((void *)b);
  return r;
}

// avahi_service_type_browser_get_client
// file browser.c line 465
struct AvahiClient * avahi_service_type_browser_get_client(struct AvahiServiceTypeBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiServiceTypeBrowser *)NULL));
  return b->client;
}

// avahi_service_type_browser_new
// file browser.c line 350
struct AvahiServiceTypeBrowser * avahi_service_type_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous_44 flags, void (*callback)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous_14, const char *, const char *, enum anonymous_13, void *), void *userdata)
{
  struct AvahiServiceTypeBrowser *b = (struct AvahiServiceTypeBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous_14, const char *, const char *, enum anonymous_13, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected_1;
  return_value_avahi_client_is_connected_1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal_2;
  unsigned int return_value_dbus_message_append_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  unsigned int return_value_dbus_message_get_args_6;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  if(return_value_avahi_client_is_connected_1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    return_value_avahi_new_internal_2=avahi_new_internal_link2((unsigned int)1, sizeof(struct AvahiServiceTypeBrowser) /*64ul*/ );
    b = (struct AvahiServiceTypeBrowser *)return_value_avahi_new_internal_2;
    if(b == ((struct AvahiServiceTypeBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      b->client = client;
      b->callback = callback;
      b->userdata = userdata;
      b->path = (char *)(void *)0;
      b->domain = (char *)(void *)0;
      b->interface = interface;
      b->protocol = protocol;
      do
      {
        struct AvahiServiceTypeBrowser **_head = &client->service_type_browsers;
        struct AvahiServiceTypeBrowser *_item = b;
        /* assertion _item */
        assert(_item != ((struct AvahiServiceTypeBrowser *)NULL));
        _item->service_type_browsers_next = *_head;
        if(!(_item->service_type_browsers_next == ((struct AvahiServiceTypeBrowser *)NULL)))
          _item->service_type_browsers_next->service_type_browsers_prev = _item;

        _item->service_type_browsers_prev = (struct AvahiServiceTypeBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      if(!(*domain == 0))
      {
        b->domain=avahi_strdup(domain);
        if(!(b->domain == ((char *)NULL)))
          goto __CPROVER_DUMP_L6;

        avahi_client_set_errno(client, -24);
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "ServiceTypeBrowserNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args_3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &domain, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args_3 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr_5 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
              tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_5)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args_6 == 0u)
                tmp_if_expr_8 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
                tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr_8)
                avahi_client_set_errno(client, -22);

              else
              {
                b->path=avahi_strdup(path);
                if(b->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return b;
                }
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_9;
  return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(b == ((struct AvahiServiceTypeBrowser *)NULL)))
    avahi_service_type_browser_free(b);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiServiceTypeBrowser *)(void *)0;
}

// avahi_set_allocator
// file malloc.c line 196
void avahi_set_allocator(const struct AvahiAllocator *a)
{
  allocator = a;
}

// avahi_simple_poll_dispatch
// file simple-watch.c line 547
signed int avahi_simple_poll_dispatch(struct AvahiSimplePoll_0 *s)
{
  struct AvahiTimeout_1 *next_timeout;
  struct AvahiWatch_1 *w;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  /* assertion s->state == STATE_RAN */
  assert((signed int)s->state == STATE_RAN);
  s->state = (enum anonymous_31)STATE_DISPATCHING;
  next_timeout=find_next_timeout(s);
  if(!(next_timeout == ((struct AvahiTimeout_1 *)NULL)))
  {
    if(next_timeout->expiry.tv_sec == 0l)
    {
      if(next_timeout->expiry.tv_usec == 0l)
      {
        timeout_callback_link1(next_timeout);
        goto finish;
      }

    }

    signed long int return_value_avahi_age_1;
    return_value_avahi_age_1=avahi_age(&next_timeout->expiry);
    if(return_value_avahi_age_1 >= 0l)
    {
      timeout_callback_link1(next_timeout);
      goto finish;
    }

  }

  w = s->watches;
  for( ; !(w == ((struct AvahiWatch_1 *)NULL)); w = w->watches_next)
    if(w->dead == 0)
    {
      /* assertion w->idx >= 0 */
      assert(w->idx >= 0);
      /* assertion w->idx < s->n_pollfds */
      assert(w->idx < s->n_pollfds);
      if(!((signed int)(s->pollfds + (signed long int)w->idx)->revents == 0))
      {
        w->callback(w, w->pollfd.fd, (enum anonymous)(s->pollfds + (signed long int)w->idx)->revents, w->userdata);
        break;
      }

    }


finish:
  ;
  s->state = (enum anonymous_31)STATE_DISPATCHED;
  return 0;
}

// avahi_simple_poll_free
// file simple-watch.c line 367
void avahi_simple_poll_free(struct AvahiSimplePoll_0 *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  cleanup_timeouts(s, 1);
  cleanup_watches(s, 1);
  /* assertion s->n_watches == 0 */
  assert(s->n_watches == 0);
  avahi_free((void *)s->pollfds);
  if(s->wakeup_pipe[0l] >= 0)
    close(s->wakeup_pipe[(signed long int)0]);

  if(s->wakeup_pipe[1l] >= 0)
    close(s->wakeup_pipe[(signed long int)1]);

  avahi_free((void *)s);
}

// avahi_simple_poll_get
// file simple-watch.c line 620
const struct AvahiPoll_1 * avahi_simple_poll_get(struct AvahiSimplePoll_0 *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  return &s->api;
}

// avahi_simple_poll_iterate
// file simple-watch.c line 596
signed int avahi_simple_poll_iterate(struct AvahiSimplePoll_0 *s, signed int timeout)
{
  signed int r;
  r=avahi_simple_poll_prepare(s, timeout);
  if(!(r == 0))
    return r;

  else
  {
    r=avahi_simple_poll_run(s);
    if(!(r == 0))
      return r;

    else
    {
      r=avahi_simple_poll_dispatch(s);
      if(!(r == 0))
        return r;

      else
        return 0;
    }
  }
}

// avahi_simple_poll_loop
// file simple-watch.c line 640
signed int avahi_simple_poll_loop(struct AvahiSimplePoll_0 *s)
{
  signed int r;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  do
  {
    r=avahi_simple_poll_iterate(s, -1);
    if(!(r == 0))
    {
      if(r >= 0)
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        return_value___errno_location_1=__errno_location();
        tmp_if_expr_2 = *return_value___errno_location_1 != 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        return r;

    }

  }
  while((_Bool)1);
}

// avahi_simple_poll_new
// file simple-watch.c line 318
struct AvahiSimplePoll_0 * avahi_simple_poll_new(void)
{
  struct AvahiSimplePoll_0 *s;
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link2_link1((unsigned int)1, sizeof(struct AvahiSimplePoll_0) /*160ul*/ );
  s = (struct AvahiSimplePoll_0 *)return_value_avahi_new_internal_1;
  if(s == ((struct AvahiSimplePoll_0 *)NULL))
    return (struct AvahiSimplePoll_0 *)(void *)0;

  else
  {
    signed int return_value_pipe_2;
    return_value_pipe_2=pipe(s->wakeup_pipe);
    if(!(return_value_pipe_2 >= 0))
    {
      avahi_free((void *)s);
      return (struct AvahiSimplePoll_0 *)(void *)0;
    }

    else
    {
      set_nonblock(s->wakeup_pipe[(signed long int)0]);
      set_nonblock(s->wakeup_pipe[(signed long int)1]);
      s->api.userdata = (void *)s;
      s->api.watch_new = watch_new;
      s->api.watch_free = watch_free;
      s->api.watch_update = watch_update;
      s->api.watch_get_events = watch_get_events;
      s->api.timeout_new = timeout_new;
      s->api.timeout_free = timeout_free;
      s->api.timeout_update = timeout_update;
      s->pollfds = (struct pollfd *)(void *)0;
      s->n_pollfds = 0;
      s->max_pollfds = s->n_pollfds;
      s->rebuild_pollfds = 1;
      s->quit = 0;
      s->n_watches = 0;
      s->events_valid = 0;
      s->watch_req_cleanup = 0;
      s->timeout_req_cleanup = 0;
      s->prepared_timeout = 0;
      s->state = (enum anonymous_31)STATE_INIT;
      s->wakeup_issued = 0;
      avahi_simple_poll_set_func(s, (signed int (*)(struct pollfd *, unsigned int, signed int, void *))(void *)0, (void *)0);
      do
        s->watches = (struct AvahiWatch_1 *)(void *)0;
      while((_Bool)0);
      do
        s->timeouts = (struct AvahiTimeout_1 *)(void *)0;
      while((_Bool)0);
      return s;
    }
  }
}

// avahi_simple_poll_prepare
// file simple-watch.c line 450
signed int avahi_simple_poll_prepare(struct AvahiSimplePoll_0 *s, signed int timeout)
{
  struct AvahiTimeout_1 *next_timeout;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  _Bool tmp_if_expr_1;
  if((signed int)s->state == STATE_INIT)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)s->state == STATE_DISPATCHED ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)s->state == STATE_FAILURE ? (_Bool)1 : (_Bool)0;
  /* assertion s->state == STATE_INIT || s->state == STATE_DISPATCHED || s->state == STATE_FAILURE */
  assert(tmp_if_expr_2);
  s->state = (enum anonymous_31)STATE_PREPARING;
  clear_wakeup(s);
  if(!(s->watch_req_cleanup == 0))
    cleanup_watches(s, 0);

  if(!(s->timeout_req_cleanup == 0))
    cleanup_timeouts(s, 0);

  signed int return_value_rebuild_3;
  if(!(s->quit == 0))
  {
    s->state = (enum anonymous_31)STATE_QUIT;
    return 1;
  }

  else
    if(!(s->rebuild_pollfds == 0))
    {
      return_value_rebuild_3=rebuild(s);
      if(return_value_rebuild_3 >= 0)
        goto __CPROVER_DUMP_L8;

      s->state = (enum anonymous_31)STATE_FAILURE;
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      next_timeout=find_next_timeout(s);
      if(!(next_timeout == ((struct AvahiTimeout_1 *)NULL)))
      {
        struct timeval now;
        signed int t;
        signed long int usec;
        if(next_timeout->expiry.tv_sec == 0l)
        {
          if(!(next_timeout->expiry.tv_usec == 0l))
            goto __CPROVER_DUMP_L9;

          timeout = 0;
        }

        else
        {

        __CPROVER_DUMP_L9:
          ;
          gettimeofday(&now, (struct timezone *)(void *)0);
          usec=avahi_timeval_diff(&next_timeout->expiry, &now);
          if(!(usec >= 1l))
            timeout = 0;

          else
          {
            t = (signed int)(usec / (signed long int)1000) + 1;
            if(!(t >= timeout) || !(timeout >= 0))
              timeout = t;

          }
        }
      }


    finish:
      ;
      s->prepared_timeout = timeout;
      s->state = (enum anonymous_31)STATE_PREPARED;
      return 0;
    }
}

// avahi_simple_poll_quit
// file simple-watch.c line 611
void avahi_simple_poll_quit(struct AvahiSimplePoll_0 *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  s->quit = 1;
  avahi_simple_poll_wakeup(s);
}

// avahi_simple_poll_run
// file simple-watch.c line 518
signed int avahi_simple_poll_run(struct AvahiSimplePoll_0 *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  _Bool tmp_if_expr_1;
  if((signed int)s->state == STATE_PREPARED)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)s->state == STATE_FAILURE ? (_Bool)1 : (_Bool)0;
  /* assertion s->state == STATE_PREPARED || s->state == STATE_FAILURE */
  assert(tmp_if_expr_1);
  s->state = (enum anonymous_31)STATE_RUNNING;
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  *return_value___errno_location_2 = 0;
  signed int return_value;
  return_value=s->poll_func(s->pollfds, (unsigned int)s->n_pollfds, s->prepared_timeout, s->poll_func_userdata);
  if(!(return_value >= 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    s->state = (enum anonymous_31)STATE_FAILURE;
    return -1;
  }

  s->events_valid = 1;
  s->state = (enum anonymous_31)STATE_RAN;
  return 0;
}

// avahi_simple_poll_set_func
// file simple-watch.c line 630
void avahi_simple_poll_set_func(struct AvahiSimplePoll_0 *s, signed int (*func)(struct pollfd *, unsigned int, signed int, void *), void *userdata)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  s->poll_func = func != ((signed int (*)(struct pollfd *, unsigned int, signed int, void *))NULL) ? func : system_poll;
  s->poll_func_userdata = func != ((signed int (*)(struct pollfd *, unsigned int, signed int, void *))NULL) ? userdata : (void *)0;
  avahi_simple_poll_wakeup(s);
}

// avahi_simple_poll_wakeup
// file simple-watch.c line 97
void avahi_simple_poll_wakeup(struct AvahiSimplePoll_0 *s)
{
  char c = (char)87;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  write(s->wakeup_pipe[(signed long int)1], (const void *)&c, sizeof(char) /*1ul*/ );
  s->wakeup_issued = 1;
}

// avahi_strdup
// file ../avahi-common/malloc.h line 66
char * avahi_strdup(const char *s)
{
  char *r;
  unsigned long int size;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    size=strlen(s);
    void *return_value_avahi_malloc_1;
    return_value_avahi_malloc_1=avahi_malloc(size + (unsigned long int)1);
    r = (char *)return_value_avahi_malloc_1;
    if(r == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      memcpy((void *)r, (const void *)s, size + (unsigned long int)1);
      return r;
    }
  }
}

// avahi_strdup_printf
// file malloc.c line 235
char * avahi_strdup_printf(const char *fmt, ...)
{
  char *s;
  void **ap;
  /* assertion fmt */
  assert(fmt != ((const char *)NULL));
  ap = (void **)&fmt;
  s=avahi_strdup_vprintf(fmt, ap);
  ap = ((void **)NULL);
  return s;
}

// avahi_strdup_vprintf
// file malloc.c line 200
char * avahi_strdup_vprintf(const char *fmt, void **ap)
{
  unsigned long int len = (unsigned long int)80;
  char *buf;
  /* assertion fmt */
  assert(fmt != ((const char *)NULL));
  void *return_value_avahi_malloc_1;
  return_value_avahi_malloc_1=avahi_malloc(len);
  buf = (char *)return_value_avahi_malloc_1;
  if(buf == ((char *)NULL))
    return (char *)(void *)0;

  else
    do
    {
      signed int n;
      char *nbuf;
      void **ap2 = (void **)ap;
      n=vsnprintf(buf, len, fmt, ap2);
      ap2 = ((void **)NULL);
      if(n >= 0 && !(n >= (signed int)len))
        return buf;

      if(n >= 0)
        len = (unsigned long int)(n + 1);

      else
        len = len * (unsigned long int)2;
      void *return_value_avahi_realloc_2;
      return_value_avahi_realloc_2=avahi_realloc((void *)buf, len);
      nbuf = (char *)return_value_avahi_realloc_2;
      if(nbuf == ((char *)NULL))
      {
        avahi_free((void *)buf);
        return (char *)(void *)0;
      }

      buf = nbuf;
    }
    while((_Bool)1);
}

// avahi_strerror
// file error.c line 27
const char * avahi_strerror(signed int error)
{
  const char * const msg[54l] = { "OK", "Operation failed", "Bad state", "Invalid host name", "Invalid domain name", "No suitable network protocol available",
    "Invalid DNS TTL", "Resource record key is pattern", "Local name collision", "Invalid record", "Invalid service name", "Invalid service type", "Invalid port number", "Invalid record key", "Invalid address", "Timeout reached", "Too many clients", "Too many objects", "Too many entries", "OS Error", "Access denied", "Invalid operation", "An unexpected D-Bus error occurred", "Daemon connection failed", "Memory exhausted", "The object passed in was not valid", "Daemon not running", "Invalid interface index", "Invalid protocol specification", "Invalid flags", "Not found", "Invalid configuration", "Version mismatch", "Invalid service subtype", "Invalid packet", "Invalid DNS return code", "DNS failure: FORMERR", "DNS failure: SERVFAIL", "DNS failure: NXDOMAIN", "DNS failure: NOTIMP", "DNS failure: REFUSED", "DNS failure: YXDOMAIN", "DNS failure: YXRRSET", "DNS failure: NXRRSET", "DNS failure: NOTAUTH", "DNS failure: NOTZONE", "Invalid RDATA", "Invalid DNS type", "Invalid DNS class", "Not supported", "Not permitted", "Invalid argument", "Is empty", "The requested operation is invalid because redundant" };
  avahi_init_i18n();
  char *return_value_dgettext_1;
  if(-error >= 54 || !(-error >= 0))
  {
    return_value_dgettext_1=dgettext("avahi", "Invalid Error Code");
    return return_value_dgettext_1;
  }

  else
  {
    char *return_value_dgettext_2;
    return_value_dgettext_2=dgettext("avahi", msg[(signed long int)-error]);
    return return_value_dgettext_2;
  }
}

// avahi_string_list_add
// file ../avahi-common/strlst.h line 73
struct AvahiStringList * avahi_string_list_add(struct AvahiStringList *l, const char *text)
{
  /* assertion text */
  assert(text != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(text);
  struct AvahiStringList *return_value_avahi_string_list_add_arbitrary_2;
  return_value_avahi_string_list_add_arbitrary_2=avahi_string_list_add_arbitrary(l, (const unsigned char *)text, return_value_strlen_1);
  return return_value_avahi_string_list_add_arbitrary_2;
}

// avahi_string_list_add_anonymous
// file strlst.c line 34
struct AvahiStringList * avahi_string_list_add_anonymous(struct AvahiStringList *l, unsigned long int size)
{
  struct AvahiStringList *n;
  void *return_value_avahi_malloc_1;
  return_value_avahi_malloc_1=avahi_malloc(sizeof(struct AvahiStringList) /*24ul*/  + size);
  n = (struct AvahiStringList *)return_value_avahi_malloc_1;
  if(n == ((struct AvahiStringList *)NULL))
    return (struct AvahiStringList *)(void *)0;

  else
  {
    n->next = l;
    n->size = size;
    n->text[(signed long int)size] = (unsigned char)0;
    return n;
  }
}

// avahi_string_list_add_arbitrary
// file ../avahi-common/strlst.h line 85
struct AvahiStringList * avahi_string_list_add_arbitrary(struct AvahiStringList *l, const unsigned char *text, unsigned long int size)
{
  struct AvahiStringList *n;
  /* assertion size == 0 || text */
  assert(size == (unsigned long int)0 || text != ((const unsigned char *)NULL));
  n=avahi_string_list_add_anonymous(l, size);
  if(n == ((struct AvahiStringList *)NULL))
    return (struct AvahiStringList *)(void *)0;

  else
  {
    if(size >= 1ul)
      memcpy((void *)n->text, (const void *)text, size);

    return n;
  }
}

// avahi_string_list_add_many
// file strlst.c line 255
struct AvahiStringList * avahi_string_list_add_many(struct AvahiStringList *r, ...)
{
  void **va = (void **)&r;
  r=avahi_string_list_add_many_va(r, va);
  va = ((void **)NULL);
  return r;
}

// avahi_string_list_add_many_va
// file strlst.c line 265
struct AvahiStringList * avahi_string_list_add_many_va(struct AvahiStringList *r, __builtin_va_list va)
{
  const char *txt;
  do
  {
    txt=va_arg(va, __typeof__(txt));
    if(txt == ((const char *)NULL))
      break;

    r=avahi_string_list_add(r, txt);
  }
  while((_Bool)1);
  return r;
}

// avahi_string_list_add_pair
// file strlst.c line 395
struct AvahiStringList * avahi_string_list_add_pair(struct AvahiStringList *l, const char *key, const char *value)
{
  /* assertion key */
  assert(key != ((const char *)NULL));
  struct AvahiStringList *return_value_avahi_string_list_add_printf_1;
  struct AvahiStringList *return_value_avahi_string_list_add_2;
  if(!(value == ((const char *)NULL)))
  {
    return_value_avahi_string_list_add_printf_1=avahi_string_list_add_printf(l, "%s=%s", key, value);
    return return_value_avahi_string_list_add_printf_1;
  }

  else
  {
    return_value_avahi_string_list_add_2=avahi_string_list_add(l, key);
    return return_value_avahi_string_list_add_2;
  }
}

// avahi_string_list_add_pair_arbitrary
// file strlst.c line 404
struct AvahiStringList * avahi_string_list_add_pair_arbitrary(struct AvahiStringList *l, const char *key, const unsigned char *value, unsigned long int size)
{
  unsigned long int n;
  /* assertion key */
  assert(key != ((const char *)NULL));
  struct AvahiStringList *return_value_avahi_string_list_add_1;
  if(value == ((const unsigned char *)NULL))
  {
    return_value_avahi_string_list_add_1=avahi_string_list_add(l, key);
    return return_value_avahi_string_list_add_1;
  }

  else
  {
    n=strlen(key);
    l=avahi_string_list_add_anonymous(l, n + (unsigned long int)1 + size);
    if(l == ((struct AvahiStringList *)NULL))
      return (struct AvahiStringList *)(void *)0;

    else
    {
      memcpy((void *)l->text, (const void *)key, n);
      l->text[(signed long int)n] = (unsigned char)61;
      memcpy((void *)(l->text + (signed long int)n + (signed long int)1), (const void *)value, size);
      return l;
    }
  }
}

// avahi_string_list_add_printf
// file strlst.c line 366
struct AvahiStringList * avahi_string_list_add_printf(struct AvahiStringList *l, const char *format, ...)
{
  void **va;
  /* assertion format */
  assert(format != ((const char *)NULL));
  va = (void **)&format;
  l=avahi_string_list_add_vprintf(l, format, va);
  va = ((void **)NULL);
  return l;
}

// avahi_string_list_add_vprintf
// file strlst.c line 326
struct AvahiStringList * avahi_string_list_add_vprintf(struct AvahiStringList *l, const char *format, void **va)
{
  unsigned long int len = (unsigned long int)80;
  struct AvahiStringList *r;
  /* assertion format */
  assert(format != ((const char *)NULL));
  void *return_value_avahi_malloc_1;
  return_value_avahi_malloc_1=avahi_malloc(sizeof(struct AvahiStringList) /*24ul*/  + len);
  r = (struct AvahiStringList *)return_value_avahi_malloc_1;
  if(r == ((struct AvahiStringList *)NULL))
    return (struct AvahiStringList *)(void *)0;

  else
  {
    do
    {
      signed int n;
      struct AvahiStringList *nr;
      void **va2 = (void **)va;
      n=vsnprintf((char *)r->text, len, format, va2);
      va2 = ((void **)NULL);
      if(n >= 0 && !(n >= (signed int)len))
        break;

      if(n >= 0)
        len = (unsigned long int)(n + 1);

      else
        len = len * (unsigned long int)2;
      void *return_value_avahi_realloc_2;
      return_value_avahi_realloc_2=avahi_realloc((void *)r, sizeof(struct AvahiStringList) /*24ul*/  + len);
      nr = (struct AvahiStringList *)return_value_avahi_realloc_2;
      if(nr == ((struct AvahiStringList *)NULL))
      {
        avahi_free((void *)r);
        return (struct AvahiStringList *)(void *)0;
      }

      r = nr;
    }
    while((_Bool)1);
    r->next = l;
    r->size=strlen((char *)r->text);
    return r;
  }
}

// avahi_string_list_copy
// file strlst.c line 293
struct AvahiStringList * avahi_string_list_copy(const struct AvahiStringList *l)
{
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  for( ; !(l == ((const struct AvahiStringList *)NULL)); l = l->next)
  {
    r=avahi_string_list_add_arbitrary(r, l->text, l->size);
    if(r == ((struct AvahiStringList *)NULL))
    {
      avahi_string_list_free(r);
      return (struct AvahiStringList *)(void *)0;
    }

  }
  struct AvahiStringList *return_value_avahi_string_list_reverse_1;
  return_value_avahi_string_list_reverse_1=avahi_string_list_reverse(r);
  return return_value_avahi_string_list_reverse_1;
}

// avahi_string_list_equal
// file strlst.c line 235
signed int avahi_string_list_equal(const struct AvahiStringList *a, const struct AvahiStringList *b)
{
  signed int return_value_memcmp_1;
  while((_Bool)1)
  {
    if(a == ((const struct AvahiStringList *)NULL) && b == ((const struct AvahiStringList *)NULL))
      return 1;

    if(a == ((const struct AvahiStringList *)NULL) || b == ((const struct AvahiStringList *)NULL))
      return 0;

    if(!(a->size == b->size))
      return 0;

    if(!(a->size == 0ul))
    {
      return_value_memcmp_1=memcmp((const void *)a->text, (const void *)b->text, a->size);
      if(!(return_value_memcmp_1 == 0))
        return 0;

    }

    a = a->next;
    b = b->next;
  }
}

// avahi_string_list_find
// file strlst.c line 378
struct AvahiStringList * avahi_string_list_find(struct AvahiStringList *l, const char *key)
{
  unsigned long int n;
  /* assertion key */
  assert(key != ((const char *)NULL));
  n=strlen(key);
  for( ; !(l == ((struct AvahiStringList *)NULL)); l = l->next)
  {
    signed int return_value_strcasecmp_1;
    return_value_strcasecmp_1=strcasecmp((char *)l->text, key);
    if(return_value_strcasecmp_1 == 0)
      return l;

    signed int return_value_strncasecmp_2;
    return_value_strncasecmp_2=strncasecmp((char *)l->text, key, n);
    if(return_value_strncasecmp_2 == 0)
    {
      if((signed int)l->text[(signed long int)n] == 61)
        return l;

    }

  }
  return (struct AvahiStringList *)(void *)0;
}

// avahi_string_list_free
// file ../avahi-common/strlst.h line 64
void avahi_string_list_free(struct AvahiStringList *l)
{
  struct AvahiStringList *n;
  for( ; !(l == ((struct AvahiStringList *)NULL)); l = n)
  {
    n = l->next;
    avahi_free((void *)l);
  }
}

// avahi_string_list_get_next
// file strlst.c line 469
struct AvahiStringList * avahi_string_list_get_next(struct AvahiStringList *l)
{
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  return l->next;
}

// avahi_string_list_get_pair
// file ../avahi-common/strlst.h line 160
signed int avahi_string_list_get_pair(struct AvahiStringList *l, char **key, char **value, unsigned long int *size)
{
  char *e;
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  void *return_value_memchr_2;
  return_value_memchr_2=memchr((const void *)l->text, 61, l->size);
  e = (char *)return_value_memchr_2;
  if(e == ((char *)NULL))
  {
    if(!(key == ((char **)NULL)))
    {
      *key=avahi_strdup((char *)l->text);
      if(*key == ((char *)NULL))
        return -1;

    }

    if(!(value == ((char **)NULL)))
      *value = (char *)(void *)0;

    if(!(size == ((unsigned long int *)NULL)))
      *size = (unsigned long int)0;

  }

  else
  {
    unsigned long int n;
    if(!(key == ((char **)NULL)))
    {
      *key=avahi_strndup((char *)l->text, (unsigned long int)(e - (char *)l->text));
      if(*key == ((char *)NULL))
        return -1;

    }

    e = e + 1l;
    n = l->size - (unsigned long int)(e - (char *)l->text);
    if(!(value == ((char **)NULL)))
    {
      void *return_value_avahi_memdup_1;
      return_value_avahi_memdup_1=avahi_memdup((const void *)e, n + (unsigned long int)1);
      *value = (char *)return_value_avahi_memdup_1;
      if(*value == ((char *)NULL))
      {
        if(!(key == ((char **)NULL)))
          avahi_free((void *)*key);

        return -1;
      }

      (*value)[(signed long int)n] = (char)0;
    }

    if(!(size == ((unsigned long int *)NULL)))
      *size = n;

  }
  return 0;
}

// avahi_string_list_get_service_cookie
// file strlst.c line 484
unsigned int avahi_string_list_get_service_cookie(struct AvahiStringList *l)
{
  struct AvahiStringList *f;
  char *value = (char *)(void *)0;
  char *end = (char *)(void *)0;
  unsigned int ret;
  f=avahi_string_list_find(l, "org.freedesktop.Avahi.cookie");
  if(f == ((struct AvahiStringList *)NULL))
    return (unsigned int)0;

  else
  {
    signed int return_value_avahi_string_list_get_pair_1;
    return_value_avahi_string_list_get_pair_1=avahi_string_list_get_pair(f, (char **)(void *)0, &value, (unsigned long int *)(void *)0);
    if(value == ((char *)NULL) || !(return_value_avahi_string_list_get_pair_1 >= 0))
      return (unsigned int)0;

    else
    {
      signed long long int return_value_strtoll_2;
      return_value_strtoll_2=strtoll(value, &end, 0);
      ret = (unsigned int)return_value_strtoll_2;
      if(!(*value == 0))
      {
        if(end == ((char *)NULL))
          goto __CPROVER_DUMP_L3;

        if((signed int)*end == 0)
          goto __CPROVER_DUMP_L3;

        avahi_free((void *)value);
        return (unsigned int)0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        avahi_free((void *)value);
        return ret;
      }
    }
  }
}

// avahi_string_list_get_size
// file strlst.c line 479
unsigned long int avahi_string_list_get_size(struct AvahiStringList *l)
{
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  return l->size;
}

// avahi_string_list_get_text
// file strlst.c line 474
unsigned char * avahi_string_list_get_text(struct AvahiStringList *l)
{
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  return l->text;
}

// avahi_string_list_length
// file strlst.c line 317
unsigned int avahi_string_list_length(const struct AvahiStringList *l)
{
  unsigned int n = (unsigned int)0;
  for( ; !(l == ((const struct AvahiStringList *)NULL)); l = l->next)
    n = n + 1u;
  return n;
}

// avahi_string_list_new
// file strlst.c line 274
struct AvahiStringList * avahi_string_list_new(const char *txt, ...)
{
  void **va;
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  if(!(txt == ((const char *)NULL)))
  {
    r=avahi_string_list_add(r, txt);
    va = (void **)&txt;
    r=avahi_string_list_add_many_va(r, va);
    va = ((void **)NULL);
  }

  return r;
}

// avahi_string_list_new_from_array
// file strlst.c line 305
struct AvahiStringList * avahi_string_list_new_from_array(const char **array, signed int length)
{
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  signed int i;
  /* assertion array */
  assert(array != ((const char **)NULL));
  i = 0;
  signed int tmp_if_expr_1;
  do
  {
    if(length >= 0)
      tmp_if_expr_1 = (signed int)(i < length);

    else
      tmp_if_expr_1 = (signed int)!(!(array[(signed long int)i] != ((const char *)NULL)));
    if(tmp_if_expr_1 == 0)
      break;

    r=avahi_string_list_add(r, array[(signed long int)i]);
    i = i + 1;
  }
  while((_Bool)1);
  return r;
}

// avahi_string_list_new_va
// file ../avahi-common/strlst.h line 55
struct AvahiStringList * avahi_string_list_new_va(void **va)
{
  struct AvahiStringList *return_value_avahi_string_list_add_many_va_1;
  return_value_avahi_string_list_add_many_va_1=avahi_string_list_add_many_va((struct AvahiStringList *)(void *)0, va);
  return return_value_avahi_string_list_add_many_va_1;
}

// avahi_string_list_parse
// file strlst.c line 69
signed int avahi_string_list_parse(const void *data, unsigned long int size, struct AvahiStringList **ret)
{
  const unsigned char *c;
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  /* assertion data */
  assert(data != NULL);
  /* assertion ret */
  assert(ret != ((struct AvahiStringList **)NULL));
  c = (const unsigned char *)data;
  const unsigned char *tmp_post_1;
  while(size >= 1ul)
  {
    unsigned long int k;
    tmp_post_1 = c;
    c = c + 1l;
    k = (unsigned long int)*tmp_post_1;
    size = size - 1ul;
    if(!(size >= k))
      goto fail;

    if(k >= 1ul)
    {
      struct AvahiStringList *n;
      n=avahi_string_list_add_arbitrary(r, c, k);
      if(n == ((struct AvahiStringList *)NULL))
        goto fail;

      r = n;
    }

    c = c + (signed long int)k;
    size = size - k;
  }
  *ret = r;
  return 0;

fail:
  ;
  avahi_string_list_free(r);
  return -1;
}

// avahi_string_list_reverse
// file ../avahi-common/strlst.h line 130
struct AvahiStringList * avahi_string_list_reverse(struct AvahiStringList *l)
{
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  struct AvahiStringList *n;
  for( ; !(l == ((struct AvahiStringList *)NULL)); l = n)
  {
    n = l->next;
    l->next = r;
    r = l;
  }
  return r;
}

// avahi_string_list_serialize
// file strlst.c line 168
unsigned long int avahi_string_list_serialize(struct AvahiStringList *l, void *data, unsigned long int size)
{
  unsigned long int used = (unsigned long int)0;
  unsigned char *tmp_post_1;
  if(!(data == NULL))
  {
    struct AvahiStringList *n;
    unsigned char *c;
    l=avahi_string_list_reverse(l);
    c = (unsigned char *)data;
    n = l;
    for( ; size >= 2ul && !(n == ((struct AvahiStringList *)NULL)); n = n->next)
    {
      unsigned long int k = n->size;
      if(!(k == 0ul))
      {
        if(k >= 256ul)
          k = (unsigned long int)255;

        if(!(size + 18446744073709551615ul >= k))
          k = size - (unsigned long int)1;

        tmp_post_1 = c;
        c = c + 1l;
        *tmp_post_1 = (unsigned char)k;
        memcpy((void *)c, (const void *)n->text, k);
        c = c + (signed long int)k;
        used = used + (unsigned long int)1 + k;
        size = size - ((unsigned long int)1 + k);
      }

    }
    l=avahi_string_list_reverse(l);
    if(used == 0ul && size >= 1ul)
    {
      *((unsigned char *)data) = (unsigned char)0;
      used = (unsigned long int)1;
    }

  }

  else
  {
    struct AvahiStringList *avahi_string_list_serialize__1__2__n = l;
    for( ; !(avahi_string_list_serialize__1__2__n == ((struct AvahiStringList *)NULL)); avahi_string_list_serialize__1__2__n = avahi_string_list_serialize__1__2__n->next)
    {
      unsigned long int avahi_string_list_serialize__1__2__1__1__k = avahi_string_list_serialize__1__2__n->size;
      if(!(avahi_string_list_serialize__1__2__1__1__k == 0ul))
      {
        if(avahi_string_list_serialize__1__2__1__1__k >= 256ul)
          avahi_string_list_serialize__1__2__1__1__k = (unsigned long int)255;

        used = used + (unsigned long int)1 + avahi_string_list_serialize__1__2__1__1__k;
      }

    }
    if(used == 0ul)
      used = (unsigned long int)1;

  }
  return used;
}

// avahi_string_list_to_string
// file strlst.c line 131
char * avahi_string_list_to_string(struct AvahiStringList *l)
{
  struct AvahiStringList *n;
  unsigned long int s = (unsigned long int)0;
  char *t;
  char *e;
  n = l;
  for( ; !(n == ((struct AvahiStringList *)NULL)); n = n->next)
  {
    if(!(n == l))
      s = s + 1ul;

    s = s + n->size + (unsigned long int)2;
  }
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link1_link1((unsigned int)(s + (unsigned long int)1), sizeof(char) /*1ul*/ );
  e = (char *)return_value_avahi_new_internal_1;
  t = e;
  char *tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  if(t == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    l=avahi_string_list_reverse(l);
    n = l;
    for( ; !(n == ((struct AvahiStringList *)NULL)); n = n->next)
    {
      if(!(n == l))
      {
        tmp_post_2 = e;
        e = e + 1l;
        *tmp_post_2 = (char)32;
      }

      tmp_post_3 = e;
      e = e + 1l;
      *tmp_post_3 = (char)34;
      strncpy(e, (char *)n->text, n->size);
      e[(signed long int)n->size] = (char)0;
      e=strchr(e, 0);
      tmp_post_4 = e;
      e = e + 1l;
      *tmp_post_4 = (char)34;
      /* assertion e */
      assert(e != ((char *)NULL));
    }
    l=avahi_string_list_reverse(l);
    *e = (char)0;
    return t;
  }
}

// avahi_strndup
// file malloc.c line 175
char * avahi_strndup(const char *s, unsigned long int max)
{
  char *r;
  unsigned long int size;
  const char *p;
  _Bool tmp_if_expr_1;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    p = s;
    size = (unsigned long int)0;
    do
    {
      if(!(size >= max))
        tmp_if_expr_1 = *p != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      p = p + 1l;
      size = size + 1ul;
    }
    while((_Bool)1);
    void *return_value_avahi_new_internal_2;
    return_value_avahi_new_internal_2=avahi_new_internal_link5((unsigned int)(size + (unsigned long int)1), sizeof(char) /*1ul*/ );
    r = (char *)return_value_avahi_new_internal_2;
    if(r == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      memcpy((void *)r, (const void *)s, size);
      r[(signed long int)size] = (char)0;
      return r;
    }
  }
}

// avahi_threaded_poll_free
// file thread-watch.c line 107
void avahi_threaded_poll_free(struct AvahiThreadedPoll_0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll_0 *)NULL));
  _Bool tmp_if_expr_3;
  unsigned long int return_value_pthread_self_1;
  signed int return_value_pthread_equal_2;
  if(p->thread_running == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_pthread_self_1=pthread_self();
    return_value_pthread_equal_2=pthread_equal(return_value_pthread_self_1, p->thread_id);
    tmp_if_expr_3 = !(return_value_pthread_equal_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  /* assertion !p->thread_running || !pthread_equal(pthread_self(), p->thread_id) */
  assert(tmp_if_expr_3);
  if(!(p->thread_running == 0))
    avahi_threaded_poll_stop(p);

  if(!(p->simple_poll == ((struct AvahiSimplePoll_0 *)NULL)))
    avahi_simple_poll_free(p->simple_poll);

  pthread_mutex_destroy(&p->mutex);
  avahi_free((void *)p);
}

// avahi_threaded_poll_get
// file thread-watch.c line 123
const struct AvahiPoll_1 * avahi_threaded_poll_get(struct AvahiThreadedPoll_0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll_0 *)NULL));
  const struct AvahiPoll_1 *return_value_avahi_simple_poll_get_1;
  return_value_avahi_simple_poll_get_1=avahi_simple_poll_get(p->simple_poll);
  return return_value_avahi_simple_poll_get_1;
}

// avahi_threaded_poll_lock
// file thread-watch.c line 170
void avahi_threaded_poll_lock(struct AvahiThreadedPoll_0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll_0 *)NULL));
  _Bool tmp_if_expr_3;
  unsigned long int return_value_pthread_self_1;
  signed int return_value_pthread_equal_2;
  if(p->thread_running == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_pthread_self_1=pthread_self();
    return_value_pthread_equal_2=pthread_equal(return_value_pthread_self_1, p->thread_id);
    tmp_if_expr_3 = !(return_value_pthread_equal_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  /* assertion !p->thread_running || !pthread_equal(pthread_self(), p->thread_id) */
  assert(tmp_if_expr_3);
  pthread_mutex_lock(&p->mutex);
}

// avahi_threaded_poll_new
// file thread-watch.c line 77
struct AvahiThreadedPoll_0 * avahi_threaded_poll_new(void)
{
  struct AvahiThreadedPoll_0 *p;
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link3_link1((unsigned int)1, sizeof(struct AvahiThreadedPoll_0) /*64ul*/ );
  p = (struct AvahiThreadedPoll_0 *)return_value_avahi_new_internal_1;
  if(!(p == ((struct AvahiThreadedPoll_0 *)NULL)))
  {
    p->simple_poll=avahi_simple_poll_new();
    if(p->simple_poll == ((struct AvahiSimplePoll_0 *)NULL))
      goto fail;

    pthread_mutex_init(&p->mutex, (const union anonymous_38 *)(void *)0);
    avahi_simple_poll_set_func(p->simple_poll, poll_func, (void *)&p->mutex);
    p->thread_running = 0;
    return p;
  }

  else
  {

  fail:
    ;
    if(!(p == ((struct AvahiThreadedPoll_0 *)NULL)))
    {
      if(!(p->simple_poll == ((struct AvahiSimplePoll_0 *)NULL)))
      {
        avahi_simple_poll_free(p->simple_poll);
        pthread_mutex_destroy(&p->mutex);
      }

      avahi_free((void *)p);
    }

    return (struct AvahiThreadedPoll_0 *)(void *)0;
  }
}

// avahi_threaded_poll_quit
// file thread-watch.c line 161
void avahi_threaded_poll_quit(struct AvahiThreadedPoll_0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll_0 *)NULL));
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  signed int return_value_pthread_equal_2;
  return_value_pthread_equal_2=pthread_equal(return_value_pthread_self_1, p->thread_id);
  /* assertion pthread_equal(pthread_self(), p->thread_id) */
  assert(return_value_pthread_equal_2 != 0);
  avahi_simple_poll_quit(p->simple_poll);
}

// avahi_threaded_poll_start
// file thread-watch.c line 129
signed int avahi_threaded_poll_start(struct AvahiThreadedPoll_0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll_0 *)NULL));
  /* assertion !p->thread_running */
  assert(!(p->thread_running != 0));
  signed int return_value_pthread_create_1;
  return_value_pthread_create_1=pthread_create(&p->thread_id, (const union pthread_attr_t *)(void *)0, thread, (void *)p);
  if(!(return_value_pthread_create_1 >= 0))
    return -1;

  else
  {
    p->thread_running = 1;
    return 0;
  }
}

// avahi_threaded_poll_stop
// file thread-watch.c line 142
signed int avahi_threaded_poll_stop(struct AvahiThreadedPoll_0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll_0 *)NULL));
  if(p->thread_running == 0)
    return -1;

  else
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    signed int return_value_pthread_equal_2;
    return_value_pthread_equal_2=pthread_equal(return_value_pthread_self_1, p->thread_id);
    /* assertion !pthread_equal(pthread_self(), p->thread_id) */
    assert(!(return_value_pthread_equal_2 != 0));
    pthread_mutex_lock(&p->mutex);
    avahi_simple_poll_quit(p->simple_poll);
    pthread_mutex_unlock(&p->mutex);
    pthread_join(p->thread_id, (void **)(void *)0);
    p->thread_running = 0;
    return p->retval;
  }
}

// avahi_threaded_poll_unlock
// file thread-watch.c line 179
void avahi_threaded_poll_unlock(struct AvahiThreadedPoll_0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll_0 *)NULL));
  _Bool tmp_if_expr_3;
  unsigned long int return_value_pthread_self_1;
  signed int return_value_pthread_equal_2;
  if(p->thread_running == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_pthread_self_1=pthread_self();
    return_value_pthread_equal_2=pthread_equal(return_value_pthread_self_1, p->thread_id);
    tmp_if_expr_3 = !(return_value_pthread_equal_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  /* assertion !p->thread_running || !pthread_equal(pthread_self(), p->thread_id) */
  assert(tmp_if_expr_3);
  pthread_mutex_unlock(&p->mutex);
}

// avahi_timeval_add
// file timeval.c line 59
struct timeval * avahi_timeval_add(struct timeval *a, signed long int usec)
{
  signed long int u;
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  u = usec + a->tv_usec;
  if(!(u >= 0l))
  {
    a->tv_usec = (signed long int)((signed long int)1000000 + u % (signed long int)1000000);
    a->tv_sec = a->tv_sec + (signed long int)((signed long int)-1 + u / (signed long int)1000000);
  }

  else
  {
    a->tv_usec = (signed long int)(u % (signed long int)1000000);
    a->tv_sec = a->tv_sec + (signed long int)(u / (signed long int)1000000);
  }
  return a;
}

// avahi_timeval_compare
// file timeval.c line 30
signed int avahi_timeval_compare(struct timeval *a, struct timeval *b)
{
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  /* assertion b */
  assert(b != ((struct timeval *)NULL));
  if(!(a->tv_sec >= b->tv_sec))
    return -1;

  else
    if(!(b->tv_sec >= a->tv_sec))
      return 1;

    else
      if(!(a->tv_usec >= b->tv_usec))
        return -1;

      else
        if(!(b->tv_usec >= a->tv_usec))
          return 1;

        else
          return 0;
}

// avahi_timeval_diff
// file timeval.c line 49
signed long int avahi_timeval_diff(struct timeval *a, struct timeval *b)
{
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  /* assertion b */
  assert(b != ((struct timeval *)NULL));
  signed int return_value_avahi_timeval_compare_2;
  return_value_avahi_timeval_compare_2=avahi_timeval_compare(a, b);
  signed long int return_value_avahi_timeval_diff_1;
  if(!(return_value_avahi_timeval_compare_2 >= 0))
  {
    return_value_avahi_timeval_diff_1=avahi_timeval_diff(b, a);
    return -return_value_avahi_timeval_diff_1;
  }

  else
    return (((signed long int)a->tv_sec - b->tv_sec) * (signed long int)1000000 + a->tv_usec) - b->tv_usec;
}

// avahi_unescape_label
// file domain.c line 41
char * avahi_unescape_label(const char **name, char *dest, unsigned long int size)
{
  unsigned int i = (unsigned int)0;
  char *d;
  /* assertion dest */
  assert(dest != ((char *)NULL));
  /* assertion size > 0 */
  assert(size > (unsigned long int)0);
  /* assertion name */
  assert(name != ((const char **)NULL));
  d = dest;
  _Bool tmp_if_expr_8;
  char *tmp_post_1;
  const char *tmp_post_2;
  const unsigned short int **return_value___ctype_b_loc_7;
  _Bool tmp_if_expr_5;
  const unsigned short int **return_value___ctype_b_loc_4;
  char *tmp_post_6;
  char *tmp_post_9;
  const char *tmp_post_10;
  while((_Bool)1)
  {
    if((unsigned long int)i >= size)
      return (char *)(void *)0;

    if((signed int)*(*name) == 46)
    {
      *name = *name + 1l;
      break;
    }

    if((signed int)*(*name) == 0)
      break;

    if((signed int)*(*name) == 92)
    {
      *name = *name + 1l;
      if((signed int)*(*name) == 0)
        return (char *)(void *)0;

      else
      {
        if((signed int)*(*name) == 92)
          tmp_if_expr_8 = (_Bool)1;

        else
          tmp_if_expr_8 = (signed int)*(*name) == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_8)
        {
          tmp_post_1 = d;
          d = d + 1l;
          tmp_post_2 = *name;
          *name = *name + 1l;
          *tmp_post_1 = *tmp_post_2;
          i = i + 1u;
        }

        else
        {
          return_value___ctype_b_loc_7=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)*(*name)]) == 0))
          {
            signed int n;
            const unsigned short int **return_value___ctype_b_loc_3;
            return_value___ctype_b_loc_3=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)(*name)[1l]]) == 0)
              tmp_if_expr_5 = (_Bool)1;

            else
            {
              return_value___ctype_b_loc_4=__ctype_b_loc();
              tmp_if_expr_5 = !(((signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(*name)[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_5)
              return (char *)(void *)0;

            n = (signed int)(unsigned char)((signed int)*(*name) - 48) * 100 + (signed int)(unsigned char)((signed int)(*name)[(signed long int)1] - 48) * 10 + (signed int)(unsigned char)((signed int)(*name)[(signed long int)2] - 48);
            if(n == 0 || n >= 256)
              return (char *)(void *)0;

            tmp_post_6 = d;
            d = d + 1l;
            *tmp_post_6 = (char)n;
            i = i + 1u;
            *name = *name + (signed long int)3;
          }

          else
            return (char *)(void *)0;
        }
      }
    }

    else
    {
      tmp_post_9 = d;
      d = d + 1l;
      tmp_post_10 = *name;
      *name = *name + 1l;
      *tmp_post_9 = *tmp_post_10;
      i = i + 1u;
    }
  }
  /* assertion i < size */
  assert((unsigned long int)i < size);
  *d = (char)0;
  const char *return_value_avahi_utf8_valid_11;
  return_value_avahi_utf8_valid_11=avahi_utf8_valid(dest);
  if(return_value_avahi_utf8_valid_11 == ((const char *)NULL))
    return (char *)(void *)0;

  else
    return dest;
}

// avahi_utf8_valid
// file utf8.h line 29
const char * avahi_utf8_valid(const char *str)
{
  unsigned int val = (unsigned int)0;
  unsigned int min = (unsigned int)0;
  const char *p = str;
  for( ; !(*p == 0); p = p + 1l)
  {
    if((signed int)*((const unsigned char *)p) >= 128)
    {
      if((0xe0 & (signed int)*((const unsigned char *)p)) == 0xc0)
      {
        if((0x1e & (signed int)*((const unsigned char *)p)) == 0)
          goto error;

        p = p + 1l;
        if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
          goto error;

      }

      else
      {
        if((0xf0 & (signed int)*((const unsigned char *)p)) == 0xe0)
        {
          min = (unsigned int)(1 << 11);
          val = (unsigned int)((signed int)*((const unsigned char *)p) & 0x0f);
          goto TWO_REMAINING;
        }

        else
          if((0xf8 & (signed int)*((const unsigned char *)p)) == 0xf0)
          {
            min = (unsigned int)(1 << 16);
            val = (unsigned int)((signed int)*((const unsigned char *)p) & 0x07);
          }

          else
            goto error;
        p = p + 1l;
        do
        {
          if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
            goto error;

          val = val << 6;
          val = val | (unsigned int)((signed int)*((const unsigned char *)p) & 0x3f);
        }
        while((_Bool)0);

      TWO_REMAINING:
        ;
        p = p + 1l;
        do
        {
          if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
            goto error;

          val = val << 6;
          val = val | (unsigned int)((signed int)*((const unsigned char *)p) & 0x3f);
        }
        while((_Bool)0);
        p = p + 1l;
        do
        {
          if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
            goto error;

          val = val << 6;
          val = val | (unsigned int)((signed int)*((const unsigned char *)p) & 0x3f);
        }
        while((_Bool)0);
        if(!(val >= min))
          goto error;

        if((65534u & val) == 65534u || (0xFFFFF800 & val) == 55296u || val >= 1114112u || !(val >= 65008u) && val >= 64976u)
          goto error;

      }
      goto __CPROVER_DUMP_L13;

    error:
      ;
      return (const char *)(void *)0;
    }


  __CPROVER_DUMP_L13:
    ;
  }
  return str;
}

// avahi_xdg_config_open
// file xdg-config.h line 25
struct _IO_FILE * avahi_xdg_config_open(const char *filename)
{
  struct _IO_FILE *f;
  const char *e;
  const char *d;
  char fn[4096l];
  char *p = (char *)(void *)0;
  char buf[2048l];
  char *s = (char *)(void *)0;
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  e=getenv("XDG_CONFIG_HOME");
  _Bool tmp_if_expr_1;
  if(!(e == ((const char *)NULL)))
    tmp_if_expr_1 = *e != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    p = fn;
    snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", e, filename);
  }

  else
  {
    e=getenv("HOME");
    if(!(e == ((const char *)NULL)))
    {
      if(!(*e == 0))
      {
        p = fn;
        snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s/.config/%s", e, filename);
      }

    }

  }
  signed int *return_value___errno_location_2;
  if(!(p == ((char *)NULL)))
  {
    f=fopen(p, "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
      return f;

    else
    {
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 2))
        return (struct _IO_FILE *)(void *)0;

    }
  }

  d=getenv("XDG_CONFIG_DIRS");
  _Bool tmp_if_expr_3;
  if(d == ((const char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = !(*d != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
    d = "/etc/xdg";

  snprintf(buf, sizeof(char [2048l]) /*2048ul*/ , "%s", d);
  e=strtok_r(buf, ":", &s);
  while(!(e == ((const char *)NULL)))
  {
    snprintf(fn, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", e, filename);
    f=fopen(fn, "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
      return f;

    e=strtok_r((char *)(void *)0, ":", &s);
  }
  return (struct _IO_FILE *)(void *)0;
}

// browse_callback
// file avahi-ui.c line 400
static void browse_callback(struct AvahiServiceBrowser *b, signed int interface, signed int protocol, enum anonymous_14 event, const char *name, const char *type, const char *domain, enum anonymous_13 flags, void *userdata)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)userdata, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  char *ifs;
  const char *pretty_type;
  char ifname[16l];
  struct _GtkTreeIter iter;
  struct _GtkTreeSelection *selection;
  char *return_value_if_indextoname_3;
  void *return_value_g_hash_table_lookup_4;
  _Bool tmp_if_expr_10;
  unsigned long int return_value_gtk_tree_view_get_type_11;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  signed int return_value_gtk_tree_selection_get_selected_22;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_21;
  signed int return_value_avahi_domain_equal_18;
  _Bool tmp_if_expr_20;
  signed int return_value_strcasecmp_19;
  struct _GtkTreeIter browse_callback__1__1__2__iter;
  signed int valid;
  unsigned long int return_value_gtk_tree_model_get_type_23;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
  _Bool tmp_if_expr_28;
  signed int return_value_strcasecmp_27;
  _Bool tmp_if_expr_30;
  signed int return_value_avahi_domain_equal_29;
  const char *tmp_if_expr_37;
  char *return_value_dgettext_36;
  switch((signed int)event)
  {
    case AVAHI_BROWSER_NEW:
    {
      pretty_type = (const char *)(void *)0;
      return_value_if_indextoname_3=if_indextoname((unsigned int)interface, ifname);
      if(return_value_if_indextoname_3 == ((char *)NULL))
        g_snprintf(ifname, sizeof(char [16l]) /*16ul*/ , "%i", interface);

      ifs=g_strdup_printf("%s %s", (const void *)ifname, protocol == 0 ? "IPv4" : "IPv6");
      if(!(d->priv->service_type_names == ((struct _GHashTable *)NULL)))
      {
        return_value_g_hash_table_lookup_4=g_hash_table_lookup(d->priv->service_type_names, (const void *)type);
        pretty_type = (const char *)return_value_g_hash_table_lookup_4;
      }

      if(pretty_type == ((const char *)NULL))
        pretty_type=stdb_lookup(type);

      gtk_list_store_append(d->priv->service_list_store, &iter);
      gtk_list_store_set(d->priv->service_list_store, &iter, 0, interface, 1, protocol, 3, name, 2, type, 4, ifs, 5, pretty_type, -1);
      g_free((void *)ifs);
      if(d->priv->common_protocol == -1)
        d->priv->common_protocol = protocol;

      if(d->priv->common_interface == -1)
        d->priv->common_interface = interface;

      if(!(d->priv->common_interface == interface))
        tmp_if_expr_10 = (_Bool)1;

      else
        tmp_if_expr_10 = d->priv->common_protocol != protocol ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_10)
      {
        unsigned long int return_value_gtk_tree_view_get_type_5;
        return_value_gtk_tree_view_get_type_5=gtk_tree_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
        return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type_5);
        struct _GtkTreeViewColumn *return_value_gtk_tree_view_get_column_7;
        return_value_gtk_tree_view_get_column_7=gtk_tree_view_get_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_6, 0);
        gtk_tree_view_column_set_visible(return_value_gtk_tree_view_get_column_7, (signed int)!(0 != 0));
        unsigned long int return_value_gtk_tree_view_get_type_8;
        return_value_gtk_tree_view_get_type_8=gtk_tree_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
        return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type_8);
        gtk_tree_view_set_headers_visible((struct _GtkTreeView *)return_value_g_type_check_instance_cast_9, (signed int)!(0 != 0));
      }

      return_value_gtk_tree_view_get_type_11=gtk_tree_view_get_type();
      return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type_11);
      selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast_12);
      return_value_gtk_tree_selection_get_selected_22=gtk_tree_selection_get_selected(selection, (struct _GtkTreeModel **)(void *)0, (struct _GtkTreeIter *)(void *)0);
      if(return_value_gtk_tree_selection_get_selected_22 == 0)
      {
        if(d->priv->service_type == ((char *)NULL))
          tmp_if_expr_17 = (_Bool)1;

        else
          tmp_if_expr_17 = !(d->priv->service_name != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_17)
          tmp_if_expr_21 = (_Bool)1;

        else
        {
          return_value_avahi_domain_equal_18=avahi_domain_equal(d->priv->service_type, type);
          if(!(return_value_avahi_domain_equal_18 == 0))
          {
            return_value_strcasecmp_19=strcasecmp(d->priv->service_name, name);
            tmp_if_expr_20 = return_value_strcasecmp_19 == 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_20 = (_Bool)0;
          tmp_if_expr_21 = tmp_if_expr_20 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_21)
        {
          struct _GtkTreePath *path;
          gtk_tree_selection_select_iter(selection, &iter);
          unsigned long int return_value_gtk_tree_model_get_type_13;
          return_value_gtk_tree_model_get_type_13=gtk_tree_model_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
          return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_tree_model_get_type_13);
          path=gtk_tree_model_get_path((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_14, &iter);
          unsigned long int return_value_gtk_tree_view_get_type_15;
          return_value_gtk_tree_view_get_type_15=gtk_tree_view_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
          return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type_15);
          gtk_tree_view_set_cursor((struct _GtkTreeView *)return_value_g_type_check_instance_cast_16, path, (struct _GtkTreeViewColumn *)(void *)0, 0);
          gtk_tree_path_free(path);
        }

      }

      goto __CPROVER_DUMP_L30;
    }
    case AVAHI_BROWSER_REMOVE:
    {
      return_value_gtk_tree_model_get_type_23=gtk_tree_model_get_type();
      return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_tree_model_get_type_23);
      valid=gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_24, &browse_callback__1__1__2__iter);
      while(!(valid == 0))
      {
        signed int _interface;
        signed int _protocol;
        char *_name;
        char *_type;
        signed int found;
        unsigned long int return_value_gtk_tree_model_get_type_25;
        return_value_gtk_tree_model_get_type_25=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
        return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_tree_model_get_type_25);
        gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_26, &browse_callback__1__1__2__iter, 0, &_interface, 1, &_protocol, 3, &_name, 2, &_type, -1);
        if(_interface == interface && _protocol == protocol)
        {
          return_value_strcasecmp_27=strcasecmp(_name, name);
          tmp_if_expr_28 = return_value_strcasecmp_27 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_28 = (_Bool)0;
        if(tmp_if_expr_28)
        {
          return_value_avahi_domain_equal_29=avahi_domain_equal(_type, type);
          tmp_if_expr_30 = return_value_avahi_domain_equal_29 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_30 = (_Bool)0;
        found = (signed int)tmp_if_expr_30;
        g_free((void *)_name);
        if(!(found == 0))
        {
          gtk_list_store_remove(d->priv->service_list_store, &browse_callback__1__1__2__iter);
          break;
        }

        unsigned long int return_value_gtk_tree_model_get_type_31;
        return_value_gtk_tree_model_get_type_31=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_32;
        return_value_g_type_check_instance_cast_32=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_tree_model_get_type_31);
        valid=gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_32, &browse_callback__1__1__2__iter);
      }
      goto __CPROVER_DUMP_L30;
    }
    case AVAHI_BROWSER_FAILURE:
    {
      struct _GtkWidget *m;
      unsigned long int return_value_gtk_window_get_type_33;
      return_value_gtk_window_get_type_33=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_34;
      return_value_g_type_check_instance_cast_34=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type_33);
      char *return_value_dgettext_35;
      return_value_dgettext_35=dgettext("avahi", "Browsing for service type %s in domain %s failed: %s");
      if(!(domain == ((const char *)NULL)))
        tmp_if_expr_37 = domain;

      else
      {
        return_value_dgettext_36=dgettext("avahi", "n/a");
        tmp_if_expr_37 = return_value_dgettext_36;
      }
      signed int return_value_avahi_client_errno_38;
      return_value_avahi_client_errno_38=avahi_client_errno(d->priv->client);
      const char *return_value_avahi_strerror_39;
      return_value_avahi_strerror_39=avahi_strerror(return_value_avahi_client_errno_38);
      m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast_34, (enum anonymous_30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous_29)GTK_MESSAGE_ERROR, (enum anonymous_17)GTK_BUTTONS_CLOSE, return_value_dgettext_35, type, tmp_if_expr_37, return_value_avahi_strerror_39);
      unsigned long int return_value_gtk_dialog_get_type_40;
      return_value_gtk_dialog_get_type_40=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_41;
      return_value_g_type_check_instance_cast_41=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type_40);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_41);
      gtk_widget_destroy(m);
    }
    case AVAHI_BROWSER_ALL_FOR_NOW:
      if(d->priv->service_pulse_timeout >= 1u)
      {
        g_source_remove(d->priv->service_pulse_timeout);
        d->priv->service_pulse_timeout = (unsigned int)0;
        gtk_widget_hide(d->priv->service_progress_bar);
      }

    case AVAHI_BROWSER_CACHE_EXHAUSTED:

    default:

      __CPROVER_DUMP_L30:
        ;
  }
}

// calloc_glue
// file glib-malloc.c line 37
static void * calloc_glue(unsigned long int nmemb, unsigned long int size)
{
  void *return_value_g_malloc0_1;
  return_value_g_malloc0_1=g_malloc0(nmemb * size);
  return return_value_g_malloc0_1;
}

// check_func
// file glib-watch.c line 291
static signed int check_func(struct _GSource *source)
{
  struct AvahiGLibPoll *g = (struct AvahiGLibPoll *)source;
  struct AvahiWatch_0 *w;
  struct AvahiTimeout *next_timeout;
  do
    if(g == ((struct AvahiGLibPoll *)NULL))
      g_assertion_message_expr((char *)0, "glib-watch.c", 296, (const char *)"check_func", "g");

  while((_Bool)0);
  next_timeout=find_next_timeout_link2(g);
  if(!(next_timeout == ((struct AvahiTimeout *)NULL)))
  {
    struct _GTimeVal now;
    struct timeval tvnow;
    g_source_get_current_time(source, &now);
    tvnow.tv_sec = now.tv_sec;
    tvnow.tv_usec = now.tv_usec;
    signed int return_value_avahi_timeval_compare_1;
    return_value_avahi_timeval_compare_1=avahi_timeval_compare(&next_timeout->expiry, &tvnow);
    if(!(return_value_avahi_timeval_compare_1 >= 1))
      return (signed int)!(0 != 0);

  }

  w = g->watches;
  for( ; !(w == ((struct AvahiWatch_0 *)NULL)); w = w->watches_next)
    if((signed int)w->pollfd.revents >= 1)
      return (signed int)!(0 != 0);

  return 0;
}

// check_version
// file client.c line 351
static signed int check_version(struct AvahiClient *client, signed int *ret_error)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  unsigned int version;
  signed int e = -24;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  dbus_error_init(&error);
  message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetAPIVersion");
  _Bool tmp_if_expr_14;
  unsigned int return_value_dbus_error_is_set_13;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  _Bool tmp_if_expr_8;
  unsigned int return_value_dbus_error_is_set_7;
  _Bool tmp_if_expr_12;
  unsigned int return_value_dbus_error_is_set_11;
  if(!(message == ((struct DBusMessage *)NULL)))
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr_14 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_13=dbus_error_is_set(&error);
      tmp_if_expr_14 = return_value_dbus_error_is_set_13 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_14)
    {
      char *version_str;
      unsigned int return_value_dbus_error_is_set_1;
      return_value_dbus_error_is_set_1=dbus_error_is_set(&error);
      if(return_value_dbus_error_is_set_1 == 0u)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_strcmp_2=strcmp(error.name, "org.freedesktop.DBus.Error.UnknownMethod");
        tmp_if_expr_3 = return_value_strcmp_2 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        goto fail;

      dbus_message_unref(message);
      if(!(reply == ((struct DBusMessage *)NULL)))
        dbus_message_unref(reply);

      dbus_error_free(&error);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetVersionString");
      if(message == ((struct DBusMessage *)NULL))
        goto fail;

      reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
      if(reply == ((struct DBusMessage *)NULL))
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
        tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        goto fail;

      unsigned int return_value_dbus_message_get_args_6;
      return_value_dbus_message_get_args_6=dbus_message_get_args(reply, &error, (signed int)115, &version_str, (signed int)0);
      if(return_value_dbus_message_get_args_6 == 0u)
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_7=dbus_error_is_set(&error);
        tmp_if_expr_8 = return_value_dbus_error_is_set_7 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8)
        goto fail;

      signed int return_value_strcmp_9;
      return_value_strcmp_9=strcmp(version_str, "avahi 0.6");
      version = (unsigned int)(return_value_strcmp_9 == 0 ? 0x0201 : 0x0000);
    }

    else
    {
      unsigned int return_value_dbus_message_get_args_10;
      return_value_dbus_message_get_args_10=dbus_message_get_args(reply, &error, (signed int)117, &version, (signed int)0);
      if(return_value_dbus_message_get_args_10 == 0u)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_11=dbus_error_is_set(&error);
        tmp_if_expr_12 = return_value_dbus_error_is_set_11 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
        goto fail;

    }
    if(!((65280u & version) == 512u) || !((255u & version) >= 1u))
    {
      e = -32;
      goto fail;
    }

    dbus_message_unref(message);
    dbus_message_unref(reply);
    return 0;
  }

  else
  {

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_15;
    return_value_dbus_error_is_set_15=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_15 == 0u))
    {
      e=avahi_error_dbus_to_number(error.name);
      dbus_error_free(&error);
    }

    if(!(ret_error == ((signed int *)NULL)))
      *ret_error = e;

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return e;
  }
}

// check_version_link1
// file client.c line 351
static signed int check_version_link1(struct AvahiClient *client_link1, signed int *ret_error_link1)
{
  struct DBusMessage *message_link1 = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply_link1 = (struct DBusMessage *)(void *)0;
  struct DBusError error_link1;
  unsigned int version_link1;
  signed int e_link1 = -24;
  /* assertion client */
  assert(client_link1 != ((struct AvahiClient *)NULL));
  dbus_error_init(&error_link1);
  message_link1=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetAPIVersion");
  _Bool tmp_if_expr_14_link1;
  unsigned int return_value_dbus_error_is_set_13_link1;
  _Bool tmp_if_expr_3_link1;
  signed int return_value_strcmp_2_link1;
  _Bool tmp_if_expr_5_link1;
  unsigned int return_value_dbus_error_is_set_4_link1;
  _Bool tmp_if_expr_8_link1;
  unsigned int return_value_dbus_error_is_set_7_link1;
  _Bool tmp_if_expr_12_link1;
  unsigned int return_value_dbus_error_is_set_11_link1;
  if(!(message_link1 == ((struct DBusMessage *)NULL)))
  {
    reply_link1=dbus_connection_send_with_reply_and_block(client_link1->bus, message_link1, -1, &error_link1);
    if(reply_link1 == ((struct DBusMessage *)NULL))
      tmp_if_expr_14_link1 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_13_link1=dbus_error_is_set(&error_link1);
      tmp_if_expr_14_link1 = return_value_dbus_error_is_set_13_link1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_14_link1)
    {
      char *version_str_link1;
      unsigned int return_value_dbus_error_is_set_1_link1;
      return_value_dbus_error_is_set_1_link1=dbus_error_is_set(&error_link1);
      if(return_value_dbus_error_is_set_1_link1 == 0u)
        tmp_if_expr_3_link1 = (_Bool)1;

      else
      {
        return_value_strcmp_2_link1=strcmp(error_link1.name, "org.freedesktop.DBus.Error.UnknownMethod");
        tmp_if_expr_3_link1 = return_value_strcmp_2_link1 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3_link1)
        goto fail;

      dbus_message_unref(message_link1);
      if(!(reply_link1 == ((struct DBusMessage *)NULL)))
        dbus_message_unref(reply_link1);

      dbus_error_free(&error_link1);
      message_link1=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetVersionString");
      if(message_link1 == ((struct DBusMessage *)NULL))
        goto fail;

      reply_link1=dbus_connection_send_with_reply_and_block(client_link1->bus, message_link1, -1, &error_link1);
      if(reply_link1 == ((struct DBusMessage *)NULL))
        tmp_if_expr_5_link1 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4_link1=dbus_error_is_set(&error_link1);
        tmp_if_expr_5_link1 = return_value_dbus_error_is_set_4_link1 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5_link1)
        goto fail;

      unsigned int return_value_dbus_message_get_args_6_link1;
      return_value_dbus_message_get_args_6_link1=dbus_message_get_args(reply_link1, &error_link1, (signed int)115, &version_str_link1, (signed int)0);
      if(return_value_dbus_message_get_args_6_link1 == 0u)
        tmp_if_expr_8_link1 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_7_link1=dbus_error_is_set(&error_link1);
        tmp_if_expr_8_link1 = return_value_dbus_error_is_set_7_link1 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8_link1)
        goto fail;

      signed int return_value_strcmp_9_link1;
      return_value_strcmp_9_link1=strcmp(version_str_link1, "avahi 0.6");
      version_link1 = (unsigned int)(return_value_strcmp_9_link1 == 0 ? 0x0201 : 0x0000);
    }

    else
    {
      unsigned int return_value_dbus_message_get_args_10_link1;
      return_value_dbus_message_get_args_10_link1=dbus_message_get_args(reply_link1, &error_link1, (signed int)117, &version_link1, (signed int)0);
      if(return_value_dbus_message_get_args_10_link1 == 0u)
        tmp_if_expr_12_link1 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_11_link1=dbus_error_is_set(&error_link1);
        tmp_if_expr_12_link1 = return_value_dbus_error_is_set_11_link1 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12_link1)
        goto fail;

    }
    if(!((65280u & version_link1) == 512u) || !((255u & version_link1) >= 1u))
    {
      e_link1 = -32;
      goto fail;
    }

    dbus_message_unref(message_link1);
    dbus_message_unref(reply_link1);
    return 0;
  }

  else
  {

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_15_link1;
    return_value_dbus_error_is_set_15_link1=dbus_error_is_set(&error_link1);
    if(!(return_value_dbus_error_is_set_15_link1 == 0u))
    {
      e_link1=avahi_error_dbus_to_number(error_link1.name);
      dbus_error_free(&error_link1);
    }

    if(!(ret_error_link1 == ((signed int *)NULL)))
      *ret_error_link1 = e_link1;

    if(!(message_link1 == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message_link1);

    if(!(reply_link1 == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply_link1);

    return e_link1;
  }
}

// cleanup_timeouts
// file simple-watch.c line 304
static void cleanup_timeouts(struct AvahiSimplePoll_0 *s, signed int all)
{
  struct AvahiTimeout_1 *t;
  struct AvahiTimeout_1 *next;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  t = s->timeouts;
  _Bool tmp_if_expr_1;
  for( ; !(t == ((struct AvahiTimeout_1 *)NULL)); t = next)
  {
    next = t->timeouts_next;
    if(!(all == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = t->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      destroy_timeout(t);

  }
  s->timeout_req_cleanup = 0;
}

// cleanup_timeouts_link1
// file simple-watch.c line 304
static void cleanup_timeouts_link1(struct AvahiSimplePoll_0 *s_link1, signed int all_link1)
{
  struct AvahiTimeout_1 *t_link1;
  struct AvahiTimeout_1 *next_link1;
  /* assertion s */
  assert(s_link1 != ((struct AvahiSimplePoll_0 *)NULL));
  t_link1 = s_link1->timeouts;
  _Bool tmp_if_expr_1_link1;
  for( ; !(t_link1 == ((struct AvahiTimeout_1 *)NULL)); t_link1 = next_link1)
  {
    next_link1 = t_link1->timeouts_next;
    if(!(all_link1 == 0))
      tmp_if_expr_1_link1 = (_Bool)1;

    else
      tmp_if_expr_1_link1 = t_link1->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link1)
      destroy_timeout_link1(t_link1);

  }
  s_link1->timeout_req_cleanup = 0;
}

// cleanup_timeouts_link1_link1
// file simple-watch.c line 304
static void cleanup_timeouts_link1_link1(struct AvahiSimplePoll *s_link2, signed int all_link1_link1)
{
  struct AvahiTimeout_0 *t_link1_link1;
  struct AvahiTimeout_0 *next_link1_link1;
  /* assertion s */
  assert(s_link2 != ((struct AvahiSimplePoll *)NULL));
  t_link1_link1 = s_link2->timeouts;
  _Bool tmp_if_expr_1_link1_link1;
  for( ; !(t_link1_link1 == ((struct AvahiTimeout_0 *)NULL)); t_link1_link1 = next_link1_link1)
  {
    next_link1_link1 = t_link1_link1->timeouts_next;
    if(!(all_link1_link1 == 0))
      tmp_if_expr_1_link1_link1 = (_Bool)1;

    else
      tmp_if_expr_1_link1_link1 = t_link1_link1->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link1_link1)
      destroy_timeout_link1_link1(t_link1_link1);

  }
  s_link2->timeout_req_cleanup = 0;
}

// cleanup_timeouts_link1_link2
// file simple-watch.c line 304
static void cleanup_timeouts_link1_link2(struct AvahiSimplePoll_0 *s_link1_link1, signed int all_link1_link2)
{
  struct AvahiTimeout_1 *t_link1_link2;
  struct AvahiTimeout_1 *next_link1_link2;
  /* assertion s */
  assert(s_link1_link1 != ((struct AvahiSimplePoll_0 *)NULL));
  t_link1_link2 = s_link1_link1->timeouts;
  _Bool tmp_if_expr_1_link1_link2;
  for( ; !(t_link1_link2 == ((struct AvahiTimeout_1 *)NULL)); t_link1_link2 = next_link1_link2)
  {
    next_link1_link2 = t_link1_link2->timeouts_next;
    if(!(all_link1_link2 == 0))
      tmp_if_expr_1_link1_link2 = (_Bool)1;

    else
      tmp_if_expr_1_link1_link2 = t_link1_link2->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link1_link2)
      destroy_timeout_link1_link2(t_link1_link2);

  }
  s_link1_link1->timeout_req_cleanup = 0;
}

// cleanup_timeouts_link2
// file glib-watch.c line 216
static void cleanup_timeouts_link2(struct AvahiGLibPoll *g, signed int all_link2)
{
  struct AvahiTimeout *t_link2;
  struct AvahiTimeout *next_link2;
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  t_link2 = g->timeouts;
  _Bool tmp_if_expr_1_link2;
  for( ; !(t_link2 == ((struct AvahiTimeout *)NULL)); t_link2 = next_link2)
  {
    next_link2 = t_link2->timeouts_next;
    if(!(all_link2 == 0))
      tmp_if_expr_1_link2 = (_Bool)1;

    else
      tmp_if_expr_1_link2 = t_link2->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link2)
      destroy_timeout_link2(t_link2);

  }
  g->timeout_req_cleanup = 0;
}

// cleanup_timeouts_link3
// file simple-watch.c line 304
static void cleanup_timeouts_link3(struct AvahiSimplePoll_0 *s_link3, signed int all_link3)
{
  struct AvahiTimeout_1 *t_link3;
  struct AvahiTimeout_1 *next_link3;
  /* assertion s */
  assert(s_link3 != ((struct AvahiSimplePoll_0 *)NULL));
  t_link3 = s_link3->timeouts;
  _Bool tmp_if_expr_1_link3;
  for( ; !(t_link3 == ((struct AvahiTimeout_1 *)NULL)); t_link3 = next_link3)
  {
    next_link3 = t_link3->timeouts_next;
    if(!(all_link3 == 0))
      tmp_if_expr_1_link3 = (_Bool)1;

    else
      tmp_if_expr_1_link3 = t_link3->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link3)
      destroy_timeout_link3(t_link3);

  }
  s_link3->timeout_req_cleanup = 0;
}

// cleanup_watches
// file simple-watch.c line 230
static void cleanup_watches(struct AvahiSimplePoll_0 *s, signed int all)
{
  struct AvahiWatch_1 *w;
  struct AvahiWatch_1 *next;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  w = s->watches;
  _Bool tmp_if_expr_1;
  for( ; !(w == ((struct AvahiWatch_1 *)NULL)); w = next)
  {
    next = w->watches_next;
    if(!(all == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = w->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      destroy_watch(w);

  }
  s->timeout_req_cleanup = 0;
}

// cleanup_watches_link1
// file simple-watch.c line 230
static void cleanup_watches_link1(struct AvahiSimplePoll_0 *s_link1, signed int all_link1)
{
  struct AvahiWatch_1 *w_link1;
  struct AvahiWatch_1 *next_link1;
  /* assertion s */
  assert(s_link1 != ((struct AvahiSimplePoll_0 *)NULL));
  w_link1 = s_link1->watches;
  _Bool tmp_if_expr_1_link1;
  for( ; !(w_link1 == ((struct AvahiWatch_1 *)NULL)); w_link1 = next_link1)
  {
    next_link1 = w_link1->watches_next;
    if(!(all_link1 == 0))
      tmp_if_expr_1_link1 = (_Bool)1;

    else
      tmp_if_expr_1_link1 = w_link1->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link1)
      destroy_watch_link1(w_link1);

  }
  s_link1->timeout_req_cleanup = 0;
}

// cleanup_watches_link1_link1
// file simple-watch.c line 230
static void cleanup_watches_link1_link1(struct AvahiSimplePoll *s_link2, signed int all_link1_link1)
{
  struct AvahiWatch *w_link1_link1;
  struct AvahiWatch *next_link1_link1;
  /* assertion s */
  assert(s_link2 != ((struct AvahiSimplePoll *)NULL));
  w_link1_link1 = s_link2->watches;
  _Bool tmp_if_expr_1_link1_link1;
  for( ; !(w_link1_link1 == ((struct AvahiWatch *)NULL)); w_link1_link1 = next_link1_link1)
  {
    next_link1_link1 = w_link1_link1->watches_next;
    if(!(all_link1_link1 == 0))
      tmp_if_expr_1_link1_link1 = (_Bool)1;

    else
      tmp_if_expr_1_link1_link1 = w_link1_link1->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link1_link1)
      destroy_watch_link1_link1(w_link1_link1);

  }
  s_link2->timeout_req_cleanup = 0;
}

// cleanup_watches_link1_link2
// file simple-watch.c line 230
static void cleanup_watches_link1_link2(struct AvahiSimplePoll_0 *s_link1_link1, signed int all_link1_link2)
{
  struct AvahiWatch_1 *w_link1_link2;
  struct AvahiWatch_1 *next_link1_link2;
  /* assertion s */
  assert(s_link1_link1 != ((struct AvahiSimplePoll_0 *)NULL));
  w_link1_link2 = s_link1_link1->watches;
  _Bool tmp_if_expr_1_link1_link2;
  for( ; !(w_link1_link2 == ((struct AvahiWatch_1 *)NULL)); w_link1_link2 = next_link1_link2)
  {
    next_link1_link2 = w_link1_link2->watches_next;
    if(!(all_link1_link2 == 0))
      tmp_if_expr_1_link1_link2 = (_Bool)1;

    else
      tmp_if_expr_1_link1_link2 = w_link1_link2->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link1_link2)
      destroy_watch_link1_link2(w_link1_link2);

  }
  s_link1_link1->timeout_req_cleanup = 0;
}

// cleanup_watches_link2
// file glib-watch.c line 79
static void cleanup_watches_link2(struct AvahiGLibPoll *g, signed int all_link2)
{
  struct AvahiWatch_0 *w_link2;
  struct AvahiWatch_0 *next_link2;
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  w_link2 = g->watches;
  _Bool tmp_if_expr_1_link2;
  for( ; !(w_link2 == ((struct AvahiWatch_0 *)NULL)); w_link2 = next_link2)
  {
    next_link2 = w_link2->watches_next;
    if(!(all_link2 == 0))
      tmp_if_expr_1_link2 = (_Bool)1;

    else
      tmp_if_expr_1_link2 = w_link2->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link2)
      destroy_watch_link2(w_link2);

  }
  g->watch_req_cleanup = 0;
}

// cleanup_watches_link3
// file simple-watch.c line 230
static void cleanup_watches_link3(struct AvahiSimplePoll_0 *s_link3, signed int all_link3)
{
  struct AvahiWatch_1 *w_link3;
  struct AvahiWatch_1 *next_link3;
  /* assertion s */
  assert(s_link3 != ((struct AvahiSimplePoll_0 *)NULL));
  w_link3 = s_link3->watches;
  _Bool tmp_if_expr_1_link3;
  for( ; !(w_link3 == ((struct AvahiWatch_1 *)NULL)); w_link3 = next_link3)
  {
    next_link3 = w_link3->watches_next;
    if(!(all_link3 == 0))
      tmp_if_expr_1_link3 = (_Bool)1;

    else
      tmp_if_expr_1_link3 = w_link3->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link3)
      destroy_watch_link3(w_link3);

  }
  s_link3->timeout_req_cleanup = 0;
}

// clear_wakeup
// file simple-watch.c line 105
static void clear_wakeup(struct AvahiSimplePoll_0 *s)
{
  char c[10l];
  signed long int return_value_read_1;
  if(!(s->wakeup_issued == 0))
  {
    s->wakeup_issued = 0;
    do
    {
      return_value_read_1=read(s->wakeup_pipe[(signed long int)0], (void *)&c, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read_1 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// clear_wakeup_link1
// file simple-watch.c line 105
static void clear_wakeup_link1(struct AvahiSimplePoll_0 *s_link1)
{
  char c_link1[10l];
  signed long int return_value_read_1_link1;
  if(!(s_link1->wakeup_issued == 0))
  {
    s_link1->wakeup_issued = 0;
    do
    {
      return_value_read_1_link1=read(s_link1->wakeup_pipe[(signed long int)0], (void *)&c_link1, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read_1_link1 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// clear_wakeup_link1_link1
// file simple-watch.c line 105
static void clear_wakeup_link1_link1(struct AvahiSimplePoll_0 *s_link1_link1)
{
  char c_link1_link1[10l];
  signed long int return_value_read_1_link1_link1;
  if(!(s_link1_link1->wakeup_issued == 0))
  {
    s_link1_link1->wakeup_issued = 0;
    do
    {
      return_value_read_1_link1_link1=read(s_link1_link1->wakeup_pipe[(signed long int)0], (void *)&c_link1_link1, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read_1_link1_link1 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// clear_wakeup_link2
// file simple-watch.c line 105
static void clear_wakeup_link2(struct AvahiSimplePoll *s_link2)
{
  char c_link2[10l];
  signed long int return_value_read_1_link2;
  if(!(s_link2->wakeup_issued == 0))
  {
    s_link2->wakeup_issued = 0;
    do
    {
      return_value_read_1_link2=read(s_link2->wakeup_pipe[(signed long int)0], (void *)&c_link2, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read_1_link2 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// clear_wakeup_link3
// file simple-watch.c line 105
static void clear_wakeup_link3(struct AvahiSimplePoll_0 *s_link3)
{
  char c_link3[10l];
  signed long int return_value_read_1_link3;
  if(!(s_link3->wakeup_issued == 0))
  {
    s_link3->wakeup_issued = 0;
    do
    {
      return_value_read_1_link3=read(s_link3->wakeup_pipe[(signed long int)0], (void *)&c_link3, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read_1_link3 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// client_callback
// file avahi-ui.c line 318
static void client_callback(struct AvahiClient *c, enum anonymous_11 state, void *userdata)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)userdata, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  if((signed int)state == AVAHI_CLIENT_FAILURE)
  {
    struct _GtkWidget *m;
    unsigned long int return_value_gtk_window_get_type_3;
    return_value_gtk_window_get_type_3=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
    return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type_3);
    char *return_value_dgettext_5;
    return_value_dgettext_5=dgettext("avahi", "Avahi client failure: %s");
    signed int return_value_avahi_client_errno_6;
    return_value_avahi_client_errno_6=avahi_client_errno(c);
    const char *return_value_avahi_strerror_7;
    return_value_avahi_strerror_7=avahi_strerror(return_value_avahi_client_errno_6);
    m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast_4, (enum anonymous_30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous_29)GTK_MESSAGE_ERROR, (enum anonymous_17)GTK_BUTTONS_CLOSE, return_value_dgettext_5, return_value_avahi_strerror_7);
    unsigned long int return_value_gtk_dialog_get_type_8;
    return_value_gtk_dialog_get_type_8=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
    return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type_8);
    gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_9);
    gtk_widget_destroy(m);
    unsigned long int return_value_gtk_dialog_get_type_10;
    return_value_gtk_dialog_get_type_10=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_11;
    return_value_g_type_check_instance_cast_11=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_10);
    gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_11, -6);
  }

}

// client_set_state
// file client.c line 58
static void client_set_state(struct AvahiClient *client, enum anonymous_11 state)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  if(!(client->state == state))
  {
    client->state = state;
    switch((signed int)client->state)
    {
      case AVAHI_CLIENT_FAILURE:
        if(!(client->bus == ((struct DBusConnection *)NULL)))
        {
          dbus_connection_close(client->bus);
          dbus_connection_unref(client->bus);
          client->bus = (struct DBusConnection *)(void *)0;
        }

      case AVAHI_CLIENT_S_COLLISION:

      case AVAHI_CLIENT_S_REGISTERING:
      {
        avahi_free((void *)client->host_name);
        avahi_free((void *)client->host_name_fqdn);
        avahi_free((void *)client->domain_name);
        client->host_name = (char *)(void *)0;
        client->host_name_fqdn = (char *)(void *)0;
        client->domain_name = (char *)(void *)0;
      }
      case AVAHI_CLIENT_S_RUNNING:

      case AVAHI_CLIENT_CONNECTING:

      default:
        if(!(client->callback == ((void (*)(struct AvahiClient *, enum anonymous_11, void *))NULL)))
          client->callback(client, state, client->userdata);

    }
  }

}

// client_set_state_link1
// file client.c line 58
static void client_set_state_link1(struct AvahiClient *client_link1, enum anonymous_11 state_link1)
{
  /* assertion client */
  assert(client_link1 != ((struct AvahiClient *)NULL));
  if(!(client_link1->state == state_link1))
  {
    client_link1->state = state_link1;
    switch((signed int)client_link1->state)
    {
      case AVAHI_CLIENT_FAILURE:
        if(!(client_link1->bus == ((struct DBusConnection *)NULL)))
        {
          dbus_connection_close(client_link1->bus);
          dbus_connection_unref(client_link1->bus);
          client_link1->bus = (struct DBusConnection *)(void *)0;
        }

      case AVAHI_CLIENT_S_COLLISION:

      case AVAHI_CLIENT_S_REGISTERING:
      {
        avahi_free((void *)client_link1->host_name);
        avahi_free((void *)client_link1->host_name_fqdn);
        avahi_free((void *)client_link1->domain_name);
        client_link1->host_name = (char *)(void *)0;
        client_link1->host_name_fqdn = (char *)(void *)0;
        client_link1->domain_name = (char *)(void *)0;
      }
      case AVAHI_CLIENT_S_RUNNING:

      case AVAHI_CLIENT_CONNECTING:

      default:
        if(!(client_link1->callback == ((void (*)(struct AvahiClient *, enum anonymous_11, void *))NULL)))
          client_link1->callback(client_link1, state_link1, client_link1->userdata);

    }
  }

}

// connection_data_ref
// file ../avahi-common/dbus-watch-glue.c line 68
static struct anonymous_28 * connection_data_ref(struct anonymous_28 *d)
{
  /* assertion d */
  assert(d != ((struct anonymous_28 *)NULL));
  /* assertion d->ref >= 1 */
  assert(d->ref >= 1);
  d->ref = d->ref + 1;
  return d;
}

// connection_data_ref_link1
// file ../avahi-common/dbus-watch-glue.c line 68
static struct anonymous_28 * connection_data_ref_link1(struct anonymous_28 *d_link1)
{
  /* assertion d */
  assert(d_link1 != ((struct anonymous_28 *)NULL));
  /* assertion d->ref >= 1 */
  assert(d_link1->ref >= 1);
  d_link1->ref = d_link1->ref + 1;
  return d_link1;
}

// connection_data_unref
// file ../avahi-common/dbus-watch-glue.c line 76
static void connection_data_unref(struct anonymous_28 *d)
{
  /* assertion d */
  assert(d != ((struct anonymous_28 *)NULL));
  /* assertion d->ref >= 1 */
  assert(d->ref >= 1);
  d->ref = d->ref - 1;
  if(!(d->ref >= 1))
  {
    d->poll_api->timeout_free(d->dispatch_timeout);
    avahi_free((void *)d);
  }

}

// connection_data_unref_link1
// file ../avahi-common/dbus-watch-glue.c line 76
static void connection_data_unref_link1(struct anonymous_28 *d_link1)
{
  /* assertion d */
  assert(d_link1 != ((struct anonymous_28 *)NULL));
  /* assertion d->ref >= 1 */
  assert(d_link1->ref >= 1);
  d_link1->ref = d_link1->ref - 1;
  if(!(d_link1->ref >= 1))
  {
    d_link1->poll_api->timeout_free(d_link1->dispatch_timeout);
    avahi_free((void *)d_link1);
  }

}

// defer_timeout_callback
// file browser.c line 83
static void defer_timeout_callback(struct AvahiTimeout_1 *t, void *userdata)
{
  struct AvahiDomainBrowser *db = (struct AvahiDomainBrowser *)userdata;
  struct AvahiStringList *l;
  /* assertion t */
  assert(t != ((struct AvahiTimeout_1 *)NULL));
  db->client->poll_api->timeout_free(db->defer_timeout);
  db->defer_timeout = (struct AvahiTimeout_1 *)(void *)0;
  domain_browser_ref(db);
  l = db->static_browse_domains;
  if(!(l == ((struct AvahiStringList *)NULL)))
  {
    if(db->ref >= 2)
    {
      db->callback(db, -1, -1, (enum anonymous_14)AVAHI_BROWSER_NEW, (char *)l->text, (enum anonymous_13)AVAHI_LOOKUP_RESULT_STATIC, db->userdata);
      l = l->next;
    }

  }

  avahi_domain_browser_free(db);
}

// defer_timeout_callback_link1
// file browser.c line 83
static void defer_timeout_callback_link1(struct AvahiTimeout_1 *t_link1, void *userdata_link1)
{
  struct AvahiDomainBrowser *db_link1 = (struct AvahiDomainBrowser *)userdata_link1;
  struct AvahiStringList *l_link1;
  /* assertion t */
  assert(t_link1 != ((struct AvahiTimeout_1 *)NULL));
  db_link1->client->poll_api->timeout_free(db_link1->defer_timeout);
  db_link1->defer_timeout = (struct AvahiTimeout_1 *)(void *)0;
  domain_browser_ref_link1(db_link1);
  l_link1 = db_link1->static_browse_domains;
  if(!(l_link1 == ((struct AvahiStringList *)NULL)))
  {
    if(db_link1->ref >= 2)
    {
      db_link1->callback(db_link1, -1, -1, (enum anonymous_14)AVAHI_BROWSER_NEW, (char *)l_link1->text, (enum anonymous_13)AVAHI_LOOKUP_RESULT_STATIC, db_link1->userdata);
      l_link1 = l_link1->next;
    }

  }

  avahi_domain_browser_free(db_link1);
}

// destroy_timeout
// file simple-watch.c line 296
static void destroy_timeout(struct AvahiTimeout_1 *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout_1 *)NULL));
  do
  {
    struct AvahiTimeout_1 **_head = &t->simple_poll->timeouts;
    struct AvahiTimeout_1 *_item = t;
    /* assertion _item */
    assert(_item != ((struct AvahiTimeout_1 *)NULL));
    if(!(_item->timeouts_next == ((struct AvahiTimeout_1 *)NULL)))
      _item->timeouts_next->timeouts_prev = _item->timeouts_prev;

    if(!(_item->timeouts_prev == ((struct AvahiTimeout_1 *)NULL)))
      _item->timeouts_prev->timeouts_next = _item->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->timeouts_next;
    }
    _item->timeouts_prev = (struct AvahiTimeout_1 *)(void *)0;
    _item->timeouts_next = _item->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t);
}

// destroy_timeout_link1
// file simple-watch.c line 296
static void destroy_timeout_link1(struct AvahiTimeout_1 *t_link1)
{
  /* assertion t */
  assert(t_link1 != ((struct AvahiTimeout_1 *)NULL));
  do
  {
    struct AvahiTimeout_1 **_head_link1 = &t_link1->simple_poll->timeouts;
    struct AvahiTimeout_1 *_item_link1 = t_link1;
    /* assertion _item */
    assert(_item_link1 != ((struct AvahiTimeout_1 *)NULL));
    if(!(_item_link1->timeouts_next == ((struct AvahiTimeout_1 *)NULL)))
      _item_link1->timeouts_next->timeouts_prev = _item_link1->timeouts_prev;

    if(!(_item_link1->timeouts_prev == ((struct AvahiTimeout_1 *)NULL)))
      _item_link1->timeouts_prev->timeouts_next = _item_link1->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head_link1 == _item_link1);
      *_head_link1 = _item_link1->timeouts_next;
    }
    _item_link1->timeouts_prev = (struct AvahiTimeout_1 *)(void *)0;
    _item_link1->timeouts_next = _item_link1->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t_link1);
}

// destroy_timeout_link1_link1
// file simple-watch.c line 296
static void destroy_timeout_link1_link1(struct AvahiTimeout_0 *t_link1_link1)
{
  /* assertion t */
  assert(t_link1_link1 != ((struct AvahiTimeout_0 *)NULL));
  do
  {
    struct AvahiTimeout_0 **_head_link1_link1 = &t_link1_link1->simple_poll->timeouts;
    struct AvahiTimeout_0 *_item_link1_link1 = t_link1_link1;
    /* assertion _item */
    assert(_item_link1_link1 != ((struct AvahiTimeout_0 *)NULL));
    if(!(_item_link1_link1->timeouts_next == ((struct AvahiTimeout_0 *)NULL)))
      _item_link1_link1->timeouts_next->timeouts_prev = _item_link1_link1->timeouts_prev;

    if(!(_item_link1_link1->timeouts_prev == ((struct AvahiTimeout_0 *)NULL)))
      _item_link1_link1->timeouts_prev->timeouts_next = _item_link1_link1->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head_link1_link1 == _item_link1_link1);
      *_head_link1_link1 = _item_link1_link1->timeouts_next;
    }
    _item_link1_link1->timeouts_prev = (struct AvahiTimeout_0 *)(void *)0;
    _item_link1_link1->timeouts_next = _item_link1_link1->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t_link1_link1);
}

// destroy_timeout_link1_link2
// file simple-watch.c line 296
static void destroy_timeout_link1_link2(struct AvahiTimeout_1 *t_link1_link2)
{
  /* assertion t */
  assert(t_link1_link2 != ((struct AvahiTimeout_1 *)NULL));
  do
  {
    struct AvahiTimeout_1 **_head_link1_link2 = &t_link1_link2->simple_poll->timeouts;
    struct AvahiTimeout_1 *_item_link1_link2 = t_link1_link2;
    /* assertion _item */
    assert(_item_link1_link2 != ((struct AvahiTimeout_1 *)NULL));
    if(!(_item_link1_link2->timeouts_next == ((struct AvahiTimeout_1 *)NULL)))
      _item_link1_link2->timeouts_next->timeouts_prev = _item_link1_link2->timeouts_prev;

    if(!(_item_link1_link2->timeouts_prev == ((struct AvahiTimeout_1 *)NULL)))
      _item_link1_link2->timeouts_prev->timeouts_next = _item_link1_link2->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head_link1_link2 == _item_link1_link2);
      *_head_link1_link2 = _item_link1_link2->timeouts_next;
    }
    _item_link1_link2->timeouts_prev = (struct AvahiTimeout_1 *)(void *)0;
    _item_link1_link2->timeouts_next = _item_link1_link2->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t_link1_link2);
}

// destroy_timeout_link2
// file glib-watch.c line 209
static void destroy_timeout_link2(struct AvahiTimeout *t_link2)
{
  /* assertion t */
  assert(t_link2 != ((struct AvahiTimeout *)NULL));
  do
  {
    struct AvahiTimeout **_head_link2 = &t_link2->glib_poll->timeouts;
    struct AvahiTimeout *_item_link2 = t_link2;
    /* assertion _item */
    assert(_item_link2 != ((struct AvahiTimeout *)NULL));
    if(!(_item_link2->timeouts_next == ((struct AvahiTimeout *)NULL)))
      _item_link2->timeouts_next->timeouts_prev = _item_link2->timeouts_prev;

    if(!(_item_link2->timeouts_prev == ((struct AvahiTimeout *)NULL)))
      _item_link2->timeouts_prev->timeouts_next = _item_link2->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head_link2 == _item_link2);
      *_head_link2 = _item_link2->timeouts_next;
    }
    _item_link2->timeouts_prev = (struct AvahiTimeout *)(void *)0;
    _item_link2->timeouts_next = _item_link2->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t_link2);
}

// destroy_timeout_link3
// file simple-watch.c line 296
static void destroy_timeout_link3(struct AvahiTimeout_1 *t_link3)
{
  /* assertion t */
  assert(t_link3 != ((struct AvahiTimeout_1 *)NULL));
  do
  {
    struct AvahiTimeout_1 **_head_link3 = &t_link3->simple_poll->timeouts;
    struct AvahiTimeout_1 *_item_link3 = t_link3;
    /* assertion _item */
    assert(_item_link3 != ((struct AvahiTimeout_1 *)NULL));
    if(!(_item_link3->timeouts_next == ((struct AvahiTimeout_1 *)NULL)))
      _item_link3->timeouts_next->timeouts_prev = _item_link3->timeouts_prev;

    if(!(_item_link3->timeouts_prev == ((struct AvahiTimeout_1 *)NULL)))
      _item_link3->timeouts_prev->timeouts_next = _item_link3->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head_link3 == _item_link3);
      *_head_link3 = _item_link3->timeouts_next;
    }
    _item_link3->timeouts_prev = (struct AvahiTimeout_1 *)(void *)0;
    _item_link3->timeouts_next = _item_link3->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t_link3);
}

// destroy_watch
// file simple-watch.c line 218
static void destroy_watch(struct AvahiWatch_1 *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch_1 *)NULL));
  remove_pollfd(w);
  do
  {
    struct AvahiWatch_1 **_head = &w->simple_poll->watches;
    struct AvahiWatch_1 *_item = w;
    /* assertion _item */
    assert(_item != ((struct AvahiWatch_1 *)NULL));
    if(!(_item->watches_next == ((struct AvahiWatch_1 *)NULL)))
      _item->watches_next->watches_prev = _item->watches_prev;

    if(!(_item->watches_prev == ((struct AvahiWatch_1 *)NULL)))
      _item->watches_prev->watches_next = _item->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->watches_next;
    }
    _item->watches_prev = (struct AvahiWatch_1 *)(void *)0;
    _item->watches_next = _item->watches_prev;
  }
  while((_Bool)0);
  if(w->dead == 0)
    w->simple_poll->n_watches = w->simple_poll->n_watches - 1;

  avahi_free((void *)w);
}

// destroy_watch_link1
// file simple-watch.c line 218
static void destroy_watch_link1(struct AvahiWatch_1 *w_link1)
{
  /* assertion w */
  assert(w_link1 != ((struct AvahiWatch_1 *)NULL));
  remove_pollfd_link1(w_link1);
  do
  {
    struct AvahiWatch_1 **_head_link1 = &w_link1->simple_poll->watches;
    struct AvahiWatch_1 *_item_link1 = w_link1;
    /* assertion _item */
    assert(_item_link1 != ((struct AvahiWatch_1 *)NULL));
    if(!(_item_link1->watches_next == ((struct AvahiWatch_1 *)NULL)))
      _item_link1->watches_next->watches_prev = _item_link1->watches_prev;

    if(!(_item_link1->watches_prev == ((struct AvahiWatch_1 *)NULL)))
      _item_link1->watches_prev->watches_next = _item_link1->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head_link1 == _item_link1);
      *_head_link1 = _item_link1->watches_next;
    }
    _item_link1->watches_prev = (struct AvahiWatch_1 *)(void *)0;
    _item_link1->watches_next = _item_link1->watches_prev;
  }
  while((_Bool)0);
  if(w_link1->dead == 0)
    w_link1->simple_poll->n_watches = w_link1->simple_poll->n_watches - 1;

  avahi_free((void *)w_link1);
}

// destroy_watch_link1_link1
// file simple-watch.c line 218
static void destroy_watch_link1_link1(struct AvahiWatch *w_link1_link1)
{
  /* assertion w */
  assert(w_link1_link1 != ((struct AvahiWatch *)NULL));
  remove_pollfd_link2(w_link1_link1);
  do
  {
    struct AvahiWatch **_head_link1_link1 = &w_link1_link1->simple_poll->watches;
    struct AvahiWatch *_item_link1_link1 = w_link1_link1;
    /* assertion _item */
    assert(_item_link1_link1 != ((struct AvahiWatch *)NULL));
    if(!(_item_link1_link1->watches_next == ((struct AvahiWatch *)NULL)))
      _item_link1_link1->watches_next->watches_prev = _item_link1_link1->watches_prev;

    if(!(_item_link1_link1->watches_prev == ((struct AvahiWatch *)NULL)))
      _item_link1_link1->watches_prev->watches_next = _item_link1_link1->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head_link1_link1 == _item_link1_link1);
      *_head_link1_link1 = _item_link1_link1->watches_next;
    }
    _item_link1_link1->watches_prev = (struct AvahiWatch *)(void *)0;
    _item_link1_link1->watches_next = _item_link1_link1->watches_prev;
  }
  while((_Bool)0);
  if(w_link1_link1->dead == 0)
    w_link1_link1->simple_poll->n_watches = w_link1_link1->simple_poll->n_watches - 1;

  avahi_free((void *)w_link1_link1);
}

// destroy_watch_link1_link2
// file simple-watch.c line 218
static void destroy_watch_link1_link2(struct AvahiWatch_1 *w_link1_link2)
{
  /* assertion w */
  assert(w_link1_link2 != ((struct AvahiWatch_1 *)NULL));
  remove_pollfd_link1_link1(w_link1_link2);
  do
  {
    struct AvahiWatch_1 **_head_link1_link2 = &w_link1_link2->simple_poll->watches;
    struct AvahiWatch_1 *_item_link1_link2 = w_link1_link2;
    /* assertion _item */
    assert(_item_link1_link2 != ((struct AvahiWatch_1 *)NULL));
    if(!(_item_link1_link2->watches_next == ((struct AvahiWatch_1 *)NULL)))
      _item_link1_link2->watches_next->watches_prev = _item_link1_link2->watches_prev;

    if(!(_item_link1_link2->watches_prev == ((struct AvahiWatch_1 *)NULL)))
      _item_link1_link2->watches_prev->watches_next = _item_link1_link2->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head_link1_link2 == _item_link1_link2);
      *_head_link1_link2 = _item_link1_link2->watches_next;
    }
    _item_link1_link2->watches_prev = (struct AvahiWatch_1 *)(void *)0;
    _item_link1_link2->watches_next = _item_link1_link2->watches_prev;
  }
  while((_Bool)0);
  if(w_link1_link2->dead == 0)
    w_link1_link2->simple_poll->n_watches = w_link1_link2->simple_poll->n_watches - 1;

  avahi_free((void *)w_link1_link2);
}

// destroy_watch_link2
// file glib-watch.c line 68
static void destroy_watch_link2(struct AvahiWatch_0 *w_link2)
{
  /* assertion w */
  assert(w_link2 != ((struct AvahiWatch_0 *)NULL));
  if(!(w_link2->pollfd_added == 0))
    g_source_remove_poll(&w_link2->glib_poll->source, &w_link2->pollfd);

  do
  {
    struct AvahiWatch_0 **_head_link2 = &w_link2->glib_poll->watches;
    struct AvahiWatch_0 *_item_link2 = w_link2;
    /* assertion _item */
    assert(_item_link2 != ((struct AvahiWatch_0 *)NULL));
    if(!(_item_link2->watches_next == ((struct AvahiWatch_0 *)NULL)))
      _item_link2->watches_next->watches_prev = _item_link2->watches_prev;

    if(!(_item_link2->watches_prev == ((struct AvahiWatch_0 *)NULL)))
      _item_link2->watches_prev->watches_next = _item_link2->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head_link2 == _item_link2);
      *_head_link2 = _item_link2->watches_next;
    }
    _item_link2->watches_prev = (struct AvahiWatch_0 *)(void *)0;
    _item_link2->watches_next = _item_link2->watches_prev;
  }
  while((_Bool)0);
  avahi_free((void *)w_link2);
}

// destroy_watch_link3
// file simple-watch.c line 218
static void destroy_watch_link3(struct AvahiWatch_1 *w_link3)
{
  /* assertion w */
  assert(w_link3 != ((struct AvahiWatch_1 *)NULL));
  remove_pollfd_link3(w_link3);
  do
  {
    struct AvahiWatch_1 **_head_link3 = &w_link3->simple_poll->watches;
    struct AvahiWatch_1 *_item_link3 = w_link3;
    /* assertion _item */
    assert(_item_link3 != ((struct AvahiWatch_1 *)NULL));
    if(!(_item_link3->watches_next == ((struct AvahiWatch_1 *)NULL)))
      _item_link3->watches_next->watches_prev = _item_link3->watches_prev;

    if(!(_item_link3->watches_prev == ((struct AvahiWatch_1 *)NULL)))
      _item_link3->watches_prev->watches_next = _item_link3->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head_link3 == _item_link3);
      *_head_link3 = _item_link3->watches_next;
    }
    _item_link3->watches_prev = (struct AvahiWatch_1 *)(void *)0;
    _item_link3->watches_next = _item_link3->watches_prev;
  }
  while((_Bool)0);
  if(w_link3->dead == 0)
    w_link3->simple_poll->n_watches = w_link3->simple_poll->n_watches - 1;

  avahi_free((void *)w_link3);
}

// dispatch_func
// file glib-watch.c line 316
static signed int dispatch_func(struct _GSource *source, signed int (*callback)(void *), void *userdata)
{
  struct AvahiGLibPoll *g = (struct AvahiGLibPoll *)source;
  struct AvahiWatch_0 *w;
  struct AvahiTimeout *next_timeout;
  do
    if(g == ((struct AvahiGLibPoll *)NULL))
      g_assertion_message_expr((char *)0, "glib-watch.c", 321, (const char *)"dispatch_func", "g");

  while((_Bool)0);
  next_timeout=find_next_timeout_link2(g);
  if(!(next_timeout == ((struct AvahiTimeout *)NULL)))
  {
    struct _GTimeVal now;
    struct timeval tvnow;
    g_source_get_current_time(source, &now);
    tvnow.tv_sec = now.tv_sec;
    tvnow.tv_usec = now.tv_usec;
    signed int return_value_avahi_timeval_compare_1;
    return_value_avahi_timeval_compare_1=avahi_timeval_compare(&next_timeout->expiry, &tvnow);
    if(!(return_value_avahi_timeval_compare_1 >= 0))
    {
      start_timeout_callback(next_timeout);
      return (signed int)!(0 != 0);
    }

  }

  w = g->watches;
  for( ; !(w == ((struct AvahiWatch_0 *)NULL)); w = w->watches_next)
    if((signed int)w->pollfd.revents >= 1)
    {
      /* assertion w->callback */
      assert(w->callback != ((void (*)(struct AvahiWatch_0 *, signed int, enum anonymous, void *))NULL));
      enum anonymous return_value_map_events_from_glib_2;
      return_value_map_events_from_glib_2=map_events_from_glib(w->pollfd.revents);
      w->callback(w, w->pollfd.fd, return_value_map_events_from_glib_2, w->userdata);
      w->pollfd.revents = (unsigned short int)0;
      return (signed int)!(0 != 0);
    }

  return (signed int)!(0 != 0);
}

// dispatch_status
// file ../avahi-common/dbus-watch-glue.c line 310
static void dispatch_status(struct DBusConnection *connection, enum anonymous_27 new_status, void *userdata)
{
  struct anonymous_28 *d = (struct anonymous_28 *)userdata;
  if((signed int)new_status == DBUS_DISPATCH_DATA_REMAINS)
    request_dispatch(d, 1);

}

// dispatch_status_link1
// file ../avahi-common/dbus-watch-glue.c line 310
static void dispatch_status_link1(struct DBusConnection *connection_link1, enum anonymous_27 new_status_link1, void *userdata_link1)
{
  struct anonymous_28 *d_link1 = (struct anonymous_28 *)userdata_link1;
  if((signed int)new_status_link1 == DBUS_DISPATCH_DATA_REMAINS)
    request_dispatch_link1(d_link1, 1);

}

// dispatch_timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 97
static void dispatch_timeout_callback(struct AvahiTimeout_1 *t, void *userdata)
{
  struct anonymous_28 *d = (struct anonymous_28 *)userdata;
  /* assertion t */
  assert(t != ((struct AvahiTimeout_1 *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous_28 *)NULL));
  connection_data_ref(d);
  dbus_connection_ref(d->connection);
  enum anonymous_27 return_value_dbus_connection_dispatch_1;
  return_value_dbus_connection_dispatch_1=dbus_connection_dispatch(d->connection);
  if((signed int)return_value_dbus_connection_dispatch_1 == DBUS_DISPATCH_DATA_REMAINS)
    request_dispatch(d, 1);

  else
    request_dispatch(d, 0);
  dbus_connection_unref(d->connection);
  connection_data_unref(d);
}

// dispatch_timeout_callback_link1
// file ../avahi-common/dbus-watch-glue.c line 97
static void dispatch_timeout_callback_link1(struct AvahiTimeout_1 *t_link1, void *userdata_link1)
{
  struct anonymous_28 *d_link1 = (struct anonymous_28 *)userdata_link1;
  /* assertion t */
  assert(t_link1 != ((struct AvahiTimeout_1 *)NULL));
  /* assertion d */
  assert(d_link1 != ((struct anonymous_28 *)NULL));
  connection_data_ref_link1(d_link1);
  dbus_connection_ref(d_link1->connection);
  enum anonymous_27 return_value_dbus_connection_dispatch_1_link1;
  return_value_dbus_connection_dispatch_1_link1=dbus_connection_dispatch(d_link1->connection);
  if((signed int)return_value_dbus_connection_dispatch_1_link1 == DBUS_DISPATCH_DATA_REMAINS)
    request_dispatch_link1(d_link1, 1);

  else
    request_dispatch_link1(d_link1, 0);
  dbus_connection_unref(d_link1->connection);
  connection_data_unref_link1(d_link1);
}

// domain_browse_callback
// file avahi-ui.c line 559
static void domain_browse_callback(struct AvahiDomainBrowser *b, signed int interface, signed int protocol, enum anonymous_14 event, const char *name, enum anonymous_13 flags, void *userdata)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)userdata, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  struct _GtkTreeIter iter;
  signed int found;
  signed int valid;
  signed int ref;
  unsigned long int return_value_gtk_tree_model_get_type_3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  signed int domain_browse_callback__1__1__2__valid;
  struct _GtkTreeIter domain_browse_callback__1__1__2__iter;
  unsigned long int return_value_gtk_tree_model_get_type_9;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  switch((signed int)event)
  {
    case AVAHI_BROWSER_NEW:
    {
      found = 0;
      return_value_gtk_tree_model_get_type_3=gtk_tree_model_get_type();
      return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type_3);
      valid=gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_4, &iter);
      while(!(valid == 0))
      {
        char *_name;
        unsigned long int return_value_gtk_tree_model_get_type_5;
        return_value_gtk_tree_model_get_type_5=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
        return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type_5);
        gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_6, &iter, 0, &_name, 1, &ref, -1);
        found=avahi_domain_equal(_name, name);
        g_free((void *)_name);
        if(!(found == 0))
          break;

        unsigned long int return_value_gtk_tree_model_get_type_7;
        return_value_gtk_tree_model_get_type_7=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
        return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type_7);
        valid=gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_8, &iter);
      }
      if(!(found == 0))
        gtk_list_store_set(d->priv->domain_list_store, &iter, 1, ref + 1, -1);

      else
      {
        gtk_list_store_append(d->priv->domain_list_store, &iter);
        gtk_list_store_set(d->priv->domain_list_store, &iter, 0, name, 1, 1, -1);
      }
      domain_make_default_selection(d, name, &iter);
      goto __CPROVER_DUMP_L15;
    }
    case AVAHI_BROWSER_REMOVE:
    {
      return_value_gtk_tree_model_get_type_9=gtk_tree_model_get_type();
      return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type_9);
      domain_browse_callback__1__1__2__valid=gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_10, &domain_browse_callback__1__1__2__iter);
      while(!(domain_browse_callback__1__1__2__valid == 0))
      {
        signed int domain_browse_callback__1__1__2__1__ref;
        char *domain_browse_callback__1__1__2__1___name;
        signed int domain_browse_callback__1__1__2__1__found;
        unsigned long int return_value_gtk_tree_model_get_type_11;
        return_value_gtk_tree_model_get_type_11=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
        return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type_11);
        gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_12, &domain_browse_callback__1__1__2__iter, 0, &domain_browse_callback__1__1__2__1___name, 1, &domain_browse_callback__1__1__2__1__ref, -1);
        domain_browse_callback__1__1__2__1__found=avahi_domain_equal(domain_browse_callback__1__1__2__1___name, name);
        g_free((void *)domain_browse_callback__1__1__2__1___name);
        if(!(domain_browse_callback__1__1__2__1__found == 0))
        {
          if(!(domain_browse_callback__1__1__2__1__ref >= 2))
            gtk_list_store_remove(d->priv->service_list_store, &domain_browse_callback__1__1__2__iter);

          else
            gtk_list_store_set(d->priv->domain_list_store, &domain_browse_callback__1__1__2__iter, 1, domain_browse_callback__1__1__2__1__ref - 1, -1);
          break;
        }

        unsigned long int return_value_gtk_tree_model_get_type_13;
        return_value_gtk_tree_model_get_type_13=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
        return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type_13);
        domain_browse_callback__1__1__2__valid=gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_14, &domain_browse_callback__1__1__2__iter);
      }
      goto __CPROVER_DUMP_L15;
    }
    case AVAHI_BROWSER_FAILURE:
    {
      struct _GtkWidget *m;
      unsigned long int return_value_gtk_window_get_type_15;
      return_value_gtk_window_get_type_15=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
      return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type_15);
      char *return_value_dgettext_17;
      return_value_dgettext_17=dgettext("avahi", "Avahi domain browser failure: %s");
      signed int return_value_avahi_client_errno_18;
      return_value_avahi_client_errno_18=avahi_client_errno(d->priv->client);
      const char *return_value_avahi_strerror_19;
      return_value_avahi_strerror_19=avahi_strerror(return_value_avahi_client_errno_18);
      m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast_16, (enum anonymous_30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous_29)GTK_MESSAGE_ERROR, (enum anonymous_17)GTK_BUTTONS_CLOSE, return_value_dgettext_17, return_value_avahi_strerror_19);
      unsigned long int return_value_gtk_dialog_get_type_20;
      return_value_gtk_dialog_get_type_20=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_21;
      return_value_g_type_check_instance_cast_21=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type_20);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_21);
      gtk_widget_destroy(m);
    }
    case AVAHI_BROWSER_ALL_FOR_NOW:
      if(d->priv->domain_pulse_timeout >= 1u)
      {
        g_source_remove(d->priv->domain_pulse_timeout);
        d->priv->domain_pulse_timeout = (unsigned int)0;
        gtk_widget_hide(d->priv->domain_progress_bar);
      }

    case AVAHI_BROWSER_CACHE_EXHAUSTED:

    default:

      __CPROVER_DUMP_L15:
        ;
  }
}

// domain_browser_ref
// file browser.c line 77
static void domain_browser_ref(struct AvahiDomainBrowser *db)
{
  /* assertion db */
  assert(db != ((struct AvahiDomainBrowser *)NULL));
  /* assertion db->ref >= 1 */
  assert(db->ref >= 1);
  db->ref = db->ref + 1;
}

// domain_browser_ref_link1
// file browser.c line 77
static void domain_browser_ref_link1(struct AvahiDomainBrowser *db_link1)
{
  /* assertion db */
  assert(db_link1 != ((struct AvahiDomainBrowser *)NULL));
  /* assertion db->ref >= 1 */
  assert(db_link1->ref >= 1);
  db_link1->ref = db_link1->ref + 1;
}

// domain_button_clicked
// file avahi-ui.c line 959
static void domain_button_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkWidget *vbox;
  struct _GtkWidget *vbox2;
  struct _GtkWidget *scrolled_window;
  struct _GtkTreeSelection *selection;
  struct _GtkCellRenderer *renderer;
  struct _GtkTreeViewColumn *column;
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  struct _AuiServiceDialogPrivate *p = d->priv;
  const char *domain;
  struct _GtkTreeIter iter;
  do
    if(!(p->domain_dialog == ((struct _GtkWidget *)NULL)))
    {
      g_return_if_fail_warning((char *)0, (const char *)"domain_button_clicked", "!p->domain_dialog");
      goto __CPROVER_DUMP_L9;
    }

  while((_Bool)0);
  do
    if(!(p->domain_browser == ((struct AvahiDomainBrowser *)NULL)))
    {
      g_return_if_fail_warning((char *)0, (const char *)"domain_button_clicked", "!p->domain_browser");
      goto __CPROVER_DUMP_L9;
    }

  while((_Bool)0);
  domain=get_domain_name(d);
  if(domain == ((const char *)NULL))
  {
    unsigned long int return_value_gtk_dialog_get_type_3;
    return_value_gtk_dialog_get_type_3=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
    return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_3);
    gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_4, -6);
    goto __CPROVER_DUMP_L9;
  }

  p->domain_browser=avahi_domain_browser_new(p->client, -1, -1, (const char *)(void *)0, (enum anonymous_43)AVAHI_DOMAIN_BROWSER_BROWSE, (enum anonymous_44)0, domain_browse_callback, (void *)d);
  if(p->domain_browser == ((struct AvahiDomainBrowser *)NULL))
  {
    struct _GtkWidget *m;
    unsigned long int return_value_gtk_window_get_type_5;
    return_value_gtk_window_get_type_5=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
    return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type_5);
    char *return_value_dgettext_7;
    return_value_dgettext_7=dgettext("avahi", "Failed to create domain browser: %s");
    signed int return_value_avahi_client_errno_8;
    return_value_avahi_client_errno_8=avahi_client_errno(p->client);
    const char *return_value_avahi_strerror_9;
    return_value_avahi_strerror_9=avahi_strerror(return_value_avahi_client_errno_8);
    m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, (enum anonymous_30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous_29)GTK_MESSAGE_ERROR, (enum anonymous_17)GTK_BUTTONS_CLOSE, return_value_dgettext_7, return_value_avahi_strerror_9);
    unsigned long int return_value_gtk_dialog_get_type_10;
    return_value_gtk_dialog_get_type_10=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_11;
    return_value_g_type_check_instance_cast_11=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type_10);
    gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_11);
    gtk_widget_destroy(m);
    unsigned long int return_value_gtk_dialog_get_type_12;
    return_value_gtk_dialog_get_type_12=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_13;
    return_value_g_type_check_instance_cast_13=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_12);
    gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_13, -6);
    goto __CPROVER_DUMP_L9;
  }

  p->domain_dialog=gtk_dialog_new();
  unsigned long int return_value_gtk_container_get_type_14;
  return_value_gtk_container_get_type_14=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_15;
  return_value_g_type_check_instance_cast_15=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_container_get_type_14);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_15, (unsigned int)5);
  unsigned long int return_value_gtk_window_get_type_16;
  return_value_gtk_window_get_type_16=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_17;
  return_value_g_type_check_instance_cast_17=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_window_get_type_16);
  char *return_value_dgettext_18;
  return_value_dgettext_18=dgettext("avahi", "Change domain");
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_17, return_value_dgettext_18);
  vbox=gtk_box_new((enum anonymous_16)GTK_ORIENTATION_VERTICAL, 8);
  unsigned long int return_value_gtk_container_get_type_19;
  return_value_gtk_container_get_type_19=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
  return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_container_get_type_19);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_20, (unsigned int)8);
  unsigned long int return_value_gtk_dialog_get_type_21;
  return_value_gtk_dialog_get_type_21=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
  return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_dialog_get_type_21);
  struct _GtkWidget *return_value_gtk_dialog_get_content_area_23;
  return_value_gtk_dialog_get_content_area_23=gtk_dialog_get_content_area((struct _GtkDialog *)return_value_g_type_check_instance_cast_22);
  unsigned long int return_value_gtk_box_get_type_24;
  return_value_gtk_box_get_type_24=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_25;
  return_value_g_type_check_instance_cast_25=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_get_content_area_23, return_value_gtk_box_get_type_24);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_25, vbox, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  p->domain_entry=gtk_entry_new();
  unsigned long int return_value_gtk_entry_get_type_26;
  return_value_gtk_entry_get_type_26=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_27;
  return_value_g_type_check_instance_cast_27=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_entry, return_value_gtk_entry_get_type_26);
  gtk_entry_set_max_length((struct _GtkEntry *)return_value_g_type_check_instance_cast_27, 1014);
  unsigned long int return_value_gtk_entry_get_type_28;
  return_value_gtk_entry_get_type_28=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_29;
  return_value_g_type_check_instance_cast_29=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_entry, return_value_gtk_entry_get_type_28);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_29, domain);
  unsigned long int return_value_gtk_entry_get_type_30;
  return_value_gtk_entry_get_type_30=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_31;
  return_value_g_type_check_instance_cast_31=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_entry, return_value_gtk_entry_get_type_30);
  gtk_entry_set_activates_default((struct _GtkEntry *)return_value_g_type_check_instance_cast_31, (signed int)!(0 != 0));
  g_signal_connect_data((void *)p->domain_entry, "changed", (void (*)(void))domain_entry_changed_callback, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_7)0);
  unsigned long int return_value_gtk_box_get_type_32;
  return_value_gtk_box_get_type_32=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_33;
  return_value_g_type_check_instance_cast_33=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type_32);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_33, p->domain_entry, 0, 0, (unsigned int)0);
  vbox2=gtk_box_new((enum anonymous_16)GTK_ORIENTATION_VERTICAL, 8);
  unsigned long int return_value_gtk_box_get_type_34;
  return_value_gtk_box_get_type_34=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_35;
  return_value_g_type_check_instance_cast_35=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type_34);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_35, vbox2, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  scrolled_window=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
  unsigned long int return_value_gtk_scrolled_window_get_type_36;
  return_value_gtk_scrolled_window_get_type_36=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_37;
  return_value_g_type_check_instance_cast_37=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type_36);
  gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_37, (enum anonymous_2)GTK_POLICY_AUTOMATIC, (enum anonymous_2)GTK_POLICY_AUTOMATIC);
  unsigned long int return_value_gtk_scrolled_window_get_type_38;
  return_value_gtk_scrolled_window_get_type_38=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_39;
  return_value_g_type_check_instance_cast_39=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type_38);
  gtk_scrolled_window_set_shadow_type((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_39, (enum anonymous_5)GTK_SHADOW_ETCHED_IN);
  unsigned long int return_value_gtk_box_get_type_40;
  return_value_gtk_box_get_type_40=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_41;
  return_value_g_type_check_instance_cast_41=g_type_check_instance_cast((struct _GTypeInstance *)vbox2, return_value_gtk_box_get_type_40);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_41, scrolled_window, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  p->domain_list_store=gtk_list_store_new(2, (unsigned long int)(16 << 2), (unsigned long int)(6 << 2));
  unsigned long int return_value_gtk_tree_model_get_type_42;
  return_value_gtk_tree_model_get_type_42=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_43;
  return_value_g_type_check_instance_cast_43=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_list_store, return_value_gtk_tree_model_get_type_42);
  p->domain_tree_view=gtk_tree_view_new_with_model((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_43);
  unsigned long int return_value_gtk_tree_view_get_type_44;
  return_value_gtk_tree_view_get_type_44=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_45;
  return_value_g_type_check_instance_cast_45=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_tree_view, return_value_gtk_tree_view_get_type_44);
  gtk_tree_view_set_headers_visible((struct _GtkTreeView *)return_value_g_type_check_instance_cast_45, 0);
  g_signal_connect_data((void *)p->domain_tree_view, "row-activated", (void (*)(void))domain_row_activated_callback, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_7)0);
  unsigned long int return_value_gtk_tree_view_get_type_46;
  return_value_gtk_tree_view_get_type_46=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_47;
  return_value_g_type_check_instance_cast_47=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_tree_view, return_value_gtk_tree_view_get_type_46);
  selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast_47);
  gtk_tree_selection_set_mode(selection, (enum anonymous_1)GTK_SELECTION_BROWSE);
  g_signal_connect_data((void *)selection, "changed", (void (*)(void))domain_selection_changed_callback, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_7)0);
  renderer=gtk_cell_renderer_text_new();
  char *return_value_dgettext_48;
  return_value_dgettext_48=dgettext("avahi", "Service Name");
  column=gtk_tree_view_column_new_with_attributes(return_value_dgettext_48, renderer, (const void *)"text", 0, (void *)0);
  gtk_tree_view_column_set_expand(column, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_tree_view_get_type_49;
  return_value_gtk_tree_view_get_type_49=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_50;
  return_value_g_type_check_instance_cast_50=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_tree_view, return_value_gtk_tree_view_get_type_49);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_50, column);
  unsigned long int return_value_gtk_tree_view_get_type_51;
  return_value_gtk_tree_view_get_type_51=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_52;
  return_value_g_type_check_instance_cast_52=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_tree_view, return_value_gtk_tree_view_get_type_51);
  gtk_tree_view_set_search_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_52, 0);
  unsigned long int return_value_gtk_container_get_type_53;
  return_value_gtk_container_get_type_53=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_54;
  return_value_g_type_check_instance_cast_54=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_container_get_type_53);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_54, p->domain_tree_view);
  p->domain_progress_bar=gtk_progress_bar_new();
  unsigned long int return_value_gtk_progress_bar_get_type_55;
  return_value_gtk_progress_bar_get_type_55=gtk_progress_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_56;
  return_value_g_type_check_instance_cast_56=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_progress_bar, return_value_gtk_progress_bar_get_type_55);
  char *return_value_dgettext_57;
  return_value_dgettext_57=dgettext("avahi", "Browsing...");
  gtk_progress_bar_set_text((struct _GtkProgressBar *)return_value_g_type_check_instance_cast_56, return_value_dgettext_57);
  unsigned long int return_value_gtk_progress_bar_get_type_58;
  return_value_gtk_progress_bar_get_type_58=gtk_progress_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_59;
  return_value_g_type_check_instance_cast_59=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_progress_bar, return_value_gtk_progress_bar_get_type_58);
  gtk_progress_bar_set_pulse_step((struct _GtkProgressBar *)return_value_g_type_check_instance_cast_59, 0.1);
  unsigned long int return_value_gtk_box_get_type_60;
  return_value_gtk_box_get_type_60=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_61;
  return_value_g_type_check_instance_cast_61=g_type_check_instance_cast((struct _GTypeInstance *)vbox2, return_value_gtk_box_get_type_60);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast_61, p->domain_progress_bar, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_dialog_get_type_62;
  return_value_gtk_dialog_get_type_62=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_63;
  return_value_g_type_check_instance_cast_63=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_dialog_get_type_62);
  char *return_value_dgettext_64;
  return_value_dgettext_64=dgettext("avahi", "_Cancel");
  gtk_dialog_add_button((struct _GtkDialog *)return_value_g_type_check_instance_cast_63, return_value_dgettext_64, -6);
  unsigned long int return_value_gtk_dialog_get_type_65;
  return_value_gtk_dialog_get_type_65=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_66;
  return_value_g_type_check_instance_cast_66=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_dialog_get_type_65);
  char *return_value_dgettext_67;
  return_value_dgettext_67=dgettext("avahi", "_OK");
  struct _GtkWidget *return_value_gtk_dialog_add_button_68;
  return_value_gtk_dialog_add_button_68=gtk_dialog_add_button((struct _GtkDialog *)return_value_g_type_check_instance_cast_66, return_value_dgettext_67, -3);
  unsigned long int return_value_gtk_widget_get_type_69;
  return_value_gtk_widget_get_type_69=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_70;
  return_value_g_type_check_instance_cast_70=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_add_button_68, return_value_gtk_widget_get_type_69);
  p->domain_ok_button = (struct _GtkWidget *)return_value_g_type_check_instance_cast_70;
  unsigned long int return_value_gtk_dialog_get_type_71;
  return_value_gtk_dialog_get_type_71=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_72;
  return_value_g_type_check_instance_cast_72=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_dialog_get_type_71);
  gtk_dialog_set_default_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_72, -3);
  unsigned long int return_value_gtk_entry_get_type_73;
  return_value_gtk_entry_get_type_73=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_74;
  return_value_g_type_check_instance_cast_74=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_entry, return_value_gtk_entry_get_type_73);
  const char *return_value_gtk_entry_get_text_75;
  return_value_gtk_entry_get_text_75=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_74);
  signed int return_value_is_valid_domain_suffix_76;
  return_value_is_valid_domain_suffix_76=is_valid_domain_suffix(return_value_gtk_entry_get_text_75);
  gtk_widget_set_sensitive(p->domain_ok_button, return_value_is_valid_domain_suffix_76);
  gtk_widget_grab_default(p->domain_ok_button);
  gtk_widget_grab_focus(p->domain_entry);
  unsigned long int return_value_gtk_window_get_type_77;
  return_value_gtk_window_get_type_77=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_78;
  return_value_g_type_check_instance_cast_78=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_window_get_type_77);
  gtk_window_set_default_size((struct _GtkWindow *)return_value_g_type_check_instance_cast_78, 300, 300);
  gtk_widget_show_all(vbox);
  gtk_list_store_append(p->domain_list_store, &iter);
  gtk_list_store_set(p->domain_list_store, &iter, 0, (const void *)"local", 1, 1, -1);
  domain_make_default_selection(d, "local", &iter);
  p->domain_pulse_timeout=g_timeout_add((unsigned int)100, domain_pulse_callback, (void *)d);
  unsigned long int return_value_gtk_dialog_get_type_82;
  return_value_gtk_dialog_get_type_82=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_83;
  return_value_g_type_check_instance_cast_83=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_dialog_get_type_82);
  signed int return_value_gtk_dialog_run_84;
  return_value_gtk_dialog_run_84=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_83);
  unsigned long int return_value_gtk_entry_get_type_79;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_80;
  const char *return_value_gtk_entry_get_text_81;
  if(return_value_gtk_dialog_run_84 == -3)
  {
    return_value_gtk_entry_get_type_79=gtk_entry_get_type();
    return_value_g_type_check_instance_cast_80=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_entry, return_value_gtk_entry_get_type_79);
    return_value_gtk_entry_get_text_81=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_80);
    aui_service_dialog_set_domain(d, return_value_gtk_entry_get_text_81);
  }

  gtk_widget_destroy(p->domain_dialog);
  p->domain_dialog = (struct _GtkWidget *)(void *)0;
  if(p->domain_pulse_timeout >= 1u)
  {
    g_source_remove(p->domain_pulse_timeout);
    p->domain_pulse_timeout = (unsigned int)0;
  }

  avahi_domain_browser_free(p->domain_browser);
  p->domain_browser = (struct AvahiDomainBrowser *)(void *)0;

__CPROVER_DUMP_L9:
  ;
}

// domain_entry_changed_callback
// file avahi-ui.c line 953
static void domain_entry_changed_callback(struct _GtkEditable *editable, void *user_data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  unsigned long int return_value_gtk_entry_get_type_3;
  return_value_gtk_entry_get_type_3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_entry, return_value_gtk_entry_get_type_3);
  const char *return_value_gtk_entry_get_text_5;
  return_value_gtk_entry_get_text_5=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_4);
  signed int return_value_is_valid_domain_suffix_6;
  return_value_is_valid_domain_suffix_6=is_valid_domain_suffix(return_value_gtk_entry_get_text_5);
  gtk_widget_set_sensitive(d->priv->domain_ok_button, return_value_is_valid_domain_suffix_6);
}

// domain_make_default_selection
// file avahi-ui.c line 540
static void domain_make_default_selection(struct _AuiServiceDialog *d, const char *name, struct _GtkTreeIter *iter)
{
  struct _GtkTreeSelection *selection;
  unsigned long int return_value_gtk_tree_view_get_type_1;
  return_value_gtk_tree_view_get_type_1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_tree_view, return_value_gtk_tree_view_get_type_1);
  selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast_2);
  signed int return_value_gtk_tree_selection_get_selected_11;
  return_value_gtk_tree_selection_get_selected_11=gtk_tree_selection_get_selected(selection, (struct _GtkTreeModel **)(void *)0, (struct _GtkTreeIter *)(void *)0);
  if(return_value_gtk_tree_selection_get_selected_11 == 0)
  {
    unsigned long int return_value_gtk_entry_get_type_7;
    return_value_gtk_entry_get_type_7=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
    return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_entry, return_value_gtk_entry_get_type_7);
    const char *return_value_gtk_entry_get_text_9;
    return_value_gtk_entry_get_text_9=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_8);
    signed int return_value_avahi_domain_equal_10;
    return_value_avahi_domain_equal_10=avahi_domain_equal(return_value_gtk_entry_get_text_9, name);
    if(!(return_value_avahi_domain_equal_10 == 0))
    {
      struct _GtkTreePath *path;
      gtk_tree_selection_select_iter(selection, iter);
      unsigned long int return_value_gtk_tree_model_get_type_3;
      return_value_gtk_tree_model_get_type_3=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
      return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type_3);
      path=gtk_tree_model_get_path((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_4, iter);
      unsigned long int return_value_gtk_tree_view_get_type_5;
      return_value_gtk_tree_view_get_type_5=gtk_tree_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
      return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_tree_view, return_value_gtk_tree_view_get_type_5);
      gtk_tree_view_set_cursor((struct _GtkTreeView *)return_value_g_type_check_instance_cast_6, path, (struct _GtkTreeViewColumn *)(void *)0, 0);
      gtk_tree_path_free(path);
    }

  }

}

// domain_pulse_callback
// file avahi-ui.c line 311
static signed int domain_pulse_callback(void *data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)data, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  unsigned long int return_value_gtk_progress_bar_get_type_3;
  return_value_gtk_progress_bar_get_type_3=gtk_progress_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_progress_bar, return_value_gtk_progress_bar_get_type_3);
  gtk_progress_bar_pulse((struct _GtkProgressBar *)return_value_g_type_check_instance_cast_4);
  return (signed int)!(0 != 0);
}

// domain_row_activated_callback
// file avahi-ui.c line 933
static void domain_row_activated_callback(struct _GtkTreeView *tree_view, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  unsigned long int return_value_gtk_entry_get_type_5;
  return_value_gtk_entry_get_type_5=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_entry, return_value_gtk_entry_get_type_5);
  const char *return_value_gtk_entry_get_text_7;
  return_value_gtk_entry_get_text_7=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_6);
  signed int return_value_is_valid_domain_suffix_8;
  return_value_is_valid_domain_suffix_8=is_valid_domain_suffix(return_value_gtk_entry_get_text_7);
  unsigned long int return_value_gtk_dialog_get_type_3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  if(!(return_value_is_valid_domain_suffix_8 == 0))
  {
    return_value_gtk_dialog_get_type_3=gtk_dialog_get_type();
    return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_dialog, return_value_gtk_dialog_get_type_3);
    gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_4, -3);
  }

}

// domain_selection_changed_callback
// file avahi-ui.c line 940
static void domain_selection_changed_callback(struct _GtkTreeSelection *selection, void *user_data)
{
  struct _GtkTreeIter iter;
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  char *name;
  do
  {
    unsigned long int return_value_gtk_tree_view_get_type_3;
    return_value_gtk_tree_view_get_type_3=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
    return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_tree_view, return_value_gtk_tree_view_get_type_3);
    struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection_5;
    return_value_gtk_tree_view_get_selection_5=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast_4);
    signed int return_value_gtk_tree_selection_get_selected_6;
    return_value_gtk_tree_selection_get_selected_6=gtk_tree_selection_get_selected(return_value_gtk_tree_view_get_selection_5, (struct _GtkTreeModel **)(void *)0, &iter);
    if(return_value_gtk_tree_selection_get_selected_6 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"domain_selection_changed_callback", "gtk_tree_selection_get_selected(gtk_tree_view_get_selection(GTK_TREE_VIEW(d->priv->domain_tree_view)), NULL, &iter)");
      goto __CPROVER_DUMP_L3;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gtk_tree_model_get_type_7;
  return_value_gtk_tree_model_get_type_7=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type_7);
  gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_8, &iter, 0, &name, -1);
  unsigned long int return_value_gtk_entry_get_type_9;
  return_value_gtk_entry_get_type_9=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_entry, return_value_gtk_entry_get_type_9);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_10, name);

__CPROVER_DUMP_L3:
  ;
}

// drop_incomplete_utf8
// file alternative.c line 34
static void drop_incomplete_utf8(char *c)
{
  char *e;
  char *return_value_strchr_1;
  return_value_strchr_1=strchr(c, 0);
  e = return_value_strchr_1 - (signed long int)1;
  while(e >= c)
  {
    const char *return_value_avahi_utf8_valid_2;
    return_value_avahi_utf8_valid_2=avahi_utf8_valid(c);
    if(!(return_value_avahi_utf8_valid_2 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e & 128) != 0);
    *e = (char)0;
    e = e - 1l;
  }
}

// drop_incomplete_utf8_link1
// file alternative.c line 34
static void drop_incomplete_utf8_link1(char *c_link1)
{
  char *e_link1;
  char *return_value_strchr_1_link1;
  return_value_strchr_1_link1=strchr(c_link1, 0);
  e_link1 = return_value_strchr_1_link1 - (signed long int)1;
  while(e_link1 >= c_link1)
  {
    const char *return_value_avahi_utf8_valid_2_link1;
    return_value_avahi_utf8_valid_2_link1=avahi_utf8_valid(c_link1);
    if(!(return_value_avahi_utf8_valid_2_link1 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e_link1 & 128) != 0);
    *e_link1 = (char)0;
    e_link1 = e_link1 - 1l;
  }
}

// drop_incomplete_utf8_link1_link1
// file alternative.c line 34
static void drop_incomplete_utf8_link1_link1(char *c_link1_link1)
{
  char *e_link1_link1;
  char *return_value_strchr_1_link1_link1;
  return_value_strchr_1_link1_link1=strchr(c_link1_link1, 0);
  e_link1_link1 = return_value_strchr_1_link1_link1 - (signed long int)1;
  while(e_link1_link1 >= c_link1_link1)
  {
    const char *return_value_avahi_utf8_valid_2_link1_link1;
    return_value_avahi_utf8_valid_2_link1_link1=avahi_utf8_valid(c_link1_link1);
    if(!(return_value_avahi_utf8_valid_2_link1_link1 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e_link1_link1 & 128) != 0);
    *e_link1_link1 = (char)0;
    e_link1_link1 = e_link1_link1 - 1l;
  }
}

// drop_incomplete_utf8_link2
// file alternative.c line 34
static void drop_incomplete_utf8_link2(char *c_link2)
{
  char *e_link2;
  char *return_value_strchr_1_link2;
  return_value_strchr_1_link2=strchr(c_link2, 0);
  e_link2 = return_value_strchr_1_link2 - (signed long int)1;
  while(e_link2 >= c_link2)
  {
    const char *return_value_avahi_utf8_valid_2_link2;
    return_value_avahi_utf8_valid_2_link2=avahi_utf8_valid(c_link2);
    if(!(return_value_avahi_utf8_valid_2_link2 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e_link2 & 128) != 0);
    *e_link2 = (char)0;
    e_link2 = e_link2 - 1l;
  }
}

// drop_incomplete_utf8_link3
// file alternative.c line 34
static void drop_incomplete_utf8_link3(char *c_link3)
{
  char *e_link3;
  char *return_value_strchr_1_link3;
  return_value_strchr_1_link3=strchr(c_link3, 0);
  e_link3 = return_value_strchr_1_link3 - (signed long int)1;
  while(e_link3 >= c_link3)
  {
    const char *return_value_avahi_utf8_valid_2_link3;
    return_value_avahi_utf8_valid_2_link3=avahi_utf8_valid(c_link3);
    if(!(return_value_avahi_utf8_valid_2_link3 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e_link3 & 128) != 0);
    *e_link3 = (char)0;
    e_link3 = e_link3 - 1l;
  }
}

// entry_group_simple_method_call
// file entrygroup.c line 188
static signed int entry_group_simple_method_call(struct AvahiEntryGroup *group, const char *method)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  struct AvahiClient *client;
  dbus_error_init(&error);
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  client = group->client;
  message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", method);
  _Bool tmp_if_expr_2;
  unsigned int return_value_dbus_error_is_set_1;
  unsigned int return_value_dbus_message_get_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  if(message == ((struct DBusMessage *)NULL))
    r=avahi_client_set_errno(client, -24);

  else
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_1=dbus_error_is_set(&error);
      tmp_if_expr_2 = return_value_dbus_error_is_set_1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      r=avahi_client_set_errno(client, -22);

    else
    {
      return_value_dbus_message_get_args_3=dbus_message_get_args(reply, &error, (signed int)0);
      if(return_value_dbus_message_get_args_3 == 0u)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
        tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        r=avahi_client_set_errno(client, -22);

      else
      {
        dbus_message_unref(message);
        dbus_message_unref(reply);
        return 0;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_6;
  return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_6 == 0u))
  {
    r=avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return r;
}

// entry_group_simple_method_call_link1
// file entrygroup.c line 188
static signed int entry_group_simple_method_call_link1(struct AvahiEntryGroup *group_link1, const char *method_link1)
{
  struct DBusMessage *message_link1 = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply_link1 = (struct DBusMessage *)(void *)0;
  struct DBusError error_link1;
  signed int r_link1 = 0;
  struct AvahiClient *client_link1;
  dbus_error_init(&error_link1);
  /* assertion group */
  assert(group_link1 != ((struct AvahiEntryGroup *)NULL));
  client_link1 = group_link1->client;
  message_link1=dbus_message_new_method_call("org.freedesktop.Avahi", group_link1->path, "org.freedesktop.Avahi.EntryGroup", method_link1);
  _Bool tmp_if_expr_2_link1;
  unsigned int return_value_dbus_error_is_set_1_link1;
  unsigned int return_value_dbus_message_get_args_3_link1;
  _Bool tmp_if_expr_5_link1;
  unsigned int return_value_dbus_error_is_set_4_link1;
  if(message_link1 == ((struct DBusMessage *)NULL))
    r_link1=avahi_client_set_errno(client_link1, -24);

  else
  {
    reply_link1=dbus_connection_send_with_reply_and_block(client_link1->bus, message_link1, -1, &error_link1);
    if(reply_link1 == ((struct DBusMessage *)NULL))
      tmp_if_expr_2_link1 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_1_link1=dbus_error_is_set(&error_link1);
      tmp_if_expr_2_link1 = return_value_dbus_error_is_set_1_link1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2_link1)
      r_link1=avahi_client_set_errno(client_link1, -22);

    else
    {
      return_value_dbus_message_get_args_3_link1=dbus_message_get_args(reply_link1, &error_link1, (signed int)0);
      if(return_value_dbus_message_get_args_3_link1 == 0u)
        tmp_if_expr_5_link1 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4_link1=dbus_error_is_set(&error_link1);
        tmp_if_expr_5_link1 = return_value_dbus_error_is_set_4_link1 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5_link1)
        r_link1=avahi_client_set_errno(client_link1, -22);

      else
      {
        dbus_message_unref(message_link1);
        dbus_message_unref(reply_link1);
        return 0;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_6_link1;
  return_value_dbus_error_is_set_6_link1=dbus_error_is_set(&error_link1);
  if(!(return_value_dbus_error_is_set_6_link1 == 0u))
  {
    r_link1=avahi_client_set_dbus_error(client_link1, &error_link1);
    dbus_error_free(&error_link1);
  }

  if(!(message_link1 == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message_link1);

  if(!(reply_link1 == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply_link1);

  return r_link1;
}

// filter_func
// file client.c line 103
static enum anonymous_42 filter_func(struct DBusConnection *bus, struct DBusMessage *message, void *userdata)
{
  struct AvahiClient *client = (struct AvahiClient *)userdata;
  struct DBusError error;
  /* assertion bus */
  assert(bus != ((struct DBusConnection *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  unsigned int return_value_dbus_message_is_signal_75;
  return_value_dbus_message_is_signal_75=dbus_message_is_signal(message, "org.freedesktop.DBus.Local", "Disconnected");
  unsigned int return_value_dbus_message_is_signal_74;
  unsigned int return_value_dbus_message_is_signal_73;
  _Bool tmp_if_expr_3;
  unsigned int return_value_dbus_error_is_set_2;
  _Bool tmp_if_expr_6;
  signed int return_value_avahi_client_is_connected_5;
  _Bool tmp_if_expr_4;
  signed int return_value_avahi_client_is_connected_72;
  unsigned int return_value_dbus_message_is_signal_71;
  _Bool tmp_if_expr_10;
  unsigned int return_value_dbus_error_is_set_9;
  unsigned int return_value_dbus_message_is_signal_70;
  signed int return_value_strcmp_11;
  _Bool tmp_if_expr_14;
  unsigned int return_value_dbus_error_is_set_13;
  unsigned int return_value_dbus_message_is_signal_69;
  enum anonymous_42 return_value_avahi_domain_browser_event_15;
  unsigned int return_value_dbus_message_is_signal_68;
  enum anonymous_42 return_value_avahi_domain_browser_event_16;
  unsigned int return_value_dbus_message_is_signal_67;
  enum anonymous_42 return_value_avahi_domain_browser_event_17;
  unsigned int return_value_dbus_message_is_signal_66;
  enum anonymous_42 return_value_avahi_domain_browser_event_18;
  unsigned int return_value_dbus_message_is_signal_65;
  enum anonymous_42 return_value_avahi_domain_browser_event_19;
  unsigned int return_value_dbus_message_is_signal_64;
  enum anonymous_42 return_value_avahi_service_type_browser_event_20;
  unsigned int return_value_dbus_message_is_signal_63;
  enum anonymous_42 return_value_avahi_service_type_browser_event_21;
  unsigned int return_value_dbus_message_is_signal_62;
  enum anonymous_42 return_value_avahi_service_type_browser_event_22;
  unsigned int return_value_dbus_message_is_signal_61;
  enum anonymous_42 return_value_avahi_service_type_browser_event_23;
  unsigned int return_value_dbus_message_is_signal_60;
  enum anonymous_42 return_value_avahi_service_type_browser_event_24;
  unsigned int return_value_dbus_message_is_signal_59;
  enum anonymous_42 return_value_avahi_service_browser_event_25;
  unsigned int return_value_dbus_message_is_signal_58;
  enum anonymous_42 return_value_avahi_service_browser_event_26;
  unsigned int return_value_dbus_message_is_signal_57;
  enum anonymous_42 return_value_avahi_service_browser_event_27;
  unsigned int return_value_dbus_message_is_signal_56;
  enum anonymous_42 return_value_avahi_service_browser_event_28;
  unsigned int return_value_dbus_message_is_signal_55;
  enum anonymous_42 return_value_avahi_service_browser_event_29;
  unsigned int return_value_dbus_message_is_signal_54;
  enum anonymous_42 return_value_avahi_service_resolver_event_30;
  unsigned int return_value_dbus_message_is_signal_53;
  enum anonymous_42 return_value_avahi_service_resolver_event_31;
  unsigned int return_value_dbus_message_is_signal_52;
  enum anonymous_42 return_value_avahi_host_name_resolver_event_32;
  unsigned int return_value_dbus_message_is_signal_51;
  enum anonymous_42 return_value_avahi_host_name_resolver_event_33;
  unsigned int return_value_dbus_message_is_signal_50;
  enum anonymous_42 return_value_avahi_address_resolver_event_34;
  unsigned int return_value_dbus_message_is_signal_49;
  enum anonymous_42 return_value_avahi_address_resolver_event_35;
  unsigned int return_value_dbus_message_is_signal_48;
  enum anonymous_42 return_value_avahi_record_browser_event_36;
  unsigned int return_value_dbus_message_is_signal_47;
  enum anonymous_42 return_value_avahi_record_browser_event_37;
  unsigned int return_value_dbus_message_is_signal_46;
  enum anonymous_42 return_value_avahi_record_browser_event_38;
  unsigned int return_value_dbus_message_is_signal_45;
  enum anonymous_42 return_value_avahi_record_browser_event_39;
  unsigned int return_value_dbus_message_is_signal_44;
  enum anonymous_42 return_value_avahi_record_browser_event_40;
  if(!(return_value_dbus_message_is_signal_75 == 0u))
  {
    avahi_client_set_errno(client, -23);
    goto fail;
  }

  else
  {
    return_value_dbus_message_is_signal_74=dbus_message_is_signal(message, "org.freedesktop.DBus", "NameAcquired");
    if(return_value_dbus_message_is_signal_74 == 0u)
    {
      return_value_dbus_message_is_signal_73=dbus_message_is_signal(message, "org.freedesktop.DBus", "NameOwnerChanged");
      if(!(return_value_dbus_message_is_signal_73 == 0u))
      {
        char *name;
        char *old;
        char *new;
        unsigned int return_value_dbus_message_get_args_1;
        return_value_dbus_message_get_args_1=dbus_message_get_args(message, &error, (signed int)115, &name, (signed int)115, &old, (signed int)115, &new, (signed int)0);
        if(return_value_dbus_message_get_args_1 == 0u)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_2=dbus_error_is_set(&error);
          tmp_if_expr_3 = return_value_dbus_error_is_set_2 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          fprintf(stderr, "WARNING: Failed to parse NameOwnerChanged signal: %s\n", error.message);
          avahi_client_set_errno(client, -22);
          goto fail;
        }

        signed int return_value_strcmp_7;
        return_value_strcmp_7=strcmp(name, "org.freedesktop.Avahi");
        if(return_value_strcmp_7 == 0)
        {
          if(!(*old == 0))
          {
            return_value_avahi_client_is_connected_5=avahi_client_is_connected(client);
            tmp_if_expr_6 = return_value_avahi_client_is_connected_5 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_6 = (_Bool)0;
          if(tmp_if_expr_6)
          {
            avahi_client_set_errno(client, -23);
            goto fail;
          }

          else
            if((signed int)client->state == AVAHI_CLIENT_CONNECTING)
            {
              if(old == ((char *)NULL))
                tmp_if_expr_4 = (_Bool)1;

              else
                tmp_if_expr_4 = (signed int)*old == 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_4)
              {
                signed int ret;
                ret=init_server(client, (signed int *)(void *)0);
                if(!(ret >= 0))
                {
                  avahi_client_set_errno(client, ret);
                  goto fail;
                }

              }

            }

        }

      }

      else
      {
        return_value_avahi_client_is_connected_72=avahi_client_is_connected(client);
        if(!(return_value_avahi_client_is_connected_72 == 0))
        {
          return_value_dbus_message_is_signal_71=dbus_message_is_signal(message, "org.freedesktop.Avahi.Server", "StateChanged");
          if(!(return_value_dbus_message_is_signal_71 == 0u))
          {
            signed int state;
            char *e = (char *)(void *)0;
            signed int c;
            unsigned int return_value_dbus_message_get_args_8;
            return_value_dbus_message_get_args_8=dbus_message_get_args(message, &error, (signed int)105, &state, (signed int)115, &e, (signed int)0);
            if(return_value_dbus_message_get_args_8 == 0u)
              tmp_if_expr_10 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_9=dbus_error_is_set(&error);
              tmp_if_expr_10 = return_value_dbus_error_is_set_9 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_10)
            {
              fprintf(stderr, "WARNING: Failed to parse Server.StateChanged signal: %s\n", error.message);
              avahi_client_set_errno(client, -22);
              goto fail;
            }

            c=avahi_error_dbus_to_number(e);
            if(!(c == 0))
              avahi_client_set_errno(client, c);

            client_set_state(client, (enum anonymous_11)state);
          }

          else
          {
            return_value_dbus_message_is_signal_70=dbus_message_is_signal(message, "org.freedesktop.Avahi.EntryGroup", "StateChanged");
            if(!(return_value_dbus_message_is_signal_70 == 0u))
            {
              const char *path;
              struct AvahiEntryGroup *g;
              path=dbus_message_get_path(message);
              g = client->groups;
              for( ; !(g == ((struct AvahiEntryGroup *)NULL)); g = g->groups_next)
              {
                return_value_strcmp_11=strcmp(g->path, path);
                if(return_value_strcmp_11 == 0)
                  break;

              }
              if(!(g == ((struct AvahiEntryGroup *)NULL)))
              {
                signed int filter_func__1__6__2__state;
                char *filter_func__1__6__2__e;
                signed int filter_func__1__6__2__c;
                unsigned int return_value_dbus_message_get_args_12;
                return_value_dbus_message_get_args_12=dbus_message_get_args(message, &error, (signed int)105, &filter_func__1__6__2__state, (signed int)115, &filter_func__1__6__2__e, (signed int)0);
                if(return_value_dbus_message_get_args_12 == 0u)
                  tmp_if_expr_14 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set_13=dbus_error_is_set(&error);
                  tmp_if_expr_14 = return_value_dbus_error_is_set_13 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_14)
                {
                  fprintf(stderr, "WARNING: Failed to parse EntryGroup.StateChanged signal: %s\n", error.message);
                  avahi_client_set_errno(client, -22);
                  goto fail;
                }

                filter_func__1__6__2__c=avahi_error_dbus_to_number(filter_func__1__6__2__e);
                if(!(filter_func__1__6__2__c == 0))
                  avahi_client_set_errno(client, filter_func__1__6__2__c);

                avahi_entry_group_set_state(g, (enum anonymous_40)filter_func__1__6__2__state);
              }

            }

            else
            {
              return_value_dbus_message_is_signal_69=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "ItemNew");
              if(!(return_value_dbus_message_is_signal_69 == 0u))
              {
                return_value_avahi_domain_browser_event_15=avahi_domain_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_NEW, message);
                return return_value_avahi_domain_browser_event_15;
              }

              else
              {
                return_value_dbus_message_is_signal_68=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "ItemRemove");
                if(!(return_value_dbus_message_is_signal_68 == 0u))
                {
                  return_value_avahi_domain_browser_event_16=avahi_domain_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_REMOVE, message);
                  return return_value_avahi_domain_browser_event_16;
                }

                else
                {
                  return_value_dbus_message_is_signal_67=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "CacheExhausted");
                  if(!(return_value_dbus_message_is_signal_67 == 0u))
                  {
                    return_value_avahi_domain_browser_event_17=avahi_domain_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                    return return_value_avahi_domain_browser_event_17;
                  }

                  else
                  {
                    return_value_dbus_message_is_signal_66=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "AllForNow");
                    if(!(return_value_dbus_message_is_signal_66 == 0u))
                    {
                      return_value_avahi_domain_browser_event_18=avahi_domain_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_ALL_FOR_NOW, message);
                      return return_value_avahi_domain_browser_event_18;
                    }

                    else
                    {
                      return_value_dbus_message_is_signal_65=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "Failure");
                      if(!(return_value_dbus_message_is_signal_65 == 0u))
                      {
                        return_value_avahi_domain_browser_event_19=avahi_domain_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_FAILURE, message);
                        return return_value_avahi_domain_browser_event_19;
                      }

                      else
                      {
                        return_value_dbus_message_is_signal_64=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "ItemNew");
                        if(!(return_value_dbus_message_is_signal_64 == 0u))
                        {
                          return_value_avahi_service_type_browser_event_20=avahi_service_type_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_NEW, message);
                          return return_value_avahi_service_type_browser_event_20;
                        }

                        else
                        {
                          return_value_dbus_message_is_signal_63=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "ItemRemove");
                          if(!(return_value_dbus_message_is_signal_63 == 0u))
                          {
                            return_value_avahi_service_type_browser_event_21=avahi_service_type_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_REMOVE, message);
                            return return_value_avahi_service_type_browser_event_21;
                          }

                          else
                          {
                            return_value_dbus_message_is_signal_62=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "CacheExhausted");
                            if(!(return_value_dbus_message_is_signal_62 == 0u))
                            {
                              return_value_avahi_service_type_browser_event_22=avahi_service_type_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                              return return_value_avahi_service_type_browser_event_22;
                            }

                            else
                            {
                              return_value_dbus_message_is_signal_61=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "AllForNow");
                              if(!(return_value_dbus_message_is_signal_61 == 0u))
                              {
                                return_value_avahi_service_type_browser_event_23=avahi_service_type_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_ALL_FOR_NOW, message);
                                return return_value_avahi_service_type_browser_event_23;
                              }

                              else
                              {
                                return_value_dbus_message_is_signal_60=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "Failure");
                                if(!(return_value_dbus_message_is_signal_60 == 0u))
                                {
                                  return_value_avahi_service_type_browser_event_24=avahi_service_type_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_FAILURE, message);
                                  return return_value_avahi_service_type_browser_event_24;
                                }

                                else
                                {
                                  return_value_dbus_message_is_signal_59=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "ItemNew");
                                  if(!(return_value_dbus_message_is_signal_59 == 0u))
                                  {
                                    return_value_avahi_service_browser_event_25=avahi_service_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_NEW, message);
                                    return return_value_avahi_service_browser_event_25;
                                  }

                                  else
                                  {
                                    return_value_dbus_message_is_signal_58=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "ItemRemove");
                                    if(!(return_value_dbus_message_is_signal_58 == 0u))
                                    {
                                      return_value_avahi_service_browser_event_26=avahi_service_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_REMOVE, message);
                                      return return_value_avahi_service_browser_event_26;
                                    }

                                    else
                                    {
                                      return_value_dbus_message_is_signal_57=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "CacheExhausted");
                                      if(!(return_value_dbus_message_is_signal_57 == 0u))
                                      {
                                        return_value_avahi_service_browser_event_27=avahi_service_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                                        return return_value_avahi_service_browser_event_27;
                                      }

                                      else
                                      {
                                        return_value_dbus_message_is_signal_56=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "AllForNow");
                                        if(!(return_value_dbus_message_is_signal_56 == 0u))
                                        {
                                          return_value_avahi_service_browser_event_28=avahi_service_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_ALL_FOR_NOW, message);
                                          return return_value_avahi_service_browser_event_28;
                                        }

                                        else
                                        {
                                          return_value_dbus_message_is_signal_55=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "Failure");
                                          if(!(return_value_dbus_message_is_signal_55 == 0u))
                                          {
                                            return_value_avahi_service_browser_event_29=avahi_service_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_FAILURE, message);
                                            return return_value_avahi_service_browser_event_29;
                                          }

                                          else
                                          {
                                            return_value_dbus_message_is_signal_54=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceResolver", "Found");
                                            if(!(return_value_dbus_message_is_signal_54 == 0u))
                                            {
                                              return_value_avahi_service_resolver_event_30=avahi_service_resolver_event(client, (enum anonymous_12)AVAHI_RESOLVER_FOUND, message);
                                              return return_value_avahi_service_resolver_event_30;
                                            }

                                            else
                                            {
                                              return_value_dbus_message_is_signal_53=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceResolver", "Failure");
                                              if(!(return_value_dbus_message_is_signal_53 == 0u))
                                              {
                                                return_value_avahi_service_resolver_event_31=avahi_service_resolver_event(client, (enum anonymous_12)AVAHI_RESOLVER_FAILURE, message);
                                                return return_value_avahi_service_resolver_event_31;
                                              }

                                              else
                                              {
                                                return_value_dbus_message_is_signal_52=dbus_message_is_signal(message, "org.freedesktop.Avahi.HostNameResolver", "Found");
                                                if(!(return_value_dbus_message_is_signal_52 == 0u))
                                                {
                                                  return_value_avahi_host_name_resolver_event_32=avahi_host_name_resolver_event(client, (enum anonymous_12)AVAHI_RESOLVER_FOUND, message);
                                                  return return_value_avahi_host_name_resolver_event_32;
                                                }

                                                else
                                                {
                                                  return_value_dbus_message_is_signal_51=dbus_message_is_signal(message, "org.freedesktop.Avahi.HostNameResolver", "Failure");
                                                  if(!(return_value_dbus_message_is_signal_51 == 0u))
                                                  {
                                                    return_value_avahi_host_name_resolver_event_33=avahi_host_name_resolver_event(client, (enum anonymous_12)AVAHI_RESOLVER_FAILURE, message);
                                                    return return_value_avahi_host_name_resolver_event_33;
                                                  }

                                                  else
                                                  {
                                                    return_value_dbus_message_is_signal_50=dbus_message_is_signal(message, "org.freedesktop.Avahi.AddressResolver", "Found");
                                                    if(!(return_value_dbus_message_is_signal_50 == 0u))
                                                    {
                                                      return_value_avahi_address_resolver_event_34=avahi_address_resolver_event(client, (enum anonymous_12)AVAHI_RESOLVER_FOUND, message);
                                                      return return_value_avahi_address_resolver_event_34;
                                                    }

                                                    else
                                                    {
                                                      return_value_dbus_message_is_signal_49=dbus_message_is_signal(message, "org.freedesktop.Avahi.AddressResolver", "Failure");
                                                      if(!(return_value_dbus_message_is_signal_49 == 0u))
                                                      {
                                                        return_value_avahi_address_resolver_event_35=avahi_address_resolver_event(client, (enum anonymous_12)AVAHI_RESOLVER_FAILURE, message);
                                                        return return_value_avahi_address_resolver_event_35;
                                                      }

                                                      else
                                                      {
                                                        return_value_dbus_message_is_signal_48=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "ItemNew");
                                                        if(!(return_value_dbus_message_is_signal_48 == 0u))
                                                        {
                                                          return_value_avahi_record_browser_event_36=avahi_record_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_NEW, message);
                                                          return return_value_avahi_record_browser_event_36;
                                                        }

                                                        else
                                                        {
                                                          return_value_dbus_message_is_signal_47=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "ItemRemove");
                                                          if(!(return_value_dbus_message_is_signal_47 == 0u))
                                                          {
                                                            return_value_avahi_record_browser_event_37=avahi_record_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_REMOVE, message);
                                                            return return_value_avahi_record_browser_event_37;
                                                          }

                                                          else
                                                          {
                                                            return_value_dbus_message_is_signal_46=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "CacheExhausted");
                                                            if(!(return_value_dbus_message_is_signal_46 == 0u))
                                                            {
                                                              return_value_avahi_record_browser_event_38=avahi_record_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                                                              return return_value_avahi_record_browser_event_38;
                                                            }

                                                            else
                                                            {
                                                              return_value_dbus_message_is_signal_45=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "AllForNow");
                                                              if(!(return_value_dbus_message_is_signal_45 == 0u))
                                                              {
                                                                return_value_avahi_record_browser_event_39=avahi_record_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_ALL_FOR_NOW, message);
                                                                return return_value_avahi_record_browser_event_39;
                                                              }

                                                              else
                                                              {
                                                                return_value_dbus_message_is_signal_44=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "Failure");
                                                                if(!(return_value_dbus_message_is_signal_44 == 0u))
                                                                {
                                                                  return_value_avahi_record_browser_event_40=avahi_record_browser_event(client, (enum anonymous_14)AVAHI_BROWSER_FAILURE, message);
                                                                  return return_value_avahi_record_browser_event_40;
                                                                }

                                                                else
                                                                {
                                                                  const char *return_value_dbus_message_get_interface_41;
                                                                  return_value_dbus_message_get_interface_41=dbus_message_get_interface(message);
                                                                  const char *return_value_dbus_message_get_path_42;
                                                                  return_value_dbus_message_get_path_42=dbus_message_get_path(message);
                                                                  const char *return_value_dbus_message_get_member_43;
                                                                  return_value_dbus_message_get_member_43=dbus_message_get_member(message);
                                                                  fprintf(stderr, "WARNING: Unhandled message: interface=%s, path=%s, member=%s\n", return_value_dbus_message_get_interface_41, return_value_dbus_message_get_path_42, return_value_dbus_message_get_member_43);
                                                                  return (enum anonymous_42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

      }
    }

  }
  return (enum anonymous_42)DBUS_HANDLER_RESULT_HANDLED;

fail:
  ;
  unsigned int return_value_dbus_error_is_set_77;
  return_value_dbus_error_is_set_77=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_77 == 0u))
  {
    signed int return_value_avahi_error_dbus_to_number_76;
    return_value_avahi_error_dbus_to_number_76=avahi_error_dbus_to_number(error.name);
    avahi_client_set_errno(client, return_value_avahi_error_dbus_to_number_76);
    dbus_error_free(&error);
  }

  client_set_state(client, (enum anonymous_11)AVAHI_CLIENT_FAILURE);
  return (enum anonymous_42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}

// filter_func_link1
// file client.c line 103
static enum anonymous_42 filter_func_link1(struct DBusConnection *bus_link1, struct DBusMessage *message_link1, void *userdata_link1)
{
  struct AvahiClient *client_link1 = (struct AvahiClient *)userdata_link1;
  struct DBusError error_link1;
  /* assertion bus */
  assert(bus_link1 != ((struct DBusConnection *)NULL));
  /* assertion message */
  assert(message_link1 != ((struct DBusMessage *)NULL));
  dbus_error_init(&error_link1);
  unsigned int return_value_dbus_message_is_signal_75_link1;
  return_value_dbus_message_is_signal_75_link1=dbus_message_is_signal(message_link1, "org.freedesktop.DBus.Local", "Disconnected");
  unsigned int return_value_dbus_message_is_signal_74_link1;
  unsigned int return_value_dbus_message_is_signal_73_link1;
  _Bool tmp_if_expr_3_link1;
  unsigned int return_value_dbus_error_is_set_2_link1;
  _Bool tmp_if_expr_6_link1;
  signed int return_value_avahi_client_is_connected_5_link1;
  _Bool tmp_if_expr_4_link1;
  signed int return_value_avahi_client_is_connected_72_link1;
  unsigned int return_value_dbus_message_is_signal_71_link1;
  _Bool tmp_if_expr_10_link1;
  unsigned int return_value_dbus_error_is_set_9_link1;
  unsigned int return_value_dbus_message_is_signal_70_link1;
  signed int return_value_strcmp_11_link1;
  _Bool tmp_if_expr_14_link1;
  unsigned int return_value_dbus_error_is_set_13_link1;
  unsigned int return_value_dbus_message_is_signal_69_link1;
  enum anonymous_42 return_value_avahi_domain_browser_event_15_link1;
  unsigned int return_value_dbus_message_is_signal_68_link1;
  enum anonymous_42 return_value_avahi_domain_browser_event_16_link1;
  unsigned int return_value_dbus_message_is_signal_67_link1;
  enum anonymous_42 return_value_avahi_domain_browser_event_17_link1;
  unsigned int return_value_dbus_message_is_signal_66_link1;
  enum anonymous_42 return_value_avahi_domain_browser_event_18_link1;
  unsigned int return_value_dbus_message_is_signal_65_link1;
  enum anonymous_42 return_value_avahi_domain_browser_event_19_link1;
  unsigned int return_value_dbus_message_is_signal_64_link1;
  enum anonymous_42 return_value_avahi_service_type_browser_event_20_link1;
  unsigned int return_value_dbus_message_is_signal_63_link1;
  enum anonymous_42 return_value_avahi_service_type_browser_event_21_link1;
  unsigned int return_value_dbus_message_is_signal_62_link1;
  enum anonymous_42 return_value_avahi_service_type_browser_event_22_link1;
  unsigned int return_value_dbus_message_is_signal_61_link1;
  enum anonymous_42 return_value_avahi_service_type_browser_event_23_link1;
  unsigned int return_value_dbus_message_is_signal_60_link1;
  enum anonymous_42 return_value_avahi_service_type_browser_event_24_link1;
  unsigned int return_value_dbus_message_is_signal_59_link1;
  enum anonymous_42 return_value_avahi_service_browser_event_25_link1;
  unsigned int return_value_dbus_message_is_signal_58_link1;
  enum anonymous_42 return_value_avahi_service_browser_event_26_link1;
  unsigned int return_value_dbus_message_is_signal_57_link1;
  enum anonymous_42 return_value_avahi_service_browser_event_27_link1;
  unsigned int return_value_dbus_message_is_signal_56_link1;
  enum anonymous_42 return_value_avahi_service_browser_event_28_link1;
  unsigned int return_value_dbus_message_is_signal_55_link1;
  enum anonymous_42 return_value_avahi_service_browser_event_29_link1;
  unsigned int return_value_dbus_message_is_signal_54_link1;
  enum anonymous_42 return_value_avahi_service_resolver_event_30_link1;
  unsigned int return_value_dbus_message_is_signal_53_link1;
  enum anonymous_42 return_value_avahi_service_resolver_event_31_link1;
  unsigned int return_value_dbus_message_is_signal_52_link1;
  enum anonymous_42 return_value_avahi_host_name_resolver_event_32_link1;
  unsigned int return_value_dbus_message_is_signal_51_link1;
  enum anonymous_42 return_value_avahi_host_name_resolver_event_33_link1;
  unsigned int return_value_dbus_message_is_signal_50_link1;
  enum anonymous_42 return_value_avahi_address_resolver_event_34_link1;
  unsigned int return_value_dbus_message_is_signal_49_link1;
  enum anonymous_42 return_value_avahi_address_resolver_event_35_link1;
  unsigned int return_value_dbus_message_is_signal_48_link1;
  enum anonymous_42 return_value_avahi_record_browser_event_36_link1;
  unsigned int return_value_dbus_message_is_signal_47_link1;
  enum anonymous_42 return_value_avahi_record_browser_event_37_link1;
  unsigned int return_value_dbus_message_is_signal_46_link1;
  enum anonymous_42 return_value_avahi_record_browser_event_38_link1;
  unsigned int return_value_dbus_message_is_signal_45_link1;
  enum anonymous_42 return_value_avahi_record_browser_event_39_link1;
  unsigned int return_value_dbus_message_is_signal_44_link1;
  enum anonymous_42 return_value_avahi_record_browser_event_40_link1;
  if(!(return_value_dbus_message_is_signal_75_link1 == 0u))
  {
    avahi_client_set_errno(client_link1, -23);
    goto fail;
  }

  else
  {
    return_value_dbus_message_is_signal_74_link1=dbus_message_is_signal(message_link1, "org.freedesktop.DBus", "NameAcquired");
    if(return_value_dbus_message_is_signal_74_link1 == 0u)
    {
      return_value_dbus_message_is_signal_73_link1=dbus_message_is_signal(message_link1, "org.freedesktop.DBus", "NameOwnerChanged");
      if(!(return_value_dbus_message_is_signal_73_link1 == 0u))
      {
        char *name_link1;
        char *old_link1;
        char *new_link1;
        unsigned int return_value_dbus_message_get_args_1_link1;
        return_value_dbus_message_get_args_1_link1=dbus_message_get_args(message_link1, &error_link1, (signed int)115, &name_link1, (signed int)115, &old_link1, (signed int)115, &new_link1, (signed int)0);
        if(return_value_dbus_message_get_args_1_link1 == 0u)
          tmp_if_expr_3_link1 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set_2_link1=dbus_error_is_set(&error_link1);
          tmp_if_expr_3_link1 = return_value_dbus_error_is_set_2_link1 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3_link1)
        {
          fprintf(stderr, "WARNING: Failed to parse NameOwnerChanged signal: %s\n", error_link1.message);
          avahi_client_set_errno(client_link1, -22);
          goto fail;
        }

        signed int return_value_strcmp_7_link1;
        return_value_strcmp_7_link1=strcmp(name_link1, "org.freedesktop.Avahi");
        if(return_value_strcmp_7_link1 == 0)
        {
          if(!(*old_link1 == 0))
          {
            return_value_avahi_client_is_connected_5_link1=avahi_client_is_connected(client_link1);
            tmp_if_expr_6_link1 = return_value_avahi_client_is_connected_5_link1 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_6_link1 = (_Bool)0;
          if(tmp_if_expr_6_link1)
          {
            avahi_client_set_errno(client_link1, -23);
            goto fail;
          }

          else
            if((signed int)client_link1->state == AVAHI_CLIENT_CONNECTING)
            {
              if(old_link1 == ((char *)NULL))
                tmp_if_expr_4_link1 = (_Bool)1;

              else
                tmp_if_expr_4_link1 = (signed int)*old_link1 == 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_4_link1)
              {
                signed int ret_link1;
                ret_link1=init_server_link1(client_link1, (signed int *)(void *)0);
                if(!(ret_link1 >= 0))
                {
                  avahi_client_set_errno(client_link1, ret_link1);
                  goto fail;
                }

              }

            }

        }

      }

      else
      {
        return_value_avahi_client_is_connected_72_link1=avahi_client_is_connected(client_link1);
        if(!(return_value_avahi_client_is_connected_72_link1 == 0))
        {
          return_value_dbus_message_is_signal_71_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.Server", "StateChanged");
          if(!(return_value_dbus_message_is_signal_71_link1 == 0u))
          {
            signed int state_link1;
            char *e_link1 = (char *)(void *)0;
            signed int c_link1;
            unsigned int return_value_dbus_message_get_args_8_link1;
            return_value_dbus_message_get_args_8_link1=dbus_message_get_args(message_link1, &error_link1, (signed int)105, &state_link1, (signed int)115, &e_link1, (signed int)0);
            if(return_value_dbus_message_get_args_8_link1 == 0u)
              tmp_if_expr_10_link1 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set_9_link1=dbus_error_is_set(&error_link1);
              tmp_if_expr_10_link1 = return_value_dbus_error_is_set_9_link1 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_10_link1)
            {
              fprintf(stderr, "WARNING: Failed to parse Server.StateChanged signal: %s\n", error_link1.message);
              avahi_client_set_errno(client_link1, -22);
              goto fail;
            }

            c_link1=avahi_error_dbus_to_number(e_link1);
            if(!(c_link1 == 0))
              avahi_client_set_errno(client_link1, c_link1);

            client_set_state_link1(client_link1, (enum anonymous_11)state_link1);
          }

          else
          {
            return_value_dbus_message_is_signal_70_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.EntryGroup", "StateChanged");
            if(!(return_value_dbus_message_is_signal_70_link1 == 0u))
            {
              const char *path_link1;
              struct AvahiEntryGroup *g_link1;
              path_link1=dbus_message_get_path(message_link1);
              g_link1 = client_link1->groups;
              for( ; !(g_link1 == ((struct AvahiEntryGroup *)NULL)); g_link1 = g_link1->groups_next)
              {
                return_value_strcmp_11_link1=strcmp(g_link1->path, path_link1);
                if(return_value_strcmp_11_link1 == 0)
                  break;

              }
              if(!(g_link1 == ((struct AvahiEntryGroup *)NULL)))
              {
                signed int filter_func__1__6__2__state_link1;
                char *filter_func__1__6__2__e_link1;
                signed int filter_func__1__6__2__c_link1;
                unsigned int return_value_dbus_message_get_args_12_link1;
                return_value_dbus_message_get_args_12_link1=dbus_message_get_args(message_link1, &error_link1, (signed int)105, &filter_func__1__6__2__state_link1, (signed int)115, &filter_func__1__6__2__e_link1, (signed int)0);
                if(return_value_dbus_message_get_args_12_link1 == 0u)
                  tmp_if_expr_14_link1 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set_13_link1=dbus_error_is_set(&error_link1);
                  tmp_if_expr_14_link1 = return_value_dbus_error_is_set_13_link1 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_14_link1)
                {
                  fprintf(stderr, "WARNING: Failed to parse EntryGroup.StateChanged signal: %s\n", error_link1.message);
                  avahi_client_set_errno(client_link1, -22);
                  goto fail;
                }

                filter_func__1__6__2__c_link1=avahi_error_dbus_to_number(filter_func__1__6__2__e_link1);
                if(!(filter_func__1__6__2__c_link1 == 0))
                  avahi_client_set_errno(client_link1, filter_func__1__6__2__c_link1);

                avahi_entry_group_set_state(g_link1, (enum anonymous_40)filter_func__1__6__2__state_link1);
              }

            }

            else
            {
              return_value_dbus_message_is_signal_69_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.DomainBrowser", "ItemNew");
              if(!(return_value_dbus_message_is_signal_69_link1 == 0u))
              {
                return_value_avahi_domain_browser_event_15_link1=avahi_domain_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_NEW, message_link1);
                return return_value_avahi_domain_browser_event_15_link1;
              }

              else
              {
                return_value_dbus_message_is_signal_68_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.DomainBrowser", "ItemRemove");
                if(!(return_value_dbus_message_is_signal_68_link1 == 0u))
                {
                  return_value_avahi_domain_browser_event_16_link1=avahi_domain_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_REMOVE, message_link1);
                  return return_value_avahi_domain_browser_event_16_link1;
                }

                else
                {
                  return_value_dbus_message_is_signal_67_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.DomainBrowser", "CacheExhausted");
                  if(!(return_value_dbus_message_is_signal_67_link1 == 0u))
                  {
                    return_value_avahi_domain_browser_event_17_link1=avahi_domain_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_CACHE_EXHAUSTED, message_link1);
                    return return_value_avahi_domain_browser_event_17_link1;
                  }

                  else
                  {
                    return_value_dbus_message_is_signal_66_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.DomainBrowser", "AllForNow");
                    if(!(return_value_dbus_message_is_signal_66_link1 == 0u))
                    {
                      return_value_avahi_domain_browser_event_18_link1=avahi_domain_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_ALL_FOR_NOW, message_link1);
                      return return_value_avahi_domain_browser_event_18_link1;
                    }

                    else
                    {
                      return_value_dbus_message_is_signal_65_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.DomainBrowser", "Failure");
                      if(!(return_value_dbus_message_is_signal_65_link1 == 0u))
                      {
                        return_value_avahi_domain_browser_event_19_link1=avahi_domain_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_FAILURE, message_link1);
                        return return_value_avahi_domain_browser_event_19_link1;
                      }

                      else
                      {
                        return_value_dbus_message_is_signal_64_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.ServiceTypeBrowser", "ItemNew");
                        if(!(return_value_dbus_message_is_signal_64_link1 == 0u))
                        {
                          return_value_avahi_service_type_browser_event_20_link1=avahi_service_type_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_NEW, message_link1);
                          return return_value_avahi_service_type_browser_event_20_link1;
                        }

                        else
                        {
                          return_value_dbus_message_is_signal_63_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.ServiceTypeBrowser", "ItemRemove");
                          if(!(return_value_dbus_message_is_signal_63_link1 == 0u))
                          {
                            return_value_avahi_service_type_browser_event_21_link1=avahi_service_type_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_REMOVE, message_link1);
                            return return_value_avahi_service_type_browser_event_21_link1;
                          }

                          else
                          {
                            return_value_dbus_message_is_signal_62_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.ServiceTypeBrowser", "CacheExhausted");
                            if(!(return_value_dbus_message_is_signal_62_link1 == 0u))
                            {
                              return_value_avahi_service_type_browser_event_22_link1=avahi_service_type_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_CACHE_EXHAUSTED, message_link1);
                              return return_value_avahi_service_type_browser_event_22_link1;
                            }

                            else
                            {
                              return_value_dbus_message_is_signal_61_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.ServiceTypeBrowser", "AllForNow");
                              if(!(return_value_dbus_message_is_signal_61_link1 == 0u))
                              {
                                return_value_avahi_service_type_browser_event_23_link1=avahi_service_type_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_ALL_FOR_NOW, message_link1);
                                return return_value_avahi_service_type_browser_event_23_link1;
                              }

                              else
                              {
                                return_value_dbus_message_is_signal_60_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.ServiceTypeBrowser", "Failure");
                                if(!(return_value_dbus_message_is_signal_60_link1 == 0u))
                                {
                                  return_value_avahi_service_type_browser_event_24_link1=avahi_service_type_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_FAILURE, message_link1);
                                  return return_value_avahi_service_type_browser_event_24_link1;
                                }

                                else
                                {
                                  return_value_dbus_message_is_signal_59_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.ServiceBrowser", "ItemNew");
                                  if(!(return_value_dbus_message_is_signal_59_link1 == 0u))
                                  {
                                    return_value_avahi_service_browser_event_25_link1=avahi_service_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_NEW, message_link1);
                                    return return_value_avahi_service_browser_event_25_link1;
                                  }

                                  else
                                  {
                                    return_value_dbus_message_is_signal_58_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.ServiceBrowser", "ItemRemove");
                                    if(!(return_value_dbus_message_is_signal_58_link1 == 0u))
                                    {
                                      return_value_avahi_service_browser_event_26_link1=avahi_service_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_REMOVE, message_link1);
                                      return return_value_avahi_service_browser_event_26_link1;
                                    }

                                    else
                                    {
                                      return_value_dbus_message_is_signal_57_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.ServiceBrowser", "CacheExhausted");
                                      if(!(return_value_dbus_message_is_signal_57_link1 == 0u))
                                      {
                                        return_value_avahi_service_browser_event_27_link1=avahi_service_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_CACHE_EXHAUSTED, message_link1);
                                        return return_value_avahi_service_browser_event_27_link1;
                                      }

                                      else
                                      {
                                        return_value_dbus_message_is_signal_56_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.ServiceBrowser", "AllForNow");
                                        if(!(return_value_dbus_message_is_signal_56_link1 == 0u))
                                        {
                                          return_value_avahi_service_browser_event_28_link1=avahi_service_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_ALL_FOR_NOW, message_link1);
                                          return return_value_avahi_service_browser_event_28_link1;
                                        }

                                        else
                                        {
                                          return_value_dbus_message_is_signal_55_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.ServiceBrowser", "Failure");
                                          if(!(return_value_dbus_message_is_signal_55_link1 == 0u))
                                          {
                                            return_value_avahi_service_browser_event_29_link1=avahi_service_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_FAILURE, message_link1);
                                            return return_value_avahi_service_browser_event_29_link1;
                                          }

                                          else
                                          {
                                            return_value_dbus_message_is_signal_54_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.ServiceResolver", "Found");
                                            if(!(return_value_dbus_message_is_signal_54_link1 == 0u))
                                            {
                                              return_value_avahi_service_resolver_event_30_link1=avahi_service_resolver_event(client_link1, (enum anonymous_12)AVAHI_RESOLVER_FOUND, message_link1);
                                              return return_value_avahi_service_resolver_event_30_link1;
                                            }

                                            else
                                            {
                                              return_value_dbus_message_is_signal_53_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.ServiceResolver", "Failure");
                                              if(!(return_value_dbus_message_is_signal_53_link1 == 0u))
                                              {
                                                return_value_avahi_service_resolver_event_31_link1=avahi_service_resolver_event(client_link1, (enum anonymous_12)AVAHI_RESOLVER_FAILURE, message_link1);
                                                return return_value_avahi_service_resolver_event_31_link1;
                                              }

                                              else
                                              {
                                                return_value_dbus_message_is_signal_52_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.HostNameResolver", "Found");
                                                if(!(return_value_dbus_message_is_signal_52_link1 == 0u))
                                                {
                                                  return_value_avahi_host_name_resolver_event_32_link1=avahi_host_name_resolver_event(client_link1, (enum anonymous_12)AVAHI_RESOLVER_FOUND, message_link1);
                                                  return return_value_avahi_host_name_resolver_event_32_link1;
                                                }

                                                else
                                                {
                                                  return_value_dbus_message_is_signal_51_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.HostNameResolver", "Failure");
                                                  if(!(return_value_dbus_message_is_signal_51_link1 == 0u))
                                                  {
                                                    return_value_avahi_host_name_resolver_event_33_link1=avahi_host_name_resolver_event(client_link1, (enum anonymous_12)AVAHI_RESOLVER_FAILURE, message_link1);
                                                    return return_value_avahi_host_name_resolver_event_33_link1;
                                                  }

                                                  else
                                                  {
                                                    return_value_dbus_message_is_signal_50_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.AddressResolver", "Found");
                                                    if(!(return_value_dbus_message_is_signal_50_link1 == 0u))
                                                    {
                                                      return_value_avahi_address_resolver_event_34_link1=avahi_address_resolver_event(client_link1, (enum anonymous_12)AVAHI_RESOLVER_FOUND, message_link1);
                                                      return return_value_avahi_address_resolver_event_34_link1;
                                                    }

                                                    else
                                                    {
                                                      return_value_dbus_message_is_signal_49_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.AddressResolver", "Failure");
                                                      if(!(return_value_dbus_message_is_signal_49_link1 == 0u))
                                                      {
                                                        return_value_avahi_address_resolver_event_35_link1=avahi_address_resolver_event(client_link1, (enum anonymous_12)AVAHI_RESOLVER_FAILURE, message_link1);
                                                        return return_value_avahi_address_resolver_event_35_link1;
                                                      }

                                                      else
                                                      {
                                                        return_value_dbus_message_is_signal_48_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.RecordBrowser", "ItemNew");
                                                        if(!(return_value_dbus_message_is_signal_48_link1 == 0u))
                                                        {
                                                          return_value_avahi_record_browser_event_36_link1=avahi_record_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_NEW, message_link1);
                                                          return return_value_avahi_record_browser_event_36_link1;
                                                        }

                                                        else
                                                        {
                                                          return_value_dbus_message_is_signal_47_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.RecordBrowser", "ItemRemove");
                                                          if(!(return_value_dbus_message_is_signal_47_link1 == 0u))
                                                          {
                                                            return_value_avahi_record_browser_event_37_link1=avahi_record_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_REMOVE, message_link1);
                                                            return return_value_avahi_record_browser_event_37_link1;
                                                          }

                                                          else
                                                          {
                                                            return_value_dbus_message_is_signal_46_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.RecordBrowser", "CacheExhausted");
                                                            if(!(return_value_dbus_message_is_signal_46_link1 == 0u))
                                                            {
                                                              return_value_avahi_record_browser_event_38_link1=avahi_record_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_CACHE_EXHAUSTED, message_link1);
                                                              return return_value_avahi_record_browser_event_38_link1;
                                                            }

                                                            else
                                                            {
                                                              return_value_dbus_message_is_signal_45_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.RecordBrowser", "AllForNow");
                                                              if(!(return_value_dbus_message_is_signal_45_link1 == 0u))
                                                              {
                                                                return_value_avahi_record_browser_event_39_link1=avahi_record_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_ALL_FOR_NOW, message_link1);
                                                                return return_value_avahi_record_browser_event_39_link1;
                                                              }

                                                              else
                                                              {
                                                                return_value_dbus_message_is_signal_44_link1=dbus_message_is_signal(message_link1, "org.freedesktop.Avahi.RecordBrowser", "Failure");
                                                                if(!(return_value_dbus_message_is_signal_44_link1 == 0u))
                                                                {
                                                                  return_value_avahi_record_browser_event_40_link1=avahi_record_browser_event(client_link1, (enum anonymous_14)AVAHI_BROWSER_FAILURE, message_link1);
                                                                  return return_value_avahi_record_browser_event_40_link1;
                                                                }

                                                                else
                                                                {
                                                                  const char *return_value_dbus_message_get_interface_41_link1;
                                                                  return_value_dbus_message_get_interface_41_link1=dbus_message_get_interface(message_link1);
                                                                  const char *return_value_dbus_message_get_path_42_link1;
                                                                  return_value_dbus_message_get_path_42_link1=dbus_message_get_path(message_link1);
                                                                  const char *return_value_dbus_message_get_member_43_link1;
                                                                  return_value_dbus_message_get_member_43_link1=dbus_message_get_member(message_link1);
                                                                  fprintf(stderr, "WARNING: Unhandled message: interface=%s, path=%s, member=%s\n", return_value_dbus_message_get_interface_41_link1, return_value_dbus_message_get_path_42_link1, return_value_dbus_message_get_member_43_link1);
                                                                  return (enum anonymous_42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

      }
    }

  }
  return (enum anonymous_42)DBUS_HANDLER_RESULT_HANDLED;

fail:
  ;
  unsigned int return_value_dbus_error_is_set_77_link1;
  return_value_dbus_error_is_set_77_link1=dbus_error_is_set(&error_link1);
  if(!(return_value_dbus_error_is_set_77_link1 == 0u))
  {
    signed int return_value_avahi_error_dbus_to_number_76_link1;
    return_value_avahi_error_dbus_to_number_76_link1=avahi_error_dbus_to_number(error_link1.name);
    avahi_client_set_errno(client_link1, return_value_avahi_error_dbus_to_number_76_link1);
    dbus_error_free(&error_link1);
  }

  client_set_state_link1(client_link1, (enum anonymous_11)AVAHI_CLIENT_FAILURE);
  return (enum anonymous_42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}

// find_next_timeout
// file simple-watch.c line 425
static struct AvahiTimeout_1 * find_next_timeout(struct AvahiSimplePoll_0 *s)
{
  struct AvahiTimeout_1 *t;
  struct AvahiTimeout_1 *n = (struct AvahiTimeout_1 *)(void *)0;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  t = s->timeouts;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  signed int return_value_avahi_timeval_compare_2;
  for( ; !(t == ((struct AvahiTimeout_1 *)NULL)); t = t->timeouts_next)
  {
    if(!(t->dead == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = !(t->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1)
    {
      if(n == ((struct AvahiTimeout_1 *)NULL))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare_2=avahi_timeval_compare(&t->expiry, &n->expiry);
        tmp_if_expr_3 = return_value_avahi_timeval_compare_2 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        n = t;

    }

  }
  return n;
}

// find_next_timeout_link1
// file simple-watch.c line 425
static struct AvahiTimeout_1 * find_next_timeout_link1(struct AvahiSimplePoll_0 *s_link1)
{
  struct AvahiTimeout_1 *t_link1;
  struct AvahiTimeout_1 *n_link1 = (struct AvahiTimeout_1 *)(void *)0;
  /* assertion s */
  assert(s_link1 != ((struct AvahiSimplePoll_0 *)NULL));
  t_link1 = s_link1->timeouts;
  _Bool tmp_if_expr_1_link1;
  _Bool tmp_if_expr_3_link1;
  signed int return_value_avahi_timeval_compare_2_link1;
  for( ; !(t_link1 == ((struct AvahiTimeout_1 *)NULL)); t_link1 = t_link1->timeouts_next)
  {
    if(!(t_link1->dead == 0))
      tmp_if_expr_1_link1 = (_Bool)1;

    else
      tmp_if_expr_1_link1 = !(t_link1->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1_link1)
    {
      if(n_link1 == ((struct AvahiTimeout_1 *)NULL))
        tmp_if_expr_3_link1 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare_2_link1=avahi_timeval_compare(&t_link1->expiry, &n_link1->expiry);
        tmp_if_expr_3_link1 = return_value_avahi_timeval_compare_2_link1 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3_link1)
        n_link1 = t_link1;

    }

  }
  return n_link1;
}

// find_next_timeout_link1_link1
// file simple-watch.c line 425
static struct AvahiTimeout_0 * find_next_timeout_link1_link1(struct AvahiSimplePoll *s_link2)
{
  struct AvahiTimeout_0 *t_link1_link1;
  struct AvahiTimeout_0 *n_link1_link1 = (struct AvahiTimeout_0 *)(void *)0;
  /* assertion s */
  assert(s_link2 != ((struct AvahiSimplePoll *)NULL));
  t_link1_link1 = s_link2->timeouts;
  _Bool tmp_if_expr_1_link1_link1;
  _Bool tmp_if_expr_3_link1_link1;
  signed int return_value_avahi_timeval_compare_2_link1_link1;
  for( ; !(t_link1_link1 == ((struct AvahiTimeout_0 *)NULL)); t_link1_link1 = t_link1_link1->timeouts_next)
  {
    if(!(t_link1_link1->dead == 0))
      tmp_if_expr_1_link1_link1 = (_Bool)1;

    else
      tmp_if_expr_1_link1_link1 = !(t_link1_link1->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1_link1_link1)
    {
      if(n_link1_link1 == ((struct AvahiTimeout_0 *)NULL))
        tmp_if_expr_3_link1_link1 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare_2_link1_link1=avahi_timeval_compare(&t_link1_link1->expiry, &n_link1_link1->expiry);
        tmp_if_expr_3_link1_link1 = return_value_avahi_timeval_compare_2_link1_link1 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3_link1_link1)
        n_link1_link1 = t_link1_link1;

    }

  }
  return n_link1_link1;
}

// find_next_timeout_link1_link2
// file simple-watch.c line 425
static struct AvahiTimeout_1 * find_next_timeout_link1_link2(struct AvahiSimplePoll_0 *s_link1_link1)
{
  struct AvahiTimeout_1 *t_link1_link2;
  struct AvahiTimeout_1 *n_link1_link2 = (struct AvahiTimeout_1 *)(void *)0;
  /* assertion s */
  assert(s_link1_link1 != ((struct AvahiSimplePoll_0 *)NULL));
  t_link1_link2 = s_link1_link1->timeouts;
  _Bool tmp_if_expr_1_link1_link2;
  _Bool tmp_if_expr_3_link1_link2;
  signed int return_value_avahi_timeval_compare_2_link1_link2;
  for( ; !(t_link1_link2 == ((struct AvahiTimeout_1 *)NULL)); t_link1_link2 = t_link1_link2->timeouts_next)
  {
    if(!(t_link1_link2->dead == 0))
      tmp_if_expr_1_link1_link2 = (_Bool)1;

    else
      tmp_if_expr_1_link1_link2 = !(t_link1_link2->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1_link1_link2)
    {
      if(n_link1_link2 == ((struct AvahiTimeout_1 *)NULL))
        tmp_if_expr_3_link1_link2 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare_2_link1_link2=avahi_timeval_compare(&t_link1_link2->expiry, &n_link1_link2->expiry);
        tmp_if_expr_3_link1_link2 = return_value_avahi_timeval_compare_2_link1_link2 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3_link1_link2)
        n_link1_link2 = t_link1_link2;

    }

  }
  return n_link1_link2;
}

// find_next_timeout_link2
// file glib-watch.c line 230
static struct AvahiTimeout * find_next_timeout_link2(struct AvahiGLibPoll *g)
{
  struct AvahiTimeout *t_link2;
  struct AvahiTimeout *n_link2 = (struct AvahiTimeout *)(void *)0;
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  t_link2 = g->timeouts;
  _Bool tmp_if_expr_1_link2;
  _Bool tmp_if_expr_3_link2;
  signed int return_value_avahi_timeval_compare_2_link2;
  for( ; !(t_link2 == ((struct AvahiTimeout *)NULL)); t_link2 = t_link2->timeouts_next)
  {
    if(!(t_link2->dead == 0))
      tmp_if_expr_1_link2 = (_Bool)1;

    else
      tmp_if_expr_1_link2 = !(t_link2->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1_link2)
    {
      if(n_link2 == ((struct AvahiTimeout *)NULL))
        tmp_if_expr_3_link2 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare_2_link2=avahi_timeval_compare(&t_link2->expiry, &n_link2->expiry);
        tmp_if_expr_3_link2 = return_value_avahi_timeval_compare_2_link2 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3_link2)
        n_link2 = t_link2;

    }

  }
  return n_link2;
}

// find_next_timeout_link3
// file simple-watch.c line 425
static struct AvahiTimeout_1 * find_next_timeout_link3(struct AvahiSimplePoll_0 *s_link3)
{
  struct AvahiTimeout_1 *t_link3;
  struct AvahiTimeout_1 *n_link3 = (struct AvahiTimeout_1 *)(void *)0;
  /* assertion s */
  assert(s_link3 != ((struct AvahiSimplePoll_0 *)NULL));
  t_link3 = s_link3->timeouts;
  _Bool tmp_if_expr_1_link3;
  _Bool tmp_if_expr_3_link3;
  signed int return_value_avahi_timeval_compare_2_link3;
  for( ; !(t_link3 == ((struct AvahiTimeout_1 *)NULL)); t_link3 = t_link3->timeouts_next)
  {
    if(!(t_link3->dead == 0))
      tmp_if_expr_1_link3 = (_Bool)1;

    else
      tmp_if_expr_1_link3 = !(t_link3->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1_link3)
    {
      if(n_link3 == ((struct AvahiTimeout_1 *)NULL))
        tmp_if_expr_3_link3 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare_2_link3=avahi_timeval_compare(&t_link3->expiry, &n_link3->expiry);
        tmp_if_expr_3_link3 = return_value_avahi_timeval_compare_2_link3 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3_link3)
        n_link3 = t_link3;

    }

  }
  return n_link3;
}

// get_default_response
// file avahi-ui.c line 128
static signed int get_default_response(struct _GtkDialog *dlg)
{
  signed int ret = -1;
  unsigned long int return_value_gtk_window_get_type_4;
  return_value_gtk_window_get_type_4=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
  return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_window_get_type_4);
  struct _GtkWidget *return_value_gtk_window_get_default_widget_6;
  return_value_gtk_window_get_default_widget_6=gtk_window_get_default_widget((struct _GtkWindow *)return_value_g_type_check_instance_cast_5);
  unsigned long int return_value_gtk_window_get_type_1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  struct _GtkWidget *return_value_gtk_window_get_default_widget_3;
  if(!(return_value_gtk_window_get_default_widget_6 == ((struct _GtkWidget *)NULL)))
  {
    return_value_gtk_window_get_type_1=gtk_window_get_type();
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_window_get_type_1);
    return_value_gtk_window_get_default_widget_3=gtk_window_get_default_widget((struct _GtkWindow *)return_value_g_type_check_instance_cast_2);
    ret=gtk_dialog_get_response_for_widget(dlg, return_value_gtk_window_get_default_widget_3);
  }

  if(ret == -1)
  {
    struct _GList *children;
    struct _GList *t;
    signed int bad = -1;
    struct _GtkWidget *return_value_gtk_dialog_get_action_area_7;
    return_value_gtk_dialog_get_action_area_7=gtk_dialog_get_action_area(dlg);
    unsigned long int return_value_gtk_container_get_type_8;
    return_value_gtk_container_get_type_8=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
    return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_get_action_area_7, return_value_gtk_container_get_type_8);
    children=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast_9);
    t = children;
    while(!(t == ((struct _GList *)NULL)))
    {
      struct _GtkWidget *child = (struct _GtkWidget *)t->data;
      ret=gtk_dialog_get_response_for_widget(dlg, child);
      if(ret == -10 || ret == -8 || ret == -5 || ret == -3)
        break;

      if(bad == -1 && !(ret == -1))
        bad = ret;

      t = t->next;
    }
    g_list_free(children);
    if(ret == -1)
      ret = bad;

  }

  return ret;
}

// get_domain_name
// file avahi-ui.c line 670
static const char * get_domain_name(struct _AuiServiceDialog *d)
{
  const char *domain;
  do
    if(d == ((struct _AuiServiceDialog *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"get_domain_name", "d");
      return (const char *)(void *)0;
    }

  while((_Bool)0);
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"get_domain_name", "AUI_IS_SERVICE_DIALOG(d)");
      return (const char *)(void *)0;
    }

  }
  while((_Bool)0);
  if(!(d->priv->domain == ((char *)NULL)))
    return d->priv->domain;

  else
  {
    domain=avahi_client_get_domain_name(d->priv->client);
    if(domain == ((const char *)NULL))
    {
      struct _GtkWidget *m;
      unsigned long int return_value_gtk_window_get_type_3;
      return_value_gtk_window_get_type_3=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
      return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type_3);
      char *return_value_dgettext_5;
      return_value_dgettext_5=dgettext("avahi", "Failed to read Avahi domain: %s");
      signed int return_value_avahi_client_errno_6;
      return_value_avahi_client_errno_6=avahi_client_errno(d->priv->client);
      const char *return_value_avahi_strerror_7;
      return_value_avahi_strerror_7=avahi_strerror(return_value_avahi_client_errno_6);
      m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast_4, (enum anonymous_30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous_29)GTK_MESSAGE_ERROR, (enum anonymous_17)GTK_BUTTONS_CLOSE, return_value_dgettext_5, return_value_avahi_strerror_7);
      unsigned long int return_value_gtk_dialog_get_type_8;
      return_value_gtk_dialog_get_type_8=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
      return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type_8);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_9);
      gtk_widget_destroy(m);
      return (const char *)(void *)0;
    }

    return domain;
  }
}

// get_server_state
// file client.c line 305
static signed int get_server_state(struct AvahiClient *client, signed int *ret_error)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int state;
  signed int e = -24;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  dbus_error_init(&error);
  message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetState");
  _Bool tmp_if_expr_2;
  unsigned int return_value_dbus_error_is_set_1;
  unsigned int return_value_dbus_message_get_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  if(!(message == ((struct DBusMessage *)NULL)))
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_1=dbus_error_is_set(&error);
      tmp_if_expr_2 = return_value_dbus_error_is_set_1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      goto fail;

    return_value_dbus_message_get_args_3=dbus_message_get_args(reply, &error, (signed int)105, &state, (signed int)0);
    if(return_value_dbus_message_get_args_3 == 0u)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
      tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      goto fail;

    client_set_state(client, (enum anonymous_11)state);
    dbus_message_unref(message);
    dbus_message_unref(reply);
    return 0;
  }

  else
  {

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_6;
    return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set_6 == 0u))
    {
      e=avahi_error_dbus_to_number(error.name);
      dbus_error_free(&error);
    }

    if(!(ret_error == ((signed int *)NULL)))
      *ret_error = e;

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return e;
  }
}

// get_server_state_link1
// file client.c line 305
static signed int get_server_state_link1(struct AvahiClient *client_link1, signed int *ret_error_link1)
{
  struct DBusMessage *message_link1 = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply_link1 = (struct DBusMessage *)(void *)0;
  struct DBusError error_link1;
  signed int state_link1;
  signed int e_link1 = -24;
  /* assertion client */
  assert(client_link1 != ((struct AvahiClient *)NULL));
  dbus_error_init(&error_link1);
  message_link1=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetState");
  _Bool tmp_if_expr_2_link1;
  unsigned int return_value_dbus_error_is_set_1_link1;
  unsigned int return_value_dbus_message_get_args_3_link1;
  _Bool tmp_if_expr_5_link1;
  unsigned int return_value_dbus_error_is_set_4_link1;
  if(!(message_link1 == ((struct DBusMessage *)NULL)))
  {
    reply_link1=dbus_connection_send_with_reply_and_block(client_link1->bus, message_link1, -1, &error_link1);
    if(reply_link1 == ((struct DBusMessage *)NULL))
      tmp_if_expr_2_link1 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_1_link1=dbus_error_is_set(&error_link1);
      tmp_if_expr_2_link1 = return_value_dbus_error_is_set_1_link1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2_link1)
      goto fail;

    return_value_dbus_message_get_args_3_link1=dbus_message_get_args(reply_link1, &error_link1, (signed int)105, &state_link1, (signed int)0);
    if(return_value_dbus_message_get_args_3_link1 == 0u)
      tmp_if_expr_5_link1 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_4_link1=dbus_error_is_set(&error_link1);
      tmp_if_expr_5_link1 = return_value_dbus_error_is_set_4_link1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5_link1)
      goto fail;

    client_set_state_link1(client_link1, (enum anonymous_11)state_link1);
    dbus_message_unref(message_link1);
    dbus_message_unref(reply_link1);
    return 0;
  }

  else
  {

  fail:
    ;
    unsigned int return_value_dbus_error_is_set_6_link1;
    return_value_dbus_error_is_set_6_link1=dbus_error_is_set(&error_link1);
    if(!(return_value_dbus_error_is_set_6_link1 == 0u))
    {
      e_link1=avahi_error_dbus_to_number(error_link1.name);
      dbus_error_free(&error_link1);
    }

    if(!(ret_error_link1 == ((signed int *)NULL)))
      *ret_error_link1 = e_link1;

    if(!(message_link1 == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message_link1);

    if(!(reply_link1 == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply_link1);

    return e_link1;
  }
}

// help
// file bssh.c line 53
static void help(struct _IO_FILE *f, const char *argv0)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("avahi", "%s [options]\n\n    -h --help            Show this help\n    -s --ssh             Browse SSH servers\n    -v --vnc             Browse VNC servers\n    -S --shell           Browse both SSH and VNC\n    -d --domain=DOMAIN   The domain to browse in\n");
  fprintf(f, return_value_dgettext_1, argv0);
}

// init
// file ../avahi-utils/stdb.c line 46
static signed int init(void)
{
  if(!(gdbm_file == ((struct anonymous_36 *)NULL)))
    return 0;

  else
  {
    gdbm_file=gdbm_open((char *)"/usr/lib/x86_64-linux-gnu/avahi/service-types.db", 0, 0, 0, (void (*)())(void *)0);
    if(gdbm_file == ((struct anonymous_36 *)NULL))
      return -1;

    else
      return 0;
  }
}

// init_server
// file client.c line 431
static signed int init_server(struct AvahiClient *client, signed int *ret_error)
{
  signed int r;
  r=check_version(client, ret_error);
  if(!(r >= 0))
    return r;

  else
  {
    r=get_server_state(client, ret_error);
    if(!(r >= 0))
      return r;

    else
      return 0;
  }
}

// init_server_link1
// file client.c line 431
static signed int init_server_link1(struct AvahiClient *client_link1, signed int *ret_error_link1)
{
  signed int r_link1;
  r_link1=check_version_link1(client_link1, ret_error_link1);
  if(!(r_link1 >= 0))
    return r_link1;

  else
  {
    r_link1=get_server_state_link1(client_link1, ret_error_link1);
    if(!(r_link1 >= 0))
      return r_link1;

    else
      return 0;
  }
}

// is_valid_domain_suffix
// file avahi-ui.c line 919
static signed int is_valid_domain_suffix(const char *n)
{
  char label[64l];
  signed int return_value_avahi_is_valid_domain_name_1;
  return_value_avahi_is_valid_domain_name_1=avahi_is_valid_domain_name(n);
  if(return_value_avahi_is_valid_domain_name_1 == 0)
    return 0;

  else
  {
    char *return_value_avahi_unescape_label_2;
    return_value_avahi_unescape_label_2=avahi_unescape_label(&n, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label_2 == ((char *)NULL))
      return 0;

    else
      return (signed int)!(!(label[(signed long int)0] != 0));
  }
}

// main
// file bssh.c line 108
signed int main(signed int argc, char **argv)
{
  struct _GtkWidget *d;
  struct Config config;
  const char *argv0;
  avahi_init_i18n();
  setlocale(6, "");
  argv0=strrchr(argv[(signed long int)0], 47);
  if(!(argv0 == ((const char *)NULL)))
    argv0 = argv0 + 1l;

  else
    argv0 = argv[(signed long int)0];
  signed int return_value_g_str_has_suffix_2;
  return_value_g_str_has_suffix_2=g_str_has_suffix(argv[(signed long int)0], "bshell");
  signed int return_value_g_str_has_suffix_1;
  if(!(return_value_g_str_has_suffix_2 == 0))
    config.command = (enum anonymous_9)COMMAND_SHELL;

  else
  {
    return_value_g_str_has_suffix_1=g_str_has_suffix(argv[(signed long int)0], "bvnc");
    if(!(return_value_g_str_has_suffix_1 == 0))
      config.command = (enum anonymous_9)COMMAND_VNC;

    else
      config.command = (enum anonymous_9)COMMAND_SSH;
  }
  config.domain = (char *)(void *)0;
  signed int return_value_parse_command_line_3;
  return_value_parse_command_line_3=parse_command_line(&config, argc, argv);
  char *return_value_dgettext_4;
  char *return_value_dgettext_5;
  char *return_value_dgettext_6;
  unsigned long int return_value_aui_service_dialog_get_type_7;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  unsigned long int return_value_aui_service_dialog_get_type_9;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  char *return_value_dgettext_11;
  unsigned long int return_value_aui_service_dialog_get_type_12;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_13;
  char *return_value_dgettext_14;
  char *return_value_dgettext_15;
  char *return_value_dgettext_16;
  char *return_value_dgettext_17;
  unsigned long int return_value_aui_service_dialog_get_type_18;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_19;
  char *return_value_dgettext_20;
  char *return_value_dgettext_21;
  char *return_value_dgettext_22;
  unsigned long int return_value_aui_service_dialog_get_type_23;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
  unsigned long int return_value_aui_service_dialog_get_type_25;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
  unsigned long int return_value_aui_service_dialog_get_type_27;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
  unsigned long int return_value_aui_service_dialog_get_type_29;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_30;
  signed int return_value_avahi_nss_support_31;
  unsigned long int return_value_gtk_window_get_type_32;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_33;
  unsigned long int return_value_gtk_dialog_get_type_70;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_71;
  signed int return_value_gtk_dialog_run_72;
  unsigned long int return_value_aui_service_dialog_get_type_40;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_41;
  const char *return_value_aui_service_dialog_get_host_name_42;
  unsigned long int return_value_aui_service_dialog_get_type_43;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_44;
  const struct AvahiAddress *return_value_aui_service_dialog_get_address_45;
  char *return_value_avahi_address_snprint_46;
  _Bool tmp_if_expr_61;
  char *return_value_getenv_60;
  _Bool tmp_if_expr_64;
  char *return_value_getenv_63;
  if(!(return_value_parse_command_line_3 >= 0))
  {
    help(stderr, argv0);
    return 1;
  }

  else
  {
    bindtextdomain("avahi", "/usr/share/locale");
    bind_textdomain_codeset("avahi", "UTF-8");
    textdomain("avahi");
    gtk_init(&argc, &argv);
    switch((signed int)config.command)
    {
      case COMMAND_HELP:
      {
        help(stdout, argv0);
        return 0;
      }
      case COMMAND_SHELL:
      {
        return_value_dgettext_4=dgettext("avahi", "Choose Shell Server");
        return_value_dgettext_5=dgettext("avahi", "_Cancel");
        return_value_dgettext_6=dgettext("avahi", "C_onnect");
        d=aui_service_dialog_new(return_value_dgettext_4, (struct _GtkWindow *)(void *)0, return_value_dgettext_5, -6, return_value_dgettext_6, -3, (void *)0);
        return_value_aui_service_dialog_get_type_7=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_7);
        aui_service_dialog_set_browse_service_types((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_8, "_rfb._tcp", (const void *)"_ssh._tcp", (void *)0);
        return_value_aui_service_dialog_get_type_9=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_9);
        return_value_dgettext_11=dgettext("avahi", "Desktop");
        aui_service_dialog_set_service_type_name((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_10, "_rfb._tcp", return_value_dgettext_11);
        return_value_aui_service_dialog_get_type_12=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast_13=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_12);
        return_value_dgettext_14=dgettext("avahi", "Terminal");
        aui_service_dialog_set_service_type_name((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_13, "_ssh._tcp", return_value_dgettext_14);
        goto __CPROVER_DUMP_L11;
      }
      case COMMAND_VNC:
      {
        return_value_dgettext_15=dgettext("avahi", "Choose VNC server");
        return_value_dgettext_16=dgettext("avahi", "_Cancel");
        return_value_dgettext_17=dgettext("avahi", "C_onnect");
        d=aui_service_dialog_new(return_value_dgettext_15, (struct _GtkWindow *)(void *)0, return_value_dgettext_16, -6, return_value_dgettext_17, -3, (void *)0);
        return_value_aui_service_dialog_get_type_18=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast_19=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_18);
        aui_service_dialog_set_browse_service_types((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_19, "_rfb._tcp", (void *)0);
        goto __CPROVER_DUMP_L11;
      }
      case COMMAND_SSH:
      {
        return_value_dgettext_20=dgettext("avahi", "Choose SSH server");
        return_value_dgettext_21=dgettext("avahi", "_Cancel");
        return_value_dgettext_22=dgettext("avahi", "C_onnect");
        d=aui_service_dialog_new(return_value_dgettext_20, (struct _GtkWindow *)(void *)0, return_value_dgettext_21, -6, return_value_dgettext_22, -3, (void *)0);
        return_value_aui_service_dialog_get_type_23=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_23);
        aui_service_dialog_set_browse_service_types((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_24, "_ssh._tcp", (void *)0);
      }
      default:
      {

      __CPROVER_DUMP_L11:
        ;
        return_value_aui_service_dialog_get_type_25=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_25);
        aui_service_dialog_set_domain((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_26, config.domain);
        return_value_aui_service_dialog_get_type_27=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_27);
        aui_service_dialog_set_resolve_service((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_28, (signed int)!(0 != 0));
        return_value_aui_service_dialog_get_type_29=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast_30=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_29);
        return_value_avahi_nss_support_31=avahi_nss_support();
        aui_service_dialog_set_resolve_host_name((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_30, (signed int)!(return_value_avahi_nss_support_31 != 0));
        return_value_gtk_window_get_type_32=gtk_window_get_type();
        return_value_g_type_check_instance_cast_33=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type_32);
        gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast_33);
        return_value_gtk_dialog_get_type_70=gtk_dialog_get_type();
        return_value_g_type_check_instance_cast_71=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_70);
        return_value_gtk_dialog_run_72=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_71);
        if(return_value_gtk_dialog_run_72 == -3)
        {
          char a[40l];
          char *u = (char *)(void *)0;
          char *n = (char *)(void *)0;
          char *h = (char *)(void *)0;
          char *t = (char *)(void *)0;
          const struct AvahiStringList *txt;
          unsigned long int return_value_aui_service_dialog_get_type_34;
          return_value_aui_service_dialog_get_type_34=aui_service_dialog_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_35;
          return_value_g_type_check_instance_cast_35=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_34);
          const char *return_value_aui_service_dialog_get_service_type_36;
          return_value_aui_service_dialog_get_service_type_36=aui_service_dialog_get_service_type((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_35);
          t=g_strdup(return_value_aui_service_dialog_get_service_type_36);
          unsigned long int return_value_aui_service_dialog_get_type_37;
          return_value_aui_service_dialog_get_type_37=aui_service_dialog_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_38;
          return_value_g_type_check_instance_cast_38=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_37);
          const char *return_value_aui_service_dialog_get_service_name_39;
          return_value_aui_service_dialog_get_service_name_39=aui_service_dialog_get_service_name((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_38);
          n=g_strdup(return_value_aui_service_dialog_get_service_name_39);
          signed int return_value_avahi_nss_support_47;
          return_value_avahi_nss_support_47=avahi_nss_support();
          if(!(return_value_avahi_nss_support_47 == 0))
          {
            return_value_aui_service_dialog_get_type_40=aui_service_dialog_get_type();
            return_value_g_type_check_instance_cast_41=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_40);
            return_value_aui_service_dialog_get_host_name_42=aui_service_dialog_get_host_name((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_41);
            h=g_strdup(return_value_aui_service_dialog_get_host_name_42);
          }

          else
          {
            return_value_aui_service_dialog_get_type_43=aui_service_dialog_get_type();
            return_value_g_type_check_instance_cast_44=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_43);
            return_value_aui_service_dialog_get_address_45=aui_service_dialog_get_address((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_44);
            return_value_avahi_address_snprint_46=avahi_address_snprint(a, sizeof(char [40l]) /*40ul*/ , return_value_aui_service_dialog_get_address_45);
            h=g_strdup(return_value_avahi_address_snprint_46);
          }
          char *return_value_dgettext_48;
          return_value_dgettext_48=dgettext("avahi", "Connecting to '%s' ...\n");
          g_print(return_value_dgettext_48, n);
          signed int return_value_avahi_domain_equal_65;
          return_value_avahi_domain_equal_65=avahi_domain_equal(t, "_rfb._tcp");
          if(!(return_value_avahi_domain_equal_65 == 0))
          {
            char p[1030l];
            unsigned long int return_value_aui_service_dialog_get_type_49;
            return_value_aui_service_dialog_get_type_49=aui_service_dialog_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_50;
            return_value_g_type_check_instance_cast_50=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_49);
            unsigned short int return_value_aui_service_dialog_get_port_51;
            return_value_aui_service_dialog_get_port_51=aui_service_dialog_get_port((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_50);
            snprintf(p, sizeof(char [1030l]) /*1030ul*/ , "%s:%u", h, (signed int)return_value_aui_service_dialog_get_port_51 - 5900);
            gtk_widget_destroy(d);
            g_print("vncviewer %s\n", (const void *)p);
            execlp("xvncviewer", "xvncviewer", (const void *)p, (void *)0);
            execlp("vncviewer", "vncviewer", (const void *)p, (void *)0);
          }

          else
          {
            char main__1__3__2__p[16l];
            unsigned long int return_value_aui_service_dialog_get_type_52;
            return_value_aui_service_dialog_get_type_52=aui_service_dialog_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_53;
            return_value_g_type_check_instance_cast_53=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_52);
            unsigned short int return_value_aui_service_dialog_get_port_54;
            return_value_aui_service_dialog_get_port_54=aui_service_dialog_get_port((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_53);
            snprintf(main__1__3__2__p, sizeof(char [16l]) /*16ul*/ , "%u", return_value_aui_service_dialog_get_port_54);
            unsigned long int return_value_aui_service_dialog_get_type_55;
            return_value_aui_service_dialog_get_type_55=aui_service_dialog_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_56;
            return_value_g_type_check_instance_cast_56=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type_55);
            txt=aui_service_dialog_get_txt_data((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_56);
            for( ; !(txt == ((const struct AvahiStringList *)NULL)); txt = txt->next)
            {
              char *key;
              char *value;
              signed int return_value_avahi_string_list_get_pair_57;
              return_value_avahi_string_list_get_pair_57=avahi_string_list_get_pair((struct AvahiStringList *)txt, &key, &value, (unsigned long int *)(void *)0);
              if(!(return_value_avahi_string_list_get_pair_57 >= 0))
                break;

              signed int return_value_strcmp_58;
              return_value_strcmp_58=strcmp(key, "u");
              if(return_value_strcmp_58 == 0)
                u=g_strdup(value);

              avahi_free((void *)key);
              avahi_free((void *)value);
            }
            gtk_widget_destroy(d);
            if(!(u == ((char *)NULL)))
            {
              g_print("ssh -p %s -l %s %s\n", (const void *)main__1__3__2__p, u, h);
              signed int return_value_isatty_59;
              return_value_isatty_59=isatty(0);
              if(!(return_value_isatty_59 == 0))
                tmp_if_expr_61 = (_Bool)1;

              else
              {
                return_value_getenv_60=getenv("DISPLAY");
                tmp_if_expr_61 = !(return_value_getenv_60 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_61)
                execlp("ssh", "ssh", (const void *)"-p", (const void *)main__1__3__2__p, (const void *)"-l", u, h, (void *)0);

              else
              {
                execlp("x-terminal-emulator", "x-terminal-emulator", (const void *)"-T", n, (const void *)"-e", (const void *)"ssh", (const void *)"-p", (const void *)main__1__3__2__p, (const void *)"-l", u, h, (void *)0);
                execlp("gnome-terminal", "gnome-terminal", (const void *)"-t", n, (const void *)"-x", (const void *)"ssh", (const void *)"-p", (const void *)main__1__3__2__p, (const void *)"-l", u, h, (void *)0);
                execlp("xterm", "xterm", (const void *)"-T", n, (const void *)"-e", (const void *)"ssh", (const void *)"-p", (const void *)main__1__3__2__p, (const void *)"-l", u, h, (void *)0);
              }
            }

            else
            {
              g_print("ssh -p %s %s\n", (const void *)main__1__3__2__p, h);
              signed int return_value_isatty_62;
              return_value_isatty_62=isatty(0);
              if(!(return_value_isatty_62 == 0))
                tmp_if_expr_64 = (_Bool)1;

              else
              {
                return_value_getenv_63=getenv("DISPLAY");
                tmp_if_expr_64 = !(return_value_getenv_63 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_64)
                execlp("ssh", "ssh", (const void *)"-p", (const void *)main__1__3__2__p, h, (void *)0);

              else
              {
                execlp("x-terminal-emulator", "x-terminal-emulator", (const void *)"-T", n, (const void *)"-e", (const void *)"ssh", (const void *)"-p", (const void *)main__1__3__2__p, h, (void *)0);
                execlp("gnome-terminal", "gnome-terminal", (const void *)"-t", n, (const void *)"-x", (const void *)"ssh", (const void *)"-p", (const void *)main__1__3__2__p, h, (void *)0);
                execlp("xterm", "xterm", (const void *)"-T", n, (const void *)"-e", (const void *)"ssh", (const void *)"-p", (const void *)main__1__3__2__p, h, (void *)0);
              }
            }
          }
          char *return_value_dgettext_66;
          return_value_dgettext_66=dgettext("avahi", "execlp() failed: %s\n");
          signed int *return_value___errno_location_67;
          return_value___errno_location_67=__errno_location();
          char *return_value_strerror_68;
          return_value_strerror_68=strerror(*return_value___errno_location_67);
          g_log((char *)0, (enum anonymous_10)G_LOG_LEVEL_WARNING, return_value_dgettext_66, return_value_strerror_68);
          g_free((void *)h);
          g_free((void *)u);
          g_free((void *)t);
          g_free((void *)n);
        }

        else
        {
          gtk_widget_destroy(d);
          char *return_value_dgettext_69;
          return_value_dgettext_69=dgettext("avahi", "Canceled.\n");
          g_print(return_value_dgettext_69);
        }
        g_free((void *)config.domain);
        return 1;
      }
    }
  }
}

// malloc_glue
// file glib-malloc.c line 29
static void * malloc_glue(unsigned long int l)
{
  void *return_value_g_malloc_1;
  return_value_g_malloc_1=g_malloc(l);
  return return_value_g_malloc_1;
}

// map_events_from_glib
// file glib-watch.c line 101
static enum anonymous map_events_from_glib(unsigned short int events)
{
  return (enum anonymous)((((signed int)events & 1) != 0 ? AVAHI_WATCH_IN : 0) | (((signed int)events & 4) != 0 ? AVAHI_WATCH_OUT : 0) | (((signed int)events & 8) != 0 ? AVAHI_WATCH_ERR : 0) | (((signed int)events & 16) != 0 ? AVAHI_WATCH_HUP : 0));
}

// map_events_to_glib
// file glib-watch.c line 93
static unsigned short int map_events_to_glib(enum anonymous events)
{
  return (unsigned short int)((((signed int)events & AVAHI_WATCH_IN) != 0 ? 1 : 0) | (((signed int)events & AVAHI_WATCH_OUT) != 0 ? 4 : 0) | (((signed int)events & AVAHI_WATCH_ERR) != 0 ? 8 : 0) | (((signed int)events & AVAHI_WATCH_HUP) != 0 ? 16 : 0));
}

// oom
// file malloc.c line 44
static void oom(void)
{
  static const char msg[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n = msg;
  unsigned long int return_value_strlen_1;
  do
  {
    return_value_strlen_1=strlen(n);
    if(!(return_value_strlen_1 >= 1ul))
      break;

    signed long int r;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(n);
    r=write(2, (const void *)n, return_value_strlen_2);
    if(!(r >= 0l))
      break;

    n = n + r;
  }
  while((_Bool)1);
  abort();
}

// oom_link1
// file malloc.c line 44
static void oom_link1(void)
{
  static const char msg_link1[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n_link1 = msg_link1;
  unsigned long int return_value_strlen_1_link1;
  do
  {
    return_value_strlen_1_link1=strlen(n_link1);
    if(!(return_value_strlen_1_link1 >= 1ul))
      break;

    signed long int r_link1;
    unsigned long int return_value_strlen_2_link1;
    return_value_strlen_2_link1=strlen(n_link1);
    r_link1=write(2, (const void *)n_link1, return_value_strlen_2_link1);
    if(!(r_link1 >= 0l))
      break;

    n_link1 = n_link1 + r_link1;
  }
  while((_Bool)1);
  abort();
}

// oom_link1_link1
// file malloc.c line 44
static void oom_link1_link1(void)
{
  static const char msg_link1_link1[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n_link1_link1 = msg_link1_link1;
  unsigned long int return_value_strlen_1_link1_link1;
  do
  {
    return_value_strlen_1_link1_link1=strlen(n_link1_link1);
    if(!(return_value_strlen_1_link1_link1 >= 1ul))
      break;

    signed long int r_link1_link1;
    unsigned long int return_value_strlen_2_link1_link1;
    return_value_strlen_2_link1_link1=strlen(n_link1_link1);
    r_link1_link1=write(2, (const void *)n_link1_link1, return_value_strlen_2_link1_link1);
    if(!(r_link1_link1 >= 0l))
      break;

    n_link1_link1 = n_link1_link1 + r_link1_link1;
  }
  while((_Bool)1);
  abort();
}

// oom_link2
// file malloc.c line 44
static void oom_link2(void)
{
  static const char msg_link2[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n_link2 = msg_link2;
  unsigned long int return_value_strlen_1_link2;
  do
  {
    return_value_strlen_1_link2=strlen(n_link2);
    if(!(return_value_strlen_1_link2 >= 1ul))
      break;

    signed long int r_link2;
    unsigned long int return_value_strlen_2_link2;
    return_value_strlen_2_link2=strlen(n_link2);
    r_link2=write(2, (const void *)n_link2, return_value_strlen_2_link2);
    if(!(r_link2 >= 0l))
      break;

    n_link2 = n_link2 + r_link2;
  }
  while((_Bool)1);
  abort();
}

// oom_link3
// file malloc.c line 44
static void oom_link3(void)
{
  static const char msg_link3[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n_link3 = msg_link3;
  unsigned long int return_value_strlen_1_link3;
  do
  {
    return_value_strlen_1_link3=strlen(n_link3);
    if(!(return_value_strlen_1_link3 >= 1ul))
      break;

    signed long int r_link3;
    unsigned long int return_value_strlen_2_link3;
    return_value_strlen_2_link3=strlen(n_link3);
    r_link3=write(2, (const void *)n_link3, return_value_strlen_2_link3);
    if(!(r_link3 >= 0l))
      break;

    n_link3 = n_link3 + r_link3;
  }
  while((_Bool)1);
  abort();
}

// parse_command_line
// file bssh.c line 64
static signed int parse_command_line(struct Config *c, signed int argc, char **argv)
{
  signed int o;
  do
  {
    static struct option long_options[6l] = { { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="ssh", .has_arg=0, .flag=(signed int *)(void *)0, .val=115 },
    { .name="vnc", .has_arg=0, .flag=(signed int *)(void *)0, .val=118 },
    { .name="shell", .has_arg=0, .flag=(signed int *)(void *)0, .val=83 },
    { .name="domain", .has_arg=1, .flag=(signed int *)(void *)0, .val=100 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
    o=getopt_long(argc, argv, "hVd:svS", long_options, (signed int *)(void *)0);
    if(!(o >= 0))
      break;

    switch(o)
    {
      case 104:
      {
        c->command = (enum anonymous_9)COMMAND_HELP;
        break;
      }
      case 115:
      {
        c->command = (enum anonymous_9)COMMAND_SSH;
        break;
      }
      case 118:
      {
        c->command = (enum anonymous_9)COMMAND_VNC;
        break;
      }
      case 83:
      {
        c->command = (enum anonymous_9)COMMAND_SHELL;
        break;
      }
      case 100:
      {
        avahi_free((void *)c->domain);
        c->domain=avahi_strdup(optarg);
        break;
      }
      default:
        return -1;
    }
  }
  while((_Bool)1);
  if(!(optind >= argc))
  {
    char *return_value_dgettext_1;
    return_value_dgettext_1=dgettext("avahi", "Too many arguments\n");
    fprintf(stderr, return_value_dgettext_1);
    return -1;
  }

  return 0;
}

// parse_domain_file
// file browser.c line 58
static void parse_domain_file(struct AvahiDomainBrowser *b)
{
  struct _IO_FILE *f;
  char buf[1014l];
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  f=avahi_xdg_config_open("avahi/browse-domains");
  char *return_value_fgets_1;
  if(!(f == ((struct _IO_FILE *)NULL)))
    do
    {
      return_value_fgets_1=fgets(buf, (signed int)(sizeof(char [1014l]) /*1014ul*/  - (unsigned long int)1), f);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      char domain[1014l];
      unsigned long int return_value_strcspn_2;
      return_value_strcspn_2=strcspn(buf, "\n\r");
      buf[(signed long int)return_value_strcspn_2] = (char)0;
      char *return_value_avahi_normalize_name_3;
      return_value_avahi_normalize_name_3=avahi_normalize_name(buf, domain, sizeof(char [1014l]) /*1014ul*/ );
      if(!(return_value_avahi_normalize_name_3 == ((char *)NULL)))
        b->static_browse_domains=avahi_string_list_add(b->static_browse_domains, domain);

    }
    while((_Bool)1);

}

// parse_domain_file_link1
// file browser.c line 58
static void parse_domain_file_link1(struct AvahiDomainBrowser *b_link1)
{
  struct _IO_FILE *f_link1;
  char buf_link1[1014l];
  /* assertion b */
  assert(b_link1 != ((struct AvahiDomainBrowser *)NULL));
  f_link1=avahi_xdg_config_open("avahi/browse-domains");
  char *return_value_fgets_1_link1;
  if(!(f_link1 == ((struct _IO_FILE *)NULL)))
    do
    {
      return_value_fgets_1_link1=fgets(buf_link1, (signed int)(sizeof(char [1014l]) /*1014ul*/  - (unsigned long int)1), f_link1);
      if(return_value_fgets_1_link1 == ((char *)NULL))
        break;

      char domain_link1[1014l];
      unsigned long int return_value_strcspn_2_link1;
      return_value_strcspn_2_link1=strcspn(buf_link1, "\n\r");
      buf_link1[(signed long int)return_value_strcspn_2_link1] = (char)0;
      char *return_value_avahi_normalize_name_3_link1;
      return_value_avahi_normalize_name_3_link1=avahi_normalize_name(buf_link1, domain_link1, sizeof(char [1014l]) /*1014ul*/ );
      if(!(return_value_avahi_normalize_name_3_link1 == ((char *)NULL)))
        b_link1->static_browse_domains=avahi_string_list_add(b_link1->static_browse_domains, domain_link1);

    }
    while((_Bool)1);

}

// parse_environment
// file browser.c line 41
static void parse_environment(struct AvahiDomainBrowser *b)
{
  char buf[3042l];
  char *e;
  char *t;
  char *p;
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  e=getenv("AVAHI_BROWSE_DOMAINS");
  if(!(e == ((char *)NULL)))
  {
    snprintf(buf, sizeof(char [3042l]) /*3042ul*/ , "%s", e);
    t=strtok_r(buf, ":", &p);
    while(!(t == ((char *)NULL)))
    {
      char domain[1014l];
      char *return_value_avahi_normalize_name_1;
      return_value_avahi_normalize_name_1=avahi_normalize_name(t, domain, sizeof(char [1014l]) /*1014ul*/ );
      if(!(return_value_avahi_normalize_name_1 == ((char *)NULL)))
        b->static_browse_domains=avahi_string_list_add(b->static_browse_domains, domain);

      t=strtok_r((char *)(void *)0, ":", &p);
    }
  }

}

// parse_environment_link1
// file browser.c line 41
static void parse_environment_link1(struct AvahiDomainBrowser *b_link1)
{
  char buf_link1[3042l];
  char *e_link1;
  char *t_link1;
  char *p_link1;
  /* assertion b */
  assert(b_link1 != ((struct AvahiDomainBrowser *)NULL));
  e_link1=getenv("AVAHI_BROWSE_DOMAINS");
  if(!(e_link1 == ((char *)NULL)))
  {
    snprintf(buf_link1, sizeof(char [3042l]) /*3042ul*/ , "%s", e_link1);
    t_link1=strtok_r(buf_link1, ":", &p_link1);
    while(!(t_link1 == ((char *)NULL)))
    {
      char domain_link1[1014l];
      char *return_value_avahi_normalize_name_1_link1;
      return_value_avahi_normalize_name_1_link1=avahi_normalize_name(t_link1, domain_link1, sizeof(char [1014l]) /*1014ul*/ );
      if(!(return_value_avahi_normalize_name_1_link1 == ((char *)NULL)))
        b_link1->static_browse_domains=avahi_string_list_add(b_link1->static_browse_domains, domain_link1);

      t_link1=strtok_r((char *)(void *)0, ":", &p_link1);
    }
  }

}

// poll_func
// file thread-watch.c line 48
static signed int poll_func(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata)
{
  union anonymous_6 *mutex = (union anonymous_6 *)userdata;
  signed int r;
  pthread_mutex_unlock(mutex);
  r=poll(ufds, (unsigned long int)nfds, timeout);
  pthread_mutex_lock(mutex);
  return r;
}

// poll_func_link1
// file thread-watch.c line 48
static signed int poll_func_link1(struct pollfd *ufds_link1, unsigned int nfds_link1, signed int timeout_link1, void *userdata_link1)
{
  union anonymous_6 *mutex_link1 = (union anonymous_6 *)userdata_link1;
  signed int r_link1;
  pthread_mutex_unlock(mutex_link1);
  r_link1=poll(ufds_link1, (unsigned long int)nfds_link1, timeout_link1);
  pthread_mutex_lock(mutex_link1);
  return r_link1;
}

// poll_func_link1_link1
// file thread-watch.c line 48
static signed int poll_func_link1_link1(struct pollfd *ufds_link1_link1, unsigned int nfds_link1_link1, signed int timeout_link1_link1, void *userdata_link1_link1)
{
  union anonymous_6 *mutex_link1_link1 = (union anonymous_6 *)userdata_link1_link1;
  signed int r_link1_link1;
  pthread_mutex_unlock(mutex_link1_link1);
  r_link1_link1=poll(ufds_link1_link1, (unsigned long int)nfds_link1_link1, timeout_link1_link1);
  pthread_mutex_lock(mutex_link1_link1);
  return r_link1_link1;
}

// poll_func_link2
// file thread-watch.c line 48
static signed int poll_func_link2(struct pollfd *ufds_link2, unsigned int nfds_link2, signed int timeout_link2, void *userdata_link2)
{
  union anonymous_6 *mutex_link2 = (union anonymous_6 *)userdata_link2;
  signed int r_link2;
  pthread_mutex_unlock(mutex_link2);
  r_link2=poll(ufds_link2, (unsigned long int)nfds_link2, timeout_link2);
  pthread_mutex_lock(mutex_link2);
  return r_link2;
}

// poll_func_link3
// file thread-watch.c line 48
static signed int poll_func_link3(struct pollfd *ufds_link3, unsigned int nfds_link3, signed int timeout_link3, void *userdata_link3)
{
  union anonymous_6 *mutex_link3 = (union anonymous_6 *)userdata_link3;
  signed int r_link3;
  pthread_mutex_unlock(mutex_link3);
  r_link3=poll(ufds_link3, (unsigned long int)nfds_link3, timeout_link3);
  pthread_mutex_lock(mutex_link3);
  return r_link3;
}

// prepare_func
// file glib-watch.c line 255
static signed int prepare_func(struct _GSource *source, signed int *timeout)
{
  struct AvahiGLibPoll *g = (struct AvahiGLibPoll *)source;
  struct AvahiTimeout *next_timeout;
  do
    if(g == ((struct AvahiGLibPoll *)NULL))
      g_assertion_message_expr((char *)0, "glib-watch.c", 259, (const char *)"prepare_func", "g");

  while((_Bool)0);
  do
    if(timeout == ((signed int *)NULL))
      g_assertion_message_expr((char *)0, "glib-watch.c", 260, (const char *)"prepare_func", "timeout");

  while((_Bool)0);
  if(!(g->watch_req_cleanup == 0))
    cleanup_watches_link2(g, 0);

  if(!(g->timeout_req_cleanup == 0))
    cleanup_timeouts_link2(g, 0);

  next_timeout=find_next_timeout_link2(g);
  if(!(next_timeout == ((struct AvahiTimeout *)NULL)))
  {
    struct _GTimeVal now;
    struct timeval tvnow;
    signed long int usec;
    g_source_get_current_time(source, &now);
    tvnow.tv_sec = now.tv_sec;
    tvnow.tv_usec = now.tv_usec;
    usec=avahi_timeval_diff(&next_timeout->expiry, &tvnow);
    if(!(usec >= 1l))
    {
      *timeout = 0;
      return (signed int)!(0 != 0);
    }

    *timeout = (signed int)(usec / (signed long int)1000);
  }

  else
    *timeout = -1;
  return 0;
}

// realloc_glue
// file glib-malloc.c line 33
static void * realloc_glue(void *p, unsigned long int l)
{
  void *return_value_g_realloc_1;
  return_value_g_realloc_1=g_realloc(p, l);
  return return_value_g_realloc_1;
}

// rebuild
// file simple-watch.c line 385
static signed int rebuild(struct AvahiSimplePoll_0 *s)
{
  struct AvahiWatch_1 *w;
  signed int idx;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  if(!(s->max_pollfds >= 1 + s->n_watches))
  {
    struct pollfd *n;
    s->max_pollfds = s->n_watches + 10;
    void *return_value_avahi_realloc_1;
    return_value_avahi_realloc_1=avahi_realloc((void *)s->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s->max_pollfds);
    n = (struct pollfd *)return_value_avahi_realloc_1;
    if(n == ((struct pollfd *)NULL))
      return -1;

    s->pollfds = n;
  }

  (s->pollfds + (signed long int)0)->fd = s->wakeup_pipe[(signed long int)0];
  (s->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx = 1;
  w = s->watches;
  signed int tmp_post_2;
  for( ; !(w == ((struct AvahiWatch_1 *)NULL)); w = w->watches_next)
    if(w->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w->idx < s->max_pollfds);
      tmp_post_2 = idx;
      idx = idx + 1;
      w->idx = tmp_post_2;
      s->pollfds[(signed long int)w->idx] = w->pollfd;
    }

  s->n_pollfds = idx;
  s->events_valid = 0;
  s->rebuild_pollfds = 0;
  return 0;
}

// rebuild_link1
// file simple-watch.c line 385
static signed int rebuild_link1(struct AvahiSimplePoll_0 *s_link1)
{
  struct AvahiWatch_1 *w_link1;
  signed int idx_link1;
  /* assertion s */
  assert(s_link1 != ((struct AvahiSimplePoll_0 *)NULL));
  if(!(s_link1->max_pollfds >= 1 + s_link1->n_watches))
  {
    struct pollfd *n_link1;
    s_link1->max_pollfds = s_link1->n_watches + 10;
    void *return_value_avahi_realloc_1_link1;
    return_value_avahi_realloc_1_link1=avahi_realloc((void *)s_link1->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s_link1->max_pollfds);
    n_link1 = (struct pollfd *)return_value_avahi_realloc_1_link1;
    if(n_link1 == ((struct pollfd *)NULL))
      return -1;

    s_link1->pollfds = n_link1;
  }

  (s_link1->pollfds + (signed long int)0)->fd = s_link1->wakeup_pipe[(signed long int)0];
  (s_link1->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s_link1->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx_link1 = 1;
  w_link1 = s_link1->watches;
  signed int tmp_post_2_link1;
  for( ; !(w_link1 == ((struct AvahiWatch_1 *)NULL)); w_link1 = w_link1->watches_next)
    if(w_link1->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w_link1->idx < s_link1->max_pollfds);
      tmp_post_2_link1 = idx_link1;
      idx_link1 = idx_link1 + 1;
      w_link1->idx = tmp_post_2_link1;
      s_link1->pollfds[(signed long int)w_link1->idx] = w_link1->pollfd;
    }

  s_link1->n_pollfds = idx_link1;
  s_link1->events_valid = 0;
  s_link1->rebuild_pollfds = 0;
  return 0;
}

// rebuild_link1_link1
// file simple-watch.c line 385
static signed int rebuild_link1_link1(struct AvahiSimplePoll_0 *s_link1_link1)
{
  struct AvahiWatch_1 *w_link1_link1;
  signed int idx_link1_link1;
  /* assertion s */
  assert(s_link1_link1 != ((struct AvahiSimplePoll_0 *)NULL));
  if(!(s_link1_link1->max_pollfds >= 1 + s_link1_link1->n_watches))
  {
    struct pollfd *n_link1_link1;
    s_link1_link1->max_pollfds = s_link1_link1->n_watches + 10;
    void *return_value_avahi_realloc_1_link1_link1;
    return_value_avahi_realloc_1_link1_link1=avahi_realloc((void *)s_link1_link1->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s_link1_link1->max_pollfds);
    n_link1_link1 = (struct pollfd *)return_value_avahi_realloc_1_link1_link1;
    if(n_link1_link1 == ((struct pollfd *)NULL))
      return -1;

    s_link1_link1->pollfds = n_link1_link1;
  }

  (s_link1_link1->pollfds + (signed long int)0)->fd = s_link1_link1->wakeup_pipe[(signed long int)0];
  (s_link1_link1->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s_link1_link1->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx_link1_link1 = 1;
  w_link1_link1 = s_link1_link1->watches;
  signed int tmp_post_2_link1_link1;
  for( ; !(w_link1_link1 == ((struct AvahiWatch_1 *)NULL)); w_link1_link1 = w_link1_link1->watches_next)
    if(w_link1_link1->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w_link1_link1->idx < s_link1_link1->max_pollfds);
      tmp_post_2_link1_link1 = idx_link1_link1;
      idx_link1_link1 = idx_link1_link1 + 1;
      w_link1_link1->idx = tmp_post_2_link1_link1;
      s_link1_link1->pollfds[(signed long int)w_link1_link1->idx] = w_link1_link1->pollfd;
    }

  s_link1_link1->n_pollfds = idx_link1_link1;
  s_link1_link1->events_valid = 0;
  s_link1_link1->rebuild_pollfds = 0;
  return 0;
}

// rebuild_link2
// file simple-watch.c line 385
static signed int rebuild_link2(struct AvahiSimplePoll *s_link2)
{
  struct AvahiWatch *w_link2;
  signed int idx_link2;
  /* assertion s */
  assert(s_link2 != ((struct AvahiSimplePoll *)NULL));
  if(!(s_link2->max_pollfds >= 1 + s_link2->n_watches))
  {
    struct pollfd *n_link2;
    s_link2->max_pollfds = s_link2->n_watches + 10;
    void *return_value_avahi_realloc_1_link2;
    return_value_avahi_realloc_1_link2=avahi_realloc((void *)s_link2->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s_link2->max_pollfds);
    n_link2 = (struct pollfd *)return_value_avahi_realloc_1_link2;
    if(n_link2 == ((struct pollfd *)NULL))
      return -1;

    s_link2->pollfds = n_link2;
  }

  (s_link2->pollfds + (signed long int)0)->fd = s_link2->wakeup_pipe[(signed long int)0];
  (s_link2->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s_link2->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx_link2 = 1;
  w_link2 = s_link2->watches;
  signed int tmp_post_2_link2;
  for( ; !(w_link2 == ((struct AvahiWatch *)NULL)); w_link2 = w_link2->watches_next)
    if(w_link2->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w_link2->idx < s_link2->max_pollfds);
      tmp_post_2_link2 = idx_link2;
      idx_link2 = idx_link2 + 1;
      w_link2->idx = tmp_post_2_link2;
      s_link2->pollfds[(signed long int)w_link2->idx] = w_link2->pollfd;
    }

  s_link2->n_pollfds = idx_link2;
  s_link2->events_valid = 0;
  s_link2->rebuild_pollfds = 0;
  return 0;
}

// rebuild_link3
// file simple-watch.c line 385
static signed int rebuild_link3(struct AvahiSimplePoll_0 *s_link3)
{
  struct AvahiWatch_1 *w_link3;
  signed int idx_link3;
  /* assertion s */
  assert(s_link3 != ((struct AvahiSimplePoll_0 *)NULL));
  if(!(s_link3->max_pollfds >= 1 + s_link3->n_watches))
  {
    struct pollfd *n_link3;
    s_link3->max_pollfds = s_link3->n_watches + 10;
    void *return_value_avahi_realloc_1_link3;
    return_value_avahi_realloc_1_link3=avahi_realloc((void *)s_link3->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s_link3->max_pollfds);
    n_link3 = (struct pollfd *)return_value_avahi_realloc_1_link3;
    if(n_link3 == ((struct pollfd *)NULL))
      return -1;

    s_link3->pollfds = n_link3;
  }

  (s_link3->pollfds + (signed long int)0)->fd = s_link3->wakeup_pipe[(signed long int)0];
  (s_link3->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s_link3->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx_link3 = 1;
  w_link3 = s_link3->watches;
  signed int tmp_post_2_link3;
  for( ; !(w_link3 == ((struct AvahiWatch_1 *)NULL)); w_link3 = w_link3->watches_next)
    if(w_link3->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w_link3->idx < s_link3->max_pollfds);
      tmp_post_2_link3 = idx_link3;
      idx_link3 = idx_link3 + 1;
      w_link3->idx = tmp_post_2_link3;
      s_link3->pollfds[(signed long int)w_link3->idx] = w_link3->pollfd;
    }

  s_link3->n_pollfds = idx_link3;
  s_link3->events_valid = 0;
  s_link3->rebuild_pollfds = 0;
  return 0;
}

// remove_pollfd
// file simple-watch.c line 194
static void remove_pollfd(struct AvahiWatch_1 *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch_1 *)NULL));
  if(!(w->idx == -1))
    w->simple_poll->rebuild_pollfds = 1;

}

// remove_pollfd_link1
// file simple-watch.c line 194
static void remove_pollfd_link1(struct AvahiWatch_1 *w_link1)
{
  /* assertion w */
  assert(w_link1 != ((struct AvahiWatch_1 *)NULL));
  if(!(w_link1->idx == -1))
    w_link1->simple_poll->rebuild_pollfds = 1;

}

// remove_pollfd_link1_link1
// file simple-watch.c line 194
static void remove_pollfd_link1_link1(struct AvahiWatch_1 *w_link1_link1)
{
  /* assertion w */
  assert(w_link1_link1 != ((struct AvahiWatch_1 *)NULL));
  if(!(w_link1_link1->idx == -1))
    w_link1_link1->simple_poll->rebuild_pollfds = 1;

}

// remove_pollfd_link2
// file simple-watch.c line 194
static void remove_pollfd_link2(struct AvahiWatch *w_link2)
{
  /* assertion w */
  assert(w_link2 != ((struct AvahiWatch *)NULL));
  if(!(w_link2->idx == -1))
    w_link2->simple_poll->rebuild_pollfds = 1;

}

// remove_pollfd_link3
// file simple-watch.c line 194
static void remove_pollfd_link3(struct AvahiWatch_1 *w_link3)
{
  /* assertion w */
  assert(w_link3 != ((struct AvahiWatch_1 *)NULL));
  if(!(w_link3->idx == -1))
    w_link3->simple_poll->rebuild_pollfds = 1;

}

// remove_timeout
// file ../avahi-common/dbus-watch-glue.c line 286
static void remove_timeout(struct DBusTimeout *dbus_timeout, void *userdata)
{
  struct anonymous_28 *d = (struct anonymous_28 *)userdata;
  struct TimeoutData *timeout;
  /* assertion dbus_timeout */
  assert(dbus_timeout != ((struct DBusTimeout *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous_28 *)NULL));
  void *return_value_dbus_timeout_get_data_1;
  return_value_dbus_timeout_get_data_1=dbus_timeout_get_data(dbus_timeout);
  timeout = (struct TimeoutData *)return_value_dbus_timeout_get_data_1;
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  d->poll_api->timeout_free(timeout->avahi_timeout);
  timeout->avahi_timeout = (struct AvahiTimeout_1 *)(void *)0;
}

// remove_timeout_link1
// file ../avahi-common/dbus-watch-glue.c line 286
static void remove_timeout_link1(struct DBusTimeout *dbus_timeout_link1, void *userdata_link1)
{
  struct anonymous_28 *d_link1 = (struct anonymous_28 *)userdata_link1;
  struct TimeoutData *timeout_link1;
  /* assertion dbus_timeout */
  assert(dbus_timeout_link1 != ((struct DBusTimeout *)NULL));
  /* assertion d */
  assert(d_link1 != ((struct anonymous_28 *)NULL));
  void *return_value_dbus_timeout_get_data_1_link1;
  return_value_dbus_timeout_get_data_1_link1=dbus_timeout_get_data(dbus_timeout_link1);
  timeout_link1 = (struct TimeoutData *)return_value_dbus_timeout_get_data_1_link1;
  /* assertion timeout */
  assert(timeout_link1 != ((struct TimeoutData *)NULL));
  d_link1->poll_api->timeout_free(timeout_link1->avahi_timeout);
  timeout_link1->avahi_timeout = (struct AvahiTimeout_1 *)(void *)0;
}

// remove_watch
// file ../avahi-common/dbus-watch-glue.c line 174
static void remove_watch(struct DBusWatch *dbus_watch, void *userdata)
{
  struct anonymous_28 *d = (struct anonymous_28 *)userdata;
  struct AvahiWatch_1 *avahi_watch;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous_28 *)NULL));
  void *return_value_dbus_watch_get_data_1;
  return_value_dbus_watch_get_data_1=dbus_watch_get_data(dbus_watch);
  avahi_watch = (struct AvahiWatch_1 *)return_value_dbus_watch_get_data_1;
  if(!(avahi_watch == ((struct AvahiWatch_1 *)NULL)))
  {
    d->poll_api->watch_free(avahi_watch);
    dbus_watch_set_data(dbus_watch, (void *)0, (void (*)(void *))(void *)0);
  }

}

// remove_watch_link1
// file ../avahi-common/dbus-watch-glue.c line 174
static void remove_watch_link1(struct DBusWatch *dbus_watch_link1, void *userdata_link1)
{
  struct anonymous_28 *d_link1 = (struct anonymous_28 *)userdata_link1;
  struct AvahiWatch_1 *avahi_watch_link1;
  /* assertion dbus_watch */
  assert(dbus_watch_link1 != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d_link1 != ((struct anonymous_28 *)NULL));
  void *return_value_dbus_watch_get_data_1_link1;
  return_value_dbus_watch_get_data_1_link1=dbus_watch_get_data(dbus_watch_link1);
  avahi_watch_link1 = (struct AvahiWatch_1 *)return_value_dbus_watch_get_data_1_link1;
  if(!(avahi_watch_link1 == ((struct AvahiWatch_1 *)NULL)))
  {
    d_link1->poll_api->watch_free(avahi_watch_link1);
    dbus_watch_set_data(dbus_watch_link1, (void *)0, (void (*)(void *))(void *)0);
  }

}

// request_dispatch
// file ../avahi-common/dbus-watch-glue.c line 86
static void request_dispatch(struct anonymous_28 *d, signed int enable)
{
  /* assertion d */
  assert(d != ((struct anonymous_28 *)NULL));
  if(!(enable == 0))
  {
    enum anonymous_27 return_value_dbus_connection_get_dispatch_status_1;
    return_value_dbus_connection_get_dispatch_status_1=dbus_connection_get_dispatch_status(d->connection);
    /* assertion dbus_connection_get_dispatch_status(d->connection) == DBUS_DISPATCH_DATA_REMAINS */
    assert((signed int)return_value_dbus_connection_get_dispatch_status_1 == DBUS_DISPATCH_DATA_REMAINS);
    static struct timeval tv = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
    d->poll_api->timeout_update(d->dispatch_timeout, &tv);
  }

  else
    d->poll_api->timeout_update(d->dispatch_timeout, (struct timeval *)(void *)0);
}

// request_dispatch_link1
// file ../avahi-common/dbus-watch-glue.c line 86
static void request_dispatch_link1(struct anonymous_28 *d_link1, signed int enable_link1)
{
  /* assertion d */
  assert(d_link1 != ((struct anonymous_28 *)NULL));
  if(!(enable_link1 == 0))
  {
    enum anonymous_27 return_value_dbus_connection_get_dispatch_status_1_link1;
    return_value_dbus_connection_get_dispatch_status_1_link1=dbus_connection_get_dispatch_status(d_link1->connection);
    /* assertion dbus_connection_get_dispatch_status(d->connection) == DBUS_DISPATCH_DATA_REMAINS */
    assert((signed int)return_value_dbus_connection_get_dispatch_status_1_link1 == DBUS_DISPATCH_DATA_REMAINS);
    static struct timeval tv_link1 = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
    d_link1->poll_api->timeout_update(d_link1->dispatch_timeout, &tv_link1);
  }

  else
    d_link1->poll_api->timeout_update(d_link1->dispatch_timeout, (struct timeval *)(void *)0);
}

// resolve_callback
// file avahi-ui.c line 335
static void resolve_callback(struct AvahiServiceResolver *r, signed int interface, signed int protocol, enum anonymous_12 event, const char *name, const char *type, const char *domain, const char *host_name, const struct AvahiAddress *a, unsigned short int port, struct AvahiStringList *txt, enum anonymous_13 flags, void *userdata)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)userdata, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  unsigned long int return_value_gtk_dialog_get_type_3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  struct _GtkWidget *m;
  unsigned long int return_value_gtk_window_get_type_5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  char *return_value_dgettext_7;
  signed int return_value_avahi_client_errno_8;
  const char *return_value_avahi_strerror_9;
  unsigned long int return_value_gtk_dialog_get_type_10;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_11;
  unsigned long int return_value_gtk_dialog_get_type_12;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_13;
  switch((signed int)event)
  {
    case AVAHI_RESOLVER_FOUND:
    {
      d->priv->resolve_service_done = 1;
      g_free((void *)d->priv->service_name);
      d->priv->service_name=g_strdup(name);
      g_free((void *)d->priv->service_type);
      d->priv->service_type=g_strdup(type);
      g_free((void *)d->priv->domain);
      d->priv->domain=g_strdup(domain);
      g_free((void *)d->priv->host_name);
      d->priv->host_name=g_strdup(host_name);
      d->priv->port = port;
      avahi_string_list_free(d->priv->txt_data);
      d->priv->txt_data=avahi_string_list_copy(txt);
      if(!(a == ((const struct AvahiAddress *)NULL)))
      {
        d->priv->resolve_host_name_done = 1;
        d->priv->address = *a;
      }

      return_value_gtk_dialog_get_type_3=gtk_dialog_get_type();
      return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_3);
      gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_4, d->priv->forward_response_id);
      break;
    }
    case AVAHI_RESOLVER_FAILURE:
    {
      return_value_gtk_window_get_type_5=gtk_window_get_type();
      return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type_5);
      return_value_dgettext_7=dgettext("avahi", "Avahi resolver failure: %s");
      return_value_avahi_client_errno_8=avahi_client_errno(d->priv->client);
      return_value_avahi_strerror_9=avahi_strerror(return_value_avahi_client_errno_8);
      m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, (enum anonymous_30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous_29)GTK_MESSAGE_ERROR, (enum anonymous_17)GTK_BUTTONS_CLOSE, return_value_dgettext_7, return_value_avahi_strerror_9);
      return_value_gtk_dialog_get_type_10=gtk_dialog_get_type();
      return_value_g_type_check_instance_cast_11=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type_10);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_11);
      gtk_widget_destroy(m);
      return_value_gtk_dialog_get_type_12=gtk_dialog_get_type();
      return_value_g_type_check_instance_cast_13=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_12);
      gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_13, -6);
    }
  }
}

// response_callback
// file avahi-ui.c line 859
static void response_callback(struct _GtkDialog *dialog, signed int response, void *user_data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  _Bool tmp_if_expr_25;
  _Bool tmp_if_expr_27;
  _Bool tmp_if_expr_26;
  if(response == -10 || response == -8 || response == -5 || response == -3)
  {
    if(!(d->priv->resolve_service == 0))
      tmp_if_expr_25 = !(d->priv->resolve_service_done != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_25 = (_Bool)0;
    if(tmp_if_expr_25)
      tmp_if_expr_27 = (_Bool)1;

    else
    {
      if(!(d->priv->resolve_host_name == 0))
        tmp_if_expr_26 = !(d->priv->resolve_host_name_done != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_26 = (_Bool)0;
      tmp_if_expr_27 = tmp_if_expr_26 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_27)
    {
      struct _GtkTreeIter iter;
      signed int interface;
      signed int protocol;
      char *name;
      char *type;
      struct _GdkCursor *cursor;
      unsigned long int return_value_gtk_dialog_get_type_3;
      return_value_gtk_dialog_get_type_3=gtk_dialog_get_type();
      unsigned int return_value_g_signal_lookup_4;
      return_value_g_signal_lookup_4=g_signal_lookup("response", return_value_gtk_dialog_get_type_3);
      g_signal_stop_emission((void *)dialog, return_value_g_signal_lookup_4, (unsigned int)0);
      d->priv->forward_response_id = response;
      if(!(d->priv->resolver == ((struct AvahiServiceResolver *)NULL)))
        goto __CPROVER_DUMP_L13;

      do
      {
        unsigned long int return_value_gtk_tree_view_get_type_5;
        return_value_gtk_tree_view_get_type_5=gtk_tree_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
        return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type_5);
        struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection_7;
        return_value_gtk_tree_view_get_selection_7=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast_6);
        signed int return_value_gtk_tree_selection_get_selected_8;
        return_value_gtk_tree_selection_get_selected_8=gtk_tree_selection_get_selected(return_value_gtk_tree_view_get_selection_7, (struct _GtkTreeModel **)(void *)0, &iter);
        if(return_value_gtk_tree_selection_get_selected_8 == 0)
        {
          g_return_if_fail_warning((char *)0, (const char *)"response_callback", "gtk_tree_selection_get_selected(gtk_tree_view_get_selection(GTK_TREE_VIEW(d->priv->service_tree_view)), NULL, &iter)");
          goto __CPROVER_DUMP_L13;
        }

      }
      while((_Bool)0);
      unsigned long int return_value_gtk_tree_model_get_type_9;
      return_value_gtk_tree_model_get_type_9=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
      return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_tree_model_get_type_9);
      gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_10, &iter, 0, &interface, 1, &protocol, 3, &name, 2, &type, -1);
      do
        if(d->priv->client == ((struct AvahiClient *)NULL))
        {
          g_return_if_fail_warning((char *)0, (const char *)"response_callback", "d->priv->client");
          goto __CPROVER_DUMP_L13;
        }

      while((_Bool)0);
      unsigned long int return_value_gtk_widget_get_type_11;
      return_value_gtk_widget_get_type_11=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
      return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_widget_get_type_11);
      gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast_12, 0);
      cursor=gdk_cursor_new((enum anonymous_34)GDK_WATCH);
      unsigned long int return_value_gtk_widget_get_type_13;
      return_value_gtk_widget_get_type_13=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
      return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_widget_get_type_13);
      struct _GdkWindow *return_value_gtk_widget_get_window_15;
      return_value_gtk_widget_get_window_15=gtk_widget_get_window((struct _GtkWidget *)return_value_g_type_check_instance_cast_14);
      gdk_window_set_cursor(return_value_gtk_widget_get_window_15, cursor);
      g_object_unref((void *)cursor);
      d->priv->resolver=avahi_service_resolver_new(d->priv->client, interface, protocol, name, type, d->priv->domain, d->priv->address_family, (enum anonymous_44)(!(d->priv->resolve_host_name != 0) ? AVAHI_LOOKUP_NO_ADDRESS : 0), resolve_callback, (void *)d);
      if(d->priv->resolver == ((struct AvahiServiceResolver *)NULL))
      {
        struct _GtkWidget *m;
        unsigned long int return_value_gtk_window_get_type_16;
        return_value_gtk_window_get_type_16=gtk_window_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_17;
        return_value_g_type_check_instance_cast_17=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type_16);
        char *return_value_dgettext_18;
        return_value_dgettext_18=dgettext("avahi", "Failed to create resolver for %s of type %s in domain %s: %s");
        signed int return_value_avahi_client_errno_19;
        return_value_avahi_client_errno_19=avahi_client_errno(d->priv->client);
        const char *return_value_avahi_strerror_20;
        return_value_avahi_strerror_20=avahi_strerror(return_value_avahi_client_errno_19);
        m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast_17, (enum anonymous_30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous_29)GTK_MESSAGE_ERROR, (enum anonymous_17)GTK_BUTTONS_CLOSE, return_value_dgettext_18, name, type, d->priv->domain, return_value_avahi_strerror_20);
        unsigned long int return_value_gtk_dialog_get_type_21;
        return_value_gtk_dialog_get_type_21=gtk_dialog_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
        return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type_21);
        gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_22);
        gtk_widget_destroy(m);
        unsigned long int return_value_gtk_dialog_get_type_23;
        return_value_gtk_dialog_get_type_23=gtk_dialog_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
        return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_23);
        gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_24, -6);
        goto __CPROVER_DUMP_L13;
      }

    }

  }


__CPROVER_DUMP_L13:
  ;
}

// restart_browsing
// file avahi-ui.c line 1207
static void restart_browsing(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr_2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression_1 = __r;
    if(tmp_statement_expression_1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"restart_browsing", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  if(!(d->priv->start_idle >= 1u))
    d->priv->start_idle=g_idle_add(start_callback, (void *)d);


__CPROVER_DUMP_L8:
  ;
}

// retrieve_state
// file entrygroup.c line 52
static signed int retrieve_state(struct AvahiEntryGroup *group)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  signed int state;
  struct AvahiClient *client;
  dbus_error_init(&error);
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  client = group->client;
  message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "GetState");
  _Bool tmp_if_expr_2;
  unsigned int return_value_dbus_error_is_set_1;
  unsigned int return_value_dbus_message_get_args_3;
  _Bool tmp_if_expr_5;
  unsigned int return_value_dbus_error_is_set_4;
  if(message == ((struct DBusMessage *)NULL))
    r=avahi_client_set_errno(client, -24);

  else
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_1=dbus_error_is_set(&error);
      tmp_if_expr_2 = return_value_dbus_error_is_set_1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      r=avahi_client_set_errno(client, -22);

    else
    {
      return_value_dbus_message_get_args_3=dbus_message_get_args(reply, &error, (signed int)105, &state, (signed int)0);
      if(return_value_dbus_message_get_args_3 == 0u)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4=dbus_error_is_set(&error);
        tmp_if_expr_5 = return_value_dbus_error_is_set_4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        r=avahi_client_set_errno(client, -22);

      else
      {
        dbus_message_unref(message);
        dbus_message_unref(reply);
        return state;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_6;
  return_value_dbus_error_is_set_6=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set_6 == 0u))
  {
    r=avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return r;
}

// retrieve_state_link1
// file entrygroup.c line 52
static signed int retrieve_state_link1(struct AvahiEntryGroup *group_link1)
{
  struct DBusMessage *message_link1 = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply_link1 = (struct DBusMessage *)(void *)0;
  struct DBusError error_link1;
  signed int r_link1 = 0;
  signed int state_link1;
  struct AvahiClient *client_link1;
  dbus_error_init(&error_link1);
  /* assertion group */
  assert(group_link1 != ((struct AvahiEntryGroup *)NULL));
  client_link1 = group_link1->client;
  message_link1=dbus_message_new_method_call("org.freedesktop.Avahi", group_link1->path, "org.freedesktop.Avahi.EntryGroup", "GetState");
  _Bool tmp_if_expr_2_link1;
  unsigned int return_value_dbus_error_is_set_1_link1;
  unsigned int return_value_dbus_message_get_args_3_link1;
  _Bool tmp_if_expr_5_link1;
  unsigned int return_value_dbus_error_is_set_4_link1;
  if(message_link1 == ((struct DBusMessage *)NULL))
    r_link1=avahi_client_set_errno(client_link1, -24);

  else
  {
    reply_link1=dbus_connection_send_with_reply_and_block(client_link1->bus, message_link1, -1, &error_link1);
    if(reply_link1 == ((struct DBusMessage *)NULL))
      tmp_if_expr_2_link1 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set_1_link1=dbus_error_is_set(&error_link1);
      tmp_if_expr_2_link1 = return_value_dbus_error_is_set_1_link1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2_link1)
      r_link1=avahi_client_set_errno(client_link1, -22);

    else
    {
      return_value_dbus_message_get_args_3_link1=dbus_message_get_args(reply_link1, &error_link1, (signed int)105, &state_link1, (signed int)0);
      if(return_value_dbus_message_get_args_3_link1 == 0u)
        tmp_if_expr_5_link1 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set_4_link1=dbus_error_is_set(&error_link1);
        tmp_if_expr_5_link1 = return_value_dbus_error_is_set_4_link1 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5_link1)
        r_link1=avahi_client_set_errno(client_link1, -22);

      else
      {
        dbus_message_unref(message_link1);
        dbus_message_unref(reply_link1);
        return state_link1;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set_6_link1;
  return_value_dbus_error_is_set_6_link1=dbus_error_is_set(&error_link1);
  if(!(return_value_dbus_error_is_set_6_link1 == 0u))
  {
    r_link1=avahi_client_set_dbus_error(client_link1, &error_link1);
    dbus_error_free(&error_link1);
  }

  if(!(message_link1 == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message_link1);

  if(!(reply_link1 == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply_link1);

  return r_link1;
}

// service_pulse_callback
// file avahi-ui.c line 304
static signed int service_pulse_callback(void *data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)data, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  unsigned long int return_value_gtk_progress_bar_get_type_3;
  return_value_gtk_progress_bar_get_type_3=gtk_progress_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_progress_bar, return_value_gtk_progress_bar_get_type_3);
  gtk_progress_bar_pulse((struct _GtkProgressBar *)return_value_g_type_check_instance_cast_4);
  return (signed int)!(0 != 0);
}

// service_row_activated_callback
// file avahi-ui.c line 842
static void service_row_activated_callback(struct _GtkTreeView *tree_view, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  unsigned long int return_value_gtk_dialog_get_type_3;
  return_value_gtk_dialog_get_type_3=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_3);
  unsigned long int return_value_gtk_dialog_get_type_5;
  return_value_gtk_dialog_get_type_5=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_5);
  signed int return_value_get_default_response_7;
  return_value_get_default_response_7=get_default_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_6);
  gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_4, return_value_get_default_response_7);
}

// service_selection_changed_callback
// file avahi-ui.c line 848
static void service_selection_changed_callback(struct _GtkTreeSelection *selection, void *user_data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  signed int b;
  b=gtk_tree_selection_get_selected(selection, (struct _GtkTreeModel **)(void *)0, (struct _GtkTreeIter *)(void *)0);
  unsigned long int return_value_gtk_dialog_get_type_3;
  return_value_gtk_dialog_get_type_3=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_3);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast_4, -3, b);
  unsigned long int return_value_gtk_dialog_get_type_5;
  return_value_gtk_dialog_get_type_5=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_5);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast_6, -5, b);
  unsigned long int return_value_gtk_dialog_get_type_7;
  return_value_gtk_dialog_get_type_7=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_7);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast_8, -8, b);
  unsigned long int return_value_gtk_dialog_get_type_9;
  return_value_gtk_dialog_get_type_9=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_9);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast_10, -10, b);
}

// set_nonblock
// file simple-watch.c line 118
static signed int set_nonblock(signed int fd)
{
  signed int n;
  /* assertion fd >= 0 */
  assert(fd >= 0);
  n=fcntl(fd, 3);
  if(!(n >= 0))
    return -1;

  else
    if(!((04000 & n) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl_1;
      return_value_fcntl_1=fcntl(fd, 4, n | 04000);
      return return_value_fcntl_1;
    }
}

// set_nonblock_link1
// file simple-watch.c line 118
static signed int set_nonblock_link1(signed int fd_link1)
{
  signed int n_link1;
  /* assertion fd >= 0 */
  assert(fd_link1 >= 0);
  n_link1=fcntl(fd_link1, 3);
  if(!(n_link1 >= 0))
    return -1;

  else
    if(!((04000 & n_link1) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl_1_link1;
      return_value_fcntl_1_link1=fcntl(fd_link1, 4, n_link1 | 04000);
      return return_value_fcntl_1_link1;
    }
}

// set_nonblock_link1_link1
// file simple-watch.c line 118
static signed int set_nonblock_link1_link1(signed int fd_link1_link1)
{
  signed int n_link1_link1;
  /* assertion fd >= 0 */
  assert(fd_link1_link1 >= 0);
  n_link1_link1=fcntl(fd_link1_link1, 3);
  if(!(n_link1_link1 >= 0))
    return -1;

  else
    if(!((04000 & n_link1_link1) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl_1_link1_link1;
      return_value_fcntl_1_link1_link1=fcntl(fd_link1_link1, 4, n_link1_link1 | 04000);
      return return_value_fcntl_1_link1_link1;
    }
}

// set_nonblock_link2
// file simple-watch.c line 118
static signed int set_nonblock_link2(signed int fd_link2)
{
  signed int n_link2;
  /* assertion fd >= 0 */
  assert(fd_link2 >= 0);
  n_link2=fcntl(fd_link2, 3);
  if(!(n_link2 >= 0))
    return -1;

  else
    if(!((04000 & n_link2) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl_1_link2;
      return_value_fcntl_1_link2=fcntl(fd_link2, 4, n_link2 | 04000);
      return return_value_fcntl_1_link2;
    }
}

// set_nonblock_link3
// file simple-watch.c line 118
static signed int set_nonblock_link3(signed int fd_link3)
{
  signed int n_link3;
  /* assertion fd >= 0 */
  assert(fd_link3 >= 0);
  n_link3=fcntl(fd_link3, 3);
  if(!(n_link3 >= 0))
    return -1;

  else
    if(!((04000 & n_link3) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl_1_link3;
      return_value_fcntl_1_link3=fcntl(fd_link3, 4, n_link3 | 04000);
      return return_value_fcntl_1_link3;
    }
}

// start_callback
// file avahi-ui.c line 695
static signed int start_callback(void *data)
{
  signed int error;
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type_1;
  return_value_aui_service_dialog_get_type_1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)data, return_value_aui_service_dialog_get_type_1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast_2;
  char **st;
  struct AvahiServiceBrowser **sb;
  unsigned int i;
  const char *domain;
  d->priv->start_idle = (unsigned int)0;
  _Bool tmp_if_expr_4;
  if(d->priv->browse_service_types == ((char **)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = !(*d->priv->browse_service_types != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_4)
  {
    char *return_value_dgettext_3;
    return_value_dgettext_3=dgettext("avahi", "Browse service type list is empty!");
    g_log((char *)0, (enum anonymous_10)G_LOG_LEVEL_WARNING, return_value_dgettext_3);
    return 0;
  }

  if(d->priv->client == ((struct AvahiClient *)NULL))
  {
    const struct AvahiPoll_1 *return_value_avahi_glib_poll_get_13;
    return_value_avahi_glib_poll_get_13=avahi_glib_poll_get(d->priv->glib_poll);
    d->priv->client=avahi_client_new(return_value_avahi_glib_poll_get_13, (enum anonymous_39)0, client_callback, (void *)d, &error);
    if(d->priv->client == ((struct AvahiClient *)NULL))
    {
      struct _GtkWidget *m;
      unsigned long int return_value_gtk_window_get_type_5;
      return_value_gtk_window_get_type_5=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
      return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type_5);
      char *return_value_dgettext_7;
      return_value_dgettext_7=dgettext("avahi", "Failed to connect to Avahi server: %s");
      const char *return_value_avahi_strerror_8;
      return_value_avahi_strerror_8=avahi_strerror(error);
      m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, (enum anonymous_30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous_29)GTK_MESSAGE_ERROR, (enum anonymous_17)GTK_BUTTONS_CLOSE, return_value_dgettext_7, return_value_avahi_strerror_8);
      unsigned long int return_value_gtk_dialog_get_type_9;
      return_value_gtk_dialog_get_type_9=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
      return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type_9);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_10);
      gtk_widget_destroy(m);
      unsigned long int return_value_gtk_dialog_get_type_11;
      return_value_gtk_dialog_get_type_11=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
      return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_11);
      gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_12, -6);
      return 0;
    }

  }

  domain=get_domain_name(d);
  if(domain == ((const char *)NULL))
  {
    unsigned long int return_value_gtk_dialog_get_type_14;
    return_value_gtk_dialog_get_type_14=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_15;
    return_value_g_type_check_instance_cast_15=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_14);
    gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_15, -6);
    return 0;
  }

  do
    if(domain == ((const char *)NULL))
      g_assertion_message_expr((char *)0, "avahi-ui.c", 732, (const char *)"start_callback", "domain");

  while((_Bool)0);
  signed int return_value_avahi_domain_equal_22;
  return_value_avahi_domain_equal_22=avahi_domain_equal(domain, "local.");
  unsigned long int return_value_gtk_label_get_type_16;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_17;
  char *return_value_dgettext_18;
  if(!(return_value_avahi_domain_equal_22 == 0))
  {
    return_value_gtk_label_get_type_16=gtk_label_get_type();
    return_value_g_type_check_instance_cast_17=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_label, return_value_gtk_label_get_type_16);
    return_value_dgettext_18=dgettext("avahi", "Browsing for services on <b>local network</b>:");
    gtk_label_set_markup((struct _GtkLabel *)return_value_g_type_check_instance_cast_17, return_value_dgettext_18);
  }

  else
  {
    char *t;
    char *return_value_dgettext_19;
    return_value_dgettext_19=dgettext("avahi", "Browsing for services in domain <b>%s</b>:");
    t=g_strdup_printf(return_value_dgettext_19, domain);
    unsigned long int return_value_gtk_label_get_type_20;
    return_value_gtk_label_get_type_20=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_21;
    return_value_g_type_check_instance_cast_21=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_label, return_value_gtk_label_get_type_20);
    gtk_label_set_markup((struct _GtkLabel *)return_value_g_type_check_instance_cast_21, t);
    g_free((void *)t);
  }
  if(!(d->priv->browsers == ((struct AvahiServiceBrowser **)NULL)))
  {
    sb = d->priv->browsers;
    for( ; !(*sb == ((struct AvahiServiceBrowser *)NULL)); sb = sb + 1l)
      avahi_service_browser_free(*sb);
    g_free((void *)d->priv->browsers);
    d->priv->browsers = (struct AvahiServiceBrowser **)(void *)0;
  }

  unsigned long int return_value_gtk_list_store_get_type_23;
  return_value_gtk_list_store_get_type_23=gtk_list_store_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
  return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_list_store_get_type_23);
  gtk_list_store_clear((struct _GtkListStore *)return_value_g_type_check_instance_cast_24);
  d->priv->common_interface = -1;
  d->priv->common_protocol = -1;
  unsigned long int return_value_gtk_tree_view_get_type_25;
  return_value_gtk_tree_view_get_type_25=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
  return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type_25);
  struct _GtkTreeViewColumn *return_value_gtk_tree_view_get_column_27;
  return_value_gtk_tree_view_get_column_27=gtk_tree_view_get_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_26, 0);
  gtk_tree_view_column_set_visible(return_value_gtk_tree_view_get_column_27, 0);
  unsigned long int return_value_gtk_tree_view_get_type_28;
  return_value_gtk_tree_view_get_type_28=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_29;
  return_value_g_type_check_instance_cast_29=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type_28);
  gtk_tree_view_set_headers_visible((struct _GtkTreeView *)return_value_g_type_check_instance_cast_29, 0);
  gtk_widget_show(d->priv->service_progress_bar);
  if(!(d->priv->service_pulse_timeout >= 1u))
    d->priv->service_pulse_timeout=g_timeout_add((unsigned int)100, service_pulse_callback, (void *)d);

  i = (unsigned int)0;
  for( ; !(d->priv->browse_service_types[(signed long int)i] == ((char *)NULL)); i = i + 1u)
    ;
  do
    if(!(i >= 1u))
      g_assertion_message_expr((char *)0, "avahi-ui.c", 763, (const char *)"start_callback", "i > 0");

  while((_Bool)0);
  void *return_value_g_malloc0_n_30;
  return_value_g_malloc0_n_30=g_malloc0_n((unsigned long int)(i + (unsigned int)1), sizeof(struct AvahiServiceBrowser *) /*8ul*/ );
  d->priv->browsers = (struct AvahiServiceBrowser **)return_value_g_malloc0_n_30;
  st = d->priv->browse_service_types;
  sb = d->priv->browsers;
  for( ; !(*st == ((char *)NULL)); sb = sb + 1l)
  {
    *sb=avahi_service_browser_new(d->priv->client, -1, -1, *st, d->priv->domain, (enum anonymous_44)0, browse_callback, (void *)d);
    if(*sb == ((struct AvahiServiceBrowser *)NULL))
    {
      struct _GtkWidget *start_callback__1__9__1__1__m;
      unsigned long int return_value_gtk_window_get_type_31;
      return_value_gtk_window_get_type_31=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_32;
      return_value_g_type_check_instance_cast_32=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type_31);
      char *return_value_dgettext_33;
      return_value_dgettext_33=dgettext("avahi", "Failed to create browser for %s: %s");
      signed int return_value_avahi_client_errno_34;
      return_value_avahi_client_errno_34=avahi_client_errno(d->priv->client);
      const char *return_value_avahi_strerror_35;
      return_value_avahi_strerror_35=avahi_strerror(return_value_avahi_client_errno_34);
      start_callback__1__9__1__1__m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast_32, (enum anonymous_30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous_29)GTK_MESSAGE_ERROR, (enum anonymous_17)GTK_BUTTONS_CLOSE, return_value_dgettext_33, *st, return_value_avahi_strerror_35);
      unsigned long int return_value_gtk_dialog_get_type_36;
      return_value_gtk_dialog_get_type_36=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_37;
      return_value_g_type_check_instance_cast_37=g_type_check_instance_cast((struct _GTypeInstance *)start_callback__1__9__1__1__m, return_value_gtk_dialog_get_type_36);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_37);
      gtk_widget_destroy(start_callback__1__9__1__1__m);
      unsigned long int return_value_gtk_dialog_get_type_38;
      return_value_gtk_dialog_get_type_38=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_39;
      return_value_g_type_check_instance_cast_39=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type_38);
      gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast_39, -6);
      return 0;
    }

    st = st + 1l;
  }
  return 0;
}

// start_timeout_callback
// file glib-watch.c line 246
static void start_timeout_callback(struct AvahiTimeout *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  /* assertion t->enabled */
  assert(t->enabled != 0);
  t->enabled = 0;
  t->callback(t, t->userdata);
}

// stdb_getent
// file ../avahi-utils/stdb.c line 168
char * stdb_getent(void)
{
  struct anonymous_37 key;
  signed int return_value_init_1;
  return_value_init_1=init();
  if(!(return_value_init_1 >= 0))
    return (char *)(void *)0;

  else
    while((_Bool)1)
    {
      if(enum_key == ((char *)NULL))
        key=gdbm_firstkey(gdbm_file);

      else
      {
        key.dptr = enum_key;
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(enum_key);
        key.dsize = (signed int)return_value_strlen_2;
        key=gdbm_nextkey(gdbm_file, key);
      }
      avahi_free((void *)enum_key);
      enum_key = (char *)(void *)0;
      if(key.dptr == ((char *)NULL))
        return (char *)(void *)0;

      enum_key=avahi_strndup(key.dptr, (unsigned long int)key.dsize);
      free((void *)key.dptr);
      char *return_value_strchr_3;
      return_value_strchr_3=strchr(enum_key, 91);
      if(return_value_strchr_3 == ((char *)NULL))
        return enum_key;

    }
}

// stdb_lookup
// file ../avahi-utils/stdb.h line 25
const char * stdb_lookup(const char *name)
{
  struct anonymous_37 key;
  struct anonymous_37 data;
  const char *loc;
  signed int return_value_init_1;
  return_value_init_1=init();
  if(return_value_init_1 >= 0)
  {
    data.dptr = (char *)(void *)0;
    data.dsize = 0;
    loc=setlocale(5, (const char *)(void *)0);
    if(!(loc == ((const char *)NULL)))
    {
      char k[256l];
      snprintf(k, sizeof(char [256l]) /*256ul*/ , "%s[%s]", name, loc);
      key.dptr = k;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(k);
      key.dsize = (signed int)return_value_strlen_2;
      data=gdbm_fetch(gdbm_file, key);
      if(data.dptr == ((char *)NULL))
      {
        char l[32l];
        char *e;
        snprintf(l, sizeof(char [32l]) /*32ul*/ , "%s", loc);
        e=strchr(l, 64);
        if(!(e == ((char *)NULL)))
        {
          *e = (char)0;
          snprintf(k, sizeof(char [256l]) /*256ul*/ , "%s[%s]", name, (const void *)l);
          key.dptr = k;
          unsigned long int return_value_strlen_3;
          return_value_strlen_3=strlen(k);
          key.dsize = (signed int)return_value_strlen_3;
          data=gdbm_fetch(gdbm_file, key);
        }

        if(data.dptr == ((char *)NULL))
        {
          e=strchr(l, 95);
          if(!(e == ((char *)NULL)))
          {
            *e = (char)0;
            snprintf(k, sizeof(char [256l]) /*256ul*/ , "%s[%s]", name, (const void *)l);
            key.dptr = k;
            unsigned long int return_value_strlen_4;
            return_value_strlen_4=strlen(k);
            key.dsize = (signed int)return_value_strlen_4;
            data=gdbm_fetch(gdbm_file, key);
          }

        }

      }

    }

    if(data.dptr == ((char *)NULL))
    {
      key.dptr = (char *)name;
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(name);
      key.dsize = (signed int)return_value_strlen_5;
      data=gdbm_fetch(gdbm_file, key);
    }

    if(data.dptr == ((char *)NULL))
      goto fail;

    avahi_free((void *)buffer);
    buffer=avahi_strndup(data.dptr, (unsigned long int)data.dsize);
    free((void *)data.dptr);
    return buffer;
  }

  else
  {

  fail:
    ;
    return name;
  }
}

// stdb_setent
// file ../avahi-utils/stdb.c line 209
void stdb_setent(void)
{
  avahi_free((void *)enum_key);
  enum_key = (char *)(void *)0;
}

// stdb_shutdown
// file ../avahi-utils/stdb.c line 148
void stdb_shutdown(void)
{
  if(!(gdbm_file == ((struct anonymous_36 *)NULL)))
    gdbm_close(gdbm_file);

  gdbm_file = (struct anonymous_36 *)(void *)0;
  avahi_free((void *)buffer);
  avahi_free((void *)enum_key);
  enum_key = (char *)(void *)0;
  buffer = enum_key;
}

// strlcpy
// file domain.c line 482
static unsigned long int strlcpy(char *dest, const char *src, unsigned long int n)
{
  /* assertion dest */
  assert(dest != ((char *)NULL));
  /* assertion src */
  assert(src != ((const char *)NULL));
  if(n >= 1ul)
  {
    strncpy(dest, src, n - (unsigned long int)1);
    dest[(signed long int)(n - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(src);
  return return_value_strlen_1;
}

// strlcpy_link1
// file domain.c line 482
static unsigned long int strlcpy_link1(char *dest_link1, const char *src_link1, unsigned long int n_link1)
{
  /* assertion dest */
  assert(dest_link1 != ((char *)NULL));
  /* assertion src */
  assert(src_link1 != ((const char *)NULL));
  if(n_link1 >= 1ul)
  {
    strncpy(dest_link1, src_link1, n_link1 - (unsigned long int)1);
    dest_link1[(signed long int)(n_link1 - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen_1_link1;
  return_value_strlen_1_link1=strlen(src_link1);
  return return_value_strlen_1_link1;
}

// strlcpy_link1_link1
// file domain.c line 482
static unsigned long int strlcpy_link1_link1(char *dest_link1_link1, const char *src_link1_link1, unsigned long int n_link1_link1)
{
  /* assertion dest */
  assert(dest_link1_link1 != ((char *)NULL));
  /* assertion src */
  assert(src_link1_link1 != ((const char *)NULL));
  if(n_link1_link1 >= 1ul)
  {
    strncpy(dest_link1_link1, src_link1_link1, n_link1_link1 - (unsigned long int)1);
    dest_link1_link1[(signed long int)(n_link1_link1 - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen_1_link1_link1;
  return_value_strlen_1_link1_link1=strlen(src_link1_link1);
  return return_value_strlen_1_link1_link1;
}

// strlcpy_link2
// file domain.c line 482
static unsigned long int strlcpy_link2(char *dest_link2, const char *src_link2, unsigned long int n_link2)
{
  /* assertion dest */
  assert(dest_link2 != ((char *)NULL));
  /* assertion src */
  assert(src_link2 != ((const char *)NULL));
  if(n_link2 >= 1ul)
  {
    strncpy(dest_link2, src_link2, n_link2 - (unsigned long int)1);
    dest_link2[(signed long int)(n_link2 - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen_1_link2;
  return_value_strlen_1_link2=strlen(src_link2);
  return return_value_strlen_1_link2;
}

// strlcpy_link3
// file domain.c line 482
static unsigned long int strlcpy_link3(char *dest_link3, const char *src_link3, unsigned long int n_link3)
{
  /* assertion dest */
  assert(dest_link3 != ((char *)NULL));
  /* assertion src */
  assert(src_link3 != ((const char *)NULL));
  if(n_link3 >= 1ul)
  {
    strncpy(dest_link3, src_link3, n_link3 - (unsigned long int)1);
    dest_link3[(signed long int)(n_link3 - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen_1_link3;
  return_value_strlen_1_link3=strlen(src_link3);
  return return_value_strlen_1_link3;
}

// system_poll
// file simple-watch.c line 626
static signed int system_poll(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata)
{
  signed int return_value_poll_1;
  return_value_poll_1=poll(ufds, (unsigned long int)nfds, timeout);
  return return_value_poll_1;
}

// system_poll_link1
// file simple-watch.c line 626
static signed int system_poll_link1(struct pollfd *ufds_link1, unsigned int nfds_link1, signed int timeout_link1, void *userdata_link1)
{
  signed int return_value_poll_1_link1;
  return_value_poll_1_link1=poll(ufds_link1, (unsigned long int)nfds_link1, timeout_link1);
  return return_value_poll_1_link1;
}

// system_poll_link1_link1
// file simple-watch.c line 626
static signed int system_poll_link1_link1(struct pollfd *ufds_link1_link1, unsigned int nfds_link1_link1, signed int timeout_link1_link1, void *userdata_link1_link1)
{
  signed int return_value_poll_1_link1_link1;
  return_value_poll_1_link1_link1=poll(ufds_link1_link1, (unsigned long int)nfds_link1_link1, timeout_link1_link1);
  return return_value_poll_1_link1_link1;
}

// system_poll_link2
// file simple-watch.c line 626
static signed int system_poll_link2(struct pollfd *ufds_link2, unsigned int nfds_link2, signed int timeout_link2, void *userdata_link2)
{
  signed int return_value_poll_1_link2;
  return_value_poll_1_link2=poll(ufds_link2, (unsigned long int)nfds_link2, timeout_link2);
  return return_value_poll_1_link2;
}

// system_poll_link3
// file simple-watch.c line 626
static signed int system_poll_link3(struct pollfd *ufds_link3, unsigned int nfds_link3, signed int timeout_link3, void *userdata_link3)
{
  signed int return_value_poll_1_link3;
  return_value_poll_1_link3=poll(ufds_link3, (unsigned long int)nfds_link3, timeout_link3);
  return return_value_poll_1_link3;
}

// thread
// file thread-watch.c line 62
static void * thread(void *userdata)
{
  struct AvahiThreadedPoll_0 *p = (struct AvahiThreadedPoll_0 *)userdata;
  struct anonymous_8 mask;
  sigfillset(&mask);
  pthread_sigmask(0, &mask, (struct anonymous_8 *)(void *)0);
  pthread_mutex_lock(&p->mutex);
  p->retval=avahi_simple_poll_loop(p->simple_poll);
  pthread_mutex_unlock(&p->mutex);
  return (void *)0;
}

// thread_link1
// file thread-watch.c line 62
static void * thread_link1(void *userdata_link1)
{
  struct AvahiThreadedPoll_0 *p_link1 = (struct AvahiThreadedPoll_0 *)userdata_link1;
  struct anonymous_8 mask_link1;
  sigfillset(&mask_link1);
  pthread_sigmask(0, &mask_link1, (struct anonymous_8 *)(void *)0);
  pthread_mutex_lock(&p_link1->mutex);
  p_link1->retval=avahi_simple_poll_loop(p_link1->simple_poll);
  pthread_mutex_unlock(&p_link1->mutex);
  return (void *)0;
}

// thread_link1_link1
// file thread-watch.c line 62
static void * thread_link1_link1(void *userdata_link1_link1)
{
  struct AvahiThreadedPoll_0 *p_link1_link1 = (struct AvahiThreadedPoll_0 *)userdata_link1_link1;
  struct anonymous_8 mask_link1_link1;
  sigfillset(&mask_link1_link1);
  pthread_sigmask(0, &mask_link1_link1, (struct anonymous_8 *)(void *)0);
  pthread_mutex_lock(&p_link1_link1->mutex);
  p_link1_link1->retval=avahi_simple_poll_loop(p_link1_link1->simple_poll);
  pthread_mutex_unlock(&p_link1_link1->mutex);
  return (void *)0;
}

// thread_link2
// file thread-watch.c line 62
static void * thread_link2(void *userdata_link2)
{
  struct AvahiThreadedPoll *p_link2 = (struct AvahiThreadedPoll *)userdata_link2;
  struct anonymous_8 mask_link2;
  sigfillset(&mask_link2);
  pthread_sigmask(0, &mask_link2, (struct anonymous_8 *)(void *)0);
  pthread_mutex_lock(&p_link2->mutex);
  p_link2->retval=avahi_simple_poll_loop(p_link2->simple_poll);
  pthread_mutex_unlock(&p_link2->mutex);
  return (void *)0;
}

// thread_link3
// file thread-watch.c line 62
static void * thread_link3(void *userdata_link3)
{
  struct AvahiThreadedPoll_0 *p_link3 = (struct AvahiThreadedPoll_0 *)userdata_link3;
  struct anonymous_8 mask_link3;
  sigfillset(&mask_link3);
  pthread_sigmask(0, &mask_link3, (struct anonymous_8 *)(void *)0);
  pthread_mutex_lock(&p_link3->mutex);
  p_link3->retval=avahi_simple_poll_loop(p_link3->simple_poll);
  pthread_mutex_unlock(&p_link3->mutex);
  return (void *)0;
}

// timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 237
static void timeout_callback(struct AvahiTimeout_1 *avahi_timeout, void *userdata)
{
  struct TimeoutData *timeout = (struct TimeoutData *)userdata;
  /* assertion avahi_timeout */
  assert(avahi_timeout != ((struct AvahiTimeout_1 *)NULL));
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  timeout_data_ref(timeout);
  dbus_timeout_handle(timeout->dbus_timeout);
  if(!(timeout->avahi_timeout == ((struct AvahiTimeout_1 *)NULL)))
    update_timeout(timeout);

  timeout_data_unref(timeout);
}

// timeout_callback_link1
// file simple-watch.c line 441
static void timeout_callback_link1(struct AvahiTimeout_1 *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout_1 *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  /* assertion t->enabled */
  assert(t->enabled != 0);
  t->enabled = 0;
  t->callback(t, t->userdata);
}

// timeout_callback_link1_link1
// file simple-watch.c line 441
static void timeout_callback_link1_link1(struct AvahiTimeout_1 *t_link1_link1)
{
  /* assertion t */
  assert(t_link1_link1 != ((struct AvahiTimeout_1 *)NULL));
  /* assertion !t->dead */
  assert(!(t_link1_link1->dead != 0));
  /* assertion t->enabled */
  assert(t_link1_link1->enabled != 0);
  t_link1_link1->enabled = 0;
  t_link1_link1->callback(t_link1_link1, t_link1_link1->userdata);
}

// timeout_callback_link2
// file simple-watch.c line 441
static void timeout_callback_link2(struct AvahiTimeout_1 *t_link1)
{
  /* assertion t */
  assert(t_link1 != ((struct AvahiTimeout_1 *)NULL));
  /* assertion !t->dead */
  assert(!(t_link1->dead != 0));
  /* assertion t->enabled */
  assert(t_link1->enabled != 0);
  t_link1->enabled = 0;
  t_link1->callback(t_link1, t_link1->userdata);
}

// timeout_callback_link2_link1
// file ../avahi-common/dbus-watch-glue.c line 237
static void timeout_callback_link2_link1(struct AvahiTimeout_1 *avahi_timeout_link1, void *userdata_link1)
{
  struct TimeoutData *timeout_link1 = (struct TimeoutData *)userdata_link1;
  /* assertion avahi_timeout */
  assert(avahi_timeout_link1 != ((struct AvahiTimeout_1 *)NULL));
  /* assertion timeout */
  assert(timeout_link1 != ((struct TimeoutData *)NULL));
  timeout_data_ref_link1(timeout_link1);
  dbus_timeout_handle(timeout_link1->dbus_timeout);
  if(!(timeout_link1->avahi_timeout == ((struct AvahiTimeout_1 *)NULL)))
    update_timeout_link1(timeout_link1);

  timeout_data_unref_link1(timeout_link1);
}

// timeout_callback_link3
// file simple-watch.c line 441
static void timeout_callback_link3(struct AvahiTimeout_0 *t_link2)
{
  /* assertion t */
  assert(t_link2 != ((struct AvahiTimeout_0 *)NULL));
  /* assertion !t->dead */
  assert(!(t_link2->dead != 0));
  /* assertion t->enabled */
  assert(t_link2->enabled != 0);
  t_link2->enabled = 0;
  t_link2->callback(t_link2, t_link2->userdata);
}

// timeout_callback_link4
// file simple-watch.c line 441
static void timeout_callback_link4(struct AvahiTimeout_1 *t_link3)
{
  /* assertion t */
  assert(t_link3 != ((struct AvahiTimeout_1 *)NULL));
  /* assertion !t->dead */
  assert(!(t_link3->dead != 0));
  /* assertion t->enabled */
  assert(t_link3->enabled != 0);
  t_link3->enabled = 0;
  t_link3->callback(t_link3, t_link3->userdata);
}

// timeout_data_ref
// file ../avahi-common/dbus-watch-glue.c line 203
static struct TimeoutData * timeout_data_ref(struct TimeoutData *t)
{
  /* assertion t */
  assert(t != ((struct TimeoutData *)NULL));
  /* assertion t->ref >= 1 */
  assert(t->ref >= 1);
  t->ref = t->ref + 1;
  return t;
}

// timeout_data_ref_link1
// file ../avahi-common/dbus-watch-glue.c line 203
static struct TimeoutData * timeout_data_ref_link1(struct TimeoutData *t_link1)
{
  /* assertion t */
  assert(t_link1 != ((struct TimeoutData *)NULL));
  /* assertion t->ref >= 1 */
  assert(t_link1->ref >= 1);
  t_link1->ref = t_link1->ref + 1;
  return t_link1;
}

// timeout_data_unref
// file ../avahi-common/dbus-watch-glue.c line 211
static void timeout_data_unref(struct TimeoutData *t)
{
  /* assertion t */
  assert(t != ((struct TimeoutData *)NULL));
  /* assertion t->ref >= 1 */
  assert(t->ref >= 1);
  t->ref = t->ref - 1;
  if(!(t->ref >= 1))
  {
    if(!(t->avahi_timeout == ((struct AvahiTimeout_1 *)NULL)))
      t->poll_api->timeout_free(t->avahi_timeout);

    avahi_free((void *)t);
  }

}

// timeout_data_unref_link1
// file ../avahi-common/dbus-watch-glue.c line 211
static void timeout_data_unref_link1(struct TimeoutData *t_link1)
{
  /* assertion t */
  assert(t_link1 != ((struct TimeoutData *)NULL));
  /* assertion t->ref >= 1 */
  assert(t_link1->ref >= 1);
  t_link1->ref = t_link1->ref - 1;
  if(!(t_link1->ref >= 1))
  {
    if(!(t_link1->avahi_timeout == ((struct AvahiTimeout_1 *)NULL)))
      t_link1->poll_api->timeout_free(t_link1->avahi_timeout);

    avahi_free((void *)t_link1);
  }

}

// timeout_free
// file simple-watch.c line 284
static void timeout_free(struct AvahiTimeout_1 *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout_1 *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  avahi_simple_poll_wakeup(t->simple_poll);
  t->dead = 1;
  t->simple_poll->timeout_req_cleanup = 1;
}

// timeout_free_link1
// file simple-watch.c line 284
static void timeout_free_link1(struct AvahiTimeout_1 *t_link1)
{
  /* assertion t */
  assert(t_link1 != ((struct AvahiTimeout_1 *)NULL));
  /* assertion !t->dead */
  assert(!(t_link1->dead != 0));
  avahi_simple_poll_wakeup(t_link1->simple_poll);
  t_link1->dead = 1;
  t_link1->simple_poll->timeout_req_cleanup = 1;
}

// timeout_free_link1_link1
// file simple-watch.c line 284
static void timeout_free_link1_link1(struct AvahiTimeout_0 *t_link1_link1)
{
  /* assertion t */
  assert(t_link1_link1 != ((struct AvahiTimeout_0 *)NULL));
  /* assertion !t->dead */
  assert(!(t_link1_link1->dead != 0));
  avahi_simple_poll_wakeup(t_link1_link1->simple_poll);
  t_link1_link1->dead = 1;
  t_link1_link1->simple_poll->timeout_req_cleanup = 1;
}

// timeout_free_link1_link2
// file simple-watch.c line 284
static void timeout_free_link1_link2(struct AvahiTimeout_1 *t_link1_link2)
{
  /* assertion t */
  assert(t_link1_link2 != ((struct AvahiTimeout_1 *)NULL));
  /* assertion !t->dead */
  assert(!(t_link1_link2->dead != 0));
  avahi_simple_poll_wakeup(t_link1_link2->simple_poll);
  t_link1_link2->dead = 1;
  t_link1_link2->simple_poll->timeout_req_cleanup = 1;
}

// timeout_free_link2
// file glib-watch.c line 201
static void timeout_free_link2(struct AvahiTimeout *t_link2)
{
  /* assertion t */
  assert(t_link2 != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t_link2->dead != 0));
  t_link2->dead = (signed int)!(0 != 0);
  t_link2->glib_poll->timeout_req_cleanup = (signed int)!(0 != 0);
}

// timeout_free_link3
// file simple-watch.c line 284
static void timeout_free_link3(struct AvahiTimeout_1 *t_link3)
{
  /* assertion t */
  assert(t_link3 != ((struct AvahiTimeout_1 *)NULL));
  /* assertion !t->dead */
  assert(!(t_link3->dead != 0));
  avahi_simple_poll_wakeup(t_link3->simple_poll);
  t_link3->dead = 1;
  t_link3->simple_poll->timeout_req_cleanup = 1;
}

// timeout_new
// file simple-watch.c line 244
static struct AvahiTimeout_1 * timeout_new(const struct AvahiPoll_1 *api, struct timeval *tv, void (*callback)(struct AvahiTimeout_1 *, void *), void *userdata)
{
  struct AvahiTimeout_1 *t;
  struct AvahiSimplePoll_0 *s;
  /* assertion api */
  assert(api != ((const struct AvahiPoll_1 *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiTimeout_1 *, void *))NULL));
  s = (struct AvahiSimplePoll_0 *)api->userdata;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link2_link1((unsigned int)1, sizeof(struct AvahiTimeout_1) /*64ul*/ );
  t = (struct AvahiTimeout_1 *)return_value_avahi_new_internal_1;
  if(t == ((struct AvahiTimeout_1 *)NULL))
    return (struct AvahiTimeout_1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s);
    t->simple_poll = s;
    t->dead = 0;
    t->enabled = (signed int)!(!(tv != ((struct timeval *)NULL)));
    if(!(t->enabled == 0))
      t->expiry = *tv;

    t->callback = callback;
    t->userdata = userdata;
    do
    {
      struct AvahiTimeout_1 **_head = &s->timeouts;
      struct AvahiTimeout_1 *_item = t;
      /* assertion _item */
      assert(_item != ((struct AvahiTimeout_1 *)NULL));
      _item->timeouts_next = *_head;
      if(!(_item->timeouts_next == ((struct AvahiTimeout_1 *)NULL)))
        _item->timeouts_next->timeouts_prev = _item;

      _item->timeouts_prev = (struct AvahiTimeout_1 *)(void *)0;
      *_head = _item;
    }
    while((_Bool)0);
    return t;
  }
}

// timeout_new_link1
// file simple-watch.c line 244
static struct AvahiTimeout_1 * timeout_new_link1(const struct AvahiPoll_1 *api_link1, struct timeval *tv_link1, void (*callback_link1)(struct AvahiTimeout_1 *, void *), void *userdata_link1)
{
  struct AvahiTimeout_1 *t_link1;
  struct AvahiSimplePoll_0 *s_link1;
  /* assertion api */
  assert(api_link1 != ((const struct AvahiPoll_1 *)NULL));
  /* assertion callback */
  assert(callback_link1 != ((void (*)(struct AvahiTimeout_1 *, void *))NULL));
  s_link1 = (struct AvahiSimplePoll_0 *)api_link1->userdata;
  /* assertion s */
  assert(s_link1 != ((struct AvahiSimplePoll_0 *)NULL));
  void *return_value_avahi_new_internal_1_link1;
  return_value_avahi_new_internal_1_link1=avahi_new_internal_link2_link2((unsigned int)1, sizeof(struct AvahiTimeout_1) /*64ul*/ );
  t_link1 = (struct AvahiTimeout_1 *)return_value_avahi_new_internal_1_link1;
  if(t_link1 == ((struct AvahiTimeout_1 *)NULL))
    return (struct AvahiTimeout_1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s_link1);
    t_link1->simple_poll = s_link1;
    t_link1->dead = 0;
    t_link1->enabled = (signed int)!(!(tv_link1 != ((struct timeval *)NULL)));
    if(!(t_link1->enabled == 0))
      t_link1->expiry = *tv_link1;

    t_link1->callback = callback_link1;
    t_link1->userdata = userdata_link1;
    do
    {
      struct AvahiTimeout_1 **_head_link1 = &s_link1->timeouts;
      struct AvahiTimeout_1 *_item_link1 = t_link1;
      /* assertion _item */
      assert(_item_link1 != ((struct AvahiTimeout_1 *)NULL));
      _item_link1->timeouts_next = *_head_link1;
      if(!(_item_link1->timeouts_next == ((struct AvahiTimeout_1 *)NULL)))
        _item_link1->timeouts_next->timeouts_prev = _item_link1;

      _item_link1->timeouts_prev = (struct AvahiTimeout_1 *)(void *)0;
      *_head_link1 = _item_link1;
    }
    while((_Bool)0);
    return t_link1;
  }
}

// timeout_new_link1_link1
// file simple-watch.c line 244
static struct AvahiTimeout_0 * timeout_new_link1_link1(const struct AvahiPoll_0 *api_link1_link1, struct timeval *tv_link1_link1, void (*callback_link1_link1)(struct AvahiTimeout_0 *, void *), void *userdata_link1_link1)
{
  struct AvahiTimeout_0 *t_link1_link1;
  struct AvahiSimplePoll *s_link2;
  /* assertion api */
  assert(api_link1_link1 != ((const struct AvahiPoll_0 *)NULL));
  /* assertion callback */
  assert(callback_link1_link1 != ((void (*)(struct AvahiTimeout_0 *, void *))NULL));
  s_link2 = (struct AvahiSimplePoll *)api_link1_link1->userdata;
  /* assertion s */
  assert(s_link2 != ((struct AvahiSimplePoll *)NULL));
  void *return_value_avahi_new_internal_1_link1_link1;
  return_value_avahi_new_internal_1_link1_link1=avahi_new_internal_link2_link3((unsigned int)1, sizeof(struct AvahiTimeout_0) /*64ul*/ );
  t_link1_link1 = (struct AvahiTimeout_0 *)return_value_avahi_new_internal_1_link1_link1;
  if(t_link1_link1 == ((struct AvahiTimeout_0 *)NULL))
    return (struct AvahiTimeout_0 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s_link2);
    t_link1_link1->simple_poll = s_link2;
    t_link1_link1->dead = 0;
    t_link1_link1->enabled = (signed int)!(!(tv_link1_link1 != ((struct timeval *)NULL)));
    if(!(t_link1_link1->enabled == 0))
      t_link1_link1->expiry = *tv_link1_link1;

    t_link1_link1->callback = callback_link1_link1;
    t_link1_link1->userdata = userdata_link1_link1;
    do
    {
      struct AvahiTimeout_0 **_head_link1_link1 = &s_link2->timeouts;
      struct AvahiTimeout_0 *_item_link1_link1 = t_link1_link1;
      /* assertion _item */
      assert(_item_link1_link1 != ((struct AvahiTimeout_0 *)NULL));
      _item_link1_link1->timeouts_next = *_head_link1_link1;
      if(!(_item_link1_link1->timeouts_next == ((struct AvahiTimeout_0 *)NULL)))
        _item_link1_link1->timeouts_next->timeouts_prev = _item_link1_link1;

      _item_link1_link1->timeouts_prev = (struct AvahiTimeout_0 *)(void *)0;
      *_head_link1_link1 = _item_link1_link1;
    }
    while((_Bool)0);
    return t_link1_link1;
  }
}

// timeout_new_link1_link2
// file simple-watch.c line 244
static struct AvahiTimeout_1 * timeout_new_link1_link2(const struct AvahiPoll_1 *api_link1_link2, struct timeval *tv_link1_link2, void (*callback_link1_link2)(struct AvahiTimeout_1 *, void *), void *userdata_link1_link2)
{
  struct AvahiTimeout_1 *t_link1_link2;
  struct AvahiSimplePoll_0 *s_link1_link1;
  /* assertion api */
  assert(api_link1_link2 != ((const struct AvahiPoll_1 *)NULL));
  /* assertion callback */
  assert(callback_link1_link2 != ((void (*)(struct AvahiTimeout_1 *, void *))NULL));
  s_link1_link1 = (struct AvahiSimplePoll_0 *)api_link1_link2->userdata;
  /* assertion s */
  assert(s_link1_link1 != ((struct AvahiSimplePoll_0 *)NULL));
  void *return_value_avahi_new_internal_1_link1_link2;
  return_value_avahi_new_internal_1_link1_link2=avahi_new_internal_link2_link1_link1((unsigned int)1, sizeof(struct AvahiTimeout_1) /*64ul*/ );
  t_link1_link2 = (struct AvahiTimeout_1 *)return_value_avahi_new_internal_1_link1_link2;
  if(t_link1_link2 == ((struct AvahiTimeout_1 *)NULL))
    return (struct AvahiTimeout_1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s_link1_link1);
    t_link1_link2->simple_poll = s_link1_link1;
    t_link1_link2->dead = 0;
    t_link1_link2->enabled = (signed int)!(!(tv_link1_link2 != ((struct timeval *)NULL)));
    if(!(t_link1_link2->enabled == 0))
      t_link1_link2->expiry = *tv_link1_link2;

    t_link1_link2->callback = callback_link1_link2;
    t_link1_link2->userdata = userdata_link1_link2;
    do
    {
      struct AvahiTimeout_1 **_head_link1_link2 = &s_link1_link1->timeouts;
      struct AvahiTimeout_1 *_item_link1_link2 = t_link1_link2;
      /* assertion _item */
      assert(_item_link1_link2 != ((struct AvahiTimeout_1 *)NULL));
      _item_link1_link2->timeouts_next = *_head_link1_link2;
      if(!(_item_link1_link2->timeouts_next == ((struct AvahiTimeout_1 *)NULL)))
        _item_link1_link2->timeouts_next->timeouts_prev = _item_link1_link2;

      _item_link1_link2->timeouts_prev = (struct AvahiTimeout_1 *)(void *)0;
      *_head_link1_link2 = _item_link1_link2;
    }
    while((_Bool)0);
    return t_link1_link2;
  }
}

// timeout_new_link2
// file glib-watch.c line 166
static struct AvahiTimeout * timeout_new_link2(const struct AvahiPoll *api_link2, struct timeval *tv_link2, void (*callback_link2)(struct AvahiTimeout *, void *), void *userdata_link2)
{
  struct AvahiTimeout *t_link2;
  struct AvahiGLibPoll *g;
  /* assertion api */
  assert(api_link2 != ((const struct AvahiPoll *)NULL));
  /* assertion callback */
  assert(callback_link2 != ((void (*)(struct AvahiTimeout *, void *))NULL));
  g = (struct AvahiGLibPoll *)api_link2->userdata;
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  void *return_value_avahi_new_internal_1_link2;
  return_value_avahi_new_internal_1_link2=avahi_new_internal_link7((unsigned int)1, sizeof(struct AvahiTimeout) /*64ul*/ );
  t_link2 = (struct AvahiTimeout *)return_value_avahi_new_internal_1_link2;
  if(t_link2 == ((struct AvahiTimeout *)NULL))
    return (struct AvahiTimeout *)(void *)0;

  else
  {
    t_link2->glib_poll = g;
    t_link2->dead = 0;
    t_link2->enabled = (signed int)!(!(tv_link2 != ((struct timeval *)NULL)));
    if(!(t_link2->enabled == 0))
      t_link2->expiry = *tv_link2;

    t_link2->callback = callback_link2;
    t_link2->userdata = userdata_link2;
    do
    {
      struct AvahiTimeout **_head_link2 = &g->timeouts;
      struct AvahiTimeout *_item_link2 = t_link2;
      /* assertion _item */
      assert(_item_link2 != ((struct AvahiTimeout *)NULL));
      _item_link2->timeouts_next = *_head_link2;
      if(!(_item_link2->timeouts_next == ((struct AvahiTimeout *)NULL)))
        _item_link2->timeouts_next->timeouts_prev = _item_link2;

      _item_link2->timeouts_prev = (struct AvahiTimeout *)(void *)0;
      *_head_link2 = _item_link2;
    }
    while((_Bool)0);
    return t_link2;
  }
}

// timeout_new_link3
// file simple-watch.c line 244
static struct AvahiTimeout_1 * timeout_new_link3(const struct AvahiPoll_1 *api_link3, struct timeval *tv_link3, void (*callback_link3)(struct AvahiTimeout_1 *, void *), void *userdata_link3)
{
  struct AvahiTimeout_1 *t_link3;
  struct AvahiSimplePoll_0 *s_link3;
  /* assertion api */
  assert(api_link3 != ((const struct AvahiPoll_1 *)NULL));
  /* assertion callback */
  assert(callback_link3 != ((void (*)(struct AvahiTimeout_1 *, void *))NULL));
  s_link3 = (struct AvahiSimplePoll_0 *)api_link3->userdata;
  /* assertion s */
  assert(s_link3 != ((struct AvahiSimplePoll_0 *)NULL));
  void *return_value_avahi_new_internal_1_link3;
  return_value_avahi_new_internal_1_link3=avahi_new_internal_link2_link4((unsigned int)1, sizeof(struct AvahiTimeout_1) /*64ul*/ );
  t_link3 = (struct AvahiTimeout_1 *)return_value_avahi_new_internal_1_link3;
  if(t_link3 == ((struct AvahiTimeout_1 *)NULL))
    return (struct AvahiTimeout_1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s_link3);
    t_link3->simple_poll = s_link3;
    t_link3->dead = 0;
    t_link3->enabled = (signed int)!(!(tv_link3 != ((struct timeval *)NULL)));
    if(!(t_link3->enabled == 0))
      t_link3->expiry = *tv_link3;

    t_link3->callback = callback_link3;
    t_link3->userdata = userdata_link3;
    do
    {
      struct AvahiTimeout_1 **_head_link3 = &s_link3->timeouts;
      struct AvahiTimeout_1 *_item_link3 = t_link3;
      /* assertion _item */
      assert(_item_link3 != ((struct AvahiTimeout_1 *)NULL));
      _item_link3->timeouts_next = *_head_link3;
      if(!(_item_link3->timeouts_next == ((struct AvahiTimeout_1 *)NULL)))
        _item_link3->timeouts_next->timeouts_prev = _item_link3;

      _item_link3->timeouts_prev = (struct AvahiTimeout_1 *)(void *)0;
      *_head_link3 = _item_link3;
    }
    while((_Bool)0);
    return t_link3;
  }
}

// timeout_toggled
// file ../avahi-common/dbus-watch-glue.c line 300
static void timeout_toggled(struct DBusTimeout *dbus_timeout, void *userdata)
{
  struct TimeoutData *timeout;
  /* assertion dbus_timeout */
  assert(dbus_timeout != ((struct DBusTimeout *)NULL));
  void *return_value_dbus_timeout_get_data_1;
  return_value_dbus_timeout_get_data_1=dbus_timeout_get_data(dbus_timeout);
  timeout = (struct TimeoutData *)return_value_dbus_timeout_get_data_1;
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  update_timeout(timeout);
}

// timeout_toggled_link1
// file ../avahi-common/dbus-watch-glue.c line 300
static void timeout_toggled_link1(struct DBusTimeout *dbus_timeout_link1, void *userdata_link1)
{
  struct TimeoutData *timeout_link1;
  /* assertion dbus_timeout */
  assert(dbus_timeout_link1 != ((struct DBusTimeout *)NULL));
  void *return_value_dbus_timeout_get_data_1_link1;
  return_value_dbus_timeout_get_data_1_link1=dbus_timeout_get_data(dbus_timeout_link1);
  timeout_link1 = (struct TimeoutData *)return_value_dbus_timeout_get_data_1_link1;
  /* assertion timeout */
  assert(timeout_link1 != ((struct TimeoutData *)NULL));
  update_timeout_link1(timeout_link1);
}

// timeout_update
// file simple-watch.c line 273
static void timeout_update(struct AvahiTimeout_1 *t, struct timeval *tv)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout_1 *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  avahi_simple_poll_wakeup(t->simple_poll);
  t->enabled = (signed int)!(!(tv != ((struct timeval *)NULL)));
  if(!(t->enabled == 0))
    t->expiry = *tv;

}

// timeout_update_link1
// file simple-watch.c line 273
static void timeout_update_link1(struct AvahiTimeout_1 *t_link1, struct timeval *tv_link1)
{
  /* assertion t */
  assert(t_link1 != ((struct AvahiTimeout_1 *)NULL));
  /* assertion !t->dead */
  assert(!(t_link1->dead != 0));
  avahi_simple_poll_wakeup(t_link1->simple_poll);
  t_link1->enabled = (signed int)!(!(tv_link1 != ((struct timeval *)NULL)));
  if(!(t_link1->enabled == 0))
    t_link1->expiry = *tv_link1;

}

// timeout_update_link1_link1
// file simple-watch.c line 273
static void timeout_update_link1_link1(struct AvahiTimeout_0 *t_link1_link1, struct timeval *tv_link1_link1)
{
  /* assertion t */
  assert(t_link1_link1 != ((struct AvahiTimeout_0 *)NULL));
  /* assertion !t->dead */
  assert(!(t_link1_link1->dead != 0));
  avahi_simple_poll_wakeup(t_link1_link1->simple_poll);
  t_link1_link1->enabled = (signed int)!(!(tv_link1_link1 != ((struct timeval *)NULL)));
  if(!(t_link1_link1->enabled == 0))
    t_link1_link1->expiry = *tv_link1_link1;

}

// timeout_update_link1_link2
// file simple-watch.c line 273
static void timeout_update_link1_link2(struct AvahiTimeout_1 *t_link1_link2, struct timeval *tv_link1_link2)
{
  /* assertion t */
  assert(t_link1_link2 != ((struct AvahiTimeout_1 *)NULL));
  /* assertion !t->dead */
  assert(!(t_link1_link2->dead != 0));
  avahi_simple_poll_wakeup(t_link1_link2->simple_poll);
  t_link1_link2->enabled = (signed int)!(!(tv_link1_link2 != ((struct timeval *)NULL)));
  if(!(t_link1_link2->enabled == 0))
    t_link1_link2->expiry = *tv_link1_link2;

}

// timeout_update_link2
// file glib-watch.c line 193
static void timeout_update_link2(struct AvahiTimeout *t_link2, struct timeval *tv_link2)
{
  /* assertion t */
  assert(t_link2 != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t_link2->dead != 0));
  t_link2->enabled = (signed int)!(!(tv_link2 != ((struct timeval *)NULL)));
  if(!(t_link2->enabled == 0))
    t_link2->expiry = *tv_link2;

}

// timeout_update_link3
// file simple-watch.c line 273
static void timeout_update_link3(struct AvahiTimeout_1 *t_link3, struct timeval *tv_link3)
{
  /* assertion t */
  assert(t_link3 != ((struct AvahiTimeout_1 *)NULL));
  /* assertion !t->dead */
  assert(!(t_link3->dead != 0));
  avahi_simple_poll_wakeup(t_link3->simple_poll);
  t_link3->enabled = (signed int)!(!(tv_link3 != ((struct timeval *)NULL)));
  if(!(t_link3->enabled == 0))
    t_link3->expiry = *tv_link3;

}

// translate_avahi_to_dbus
// file ../avahi-common/dbus-watch-glue.c line 46
static unsigned int translate_avahi_to_dbus(enum anonymous e)
{
  unsigned int f = (unsigned int)0;
  if(!((AVAHI_WATCH_IN & (signed int)e) == 0))
    f = f | (unsigned int)1;

  if(!((AVAHI_WATCH_OUT & (signed int)e) == 0))
    f = f | (unsigned int)2;

  if(!((AVAHI_WATCH_ERR & (signed int)e) == 0))
    f = f | (unsigned int)4;

  if(!((AVAHI_WATCH_HUP & (signed int)e) == 0))
    f = f | (unsigned int)8;

  return f;
}

// translate_avahi_to_dbus_link1
// file ../avahi-common/dbus-watch-glue.c line 46
static unsigned int translate_avahi_to_dbus_link1(enum anonymous e_link1)
{
  unsigned int f_link1 = (unsigned int)0;
  if(!((AVAHI_WATCH_IN & (signed int)e_link1) == 0))
    f_link1 = f_link1 | (unsigned int)1;

  if(!((AVAHI_WATCH_OUT & (signed int)e_link1) == 0))
    f_link1 = f_link1 | (unsigned int)2;

  if(!((AVAHI_WATCH_ERR & (signed int)e_link1) == 0))
    f_link1 = f_link1 | (unsigned int)4;

  if(!((AVAHI_WATCH_HUP & (signed int)e_link1) == 0))
    f_link1 = f_link1 | (unsigned int)8;

  return f_link1;
}

// translate_dbus_to_avahi
// file ../avahi-common/dbus-watch-glue.c line 31
static enum anonymous translate_dbus_to_avahi(unsigned int f)
{
  enum anonymous e = (enum anonymous)0;
  if(!((1u & f) == 0u))
    e = e | (enum anonymous)AVAHI_WATCH_IN;

  if(!((2u & f) == 0u))
    e = e | (enum anonymous)AVAHI_WATCH_OUT;

  if(!((4u & f) == 0u))
    e = e | (enum anonymous)AVAHI_WATCH_ERR;

  if(!((8u & f) == 0u))
    e = e | (enum anonymous)AVAHI_WATCH_HUP;

  return e;
}

// translate_dbus_to_avahi_link1
// file ../avahi-common/dbus-watch-glue.c line 31
static enum anonymous translate_dbus_to_avahi_link1(unsigned int f_link1)
{
  enum anonymous e_link1 = (enum anonymous)0;
  if(!((1u & f_link1) == 0u))
    e_link1 = e_link1 | (enum anonymous)AVAHI_WATCH_IN;

  if(!((2u & f_link1) == 0u))
    e_link1 = e_link1 | (enum anonymous)AVAHI_WATCH_OUT;

  if(!((4u & f_link1) == 0u))
    e_link1 = e_link1 | (enum anonymous)AVAHI_WATCH_ERR;

  if(!((8u & f_link1) == 0u))
    e_link1 = e_link1 | (enum anonymous)AVAHI_WATCH_HUP;

  return e_link1;
}

// update_timeout
// file ../avahi-common/dbus-watch-glue.c line 223
static void update_timeout(struct TimeoutData *timeout)
{
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  /* assertion timeout->ref >= 1 */
  assert(timeout->ref >= 1);
  unsigned int return_value_dbus_timeout_get_enabled_2;
  return_value_dbus_timeout_get_enabled_2=dbus_timeout_get_enabled(timeout->dbus_timeout);
  if(!(return_value_dbus_timeout_get_enabled_2 == 0u))
  {
    struct timeval tv;
    signed int return_value_dbus_timeout_get_interval_1;
    return_value_dbus_timeout_get_interval_1=dbus_timeout_get_interval(timeout->dbus_timeout);
    avahi_elapse_time(&tv, (unsigned int)return_value_dbus_timeout_get_interval_1, (unsigned int)0);
    timeout->poll_api->timeout_update(timeout->avahi_timeout, &tv);
  }

  else
    timeout->poll_api->timeout_update(timeout->avahi_timeout, (struct timeval *)(void *)0);
}

// update_timeout_link1
// file ../avahi-common/dbus-watch-glue.c line 223
static void update_timeout_link1(struct TimeoutData *timeout_link1)
{
  /* assertion timeout */
  assert(timeout_link1 != ((struct TimeoutData *)NULL));
  /* assertion timeout->ref >= 1 */
  assert(timeout_link1->ref >= 1);
  unsigned int return_value_dbus_timeout_get_enabled_2_link1;
  return_value_dbus_timeout_get_enabled_2_link1=dbus_timeout_get_enabled(timeout_link1->dbus_timeout);
  if(!(return_value_dbus_timeout_get_enabled_2_link1 == 0u))
  {
    struct timeval tv_link1;
    signed int return_value_dbus_timeout_get_interval_1_link1;
    return_value_dbus_timeout_get_interval_1_link1=dbus_timeout_get_interval(timeout_link1->dbus_timeout);
    avahi_elapse_time(&tv_link1, (unsigned int)return_value_dbus_timeout_get_interval_1_link1, (unsigned int)0);
    timeout_link1->poll_api->timeout_update(timeout_link1->avahi_timeout, &tv_link1);
  }

  else
    timeout_link1->poll_api->timeout_update(timeout_link1->avahi_timeout, (struct timeval *)(void *)0);
}

// update_watch
// file ../avahi-common/dbus-watch-glue.c line 125
static unsigned int update_watch(const struct AvahiPoll_1 *poll_api, struct DBusWatch *dbus_watch)
{
  struct AvahiWatch_1 *avahi_watch;
  unsigned int b;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  void *return_value_dbus_watch_get_data_1;
  return_value_dbus_watch_get_data_1=dbus_watch_get_data(dbus_watch);
  avahi_watch = (struct AvahiWatch_1 *)return_value_dbus_watch_get_data_1;
  b=dbus_watch_get_enabled(dbus_watch);
  if(avahi_watch == ((struct AvahiWatch_1 *)NULL) && !(b == 0u))
  {
    signed int return_value_dbus_watch_get_unix_fd_2;
    return_value_dbus_watch_get_unix_fd_2=dbus_watch_get_unix_fd(dbus_watch);
    unsigned int return_value_dbus_watch_get_flags_3;
    return_value_dbus_watch_get_flags_3=dbus_watch_get_flags(dbus_watch);
    enum anonymous return_value_translate_dbus_to_avahi_4;
    return_value_translate_dbus_to_avahi_4=translate_dbus_to_avahi(return_value_dbus_watch_get_flags_3);
    avahi_watch=poll_api->watch_new(poll_api, return_value_dbus_watch_get_unix_fd_2, return_value_translate_dbus_to_avahi_4, watch_callback, (void *)dbus_watch);
    if(avahi_watch == ((struct AvahiWatch_1 *)NULL))
      return (unsigned int)0;

    dbus_watch_set_data(dbus_watch, (void *)avahi_watch, (void (*)(void *))(void *)0);
  }

  else
    if(b == 0u && !(avahi_watch == ((struct AvahiWatch_1 *)NULL)))
    {
      poll_api->watch_free(avahi_watch);
      dbus_watch_set_data(dbus_watch, (void *)0, (void (*)(void *))(void *)0);
    }

    else
      if(!(avahi_watch == ((struct AvahiWatch_1 *)NULL)))
      {
        unsigned int return_value_dbus_watch_get_flags_5;
        return_value_dbus_watch_get_flags_5=dbus_watch_get_flags(dbus_watch);
        poll_api->watch_update(avahi_watch, (enum anonymous)return_value_dbus_watch_get_flags_5);
      }

  return (unsigned int)1;
}

// update_watch_link1
// file ../avahi-common/dbus-watch-glue.c line 125
static unsigned int update_watch_link1(const struct AvahiPoll_1 *poll_api_link1, struct DBusWatch *dbus_watch_link1)
{
  struct AvahiWatch_1 *avahi_watch_link1;
  unsigned int b_link1;
  /* assertion dbus_watch */
  assert(dbus_watch_link1 != ((struct DBusWatch *)NULL));
  void *return_value_dbus_watch_get_data_1_link1;
  return_value_dbus_watch_get_data_1_link1=dbus_watch_get_data(dbus_watch_link1);
  avahi_watch_link1 = (struct AvahiWatch_1 *)return_value_dbus_watch_get_data_1_link1;
  b_link1=dbus_watch_get_enabled(dbus_watch_link1);
  if(avahi_watch_link1 == ((struct AvahiWatch_1 *)NULL) && !(b_link1 == 0u))
  {
    signed int return_value_dbus_watch_get_unix_fd_2_link1;
    return_value_dbus_watch_get_unix_fd_2_link1=dbus_watch_get_unix_fd(dbus_watch_link1);
    unsigned int return_value_dbus_watch_get_flags_3_link1;
    return_value_dbus_watch_get_flags_3_link1=dbus_watch_get_flags(dbus_watch_link1);
    enum anonymous return_value_translate_dbus_to_avahi_4_link1;
    return_value_translate_dbus_to_avahi_4_link1=translate_dbus_to_avahi_link1(return_value_dbus_watch_get_flags_3_link1);
    avahi_watch_link1=poll_api_link1->watch_new(poll_api_link1, return_value_dbus_watch_get_unix_fd_2_link1, return_value_translate_dbus_to_avahi_4_link1, watch_callback_link1, (void *)dbus_watch_link1);
    if(avahi_watch_link1 == ((struct AvahiWatch_1 *)NULL))
      return (unsigned int)0;

    dbus_watch_set_data(dbus_watch_link1, (void *)avahi_watch_link1, (void (*)(void *))(void *)0);
  }

  else
    if(b_link1 == 0u && !(avahi_watch_link1 == ((struct AvahiWatch_1 *)NULL)))
    {
      poll_api_link1->watch_free(avahi_watch_link1);
      dbus_watch_set_data(dbus_watch_link1, (void *)0, (void (*)(void *))(void *)0);
    }

    else
      if(!(avahi_watch_link1 == ((struct AvahiWatch_1 *)NULL)))
      {
        unsigned int return_value_dbus_watch_get_flags_5_link1;
        return_value_dbus_watch_get_flags_5_link1=dbus_watch_get_flags(dbus_watch_link1);
        poll_api_link1->watch_update(avahi_watch_link1, (enum anonymous)return_value_dbus_watch_get_flags_5_link1);
      }

  return (unsigned int)1;
}

// watch_callback
// file ../avahi-common/dbus-watch-glue.c line 115
static void watch_callback(struct AvahiWatch_1 *avahi_watch, signed int fd, enum anonymous events, void *userdata)
{
  struct DBusWatch *dbus_watch = (struct DBusWatch *)userdata;
  /* assertion avahi_watch */
  assert(avahi_watch != ((struct AvahiWatch_1 *)NULL));
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  unsigned int return_value_translate_avahi_to_dbus_1;
  return_value_translate_avahi_to_dbus_1=translate_avahi_to_dbus(events);
  dbus_watch_handle(dbus_watch, return_value_translate_avahi_to_dbus_1);
}

// watch_callback_link1
// file ../avahi-common/dbus-watch-glue.c line 115
static void watch_callback_link1(struct AvahiWatch_1 *avahi_watch_link1, signed int fd_link1, enum anonymous events_link1, void *userdata_link1)
{
  struct DBusWatch *dbus_watch_link1 = (struct DBusWatch *)userdata_link1;
  /* assertion avahi_watch */
  assert(avahi_watch_link1 != ((struct AvahiWatch_1 *)NULL));
  /* assertion dbus_watch */
  assert(dbus_watch_link1 != ((struct DBusWatch *)NULL));
  unsigned int return_value_translate_avahi_to_dbus_1_link1;
  return_value_translate_avahi_to_dbus_1_link1=translate_avahi_to_dbus_link1(events_link1);
  dbus_watch_handle(dbus_watch_link1, return_value_translate_avahi_to_dbus_1_link1);
}

// watch_free
// file simple-watch.c line 203
static void watch_free(struct AvahiWatch_1 *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch_1 *)NULL));
  /* assertion !w->dead */
  assert(!(w->dead != 0));
  avahi_simple_poll_wakeup(w->simple_poll);
  remove_pollfd(w);
  w->dead = 1;
  w->simple_poll->n_watches = w->simple_poll->n_watches - 1;
  w->simple_poll->watch_req_cleanup = 1;
}

// watch_free_link1
// file simple-watch.c line 203
static void watch_free_link1(struct AvahiWatch_1 *w_link1)
{
  /* assertion w */
  assert(w_link1 != ((struct AvahiWatch_1 *)NULL));
  /* assertion !w->dead */
  assert(!(w_link1->dead != 0));
  avahi_simple_poll_wakeup(w_link1->simple_poll);
  remove_pollfd_link1(w_link1);
  w_link1->dead = 1;
  w_link1->simple_poll->n_watches = w_link1->simple_poll->n_watches - 1;
  w_link1->simple_poll->watch_req_cleanup = 1;
}

// watch_free_link1_link1
// file simple-watch.c line 203
static void watch_free_link1_link1(struct AvahiWatch *w_link1_link1)
{
  /* assertion w */
  assert(w_link1_link1 != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w_link1_link1->dead != 0));
  avahi_simple_poll_wakeup(w_link1_link1->simple_poll);
  remove_pollfd_link2(w_link1_link1);
  w_link1_link1->dead = 1;
  w_link1_link1->simple_poll->n_watches = w_link1_link1->simple_poll->n_watches - 1;
  w_link1_link1->simple_poll->watch_req_cleanup = 1;
}

// watch_free_link1_link2
// file simple-watch.c line 203
static void watch_free_link1_link2(struct AvahiWatch_1 *w_link1_link2)
{
  /* assertion w */
  assert(w_link1_link2 != ((struct AvahiWatch_1 *)NULL));
  /* assertion !w->dead */
  assert(!(w_link1_link2->dead != 0));
  avahi_simple_poll_wakeup(w_link1_link2->simple_poll);
  remove_pollfd_link1_link1(w_link1_link2);
  w_link1_link2->dead = 1;
  w_link1_link2->simple_poll->n_watches = w_link1_link2->simple_poll->n_watches - 1;
  w_link1_link2->simple_poll->watch_req_cleanup = 1;
}

// watch_free_link2
// file glib-watch.c line 153
static void watch_free_link2(struct AvahiWatch_0 *w_link2)
{
  /* assertion w */
  assert(w_link2 != ((struct AvahiWatch_0 *)NULL));
  /* assertion !w->dead */
  assert(!(w_link2->dead != 0));
  if(!(w_link2->pollfd_added == 0))
  {
    g_source_remove_poll(&w_link2->glib_poll->source, &w_link2->pollfd);
    w_link2->pollfd_added = 0;
  }

  w_link2->dead = (signed int)!(0 != 0);
  w_link2->glib_poll->timeout_req_cleanup = (signed int)!(0 != 0);
}

// watch_free_link3
// file simple-watch.c line 203
static void watch_free_link3(struct AvahiWatch_1 *w_link3)
{
  /* assertion w */
  assert(w_link3 != ((struct AvahiWatch_1 *)NULL));
  /* assertion !w->dead */
  assert(!(w_link3->dead != 0));
  avahi_simple_poll_wakeup(w_link3->simple_poll);
  remove_pollfd_link3(w_link3);
  w_link3->dead = 1;
  w_link3->simple_poll->n_watches = w_link3->simple_poll->n_watches - 1;
  w_link3->simple_poll->watch_req_cleanup = 1;
}

// watch_get_events
// file simple-watch.c line 184
static enum anonymous watch_get_events(struct AvahiWatch_1 *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch_1 *)NULL));
  /* assertion !w->dead */
  assert(!(w->dead != 0));
  if(!(w->idx == -1))
  {
    if(w->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous)(w->simple_poll->pollfds + (signed long int)w->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous)0;
  }
}

// watch_get_events_link1
// file simple-watch.c line 184
static enum anonymous watch_get_events_link1(struct AvahiWatch_1 *w_link1)
{
  /* assertion w */
  assert(w_link1 != ((struct AvahiWatch_1 *)NULL));
  /* assertion !w->dead */
  assert(!(w_link1->dead != 0));
  if(!(w_link1->idx == -1))
  {
    if(w_link1->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous)(w_link1->simple_poll->pollfds + (signed long int)w_link1->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous)0;
  }
}

// watch_get_events_link1_link1
// file simple-watch.c line 184
static enum anonymous watch_get_events_link1_link1(struct AvahiWatch *w_link1_link1)
{
  /* assertion w */
  assert(w_link1_link1 != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w_link1_link1->dead != 0));
  if(!(w_link1_link1->idx == -1))
  {
    if(w_link1_link1->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous)(w_link1_link1->simple_poll->pollfds + (signed long int)w_link1_link1->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous)0;
  }
}

// watch_get_events_link1_link2
// file simple-watch.c line 184
static enum anonymous watch_get_events_link1_link2(struct AvahiWatch_1 *w_link1_link2)
{
  /* assertion w */
  assert(w_link1_link2 != ((struct AvahiWatch_1 *)NULL));
  /* assertion !w->dead */
  assert(!(w_link1_link2->dead != 0));
  if(!(w_link1_link2->idx == -1))
  {
    if(w_link1_link2->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous)(w_link1_link2->simple_poll->pollfds + (signed long int)w_link1_link2->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous)0;
  }
}

// watch_get_events_link2
// file glib-watch.c line 146
static enum anonymous watch_get_events_link2(struct AvahiWatch_0 *w_link2)
{
  /* assertion w */
  assert(w_link2 != ((struct AvahiWatch_0 *)NULL));
  /* assertion !w->dead */
  assert(!(w_link2->dead != 0));
  enum anonymous return_value_map_events_from_glib_1;
  return_value_map_events_from_glib_1=map_events_from_glib(w_link2->pollfd.revents);
  return return_value_map_events_from_glib_1;
}

// watch_get_events_link3
// file simple-watch.c line 184
static enum anonymous watch_get_events_link3(struct AvahiWatch_1 *w_link3)
{
  /* assertion w */
  assert(w_link3 != ((struct AvahiWatch_1 *)NULL));
  /* assertion !w->dead */
  assert(!(w_link3->dead != 0));
  if(!(w_link3->idx == -1))
  {
    if(w_link3->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous)(w_link3->simple_poll->pollfds + (signed long int)w_link3->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous)0;
  }
}

// watch_new
// file simple-watch.c line 132
static struct AvahiWatch_1 * watch_new(const struct AvahiPoll_1 *api, signed int fd, enum anonymous event, void (*callback)(struct AvahiWatch_1 *, signed int, enum anonymous, void *), void *userdata)
{
  struct AvahiWatch_1 *w;
  struct AvahiSimplePoll_0 *s;
  /* assertion api */
  assert(api != ((const struct AvahiPoll_1 *)NULL));
  /* assertion fd >= 0 */
  assert(fd >= 0);
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiWatch_1 *, signed int, enum anonymous, void *))NULL));
  s = (struct AvahiSimplePoll_0 *)api->userdata;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll_0 *)NULL));
  void *return_value_avahi_new_internal_1;
  return_value_avahi_new_internal_1=avahi_new_internal_link2_link1((unsigned int)1, sizeof(struct AvahiWatch_1) /*56ul*/ );
  w = (struct AvahiWatch_1 *)return_value_avahi_new_internal_1;
  if(w == ((struct AvahiWatch_1 *)NULL))
    return (struct AvahiWatch_1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s);
    w->simple_poll = s;
    w->dead = 0;
    w->pollfd.fd = fd;
    w->pollfd.events = (signed short int)event;
    w->pollfd.revents = (signed short int)0;
    w->callback = callback;
    w->userdata = userdata;
    w->idx = -1;
    s->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch_1 **_head = &s->watches;
      struct AvahiWatch_1 *_item = w;
      /* assertion _item */
      assert(_item != ((struct AvahiWatch_1 *)NULL));
      _item->watches_next = *_head;
      if(!(_item->watches_next == ((struct AvahiWatch_1 *)NULL)))
        _item->watches_next->watches_prev = _item;

      _item->watches_prev = (struct AvahiWatch_1 *)(void *)0;
      *_head = _item;
    }
    while((_Bool)0);
    s->n_watches = s->n_watches + 1;
    return w;
  }
}

// watch_new_link1
// file simple-watch.c line 132
static struct AvahiWatch_1 * watch_new_link1(const struct AvahiPoll_1 *api_link1, signed int fd_link1, enum anonymous event_link1, void (*callback_link1)(struct AvahiWatch_1 *, signed int, enum anonymous, void *), void *userdata_link1)
{
  struct AvahiWatch_1 *w_link1;
  struct AvahiSimplePoll_0 *s_link1;
  /* assertion api */
  assert(api_link1 != ((const struct AvahiPoll_1 *)NULL));
  /* assertion fd >= 0 */
  assert(fd_link1 >= 0);
  /* assertion callback */
  assert(callback_link1 != ((void (*)(struct AvahiWatch_1 *, signed int, enum anonymous, void *))NULL));
  s_link1 = (struct AvahiSimplePoll_0 *)api_link1->userdata;
  /* assertion s */
  assert(s_link1 != ((struct AvahiSimplePoll_0 *)NULL));
  void *return_value_avahi_new_internal_1_link1;
  return_value_avahi_new_internal_1_link1=avahi_new_internal_link2_link2((unsigned int)1, sizeof(struct AvahiWatch_1) /*56ul*/ );
  w_link1 = (struct AvahiWatch_1 *)return_value_avahi_new_internal_1_link1;
  if(w_link1 == ((struct AvahiWatch_1 *)NULL))
    return (struct AvahiWatch_1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s_link1);
    w_link1->simple_poll = s_link1;
    w_link1->dead = 0;
    w_link1->pollfd.fd = fd_link1;
    w_link1->pollfd.events = (signed short int)event_link1;
    w_link1->pollfd.revents = (signed short int)0;
    w_link1->callback = callback_link1;
    w_link1->userdata = userdata_link1;
    w_link1->idx = -1;
    s_link1->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch_1 **_head_link1 = &s_link1->watches;
      struct AvahiWatch_1 *_item_link1 = w_link1;
      /* assertion _item */
      assert(_item_link1 != ((struct AvahiWatch_1 *)NULL));
      _item_link1->watches_next = *_head_link1;
      if(!(_item_link1->watches_next == ((struct AvahiWatch_1 *)NULL)))
        _item_link1->watches_next->watches_prev = _item_link1;

      _item_link1->watches_prev = (struct AvahiWatch_1 *)(void *)0;
      *_head_link1 = _item_link1;
    }
    while((_Bool)0);
    s_link1->n_watches = s_link1->n_watches + 1;
    return w_link1;
  }
}

// watch_new_link1_link1
// file simple-watch.c line 132
static struct AvahiWatch * watch_new_link1_link1(const struct AvahiPoll_0 *api_link1_link1, signed int fd_link1_link1, enum anonymous event_link2, void (*callback_link1_link1)(struct AvahiWatch *, signed int, enum anonymous, void *), void *userdata_link1_link1)
{
  struct AvahiWatch *w_link1_link1;
  struct AvahiSimplePoll *s_link2;
  /* assertion api */
  assert(api_link1_link1 != ((const struct AvahiPoll_0 *)NULL));
  /* assertion fd >= 0 */
  assert(fd_link1_link1 >= 0);
  /* assertion callback */
  assert(callback_link1_link1 != ((void (*)(struct AvahiWatch *, signed int, enum anonymous, void *))NULL));
  s_link2 = (struct AvahiSimplePoll *)api_link1_link1->userdata;
  /* assertion s */
  assert(s_link2 != ((struct AvahiSimplePoll *)NULL));
  void *return_value_avahi_new_internal_1_link1_link1;
  return_value_avahi_new_internal_1_link1_link1=avahi_new_internal_link2_link3((unsigned int)1, sizeof(struct AvahiWatch) /*56ul*/ );
  w_link1_link1 = (struct AvahiWatch *)return_value_avahi_new_internal_1_link1_link1;
  if(w_link1_link1 == ((struct AvahiWatch *)NULL))
    return (struct AvahiWatch *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s_link2);
    w_link1_link1->simple_poll = s_link2;
    w_link1_link1->dead = 0;
    w_link1_link1->pollfd.fd = fd_link1_link1;
    w_link1_link1->pollfd.events = (signed short int)event_link2;
    w_link1_link1->pollfd.revents = (signed short int)0;
    w_link1_link1->callback = callback_link1_link1;
    w_link1_link1->userdata = userdata_link1_link1;
    w_link1_link1->idx = -1;
    s_link2->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch **_head_link1_link1 = &s_link2->watches;
      struct AvahiWatch *_item_link1_link1 = w_link1_link1;
      /* assertion _item */
      assert(_item_link1_link1 != ((struct AvahiWatch *)NULL));
      _item_link1_link1->watches_next = *_head_link1_link1;
      if(!(_item_link1_link1->watches_next == ((struct AvahiWatch *)NULL)))
        _item_link1_link1->watches_next->watches_prev = _item_link1_link1;

      _item_link1_link1->watches_prev = (struct AvahiWatch *)(void *)0;
      *_head_link1_link1 = _item_link1_link1;
    }
    while((_Bool)0);
    s_link2->n_watches = s_link2->n_watches + 1;
    return w_link1_link1;
  }
}

// watch_new_link1_link2
// file simple-watch.c line 132
static struct AvahiWatch_1 * watch_new_link1_link2(const struct AvahiPoll_1 *api_link1_link2, signed int fd_link1_link2, enum anonymous event_link1_link1, void (*callback_link1_link2)(struct AvahiWatch_1 *, signed int, enum anonymous, void *), void *userdata_link1_link2)
{
  struct AvahiWatch_1 *w_link1_link2;
  struct AvahiSimplePoll_0 *s_link1_link1;
  /* assertion api */
  assert(api_link1_link2 != ((const struct AvahiPoll_1 *)NULL));
  /* assertion fd >= 0 */
  assert(fd_link1_link2 >= 0);
  /* assertion callback */
  assert(callback_link1_link2 != ((void (*)(struct AvahiWatch_1 *, signed int, enum anonymous, void *))NULL));
  s_link1_link1 = (struct AvahiSimplePoll_0 *)api_link1_link2->userdata;
  /* assertion s */
  assert(s_link1_link1 != ((struct AvahiSimplePoll_0 *)NULL));
  void *return_value_avahi_new_internal_1_link1_link2;
  return_value_avahi_new_internal_1_link1_link2=avahi_new_internal_link2_link1_link1((unsigned int)1, sizeof(struct AvahiWatch_1) /*56ul*/ );
  w_link1_link2 = (struct AvahiWatch_1 *)return_value_avahi_new_internal_1_link1_link2;
  if(w_link1_link2 == ((struct AvahiWatch_1 *)NULL))
    return (struct AvahiWatch_1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s_link1_link1);
    w_link1_link2->simple_poll = s_link1_link1;
    w_link1_link2->dead = 0;
    w_link1_link2->pollfd.fd = fd_link1_link2;
    w_link1_link2->pollfd.events = (signed short int)event_link1_link1;
    w_link1_link2->pollfd.revents = (signed short int)0;
    w_link1_link2->callback = callback_link1_link2;
    w_link1_link2->userdata = userdata_link1_link2;
    w_link1_link2->idx = -1;
    s_link1_link1->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch_1 **_head_link1_link2 = &s_link1_link1->watches;
      struct AvahiWatch_1 *_item_link1_link2 = w_link1_link2;
      /* assertion _item */
      assert(_item_link1_link2 != ((struct AvahiWatch_1 *)NULL));
      _item_link1_link2->watches_next = *_head_link1_link2;
      if(!(_item_link1_link2->watches_next == ((struct AvahiWatch_1 *)NULL)))
        _item_link1_link2->watches_next->watches_prev = _item_link1_link2;

      _item_link1_link2->watches_prev = (struct AvahiWatch_1 *)(void *)0;
      *_head_link1_link2 = _item_link1_link2;
    }
    while((_Bool)0);
    s_link1_link1->n_watches = s_link1_link1->n_watches + 1;
    return w_link1_link2;
  }
}

// watch_new_link2
// file glib-watch.c line 109
static struct AvahiWatch_0 * watch_new_link2(const struct AvahiPoll *api_link2, signed int fd_link2, enum anonymous events, void (*callback_link2)(struct AvahiWatch_0 *, signed int, enum anonymous, void *), void *userdata_link2)
{
  struct AvahiWatch_0 *w_link2;
  struct AvahiGLibPoll *g;
  /* assertion api */
  assert(api_link2 != ((const struct AvahiPoll *)NULL));
  /* assertion fd >= 0 */
  assert(fd_link2 >= 0);
  /* assertion callback */
  assert(callback_link2 != ((void (*)(struct AvahiWatch_0 *, signed int, enum anonymous, void *))NULL));
  g = (struct AvahiGLibPoll *)api_link2->userdata;
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  void *return_value_avahi_new_internal_1_link2;
  return_value_avahi_new_internal_1_link2=avahi_new_internal_link7((unsigned int)1, sizeof(struct AvahiWatch_0) /*56ul*/ );
  w_link2 = (struct AvahiWatch_0 *)return_value_avahi_new_internal_1_link2;
  if(w_link2 == ((struct AvahiWatch_0 *)NULL))
    return (struct AvahiWatch_0 *)(void *)0;

  else
  {
    w_link2->glib_poll = g;
    w_link2->pollfd.fd = fd_link2;
    w_link2->pollfd.events=map_events_to_glib(events);
    w_link2->pollfd.revents = (unsigned short int)0;
    w_link2->callback = callback_link2;
    w_link2->userdata = userdata_link2;
    w_link2->dead = 0;
    g_source_add_poll(&g->source, &w_link2->pollfd);
    w_link2->pollfd_added = (signed int)!(0 != 0);
    do
    {
      struct AvahiWatch_0 **_head_link2 = &g->watches;
      struct AvahiWatch_0 *_item_link2 = w_link2;
      /* assertion _item */
      assert(_item_link2 != ((struct AvahiWatch_0 *)NULL));
      _item_link2->watches_next = *_head_link2;
      if(!(_item_link2->watches_next == ((struct AvahiWatch_0 *)NULL)))
        _item_link2->watches_next->watches_prev = _item_link2;

      _item_link2->watches_prev = (struct AvahiWatch_0 *)(void *)0;
      *_head_link2 = _item_link2;
    }
    while((_Bool)0);
    return w_link2;
  }
}

// watch_new_link3
// file simple-watch.c line 132
static struct AvahiWatch_1 * watch_new_link3(const struct AvahiPoll_1 *api_link3, signed int fd_link3, enum anonymous event_link3, void (*callback_link3)(struct AvahiWatch_1 *, signed int, enum anonymous, void *), void *userdata_link3)
{
  struct AvahiWatch_1 *w_link3;
  struct AvahiSimplePoll_0 *s_link3;
  /* assertion api */
  assert(api_link3 != ((const struct AvahiPoll_1 *)NULL));
  /* assertion fd >= 0 */
  assert(fd_link3 >= 0);
  /* assertion callback */
  assert(callback_link3 != ((void (*)(struct AvahiWatch_1 *, signed int, enum anonymous, void *))NULL));
  s_link3 = (struct AvahiSimplePoll_0 *)api_link3->userdata;
  /* assertion s */
  assert(s_link3 != ((struct AvahiSimplePoll_0 *)NULL));
  void *return_value_avahi_new_internal_1_link3;
  return_value_avahi_new_internal_1_link3=avahi_new_internal_link2_link4((unsigned int)1, sizeof(struct AvahiWatch_1) /*56ul*/ );
  w_link3 = (struct AvahiWatch_1 *)return_value_avahi_new_internal_1_link3;
  if(w_link3 == ((struct AvahiWatch_1 *)NULL))
    return (struct AvahiWatch_1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s_link3);
    w_link3->simple_poll = s_link3;
    w_link3->dead = 0;
    w_link3->pollfd.fd = fd_link3;
    w_link3->pollfd.events = (signed short int)event_link3;
    w_link3->pollfd.revents = (signed short int)0;
    w_link3->callback = callback_link3;
    w_link3->userdata = userdata_link3;
    w_link3->idx = -1;
    s_link3->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch_1 **_head_link3 = &s_link3->watches;
      struct AvahiWatch_1 *_item_link3 = w_link3;
      /* assertion _item */
      assert(_item_link3 != ((struct AvahiWatch_1 *)NULL));
      _item_link3->watches_next = *_head_link3;
      if(!(_item_link3->watches_next == ((struct AvahiWatch_1 *)NULL)))
        _item_link3->watches_next->watches_prev = _item_link3;

      _item_link3->watches_prev = (struct AvahiWatch_1 *)(void *)0;
      *_head_link3 = _item_link3;
    }
    while((_Bool)0);
    s_link3->n_watches = s_link3->n_watches + 1;
    return w_link3;
  }
}

// watch_toggled
// file ../avahi-common/dbus-watch-glue.c line 187
static void watch_toggled(struct DBusWatch *dbus_watch, void *userdata)
{
  struct anonymous_28 *d = (struct anonymous_28 *)userdata;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous_28 *)NULL));
  update_watch(d->poll_api, dbus_watch);
}

// watch_toggled_link1
// file ../avahi-common/dbus-watch-glue.c line 187
static void watch_toggled_link1(struct DBusWatch *dbus_watch_link1, void *userdata_link1)
{
  struct anonymous_28 *d_link1 = (struct anonymous_28 *)userdata_link1;
  /* assertion dbus_watch */
  assert(dbus_watch_link1 != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d_link1 != ((struct anonymous_28 *)NULL));
  update_watch_link1(d_link1->poll_api, dbus_watch_link1);
}

// watch_update
// file simple-watch.c line 168
static void watch_update(struct AvahiWatch_1 *w, enum anonymous events)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch_1 *)NULL));
  /* assertion !w->dead */
  assert(!(w->dead != 0));
  avahi_simple_poll_wakeup(w->simple_poll);
  w->pollfd.events = (signed short int)events;
  if(!(w->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w->simple_poll != ((struct AvahiSimplePoll_0 *)NULL));
    w->simple_poll->pollfds[(signed long int)w->idx] = w->pollfd;
  }

  else
    w->simple_poll->rebuild_pollfds = 1;
}

// watch_update_link1
// file simple-watch.c line 168
static void watch_update_link1(struct AvahiWatch_1 *w_link1, enum anonymous events_link1)
{
  /* assertion w */
  assert(w_link1 != ((struct AvahiWatch_1 *)NULL));
  /* assertion !w->dead */
  assert(!(w_link1->dead != 0));
  avahi_simple_poll_wakeup(w_link1->simple_poll);
  w_link1->pollfd.events = (signed short int)events_link1;
  if(!(w_link1->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w_link1->simple_poll != ((struct AvahiSimplePoll_0 *)NULL));
    w_link1->simple_poll->pollfds[(signed long int)w_link1->idx] = w_link1->pollfd;
  }

  else
    w_link1->simple_poll->rebuild_pollfds = 1;
}

// watch_update_link1_link1
// file simple-watch.c line 168
static void watch_update_link1_link1(struct AvahiWatch *w_link1_link1, enum anonymous events_link1_link1)
{
  /* assertion w */
  assert(w_link1_link1 != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w_link1_link1->dead != 0));
  avahi_simple_poll_wakeup(w_link1_link1->simple_poll);
  w_link1_link1->pollfd.events = (signed short int)events_link1_link1;
  if(!(w_link1_link1->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w_link1_link1->simple_poll != ((struct AvahiSimplePoll *)NULL));
    w_link1_link1->simple_poll->pollfds[(signed long int)w_link1_link1->idx] = w_link1_link1->pollfd;
  }

  else
    w_link1_link1->simple_poll->rebuild_pollfds = 1;
}

// watch_update_link1_link2
// file simple-watch.c line 168
static void watch_update_link1_link2(struct AvahiWatch_1 *w_link1_link2, enum anonymous events_link1_link2)
{
  /* assertion w */
  assert(w_link1_link2 != ((struct AvahiWatch_1 *)NULL));
  /* assertion !w->dead */
  assert(!(w_link1_link2->dead != 0));
  avahi_simple_poll_wakeup(w_link1_link2->simple_poll);
  w_link1_link2->pollfd.events = (signed short int)events_link1_link2;
  if(!(w_link1_link2->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w_link1_link2->simple_poll != ((struct AvahiSimplePoll_0 *)NULL));
    w_link1_link2->simple_poll->pollfds[(signed long int)w_link1_link2->idx] = w_link1_link2->pollfd;
  }

  else
    w_link1_link2->simple_poll->rebuild_pollfds = 1;
}

// watch_update_link2
// file glib-watch.c line 139
static void watch_update_link2(struct AvahiWatch_0 *w_link2, enum anonymous events_link2)
{
  /* assertion w */
  assert(w_link2 != ((struct AvahiWatch_0 *)NULL));
  /* assertion !w->dead */
  assert(!(w_link2->dead != 0));
  w_link2->pollfd.events=map_events_to_glib(events_link2);
}

// watch_update_link3
// file simple-watch.c line 168
static void watch_update_link3(struct AvahiWatch_1 *w_link3, enum anonymous events_link3)
{
  /* assertion w */
  assert(w_link3 != ((struct AvahiWatch_1 *)NULL));
  /* assertion !w->dead */
  assert(!(w_link3->dead != 0));
  avahi_simple_poll_wakeup(w_link3->simple_poll);
  w_link3->pollfd.events = (signed short int)events_link3;
  if(!(w_link3->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w_link3->simple_poll != ((struct AvahiSimplePoll_0 *)NULL));
    w_link3->simple_poll->pollfds[(signed long int)w_link3->idx] = w_link3->pollfd;
  }

  else
    w_link3->simple_poll->rebuild_pollfds = 1;
}

// xcalloc
// file malloc.c line 89
static void * xcalloc(unsigned long int nmemb, unsigned long int size)
{
  void *p;
  if(nmemb == 0ul || size == 0ul)
    return (void *)0;

  else
  {
    p=calloc(nmemb, size);
    if(p == NULL)
      oom();

    return p;
  }
}

// xcalloc_link1
// file malloc.c line 89
static void * xcalloc_link1(unsigned long int nmemb_link1, unsigned long int size_link1)
{
  void *p_link1;
  if(nmemb_link1 == 0ul || size_link1 == 0ul)
    return (void *)0;

  else
  {
    p_link1=calloc(nmemb_link1, size_link1);
    if(p_link1 == NULL)
      oom_link1();

    return p_link1;
  }
}

// xcalloc_link1_link1
// file malloc.c line 89
static void * xcalloc_link1_link1(unsigned long int nmemb_link1_link1, unsigned long int size_link1_link1)
{
  void *p_link1_link1;
  if(nmemb_link1_link1 == 0ul || size_link1_link1 == 0ul)
    return (void *)0;

  else
  {
    p_link1_link1=calloc(nmemb_link1_link1, size_link1_link1);
    if(p_link1_link1 == NULL)
      oom_link1_link1();

    return p_link1_link1;
  }
}

// xcalloc_link2
// file malloc.c line 89
static void * xcalloc_link2(unsigned long int nmemb_link2, unsigned long int size_link2)
{
  void *p_link2;
  if(nmemb_link2 == 0ul || size_link2 == 0ul)
    return (void *)0;

  else
  {
    p_link2=calloc(nmemb_link2, size_link2);
    if(p_link2 == NULL)
      oom_link2();

    return p_link2;
  }
}

// xcalloc_link3
// file malloc.c line 89
static void * xcalloc_link3(unsigned long int nmemb_link3, unsigned long int size_link3)
{
  void *p_link3;
  if(nmemb_link3 == 0ul || size_link3 == 0ul)
    return (void *)0;

  else
  {
    p_link3=calloc(nmemb_link3, size_link3);
    if(p_link3 == NULL)
      oom_link3();

    return p_link3;
  }
}

// xmalloc
// file malloc.c line 62
static void * xmalloc(unsigned long int size)
{
  void *p;
  if(size == 0ul)
    return (void *)0;

  else
  {
    p=malloc(size);
    if(p == NULL)
      oom();

    return p;
  }
}

// xmalloc_link1
// file malloc.c line 62
static void * xmalloc_link1(unsigned long int size_link1)
{
  void *p_link1;
  if(size_link1 == 0ul)
    return (void *)0;

  else
  {
    p_link1=malloc(size_link1);
    if(p_link1 == NULL)
      oom_link1();

    return p_link1;
  }
}

// xmalloc_link1_link1
// file malloc.c line 62
static void * xmalloc_link1_link1(unsigned long int size_link1_link1)
{
  void *p_link1_link1;
  if(size_link1_link1 == 0ul)
    return (void *)0;

  else
  {
    p_link1_link1=malloc(size_link1_link1);
    if(p_link1_link1 == NULL)
      oom_link1_link1();

    return p_link1_link1;
  }
}

// xmalloc_link2
// file malloc.c line 62
static void * xmalloc_link2(unsigned long int size_link2)
{
  void *p_link2;
  if(size_link2 == 0ul)
    return (void *)0;

  else
  {
    p_link2=malloc(size_link2);
    if(p_link2 == NULL)
      oom_link2();

    return p_link2;
  }
}

// xmalloc_link3
// file malloc.c line 62
static void * xmalloc_link3(unsigned long int size_link3)
{
  void *p_link3;
  if(size_link3 == 0ul)
    return (void *)0;

  else
  {
    p_link3=malloc(size_link3);
    if(p_link3 == NULL)
      oom_link3();

    return p_link3;
  }
}

// xrealloc
// file malloc.c line 75
static void * xrealloc(void *p, unsigned long int size)
{
  if(size == 0ul)
  {
    free(p);
    return (void *)0;
  }

  else
  {
    p=realloc(p, size);
    if(p == NULL)
      oom();

    return p;
  }
}

// xrealloc_link1
// file malloc.c line 75
static void * xrealloc_link1(void *p_link1, unsigned long int size_link1)
{
  if(size_link1 == 0ul)
  {
    free(p_link1);
    return (void *)0;
  }

  else
  {
    p_link1=realloc(p_link1, size_link1);
    if(p_link1 == NULL)
      oom_link1();

    return p_link1;
  }
}

// xrealloc_link1_link1
// file malloc.c line 75
static void * xrealloc_link1_link1(void *p_link1_link1, unsigned long int size_link1_link1)
{
  if(size_link1_link1 == 0ul)
  {
    free(p_link1_link1);
    return (void *)0;
  }

  else
  {
    p_link1_link1=realloc(p_link1_link1, size_link1_link1);
    if(p_link1_link1 == NULL)
      oom_link1_link1();

    return p_link1_link1;
  }
}

// xrealloc_link2
// file malloc.c line 75
static void * xrealloc_link2(void *p_link2, unsigned long int size_link2)
{
  if(size_link2 == 0ul)
  {
    free(p_link2);
    return (void *)0;
  }

  else
  {
    p_link2=realloc(p_link2, size_link2);
    if(p_link2 == NULL)
      oom_link2();

    return p_link2;
  }
}

// xrealloc_link3
// file malloc.c line 75
static void * xrealloc_link3(void *p_link3, unsigned long int size_link3)
{
  if(size_link3 == 0ul)
  {
    free(p_link3);
    return (void *)0;
  }

  else
  {
    p_link3=realloc(p_link3, size_link3);
    if(p_link3 == NULL)
      oom_link3();

    return p_link3;
  }
}

