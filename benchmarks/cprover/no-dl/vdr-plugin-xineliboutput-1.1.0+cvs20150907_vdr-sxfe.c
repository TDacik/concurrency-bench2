// #anon_enum_DBUS_BUS_SESSION=0_DBUS_BUS_SYSTEM=1_DBUS_BUS_STARTER=2
// file /usr/include/dbus-1.0/dbus/dbus-shared.h line 56
enum anonymous_6 { DBUS_BUS_SESSION=0, DBUS_BUS_SYSTEM=1, DBUS_BUS_STARTER=2 };

// #anon_enum_JCS_UNKNOWN=0_JCS_GRAYSCALE=1_JCS_RGB=2_JCS_YCbCr=3_JCS_CMYK=4_JCS_YCCK=5_JCS_EXT_RGB=6_JCS_EXT_RGBX=7_JCS_EXT_BGR=8_JCS_EXT_BGRX=9_JCS_EXT_XBGR=10_JCS_EXT_XRGB=11_JCS_EXT_RGBA=12_JCS_EXT_BGRA=13_JCS_EXT_ABGR=14_JCS_EXT_ARGB=15_JCS_RGB565=16
// file /usr/include/jpeglib.h line 215
enum anonymous_0 { JCS_UNKNOWN=0, JCS_GRAYSCALE=1, JCS_RGB=2, JCS_YCbCr=3, JCS_CMYK=4, JCS_YCCK=5, JCS_EXT_RGB=6, JCS_EXT_RGBX=7, JCS_EXT_BGR=8, JCS_EXT_BGRX=9, JCS_EXT_XBGR=10, JCS_EXT_XRGB=11, JCS_EXT_RGBA=12, JCS_EXT_BGRA=13, JCS_EXT_ABGR=14, JCS_EXT_ARGB=15, JCS_RGB565=16 };

// #anon_enum_JDCT_ISLOW=0_JDCT_IFAST=1_JDCT_FLOAT=2
// file /usr/include/jpeglib.h line 244
enum anonymous_5 { JDCT_ISLOW=0, JDCT_IFAST=1, JDCT_FLOAT=2 };

// tag-#anon#ST[*{S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32}_S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32_'set_parameters'||*{S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32}_S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32_'get_parameters'||*{*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_()->*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_}_*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_()->*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#__'get_param_descr'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'get_help'|]
// file /usr/include/xine.h line 834
struct anonymous_69;

// tag-#anon#ST[*{S8}_S8_'filename'||S64'filesize'||S64'filemtime'||*{V}_V_'lib_handle'||S32'ref'||S32'no_unload'|]
// file /usr/include/xine/plugin_catalog.h line 35
struct anonymous_22;

// tag-#anon#ST[*{S8}_S8_'origin'||*{S8}_S8_'mrl'||*{S8}_S8_'link'||S64'size'||U32'type'||U32'_pad0'|]
// file /usr/include/xine.h line 1067
struct anonymous_28;

// tag-#anon#ST[*{S8}_S8_'res_name'||*{S8}_S8_'res_class'|]
// file /usr/include/X11/Xutil.h line 189
struct anonymous_9;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'filename'||S64'filesize'||S64'filemtime'||*{V}_V_'lib_handle'||S32'ref'||S32'no_unload'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'filename'||S64'filesize'||S64'filemtime'||*{V}_V_'lib_handle'||S32'ref'||S32'no_unload'|]#_'file'||*{SYM#tag-#anon#ST[U8'type'||U8'API'||U48'_pad0'||*{cS8}_cS8_'id'||U32'version'||U32'_pad1'||*{cV}_cV_'special_info'||*{*{V}_V_(*{SYM#tag-xine_s#}_SYM#tag-xine_s#_|*{V}_V_)->*{V}_V_}_*{V}_V_(*{SYM#tag-xine_s#}_SYM#tag-xine_s#_|*{V}_V_)->*{V}_V__'init'|]#}_SYM#tag-#anon#ST[U8'type'||U8'API'||U48'_pad0'||*{cS8}_cS8_'id'||U32'version'||U32'_pad1'||*{cV}_cV_'special_info'||*{*{V}_V_(*{SYM#tag-xine_s#}_SYM#tag-xine_s#_|*{V}_V_)->*{V}_V_}_*{V}_V_(*{SYM#tag-xine_s#}_SYM#tag-xine_s#_|*{V}_V_)->*{V}_V__'init'|]#_'info'||*{V}_V_'plugin_class'||*{SYM#tag-xine_list_s#}_SYM#tag-xine_list_s#_'config_entry_list'||S32'ref'||S32'priority'|]
// file /usr/include/xine/plugin_catalog.h line 44
struct anonymous_75;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'filename'||S64'filesize'||S64'filemtime'||*{V}_V_'lib_handle'||S32'ref'||S32'no_unload'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'filename'||S64'filesize'||S64'filemtime'||*{V}_V_'lib_handle'||S32'ref'||S32'no_unload'|]#_'file'||*{SYM#tag-#anon#ST[U8'type'||U8'API'||U48'_pad0'||*{cS8}_cS8_'id'||U32'version'||U32'_pad1'||*{cV}_cV_'special_info'||*{*{V}_V_(*{SYM#tag-xine_s#}_SYM#tag-xine_s#_|*{V}_V_)->*{V}_V_}_*{V}_V_(*{SYM#tag-xine_s#}_SYM#tag-xine_s#_|*{V}_V_)->*{V}_V__'init'|]#}_SYM#tag-#anon#ST[U8'type'||U8'API'||U48'_pad0'||*{cS8}_cS8_'id'||U32'version'||U32'_pad1'||*{cV}_cV_'special_info'||*{*{V}_V_(*{SYM#tag-xine_s#}_SYM#tag-xine_s#_|*{V}_V_)->*{V}_V_}_*{V}_V_(*{SYM#tag-xine_s#}_SYM#tag-xine_s#_|*{V}_V_)->*{V}_V__'init'|]#_'info'||*{V}_V_'plugin_class'||*{SYM#tag-xine_list_s#}_SYM#tag-xine_list_s#_'config_entry_list'||S32'ref'||S32'priority'|]_link1
// file /usr/include/xine/plugin_catalog.h line 44
struct anonymous_24;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visual'||U64'visualid'||S32'screen'||S32'depth'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'colormap_size'||S32'bits_per_rgb'|]
// file /usr/include/X11/Xutil.h line 287
struct anonymous_17;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#}_SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#_'depths'||S32'root_depth'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'root_visual'||*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous_33;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}_S8_'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'_pad0'||*{U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64}_U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64_'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'_pad0'|]#_'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private9'||*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private10'||S32'qlen'||U32'_pad2'||U64'last_request_read'||U64'request'||*{S8}_S8_'private11'||*{S8}_S8_'private12'||*{S8}_S8_'private13'||*{S8}_S8_'private14'||U32'max_request_size'||U32'_pad3'||*{SYM#tag-_XrmHashBucketRec#}_SYM#tag-_XrmHashBucketRec#_'db'||*{S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32}_S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32_'private15'||*{S8}_S8_'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#}_SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#_'depths'||S32'root_depth'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'root_visual'||*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#}_SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#_'depths'||S32'root_depth'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'root_visual'||*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#_'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}_S8_'private17'||*{S8}_S8_'private18'||S32'private19'||U32'_pad4'||*{S8}_S8_'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous_34;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'_pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous_32;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous_16;

// tag-#anon#ST[*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_'post'||*{S8}_S8_'name'||*{S8}_S8_'args'||S32'enable'||U32'_pad0'|]
// file xine/post.h line 32
struct anonymous_73;

// tag-#anon#ST[*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_'post'||*{S8}_S8_'name'||*{S8}_S8_'args'||S32'enable'||U32'_pad0'|]_link1
// file xine/post.h line 32
struct anonymous_26;

// tag-#anon#ST[*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_'post'||*{SYM#tag-#anon#ST[*{S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32}_S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32_'set_parameters'||*{S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32}_S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32_'get_parameters'||*{*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_()->*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_}_*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_()->*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#__'get_param_descr'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'get_help'|]#}_SYM#tag-#anon#ST[*{S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32}_S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32_'set_parameters'||*{S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32}_S32(*{SYM#tag-xine_post_s#}_SYM#tag-xine_post_s#_|*{V}_V_)->S32_'get_parameters'||*{*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_()->*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_}_*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_()->*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#__'get_param_descr'||*{*{S8}_S8_()->*{S8}_S8_}_*{S8}_S8_()->*{S8}_S8__'get_help'|]#_'api'||*{SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#}_SYM#tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]#_'descr'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'param'||*{S8}_S8_'param_data'||S32'x'||S32'y'||S32'readonly'||U32'_pad0'||*{*{S8}_S8_}_*{S8}_S8__'properties_names'|]
// file xine/post.c line 46
struct anonymous_72;

// tag-#anon#ST[*{SYM#tag-xine_stream_s#}_SYM#tag-xine_stream_s#_'stream'||*{V}_V_'data'||S32'data_length'||S32'type'||SYM#tag-timeval#'tv'|]
// file /usr/include/xine.h line 1847
struct anonymous_88;

// tag-#anon#ST[*{SYM#tag-xine_stream_s#}_SYM#tag-xine_stream_s#_'stream'||*{V}_V_'data'||S32'data_length'||S32'type'||SYM#tag-timeval#'tv'|]_link1
// file /usr/include/xine.h line 1847
struct anonymous_15;

// tag-#anon#ST[*{U8}_U8_'ovl_rgba'||S32'ovl_w'||S32'ovl_h'||S32'ovl_x'||S32'ovl_y'|]
// file /usr/include/xine.h line 1380
struct anonymous_94;

// tag-#anon#ST[*{V(*{V}_V_|S32|S32|F64|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{F64}_F64_|*{S32}_S32_|*{S32}_S32_)->V}_V(*{V}_V_|S32|S32|F64|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{F64}_F64_|*{S32}_S32_|*{S32}_S32_)->V_'frame_output_cb'||*{V}_V_'user_data'|]
// file /usr/include/xine.h line 1441
struct anonymous_91;

// tag-#anon#ST[*{V}_V_'display'||S32'screen'||U32'_pad0'||U64'd'||*{V}_V_'user_data'||*{V(*{V}_V_|S32|S32|F64|*{S32}_S32_|*{S32}_S32_|*{F64}_F64_)->V}_V(*{V}_V_|S32|S32|F64|*{S32}_S32_|*{S32}_S32_|*{F64}_F64_)->V_'dest_size_cb'||*{V(*{V}_V_|S32|S32|F64|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{F64}_F64_|*{S32}_S32_|*{S32}_S32_)->V}_V(*{V}_V_|S32|S32|F64|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{F64}_F64_|*{S32}_S32_|*{S32}_S32_)->V_'frame_output_cb'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'lock_display'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'unlock_display'|]
// file /usr/include/xine.h line 1197
struct anonymous_92;

// tag-#anon#ST[*{V}_V_'reserved'|]
// file /usr/include/xine/xine_internal.h line 78
struct anonymous_25;

// tag-#anon#ST[*{V}_V_'user_data'||S32'supported_formats'||U32'_pad0'||*{V(*{V}_V_|S32|S32|S32|F64|*{V}_V_|*{V}_V_|*{V}_V_)->V}_V(*{V}_V_|S32|S32|S32|F64|*{V}_V_|*{V}_V_|*{V}_V_)->V_'raw_output_cb'||*{V(*{V}_V_|S32|*{SYM#tag-#anon#ST[*{U8}_U8_'ovl_rgba'||S32'ovl_w'||S32'ovl_h'||S32'ovl_x'||S32'ovl_y'|]#}_SYM#tag-#anon#ST[*{U8}_U8_'ovl_rgba'||S32'ovl_w'||S32'ovl_h'||S32'ovl_x'||S32'ovl_y'|]#_)->V}_V(*{V}_V_|S32|*{SYM#tag-#anon#ST[*{U8}_U8_'ovl_rgba'||S32'ovl_w'||S32'ovl_h'||S32'ovl_x'||S32'ovl_y'|]#}_SYM#tag-#anon#ST[*{U8}_U8_'ovl_rgba'||S32'ovl_w'||S32'ovl_h'||S32'ovl_x'||S32'ovl_y'|]#_)->V_'raw_overlay_cb'|]
// file /usr/include/xine.h line 1390
struct anonymous_93;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_98;

// tag-#anon#ST[ARR17{U8}_U8_'bits'||ARR256{U8}_U8_'huffval'||U24'_pad0'||S32'sent_table'|]
// file /usr/include/jpeglib.h line 101
struct anonymous_3;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#}_SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#_'__cancel_jmp_buf'||ARR4{*{V}_V_}_*{V}_V__'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous_102;

// tag-#anon#ST[ARR64{U16}_U16_'quantval'||S32'sent_table'|]
// file /usr/include/jpeglib.h line 84
struct anonymous_1;

// tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous_101;

// tag-#anon#ST[S16'red'||S16'redMask'||S16'green'||S16'greenMask'||S16'blue'||S16'blueMask'||S16'alpha'||S16'alphaMask'|]
// file /usr/include/X11/extensions/Xrender.h line 35
struct anonymous_89;

// tag-#anon#ST[S16'x'||S16'y'||U16'width'||U16'height'|]
// file /usr/include/X11/Xlib.h line 430
struct anonymous_20;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_76;

// tag-#anon#ST[S32'component_id'||S32'component_index'||S32'h_samp_factor'||S32'v_samp_factor'||S32'quant_tbl_no'||S32'dc_tbl_no'||S32'ac_tbl_no'||U32'width_in_blocks'||U32'height_in_blocks'||S32'DCT_scaled_size'||U32'downsampled_width'||U32'downsampled_height'||S32'component_needed'||S32'MCU_width'||S32'MCU_height'||S32'MCU_blocks'||S32'MCU_sample_width'||S32'last_col_width'||S32'last_row_height'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'||S32'sent_table'|]#}_SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'||S32'sent_table'|]#_'quant_table'||*{V}_V_'dct_table'|]
// file /usr/include/jpeglib.h line 117
struct anonymous_2;

// tag-#anon#ST[S32'comps_in_scan'||ARR4{S32}_S32_'component_index'||S32'Ss'||S32'Se'||S32'Ah'||S32'Al'|]
// file /usr/include/jpeglib.h line 190
struct anonymous_4;

// tag-#anon#ST[S32'count'||U32'_pad0'||U64'holder'|]
// file /usr/include/xine/xine_internal.h line 179
struct anonymous_11;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous_78;

// tag-#anon#ST[S32'function'||U32'_pad0'||U64'plane_mask'||U64'foreground'||U64'background'||S32'line_width'||S32'line_style'||S32'cap_style'||S32'join_style'||S32'fill_style'||S32'fill_rule'||S32'arc_mode'||U32'_pad1'||U64'tile'||U64'stipple'||S32'ts_x_origin'||S32'ts_y_origin'||U64'font'||S32'subwindow_mode'||S32'graphics_exposures'||S32'clip_x_origin'||S32'clip_y_origin'||U64'clip_mask'||S32'dash_offset'||S8'dashes'||U24'_pad2'|]
// file /usr/include/X11/Xlib.h line 181
struct anonymous_77;

// tag-#anon#ST[S32'screen_number'||S16'x_org'||S16'y_org'||S16'width'||S16'height'|]
// file /usr/include/X11/extensions/Xinerama.h line 32
struct anonymous_90;

// tag-#anon#ST[S32'struct_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#}_SYM#tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]#_'parameter'|]
// file /usr/include/xine.h line 829
struct anonymous_70;

// tag-#anon#ST[S32'type'||U32'_pad0'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'resourceid'||U64'serial'||U8'error_code'||U8'request_code'||U8'minor_code'||U40'_pad1'|]
// file /usr/include/X11/Xlib.h line 924
struct anonymous_64;

// tag-#anon#ST[S32'type'||U32'_pad0'||*{cS8}_cS8_'name'||S32'size'||S32'offset'||*{*{S8}_S8_}_*{S8}_S8__'enum_values'||F64'range_min'||F64'range_max'||S32'readonly'||U32'_pad1'||*{cS8}_cS8_'description'|]
// file /usr/include/xine.h line 816
struct anonymous_71;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||S32'extension'||S32'evtype'|]
// file /usr/include/X11/Xlib.h line 948
struct anonymous_66;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||S32'extension'||S32'evtype'||U32'cookie'||U32'_pad2'||*{V}_V_'data'|]
// file /usr/include/X11/Xlib.h line 958
struct anonymous_67;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'drawable'||S32'major_code'||S32'minor_code'|]
// file /usr/include/X11/Xlib.h line 686
struct anonymous_43;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'drawable'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||S32'major_code'||S32'minor_code'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 673
struct anonymous_42;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'|]
// file /usr/include/X11/Xlib.h line 718
struct anonymous_46;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'||S32'from_configure'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 727
struct anonymous_47;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'||S32'override_redirect'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 737
struct anonymous_48;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'||S32'place'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 816
struct anonymous_55;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'||S32'x'||S32'y'|]
// file /usr/include/X11/Xlib.h line 782
struct anonymous_52;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'_pad2'||U64'above'||S32'override_redirect'||U32'_pad3'|]
// file /usr/include/X11/Xlib.h line 768
struct anonymous_51;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'||U64'parent'||S32'x'||S32'y'||S32'override_redirect'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 756
struct anonymous_50;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'owner'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 857
struct anonymous_59;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'parent'||U64'window'|]
// file /usr/include/X11/Xlib.h line 747
struct anonymous_49;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'parent'||U64'window'||S32'place'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 826
struct anonymous_56;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'override_redirect'|]
// file /usr/include/X11/Xlib.h line 705
struct anonymous_45;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'_pad2'||U64'above'||S32'detail'||U32'_pad3'||U64'value_mask'|]
// file /usr/include/X11/Xlib.h line 801
struct anonymous_54;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 870
struct anonymous_60;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'|]
// file /usr/include/X11/Xlib.h line 934
struct anonymous_35;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||ARR32{S8}_S8_'key_vector'|]
// file /usr/include/X11/Xlib.h line 653
struct anonymous_65;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||S32'mode'||S32'detail'|]
// file /usr/include/X11/Xlib.h line 634
struct anonymous_40;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||S32'request'||S32'first_keycode'||S32'count'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 912
struct anonymous_63;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||S32'state'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 696
struct anonymous_44;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||S32'width'||S32'height'|]
// file /usr/include/X11/Xlib.h line 792
struct anonymous_53;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 662
struct anonymous_41;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'atom'||U64'time'||S32'state'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 836
struct anonymous_57;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'colormap'||S32'new'||S32'state'|]
// file /usr/include/X11/Xlib.h line 882
struct anonymous_61;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'message_type'||S32'format'||U32'_pad2'||SYM#tag-#anon#UN[ARR20{S8}_S8_'b'||ARR10{S16}_S16_'s'||ARR5{S64}_S64_'l'|]#'data'|]
// file /usr/include/X11/Xlib.h line 897
struct anonymous_62;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||S32'mode'||S32'detail'||S32'same_screen'||S32'focus'||U32'state'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 610
struct anonymous_39;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||S8'is_hint'||U24'_pad2'||S32'same_screen'||U32'_pad3'|]
// file /usr/include/X11/Xlib.h line 593
struct anonymous_38;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'button'||S32'same_screen'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 575
struct anonymous_37;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'keycode'||S32'same_screen'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 557
struct anonymous_36;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'selection'||U64'time'|]
// file /usr/include/X11/Xlib.h line 847
struct anonymous_58;

// tag-#anon#ST[S32'width'||S32'height'||S32'aspect'||S32'pan_scan'|]
// file /usr/include/xine.h line 1912
struct anonymous_14;

// tag-#anon#ST[S32'width'||S32'height'||S32'crop_left'||S32'crop_right'||S32'crop_top'||S32'crop_bottom'||S32'ratio_code'||S32'interlaced'||S32'format'||S32'img_size'||*{U8}_U8_'img'|]
// file /usr/include/xine.h line 434
struct anonymous_30;

// tag-#anon#ST[S32'x'||S32'y'|]
// file /usr/include/X11/Xutil.h line 88
struct anonymous_86;

// tag-#anon#ST[S64'flags'||S32'x'||S32'y'||S32'width'||S32'height'||S32'min_width'||S32'min_height'||S32'max_width'||S32'max_height'||S32'width_inc'||S32'height_inc'||SYM#tag-#anon#ST[S32'x'||S32'y'|]#'min_aspect'||SYM#tag-#anon#ST[S32'x'||S32'y'|]#'max_aspect'||S32'base_width'||S32'base_height'||S32'win_gravity'||U32'_pad0'|]
// file /usr/include/X11/Xutil.h line 81
struct anonymous_87;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'lock'||*{V}_V_'object'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'destructor'||S32'count'||U32'_pad0'|]
// file /usr/include/xine/refcounter.h line 25
struct anonymous_29;

// tag-#anon#ST[SYM#tag-driver_hook_s#'h'||*{SYM#tag-xine_stream_s#}_SYM#tag-xine_stream_s#_'prev_stream'||*{SYM#tag-xine_stream_s#}_SYM#tag-xine_stream_s#_'xvdr_stream'||*{SYM#tag-metronom_s#}_SYM#tag-metronom_s#_'xvdr_metronom'|]
// file xine/vo_lastpts.c line 29
struct anonymous_83;

// tag-#anon#ST[SYM#tag-driver_hook_s#'h'||*{V}_V_'handle'||*{V(*{V}_V_|*{SYM#tag-vo_frame_s#}_SYM#tag-vo_frame_s#_)->V}_V(*{V}_V_|*{SYM#tag-vo_frame_s#}_SYM#tag-vo_frame_s#_)->V_'cb'|]
// file xine/vo_frameoutput.c line 27
struct anonymous_84;

// tag-#anon#ST[SYM#tag-driver_hook_s#'h'||ARR50{*{SYM#tag-vo_overlay_s#}_SYM#tag-vo_overlay_s#_}_*{SYM#tag-vo_overlay_s#}_SYM#tag-vo_overlay_s#__'overlay'|]
// file xine/vo_osdreorder.c line 23
struct anonymous_82;

// tag-#anon#ST[SYM#tag-driver_hook_s#'h'||U8'enable'||U8'unscaled_supported'||U8'custom_extent_supported'||U8'argb_supported'||U8'video_window_supported'||U8'_pad0'||U16'output_width'||U16'output_height'||U16'_pad1'||U32'factor_x'||U32'factor_y'||U16'x_move'||U16'y_move'||*{SYM#tag-osd_data_s#}_SYM#tag-osd_data_s#_'active_osds'|]
// file xine/vo_osdscaler.c line 178
struct anonymous_80;

// tag-#anon#ST[SYM#tag-xine_video_port_s#'vo'||*{SYM#tag-vo_driver_s#}_SYM#tag-vo_driver_s#_'driver'|]
// file xine/vo_hook.c line 142
struct anonymous_79;

// tag-#anon#ST[U16'extent_width'||U16'extent_height'||U32'layer'||U8'scaling'||U24'_pad0'|]
// file xine/vo_props.h line 55
struct anonymous_81;

// tag-#anon#ST[U64'background_pixmap'||U64'background_pixel'||U64'border_pixmap'||U64'border_pixel'||S32'bit_gravity'||S32'win_gravity'||S32'backing_store'||U32'_pad0'||U64'backing_planes'||U64'backing_pixel'||S32'save_under'||U32'_pad1'||S64'event_mask'||S64'do_not_propagate_mask'||S32'override_redirect'||U32'_pad2'||U64'colormap'||U64'cursor'|]
// file /usr/include/X11/Xlib.h line 290
struct anonymous_8;

// tag-#anon#ST[U64'id'||S32'type'||S32'depth'||SYM#tag-#anon#ST[S16'red'||S16'redMask'||S16'green'||S16'greenMask'||S16'blue'||S16'blueMask'||S16'alpha'||S16'alphaMask'|]#'direct'||U64'colormap'|]
// file /usr/include/X11/extensions/Xrender.h line 46
struct anonymous_21;

// tag-#anon#ST[U64'pixel'||U16'red'||U16'green'||U16'blue'||S8'flags'||S8'pad'|]
// file /usr/include/X11/Xlib.h line 410
struct anonymous_18;

// tag-#anon#ST[U64'shmseg'||S32'shmid'||U32'_pad0'||*{S8}_S8_'shmaddr'||S32'readOnly'||U32'_pad1'|]
// file /usr/include/X11/extensions/XShm.h line 50
struct anonymous_31;

// tag-#anon#ST[U8'type'||U8'API'||U48'_pad0'||*{cS8}_cS8_'id'||U32'version'||U32'_pad1'||*{cV}_cV_'special_info'||*{*{V}_V_(*{SYM#tag-xine_s#}_SYM#tag-xine_s#_|*{V}_V_)->*{V}_V_}_*{V}_V_(*{SYM#tag-xine_s#}_SYM#tag-xine_s#_|*{V}_V_)->*{V}_V__'init'|]
// file /usr/include/xine/xine_plugin.h line 50
struct anonymous_74;

// tag-#anon#ST[U8'type'||U8'API'||U48'_pad0'||*{cS8}_cS8_'id'||U32'version'||U32'_pad1'||*{cV}_cV_'special_info'||*{*{V}_V_(*{SYM#tag-xine_s#}_SYM#tag-xine_s#_|*{V}_V_)->*{V}_V_}_*{V}_V_(*{SYM#tag-xine_s#}_SYM#tag-xine_s#_|*{V}_V_)->*{V}_V__'init'|]_link1
// file /usr/include/xine/xine_plugin.h line 50
struct anonymous_23;

// tag-#anon#UN[*{SYM#tag-osd_clut_s#}_SYM#tag-osd_clut_s#_'palette'||U64'dummy02'|]
// file tools/osd_command.h line 102
union anonymous_103;

// tag-#anon#UN[*{SYM#tag-osd_rle_elem_s#}_SYM#tag-osd_rle_elem_s#_'data'||*{U8}_U8_'raw_data'||U64'dummy01'|]
// file tools/osd_command.h line 96
union anonymous_13;

// tag-#anon#UN[*{V}_V_'vis'||SYM#tag-#anon#ST[*{V(*{V}_V_|S32|S32|F64|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{F64}_F64_|*{S32}_S32_|*{S32}_S32_)->V}_V(*{V}_V_|S32|S32|F64|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{F64}_F64_|*{S32}_S32_|*{S32}_S32_)->V_'frame_output_cb'||*{V}_V_'user_data'|]#'vis_fb'||SYM#tag-#anon#ST[*{V}_V_'display'||S32'screen'||U32'_pad0'||U64'd'||*{V}_V_'user_data'||*{V(*{V}_V_|S32|S32|F64|*{S32}_S32_|*{S32}_S32_|*{F64}_F64_)->V}_V(*{V}_V_|S32|S32|F64|*{S32}_S32_|*{S32}_S32_|*{F64}_F64_)->V_'dest_size_cb'||*{V(*{V}_V_|S32|S32|F64|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{F64}_F64_|*{S32}_S32_|*{S32}_S32_)->V}_V(*{V}_V_|S32|S32|F64|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{S32}_S32_|*{F64}_F64_|*{S32}_S32_|*{S32}_S32_)->V_'frame_output_cb'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'lock_display'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'unlock_display'|]#'vis_x11'||SYM#tag-#anon#ST[*{V}_V_'user_data'||S32'supported_formats'||U32'_pad0'||*{V(*{V}_V_|S32|S32|S32|F64|*{V}_V_|*{V}_V_|*{V}_V_)->V}_V(*{V}_V_|S32|S32|S32|F64|*{V}_V_|*{V}_V_|*{V}_V_)->V_'raw_output_cb'||*{V(*{V}_V_|S32|*{SYM#tag-#anon#ST[*{U8}_U8_'ovl_rgba'||S32'ovl_w'||S32'ovl_h'||S32'ovl_x'||S32'ovl_y'|]#}_SYM#tag-#anon#ST[*{U8}_U8_'ovl_rgba'||S32'ovl_w'||S32'ovl_h'||S32'ovl_x'||S32'ovl_y'|]#_)->V}_V(*{V}_V_|S32|*{SYM#tag-#anon#ST[*{U8}_U8_'ovl_rgba'||S32'ovl_w'||S32'ovl_h'||S32'ovl_x'||S32'ovl_y'|]#}_SYM#tag-#anon#ST[*{U8}_U8_'ovl_rgba'||S32'ovl_w'||S32'ovl_h'||S32'ovl_x'||S32'ovl_y'|]#_)->V_'raw_overlay_cb'|]#'vis_raw'|]
// file xine_frontend_internal.h line 61
union anonymous_27;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_99;

// tag-#anon#UN[ARR20{S8}_S8_'b'||ARR10{S16}_S16_'s'||ARR5{S64}_S64_'l'|]
// file /usr/include/X11/Xlib.h line 905
union anonymous_68;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_12;

// tag-#anon#UN[ARR8{S32}_S32_'i'||ARR80{S8}_S8_'s'|]
// file /usr/include/jpeglib.h line 736
union anonymous;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_19;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_7;

// tag-#anon#UN[SYM#tag-frontend_s#'fe'||SYM#tag-fe_s#'x'|]
// file xine_sxfe_frontend.c line 106
union anonymous_10;

// tag-#anon#UN[U8'cb'||U8'g'|]
// file tools/osd_command.h line 51
union anonymous_95;

// tag-#anon#UN[U8'cr'||U8'b'|]
// file tools/osd_command.h line 55
union anonymous_96;

// tag-#anon#UN[U8'y'||U8'r'|]
// file tools/osd_command.h line 59
union anonymous_97;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_100;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_85;

// tag-_DBusGConnection
// file /usr/include/dbus-1.0/dbus/dbus-glib.h line 38
struct _DBusGConnection;

// tag-_DBusGProxy
// file /usr/include/dbus-1.0/dbus/dbus-glib.h line 214
struct _DBusGProxy;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GError
// file /usr/include/glib-2.0/glib/gerror.h line 42
struct _GError;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_XComposeStatus
// file /usr/include/X11/Xutil.h line 231
struct _XComposeStatus;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XImage
// file /usr/include/X11/Xlib.h line 360
struct _XImage;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XRenderPictureAttributes
// file /usr/include/X11/extensions/Xrender.h line 67
struct _XRenderPictureAttributes;

// tag-_XTransform
// file /usr/include/X11/extensions/Xrender.h line 157
struct _XTransform;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__GLXFBConfigRec
// file /usr/include/GL/glx.h line 169
struct __GLXFBConfigRec;

// tag-__GLXcontextRec
// file /usr/include/GL/glx.h line 165
struct __GLXcontextRec;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_mwmhints
// file xine_sxfe_frontend.c line 78
struct _mwmhints;

// tag-_xrender_surf
// file xine_sxfe_frontend.c line 88
struct _xrender_surf;

// tag-ao_format_s
// file /usr/include/xine/audio_out.h line 138
struct ao_format_s;

// tag-argb_layer_s
// file /usr/include/xine/video_out.h line 462
struct argb_layer_s;

// tag-audio_buffer_s
// file /usr/include/xine/audio_out.h line 148
struct audio_buffer_s_0;

// tag-audio_buffer_s_link1
// file /usr/include/xine/audio_out.h line 148
struct audio_buffer_s;

// tag-audio_decoder_s
// file /usr/include/xine/audio_decoder.h line 40
struct audio_decoder_s;

// tag-broadcaster_s
// file /usr/include/xine/broadcaster.h line 30
struct broadcaster_s;

// tag-buf_element_s
// file /usr/include/xine/buffer.h line 332
struct buf_element_s;

// tag-cfg_entry_s
// file /usr/include/xine/configfile.h line 43
struct cfg_entry_s;

// tag-config_values_s
// file /usr/include/xine/configfile.h line 44
struct config_values_s;

// tag-demux_class_s_link1
// file /usr/include/xine/demux.h line 44
struct demux_class_s;

// tag-demux_plugin_s_link1
// file /usr/include/xine/demux.h line 45
struct demux_plugin_s;

// tag-driver_hook_s
// file xine/vo_hook.h line 28
struct driver_hook_s;

// tag-extra_info_s
// file /usr/include/xine/buffer.h line 303
struct extra_info_s;

// tag-fe_s
// file xine_frontend_internal.h line 21
struct fe_s_0;

// tag-fe_s_link1
// file xine_frontend_internal.h line 21
struct fe_s;

// tag-fifo_buffer_s
// file /usr/include/xine/buffer.h line 571
struct fifo_buffer_s;

// tag-frontend_s
// file xine_frontend.h line 21
struct frontend_s;

// tag-funcs
// file /usr/include/X11/Xlib.h line 376
struct funcs;

// tag-grab_data_s
// file xine_input_vdr.h line 57
struct grab_data_s;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-input_class_s
// file /usr/include/xine/input_plugin.h line 37
struct input_class_s;

// tag-input_class_s_link1
// file /usr/include/xine/input_plugin.h line 37
struct input_class_s_0;

// tag-input_plugin_s
// file /usr/include/xine/input_plugin.h line 38
struct input_plugin_s_0;

// tag-input_plugin_s_link1
// file /usr/include/xine/input_plugin.h line 38
struct input_plugin_s;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-jpeg_c_coef_controller
// file /usr/include/jpeglib.h line 457
struct jpeg_c_coef_controller;

// tag-jpeg_c_main_controller
// file /usr/include/jpeglib.h line 455
struct jpeg_c_main_controller;

// tag-jpeg_c_prep_controller
// file /usr/include/jpeglib.h line 456
struct jpeg_c_prep_controller;

// tag-jpeg_color_converter
// file /usr/include/jpeglib.h line 459
struct jpeg_color_converter;

// tag-jpeg_common_struct
// file /usr/include/jpeglib.h line 280
struct jpeg_common_struct;

// tag-jpeg_comp_master
// file /usr/include/jpeglib.h line 454
struct jpeg_comp_master;

// tag-jpeg_compress_struct
// file /usr/include/jpeglib.h line 289
struct jpeg_compress_struct;

// tag-jpeg_destination_mgr
// file /usr/include/jpeglib.h line 299
struct jpeg_destination_mgr;

// tag-jpeg_downsampler
// file /usr/include/jpeglib.h line 460
struct jpeg_downsampler;

// tag-jpeg_entropy_encoder
// file /usr/include/jpeglib.h line 462
struct jpeg_entropy_encoder;

// tag-jpeg_error_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_error_mgr;

// tag-jpeg_forward_dct
// file /usr/include/jpeglib.h line 461
struct jpeg_forward_dct;

// tag-jpeg_marker_writer
// file /usr/include/jpeglib.h line 458
struct jpeg_marker_writer;

// tag-jpeg_memory_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_memory_mgr;

// tag-jpeg_progress_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_progress_mgr;

// tag-jvirt_barray_control
// file /usr/include/jpeglib.h line 828
struct jvirt_barray_control;

// tag-jvirt_sarray_control
// file /usr/include/jpeglib.h line 827
struct jvirt_sarray_control;

// tag-metronom_clock_s
// file /usr/include/xine/metronom.h line 53
struct metronom_clock_s;

// tag-metronom_s
// file /usr/include/xine/metronom.h line 52
struct metronom_s;

// tag-metronom_s_link1
// file /usr/include/xine/metronom.h line 52
struct metronom_s_0;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-osd_clut_s
// file tools/osd_command.h line 50
struct osd_clut_s;

// tag-osd_command_s
// file xine_frontend.h line 23
struct osd_command_s;

// tag-osd_data_s
// file xine/vo_osdscaler.c line 50
struct osd_data_s;

// tag-osd_font_s
// file /usr/include/xine/osd.h line 34
struct osd_font_s;

// tag-osd_ft2context_s
// file /usr/include/xine/osd.h line 35
struct osd_ft2context_s;

// tag-osd_object_s
// file /usr/include/xine/osd.h line 32
struct osd_object_s_0;

// tag-osd_object_s_link1
// file /usr/include/xine/osd.h line 32
struct osd_object_s;

// tag-osd_rect_s
// file tools/osd_command.h line 71
struct osd_rect_s;

// tag-osd_renderer_s
// file /usr/include/xine/osd.h line 33
struct osd_renderer_s_0;

// tag-osd_renderer_s_link1
// file /usr/include/xine/osd.h line 33
struct osd_renderer_s;

// tag-osd_rle_elem_s
// file tools/osd_command.h line 66
struct osd_rle_elem_s;

// tag-plugin_catalog_s
// file /usr/include/xine/plugin_catalog.h line 53
struct plugin_catalog_s_0;

// tag-plugin_catalog_s_link1
// file /usr/include/xine/plugin_catalog.h line 53
struct plugin_catalog_s;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-post_plugins_s
// file xine/post.h line 40
struct post_plugins_s_0;

// tag-post_plugins_s_link1
// file xine/post.h line 40
struct post_plugins_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rle_elem_s
// file /usr/include/xine/video_out.h line 457
struct rle_elem_s;

// tag-sched_param
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 72
struct sched_param;

// tag-scr_plugin_s
// file /usr/include/xine/metronom.h line 54
struct scr_plugin_s;

// tag-scratch_buffer_s
// file /usr/include/xine/scratch.h line 29
struct scratch_buffer_s;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-spu_decoder_s
// file /usr/include/xine/spu_decoder.h line 41
struct spu_decoder_s;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-sxfe_s
// file xine_sxfe_frontend.c line 103
struct sxfe_s;

// tag-tJpegCompressData_s
// file xine_frontend.c line 1654
struct tJpegCompressData_s;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-vdr_input_plugin_funcs_s
// file xine_input_vdr.h line 27
struct vdr_input_plugin_funcs_s_0;

// tag-vdr_input_plugin_funcs_s_link1
// file xine_input_vdr.h line 27
struct vdr_input_plugin_funcs_s;

// tag-vdr_input_plugin_if_s
// file xine_input_vdr.h line 23
struct vdr_input_plugin_if_s_0;

// tag-vdr_input_plugin_if_s_link1
// file xine_input_vdr.h line 23
struct vdr_input_plugin_if_s;

// tag-video_decoder_s
// file /usr/include/xine/video_decoder.h line 41
struct video_decoder_s;

// tag-video_overlay_event_s
// file /usr/include/xine/video_overlay.h line 52
struct video_overlay_event_s;

// tag-video_overlay_manager_s
// file /usr/include/xine/video_out.h line 52
struct video_overlay_manager_s;

// tag-video_overlay_manager_s_link1
// file /usr/include/xine/video_out.h line 52
struct video_overlay_manager_s_0;

// tag-video_overlay_object_s
// file /usr/include/xine/video_overlay.h line 42
struct video_overlay_object_s;

// tag-vo_driver_s
// file /usr/include/xine/video_out.h line 49
struct vo_driver_s;

// tag-vo_driver_s_link1
// file /usr/include/xine/video_out.h line 49
struct vo_driver_s_0;

// tag-vo_frame_s
// file /usr/include/xine/video_out.h line 48
struct vo_frame_s;

// tag-vo_frame_s_link1
// file /usr/include/xine/video_out.h line 48
struct vo_frame_s_0;

// tag-vo_overlay_s
// file /usr/include/xine/video_out.h line 51
struct vo_overlay_s;

// tag-xine_audio_port_s
// file /usr/include/xine.h line 83
struct xine_audio_port_s_0;

// tag-xine_audio_port_s_link1
// file /usr/include/xine.h line 83
struct xine_audio_port_s;

// tag-xine_cfg_entry_s
// file /usr/include/xine.h line 1563
struct xine_cfg_entry_s;

// tag-xine_event_queue_s
// file /usr/include/xine.h line 2132
struct xine_event_queue_s_0;

// tag-xine_event_queue_s_link1
// file /usr/include/xine.h line 2132
struct xine_event_queue_s;

// tag-xine_grab_video_frame_s
// file /usr/include/xine.h line 500
struct xine_grab_video_frame_s;

// tag-xine_list_s
// file /usr/include/xine/list.h line 45
struct xine_list_s;

// tag-xine_post_in_s
// file /usr/include/xine.h line 680
struct xine_post_in_s;

// tag-xine_post_out_s
// file /usr/include/xine.h line 681
struct xine_post_out_s;

// tag-xine_post_s
// file /usr/include/xine.h line 627
struct xine_post_s_0;

// tag-xine_post_s_link1
// file /usr/include/xine.h line 627
struct xine_post_s;

// tag-xine_s
// file /usr/include/xine.h line 81
struct xine_s_0;

// tag-xine_s_link1
// file /usr/include/xine.h line 81
struct xine_s;

// tag-xine_sarray_s
// file /usr/include/xine/sorted_array.h line 60
struct xine_sarray_s;

// tag-xine_stream_s
// file /usr/include/xine.h line 82
struct xine_stream_s_0;

// tag-xine_stream_s_link1
// file /usr/include/xine.h line 82
struct xine_stream_s;

// tag-xine_ticket_s
// file /usr/include/xine/xine_internal.h line 70
struct xine_ticket_s;

// tag-xine_video_port_s
// file /usr/include/xine.h line 84
struct xine_video_port_s;

// tag-xine_video_port_s_link1
// file /usr/include/xine.h line 84
struct xine_video_port_s_0;

#ifndef NULL
#define NULL ((void*)0)
#endif

// DPMSCapable
// file /usr/include/X11/extensions/dpms.h line 41
extern signed int DPMSCapable(struct _XDisplay *);
// DPMSDisable
// file /usr/include/X11/extensions/dpms.h line 45
extern signed int DPMSDisable(struct _XDisplay *);
// DPMSEnable
// file /usr/include/X11/extensions/dpms.h line 44
extern signed int DPMSEnable(struct _XDisplay *);
// DPMSInfo
// file /usr/include/X11/extensions/dpms.h line 47
extern signed int DPMSInfo(struct _XDisplay *, unsigned short int *, unsigned char *);
// DPMSQueryExtension
// file /usr/include/X11/extensions/dpms.h line 39
extern signed int DPMSQueryExtension(struct _XDisplay *, signed int *, signed int *);
// JpegCompressEmptyOutputBuffer
// file xine_frontend.c line 1669
static signed int JpegCompressEmptyOutputBuffer(struct jpeg_compress_struct * const cinfo);
// JpegCompressInitDestination
// file xine_frontend.c line 1659
static void JpegCompressInitDestination(struct jpeg_compress_struct * const cinfo);
// JpegCompressTermDestination
// file xine_frontend.c line 1685
static void JpegCompressTermDestination(struct jpeg_compress_struct * const cinfo);
// SignalHandler
// file xine_frontend_main.c line 45
static void SignalHandler(signed int signum);
// XAllocClassHint
// file /usr/include/X11/Xutil.h line 366
extern struct anonymous_9 * XAllocClassHint(void);
// XAllocNamedColor
// file /usr/include/X11/Xlib.h line 1988
extern signed int XAllocNamedColor(struct _XDisplay *, unsigned long int, const char *, struct anonymous_18 *, struct anonymous_18 *);
// XButtonEvent_handler
// file xine_sxfe_frontend.c line 2884
static void XButtonEvent_handler(struct sxfe_s *this, struct anonymous_37 *bev);
// XChangeProperty
// file /usr/include/X11/Xlib.h line 2068
extern signed int XChangeProperty(struct _XDisplay *, unsigned long int, unsigned long int, unsigned long int, signed int, signed int, const unsigned char *, signed int);
// XCheckMaskEvent
// file /usr/include/X11/Xlib.h line 2103
extern signed int XCheckMaskEvent(struct _XDisplay *, signed long int, union _XEvent *);
// XCloseDisplay
// file /usr/include/X11/Xlib.h line 2160
extern signed int XCloseDisplay(struct _XDisplay *);
// XConfigureEvent_handler
// file xine_sxfe_frontend.c line 2758
static void XConfigureEvent_handler(struct sxfe_s *this, struct anonymous_51 *cev);
// XCreateBitmapFromData
// file /usr/include/X11/Xlib.h line 1604
extern unsigned long int XCreateBitmapFromData(struct _XDisplay *, unsigned long int, const char *, unsigned int, unsigned int);
// XCreateColormap
// file /usr/include/X11/Xlib.h line 1552
extern unsigned long int XCreateColormap(struct _XDisplay *, unsigned long int, struct anonymous_16 *, signed int);
// XCreateGC
// file /usr/include/X11/Xlib.h line 1584
extern struct _XGC * XCreateGC(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous_77 *);
// XCreateImage
// file /usr/include/X11/Xlib.h line 1441
extern struct _XImage * XCreateImage(struct _XDisplay *, struct anonymous_16 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
// XCreatePixmap
// file /usr/include/X11/Xlib.h line 1597
extern unsigned long int XCreatePixmap(struct _XDisplay *, unsigned long int, unsigned int, unsigned int, unsigned int);
// XCreatePixmapCursor
// file /usr/include/X11/Xlib.h line 1558
extern unsigned long int XCreatePixmapCursor(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous_18 *, struct anonymous_18 *, unsigned int, unsigned int);
// XCreateWindow
// file /usr/include/X11/Xlib.h line 1636
extern unsigned long int XCreateWindow(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned int, signed int, unsigned int, struct anonymous_16 *, unsigned long int, struct anonymous_8 *);
// XDefineCursor
// file /usr/include/X11/Xlib.h line 2231
extern signed int XDefineCursor(struct _XDisplay *, unsigned long int, unsigned long int);
// XDestroyWindow
// file /usr/include/X11/Xlib.h line 2243
extern signed int XDestroyWindow(struct _XDisplay *, unsigned long int);
// XFetchName
// file /usr/include/X11/Xlib.h line 2453
extern signed int XFetchName(struct _XDisplay *, unsigned long int, char **);
// XFillRectangle
// file /usr/include/X11/Xlib.h line 2489
extern signed int XFillRectangle(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int);
// XFlush
// file /usr/include/X11/Xlib.h line 2507
extern signed int XFlush(struct _XDisplay *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XFreeGC
// file /usr/include/X11/Xlib.h line 2561
extern signed int XFreeGC(struct _XDisplay *, struct _XGC *);
// XFreePixmap
// file /usr/include/X11/Xlib.h line 2570
extern signed int XFreePixmap(struct _XDisplay *, unsigned long int);
// XGetVisualInfo
// file /usr/include/X11/Xutil.h line 471
extern struct anonymous_17 * XGetVisualInfo(struct _XDisplay *, signed long int, struct anonymous_17 *, signed int *);
// XInitThreads
// file /usr/include/X11/Xlib.h line 1734
extern signed int XInitThreads(void);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XKeyEvent_handler
// file xine_sxfe_frontend.c line 2687
static void XKeyEvent_handler(struct sxfe_s *this, struct anonymous_36 *kev);
// XKeysymToString
// file /usr/include/X11/Xlib.h line 1518
extern char * XKeysymToString(unsigned long int);
// XLockDisplay
// file /usr/include/X11/Xlib.h line 1738
extern void XLockDisplay(struct _XDisplay *);
// XLookupString
// file /usr/include/X11/Xutil.h line 534
extern signed int XLookupString(struct anonymous_36 *, char *, signed int, unsigned long int *, struct _XComposeStatus *);
// XLowerWindow
// file /usr/include/X11/Xlib.h line 2791
extern signed int XLowerWindow(struct _XDisplay *, unsigned long int);
// XMapRaised
// file /usr/include/X11/Xlib.h line 2796
extern signed int XMapRaised(struct _XDisplay *, unsigned long int);
// XMapWindow
// file /usr/include/X11/Xlib.h line 2806
extern signed int XMapWindow(struct _XDisplay *, unsigned long int);
// XMotionEvent_handler
// file xine_sxfe_frontend.c line 2843
static void XMotionEvent_handler(struct sxfe_s *this, struct anonymous_38 *mev);
// XMoveWindow
// file /usr/include/X11/Xlib.h line 2834
extern signed int XMoveWindow(struct _XDisplay *, unsigned long int, signed int, signed int);
// XNextEvent
// file /usr/include/X11/Xlib.h line 2841
extern signed int XNextEvent(struct _XDisplay *, union _XEvent *);
// XOpenDisplay
// file /usr/include/X11/Xlib.h line 1483
extern struct _XDisplay * XOpenDisplay(const char *);
// XPending
// file /usr/include/X11/Xlib.h line 2881
extern signed int XPending(struct _XDisplay *);
// XPutImage
// file /usr/include/X11/Xlib.h line 2903
extern signed int XPutImage(struct _XDisplay *, unsigned long int, struct _XGC *, struct _XImage *, signed int, signed int, signed int, signed int, unsigned int, unsigned int);
// XRaiseWindow
// file /usr/include/X11/Xlib.h line 3026
extern signed int XRaiseWindow(struct _XDisplay *, unsigned long int);
// XRenderComposite
// file /usr/include/X11/extensions/Xrender.h line 276
void XRenderComposite(struct _XDisplay *, signed int, unsigned long int, unsigned long int, unsigned long int, signed int, signed int, signed int, signed int, signed int, signed int, unsigned int, unsigned int);
// XRenderCreatePicture
// file /usr/include/X11/extensions/Xrender.h line 241
unsigned long int XRenderCreatePicture(struct _XDisplay *, unsigned long int, const struct anonymous_21 *, unsigned long int, const struct _XRenderPictureAttributes *);
// XRenderFindStandardFormat
// file /usr/include/X11/extensions/Xrender.h line 232
struct anonymous_21 * XRenderFindStandardFormat(struct _XDisplay *, signed int);
// XRenderFindVisualFormat
// file /usr/include/X11/extensions/Xrender.h line 216
struct anonymous_21 * XRenderFindVisualFormat(struct _XDisplay *, const struct anonymous_16 *);
// XRenderFreePicture
// file /usr/include/X11/extensions/Xrender.h line 272
void XRenderFreePicture(struct _XDisplay *, unsigned long int);
// XRenderQueryExtension
// file /usr/include/X11/extensions/Xrender.h line 203
signed int XRenderQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XRenderSetPictureFilter
// file /usr/include/X11/extensions/Xrender.h line 485
void XRenderSetPictureFilter(struct _XDisplay *, unsigned long int, const char *, signed int *, signed int);
// XRenderSetPictureTransform
// file /usr/include/X11/extensions/Xrender.h line 267
void XRenderSetPictureTransform(struct _XDisplay *, unsigned long int, struct _XTransform *);
// XResizeWindow
// file /usr/include/X11/Xlib.h line 3099
extern signed int XResizeWindow(struct _XDisplay *, unsigned long int, unsigned int, unsigned int);
// XSelectInput
// file /usr/include/X11/Xlib.h line 3129
extern signed int XSelectInput(struct _XDisplay *, unsigned long int, signed long int);
// XSendEvent
// file /usr/include/X11/Xlib.h line 3135
extern signed int XSendEvent(struct _XDisplay *, unsigned long int, signed int, signed long int, union _XEvent *);
// XSetClassHint
// file /usr/include/X11/Xutil.h line 583
extern signed int XSetClassHint(struct _XDisplay *, unsigned long int, struct anonymous_9 *);
// XSetForeground
// file /usr/include/X11/Xlib.h line 3227
extern signed int XSetForeground(struct _XDisplay *, struct _XGC *, unsigned long int);
// XSetNormalHints
// file /usr/include/X11/Xutil.h line 596
extern signed int XSetNormalHints(struct _XDisplay *, unsigned long int, struct anonymous_87 *);
// XSetScreenSaver
// file /usr/include/X11/Xlib.h line 3284
extern signed int XSetScreenSaver(struct _XDisplay *, signed int, signed int, signed int, signed int);
// XSetWMProtocols
// file /usr/include/X11/Xlib.h line 1888
extern signed int XSetWMProtocols(struct _XDisplay *, unsigned long int, unsigned long int *, signed int);
// XShapeCombineMask
// file /usr/include/X11/extensions/shape.h line 85
extern void XShapeCombineMask(struct _XDisplay *, unsigned long int, signed int, signed int, signed int, unsigned long int, signed int);
// XShapeCombineRectangles
// file /usr/include/X11/extensions/shape.h line 73
extern void XShapeCombineRectangles(struct _XDisplay *, unsigned long int, signed int, signed int, signed int, struct anonymous_20 *, signed int, signed int, signed int);
// XShapeQueryExtension
// file /usr/include/X11/extensions/shape.h line 51
extern signed int XShapeQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XShmAttach
// file /usr/include/X11/extensions/XShm.h line 78
signed int XShmAttach(struct _XDisplay *, struct anonymous_31 *);
// XShmCreateImage
// file /usr/include/X11/extensions/XShm.h line 111
struct _XImage * XShmCreateImage(struct _XDisplay *, struct anonymous_16 *, unsigned int, signed int, char *, struct anonymous_31 *, unsigned int, unsigned int);
// XShmDetach
// file /usr/include/X11/extensions/XShm.h line 83
signed int XShmDetach(struct _XDisplay *, struct anonymous_31 *);
// XShmGetEventBase
// file /usr/include/X11/extensions/XShm.h line 63
signed int XShmGetEventBase(struct _XDisplay *);
// XShmPutImage
// file /usr/include/X11/extensions/XShm.h line 88
signed int XShmPutImage(struct _XDisplay *, unsigned long int, struct _XGC *, struct _XImage *, signed int, signed int, signed int, signed int, unsigned int, unsigned int, signed int);
// XShmQueryExtension
// file /usr/include/X11/extensions/XShm.h line 59
signed int XShmQueryExtension(struct _XDisplay *);
// XStoreName
// file /usr/include/X11/Xlib.h line 3395
extern signed int XStoreName(struct _XDisplay *, unsigned long int, const char *);
// XSync
// file /usr/include/X11/Xlib.h line 3409
extern signed int XSync(struct _XDisplay *, signed int);
// XTranslateCoordinates
// file /usr/include/X11/Xlib.h line 3446
extern signed int XTranslateCoordinates(struct _XDisplay *, unsigned long int, unsigned long int, signed int, signed int, signed int *, signed int *, unsigned long int *);
// XUnlockDisplay
// file /usr/include/X11/Xlib.h line 1742
extern void XUnlockDisplay(struct _XDisplay *);
// XUnmapWindow
// file /usr/include/X11/Xlib.h line 3505
extern signed int XUnmapWindow(struct _XDisplay *, unsigned long int);
// XineramaIsActive
// file /usr/include/X11/extensions/Xinerama.h line 54
signed int XineramaIsActive(struct _XDisplay *);
// XineramaQueryScreens
// file /usr/include/X11/extensions/Xinerama.h line 66
struct anonymous_90 * XineramaQueryScreens(struct _XDisplay *, signed int *);
// __asprintf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 158
extern signed int __asprintf_chk(char ** restrict , signed int, const char *, ...);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __fdelt_chk
// file /usr/include/x86_64-linux-gnu/bits/select2.h line 24
extern signed long int __fdelt_chk(signed long int);
// __fdelt_warn
// file /usr/include/x86_64-linux-gnu/bits/select2.h line 25
extern signed long int __fdelt_warn(signed long int);
// __fgets_alias
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 243
extern char * __fgets_alias(char *, signed int, struct _IO_FILE *);
// __fgets_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 241
extern char * __fgets_chk(char *, unsigned long int, signed int, struct _IO_FILE *);
// __fgets_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 246
extern char * __fgets_chk_warn(char *, unsigned long int, signed int, struct _IO_FILE *);
// __fprintf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 85
extern signed int __fprintf_chk(struct _IO_FILE *, signed int, const char *, ...);
// __poll_alias
// file /usr/include/x86_64-linux-gnu/bits/poll2.h line 26
extern signed int __poll_alias(struct pollfd *, unsigned long int, signed int);
// __poll_chk
// file /usr/include/x86_64-linux-gnu/bits/poll2.h line 28
extern signed int __poll_chk(struct pollfd *, unsigned long int, signed int, unsigned long int);
// __poll_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/poll2.h line 30
extern signed int __poll_chk_warn(struct pollfd *, unsigned long int, signed int, unsigned long int);
// __pplugin_retrieve_parameters
// file xine/post.c line 62
static signed int __pplugin_retrieve_parameters(struct anonymous_72 *pobj);
// __pplugin_update_parameters
// file xine/post.c line 112
static void __pplugin_update_parameters(struct xine_post_s_0 *post, char *args);
// __printf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 87
extern signed int __printf_chk(signed int, const char *, ...);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous_102 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous_102 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous_102 *);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __read_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 25
extern signed long int __read_alias(signed int, void *, unsigned long int);
// __read_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 23
extern signed long int __read_chk(signed int, void *, unsigned long int, unsigned long int);
// __read_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 27
extern signed long int __read_chk_warn(signed int, void *, unsigned long int, unsigned long int);
// __recvfrom_alias
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 51
extern signed long int __recvfrom_alias(signed int, void *, unsigned long int, signed int, union anonymous_85, unsigned int *);
// __recvfrom_chk
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 47
extern signed long int __recvfrom_chk(signed int, void *, unsigned long int, unsigned long int, signed int, union anonymous_85, unsigned int *);
// __recvfrom_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 55
extern signed long int __recvfrom_chk_warn(signed int, void *, unsigned long int, unsigned long int, signed int, union anonymous_85, unsigned int *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __strpbrk_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1100
static inline char * __strpbrk_c2(const char *__s, signed int __accept1, signed int __accept2);
// __strpbrk_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1111
static inline char * __strpbrk_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3);
// __strsep_1c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c(char **__s, char __reject);
// __strsep_2c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c(char **__s, char __reject1, char __reject2);
// __strsep_3c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c(char **__s, char __reject1, char __reject2, char __reject3);
// __strsep_g
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1179
extern char * __strsep_g(char **, const char *);
// __syslog_chk
// file /usr/include/x86_64-linux-gnu/bits/syslog.h line 24
extern void __syslog_chk(signed int, signed int, const char *, ...);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 412
extern signed int __xstat(signed int, const char *, struct stat *);
// _applugin_enable_post
// file xine/post.c line 692
static signed int _applugin_enable_post(struct post_plugins_s_0 *fe, const char *name, const char *args, signed int *found);
// _applugin_rewire
// file xine/post.c line 614
static void _applugin_rewire(struct post_plugins_s_0 *fe);
// _applugin_rewire_from_post_elements
// file xine/post.c line 452
static void _applugin_rewire_from_post_elements(struct post_plugins_s_0 *fe, struct anonymous_73 **post_elements, signed int post_elements_num);
// _applugin_unwire
// file xine/post.c line 399
static void _applugin_unwire(struct post_plugins_s_0 *fe);
// _pp_args
// file xine/post.c line 715
static const char * _pp_args(const char *initstr);
// _pp_name_strdup
// file xine/post.c line 705
static char * _pp_name_strdup(const char *initstr);
// _pplugin_disable_post
// file xine/post.c line 779
static signed int _pplugin_disable_post(struct post_plugins_s_0 *fe, const char *name, struct anonymous_73 **post_elements, signed int post_elements_num);
// _pplugin_enable_post
// file xine/post.c line 642
static signed int _pplugin_enable_post(struct post_plugins_s_0 *fe, const char *name, const char *args, struct anonymous_73 **post_elements, signed int post_elements_num, signed int *found);
// _pplugin_join_deinterlace_and_post_elements
// file xine/post.c line 486
static struct anonymous_73 ** _pplugin_join_deinterlace_and_post_elements(struct post_plugins_s_0 *fe, signed int *post_elements_num);
// _pplugin_join_visualization_and_post_elements
// file xine/post.c line 558
static struct anonymous_73 ** _pplugin_join_visualization_and_post_elements(struct post_plugins_s_0 *fe, signed int *post_elements_num);
// _pplugin_unload_post
// file xine/post.c line 822
static signed int _pplugin_unload_post(struct post_plugins_s_0 *fe, const char *name, struct anonymous_73 ***post_elements, signed int *post_elements_num);
// _pplugin_update_parameter
// file xine/post.c line 106
static void _pplugin_update_parameter(struct anonymous_72 *pobj);
// _vpplugin_enable_post
// file xine/post.c line 679
static signed int _vpplugin_enable_post(struct post_plugins_s_0 *fe, const char *name, const char *args, signed int *found);
// _vpplugin_rewire
// file xine/post.c line 600
static void _vpplugin_rewire(struct post_plugins_s_0 *fe);
// _vpplugin_rewire_from_post_elements
// file xine/post.c line 407
static void _vpplugin_rewire_from_post_elements(struct post_plugins_s_0 *fe, struct anonymous_73 **post_elements, signed int post_elements_num);
// _vpplugin_unwire
// file xine/post.c line 391
static void _vpplugin_unwire(struct post_plugins_s_0 *fe);
// _x_stream_info_set
// file /usr/include/xine/info_helper.h line 41
void _x_stream_info_set(struct xine_stream_s *, signed int, signed int);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// alarm
// file /usr/include/unistd.h line 432
extern unsigned int alarm(unsigned int);
// applugin_disable_post
// file xine/post.c line 809
signed int applugin_disable_post(struct post_plugins_s_0 *fe, const char *name);
// applugin_enable_post
// file xine/post.c line 751
signed int applugin_enable_post(struct post_plugins_s_0 *fe, const char *initstr, signed int *found);
// applugin_parse_and_store_post
// file xine/post.c line 384
void applugin_parse_and_store_post(struct post_plugins_s_0 *fe, const char *post_chain);
// applugin_rewire_posts
// file xine/post.c line 635
void applugin_rewire_posts(struct post_plugins_s_0 *fe);
// applugin_unload_post
// file xine/post.c line 887
signed int applugin_unload_post(struct post_plugins_s_0 *fe, const char *name);
// asprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 176
static inline signed int asprintf(char ** restrict __ptr, const char * restrict __fmt, ...);
// asprintf_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 176
static inline signed int asprintf_link1(char ** restrict __ptr_link1, const char * restrict __fmt_link1, ...);
// asprintf_link2
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 176
static inline signed int asprintf_link2(char ** restrict __ptr_link2, const char * restrict __fmt_link2, ...);
// asprintf_link3
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 176
static inline signed int asprintf_link3(char ** restrict __ptr_link3, const char * restrict __fmt_link3, ...);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous_85, unsigned int);
// bindTexImage_object
//
void bindTexImage_object(struct _XDisplay *, unsigned long int, signed int, signed int *);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cec_start
// file xine_frontend_cec.h line 16
void cec_start(struct frontend_s *fe, signed int hdmi_port, signed int dev_type);
// cec_stop
// file xine_frontend_cec.h line 17
void cec_stop(void);
// ceil
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 178
extern double ceil(double);
// check_for_scaling
// file xine/vo_osdscaler.c line 236
static signed int check_for_scaling(struct anonymous_80 *this, struct vo_frame_s *frame, struct vo_overlay_s *overlay);
// check_mouse_cursor_hide
// file xine_sxfe_frontend.c line 2946
static void check_mouse_cursor_hide(struct sxfe_s *this, signed long int elapsed);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// configure_audio_out
// file xine_frontend.c line 455
static void configure_audio_out(const struct fe_s *this, const char *audio_driver, const char *audio_port);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous_85, unsigned int);
// create_windows
// file xine_sxfe_frontend.c line 1471
static void create_windows(struct sxfe_s *this);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// dbus_g_bus_get
// file /usr/include/dbus-1.0/dbus/dbus-glib.h line 109
struct _DBusGConnection * dbus_g_bus_get(enum anonymous_6, struct _GError **);
// dbus_g_error_get_name
// file /usr/include/dbus-1.0/dbus/dbus-glib.h line 100
const char * dbus_g_error_get_name(struct _GError *);
// dbus_g_error_quark
// file /usr/include/dbus-1.0/dbus/dbus-glib.h line 58
unsigned int dbus_g_error_quark(void);
// dbus_g_proxy_call
// file /usr/include/dbus-1.0/dbus/dbus-glib.h line 275
signed int dbus_g_proxy_call(struct _DBusGProxy *, const char *, struct _GError **, unsigned long int, ...);
// dbus_g_proxy_new_for_name
// file /usr/include/dbus-1.0/dbus/dbus-glib.h line 242
struct _DBusGProxy * dbus_g_proxy_new_for_name(struct _DBusGConnection *, const char *, const char *, const char *);
// detect_display_ratio
// file xine_sxfe_frontend.c line 1440
static double detect_display_ratio(struct _XDisplay *dpy, signed int screen);
// detect_xvdr_metronom
// file xine/vo_lastpts.c line 36
static void detect_xvdr_metronom(struct anonymous_83 *this, struct xine_stream_s_0 *stream);
// disable_DPMS
// file xine_sxfe_frontend.c line 1343
static void disable_DPMS(struct sxfe_s *this);
// discovery_init
// file tools/vdrdiscovery.c line 51
static inline signed int discovery_init(signed int port);
// display_frame
// file xine/vo_frameoutput.c line 44
static void display_frame(struct vo_driver_s *self, struct vo_frame_s *vo_img);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// elapsed
// file tools/time_ms.h line 28
static unsigned long int elapsed(unsigned long int t);
// elapsed_link1
// file tools/time_ms.h line 28
static unsigned long int elapsed_link1(unsigned long int t_link1);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fe_compress_grab_frame
// file xine_frontend.c line 1918
static char * fe_compress_grab_frame(struct fe_s *this, signed int *size, signed int jpeg, signed int quality, signed int width, signed int height, struct xine_grab_video_frame_s *frame);
// fe_control
// file xine_frontend.c line 1472
static void * fe_control(struct frontend_s *this_gen, const char *cmd);
// fe_creator_object
//
struct frontend_s * fe_creator_object(void);
// fe_dest_pixel_aspect
// file xine_frontend.c line 222
static double fe_dest_pixel_aspect(const struct fe_s *this, double video_pixel_aspect, signed int video_width, signed int video_height);
// fe_frame_output_cb
// file xine_frontend.c line 304
static void fe_frame_output_cb(void *data, signed int video_width, signed int video_height, double video_pixel_aspect, signed int *dest_x, signed int *dest_y, signed int *dest_width, signed int *dest_height, double *dest_pixel_aspect, signed int *win_x, signed int *win_y);
// fe_free
// file xine_frontend.c line 1286
static void fe_free(struct frontend_s *this_gen);
// fe_grab
// file xine_frontend.c line 1982
static char * fe_grab(struct frontend_s *this_gen, signed int *size, signed int jpeg, signed int quality, signed int width, signed int height);
// fe_is_finished
// file xine_frontend.c line 1297
static signed int fe_is_finished(struct frontend_s *this_gen, signed int slave_stream);
// fe_post_close
// file xine_frontend.c line 960
static void fe_post_close(const struct fe_s *this, const char *name, signed int which);
// fe_post_open
// file xine_frontend.c line 1043
static void fe_post_open(const struct fe_s *this, const char *name, const char *args);
// fe_post_rewire
// file xine_frontend.c line 944
static void fe_post_rewire(const struct fe_s *this);
// fe_post_unload
// file xine_frontend.c line 951
static void fe_post_unload(const struct fe_s *this);
// fe_post_unwire
// file xine_frontend.c line 899
static void fe_post_unwire(struct fe_s *this);
// fe_send_event
// file xine_frontend.c line 1412
static signed int fe_send_event(struct frontend_s *this_gen, const char *data);
// fe_send_input_event
// file xine_frontend.c line 1364
static signed int fe_send_input_event(struct frontend_s *this_gen, const char *map, const char *key, signed int repeat, signed int release);
// fe_shutdown_init
// file xine_frontend.c line 801
static void fe_shutdown_init(struct frontend_s *this_gen, const char *cmd, signed int timeout);
// fe_xine_close
// file xine_frontend.c line 1210
static void fe_xine_close(struct frontend_s *this_gen);
// fe_xine_exit
// file xine_frontend.c line 1234
static void fe_xine_exit(struct frontend_s *this_gen);
// fe_xine_init
// file xine_frontend.c line 581
static signed int fe_xine_init(struct frontend_s *this_gen, const char *audio_driver, const char *audio_port, const char *video_driver, signed int pes_buffers, const char *static_post_plugins, const char *config_file);
// fe_xine_open
// file xine_frontend.c line 819
static signed int fe_xine_open(struct frontend_s *this_gen, const char *mrl);
// fe_xine_play
// file xine_frontend.c line 1161
static signed int fe_xine_play(struct frontend_s *this_gen);
// fe_xine_stop
// file xine_frontend.c line 1190
static signed int fe_xine_stop(struct frontend_s *this_gen);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 253
static inline char * fgets(char * restrict __s, signed int __n, struct _IO_FILE * restrict __stream);
// fgets_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 253
static inline char * fgets_link1(char * restrict __s_link1, signed int __n_link1, struct _IO_FILE * restrict __stream_link1);
// find_argb_visual
// file xine_sxfe_frontend.c line 774
static struct anonymous_16 * find_argb_visual(struct _XDisplay *dpy, signed int scr);
// find_input_plugin
// file xine_frontend.c line 191
static signed int find_input_plugin(struct fe_s *this);
// floor
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 184
extern double floor(double);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf(struct _IO_FILE * restrict __stream, const char * restrict __fmt, ...);
// fprintf_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf_link1(struct _IO_FILE * restrict __stream_link1, const char * restrict __fmt_link1, ...);
// fprintf_link2
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf_link2(struct _IO_FILE * restrict __stream_link2, const char * restrict __fmt_link2, ...);
// fprintf_link3
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf_link3(struct _IO_FILE * restrict __stream_link3, const char * restrict __fmt_link3, ...);
// fprintf_link4
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf_link4(struct _IO_FILE * restrict __stream_link4, const char * restrict __fmt_link4, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freopen
// file /usr/include/stdio.h line 286
extern struct _IO_FILE * freopen(const char *, const char *, struct _IO_FILE *);
// g_error_free
// file /usr/include/glib-2.0/glib/gerror.h line 68
extern void g_error_free(struct _GError *);
// g_object_unref
// file /usr/include/glib-2.0/gobject/gobject.h line 480
extern void g_object_unref(void *);
// get_opt_val
// file xine_frontend.c line 1033
static signed int get_opt_val(const char *s, const char *opt);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// glBegin
// file /usr/include/GL/gl.h line 929
void glBegin(unsigned int);
// glBindTexture
// file /usr/include/GL/gl.h line 1311
void glBindTexture(unsigned int, unsigned int);
// glBlendFunc
// file /usr/include/GL/gl.h line 760
void glBlendFunc(unsigned int, unsigned int);
// glClear
// file /usr/include/GL/gl.h line 752
void glClear(unsigned int);
// glClearColor
// file /usr/include/GL/gl.h line 750
void glClearColor(float, float, float, float);
// glColor4f
// file /usr/include/GL/gl.h line 1003
void glColor4f(float, float, float, float);
// glEnable
// file /usr/include/GL/gl.h line 796
void glEnable(unsigned int);
// glEnd
// file /usr/include/GL/gl.h line 931
void glEnd(void);
// glGenTextures
// file /usr/include/GL/gl.h line 1307
void glGenTextures(signed int, unsigned int *);
// glGetError
// file /usr/include/GL/gl.h line 829
unsigned int glGetError(void);
// glGetString
// file /usr/include/GL/gl.h line 831
const unsigned char * glGetString(unsigned int);
// glLoadIdentity
// file /usr/include/GL/gl.h line 883
void glLoadIdentity(void);
// glMatrixMode
// file /usr/include/GL/gl.h line 866
void glMatrixMode(unsigned int);
// glOrtho
// file /usr/include/GL/gl.h line 868
void glOrtho(double, double, double, double, double, double);
// glTexCoord2f
// file /usr/include/GL/gl.h line 1042
void glTexCoord2f(float, float);
// glTexImage2D
// file /usr/include/GL/gl.h line 1294
void glTexImage2D(unsigned int, signed int, signed int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// glTexParameteri
// file /usr/include/GL/gl.h line 1270
void glTexParameteri(unsigned int, unsigned int, signed int);
// glVertex3f
// file /usr/include/GL/gl.h line 940
void glVertex3f(float, float, float);
// glXChooseFBConfig
// file /usr/include/GL/glx.h line 242
extern struct __GLXFBConfigRec ** glXChooseFBConfig(struct _XDisplay *, signed int, const signed int *, signed int *);
// glXChooseVisual
// file /usr/include/GL/glx.h line 187
extern struct anonymous_17 * glXChooseVisual(struct _XDisplay *, signed int, signed int *);
// glXCreateContext
// file /usr/include/GL/glx.h line 190
extern struct __GLXcontextRec * glXCreateContext(struct _XDisplay *, struct anonymous_17 *, struct __GLXcontextRec *, signed int);
// glXCreatePixmap
// file /usr/include/GL/glx.h line 259
extern unsigned long int glXCreatePixmap(struct _XDisplay *, struct __GLXFBConfigRec *, unsigned long int, const signed int *);
// glXDestroyContext
// file /usr/include/GL/glx.h line 193
extern void glXDestroyContext(struct _XDisplay *, struct __GLXcontextRec *);
// glXMakeCurrent
// file /usr/include/GL/glx.h line 195
extern signed int glXMakeCurrent(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *);
// glXQueryExtensionsString
// file /usr/include/GL/glx.h line 230
extern const char * glXQueryExtensionsString(struct _XDisplay *, signed int);
// glXQueryVersion
// file /usr/include/GL/glx.h line 210
extern signed int glXQueryVersion(struct _XDisplay *, signed int *, signed int *);
// glXSwapBuffers
// file /usr/include/GL/glx.h line 201
extern void glXSwapBuffers(struct _XDisplay *, unsigned long int);
// gnome_screensaver_control
// file tools/gnome_screensaver.h line 4
extern void gnome_screensaver_control(signed int enable);
// gnome_sessionmanager_control
// file tools/gnome_screensaver.c line 62
static signed int gnome_sessionmanager_control(struct _DBusGConnection *connection, signed int enable);
// guess_cpu_count
// file xine_frontend.c line 80
static signed int guess_cpu_count(void);
// hud_fill_argb
// file xine_sxfe_frontend.c line 810
static void hud_fill_argb(unsigned int *dst, signed int dst_pitch, struct osd_command_s *cmd);
// hud_fill_img_memory
// file xine_sxfe_frontend.c line 847
static void hud_fill_img_memory(unsigned int *dst, signed int dst_pitch, unsigned int *mask, signed int mask_pitch, signed int *mask_changed, struct osd_command_s *cmd);
// hud_frame_output_cb
// file xine_sxfe_frontend.c line 1071
static void hud_frame_output_cb(void *data, signed int video_width, signed int video_height, double video_pixel_aspect, signed int *dest_x, signed int *dest_y, signed int *dest_width, signed int *dest_height, double *dest_pixel_aspect, signed int *win_x, signed int *win_y);
// hud_osd_close
// file xine_sxfe_frontend.c line 1301
static void hud_osd_close(struct sxfe_s *this);
// hud_osd_command
// file xine_sxfe_frontend.c line 1013
static signed int hud_osd_command(struct frontend_s *this_gen, struct osd_command_s *cmd);
// hud_osd_draw
// file xine_sxfe_frontend.c line 873
static void hud_osd_draw(struct sxfe_s *this, struct osd_command_s *cmd);
// hud_osd_focus
// file xine_sxfe_frontend.c line 1280
static void hud_osd_focus(struct sxfe_s *this, struct anonymous_40 *fev);
// hud_osd_hide
// file xine_sxfe_frontend.c line 957
static void hud_osd_hide(struct sxfe_s *this);
// hud_osd_open
// file xine_sxfe_frontend.c line 1115
static signed int hud_osd_open(struct sxfe_s *this);
// hud_osd_resize
// file xine_sxfe_frontend.c line 1251
static void hud_osd_resize(struct sxfe_s *this, unsigned long int video_window, signed int width, signed int height);
// hud_osd_show
// file xine_sxfe_frontend.c line 984
static void hud_osd_show(struct sxfe_s *this);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// init_atoms
// file xine_sxfe_frontend.c line 282
static void init_atoms(struct sxfe_s *this);
// init_dummy_ports
// file xine_frontend.c line 865
static void init_dummy_ports(struct fe_s *this, signed int on);
// init_fe
// file xine_frontend.c line 2056
void init_fe(struct fe_s *fe);
// input_event_cb
// file xine_frontend.c line 1152
static void input_event_cb(struct frontend_s *this_gen, const char *keymap, const char *key);
// intercept_video_driver
// file xine_frontend.c line 50
static void intercept_video_driver(struct xine_video_port_s_0 *video_port);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// jpeg_CreateCompress
// file /usr/include/jpeglib.h line 904
extern void jpeg_CreateCompress(struct jpeg_compress_struct *, signed int, unsigned long int);
// jpeg_destroy_compress
// file /usr/include/jpeglib.h line 909
extern void jpeg_destroy_compress(struct jpeg_compress_struct *);
// jpeg_finish_compress
// file /usr/include/jpeglib.h line 954
extern void jpeg_finish_compress(struct jpeg_compress_struct *);
// jpeg_set_defaults
// file /usr/include/jpeglib.h line 926
extern void jpeg_set_defaults(struct jpeg_compress_struct *);
// jpeg_set_quality
// file /usr/include/jpeglib.h line 931
extern void jpeg_set_quality(struct jpeg_compress_struct *, signed int, signed int);
// jpeg_start_compress
// file /usr/include/jpeglib.h line 949
extern void jpeg_start_compress(struct jpeg_compress_struct *, signed int);
// jpeg_std_error
// file /usr/include/jpeglib.h line 889
extern struct jpeg_error_mgr * jpeg_std_error(struct jpeg_error_mgr *);
// jpeg_write_scanlines
// file /usr/include/jpeglib.h line 951
extern unsigned int jpeg_write_scanlines(struct jpeg_compress_struct *, unsigned char **, unsigned int);
// kbd_receiver_thread
// file xine_frontend_kbd.c line 169
static void * kbd_receiver_thread(void *fe_gen);
// kbd_receiver_thread::1::3::__cancel_routine_object
//
void __cancel_routine_object(void *);
// kbd_receiver_thread_cleanup
// file xine_frontend_kbd.c line 155
static void kbd_receiver_thread_cleanup(void *arg);
// kbd_start
// file xine_frontend_kbd.h line 16
void kbd_start(struct frontend_s *fe, signed int slave_mode);
// kbd_stop
// file xine_frontend_kbd.h line 17
void kbd_stop(void);
// lastpts_display_frame
// file xine/vo_lastpts.c line 53
static void lastpts_display_frame(struct vo_driver_s *self, struct vo_frame_s *vo_img);
// lirc_receiver_thread
// file xine_frontend_lirc.c line 96
static void * lirc_receiver_thread(void *fe_gen);
// lirc_start
// file xine_frontend_lirc.h line 16
void lirc_start(struct frontend_s *fe, const char *lirc_dev, signed int repeat_emu);
// lirc_stop
// file xine_frontend_lirc.h line 17
void lirc_stop(void);
// lircd_connect
// file xine_frontend_lirc.c line 65
static void lircd_connect(void);
// list_plugins_type
// file xine_frontend.c line 146
static void list_plugins_type(struct xine_s *xine, const char *msg, const char * const * (*list_func)(struct xine_s *));
// list_plugins_type::list_func_object
//
const char * const * list_func_object(struct xine_s *);
// list_xine_plugins
// file xine_frontend.c line 162
void list_xine_plugins(struct frontend_s *fe, signed int verbose);
// main::_tmp::return_value_signal_64_object
//
void return_value_signal_64_object(signed int);
// main::_tmp::return_value_signal_65_object
//
void return_value_signal_65_object(signed int);
// main::_tmp::return_value_signal_66_object
//
void return_value_signal_66_object(signed int);
// main::_tmp::return_value_signal_67_object
//
void return_value_signal_67_object(signed int);
// make_dirs
// file xine_frontend.c line 118
static void make_dirs(const char *file);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy(void * restrict __dest, const void * restrict __src, unsigned long int __len);
// memcpy_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy_link1(void * restrict __dest_link1, const void * restrict __src_link1, unsigned long int __len_link1);
// memcpy_link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy_link2(void * restrict __dest_link2, const void * restrict __src_link2, unsigned long int __len_link2);
// memcpy_link3
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy_link3(void * restrict __dest_link3, const void * restrict __src_link3, unsigned long int __len_link3);
// memcpy_link4
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy_link4(void * restrict __dest_link4, const void * restrict __src_link4, unsigned long int __len_link4);
// memmove
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 57
static inline void * memmove(void *__dest, const void *__src, unsigned long int __len);
// memset
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset(void *__dest, signed int __ch, unsigned long int __len);
// memset_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset_link1(void *__dest_link1, signed int __ch_link1, unsigned long int __len_link1);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// nice
// file /usr/include/unistd.h line 598
extern signed int nice(signed int);
// open_display
// file xine_sxfe_frontend.c line 1369
static signed int open_display(struct sxfe_s *this, const char *video_port);
// opengl_deinit
// file xine_sxfe_frontend.c line 1982
static void opengl_deinit(struct sxfe_s *this);
// opengl_draw_frame_thread
// file xine_sxfe_frontend.c line 1990
static void * opengl_draw_frame_thread(void *arg);
// opengl_fill_argb
// file xine_sxfe_frontend.c line 1527
static void opengl_fill_argb(unsigned int *dst, signed int dst_pitch, struct osd_command_s *cmd);
// opengl_frame_output_cb
// file xine_sxfe_frontend.c line 1678
static void opengl_frame_output_cb(void *data, signed int video_width, signed int video_height, double video_pixel_aspect, signed int *dest_x, signed int *dest_y, signed int *dest_width, signed int *dest_height, double *dest_pixel_aspect, signed int *win_x, signed int *win_y);
// opengl_init
// file xine_sxfe_frontend.c line 1786
static signed int opengl_init(struct sxfe_s *this);
// opengl_init_dl
// file xine_sxfe_frontend.c line 1723
static signed int opengl_init_dl(struct sxfe_s *this);
// opengl_init_dl::1::glXGetProcAddressARB_object
//
void * glXGetProcAddressARB_object(unsigned char *);
// opengl_osd_command
// file xine_sxfe_frontend.c line 1613
static signed int opengl_osd_command(struct frontend_s *this_gen, struct osd_command_s *cmd);
// opengl_osd_draw
// file xine_sxfe_frontend.c line 1551
static void opengl_osd_draw(struct sxfe_s *this, struct osd_command_s *cmd);
// opengl_osd_hide
// file xine_sxfe_frontend.c line 1583
static void opengl_osd_hide(struct sxfe_s *this);
// opengl_osd_show
// file xine_sxfe_frontend.c line 1592
static void opengl_osd_show(struct sxfe_s *this);
// opengl_start
// file xine_sxfe_frontend.c line 2194
static signed int opengl_start(struct sxfe_s *this);
// opengl_trigger_drawing_thread
// file xine_sxfe_frontend.c line 1659
void opengl_trigger_drawing_thread(struct sxfe_s *this);
// opengl_wait_drawing_finished
// file xine_sxfe_frontend.c line 1670
void opengl_wait_drawing_finished(struct sxfe_s *this);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// osd_command
// file xine_sxfe_frontend.c line 662
static signed int osd_command(struct sxfe_s *this, struct osd_command_s *cmd);
// osd_data_clear
// file xine/vo_osdscaler.c line 85
static void osd_data_clear(struct osd_data_s *data);
// osd_data_dispose
// file xine/vo_osdscaler.c line 73
static void osd_data_dispose(struct osd_data_s *data);
// osd_data_init
// file xine/vo_osdscaler.c line 128
static struct osd_data_s * osd_data_init(struct vo_overlay_s *ovl, struct osd_data_s *next, unsigned int factor_x, unsigned int factor_y);
// osd_data_remove
// file xine/vo_osdscaler.c line 99
static void osd_data_remove(struct osd_data_s **list, struct osd_data_s *data);
// osd_fill_lut8
// file xine_sxfe_frontend.c line 602
static void osd_fill_lut8(unsigned int *dst, signed int dst_pitch, signed int argb, struct osd_command_s *cmd);
// osd_level
// file xine/vo_osdreorder.c line 35
static signed int osd_level(struct vo_overlay_s *overlay);
// osd_reorder_init
// file xine/vo_osdreorder.c line 92
struct vo_driver_s * osd_reorder_init(void);
// osd_set_video_window
// file xine_sxfe_frontend.c line 626
static void osd_set_video_window(struct sxfe_s *this, struct osd_command_s *cmd);
// osdreorder_overlay_blend
// file xine/vo_osdreorder.c line 53
static void osdreorder_overlay_blend(struct vo_driver_s *self, struct vo_frame_s *frame, struct vo_overlay_s *overlay);
// osdreorder_overlay_end
// file xine/vo_osdreorder.c line 74
static void osdreorder_overlay_end(struct vo_driver_s *self, struct vo_frame_s *vo_img);
// osdscaler_dispose
// file xine/vo_osdscaler.c line 457
static void osdscaler_dispose(struct vo_driver_s *self);
// osdscaler_get_capabilities
// file xine/vo_osdscaler.c line 411
static unsigned int osdscaler_get_capabilities(struct vo_driver_s *self);
// osdscaler_get_property
// file xine/vo_osdscaler.c line 420
static signed int osdscaler_get_property(struct vo_driver_s *self, signed int prop);
// osdscaler_init
// file xine/vo_osdscaler.c line 470
struct vo_driver_s * osdscaler_init(void);
// osdscaler_overlay_begin
// file xine/vo_osdscaler.c line 208
static void osdscaler_overlay_begin(struct vo_driver_s *self, struct vo_frame_s *frame, signed int changed);
// osdscaler_overlay_blend
// file xine/vo_osdscaler.c line 380
static void osdscaler_overlay_blend(struct vo_driver_s *self, struct vo_frame_s *frame, struct vo_overlay_s *overlay);
// osdscaler_overlay_end
// file xine/vo_osdscaler.c line 394
static void osdscaler_overlay_end(struct vo_driver_s *self, struct vo_frame_s *vo_img);
// osdscaler_set_property
// file xine/vo_osdscaler.c line 435
static signed int osdscaler_set_property(struct vo_driver_s *self, signed int prop, signed int val);
// poll
// file /usr/include/x86_64-linux-gnu/bits/poll2.h line 36
static inline signed int poll(struct pollfd *__fds, unsigned long int __nfds, signed int __timeout);
// poll_link1
// file /usr/include/x86_64-linux-gnu/bits/poll2.h line 36
static inline signed int poll_link1(struct pollfd *__fds_link1, unsigned long int __nfds_link1, signed int __timeout_link1);
// poll_link2
// file /usr/include/x86_64-linux-gnu/bits/poll2.h line 36
static inline signed int poll_link2(struct pollfd *__fds_link2, unsigned long int __nfds_link2, signed int __timeout_link2);
// pplugin_parse_and_load
// file xine/post.c line 229
static struct anonymous_73 ** pplugin_parse_and_load(struct post_plugins_s_0 *fe, signed int plugin_type, const char *pchain, signed int *post_elements_num);
// pplugin_parse_and_store_post
// file xine/post.c line 308
void pplugin_parse_and_store_post(struct post_plugins_s_0 *fe, signed int plugin_type, const char *post_chain);
// printf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 102
static inline signed int printf(const char * restrict __fmt, ...);
// printf_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 102
static inline signed int printf_link1(const char * restrict __fmt_link1, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_getschedparam
// file /usr/include/pthread.h line 318
extern signed int pthread_attr_getschedparam(const union pthread_attr_t *, struct sched_param *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_attr_setschedparam
// file /usr/include/pthread.h line 323
extern signed int pthread_attr_setschedparam(union pthread_attr_t *, struct sched_param *);
// pthread_attr_setscope
// file /usr/include/pthread.h line 353
extern signed int pthread_attr_setscope(union pthread_attr_t *, signed int);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_19 *, const union anonymous_12 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_19 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_19 *, union anonymous_7 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_7 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_7 *, const union anonymous_12 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_7 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_7 *);
// pthread_testcancel
// file /usr/include/pthread.h line 520
extern void pthread_testcancel(void);
// read
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 34
static inline signed long int read(signed int __fd, void *__buf, unsigned long int __nbytes);
// read_link1
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 34
static inline signed long int read_link1(signed int __fd_link1, void *__buf_link1, unsigned long int __nbytes_link1);
// read_key
// file xine_frontend_kbd.c line 53
static signed int read_key(void);
// read_key_seq
// file xine_frontend_kbd.c line 99
static unsigned long int read_key_seq(void);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 64
static inline signed long int recvfrom(signed int __fd, void * restrict __buf, unsigned long int __n, signed int __flags, union anonymous_85 __addr, unsigned int * restrict __addr_len);
// rle_compress
// file tools/rle.c line 29
unsigned int rle_compress(struct osd_rle_elem_s **rle_data, const unsigned char *data, unsigned int w, unsigned int h);
// rle_compress_hdmv
// file tools/rle.c line 248
unsigned long int rle_compress_hdmv(unsigned char **rle_data, const unsigned char *data, unsigned int w, unsigned int h, signed int *num_rle);
// rle_compress_net
// file tools/rle.c line 67
unsigned int rle_compress_net(unsigned char **rle_data, unsigned int *elems, const unsigned char *data, unsigned int w, unsigned int h);
// rle_palette_to_argb
// file tools/rle.h line 32
void rle_palette_to_argb(unsigned int *argb, struct osd_clut_s *palette, unsigned int entries);
// rle_palette_to_rgba
// file tools/rle.h line 33
void rle_palette_to_rgba(unsigned int *rgba, struct osd_clut_s *palette, unsigned int entries);
// rle_recompress_net
// file tools/rle.c line 78
unsigned int rle_recompress_net(unsigned char *raw, struct osd_rle_elem_s *data, unsigned int elems);
// rle_scale_nearest
// file xine/../tools/rle.h line 53
struct osd_rle_elem_s * rle_scale_nearest(const struct osd_rle_elem_s *old_rle, signed int *rle_elems, unsigned int w, unsigned int h, unsigned int new_w, unsigned int new_h);
// rle_uncompress_argb
// file tools/rle.h line 38
void rle_uncompress_argb(unsigned int *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle, struct osd_clut_s *palette, unsigned int palette_entries);
// rle_uncompress_hdmv
// file tools/rle.c line 298
signed int rle_uncompress_hdmv(struct osd_rle_elem_s **data, unsigned int w, unsigned int h, const unsigned char *rle_data, unsigned int num_rle, unsigned long int rle_size);
// rle_uncompress_lut8
// file tools/rle.c line 372
void rle_uncompress_lut8(unsigned char *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle);
// rle_uncompress_rgba
// file tools/rle.h line 42
void rle_uncompress_rgba(unsigned int *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle, struct osd_clut_s *palette, unsigned int palette_entries);
// rle_uncompress_u32
// file tools/rle.c line 420
static void rle_uncompress_u32(unsigned int *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle, unsigned int *lut);
// scale_overlay
// file xine/vo_osdscaler.c line 335
static struct vo_overlay_s * scale_overlay(struct anonymous_80 *this, struct vo_frame_s *frame, struct vo_overlay_s *overlay);
// sched_get_priority_min
// file /usr/include/sched.h line 71
extern signed int sched_get_priority_min(signed int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_98 *, struct anonymous_98 *, struct anonymous_98 *, struct timeval *);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, union anonymous_85, unsigned int);
// set_above
// file xine_sxfe_frontend.c line 418
static void set_above(struct sxfe_s *this, signed int stay_above);
// set_border
// file xine_sxfe_frontend.c line 319
static void set_border(struct sxfe_s *this, unsigned long int window, signed int border);
// set_cursor
// file xine_sxfe_frontend.c line 523
static void set_cursor(struct _XDisplay *dpy, unsigned long int win, const signed int enable);
// set_fs_size_hint
// file xine_sxfe_frontend.c line 301
static void set_fs_size_hint(struct sxfe_s *this);
// set_fullscreen_props
// file xine_sxfe_frontend.c line 337
static void set_fullscreen_props(struct sxfe_s *this);
// set_icon
// file xine_sxfe_frontend.c line 1409
static void set_icon(struct sxfe_s *this);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// shutdown_system
// file xine_frontend.c line 105
static void shutdown_system(char *cmd, signed int user_requested);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// slave_receiver_thread
// file xine_frontend_kbd.c line 257
static void * slave_receiver_thread(void *fe_gen);
// slave_receiver_thread::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// slave_receiver_thread_cleanup
// file xine_frontend_kbd.c line 250
static void slave_receiver_thread_cleanup(void *arg);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, ...);
// snprintf_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf_link1(char * restrict __s_link1, unsigned long int __n_link1, const char * restrict __fmt_link1, ...);
// snprintf_link2
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf_link2(char * restrict __s_link2, unsigned long int __n_link2, const char * restrict __fmt_link2, ...);
// snprintf_link3
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf_link3(char * restrict __s_link3, unsigned long int __n_link3, const char * restrict __fmt_link3, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 31
static inline signed int sprintf(char * restrict __s, const char * restrict __fmt, ...);
// sprintf_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 31
static inline signed int sprintf_link1(char * restrict __s_link1, const char * restrict __fmt_link1, ...);
// sprintf_link2
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 31
static inline signed int sprintf_link2(char * restrict __s_link2, const char * restrict __fmt_link2, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 146
static inline char * strcat(char * restrict __dest, const char * restrict __src);
// strcat_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 146
static inline char * strcat_link1(char * restrict __dest_link1, const char * restrict __src_link1);
// strcat_link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 146
static inline char * strcat_link2(char * restrict __dest_link2, const char * restrict __src_link2);
// strcatrealloc
// file xine_frontend_main.c line 69
static char * strcatrealloc(char *dest, const char *src);
// strcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 108
static inline char * strcpy(char * restrict __dest, const char * restrict __src);
// strcpy_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 108
static inline char * strcpy_link1(char * restrict __dest_link1, const char * restrict __src_link1);
// strcpy_link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 108
static inline char * strcpy_link2(char * restrict __dest_link2, const char * restrict __src_link2);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strn0cpy
// file xine_frontend.c line 72
char * strn0cpy(char *dest, const char *src, signed int n);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 153
static inline char * strncat(char * restrict __dest, const char * restrict __src, unsigned long int __len);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 123
static inline char * strncpy(char * restrict __dest, const char * restrict __src, unsigned long int __len);
// strncpy_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 123
static inline char * strncpy_link1(char * restrict __dest_link1, const char * restrict __src_link1, unsigned long int __len_link1);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// sxfe_dest_size_cb
// file xine_sxfe_frontend.c line 266
static void sxfe_dest_size_cb(void *data, signed int video_width, signed int video_height, double video_pixel_aspect, signed int *dest_width, signed int *dest_height, double *dest_pixel_aspect);
// sxfe_display_close
// file xine_sxfe_frontend.c line 3070
static void sxfe_display_close(struct frontend_s *this_gen);
// sxfe_display_config
// file xine_sxfe_frontend.c line 2466
static signed int sxfe_display_config(struct frontend_s *this_gen, signed int xpos, signed int ypos, signed int width, signed int height, signed int fullscreen, signed int modeswitch, const char *modeline, signed int aspect, signed int scale_video);
// sxfe_display_edid
// file xine_sxfe_frontend.c line 2570
static unsigned char * sxfe_display_edid(struct frontend_s *this_gen, signed int *size);
// sxfe_display_open
// file xine_sxfe_frontend.c line 2244
static signed int sxfe_display_open(struct frontend_s *this_gen, signed int xpos, signed int ypos, signed int width, signed int height, signed int fullscreen, signed int hud, signed int opengl, signed int modeswitch, const char *modeline, signed int aspect, signed int no_x_kbd, signed int gui_hotkeys, signed int touchscreen, const char *video_port, signed int scale_video, const char *aspect_controller, signed int window_id);
// sxfe_get_frontend
// file xine_sxfe_frontend.c line 3185
static struct frontend_s * sxfe_get_frontend(void);
// sxfe_interrupt
// file xine_sxfe_frontend.c line 2664
static void sxfe_interrupt(struct frontend_s *this_gen);
// sxfe_run
// file xine_sxfe_frontend.c line 2957
static signed int sxfe_run(struct frontend_s *this_gen);
// sxfe_toggle_fullscreen
// file xine_sxfe_frontend.c line 2542
static void sxfe_toggle_fullscreen(struct fe_s_0 *this_gen, signed int fullscreen);
// sxfe_xine_open
// file xine_sxfe_frontend.c line 3134
static signed int sxfe_xine_open(struct frontend_s *this_gen, const char *mrl);
// sxfe_xine_play
// file xine_sxfe_frontend.c line 3155
static signed int sxfe_xine_play(struct frontend_s *this_gen);
// syscall
// file /usr/include/unistd.h line 1058
extern signed long int syscall(signed long int, ...);
// syslog
// file /usr/include/x86_64-linux-gnu/bits/syslog.h line 29
static inline void syslog(signed int __pri, const char *__fmt, ...);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// time_ms
// file tools/time_ms.h line 16
static unsigned long int time_ms(void);
// time_ms_link1
// file tools/time_ms.h line 16
static unsigned long int time_ms_link1(void);
// udp_discovery_broadcast
// file tools/vdrdiscovery.c line 105
signed int udp_discovery_broadcast(signed int fd_discovery, signed int server_port, const char *server_address);
// udp_discovery_find_server
// file tools/vdrdiscovery.h line 35
signed int udp_discovery_find_server(signed int *port, char *address);
// udp_discovery_init
// file tools/vdrdiscovery.c line 81
signed int udp_discovery_init(void);
// udp_discovery_is_valid_search
// file tools/vdrdiscovery.c line 185
signed int udp_discovery_is_valid_search(const char *buf);
// udp_discovery_recv
// file tools/vdrdiscovery.c line 155
signed int udp_discovery_recv(signed int fd_discovery, char *buf, signed int timeout, struct sockaddr_in *source);
// udp_discovery_search
// file tools/vdrdiscovery.c line 135
static inline signed int udp_discovery_search(signed int fd_discovery, signed int port);
// udp_discovery_send
// file tools/vdrdiscovery.c line 86
static inline signed int udp_discovery_send(signed int fd_discovery, signed int port, char *msg);
// unwire_video_driver
// file xine/vo_hook.c line 182
signed int unwire_video_driver(struct xine_video_port_s *video_port, struct vo_driver_s *hook_gen, struct vo_driver_s *video_out);
// update_mask
// file xine_sxfe_frontend.c line 825
static void update_mask(unsigned int *dst, signed int dst_pitch, unsigned int *mask, signed int mask_pitch, signed int *mask_changed, struct osd_command_s *cmd);
// update_screen_size
// file xine_sxfe_frontend.c line 585
static void update_screen_size(struct sxfe_s *this);
// update_window_title
// file xine_sxfe_frontend.c line 390
static void update_window_title(struct sxfe_s *this);
// update_xinerama_info
// file xine_sxfe_frontend.c line 543
static void update_xinerama_info(struct sxfe_s *this);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vo_def_alloc_frame
// file xine/vo_hook.c line 62
struct vo_frame_s * vo_def_alloc_frame(struct vo_driver_s *self);
// vo_def_display_frame
// file xine/vo_hook.c line 72
void vo_def_display_frame(struct vo_driver_s *self, struct vo_frame_s *a1);
// vo_def_dispose
// file xine/vo_hook.c line 85
void vo_def_dispose(struct vo_driver_s *self);
// vo_def_get_capabilities
// file xine/vo_hook.c line 61
unsigned int vo_def_get_capabilities(struct vo_driver_s *self);
// vo_def_get_property
// file xine/vo_hook.c line 76
signed int vo_def_get_property(struct vo_driver_s *self, signed int a1);
// vo_def_get_property_min_max
// file xine/vo_hook.c line 78
void vo_def_get_property_min_max(struct vo_driver_s *self, signed int a1, signed int *a2, signed int *a3);
// vo_def_gui_data_exchange
// file xine/vo_hook.c line 79
signed int vo_def_gui_data_exchange(struct vo_driver_s *self, signed int a1, void *a2);
// vo_def_new_grab_video_frame
// file xine/vo_hook.c line 82
struct xine_grab_video_frame_s * vo_def_new_grab_video_frame(struct vo_driver_s *self);
// vo_def_overlay_begin
// file xine/vo_hook.c line 73
void vo_def_overlay_begin(struct vo_driver_s *self, struct vo_frame_s *a1, signed int a2);
// vo_def_overlay_blend
// file xine/vo_hook.c line 74
void vo_def_overlay_blend(struct vo_driver_s *self, struct vo_frame_s *a1, struct vo_overlay_s *a2);
// vo_def_overlay_end
// file xine/vo_hook.c line 75
void vo_def_overlay_end(struct vo_driver_s *self, struct vo_frame_s *a1);
// vo_def_redraw_needed
// file xine/vo_hook.c line 80
signed int vo_def_redraw_needed(struct vo_driver_s *self);
// vo_def_set_property
// file xine/vo_hook.c line 77
signed int vo_def_set_property(struct vo_driver_s *self, signed int a1, signed int a2);
// vo_def_update_frame_format
// file xine/vo_hook.c line 64
void vo_def_update_frame_format(struct vo_driver_s *self, struct vo_frame_s *img, unsigned int width, unsigned int height, double ratio, signed int format, signed int flags);
// vo_frameoutput_init
// file xine/vo_frameoutput.c line 61
struct vo_driver_s * vo_frameoutput_init(void *handle, void (*cb)(void *, struct vo_frame_s *));
// vo_frameoutput_init::cb_object
//
void cb_object(void *, struct vo_frame_s *);
// vo_lastpts_init
// file xine/vo_lastpts.c line 99
struct vo_driver_s * vo_lastpts_init(void);
// vo_proxy_hooks_init
// file xine/vo_hook.c line 99
static void vo_proxy_hooks_init(struct vo_driver_s *drv, struct vo_driver_s *next_driver);
// vo_proxy_hooks_init::_tmp::tmp_if_expr_1_object
//
unsigned int tmp_if_expr_1_object(struct vo_driver_s *);
// vo_proxy_hooks_init::_tmp::tmp_if_expr_10_object
//
void tmp_if_expr_10_object(struct vo_driver_s *);
// vo_proxy_hooks_init::_tmp::tmp_if_expr_2_object
//
struct vo_frame_s * tmp_if_expr_2_object(struct vo_driver_s *);
// vo_proxy_hooks_init::_tmp::tmp_if_expr_3_object
//
void tmp_if_expr_3_object(struct vo_driver_s *, struct vo_frame_s *, unsigned int, unsigned int, double, signed int, signed int);
// vo_proxy_hooks_init::_tmp::tmp_if_expr_4_object
//
void tmp_if_expr_4_object(struct vo_driver_s *, struct vo_frame_s *);
// vo_proxy_hooks_init::_tmp::tmp_if_expr_5_object
//
signed int tmp_if_expr_5_object(struct vo_driver_s *, signed int);
// vo_proxy_hooks_init::_tmp::tmp_if_expr_6_object
//
signed int tmp_if_expr_6_object(struct vo_driver_s *, signed int, signed int);
// vo_proxy_hooks_init::_tmp::tmp_if_expr_7_object
//
void tmp_if_expr_7_object(struct vo_driver_s *, signed int, signed int *, signed int *);
// vo_proxy_hooks_init::_tmp::tmp_if_expr_8_object
//
signed int tmp_if_expr_8_object(struct vo_driver_s *, signed int, void *);
// vo_proxy_hooks_init::_tmp::tmp_if_expr_9_object
//
signed int tmp_if_expr_9_object(struct vo_driver_s *);
// vpplugin_disable_post
// file xine/post.c line 796
signed int vpplugin_disable_post(struct post_plugins_s_0 *fe, const char *name);
// vpplugin_enable_post
// file xine/post.c line 723
signed int vpplugin_enable_post(struct post_plugins_s_0 *fe, const char *initstr, signed int *found);
// vpplugin_parse_and_store_post
// file xine/post.c line 377
void vpplugin_parse_and_store_post(struct post_plugins_s_0 *fe, const char *post_chain);
// vpplugin_rewire_posts
// file xine/post.c line 628
void vpplugin_rewire_posts(struct post_plugins_s_0 *fe);
// vpplugin_unload_post
// file xine/post.c line 873
signed int vpplugin_unload_post(struct post_plugins_s_0 *fe, const char *name);
// vsnprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 74
static inline signed int vsnprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, void **__ap);
// wire_video_driver
// file xine/vo_hook.c line 152
signed int wire_video_driver(struct xine_video_port_s *video_port, struct vo_driver_s *hook);
// write_rle_hdmv
// file tools/rle.c line 210
static unsigned char * write_rle_hdmv(unsigned char *rle_data, unsigned int color, unsigned int len);
// x_syslog
// file logdefs.h line 57
void x_syslog(signed int level, const char *module, const char *fmt, ...);
// xine_check_version
// file /usr/include/xine.h line 100
signed int xine_check_version(signed int, signed int, signed int);
// xine_close
// file /usr/include/xine.h line 255
void xine_close(struct xine_stream_s *);
// xine_close_audio_driver
// file /usr/include/xine.h line 151
void xine_close_audio_driver(struct xine_s *, struct xine_audio_port_s *);
// xine_close_video_driver
// file /usr/include/xine.h line 152
void xine_close_video_driver(struct xine_s *, struct xine_video_port_s_0 *);
// xine_config_load
// file /usr/include/xine.h line 1711
void xine_config_load(struct xine_s *, const char *);
// xine_config_register_bool
// file /usr/include/xine.h line 1664
signed int xine_config_register_bool(struct xine_s *, const char *, signed int, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
// xine_config_register_enum
// file /usr/include/xine.h line 1645
signed int xine_config_register_enum(struct xine_s *, const char *, signed int, char **, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
// xine_config_register_num
// file /usr/include/xine.h line 1655
signed int xine_config_register_num(struct xine_s *, const char *, signed int, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
// xine_config_register_string
// file /usr/include/xine.h line 1616
const char * xine_config_register_string(struct xine_s *, const char *, const char *, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
// xine_config_save
// file /usr/include/xine.h line 1712
void xine_config_save(struct xine_s *, const char *);
// xine_control
// file xine_frontend.c line 1330
static signed int xine_control(struct frontend_s *this_gen, const char *cmd);
// xine_dispose
// file /usr/include/xine.h line 267
void xine_dispose(struct xine_stream_s *);
// xine_event_cb
// file xine_frontend.c line 408
static void xine_event_cb(void *user_data, const struct anonymous_15 *event);
// xine_event_create_listener_thread
// file /usr/include/xine.h line 2164
void xine_event_create_listener_thread(struct xine_event_queue_s *, void (*)(void *, const struct anonymous_15 *), void *);
// xine_event_dispose_queue
// file /usr/include/xine.h line 2142
void xine_event_dispose_queue(struct xine_event_queue_s *);
// xine_event_new_queue
// file /usr/include/xine.h line 2141
struct xine_event_queue_s * xine_event_new_queue(struct xine_stream_s *);
// xine_event_send
// file /usr/include/xine.h line 2174
void xine_event_send(struct xine_stream_s *, const struct anonymous_15 *);
// xine_exit
// file /usr/include/xine.h line 173
void xine_exit(struct xine_s *);
// xine_fast_memcpy_object
//
void * xine_fast_memcpy_object(void *, const void *, unsigned long int);
// xine_get_audio_source
// file /usr/include/xine.h line 766
struct xine_post_out_s * xine_get_audio_source(struct xine_stream_s *);
// xine_get_homedir
// file /usr/include/xine/xineutils.h line 164
const char * xine_get_homedir(void);
// xine_get_param
// file /usr/include/xine.h line 282
signed int xine_get_param(struct xine_stream_s *, signed int);
// xine_get_version
// file /usr/include/xine.h line 96
void xine_get_version(signed int *, signed int *, signed int *);
// xine_get_video_source
// file /usr/include/xine.h line 765
struct xine_post_out_s * xine_get_video_source(struct xine_stream_s *);
// xine_init
// file /usr/include/xine.h line 129
void xine_init(struct xine_s *);
// xine_list_audio_decoder_plugins
// file /usr/include/xine.h line 1170
const char * const * xine_list_audio_decoder_plugins(struct xine_s *);
// xine_list_audio_output_plugins
// file /usr/include/xine.h line 1155
const char * const * xine_list_audio_output_plugins(struct xine_s *);
// xine_list_demuxer_plugins
// file /usr/include/xine.h line 1161
const char * const * xine_list_demuxer_plugins(struct xine_s *);
// xine_list_input_plugins
// file /usr/include/xine.h line 1164
const char * const * xine_list_input_plugins(struct xine_s *);
// xine_list_post_plugins
// file /usr/include/xine.h line 666
const char * const * xine_list_post_plugins(struct xine_s *);
// xine_list_spu_plugins
// file /usr/include/xine.h line 1167
const char * const * xine_list_spu_plugins(struct xine_s *);
// xine_list_video_decoder_plugins
// file /usr/include/xine.h line 1171
const char * const * xine_list_video_decoder_plugins(struct xine_s *);
// xine_list_video_output_plugins
// file /usr/include/xine.h line 1156
const char * const * xine_list_video_output_plugins(struct xine_s *);
// xine_monotonic_clock
// file /usr/include/xine/xineutils.h line 528
signed int xine_monotonic_clock(struct timeval *, struct timezone *);
// xine_new
// file /usr/include/xine.h line 118
struct xine_s * xine_new(void);
// xine_new_grab_video_frame
// file /usr/include/xine.h line 544
struct xine_grab_video_frame_s * xine_new_grab_video_frame(struct xine_stream_s *);
// xine_open
// file /usr/include/xine.h line 231
signed int xine_open(struct xine_stream_s *, const char *);
// xine_open_audio_driver
// file /usr/include/xine.h line 146
struct xine_audio_port_s * xine_open_audio_driver(struct xine_s *, const char *, void *);
// xine_open_video_driver
// file /usr/include/xine.h line 148
struct xine_video_port_s_0 * xine_open_video_driver(struct xine_s *, const char *, signed int, void *);
// xine_osd_command
// file xine_frontend.c line 1340
static signed int xine_osd_command(struct frontend_s *this_gen, struct osd_command_s *cmd);
// xine_play
// file /usr/include/xine.h line 243
signed int xine_play(struct xine_stream_s *, signed int, signed int);
// xine_port_send_gui_data
// file /usr/include/xine.h line 1182
signed int xine_port_send_gui_data(struct xine_video_port_s *, signed int, void *);
// xine_post_dispose
// file /usr/include/xine.h line 773
void xine_post_dispose(struct xine_s_0 *, struct xine_post_s_0 *);
// xine_post_init
// file /usr/include/xine.h line 660
struct xine_post_s_0 * xine_post_init(struct xine_s_0 *, const char *, signed int, struct xine_audio_port_s_0 **, struct xine_video_port_s **);
// xine_post_input
// file /usr/include/xine.h line 729
struct xine_post_in_s * xine_post_input(struct xine_post_s_0 *, const char *);
// xine_post_list_outputs
// file /usr/include/xine.h line 726
const char * const * xine_post_list_outputs(struct xine_post_s_0 *);
// xine_post_output
// file /usr/include/xine.h line 732
struct xine_post_out_s * xine_post_output(struct xine_post_s_0 *, const char *);
// xine_post_wire
// file /usr/include/xine.h line 738
signed int xine_post_wire(struct xine_post_out_s *, struct xine_post_in_s *);
// xine_post_wire_audio_port
// file /usr/include/xine.h line 760
signed int xine_post_wire_audio_port(struct xine_post_out_s *, struct xine_audio_port_s *);
// xine_post_wire_video_port
// file /usr/include/xine.h line 749
signed int xine_post_wire_video_port(struct xine_post_out_s *, struct xine_video_port_s_0 *);
// xine_queue_pes_packet
// file xine_frontend.c line 1349
static signed int xine_queue_pes_packet(struct frontend_s *this_gen, signed int stream, unsigned long int pos, const char *data, signed int len);
// xine_set_param
// file /usr/include/xine.h line 281
void xine_set_param(struct xine_stream_s *, signed int, signed int);
// xine_stop
// file /usr/include/xine.h line 249
void xine_stop(struct xine_stream_s *);
// xine_stream_new
// file /usr/include/xine.h line 191
struct xine_stream_s * xine_stream_new(struct xine_s *, struct xine_audio_port_s *, struct xine_video_port_s_0 *);
// xrender_surf_adopt
// file xine_sxfe_frontend.c line 744
static struct _xrender_surf * xrender_surf_adopt(struct _XDisplay *dpy, unsigned long int draw, struct anonymous_16 *vis, signed int w, signed int h);
// xrender_surf_blend
// file xine_sxfe_frontend.c line 715
static void xrender_surf_blend(struct _XDisplay *dpy, struct _xrender_surf *src, struct _xrender_surf *dst, signed int x, signed int y, signed int w, signed int h, double scale_x, double scale_y, signed int smooth, signed int *new_x, signed int *new_y, signed int *new_w, signed int *new_h);
// xrender_surf_free
// file xine_sxfe_frontend.c line 766
static void xrender_surf_free(struct _XDisplay *dpy, struct _xrender_surf *rs);
// xrender_surf_new
// file xine_sxfe_frontend.c line 692
static struct _xrender_surf * xrender_surf_new(struct _XDisplay *dpy, unsigned long int draw, struct anonymous_16 *vis, signed int w, signed int h, signed int alpha);

struct anonymous_69
{
  // set_parameters
  signed int (*set_parameters)(struct xine_post_s_0 *, void *);
  // get_parameters
  signed int (*get_parameters)(struct xine_post_s_0 *, void *);
  // get_param_descr
  struct anonymous_70 * (*get_param_descr)(void);
  // get_help
  char * (*get_help)(void);
};

struct anonymous_22
{
  // filename
  char *filename;
  // filesize
  signed long int filesize;
  // filemtime
  signed long int filemtime;
  // lib_handle
  void *lib_handle;
  // ref
  signed int ref;
  // no_unload
  signed int no_unload;
};

struct anonymous_28
{
  // origin
  char *origin;
  // mrl
  char *mrl;
  // link
  char *link;
  // size
  signed long int size;
  // type
  unsigned int type;
};

struct anonymous_9
{
  // res_name
  char *res_name;
  // res_class
  char *res_class;
};

struct anonymous_75
{
  // file
  struct anonymous_22 *file;
  // info
  struct anonymous_74 *info;
  // plugin_class
  void *plugin_class;
  // config_entry_list
  struct xine_list_s *config_entry_list;
  // ref
  signed int ref;
  // priority
  signed int priority;
};

struct anonymous_24
{
  // file
  struct anonymous_22 *file;
  // info
  struct anonymous_23 *info;
  // plugin_class
  void *plugin_class;
  // config_entry_list
  struct xine_list_s *config_entry_list;
  // ref
  signed int ref;
  // priority
  signed int priority;
};

struct anonymous_17
{
  // visual
  struct anonymous_16 *visual;
  // visualid
  unsigned long int visualid;
  // screen
  signed int screen;
  // depth
  signed int depth;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
};

struct anonymous_33
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous_78 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous_16 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous_34
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous_32 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous_33 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous_32
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_16
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous_73
{
  // post
  struct xine_post_s_0 *post;
  // name
  char *name;
  // args
  char *args;
  // enable
  signed int enable;
};

struct anonymous_26
{
  // post
  struct xine_post_s *post;
  // name
  char *name;
  // args
  char *args;
  // enable
  signed int enable;
};

struct anonymous_72
{
  // post
  struct xine_post_s_0 *post;
  // api
  struct anonymous_69 *api;
  // descr
  struct anonymous_70 *descr;
  // param
  struct anonymous_71 *param;
  // param_data
  char *param_data;
  // x
  signed int x;
  // y
  signed int y;
  // readonly
  signed int readonly;
  // properties_names
  char **properties_names;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct anonymous_88
{
  // stream
  struct xine_stream_s_0 *stream;
  // data
  void *data;
  // data_length
  signed int data_length;
  // type
  signed int type;
  // tv
  struct timeval tv;
};

struct anonymous_15
{
  // stream
  struct xine_stream_s *stream;
  // data
  void *data;
  // data_length
  signed int data_length;
  // type
  signed int type;
  // tv
  struct timeval tv;
};

struct anonymous_94
{
  // ovl_rgba
  unsigned char *ovl_rgba;
  // ovl_w
  signed int ovl_w;
  // ovl_h
  signed int ovl_h;
  // ovl_x
  signed int ovl_x;
  // ovl_y
  signed int ovl_y;
};

struct anonymous_91
{
  // frame_output_cb
  void (*frame_output_cb)(void *, signed int, signed int, double, signed int *, signed int *, signed int *, signed int *, double *, signed int *, signed int *);
  // user_data
  void *user_data;
};

struct anonymous_92
{
  // display
  void *display;
  // screen
  signed int screen;
  // d
  unsigned long int d;
  // user_data
  void *user_data;
  // dest_size_cb
  void (*dest_size_cb)(void *, signed int, signed int, double, signed int *, signed int *, double *);
  // frame_output_cb
  void (*frame_output_cb)(void *, signed int, signed int, double, signed int *, signed int *, signed int *, signed int *, double *, signed int *, signed int *);
  // lock_display
  void (*lock_display)(void *);
  // unlock_display
  void (*unlock_display)(void *);
};

struct anonymous_25
{
  // reserved
  void *reserved;
};

struct anonymous_93
{
  // user_data
  void *user_data;
  // supported_formats
  signed int supported_formats;
  // raw_output_cb
  void (*raw_output_cb)(void *, signed int, signed int, signed int, double, void *, void *, void *);
  // raw_overlay_cb
  void (*raw_overlay_cb)(void *, signed int, struct anonymous_94 *);
};

struct anonymous_98
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_3
{
  // bits
  unsigned char bits[17l];
  // huffval
  unsigned char huffval[256l];
  // sent_table
  signed int sent_table;
};

struct anonymous_101
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous_102
{
  // __cancel_jmp_buf
  struct anonymous_101 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous_1
{
  // quantval
  unsigned short int quantval[64l];
  // sent_table
  signed int sent_table;
};

struct anonymous_89
{
  // red
  signed short int red;
  // redMask
  signed short int redMask;
  // green
  signed short int green;
  // greenMask
  signed short int greenMask;
  // blue
  signed short int blue;
  // blueMask
  signed short int blueMask;
  // alpha
  signed short int alpha;
  // alphaMask
  signed short int alphaMask;
};

struct anonymous_20
{
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
};

struct anonymous_76
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_2
{
  // component_id
  signed int component_id;
  // component_index
  signed int component_index;
  // h_samp_factor
  signed int h_samp_factor;
  // v_samp_factor
  signed int v_samp_factor;
  // quant_tbl_no
  signed int quant_tbl_no;
  // dc_tbl_no
  signed int dc_tbl_no;
  // ac_tbl_no
  signed int ac_tbl_no;
  // width_in_blocks
  unsigned int width_in_blocks;
  // height_in_blocks
  unsigned int height_in_blocks;
  // DCT_scaled_size
  signed int DCT_scaled_size;
  // downsampled_width
  unsigned int downsampled_width;
  // downsampled_height
  unsigned int downsampled_height;
  // component_needed
  signed int component_needed;
  // MCU_width
  signed int MCU_width;
  // MCU_height
  signed int MCU_height;
  // MCU_blocks
  signed int MCU_blocks;
  // MCU_sample_width
  signed int MCU_sample_width;
  // last_col_width
  signed int last_col_width;
  // last_row_height
  signed int last_row_height;
  // quant_table
  struct anonymous_1 *quant_table;
  // dct_table
  void *dct_table;
};

struct anonymous_4
{
  // comps_in_scan
  signed int comps_in_scan;
  // component_index
  signed int component_index[4l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
};

struct anonymous_11
{
  // count
  signed int count;
  // holder
  unsigned long int holder;
};

struct anonymous_78
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous_16 *visuals;
};

struct anonymous_77
{
  // function
  signed int function;
  // plane_mask
  unsigned long int plane_mask;
  // foreground
  unsigned long int foreground;
  // background
  unsigned long int background;
  // line_width
  signed int line_width;
  // line_style
  signed int line_style;
  // cap_style
  signed int cap_style;
  // join_style
  signed int join_style;
  // fill_style
  signed int fill_style;
  // fill_rule
  signed int fill_rule;
  // arc_mode
  signed int arc_mode;
  // tile
  unsigned long int tile;
  // stipple
  unsigned long int stipple;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // font
  unsigned long int font;
  // subwindow_mode
  signed int subwindow_mode;
  // graphics_exposures
  signed int graphics_exposures;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // dash_offset
  signed int dash_offset;
  // dashes
  char dashes;
};

struct anonymous_90
{
  // screen_number
  signed int screen_number;
  // x_org
  signed short int x_org;
  // y_org
  signed short int y_org;
  // width
  signed short int width;
  // height
  signed short int height;
};

struct anonymous_70
{
  // struct_size
  signed int struct_size;
  // parameter
  struct anonymous_71 *parameter;
};

struct anonymous_64
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous_71
{
  // type
  signed int type;
  // name
  const char *name;
  // size
  signed int size;
  // offset
  signed int offset;
  // enum_values
  char **enum_values;
  // range_min
  double range_min;
  // range_max
  double range_max;
  // readonly
  signed int readonly;
  // description
  const char *description;
};

struct anonymous_66
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous_67
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous_43
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_42
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_46
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous_47
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous_48
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_55
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_52
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous_51
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_50
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_59
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_49
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous_56
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_45
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_54
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous_60
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_35
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous_65
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous_40
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous_63
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous_44
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous_53
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous_41
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous_57
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous_61
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous_68
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous_62
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous_68 data;
};

struct anonymous_39
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous_38
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous_37
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous_36
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous_58
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous_14
{
  // width
  signed int width;
  // height
  signed int height;
  // aspect
  signed int aspect;
  // pan_scan
  signed int pan_scan;
};

struct anonymous_30
{
  // width
  signed int width;
  // height
  signed int height;
  // crop_left
  signed int crop_left;
  // crop_right
  signed int crop_right;
  // crop_top
  signed int crop_top;
  // crop_bottom
  signed int crop_bottom;
  // ratio_code
  signed int ratio_code;
  // interlaced
  signed int interlaced;
  // format
  signed int format;
  // img_size
  signed int img_size;
  // img
  unsigned char *img;
};

struct anonymous_86
{
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous_87
{
  // flags
  signed long int flags;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // min_width
  signed int min_width;
  // min_height
  signed int min_height;
  // max_width
  signed int max_width;
  // max_height
  signed int max_height;
  // width_inc
  signed int width_inc;
  // height_inc
  signed int height_inc;
  // min_aspect
  struct anonymous_86 min_aspect;
  // max_aspect
  struct anonymous_86 max_aspect;
  // base_width
  signed int base_width;
  // base_height
  signed int base_height;
  // win_gravity
  signed int win_gravity;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_7
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_29
{
  // lock
  union anonymous_7 lock;
  // object
  void *object;
  // destructor
  void (*destructor)(void *);
  // count
  signed int count;
};

struct vo_driver_s
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct vo_driver_s *);
  // alloc_frame
  struct vo_frame_s * (*alloc_frame)(struct vo_driver_s *);
  // update_frame_format
  void (*update_frame_format)(struct vo_driver_s *, struct vo_frame_s *, unsigned int, unsigned int, double, signed int, signed int);
  // display_frame
  void (*display_frame)(struct vo_driver_s *, struct vo_frame_s *);
  // overlay_begin
  void (*overlay_begin)(struct vo_driver_s *, struct vo_frame_s *, signed int);
  // overlay_blend
  void (*overlay_blend)(struct vo_driver_s *, struct vo_frame_s *, struct vo_overlay_s *);
  // overlay_end
  void (*overlay_end)(struct vo_driver_s *, struct vo_frame_s *);
  // get_property
  signed int (*get_property)(struct vo_driver_s *, signed int);
  // set_property
  signed int (*set_property)(struct vo_driver_s *, signed int, signed int);
  // get_property_min_max
  void (*get_property_min_max)(struct vo_driver_s *, signed int, signed int *, signed int *);
  // gui_data_exchange
  signed int (*gui_data_exchange)(struct vo_driver_s *, signed int, void *);
  // redraw_needed
  signed int (*redraw_needed)(struct vo_driver_s *);
  // new_grab_video_frame
  struct xine_grab_video_frame_s * (*new_grab_video_frame)(struct vo_driver_s *);
  // dispose
  void (*dispose)(struct vo_driver_s *);
  // node
  void *node;
};

struct driver_hook_s
{
  // vo
  struct vo_driver_s vo;
  // orig_driver
  struct vo_driver_s *orig_driver;
};

struct anonymous_83
{
  // h
  struct driver_hook_s h;
  // prev_stream
  struct xine_stream_s_0 *prev_stream;
  // xvdr_stream
  struct xine_stream_s_0 *xvdr_stream;
  // xvdr_metronom
  struct metronom_s *xvdr_metronom;
};

struct anonymous_84
{
  // h
  struct driver_hook_s h;
  // handle
  void *handle;
  // cb
  void (*cb)(void *, struct vo_frame_s *);
};

struct vo_overlay_s
{
  // rle
  struct rle_elem_s *rle;
  // data_size
  signed int data_size;
  // num_rle
  signed int num_rle;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // video_window_x
  signed int video_window_x;
  // video_window_y
  signed int video_window_y;
  // video_window_width
  signed int video_window_width;
  // video_window_height
  signed int video_window_height;
  // extent_width
  signed int extent_width;
  // extent_height
  signed int extent_height;
  // color
  unsigned int color[256l];
  // trans
  unsigned char trans[256l];
  // rgb_clut
  signed int rgb_clut;
  // hili_top
  signed int hili_top;
  // hili_bottom
  signed int hili_bottom;
  // hili_left
  signed int hili_left;
  // hili_right
  signed int hili_right;
  // hili_color
  unsigned int hili_color[256l];
  // hili_trans
  unsigned char hili_trans[256l];
  // hili_rgb_clut
  signed int hili_rgb_clut;
  // unscaled
  signed int unscaled;
  // argb_layer
  struct argb_layer_s *argb_layer;
};

struct anonymous_82
{
  // h
  struct driver_hook_s h;
  // overlay
  struct vo_overlay_s *overlay[50l];
};

struct anonymous_80
{
  // h
  struct driver_hook_s h;
  // enable
  unsigned char enable;
  // unscaled_supported
  unsigned char unscaled_supported;
  // custom_extent_supported
  unsigned char custom_extent_supported;
  // argb_supported
  unsigned char argb_supported;
  // video_window_supported
  unsigned char video_window_supported;
  // output_width
  unsigned short int output_width;
  // output_height
  unsigned short int output_height;
  // factor_x
  unsigned int factor_x;
  // factor_y
  unsigned int factor_y;
  // x_move
  unsigned short int x_move;
  // y_move
  unsigned short int y_move;
  // active_osds
  struct osd_data_s *active_osds;
};

struct xine_video_port_s
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct xine_video_port_s *);
  // open
  void (*open)(struct xine_video_port_s *, struct xine_stream_s_0 *);
  // get_frame
  struct vo_frame_s * (*get_frame)(struct xine_video_port_s *, unsigned int, unsigned int, double, signed int, signed int);
  // new_grab_video_frame
  struct xine_grab_video_frame_s * (*new_grab_video_frame)(struct xine_video_port_s *);
  // get_last_frame
  struct vo_frame_s * (*get_last_frame)(struct xine_video_port_s *);
  // enable_ovl
  void (*enable_ovl)(struct xine_video_port_s *, signed int);
  // get_overlay_manager
  struct video_overlay_manager_s * (*get_overlay_manager)(struct xine_video_port_s *);
  // flush
  void (*flush)(struct xine_video_port_s *);
  // trigger_drawing
  void (*trigger_drawing)(struct xine_video_port_s *);
  // get_property
  signed int (*get_property)(struct xine_video_port_s *, signed int);
  // set_property
  signed int (*set_property)(struct xine_video_port_s *, signed int, signed int);
  // status
  signed int (*status)(struct xine_video_port_s *, struct xine_stream_s_0 *, signed int *, signed int *, signed long int *);
  // close
  void (*close)(struct xine_video_port_s *, struct xine_stream_s_0 *);
  // exit
  void (*exit)(struct xine_video_port_s *);
  // driver
  struct vo_driver_s *driver;
};

struct anonymous_79
{
  // vo
  struct xine_video_port_s vo;
  // driver
  struct vo_driver_s *driver;
};

struct anonymous_81
{
  // extent_width
  unsigned short int extent_width;
  // extent_height
  unsigned short int extent_height;
  // layer
  unsigned int layer;
  // scaling
  unsigned char scaling;
};

struct anonymous_8
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

struct anonymous_21
{
  // id
  unsigned long int id;
  // type
  signed int type;
  // depth
  signed int depth;
  // direct
  struct anonymous_89 direct;
  // colormap
  unsigned long int colormap;
};

struct anonymous_18
{
  // pixel
  unsigned long int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // flags
  char flags;
  // pad
  char pad;
};

struct anonymous_31
{
  // shmseg
  unsigned long int shmseg;
  // shmid
  signed int shmid;
  // shmaddr
  char *shmaddr;
  // readOnly
  signed int readOnly;
};

struct anonymous_74
{
  // type
  unsigned char type;
  // API
  unsigned char API;
  // id
  const char *id;
  // version
  unsigned int version;
  // special_info
  const void *special_info;
  // init
  void * (*init)(struct xine_s_0 *, void *);
};

struct anonymous_23
{
  // type
  unsigned char type;
  // API
  unsigned char API;
  // id
  const char *id;
  // version
  unsigned int version;
  // special_info
  const void *special_info;
  // init
  void * (*init)(struct xine_s *, void *);
};

union anonymous_103
{
  // palette
  struct osd_clut_s *palette;
  // dummy02
  unsigned long int dummy02;
};

union anonymous_13
{
  // data
  struct osd_rle_elem_s *data;
  // raw_data
  unsigned char *raw_data;
  // dummy01
  unsigned long int dummy01;
};

union anonymous_27
{
  // vis
  void *vis;
  // vis_fb
  struct anonymous_91 vis_fb;
  // vis_x11
  struct anonymous_92 vis_x11;
  // vis_raw
  struct anonymous_93 vis_raw;
};

union anonymous_99
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_12
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous
{
  // i
  signed int i[8l];
  // s
  char s[80l];
};

union anonymous_19
{
  // __data
  struct anonymous_76 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct frontend_s
{
  // fe_display_open
  signed int (*fe_display_open)(struct frontend_s *, signed int, signed int, signed int, signed int, signed int, signed int, signed int, signed int, const char *, signed int, signed int, signed int, signed int, const char *, signed int, const char *, signed int);
  // fe_display_config
  signed int (*fe_display_config)(struct frontend_s *, signed int, signed int, signed int, signed int, signed int, signed int, const char *, signed int, signed int);
  // fe_display_edid
  unsigned char * (*fe_display_edid)(struct frontend_s *, signed int *);
  // fe_display_close
  void (*fe_display_close)(struct frontend_s *);
  // xine_init
  signed int (*xine_init)(struct frontend_s *, const char *, const char *, const char *, signed int, const char *, const char *);
  // xine_open
  signed int (*xine_open)(struct frontend_s *, const char *);
  // xine_play
  signed int (*xine_play)(struct frontend_s *);
  // xine_stop
  signed int (*xine_stop)(struct frontend_s *);
  // xine_close
  void (*xine_close)(struct frontend_s *);
  // xine_exit
  void (*xine_exit)(struct frontend_s *);
  // shutdown_init
  void (*shutdown_init)(struct frontend_s *, const char *, signed int);
  // fe_run
  signed int (*fe_run)(struct frontend_s *);
  // fe_interrupt
  void (*fe_interrupt)(struct frontend_s *);
  // fe_free
  void (*fe_free)(struct frontend_s *);
  // xine_is_finished
  signed int (*xine_is_finished)(struct frontend_s *, signed int);
  // xine_osd_command
  signed int (*xine_osd_command)(struct frontend_s *, struct osd_command_s *);
  // xine_control
  signed int (*xine_control)(struct frontend_s *, const char *);
  // xine_queue_pes_packet
  signed int (*xine_queue_pes_packet)(struct frontend_s *, signed int, unsigned long int, const char *, signed int);
  // grab
  char * (*grab)(struct frontend_s *, signed int *, signed int, signed int, signed int, signed int);
  // send_event
  signed int (*send_event)(struct frontend_s *, const char *);
  // send_input_event
  signed int (*send_input_event)(struct frontend_s *, const char *, const char *, signed int, signed int);
  // fe_message_h
  void *fe_message_h;
  // fe_message_cb
  void (*fe_message_cb)(void *, const char *, const char *);
};

struct fe_s_0
{
  // fe
  struct frontend_s fe;
  // dest_pixel_aspect
  double (*dest_pixel_aspect)(struct fe_s_0 *, double, signed int, signed int);
  // frame_output_handler
  void (*frame_output_handler)(void *, signed int, signed int, double, signed int *, signed int *, signed int *, signed int *, double *, signed int *, signed int *);
  // update_display_size_cb
  void (*update_display_size_cb)(struct fe_s_0 *);
  // toggle_fullscreen_cb
  void (*toggle_fullscreen_cb)(struct fe_s_0 *, signed int);
  // frame_draw_cb
  void (*frame_draw_cb)(void *, struct vo_frame_s *);
  // xine
  struct xine_s_0 *xine;
  // stream
  struct xine_stream_s_0 *stream;
  // slave_stream
  struct xine_stream_s_0 *slave_stream;
  // input_plugin
  struct vdr_input_plugin_if_s_0 *input_plugin;
  // video_port
  struct xine_video_port_s *video_port;
  // video_port_none
  struct xine_video_port_s *video_port_none;
  // audio_port
  struct xine_audio_port_s_0 *audio_port;
  // audio_port_none
  struct xine_audio_port_s_0 *audio_port_none;
  // event_queue
  struct xine_event_queue_s_0 *event_queue;
  // postplugins
  struct post_plugins_s_0 *postplugins;
  // video_port_name
  char *video_port_name;
  // aspect_controller
  char *aspect_controller;
  // configfile
  char *configfile;
  // xine_visual_type
  signed int xine_visual_type;
  // _anon0
  union anonymous_27 _anon0;
  // video_aspect
  double video_aspect;
  // display_ratio
  double display_ratio;
  // terminate_key_pressed
  unsigned int terminate_key_pressed;
  // xpos
  unsigned short int xpos;
  // ypos
  unsigned short int ypos;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // video_width
  unsigned short int video_width;
  // video_height
  unsigned short int video_height;
  // pes_buffers
  unsigned short int pes_buffers;
  // aspect
  unsigned char aspect;
  // overscan
  unsigned char overscan;
  // scale_video
  unsigned char scale_video : 1;
  // playback_finished
  unsigned char playback_finished : 1;
  // slave_playback_finished
  unsigned char slave_playback_finished : 1;
  // shutdown_cmd
  char *shutdown_cmd;
  // shutdown_timeout
  signed int shutdown_timeout;
  // shutdown_time
  signed long int shutdown_time;
};

union anonymous_10
{
  // fe
  struct frontend_s fe;
  // x
  struct fe_s_0 x;
};

union anonymous_95
{
  // cb
  unsigned char cb;
  // g
  unsigned char g;
};

union anonymous_96
{
  // cr
  unsigned char cr;
  // b
  unsigned char b;
};

union anonymous_97
{
  // y
  unsigned char y;
  // r
  unsigned char r;
};

union anonymous_100
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_85
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _DBusGProxy
{
  // parent
  struct _GObject parent;
};

struct _GError
{
  // domain
  unsigned int domain;
  // code
  signed int code;
  // message
  char *message;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _XComposeStatus
{
  // compose_ptr
  char *compose_ptr;
  // chars_matched
  signed int chars_matched;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous_35 xany;
  // xkey
  struct anonymous_36 xkey;
  // xbutton
  struct anonymous_37 xbutton;
  // xmotion
  struct anonymous_38 xmotion;
  // xcrossing
  struct anonymous_39 xcrossing;
  // xfocus
  struct anonymous_40 xfocus;
  // xexpose
  struct anonymous_41 xexpose;
  // xgraphicsexpose
  struct anonymous_42 xgraphicsexpose;
  // xnoexpose
  struct anonymous_43 xnoexpose;
  // xvisibility
  struct anonymous_44 xvisibility;
  // xcreatewindow
  struct anonymous_45 xcreatewindow;
  // xdestroywindow
  struct anonymous_46 xdestroywindow;
  // xunmap
  struct anonymous_47 xunmap;
  // xmap
  struct anonymous_48 xmap;
  // xmaprequest
  struct anonymous_49 xmaprequest;
  // xreparent
  struct anonymous_50 xreparent;
  // xconfigure
  struct anonymous_51 xconfigure;
  // xgravity
  struct anonymous_52 xgravity;
  // xresizerequest
  struct anonymous_53 xresizerequest;
  // xconfigurerequest
  struct anonymous_54 xconfigurerequest;
  // xcirculate
  struct anonymous_55 xcirculate;
  // xcirculaterequest
  struct anonymous_56 xcirculaterequest;
  // xproperty
  struct anonymous_57 xproperty;
  // xselectionclear
  struct anonymous_58 xselectionclear;
  // xselectionrequest
  struct anonymous_59 xselectionrequest;
  // xselection
  struct anonymous_60 xselection;
  // xcolormap
  struct anonymous_61 xcolormap;
  // xclient
  struct anonymous_62 xclient;
  // xmapping
  struct anonymous_63 xmapping;
  // xerror
  struct anonymous_64 xerror;
  // xkeymap
  struct anonymous_65 xkeymap;
  // xgeneric
  struct anonymous_66 xgeneric;
  // xcookie
  struct anonymous_67 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct funcs
{
  // create_image
  struct _XImage * (*create_image)(struct _XDisplay *, struct anonymous_16 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
  // destroy_image
  signed int (*destroy_image)(struct _XImage *);
  // get_pixel
  unsigned long int (*get_pixel)(struct _XImage *, signed int, signed int);
  // put_pixel
  signed int (*put_pixel)(struct _XImage *, signed int, signed int, unsigned long int);
  // sub_image
  struct _XImage * (*sub_image)(struct _XImage *, signed int, signed int, unsigned int, unsigned int);
  // add_pixel
  signed int (*add_pixel)(struct _XImage *, signed long int);
};

struct _XImage
{
  // width
  signed int width;
  // height
  signed int height;
  // xoffset
  signed int xoffset;
  // format
  signed int format;
  // data
  char *data;
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // bitmap_pad
  signed int bitmap_pad;
  // depth
  signed int depth;
  // bytes_per_line
  signed int bytes_per_line;
  // bits_per_pixel
  signed int bits_per_pixel;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // obdata
  char *obdata;
  // f
  struct funcs f;
};

struct _XRenderPictureAttributes
{
  // repeat
  signed int repeat;
  // alpha_map
  unsigned long int alpha_map;
  // alpha_x_origin
  signed int alpha_x_origin;
  // alpha_y_origin
  signed int alpha_y_origin;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // graphics_exposures
  signed int graphics_exposures;
  // subwindow_mode
  signed int subwindow_mode;
  // poly_edge
  signed int poly_edge;
  // poly_mode
  signed int poly_mode;
  // dither
  unsigned long int dither;
  // component_alpha
  signed int component_alpha;
};

struct _XTransform
{
  // matrix
  signed int matrix[3l][3l];
};

struct _mwmhints
{
  // flags
  unsigned long int flags;
  // functions
  unsigned long int functions;
  // decorations
  unsigned long int decorations;
  // input_mode
  signed long int input_mode;
  // status
  unsigned long int status;
};

struct _xrender_surf
{
  // vis
  struct anonymous_16 *vis;
  // draw
  unsigned long int draw;
  // pic
  unsigned long int pic;
  // w
  unsigned short int w;
  // h
  unsigned short int h;
  // depth
  unsigned char depth;
  // allocated
  unsigned char allocated : 1;
};

struct ao_format_s
{
  // bits
  unsigned int bits;
  // rate
  unsigned int rate;
  // mode
  signed int mode;
};

struct argb_layer_s
{
  // mutex
  union anonymous_7 mutex;
  // buffer
  unsigned int *buffer;
  // x1
  signed int x1;
  // y1
  signed int y1;
  // x2
  signed int x2;
  // y2
  signed int y2;
  // ref_count
  signed int ref_count;
};

struct audio_buffer_s_0
{
  // next
  struct audio_buffer_s_0 *next;
  // mem
  signed short int *mem;
  // mem_size
  signed int mem_size;
  // num_frames
  signed int num_frames;
  // vpts
  signed long int vpts;
  // frame_header_count
  unsigned int frame_header_count;
  // first_access_unit
  unsigned int first_access_unit;
  // extra_info
  struct extra_info_s *extra_info;
  // stream
  struct xine_stream_s_0 *stream;
  // format
  struct ao_format_s format;
};

struct audio_buffer_s
{
  // next
  struct audio_buffer_s *next;
  // mem
  signed short int *mem;
  // mem_size
  signed int mem_size;
  // num_frames
  signed int num_frames;
  // vpts
  signed long int vpts;
  // frame_header_count
  unsigned int frame_header_count;
  // first_access_unit
  unsigned int first_access_unit;
  // extra_info
  struct extra_info_s *extra_info;
  // stream
  struct xine_stream_s *stream;
  // format
  struct ao_format_s format;
};

struct audio_decoder_s
{
  // decode_data
  void (*decode_data)(struct audio_decoder_s *, struct buf_element_s *);
  // reset
  void (*reset)(struct audio_decoder_s *);
  // discontinuity
  void (*discontinuity)(struct audio_decoder_s *);
  // dispose
  void (*dispose)(struct audio_decoder_s *);
  // node
  void *node;
};

struct buf_element_s
{
  // next
  struct buf_element_s *next;
  // mem
  unsigned char *mem;
  // content
  unsigned char *content;
  // size
  signed int size;
  // max_size
  signed int max_size;
  // pts
  signed long int pts;
  // disc_off
  signed long int disc_off;
  // extra_info
  struct extra_info_s *extra_info;
  // decoder_flags
  unsigned int decoder_flags;
  // decoder_info
  unsigned int decoder_info[5l];
  // decoder_info_ptr
  void *decoder_info_ptr[5l];
  // free_buffer
  void (*free_buffer)(struct buf_element_s *);
  // source
  void *source;
  // type
  unsigned int type;
};

struct cfg_entry_s
{
  // next
  struct cfg_entry_s *next;
  // config
  struct config_values_s *config;
  // key
  char *key;
  // type
  signed int type;
  // exp_level
  signed int exp_level;
  // unknown_value
  char *unknown_value;
  // str_value
  char *str_value;
  // str_default
  char *str_default;
  // num_value
  signed int num_value;
  // num_default
  signed int num_default;
  // range_min
  signed int range_min;
  // range_max
  signed int range_max;
  // enum_values
  char **enum_values;
  // description
  char *description;
  // help
  char *help;
  // callback
  void (*callback)(void *, struct xine_cfg_entry_s *);
  // callback_data
  void *callback_data;
};

struct config_values_s
{
  // register_string
  char * (*register_string)(struct config_values_s *, const char *, const char *, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // register_filename
  char * (*register_filename)(struct config_values_s *, const char *, const char *, signed int, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // register_range
  signed int (*register_range)(struct config_values_s *, const char *, signed int, signed int, signed int, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // register_enum
  signed int (*register_enum)(struct config_values_s *, const char *, signed int, char **, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // register_num
  signed int (*register_num)(struct config_values_s *, const char *, signed int, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // register_bool
  signed int (*register_bool)(struct config_values_s *, const char *, signed int, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // register_entry
  void (*register_entry)(struct config_values_s *, struct cfg_entry_s *);
  // update_num
  void (*update_num)(struct config_values_s *, const char *, signed int);
  // update_string
  void (*update_string)(struct config_values_s *, const char *, const char *);
  // parse_enum
  signed int (*parse_enum)(const char *, const char **);
  // lookup_entry
  struct cfg_entry_s * (*lookup_entry)(struct config_values_s *, const char *);
  // unregister_callback
  void (*unregister_callback)(struct config_values_s *, const char *);
  // dispose
  void (*dispose)(struct config_values_s *);
  // set_new_entry_callback
  void (*set_new_entry_callback)(struct config_values_s *, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // unset_new_entry_callback
  void (*unset_new_entry_callback)(struct config_values_s *);
  // get_serialized_entry
  char * (*get_serialized_entry)(struct config_values_s *, const char *);
  // register_serialized_entry
  char * (*register_serialized_entry)(struct config_values_s *, const char *);
  // first
  struct cfg_entry_s *first;
  // last
  struct cfg_entry_s *last;
  // cur
  struct cfg_entry_s *cur;
  // new_entry_cb
  void (*new_entry_cb)(void *, struct xine_cfg_entry_s *);
  // new_entry_cbdata
  void *new_entry_cbdata;
  // config_lock
  union anonymous_7 config_lock;
  // current_version
  signed int current_version;
};

struct demux_class_s
{
  // open_plugin
  struct demux_plugin_s * (*open_plugin)(struct demux_class_s *, struct xine_stream_s *, struct input_plugin_s *);
  // identifier
  const char *identifier;
  // description
  const char *description;
  // text_domain
  const char *text_domain;
  // mimetypes
  const char *mimetypes;
  // extensions
  const char *extensions;
  // dispose
  void (*dispose)(struct demux_class_s *);
};

struct demux_plugin_s
{
  // send_headers
  void (*send_headers)(struct demux_plugin_s *);
  // seek
  signed int (*seek)(struct demux_plugin_s *, signed long int, signed int, signed int);
  // send_chunk
  signed int (*send_chunk)(struct demux_plugin_s *);
  // dispose
  void (*dispose)(struct demux_plugin_s *);
  // get_status
  signed int (*get_status)(struct demux_plugin_s *);
  // get_stream_length
  signed int (*get_stream_length)(struct demux_plugin_s *);
  // get_capabilities
  unsigned int (*get_capabilities)(struct demux_plugin_s *);
  // get_optional_data
  signed int (*get_optional_data)(struct demux_plugin_s *, void *, signed int);
  // demux_class
  struct demux_class_s *demux_class;
  // node
  void *node;
};

struct extra_info_s
{
  // input_normpos
  signed int input_normpos;
  // input_time
  signed int input_time;
  // frame_number
  unsigned int frame_number;
  // seek_count
  signed int seek_count;
  // vpts
  signed long int vpts;
  // invalid
  signed int invalid;
  // total_time
  signed int total_time;
};

struct fe_s
{
  // fe
  struct frontend_s fe;
  // dest_pixel_aspect
  double (*dest_pixel_aspect)(struct fe_s *, double, signed int, signed int);
  // frame_output_handler
  void (*frame_output_handler)(void *, signed int, signed int, double, signed int *, signed int *, signed int *, signed int *, double *, signed int *, signed int *);
  // update_display_size_cb
  void (*update_display_size_cb)(struct fe_s *);
  // toggle_fullscreen_cb
  void (*toggle_fullscreen_cb)(struct fe_s *, signed int);
  // frame_draw_cb
  void (*frame_draw_cb)(void *, struct vo_frame_s_0 *);
  // xine
  struct xine_s *xine;
  // stream
  struct xine_stream_s *stream;
  // slave_stream
  struct xine_stream_s *slave_stream;
  // input_plugin
  struct vdr_input_plugin_if_s *input_plugin;
  // video_port
  struct xine_video_port_s_0 *video_port;
  // video_port_none
  struct xine_video_port_s_0 *video_port_none;
  // audio_port
  struct xine_audio_port_s *audio_port;
  // audio_port_none
  struct xine_audio_port_s *audio_port_none;
  // event_queue
  struct xine_event_queue_s *event_queue;
  // postplugins
  struct post_plugins_s *postplugins;
  // video_port_name
  char *video_port_name;
  // aspect_controller
  char *aspect_controller;
  // configfile
  char *configfile;
  // xine_visual_type
  signed int xine_visual_type;
  // _anon0
  union anonymous_27 _anon0;
  // video_aspect
  double video_aspect;
  // display_ratio
  double display_ratio;
  // terminate_key_pressed
  unsigned int terminate_key_pressed;
  // xpos
  unsigned short int xpos;
  // ypos
  unsigned short int ypos;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // video_width
  unsigned short int video_width;
  // video_height
  unsigned short int video_height;
  // pes_buffers
  unsigned short int pes_buffers;
  // aspect
  unsigned char aspect;
  // overscan
  unsigned char overscan;
  // scale_video
  unsigned char scale_video : 1;
  // playback_finished
  unsigned char playback_finished : 1;
  // slave_playback_finished
  unsigned char slave_playback_finished : 1;
  // shutdown_cmd
  char *shutdown_cmd;
  // shutdown_timeout
  signed int shutdown_timeout;
  // shutdown_time
  signed long int shutdown_time;
};

struct fifo_buffer_s
{
  // first
  struct buf_element_s *first;
  // last
  struct buf_element_s *last;
  // fifo_size
  signed int fifo_size;
  // fifo_data_size
  unsigned int fifo_data_size;
  // fifo_empty_cb_data
  void *fifo_empty_cb_data;
  // mutex
  union anonymous_7 mutex;
  // not_empty
  union anonymous_19 not_empty;
  // put
  void (*put)(struct fifo_buffer_s *, struct buf_element_s *);
  // get
  struct buf_element_s * (*get)(struct fifo_buffer_s *);
  // clear
  void (*clear)(struct fifo_buffer_s *);
  // size
  signed int (*size)(struct fifo_buffer_s *);
  // num_free
  signed int (*num_free)(struct fifo_buffer_s *);
  // data_size
  unsigned int (*data_size)(struct fifo_buffer_s *);
  // dispose
  void (*dispose)(struct fifo_buffer_s *);
  // buffer_pool_alloc
  struct buf_element_s * (*buffer_pool_alloc)(struct fifo_buffer_s *);
  // buffer_pool_try_alloc
  struct buf_element_s * (*buffer_pool_try_alloc)(struct fifo_buffer_s *);
  // insert
  void (*insert)(struct fifo_buffer_s *, struct buf_element_s *);
  // register_alloc_cb
  void (*register_alloc_cb)(struct fifo_buffer_s *, void (*)(struct fifo_buffer_s *, void *), void *);
  // register_put_cb
  void (*register_put_cb)(struct fifo_buffer_s *, void (*)(struct fifo_buffer_s *, struct buf_element_s *, void *), void *);
  // register_get_cb
  void (*register_get_cb)(struct fifo_buffer_s *, void (*)(struct fifo_buffer_s *, struct buf_element_s *, void *), void *);
  // unregister_alloc_cb
  void (*unregister_alloc_cb)(struct fifo_buffer_s *, void (*)(struct fifo_buffer_s *, void *));
  // unregister_put_cb
  void (*unregister_put_cb)(struct fifo_buffer_s *, void (*)(struct fifo_buffer_s *, struct buf_element_s *, void *));
  // unregister_get_cb
  void (*unregister_get_cb)(struct fifo_buffer_s *, void (*)(struct fifo_buffer_s *, struct buf_element_s *, void *));
  // buffer_pool_top
  struct buf_element_s *buffer_pool_top;
  // buffer_pool_mutex
  union anonymous_7 buffer_pool_mutex;
  // buffer_pool_cond_not_empty
  union anonymous_19 buffer_pool_cond_not_empty;
  // buffer_pool_num_free
  signed int buffer_pool_num_free;
  // buffer_pool_capacity
  signed int buffer_pool_capacity;
  // buffer_pool_buf_size
  signed int buffer_pool_buf_size;
  // buffer_pool_base
  void *buffer_pool_base;
  // alloc_cb
  void (*alloc_cb[5l])(struct fifo_buffer_s *, void *);
  // put_cb
  void (*put_cb[5l])(struct fifo_buffer_s *, struct buf_element_s *, void *);
  // get_cb
  void (*get_cb[5l])(struct fifo_buffer_s *, struct buf_element_s *, void *);
  // alloc_cb_data
  void *alloc_cb_data[5l];
  // put_cb_data
  void *put_cb_data[5l];
  // get_cb_data
  void *get_cb_data[5l];
};

struct grab_data_s
{
  // size
  unsigned long int size;
  // data
  char *data;
};

struct in6_addr
{
  // __in6_u
  union anonymous_99 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct input_class_s
{
  // get_instance
  struct input_plugin_s_0 * (*get_instance)(struct input_class_s *, struct xine_stream_s_0 *, const char *);
  // identifier
  const char *identifier;
  // description
  const char *description;
  // text_domain
  const char *text_domain;
  // get_dir
  struct anonymous_28 ** (*get_dir)(struct input_class_s *, const char *, signed int *);
  // get_autoplay_list
  const char * const * (*get_autoplay_list)(struct input_class_s *, signed int *);
  // dispose
  void (*dispose)(struct input_class_s *);
  // eject_media
  signed int (*eject_media)(struct input_class_s *);
};

struct input_class_s_0
{
  // get_instance
  struct input_plugin_s * (*get_instance)(struct input_class_s_0 *, struct xine_stream_s *, const char *);
  // identifier
  const char *identifier;
  // description
  const char *description;
  // text_domain
  const char *text_domain;
  // get_dir
  struct anonymous_28 ** (*get_dir)(struct input_class_s_0 *, const char *, signed int *);
  // get_autoplay_list
  const char * const * (*get_autoplay_list)(struct input_class_s_0 *, signed int *);
  // dispose
  void (*dispose)(struct input_class_s_0 *);
  // eject_media
  signed int (*eject_media)(struct input_class_s_0 *);
};

struct input_plugin_s_0
{
  // open
  signed int (*open)(struct input_plugin_s_0 *);
  // get_capabilities
  unsigned int (*get_capabilities)(struct input_plugin_s_0 *);
  // read
  signed long int (*read)(struct input_plugin_s_0 *, void *, signed long int);
  // read_block
  struct buf_element_s * (*read_block)(struct input_plugin_s_0 *, struct fifo_buffer_s *, signed long int);
  // seek
  signed long int (*seek)(struct input_plugin_s_0 *, signed long int, signed int);
  // seek_time
  signed long int (*seek_time)(struct input_plugin_s_0 *, signed int, signed int);
  // get_current_pos
  signed long int (*get_current_pos)(struct input_plugin_s_0 *);
  // get_current_time
  signed int (*get_current_time)(struct input_plugin_s_0 *);
  // get_length
  signed long int (*get_length)(struct input_plugin_s_0 *);
  // get_blocksize
  unsigned int (*get_blocksize)(struct input_plugin_s_0 *);
  // get_mrl
  const char * (*get_mrl)(struct input_plugin_s_0 *);
  // get_optional_data
  signed int (*get_optional_data)(struct input_plugin_s_0 *, void *, signed int);
  // dispose
  void (*dispose)(struct input_plugin_s_0 *);
  // input_class
  struct input_class_s *input_class;
  // node
  void *node;
};

struct input_plugin_s
{
  // open
  signed int (*open)(struct input_plugin_s *);
  // get_capabilities
  unsigned int (*get_capabilities)(struct input_plugin_s *);
  // read
  signed long int (*read)(struct input_plugin_s *, void *, signed long int);
  // read_block
  struct buf_element_s * (*read_block)(struct input_plugin_s *, struct fifo_buffer_s *, signed long int);
  // seek
  signed long int (*seek)(struct input_plugin_s *, signed long int, signed int);
  // seek_time
  signed long int (*seek_time)(struct input_plugin_s *, signed int, signed int);
  // get_current_pos
  signed long int (*get_current_pos)(struct input_plugin_s *);
  // get_current_time
  signed int (*get_current_time)(struct input_plugin_s *);
  // get_length
  signed long int (*get_length)(struct input_plugin_s *);
  // get_blocksize
  unsigned int (*get_blocksize)(struct input_plugin_s *);
  // get_mrl
  const char * (*get_mrl)(struct input_plugin_s *);
  // get_optional_data
  signed int (*get_optional_data)(struct input_plugin_s *, void *, signed int);
  // dispose
  void (*dispose)(struct input_plugin_s *);
  // input_class
  struct input_class_s_0 *input_class;
  // node
  void *node;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct jpeg_common_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
};

struct jpeg_compress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // dest
  struct jpeg_destination_mgr *dest;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // input_components
  signed int input_components;
  // in_color_space
  enum anonymous_0 in_color_space;
  // input_gamma
  double input_gamma;
  // data_precision
  signed int data_precision;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous_0 jpeg_color_space;
  // comp_info
  struct anonymous_2 *comp_info;
  // quant_tbl_ptrs
  struct anonymous_1 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous_3 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous_3 *ac_huff_tbl_ptrs[4l];
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // num_scans
  signed int num_scans;
  // scan_info
  const struct anonymous_4 *scan_info;
  // raw_data_in
  signed int raw_data_in;
  // arith_code
  signed int arith_code;
  // optimize_coding
  signed int optimize_coding;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // smoothing_factor
  signed int smoothing_factor;
  // dct_method
  enum anonymous_5 dct_method;
  // restart_interval
  unsigned int restart_interval;
  // restart_in_rows
  signed int restart_in_rows;
  // write_JFIF_header
  signed int write_JFIF_header;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // write_Adobe_marker
  signed int write_Adobe_marker;
  // next_scanline
  unsigned int next_scanline;
  // progressive_mode
  signed int progressive_mode;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous_2 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // master
  struct jpeg_comp_master *master;
  // main
  struct jpeg_c_main_controller *main;
  // prep
  struct jpeg_c_prep_controller *prep;
  // coef
  struct jpeg_c_coef_controller *coef;
  // marker
  struct jpeg_marker_writer *marker;
  // cconvert
  struct jpeg_color_converter *cconvert;
  // downsample
  struct jpeg_downsampler *downsample;
  // fdct
  struct jpeg_forward_dct *fdct;
  // entropy
  struct jpeg_entropy_encoder *entropy;
  // script_space
  struct anonymous_4 *script_space;
  // script_space_size
  signed int script_space_size;
};

struct jpeg_destination_mgr
{
  // next_output_byte
  unsigned char *next_output_byte;
  // free_in_buffer
  unsigned long int free_in_buffer;
  // init_destination
  void (*init_destination)(struct jpeg_compress_struct *);
  // empty_output_buffer
  signed int (*empty_output_buffer)(struct jpeg_compress_struct *);
  // term_destination
  void (*term_destination)(struct jpeg_compress_struct *);
};

struct jpeg_error_mgr
{
  // error_exit
  void (*error_exit)(struct jpeg_common_struct *);
  // emit_message
  void (*emit_message)(struct jpeg_common_struct *, signed int);
  // output_message
  void (*output_message)(struct jpeg_common_struct *);
  // format_message
  void (*format_message)(struct jpeg_common_struct *, char *);
  // reset_error_mgr
  void (*reset_error_mgr)(struct jpeg_common_struct *);
  // msg_code
  signed int msg_code;
  // msg_parm
  union anonymous msg_parm;
  // trace_level
  signed int trace_level;
  // num_warnings
  signed long int num_warnings;
  // jpeg_message_table
  const char * const *jpeg_message_table;
  // last_jpeg_message
  signed int last_jpeg_message;
  // addon_message_table
  const char * const *addon_message_table;
  // first_addon_message
  signed int first_addon_message;
  // last_addon_message
  signed int last_addon_message;
};

struct jpeg_memory_mgr
{
  // alloc_small
  void * (*alloc_small)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_large
  void * (*alloc_large)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_sarray
  unsigned char ** (*alloc_sarray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int);
  // alloc_barray
  signed short int (**(*alloc_barray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int))[64l];
  // request_virt_sarray
  struct jvirt_sarray_control * (*request_virt_sarray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // request_virt_barray
  struct jvirt_barray_control * (*request_virt_barray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // realize_virt_arrays
  void (*realize_virt_arrays)(struct jpeg_common_struct *);
  // access_virt_sarray
  unsigned char ** (*access_virt_sarray)(struct jpeg_common_struct *, struct jvirt_sarray_control *, unsigned int, unsigned int, signed int);
  // access_virt_barray
  signed short int (**(*access_virt_barray)(struct jpeg_common_struct *, struct jvirt_barray_control *, unsigned int, unsigned int, signed int))[64l];
  // free_pool
  void (*free_pool)(struct jpeg_common_struct *, signed int);
  // self_destruct
  void (*self_destruct)(struct jpeg_common_struct *);
  // max_memory_to_use
  signed long int max_memory_to_use;
  // max_alloc_chunk
  signed long int max_alloc_chunk;
};

struct jpeg_progress_mgr
{
  // progress_monitor
  void (*progress_monitor)(struct jpeg_common_struct *);
  // pass_counter
  signed long int pass_counter;
  // pass_limit
  signed long int pass_limit;
  // completed_passes
  signed int completed_passes;
  // total_passes
  signed int total_passes;
};

struct metronom_clock_s
{
  // set_option
  void (*set_option)(struct metronom_clock_s *, signed int, signed long int);
  // get_option
  signed long int (*get_option)(struct metronom_clock_s *, signed int);
  // dummy1
  void *dummy1;
  // dummy2
  void *dummy2;
  // dummy3
  void *dummy3;
  // get_current_time
  signed long int (*get_current_time)(struct metronom_clock_s *);
  // adjust_clock
  void (*adjust_clock)(struct metronom_clock_s *, signed long int);
  // dummy4
  void *dummy4;
  // register_scr
  signed int (*register_scr)(struct metronom_clock_s *, struct scr_plugin_s *);
  // unregister_scr
  void (*unregister_scr)(struct metronom_clock_s *, struct scr_plugin_s *);
  // dummy5
  void *dummy5;
  // dummy6
  void *dummy6;
  // dummy7
  void *dummy7;
  // dummy8
  void *dummy8;
  // dummy9
  unsigned long int dummy9;
  // dummy10
  signed int dummy10;
  // dummy11
  signed int dummy11;
  // speed
  signed int speed;
};

struct metronom_s
{
  // set_audio_rate
  void (*set_audio_rate)(struct metronom_s *, signed long int);
  // got_video_frame
  void (*got_video_frame)(struct metronom_s *, struct vo_frame_s *);
  // got_audio_samples
  signed long int (*got_audio_samples)(struct metronom_s *, signed long int, signed int);
  // got_spu_packet
  signed long int (*got_spu_packet)(struct metronom_s *, signed long int);
  // handle_audio_discontinuity
  void (*handle_audio_discontinuity)(struct metronom_s *, signed int, signed long int);
  // handle_video_discontinuity
  void (*handle_video_discontinuity)(struct metronom_s *, signed int, signed long int);
  // set_option
  void (*set_option)(struct metronom_s *, signed int, signed long int);
  // get_option
  signed long int (*get_option)(struct metronom_s *, signed int);
  // set_master
  void (*set_master)(struct metronom_s *, struct metronom_s *);
  // exit
  void (*exit)(struct metronom_s *);
};

struct metronom_s_0
{
  // set_audio_rate
  void (*set_audio_rate)(struct metronom_s_0 *, signed long int);
  // got_video_frame
  void (*got_video_frame)(struct metronom_s_0 *, struct vo_frame_s_0 *);
  // got_audio_samples
  signed long int (*got_audio_samples)(struct metronom_s_0 *, signed long int, signed int);
  // got_spu_packet
  signed long int (*got_spu_packet)(struct metronom_s_0 *, signed long int);
  // handle_audio_discontinuity
  void (*handle_audio_discontinuity)(struct metronom_s_0 *, signed int, signed long int);
  // handle_video_discontinuity
  void (*handle_video_discontinuity)(struct metronom_s_0 *, signed int, signed long int);
  // set_option
  void (*set_option)(struct metronom_s_0 *, signed int, signed long int);
  // get_option
  signed long int (*get_option)(struct metronom_s_0 *, signed int);
  // set_master
  void (*set_master)(struct metronom_s_0 *, struct metronom_s_0 *);
  // exit
  void (*exit)(struct metronom_s_0 *);
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct osd_clut_s
{
  // _anon0
  union anonymous_95 _anon0;
  // _anon1
  union anonymous_96 _anon1;
  // _anon2
  union anonymous_97 _anon2;
  // alpha
  unsigned char alpha;
} __attribute__ ((__packed__));

struct osd_rect_s
{
  // x1
  unsigned short int x1;
  // y1
  unsigned short int y1;
  // x2
  unsigned short int x2;
  // y2
  unsigned short int y2;
};

struct osd_command_s
{
  // size
  unsigned char size;
  // cmd
  unsigned char cmd;
  // wnd
  unsigned char wnd;
  // layer
  unsigned char layer;
  // pts
  signed long int pts;
  // delay_ms
  unsigned int delay_ms;
  // x
  unsigned short int x;
  // y
  unsigned short int y;
  // w
  unsigned short int w;
  // h
  unsigned short int h;
  // datalen
  unsigned int datalen;
  // num_rle
  unsigned int num_rle;
  // _anon0
  union anonymous_13 _anon0;
  // colors
  unsigned int colors;
  // _anon1
  union anonymous_103 _anon1;
  // dirty_area
  struct osd_rect_s dirty_area;
  // flags
  unsigned char flags;
  // scaling
  unsigned char scaling;
} __attribute__ ((__packed__));

struct osd_data_s
{
  // source
  struct vo_overlay_s *source;
  // scaled
  unsigned char scaled : 1;
  // ovl
  struct vo_overlay_s ovl;
  // output_width
  unsigned short int output_width;
  // output_height
  unsigned short int output_height;
  // next
  struct osd_data_s *next;
};

struct osd_object_s_0
{
  // next
  struct osd_object_s_0 *next;
  // renderer
  struct osd_renderer_s_0 *renderer;
  // width
  signed int width;
  // height
  signed int height;
  // area
  unsigned char *area;
  // area_touched
  signed int area_touched;
  // display_x
  signed int display_x;
  // display_y
  signed int display_y;
  // video_window_x
  signed int video_window_x;
  // video_window_y
  signed int video_window_y;
  // video_window_width
  signed int video_window_width;
  // video_window_height
  signed int video_window_height;
  // extent_width
  signed int extent_width;
  // extent_height
  signed int extent_height;
  // x1
  signed int x1;
  // y1
  signed int y1;
  // x2
  signed int x2;
  // y2
  signed int y2;
  // color
  unsigned int color[256l];
  // trans
  unsigned char trans[256l];
  // font
  struct osd_font_s *font;
  // ft2
  struct osd_ft2context_s *ft2;
  // argb_layer
  struct argb_layer_s *argb_layer;
  // handle
  signed int handle;
};

struct osd_object_s
{
  // next
  struct osd_object_s *next;
  // renderer
  struct osd_renderer_s *renderer;
  // width
  signed int width;
  // height
  signed int height;
  // area
  unsigned char *area;
  // area_touched
  signed int area_touched;
  // display_x
  signed int display_x;
  // display_y
  signed int display_y;
  // video_window_x
  signed int video_window_x;
  // video_window_y
  signed int video_window_y;
  // video_window_width
  signed int video_window_width;
  // video_window_height
  signed int video_window_height;
  // extent_width
  signed int extent_width;
  // extent_height
  signed int extent_height;
  // x1
  signed int x1;
  // y1
  signed int y1;
  // x2
  signed int x2;
  // y2
  signed int y2;
  // color
  unsigned int color[256l];
  // trans
  unsigned char trans[256l];
  // font
  struct osd_font_s *font;
  // ft2
  struct osd_ft2context_s *ft2;
  // argb_layer
  struct argb_layer_s *argb_layer;
  // handle
  signed int handle;
};

struct video_overlay_object_s
{
  // handle
  signed int handle;
  // object_type
  unsigned int object_type;
  // pts
  signed long int pts;
  // overlay
  struct vo_overlay_s *overlay;
  // palette
  unsigned int *palette;
  // palette_type
  unsigned int palette_type;
};

struct video_overlay_event_s
{
  // vpts
  signed long int vpts;
  // event_type
  unsigned int event_type;
  // object
  struct video_overlay_object_s object;
};

struct osd_renderer_s_0
{
  // stream
  struct xine_stream_s_0 *stream;
  // new_object
  struct osd_object_s_0 * (*new_object)(struct osd_renderer_s_0 *, signed int, signed int);
  // free_object
  void (*free_object)(struct osd_object_s_0 *);
  // show
  signed int (*show)(struct osd_object_s_0 *, signed long int);
  // hide
  signed int (*hide)(struct osd_object_s_0 *, signed long int);
  // point
  void (*point)(struct osd_object_s_0 *, signed int, signed int, signed int);
  // line
  void (*line)(struct osd_object_s_0 *, signed int, signed int, signed int, signed int, signed int);
  // filled_rect
  void (*filled_rect)(struct osd_object_s_0 *, signed int, signed int, signed int, signed int, signed int);
  // set_palette
  void (*set_palette)(struct osd_object_s_0 *, const unsigned int *, const unsigned char *);
  // set_text_palette
  void (*set_text_palette)(struct osd_object_s_0 *, signed int, signed int);
  // get_palette
  void (*get_palette)(struct osd_object_s_0 *, unsigned int *, unsigned char *);
  // set_position
  void (*set_position)(struct osd_object_s_0 *, signed int, signed int);
  // set_font
  signed int (*set_font)(struct osd_object_s_0 *, const char *, signed int);
  // set_encoding
  signed int (*set_encoding)(struct osd_object_s_0 *, const char *);
  // render_text
  signed int (*render_text)(struct osd_object_s_0 *, signed int, signed int, const char *, signed int);
  // get_text_size
  signed int (*get_text_size)(struct osd_object_s_0 *, const char *, signed int *, signed int *);
  // close
  void (*close)(struct osd_renderer_s_0 *);
  // clear
  void (*clear)(struct osd_object_s_0 *);
  // draw_bitmap
  void (*draw_bitmap)(struct osd_object_s_0 *, unsigned char *, signed int, signed int, signed int, signed int, unsigned char *);
  // show_unscaled
  signed int (*show_unscaled)(struct osd_object_s_0 *, signed long int);
  // get_capabilities
  unsigned int (*get_capabilities)(struct osd_object_s_0 *);
  // set_extent
  void (*set_extent)(struct osd_object_s_0 *, signed int, signed int);
  // set_argb_buffer
  void (*set_argb_buffer)(struct osd_object_s_0 *, unsigned int *, signed int, signed int, signed int, signed int);
  // set_video_window
  void (*set_video_window)(struct osd_object_s_0 *, signed int, signed int, signed int, signed int);
  // osd_mutex
  union anonymous_7 osd_mutex;
  // event
  struct video_overlay_event_s event;
  // osds
  struct osd_object_s_0 *osds;
  // fonts
  struct osd_font_s *fonts;
  // textpalette
  signed int textpalette;
};

struct osd_renderer_s
{
  // stream
  struct xine_stream_s *stream;
  // new_object
  struct osd_object_s * (*new_object)(struct osd_renderer_s *, signed int, signed int);
  // free_object
  void (*free_object)(struct osd_object_s *);
  // show
  signed int (*show)(struct osd_object_s *, signed long int);
  // hide
  signed int (*hide)(struct osd_object_s *, signed long int);
  // point
  void (*point)(struct osd_object_s *, signed int, signed int, signed int);
  // line
  void (*line)(struct osd_object_s *, signed int, signed int, signed int, signed int, signed int);
  // filled_rect
  void (*filled_rect)(struct osd_object_s *, signed int, signed int, signed int, signed int, signed int);
  // set_palette
  void (*set_palette)(struct osd_object_s *, const unsigned int *, const unsigned char *);
  // set_text_palette
  void (*set_text_palette)(struct osd_object_s *, signed int, signed int);
  // get_palette
  void (*get_palette)(struct osd_object_s *, unsigned int *, unsigned char *);
  // set_position
  void (*set_position)(struct osd_object_s *, signed int, signed int);
  // set_font
  signed int (*set_font)(struct osd_object_s *, const char *, signed int);
  // set_encoding
  signed int (*set_encoding)(struct osd_object_s *, const char *);
  // render_text
  signed int (*render_text)(struct osd_object_s *, signed int, signed int, const char *, signed int);
  // get_text_size
  signed int (*get_text_size)(struct osd_object_s *, const char *, signed int *, signed int *);
  // close
  void (*close)(struct osd_renderer_s *);
  // clear
  void (*clear)(struct osd_object_s *);
  // draw_bitmap
  void (*draw_bitmap)(struct osd_object_s *, unsigned char *, signed int, signed int, signed int, signed int, unsigned char *);
  // show_unscaled
  signed int (*show_unscaled)(struct osd_object_s *, signed long int);
  // get_capabilities
  unsigned int (*get_capabilities)(struct osd_object_s *);
  // set_extent
  void (*set_extent)(struct osd_object_s *, signed int, signed int);
  // set_argb_buffer
  void (*set_argb_buffer)(struct osd_object_s *, unsigned int *, signed int, signed int, signed int, signed int);
  // set_video_window
  void (*set_video_window)(struct osd_object_s *, signed int, signed int, signed int, signed int);
  // osd_mutex
  union anonymous_7 osd_mutex;
  // event
  struct video_overlay_event_s event;
  // osds
  struct osd_object_s *osds;
  // fonts
  struct osd_font_s *fonts;
  // textpalette
  signed int textpalette;
};

struct osd_rle_elem_s
{
  // len
  unsigned short int len;
  // color
  unsigned short int color;
} __attribute__ ((__packed__));

struct plugin_catalog_s_0
{
  // plugin_lists
  struct xine_sarray_s *plugin_lists[8l];
  // cache_list
  struct xine_sarray_s *cache_list;
  // file_list
  struct xine_list_s *file_list;
  // audio_decoder_map
  struct anonymous_75 *audio_decoder_map[128l][10l];
  // video_decoder_map
  struct anonymous_75 *video_decoder_map[128l][10l];
  // spu_decoder_map
  struct anonymous_75 *spu_decoder_map[128l][10l];
  // ids
  const char *ids[256l];
  // prio_desc
  char *prio_desc[128l];
  // lock
  union anonymous_7 lock;
  // plugin_count
  signed int plugin_count;
  // decoder_count
  signed int decoder_count;
};

struct plugin_catalog_s
{
  // plugin_lists
  struct xine_sarray_s *plugin_lists[8l];
  // cache_list
  struct xine_sarray_s *cache_list;
  // file_list
  struct xine_list_s *file_list;
  // audio_decoder_map
  struct anonymous_24 *audio_decoder_map[128l][10l];
  // video_decoder_map
  struct anonymous_24 *video_decoder_map[128l][10l];
  // spu_decoder_map
  struct anonymous_24 *spu_decoder_map[128l][10l];
  // ids
  const char *ids[256l];
  // prio_desc
  char *prio_desc[128l];
  // lock
  union anonymous_7 lock;
  // plugin_count
  signed int plugin_count;
  // decoder_count
  signed int decoder_count;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

struct post_plugins_s_0
{
  // static_post_plugins
  char *static_post_plugins;
  // video_source
  struct xine_stream_s_0 *video_source;
  // audio_source
  struct xine_stream_s_0 *audio_source;
  // pip_stream
  struct xine_stream_s_0 *pip_stream;
  // xine
  struct xine_s_0 *xine;
  // video_port
  struct xine_video_port_s *video_port;
  // audio_port
  struct xine_audio_port_s_0 *audio_port;
  // post_audio_elements_num
  signed int post_audio_elements_num;
  // post_video_elements_num
  signed int post_video_elements_num;
  // post_vis_elements_num
  signed int post_vis_elements_num;
  // post_pip_elements_num
  signed int post_pip_elements_num;
  // post_audio_elements
  struct anonymous_73 **post_audio_elements;
  // post_video_elements
  struct anonymous_73 **post_video_elements;
  // post_vis_elements
  struct anonymous_73 **post_vis_elements;
  // post_pip_elements
  struct anonymous_73 **post_pip_elements;
  // post_audio_enable
  signed int post_audio_enable;
  // post_video_enable
  signed int post_video_enable;
  // post_vis_enable
  signed int post_vis_enable;
  // post_pip_enable
  signed int post_pip_enable;
};

struct post_plugins_s
{
  // static_post_plugins
  char *static_post_plugins;
  // video_source
  struct xine_stream_s *video_source;
  // audio_source
  struct xine_stream_s *audio_source;
  // pip_stream
  struct xine_stream_s *pip_stream;
  // xine
  struct xine_s *xine;
  // video_port
  struct xine_video_port_s_0 *video_port;
  // audio_port
  struct xine_audio_port_s *audio_port;
  // post_audio_elements_num
  signed int post_audio_elements_num;
  // post_video_elements_num
  signed int post_video_elements_num;
  // post_vis_elements_num
  signed int post_vis_elements_num;
  // post_pip_elements_num
  signed int post_pip_elements_num;
  // post_audio_elements
  struct anonymous_26 **post_audio_elements;
  // post_video_elements
  struct anonymous_26 **post_video_elements;
  // post_vis_elements
  struct anonymous_26 **post_vis_elements;
  // post_pip_elements
  struct anonymous_26 **post_pip_elements;
  // post_audio_enable
  signed int post_audio_enable;
  // post_video_enable
  signed int post_video_enable;
  // post_vis_enable
  signed int post_vis_enable;
  // post_pip_enable
  signed int post_pip_enable;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rle_elem_s
{
  // len
  unsigned short int len;
  // color
  unsigned short int color;
};

struct sched_param
{
  // __sched_priority
  signed int __sched_priority;
};

struct scr_plugin_s
{
  // get_priority
  signed int (*get_priority)(struct scr_plugin_s *);
  // set_fine_speed
  signed int (*set_fine_speed)(struct scr_plugin_s *, signed int);
  // adjust
  void (*adjust)(struct scr_plugin_s *, signed long int);
  // start
  void (*start)(struct scr_plugin_s *, signed long int);
  // get_current
  signed long int (*get_current)(struct scr_plugin_s *);
  // exit
  void (*exit)(struct scr_plugin_s *);
  // clock
  struct metronom_clock_s *clock;
  // interface_version
  signed int interface_version;
};

struct scratch_buffer_s
{
  // scratch_printf
  void (*scratch_printf)(struct scratch_buffer_s *, const char *, void **);
  // get_content
  char ** (*get_content)(struct scratch_buffer_s *);
  // dispose
  void (*dispose)(struct scratch_buffer_s *);
  // lines
  char **lines;
  // ordered
  char **ordered;
  // num_lines
  signed int num_lines;
  // cur
  signed int cur;
  // lock
  union anonymous_7 lock;
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct spu_decoder_s
{
  // decode_data
  void (*decode_data)(struct spu_decoder_s *, struct buf_element_s *);
  // reset
  void (*reset)(struct spu_decoder_s *);
  // discontinuity
  void (*discontinuity)(struct spu_decoder_s *);
  // dispose
  void (*dispose)(struct spu_decoder_s *);
  // get_interact_info
  signed int (*get_interact_info)(struct spu_decoder_s *, void *);
  // set_button
  void (*set_button)(struct spu_decoder_s *, signed int, signed int);
  // node
  void *node;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct sxfe_s
{
  // _anon0
  union anonymous_10 _anon0;
  // fe_xine_open
  signed int (*fe_xine_open)(struct frontend_s *, const char *);
  // fe_xine_play
  signed int (*fe_xine_play)(struct frontend_s *);
  // display
  struct _XDisplay *display;
  // root_window
  unsigned long int root_window;
  // window
  unsigned long int window[2l];
  // screen
  signed int screen;
  // window_id
  signed int window_id;
  // xshm_completion_event
  signed int xshm_completion_event;
  // prev_click_time
  unsigned long int prev_click_time;
  // mousecursor_timeout
  signed int mousecursor_timeout;
  // dpms_state
  unsigned char dpms_state;
  // xa_SXFE_INTERRUPT
  unsigned long int xa_SXFE_INTERRUPT;
  // xa_WM_DELETE_WINDOW
  unsigned long int xa_WM_DELETE_WINDOW;
  // xa_MOTIF_WM_HINTS
  unsigned long int xa_MOTIF_WM_HINTS;
  // xa_WIN_LAYER
  unsigned long int xa_WIN_LAYER;
  // xa_WIN_STATE
  unsigned long int xa_WIN_STATE;
  // xa_NET_ACTIVE_WINDOW
  unsigned long int xa_NET_ACTIVE_WINDOW;
  // xa_NET_WM_STATE
  unsigned long int xa_NET_WM_STATE;
  // xa_NET_WM_STATE_ADD
  unsigned long int xa_NET_WM_STATE_ADD;
  // xa_NET_WM_STATE_DEL
  unsigned long int xa_NET_WM_STATE_DEL;
  // xa_NET_WM_STATE_ABOVE
  unsigned long int xa_NET_WM_STATE_ABOVE;
  // xa_NET_WM_STATE_STICKY
  unsigned long int xa_NET_WM_STATE_STICKY;
  // xa_NET_WM_STATE_FULLSCREEN
  unsigned long int xa_NET_WM_STATE_FULLSCREEN;
  // xa_NET_WM_STATE_STAYS_ON_TOP
  unsigned long int xa_NET_WM_STATE_STAYS_ON_TOP;
  // xinerama_screen
  signed int xinerama_screen;
  // xinerama_x
  unsigned short int xinerama_x;
  // xinerama_y
  unsigned short int xinerama_y;
  // origwidth
  unsigned short int origwidth;
  // origheight
  unsigned short int origheight;
  // origxpos
  unsigned short int origxpos;
  // origypos
  unsigned short int origypos;
  // dragging_x
  unsigned short int dragging_x;
  // dragging_y
  unsigned short int dragging_y;
  // fullscreen
  unsigned char fullscreen : 1;
  // fullscreen_state_forced
  unsigned char fullscreen_state_forced : 1;
  // stay_above
  unsigned char stay_above : 1;
  // no_border
  unsigned char no_border : 1;
  // check_move
  unsigned char check_move : 1;
  // dragging
  unsigned char dragging : 1;
  // gui_hotkeys
  unsigned char gui_hotkeys : 1;
  // no_x_kbd
  unsigned char no_x_kbd : 1;
  // touchscreen
  unsigned char touchscreen : 1;
  // video_win_mutex
  union anonymous_7 video_win_mutex;
  // video_win_active
  unsigned char video_win_active;
  // video_win_changed
  unsigned char video_win_changed;
  // video_win_x
  unsigned short int video_win_x;
  // video_win_y
  unsigned short int video_win_y;
  // video_win_w
  unsigned short int video_win_w;
  // video_win_h
  unsigned short int video_win_h;
  // osd_visible
  unsigned char osd_visible;
  // osd_width
  unsigned short int osd_width;
  // osd_height
  unsigned short int osd_height;
  // opengl_window
  unsigned long int opengl_window;
  // opengl_context
  struct __GLXcontextRec *opengl_context;
  // screen_width
  signed int screen_width;
  // screen_height
  signed int screen_height;
  // opengl_drawing_thread
  unsigned long int opengl_drawing_thread;
  // opengl_redraw_mutex
  union anonymous_7 opengl_redraw_mutex;
  // opengl_redraw_cv
  union anonymous_19 opengl_redraw_cv;
  // opengl_redraw_request_nr
  unsigned int opengl_redraw_request_nr;
  // opengl_redraw_served_nr
  unsigned int opengl_redraw_served_nr;
  // opengl_redraw_finished_mutex
  union anonymous_7 opengl_redraw_finished_mutex;
  // opengl_redraw_finished_cv
  union anonymous_19 opengl_redraw_finished_cv;
  // opengl_osd_texture_img_mutex
  union anonymous_7 opengl_osd_texture_img_mutex;
  // video_frame_pixmap
  unsigned long int video_frame_pixmap;
  // video_frame_gc
  struct _XGC *video_frame_gc;
  // video_frame_texture
  unsigned int video_frame_texture;
  // osd_texture
  unsigned int osd_texture;
  // opengl_osd_texture_img
  unsigned int *opengl_osd_texture_img;
  // opengl_hud
  unsigned char opengl_hud : 1;
  // opengl_always
  unsigned char opengl_always : 1;
  // opengl_osd_texture_img_updated
  unsigned char opengl_osd_texture_img_updated : 1;
  // opengl_deinit
  unsigned char opengl_deinit : 1;
  // opengl_xshape_available
  unsigned char opengl_xshape_available : 1;
  // hud
  unsigned char hud;
  // hud_img
  struct _XImage *hud_img;
  // hud_vis
  struct anonymous_16 *hud_vis;
  // surf_win
  struct _xrender_surf *surf_win;
  // surf_img
  struct _xrender_surf *surf_img;
  // hud_img_mem
  unsigned int *hud_img_mem;
  // gc
  struct _XGC *gc;
  // hud_window
  unsigned long int hud_window;
  // xshape_hud
  unsigned char xshape_hud : 1;
  // surf_back_img
  struct _xrender_surf *surf_back_img;
  // shape_mask_mem
  unsigned int *shape_mask_mem;
  // shape_mask_pixmap
  unsigned long int shape_mask_pixmap;
  // shape_mask_gc
  struct _XGC *shape_mask_gc;
  // shape_mask_picture
  unsigned long int shape_mask_picture;
  // hud_shminfo
  struct anonymous_31 hud_shminfo;
};

struct tJpegCompressData_s
{
  // size
  signed int size;
  // mem
  unsigned char *mem;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct vdr_input_plugin_funcs_s_0
{
  // push_input_write
  signed int (*push_input_write)(struct vdr_input_plugin_if_s_0 *, signed int, unsigned long int, const char *, signed int);
  // push_input_control
  signed int (*push_input_control)(struct vdr_input_plugin_if_s_0 *, const char *);
  // push_input_osd
  signed int (*push_input_osd)(struct vdr_input_plugin_if_s_0 *, struct osd_command_s *);
  // xine_input_event
  void (*xine_input_event)(struct frontend_s *, const char *, const char *);
  // intercept_osd
  signed int (*intercept_osd)(struct frontend_s *, struct osd_command_s *);
  // fe_control
  void * (*fe_control)(struct frontend_s *, const char *);
  // fe_handle
  struct frontend_s *fe_handle;
  // post_vdr_event
  signed int (*post_vdr_event)(struct vdr_input_plugin_if_s_0 *, const char *);
};

struct vdr_input_plugin_funcs_s
{
  // push_input_write
  signed int (*push_input_write)(struct vdr_input_plugin_if_s *, signed int, unsigned long int, const char *, signed int);
  // push_input_control
  signed int (*push_input_control)(struct vdr_input_plugin_if_s *, const char *);
  // push_input_osd
  signed int (*push_input_osd)(struct vdr_input_plugin_if_s *, struct osd_command_s *);
  // xine_input_event
  void (*xine_input_event)(struct frontend_s *, const char *, const char *);
  // intercept_osd
  signed int (*intercept_osd)(struct frontend_s *, struct osd_command_s *);
  // fe_control
  void * (*fe_control)(struct frontend_s *, const char *);
  // fe_handle
  struct frontend_s *fe_handle;
  // post_vdr_event
  signed int (*post_vdr_event)(struct vdr_input_plugin_if_s *, const char *);
};

struct vdr_input_plugin_if_s_0
{
  // input_plugin
  struct input_plugin_s_0 input_plugin;
  // f
  struct vdr_input_plugin_funcs_s_0 f;
};

struct vdr_input_plugin_if_s
{
  // input_plugin
  struct input_plugin_s input_plugin;
  // f
  struct vdr_input_plugin_funcs_s f;
};

struct video_decoder_s
{
  // decode_data
  void (*decode_data)(struct video_decoder_s *, struct buf_element_s *);
  // reset
  void (*reset)(struct video_decoder_s *);
  // discontinuity
  void (*discontinuity)(struct video_decoder_s *);
  // flush
  void (*flush)(struct video_decoder_s *);
  // dispose
  void (*dispose)(struct video_decoder_s *);
  // node
  void *node;
};

struct video_overlay_manager_s
{
  // init
  void (*init)(struct video_overlay_manager_s *);
  // dispose
  void (*dispose)(struct video_overlay_manager_s *);
  // get_handle
  signed int (*get_handle)(struct video_overlay_manager_s *, signed int);
  // free_handle
  void (*free_handle)(struct video_overlay_manager_s *, signed int);
  // add_event
  signed int (*add_event)(struct video_overlay_manager_s *, void *);
  // flush_events
  void (*flush_events)(struct video_overlay_manager_s *);
  // redraw_needed
  signed int (*redraw_needed)(struct video_overlay_manager_s *, signed long int);
  // multiple_overlay_blend
  void (*multiple_overlay_blend)(struct video_overlay_manager_s *, signed long int, struct vo_driver_s *, struct vo_frame_s *, signed int);
};

struct video_overlay_manager_s_0
{
  // init
  void (*init)(struct video_overlay_manager_s_0 *);
  // dispose
  void (*dispose)(struct video_overlay_manager_s_0 *);
  // get_handle
  signed int (*get_handle)(struct video_overlay_manager_s_0 *, signed int);
  // free_handle
  void (*free_handle)(struct video_overlay_manager_s_0 *, signed int);
  // add_event
  signed int (*add_event)(struct video_overlay_manager_s_0 *, void *);
  // flush_events
  void (*flush_events)(struct video_overlay_manager_s_0 *);
  // redraw_needed
  signed int (*redraw_needed)(struct video_overlay_manager_s_0 *, signed long int);
  // multiple_overlay_blend
  void (*multiple_overlay_blend)(struct video_overlay_manager_s_0 *, signed long int, struct vo_driver_s_0 *, struct vo_frame_s_0 *, signed int);
};

struct vo_driver_s_0
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct vo_driver_s_0 *);
  // alloc_frame
  struct vo_frame_s_0 * (*alloc_frame)(struct vo_driver_s_0 *);
  // update_frame_format
  void (*update_frame_format)(struct vo_driver_s_0 *, struct vo_frame_s_0 *, unsigned int, unsigned int, double, signed int, signed int);
  // display_frame
  void (*display_frame)(struct vo_driver_s_0 *, struct vo_frame_s_0 *);
  // overlay_begin
  void (*overlay_begin)(struct vo_driver_s_0 *, struct vo_frame_s_0 *, signed int);
  // overlay_blend
  void (*overlay_blend)(struct vo_driver_s_0 *, struct vo_frame_s_0 *, struct vo_overlay_s *);
  // overlay_end
  void (*overlay_end)(struct vo_driver_s_0 *, struct vo_frame_s_0 *);
  // get_property
  signed int (*get_property)(struct vo_driver_s_0 *, signed int);
  // set_property
  signed int (*set_property)(struct vo_driver_s_0 *, signed int, signed int);
  // get_property_min_max
  void (*get_property_min_max)(struct vo_driver_s_0 *, signed int, signed int *, signed int *);
  // gui_data_exchange
  signed int (*gui_data_exchange)(struct vo_driver_s_0 *, signed int, void *);
  // redraw_needed
  signed int (*redraw_needed)(struct vo_driver_s_0 *);
  // new_grab_video_frame
  struct xine_grab_video_frame_s * (*new_grab_video_frame)(struct vo_driver_s_0 *);
  // dispose
  void (*dispose)(struct vo_driver_s_0 *);
  // node
  void *node;
};

struct vo_frame_s
{
  // proc_provide_standard_frame_data
  void (*proc_provide_standard_frame_data)(struct vo_frame_s *, struct anonymous_30 *);
  // proc_duplicate_frame_data
  void (*proc_duplicate_frame_data)(struct vo_frame_s *, struct vo_frame_s *);
  // proc_frame
  void (*proc_frame)(struct vo_frame_s *);
  // proc_slice
  void (*proc_slice)(struct vo_frame_s *, unsigned char **);
  // field
  void (*field)(struct vo_frame_s *, signed int);
  // draw
  signed int (*draw)(struct vo_frame_s *, struct xine_stream_s_0 *);
  // lock
  void (*lock)(struct vo_frame_s *);
  // free
  void (*free)(struct vo_frame_s *);
  // dispose
  void (*dispose)(struct vo_frame_s *);
  // pts
  signed long int pts;
  // vpts
  signed long int vpts;
  // bad_frame
  signed int bad_frame;
  // duration
  signed int duration;
  // base
  unsigned char *base[3l];
  // pitches
  signed int pitches[3l];
  // top_field_first
  signed int top_field_first;
  // repeat_first_field
  signed int repeat_first_field;
  // progressive_frame
  signed int progressive_frame;
  // picture_coding_type
  signed int picture_coding_type;
  // crop_left
  signed int crop_left;
  // crop_right
  signed int crop_right;
  // crop_top
  signed int crop_top;
  // crop_bottom
  signed int crop_bottom;
  // lock_counter
  signed int lock_counter;
  // mutex
  union anonymous_7 mutex;
  // extra_info
  struct extra_info_s *extra_info;
  // width
  signed int width;
  // height
  signed int height;
  // ratio
  double ratio;
  // format
  signed int format;
  // drawn
  signed int drawn;
  // flags
  signed int flags;
  // proc_called
  signed int proc_called;
  // accel_data
  void *accel_data;
  // port
  struct xine_video_port_s *port;
  // driver
  struct vo_driver_s *driver;
  // stream
  struct xine_stream_s_0 *stream;
  // overlay_offset_x
  signed int overlay_offset_x;
  // overlay_offset_y
  signed int overlay_offset_y;
  // future_frame
  struct vo_frame_s *future_frame;
  // next
  struct vo_frame_s *next;
  // id
  signed int id;
  // is_first
  signed int is_first;
};

struct vo_frame_s_0
{
  // proc_provide_standard_frame_data
  void (*proc_provide_standard_frame_data)(struct vo_frame_s_0 *, struct anonymous_30 *);
  // proc_duplicate_frame_data
  void (*proc_duplicate_frame_data)(struct vo_frame_s_0 *, struct vo_frame_s_0 *);
  // proc_frame
  void (*proc_frame)(struct vo_frame_s_0 *);
  // proc_slice
  void (*proc_slice)(struct vo_frame_s_0 *, unsigned char **);
  // field
  void (*field)(struct vo_frame_s_0 *, signed int);
  // draw
  signed int (*draw)(struct vo_frame_s_0 *, struct xine_stream_s *);
  // lock
  void (*lock)(struct vo_frame_s_0 *);
  // free
  void (*free)(struct vo_frame_s_0 *);
  // dispose
  void (*dispose)(struct vo_frame_s_0 *);
  // pts
  signed long int pts;
  // vpts
  signed long int vpts;
  // bad_frame
  signed int bad_frame;
  // duration
  signed int duration;
  // base
  unsigned char *base[3l];
  // pitches
  signed int pitches[3l];
  // top_field_first
  signed int top_field_first;
  // repeat_first_field
  signed int repeat_first_field;
  // progressive_frame
  signed int progressive_frame;
  // picture_coding_type
  signed int picture_coding_type;
  // crop_left
  signed int crop_left;
  // crop_right
  signed int crop_right;
  // crop_top
  signed int crop_top;
  // crop_bottom
  signed int crop_bottom;
  // lock_counter
  signed int lock_counter;
  // mutex
  union anonymous_7 mutex;
  // extra_info
  struct extra_info_s *extra_info;
  // width
  signed int width;
  // height
  signed int height;
  // ratio
  double ratio;
  // format
  signed int format;
  // drawn
  signed int drawn;
  // flags
  signed int flags;
  // proc_called
  signed int proc_called;
  // accel_data
  void *accel_data;
  // port
  struct xine_video_port_s_0 *port;
  // driver
  struct vo_driver_s_0 *driver;
  // stream
  struct xine_stream_s *stream;
  // overlay_offset_x
  signed int overlay_offset_x;
  // overlay_offset_y
  signed int overlay_offset_y;
  // future_frame
  struct vo_frame_s_0 *future_frame;
  // next
  struct vo_frame_s_0 *next;
  // id
  signed int id;
  // is_first
  signed int is_first;
};

struct xine_audio_port_s_0
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct xine_audio_port_s_0 *);
  // get_property
  signed int (*get_property)(struct xine_audio_port_s_0 *, signed int);
  // set_property
  signed int (*set_property)(struct xine_audio_port_s_0 *, signed int, signed int);
  // open
  signed int (*open)(struct xine_audio_port_s_0 *, struct xine_stream_s_0 *, unsigned int, unsigned int, signed int);
  // get_buffer
  struct audio_buffer_s_0 * (*get_buffer)(struct xine_audio_port_s_0 *);
  // put_buffer
  void (*put_buffer)(struct xine_audio_port_s_0 *, struct audio_buffer_s_0 *, struct xine_stream_s_0 *);
  // close
  void (*close)(struct xine_audio_port_s_0 *, struct xine_stream_s_0 *);
  // exit
  void (*exit)(struct xine_audio_port_s_0 *);
  // control
  signed int (*control)(struct xine_audio_port_s_0 *, signed int, ...);
  // flush
  void (*flush)(struct xine_audio_port_s_0 *);
  // status
  signed int (*status)(struct xine_audio_port_s_0 *, struct xine_stream_s_0 *, unsigned int *, unsigned int *, signed int *);
};

struct xine_audio_port_s
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct xine_audio_port_s *);
  // get_property
  signed int (*get_property)(struct xine_audio_port_s *, signed int);
  // set_property
  signed int (*set_property)(struct xine_audio_port_s *, signed int, signed int);
  // open
  signed int (*open)(struct xine_audio_port_s *, struct xine_stream_s *, unsigned int, unsigned int, signed int);
  // get_buffer
  struct audio_buffer_s * (*get_buffer)(struct xine_audio_port_s *);
  // put_buffer
  void (*put_buffer)(struct xine_audio_port_s *, struct audio_buffer_s *, struct xine_stream_s *);
  // close
  void (*close)(struct xine_audio_port_s *, struct xine_stream_s *);
  // exit
  void (*exit)(struct xine_audio_port_s *);
  // control
  signed int (*control)(struct xine_audio_port_s *, signed int, ...);
  // flush
  void (*flush)(struct xine_audio_port_s *);
  // status
  signed int (*status)(struct xine_audio_port_s *, struct xine_stream_s *, unsigned int *, unsigned int *, signed int *);
};

struct xine_cfg_entry_s
{
  // key
  const char *key;
  // type
  signed int type;
  // exp_level
  signed int exp_level;
  // unknown_value
  char *unknown_value;
  // str_value
  char *str_value;
  // str_default
  char *str_default;
  // num_value
  signed int num_value;
  // num_default
  signed int num_default;
  // range_min
  signed int range_min;
  // range_max
  signed int range_max;
  // enum_values
  char **enum_values;
  // description
  const char *description;
  // help
  const char *help;
  // callback
  void (*callback)(void *, struct xine_cfg_entry_s *);
  // callback_data
  void *callback_data;
};

struct xine_event_queue_s_0
{
  // events
  struct xine_list_s *events;
  // lock
  union anonymous_7 lock;
  // new_event
  union anonymous_19 new_event;
  // events_processed
  union anonymous_19 events_processed;
  // stream
  struct xine_stream_s_0 *stream;
  // listener_thread
  unsigned long int *listener_thread;
  // user_data
  void *user_data;
  // callback
  void (*callback)(void *, const struct anonymous_88 *);
  // callback_running
  signed int callback_running;
};

struct xine_event_queue_s
{
  // events
  struct xine_list_s *events;
  // lock
  union anonymous_7 lock;
  // new_event
  union anonymous_19 new_event;
  // events_processed
  union anonymous_19 events_processed;
  // stream
  struct xine_stream_s *stream;
  // listener_thread
  unsigned long int *listener_thread;
  // user_data
  void *user_data;
  // callback
  void (*callback)(void *, const struct anonymous_15 *);
  // callback_running
  signed int callback_running;
};

struct xine_grab_video_frame_s
{
  // grab
  signed int (*grab)(struct xine_grab_video_frame_s *);
  // dispose
  void (*dispose)(struct xine_grab_video_frame_s *);
  // crop_left
  signed int crop_left;
  // crop_right
  signed int crop_right;
  // crop_top
  signed int crop_top;
  // crop_bottom
  signed int crop_bottom;
  // width
  signed int width;
  // height
  signed int height;
  // img
  unsigned char *img;
  // vpts
  signed long int vpts;
  // timeout
  signed int timeout;
  // flags
  signed int flags;
};

struct xine_post_in_s
{
  // name
  const char *name;
  // data
  void *data;
  // type
  signed int type;
};

struct xine_post_out_s
{
  // name
  const char *name;
  // data
  void *data;
  // rewire
  signed int (*rewire)(struct xine_post_out_s *, void *);
  // type
  signed int type;
};

struct xine_post_s_0
{
  // audio_input
  struct xine_audio_port_s_0 **audio_input;
  // video_input
  struct xine_video_port_s **video_input;
  // type
  signed int type;
};

struct xine_post_s
{
  // audio_input
  struct xine_audio_port_s **audio_input;
  // video_input
  struct xine_video_port_s_0 **video_input;
  // type
  signed int type;
};

struct xine_s_0
{
  // config
  struct config_values_s *config;
  // plugin_catalog
  struct plugin_catalog_s_0 *plugin_catalog;
  // verbosity
  signed int verbosity;
  // demux_strategy
  signed int demux_strategy;
  // save_path
  char *save_path;
  // log_buffers
  struct scratch_buffer_s *log_buffers[3l];
  // streams
  struct xine_list_s *streams;
  // streams_lock
  union anonymous_7 streams_lock;
  // clock
  struct metronom_clock_s *clock;
  // basedir_handle
  struct anonymous_25 basedir_handle;
};

struct xine_s
{
  // config
  struct config_values_s *config;
  // plugin_catalog
  struct plugin_catalog_s *plugin_catalog;
  // verbosity
  signed int verbosity;
  // demux_strategy
  signed int demux_strategy;
  // save_path
  char *save_path;
  // log_buffers
  struct scratch_buffer_s *log_buffers[3l];
  // streams
  struct xine_list_s *streams;
  // streams_lock
  union anonymous_7 streams_lock;
  // clock
  struct metronom_clock_s *clock;
  // basedir_handle
  struct anonymous_25 basedir_handle;
  // port_ticket
  struct xine_ticket_s *port_ticket;
  // log_lock
  union anonymous_7 log_lock;
  // log_cb
  void (*log_cb)(void *, signed int);
  // log_cb_user_data
  void *log_cb_user_data;
};

struct xine_stream_s_0
{
  // xine
  struct xine_s_0 *xine;
  // metronom
  struct metronom_s *metronom;
  // input_plugin
  struct input_plugin_s_0 *input_plugin;
  // video_out
  struct xine_video_port_s *video_out;
  // video_fifo
  struct fifo_buffer_s *video_fifo;
  // audio_out
  struct xine_audio_port_s_0 *audio_out;
  // audio_fifo
  struct fifo_buffer_s *audio_fifo;
  // osd_renderer
  struct osd_renderer_s_0 *osd_renderer;
  // master
  struct xine_stream_s_0 *master;
  // slave
  struct xine_stream_s_0 *slave;
  // spu_decoder_plugin
  struct spu_decoder_s *spu_decoder_plugin;
  // video_driver
  struct vo_driver_s *video_driver;
  // audio_channel_auto
  signed int audio_channel_auto;
  // spu_decoder_streamtype
  signed int spu_decoder_streamtype;
  // spu_channel_user
  signed int spu_channel_user;
  // spu_channel_auto
  signed int spu_channel_auto;
  // spu_channel_letterbox
  signed int spu_channel_letterbox;
  // spu_channel
  signed int spu_channel;
  // content_detection_method
  signed int content_detection_method;
};

struct xine_stream_s
{
  // xine
  struct xine_s *xine;
  // metronom
  struct metronom_s_0 *metronom;
  // input_plugin
  struct input_plugin_s *input_plugin;
  // video_out
  struct xine_video_port_s_0 *video_out;
  // video_fifo
  struct fifo_buffer_s *video_fifo;
  // audio_out
  struct xine_audio_port_s *audio_out;
  // audio_fifo
  struct fifo_buffer_s *audio_fifo;
  // osd_renderer
  struct osd_renderer_s *osd_renderer;
  // master
  struct xine_stream_s *master;
  // slave
  struct xine_stream_s *slave;
  // spu_decoder_plugin
  struct spu_decoder_s *spu_decoder_plugin;
  // video_driver
  struct vo_driver_s_0 *video_driver;
  // audio_channel_auto
  signed int audio_channel_auto;
  // spu_decoder_streamtype
  signed int spu_decoder_streamtype;
  // spu_channel_user
  signed int spu_channel_user;
  // spu_channel_auto
  signed int spu_channel_auto;
  // spu_channel_letterbox
  signed int spu_channel_letterbox;
  // spu_channel
  signed int spu_channel;
  // content_detection_method
  signed int content_detection_method;
  // status
  signed int status;
  // speed_change_lock
  union anonymous_7 speed_change_lock;
  // ignore_speed_change
  unsigned int ignore_speed_change : 1;
  // video_thread_created
  unsigned int video_thread_created : 1;
  // audio_thread_created
  unsigned int audio_thread_created : 1;
  // first_frame_flag
  unsigned int first_frame_flag : 2;
  // demux_action_pending
  unsigned int demux_action_pending : 1;
  // demux_thread_created
  unsigned int demux_thread_created : 1;
  // demux_thread_running
  unsigned int demux_thread_running : 1;
  // slave_is_subtitle
  unsigned int slave_is_subtitle : 1;
  // emergency_brake
  unsigned int emergency_brake : 1;
  // early_finish_event
  unsigned int early_finish_event : 1;
  // gapless_switch
  unsigned int gapless_switch : 1;
  // keep_ao_driver_open
  unsigned int keep_ao_driver_open : 1;
  // eject_class
  struct input_class_s_0 *eject_class;
  // demux_plugin
  struct demux_plugin_s *demux_plugin;
  // video_thread
  unsigned long int video_thread;
  // video_decoder_plugin
  struct video_decoder_s *video_decoder_plugin;
  // video_decoder_extra_info
  struct extra_info_s *video_decoder_extra_info;
  // video_decoder_streamtype
  signed int video_decoder_streamtype;
  // video_channel
  signed int video_channel;
  // audio_track_map
  unsigned int audio_track_map[50l];
  // audio_track_map_entries
  signed int audio_track_map_entries;
  // audio_decoder_streamtype
  signed int audio_decoder_streamtype;
  // audio_thread
  unsigned long int audio_thread;
  // audio_decoder_plugin
  struct audio_decoder_s *audio_decoder_plugin;
  // audio_decoder_extra_info
  struct extra_info_s *audio_decoder_extra_info;
  // audio_type
  unsigned int audio_type;
  // audio_channel_user
  signed int audio_channel_user;
  // spu_track_map
  unsigned int spu_track_map[50l];
  // spu_track_map_entries
  signed int spu_track_map_entries;
  // spu_channel_pan_scan
  signed int spu_channel_pan_scan;
  // frontend_lock
  union anonymous_7 frontend_lock;
  // info_mutex
  union anonymous_7 info_mutex;
  // stream_info_public
  signed int stream_info_public[99l];
  // stream_info
  signed int stream_info[99l];
  // meta_mutex
  union anonymous_7 meta_mutex;
  // meta_info_public
  char *meta_info_public[99l];
  // meta_info
  char *meta_info[99l];
  // first_frame_lock
  union anonymous_7 first_frame_lock;
  // first_frame_reached
  union anonymous_19 first_frame_reached;
  // counter_lock
  union anonymous_7 counter_lock;
  // counter_changed
  union anonymous_19 counter_changed;
  // header_count_audio
  signed int header_count_audio;
  // header_count_video
  signed int header_count_video;
  // finished_count_audio
  signed int finished_count_audio;
  // finished_count_video
  signed int finished_count_video;
  // event_queues
  struct xine_list_s *event_queues;
  // event_queues_lock
  union anonymous_7 event_queues_lock;
  // demux_thread
  unsigned long int demux_thread;
  // demux_lock
  union anonymous_7 demux_lock;
  // demux_action_lock
  union anonymous_7 demux_action_lock;
  // demux_resume
  union anonymous_19 demux_resume;
  // demux_mutex
  union anonymous_7 demux_mutex;
  // current_extra_info
  struct extra_info_s *current_extra_info;
  // current_extra_info_lock
  union anonymous_7 current_extra_info_lock;
  // video_seek_count
  signed int video_seek_count;
  // delay_finish_event
  signed int delay_finish_event;
  // slave_affection
  signed int slave_affection;
  // err
  signed int err;
  // video_source
  struct xine_post_out_s video_source;
  // audio_source
  struct xine_post_out_s audio_source;
  // broadcaster
  struct broadcaster_s *broadcaster;
  // refcounter
  struct anonymous_29 *refcounter;
};

struct xine_ticket_s
{
  // ticket_revoked
  signed int ticket_revoked;
  // acquire
  void (*acquire)(struct xine_ticket_s *, signed int);
  // release
  void (*release)(struct xine_ticket_s *, signed int);
  // renew
  void (*renew)(struct xine_ticket_s *, signed int);
  // issue
  void (*issue)(struct xine_ticket_s *, signed int);
  // revoke
  void (*revoke)(struct xine_ticket_s *, signed int);
  // acquire_nonblocking
  signed int (*acquire_nonblocking)(struct xine_ticket_s *, signed int);
  // release_nonblocking
  void (*release_nonblocking)(struct xine_ticket_s *, signed int);
  // lock_port_rewiring
  signed int (*lock_port_rewiring)(struct xine_ticket_s *, signed int);
  // unlock_port_rewiring
  void (*unlock_port_rewiring)(struct xine_ticket_s *);
  // dispose
  void (*dispose)(struct xine_ticket_s *);
  // lock
  union anonymous_7 lock;
  // revoke_lock
  union anonymous_7 revoke_lock;
  // issued
  union anonymous_19 issued;
  // revoked
  union anonymous_19 revoked;
  // tickets_granted
  signed int tickets_granted;
  // irrevocable_tickets
  signed int irrevocable_tickets;
  // pending_revocations
  signed int pending_revocations;
  // atomic_revoke
  signed int atomic_revoke;
  // atomic_revoker_thread
  unsigned long int atomic_revoker_thread;
  // port_rewiring_lock
  union anonymous_7 port_rewiring_lock;
  // holder_threads
  struct anonymous_11 *holder_threads;
  // holder_thread_count
  unsigned int holder_thread_count;
};

struct xine_video_port_s_0
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct xine_video_port_s_0 *);
  // open
  void (*open)(struct xine_video_port_s_0 *, struct xine_stream_s *);
  // get_frame
  struct vo_frame_s_0 * (*get_frame)(struct xine_video_port_s_0 *, unsigned int, unsigned int, double, signed int, signed int);
  // new_grab_video_frame
  struct xine_grab_video_frame_s * (*new_grab_video_frame)(struct xine_video_port_s_0 *);
  // get_last_frame
  struct vo_frame_s_0 * (*get_last_frame)(struct xine_video_port_s_0 *);
  // enable_ovl
  void (*enable_ovl)(struct xine_video_port_s_0 *, signed int);
  // get_overlay_manager
  struct video_overlay_manager_s_0 * (*get_overlay_manager)(struct xine_video_port_s_0 *);
  // flush
  void (*flush)(struct xine_video_port_s_0 *);
  // trigger_drawing
  void (*trigger_drawing)(struct xine_video_port_s_0 *);
  // get_property
  signed int (*get_property)(struct xine_video_port_s_0 *, signed int);
  // set_property
  signed int (*set_property)(struct xine_video_port_s_0 *, signed int, signed int);
  // status
  signed int (*status)(struct xine_video_port_s_0 *, struct xine_stream_s *, signed int *, signed int *, signed long int *);
  // close
  void (*close)(struct xine_video_port_s_0 *, struct xine_stream_s *);
  // exit
  void (*exit)(struct xine_video_port_s_0 *);
  // driver
  struct vo_driver_s_0 *driver;
};


// LogToSysLog
// file logdefs.c line 23
signed int LogToSysLog = 1;
// SysLogLevel
// file xine_frontend_main.c line 37
signed int SysLogLevel = 2;
// bindTexImage
// file xine_sxfe_frontend.c line 254
void (*bindTexImage)(struct _XDisplay *, unsigned long int, signed int, signed int *);
// cookie
// file tools/gnome_screensaver.c line 60
static unsigned int cookie;
// fd_lirc
// file xine_frontend_lirc.c line 59
static volatile signed int fd_lirc = -1;
// fe_creator
// file xine_sxfe_frontend.c line 3215
struct frontend_s * (* const fe_creator)(void);
// fe_creator
// file xine_sxfe_frontend.c line 3215
struct frontend_s * (* const fe_creator)(void) = sxfe_get_frontend;
// gui_hotkeys
// file xine_frontend_main.c line 40
signed int gui_hotkeys = 0;
// help_str
// file xine_frontend_main.c line 91
static const char help_str[3442l] = { 'W', 'h', 'e', 'n', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'g', 'i', 'v', 'e', 'n', ',', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'i', 's', ' ', 's', 'e', 'a', 'r', 'c', 'h', 'e', 'd', ' ', 'f', 'r', 'o', 'm', ' ', 'l', 'o', 'c', 'a', 'l', ' ', 'n', 'e', 't', 'w', 'o', 'r', 'k', '.', '\n', 'I', 'f', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'o', 'u', 'n', 'd', ',', ' ', 'l', 'o', 'c', 'a', 'l', 'h', 'o', 's', 't', ' ', '(', '1', '2', '7', '.', '0', '.', '0', '.', '1', ')', ' ', 'i', 's', ' ', 'u', 's', 'e', 'd', ' ', 'a', 's', ' ', 'd', 'e', 'f', 'a', 'u', 'l', 't', '.', '\n', '\n', ' ', ' ', ' ', '-', 'H', ',', ' ', '-', '-', 'h', 'e', 'l', 'p', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'S', 'h', 'o', 'w', ' ', '(', 't', 'h', 'i', 's', ')', ' ', 'h', 'e', 'l', 'p', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', '\n', ' ', ' ', ' ', '-', 'A', ',', ' ', '-', '-', 'a', 'u', 'd', 'i', 'o', '=', 'a', 'u', 'd', 'i', 'o', 'd', 'r', 'i', 'v', 'e', 'r', '[', ':', 'd', 'e', 'v', 'i', 'c', 'e', ']', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'S', 'e', 'l', 'e', 'c', 't', ' ', 'a', 'u', 'd', 'i', 'o', ' ', 'd', 'r', 'i', 'v', 'e', 'r', ' ', 'a', 'n', 'd', ' ', 'o', 'p', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'p', 'o', 'r', 't', '\n', ' ', ' ', ' ', '-', 'V', ',', ' ', '-', '-', 'v', 'i', 'd', 'e', 'o', '=', 'v', 'i', 'd', 'e', 'o', 'd', 'r', 'i', 'v', 'e', 'r', '[', ':', 'd', 'e', 'v', 'i', 'c', 'e', ']', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'S', 'e', 'l', 'e', 'c', 't', ' ', 'v', 'i', 'd', 'e', 'o', ' ', 'd', 'r', 'i', 'v', 'e', 'r', ' ', 'a', 'n', 'd', ' ', 'o', 'p', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'p', 'o', 'r', 't', '\n', ' ', ' ', ' ', '-', 'd', ',', ' ', '-', '-', 'd', 'i', 's', 'p', 'l', 'a', 'y', '=', 'd', 'i', 's', 'p', 'l', 'a', 'y', 'a', 'd', 'd', 'r', 'e', 's', 's', ' ', ' ', 'X', '1', '1', ' ', 'd', 'i', 's', 'p', 'l', 'a', 'y', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', '\n', ' ', ' ', ' ', '-', 'W', ',', ' ', '-', '-', 'w', 'i', 'd', '=', 'i', 'd', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'U', 's', 'e', ' ', 'e', 'x', 'i', 's', 't', 'i', 'n', 'g', ' ', 'X', '1', '1', ' ', 'w', 'i', 'n', 'd', 'o', 'w', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'S', 'p', 'e', 'c', 'i', 'a', 'l', ' ', 'I', 'D', ' ', 'f', 'o', 'r', ' ', 'r', 'o', 'o', 't', ' ', 'w', 'i', 'n', 'd', 'o', 'w', ':', ' ', '-', '-', 'w', 'i', 'd', '=', 'r', 'o', 'o', 't', '\n', ' ', ' ', ' ', '-', 'a', ',', ' ', '-', '-', 'a', 's', 'p', 'e', 'c', 't', '=', '[', 'a', 'u', 't', 'o', '|', '4', ':', '3', '|', '1', '6', ':', '9', '|', '1', '6', ':', '1', '0', '|', 'd', 'e', 'f', 'a', 'u', 'l', 't', ']', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'D', 'i', 's', 'p', 'l', 'a', 'y', ' ', 'a', 's', 'p', 'e', 'c', 't', ' ', 'r', 'a', 't', 'i', 'o', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'U', 's', 'e', ' ', 's', 'c', 'r', 'i', 'p', 't', ' ', 't', 'o', ' ', 'c', 'o', 'n', 't', 'r', 'o', 'l', ' ', 'H', 'W', ' ', 'a', 's', 'p', 'e', 'c', 't', ' ', 'r', 'a', 't', 'i', 'o', ':', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '-', '-', 'a', 's', 'p', 'e', 'c', 't', '=', 'a', 'u', 't', 'o', ':', 'p', 'a', 't', 'h', '_', 't', 'o', '_', 's', 'c', 'r', 'i', 'p', 't', '\n', ' ', ' ', ' ', '-', 'f', ',', ' ', '-', '-', 'f', 'u', 'l', 'l', 's', 'c', 'r', 'e', 'e', 'n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'F', 'u', 'l', 'l', 's', 'c', 'r', 'e', 'e', 'n', ' ', 'm', 'o', 'd', 'e', '\n', ' ', ' ', ' ', '-', 'D', ',', ' ', '-', '-', 'h', 'u', 'd', '[', '=', 'f', 'l', 'a', 'g', '[', ',', 'f', 'l', 'a', 'g', ']', ']', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'a', 'd', ' ', 'U', 'p', ' ', 'D', 'i', 's', 'p', 'l', 'a', 'y', ' ', 'O', 'S', 'D', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'O', 'p', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'f', 'l', 'a', 'g', 's', ':', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'x', 's', 'h', 'a', 'p', 'e', ' ', ' ', 'U', 's', 'e', ' ', 'X', 'S', 'h', 'a', 'p', 'e', ' ', 'i', 'n', 's', 't', 'e', 'a', 'd', ' ', 'o', 'f', ' ', 'c', 'o', 'm', 'p', 'o', 's', 'i', 't', 'i', 'n', 'g', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '(', 'n', 'o', ' ', 'c', 'o', 'm', 'p', 'o', 's', 'i', 't', 'i', 'n', 'g', ' ', 'm', 'a', 'n', 'a', 'g', 'e', 'r', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', ')', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'o', 'p', 'e', 'n', 'g', 'l', ' ', ' ', 'U', 's', 'e', ' ', 'O', 'p', 'e', 'n', 'G', 'L', ' ', 'i', 'n', 's', 't', 'e', 'a', 'd', ' ', 'o', 'f', ' ', 'c', 'o', 'm', 'p', 'o', 's', 'i', 't', 'i', 'n', 'g', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '(', 'n', 'o', ' ', 'c', 'o', 'm', 'p', 'o', 's', 'i', 't', 'i', 'n', 'g', ' ', 'm', 'a', 'n', 'a', 'g', 'e', 'r', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', ')', '\n', ' ', ' ', ' ', '-', 'O', ',', ' ', '-', '-', 'o', 'p', 'e', 'n', 'g', 'l', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'U', 's', 'e', ' ', 'O', 'p', 'e', 'n', 'G', 'L', ' ', 'f', 'o', 'r', ' ', 'v', 'i', 'd', 'e', 'o', ' ', 'a', 'n', 'd', ' ', 'H', 'e', 'a', 'd', ' ', 'U', 'p', ' ', 'D', 'i', 's', 'p', 'l', 'a', 'y', ' ', 'O', 'S', 'D', '\n', ' ', ' ', ' ', '-', 'w', ',', ' ', '-', '-', 'w', 'i', 'd', 't', 'h', '=', 'x', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'V', 'i', 'd', 'e', 'o', ' ', 'w', 'i', 'n', 'd', 'o', 'w', ' ', 'w', 'i', 'd', 't', 'h', '\n', ' ', ' ', ' ', '-', 'h', ',', ' ', '-', '-', 'h', 'e', 'i', 'g', 'h', 't', '=', 'x', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'V', 'i', 'd', 'e', 'o', ' ', 'w', 'i', 'n', 'd', 'o', 'w', ' ', 'h', 'e', 'i', 'g', 'h', 't', '\n', ' ', ' ', ' ', '-', 'g', ',', ' ', '-', '-', 'g', 'e', 'o', 'm', 'e', 't', 'r', 'y', '=', 'W', 'x', 'H', '[', '+', 'X', '+', 'Y', ']', ' ', ' ', ' ', ' ', ' ', ' ', 'S', 'e', 't', ' ', 'o', 'u', 't', 'p', 'u', 't', ' ', 'w', 'i', 'n', 'd', 'o', 'w', ' ', 'g', 'e', 'o', 'm', 'e', 't', 'r', 'y', ' ', '(', 'X', ' ', 's', 't', 'y', 'l', 'e', ')', '\n', ' ', ' ', ' ', '-', 'B', ',', ' ', '-', '-', 'b', 'u', 'f', 'f', 'e', 'r', 's', '=', 'x', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'N', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f', ' ', 'P', 'E', 'S', ' ', 'b', 'u', 'f', 'f', 'e', 'r', 's', '\n', ' ', ' ', ' ', '-', 'n', ',', ' ', '-', '-', 'n', 'o', 's', 'c', 'a', 'l', 'i', 'n', 'g', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'D', 'i', 's', 'a', 'b', 'l', 'e', ' ', 'a', 'l', 'l', ' ', 'v', 'i', 'd', 'e', 'o', ' ', 's', 'c', 'a', 'l', 'i', 'n', 'g', '\n', ' ', ' ', ' ', '-', 'P', ',', ' ', '-', '-', 'p', 'o', 's', 't', '=', 'n', 'a', 'm', 'e', '[', ':', 'a', 'r', 'g', '=', 'v', 'a', 'l', '[', ',', 'a', 'r', 'g', '=', 'v', 'a', 'l', ']', ']', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'L', 'o', 'a', 'd', ' ', 'a', 'n', 'd', ' ', 'u', 's', 'e', ' ', 'x', 'i', 'n', 'e', ' ', 'p', 'o', 's', 't', ' ', 'p', 'l', 'u', 'g', 'i', 'n', '(', 's', ')', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'E', 'x', 'a', 'm', 'p', 'l', 'e', 's', ':', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '-', '-', 'p', 'o', 's', 't', '=', 'u', 'p', 'm', 'i', 'x', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '-', '-', 'p', 'o', 's', 't', '=', 'u', 'p', 'm', 'i', 'x', ';', 't', 'v', 't', 'i', 'm', 'e', ':', 'e', 'n', 'a', 'b', 'l', 'e', 'd', '=', '1', ',', 'c', 'h', 'e', 'a', 'p', '_', 'm', 'o', 'd', 'e', '=', '1', '\n', ' ', ' ', ' ', '-', 'L', ',', ' ', '-', '-', 'l', 'i', 'r', 'c', '[', '=', 'd', 'e', 'v', 'i', 'c', 'e', 'n', 'a', 'm', 'e', ']', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'U', 's', 'e', ' ', 'l', 'i', 'r', 'c', ' ', 'i', 'n', 'p', 'u', 't', ' ', 'd', 'e', 'v', 'i', 'c', 'e', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'O', 'p', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'l', 'i', 'r', 'c', ' ', 's', 'o', 'c', 'k', 'e', 't', ' ', 'n', 'a', 'm', 'e', ' ', 'c', 'a', 'n', ' ', 'b', 'e', ' ', 'g', 'i', 'v', 'e', 'n', '\n', ' ', ' ', ' ', '-', 'C', ',', ' ', '-', '-', 'c', 'o', 'n', 'f', 'i', 'g', '=', 'f', 'i', 'l', 'e', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'U', 's', 'e', ' ', 'c', 'o', 'n', 'f', 'i', 'g', ' ', 'f', 'i', 'l', 'e', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ':', ' ', 126, '/', '.', 'x', 'i', 'n', 'e', '/', 'c', 'o', 'n', 'f', 'i', 'g', '_', 'x', 'i', 'n', 'e', 'l', 'i', 'b', 'o', 'u', 't', 'p', 'u', 't', ')', '.', '\n', ' ', ' ', ' ', '-', 'v', ',', ' ', '-', '-', 'v', 'e', 'r', 'b', 'o', 's', 'e', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'V', 'e', 'r', 'b', 'o', 's', 'e', ' ', 'd', 'e', 'b', 'u', 'g', ' ', 'o', 'u', 't', 'p', 'u', 't', '\n', ' ', ' ', ' ', '-', 's', ',', ' ', '-', '-', 's', 'i', 'l', 'e', 'n', 't', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'S', 'i', 'l', 'e', 'n', 't', ' ', 'm', 'o', 'd', 'e', ' ', '(', 'r', 'e', 'p', 'o', 'r', 't', ' ', 'o', 'n', 'l', 'y', ' ', 'e', 'r', 'r', 'o', 'r', 's', ')', '\n', ' ', ' ', ' ', '-', 'l', ',', ' ', '-', '-', 's', 'y', 's', 'l', 'o', 'g', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'W', 'r', 'i', 't', 'e', ' ', 'a', 'l', 'l', ' ', 'o', 'u', 't', 'p', 'u', 't', ' ', 't', 'o', ' ', 's', 'y', 's', 't', 'e', 'm', ' ', 'l', 'o', 'g', '\n', ' ', ' ', ' ', '-', 'k', ',', ' ', '-', '-', 'n', 'o', 'k', 'b', 'd', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'D', 'i', 's', 'a', 'b', 'l', 'e', ' ', 'c', 'o', 'n', 's', 'o', 'l', 'e', ' ', 'k', 'e', 'y', 'b', 'o', 'a', 'r', 'd', ' ', 'i', 'n', 'p', 'u', 't', '\n', ' ', ' ', ' ', '-', 'x', ',', ' ', '-', '-', 'n', 'o', 'x', 'k', 'b', 'd', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'D', 'i', 's', 'a', 'b', 'l', 'e', ' ', 'X', '1', '1', ' ', 'k', 'e', 'y', 'b', 'o', 'a', 'r', 'd', ' ', 'i', 'n', 'p', 'u', 't', '\n', ' ', ' ', ' ', '-', 'o', ',', ' ', '-', '-', 'h', 'o', 't', 'k', 'e', 'y', 's', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'E', 'n', 'a', 'b', 'l', 'e', ' ', 'f', 'r', 'o', 'n', 't', 'e', 'n', 'd', ' ', 'G', 'U', 'I', ' ', 'h', 'o', 't', 'k', 'e', 'y', 's', '\n', ' ', ' ', ' ', '-', 'U', ',', ' ', '-', '-', 't', 'o', 'u', 'c', 'h', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'E', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', 'u', 'c', 'h', ' ', 's', 'c', 'r', 'e', 'e', 'n', ' ', 'r', 'e', 'm', 'o', 't', 'e', ' ', 'c', 'o', 'n', 't', 'r', 'o', 'l', 'l', 'e', 'r', '\n', ' ', ' ', ' ', '-', 'p', ',', ' ', '-', '-', 's', 'h', 'u', 't', 'd', 'o', 'w', 'n', '=', 'M', 'I', 'N', '[', ':', 'C', 'M', 'D', ']', ' ', ' ', ' ', ' ', ' ', ' ', 'S', 'h', 'u', 't', 'd', 'o', 'w', 'n', ' ', 'a', 'f', 't', 'e', 'r', ' ', 'M', 'I', 'N', ' ', 'm', 'i', 'n', 'u', 't', 'e', 's', ' ', 'o', 'f', ' ', 'i', 'n', 'a', 'c', 't', 'i', 'v', 'i', 't', 'y', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'U', 's', 'e', ' ', 'C', 'M', 'D', ' ', 't', 'o', ' ', 'p', 'e', 'r', 'f', 'o', 'r', 'm', ' ', 's', 'h', 'u', 't', 'd', 'o', 'w', 'n', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ':', ' ', '/', 's', 'b', 'i', 'n', '/', 's', 'h', 'u', 't', 'd', 'o', 'w', 'n', ')', '\n', ' ', ' ', ' ', '-', 'T', ',', ' ', '-', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 'l', '=', 'd', 'e', 'v', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'C', 'o', 'n', 't', 'r', 'o', 'l', 'l', 'i', 'n', 'g', ' ', 'T', 'T', 'Y', '\n', ' ', ' ', ' ', '-', 'b', ',', ' ', '-', '-', 'd', 'a', 'e', 'm', 'o', 'n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'R', 'u', 'n', ' ', 'a', 's', ' ', 'd', 'a', 'e', 'm', 'o', 'n', ' ', '(', 'd', 'i', 's', 'a', 'b', 'l', 'e', ' ', 'k', 'e', 'y', 'b', 'o', 'a', 'r', 'd', ',', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'l', 'o', 'g', ' ', 't', 'o', ' ', 's', 'y', 's', 'l', 'o', 'g', ' ', 'a', 'n', 'd', ' ', 'f', 'o', 'r', 'k', ' ', 't', 'o', ' ', 'b', 'a', 'c', 'k', 'g', 'r', 'o', 'u', 'n', 'd', ')', '\n', ' ', ' ', ' ', '-', 'S', ',', ' ', '-', '-', 's', 'l', 'a', 'v', 'e', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'E', 'n', 'a', 'b', 'l', 'e', ' ', 's', 'l', 'a', 'v', 'e', ' ', 'm', 'o', 'd', 'e', ' ', '(', 'r', 'e', 'a', 'd', ' ', 'c', 'o', 'm', 'm', 'a', 'n', 'd', 's', ' ', 'f', 'r', 'o', 'm', ' ', 's', 't', 'd', 'i', 'n', ')', '\n', ' ', ' ', ' ', '-', 'R', ',', ' ', '-', '-', 'r', 'e', 'c', 'o', 'n', 'n', 'e', 'c', 't', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'A', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', 'l', 'l', 'y', ' ', 'r', 'e', 'c', 'o', 'n', 'n', 'e', 'c', 't', ' ', 'w', 'h', 'e', 'n', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'h', 'a', 's', ' ', 'b', 'e', 'e', 'n', ' ', 'l', 'o', 's', 't', '\n', ' ', ' ', ' ', '-', 't', ',', ' ', '-', '-', 't', 'c', 'p', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'U', 's', 'e', ' ', 'T', 'C', 'P', ' ', 't', 'r', 'a', 'n', 's', 'p', 'o', 'r', 't', '\n', ' ', ' ', ' ', '-', 'u', ',', ' ', '-', '-', 'u', 'd', 'p', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'U', 's', 'e', ' ', 'U', 'D', 'P', ' ', 't', 'r', 'a', 'n', 's', 'p', 'o', 'r', 't', '\n', ' ', ' ', ' ', '-', 'r', ',', ' ', '-', '-', 'r', 't', 'p', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'U', 's', 'e', ' ', 'R', 'T', 'P', ' ', 't', 'r', 'a', 'n', 's', 'p', 'o', 'r', 't', '\n', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'I', 'f', ' ', 'n', 'o', ' ', 't', 'r', 'a', 'n', 's', 'p', 'o', 'r', 't', ' ', 'o', 'p', 't', 'i', 'o', 'n', 's', ' ', 'a', 'r', 'e', ' ', 'g', 'i', 'v', 'e', 'n', ',', ' ', 't', 'r', 'a', 'n', 's', 'p', 'o', 'r', 't', 's', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'a', 'r', 'e', ' ', 't', 'r', 'i', 'e', 'd', ' ', 'i', 'n', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'o', 'r', 'd', 'e', 'r', ':', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'l', 'o', 'c', 'a', 'l', ' ', 'p', 'i', 'p', 'e', ',', ' ', 'r', 't', 'p', ',', ' ', 'u', 'd', 'p', ',', ' ', 't', 'c', 'p', '\n', '\n', 0 };
// kbd_thread
// file xine_frontend_kbd.c line 35
static unsigned long int kbd_thread;
// last_signal
// file xine_frontend_main.c line 39
volatile signed int last_signal = 0;
// lirc_device_name
// file xine_frontend_lirc.c line 58
static const volatile char *lirc_device_name = (const volatile char *)(void *)0;
// lirc_repeat_emu
// file xine_frontend_lirc.c line 60
static signed int lirc_repeat_emu = 0;
// lirc_thread
// file xine_frontend_lirc.c line 57
static unsigned long int lirc_thread;
// long_options
// file xine_frontend_main.c line 179
static struct option long_options[33l] = { { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=72 },
    { .name="audio", .has_arg=1, .flag=(signed int *)(void *)0, .val=65 },
    { .name="video", .has_arg=1, .flag=(signed int *)(void *)0, .val=86 },
    { .name="aspect", .has_arg=1, .flag=(signed int *)(void *)0, .val=97 },
    { .name="display", .has_arg=1, .flag=(signed int *)(void *)0, .val=100 },
    { .name="wid", .has_arg=1, .flag=(signed int *)(void *)0, .val=87 },
    { .name="fullscreen", .has_arg=0, .flag=(signed int *)(void *)0, .val=102 },
    { .name="geometry", .has_arg=1, .flag=(signed int *)(void *)0, .val=103 },
    { .name="hud", .has_arg=2, .flag=(signed int *)(void *)0, .val=68 },
    { .name="opengl", .has_arg=0, .flag=(signed int *)(void *)0, .val=79 },
    { .name="width", .has_arg=1, .flag=(signed int *)(void *)0, .val=119 },
    { .name="height", .has_arg=1, .flag=(signed int *)(void *)0, .val=104 },
    { .name="buffers", .has_arg=1, .flag=(signed int *)(void *)0, .val=66 },
    { .name="noscaling", .has_arg=0, .flag=(signed int *)(void *)0, .val=110 },
    { .name="post", .has_arg=1, .flag=(signed int *)(void *)0, .val=80 },
    { .name="lirc", .has_arg=2, .flag=(signed int *)(void *)0, .val=76 },
    { .name="config", .has_arg=1, .flag=(signed int *)(void *)0, .val=67 },
    { .name="terminal", .has_arg=1, .flag=(signed int *)(void *)0, .val=84 },
    { .name="shutdown", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="verbose", .has_arg=0, .flag=(signed int *)(void *)0, .val=118 },
    { .name="silent", .has_arg=0, .flag=(signed int *)(void *)0, .val=115 },
    { .name="syslog", .has_arg=0, .flag=(signed int *)(void *)0, .val=108 },
    { .name="nokbd", .has_arg=0, .flag=(signed int *)(void *)0, .val=107 },
    { .name="noxkbd", .has_arg=0, .flag=(signed int *)(void *)0, .val=120 },
    { .name="hotkeys", .has_arg=0, .flag=(signed int *)(void *)0, .val=111 },
    { .name="touch", .has_arg=0, .flag=(signed int *)(void *)0, .val=85 },
    { .name="daemon", .has_arg=0, .flag=(signed int *)(void *)0, .val=98 },
    { .name="slave", .has_arg=0, .flag=(signed int *)(void *)0, .val=83 },
    { .name="reconnect", .has_arg=0, .flag=(signed int *)(void *)0, .val=82 },
    { .name="tcp", .has_arg=0, .flag=(signed int *)(void *)0, .val=116 },
    { .name="udp", .has_arg=0, .flag=(signed int *)(void *)0, .val=117 },
    { .name="rtp", .has_arg=0, .flag=(signed int *)(void *)0, .val=114 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// saved_tm
// file xine_frontend_kbd.c line 36
static struct termios saved_tm;
// short_options
// file xine_frontend_main.c line 177
static const char short_options[49l] = { 'H', 'A', ':', 'V', ':', 'd', ':', 'W', ':', 'a', ':', 'f', 'g', ':', 'D', 'w', ':', 'h', ':', 'B', ':', 'n', 'P', ':', 'L', ':', 'C', ':', 'T', ':', 'p', ':', 'v', 's', 'x', 'l', 'k', 'o', 'O', 'e', 'E', 'b', 'S', 'R', 't', 'u', 'U', 'r', 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// tm
// file xine_frontend_kbd.c line 36
static struct termios tm;
// xine_fast_memcpy
// file /usr/include/xine/xineutils.h line 123
extern void * (*xine_fast_memcpy)(void *, const void *, unsigned long int);

// JpegCompressEmptyOutputBuffer
// file xine_frontend.c line 1669
static signed int JpegCompressEmptyOutputBuffer(struct jpeg_compress_struct * const cinfo)
{
  struct tJpegCompressData_s *jcd = (struct tJpegCompressData_s *)cinfo->client_data;
  if(!(jcd == ((struct tJpegCompressData_s *)NULL)))
  {
    signed int Used = jcd->size;
    jcd->size = jcd->size + 500000;
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)jcd->mem, (unsigned long int)jcd->size);
    jcd->mem = (unsigned char *)return_value_realloc_1;
    if(!(jcd->mem == ((unsigned char *)NULL)))
    {
      cinfo->dest->next_output_byte = jcd->mem + (signed long int)Used;
      cinfo->dest->free_in_buffer = (unsigned long int)(jcd->size - Used);
      return 1;
    }

  }

  return 0;
}

// JpegCompressInitDestination
// file xine_frontend.c line 1659
static void JpegCompressInitDestination(struct jpeg_compress_struct * const cinfo)
{
  struct tJpegCompressData_s *jcd = (struct tJpegCompressData_s *)cinfo->client_data;
  if(!(jcd == ((struct tJpegCompressData_s *)NULL)))
  {
    jcd->size = 500000;
    cinfo->dest->free_in_buffer = (unsigned long int)jcd->size;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)jcd->size);
    jcd->mem = (unsigned char *)return_value_malloc_1;
    cinfo->dest->next_output_byte = jcd->mem;
  }

}

// JpegCompressTermDestination
// file xine_frontend.c line 1685
static void JpegCompressTermDestination(struct jpeg_compress_struct * const cinfo)
{
  struct tJpegCompressData_s *jcd = (struct tJpegCompressData_s *)cinfo->client_data;
  if(!(jcd == ((struct tJpegCompressData_s *)NULL)))
  {
    signed int Used = (signed int)(cinfo->dest->next_output_byte - jcd->mem);
    if(!(Used >= jcd->size))
    {
      jcd->size = Used;
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)jcd->mem, (unsigned long int)jcd->size);
      jcd->mem = (unsigned char *)return_value_realloc_1;
    }

  }

}

// SignalHandler
// file xine_frontend_main.c line 45
static void SignalHandler(signed int signum)
{
  do
    if(SysLogLevel >= 2)
      x_syslog(6, "[vdr-fe]    ", "caught signal %d", signum);

  while((_Bool)0);
  switch(signum)
  {
    case 1:
      last_signal = signum;
    case 13:
      break;
    default:
    {
      if(!(last_signal == 0))
      {
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-fe]    ", "SignalHandler: exit(-1)");

        while((_Bool)0);
        exit(-1);
      }

      last_signal = signum;
    }
  }
  signal(signum, SignalHandler);
}

// XButtonEvent_handler
// file xine_sxfe_frontend.c line 2884
static void XButtonEvent_handler(struct sxfe_s *this, struct anonymous_37 *bev)
{
  switch(bev->button)
  {
    case (unsigned int)1:
    {
      if(!(this->touchscreen == 0))
      {
        signed int x = (bev->x * 4) / (signed int)this->_anon0.x.width;
        signed int y = (bev->y * 3) / (signed int)this->_anon0.x.height;
        static const char * const map[3l][4l] = { { "Menu", "Up", "Back", "Ok" }, { "Left", "Down", "Right", "Ok" }, { "Red", "Green", "Yellow", "Blue" } };
        if(!(map[(signed long int)y][(signed long int)x] == ((const char *)NULL)))
        {
          char tmp[128l];
          sprintf(tmp, "KEY %s", map[(signed long int)y][(signed long int)x]);
          this->_anon0.x.fe.send_event((struct frontend_s *)this, tmp);
        }

        break;
      }

      if(!(bev->time + -this->prev_click_time >= 500ul))
      {
        this->_anon0.x.toggle_fullscreen_cb(&this->_anon0.x, -1);
        this->prev_click_time = (unsigned long int)0;
      }

      else
      {
        this->prev_click_time = bev->time;
        if(this->fullscreen == 0)
        {
          if(!(this->no_border == 0))
          {
            if(this->dragging == 0)
            {
              this->dragging = (unsigned char)1;
              this->dragging_x = (unsigned short int)bev->x_root;
              this->dragging_y = (unsigned short int)bev->y_root;
            }

          }

        }

      }
      break;
    }
    case (unsigned int)3:
      if(this->fullscreen == 0)
      {
        if(this->stay_above == 0)
          set_above(this, 1);

        else
          if(this->no_border == 0)
          {
            set_border(this, this->window[(signed long int)0], 0);
            this->no_border = (unsigned char)1;
          }

          else
          {
            set_border(this, this->window[(signed long int)0], 1);
            this->no_border = (unsigned char)0;
            set_above(this, 0);
          }
      }

  }
}

// XConfigureEvent_handler
// file xine_sxfe_frontend.c line 2758
static void XConfigureEvent_handler(struct sxfe_s *this, struct anonymous_51 *cev)
{
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_7;
  if(!(cev->window == this->opengl_window))
  {
    if(!(cev->window == (unsigned long int)this->window_id))
    {
      if(!(cev->window == this->root_window))
        goto __CPROVER_DUMP_L6;

      if(!(this->fullscreen == 0))
      {
        if(!(cev->width == (signed int)this->_anon0.x.width))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = cev->height != (signed int)this->_anon0.x.height ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          do
            if(SysLogLevel >= 2)
              x_syslog(6, "[vdr-sxfe]  ", "Root window size changed. Resizing video window from %dx%d to %dx%d", this->_anon0.x.width, this->_anon0.x.height, cev->width, cev->height);

          while((_Bool)0);
          XLockDisplay(this->display);
          XResizeWindow(this->display, this->window[(signed long int)1], (unsigned int)cev->width, (unsigned int)cev->height);
          XMoveWindow(this->display, this->window[(signed long int)1], (signed int)this->xinerama_x, (signed int)this->xinerama_y);
          XUnlockDisplay(this->display);
        }

      }

    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      if(!(this->hud == 0))
        hud_osd_resize(this, cev->window, cev->width, cev->height);

      if(!((signed int)this->_anon0.x.width == cev->width))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)this->_anon0.x.height != cev->height ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        if(!(this->fullscreen == 0))
          tmp_if_expr_2 = this->window[(signed long int)1] == cev->window ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          if(this->fullscreen == 0)
            tmp_if_expr_3 = this->window[(signed long int)0] == cev->window ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          do
            if(SysLogLevel >= 3)
              x_syslog(7, "[vdr-sxfe]  ", "Video window size changed from %dx%d to %dx%d", this->_anon0.x.width, this->_anon0.x.height, cev->width, cev->height);

          while((_Bool)0);
          this->_anon0.x.width = (unsigned short int)cev->width;
          this->_anon0.x.height = (unsigned short int)cev->height;
          char str[128l];
          snprintf(str, sizeof(char [128l]) /*128ul*/ , "INFO WINDOW %dx%d", this->_anon0.x.width, this->_anon0.x.height);
          this->_anon0.x.fe.send_event((struct frontend_s *)this, str);
        }

      }

      if(this->window[0l] == cev->window)
      {
        if(!(this->check_move == 0))
        {
          do
            if(SysLogLevel >= 3)
              x_syslog(7, "[vdr-sxfe]  ", "ConfigureNotify reveived with x=%d, y=%d, check_move=%d", cev->x, cev->y, this->check_move);

          while((_Bool)0);
          this->check_move = (unsigned char)0;
          if(!((signed int)this->_anon0.x.xpos == cev->x))
          {
            if(!((signed int)this->_anon0.x.ypos == cev->y))
            {
              XLockDisplay(this->display);
              XMoveWindow(this->display, this->window[(signed long int)0], cev->x, cev->y);
              XUnlockDisplay(this->display);
            }

          }

        }

      }

      if(this->fullscreen == 0)
      {
        if(cev->x == 0)
          tmp_if_expr_7 = cev->y == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
        {
          signed int tmp_x;
          signed int tmp_y;
          unsigned long int tmp_win;
          XLockDisplay(this->display);
          signed int return_value_XTranslateCoordinates_6;
          return_value_XTranslateCoordinates_6=XTranslateCoordinates(this->display, cev->window, this->root_window, 0, 0, &tmp_x, &tmp_y, &tmp_win);
          if(!(return_value_XTranslateCoordinates_6 == 0))
          {
            this->_anon0.x.xpos = (unsigned short int)tmp_x;
            this->_anon0.x.ypos = (unsigned short int)tmp_y;
          }

          XUnlockDisplay(this->display);
        }

        else
        {
          this->_anon0.x.xpos = (unsigned short int)cev->x;
          this->_anon0.x.ypos = (unsigned short int)cev->y;
        }
      }

    }
  }

}

// XKeyEvent_handler
// file xine_sxfe_frontend.c line 2687
static void XKeyEvent_handler(struct sxfe_s *this, struct anonymous_36 *kev)
{
  if(!(kev->keycode == 0u))
  {
    if(kev->type == 2)
    {
      unsigned long int ks;
      char buffer[20l];
      struct _XComposeStatus status;
      const char *fe_event = (const char *)(void *)0;
      const char *ks_name;
      XLockDisplay(this->display);
      XLookupString(kev, buffer, (signed int)sizeof(char [20l]) /*20ul*/ , &ks, &status);
      ks_name=XKeysymToString(ks);
      XUnlockDisplay(this->display);
      switch(ks)
      {
        case (unsigned long int)0x0066:

        case (unsigned long int)0x0046:
        {
          if(!(this->gui_hotkeys == 0))
            fe_event = "TOGGLE_FULLSCREEN";

          break;
        }
        case (unsigned long int)0x0064:

        case (unsigned long int)0x0044:
        {
          if(!(this->gui_hotkeys == 0))
            fe_event = "TOGGLE_DEINTERLACE";

          break;
        }
        case (unsigned long int)0x0070:

        case (unsigned long int)0x0050:
        {
          if(!(this->gui_hotkeys == 0))
            fe_event = "POWER_OFF";

          break;
        }
        case (unsigned long int)0xff1b:
          if(this->_anon0.fe.fe_message_cb == ((void (*)(void *, const char *, const char *))NULL))
            fe_event = "QUIT";

      }
      if(!(fe_event == ((const char *)NULL)))
        this->_anon0.x.fe.send_event((struct frontend_s *)this, fe_event);

      else
        if(this->no_x_kbd == 0)
        {
          if(!(ks_name == ((const char *)NULL)))
          {
            char keyname[40l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
            if(!((12u & kev->state) == 0u))
            {
              if(!((8u & kev->state) == 0u))
                strcat(keyname, "Alt+");

              if(!((4u & kev->state) == 0u))
                strcat(keyname, "Ctrl+");

              strncat(keyname, ks_name, sizeof(char [40l]) /*40ul*/  - (unsigned long int)11);
              ks_name = keyname;
            }

            this->_anon0.x.fe.send_input_event((struct frontend_s *)this, "XKeySym", ks_name, 0, 0);
          }

        }

    }

  }

}

// XMotionEvent_handler
// file xine_sxfe_frontend.c line 2843
static void XMotionEvent_handler(struct sxfe_s *this, struct anonymous_38 *mev)
{
  if(!(this->mousecursor_timeout >= 1))
    set_cursor(this->display, this->window[(signed long int)(this->fullscreen != 0 ? 1 : 0)], 1);

  this->mousecursor_timeout = 2000;
  signed int return_value_XCheckMaskEvent_1;
  if(!(this->dragging == 0))
  {
    if(this->fullscreen == 0)
    {
      unsigned long int tmp_win;
      signed int xpos;
      signed int ypos;
      XLockDisplay(this->display);
      do
      {
        return_value_XCheckMaskEvent_1=XCheckMaskEvent(this->display, 1L << 13, (union _XEvent *)mev);
        if(return_value_XCheckMaskEvent_1 == 0)
          break;

      }
      while((_Bool)1);
      XTranslateCoordinates(this->display, this->window[(signed long int)0], this->root_window, 0, 0, &xpos, &ypos, &tmp_win);
      xpos = xpos + (mev->x_root - (signed int)this->dragging_x);
      this->_anon0.x.xpos = (unsigned short int)xpos;
      ypos = ypos + (mev->y_root - (signed int)this->dragging_y);
      this->_anon0.x.ypos = (unsigned short int)ypos;
      this->dragging_x = (unsigned short int)mev->x_root;
      this->dragging_y = (unsigned short int)mev->y_root;
      XMoveWindow(this->display, this->window[(signed long int)0], xpos, ypos);
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-sxfe]  ", "MotionNotify: XMoveWindow called with x=%d and y=%d", xpos, ypos);

      while((_Bool)0);
      XUnlockDisplay(this->display);
    }

  }

}

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// __pplugin_retrieve_parameters
// file xine/post.c line 62
static signed int __pplugin_retrieve_parameters(struct anonymous_72 *pobj)
{
  struct xine_post_in_s *input_api;
  struct xine_post_in_s *return_value_xine_post_input_5;
  return_value_xine_post_input_5=xine_post_input(pobj->post, "parameters");
  input_api = (struct xine_post_in_s *)return_value_xine_post_input_5;
  void *return_value_calloc_2;
  void *return_value_realloc_3;
  if(!(input_api == ((struct xine_post_in_s *)NULL)))
  {
    struct anonymous_69 *post_api;
    struct anonymous_70 *api_descr;
    struct anonymous_71 *parm;
    signed int pnum = 0;
    post_api = (struct anonymous_69 *)input_api->data;
    api_descr=post_api->get_param_descr();
    parm = api_descr->parameter;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)api_descr->struct_size);
    pobj->param_data = (char *)return_value_malloc_1;
    if(!(parm->type == 0))
    {
      post_api->get_parameters(pobj->post, (void *)pobj->param_data);
      if(pnum == 0)
      {
        return_value_calloc_2=calloc((unsigned long int)2, sizeof(char *) /*8ul*/ );
        pobj->properties_names = (char **)return_value_calloc_2;
      }

      else
      {
        return_value_realloc_3=realloc((void *)pobj->properties_names, sizeof(char *) /*8ul*/  * (unsigned long int)(pnum + 2));
        pobj->properties_names = (char **)return_value_realloc_3;
      }
      char *return_value___strdup_4;
      return_value___strdup_4=__strdup(parm->name);
      pobj->properties_names[(signed long int)pnum] = return_value___strdup_4;
      pobj->properties_names[(signed long int)(pnum + 1)] = (char *)(void *)0;
      pnum = pnum + 1;
      parm = parm + 1l;
    }

    pobj->api = post_api;
    pobj->descr = api_descr;
    pobj->param = api_descr->parameter;
    return 1;
  }

  return 0;
}

// __pplugin_update_parameters
// file xine/post.c line 112
static void __pplugin_update_parameters(struct xine_post_s_0 *post, char *args)
{
  char *p;
  struct anonymous_72 pobj = { .post=post, .api=((struct anonymous_69 *)NULL), .descr=((struct anonymous_70 *)NULL),
    .param=((struct anonymous_71 *)NULL),
    .param_data=((char *)NULL),
    .x=0, .y=0, .readonly=0,
    .properties_names=((char **)NULL) };
  signed int return_value___pplugin_retrieve_parameters_10;
  return_value___pplugin_retrieve_parameters_10=__pplugin_retrieve_parameters(&pobj);
  char *tmp_statement_expression_1;
  unsigned long int return_value_strlen_9;
  char *tmp_post_3;
  signed int return_value_strcasecmp_4;
  signed long int return_value_strtol_6;
  if(!(return_value___pplugin_retrieve_parameters_10 == 0))
  {
    signed int i;
    if(!(pobj.properties_names == ((char **)NULL)) && !(args == ((char *)NULL)))
    {
      if(!(*args == 0))
      {
        char *param;
        do
        {
          char __r0;
          char __r1;
          char __r2;
          char *return_value___strsep_g_2;
          return_value___strsep_g_2=__strsep_g(&args, ",");
          tmp_statement_expression_1 = return_value___strsep_g_2;
          param = tmp_statement_expression_1;
          if(param == ((char *)NULL))
            break;

          p = param;
          for( ; !((signed int)*p == 0); p = p + 1l)
            if((signed int)*p == 61)
              break;

          if(!(p == ((char *)NULL)))
          {
            return_value_strlen_9=strlen(p);
            if(!(return_value_strlen_9 == 0ul))
            {
              signed int param_num = 0;
              tmp_post_3 = p;
              p = p + 1l;
              *tmp_post_3 = (char)0;
              for( ; !(pobj.properties_names[(signed long int)param_num] == ((char *)NULL)); param_num = param_num + 1)
              {
                return_value_strcasecmp_4=strcasecmp(pobj.properties_names[(signed long int)param_num], param);
                if(return_value_strcasecmp_4 == 0)
                  break;

              }
              if(!(pobj.properties_names[(signed long int)param_num] == ((char *)NULL)))
              {
                pobj.param = pobj.descr->parameter;
                pobj.param = pobj.param + (signed long int)param_num;
                pobj.readonly = pobj.param->readonly;
                switch(pobj.param->type)
                {
                  case 1:
                  {
                    if(pobj.readonly == 0)
                    {
                      if(!(pobj.param->enum_values == ((char **)NULL)))
                      {
                        char **values = pobj.param->enum_values;
                        signed int __pplugin_update_parameters__1__1__1__2__1__1__1__1__1__i = 0;
                        while(!(values[(signed long int)__pplugin_update_parameters__1__1__1__2__1__1__1__1__1__i] == ((char *)NULL)))
                        {
                          signed int return_value_strcasecmp_5;
                          return_value_strcasecmp_5=strcasecmp(values[(signed long int)__pplugin_update_parameters__1__1__1__2__1__1__1__1__1__i], p);
                          if(return_value_strcasecmp_5 == 0)
                          {
                            *((signed int *)(pobj.param_data + (signed long int)pobj.param->offset)) = __pplugin_update_parameters__1__1__1__2__1__1__1__1__1__i;
                            break;
                          }

                          __pplugin_update_parameters__1__1__1__2__1__1__1__1__1__i = __pplugin_update_parameters__1__1__1__2__1__1__1__1__1__i + 1;
                        }
                        if(values[(signed long int)__pplugin_update_parameters__1__1__1__2__1__1__1__1__1__i] == ((char *)NULL))
                        {
                          return_value_strtol_6=strtol(p, &p, 10);
                          *((signed int *)(pobj.param_data + (signed long int)pobj.param->offset)) = (signed int)return_value_strtol_6;
                        }

                      }

                      else
                      {
                        signed long int return_value_strtol_7;
                        return_value_strtol_7=strtol(p, &p, 10);
                        *((signed int *)(pobj.param_data + (signed long int)pobj.param->offset)) = (signed int)return_value_strtol_7;
                      }
                      _pplugin_update_parameter(&pobj);
                    }

                    break;
                  }
                  case 2:
                  {
                    if(pobj.readonly == 0)
                    {
                      *((double *)(pobj.param_data + (signed long int)pobj.param->offset))=strtod(p, &p);
                      _pplugin_update_parameter(&pobj);
                    }

                    break;
                  }
                  case 3:

                  case 4:
                  {
                    if(pobj.readonly == 0)
                    {
                      if(pobj.param->type == 3)
                      {
                        signed int maxlen = (signed int)((unsigned long int)pobj.param->size / sizeof(char) /*1ul*/ );
                        snprintf_link2((char *)(pobj.param_data + (signed long int)pobj.param->offset), (unsigned long int)maxlen, "%s", p);
                        _pplugin_update_parameter(&pobj);
                      }

                      else
                        fprintf_link1(stderr, "parameter type POST_PARAM_TYPE_STRING not supported yet.\n");
                    }

                    break;
                  }
                  case 5:
                  {
                    if(pobj.readonly == 0)
                      fprintf_link1(stderr, "parameter type POST_PARAM_TYPE_STRINGLIST not supported yet.\n");

                    break;
                  }
                  case 6:
                  {
                    if(pobj.readonly == 0)
                    {
                      signed long int return_value_strtol_8;
                      return_value_strtol_8=strtol(p, &p, 10);
                      *((signed int *)(pobj.param_data + (signed long int)pobj.param->offset)) = (signed int)return_value_strtol_8 != 0 ? 1 : 0;
                      _pplugin_update_parameter(&pobj);
                    }

                    break;
                  }
                  case 0:
                    break;
                  default:
                    do
                      if(SysLogLevel >= 2)
                        x_syslog(6, "[xine-post] ", "%s(%d): Unknown post parameter type %d!", (const void *)"__pplugin_update_parameters", 206, pobj.param->type);

                    while((_Bool)0);
                }
              }

              else
                do
                  if(SysLogLevel >= 2)
                    x_syslog(6, "[xine-post] ", "Unknown post plugin parameter %s !", param);

                while((_Bool)0);
            }

          }

        }
        while((_Bool)1);
        i = 0;
        for( ; !(pobj.properties_names[(signed long int)i] == ((char *)NULL)); i = i + 1)
          free((void *)pobj.properties_names[(signed long int)i]);
        free((void *)pobj.properties_names);
      }

    }

    free((void *)pobj.param_data);
  }

}

// __strpbrk_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1100
static inline char * __strpbrk_c2(const char *__s, signed int __accept1, signed int __accept2)
{
  for( ; !((signed int)*__s == 0); __s = __s + 1l)
  {
    if((signed int)*__s == __accept1)
      break;

    if((signed int)*__s == __accept2)
      break;

  }
  return (signed int)*__s == 0 ? (char *)(void *)0 : (char *)(unsigned long int)__s;
}

// __strpbrk_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1111
static inline char * __strpbrk_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3)
{
  for( ; !((signed int)*__s == 0); __s = __s + 1l)
  {
    if((signed int)*__s == __accept1)
      break;

    if((signed int)*__s == __accept2)
      break;

    if((signed int)*__s == __accept3)
      break;

  }
  return (signed int)*__s == 0 ? (char *)(void *)0 : (char *)(unsigned long int)__s;
}

// __strsep_1c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c(char **__s, char __reject)
{
  char *__retval = *__s;
  char *return_value___builtin_strchr_2;
  char *tmp_post_1;
  if(!(__retval == ((char *)NULL)))
  {
    return_value___builtin_strchr_2=__builtin_strchr(__retval, (signed int)__reject);
    *__s = return_value___builtin_strchr_2;
    if(!(*__s == ((char *)NULL)))
    {
      tmp_post_1 = *__s;
      *__s = *__s + 1l;
      *tmp_post_1 = (char)0;
    }

  }

  return __retval;
}

// __strsep_2c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c(char **__s, char __reject1, char __reject2)
{
  char *__retval = *__s;
  _Bool tmp_if_expr_2;
  char *tmp_post_1;
  if(!(__retval == ((char *)NULL)))
  {
    char *__cp = __retval;
    for( ; (_Bool)1; __cp = __cp + 1l)
    {
      if((signed int)*__cp == 0)
      {
        __cp = (char *)(void *)0;
        break;
      }

      if(*__cp == __reject1)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = *__cp == __reject2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        tmp_post_1 = __cp;
        __cp = __cp + 1l;
        *tmp_post_1 = (char)0;
        break;
      }

    }
    *__s = __cp;
  }

  return __retval;
}

// __strsep_3c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c(char **__s, char __reject1, char __reject2, char __reject3)
{
  char *__retval = *__s;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  char *tmp_post_1;
  if(!(__retval == ((char *)NULL)))
  {
    char *__cp = __retval;
    for( ; (_Bool)1; __cp = __cp + 1l)
    {
      if((signed int)*__cp == 0)
      {
        __cp = (char *)(void *)0;
        break;
      }

      if(*__cp == __reject1)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = *__cp == __reject2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = *__cp == __reject3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
      {
        tmp_post_1 = __cp;
        __cp = __cp + 1l;
        *tmp_post_1 = (char)0;
        break;
      }

    }
    *__s = __cp;
  }

  return __retval;
}

// _applugin_enable_post
// file xine/post.c line 692
static signed int _applugin_enable_post(struct post_plugins_s_0 *fe, const char *name, const char *args, signed int *found)
{
  signed int result = 0;
  if(*found == 0)
    result=_pplugin_enable_post(fe, name, args, fe->post_audio_elements, fe->post_audio_elements_num, found);

  if(*found == 0)
    result=_pplugin_enable_post(fe, name, args, fe->post_vis_elements, fe->post_vis_elements_num, found);

  return result;
}

// _applugin_rewire
// file xine/post.c line 614
static void _applugin_rewire(struct post_plugins_s_0 *fe)
{
  signed int post_elements_num;
  static struct anonymous_73 **post_elements;
  post_elements=_pplugin_join_visualization_and_post_elements(fe, &post_elements_num);
  if(!(post_elements == ((struct anonymous_73 **)NULL)))
  {
    _applugin_rewire_from_post_elements(fe, post_elements, post_elements_num);
    free((void *)post_elements);
  }

}

// _applugin_rewire_from_post_elements
// file xine/post.c line 452
static void _applugin_rewire_from_post_elements(struct post_plugins_s_0 *fe, struct anonymous_73 **post_elements, signed int post_elements_num)
{
  if(!(post_elements_num == 0))
  {
    struct xine_post_out_s *ao_source;
    signed int i = 0;
    i = post_elements_num - 1;
    for( ; i >= 0; i = i - 1)
    {
      const char * const *outs;
      outs=xine_post_list_outputs(post_elements[(signed long int)i]->post);
      const struct xine_post_out_s *ao_out;
      ao_out=xine_post_output(post_elements[(signed long int)i]->post, (char *)*outs);
      if(i == post_elements_num + -1)
      {
        do
          if(SysLogLevel >= 3)
            x_syslog(7, "[xine-post] ", "        wiring %10s[out] -> [in]audio_out", post_elements[(signed long int)i]->name);

        while((_Bool)0);
        xine_post_wire_audio_port((struct xine_post_out_s *)ao_out, fe->audio_port);
      }

      else
      {
        const struct xine_post_in_s *ao_in;
        ao_in=xine_post_input(post_elements[(signed long int)(i + 1)]->post, "audio");
        if(ao_in == ((const struct xine_post_in_s *)NULL))
          ao_in=xine_post_input(post_elements[(signed long int)(i + 1)]->post, "audio in");

        do
          if(SysLogLevel >= 3)
            x_syslog(7, "[xine-post] ", "        wiring %10s[out] -> [in]%-10s ", post_elements[(signed long int)i]->name, post_elements[(signed long int)(i + 1)]->name);

        while((_Bool)0);
        xine_post_wire((struct xine_post_out_s *)ao_out, (struct xine_post_in_s *)ao_in);
      }
    }
    ao_source=xine_get_audio_source(fe->audio_source);
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[xine-post] ", "        wiring %10s[out] -> [in]%-10s", (const void *)"stream", post_elements[(signed long int)0]->name);

    while((_Bool)0);
    xine_post_wire_audio_port(ao_source, post_elements[(signed long int)0]->post->audio_input[(signed long int)0]);
  }

}

// _applugin_unwire
// file xine/post.c line 399
static void _applugin_unwire(struct post_plugins_s_0 *fe)
{
  struct xine_post_out_s *ao_source;
  ao_source=xine_get_audio_source(fe->audio_source);
  xine_post_wire_audio_port(ao_source, fe->audio_port);
}

// _pp_args
// file xine/post.c line 715
static const char * _pp_args(const char *initstr)
{
  char *pt;
  char *return_value___builtin_strchr_1;
  return_value___builtin_strchr_1=__builtin_strchr(initstr, 58);
  pt = return_value___builtin_strchr_1;
  if(!(pt == ((char *)NULL)))
  {
    if(pt[1l] == 0)
      goto __CPROVER_DUMP_L1;

    return pt + (signed long int)1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (const char *)(void *)0;
  }
}

// _pp_name_strdup
// file xine/post.c line 705
static char * _pp_name_strdup(const char *initstr)
{
  char *name;
  char *return_value___strdup_1;
  return_value___strdup_1=__strdup(initstr);
  name = return_value___strdup_1;
  char *pt;
  char *return_value___builtin_strchr_2;
  return_value___builtin_strchr_2=__builtin_strchr(name, 58);
  pt = return_value___builtin_strchr_2;
  if(!(pt == ((char *)NULL)))
    *pt = (char)0;

  return name;
}

// _pplugin_disable_post
// file xine/post.c line 779
static signed int _pplugin_disable_post(struct post_plugins_s_0 *fe, const char *name, struct anonymous_73 **post_elements, signed int post_elements_num)
{
  signed int i;
  signed int result = 0;
  _Bool tmp_if_expr_3;
  signed int tmp_statement_expression_1;
  if(!(post_elements == ((struct anonymous_73 **)NULL)))
  {
    i = 0;
    for( ; !(i >= post_elements_num); i = i + 1)
      if(!(post_elements[(signed long int)i] == ((struct anonymous_73 *)NULL)))
      {
        if(name == ((const char *)NULL))
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_2;
          return_value___builtin_strcmp_2=__builtin_strcmp(post_elements[(signed long int)i]->name, name);
          tmp_statement_expression_1 = return_value___builtin_strcmp_2;
          tmp_if_expr_3 = !(tmp_statement_expression_1 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          if(post_elements[(signed long int)i]->enable == 1)
          {
            post_elements[(signed long int)i]->enable = 0;
            result = 1;
          }

        }

      }

  }

  return result;
}

// _pplugin_enable_post
// file xine/post.c line 642
static signed int _pplugin_enable_post(struct post_plugins_s_0 *fe, const char *name, const char *args, struct anonymous_73 **post_elements, signed int post_elements_num, signed int *found)
{
  signed int i;
  signed int result = 0;
  i = 0;
  signed int tmp_statement_expression_4;
  char *tmp_if_expr_3;
  for( ; !(i >= post_elements_num); i = i + 1)
    if(!(post_elements[(signed long int)i] == ((struct anonymous_73 *)NULL)))
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_5;
      return_value___builtin_strcmp_5=__builtin_strcmp(post_elements[(signed long int)i]->name, name);
      tmp_statement_expression_4 = return_value___builtin_strcmp_5;
      if(tmp_statement_expression_4 == 0)
      {
        if(post_elements[(signed long int)i]->enable == 0)
        {
          post_elements[(signed long int)i]->enable = 1;
          result = 1;
        }

        *found = 1;
        if(!(args == ((const char *)NULL)))
        {
          if(!(*args == 0))
          {
            if(!(post_elements[(signed long int)i]->enable == 2))
            {
              char *tmp;
              char *return_value___strdup_1;
              return_value___strdup_1=__strdup(args);
              tmp = return_value___strdup_1;
              __pplugin_update_parameters(post_elements[(signed long int)i]->post, tmp);
              free((void *)tmp);
              if(!(post_elements[(signed long int)i]->args == ((char *)NULL)))
                free((void *)post_elements[(signed long int)i]->args);

              char *return_value___strdup_2;
              return_value___strdup_2=__strdup(args);
              post_elements[(signed long int)i]->args = return_value___strdup_2;
            }

            else
            {
              do
                if(SysLogLevel >= 3)
                  x_syslog(7, "[xine-post] ", "  * enable post %s, parameters fixed in command line.", name);

              while((_Bool)0);
              do
                if(SysLogLevel >= 3)
                  x_syslog(7, "[xine-post] ", "      requested: %s", (_Bool)args ? args : "none");

              while((_Bool)0);
              do
                if(SysLogLevel >= 3)
                {
                  if(!(post_elements[(signed long int)i]->args == ((char *)NULL)))
                    tmp_if_expr_3 = post_elements[(signed long int)i]->args;

                  else
                    tmp_if_expr_3 = "none";
                  x_syslog(7, "[xine-post] ", "      using    : %s", tmp_if_expr_3);
                }

              while((_Bool)0);
            }
          }

        }

      }

    }

  return result;
}

// _pplugin_join_deinterlace_and_post_elements
// file xine/post.c line 486
static struct anonymous_73 ** _pplugin_join_deinterlace_and_post_elements(struct post_plugins_s_0 *fe, signed int *post_elements_num)
{
  struct anonymous_73 **post_elements;
  signed int i = 0;
  signed int j = 0;
  signed int n = 0;
  signed int p = 0;
  *post_elements_num = 0;
  if(!(fe->post_video_enable == 0))
    *post_elements_num = *post_elements_num + fe->post_video_elements_num;

  if(!(fe->post_pip_enable == 0))
    *post_elements_num = *post_elements_num + fe->post_pip_elements_num;

  signed int tmp_statement_expression_2;
  if(*post_elements_num == 0)
    return (struct anonymous_73 **)(void *)0;

  else
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)*post_elements_num, sizeof(struct anonymous_73 *) /*8ul*/ );
    post_elements = (struct anonymous_73 **)return_value_calloc_1;
    if(!(fe->post_pip_enable == 0))
    {
      i = 0;
      for( ; !(i >= fe->post_pip_elements_num); i = i + 1)
        if(!(fe->post_pip_elements[(signed long int)i]->enable == 0))
          post_elements[(signed long int)((i + j) - n)] = fe->post_pip_elements[(signed long int)i];

        else
          n = n + 1;
    }

    if(!(fe->post_video_enable == 0))
    {
      j = 0;
      for( ; !(j >= fe->post_video_elements_num); j = j + 1)
        if(!(fe->post_video_elements[(signed long int)j]->enable == 0))
          post_elements[(signed long int)((i + j) - n)] = fe->post_video_elements[(signed long int)j];

        else
          n = n + 1;
    }

    *post_elements_num = *post_elements_num - n;
    if(*post_elements_num == 0)
    {
      free((void *)post_elements);
      return (struct anonymous_73 **)(void *)0;
    }

    else
    {
      n = 0;
      static const char *order[5l] = { "autocrop", "thread", "tvtime", "swscale", (const char *)(void *)0 };
      for( ; !(order[(signed long int)p] == ((const char *)NULL)); p = p + 1)
      {
        i = 0;
        for( ; !(i >= *post_elements_num); i = i + 1)
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_3;
          return_value___builtin_strcmp_3=__builtin_strcmp(post_elements[(signed long int)i]->name, order[(signed long int)p]);
          tmp_statement_expression_2 = return_value___builtin_strcmp_3;
          if(tmp_statement_expression_2 == 0)
          {
            if(!(i == n))
            {
              struct anonymous_73 *tmp = post_elements[(signed long int)i];
              j = i;
              for( ; !(n >= j); j = j - 1)
                post_elements[(signed long int)j] = post_elements[(signed long int)(j - 1)];
              post_elements[(signed long int)n] = tmp;
              do
                if(SysLogLevel >= 3)
                  x_syslog(7, "[xine-post] ", "      moved %s to post slot %d", order[(signed long int)p], n);

              while((_Bool)0);
            }

            n = n + 1;
            break;
          }

        }
      }
      return post_elements;
    }
  }
}

// _pplugin_join_visualization_and_post_elements
// file xine/post.c line 558
static struct anonymous_73 ** _pplugin_join_visualization_and_post_elements(struct post_plugins_s_0 *fe, signed int *post_elements_num)
{
  struct anonymous_73 **post_elements;
  signed int i = 0;
  signed int j = 0;
  signed int n = 0;
  *post_elements_num = 0;
  if(!(fe->post_audio_enable == 0))
    *post_elements_num = *post_elements_num + fe->post_audio_elements_num;

  if(!(fe->post_vis_enable == 0))
    *post_elements_num = *post_elements_num + fe->post_vis_elements_num;

  if(*post_elements_num == 0)
    return (struct anonymous_73 **)(void *)0;

  else
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)*post_elements_num, sizeof(struct anonymous_73 *) /*8ul*/ );
    post_elements = (struct anonymous_73 **)return_value_calloc_1;
    if(!(fe->post_audio_enable == 0))
    {
      j = 0;
      for( ; !(j >= fe->post_audio_elements_num); j = j + 1)
        if(!(fe->post_audio_elements[(signed long int)j]->enable == 0))
          post_elements[(signed long int)((i + j) - n)] = fe->post_audio_elements[(signed long int)j];

        else
          n = n + 1;
    }

    if(!(fe->post_vis_enable == 0))
    {
      i = 0;
      for( ; !(i >= fe->post_vis_elements_num); i = i + 1)
        if(!(fe->post_vis_elements[(signed long int)i]->enable == 0))
          post_elements[(signed long int)((i + j) - n)] = fe->post_vis_elements[(signed long int)i];

        else
          n = n + 1;
    }

    *post_elements_num = *post_elements_num - n;
    if(*post_elements_num == 0)
    {
      free((void *)post_elements);
      return (struct anonymous_73 **)(void *)0;
    }

    else
      return post_elements;
  }
}

// _pplugin_unload_post
// file xine/post.c line 822
static signed int _pplugin_unload_post(struct post_plugins_s_0 *fe, const char *name, struct anonymous_73 ***post_elements, signed int *post_elements_num)
{
  signed int i;
  signed int j;
  signed int result = 0;
  _Bool tmp_if_expr_1;
  if(*post_elements == ((struct anonymous_73 **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*post_elements_num != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  signed int tmp_statement_expression_2;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= *post_elements_num); i = i + 1)
      if(!((*post_elements)[(signed long int)i] == ((struct anonymous_73 *)NULL)))
      {
        if(name == ((const char *)NULL))
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_3;
          return_value___builtin_strcmp_3=__builtin_strcmp((*post_elements)[(signed long int)i]->name, name);
          tmp_statement_expression_2 = return_value___builtin_strcmp_3;
          tmp_if_expr_4 = !(tmp_statement_expression_2 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          if((*post_elements)[(signed long int)i]->enable == 0 || name == ((const char *)NULL))
          {
            xine_post_dispose(fe->xine, (*post_elements)[(signed long int)i]->post);
            free((void *)(*post_elements)[(signed long int)i]->name);
            if(!((*post_elements)[(signed long int)i]->args == ((char *)NULL)))
              free((void *)(*post_elements)[(signed long int)i]->args);

            free((void *)(*post_elements)[(signed long int)i]);
            j = i;
            for( ; !(j >= *post_elements_num + -1); j = j + 1)
              (*post_elements)[(signed long int)j] = (*post_elements)[(signed long int)(j + 1)];
            *post_elements_num = *post_elements_num - 1;
            (*post_elements)[(signed long int)*post_elements_num] = ((struct anonymous_73 *)NULL);
            result = 1;
            i = i - 1;
          }

          else
            do
              if(SysLogLevel >= 3)
                x_syslog(7, "[xine-post] ", "Unload %s failed: plugin enabled and in use", (*post_elements)[(signed long int)i]->name);

            while((_Bool)0);
        }

      }

    if(!(*post_elements_num >= 1))
    {
      if(!(*post_elements == ((struct anonymous_73 **)NULL)))
        free((void *)*post_elements);

      *post_elements = (struct anonymous_73 **)(void *)0;
    }

    return result;
  }
}

// _pplugin_update_parameter
// file xine/post.c line 106
static void _pplugin_update_parameter(struct anonymous_72 *pobj)
{
  pobj->api->set_parameters(pobj->post, (void *)pobj->param_data);
  pobj->api->get_parameters(pobj->post, (void *)pobj->param_data);
}

// _vpplugin_enable_post
// file xine/post.c line 679
static signed int _vpplugin_enable_post(struct post_plugins_s_0 *fe, const char *name, const char *args, signed int *found)
{
  signed int result = 0;
  if(*found == 0)
    result=_pplugin_enable_post(fe, name, args, fe->post_video_elements, fe->post_video_elements_num, found);

  if(*found == 0)
    result=_pplugin_enable_post(fe, name, args, fe->post_pip_elements, fe->post_pip_elements_num, found);

  return result;
}

// _vpplugin_rewire
// file xine/post.c line 600
static void _vpplugin_rewire(struct post_plugins_s_0 *fe)
{
  signed int post_elements_num;
  static struct anonymous_73 **post_elements;
  post_elements=_pplugin_join_deinterlace_and_post_elements(fe, &post_elements_num);
  if(!(post_elements == ((struct anonymous_73 **)NULL)))
  {
    _vpplugin_rewire_from_post_elements(fe, post_elements, post_elements_num);
    free((void *)post_elements);
  }

}

// _vpplugin_rewire_from_post_elements
// file xine/post.c line 407
static void _vpplugin_rewire_from_post_elements(struct post_plugins_s_0 *fe, struct anonymous_73 **post_elements, signed int post_elements_num)
{
  signed int tmp_statement_expression_1;
  if(!(post_elements_num == 0))
  {
    struct xine_post_out_s *vo_source;
    signed int i = 0;
    i = post_elements_num - 1;
    for( ; i >= 0; i = i - 1)
    {
      const char * const *outs;
      outs=xine_post_list_outputs(post_elements[(signed long int)i]->post);
      const struct xine_post_out_s *vo_out;
      vo_out=xine_post_output(post_elements[(signed long int)i]->post, (char *)*outs);
      if(i == post_elements_num + -1)
      {
        do
          if(SysLogLevel >= 3)
            x_syslog(7, "[xine-post] ", "        wiring %10s[out] -> [in]video_out", post_elements[(signed long int)i]->name);

        while((_Bool)0);
        xine_post_wire_video_port((struct xine_post_out_s *)vo_out, fe->video_port);
      }

      else
      {
        const struct xine_post_in_s *vo_in;
        vo_in=xine_post_input(post_elements[(signed long int)(i + 1)]->post, "video");
        if(vo_in == ((const struct xine_post_in_s *)NULL))
          vo_in=xine_post_input(post_elements[(signed long int)(i + 1)]->post, "video in");

        do
          if(SysLogLevel >= 3)
            x_syslog(7, "[xine-post] ", "        wiring %10s[out] -> [in]%-10s ", post_elements[(signed long int)i]->name, post_elements[(signed long int)(i + 1)]->name);

        while((_Bool)0);
        xine_post_wire((struct xine_post_out_s *)vo_out, (struct xine_post_in_s *)vo_in);
      }
    }
    if(!(fe->post_pip_enable == 0))
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_2;
      return_value___builtin_strcmp_2=__builtin_strcmp(post_elements[(signed long int)0]->name, "mosaico");
      tmp_statement_expression_1 = return_value___builtin_strcmp_2;
      if(tmp_statement_expression_1 == 0)
      {
        if(!(fe->pip_stream == ((struct xine_stream_s_0 *)NULL)))
        {
          vo_source=xine_get_video_source(fe->pip_stream);
          do
            if(SysLogLevel >= 3)
              x_syslog(7, "[xine-post] ", "        wiring %10s[out] -> [in1]%-10s ", (const void *)"pip stream", post_elements[(signed long int)0]->name);

          while((_Bool)0);
          xine_post_wire_video_port(vo_source, post_elements[(signed long int)0]->post->video_input[(signed long int)1]);
        }

      }

    }

    vo_source=xine_get_video_source(fe->video_source);
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[xine-post] ", "        wiring %10s[out] -> [in]%-10s", (const void *)"stream", post_elements[(signed long int)0]->name);

    while((_Bool)0);
    xine_post_wire_video_port(vo_source, post_elements[(signed long int)0]->post->video_input[(signed long int)0]);
  }

}

// _vpplugin_unwire
// file xine/post.c line 391
static void _vpplugin_unwire(struct post_plugins_s_0 *fe)
{
  struct xine_post_out_s *vo_source;
  vo_source=xine_get_video_source(fe->video_source);
  xine_post_wire_video_port(vo_source, fe->video_port);
}

// applugin_disable_post
// file xine/post.c line 809
signed int applugin_disable_post(struct post_plugins_s_0 *fe, const char *name)
{
  signed int return_value__pplugin_disable_post_1;
  return_value__pplugin_disable_post_1=_pplugin_disable_post(fe, name, fe->post_audio_elements, fe->post_audio_elements_num);
  _Bool tmp_if_expr_3;
  signed int return_value__pplugin_disable_post_2;
  if(!(return_value__pplugin_disable_post_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value__pplugin_disable_post_2=_pplugin_disable_post(fe, name, fe->post_vis_elements, fe->post_vis_elements_num);
    tmp_if_expr_3 = return_value__pplugin_disable_post_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    _applugin_unwire(fe);
    return 1;
  }

  else
    return 0;
}

// applugin_enable_post
// file xine/post.c line 751
signed int applugin_enable_post(struct post_plugins_s_0 *fe, const char *initstr, signed int *found)
{
  const char *args;
  args=_pp_args(initstr);
  char *name;
  name=_pp_name_strdup(initstr);
  signed int result;
  result=_applugin_enable_post(fe, name, args, found);
  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[xine-post] ", "  * enable post %s --> %s, %s", name, *found != 0 ? "found" : "not found", result != 0 ? "enabled" : "no action");

  while((_Bool)0);
  if(*found == 0)
  {
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[xine-post] ", "  * loading post %s", initstr);

    while((_Bool)0);
    applugin_parse_and_store_post(fe, initstr);
    result=_applugin_enable_post(fe, name, (const char *)(void *)0, found);
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[xine-post] ", "  * enable post %s --> %s, %s", name, *found != 0 ? "found" : "not found", result != 0 ? "enabled" : "no action");

    while((_Bool)0);
  }

  if(!(result == 0))
    _applugin_unwire(fe);

  free((void *)name);
  return result;
}

// applugin_parse_and_store_post
// file xine/post.c line 384
void applugin_parse_and_store_post(struct post_plugins_s_0 *fe, const char *post_chain)
{
  pplugin_parse_and_store_post(fe, 0x020000, post_chain);
  pplugin_parse_and_store_post(fe, 0x020001, post_chain);
}

// applugin_rewire_posts
// file xine/post.c line 635
void applugin_rewire_posts(struct post_plugins_s_0 *fe)
{
  _applugin_unwire(fe);
  _applugin_rewire(fe);
}

// applugin_unload_post
// file xine/post.c line 887
signed int applugin_unload_post(struct post_plugins_s_0 *fe, const char *name)
{
  signed int result;
  result=applugin_disable_post(fe, name);
  _pplugin_unload_post(fe, name, &fe->post_audio_elements, &fe->post_audio_elements_num);
  _pplugin_unload_post(fe, name, &fe->post_vis_elements, &fe->post_vis_elements_num);
  return result;
}

// asprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 176
static inline signed int asprintf(char ** restrict __ptr, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack_1;
  return_value___builtin_va_arg_pack_1=__builtin_va_arg_pack();
  signed int return_value___asprintf_chk_2;
  return_value___asprintf_chk_2=__asprintf_chk(__ptr, 2 - 1, __fmt, return_value___builtin_va_arg_pack_1);
  return return_value___asprintf_chk_2;
}

// asprintf_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 176
static inline signed int asprintf_link1(char ** restrict __ptr_link1, const char * restrict __fmt_link1, ...)
{
  void *return_value___builtin_va_arg_pack_1_link1;
  return_value___builtin_va_arg_pack_1_link1=__builtin_va_arg_pack();
  signed int return_value___asprintf_chk_2_link1;
  return_value___asprintf_chk_2_link1=__asprintf_chk(__ptr_link1, 2 - 1, __fmt_link1, return_value___builtin_va_arg_pack_1_link1);
  return return_value___asprintf_chk_2_link1;
}

// asprintf_link2
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 176
static inline signed int asprintf_link2(char ** restrict __ptr_link2, const char * restrict __fmt_link2, ...)
{
  void *return_value___builtin_va_arg_pack_1_link2;
  return_value___builtin_va_arg_pack_1_link2=__builtin_va_arg_pack();
  signed int return_value___asprintf_chk_2_link2;
  return_value___asprintf_chk_2_link2=__asprintf_chk(__ptr_link2, 2 - 1, __fmt_link2, return_value___builtin_va_arg_pack_1_link2);
  return return_value___asprintf_chk_2_link2;
}

// asprintf_link3
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 176
static inline signed int asprintf_link3(char ** restrict __ptr_link3, const char * restrict __fmt_link3, ...)
{
  void *return_value___builtin_va_arg_pack_1_link3;
  return_value___builtin_va_arg_pack_1_link3=__builtin_va_arg_pack();
  signed int return_value___asprintf_chk_2_link3;
  return_value___asprintf_chk_2_link3=__asprintf_chk(__ptr_link3, 2 - 1, __fmt_link3, return_value___builtin_va_arg_pack_1_link3);
  return return_value___asprintf_chk_2_link3;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1)
{
  signed long int return_value_strtol_1_link1;
  return_value_strtol_1_link1=strtol(__nptr_link1, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link1;
}

// cec_start
// file xine_frontend_cec.h line 16
void cec_start(struct frontend_s *fe, signed int hdmi_port, signed int dev_type)
{
  ;
}

// cec_stop
// file xine_frontend_cec.h line 17
void cec_stop(void)
{
  ;
}

// check_for_scaling
// file xine/vo_osdscaler.c line 236
static signed int check_for_scaling(struct anonymous_80 *this, struct vo_frame_s *frame, struct vo_overlay_s *overlay)
{
  signed int extent_width;
  signed int extent_height;
  this->y_move = (unsigned short int)0;
  this->x_move = this->y_move;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  signed int tmp_if_expr_6;
  _Bool tmp_if_expr_8;
  signed int tmp_if_expr_7;
  if(this->enable == 0)
  {
    do
      if(SysLogLevel >= 4)
        x_syslog(7, "[osdscaler] ", "check_for_scaling(): scaling disabled in config");

    while((_Bool)0);
    return 0;
  }

  else
    if(overlay->rle == ((struct rle_elem_s *)NULL))
    {
      do
        if(SysLogLevel >= 4)
          x_syslog(7, "[osdscaler] ", "check_for_scaling(): no overlay->rle");

      while((_Bool)0);
      return 0;
    }

    else
      if(!(overlay->argb_layer == ((struct argb_layer_s *)NULL)))
      {
        do
          if(SysLogLevel >= 4)
            x_syslog(7, "[osdscaler] ", "check_for_scaling(): overlay has argb layer");

        while((_Bool)0);
        return 0;
      }

      else
        if(!(overlay->hili_rgb_clut == -9999))
        {
          if(frame->stream == ((struct xine_stream_s_0 *)NULL))
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = frame->stream == (struct xine_stream_s_0 *)-1 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_1)
            return 0;

          return 0;
        }

        else
        {
          struct anonymous_81 *data = (struct anonymous_81 *)overlay->hili_color;
          extent_width = (signed int)data->extent_width;
          extent_height = (signed int)data->extent_height;
          if(!((signed int)data->scaling >= 1))
            return 0;

          else
            if(!(this->custom_extent_supported == 0))
            {
              overlay->extent_width = extent_width;
              overlay->extent_height = extent_height;
              return 0;
            }

            else
            {
              overlay->extent_width = 0;
              overlay->extent_height = 0;
              if(!(extent_height >= 128) || !(extent_width >= 128))
              {
                do
                  if(SysLogLevel >= 2)
                    x_syslog(6, "[osdscaler] ", "VDR overlay: invalid extent size %dx%d", extent_width, extent_height);

                while((_Bool)0);
                return 0;
              }

              else
              {
                if(!(overlay->unscaled == 0))
                  tmp_if_expr_4 = this->unscaled_supported != 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_4 = (_Bool)0;
                if(tmp_if_expr_4)
                {
                  signed int return_value_vo_def_get_property_2;
                  return_value_vo_def_get_property_2=vo_def_get_property((struct vo_driver_s *)this, 15);
                  this->output_width = (unsigned short int)return_value_vo_def_get_property_2;
                  signed int return_value_vo_def_get_property_3;
                  return_value_vo_def_get_property_3=vo_def_get_property((struct vo_driver_s *)this, 16);
                  this->output_height = (unsigned short int)return_value_vo_def_get_property_3;
                }

                else
                {
                  this->output_width = (unsigned short int)frame->width;
                  this->output_height = (unsigned short int)frame->height;
                  if(frame->crop_top >= 1)
                    this->output_height = this->output_height - (unsigned short int)frame->crop_top;

                  if(frame->crop_bottom >= 1)
                    this->output_height = this->output_height - (unsigned short int)frame->crop_bottom;

                  if(frame->crop_left >= 1)
                    this->output_width = this->output_width - (unsigned short int)frame->crop_left;

                  if(frame->crop_right >= 1)
                    this->output_width = this->output_width - (unsigned short int)frame->crop_right;

                }
                if(!((signed int)this->output_width >= 128))
                  tmp_if_expr_5 = (_Bool)1;

                else
                  tmp_if_expr_5 = (signed int)this->output_height < 128 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_5)
                {
                  do
                    if(SysLogLevel >= 2)
                      x_syslog(6, "[osdscaler] ", "invalid output dimensions: %dx%d", this->output_width, this->output_height);

                  while((_Bool)0);
                  return 0;
                }

                else
                {
                  if(!((signed int)this->output_width + -extent_width >= 0))
                    tmp_if_expr_6 = -((signed int)this->output_width - extent_width);

                  else
                    tmp_if_expr_6 = (signed int)this->output_width - extent_width;
                  if(!(extent_width / 20 >= tmp_if_expr_6))
                    tmp_if_expr_8 = (_Bool)1;

                  else
                  {
                    if(!((signed int)this->output_height + -extent_height >= 0))
                      tmp_if_expr_7 = -((signed int)this->output_height - extent_height);

                    else
                      tmp_if_expr_7 = (signed int)this->output_height - extent_height;
                    tmp_if_expr_8 = tmp_if_expr_7 > extent_height / 20 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_8)
                  {
                    this->factor_x = (unsigned int)((0x10000 * (signed int)this->output_width) / extent_width);
                    this->factor_y = (unsigned int)((0x10000 * (signed int)this->output_height) / extent_height);
                    return 1;
                  }

                  else
                  {
                    if(!((signed int)this->output_width == extent_width))
                      this->x_move = (unsigned short int)(((signed int)this->output_width - extent_width) / 2);

                    if(!((signed int)this->output_height == extent_height))
                      this->y_move = (unsigned short int)(((signed int)this->output_height - extent_height) / 2);

                    return 0;
                  }
                }
              }
            }
        }
}

// check_mouse_cursor_hide
// file xine_sxfe_frontend.c line 2946
static void check_mouse_cursor_hide(struct sxfe_s *this, signed long int elapsed)
{
  if(elapsed >= 1l && !(elapsed >= 500l))
  {
    this->mousecursor_timeout = this->mousecursor_timeout - (signed int)elapsed;
    if(!(this->mousecursor_timeout >= 1))
      set_cursor(this->display, this->window[(signed long int)(this->fullscreen != 0 ? 1 : 0)], 0);

  }

}

// configure_audio_out
// file xine_frontend.c line 455
static void configure_audio_out(const struct fe_s *this, const char *audio_driver, const char *audio_port)
{
  signed int tmp_statement_expression_5;
  unsigned long int return_value_strlen_4;
  _Bool tmp_if_expr_3;
  char *return_value_strstr_2;
  if(!(audio_driver == ((const char *)NULL)) && !(audio_port == ((const char *)NULL)))
  {
    unsigned long int configure_audio_out__1__1____s1_len;
    unsigned long int configure_audio_out__1__1____s2_len;
    signed int return_value___builtin_strcmp_6;
    return_value___builtin_strcmp_6=__builtin_strcmp("alsa", audio_driver);
    tmp_statement_expression_5 = return_value___builtin_strcmp_6;
    if(tmp_statement_expression_5 == 0)
    {
      return_value_strlen_4=strlen(audio_port);
      if(return_value_strlen_4 >= 1ul)
      {
        static char *speaker_arrangement[14l] = { "Mono 1.0", "Stereo 2.0", "Headphones 2.0", "Stereo 2.1", "Surround 3.0", "Surround 4.0", "Surround 4.1", "Surround 5.0", "Surround 5.1", "Surround 6.0", "Surround 6.1", "Surround 7.1", "Pass Through", (char *)(void *)0 };
        xine_config_register_enum(this->xine, "audio.output.speaker_arrangement", 1, speaker_arrangement, "speaker arrangement", "Select how your speakers are arranged, this determines which speakers xine uses for sound output. The individual values are:\n\nMono 1.0: You have only one speaker.\nStereo 2.0: You have two speakers for left and right channel.\nHeadphones 2.0: You use headphones.\nStereo 2.1: You have two speakers for left and right channel, and one subwoofer for the low frequencies.\nSurround 3.0: You have three speakers for left, right and rear channel.\nSurround 4.0: You have four speakers for front left and right and rear left and right channels.\nSurround 4.1: You have four speakers for front left and right and rear left and right channels, and one subwoofer for the low frequencies.\nSurround 5.0: You have five speakers for front left, center and right and rear left and right channels.\nSurround 5.1: You have five speakers for front left, center and right and rear left and right channels, and one subwoofer for the low frequencies.\nSurround 6.0: You have six speakers for front left, center and right and rear left, center and right channels.\nSurround 6.1: You have six speakers for front left, center and right and rear left, center and right channels, and one subwoofer for the low frequencies.\nSurround 7.1: You have seven speakers for front left, center and right, left and right and rear left and right channels, and one subwoofer for the low frequencies.\nPass Through: Your sound system will receive undecoded digital sound from xine. You need to connect a digital surround decoder capable of decoding the formats you want to play to your sound card's digital output.", 10, (void (*)(void *, struct xine_cfg_entry_s *))(void *)0, (void *)0);
        xine_config_register_string(this->xine, "audio.device.alsa_default_device", "default", "device used for mono output", "xine will use this alsa device to output mono sound.\nSee the alsa documentation for information on alsa devices.", 10, (void (*)(void *, struct xine_cfg_entry_s *))(void *)0, (void *)0);
        xine_config_register_string(this->xine, "audio.device.alsa_front_device", "plug:front:default", "device used for stereo output", "xine will use this alsa device to output stereo sound.\nSee the alsa documentation for information on alsa devices.", 10, (void (*)(void *, struct xine_cfg_entry_s *))(void *)0, (void *)0);
        xine_config_register_string(this->xine, "audio.device.alsa_surround51_device", "plug:surround51:0", "device used for 5.1-channel output", "xine will use this alsa device to output 5 channel plus LFE (5.1) surround sound.\nSee the alsa documentation for information on alsa devices.", 10, (void (*)(void *, struct xine_cfg_entry_s *))(void *)0, (void *)0);
        xine_config_register_string(this->xine, "audio.device.alsa_passthrough_device", "iec958:AES0=0x6,AES1=0x82,AES2=0x0,AES3=0x2", "device used for 5.1-channel output", "xine will use this alsa device to output undecoded digital surround sound. This can be used be external surround decoders.\nSee the alsa documentation for information on alsa devices.", 10, (void (*)(void *, struct xine_cfg_entry_s *))(void *)0, (void *)0);
        this->xine->config->update_string(this->xine->config, "audio.device.alsa_front_device", audio_port);
        this->xine->config->update_string(this->xine->config, "audio.device.alsa_default_device", audio_port);
        this->xine->config->update_string(this->xine->config, "audio.device.alsa_surround51_device", audio_port);
        char *return_value_strstr_1;
        return_value_strstr_1=strstr(audio_port, "iec");
        if(!(return_value_strstr_1 == ((char *)NULL)))
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_strstr_2=strstr(audio_port, "spdif");
          tmp_if_expr_3 = return_value_strstr_2 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          this->xine->config->update_string(this->xine->config, "audio.device.alsa_passthrough_device", audio_port);
          this->xine->config->update_num(this->xine->config, "audio.output.speaker_arrangement", 12);
        }

      }

    }

  }

  signed int tmp_statement_expression_13;
  signed int tmp_statement_expression_7;
  signed int return_value_sscanf_9;
  signed int return_value_sscanf_11;
  if(!(audio_driver == ((const char *)NULL)))
  {
    unsigned long int configure_audio_out__1__3____s1_len;
    unsigned long int configure_audio_out__1__3____s2_len;
    signed int return_value___builtin_strcmp_14;
    return_value___builtin_strcmp_14=__builtin_strcmp("oss", audio_driver);
    tmp_statement_expression_13 = return_value___builtin_strcmp_14;
    if(tmp_statement_expression_13 == 0)
    {
      if(!(audio_port == ((const char *)NULL)))
      {
        signed int devnum = -2;
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_8;
        return_value___builtin_strcmp_8=__builtin_strcmp("default", audio_port);
        tmp_statement_expression_7 = return_value___builtin_strcmp_8;
        if(tmp_statement_expression_7 == 0)
          devnum = -1;

        signed int return_value_strncmp_10;
        return_value_strncmp_10=strncmp("/dev/dsp", audio_port, (unsigned long int)8);
        if(return_value_strncmp_10 == 0)
        {
          return_value_sscanf_9=sscanf(audio_port + (signed long int)8, "%d", &devnum);
          if(!(return_value_sscanf_9 >= 1))
            devnum = -1;

        }

        signed int return_value_strncmp_12;
        return_value_strncmp_12=strncmp("/dev/sound/dsp", audio_port, (unsigned long int)14);
        if(return_value_strncmp_12 == 0)
        {
          return_value_sscanf_11=sscanf(audio_port + (signed long int)14, "%d", &devnum);
          if(!(return_value_sscanf_11 >= 1))
            devnum = -1;

        }

        if(devnum >= -1)
        {
          xine_config_register_num(this->xine, "audio.device.oss_device_number", -1, "OSS audio device number, -1 for none", "The full audio device name is created by concatenating the OSS device name and the audio device number.\nIf you do not need a number because you are happy with your system's default audio device, set this to -1.\nThe range of this value is -1 or 0-15. This setting is ignored, when the OSS audio device name is set to \"auto\".", 10, (void (*)(void *, struct xine_cfg_entry_s *))(void *)0, (void *)0);
          this->xine->config->update_num(this->xine->config, "audio.device.oss_device_num", devnum);
        }

      }

    }

  }

}

// create_windows
// file xine_sxfe_frontend.c line 1471
static void create_windows(struct sxfe_s *this)
{
  struct anonymous_8 xswa;
  unsigned long int xswa_mask;
  xswa.background_pixel = (unsigned long int)0x00000000;
  xswa.border_pixel = (unsigned long int)0;
  xswa.backing_store = 1;
  xswa_mask = (unsigned long int)(1L << 3 | 1L << 6);
  XLockDisplay(this->display);
  this->window[(signed long int)0]=XCreateWindow(this->display, this->root_window, (signed int)this->_anon0.x.xpos, (signed int)this->_anon0.x.ypos, (unsigned int)this->_anon0.x.width, (unsigned int)this->_anon0.x.height, (unsigned int)1, (signed int)0L, (unsigned int)1, ((struct anonymous_16 *)NULL), xswa_mask, &xswa);
  this->window[(signed long int)1]=XCreateWindow(this->display, this->root_window, (signed int)this->xinerama_x, (signed int)this->xinerama_y, (unsigned int)this->_anon0.x.width, (unsigned int)this->_anon0.x.height, (unsigned int)0, (signed int)0L, (unsigned int)1, ((struct anonymous_16 *)NULL), xswa_mask, &xswa);
  set_fullscreen_props(this);
  struct anonymous_9 *classHint;
  classHint=XAllocClassHint();
  if(!(classHint == ((struct anonymous_9 *)NULL)))
  {
    classHint->res_name = "VDR";
    classHint->res_class = "VDR";
    XSetClassHint(this->display, this->window[(signed long int)0], classHint);
    XSetClassHint(this->display, this->window[(signed long int)1], classHint);
    XFree((void *)classHint);
  }

  const char *initial_title = !(this->_anon0.fe.fe_message_cb != ((void (*)(void *, const char *, const char *))NULL)) ? "Connecting to VDR ..." : "Local VDR";
  XStoreName(this->display, this->window[(signed long int)0], initial_title);
  XStoreName(this->display, this->window[(signed long int)1], initial_title);
  set_icon(this);
  XUnlockDisplay(this->display);
}

// detect_display_ratio
// file xine_sxfe_frontend.c line 1440
static double detect_display_ratio(struct _XDisplay *dpy, signed int screen)
{
  double res_h = ((double)(&((struct anonymous_34 *)dpy)->screens[(signed long int)screen])->width * 1000.0) / (double)(&((struct anonymous_34 *)dpy)->screens[(signed long int)screen])->mwidth;
  double res_v = ((double)(&((struct anonymous_34 *)dpy)->screens[(signed long int)screen])->height * 1000.0) / (double)(&((struct anonymous_34 *)dpy)->screens[(signed long int)screen])->mheight;
  double display_ratio = res_v / res_h;
  double diff = display_ratio - 1.0;
  if(diff < 0.01 && diff > -1.000000e-2)
    display_ratio = 1.0;

  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[vdr-sxfe]  ", "Display size : %d x %d mm", (&((struct anonymous_34 *)dpy)->screens[(signed long int)screen])->mwidth, (&((struct anonymous_34 *)dpy)->screens[(signed long int)screen])->mheight);

  while((_Bool)0);
  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[vdr-sxfe]  ", "               %d x %d pixels", (&((struct anonymous_34 *)dpy)->screens[(signed long int)screen])->width, (&((struct anonymous_34 *)dpy)->screens[(signed long int)screen])->height);

  while((_Bool)0);
  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[vdr-sxfe]  ", "               %ddpi / %ddpi", (signed int)((res_v / (double)1000) * 25.4), (signed int)((res_h / (double)1000) * 25.4));

  while((_Bool)0);
  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[vdr-sxfe]  ", "Display ratio: %f/%f = %f", res_v, res_h, display_ratio);

  while((_Bool)0);
  return display_ratio;
}

// detect_xvdr_metronom
// file xine/vo_lastpts.c line 36
static void detect_xvdr_metronom(struct anonymous_83 *this, struct xine_stream_s_0 *stream)
{
  signed long int return_value;
  return_value=stream->metronom->get_option(stream->metronom, 0x1001 + 3);
  if(return_value == 4100l)
  {
    if(SysLogLevel >= 3)
      x_syslog(7, "[lastpts  ] ", "new stream is vdr stream");

    this->xvdr_metronom = stream->metronom;
    this->xvdr_stream = stream;
  }

}

// disable_DPMS
// file xine_sxfe_frontend.c line 1343
static void disable_DPMS(struct sxfe_s *this)
{
  signed int dpms_dummy;
  XLockDisplay(this->display);
  signed int return_value_DPMSQueryExtension_1;
  return_value_DPMSQueryExtension_1=DPMSQueryExtension(this->display, &dpms_dummy, &dpms_dummy);
  _Bool tmp_if_expr_3;
  signed int return_value_DPMSCapable_2;
  if(!(return_value_DPMSQueryExtension_1 == 0))
  {
    return_value_DPMSCapable_2=DPMSCapable(this->display);
    tmp_if_expr_3 = return_value_DPMSCapable_2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
  {
    unsigned short int dpms_level;
    DPMSInfo(this->display, &dpms_level, &this->dpms_state);
    DPMSDisable(this->display);
  }

  else
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[vdr-sxfe]  ", "disable_DPMS: DPMS unavailable");

    while((_Bool)0);
  XUnlockDisplay(this->display);
}

// discovery_init
// file tools/vdrdiscovery.c line 51
static inline signed int discovery_init(signed int port)
{
  signed int fd_discovery = -1;
  signed int iBroadcast = 1;
  signed int iReuse = 1;
  struct sockaddr_in sin;
  fd_discovery=socket(2, 2, 0);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  signed int *return_value___errno_location_8;
  char *return_value_strerror_9;
  unsigned short int tmp_statement_expression_12;
  signed int *return_value___errno_location_13;
  char *return_value_strerror_14;
  if(!(fd_discovery >= 0))
  {
    do
      if(SysLogLevel >= 1)
      {
        x_syslog(3, "[discovery] ", "discovery_init: socket() failed");
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        if(!(*return_value___errno_location_3 == 0))
        {
          return_value___errno_location_1=__errno_location();
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          x_syslog(3, "[discovery] ", "   (ERROR (%s,%d): %s)", (const void *)"tools/vdrdiscovery.c", 58, return_value_strerror_2);
        }

      }

    while((_Bool)0);
    return -1;
  }

  else
  {
    signed int return_value_setsockopt_7;
    return_value_setsockopt_7=setsockopt(fd_discovery, 1, 6, (const void *)&iBroadcast, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_7 >= 0))
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[discovery] ", "discovery_init: setsockopt(SO_BROADCAST) failed");
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          if(!(*return_value___errno_location_6 == 0))
          {
            return_value___errno_location_4=__errno_location();
            return_value_strerror_5=strerror(*return_value___errno_location_4);
            x_syslog(3, "[discovery] ", "   (ERROR (%s,%d): %s)", (const void *)"tools/vdrdiscovery.c", 63, return_value_strerror_5);
          }

        }

      while((_Bool)0);

    signed int return_value_setsockopt_11;
    return_value_setsockopt_11=setsockopt(fd_discovery, 1, 2, (const void *)&iReuse, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_11 >= 0))
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[discovery] ", "discovery_init: setsockopt(SO_REUSEADDR) failed");
          signed int *return_value___errno_location_10;
          return_value___errno_location_10=__errno_location();
          if(!(*return_value___errno_location_10 == 0))
          {
            return_value___errno_location_8=__errno_location();
            return_value_strerror_9=strerror(*return_value___errno_location_8);
            x_syslog(3, "[discovery] ", "   (ERROR (%s,%d): %s)", (const void *)"tools/vdrdiscovery.c", 66, return_value_strerror_9);
          }

        }

      while((_Bool)0);

    sin.sin_family = (unsigned short int)2;
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)port;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_12 = __v;
    sin.sin_port = tmp_statement_expression_12;
    sin.sin_addr.s_addr=__bswap_32((unsigned int)0xffffffff);
    signed int return_value_bind_16;
    return_value_bind_16=bind(fd_discovery, (struct sockaddr *)&sin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_bind_16 >= 0))
    {
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[discovery] ", "discovery_init: bind() failed");
          signed int *return_value___errno_location_15;
          return_value___errno_location_15=__errno_location();
          if(!(*return_value___errno_location_15 == 0))
          {
            return_value___errno_location_13=__errno_location();
            return_value_strerror_14=strerror(*return_value___errno_location_13);
            x_syslog(3, "[discovery] ", "   (ERROR (%s,%d): %s)", (const void *)"tools/vdrdiscovery.c", 73, return_value_strerror_14);
          }

        }

      while((_Bool)0);
      close(fd_discovery);
      return -1;
    }

    else
      return fd_discovery;
  }
}

// display_frame
// file xine/vo_frameoutput.c line 44
static void display_frame(struct vo_driver_s *self, struct vo_frame_s *vo_img)
{
  struct anonymous_84 *this = (struct anonymous_84 *)self;
  do
    if(self == ((struct vo_driver_s *)NULL))
    {
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[frame_out] ", "Asseretion failed: %s at %s:%d (%s)", (const void *)"self", (const void *)"xine/vo_frameoutput.c", 48, (const void *)"display_frame");

      while((_Bool)0);
      goto __CPROVER_DUMP_L10;
    }

  while((_Bool)0);
  do
    if(vo_img == ((struct vo_frame_s *)NULL))
    {
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[frame_out] ", "Asseretion failed: %s at %s:%d (%s)", (const void *)"vo_img", (const void *)"xine/vo_frameoutput.c", 49, (const void *)"display_frame");

      while((_Bool)0);
      goto __CPROVER_DUMP_L10;
    }

  while((_Bool)0);
  if(!(this->cb == ((void (*)(void *, struct vo_frame_s *))NULL)))
    this->cb(this->handle, vo_img);

  this->h.orig_driver->display_frame(this->h.orig_driver, vo_img);

__CPROVER_DUMP_L10:
  ;
}

// elapsed
// file tools/time_ms.h line 28
static unsigned long int elapsed(unsigned long int t)
{
  unsigned long int return_value_time_ms_1;
  return_value_time_ms_1=time_ms();
  return return_value_time_ms_1 - t;
}

// elapsed_link1
// file tools/time_ms.h line 28
static unsigned long int elapsed_link1(unsigned long int t_link1)
{
  unsigned long int return_value_time_ms_1_link1;
  return_value_time_ms_1_link1=time_ms_link1();
  return return_value_time_ms_1_link1 - t_link1;
}

// fe_compress_grab_frame
// file xine_frontend.c line 1918
static char * fe_compress_grab_frame(struct fe_s *this, signed int *size, signed int jpeg, signed int quality, signed int width, signed int height, struct xine_grab_video_frame_s *frame)
{
  if(!(jpeg == 0))
  {
    struct jpeg_destination_mgr jdm;
    struct jpeg_compress_struct cinfo;
    struct jpeg_error_mgr jerr;
    struct tJpegCompressData_s jcd;
    jdm.init_destination = JpegCompressInitDestination;
    jdm.empty_output_buffer = JpegCompressEmptyOutputBuffer;
    jdm.term_destination = JpegCompressTermDestination;
    cinfo.err=jpeg_std_error(&jerr);
    jpeg_CreateCompress(&cinfo, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
    cinfo.dest = &jdm;
    cinfo.client_data = (void *)&jcd;
    cinfo.image_width = (unsigned int)width;
    cinfo.image_height = (unsigned int)height;
    cinfo.input_components = 3;
    cinfo.in_color_space = (enum anonymous_0)JCS_RGB;
    jpeg_set_defaults(&cinfo);
    jpeg_set_quality(&cinfo, quality, 1);
    jpeg_start_compress(&cinfo, 1);
    const signed long int jcd_array_size0 = (signed long int)height;
    unsigned char *rp[jcd_array_size0];
    signed int rs = width * 3;
    signed int k = 0;
    for( ; !(k >= height); k = k + 1)
      rp[(signed long int)k] = frame->img + (signed long int)(k * rs);
    jpeg_write_scanlines(&cinfo, rp, (unsigned int)height);
    jpeg_finish_compress(&cinfo);
    jpeg_destroy_compress(&cinfo);
    *size = jcd.size;
    return (char *)jcd.mem;
  }

  unsigned long int bytes = (unsigned long int)(width * height * 3);
  unsigned char *pnm;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(bytes + (unsigned long int)64);
  pnm = (unsigned char *)return_value_malloc_1;
  if(pnm == ((unsigned char *)NULL))
  {
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[vdr-fe]    ", "fe_grab: malloc failed");

    while((_Bool)0);
    return (char *)(void *)0;
  }

  else
  {
    sprintf_link1((char *)pnm, "P6\n%d\n%d\n255\n", width, height);
    signed int hdrlen;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen((char *)pnm);
    hdrlen = (signed int)return_value_strlen_2;
    xine_fast_memcpy((void *)(pnm + (signed long int)hdrlen), (const void *)frame->img, bytes);
    *size = (signed int)(bytes + (unsigned long int)hdrlen);
    return (char *)pnm;
  }
}

// fe_control
// file xine_frontend.c line 1472
static void * fe_control(struct frontend_s *this_gen, const char *cmd)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  struct post_plugins_s *posts;
  signed int return_value_strncmp_29;
  struct xine_stream_s *tmp_if_expr_1;
  signed int return_value_strncmp_28;
  signed int return_value_strncmp_27;
  _Bool tmp_if_expr_10;
  signed int return_value_xine_play_9;
  signed int *return_value___errno_location_5;
  char *return_value_strerror_6;
  signed int return_value_strncmp_26;
  char *tmp_post_15;
  signed int return_value_strncmp_18;
  signed int return_value_atoi_16;
  signed int return_value_strncmp_25;
  signed int return_value_strncmp_24;
  if(cmd == ((const char *)NULL) || this == ((struct fe_s *)NULL))
  {
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[vdr-fe]    ", "fe_control(0x%lx,0x%lx) : invalid argument", (unsigned long int)this_gen, (unsigned long int)cmd);

    while((_Bool)0);
    return (void *)0;
  }

  else
  {
    posts = this->postplugins;
    if(posts == ((struct post_plugins_s *)NULL))
    {
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[vdr-fe]    ", "fe_control : this->posts == NULL");

      while((_Bool)0);
      return (void *)0;
    }

    else
    {
      signed int return_value_strncmp_30;
      return_value_strncmp_30=strncmp(cmd, "SLAVE CLOSED", (unsigned long int)16);
      if(return_value_strncmp_30 == 0)
      {
        if(!(this->slave_stream == ((struct xine_stream_s *)NULL)))
          fe_control(this_gen, "SLAVE 0x0\r\n");

        init_dummy_ports(this, 0);
        this->video_height = (unsigned short int)0;
        this->video_width = this->video_height;
      }

      else
      {
        return_value_strncmp_29=strncmp(cmd, "SLAVE 0x", (unsigned long int)8);
        if(return_value_strncmp_29 == 0)
        {
          unsigned long int pt;
          signed int return_value_sscanf_4;
          return_value_sscanf_4=sscanf(cmd + (signed long int)8, "%lx", &pt);
          if(return_value_sscanf_4 == 1)
          {
            struct xine_stream_s *slave_stream = (struct xine_stream_s *)pt;
            if(!(this->slave_stream == slave_stream))
            {
              fe_post_unwire(this);
              if(!(this->slave_stream == ((struct xine_stream_s *)NULL)))
              {
                if(this->slave_stream == this->postplugins->audio_source)
                {
                  struct xine_post_out_s *ao_source;
                  ao_source=xine_get_audio_source(this->slave_stream);
                  do
                    if(SysLogLevel >= 2)
                      x_syslog(6, "[vdr-fe]    ", "unwiring slave stream from output");

                  while((_Bool)0);
                  xine_post_wire_audio_port(ao_source, this->audio_port_none);
                }

              }

              this->slave_stream = slave_stream;
              if(!(this->slave_stream == ((struct xine_stream_s *)NULL)))
                tmp_if_expr_1 = this->slave_stream;

              else
                tmp_if_expr_1 = this->stream;
              this->postplugins->audio_source = tmp_if_expr_1;
              this->postplugins->video_source = this->postplugins->audio_source;
              char *return_value_strstr_2;
              return_value_strstr_2=strstr(cmd, "Video");
              if(!(return_value_strstr_2 == ((char *)NULL)))
                this->postplugins->audio_source = this->stream;

              char *return_value_strstr_3;
              return_value_strstr_3=strstr(cmd, "Audio");
              if(!(return_value_strstr_3 == ((char *)NULL)))
                this->postplugins->video_source = this->stream;

              if(!(this->slave_stream == ((struct xine_stream_s *)NULL)))
                fe_post_unwire(this);

              fe_post_rewire(this);
            }

            this->slave_playback_finished = (unsigned char)!(slave_stream != ((struct xine_stream_s *)NULL));
            this->video_height = (unsigned short int)0;
            this->video_width = this->video_height;
          }

        }

        else
        {
          return_value_strncmp_28=strncmp(cmd, "ENDOFSTREAM", (unsigned long int)11);
          if(return_value_strncmp_28 == 0)
          {
            if(!(this->slave_stream == ((struct xine_stream_s *)NULL)))
              this->slave_playback_finished = (unsigned char)1;

          }

          else
          {
            return_value_strncmp_27=strncmp(cmd, "SUBSTREAM ", (unsigned long int)10);
            if(return_value_strncmp_27 == 0)
            {
              unsigned int pid;
              signed int x;
              signed int y;
              signed int w;
              signed int h;
              signed int return_value_sscanf_11;
              return_value_sscanf_11=sscanf(cmd + (signed long int)10, "0x%x %d %d %d %d", &pid, &x, &y, &w, &h);
              if(return_value_sscanf_11 == 5)
              {
                char mrl[256l];
                if(posts->pip_stream == ((struct xine_stream_s *)NULL))
                  posts->pip_stream=xine_stream_new(this->xine, this->audio_port, this->video_port);

                do
                  if(SysLogLevel >= 2)
                    x_syslog(6, "[vdr-fe]    ", "  PIP %d: %dx%d @ (%d,%d)", pid & (unsigned int)0x0f, w, h, x, y);

                while((_Bool)0);
                do
                  if(SysLogLevel >= 2)
                    x_syslog(6, "[vdr-fe]    ", "create pip stream done");

                while((_Bool)0);
                sprintf_link1(mrl, "xvdr+slave://0x%lx#nocache", (unsigned long int)this);
                signed int return_value_xine_open_8;
                return_value_xine_open_8=xine_open(posts->pip_stream, mrl);
                if(return_value_xine_open_8 == 0)
                  tmp_if_expr_10 = (_Bool)1;

                else
                {
                  return_value_xine_play_9=xine_play(posts->pip_stream, 0, 0);
                  tmp_if_expr_10 = !(return_value_xine_play_9 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_10)
                  do
                    if(SysLogLevel >= 1)
                    {
                      x_syslog(3, "[vdr-fe]    ", "  pip stream open/play failed");
                      signed int *return_value___errno_location_7;
                      return_value___errno_location_7=__errno_location();
                      if(!(*return_value___errno_location_7 == 0))
                      {
                        return_value___errno_location_5=__errno_location();
                        return_value_strerror_6=strerror(*return_value___errno_location_5);
                        x_syslog(3, "[vdr-fe]    ", "   (ERROR (%s,%d): %s)", (const void *)"xine_frontend.c", 1554, return_value_strerror_6);
                      }

                    }

                  while((_Bool)0);

                else
                {
                  char params[64l];
                  sprintf_link1(params, "pip_num=1,x=%d,y=%d,w=%d,h=%d", x, y, w, h);
                  fe_post_open(this, "Pip", params);
                  return (void *)posts->pip_stream;
                }
              }

              fe_post_close(this, (const char *)(void *)0, 3);
              if(!(posts->pip_stream == ((struct xine_stream_s *)NULL)))
              {
                xine_close(posts->pip_stream);
                xine_dispose(posts->pip_stream);
                posts->pip_stream = (struct xine_stream_s *)(void *)0;
              }

              return (void *)0;
            }

            else
            {
              return_value_strncmp_26=strncmp(cmd, "POST ", (unsigned long int)5);
              if(return_value_strncmp_26 == 0)
              {
                char *name;
                char *return_value___strdup_12;
                return_value___strdup_12=__strdup(cmd + (signed long int)5);
                name = return_value___strdup_12;
                char *args = name;
                char *fe_control__1__12__pt;
                char *return_value___builtin_strchr_13;
                return_value___builtin_strchr_13=__builtin_strchr(name, 13);
                fe_control__1__12__pt = return_value___builtin_strchr_13;
                if(!(fe_control__1__12__pt == ((char *)NULL)))
                  *fe_control__1__12__pt = (char)0;

                char *return_value___builtin_strchr_14;
                return_value___builtin_strchr_14=__builtin_strchr(name, 10);
                fe_control__1__12__pt = return_value___builtin_strchr_14;
                if(!(fe_control__1__12__pt == ((char *)NULL)))
                  *fe_control__1__12__pt = (char)0;

                for( ; !(*args == 0); args = args + 1l)
                  if((signed int)*args == 32)
                    break;

                if(!(*args == 0))
                {
                  tmp_post_15 = args;
                  args = args + 1l;
                  *tmp_post_15 = (char)0;
                }

                for( ; !(*args == 0); args = args + 1l)
                  if(!((signed int)*args == 32))
                    break;

                signed int return_value_strncmp_19;
                return_value_strncmp_19=strncmp(args, "On", (unsigned long int)2);
                if(return_value_strncmp_19 == 0)
                {
                  args = args + (signed long int)2;
                  for( ; (signed int)*args == 32; args = args + 1l)
                    ;
                  fe_post_open(this, name, args);
                }

                else
                {
                  return_value_strncmp_18=strncmp(args, "Off", (unsigned long int)3);
                  if(return_value_strncmp_18 == 0)
                  {
                    unsigned long int return_value_strlen_17;
                    return_value_strlen_17=strlen(name);
                    if(return_value_strlen_17 == 1ul)
                    {
                      return_value_atoi_16=atoi(name);
                      fe_post_close(this, (const char *)(void *)0, return_value_atoi_16);
                    }

                    else
                      fe_post_close(this, name, -1);
                  }

                  else
                    do
                      if(SysLogLevel >= 2)
                        x_syslog(6, "[vdr-fe]    ", "fe_control: POST: unknown command %s", cmd);

                    while((_Bool)0);
                }
                free((void *)name);
                return (void *)0;
              }

              else
              {
                return_value_strncmp_25=strncmp(cmd, "GRAB ", (unsigned long int)5);
                if(return_value_strncmp_25 == 0)
                {
                  signed int quality;
                  signed int width;
                  signed int height;
                  signed int jpeg;
                  signed int size = 0;
                  signed int return_value_strncmp_20;
                  return_value_strncmp_20=strncmp(cmd + (signed long int)5, "JPEG", (unsigned long int)4);
                  jpeg = (signed int)!(return_value_strncmp_20 != 0);
                  signed int return_value_sscanf_22;
                  return_value_sscanf_22=sscanf(cmd + (signed long int)5 + (signed long int)4, "%d %d %d", &quality, &width, &height);
                  if(return_value_sscanf_22 == 3)
                  {
                    struct grab_data_s *result;
                    void *return_value_malloc_21;
                    return_value_malloc_21=malloc(sizeof(struct grab_data_s) /*16ul*/ );
                    result = (struct grab_data_s *)return_value_malloc_21;
                    result->data=this->fe.grab((struct frontend_s *)this, &size, jpeg, quality, width, height);
                    if(!(result->data == ((char *)NULL)))
                    {
                      result->size = (unsigned long int)size;
                      if(result->size >= 1ul)
                        return (void *)result;

                    }

                    free((void *)result->data);
                    free((void *)result);
                  }

                }

                else
                {
                  return_value_strncmp_24=strncmp(cmd, "OVERSCAN ", (unsigned long int)9);
                  if(return_value_strncmp_24 == 0)
                  {
                    signed int overscan;
                    signed int return_value_sscanf_23;
                    return_value_sscanf_23=sscanf(cmd + (signed long int)9, "%d", &overscan);
                    if(return_value_sscanf_23 == 1)
                    {
                      signed int crop_x = ((overscan * (signed int)this->width) / 100) / 2;
                      signed int crop_y = ((overscan * (signed int)this->height) / 100) / 2;
                      this->overscan = (unsigned char)overscan;
                      xine_set_param(this->stream, 0x01000020, crop_x);
                      xine_set_param(this->stream, 0x01000022, crop_y);
                      xine_set_param(this->stream, 0x01000021, crop_x);
                      xine_set_param(this->stream, 0x01000023, crop_y);
                      xine_set_param(this->stream, 0x01000008, 100);
                    }

                  }

                }
              }
            }
          }
        }
      }
      return (void *)0;
    }
  }
}

// fe_dest_pixel_aspect
// file xine_frontend.c line 222
static double fe_dest_pixel_aspect(const struct fe_s *this, double video_pixel_aspect, signed int video_width, signed int video_height)
{
  double result = 1.0;
  if(!((signed int)this->aspect == 1))
  {
    if((signed int)this->aspect == 2)
      goto __CPROVER_DUMP_L3;

    if((signed int)this->aspect == 3)
      goto __CPROVER_DUMP_L4;

    if((signed int)this->aspect == 4)
      goto __CPROVER_DUMP_L5;

    if((signed int)this->aspect == 5)
      goto __CPROVER_DUMP_L6;

    if((signed int)this->aspect == 6)
      goto __CPROVER_DUMP_L9;

    double correction = ((double)video_width / (double)video_height) / ((double)this->width / (double)this->height);
    result = video_pixel_aspect * correction;
    if(result > ((16.9 / 9.0) * (double)this->height) / (double)this->width)
      result = ((16.0 / 9.0) * (double)this->height) / (double)this->width;

    goto __CPROVER_DUMP_L9;
  }

  result = this->display_ratio;
  goto __CPROVER_DUMP_L9;

__CPROVER_DUMP_L3:
  ;
  result = ((4.0 / 3.0) * (double)this->height) / (double)this->width;
  goto __CPROVER_DUMP_L9;

__CPROVER_DUMP_L4:
  ;
  result = ((16.0 / 9.0) * (double)this->height) / (double)this->width;
  goto __CPROVER_DUMP_L9;

__CPROVER_DUMP_L5:
  ;
  result = ((16.0 / 10.0) * (double)this->height) / (double)this->width;
  goto __CPROVER_DUMP_L9;

__CPROVER_DUMP_L6:
  ;
  double aspect_diff = (video_pixel_aspect * (double)video_width) / (double)video_height - 4.0 / 3.0;
  if(aspect_diff < 0.05 && aspect_diff > -5.000000e-2)
    result = ((4.0 / 3.0) * (double)this->height) / (double)this->width;

  else
    result = ((16.0 / 9.0) * (double)this->height) / (double)this->width;
  goto __CPROVER_DUMP_L9;

__CPROVER_DUMP_L9:
  ;
  return result;
}

// fe_frame_output_cb
// file xine_frontend.c line 304
static void fe_frame_output_cb(void *data, signed int video_width, signed int video_height, double video_pixel_aspect, signed int *dest_x, signed int *dest_y, signed int *dest_width, signed int *dest_height, double *dest_pixel_aspect, signed int *win_x, signed int *win_y)
{
  struct fe_s *this = (struct fe_s *)data;
  _Bool tmp_if_expr_1;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  if(!(this == ((struct fe_s *)NULL)))
  {
    *dest_width = (signed int)this->width;
    *dest_height = (signed int)this->height;
    *dest_x = 0;
    *dest_y = 0;
    if(this->scale_video == 0)
    {
      if(!(video_height >= (signed int)this->height))
      {
        *dest_height = video_height;
        *dest_y = ((signed int)this->height - video_height) / 2;
      }

      if(!(video_width >= (signed int)this->width))
      {
        *dest_width = video_width;
        *dest_x = ((signed int)this->width - video_width) / 2;
      }

    }

    *win_x = (signed int)this->xpos;
    *win_y = (signed int)this->ypos;
    *dest_pixel_aspect=this->dest_pixel_aspect(this, video_pixel_aspect, video_width, video_height);
    if(!(this->stream == ((struct xine_stream_s *)NULL)))
    {
      _x_stream_info_set(this->stream, 4, (signed int)((10000.0 * video_pixel_aspect * (double)video_width) / (double)video_height));
      if(!((signed int)this->video_width == video_width))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (signed int)this->video_height != video_height ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        struct anonymous_14 framedata = { .width=video_width, .height=video_height, .aspect=0,
    .pan_scan=0 };
        const struct anonymous_15 event = { .stream=this->stream, .data=(void *)&framedata, .data_length=(signed int)sizeof(struct anonymous_14) /*16ul*/ ,
    .type=5,
    .tv={ .tv_sec=0l, .tv_usec=0l } };
        xine_event_send(this->stream, &event);
        this->video_width = (unsigned short int)video_width;
        this->video_height = (unsigned short int)video_height;
      }

      if(!(this->aspect_controller == ((char *)NULL)))
      {
        double video_aspect = (video_pixel_aspect * (double)video_width) / (double)video_height;
        double aspect_diff = video_aspect - this->video_aspect;
        if(aspect_diff < -5.000000e-2 || aspect_diff > 0.05)
        {
          char cmd[4096l];
          signed int return_value_snprintf_6;
          return_value_snprintf_6=snprintf_link1(cmd, sizeof(char [4096l]) /*4096ul*/ , "%s %d", this->aspect_controller, (signed int)(video_aspect * 10000.0));
          if(!(return_value_snprintf_6 >= (signed int)sizeof(char [4096l]) /*4096*/ ))
          {
            if(SysLogLevel >= 3)
              x_syslog(7, "[vdr-fe]    ", "Aspect ratio changed, executing %s", (const void *)cmd);

            signed int return_value_system_5;
            return_value_system_5=system(cmd);
            if(return_value_system_5 == -1)
            {
              if(SysLogLevel >= 1)
              {
                x_syslog(3, "[vdr-fe]    ", "Executing /bin/sh -c %s failed", (const void *)cmd);
                signed int *return_value___errno_location_4;
                return_value___errno_location_4=__errno_location();
                if(!(*return_value___errno_location_4 == 0))
                {
                  return_value___errno_location_2=__errno_location();
                  return_value_strerror_3=strerror(*return_value___errno_location_2);
                  x_syslog(3, "[vdr-fe]    ", "   (ERROR (%s,%d): %s)", (const void *)"xine_frontend.c", 401, return_value_strerror_3);
                }

              }

            }

            this->video_aspect = video_aspect;
          }

        }

      }

    }

  }

}

// fe_free
// file xine_frontend.c line 1286
static void fe_free(struct frontend_s *this_gen)
{
  if(!(this_gen == ((struct frontend_s *)NULL)))
  {
    struct fe_s *this = (struct fe_s *)this_gen;
    this->fe.fe_display_close(this_gen);
    free((void *)this->configfile);
    free((void *)this->shutdown_cmd);
    free((void *)this);
  }

}

// fe_grab
// file xine_frontend.c line 1982
static char * fe_grab(struct frontend_s *this_gen, signed int *size, signed int jpeg, signed int quality, signed int width, signed int height)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  signed int return_value_find_input_plugin_1;
  return_value_find_input_plugin_1=find_input_plugin(this);
  if(return_value_find_input_plugin_1 == 0)
    return ((char *)NULL);

  else
  {
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[vdr-fe]    ", "fe_grab: grabbing %s %d %dx%d", jpeg != 0 ? "JPEG" : "PNM", quality, width, height);

    while((_Bool)0);
    if(quality >= 101 || !(quality >= 0))
      quality = 100;

    width = (16 > (width < 1920 ? width : 1920) ? 16 : (width < 1920 ? width : 1920)) + 1 & ~1;
    height = (16 > (height < 1200 ? height : 1200) ? 16 : (height < 1200 ? height : 1200)) + 1 & ~1;
    this->stream->xine->port_ticket->acquire(this->stream->xine->port_ticket, 0);
    char *img = (char *)(void *)0;
    struct xine_grab_video_frame_s *grab_frame;
    grab_frame=xine_new_grab_video_frame(this->stream);
    if(!(grab_frame == ((struct xine_grab_video_frame_s *)NULL)))
    {
      grab_frame->width = width;
      grab_frame->height = height;
      signed int return_value;
      return_value=grab_frame->grab(grab_frame);
      if(return_value == 0)
        img=fe_compress_grab_frame(this, size, jpeg, quality, width, height, grab_frame);

      grab_frame->dispose(grab_frame);
    }

    this->stream->xine->port_ticket->release(this->stream->xine->port_ticket, 0);
    return img;
  }
}

// fe_is_finished
// file xine_frontend.c line 1297
static signed int fe_is_finished(struct frontend_s *this_gen, signed int slave_stream)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  _Bool tmp_if_expr_1;
  if(this == ((struct fe_s *)NULL))
    return -1;

  else
    if(!(this->terminate_key_pressed == 0u))
      return 1;

    else
      if(!(this->playback_finished == 0))
        return -1;

      else
        if(!(slave_stream == 0))
        {
          if(this->slave_stream == ((struct xine_stream_s *)NULL))
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = this->slave_playback_finished != 0 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr_1)
            goto __CPROVER_DUMP_L6;

          return 1;
        }

        else
        {

        __CPROVER_DUMP_L6:
          ;
          if(this->shutdown_timeout >= 1)
          {
            signed long int return_value_time_2;
            return_value_time_2=time((signed long int *)(void *)0);
            if(!(this->shutdown_time >= return_value_time_2))
            {
              shutdown_system(this->shutdown_cmd, 0);
              return 1;
            }

          }

          return 0;
        }
}

// fe_post_close
// file xine_frontend.c line 960
static void fe_post_close(const struct fe_s *this, const char *name, signed int which)
{
  struct post_plugins_s *posts = this->postplugins;
  signed int tmp_statement_expression_1;
  signed int tmp_statement_expression_3;
  if(!(this == ((const struct fe_s *)NULL)))
  {
    if(!(name == ((const char *)NULL)))
    {
      unsigned long int __s1_len;
      unsigned long int fe_post_close__1__1____s2_len;
      signed int return_value___builtin_strcmp_2;
      return_value___builtin_strcmp_2=__builtin_strcmp(name, "AudioVisualization");
      tmp_statement_expression_1 = return_value___builtin_strcmp_2;
      if(tmp_statement_expression_1 == 0)
      {
        name = (const char *)(void *)0;
        which = 0;
      }

    }

    if(!(name == ((const char *)NULL)))
    {
      unsigned long int fe_post_close__1__3____s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_4;
      return_value___builtin_strcmp_4=__builtin_strcmp(name, "Pip");
      tmp_statement_expression_3 = return_value___builtin_strcmp_4;
      if(tmp_statement_expression_3 == 0)
      {
        name = (const char *)(void *)0;
        which = 3;
      }

    }

    if(!(name == ((const char *)NULL)))
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-fe]    ", "closing post plugin: %s", name);

      while((_Bool)0);
      signed int return_value_applugin_unload_post_5;
      return_value_applugin_unload_post_5=applugin_unload_post(posts, name);
      if(!(return_value_applugin_unload_post_5 == 0))
      {
        applugin_rewire_posts(posts);
        goto __CPROVER_DUMP_L25;
      }

      signed int return_value_vpplugin_unload_post_6;
      return_value_vpplugin_unload_post_6=vpplugin_unload_post(posts, name);
      if(!(return_value_vpplugin_unload_post_6 == 0))
      {
        vpplugin_rewire_posts(posts);
        goto __CPROVER_DUMP_L25;
      }

      goto __CPROVER_DUMP_L25;
    }

    if(which == 0 || !(which >= 0))
    {
      if(!(posts->post_vis_elements_num == 0))
      {
        if(!(posts->post_vis_elements == ((struct anonymous_26 **)NULL)))
        {
          if(!(*posts->post_vis_elements == ((struct anonymous_26 *)NULL)))
          {
            do
              if(SysLogLevel >= 3)
                x_syslog(7, "[vdr-fe]    ", "Closing audio visualization post plugins");

            while((_Bool)0);
            signed int return_value_applugin_unload_post_7;
            return_value_applugin_unload_post_7=applugin_unload_post(posts, posts->post_vis_elements[(signed long int)0]->name);
            if(!(return_value_applugin_unload_post_7 == 0))
              applugin_rewire_posts(posts);

          }

        }

      }

    }

    if(which == 1 || !(which >= 0))
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-fe]    ", "Closing audio post plugins");

      while((_Bool)0);
      signed int return_value_applugin_disable_post_8;
      return_value_applugin_disable_post_8=applugin_disable_post(posts, (const char *)(void *)0);
      if(!(return_value_applugin_disable_post_8 == 0))
        applugin_rewire_posts(posts);

    }

    if(which == 2 || !(which >= 0))
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-fe]    ", "Closing video post plugins");

      while((_Bool)0);
      signed int return_value_vpplugin_unload_post_9;
      return_value_vpplugin_unload_post_9=vpplugin_unload_post(posts, (const char *)(void *)0);
      if(!(return_value_vpplugin_unload_post_9 == 0))
        vpplugin_rewire_posts(posts);

    }

    if(which == 3 || !(which >= 0))
    {
      if(!(posts->post_pip_elements_num == 0))
      {
        if(!(posts->post_pip_elements == ((struct anonymous_26 **)NULL)))
        {
          if(!(*posts->post_pip_elements == ((struct anonymous_26 *)NULL)))
          {
            do
              if(SysLogLevel >= 3)
                x_syslog(7, "[vdr-fe]    ", "Closing PIP (mosaico) post plugins");

            while((_Bool)0);
            signed int return_value_vpplugin_unload_post_10;
            return_value_vpplugin_unload_post_10=vpplugin_unload_post(posts, "mosaico");
            if(!(return_value_vpplugin_unload_post_10 == 0))
              vpplugin_rewire_posts(posts);

          }

        }

      }

    }

  }


__CPROVER_DUMP_L25:
  ;
}

// fe_post_open
// file xine_frontend.c line 1043
static void fe_post_open(const struct fe_s *this, const char *name, const char *args)
{
  struct post_plugins_s *posts = this->postplugins;
  char initstr[1024l];
  signed int found = 0;
  _Bool tmp_if_expr_1;
  if(this == ((const struct fe_s *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(this->xine != ((struct xine_s *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(this->stream != ((struct xine_stream_s *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int tmp_statement_expression_5;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  signed int tmp_statement_expression_7;
  signed int tmp_statement_expression_26;
  _Bool tmp_if_expr_30;
  signed int tmp_statement_expression_28;
  _Bool tmp_if_expr_33;
  signed int tmp_statement_expression_31;
  _Bool tmp_if_expr_36;
  signed int tmp_statement_expression_34;
  _Bool tmp_if_expr_39;
  signed int tmp_statement_expression_37;
  signed int tmp_statement_expression_9;
  signed int return_value_applugin_enable_post_13;
  signed int tmp_statement_expression_11;
  signed int tmp_statement_expression_23;
  signed int tmp_statement_expression_21;
  signed int tmp_statement_expression_19;
  signed int tmp_statement_expression_17;
  signed int tmp_statement_expression_15;
  signed int return_value_vpplugin_enable_post_14;
  signed int return_value_applugin_enable_post_25;
  if(!(name == ((const char *)NULL)) && !tmp_if_expr_2)
  {
    unsigned long int fe_post_open__1__1____s1_len;
    unsigned long int fe_post_open__1__1____s2_len;
    signed int return_value___builtin_strcmp_6;
    return_value___builtin_strcmp_6=__builtin_strcmp(name, "Pip");
    tmp_statement_expression_5 = return_value___builtin_strcmp_6;
    if(tmp_statement_expression_5 == 0)
    {
      posts->post_pip_enable = 1;
      name = "mosaico";
      if(posts->post_pip_elements == ((struct anonymous_26 **)NULL))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = !(posts->post_vis_elements[(signed long int)0] != ((struct anonymous_26 *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = !(posts->post_vis_elements[(signed long int)0]->enable != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-fe]    ", "enabling picture-in-picture (\"%s:%s\") post plugin", name, args);

        while((_Bool)0);

    }

    if(!(args == ((const char *)NULL)))
    {
      snprintf_link1(initstr, sizeof(char [1024l]) /*1024ul*/ , "%s:%s", name, args);
      initstr[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
    }

    else
      strn0cpy(initstr, name, (signed int)sizeof(char [1024l]) /*1024ul*/ );
    unsigned long int fe_post_open__1__4____s1_len;
    unsigned long int fe_post_open__1__4____s2_len;
    signed int return_value___builtin_strcmp_8;
    return_value___builtin_strcmp_8=__builtin_strcmp(name, "swscale");
    tmp_statement_expression_7 = return_value___builtin_strcmp_8;
    if(tmp_statement_expression_7 == 0)
    {
      char *pt;
      pt=strstr(initstr, "output_aspect=auto");
      if(!(pt == ((char *)NULL)))
      {
        char tmp[16l];
        double r = 0.0;
        pt = pt + (signed long int)14;
        switch((signed int)this->aspect)
        {
          case 0:

          case 1:
          {
            r = (this->display_ratio * (double)this->width) / (double)this->height;
            break;
          }
          case 2:
          {
            r = 4.0 / 3.0;
            break;
          }
          case 3:
          {
            r = 16.0 / 9.0;
            break;
          }
          case 4:
          {
            r = 16.0 / 10.0;
            break;
          }
          default:
            do
              if(SysLogLevel >= 3)
                x_syslog(7, "[vdr-fe]    ", "%s(%d): unknown aspect: %d", (const void *)"fe_post_open", 1081, this->aspect);

            while((_Bool)0);
        }
        sprintf_link1(tmp, "%04d", (signed int)(r * 1000.0));
        strncpy(pt, tmp, (unsigned long int)4);
      }

    }

    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[vdr-fe]    ", "opening post plugin: %s", (const void *)initstr);

    while((_Bool)0);
    unsigned long int fe_post_open__1__7____s1_len;
    unsigned long int fe_post_open__1__7____s2_len;
    signed int return_value___builtin_strcmp_27;
    return_value___builtin_strcmp_27=__builtin_strcmp(name, "goom");
    tmp_statement_expression_26 = return_value___builtin_strcmp_27;
    if(tmp_statement_expression_26 == 0)
      tmp_if_expr_30 = (_Bool)1;

    else
    {
      unsigned long int fe_post_open__1__8____s1_len;
      unsigned long int fe_post_open__1__8____s2_len;
      signed int return_value___builtin_strcmp_29;
      return_value___builtin_strcmp_29=__builtin_strcmp(name, "oscope");
      tmp_statement_expression_28 = return_value___builtin_strcmp_29;
      tmp_if_expr_30 = !(tmp_statement_expression_28 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_30)
      tmp_if_expr_33 = (_Bool)1;

    else
    {
      unsigned long int fe_post_open__1__9____s1_len;
      unsigned long int fe_post_open__1__9____s2_len;
      signed int return_value___builtin_strcmp_32;
      return_value___builtin_strcmp_32=__builtin_strcmp(name, "fftscope");
      tmp_statement_expression_31 = return_value___builtin_strcmp_32;
      tmp_if_expr_33 = !(tmp_statement_expression_31 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_33)
      tmp_if_expr_36 = (_Bool)1;

    else
    {
      unsigned long int fe_post_open__1__10____s1_len;
      unsigned long int fe_post_open__1__10____s2_len;
      signed int return_value___builtin_strcmp_35;
      return_value___builtin_strcmp_35=__builtin_strcmp(name, "fftgraph");
      tmp_statement_expression_34 = return_value___builtin_strcmp_35;
      tmp_if_expr_36 = !(tmp_statement_expression_34 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_36)
      tmp_if_expr_39 = (_Bool)1;

    else
    {
      unsigned long int fe_post_open__1__11____s1_len;
      unsigned long int fe_post_open__1__11____s2_len;
      signed int return_value___builtin_strcmp_38;
      return_value___builtin_strcmp_38=__builtin_strcmp(name, "fooviz");
      tmp_statement_expression_37 = return_value___builtin_strcmp_38;
      tmp_if_expr_39 = !(tmp_statement_expression_37 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_39)
    {
      if(!(posts->post_vis_elements_num == 0))
      {
        if(!(posts->post_vis_elements == ((struct anonymous_26 **)NULL)))
        {
          if(!(*posts->post_vis_elements == ((struct anonymous_26 *)NULL)))
          {
            unsigned long int fe_post_open__1__12__1____s1_len;
            unsigned long int fe_post_open__1__12__1____s2_len;
            signed int return_value___builtin_strcmp_10;
            return_value___builtin_strcmp_10=__builtin_strcmp(name, posts->post_vis_elements[(signed long int)0]->name);
            tmp_statement_expression_9 = return_value___builtin_strcmp_10;
            if(!(tmp_statement_expression_9 == 0))
              fe_post_close(this, (const char *)(void *)0, 0);

          }

        }

      }

      if(found == 0)
      {
        return_value_applugin_enable_post_13=applugin_enable_post(posts, initstr, &found);
        if(!(return_value_applugin_enable_post_13 == 0))
        {
          posts->post_vis_enable = 1;
          applugin_rewire_posts(posts);
          if(!(args == ((const char *)NULL)))
          {
            unsigned long int fe_post_open__1__12__3__1____s1_len;
            unsigned long int fe_post_open__1__12__3__1____s2_len;
            signed int return_value___builtin_strcmp_12;
            return_value___builtin_strcmp_12=__builtin_strcmp(name, "goom");
            tmp_statement_expression_11 = return_value___builtin_strcmp_12;
            if(tmp_statement_expression_11 == 0)
            {
              signed int val;
              val=get_opt_val(initstr, "fps");
              if(val >= 1)
                this->xine->config->update_num(this->xine->config, "effects.goom.fps", val);

              val=get_opt_val(initstr, "width");
              if(val >= 1)
                this->xine->config->update_num(this->xine->config, "effects.goom.width", val);

              val=get_opt_val(initstr, "height");
              if(val >= 1)
                this->xine->config->update_num(this->xine->config, "effects.goom.height", val);

            }

          }

        }

      }

    }

    else
    {
      unsigned long int fe_post_open__1__13__1____s1_len;
      unsigned long int fe_post_open__1__13__1____s2_len;
      signed int return_value___builtin_strcmp_24;
      return_value___builtin_strcmp_24=__builtin_strcmp(name, "audiochannel");
      tmp_statement_expression_23 = return_value___builtin_strcmp_24;
      if(!(tmp_statement_expression_23 == 0))
      {
        unsigned long int fe_post_open__1__13__2____s1_len;
        unsigned long int fe_post_open__1__13__2____s2_len;
        signed int return_value___builtin_strcmp_22;
        return_value___builtin_strcmp_22=__builtin_strcmp(name, "volnorm");
        tmp_statement_expression_21 = return_value___builtin_strcmp_22;
        if(!(tmp_statement_expression_21 == 0))
        {
          unsigned long int fe_post_open__1__13__3____s1_len;
          unsigned long int fe_post_open__1__13__3____s2_len;
          signed int return_value___builtin_strcmp_20;
          return_value___builtin_strcmp_20=__builtin_strcmp(name, "stretch");
          tmp_statement_expression_19 = return_value___builtin_strcmp_20;
          if(!(tmp_statement_expression_19 == 0))
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp_18;
            return_value___builtin_strcmp_18=__builtin_strcmp(name, "upmix_mono");
            tmp_statement_expression_17 = return_value___builtin_strcmp_18;
            if(!(tmp_statement_expression_17 == 0))
            {
              unsigned long int fe_post_open__1__13__5____s1_len;
              unsigned long int fe_post_open__1__13__5____s2_len;
              signed int return_value___builtin_strcmp_16;
              return_value___builtin_strcmp_16=__builtin_strcmp(name, "upmix");
              tmp_statement_expression_15 = return_value___builtin_strcmp_16;
              if(!(tmp_statement_expression_15 == 0))
              {
                return_value_vpplugin_enable_post_14=vpplugin_enable_post(posts, initstr, &found);
                if(!(return_value_vpplugin_enable_post_14 == 0))
                {
                  posts->post_video_enable = 1;
                  vpplugin_rewire_posts(posts);
                }

              }

            }

          }

        }

      }

      if(found == 0)
      {
        return_value_applugin_enable_post_25=applugin_enable_post(posts, initstr, &found);
        if(!(return_value_applugin_enable_post_25 == 0))
        {
          posts->post_audio_enable = 1;
          applugin_rewire_posts(posts);
        }

      }

    }
    if(found == 0)
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[vdr-fe]    ", "Can't load post plugin %s", name);

      while((_Bool)0);

    else
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-fe]    ", "Post plugin %s loaded and wired", name);

      while((_Bool)0);
  }

}

// fe_post_rewire
// file xine_frontend.c line 944
static void fe_post_rewire(const struct fe_s *this)
{
  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[vdr-fe]    ", "re-wiring post plugins");

  while((_Bool)0);
  vpplugin_rewire_posts(this->postplugins);
  applugin_rewire_posts(this->postplugins);
}

// fe_post_unload
// file xine_frontend.c line 951
static void fe_post_unload(const struct fe_s *this)
{
  if(!(this->postplugins == ((struct post_plugins_s *)NULL)))
  {
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[vdr-fe]    ", "unloading post plugins");

    while((_Bool)0);
    vpplugin_unload_post(this->postplugins, (const char *)(void *)0);
    applugin_unload_post(this->postplugins, (const char *)(void *)0);
  }

}

// fe_post_unwire
// file xine_frontend.c line 899
static void fe_post_unwire(struct fe_s *this)
{
  _Bool tmp_if_expr_1;
  if(this == ((struct fe_s *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(this->stream != ((struct xine_stream_s *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(!tmp_if_expr_1)
  {
    struct xine_post_out_s *vo_source;
    vo_source=xine_get_video_source(this->stream);
    struct xine_post_out_s *ao_source;
    ao_source=xine_get_audio_source(this->stream);
    if(!(this->slave_stream == ((struct xine_stream_s *)NULL)))
      tmp_if_expr_2 = this->slave_stream == this->postplugins->audio_source ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-fe]    ", "unwiring slave stream audio post plugins");

      while((_Bool)0);
      init_dummy_ports(this, 1);
      if(!(ao_source == ((struct xine_post_out_s *)NULL)))
      {
        if(!(this->audio_port_none == ((struct xine_audio_port_s *)NULL)))
          xine_post_wire_audio_port(ao_source, this->audio_port_none);

      }

      ao_source=xine_get_audio_source(this->slave_stream);
      if(!(ao_source == ((struct xine_post_out_s *)NULL)))
      {
        if(!(this->audio_port == ((struct xine_audio_port_s *)NULL)))
          xine_post_wire_audio_port(ao_source, this->audio_port);

      }

    }

    else
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-fe]    ", "unwiring audio post plugins");

      while((_Bool)0);
      init_dummy_ports(this, 0);
      if(!(ao_source == ((struct xine_post_out_s *)NULL)))
      {
        if(!(this->audio_port == ((struct xine_audio_port_s *)NULL)))
          xine_post_wire_audio_port(ao_source, this->audio_port);

      }

    }
    if(!(this->slave_stream == ((struct xine_stream_s *)NULL)))
      tmp_if_expr_3 = this->slave_stream == this->postplugins->video_source ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-fe]    ", "unwiring slave stream video post plugins");

      while((_Bool)0);
      vo_source=xine_get_video_source(this->slave_stream);
      if(!(vo_source == ((struct xine_post_out_s *)NULL)))
      {
        if(!(this->video_port == ((struct xine_video_port_s_0 *)NULL)))
          xine_post_wire_video_port(vo_source, this->video_port);

      }

    }

    else
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-fe]    ", "unwiring video post plugins");

      while((_Bool)0);
      if(!(vo_source == ((struct xine_post_out_s *)NULL)))
      {
        if(!(this->video_port == ((struct xine_video_port_s_0 *)NULL)))
          xine_post_wire_video_port(vo_source, this->video_port);

      }

    }
  }

}

// fe_send_event
// file xine_frontend.c line 1412
static signed int fe_send_event(struct frontend_s *this_gen, const char *data)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  signed int tmp_statement_expression_14;
  signed int return_value_strncasecmp_13;
  signed int return_value_atoi_1;
  signed int tmp_statement_expression_11;
  signed int tmp_statement_expression_9;
  signed int return_value_strncasecmp_8;
  signed int tmp_statement_expression_6;
  if(data == ((const char *)NULL))
    return 0;

  else
  {
    unsigned long int __s1_len;
    unsigned long int fe_send_event__1__1____s2_len;
    signed int return_value___builtin_strcmp_15;
    return_value___builtin_strcmp_15=__builtin_strcmp(data, "TOGGLE_FULLSCREEN");
    tmp_statement_expression_14 = return_value___builtin_strcmp_15;
    if(tmp_statement_expression_14 == 0)
    {
      if(!(this->toggle_fullscreen_cb == ((void (*)(struct fe_s *, signed int))NULL)))
        this->toggle_fullscreen_cb(this, -1);

    }

    else
    {
      return_value_strncasecmp_13=strncasecmp(data, "FULLSCREEN ", (unsigned long int)11);
      if(return_value_strncasecmp_13 == 0)
      {
        if(!(this->toggle_fullscreen_cb == ((void (*)(struct fe_s *, signed int))NULL)))
        {
          return_value_atoi_1=atoi(data + (signed long int)11);
          this->toggle_fullscreen_cb(this, return_value_atoi_1 != 0 ? 1 : 0);
        }

      }

      else
      {
        unsigned long int fe_send_event__1__4____s1_len;
        unsigned long int fe_send_event__1__4____s2_len;
        signed int return_value___builtin_strcmp_12;
        return_value___builtin_strcmp_12=__builtin_strcmp(data, "QUIT");
        tmp_statement_expression_11 = return_value___builtin_strcmp_12;
        if(tmp_statement_expression_11 == 0)
          this->terminate_key_pressed = (unsigned int)1;

        else
        {
          unsigned long int fe_send_event__1__6____s1_len;
          unsigned long int fe_send_event__1__6____s2_len;
          signed int return_value___builtin_strcmp_10;
          return_value___builtin_strcmp_10=__builtin_strcmp(data, "TOGGLE_DEINTERLACE");
          tmp_statement_expression_9 = return_value___builtin_strcmp_10;
          if(tmp_statement_expression_9 == 0)
          {
            signed int return_value_xine_get_param_2;
            return_value_xine_get_param_2=xine_get_param(this->stream, 0x01000000);
            xine_set_param(this->stream, 0x01000000, return_value_xine_get_param_2 != 0 ? 0 : 1);
          }

          else
          {
            return_value_strncasecmp_8=strncasecmp(data, "DEINTERLACE ", (unsigned long int)12);
            if(return_value_strncasecmp_8 == 0)
            {
              signed int return_value_atoi_3;
              return_value_atoi_3=atoi(data + (signed long int)12);
              xine_set_param(this->stream, 0x01000000, return_value_atoi_3 != 0 ? 1 : 0);
            }

            else
            {
              unsigned long int fe_send_event__1__9____s1_len;
              unsigned long int __s2_len;
              signed int return_value___builtin_strcmp_7;
              return_value___builtin_strcmp_7=__builtin_strcmp(data, "POWER_OFF");
              tmp_statement_expression_6 = return_value___builtin_strcmp_7;
              if(tmp_statement_expression_6 == 0)
                shutdown_system(this->shutdown_cmd, 1);

              else
              {
                do
                  if(SysLogLevel >= 3)
                    x_syslog(7, "[vdr-fe]    ", "Event: %s", data);

                while((_Bool)0);
                if(!(this->fe.fe_message_cb == ((void (*)(void *, const char *, const char *))NULL)))
                {
                  this->fe.fe_message_cb(this->fe.fe_message_h, data, (const char *)(void *)0);
                  return 1;
                }

                signed int return_value_find_input_plugin_5;
                return_value_find_input_plugin_5=find_input_plugin(this);
                if(!(return_value_find_input_plugin_5 == 0))
                {
                  if(!(this->input_plugin->f.post_vdr_event == ((signed int (*)(struct vdr_input_plugin_if_s *, const char *))NULL)))
                  {
                    char *msg = (char *)(void *)0;
                    signed int return_value_asprintf_4;
                    return_value_asprintf_4=asprintf_link1(&msg, "%s\r\n", data);
                    if(!(return_value_asprintf_4 >= 1))
                      msg = (char *)(void *)0;

                    if(!(msg == ((char *)NULL)))
                    {
                      signed int r;
                      r=this->input_plugin->f.post_vdr_event(this->input_plugin, msg);
                      free((void *)msg);
                      return r > 0 ? 1 : 0;
                    }

                    return 0;
                  }

                }

              }
            }
          }
        }
      }
    }
    return 1;
  }
}

// fe_send_input_event
// file xine_frontend.c line 1364
static signed int fe_send_input_event(struct frontend_s *this_gen, const char *map, const char *key, signed int repeat, signed int release)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[vdr-fe]    ", "Keypress: %s %s %s %s", map, key, repeat != 0 ? "Repeat" : "", release != 0 ? "Release" : "");

  while((_Bool)0);
  signed long int return_value_time_1;
  if(this->shutdown_timeout >= 1)
  {
    return_value_time_1=time((signed long int *)(void *)0);
    this->shutdown_time = return_value_time_1 + (signed long int)this->shutdown_timeout;
  }

  if(!(this->fe.fe_message_cb == ((void (*)(void *, const char *, const char *))NULL)))
  {
    this->fe.fe_message_cb(this->fe.fe_message_h, map, key);
    return 1;
  }

  else
  {
    signed int return_value_find_input_plugin_4;
    return_value_find_input_plugin_4=find_input_plugin(this);
    if(!(return_value_find_input_plugin_4 == 0))
    {
      if(!(this->input_plugin->f.post_vdr_event == ((signed int (*)(struct vdr_input_plugin_if_s *, const char *))NULL)))
      {
        char *msg = (char *)(void *)0;
        if(!(map == ((const char *)NULL)))
        {
          signed int return_value_asprintf_2;
          return_value_asprintf_2=asprintf_link1(&msg, "KEY %s %s %s %s\r\n", map, key, repeat != 0 ? "Repeat" : "", release != 0 ? "Release" : "");
          if(!(return_value_asprintf_2 >= 0))
            msg = (char *)(void *)0;

        }

        else
        {
          signed int return_value_asprintf_3;
          return_value_asprintf_3=asprintf_link1(&msg, "KEY %s\r\n", key);
          if(!(return_value_asprintf_3 >= 0))
            msg = (char *)(void *)0;

        }
        if(!(msg == ((char *)NULL)))
        {
          signed int r;
          r=this->input_plugin->f.post_vdr_event(this->input_plugin, msg);
          free((void *)msg);
          if(r >= 1)
            return 1;

        }

        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-fe]    ", "fe_send_input_event: message KEY %s lost", key);

        while((_Bool)0);
        return 0;
      }

    }

    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[vdr-fe]    ", "fe_send_input_event: handler not set, event lost !");

    while((_Bool)0);
    return 0;
  }
}

// fe_shutdown_init
// file xine_frontend.c line 801
static void fe_shutdown_init(struct frontend_s *this_gen, const char *cmd, signed int timeout)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  free((void *)this->shutdown_cmd);
  char *tmp_if_expr_2;
  char *return_value___strdup_1;
  if(!(cmd == ((const char *)NULL)))
  {
    return_value___strdup_1=__strdup(cmd);
    tmp_if_expr_2 = return_value___strdup_1;
  }

  else
    tmp_if_expr_2 = (char *)(void *)0;
  this->shutdown_cmd = tmp_if_expr_2;
  this->shutdown_timeout = timeout;
  signed long int tmp_if_expr_4;
  signed long int return_value_time_3;
  if(!(timeout >= 1))
    tmp_if_expr_4 = (signed long int)-1;

  else
  {
    return_value_time_3=time((signed long int *)(void *)0);
    tmp_if_expr_4 = return_value_time_3 + (signed long int)timeout;
  }
  this->shutdown_time = tmp_if_expr_4;
}

// fe_xine_close
// file xine_frontend.c line 1210
static void fe_xine_close(struct frontend_s *this_gen)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  if(!(this == ((struct fe_s *)NULL)))
  {
    if(!(this == ((struct fe_s *)NULL)))
    {
      if(!(this->xine == ((struct xine_s *)NULL)))
      {
        if(!(this->input_plugin == ((struct vdr_input_plugin_if_s *)NULL)))
        {
          this->input_plugin->f.xine_input_event = (void (*)(struct frontend_s *, const char *, const char *))(void *)0;
          this->input_plugin->f.fe_control = (void * (*)(struct frontend_s *, const char *))(void *)0;
        }

        if(this->stream == ((struct xine_stream_s *)NULL))
          goto __CPROVER_DUMP_L5;

        fe_xine_stop(this_gen);
        xine_close(this->stream);
        if(!(this->postplugins->pip_stream == ((struct xine_stream_s *)NULL)))
          xine_close(this->postplugins->pip_stream);

      }

    }

  }


__CPROVER_DUMP_L5:
  ;
}

// fe_xine_exit
// file xine_frontend.c line 1234
static void fe_xine_exit(struct frontend_s *this_gen)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  _Bool tmp_if_expr_1;
  if(!(this == ((struct fe_s *)NULL)))
  {
    if(!(this->xine == ((struct xine_s *)NULL)))
    {
      if(!(this->input_plugin == ((struct vdr_input_plugin_if_s *)NULL)))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = !(this->playback_finished != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        fe_xine_close(this_gen);

      fe_post_unload(this);
      if(!(this->configfile == ((char *)NULL)))
      {
        xine_config_save(this->xine, this->configfile);
        free((void *)this->configfile);
        this->configfile = (char *)(void *)0;
      }

      if(!(this->event_queue == ((struct xine_event_queue_s *)NULL)))
        xine_event_dispose_queue(this->event_queue);

      this->event_queue = (struct xine_event_queue_s *)(void *)0;
      if(!(this->stream == ((struct xine_stream_s *)NULL)))
        xine_dispose(this->stream);

      this->stream = (struct xine_stream_s *)(void *)0;
      if(!(this->postplugins == ((struct post_plugins_s *)NULL)))
      {
        if(!(this->postplugins->pip_stream == ((struct xine_stream_s *)NULL)))
          xine_dispose(this->postplugins->pip_stream);

        this->postplugins->pip_stream = (struct xine_stream_s *)(void *)0;
        free((void *)this->postplugins->static_post_plugins);
      }

      free((void *)this->postplugins);
      this->postplugins = (struct post_plugins_s *)(void *)0;
      if(!(this->slave_stream == ((struct xine_stream_s *)NULL)))
        xine_dispose(this->slave_stream);

      this->slave_stream = (struct xine_stream_s *)(void *)0;
      if(!(this->audio_port == ((struct xine_audio_port_s *)NULL)))
        xine_close_audio_driver(this->xine, this->audio_port);

      this->audio_port = (struct xine_audio_port_s *)(void *)0;
      init_dummy_ports(this, 0);
      if(!(this->video_port == ((struct xine_video_port_s_0 *)NULL)))
        xine_close_video_driver(this->xine, this->video_port);

      this->video_port = (struct xine_video_port_s_0 *)(void *)0;
      xine_exit(this->xine);
      this->xine = (struct xine_s *)(void *)0;
    }

  }

}

// fe_xine_init
// file xine_frontend.c line 581
static signed int fe_xine_init(struct frontend_s *this_gen, const char *audio_driver, const char *audio_port, const char *video_driver, signed int pes_buffers, const char *static_post_plugins, const char *config_file)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  struct post_plugins_s *posts = (struct post_plugins_s *)(void *)0;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  char *return_value___strdup_5;
  const char *return_value_xine_get_homedir_6;
  signed int return_value_asprintf_7;
  signed int tmp_statement_expression_8;
  _Bool tmp_if_expr_18;
  signed int tmp_statement_expression_16;
  _Bool tmp_if_expr_15;
  signed int tmp_statement_expression_13;
  _Bool tmp_if_expr_12;
  signed int tmp_statement_expression_10;
  _Bool tmp_if_expr_22;
  signed int tmp_statement_expression_20;
  signed int tmp_statement_expression_23;
  if(this == ((struct fe_s *)NULL))
    return 0;

  else
  {
    signed int return_value_xine_check_version_4;
    return_value_xine_check_version_4=xine_check_version(1, 1, 0);
    if(return_value_xine_check_version_4 == 0)
    {
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[vdr-fe]    ", "xine-lib is too old, require at least xine library version 1.1.0\n");
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          if(!(*return_value___errno_location_3 == 0))
          {
            return_value___errno_location_1=__errno_location();
            return_value_strerror_2=strerror(*return_value___errno_location_1);
            x_syslog(3, "[vdr-fe]    ", "   (ERROR (%s,%d): %s)", (const void *)"xine_frontend.c", 596, return_value_strerror_2);
          }

        }

      while((_Bool)0);
      return 0;
    }

    else
    {
      if(!(this->xine == ((struct xine_s *)NULL)))
        this->fe.xine_exit(this_gen);

      this->stream = (struct xine_stream_s *)(void *)0;
      this->video_port = (struct xine_video_port_s_0 *)(void *)0;
      this->audio_port = (struct xine_audio_port_s *)(void *)0;
      this->input_plugin = (struct vdr_input_plugin_if_s *)(void *)0;
      this->xine=xine_new();
      if(this->xine == ((struct xine_s *)NULL))
        return 0;

      else
      {
        this->xine->verbosity = (signed int)(SysLogLevel > 2);
        free((void *)this->configfile);
        this->configfile = (char *)(void *)0;
        if(!(config_file == ((const char *)NULL)))
        {
          return_value___strdup_5=__strdup(config_file);
          this->configfile = return_value___strdup_5;
        }

        else
        {
          return_value_xine_get_homedir_6=xine_get_homedir();
          return_value_asprintf_7=asprintf_link1(&this->configfile, "%s%s", return_value_xine_get_homedir_6, (const void *)"/.xine/config_xineliboutput");
          if(!(return_value_asprintf_7 >= 0))
            return 0;

        }
        do
          if(SysLogLevel >= 3)
            x_syslog(7, "[vdr-fe]    ", "Using xine-lib config file %s", this->configfile);

        while((_Bool)0);
        make_dirs(this->configfile);
        xine_config_load(this->xine, this->configfile);
        xine_config_register_num(this->xine, "engine.buffers.video_num_buffers", 500, "number of video buffers", "The number of video buffers (each is 8k in size) xine uses in its internal queue. Higher values mean smoother playback for unreliable inputs, but also increased latency and memory consumption.", 20, (void (*)(void *, struct xine_cfg_entry_s *))(void *)0, (void *)0);
        xine_config_register_bool(this->xine, "gui.osd_use_unscaled", 0, "Use unscaled OSD", "Use unscaled (full screen resolution) OSD if possible", 10, (void (*)(void *, struct xine_cfg_entry_s *))(void *)0, (void *)0);
        xine_init(this->xine);
        this->xine->config->update_num(this->xine->config, "video.device.xv_double_buffer", 1);
        this->xine->config->update_num(this->xine->config, "engine.buffers.video_num_buffers", pes_buffers);
        if(!(this->video_port_name == ((char *)NULL)))
        {
          if(!(video_driver == ((const char *)NULL)))
          {
            unsigned long int fe_xine_init__1__4__1____s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp_9;
            return_value___builtin_strcmp_9=__builtin_strcmp(video_driver, "fb");
            tmp_statement_expression_8 = return_value___builtin_strcmp_9;
            if(tmp_statement_expression_8 == 0)
              this->xine->config->update_string(this->xine->config, "video.device.fb_device", this->video_port_name);

          }

        }

        this->playback_finished = (unsigned char)0;
        if(!(video_driver == ((const char *)NULL)))
        {
          unsigned long int fe_xine_init__1__5____s1_len;
          unsigned long int fe_xine_init__1__5____s2_len;
          signed int return_value___builtin_strcmp_17;
          return_value___builtin_strcmp_17=__builtin_strcmp(video_driver, "none");
          tmp_statement_expression_16 = return_value___builtin_strcmp_17;
          tmp_if_expr_18 = !(tmp_statement_expression_16 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_18 = (_Bool)0;
        if(tmp_if_expr_18)
          this->video_port=xine_open_video_driver(this->xine, video_driver, 0, (void *)0);

        else
        {
          if(!(video_driver == ((const char *)NULL)))
          {
            unsigned long int __s1_len;
            unsigned long int fe_xine_init__1__6____s2_len;
            signed int return_value___builtin_strcmp_14;
            return_value___builtin_strcmp_14=__builtin_strcmp(video_driver, "dxr3");
            tmp_statement_expression_13 = return_value___builtin_strcmp_14;
            tmp_if_expr_15 = !(tmp_statement_expression_13 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_15 = (_Bool)0;
          if(tmp_if_expr_15)
            this->video_port=xine_open_video_driver(this->xine, video_driver, 1, (void *)0);

          else
          {
            if(!(video_driver == ((const char *)NULL)))
            {
              unsigned long int fe_xine_init__1__7____s1_len;
              unsigned long int fe_xine_init__1__7____s2_len;
              signed int return_value___builtin_strcmp_11;
              return_value___builtin_strcmp_11=__builtin_strcmp(video_driver, "aadxr3");
              tmp_statement_expression_10 = return_value___builtin_strcmp_11;
              tmp_if_expr_12 = !(tmp_statement_expression_10 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_12 = (_Bool)0;
            if(tmp_if_expr_12)
              this->video_port=xine_open_video_driver(this->xine, video_driver, 2, (void *)0);

            else
              this->video_port=xine_open_video_driver(this->xine, video_driver, this->xine_visual_type, (void *)&this->_anon0.vis);
          }
        }
        if(this->video_port == ((struct xine_video_port_s_0 *)NULL))
        {
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-fe]    ", "fe_xine_init: xine_open_video_driver(\"%s\") failed", video_driver != ((const char *)NULL) ? video_driver : "(NULL)");

          this->fe.xine_exit(this_gen);
          return 0;
        }

        else
        {
          intercept_video_driver(this->video_port);
          if(!(this->frame_draw_cb == ((void (*)(void *, struct vo_frame_s_0 *))NULL)))
          {
            struct vo_driver_s_0 *frameoutput;
            frameoutput=vo_frameoutput_init((void *)this, this->frame_draw_cb);
            signed int return_value_wire_video_driver_19;
            return_value_wire_video_driver_19=wire_video_driver(this->video_port, frameoutput);
            if(return_value_wire_video_driver_19 == 0)
            {
              if(SysLogLevel >= 2)
                x_syslog(6, "[vdr-fe]    ", "wire_video_driver() for frame output handler failed");

              frameoutput->dispose(frameoutput);
            }

          }

          this->video_port_none = (struct xine_video_port_s_0 *)(void *)0;
          if(!(this->update_display_size_cb == ((void (*)(struct fe_s *))NULL)))
            this->update_display_size_cb(this);

          if(!(audio_driver == ((const char *)NULL)) && !(audio_port == ((const char *)NULL)))
            configure_audio_out(this, audio_driver, audio_port);

          if(!(audio_driver == ((const char *)NULL)))
          {
            unsigned long int fe_xine_init__1__10____s1_len;
            unsigned long int fe_xine_init__1__10____s2_len;
            signed int return_value___builtin_strcmp_21;
            return_value___builtin_strcmp_21=__builtin_strcmp(audio_driver, "auto");
            tmp_statement_expression_20 = return_value___builtin_strcmp_21;
            tmp_if_expr_22 = !(tmp_statement_expression_20 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_22 = (_Bool)0;
          if(tmp_if_expr_22)
            this->audio_port=xine_open_audio_driver(this->xine, (const char *)(void *)0, (void *)0);

          else
            this->audio_port=xine_open_audio_driver(this->xine, audio_driver, (void *)0);
          if(this->audio_port == ((struct xine_audio_port_s *)NULL))
          {
            if(!(audio_driver == ((const char *)NULL)))
            {
              unsigned long int fe_xine_init__1__13____s1_len;
              unsigned long int fe_xine_init__1__13____s2_len;
              signed int return_value___builtin_strcmp_24;
              return_value___builtin_strcmp_24=__builtin_strcmp(audio_driver, "none");
              tmp_statement_expression_23 = return_value___builtin_strcmp_24;
              if(!(tmp_statement_expression_23 == 0))
              {
                if(SysLogLevel >= 2)
                  x_syslog(6, "[vdr-fe]    ", "fe_xine_init: xine_open_audio_driver(\"%s%s%s\") failed", audio_driver != ((const char *)NULL) ? audio_driver : "(NULL)", audio_port != ((const char *)NULL) ? ":" : "", audio_port != ((const char *)NULL) ? audio_port : "");

              }

            }

          }

          this->audio_port_none = (struct xine_audio_port_s *)(void *)0;
          this->stream=xine_stream_new(this->xine, this->audio_port, this->video_port);
          this->slave_stream = (struct xine_stream_s *)(void *)0;
          if(this->stream == ((struct xine_stream_s *)NULL))
          {
            if(SysLogLevel >= 2)
              x_syslog(6, "[vdr-fe]    ", "fe_xine_init: xine_stream_new failed");

            this->fe.xine_exit(this_gen);
            return 0;
          }

          else
          {
            this->event_queue=xine_event_new_queue(this->stream);
            xine_event_create_listener_thread(this->event_queue, xine_event_cb, (void *)this);
            if(this->event_queue == ((struct xine_event_queue_s *)NULL))
            {
              if(SysLogLevel >= 2)
                x_syslog(6, "[vdr-fe]    ", "fe_xine_init: xine_event_new_queue failed");

            }

            this->pes_buffers = (unsigned short int)pes_buffers;
            void *return_value_calloc_25;
            return_value_calloc_25=calloc((unsigned long int)1, sizeof(struct post_plugins_s) /*120ul*/ );
            this->postplugins = (struct post_plugins_s *)return_value_calloc_25;
            posts = this->postplugins;
            posts->xine = this->xine;
            posts->audio_port = this->audio_port;
            posts->video_port = this->video_port;
            posts->audio_source = this->stream;
            posts->video_source = posts->audio_source;
            signed int return_value_guess_cpu_count_28;
            return_value_guess_cpu_count_28=guess_cpu_count();
            if(return_value_guess_cpu_count_28 >= 2)
            {
              signed int return_value_xine_check_version_26;
              return_value_xine_check_version_26=xine_check_version(1, 1, 9);
              if(return_value_xine_check_version_26 == 0)
              {
                if(SysLogLevel >= 2)
                  x_syslog(6, "[vdr-fe]    ", "FFmpeg multithreaded video decoding is not supported in xine-lib < 1.1.9");

              }

              else
                if(SysLogLevel >= 2)
                  x_syslog(6, "[vdr-fe]    ", "Enabling FFmpeg multithreaded video decoding");

              signed int return_value_guess_cpu_count_27;
              return_value_guess_cpu_count_27=guess_cpu_count();
              this->xine->config->update_num(this->xine->config, "video.processing.ffmpeg_thread_count", return_value_guess_cpu_count_27);
            }

            if(!(static_post_plugins == ((const char *)NULL)))
            {
              if(!(*static_post_plugins == 0))
              {
                signed int i;
                if(SysLogLevel >= 3)
                  x_syslog(7, "[vdr-fe]    ", "static post plugins (from command line): %s", static_post_plugins);

                char *return_value___strdup_29;
                return_value___strdup_29=__strdup(static_post_plugins);
                posts->static_post_plugins = return_value___strdup_29;
                vpplugin_parse_and_store_post(posts, posts->static_post_plugins);
                applugin_parse_and_store_post(posts, posts->static_post_plugins);
                i = 0;
                if(!(i >= posts->post_audio_elements_num))
                {
                  if(!(posts->post_audio_elements[(signed long int)i] == ((struct anonymous_26 *)NULL)))
                    posts->post_audio_elements[(signed long int)i]->enable = 2;

                  i = i + 1;
                }

                i = 0;
                if(!(i >= posts->post_video_elements_num))
                {
                  if(!(posts->post_video_elements[(signed long int)i] == ((struct anonymous_26 *)NULL)))
                    posts->post_video_elements[(signed long int)i]->enable = 2;

                  i = i + 1;
                }

                posts->post_video_enable = 1;
                posts->post_audio_enable = 1;
              }

            }

            this->video_height = (unsigned short int)0;
            this->video_width = this->video_height;
            return 1;
          }
        }
      }
    }
  }
}

// fe_xine_open
// file xine_frontend.c line 819
static signed int fe_xine_open(struct frontend_s *this_gen, const char *mrl)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  signed int result = 0;
  char *url = (char *)(void *)0;
  if(this == ((struct fe_s *)NULL))
    return 0;

  else
  {
    this->input_plugin = (struct vdr_input_plugin_if_s *)(void *)0;
    this->playback_finished = (unsigned char)1;
    this->terminate_key_pressed = (unsigned int)0;
    signed int return_value_asprintf_1;
    return_value_asprintf_1=asprintf_link1(&url, "%s#nocache", (_Bool)mrl ? mrl : "xvdr://");
    if(!(return_value_asprintf_1 >= 0))
      return 0;

    else
    {
      result=xine_open(this->stream, url);
      if(result == 0)
      {
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-fe]    ", "fe_xine_open: xine_open(\"%s\") failed", url);

        while((_Bool)0);
        free((void *)url);
        return 0;
      }

      else
      {
        free((void *)url);
        this->xine->config->update_num(this->xine->config, "engine.buffers.video_num_buffers", (signed int)this->pes_buffers);
        return result;
      }
    }
  }
}

// fe_xine_play
// file xine_frontend.c line 1161
static signed int fe_xine_play(struct frontend_s *this_gen)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  if(this == ((struct fe_s *)NULL))
    return 0;

  else
  {
    fe_post_rewire(this);
    this->input_plugin = (struct vdr_input_plugin_if_s *)(void *)0;
    signed int return_value_xine_play_1;
    return_value_xine_play_1=xine_play(this->stream, 0, 0);
    this->playback_finished = (unsigned char)(return_value_xine_play_1 != 0 ? 0 : 1);
    signed int return_value_find_input_plugin_2;
    return_value_find_input_plugin_2=find_input_plugin(this);
    if(return_value_find_input_plugin_2 == 0)
      return -1;

    else
    {
      this->input_plugin->f.xine_input_event = this->fe.fe_message_cb != ((void (*)(void *, const char *, const char *))NULL) ? input_event_cb : (void (*)(struct frontend_s *this_gen, const char *keymap, const char *key))(void *)0;
      this->input_plugin->f.fe_control = fe_control;
      this->input_plugin->f.fe_handle = this_gen;
      if(!(this->playback_finished == 0))
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-fe]    ", "Error playing xvdr:// !");

        while((_Bool)0);

      char str[128l];
      snprintf_link1(str, sizeof(char [128l]) /*128ul*/ , "INFO WINDOW %dx%d", this->width, this->height);
      this->fe.send_event(&this->fe, str);
      return (signed int)!(this->playback_finished != 0);
    }
  }
}

// fe_xine_stop
// file xine_frontend.c line 1190
static signed int fe_xine_stop(struct frontend_s *this_gen)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  if(this == ((struct fe_s *)NULL))
    return 0;

  else
  {
    this->input_plugin = (struct vdr_input_plugin_if_s *)(void *)0;
    this->playback_finished = (unsigned char)1;
    if(this->stream == ((struct xine_stream_s *)NULL))
      return 0;

    else
    {
      xine_stop(this->stream);
      fe_post_unwire(this);
      return 1;
    }
  }
}

// fgets
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 253
static inline char * fgets(char * restrict __s, signed int __n, struct _IO_FILE * restrict __stream)
{
  char *return_value___fgets_chk_1;
  char *return_value___fgets_chk_warn_2;
  char *return_value___fgets_alias_3;
  return_value___fgets_alias_3=__fgets_alias(__s, __n, __stream);
  return return_value___fgets_alias_3;
}

// fgets_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 253
static inline char * fgets_link1(char * restrict __s_link1, signed int __n_link1, struct _IO_FILE * restrict __stream_link1)
{
  char *return_value___fgets_chk_1_link1;
  char *return_value___fgets_chk_warn_2_link1;
  char *return_value___fgets_alias_3_link1;
  return_value___fgets_alias_3_link1=__fgets_alias(__s_link1, __n_link1, __stream_link1);
  return return_value___fgets_alias_3_link1;
}

// find_argb_visual
// file xine_sxfe_frontend.c line 774
static struct anonymous_16 * find_argb_visual(struct _XDisplay *dpy, signed int scr)
{
  struct anonymous_17 *xvi;
  struct anonymous_17 template;
  signed int nvi;
  signed int i;
  struct anonymous_21 *format;
  struct anonymous_16 *visual;
  template.screen = scr;
  template.depth = 32;
  template.class = 4;
  xvi=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x4 | 0x8), &template, &nvi);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  if(xvi == ((struct anonymous_17 *)NULL))
  {
    do
      if(SysLogLevel >= 1)
      {
        x_syslog(3, "[vdr-sxfe]  ", "find_argb_visual: XGetVisualInfo failed (no xvi)");
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        if(!(*return_value___errno_location_3 == 0))
        {
          return_value___errno_location_1=__errno_location();
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 788, return_value_strerror_2);
        }

      }

    while((_Bool)0);
    return ((struct anonymous_16 *)NULL);
  }

  else
  {
    visual = ((struct anonymous_16 *)NULL);
    i = 0;
    for( ; !(i >= nvi); i = i + 1)
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-sxfe]  ", "find_argb_visual: iteration %d of %d", i, nvi);

      while((_Bool)0);
      format=XRenderFindVisualFormat(dpy, (xvi + (signed long int)i)->visual);
      if(format->type == 1)
      {
        if(!(format->direct.alphaMask == 0))
        {
          visual = (xvi + (signed long int)i)->visual;
          break;
        }

      }

    }
    XFree((void *)xvi);
    if(visual == ((struct anonymous_16 *)NULL))
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[vdr-sxfe]  ", "find_argb_visual: No visual found");
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          if(!(*return_value___errno_location_6 == 0))
          {
            return_value___errno_location_4=__errno_location();
            return_value_strerror_5=strerror(*return_value___errno_location_4);
            x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 805, return_value_strerror_5);
          }

        }

      while((_Bool)0);

    return visual;
  }
}

// find_input_plugin
// file xine_frontend.c line 191
static signed int find_input_plugin(struct fe_s *this)
{
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  signed int tmp_statement_expression_4;
  if(this->input_plugin == ((struct vdr_input_plugin_if_s *)NULL))
  {
    if(this->stream == ((struct xine_stream_s *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = !(this->stream->input_plugin != ((struct input_plugin_s *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = !(this->stream->input_plugin->input_class != ((struct input_class_s_0 *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = this->playback_finished != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[vdr-fe]    ", "find_input_plugin: stream not initialized or playback finished !");

      while((_Bool)0);
      usleep((unsigned int)(100 * 1000));
      return 0;
    }

    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_5;
    return_value___builtin_strcmp_5=__builtin_strcmp(this->stream->input_plugin->input_class->identifier, "xvdr");
    tmp_statement_expression_4 = return_value___builtin_strcmp_5;
    if(!(tmp_statement_expression_4 == 0))
    {
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[vdr-fe]    ", "find_input_plugin: current xine input plugin is not xvdr !");

      while((_Bool)0);
      return 0;
    }

    this->input_plugin = (struct vdr_input_plugin_if_s *)this->stream->input_plugin;
  }

  return 1;
}

// fprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf(struct _IO_FILE * restrict __stream, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack_1;
  return_value___builtin_va_arg_pack_1=__builtin_va_arg_pack();
  signed int return_value___fprintf_chk_2;
  return_value___fprintf_chk_2=__fprintf_chk(__stream, 2 - 1, __fmt, return_value___builtin_va_arg_pack_1);
  return return_value___fprintf_chk_2;
}

// fprintf_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf_link1(struct _IO_FILE * restrict __stream_link1, const char * restrict __fmt_link1, ...)
{
  void *return_value___builtin_va_arg_pack_1_link1;
  return_value___builtin_va_arg_pack_1_link1=__builtin_va_arg_pack();
  signed int return_value___fprintf_chk_2_link1;
  return_value___fprintf_chk_2_link1=__fprintf_chk(__stream_link1, 2 - 1, __fmt_link1, return_value___builtin_va_arg_pack_1_link1);
  return return_value___fprintf_chk_2_link1;
}

// fprintf_link2
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf_link2(struct _IO_FILE * restrict __stream_link2, const char * restrict __fmt_link2, ...)
{
  void *return_value___builtin_va_arg_pack_1_link2;
  return_value___builtin_va_arg_pack_1_link2=__builtin_va_arg_pack();
  signed int return_value___fprintf_chk_2_link2;
  return_value___fprintf_chk_2_link2=__fprintf_chk(__stream_link2, 2 - 1, __fmt_link2, return_value___builtin_va_arg_pack_1_link2);
  return return_value___fprintf_chk_2_link2;
}

// fprintf_link3
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf_link3(struct _IO_FILE * restrict __stream_link3, const char * restrict __fmt_link3, ...)
{
  void *return_value___builtin_va_arg_pack_1_link3;
  return_value___builtin_va_arg_pack_1_link3=__builtin_va_arg_pack();
  signed int return_value___fprintf_chk_2_link3;
  return_value___fprintf_chk_2_link3=__fprintf_chk(__stream_link3, 2 - 1, __fmt_link3, return_value___builtin_va_arg_pack_1_link3);
  return return_value___fprintf_chk_2_link3;
}

// fprintf_link4
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf_link4(struct _IO_FILE * restrict __stream_link4, const char * restrict __fmt_link4, ...)
{
  void *return_value___builtin_va_arg_pack_1_link4;
  return_value___builtin_va_arg_pack_1_link4=__builtin_va_arg_pack();
  signed int return_value___fprintf_chk_2_link4;
  return_value___fprintf_chk_2_link4=__fprintf_chk(__stream_link4, 2 - 1, __fmt_link4, return_value___builtin_va_arg_pack_1_link4);
  return return_value___fprintf_chk_2_link4;
}

// get_opt_val
// file xine_frontend.c line 1033
static signed int get_opt_val(const char *s, const char *opt)
{
  signed int val = -1;
  const char *pt;
  pt=strstr(s, opt);
  unsigned long int return_value_strlen_1;
  signed int return_value_sscanf_2;
  if(!(pt == ((const char *)NULL)))
  {
    return_value_strlen_1=strlen(opt);
    return_value_sscanf_2=sscanf(pt + (signed long int)return_value_strlen_1 + (signed long int)1, "%d", &val);
    if(!(return_value_sscanf_2 == 1))
      goto __CPROVER_DUMP_L1;

    return val;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return -1;
  }
}

// gnome_screensaver_control
// file tools/gnome_screensaver.h line 4
extern void gnome_screensaver_control(signed int enable)
{
  struct _DBusGConnection *connection;
  struct _GError *error;
  struct _DBusGProxy *proxy;
  signed int ret;
  error = (struct _GError *)(void *)0;
  connection=dbus_g_bus_get((enum anonymous_6)DBUS_BUS_SESSION, &error);
  char *tmp_if_expr_1;
  unsigned int return_value_dbus_g_error_quark_3;
  unsigned int return_value_dbus_g_error_quark_4;
  _Bool tmp_if_expr_7;
  const char *return_value_dbus_g_error_get_name_5;
  if(connection == ((struct _DBusGConnection *)NULL))
  {
    do
      if(SysLogLevel >= 2)
      {
        if(!(error == ((struct _GError *)NULL)))
          tmp_if_expr_1 = error->message;

        else
          tmp_if_expr_1 = "<null>";
        x_syslog(6, "[scrnsaver] ", "Failed to open connection to bus: %s", tmp_if_expr_1);
      }

    while((_Bool)0);
    g_error_free(error);
  }

  else
  {
    signed int return_value_gnome_sessionmanager_control_2;
    return_value_gnome_sessionmanager_control_2=gnome_sessionmanager_control(connection, enable);
    if(return_value_gnome_sessionmanager_control_2 == 0)
    {
      proxy=dbus_g_proxy_new_for_name(connection, "org.gnome.ScreenSaver", "/org/gnome/ScreenSaver", "org.gnome.ScreenSaver");
      if(proxy == ((struct _DBusGProxy *)NULL))
        do
          if(SysLogLevel >= 3)
            x_syslog(7, "[scrnsaver] ", "Failed to get a proxy for org.gnome.ScreenSaver");

        while((_Bool)0);

      else
      {
        error = (struct _GError *)(void *)0;
        if(!(enable == 0))
        {
          ret=dbus_g_proxy_call(proxy, "UnInhibit", &error, (unsigned long int)(7 << 2), cookie, (unsigned long int)(0 << 2), (unsigned long int)(0 << 2));
          if(ret == 0)
          {
            return_value_dbus_g_error_quark_3=dbus_g_error_quark();
            if(error->domain == return_value_dbus_g_error_quark_3)
            {
              if(error->code == 19)
              {
                do
                  if(SysLogLevel >= 2)
                    x_syslog(6, "[scrnsaver] ", "GNOME screensaver 2.15 API failed, trying 2.14 API");

                while((_Bool)0);
                g_error_free(error);
                error = (struct _GError *)(void *)0;
                ret=dbus_g_proxy_call(proxy, "AllowActivation", &error, (unsigned long int)(0 << 2), (unsigned long int)(0 << 2));
              }

            }

          }

        }

        else
        {
          ret=dbus_g_proxy_call(proxy, "Inhibit", &error, (unsigned long int)(16 << 2), (const void *)"vdr-sxfe", (unsigned long int)(16 << 2), (const void *)"Watching TV", (unsigned long int)(0 << 2), (unsigned long int)(7 << 2), &cookie, (unsigned long int)(0 << 2));
          if(ret == 0)
          {
            return_value_dbus_g_error_quark_4=dbus_g_error_quark();
            if(error->domain == return_value_dbus_g_error_quark_4)
            {
              if(error->code == 19)
              {
                do
                  if(SysLogLevel >= 2)
                    x_syslog(6, "[scrnsaver] ", "GNOME screensaver 2.15 API failed, trying 2.14 API");

                while((_Bool)0);
                g_error_free(error);
                error = (struct _GError *)(void *)0;
                ret=dbus_g_proxy_call(proxy, "InhibitActivation", &error, (unsigned long int)(16 << 2), (const void *)"Watching TV", (unsigned long int)(0 << 2), (unsigned long int)(0 << 2));
              }

            }

          }

        }
        if(ret == 0)
        {
          unsigned int return_value_dbus_g_error_quark_6;
          return_value_dbus_g_error_quark_6=dbus_g_error_quark();
          if(error->domain == return_value_dbus_g_error_quark_6)
            tmp_if_expr_7 = error->code == 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_7 = (_Bool)0;
          if(tmp_if_expr_7)
            do
              if(SysLogLevel >= 2)
              {
                return_value_dbus_g_error_get_name_5=dbus_g_error_get_name(error);
                x_syslog(6, "[scrnsaver] ", "Caught remote method exception %s: %s", return_value_dbus_g_error_get_name_5, error->message);
              }

            while((_Bool)0);

          else
            do
              if(SysLogLevel >= 2)
                x_syslog(6, "[scrnsaver] ", "Error: %s", error->message);

            while((_Bool)0);
          g_error_free(error);
        }

        else
          do
            if(SysLogLevel >= 2)
              x_syslog(6, "[scrnsaver] ", enable != 0 ? "GNOME screensaver enabled" : "GNOME screensaver disabled");

          while((_Bool)0);
        g_object_unref((void *)proxy);
      }
    }

  }
}

// gnome_sessionmanager_control
// file tools/gnome_screensaver.c line 62
static signed int gnome_sessionmanager_control(struct _DBusGConnection *connection, signed int enable)
{
  struct _GError *error;
  struct _DBusGProxy *proxy;
  signed int ret;
  proxy=dbus_g_proxy_new_for_name(connection, "org.gnome.SessionManager", "/org/gnome/SessionManager", "org.gnome.SessionManager");
  _Bool tmp_if_expr_3;
  const char *return_value_dbus_g_error_get_name_1;
  if(proxy == ((struct _DBusGProxy *)NULL))
  {
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[scrnsaver] ", "Failed to get a proxy for org.gnome.SessionManager");

    while((_Bool)0);
    return 0;
  }

  else
  {
    error = (struct _GError *)(void *)0;
    if(!(enable == 0))
      ret=dbus_g_proxy_call(proxy, "Uninhibit", &error, (unsigned long int)(7 << 2), cookie, (unsigned long int)(0 << 2), (unsigned long int)(0 << 2));

    else
      ret=dbus_g_proxy_call(proxy, "Inhibit", &error, (unsigned long int)(16 << 2), (const void *)"vdr-sxfe", (unsigned long int)(7 << 2), 0, (unsigned long int)(16 << 2), (const void *)"Watching TV", (unsigned long int)(7 << 2), 12, (unsigned long int)(0 << 2), (unsigned long int)(7 << 2), &cookie, (unsigned long int)(0 << 2));
    g_object_unref((void *)proxy);
    if(ret == 0)
    {
      unsigned int return_value_dbus_g_error_quark_2;
      return_value_dbus_g_error_quark_2=dbus_g_error_quark();
      if(error->domain == return_value_dbus_g_error_quark_2)
        tmp_if_expr_3 = error->code == 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        do
          if(SysLogLevel >= 2)
          {
            return_value_dbus_g_error_get_name_1=dbus_g_error_get_name(error);
            x_syslog(6, "[scrnsaver] ", "Caught remote method exception %s: %s", return_value_dbus_g_error_get_name_1, error->message);
          }

        while((_Bool)0);

      else
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[scrnsaver] ", "Error: %s", error->message);

        while((_Bool)0);
      g_error_free(error);
      return 0;
    }

    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[scrnsaver] ", enable != 0 ? "GNOME screensaver enabled" : "GNOME screensaver disabled");

    while((_Bool)0);
    return 1;
  }
}

// guess_cpu_count
// file xine_frontend.c line 80
static signed int guess_cpu_count(void)
{
  struct _IO_FILE *f;
  char *return_value_fgets_1;
  static signed int cores = -1;
  if(cores >= 0)
    return cores;

  else
  {
    cores = 0;
    f=fopen("/proc/cpuinfo", "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
    {
      char buf[256l];
      do
      {
        return_value_fgets_1=fgets(buf, 255, f);
        if(return_value_fgets_1 == ((char *)NULL))
          break;

        sscanf(buf, "processor : %d", &cores);
      }
      while((_Bool)1);
      fclose(f);
    }

    cores = cores + 1;
    if(cores >= 2)
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[vdr-fe]    ", "Detected %d CPUs", cores);

      while((_Bool)0);

    else
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-fe]    ", "Detected single CPU. Multithreaded decoding and post processing disabled.");

      while((_Bool)0);
    return cores;
  }
}

// hud_fill_argb
// file xine_sxfe_frontend.c line 810
static void hud_fill_argb(unsigned int *dst, signed int dst_pitch, struct osd_command_s *cmd)
{
  unsigned int *data = (unsigned int *)cmd->_anon0.raw_data;
  unsigned int y;
  dst = dst + (signed long int)((signed int)cmd->y * dst_pitch + (signed int)cmd->x);
  y = (unsigned int)cmd->h;
  for( ; !(y == 0u); y = y - 1u)
  {
    memcpy((void *)dst, (const void *)data, (unsigned long int)cmd->w * sizeof(unsigned int) /*4ul*/ );
    data = data + (signed long int)cmd->w;
    dst = dst + (signed long int)dst_pitch;
  }
}

// hud_fill_img_memory
// file xine_sxfe_frontend.c line 847
static void hud_fill_img_memory(unsigned int *dst, signed int dst_pitch, unsigned int *mask, signed int mask_pitch, signed int *mask_changed, struct osd_command_s *cmd)
{
  if((signed int)cmd->cmd == 11)
    osd_fill_lut8(dst, dst_pitch, 1, cmd);

  else
    if((signed int)cmd->cmd == 12)
      hud_fill_argb(dst, dst_pitch, cmd);

    else
      if((signed int)cmd->cmd == 2)
        rle_uncompress_argb(dst + (signed long int)((signed int)cmd->y * dst_pitch) + (signed long int)cmd->x, (unsigned int)cmd->w, (unsigned int)cmd->h, (unsigned int)dst_pitch, cmd->_anon0.data, cmd->num_rle, cmd->_anon1.palette, cmd->colors);

      else
      {
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-sxfe]  ", "hud_fill_img_memory(): unsupported format");

        while((_Bool)0);
        goto __CPROVER_DUMP_L6;
      }
  if(!(mask_changed == ((signed int *)NULL)) && !(mask == ((unsigned int *)NULL)))
    update_mask(dst, dst_pitch, mask, mask_pitch, mask_changed, cmd);


__CPROVER_DUMP_L6:
  ;
}

// hud_frame_output_cb
// file xine_sxfe_frontend.c line 1071
static void hud_frame_output_cb(void *data, signed int video_width, signed int video_height, double video_pixel_aspect, signed int *dest_x, signed int *dest_y, signed int *dest_width, signed int *dest_height, double *dest_pixel_aspect, signed int *win_x, signed int *win_y)
{
  struct sxfe_s *this = (struct sxfe_s *)data;
  this->_anon0.x.frame_output_handler(data, video_width, video_height, video_pixel_aspect, dest_x, dest_y, dest_width, dest_height, dest_pixel_aspect, win_x, win_y);
  if(!(this->video_win_active == 0))
  {
    pthread_mutex_lock(&this->video_win_mutex);
    if(!(this->video_win_changed == 0))
    {
      unsigned long int win = this->window[(signed long int)!(!(this->fullscreen != 0))];
      struct _XGC *gc;
      gc=XCreateGC(this->display, win, (unsigned long int)0, (struct anonymous_77 *)(void *)0);
      XSetForeground(this->display, gc, (unsigned long int)0x00000000);
      XFillRectangle(this->display, win, gc, 0, 0, (unsigned int)((signed int)this->_anon0.x.width - 1), (unsigned int)((signed int)this->_anon0.x.height - 1));
      XFreeGC(this->display, gc);
    }

    *dest_x = (signed int)this->video_win_x;
    *dest_y = (signed int)this->video_win_y;
    *dest_width = (signed int)this->video_win_w;
    *dest_height = (signed int)this->video_win_h;
    this->video_win_changed = (unsigned char)0;
    pthread_mutex_unlock(&this->video_win_mutex);
  }

}

// hud_osd_close
// file xine_sxfe_frontend.c line 1301
static void hud_osd_close(struct sxfe_s *this)
{
  if(!(this == ((struct sxfe_s *)NULL)))
  {
    if(!(this->hud == 0))
    {
      XLockDisplay(this->display);
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-sxfe]  ", "closing hud window...");

      while((_Bool)0);
      if(!(this->xshm_completion_event == -1))
      {
        XShmDetach(this->display, &this->hud_shminfo);
        this->hud_img->f.destroy_image(this->hud_img);
        shmdt((const void *)this->hud_shminfo.shmaddr);
        shmctl(this->hud_shminfo.shmid, 0, ((struct shmid_ds *)NULL));
      }

      else
        this->hud_img->f.destroy_image(this->hud_img);
      if(!(this->shape_mask_picture == 0ul))
        XRenderFreePicture(this->display, this->shape_mask_picture);

      if(!(this->shape_mask_pixmap == 0ul))
        XFreePixmap(this->display, this->shape_mask_pixmap);

      free((void *)this->shape_mask_mem);
      if(!(this->surf_back_img == ((struct _xrender_surf *)NULL)))
        xrender_surf_free(this->display, this->surf_back_img);

      if(!(this->surf_img == ((struct _xrender_surf *)NULL)))
        xrender_surf_free(this->display, this->surf_img);

      if(!(this->surf_win == ((struct _xrender_surf *)NULL)))
        xrender_surf_free(this->display, this->surf_win);

      XDestroyWindow(this->display, this->hud_window);
      XUnlockDisplay(this->display);
    }

  }

}

// hud_osd_command
// file xine_sxfe_frontend.c line 1013
static signed int hud_osd_command(struct frontend_s *this_gen, struct osd_command_s *cmd)
{
  struct sxfe_s *this = (struct sxfe_s *)this_gen;
  if(!(cmd == ((struct osd_command_s *)NULL)) && !(this == ((struct sxfe_s *)NULL)))
  {
    if(!(this->hud == 0))
    {
      osd_command(this, cmd);
      if((0x10 & (signed int)cmd->flags) == 0)
        return 1;

      XLockDisplay(this->display);
      switch((signed int)cmd->cmd)
      {
        case 0:
        {
          do
            if(SysLogLevel >= 4)
              x_syslog(7, "[vdr-sxfe]  ", "HUD OSD NOP");

          while((_Bool)0);
          break;
        }
        case 1:
        {
          do
            if(SysLogLevel >= 4)
              x_syslog(7, "[vdr-sxfe]  ", "HUD OSD Size");

          while((_Bool)0);
          hud_osd_show(this);
          break;
        }
        case 11:

        case 12:

        case 2:
        {
          do
            if(SysLogLevel >= 4)
              x_syslog(7, "[vdr-sxfe]  ", "HUD OSD Set");

          while((_Bool)0);
          hud_osd_draw(this, cmd);
          break;
        }
        case 3:
        {
          do
            if(SysLogLevel >= 3)
              x_syslog(7, "[vdr-sxfe]  ", "HUD OSD SetPalette");

          while((_Bool)0);
          break;
        }
        case 4:
        {
          do
            if(SysLogLevel >= 3)
              x_syslog(7, "[vdr-sxfe]  ", "HUD OSD Move");

          while((_Bool)0);
          break;
        }
        case 6:
        {
          do
            if(SysLogLevel >= 3)
              x_syslog(7, "[vdr-sxfe]  ", "HUD OSD Set YUV");

          while((_Bool)0);
          break;
        }
        case 9:
          break;
        case 5:
        {
          do
            if(SysLogLevel >= 4)
              x_syslog(7, "[vdr-sxfe]  ", "HUD OSD Close");

          while((_Bool)0);
          hud_osd_hide(this);
        }
      }
      XUnlockDisplay(this->display);
    }

  }

  return 1;
}

// hud_osd_draw
// file xine_sxfe_frontend.c line 873
static void hud_osd_draw(struct sxfe_s *this, struct osd_command_s *cmd)
{
  signed int x = (signed int)cmd->x + (signed int)cmd->dirty_area.x1;
  signed int y = (signed int)cmd->y + (signed int)cmd->dirty_area.y1;
  signed int w = ((signed int)cmd->dirty_area.x2 - (signed int)cmd->dirty_area.x1) + 1;
  signed int h = ((signed int)cmd->dirty_area.y2 - (signed int)cmd->dirty_area.y1) + 1;
  double scale_x = (double)this->_anon0.x.width / (double)this->osd_width;
  double scale_y = (double)this->_anon0.x.height / (double)this->osd_height;
  signed int mask_changed;
  struct _xrender_surf *dst_surf;
  struct _xrender_surf *tmp_if_expr_1;
  if(!(this->surf_back_img == ((struct _xrender_surf *)NULL)))
    tmp_if_expr_1 = this->surf_back_img;

  else
    tmp_if_expr_1 = this->surf_win;
  dst_surf = tmp_if_expr_1;
  unsigned long int dst_win;
  unsigned long int tmp_if_expr_2;
  if(!(this->surf_back_img == ((struct _xrender_surf *)NULL)))
    tmp_if_expr_2 = this->surf_back_img->draw;

  else
    tmp_if_expr_2 = this->hud_window;
  dst_win = tmp_if_expr_2;
  unsigned int *shape_mask_mem = this->shape_mask_mem;
  if(!(this->xshm_completion_event == -1))
  {
    hud_fill_img_memory((unsigned int *)this->hud_img->data, 1920, shape_mask_mem, 1920, &mask_changed, cmd);
    if(cmd->scaling == 0)
      XShmPutImage(this->display, dst_win, this->gc, this->hud_img, x, y, x, y, (unsigned int)w, (unsigned int)h, 0);

    else
    {
      XShmPutImage(this->display, this->surf_img->draw, this->gc, this->hud_img, x, y, x, y, (unsigned int)w, (unsigned int)h, 0);
      xrender_surf_blend(this->display, this->surf_img, dst_surf, x, y, w, h, scale_x, scale_y, (signed int)cmd->scaling & 2, &x, &y, &w, &h);
    }
  }

  else
  {
    hud_fill_img_memory(this->hud_img_mem, 1920, shape_mask_mem, 1920, &mask_changed, cmd);
    if(cmd->scaling == 0)
      XPutImage(this->display, dst_win, this->gc, this->hud_img, x, y, x, y, (unsigned int)w, (unsigned int)h);

    else
    {
      XPutImage(this->display, this->surf_img->draw, this->gc, this->hud_img, x, y, x, y, (unsigned int)w, (unsigned int)h);
      xrender_surf_blend(this->display, this->surf_img, dst_surf, x, y, w, h, scale_x, scale_y, (signed int)cmd->scaling & 2, &x, &y, &w, &h);
    }
  }
  if(!(this->xshape_hud == 0))
  {
    if(!(mask_changed == 0))
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-sxfe]  ", "hud_osd_draw: Updating shape of window");

      while((_Bool)0);
      XRenderComposite(this->display, 1, this->surf_back_img->pic, (unsigned long int)0L, this->shape_mask_picture, x, y, 0, 0, x, y, (unsigned int)w, (unsigned int)h);
      XShapeCombineMask(this->display, this->hud_window, 0, 0, 0, this->shape_mask_pixmap, 0);
    }

  }

  if(!(this->surf_back_img == ((struct _xrender_surf *)NULL)))
    XRenderComposite(this->display, 1, this->surf_back_img->pic, (unsigned long int)0L, this->surf_win->pic, x, y, 0, 0, x, y, (unsigned int)w, (unsigned int)h);

  XFlush(this->display);
}

// hud_osd_focus
// file xine_sxfe_frontend.c line 1280
static void hud_osd_focus(struct sxfe_s *this, struct anonymous_40 *fev)
{
  _Bool tmp_if_expr_1;
  if(!(this == ((struct sxfe_s *)NULL)))
  {
    if(!(this->hud == 0))
    {
      if(fev->window == this->window[0l])
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = fev->window == this->window[(signed long int)1] ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        XLockDisplay(this->display);
        if(fev->type == 9)
          XMapWindow(this->display, this->hud_window);

        else
          if(fev->type == 10)
            XUnmapWindow(this->display, this->hud_window);

        XUnlockDisplay(this->display);
      }

    }

  }

}

// hud_osd_hide
// file xine_sxfe_frontend.c line 957
static void hud_osd_hide(struct sxfe_s *this)
{
  if(!(this->osd_visible == 0))
  {
    this->osd_visible = (unsigned char)0;
    this->video_win_active = (unsigned char)0;
    if(!(this->xshape_hud == 0))
    {
      XUnmapWindow(this->display, this->hud_window);
      XSetForeground(this->display, this->shape_mask_gc, (unsigned long int)0);
      XFillRectangle(this->display, this->shape_mask_pixmap, this->shape_mask_gc, 0, 0, (unsigned int)this->_anon0.x.width, (unsigned int)this->_anon0.x.height);
      memset((void *)this->shape_mask_mem, 0, sizeof(unsigned int) /*4ul*/  * (unsigned long int)1920 * (unsigned long int)1200);
      XShapeCombineMask(this->display, this->hud_window, 0, 0, 0, this->shape_mask_pixmap, 0);
    }

    XSetForeground(this->display, this->gc, (unsigned long int)0x00000000);
    XFillRectangle(this->display, this->hud_window, this->gc, 0, 0, (unsigned int)this->_anon0.x.width, (unsigned int)this->_anon0.x.height);
    XFillRectangle(this->display, this->surf_img->draw, this->gc, 0, 0, (unsigned int)((signed int)this->osd_width + 2), (unsigned int)((signed int)this->osd_height + 2));
    XFlush(this->display);
  }

}

// hud_osd_open
// file xine_sxfe_frontend.c line 1115
static signed int hud_osd_open(struct sxfe_s *this)
{
  if(!(this == ((struct sxfe_s *)NULL)))
  {
    if(!(this->hud == 0))
    {
      signed int dummy;
      XLockDisplay(this->display);
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-sxfe]  ", "opening HUD OSD window...");

      while((_Bool)0);
      signed int return_value_XRenderQueryExtension_1;
      return_value_XRenderQueryExtension_1=XRenderQueryExtension(this->display, &dummy, &dummy);
      if(return_value_XRenderQueryExtension_1 == 0)
      {
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-sxfe]  ", "hud_osd_open: ERROR: XRender extension not available.");

        while((_Bool)0);
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-sxfe]  ", "XRender extension must be enabled in X configuration (xorg.conf etc.)");

        while((_Bool)0);
        this->hud = (unsigned char)0;
        XUnlockDisplay(this->display);
        return 1;
      }

      this->hud_vis=find_argb_visual(this->display, this->screen);
      if(this->hud_vis == ((struct anonymous_16 *)NULL))
      {
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-sxfe]  ", "find_argb_visual() failed. HUD OSD disabled.");

        while((_Bool)0);
        this->hud = (unsigned char)0;
        XUnlockDisplay(this->display);
        return 1;
      }

      unsigned long int hud_colormap;
      hud_colormap=XCreateColormap(this->display, this->root_window, this->hud_vis, 0);
      struct anonymous_8 attributes;
      attributes.override_redirect = 1;
      attributes.background_pixel = (unsigned long int)0x00000000;
      attributes.border_pixel = (unsigned long int)0;
      attributes.colormap = hud_colormap;
      attributes.backing_store = 2;
      this->hud_window=XCreateWindow(this->display, this->root_window, (signed int)this->_anon0.x.xpos, (signed int)this->_anon0.x.ypos, (unsigned int)this->_anon0.x.width, (unsigned int)this->_anon0.x.height, (unsigned int)0, 32, (unsigned int)1, this->hud_vis, (unsigned long int)(1L << 1 | 1L << 3 | 1L << 9 | 1L << 13), &attributes);
      XSelectInput(this->display, this->hud_window, 1L << 17 | 1L << 15 | 1L << 0 | 1L << 2 | 1L << 21);
      XStoreName(this->display, this->hud_window, "HUD");
      this->gc=XCreateGC(this->display, this->hud_window, (unsigned long int)0, (struct anonymous_77 *)(void *)0);
      if(!(this->xshm_completion_event == -1))
      {
        this->hud_img=XShmCreateImage(this->display, this->hud_vis, (unsigned int)32, 2, (char *)(void *)0, &this->hud_shminfo, (unsigned int)1920, (unsigned int)1200);
        this->hud_shminfo.shmid=shmget((signed int)0, (unsigned long int)(this->hud_img->bytes_per_line * this->hud_img->height), 01000 | 0777);
        void *return_value_shmat_2;
        return_value_shmat_2=shmat(this->hud_shminfo.shmid, NULL, 0);
        this->hud_img->data = (char *)return_value_shmat_2;
        this->hud_shminfo.shmaddr = this->hud_img->data;
        this->hud_shminfo.readOnly = 1;
        XShmAttach(this->display, &this->hud_shminfo);
      }

      else
      {
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-sxfe]  ", "hud_osd_open: XShm not available, falling back to normal (slow) memory");

        while((_Bool)0);
        void *return_value_malloc_3;
        return_value_malloc_3=malloc((unsigned long int)(4 * 1920 * 1200));
        this->hud_img_mem = (unsigned int *)return_value_malloc_3;
        this->hud_img=XCreateImage(this->display, this->hud_vis, (unsigned int)32, 2, 0, (char *)this->hud_img_mem, (unsigned int)1920, (unsigned int)1200, 32, 0);
      }
      if(!(this->xshape_hud == 0))
      {
        signed int return_value_XShapeQueryExtension_6;
        return_value_XShapeQueryExtension_6=XShapeQueryExtension(this->display, &dummy, &dummy);
        if(!(return_value_XShapeQueryExtension_6 == 0))
        {
          this->shape_mask_pixmap=XCreatePixmap(this->display, this->hud_window, (unsigned int)(&((struct anonymous_34 *)this->display)->screens[(signed long int)this->screen])->width, (unsigned int)(&((struct anonymous_34 *)this->display)->screens[(signed long int)this->screen])->height, (unsigned int)1);
          void *return_value_calloc_4;
          return_value_calloc_4=calloc(sizeof(unsigned int) /*4ul*/ , (unsigned long int)(1920 * 1200));
          this->shape_mask_mem = (unsigned int *)return_value_calloc_4;
          this->shape_mask_gc=XCreateGC(this->display, this->shape_mask_pixmap, (unsigned long int)0, (struct anonymous_77 *)(void *)0);
          XSetForeground(this->display, this->shape_mask_gc, (unsigned long int)0);
          XFillRectangle(this->display, this->shape_mask_pixmap, this->shape_mask_gc, 0, 0, (unsigned int)(&((struct anonymous_34 *)this->display)->screens[(signed long int)this->screen])->width, (unsigned int)(&((struct anonymous_34 *)this->display)->screens[(signed long int)this->screen])->height);
          struct anonymous_21 *return_value_XRenderFindStandardFormat_5;
          return_value_XRenderFindStandardFormat_5=XRenderFindStandardFormat(this->display, 4);
          this->shape_mask_picture=XRenderCreatePicture(this->display, this->shape_mask_pixmap, return_value_XRenderFindStandardFormat_5, (unsigned long int)0, (const struct _XRenderPictureAttributes *)(void *)0);
          XShapeCombineMask(this->display, this->hud_window, 0, 0, 0, this->shape_mask_pixmap, 0);
        }

        else
        {
          do
            if(SysLogLevel >= 2)
              x_syslog(6, "[vdr-sxfe]  ", "hud_osd_open(): XShape not available, composite window manager must be running to see OSD.");

          while((_Bool)0);
          this->xshape_hud = (unsigned char)0;
        }
      }

      this->osd_visible = (unsigned char)0;
      this->surf_win=xrender_surf_adopt(this->display, this->hud_window, this->hud_vis, 1920, 1200);
      this->surf_img=xrender_surf_new(this->display, this->hud_window, this->hud_vis, 1920, 1200, 1);
      if(!(this->xshape_hud == 0))
        this->surf_back_img=xrender_surf_new(this->display, this->hud_window, this->hud_vis, (&((struct anonymous_34 *)this->display)->screens[(signed long int)this->screen])->width, (&((struct anonymous_34 *)this->display)->screens[(signed long int)this->screen])->height, 1);

      XUnlockDisplay(this->display);
      this->_anon0.fe.xine_osd_command = hud_osd_command;
      if(!(this->_anon0.x.scale_video == 0))
        this->_anon0.x._anon0.vis_x11.frame_output_cb = hud_frame_output_cb;

      return 1;
    }

  }

  return 1;
}

// hud_osd_resize
// file xine_sxfe_frontend.c line 1251
static void hud_osd_resize(struct sxfe_s *this, unsigned long int video_window, signed int width, signed int height)
{
  if(!(this->hud == 0))
  {
    if(video_window == this->window[0l])
    {
      signed int hud_x;
      signed int hud_y;
      unsigned long int tmp_win;
      XLockDisplay(this->display);
      XTranslateCoordinates(this->display, this->window[(signed long int)0], this->root_window, 0, 0, &hud_x, &hud_y, &tmp_win);
      XResizeWindow(this->display, this->hud_window, (unsigned int)width, (unsigned int)height);
      XMoveWindow(this->display, this->hud_window, hud_x, hud_y);
      set_cursor(this->display, this->hud_window, 1);
      XUnlockDisplay(this->display);
    }

    else
      if(video_window == this->window[1l])
      {
        XLockDisplay(this->display);
        XResizeWindow(this->display, this->hud_window, (unsigned int)width, (unsigned int)height);
        XMoveWindow(this->display, this->hud_window, 0, 0);
        set_cursor(this->display, this->hud_window, 0);
        XUnlockDisplay(this->display);
      }

  }

}

// hud_osd_show
// file xine_sxfe_frontend.c line 984
static void hud_osd_show(struct sxfe_s *this)
{
  if(this->osd_visible == 0)
  {
    this->osd_visible = (unsigned char)1;
    this->video_win_active = (unsigned char)0;
    XSetForeground(this->display, this->gc, (unsigned long int)0x00000000);
    XFillRectangle(this->display, this->surf_img->draw, this->gc, 0, 0, (unsigned int)((signed int)this->osd_width + 2), (unsigned int)((signed int)this->osd_height + 2));
    if(!(this->surf_back_img == ((struct _xrender_surf *)NULL)))
      XFillRectangle(this->display, this->surf_back_img->draw, this->gc, 0, 0, (unsigned int)this->_anon0.x.width, (unsigned int)this->_anon0.x.height);

    if(!(this->xshape_hud == 0))
    {
      XSetForeground(this->display, this->shape_mask_gc, (unsigned long int)0);
      XFillRectangle(this->display, this->shape_mask_pixmap, this->shape_mask_gc, 0, 0, (unsigned int)this->_anon0.x.width, (unsigned int)this->_anon0.x.height);
      memset((void *)this->shape_mask_mem, 0, sizeof(unsigned int) /*4ul*/  * (unsigned long int)1920 * (unsigned long int)1200);
      XShapeCombineMask(this->display, this->hud_window, 0, 0, 0, this->shape_mask_pixmap, 0);
      XRaiseWindow(this->display, this->hud_window);
      XMapWindow(this->display, this->hud_window);
    }

    XFlush(this->display);
  }

}

// init_atoms
// file xine_sxfe_frontend.c line 282
static void init_atoms(struct sxfe_s *this)
{
  if(this->xa_SXFE_INTERRUPT == 0ul)
  {
    this->xa_SXFE_INTERRUPT=XInternAtom(this->display, "SXFE_INTERRUPT", 0);
    this->xa_WM_DELETE_WINDOW=XInternAtom(this->display, "WM_DELETE_WINDOW", 0);
    this->xa_MOTIF_WM_HINTS=XInternAtom(this->display, "_MOTIF_WM_HINTS", 0);
    this->xa_WIN_LAYER=XInternAtom(this->display, "_WIN_LAYER", 0);
    this->xa_WIN_STATE=XInternAtom(this->display, "_WIN_STATE", 0);
    this->xa_NET_ACTIVE_WINDOW=XInternAtom(this->display, "_NET_ACTIVE_WINDOW", 0);
    this->xa_NET_WM_STATE=XInternAtom(this->display, "_NET_WM_STATE", 0);
    this->xa_NET_WM_STATE_ADD=XInternAtom(this->display, "_NET_WM_STATE_ADD", 0);
    this->xa_NET_WM_STATE_DEL=XInternAtom(this->display, "_NET_WM_STATE_DEL", 0);
    this->xa_NET_WM_STATE_ABOVE=XInternAtom(this->display, "_NET_WM_STATE_ABOVE", 0);
    this->xa_NET_WM_STATE_STICKY=XInternAtom(this->display, "_NET_WM_STATE_STICKY", 0);
    this->xa_NET_WM_STATE_FULLSCREEN=XInternAtom(this->display, "_NET_WM_STATE_FULLSCREEN", 0);
    this->xa_NET_WM_STATE_STAYS_ON_TOP=XInternAtom(this->display, "_NET_WM_STATE_STAYS_ON_TOP", 0);
  }

}

// init_dummy_ports
// file xine_frontend.c line 865
static void init_dummy_ports(struct fe_s *this, signed int on)
{
  if(on == 0)
  {
    if(!(this->slave_stream == ((struct xine_stream_s *)NULL)))
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[vdr-fe]    ", "ERROR: init_dummy_ports(false) called while port is still in use !");

      while((_Bool)0);

    if(!(this->audio_port_none == ((struct xine_audio_port_s *)NULL)))
      xine_close_audio_driver(this->xine, this->audio_port_none);

    this->audio_port_none = (struct xine_audio_port_s *)(void *)0;
    if(!(this->video_port_none == ((struct xine_video_port_s_0 *)NULL)))
      xine_close_video_driver(this->xine, this->video_port_none);

    this->video_port_none = (struct xine_video_port_s_0 *)(void *)0;
  }

  else
  {
    if(this->audio_port_none == ((struct xine_audio_port_s *)NULL))
      this->audio_port_none = (struct xine_audio_port_s *)(void *)0;

    if(!(this->audio_port_none == ((struct xine_audio_port_s *)NULL)))
      this->audio_port_none->set_property(this->audio_port_none, 4, 1);

  }
}

// init_fe
// file xine_frontend.c line 2056
void init_fe(struct fe_s *fe)
{
  fe->fe.xine_init = fe_xine_init;
  fe->fe.xine_open = fe_xine_open;
  fe->fe.xine_play = fe_xine_play;
  fe->fe.xine_stop = fe_xine_stop;
  fe->fe.xine_close = fe_xine_close;
  fe->fe.xine_exit = fe_xine_exit;
  fe->fe.shutdown_init = fe_shutdown_init;
  fe->fe.fe_free = fe_free;
  fe->fe.xine_is_finished = fe_is_finished;
  fe->fe.xine_osd_command = xine_osd_command;
  fe->fe.xine_control = xine_control;
  fe->fe.xine_queue_pes_packet = xine_queue_pes_packet;
  fe->fe.grab = fe_grab;
  fe->fe.send_event = fe_send_event;
  fe->fe.send_input_event = fe_send_input_event;
  fe->dest_pixel_aspect = fe_dest_pixel_aspect;
  fe->frame_output_handler = fe_frame_output_cb;
}

// input_event_cb
// file xine_frontend.c line 1152
static void input_event_cb(struct frontend_s *this_gen, const char *keymap, const char *key)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  if(!(this->fe.fe_message_cb == ((void (*)(void *, const char *, const char *))NULL)))
    this->fe.fe_message_cb(this->fe.fe_message_h, keymap, key);

}

// intercept_video_driver
// file xine_frontend.c line 50
static void intercept_video_driver(struct xine_video_port_s_0 *video_port)
{
  struct vo_driver_s_0 *osdscaler;
  osdscaler=osdscaler_init();
  signed int return_value_wire_video_driver_1;
  return_value_wire_video_driver_1=wire_video_driver(video_port, osdscaler);
  if(return_value_wire_video_driver_1 == 0)
  {
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[vdr-fe]    ", "wire_video_driver() for osdscaler failed");

    while((_Bool)0);
    osdscaler->dispose(osdscaler);
  }

  struct vo_driver_s_0 *osdreorder;
  osdreorder=osd_reorder_init();
  signed int return_value_wire_video_driver_2;
  return_value_wire_video_driver_2=wire_video_driver(video_port, osdreorder);
  if(return_value_wire_video_driver_2 == 0)
  {
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[vdr-fe]    ", "wire_video_driver() for osdreorder failed");

    while((_Bool)0);
    osdreorder->dispose(osdreorder);
  }

  struct vo_driver_s_0 *lastpts;
  lastpts=vo_lastpts_init();
  signed int return_value_wire_video_driver_3;
  return_value_wire_video_driver_3=wire_video_driver(video_port, lastpts);
  if(return_value_wire_video_driver_3 == 0)
  {
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[vdr-fe]    ", "wire_video_driver() for vo_lastpts failed");

    while((_Bool)0);
    lastpts->dispose(lastpts);
  }

}

// kbd_receiver_thread
// file xine_frontend_kbd.c line 169
static void * kbd_receiver_thread(void *fe_gen)
{
  struct frontend_s *fe = (struct frontend_s *)fe_gen;
  unsigned long int code = (unsigned long int)0;
  char str[64l];
  signed int return_value_isatty_1;
  return_value_isatty_1=isatty(1);
  if(!(return_value_isatty_1 == 0))
  {
    signed int status;
    status=system("setterm -cursor off");
    if(!(status >= 0))
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[console]   ", "system(\"setterm -cursor off\") failed\n");

      while((_Bool)0);

    status=system("setterm -blank off");
    if(!(status >= 0))
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[console]   ", "system(\"setterm -blank off\") failed\n");

      while((_Bool)0);

  }

  signed int return_value_isatty_3;
  return_value_isatty_3=isatty(0);
  if(!(return_value_isatty_3 == 0))
  {
    tcgetattr(0, &saved_tm);
    signed int return_value_tcgetattr_2;
    return_value_tcgetattr_2=tcgetattr(0, &tm);
    if(return_value_tcgetattr_2 == 0)
    {
      tm.c_iflag = (unsigned int)0;
      tm.c_lflag = tm.c_lflag & (unsigned int)~(0000002 | 0000010);
      tm.c_cc[(signed long int)6] = (unsigned char)0;
      tm.c_cc[(signed long int)5] = (unsigned char)0;
      tcsetattr(0, 0, &tm);
    }

  }

  do
  {
    struct anonymous_102 __cancel_buf;
    void (*__cancel_routine)(void *) = kbd_receiver_thread_cleanup;
    void *__cancel_arg = (void *)0;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      alarm((unsigned int)0);
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = 0;
      code=read_key_seq();
      alarm((unsigned int)3);
      if(!(code == 0ul))
      {
        if(code == 4294967295ul)
          goto __CPROVER_DUMP_L19;

        if(code == 27ul)
          fe->send_event(fe, "QUIT");

        if(!(gui_hotkeys == 0))
        {
          if(code == 70ul || code == 102ul)
            fe->send_event(fe, "TOGGLE_FULLSCREEN");

          if(code == 80ul || code == 112ul)
            fe->send_event(fe, "POWER_OFF");

          if(!(code == 68ul) && !(code == 100ul))
            goto __CPROVER_DUMP_L17;

          fe->send_event(fe, "TOGGLE_DEINTERLACE");
        }

        else
        {

        __CPROVER_DUMP_L17:
          ;
          snprintf_link3(str, sizeof(char [64l]) /*64ul*/ , "%016lX", code);
          fe->send_input_event(fe, "KBD", str, 0, 0);
        }
      }

      signed int return_value;
      return_value=fe->xine_is_finished(fe, 0);

    __CPROVER_DUMP_L19:
      ;
      alarm((unsigned int)0);
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[console]   ", "Keyboard thread terminating");

      while((_Bool)0);

    __CPROVER_DUMP_L22:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  pthread_exit((void *)0);
  return (void *)0;
}

// kbd_receiver_thread_cleanup
// file xine_frontend_kbd.c line 155
static void kbd_receiver_thread_cleanup(void *arg)
{
  signed int return_value_isatty_1;
  return_value_isatty_1=isatty(0);
  if(!(return_value_isatty_1 == 0))
    tcsetattr(0, 0, &saved_tm);

  signed int return_value_isatty_2;
  return_value_isatty_2=isatty(1);
  if(!(return_value_isatty_2 == 0))
  {
    signed int status;
    status=system("setterm -cursor on");
    if(!(status >= 0))
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[console]   ", "system(\"setterm -cursor on\") failed\n");

      while((_Bool)0);

  }

  do
    if(SysLogLevel >= 2)
      x_syslog(6, "[console]   ", "Keyboard thread terminated");

  while((_Bool)0);
}

// kbd_start
// file xine_frontend_kbd.h line 16
void kbd_start(struct frontend_s *fe, signed int slave_mode)
{
  signed int err;
  err=pthread_create(&kbd_thread, (const union pthread_attr_t *)(void *)0, slave_mode != 0 ? slave_receiver_thread : kbd_receiver_thread, (void *)fe);
  if(!(err == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(err);
    fprintf_link4(stderr, "Can't create new thread for keyboard (%s)\n", return_value_strerror_1);
  }

}

// kbd_stop
// file xine_frontend_kbd.h line 17
void kbd_stop(void)
{
  void *p;
  pthread_cancel(kbd_thread);
  pthread_join(kbd_thread, &p);
}

// lastpts_display_frame
// file xine/vo_lastpts.c line 53
static void lastpts_display_frame(struct vo_driver_s *self, struct vo_frame_s *vo_img)
{
  struct anonymous_83 *this = (struct anonymous_83 *)self;
  do
    if(self == ((struct vo_driver_s *)NULL))
    {
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[lastpts  ] ", "Asseretion failed: %s at %s:%d (%s)", (const void *)"self", (const void *)"xine/vo_lastpts.c", 57, (const void *)"lastpts_display_frame");

      while((_Bool)0);
      goto __CPROVER_DUMP_L27;
    }

  while((_Bool)0);
  do
    if(vo_img == ((struct vo_frame_s *)NULL))
    {
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[lastpts  ] ", "Asseretion failed: %s at %s:%d (%s)", (const void *)"vo_img", (const void *)"xine/vo_lastpts.c", 58, (const void *)"lastpts_display_frame");

      while((_Bool)0);
      goto __CPROVER_DUMP_L27;
    }

  while((_Bool)0);
  _Bool tmp_if_expr_1;
  if(vo_img->stream == ((struct xine_stream_s_0 *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = vo_img->stream == (struct xine_stream_s_0 *)-1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = vo_img->pts <= (signed long int)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    this->h.orig_driver->display_frame(this->h.orig_driver, vo_img);

  else
  {
    if(!(vo_img->stream == this->prev_stream))
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[lastpts  ] ", "stream changed from %p to %p", this->prev_stream, vo_img->stream);

      while((_Bool)0);
      this->prev_stream = vo_img->stream;
      detect_xvdr_metronom(this, vo_img->stream);
    }

    if(vo_img->stream == this->xvdr_stream)
    {
      if(!(this->xvdr_metronom == vo_img->stream->metronom))
      {
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[lastpts  ] ", "detected new metronom");

        while((_Bool)0);
        this->xvdr_metronom = (struct metronom_s *)(void *)0;
        detect_xvdr_metronom(this, vo_img->stream);
      }

      if(!(this->xvdr_metronom == ((struct metronom_s *)NULL)))
      {
        do
          if(this->xvdr_metronom->set_option == ((void (*)(struct metronom_s *, signed int, signed long int))NULL))
          {
            do
              if(SysLogLevel >= 2)
                x_syslog(6, "[lastpts  ] ", "Asseretion failed: %s at %s:%d (%s)", (const void *)"this->xvdr_metronom->set_option", (const void *)"xine/vo_lastpts.c", 84, (const void *)"lastpts_display_frame");

            while((_Bool)0);
            goto __CPROVER_DUMP_L27;
          }

        while((_Bool)0);
        do
          if(SysLogLevel >= 4)
            x_syslog(7, "[lastpts  ] ", "last pts %ld", vo_img->pts);

        while((_Bool)0);
        this->xvdr_metronom->set_option(this->xvdr_metronom, 0x1001, vo_img->pts);
      }

    }

    this->h.orig_driver->display_frame(this->h.orig_driver, vo_img);
  }

__CPROVER_DUMP_L27:
  ;
}

// lirc_receiver_thread
// file xine_frontend_lirc.c line 96
static void * lirc_receiver_thread(void *fe_gen)
{
  struct frontend_s *fe = (struct frontend_s *)fe_gen;
  const signed int priority = -1;
  signed int timeout = -1;
  signed int repeat = 0;
  unsigned long int FirstTime;
  FirstTime=time_ms_link1();
  unsigned long int LastTime;
  LastTime=time_ms_link1();
  char buf[128l];
  char LastKeyName[30l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  do
    if(SysLogLevel >= 2)
      x_syslog(6, "[lirc]      ", "lirc forwarding started");

  while((_Bool)0);
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  signed int return_value_nice_3;
  return_value_nice_3=nice(priority);
  signed int *return_value___errno_location_2;
  if(return_value_nice_3 == -1)
  {
    return_value___errno_location_2=__errno_location();
    if(!(*return_value___errno_location_2 == 0))
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[lirc]      ", "LIRC: Can't nice to value: %d", priority);

      while((_Bool)0);

  }

  lircd_connect();
  signed long int tmp_statement_expression_4;
  _Bool tmp_if_expr_9;
  signed long int tmp_statement_expression_7;
  _Bool tmp_if_expr_13;
  signed long int tmp_statement_expression_11;
  _Bool tmp_if_expr_15;
  signed int *return_value___errno_location_14;
  signed int *return_value___errno_location_18;
  char *return_value_strerror_19;
  signed int tmp_statement_expression_23;
  unsigned long int return_value_elapsed_22;
  signed int tmp_statement_expression_26;
  unsigned long int return_value_elapsed_25;
  signed int tmp_statement_expression_30;
  signed int tmp_statement_expression_32;
  signed int tmp_statement_expression_34;
  signed int tmp_statement_expression_36;
  while(fd_lirc >= 0 && !(lirc_device_name == ((const volatile char *)NULL)))
  {
    struct anonymous_98 set;
    signed int ready;
    signed int ret = -1;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_98) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    signed long int __d = (signed long int)fd_lirc;
    signed long int return_value___fdelt_chk_5;
    return_value___fdelt_chk_5=__fdelt_chk(__d);
    tmp_statement_expression_4 = return_value___fdelt_chk_5;
    (&set)->fds_bits[tmp_statement_expression_4] = (&set)->fds_bits[tmp_statement_expression_4] | (signed long int)(1UL << fd_lirc % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    pthread_testcancel();
    if(timeout >= 0)
    {
      struct timeval tv;
      tv.tv_sec = (signed long int)(timeout / 1000);
      tv.tv_usec = (signed long int)((timeout % 1000) * 1000);
      signed int return_value_select_6;
      return_value_select_6=select(1024, &set, (struct anonymous_98 *)(void *)0, (struct anonymous_98 *)(void *)0, &tv);
      if(return_value_select_6 >= 1)
      {
        signed long int lirc_receiver_thread__1__3__3__1____d = (signed long int)fd_lirc;
        signed long int return_value___fdelt_chk_8;
        return_value___fdelt_chk_8=__fdelt_chk(lirc_receiver_thread__1__3__3__1____d);
        tmp_statement_expression_7 = return_value___fdelt_chk_8;
        tmp_if_expr_9 = ((&set)->fds_bits[tmp_statement_expression_7] & (signed long int)(1UL << fd_lirc % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_9 = (_Bool)0;
      ready = (signed int)tmp_if_expr_9;
    }

    else
    {
      signed int return_value_select_10;
      return_value_select_10=select(1024, &set, (struct anonymous_98 *)(void *)0, (struct anonymous_98 *)(void *)0, (struct timeval *)(void *)0);
      if(return_value_select_10 >= 1)
      {
        signed long int lirc_receiver_thread__1__3__4__1____d = (signed long int)fd_lirc;
        signed long int return_value___fdelt_chk_12;
        return_value___fdelt_chk_12=__fdelt_chk(lirc_receiver_thread__1__3__4__1____d);
        tmp_statement_expression_11 = return_value___fdelt_chk_12;
        tmp_if_expr_13 = ((&set)->fds_bits[tmp_statement_expression_11] & (signed long int)(1UL << fd_lirc % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_13 = (_Bool)0;
      ready = (signed int)tmp_if_expr_13;
    }
    pthread_testcancel();
    if(!(ready >= 0))
    {
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[lirc]      ", "LIRC connection lost ?");

      while((_Bool)0);
      break;
    }

    if(!(ready == 0))
    {
      do
      {
        signed int *return_value___errno_location_16;
        return_value___errno_location_16=__errno_location();
        *return_value___errno_location_16 = 0;
        signed long int return_value_read_17;
        return_value_read_17=read(fd_lirc, (void *)buf, sizeof(char [128l]) /*128ul*/ );
        ret = (signed int)return_value_read_17;
        pthread_testcancel();
        if(!(ret >= 0))
        {
          return_value___errno_location_14=__errno_location();
          tmp_if_expr_15 = *return_value___errno_location_14 == 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_15 = (_Bool)0;
      }
      while(tmp_if_expr_15);
      if(!(ret >= 1))
      {
        do
          if(SysLogLevel >= 1)
          {
            x_syslog(3, "[lirc]      ", "LIRC connection lost");
            signed int *return_value___errno_location_20;
            return_value___errno_location_20=__errno_location();
            if(!(*return_value___errno_location_20 == 0))
            {
              return_value___errno_location_18=__errno_location();
              return_value_strerror_19=strerror(*return_value___errno_location_18);
              x_syslog(3, "[lirc]      ", "   (ERROR (%s,%d): %s)", (const void *)"xine_frontend_lirc.c", 147, return_value_strerror_19);
            }

          }

        while((_Bool)0);
        lircd_connect();
        while(!(lirc_device_name == ((const volatile char *)NULL)) && !(fd_lirc >= 0))
        {
          pthread_testcancel();
          sleep((unsigned int)(3000 / 1000));
          lircd_connect();
        }
        if(fd_lirc >= 0)
          do
            if(SysLogLevel >= 2)
              x_syslog(6, "[lirc]      ", "LIRC reconnected");

          while((_Bool)0);

        continue;
      }

      if(ret >= 5)
      {
        unsigned int count;
        char KeyName[30l];
        do
          if(SysLogLevel >= 3)
            x_syslog(7, "[lirc]      ", "LIRC: %s", (const void *)buf);

        while((_Bool)0);
        signed int return_value_sscanf_21;
        return_value_sscanf_21=sscanf(buf, "%*x %x %29s", &count, (const void *)KeyName);
        if(!(return_value_sscanf_21 == 2))
        {
          do
            if(SysLogLevel >= 2)
              x_syslog(6, "[lirc]      ", "unparseable lirc command: %s", (const void *)buf);

          while((_Bool)0);
          continue;
        }

        if(!(lirc_repeat_emu == 0))
        {
          unsigned long int lirc_receiver_thread__1__3__6__3__3____s1_len;
          unsigned long int lirc_receiver_thread__1__3__6__3__3____s2_len;
          signed int return_value___builtin_strcmp_24;
          return_value___builtin_strcmp_24=__builtin_strcmp(KeyName, LastKeyName);
          tmp_statement_expression_23 = return_value___builtin_strcmp_24;
          if(tmp_statement_expression_23 == 0)
          {
            return_value_elapsed_22=elapsed_link1(LastTime);
            if(!(return_value_elapsed_22 >= 350ul))
              count = (unsigned int)(repeat + 1);

          }

        }

        if(count == 0u)
        {
          unsigned long int lirc_receiver_thread__1__3__6__3__4__1____s1_len;
          unsigned long int lirc_receiver_thread__1__3__6__3__4__1____s2_len;
          signed int return_value___builtin_strcmp_27;
          return_value___builtin_strcmp_27=__builtin_strcmp(KeyName, LastKeyName);
          tmp_statement_expression_26 = return_value___builtin_strcmp_27;
          if(tmp_statement_expression_26 == 0)
          {
            return_value_elapsed_25=elapsed_link1(FirstTime);
            if(!(return_value_elapsed_25 >= 350ul))
              continue;

          }

          if(!(repeat == 0))
          {
            alarm((unsigned int)3);
            fe->send_input_event(fe, "LIRC", LastKeyName, 0, 1);
            alarm((unsigned int)0);
          }

          strcpy_link1(LastKeyName, KeyName);
          repeat = 0;
          FirstTime=time_ms_link1();
          timeout = -1;
        }

        else
        {
          unsigned long int return_value_elapsed_28;
          return_value_elapsed_28=elapsed_link1(LastTime);
          if(!(return_value_elapsed_28 >= 100ul))
            continue;

          unsigned long int return_value_elapsed_29;
          return_value_elapsed_29=elapsed_link1(FirstTime);
          if(!(return_value_elapsed_29 >= 350ul))
          {
            if(!(lirc_repeat_emu == 0))
              LastTime=time_ms_link1();

            continue;
          }

          repeat = 1;
          timeout = 350;
        }
        LastTime=time_ms_link1();
        if(!(gui_hotkeys == 0))
        {
          unsigned long int lirc_receiver_thread__1__3__6__3__6__1____s1_len;
          unsigned long int lirc_receiver_thread__1__3__6__3__6__1____s2_len;
          signed int return_value___builtin_strcmp_31;
          return_value___builtin_strcmp_31=__builtin_strcmp(KeyName, "Quit");
          tmp_statement_expression_30 = return_value___builtin_strcmp_31;
          if(tmp_statement_expression_30 == 0)
          {
            fe->send_event(fe, "QUIT");
            break;
          }

          unsigned long int lirc_receiver_thread__1__3__6__3__6__3____s1_len;
          unsigned long int lirc_receiver_thread__1__3__6__3__6__3____s2_len;
          signed int return_value___builtin_strcmp_33;
          return_value___builtin_strcmp_33=__builtin_strcmp(KeyName, "PowerOff");
          tmp_statement_expression_32 = return_value___builtin_strcmp_33;
          if(tmp_statement_expression_32 == 0)
          {
            fe->send_event(fe, "POWER_OFF");
            break;
          }

          unsigned long int lirc_receiver_thread__1__3__6__3__6__5____s1_len;
          unsigned long int lirc_receiver_thread__1__3__6__3__6__5____s2_len;
          signed int return_value___builtin_strcmp_35;
          return_value___builtin_strcmp_35=__builtin_strcmp(KeyName, "Fullscreen");
          tmp_statement_expression_34 = return_value___builtin_strcmp_35;
          if(tmp_statement_expression_34 == 0)
          {
            if(repeat == 0)
              fe->send_event(fe, "TOGGLE_FULLSCREEN");

            continue;
          }

          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_37;
          return_value___builtin_strcmp_37=__builtin_strcmp(KeyName, "Deinterlace");
          tmp_statement_expression_36 = return_value___builtin_strcmp_37;
          if(tmp_statement_expression_36 == 0)
          {
            if(repeat == 0)
              fe->send_event(fe, "TOGGLE_DEINTERLACE");

            continue;
          }

        }

        alarm((unsigned int)3);
        fe->send_input_event(fe, "LIRC", KeyName, repeat, 0);
        alarm((unsigned int)0);
      }

    }

    if(!(repeat == 0) && (ready == 0 || !(ret >= 5)))
    {
      unsigned long int return_value_elapsed_38;
      return_value_elapsed_38=elapsed_link1(LastTime);
      if(return_value_elapsed_38 >= 500ul)
      {
        alarm((unsigned int)3);
        fe->send_input_event(fe, "LIRC", LastKeyName, 0, 1);
        alarm((unsigned int)0);
        repeat = 0;
        LastKeyName[0l] = (char)0;
        timeout = -1;
      }

    }

  }
  if(fd_lirc >= 0)
    close(fd_lirc);

  fd_lirc = -1;
  pthread_exit((void *)0);
  return (void *)0;
}

// lirc_start
// file xine_frontend_lirc.h line 16
void lirc_start(struct frontend_s *fe, const char *lirc_dev, signed int repeat_emu)
{
  if(!(lirc_dev == ((const char *)NULL)))
  {
    signed int err;
    lirc_device_name = lirc_dev;
    lirc_repeat_emu = repeat_emu;
    err=pthread_create(&lirc_thread, (const union pthread_attr_t *)(void *)0, lirc_receiver_thread, (void *)fe);
    if(!(err == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(err);
      fprintf_link3(stderr, "can't create new thread for lirc (%s)\n", return_value_strerror_1);
    }

  }

}

// lirc_stop
// file xine_frontend_lirc.h line 17
void lirc_stop(void)
{
  if(!(lirc_device_name == ((const volatile char *)NULL)))
  {
    void *p;
    lirc_device_name = (const volatile char *)(void *)0;
    if(fd_lirc >= 0)
      close(fd_lirc);

    fd_lirc = -1;
    pthread_cancel(lirc_thread);
    pthread_join(lirc_thread, &p);
  }

}

// lircd_connect
// file xine_frontend_lirc.c line 65
static void lircd_connect(void)
{
  struct sockaddr_un addr;
  if(fd_lirc >= 0)
  {
    close(fd_lirc);
    fd_lirc = -1;
  }

  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  if(lirc_device_name == ((const volatile char *)NULL))
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[lirc]      ", "no lirc device given");

    while((_Bool)0);

  else
  {
    addr.sun_family = (unsigned short int)1;
    strncpy_link1(addr.sun_path, (char *)lirc_device_name, sizeof(char [108l]) /*108ul*/ );
    addr.sun_path[(signed long int)(sizeof(char [108l]) /*108ul*/  - (unsigned long int)1)] = (char)0;
    fd_lirc=socket(1, 1, 0);
    if(!(fd_lirc >= 0))
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[lirc]      ", "lirc error: socket() < 0");
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          if(!(*return_value___errno_location_3 == 0))
          {
            return_value___errno_location_1=__errno_location();
            return_value_strerror_2=strerror(*return_value___errno_location_1);
            x_syslog(3, "[lirc]      ", "   (ERROR (%s,%d): %s)", (const void *)"xine_frontend_lirc.c", 84, return_value_strerror_2);
          }

        }

      while((_Bool)0);

    else
    {
      signed int return_value_connect_7;
      return_value_connect_7=connect(fd_lirc, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
      if(!(return_value_connect_7 == 0))
      {
        do
          if(SysLogLevel >= 1)
          {
            x_syslog(3, "[lirc]      ", "lirc error: connect(%s) < 0", lirc_device_name);
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            if(!(*return_value___errno_location_6 == 0))
            {
              return_value___errno_location_4=__errno_location();
              return_value_strerror_5=strerror(*return_value___errno_location_4);
              x_syslog(3, "[lirc]      ", "   (ERROR (%s,%d): %s)", (const void *)"xine_frontend_lirc.c", 89, return_value_strerror_5);
            }

          }

        while((_Bool)0);
        close(fd_lirc);
        fd_lirc = -1;
      }

    }
  }
}

// list_plugins_type
// file xine_frontend.c line 146
static void list_plugins_type(struct xine_s *xine, const char *msg, const char * const * (*list_func)(struct xine_s *))
{
  if(xine == ((struct xine_s *)NULL))
  {
    static struct xine_s *tmp_xine = (struct xine_s *)(void *)0;
    if(tmp_xine == ((struct xine_s *)NULL))
    {
      tmp_xine=xine_new();
      xine_init(tmp_xine);
    }

    xine = tmp_xine;
  }

  const char * const *list;
  list=list_func(xine);
  printf("%s", msg);
  const char * const *tmp_post_1;
  if(!(list == ((const char * const *)NULL)))
  {
    if(!(*list == ((const char *)NULL)))
    {
      tmp_post_1 = list;
      list = list + 1l;
      printf(" %s", *tmp_post_1);
    }

  }

  printf("\n");
}

// list_xine_plugins
// file xine_frontend.c line 162
void list_xine_plugins(struct frontend_s *fe, signed int verbose)
{
  struct fe_s *this = (struct fe_s *)fe;
  struct xine_s *tmp_xine = (struct xine_s *)(void *)0;
  struct xine_s *xine;
  struct xine_s *tmp_if_expr_1;
  if(!(this == ((struct fe_s *)NULL)))
    tmp_if_expr_1 = this->xine;

  else
    tmp_if_expr_1 = (struct xine_s *)(void *)0;
  xine = tmp_if_expr_1;
  if(xine == ((struct xine_s *)NULL))
  {
    tmp_xine=xine_new();
    xine = tmp_xine;
    xine_init(xine);
  }

  list_plugins_type(xine, "Available video drivers:", xine_list_video_output_plugins);
  list_plugins_type(xine, "Available audio drivers:", xine_list_audio_output_plugins);
  if(!(verbose == 0))
  {
    list_plugins_type(xine, "Available post plugins: ", xine_list_post_plugins);
    list_plugins_type(xine, "Available input plugins:", xine_list_input_plugins);
    list_plugins_type(xine, "Available demux plugins:", xine_list_demuxer_plugins);
    list_plugins_type(xine, "Available audio decoder plugins:", xine_list_audio_decoder_plugins);
    list_plugins_type(xine, "Available video decoder plugins:", xine_list_video_decoder_plugins);
    list_plugins_type(xine, "Available SPU decoder plugins:  ", xine_list_spu_plugins);
  }

  if(!(tmp_xine == ((struct xine_s *)NULL)))
    xine_exit(tmp_xine);

}

// main
// file xine_frontend_main.c line 233
signed int main(signed int argc, char **argv)
{
  signed int ftcp = 0;
  signed int fudp = 0;
  signed int frtp = 0;
  signed int reconnect = 0;
  signed int firsttry = 1;
  signed int fullscreen = 0;
  signed int hud = 0;
  signed int opengl = 0;
  signed int xpos = 0;
  signed int ypos = 0;
  signed int width = 720;
  signed int height = 576;
  signed int pes_buffers = 250;
  signed int scale_video = 1;
  signed int aspect = 1;
  signed int modeswitch = 0;
  signed int daemon_mode = 0;
  signed int nokbd = 0;
  signed int noxkbd = 0;
  signed int slave_mode = 0;
  signed int repeat_emu = 0;
  signed int touchscreen = 0;
  signed int window_id = -1;
  signed int xmajor;
  signed int xminor;
  signed int xsub;
  signed int c;
  signed int xine_finished = -1;
  signed int inactivity_timer = 0;
  char *mrl = (char *)(void *)0;
  char *video_driver = (char *)(void *)0;
  char *audio_driver = (char *)(void *)0;
  char *static_post_plugins = (char *)(void *)0;
  char *lirc_dev = (char *)(void *)0;
  signed int cec_hdmi_port = 0;
  signed int cec_dev_type = 0;
  char *p;
  const char *audio_device = (const char *)(void *)0;
  const char *video_port = (const char *)(void *)0;
  const char *aspect_controller = (const char *)(void *)0;
  const char *tty = (const char *)(void *)0;
  const char *exec_name = argv[(signed long int)0];
  const char *config_file = (const char *)(void *)0;
  const char *power_off_cmd = (const char *)(void *)0;
  struct frontend_s *fe = (struct frontend_s *)(void *)0;
  LogToSysLog = 0;
  char *return_value_strrchr_2;
  return_value_strrchr_2=strrchr(argv[(signed long int)0], 47);
  char *return_value_strrchr_1;
  if(!(return_value_strrchr_2 == ((char *)NULL)))
  {
    return_value_strrchr_1=strrchr(argv[(signed long int)0], 47);
    exec_name = return_value_strrchr_1 + (signed long int)1;
  }

  xine_get_version(&xmajor, &xminor, &xsub);
  printf("%s %s  (build with xine-lib %d.%d.%d, using xine-lib %d.%d.%d)\n\n", exec_name, (const void *)"2.0.0-cvs", 1, 2, 6, xmajor, xminor, xsub);
  char *return_value___strdup_3;
  char *return_value___builtin_strchr_4;
  char *return_value___strdup_5;
  char *return_value___builtin_strchr_6;
  signed int tmp_statement_expression_7;
  signed int return_value_strncmp_9;
  signed int return_value_strncmp_10;
  signed int return_value_strncmp_11;
  signed int return_value_strncmp_12;
  char *return_value_strstr_13;
  char *return_value_strstr_14;
  char *return_value_strstr_15;
  signed int return_value_access_16;
  char *return_value___builtin_strchr_17;
  char *return_value___strdup_18;
  char *return_value_strstr_20;
  do
  {
    c=getopt_long(argc, argv, short_options, long_options, (signed int *)(void *)0);
    if(c == -1)
      break;

    switch(c)
    {
      case 72:
      {
        printf("\nUsage: %s [options] [xvdr[+udp|+tcp|+rtp]:[//host[:port]]] \n\nAvailable options:\n", exec_name);
        printf("%s", (const void *)help_str);
        list_xine_plugins((struct frontend_s *)(void *)0, (signed int)(SysLogLevel > 2));
        exit(0);
      }
      case 65:
      {
        return_value___strdup_3=__strdup(optarg);
        audio_driver = return_value___strdup_3;
        return_value___builtin_strchr_4=__builtin_strchr(audio_driver, 58);
        p = return_value___builtin_strchr_4;
        if(!(p == ((char *)NULL)))
        {
          *p = (char)0;
          audio_device = p + (signed long int)1;
        }

        do
          if(SysLogLevel >= 2)
            printf("Audio driver: %s\n", audio_driver);

        while((_Bool)0);
        if(!(audio_device == ((const char *)NULL)))
          do
            if(SysLogLevel >= 2)
              printf("Audio device: %s\n", audio_device);

          while((_Bool)0);

        break;
      }
      case 86:
      {
        return_value___strdup_5=__strdup(optarg);
        video_driver = return_value___strdup_5;
        return_value___builtin_strchr_6=__builtin_strchr(video_driver, 58);
        p = return_value___builtin_strchr_6;
        if(!(p == ((char *)NULL)))
        {
          *p = (char)0;
          video_port = p + (signed long int)1;
        }

        do
          if(SysLogLevel >= 2)
            printf("Video driver: %s\n", video_driver);

        while((_Bool)0);
        if(!(video_port == ((const char *)NULL)))
          do
            if(SysLogLevel >= 2)
              printf("Video port: %s\n", video_port);

          while((_Bool)0);

        break;
      }
      case 87:
      {
        unsigned long int main__1__1__1__9____s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_8;
        return_value___builtin_strcmp_8=__builtin_strcmp(optarg, "root");
        tmp_statement_expression_7 = return_value___builtin_strcmp_8;
        if(tmp_statement_expression_7 == 0)
          window_id = -2;

        else
          window_id=atoi_link1(optarg);
        break;
      }
      case 109:
      {
        modeswitch = 1;
        do
          if(SysLogLevel >= 2)
            printf("Video mode switching not supported\n");

        while((_Bool)0);
        break;
      }
      case 100:
      {
        video_port = optarg;
        break;
      }
      case 120:
      {
        noxkbd = 1;
        break;
      }
      case 97:
      {
        return_value_strncmp_9=strncmp(optarg, "auto", (unsigned long int)4);
        if(return_value_strncmp_9 == 0)
          aspect = 0;

        return_value_strncmp_10=strncmp(optarg, "4:3", (unsigned long int)3);
        if(return_value_strncmp_10 == 0)
          aspect = 2;

        return_value_strncmp_11=strncmp(optarg, "16:9", (unsigned long int)4);
        if(return_value_strncmp_11 == 0)
          aspect = 3;

        return_value_strncmp_12=strncmp(optarg, "16:10", (unsigned long int)5);
        if(return_value_strncmp_12 == 0)
          aspect = 4;

        if(aspect == 0)
        {
          if((signed int)optarg[4l] == 58)
            aspect_controller = optarg + (signed long int)5;

        }

        do
          if(SysLogLevel >= 2)
            printf("Aspect ratio: %s\n", aspect == 0 ? "Auto" : (aspect == 2 ? "4:3" : (aspect == 3 ? "16:9" : (aspect == 4 ? "16:10" : "Default"))));

        while((_Bool)0);
        if(!(aspect_controller == ((const char *)NULL)))
          do
            if(SysLogLevel >= 2)
              printf("Using %s to switch aspect ratio\n", aspect_controller);

          while((_Bool)0);

        break;
      }
      case 102:
      {
        fullscreen = 1;
        do
          if(SysLogLevel >= 2)
            printf("Fullscreen mode\n");

        while((_Bool)0);
        break;
      }
      case 68:
      {
        hud = 0x1;
        do
          if(SysLogLevel >= 2)
            printf("HUD OSD mode\n");

        while((_Bool)0);
        if(!(optarg == ((char *)NULL)))
        {
          return_value_strstr_13=strstr(optarg, "opengl");
          if(!(return_value_strstr_13 == ((char *)NULL)))
          {
            hud = hud | 0x4;
            do
              if(SysLogLevel >= 2)
                printf("OpenGL HUD OSD mode\n");

            while((_Bool)0);
            break;
          }

        }

        if(!(optarg == ((char *)NULL)))
        {
          return_value_strstr_14=strstr(optarg, "xrender");
          if(!(return_value_strstr_14 == ((char *)NULL)))
            do
            {
              fprintf_link2(stderr, "XRender HUD OSD not supported\n");
              exit(-1);
            }
            while((_Bool)0);

        }

        if(!(optarg == ((char *)NULL)))
        {
          return_value_strstr_15=strstr(optarg, "xshape");
          if(!(return_value_strstr_15 == ((char *)NULL)))
          {
            hud = hud | 0x2;
            do
              if(SysLogLevel >= 2)
                printf("XShape HUD OSD mode\n");

            while((_Bool)0);
          }

        }

        break;
      }
      case 79:
      {
        opengl = 1;
        do
          if(SysLogLevel >= 2)
            printf("Using OpenGL to draw video and OSD\n");

        while((_Bool)0);
        break;
      }
      case 119:
      {
        width=atoi_link1(optarg);
        do
          if(SysLogLevel >= 2)
            printf("Width: %d\n", width);

        while((_Bool)0);
        break;
      }
      case 103:
      {
        sscanf(optarg, "%dx%d+%d+%d", &width, &height, &xpos, &ypos);
        do
          if(SysLogLevel >= 2)
            printf("Geometry: %dx%d+%d+%d\n", width, height, xpos, ypos);

        while((_Bool)0);
        break;
      }
      case 104:
      {
        height=atoi_link1(optarg);
        do
          if(SysLogLevel >= 2)
            printf("Height: %d\n", height);

        while((_Bool)0);
        break;
      }
      case 66:
      {
        pes_buffers=atoi_link1(optarg);
        do
          if(SysLogLevel >= 2)
            printf("Buffers: %d\n", pes_buffers);

        while((_Bool)0);
        break;
      }
      case 84:
      {
        tty = optarg;
        return_value_access_16=access(tty, 4 | 2);
        if(!(return_value_access_16 >= 0))
          do
          {
            fprintf_link2(stderr, "Can't access terminal: %s\n", tty);
            exit(-1);
          }
          while((_Bool)0);

        do
          if(SysLogLevel >= 2)
            printf("Terminal: %s\n", tty);

        while((_Bool)0);
        break;
      }
      case 110:
      {
        scale_video = 0;
        do
          if(SysLogLevel >= 2)
            printf("Video scaling disabled\n");

        while((_Bool)0);
        break;
      }
      case 112:
      {
        inactivity_timer=atoi_link1(optarg);
        return_value___builtin_strchr_17=__builtin_strchr(optarg, 58);
        power_off_cmd = return_value___builtin_strchr_17;
        power_off_cmd = power_off_cmd != ((const char *)NULL) ? power_off_cmd + (signed long int)1 : "/sbin/shutdown";
        do
          if(SysLogLevel >= 2)
            printf("Shutdown after %d minutes of inactivity using %s\n", inactivity_timer, power_off_cmd);

        while((_Bool)0);
        break;
      }
      case 80:
      {
        if(!(static_post_plugins == ((char *)NULL)))
          strcatrealloc(static_post_plugins, ";");

        static_post_plugins=strcatrealloc(static_post_plugins, optarg);
        do
          if(SysLogLevel >= 2)
            printf("Post plugins: %s\n", static_post_plugins);

        while((_Bool)0);
        break;
      }
      case 67:
      {
        config_file = optarg;
        do
          if(SysLogLevel >= 2)
            printf("Config file: %s\n", config_file);

        while((_Bool)0);
        break;
      }
      case 76:
      {
        return_value___strdup_18=__strdup((_Bool)optarg ? optarg : "/dev/lircd");
        lirc_dev = return_value___strdup_18;
        return_value_strstr_20=strstr(lirc_dev, ",repeatemu");
        if(!(return_value_strstr_20 == ((char *)NULL)))
        {
          char *return_value_strstr_19;
          return_value_strstr_19=strstr(lirc_dev, ",repeatemu");
          *return_value_strstr_19 = (char)0;
          repeat_emu = 1;
        }

        do
          if(SysLogLevel >= 2)
            printf("LIRC device:  %s%s\n", lirc_dev, repeat_emu != 0 ? ", emulating key repeat" : "");

        while((_Bool)0);
        break;
      }
      case 69:
      {
        cec_hdmi_port = -1;
        break;
      }
      case 101:
      {
        cec_hdmi_port = 0;
        do
        {
          fprintf_link2(stderr, "HDMI-CEC support not compiled in\n");
          exit(-1);
        }
        while((_Bool)0);
        break;
      }
      case 118:
      {
        SysLogLevel = SysLogLevel < 3 ? 3 : SysLogLevel + 1;
        do
          if(SysLogLevel >= 2)
            printf("Verbose mode\n");

        while((_Bool)0);
        break;
      }
      case 115:
      {
        SysLogLevel = 1;
        do
          if(SysLogLevel >= 2)
            printf("Silent mode\n");

        while((_Bool)0);
        break;
      }
      case 83:
      {
        slave_mode = 1;
        do
          if(SysLogLevel >= 2)
            printf("Slave mode\n");

        while((_Bool)0);
        break;
      }
      case 108:
      {
        LogToSysLog = 1;
        openlog(exec_name, 0x01 | 0x02, 1 << 3);
        break;
      }
      case 107:
      {
        nokbd = 1;
        do
          if(SysLogLevel >= 2)
            printf("Keyboard input disabled\n");

        while((_Bool)0);
        break;
      }
      case 111:
      {
        gui_hotkeys = 1;
        do
          if(SysLogLevel >= 2)
            printf("GUI hotkeys enabled\n  mapping keyboard f,F     -> fullscreen toggle\n          keyboard d,D     -> deinterlace toggle\n          keyboard p,P     -> power off\n          LIRC Deinterlace -> deinterlace toggle\n          LIRC Fullscreen  -> fullscreen toggle\n          LIRC PowerOff    -> power off\n          LIRC Quit        -> exit\n");

        while((_Bool)0);
        break;
      }
      case 85:
      {
        touchscreen = 1;
        do
          if(SysLogLevel >= 2)
            printf("Touchscreen input enabled\n");

        while((_Bool)0);
        do
          if(SysLogLevel >= 2)
            printf("Display is divided to 4x3 buttons:\n");

        while((_Bool)0);
        do
          if(SysLogLevel >= 2)
            printf("  Menu   Up     Back   Ok  \n");

        while((_Bool)0);
        do
          if(SysLogLevel >= 2)
            printf("  Left   Down   Right      \n");

        while((_Bool)0);
        do
          if(SysLogLevel >= 2)
            printf("  Red    Green  Yellow Blue\n");

        while((_Bool)0);
        break;
      }
      case 98:
      {
        daemon_mode = 1;
        nokbd = daemon_mode;
        do
          if(SysLogLevel >= 2)
            printf("Keyboard input disabled\n");

        while((_Bool)0);
        break;
      }
      case 82:
      {
        reconnect = 1;
        do
          if(SysLogLevel >= 2)
            printf("Automatic reconnection enabled\n");

        while((_Bool)0);
        break;
      }
      case 116:
      {
        ftcp = 1;
        do
          if(SysLogLevel >= 2)
            printf("Protocol: TCP\n");

        while((_Bool)0);
        break;
      }
      case 117:
      {
        fudp = 1;
        do
          if(SysLogLevel >= 2)
            printf("Protocol: UDP\n");

        while((_Bool)0);
        break;
      }
      case 114:
      {
        frtp = 1;
        do
          if(SysLogLevel >= 2)
            printf("Protocol: RTP\n");

        while((_Bool)0);
        break;
      }
      case 1:
      {
        printf("arg 1 (%s)\n", long_options[(signed long int)optind].name);
        exit(0);
      }
    }
  }
  while((_Bool)1);
  if(!(optind >= argc))
  {
    char *return_value___strdup_21;
    return_value___strdup_21=__strdup(argv[(signed long int)optind]);
    mrl = return_value___strdup_21;
    do
      if(SysLogLevel >= 2)
        printf("VDR Server: %s\n", mrl);

    while((_Bool)0);
    do
    {
      optind = optind + 1;
      if(optind >= argc)
        break;

      printf("Unknown argument: %s\n", argv[(signed long int)optind]);
    }
    while((_Bool)1);
  }

  do
    if(SysLogLevel >= 2)
      printf("\n");

  while((_Bool)0);
  if(!(tty == ((const char *)NULL)))
  {
    stdin=freopen(tty, "r", stdin);
    stdout=freopen(tty, "w", stdout);
    stderr=freopen(tty, "w", stderr);
  }

  signed int return_value_strncmp_22;
  _Bool tmp_if_expr_24;
  signed int return_value_strncmp_23;
  _Bool tmp_if_expr_26;
  signed int return_value_strncmp_25;
  _Bool tmp_if_expr_28;
  signed int return_value_strncmp_27;
  if(!(mrl == ((char *)NULL)))
  {
    return_value_strncmp_22=strncmp(mrl, "xvdr:tcp:", (unsigned long int)(4 + 5));
    if(return_value_strncmp_22 == 0)
      tmp_if_expr_24 = (_Bool)1;

    else
    {
      return_value_strncmp_23=strncmp(mrl, "xvdr:udp:", (unsigned long int)(4 + 5));
      tmp_if_expr_24 = !(return_value_strncmp_23 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_24)
      tmp_if_expr_26 = (_Bool)1;

    else
    {
      return_value_strncmp_25=strncmp(mrl, "xvdr:rtp:", (unsigned long int)(4 + 5));
      tmp_if_expr_26 = !(return_value_strncmp_25 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_26)
      tmp_if_expr_28 = (_Bool)1;

    else
    {
      return_value_strncmp_27=strncmp(mrl, "xvdr:pipe:", (unsigned long int)(4 + 6));
      tmp_if_expr_28 = !(return_value_strncmp_27 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_28)
      mrl[(signed long int)4] = (char)43;

  }

  _Bool tmp_if_expr_35;
  signed int tmp_statement_expression_33;
  if(mrl == ((char *)NULL))
    tmp_if_expr_35 = (_Bool)1;

  else
  {
    unsigned long int main__1__9____s1_len;
    unsigned long int main__1__9____s2_len;
    signed int return_value___builtin_strcmp_34;
    return_value___builtin_strcmp_34=__builtin_strcmp(mrl, "xvdr:");
    tmp_statement_expression_33 = return_value___builtin_strcmp_34;
    tmp_if_expr_35 = !(tmp_statement_expression_33 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_38;
  signed int tmp_statement_expression_36;
  if(tmp_if_expr_35)
    tmp_if_expr_38 = (_Bool)1;

  else
  {
    unsigned long int main__1__10____s1_len;
    unsigned long int main__1__10____s2_len;
    signed int return_value___builtin_strcmp_37;
    return_value___builtin_strcmp_37=__builtin_strcmp(mrl, "xvdr+tcp:");
    tmp_statement_expression_36 = return_value___builtin_strcmp_37;
    tmp_if_expr_38 = !(tmp_statement_expression_36 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_41;
  signed int tmp_statement_expression_39;
  if(tmp_if_expr_38)
    tmp_if_expr_41 = (_Bool)1;

  else
  {
    unsigned long int main__1__11____s1_len;
    unsigned long int main__1__11____s2_len;
    signed int return_value___builtin_strcmp_40;
    return_value___builtin_strcmp_40=__builtin_strcmp(mrl, "xvdr+udp:");
    tmp_statement_expression_39 = return_value___builtin_strcmp_40;
    tmp_if_expr_41 = !(tmp_statement_expression_39 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_44;
  signed int tmp_statement_expression_42;
  if(tmp_if_expr_41)
    tmp_if_expr_44 = (_Bool)1;

  else
  {
    unsigned long int main__1__12____s1_len;
    unsigned long int main__1__12____s2_len;
    signed int return_value___builtin_strcmp_43;
    return_value___builtin_strcmp_43=__builtin_strcmp(mrl, "xvdr+rtp:");
    tmp_statement_expression_42 = return_value___builtin_strcmp_43;
    tmp_if_expr_44 = !(tmp_statement_expression_42 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_47;
  signed int tmp_statement_expression_45;
  if(tmp_if_expr_44)
    tmp_if_expr_47 = (_Bool)1;

  else
  {
    unsigned long int __s1_len;
    unsigned long int main__1__13____s2_len;
    signed int return_value___builtin_strcmp_46;
    return_value___builtin_strcmp_46=__builtin_strcmp(mrl, "xvdr+pipe:");
    tmp_statement_expression_45 = return_value___builtin_strcmp_46;
    tmp_if_expr_47 = !(tmp_statement_expression_45 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_asprintf_30;
  if(tmp_if_expr_47)
  {
    char address[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    signed int port = -1;
    do
      if(SysLogLevel >= 2)
        printf("VDR server not given, searching ...\n");

    while((_Bool)0);
    signed int return_value_udp_discovery_find_server_32;
    return_value_udp_discovery_find_server_32=udp_discovery_find_server(&port, &address[(signed long int)0]);
    if(!(return_value_udp_discovery_find_server_32 == 0))
    {
      do
        if(SysLogLevel >= 2)
          printf("Found VDR server: host %s, port %d\n", (const void *)address, port);

      while((_Bool)0);
      if(!(mrl == ((char *)NULL)))
      {
        char *tmp = mrl;
        mrl = (char *)(void *)0;
        signed int return_value_asprintf_29;
        return_value_asprintf_29=asprintf_link2(&mrl, "%s//%s:%d", tmp, (const void *)address, port);
        if(!(return_value_asprintf_29 >= 0))
          return -1;

        free((void *)tmp);
      }

      else
      {
        return_value_asprintf_30=asprintf_link2(&mrl, "xvdr://%s:%d", (const void *)address, port);
        if(!(return_value_asprintf_30 >= 0))
          return -1;

      }
    }

    else
    {
      do
        if(SysLogLevel >= 2)
          printf("---------------------------------------------------------------\nWARNING: MRL not given and server not found from local network.\n         Trying to connect to default port on local host.\n---------------------------------------------------------------\n");

      while((_Bool)0);
      char *return_value___strdup_31;
      return_value___strdup_31=__strdup("xvdr://127.0.0.1");
      mrl = return_value___strdup_31;
    }
  }

  signed int return_value_strncmp_50;
  signed int return_value_strncmp_49;
  if(!(mrl == ((char *)NULL)))
  {
    return_value_strncmp_50=strncmp(mrl, "xvdr:", (unsigned long int)(4 + 1));
    if(!(return_value_strncmp_50 == 0))
    {
      return_value_strncmp_49=strncmp(mrl, "xvdr+", (unsigned long int)(4 + 1));
      if(!(return_value_strncmp_49 == 0))
      {
        char *mrl2 = mrl;
        do
          if(SysLogLevel >= 2)
            printf("WARNING: MRL does not start with 'xvdr:' (%s)\n", mrl);

        while((_Bool)0);
        signed int return_value_asprintf_48;
        return_value_asprintf_48=asprintf_link2(&mrl, "xvdr://%s", mrl);
        if(!(return_value_asprintf_48 >= 0))
          return -1;

        free((void *)mrl2);
      }

    }

  }

  char *main__1__18__tmp = (char *)(void *)0;
  char *main__1__18__mrl2 = mrl;
  _Bool tmp_if_expr_58;
  char *return_value_strstr_57;
  if(!(frtp == 0))
  {
    return_value_strstr_57=strstr(mrl, "rtp:");
    tmp_if_expr_58 = !(return_value_strstr_57 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_58 = (_Bool)0;
  char *return_value___strdup_51;
  _Bool tmp_if_expr_56;
  char *return_value_strstr_55;
  char *return_value___strdup_52;
  char *return_value_strstr_54;
  char *return_value___strdup_53;
  if(tmp_if_expr_58)
  {
    return_value___strdup_51=__strdup("xvdr+rtp:");
    main__1__18__tmp = return_value___strdup_51;
  }

  else
  {
    if(!(fudp == 0))
    {
      return_value_strstr_55=strstr(mrl, "udp:");
      tmp_if_expr_56 = !(return_value_strstr_55 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_56 = (_Bool)0;
    if(tmp_if_expr_56)
    {
      return_value___strdup_52=__strdup("xvdr+udp:");
      main__1__18__tmp = return_value___strdup_52;
    }

    else
      if(!(ftcp == 0))
      {
        return_value_strstr_54=strstr(mrl, "tcp:");
        if(return_value_strstr_54 == ((char *)NULL))
        {
          return_value___strdup_53=__strdup("xvdr+tcp:");
          main__1__18__tmp = return_value___strdup_53;
        }

      }

  }
  if(!(main__1__18__tmp == ((char *)NULL)))
  {
    char *return_value___builtin_strchr_59;
    return_value___builtin_strchr_59=__builtin_strchr(mrl, 47);
    mrl=strcatrealloc(main__1__18__tmp, return_value___builtin_strchr_59);
    free((void *)main__1__18__mrl2);
  }

  signed int *return_value___errno_location_60;
  char *return_value_strerror_61;
  if(!(daemon_mode == 0))
  {
    do
      if(SysLogLevel >= 2)
        printf("Entering daemon mode\n\n");

    while((_Bool)0);
    signed int return_value_daemon_63;
    return_value_daemon_63=daemon(1, 0);
    if(return_value_daemon_63 == -1)
    {
      fprintf_link2(stderr, "%s: %m\n", exec_name);
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[vdr-fe]    ", "daemon() failed");
          signed int *return_value___errno_location_62;
          return_value___errno_location_62=__errno_location();
          if(!(*return_value___errno_location_62 == 0))
          {
            return_value___errno_location_60=__errno_location();
            return_value_strerror_61=strerror(*return_value___errno_location_60);
            x_syslog(3, "[vdr-fe]    ", "   (ERROR (%s,%d): %s)", (const void *)"xine_frontend_main.c", 572, return_value_strerror_61);
          }

        }

      while((_Bool)0);
      return -2;
    }

  }

  fe=fe_creator();
  signed int return_value_4;
  if(fe == ((struct frontend_s *)NULL))
  {
    fprintf_link2(stderr, "Error initializing frontend\n");
    return -3;
  }

  else
  {
    signed int return_value;
    return_value=fe->fe_display_open(fe, xpos, ypos, width, height, fullscreen, hud, opengl, modeswitch, "", aspect, noxkbd, gui_hotkeys, touchscreen, video_port, scale_video, aspect_controller, window_id);
    if(return_value == 0)
    {
      fprintf_link2(stderr, "Error opening display\n");
      fe->fe_free(fe);
      return -4;
    }

    else
    {
      signed int return_value_1;
      return_value_1=fe->xine_init(fe, audio_driver, audio_device, video_driver, pes_buffers, static_post_plugins, config_file);
      if(return_value_1 == 0)
      {
        fprintf_link2(stderr, "Error initializing xine\n");
        list_xine_plugins(fe, (signed int)(SysLogLevel > 2));
        fe->fe_free(fe);
        return -5;
      }

      else
      {
        if(!(power_off_cmd == ((const char *)NULL)))
          fe->shutdown_init(fe, power_off_cmd, inactivity_timer * 60);

        if(SysLogLevel >= 3)
          list_xine_plugins(fe, (signed int)(SysLogLevel > 2));

        void (*return_value_signal_64)(signed int);
        return_value_signal_64=signal(1, SignalHandler);
        if(return_value_signal_64 == (void (*)(signed int))1)
          signal(1, (void (*)(signed int))1);

        void (*return_value_signal_65)(signed int);
        return_value_signal_65=signal(2, SignalHandler);
        if(return_value_signal_65 == (void (*)(signed int))1)
          signal(2, (void (*)(signed int))1);

        void (*return_value_signal_66)(signed int);
        return_value_signal_66=signal(15, SignalHandler);
        if(return_value_signal_66 == (void (*)(signed int))1)
          signal(15, (void (*)(signed int))1);

        void (*return_value_signal_67)(signed int);
        return_value_signal_67=signal(13, SignalHandler);
        if(return_value_signal_67 == (void (*)(signed int))1)
          signal(13, (void (*)(signed int))1);

        if(firsttry == 0)
        {
          if(SysLogLevel >= 2)
            printf("Connection to server lost. Reconnecting after two seconds...\n");

          sleep((unsigned int)2);
          if(SysLogLevel >= 2)
            printf("Reconnecting...\n");

        }

        signed int return_value_2;
        return_value_2=fe->xine_open(fe, mrl);
        if(return_value_2 == 0)
        {
          if(firsttry == 0)
          {
            if(SysLogLevel >= 2)
              printf("Error opening %s\n", mrl);

          }

          fprintf_link2(stderr, "Error opening %s\n", mrl);
          fe->fe_free(fe);
          return -6;
        }

        else
        {
          signed int return_value_3;
          return_value_3=fe->xine_play(fe);
          if(return_value_3 == 0)
          {
            if(firsttry == 0)
            {
              if(SysLogLevel >= 2)
                printf("Error playing %s\n", argv[(signed long int)1]);

            }

            fprintf_link2(stderr, "Error playing %s\n", argv[(signed long int)1]);
            fe->fe_free(fe);
            return -7;
          }

          else
          {
            if(!(firsttry == 0))
            {
              lirc_start(fe, lirc_dev, repeat_emu);
              cec_start(fe, cec_hdmi_port, cec_dev_type);
              if(nokbd == 0)
              {
                if(SysLogLevel >= 2)
                  printf("\n\nPress Esc to exit\n\n");

                kbd_start(fe, slave_mode);
              }

            }

            fflush(stdout);
            fflush(stderr);
            if(last_signal == 0)
              return_value_4=fe->fe_run(fe);

            xine_finished=fe->xine_is_finished(fe, 0);
            fe->xine_close(fe);
            firsttry = 0;
            if(last_signal == 1)
              last_signal = 0;

            if(SysLogLevel >= 2)
              printf("Terminating...\n");

            fe->send_event(fe, "QUIT");
            lirc_stop();
            cec_stop();
            if(nokbd == 0)
              kbd_stop();

            fe->fe_free(fe);
            free((void *)static_post_plugins);
            free((void *)mrl);
            free((void *)audio_driver);
            free((void *)video_driver);
            free((void *)lirc_dev);
            return xine_finished == 1 ? 0 : 1;
          }
        }
      }
    }
  }
}

// make_dirs
// file xine_frontend.c line 118
static void make_dirs(const char *file)
{
  struct stat st;
  char *s;
  char *return_value___strdup_1;
  return_value___strdup_1=__strdup(file);
  s = return_value___strdup_1;
  char *p = s;
  char *return_value___builtin_strchr_2;
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  char *tmp_post_8;
  if((signed int)*p == 47)
  {
    p = p + 1l;
    do
    {
      return_value___builtin_strchr_2=__builtin_strchr(p, 47);
      p = return_value___builtin_strchr_2;
      if(p == ((char *)NULL))
        break;

      *p = (char)0;
      signed int return_value_stat_7;
      return_value_stat_7=stat(s, &st);
      if(!((61440u & st.st_mode) == 16384u) || !(return_value_stat_7 == 0))
      {
        signed int return_value_mkdir_6;
        return_value_mkdir_6=mkdir(s, (unsigned int)(0400 | 0200 | 0100 | (0400 | 0200 | 0100) >> 3 | ((0400 | 0200 | 0100) >> 3) >> 3));
        if(return_value_mkdir_6 == -1)
        {
          do
            if(SysLogLevel >= 1)
            {
              x_syslog(3, "[vdr-fe]    ", "Can't create %s", s);
              signed int *return_value___errno_location_5;
              return_value___errno_location_5=__errno_location();
              if(!(*return_value___errno_location_5 == 0))
              {
                return_value___errno_location_3=__errno_location();
                return_value_strerror_4=strerror(*return_value___errno_location_3);
                x_syslog(3, "[vdr-fe]    ", "   (ERROR (%s,%d): %s)", (const void *)"xine_frontend.c", 130, return_value_strerror_4);
              }

            }

          while((_Bool)0);
          break;
        }

        do
          if(SysLogLevel >= 3)
            x_syslog(7, "[vdr-fe]    ", "Created directory %s", s);

        while((_Bool)0);
      }

      tmp_post_8 = p;
      p = p + 1l;
      *tmp_post_8 = (char)47;
    }
    while((_Bool)1);
  }

  free((void *)s);
}

// memcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy(void * restrict __dest, const void * restrict __src, unsigned long int __len)
{
  void *return_value___builtin___memcpy_chk_1;
  return_value___builtin___memcpy_chk_1=__builtin___memcpy_chk(__dest, __src, __len, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1;
}

// memcpy_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy_link1(void * restrict __dest_link1, const void * restrict __src_link1, unsigned long int __len_link1)
{
  void *return_value___builtin___memcpy_chk_1_link1;
  return_value___builtin___memcpy_chk_1_link1=__builtin___memcpy_chk(__dest_link1, __src_link1, __len_link1, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link1;
}

// memcpy_link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy_link2(void * restrict __dest_link2, const void * restrict __src_link2, unsigned long int __len_link2)
{
  void *return_value___builtin___memcpy_chk_1_link2;
  return_value___builtin___memcpy_chk_1_link2=__builtin___memcpy_chk(__dest_link2, __src_link2, __len_link2, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link2;
}

// memcpy_link3
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy_link3(void * restrict __dest_link3, const void * restrict __src_link3, unsigned long int __len_link3)
{
  void *return_value___builtin___memcpy_chk_1_link3;
  return_value___builtin___memcpy_chk_1_link3=__builtin___memcpy_chk(__dest_link3, __src_link3, __len_link3, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link3;
}

// memcpy_link4
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy_link4(void * restrict __dest_link4, const void * restrict __src_link4, unsigned long int __len_link4)
{
  void *return_value___builtin___memcpy_chk_1_link4;
  return_value___builtin___memcpy_chk_1_link4=__builtin___memcpy_chk(__dest_link4, __src_link4, __len_link4, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link4;
}

// memmove
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 57
static inline void * memmove(void *__dest, const void *__src, unsigned long int __len)
{
  char *return_value___builtin___memmove_chk_1;
  return_value___builtin___memmove_chk_1=__builtin___memmove_chk(__dest, __src, __len, 18446744073709551615ul);
  return (void *)return_value___builtin___memmove_chk_1;
}

// memset
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset(void *__dest, signed int __ch, unsigned long int __len)
{
  void *return_value___builtin___memset_chk_1;
  return_value___builtin___memset_chk_1=__builtin___memset_chk(__dest, __ch, __len, 18446744073709551615ul);
  return return_value___builtin___memset_chk_1;
}

// memset_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset_link1(void *__dest_link1, signed int __ch_link1, unsigned long int __len_link1)
{
  void *return_value___builtin___memset_chk_1_link1;
  return_value___builtin___memset_chk_1_link1=__builtin___memset_chk(__dest_link1, __ch_link1, __len_link1, 18446744073709551615ul);
  return return_value___builtin___memset_chk_1_link1;
}

// open_display
// file xine_sxfe_frontend.c line 1369
static signed int open_display(struct sxfe_s *this, const char *video_port)
{
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(video_port == ((const char *)NULL)))
  {
    if(!(*video_port == 0))
    {
      this->display=XOpenDisplay(video_port);
      if(this->display == ((struct _XDisplay *)NULL))
        do
          if(SysLogLevel >= 1)
          {
            x_syslog(3, "[vdr-sxfe]  ", "sxfe_display_open: failed to connect to X server (%s)", video_port);
            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            if(!(*return_value___errno_location_3 == 0))
            {
              return_value___errno_location_1=__errno_location();
              return_value_strerror_2=strerror(*return_value___errno_location_1);
              x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 1374, return_value_strerror_2);
            }

          }

        while((_Bool)0);

    }

  }

  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  if(this->display == ((struct _XDisplay *)NULL))
  {
    video_port=getenv("DISPLAY");
    if(!(video_port == ((const char *)NULL)))
    {
      this->display=XOpenDisplay(video_port);
      if(this->display == ((struct _XDisplay *)NULL))
        do
          if(SysLogLevel >= 1)
          {
            x_syslog(3, "[vdr-sxfe]  ", "sxfe_display_open: failed to connect to X server (%s)", video_port);
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            if(!(*return_value___errno_location_6 == 0))
            {
              return_value___errno_location_4=__errno_location();
              return_value_strerror_5=strerror(*return_value___errno_location_4);
              x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 1380, return_value_strerror_5);
            }

          }

        while((_Bool)0);

    }

  }

  if(this->display == ((struct _XDisplay *)NULL))
    this->display=XOpenDisplay((const char *)(void *)0);

  signed int *return_value___errno_location_7;
  char *return_value_strerror_8;
  if(this->display == ((struct _XDisplay *)NULL))
  {
    this->display=XOpenDisplay(":0.0");
    if(this->display == ((struct _XDisplay *)NULL))
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[vdr-sxfe]  ", "sxfe_display_open: failed to connect to X server (:0.0)");
          signed int *return_value___errno_location_9;
          return_value___errno_location_9=__errno_location();
          if(!(*return_value___errno_location_9 == 0))
          {
            return_value___errno_location_7=__errno_location();
            return_value_strerror_8=strerror(*return_value___errno_location_7);
            x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 1389, return_value_strerror_8);
          }

        }

      while((_Bool)0);

  }

  signed int *return_value___errno_location_10;
  char *return_value_strerror_11;
  if(this->display == ((struct _XDisplay *)NULL))
  {
    this->display=XOpenDisplay("127.0.0.1:0.0");
    if(this->display == ((struct _XDisplay *)NULL))
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[vdr-sxfe]  ", "sxfe_display_open: failed to connect to X server (127.0.0.1:0.0");
          signed int *return_value___errno_location_12;
          return_value___errno_location_12=__errno_location();
          if(!(*return_value___errno_location_12 == 0))
          {
            return_value___errno_location_10=__errno_location();
            return_value_strerror_11=strerror(*return_value___errno_location_10);
            x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 1394, return_value_strerror_11);
          }

        }

      while((_Bool)0);

  }

  signed int *return_value___errno_location_13;
  char *return_value_strerror_14;
  if(this->display == ((struct _XDisplay *)NULL))
  {
    do
      if(SysLogLevel >= 1)
      {
        x_syslog(3, "[vdr-sxfe]  ", "sxfe_display_open: failed to connect to X server.");
        signed int *return_value___errno_location_15;
        return_value___errno_location_15=__errno_location();
        if(!(*return_value___errno_location_15 == 0))
        {
          return_value___errno_location_13=__errno_location();
          return_value_strerror_14=strerror(*return_value___errno_location_13);
          x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 1398, return_value_strerror_14);
        }

      }

    while((_Bool)0);
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[vdr-sxfe]  ", "If X server is running, try running \"xhost +\" in xterm window");

    while((_Bool)0);
    return 0;
  }

  else
    return 1;
}

// opengl_deinit
// file xine_sxfe_frontend.c line 1982
static void opengl_deinit(struct sxfe_s *this)
{
  XFreePixmap(this->display, this->video_frame_pixmap);
  glXDestroyContext(this->display, this->opengl_context);
  XDestroyWindow(this->display, this->opengl_window);
}

// opengl_draw_frame_thread
// file xine_sxfe_frontend.c line 1990
static void * opengl_draw_frame_thread(void *arg)
{
  struct sxfe_s *this = (struct sxfe_s *)arg;
  signed int draw_frame = 0;
  signed int window_mapped = 0;
  signed int keep_osd_open = 0;
  signed int prev_osd_visible = 0;
  signed short int video_x0;
  signed short int video_y0;
  signed short int video_x1;
  signed short int video_y1;
  signed short int osd_x0;
  signed short int osd_y0;
  signed short int osd_x1;
  signed short int osd_y1;
  float osd_alpha = (float)0;
  float osd_alpha_step = (float)0.2;
  signed short int win_width = (signed short int)-1;
  signed short int win_height = (signed short int)-1;
  signed short int win_x = (signed short int)-1;
  signed short int win_y = (signed short int)-1;
  struct anonymous_20 xrect;
  float video_tex_width;
  float video_tex_height;
  signed int first_frame = 1;
  signed int force_redirect = 0;
  XLockDisplay(this->display);
  signed int return_value_opengl_init_1;
  return_value_opengl_init_1=opengl_init(this);
  if(!(return_value_opengl_init_1 >= 0))
  {
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[vdr-sxfe]  ", "OpenGL initialization failed");

    while((_Bool)0);
    XUnlockDisplay(this->display);
    exit(1);
  }

  XUnlockDisplay(this->display);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  signed int *return_value___errno_location_8;
  char *return_value_strerror_9;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_11;
  while((_Bool)1)
  {
    pthread_mutex_lock(&this->opengl_redraw_mutex);
    if(this->opengl_redraw_served_nr == this->opengl_redraw_request_nr)
      pthread_cond_wait(&this->opengl_redraw_cv, &this->opengl_redraw_mutex);

    pthread_mutex_unlock(&this->opengl_redraw_mutex);
    if(this->opengl_deinit != 0)
      break;

    if(!((signed int)win_x == (signed int)this->_anon0.x.xpos))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)win_y != (signed int)this->_anon0.x.ypos ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)win_width != (signed int)this->_anon0.x.width ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)win_height != (signed int)this->_anon0.x.height ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      win_x = (signed short int)this->_anon0.x.xpos;
      win_y = (signed short int)this->_anon0.x.ypos;
      win_width = (signed short int)this->_anon0.x.width;
      win_height = (signed short int)this->_anon0.x.height;
      force_redirect = 1;
      xrect.x = win_x;
      xrect.y = win_y;
      xrect.width = (unsigned short int)win_width;
      xrect.height = (unsigned short int)win_height;
      if(!(this->opengl_xshape_available == 0))
        XShapeCombineRectangles(this->display, this->opengl_window, 0, 0, 0, &xrect, 1, 0, 0);

    }

    do
      if(SysLogLevel >= 4)
        x_syslog(7, "[vdr-sxfe]  ", "win_x=%d win_y=%d win_width=%d win_height=%d", win_x, win_y, win_width, win_height);

    while((_Bool)0);
    keep_osd_open = 0;
    if(!(this->osd_visible == 0))
    {
      if(osd_alpha < 1.000000f)
      {
        osd_alpha = osd_alpha + osd_alpha_step;
        if(osd_alpha > 1.000000f)
          osd_alpha = (float)1.0;

      }

    }

    else
    {
      this->video_win_active = (unsigned char)0;
      if(osd_alpha > 0.000000f)
      {
        osd_alpha = osd_alpha - osd_alpha_step;
        if(osd_alpha < 0.000000f)
          osd_alpha = (float)0.0;

        keep_osd_open = 1;
      }

    }
    do
      if(SysLogLevel >= 4)
        x_syslog(7, "[vdr-sxfe]  ", "osd_alpha=%.2f keep_osd_open=%d", osd_alpha, keep_osd_open);

    while((_Bool)0);
    if(!(this->osd_visible == 0) || !(window_mapped == 0))
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = this->opengl_always != 0 ? (_Bool)1 : (_Bool)0;
    draw_frame = (signed int)tmp_if_expr_5;
    if(!(this->opengl_hud == 0))
      tmp_if_expr_6 = this->osd_visible != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_6 = (_Bool)0;
    if((prev_osd_visible == 0 || !(force_redirect == 0)) && tmp_if_expr_6)
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = (this->opengl_always != 0 ? (first_frame != 0 || force_redirect != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    static unsigned int count = (unsigned int)0;
    if(tmp_if_expr_7)
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-sxfe]  ", "redirecting video to opengl frame texture");

      while((_Bool)0);
      xine_port_send_gui_data(this->_anon0.x.video_port, 2, (void *)this->video_frame_pixmap);
      draw_frame = 0;
      count = (unsigned int)0;
      osd_alpha = osd_alpha - (float)2 * osd_alpha_step;
    }

    if(!(this->opengl_hud == 0))
    {
      if(this->osd_visible == 0)
      {
        if(!(prev_osd_visible == 0))
        {
          if(keep_osd_open == 0)
          {
            if(this->opengl_always == 0)
            {
              do
                if(SysLogLevel >= 3)
                  x_syslog(7, "[vdr-sxfe]  ", "redirecting video to window");

              while((_Bool)0);
              xine_port_send_gui_data(this->_anon0.x.video_port, 2, (void *)this->window[(signed long int)(this->fullscreen != 0 ? 1 : 0)]);
              count = (unsigned int)0;
            }

          }

        }

      }

    }

    if(!(draw_frame == 0))
    {
      do
        if(SysLogLevel >= 4)
          x_syslog(7, "[vdr-sxfe]  ", "drawing frame nr %d", count);

      while((_Bool)0);
      XLockDisplay(this->display);
      video_tex_width = (float)1.0;
      video_tex_height = (float)1.0;
      if(!(this->video_win_active == 0))
      {
        pthread_mutex_lock(&this->video_win_mutex);
        video_x0 = (signed short int)((signed int)win_x + (signed int)this->video_win_x);
        video_y0 = (signed short int)((signed int)win_y + (signed int)this->video_win_y);
        video_tex_width = (float)win_width / (float)this->screen_width;
        video_tex_height = (float)win_height / (float)this->screen_height;
        video_x1 = (signed short int)((signed int)video_x0 + ((signed int)this->video_win_w - 1));
        video_y1 = (signed short int)((signed int)video_y0 + ((signed int)this->video_win_h - 1));
        pthread_mutex_unlock(&this->video_win_mutex);
      }

      else
      {
        video_x0 = win_x;
        video_y0 = win_y;
        video_x1 = (signed short int)(((signed int)video_x0 + this->screen_width) - 1);
        video_y1 = (signed short int)(((signed int)video_y0 + this->screen_height) - 1);
      }
      osd_x0 = win_x;
      osd_y0 = win_y;
      osd_x1 = (signed short int)(((signed int)osd_x0 + (signed int)win_width) - 1);
      osd_y1 = (signed short int)(((signed int)osd_y0 + (signed int)win_height) - 1);
      video_y0 = (signed short int)((this->screen_height - 1) - (signed int)video_y0);
      video_y1 = (signed short int)((this->screen_height - 1) - (signed int)video_y1);
      osd_y0 = (signed short int)((this->screen_height - 1) - (signed int)osd_y0);
      osd_y1 = (signed short int)((this->screen_height - 1) - (signed int)osd_y1);
      do
        if(SysLogLevel >= 4)
          x_syslog(7, "[vdr-sxfe]  ", "video_x0=%d video_y0=%d video_x1=%d video_y1=%d", video_x0, video_y0, video_x1, video_y1);

      while((_Bool)0);
      do
        if(SysLogLevel >= 4)
          x_syslog(7, "[vdr-sxfe]  ", "osd_x0=%d osd_y0=%d osd_x1=%d osd_y1=%d", osd_x0, osd_y0, osd_x1, osd_y1);

      while((_Bool)0);
      glClear((unsigned int)0x00004000);
      glBindTexture((unsigned int)0x0DE1, this->video_frame_texture);
      glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
      glBegin((unsigned int)0x0007);
      glTexCoord2f((float)0.0, video_tex_height);
      glVertex3f((float)video_x0, (float)video_y1, (float)0.0);
      glTexCoord2f(video_tex_width, video_tex_height);
      glVertex3f((float)video_x1, (float)video_y1, (float)0.0);
      glTexCoord2f(video_tex_width, (float)0.0);
      glVertex3f((float)video_x1, (float)video_y0, (float)0.0);
      glTexCoord2f((float)0.0, (float)0.0);
      glVertex3f((float)video_x0, (float)video_y0, (float)0.0);
      glEnd();
      if(!(this->osd_visible == 0) || !(keep_osd_open == 0))
      {
        glBindTexture((unsigned int)0x0DE1, this->osd_texture);
        pthread_mutex_lock(&this->opengl_osd_texture_img_mutex);
        if(!(this->opengl_osd_texture_img_updated == 0))
        {
          glTexImage2D((unsigned int)0x0DE1, 0, 0x1908, (signed int)this->osd_width, (signed int)this->osd_height, 0, (unsigned int)0x1908, (unsigned int)0x8035, (const void *)this->opengl_osd_texture_img);
          unsigned int error;
          error=glGetError();
          if(!(error == 0u))
            do
              if(SysLogLevel >= 1)
              {
                x_syslog(3, "[vdr-sxfe]  ", "Can't update hud image texture");
                signed int *return_value___errno_location_10;
                return_value___errno_location_10=__errno_location();
                if(!(*return_value___errno_location_10 == 0))
                {
                  return_value___errno_location_8=__errno_location();
                  return_value_strerror_9=strerror(*return_value___errno_location_8);
                  x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 2139, return_value_strerror_9);
                }

              }

            while((_Bool)0);

          this->opengl_osd_texture_img_updated = (unsigned char)0;
        }

        pthread_mutex_unlock(&this->opengl_osd_texture_img_mutex);
        glColor4f(1.0f, 1.0f, 1.0f, osd_alpha);
        glBegin((unsigned int)0x0007);
        glTexCoord2f((float)0.0, (float)1.0);
        glVertex3f((float)osd_x0, (float)osd_y1, (float)0.0);
        glTexCoord2f((float)1.0, (float)1.0);
        glVertex3f((float)osd_x1, (float)osd_y1, (float)0.0);
        glTexCoord2f((float)1.0, (float)0.0);
        glVertex3f((float)osd_x1, (float)osd_y0, (float)0.0);
        glTexCoord2f((float)0.0, (float)0.0);
        glVertex3f((float)osd_x0, (float)osd_y0, (float)0.0);
        glEnd();
      }

      glXSwapBuffers(this->display, this->opengl_window);
      XUnlockDisplay(this->display);
      count = count + 1u;
    }

    if(window_mapped == 0 && count == 2u && !(this->osd_visible == 0))
      tmp_if_expr_12 = (_Bool)1;

    else
    {
      if(!(first_frame == 0))
        tmp_if_expr_11 = this->opengl_always != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_11 = (_Bool)0;
      tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
    }
    if(!(force_redirect == 0) || tmp_if_expr_12)
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-sxfe]  ", "mapping opengl window");

      while((_Bool)0);
      XLockDisplay(this->display);
      XRaiseWindow(this->display, this->opengl_window);
      XMapWindow(this->display, this->opengl_window);
      XUnlockDisplay(this->display);
      window_mapped = 1;
    }

    if(this->osd_visible == 0)
    {
      if(count == 3u)
      {
        if(!(window_mapped == 0))
        {
          if(keep_osd_open == 0)
          {
            if(this->opengl_always == 0)
            {
              do
                if(SysLogLevel >= 3)
                  x_syslog(7, "[vdr-sxfe]  ", "unmapping opengl window");

              while((_Bool)0);
              XLockDisplay(this->display);
              XLowerWindow(this->display, this->opengl_window);
              XUnmapWindow(this->display, this->opengl_window);
              XUnlockDisplay(this->display);
              window_mapped = 0;
            }

          }

        }

      }

    }

    if(keep_osd_open == 0)
      prev_osd_visible = (signed int)this->osd_visible;

    first_frame = 0;
    force_redirect = 0;
    pthread_mutex_lock(&this->opengl_redraw_finished_mutex);
    this->opengl_redraw_served_nr = this->opengl_redraw_served_nr + 1u;
    pthread_cond_signal(&this->opengl_redraw_finished_cv);
    pthread_mutex_unlock(&this->opengl_redraw_finished_mutex);
  }
  opengl_deinit(this);
  return (void *)0;
}

// opengl_fill_argb
// file xine_sxfe_frontend.c line 1527
static void opengl_fill_argb(unsigned int *dst, signed int dst_pitch, struct osd_command_s *cmd)
{
  signed int x0 = (signed int)cmd->dirty_area.x1;
  signed int y0 = (signed int)cmd->dirty_area.y1;
  signed int w = ((signed int)cmd->dirty_area.x2 - (signed int)cmd->dirty_area.x1) + 1;
  signed int h = ((signed int)cmd->dirty_area.y2 - (signed int)cmd->dirty_area.y1) + 1;
  signed int x;
  signed int y;
  unsigned int *src = (unsigned int *)cmd->_anon0.raw_data;
  dst = dst + (signed long int)(((signed int)cmd->y + y0) * dst_pitch + (signed int)cmd->x + x0);
  src = src + (signed long int)(y0 * (signed int)cmd->w + x0);
  y = h;
  for( ; !(y == 0); y = y - 1)
  {
    x = 0;
    for( ; !(x >= w); x = x + 1)
    {
      unsigned int value = src[(signed long int)x];
      dst[(signed long int)x] = value << 8 | value >> 24 & (unsigned int)0xFF;
    }
    src = src + (signed long int)cmd->w;
    dst = dst + (signed long int)dst_pitch;
  }
}

// opengl_frame_output_cb
// file xine_sxfe_frontend.c line 1678
static void opengl_frame_output_cb(void *data, signed int video_width, signed int video_height, double video_pixel_aspect, signed int *dest_x, signed int *dest_y, signed int *dest_width, signed int *dest_height, double *dest_pixel_aspect, signed int *win_x, signed int *win_y)
{
  struct sxfe_s *this = (struct sxfe_s *)data;
  opengl_trigger_drawing_thread(this);
  opengl_wait_drawing_finished(this);
  this->_anon0.x.frame_output_handler(data, video_width, video_height, video_pixel_aspect, dest_x, dest_y, dest_width, dest_height, dest_pixel_aspect, win_x, win_y);
}

// opengl_init
// file xine_sxfe_frontend.c line 1786
static signed int opengl_init(struct sxfe_s *this)
{
  signed int glx_major;
  signed int glx_minor;
  signed int n;
  struct __GLXFBConfigRec **fbconfigs;
  struct __GLXFBConfigRec *fbcroot;
  struct anonymous_8 attr;
  struct anonymous_17 *visinfo;
  const char *gl_version;
  signed int gl_major;
  signed int gl_minor;
  signed int fbc_attr2[10l] = { 4, 8, 1, 9, 1, 10, 1, 5, 1, (signed int)0L };
  unsigned long int glxpixmap;
  const char *glxExtensions;
  signed int return_value_opengl_init_dl_1;
  return_value_opengl_init_dl_1=opengl_init_dl(this);
  _Bool tmp_if_expr_4;
  char *return_value_strstr_3;
  signed int *return_value___errno_location_7;
  char *return_value_strerror_8;
  signed int *return_value___errno_location_10;
  char *return_value_strerror_11;
  if(!(return_value_opengl_init_dl_1 >= 0))
    return -1;

  else
  {
    do
      if(SysLogLevel >= 4)
        x_syslog(7, "[vdr-sxfe]  ", "Get GLX version ...");

    while((_Bool)0);
    signed int return_value_glXQueryVersion_2;
    return_value_glXQueryVersion_2=glXQueryVersion(this->display, &glx_major, &glx_minor);
    if(return_value_glXQueryVersion_2 == 0)
    {
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[vdr-sxfe]  ", "no GLX support");

      while((_Bool)0);
      return -1;
    }

    else
    {
      do
        if(SysLogLevel >= 4)
          x_syslog(7, "[vdr-sxfe]  ", "GLX %d.%d", glx_major, glx_minor);

      while((_Bool)0);
      if(!(glx_major >= 2) && !(glx_minor >= 3))
      {
        const char *exts;
        exts=glXQueryExtensionsString(this->display, this->screen);
        if(exts == ((const char *)NULL))
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_strstr_3=strstr(exts, "GLX_SGIX_fbconfig");
          tmp_if_expr_4 = !(return_value_strstr_3 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          do
            if(SysLogLevel >= 2)
              x_syslog(6, "[vdr-sxfe]  ", "no glx fbconfig support");

          while((_Bool)0);
          return -1;
        }

      }

      do
        if(SysLogLevel >= 4)
          x_syslog(7, "[vdr-sxfe]  ", "Found GLX fbconfig support");

      while((_Bool)0);
      if(!(glx_major >= 2) && !(glx_minor >= 3))
      {
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-sxfe]  ", "no glx 1.3 support");

        while((_Bool)0);
        return -1;
      }

      else
      {
        glxExtensions=glXQueryExtensionsString(this->display, this->screen);
        char *return_value_strstr_5;
        return_value_strstr_5=strstr(glxExtensions, "GLX_EXT_texture_from_pixmap");
        if(return_value_strstr_5 == ((char *)NULL))
        {
          do
            if(SysLogLevel >= 2)
              x_syslog(6, "[vdr-sxfe]  ", "No texture from pixmap extension");

          while((_Bool)0);
          return -1;
        }

        else
        {
          do
            if(SysLogLevel >= 4)
              x_syslog(7, "[vdr-sxfe]  ", "Found texture from pixmap extension");

          while((_Bool)0);
          signed int return_value_opengl_init_dl_6;
          return_value_opengl_init_dl_6=opengl_init_dl(this);
          if(!(return_value_opengl_init_dl_6 >= 0))
            return -1;

          else
          {
            this->screen_width = (&((struct anonymous_34 *)this->display)->screens[(signed long int)this->screen])->width;
            this->screen_height = (&((struct anonymous_34 *)this->display)->screens[(signed long int)this->screen])->height;
            static const signed int fbc_attr[21l] = { 0x8010, 0x00000002 | 0x00000001, 0x20D3, 0x00000002, 0x20D1, 1, 5, 1, 12, 0, 11, 0, 8, 1, 9, 1, 10, 1, 0x8011, 0x00000001, (const signed int)0L };
            fbconfigs=glXChooseFBConfig(this->display, this->screen, fbc_attr, &n);
            if(fbconfigs == ((struct __GLXFBConfigRec **)NULL))
            {
              do
                if(SysLogLevel >= 2)
                  x_syslog(6, "[vdr-sxfe]  ", "No glx frame buffer");

              while((_Bool)0);
              return -1;
            }

            else
            {
              fbcroot = fbconfigs[(signed long int)0];
              XFree((void *)fbconfigs);
              visinfo=glXChooseVisual(this->display, this->screen, fbc_attr2);
              attr.colormap=XCreateColormap(this->display, this->root_window, visinfo->visual, 0);
              attr.override_redirect = 1;
              this->opengl_window=XCreateWindow(this->display, this->root_window, 0, 0, (unsigned int)this->screen_width, (unsigned int)this->screen_height, (unsigned int)0, visinfo->depth, (unsigned int)1, visinfo->visual, (unsigned long int)(1L << 13 | 1L << 9), &attr);
              XSelectInput(this->display, this->opengl_window, 1L << 17 | 1L << 15 | 1L << 0 | 1L << 2 | 1L << 21);
              if(!(this->xshape_hud == 0))
                XShapeCombineRectangles(this->display, this->opengl_window, 2, 0, 0, (struct anonymous_20 *)(void *)0, 0, 0, 0);

              this->opengl_context=glXCreateContext(this->display, visinfo, ((struct __GLXcontextRec *)NULL), 1);
              XFree((void *)visinfo);
              if(this->opengl_context == ((struct __GLXcontextRec *)NULL))
              {
                do
                  if(SysLogLevel >= 1)
                  {
                    x_syslog(3, "[vdr-sxfe]  ", "Can't create glx context");
                    signed int *return_value___errno_location_9;
                    return_value___errno_location_9=__errno_location();
                    if(!(*return_value___errno_location_9 == 0))
                    {
                      return_value___errno_location_7=__errno_location();
                      return_value_strerror_8=strerror(*return_value___errno_location_7);
                      x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 1916, return_value_strerror_8);
                    }

                  }

                while((_Bool)0);
                return -1;
              }

              else
              {
                glXMakeCurrent(this->display, this->opengl_window, this->opengl_context);
                const unsigned char *return_value_glGetString_13;
                return_value_glGetString_13=glGetString((unsigned int)0x1F02);
                gl_version = (const char *)return_value_glGetString_13;
                if(gl_version == ((const char *)NULL))
                {
                  do
                    if(SysLogLevel >= 1)
                    {
                      x_syslog(3, "[vdr-sxfe]  ", "Failed to initialize GL");
                      signed int *return_value___errno_location_12;
                      return_value___errno_location_12=__errno_location();
                      if(!(*return_value___errno_location_12 == 0))
                      {
                        return_value___errno_location_10=__errno_location();
                        return_value_strerror_11=strerror(*return_value___errno_location_10);
                        x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 1922, return_value_strerror_11);
                      }

                    }

                  while((_Bool)0);
                  return -1;
                }

                else
                {
                  sscanf(gl_version, "%d.%d", &gl_major, &gl_minor);
                  if(!(gl_major >= 2) && !(gl_minor >= 2))
                  {
                    do
                      if(SysLogLevel >= 2)
                        x_syslog(6, "[vdr-sxfe]  ", "No GL 1.2 support on your platform");

                    while((_Bool)0);
                    return -1;
                  }

                  else
                    if(!(gl_major >= 2) && !(gl_minor >= 3))
                    {
                      do
                        if(SysLogLevel >= 2)
                          x_syslog(6, "[vdr-sxfe]  ", "No GL 1.3 support on your platform");

                      while((_Bool)0);
                      return -1;
                    }

                    else
                    {
                      glMatrixMode((unsigned int)0x1701);
                      glLoadIdentity();
                      glOrtho((double)0, (double)(this->screen_width - 1), (double)0, (double)(this->screen_height - 1), (double)0, (double)65535);
                      glEnable((unsigned int)0x0DE1);
                      glEnable((unsigned int)0x0BE2);
                      glBlendFunc((unsigned int)0x0302, (unsigned int)0x0303);
                      glClearColor((float)0.0, (float)0.0, (float)0.0, (float)1.0);
                      set_cursor(this->display, this->opengl_window, 0);
                      this->video_frame_pixmap=XCreatePixmap(this->display, this->opengl_window, (unsigned int)this->screen_width, (unsigned int)this->screen_height, (unsigned int)(&((struct anonymous_34 *)this->display)->screens[(signed long int)this->screen])->root_depth);
                      this->video_frame_gc=XCreateGC(this->display, this->video_frame_pixmap, (unsigned long int)0, (struct anonymous_77 *)(void *)0);
                      static const signed int pixmapAttribs[5l] = { 0x20D6, 0x20DC, 0x20D5, 0x20DA, (const signed int)0L };
                      glxpixmap=glXCreatePixmap(this->display, fbcroot, this->video_frame_pixmap, pixmapAttribs);
                      glGenTextures(1, &this->video_frame_texture);
                      glBindTexture((unsigned int)0x0DE1, this->video_frame_texture);
                      bindTexImage(this->display, glxpixmap, 0x20DE, (signed int *)(void *)0);
                      glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2601);
                      glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
                      glGenTextures(1, &this->osd_texture);
                      glBindTexture((unsigned int)0x0DE1, this->osd_texture);
                      glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2601);
                      glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
                      return 0;
                    }
                }
              }
            }
          }
        }
      }
    }
  }
}

// opengl_init_dl
// file xine_sxfe_frontend.c line 1723
static signed int opengl_init_dl(struct sxfe_s *this)
{
  void *dlhand;
  dlhand=dlopen((const char *)(void *)0, 0x00001);
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  if(dlhand == NULL)
  {
    do
      if(SysLogLevel >= 1)
      {
        char *return_value_dlerror_1;
        return_value_dlerror_1=dlerror();
        x_syslog(3, "[vdr-sxfe]  ", "opengl_init(): dlopen failed (%s)", return_value_dlerror_1);
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 0))
        {
          return_value___errno_location_2=__errno_location();
          return_value_strerror_3=strerror(*return_value___errno_location_2);
          x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 1730, return_value_strerror_3);
        }

      }

    while((_Bool)0);
    return -1;
  }

  else
  {
    void * (*glXGetProcAddressARB)(unsigned char *) = (void * (*)(unsigned char *))(void *)0;
    void *return_value_dlsym_5;
    return_value_dlsym_5=dlsym(dlhand, "glXGetProcAddressARB");
    glXGetProcAddressARB = (void * (*)(unsigned char *))return_value_dlsym_5;
    if(!(glXGetProcAddressARB == ((void * (*)(unsigned char *))NULL)))
    {
      void *return_value;
      return_value=glXGetProcAddressARB((unsigned char *)"glXBindTexImageEXT");
      bindTexImage = (void (*)(struct _XDisplay *, unsigned long int, signed int, signed int *))(void *)return_value;
      if(bindTexImage == ((void (*)(struct _XDisplay *, unsigned long int, signed int, signed int *))NULL))
      {
        if(SysLogLevel >= 2)
          x_syslog(6, "[vdr-sxfe]  ", "glXGetProcAddressARB(glXBindTexImageEXT) failed");

      }

    }

    else
    {
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[vdr-sxfe]  ", "glXGetProcAddressARB not found");

      while((_Bool)0);
      dlerror();
      void *return_value_dlsym_6;
      return_value_dlsym_6=dlsym(dlhand, "glXBindTexImageEXT");
      bindTexImage = (void (*)(struct _XDisplay *, unsigned long int, signed int, signed int *))return_value_dlsym_6;
      char *return_value_dlerror_7;
      return_value_dlerror_7=dlerror();
      if(!(return_value_dlerror_7 == ((char *)NULL)))
      {
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-sxfe]  ", "opengl_init(): can not get pointer to glXBindTexImageEXT");

        while((_Bool)0);
        goto error;
      }

    }
    dlclose(dlhand);
    return 0;

  error:
    ;
    dlclose(dlhand);
    return -1;
  }
}

// opengl_osd_command
// file xine_sxfe_frontend.c line 1613
static signed int opengl_osd_command(struct frontend_s *this_gen, struct osd_command_s *cmd)
{
  struct sxfe_s *this = (struct sxfe_s *)this_gen;
  _Bool tmp_if_expr_1;
  if(!(cmd == ((struct osd_command_s *)NULL)) && !(this == ((struct sxfe_s *)NULL)))
  {
    if(!(this->opengl_always == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = this->opengl_hud != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      osd_command(this, cmd);
      if((0x10 & (signed int)cmd->flags) == 0)
        return 1;

      XLockDisplay(this->display);
      switch((signed int)cmd->cmd)
      {
        case 1:
        {
          do
            if(SysLogLevel >= 3)
              x_syslog(7, "[vdr-sxfe]  ", "OpenGL OSD Size");

          while((_Bool)0);
          opengl_osd_show(this);
          break;
        }
        case 11:

        case 12:

        case 2:
        {
          do
            if(SysLogLevel >= 3)
              x_syslog(7, "[vdr-sxfe]  ", "OpenGL OSD Set");

          while((_Bool)0);
          opengl_osd_draw(this, cmd);
          break;
        }
        case 5:
        {
          do
            if(SysLogLevel >= 3)
              x_syslog(7, "[vdr-sxfe]  ", "OpenGL OSD Close");

          while((_Bool)0);
          opengl_osd_hide(this);
        }
      }
      XUnlockDisplay(this->display);
    }

  }

  return 1;
}

// opengl_osd_draw
// file xine_sxfe_frontend.c line 1551
static void opengl_osd_draw(struct sxfe_s *this, struct osd_command_s *cmd)
{
  pthread_mutex_lock(&this->opengl_osd_texture_img_mutex);
  unsigned int *dst = this->opengl_osd_texture_img;
  switch((signed int)cmd->cmd)
  {
    case 11:
    {
      osd_fill_lut8(dst, (signed int)this->osd_width, 0, cmd);
      break;
    }
    case 12:
    {
      opengl_fill_argb(dst, (signed int)this->osd_width, cmd);
      break;
    }
    case 2:
    {
      rle_uncompress_rgba(dst + (signed long int)((signed int)cmd->y * (signed int)this->osd_width) + (signed long int)cmd->x, (unsigned int)cmd->w, (unsigned int)cmd->h, (unsigned int)this->osd_width, cmd->_anon0.data, cmd->num_rle, cmd->_anon1.palette, cmd->colors);
      break;
    }
    default:
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[vdr-sxfe]  ", "opengl_fill_img_memory(): unsupported format");

      while((_Bool)0);
  }
  this->opengl_osd_texture_img_updated = (unsigned char)1;
  pthread_mutex_unlock(&this->opengl_osd_texture_img_mutex);
}

// opengl_osd_hide
// file xine_sxfe_frontend.c line 1583
static void opengl_osd_hide(struct sxfe_s *this)
{
  if(!(this->osd_visible == 0))
  {
    this->osd_visible = (unsigned char)0;
    this->video_win_active = (unsigned char)0;
  }

}

// opengl_osd_show
// file xine_sxfe_frontend.c line 1592
static void opengl_osd_show(struct sxfe_s *this)
{
  if(this->osd_visible == 0)
  {
    pthread_mutex_lock(&this->opengl_osd_texture_img_mutex);
    this->osd_visible = (unsigned char)1;
    this->video_win_active = (unsigned char)0;
    free((void *)this->opengl_osd_texture_img);
    unsigned long int size = sizeof(unsigned int) /*4ul*/  * (unsigned long int)this->osd_width * (unsigned long int)this->osd_height;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(size);
    this->opengl_osd_texture_img = (unsigned int *)return_value_malloc_1;
    memset((void *)this->opengl_osd_texture_img, 0, size);
    this->opengl_osd_texture_img_updated = (unsigned char)1;
    pthread_mutex_unlock(&this->opengl_osd_texture_img_mutex);
    XFlush(this->display);
  }

}

// opengl_start
// file xine_sxfe_frontend.c line 2194
static signed int opengl_start(struct sxfe_s *this)
{
  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[vdr-sxfe]  ", "sxfe_display_open: starting opengl drawing thread");

  while((_Bool)0);
  pthread_mutex_init(&this->opengl_redraw_mutex, (const union anonymous_12 *)(void *)0);
  pthread_cond_init(&this->opengl_redraw_cv, (const union anonymous_12 *)(void *)0);
  this->opengl_redraw_request_nr = (unsigned int)0;
  this->opengl_redraw_served_nr = (unsigned int)0;
  pthread_mutex_init(&this->opengl_redraw_finished_mutex, (const union anonymous_12 *)(void *)0);
  pthread_cond_init(&this->opengl_redraw_finished_cv, (const union anonymous_12 *)(void *)0);
  pthread_mutex_init(&this->opengl_osd_texture_img_mutex, (const union anonymous_12 *)(void *)0);
  union pthread_attr_t attr;
  struct sched_param param;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, 0);
  pthread_attr_getschedparam(&attr, &param);
  param.__sched_priority=sched_get_priority_min(0);
  pthread_attr_setschedparam(&attr, &param);
  pthread_attr_setscope(&attr, 0);
  this->_anon0.x._anon0.vis_x11.frame_output_cb = opengl_frame_output_cb;
  this->_anon0.fe.xine_osd_command = opengl_osd_command;
  this->osd_width = (unsigned short int)720;
  this->osd_height = (unsigned short int)576;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)this->osd_width * (unsigned long int)this->osd_height);
  this->opengl_osd_texture_img = (unsigned int *)return_value_malloc_1;
  memset((void *)this->opengl_osd_texture_img, 0, sizeof(unsigned int) /*4ul*/  * (unsigned long int)this->osd_width * (unsigned long int)this->osd_height);
  this->opengl_osd_texture_img_updated = (unsigned char)0;
  signed int dummy;
  signed int return_value_XShapeQueryExtension_2;
  return_value_XShapeQueryExtension_2=XShapeQueryExtension(this->display, &dummy, &dummy);
  if(!(return_value_XShapeQueryExtension_2 == 0))
    this->opengl_xshape_available = (unsigned char)1;

  else
    this->opengl_xshape_available = (unsigned char)0;
  signed int return_value_pthread_create_6;
  return_value_pthread_create_6=pthread_create(&this->opengl_drawing_thread, &attr, opengl_draw_frame_thread, (void *)this);
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  if(!(return_value_pthread_create_6 == 0))
  {
    pthread_attr_destroy(&attr);
    do
      if(SysLogLevel >= 1)
      {
        x_syslog(3, "[vdr-sxfe]  ", "sxfe_display_open: can not start OpenGL drawing thread");
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        if(!(*return_value___errno_location_5 == 0))
        {
          return_value___errno_location_3=__errno_location();
          return_value_strerror_4=strerror(*return_value___errno_location_3);
          x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 2228, return_value_strerror_4);
        }

      }

    while((_Bool)0);
    this->opengl_hud = (unsigned char)0;
    this->opengl_always = (unsigned char)this->opengl_hud;
    return 0;
  }

  else
  {
    pthread_attr_destroy(&attr);
    return 1;
  }
}

// opengl_trigger_drawing_thread
// file xine_sxfe_frontend.c line 1659
void opengl_trigger_drawing_thread(struct sxfe_s *this)
{
  pthread_mutex_lock(&this->opengl_redraw_mutex);
  this->opengl_redraw_request_nr = this->opengl_redraw_request_nr + 1u;
  pthread_cond_signal(&this->opengl_redraw_cv);
  pthread_mutex_unlock(&this->opengl_redraw_mutex);
}

// opengl_wait_drawing_finished
// file xine_sxfe_frontend.c line 1670
void opengl_wait_drawing_finished(struct sxfe_s *this)
{
  pthread_mutex_lock(&this->opengl_redraw_finished_mutex);
  if(!(this->opengl_redraw_request_nr == this->opengl_redraw_served_nr))
    pthread_cond_wait(&this->opengl_redraw_finished_cv, &this->opengl_redraw_finished_mutex);

  pthread_mutex_unlock(&this->opengl_redraw_finished_mutex);
}

// osd_command
// file xine_sxfe_frontend.c line 662
static signed int osd_command(struct sxfe_s *this, struct osd_command_s *cmd)
{
  signed int tmp_if_expr_1;
  signed int tmp_if_expr_2;
  switch((signed int)cmd->cmd)
  {
    case 1:
    {
      if((0x10 & (signed int)cmd->flags) == 0)
        break;

      do
        if(SysLogLevel >= 4)
          x_syslog(7, "[vdr-sxfe]  ", "OSD Size %dx%d", cmd->w, cmd->h);

      while((_Bool)0);
      if((signed int)cmd->w >= 1)
        tmp_if_expr_1 = (signed int)cmd->w;

      else
        tmp_if_expr_1 = 720;
      this->osd_width = (unsigned short int)tmp_if_expr_1;
      if((signed int)cmd->h >= 1)
        tmp_if_expr_2 = (signed int)cmd->h;

      else
        tmp_if_expr_2 = 576;
      this->osd_height = (unsigned short int)tmp_if_expr_2;
      break;
    }
    case 9:
    {
      do
        if(SysLogLevel >= 4)
          x_syslog(7, "[vdr-sxfe]  ", "OSD VideoWindow %dx%d@%d,%d", cmd->w, cmd->h, cmd->x, cmd->y);

      while((_Bool)0);
      osd_set_video_window(this, cmd);
    }
  }
  return 1;
}

// osd_data_clear
// file xine/vo_osdscaler.c line 85
static void osd_data_clear(struct osd_data_s *data)
{
  if(!(data == ((struct osd_data_s *)NULL)))
  {
    if(!(data->next == ((struct osd_data_s *)NULL)))
      osd_data_clear(data->next);

    osd_data_dispose(data);
  }

}

// osd_data_dispose
// file xine/vo_osdscaler.c line 73
static void osd_data_dispose(struct osd_data_s *data)
{
  if(!(data->scaled == 0))
    free((void *)data->ovl.rle);

  free((void *)data);
}

// osd_data_init
// file xine/vo_osdscaler.c line 128
static struct osd_data_s * osd_data_init(struct vo_overlay_s *ovl, struct osd_data_s *next, unsigned int factor_x, unsigned int factor_y)
{
  struct osd_data_s *data;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct osd_data_s) /*2688ul*/ );
  data = (struct osd_data_s *)return_value_calloc_1;
  data->source = ovl;
  data->next = next;
  memcpy_link3((void *)&data->ovl, (const void *)ovl, sizeof(struct vo_overlay_s) /*2656ul*/ );
  signed int num_rle = data->ovl.num_rle;
  signed int x2 = ovl->x + ovl->width + 1;
  signed int y2 = ovl->y + ovl->height + 1;
  x2 = (signed int)((unsigned int)(x2 + 1) * factor_x >> 16);
  y2 = (signed int)((unsigned int)(y2 + 1) * factor_y >> 16);
  data->ovl.x = (signed int)((unsigned int)ovl->x * factor_x >> 16);
  data->ovl.y = (signed int)((unsigned int)ovl->y * factor_y >> 16);
  data->ovl.width = (x2 - data->ovl.x) - 1;
  data->ovl.height = (y2 - data->ovl.y) - 1;
  if(ovl->video_window_x >= 0)
  {
    if(ovl->video_window_y >= 0)
    {
      if(ovl->video_window_width >= 1)
      {
        if(ovl->video_window_height >= 1)
        {
          data->ovl.video_window_x = (signed int)((unsigned int)ovl->video_window_x * factor_x >> 16);
          data->ovl.video_window_y = (signed int)((unsigned int)ovl->video_window_y * factor_y >> 16);
          data->ovl.video_window_width = (signed int)((unsigned int)ovl->video_window_width * factor_x >> 16);
          data->ovl.video_window_height = (signed int)((unsigned int)ovl->video_window_height * factor_y >> 16);
        }

      }

    }

  }

  struct osd_rle_elem_s *return_value_rle_scale_nearest_2;
  return_value_rle_scale_nearest_2=rle_scale_nearest((struct osd_rle_elem_s *)ovl->rle, &num_rle, (unsigned int)ovl->width, (unsigned int)ovl->height, (unsigned int)data->ovl.width, (unsigned int)data->ovl.height);
  data->ovl.rle = (struct rle_elem_s *)return_value_rle_scale_nearest_2;
  data->ovl.num_rle = num_rle;
  data->scaled = (unsigned char)1;
  return data;
}

// osd_data_remove
// file xine/vo_osdscaler.c line 99
static void osd_data_remove(struct osd_data_s **list, struct osd_data_s *data)
{
  _Bool tmp_if_expr_1;
  if(list == ((struct osd_data_s **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*list != ((struct osd_data_s *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    if(data == *list)
    {
      *list = data->next;
      free((void *)data);
    }

    else
    {
      struct osd_data_s *it = *list;
      for( ; !(it == ((struct osd_data_s *)NULL)); it = it->next)
        if(data == it->next)
        {
          it->next = data->next;
          free((void *)data);
          goto __CPROVER_DUMP_L7;
        }

    }
  }


__CPROVER_DUMP_L7:
  ;
}

// osd_fill_lut8
// file xine_sxfe_frontend.c line 602
static void osd_fill_lut8(unsigned int *dst, signed int dst_pitch, signed int argb, struct osd_command_s *cmd)
{
  unsigned char *data = cmd->_anon0.raw_data;
  unsigned int x;
  unsigned int y;
  unsigned int lut[256l];
  if(!(argb == 0))
    rle_palette_to_argb(lut, cmd->_anon1.palette, cmd->colors);

  else
    rle_palette_to_rgba(lut, cmd->_anon1.palette, cmd->colors);
  dst = dst + (signed long int)((signed int)cmd->y * dst_pitch + (signed int)cmd->x);
  y = (unsigned int)cmd->h;
  for( ; !(y == 0u); y = y - 1u)
  {
    x = (unsigned int)0;
    for( ; !(x >= (unsigned int)cmd->w); x = x + 1u)
    {
      dst[(signed long int)x] = lut[(signed long int)*data];
      data = data + 1l;
    }
    dst = dst + (signed long int)dst_pitch;
  }
}

// osd_level
// file xine/vo_osdreorder.c line 35
static signed int osd_level(struct vo_overlay_s *overlay)
{
  if(!(overlay->hili_rgb_clut == -9999))
    return 9999;

  else
  {
    struct anonymous_81 *data = (struct anonymous_81 *)overlay->hili_color;
    return (signed int)data->layer;
  }
}

// osd_reorder_init
// file xine/vo_osdreorder.c line 92
struct vo_driver_s * osd_reorder_init(void)
{
  struct anonymous_82 *this;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_82) /*528ul*/ );
  this = (struct anonymous_82 *)return_value_calloc_1;
  this->h.vo.overlay_blend = osdreorder_overlay_blend;
  this->h.vo.overlay_end = osdreorder_overlay_end;
  return &this->h.vo;
}

// osd_set_video_window
// file xine_sxfe_frontend.c line 626
static void osd_set_video_window(struct sxfe_s *this, struct osd_command_s *cmd)
{
  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[vdr-sxfe]  ", "unscaled video window: %d,%d %dx%d", cmd->x, cmd->y, cmd->w, cmd->h);

  while((_Bool)0);
  double scale_x = (double)this->_anon0.x.width / (double)this->osd_width;
  double scale_y = (double)this->_anon0.x.height / (double)this->osd_height;
  signed int x = (signed int)cmd->x;
  signed int y = (signed int)cmd->y;
  signed int w = (signed int)cmd->w;
  signed int h = (signed int)cmd->h;
  double return_value_ceil_1;
  return_value_ceil_1=ceil((double)(x > 0 ? x - 1 : 0) * scale_x);
  x = (signed int)return_value_ceil_1;
  double return_value_ceil_2;
  return_value_ceil_2=ceil((double)(y > 0 ? y - 1 : 0) * scale_y);
  y = (signed int)return_value_ceil_2;
  double return_value_floor_3;
  return_value_floor_3=floor((double)(w + 2) * scale_x);
  w = (signed int)return_value_floor_3;
  double return_value_floor_4;
  return_value_floor_4=floor((double)(h + 2) * scale_y);
  h = (signed int)return_value_floor_4;
  pthread_mutex_lock(&this->video_win_mutex);
  _Bool tmp_if_expr_5;
  if(!(x == (signed int)this->video_win_x))
    tmp_if_expr_5 = (_Bool)1;

  else
    tmp_if_expr_5 = y != (signed int)this->video_win_y ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_5)
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = w != (signed int)this->video_win_w ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_7;
  if(tmp_if_expr_6)
    tmp_if_expr_7 = (_Bool)1;

  else
    tmp_if_expr_7 = h != (signed int)this->video_win_h ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_7)
    this->video_win_changed = (unsigned char)1;

  this->video_win_x = (unsigned short int)x;
  this->video_win_y = (unsigned short int)y;
  this->video_win_w = (unsigned short int)w;
  this->video_win_h = (unsigned short int)h;
  this->video_win_active = (unsigned char)1;
  pthread_mutex_unlock(&this->video_win_mutex);
  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[vdr-sxfe]  ", "scaled video window: %d,%d %dx%d", this->video_win_x, this->video_win_y, this->video_win_w, this->video_win_h);

  while((_Bool)0);
}

// osdreorder_overlay_blend
// file xine/vo_osdreorder.c line 53
static void osdreorder_overlay_blend(struct vo_driver_s *self, struct vo_frame_s *frame, struct vo_overlay_s *overlay)
{
  struct anonymous_82 *this = (struct anonymous_82 *)self;
  signed int my_level;
  my_level=osd_level(overlay);
  signed int i = 0;
  _Bool tmp_if_expr_2;
  signed int return_value_osd_level_1;
  do
  {
    if(!(this->overlay[(signed long int)i] == ((struct vo_overlay_s *)NULL)))
    {
      return_value_osd_level_1=osd_level(this->overlay[(signed long int)i]);
      tmp_if_expr_2 = return_value_osd_level_1 >= my_level ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  if(!(this->overlay[(signed long int)i] == ((struct vo_overlay_s *)NULL)))
    memmove((void *)&this->overlay[(signed long int)(i + 1)], (const void *)&this->overlay[(signed long int)i], (unsigned long int)(49 - i) * sizeof(struct vo_overlay_s *) /*8ul*/ );

  this->overlay[(signed long int)i] = overlay;
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// osdreorder_overlay_end
// file xine/vo_osdreorder.c line 74
static void osdreorder_overlay_end(struct vo_driver_s *self, struct vo_frame_s *vo_img)
{
  struct anonymous_82 *this = (struct anonymous_82 *)self;
  signed int i = 0;
  if(!(this->overlay[(signed long int)i] == ((struct vo_overlay_s *)NULL)))
  {
    this->h.orig_driver->overlay_blend(this->h.orig_driver, vo_img, this->overlay[(signed long int)i]);
    this->overlay[(signed long int)i] = (struct vo_overlay_s *)(void *)0;
    i = i + 1;
  }

  if(!(this->h.orig_driver->overlay_end == ((void (*)(struct vo_driver_s *, struct vo_frame_s *))NULL)))
    this->h.orig_driver->overlay_end(this->h.orig_driver, vo_img);

}

// osdscaler_dispose
// file xine/vo_osdscaler.c line 457
static void osdscaler_dispose(struct vo_driver_s *self)
{
  struct anonymous_80 *this = (struct anonymous_80 *)self;
  osd_data_clear(this->active_osds);
  vo_def_dispose(self);
}

// osdscaler_get_capabilities
// file xine/vo_osdscaler.c line 411
static unsigned int osdscaler_get_capabilities(struct vo_driver_s *self)
{
  unsigned int return_value_vo_def_get_capabilities_1;
  return_value_vo_def_get_capabilities_1=vo_def_get_capabilities(self);
  return return_value_vo_def_get_capabilities_1 | (unsigned int)0x01000000;
}

// osdscaler_get_property
// file xine/vo_osdscaler.c line 420
static signed int osdscaler_get_property(struct vo_driver_s *self, signed int prop)
{
  struct anonymous_80 *this = (struct anonymous_80 *)self;
  if(prop == 0x1001)
    return (signed int)this->enable;

  signed int return_value_vo_def_get_property_1;
  return_value_vo_def_get_property_1=vo_def_get_property(self, prop);
  return return_value_vo_def_get_property_1;
}

// osdscaler_init
// file xine/vo_osdscaler.c line 470
struct vo_driver_s * osdscaler_init(void)
{
  struct anonymous_80 *this;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_80) /*160ul*/ );
  this = (struct anonymous_80 *)return_value_calloc_1;
  this->h.vo.overlay_begin = osdscaler_overlay_begin;
  this->h.vo.overlay_blend = osdscaler_overlay_blend;
  this->h.vo.overlay_end = osdscaler_overlay_end;
  this->h.vo.get_capabilities = osdscaler_get_capabilities;
  this->h.vo.get_property = osdscaler_get_property;
  this->h.vo.set_property = osdscaler_set_property;
  this->h.vo.dispose = osdscaler_dispose;
  this->enable = (unsigned char)0;
  return &this->h.vo;
}

// osdscaler_overlay_begin
// file xine/vo_osdscaler.c line 208
static void osdscaler_overlay_begin(struct vo_driver_s *self, struct vo_frame_s *frame, signed int changed)
{
  struct anonymous_80 *this = (struct anonymous_80 *)self;
  if(this->h.orig_driver == ((struct vo_driver_s *)NULL))
  {
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[osdscaler] ", "osdscaler_overlay_begin: assertion this->h.orig_driver failed !");

    while((_Bool)0);
    abort();
  }

  if(!(changed == 0))
  {
    osd_data_clear(this->active_osds);
    this->active_osds = (struct osd_data_s *)(void *)0;
    unsigned long int caps;
    unsigned int return_value_vo_def_get_capabilities_1;
    return_value_vo_def_get_capabilities_1=vo_def_get_capabilities(self);
    caps = (unsigned long int)return_value_vo_def_get_capabilities_1;
    this->unscaled_supported = (unsigned char)!(!((caps & (unsigned long int)0x00000010) != 0ul));
    this->custom_extent_supported = (unsigned char)!(!((caps & (unsigned long int)0x01000000) != 0ul));
    this->argb_supported = (unsigned char)!(!((caps & (unsigned long int)0x02000000) != 0ul));
    this->video_window_supported = (unsigned char)!(!((caps & (unsigned long int)0x04000000) != 0ul));
  }

  if(!(this->h.orig_driver->overlay_begin == ((void (*)(struct vo_driver_s *, struct vo_frame_s *, signed int))NULL)))
    this->h.orig_driver->overlay_begin(this->h.orig_driver, frame, changed);

}

// osdscaler_overlay_blend
// file xine/vo_osdscaler.c line 380
static void osdscaler_overlay_blend(struct vo_driver_s *self, struct vo_frame_s *frame, struct vo_overlay_s *overlay)
{
  struct anonymous_80 *this = (struct anonymous_80 *)self;
  overlay=scale_overlay(this, frame, overlay);
  if(!(this->h.orig_driver->overlay_blend == ((void (*)(struct vo_driver_s *, struct vo_frame_s *, struct vo_overlay_s *))NULL)))
    this->h.orig_driver->overlay_blend(this->h.orig_driver, frame, overlay);

}

// osdscaler_overlay_end
// file xine/vo_osdscaler.c line 394
static void osdscaler_overlay_end(struct vo_driver_s *self, struct vo_frame_s *vo_img)
{
  struct anonymous_80 *this = (struct anonymous_80 *)self;
  if(!(this->h.orig_driver->overlay_end == ((void (*)(struct vo_driver_s *, struct vo_frame_s *))NULL)))
    this->h.orig_driver->overlay_end(this->h.orig_driver, vo_img);

}

// osdscaler_set_property
// file xine/vo_osdscaler.c line 435
static signed int osdscaler_set_property(struct vo_driver_s *self, signed int prop, signed int val)
{
  struct anonymous_80 *this = (struct anonymous_80 *)self;
  if(prop == 0x1001)
  {
    if(!((signed int)this->enable == val))
      this->enable = (unsigned char)(val != 0 ? 1 : 0);

    return (signed int)this->enable;
  }

  signed int return_value_vo_def_set_property_1;
  return_value_vo_def_set_property_1=vo_def_set_property(self, prop, val);
  return return_value_vo_def_set_property_1;
}

// poll
// file /usr/include/x86_64-linux-gnu/bits/poll2.h line 36
static inline signed int poll(struct pollfd *__fds, unsigned long int __nfds, signed int __timeout)
{
  signed int return_value___poll_chk_1;
  signed int return_value___poll_chk_warn_2;
  signed int return_value___poll_alias_3;
  return_value___poll_alias_3=__poll_alias(__fds, __nfds, __timeout);
  return return_value___poll_alias_3;
}

// poll_link1
// file /usr/include/x86_64-linux-gnu/bits/poll2.h line 36
static inline signed int poll_link1(struct pollfd *__fds_link1, unsigned long int __nfds_link1, signed int __timeout_link1)
{
  signed int return_value___poll_chk_1_link1;
  signed int return_value___poll_chk_warn_2_link1;
  signed int return_value___poll_alias_3_link1;
  return_value___poll_alias_3_link1=__poll_alias(__fds_link1, __nfds_link1, __timeout_link1);
  return return_value___poll_alias_3_link1;
}

// poll_link2
// file /usr/include/x86_64-linux-gnu/bits/poll2.h line 36
static inline signed int poll_link2(struct pollfd *__fds_link2, unsigned long int __nfds_link2, signed int __timeout_link2)
{
  signed int return_value___poll_chk_1_link2;
  signed int return_value___poll_chk_warn_2_link2;
  signed int return_value___poll_alias_3_link2;
  return_value___poll_alias_3_link2=__poll_alias(__fds_link2, __nfds_link2, __timeout_link2);
  return return_value___poll_alias_3_link2;
}

// pplugin_parse_and_load
// file xine/post.c line 229
static struct anonymous_73 ** pplugin_parse_and_load(struct post_plugins_s_0 *fe, signed int plugin_type, const char *pchain, signed int *post_elements_num)
{
  struct anonymous_73 **post_elements = (struct anonymous_73 **)(void *)0;
  *post_elements_num = 0;
  unsigned long int return_value_strlen_15;
  char *tmp_statement_expression_2;
  unsigned long int return_value_strlen_14;
  char *tmp_post_5;
  unsigned long int return_value_strlen_7;
  void *return_value_calloc_8;
  void *return_value_realloc_9;
  char *tmp_if_expr_13;
  char *return_value___strdup_12;
  if(!(pchain == ((const char *)NULL)))
  {
    return_value_strlen_15=strlen(pchain);
    if(!(return_value_strlen_15 == 0ul))
    {
      char *post_chain;
      char *freeme;
      char *p;
      char *return_value___strdup_1;
      return_value___strdup_1=__strdup(pchain);
      post_chain = return_value___strdup_1;
      freeme = post_chain;
      do
      {
        char __r0;
        char __r1;
        char __r2;
        char *return_value___strsep_g_3;
        return_value___strsep_g_3=__strsep_g(&post_chain, ";");
        tmp_statement_expression_2 = return_value___strsep_g_3;
        p = tmp_statement_expression_2;
        if(p == ((char *)NULL))
          break;

        if(!(p == ((char *)NULL)))
        {
          return_value_strlen_14=strlen(p);
          if(!(return_value_strlen_14 == 0ul))
          {
            char *plugin;
            char *args = (char *)(void *)0;
            struct xine_post_s_0 *post;
            for( ; (signed int)*p == 32; p = p + 1l)
              ;
            char *return_value___strdup_4;
            return_value___strdup_4=__strdup(p);
            plugin = return_value___strdup_4;
            char *return_value___builtin_strchr_6;
            return_value___builtin_strchr_6=__builtin_strchr(plugin, 58);
            p = return_value___builtin_strchr_6;
            if(!(p == ((char *)NULL)))
            {
              tmp_post_5 = p;
              p = p + 1l;
              *tmp_post_5 = (char)0;
            }

            if(!(p == ((char *)NULL)))
            {
              return_value_strlen_7=strlen(p);
              if(return_value_strlen_7 >= 2ul)
                args = p;

            }

            if(plugin_type == 0x010002)
              post=xine_post_init(fe->xine, plugin, 2, &fe->audio_port, &fe->video_port);

            else
              post=xine_post_init(fe->xine, plugin, 0, &fe->audio_port, &fe->video_port);
            if(!(post == ((struct xine_post_s_0 *)NULL)) && !(plugin_type == 0))
            {
              if(!(post->type == plugin_type))
              {
                xine_post_dispose(fe->xine, post);
                post = (struct xine_post_s_0 *)(void *)0;
              }

            }

            if(!(post == ((struct xine_post_s_0 *)NULL)))
            {
              if(*post_elements_num == 0)
              {
                return_value_calloc_8=calloc((unsigned long int)2, sizeof(struct anonymous_73 *) /*8ul*/ );
                post_elements = (struct anonymous_73 **)return_value_calloc_8;
              }

              else
              {
                return_value_realloc_9=realloc((void *)post_elements, sizeof(struct anonymous_73 *) /*8ul*/  * (unsigned long int)(*post_elements_num + 2));
                post_elements = (struct anonymous_73 **)return_value_realloc_9;
              }
              void *return_value_calloc_10;
              return_value_calloc_10=calloc((unsigned long int)1, sizeof(struct anonymous_73) /*32ul*/ );
              post_elements[(signed long int)*post_elements_num] = (struct anonymous_73 *)return_value_calloc_10;
              post_elements[(signed long int)*post_elements_num]->post = post;
              char *return_value___strdup_11;
              return_value___strdup_11=__strdup(plugin);
              post_elements[(signed long int)*post_elements_num]->name = return_value___strdup_11;
              if(!(args == ((char *)NULL)))
              {
                return_value___strdup_12=__strdup(args);
                tmp_if_expr_13 = return_value___strdup_12;
              }

              else
                tmp_if_expr_13 = (char *)(void *)0;
              post_elements[(signed long int)*post_elements_num]->args = tmp_if_expr_13;
              post_elements[(signed long int)*post_elements_num]->enable = 0;
              *post_elements_num = *post_elements_num + 1;
              post_elements[(signed long int)*post_elements_num] = (struct anonymous_73 *)(void *)0;
              __pplugin_update_parameters(post, args);
            }

            free((void *)plugin);
          }

        }

      }
      while((_Bool)1);
      free((void *)freeme);
    }

  }

  return post_elements;
}

// pplugin_parse_and_store_post
// file xine/post.c line 308
void pplugin_parse_and_store_post(struct post_plugins_s_0 *fe, signed int plugin_type, const char *post_chain)
{
  struct anonymous_73 ***_post_elements;
  signed int *_post_elements_num;
  struct anonymous_73 **posts = (struct anonymous_73 **)(void *)0;
  signed int num;
  switch(plugin_type)
  {
    case 0x010000:
    {
      _post_elements = &fe->post_video_elements;
      _post_elements_num = &fe->post_video_elements_num;
      break;
    }
    case 0x010002:
    {
      _post_elements = &fe->post_pip_elements;
      _post_elements_num = &fe->post_pip_elements_num;
      break;
    }
    case 0x020001:
    {
      _post_elements = &fe->post_vis_elements;
      _post_elements_num = &fe->post_vis_elements_num;
      break;
    }
    default:
    {
      _post_elements = &fe->post_audio_elements;
      _post_elements_num = &fe->post_audio_elements_num;
    }
  }
  posts=pplugin_parse_and_load(fe, plugin_type, post_chain, &num);
  if(!(posts == ((struct anonymous_73 **)NULL)))
  {
    if(!(*_post_elements_num == 0))
    {
      signed int i;
      signed int ptot = *_post_elements_num + num;
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)*_post_elements, sizeof(struct anonymous_73 *) /*8ul*/  * (unsigned long int)(ptot + 1));
      *_post_elements = (struct anonymous_73 **)return_value_realloc_1;
      i = *_post_elements_num;
      for( ; !(i >= ptot); i = i + 1)
        (*_post_elements)[(signed long int)i] = posts[(signed long int)(i - *_post_elements_num)];
      (*_post_elements)[(signed long int)i] = (struct anonymous_73 *)(void *)0;
      *_post_elements_num = *_post_elements_num + num;
    }

    else
    {
      *_post_elements = posts;
      *_post_elements_num = num;
    }
    if(SysLogLevel >= 3)
    {
      signed int pplugin_parse_and_store_post__1__2__3__ptot = *_post_elements_num;
      signed int pplugin_parse_and_store_post__1__2__3__i;
      char s[4096l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      pplugin_parse_and_store_post__1__2__3__i = 0;
      for( ; !(pplugin_parse_and_store_post__1__2__3__i >= pplugin_parse_and_store_post__1__2__3__ptot); pplugin_parse_and_store_post__1__2__3__i = pplugin_parse_and_store_post__1__2__3__i + 1)
        if(!((*_post_elements)[(signed long int)pplugin_parse_and_store_post__1__2__3__i] == ((struct anonymous_73 *)NULL)))
        {
          if(!((*_post_elements)[(signed long int)pplugin_parse_and_store_post__1__2__3__i]->post == ((struct xine_post_s_0 *)NULL)))
          {
            if(!((*_post_elements)[(signed long int)pplugin_parse_and_store_post__1__2__3__i]->enable == 0))
              strcat_link1(s, "*");

            if(!((*_post_elements)[(signed long int)pplugin_parse_and_store_post__1__2__3__i]->name == ((char *)NULL)))
              strcat_link1(s, (*_post_elements)[(signed long int)pplugin_parse_and_store_post__1__2__3__i]->name);

            else
              strcat_link1(s, "<no name!>");
            strcat_link1(s, " ");
          }

        }

      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[xine-post] ", "    loaded plugins (type %d.%d): %s", plugin_type >> 16, plugin_type & 0xffff, (const void *)s);

      while((_Bool)0);
    }

  }

}

// printf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 102
static inline signed int printf(const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack_1;
  return_value___builtin_va_arg_pack_1=__builtin_va_arg_pack();
  signed int return_value___printf_chk_2;
  return_value___printf_chk_2=__printf_chk(2 - 1, __fmt, return_value___builtin_va_arg_pack_1);
  return return_value___printf_chk_2;
}

// printf_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 102
static inline signed int printf_link1(const char * restrict __fmt_link1, ...)
{
  void *return_value___builtin_va_arg_pack_1_link1;
  return_value___builtin_va_arg_pack_1_link1=__builtin_va_arg_pack();
  signed int return_value___printf_chk_2_link1;
  return_value___printf_chk_2_link1=__printf_chk(2 - 1, __fmt_link1, return_value___builtin_va_arg_pack_1_link1);
  return return_value___printf_chk_2_link1;
}

// read
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 34
static inline signed long int read(signed int __fd, void *__buf, unsigned long int __nbytes)
{
  signed long int return_value___read_chk_1;
  signed long int return_value___read_chk_warn_2;
  signed long int return_value___read_alias_3;
  return_value___read_alias_3=__read_alias(__fd, __buf, __nbytes);
  return return_value___read_alias_3;
}

// read_link1
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 34
static inline signed long int read_link1(signed int __fd_link1, void *__buf_link1, unsigned long int __nbytes_link1)
{
  signed long int return_value___read_chk_1_link1;
  signed long int return_value___read_chk_warn_2_link1;
  signed long int return_value___read_alias_3_link1;
  return_value___read_alias_3_link1=__read_alias(__fd_link1, __buf_link1, __nbytes_link1);
  return return_value___read_alias_3_link1;
}

// read_key
// file xine_frontend_kbd.c line 53
static signed int read_key(void)
{
  unsigned char ch;
  signed int err;
  struct pollfd pfd;
  pfd.fd = 0;
  pfd.events = (signed short int)0x001;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  pthread_testcancel();
  err=poll_link1(&pfd, (unsigned long int)1, 50);
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  signed int *return_value___errno_location_6;
  char *return_value_strerror_7;
  signed int *return_value___errno_location_12;
  signed int *return_value___errno_location_9;
  char *return_value_strerror_10;
  if(err == 1)
  {
    pthread_testcancel();
    signed long int return_value_read_2;
    return_value_read_2=read_link1(0, (void *)&ch, (unsigned long int)1);
    err = (signed int)return_value_read_2;
    if(err == 1)
      return (signed int)ch;

    if(!(err >= 0))
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[console]   ", "read_key: read(stdin) failed");
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          if(!(*return_value___errno_location_5 == 0))
          {
            return_value___errno_location_3=__errno_location();
            return_value_strerror_4=strerror(*return_value___errno_location_3);
            x_syslog(3, "[console]   ", "   (ERROR (%s,%d): %s)", (const void *)"xine_frontend_kbd.c", 71, return_value_strerror_4);
          }

        }

      while((_Bool)0);

    else
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[console]   ", "read_key: read(stdin) failed: no stdin");
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          if(!(*return_value___errno_location_8 == 0))
          {
            return_value___errno_location_6=__errno_location();
            return_value_strerror_7=strerror(*return_value___errno_location_6);
            x_syslog(3, "[console]   ", "   (ERROR (%s,%d): %s)", (const void *)"xine_frontend_kbd.c", 73, return_value_strerror_7);
          }

        }

      while((_Bool)0);
    return -2;
  }

  else
    if(!(err >= 0))
    {
      return_value___errno_location_12=__errno_location();
      if(!(*return_value___errno_location_12 == 4))
      {
        do
          if(SysLogLevel >= 1)
          {
            x_syslog(3, "[console]   ", "read_key: poll(stdin) failed");
            signed int *return_value___errno_location_11;
            return_value___errno_location_11=__errno_location();
            if(!(*return_value___errno_location_11 == 0))
            {
              return_value___errno_location_9=__errno_location();
              return_value_strerror_10=strerror(*return_value___errno_location_9);
              x_syslog(3, "[console]   ", "   (ERROR (%s,%d): %s)", (const void *)"xine_frontend_kbd.c", 77, return_value_strerror_10);
            }

          }

        while((_Bool)0);
        return -2;
      }

    }

  pthread_testcancel();
  return -1;
}

// read_key_seq
// file xine_frontend_kbd.c line 99
static unsigned long int read_key_seq(void)
{
  unsigned long int k = (unsigned long int)0;
  signed int key1;
  key1=read_key();
  if(key1 >= 0)
  {
    k = (unsigned long int)key1;
    if(key1 == 0x1B)
    {
      key1=read_key();
      if(key1 >= 0)
      {
        k = k << 8;
        k = k | (unsigned long int)(key1 & 0xFF);
        switch(key1)
        {
          case 0x4F:
          {
            key1=read_key();
            if(key1 >= 0)
            {
              k = k << 8;
              k = k | (unsigned long int)(key1 & 0xFF);
            }

            break;
          }
          case 0x5B:
          {
            key1=read_key();
            if(key1 >= 0)
            {
              k = k << 8;
              k = k | (unsigned long int)(key1 & 0xFF);
              if(key1 == 0x5B)
                do
                {
                  key1=read_key();
                  if(!(key1 >= 0))
                    break;

                  k = k << 8;
                  k = k | (unsigned long int)(key1 & 0xFF);
                }
                while(!(key1 == 0x7E));

            }

          }
          default:
            ;
        }
      }

    }

  }

  if(key1 == -2)
    return (unsigned long int)0xffffffff;

  else
    return k;
}

// recvfrom
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 64
static inline signed long int recvfrom(signed int __fd, void * restrict __buf, unsigned long int __n, signed int __flags, union anonymous_85 __addr, unsigned int * restrict __addr_len)
{
  signed long int return_value___recvfrom_chk_1;
  signed long int return_value___recvfrom_chk_warn_2;
  signed long int return_value___recvfrom_alias_3;
  return_value___recvfrom_alias_3=__recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
  return return_value___recvfrom_alias_3;
}

// rle_compress
// file tools/rle.c line 29
unsigned int rle_compress(struct osd_rle_elem_s **rle_data, const unsigned char *data, unsigned int w, unsigned int h)
{
  struct osd_rle_elem_s rle;
  struct osd_rle_elem_s *rle_p = ((struct osd_rle_elem_s *)NULL);
  struct osd_rle_elem_s *rle_base;
  unsigned int x;
  unsigned int y;
  unsigned int num_rle = (unsigned int)0;
  unsigned int rle_size = (unsigned int)8128;
  const unsigned char *c;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)((unsigned int)4 * rle_size));
  rle_p = (struct osd_rle_elem_s *)return_value_malloc_1;
  rle_base = rle_p;
  y = (unsigned int)0;
  struct osd_rle_elem_s *tmp_post_3;
  struct osd_rle_elem_s *tmp_post_4;
  for( ; !(y >= h); y = y + 1u)
  {
    rle.len = (unsigned short int)0;
    rle.color = (unsigned short int)0;
    c = data + (signed long int)(y * w);
    x = (unsigned int)0;
    for( ; !(x >= w); c = c + 1l)
    {
      if(!((signed int)rle.color == (signed int)*c))
      {
        if(!(rle.len == 0))
        {
          if(!(rle_size >= num_rle + h + 1u + -y))
          {
            rle_size = rle_size * (unsigned int)2;
            void *return_value_realloc_2;
            return_value_realloc_2=realloc((void *)rle_base, (unsigned long int)((unsigned int)4 * rle_size));
            rle_base = (struct osd_rle_elem_s *)return_value_realloc_2;
            rle_p = rle_base + (signed long int)num_rle;
          }

          tmp_post_3 = rle_p;
          rle_p = rle_p + 1l;
          *tmp_post_3 = rle;
          num_rle = num_rle + 1u;
        }

        rle.color = (unsigned short int)*c;
        rle.len = (unsigned short int)1;
      }

      else
        rle.len = rle.len + 1;
      x = x + 1u;
    }
    tmp_post_4 = rle_p;
    rle_p = rle_p + 1l;
    *tmp_post_4 = rle;
    num_rle = num_rle + 1u;
  }
  *rle_data = rle_base;
  return num_rle;
}

// rle_compress_hdmv
// file tools/rle.c line 248
unsigned long int rle_compress_hdmv(unsigned char **rle_data, const unsigned char *data, unsigned int w, unsigned int h, signed int *num_rle)
{
  unsigned int y;
  unsigned long int rle_size = (unsigned long int)0;
  unsigned char *rle = (unsigned char *)(void *)0;
  *rle_data = (unsigned char *)(void *)0;
  *num_rle = 0;
  y = (unsigned int)0;
  for( ; !(y >= h); y = y + 1u)
  {
    if(!((signed long int)rle_size + -((signed long int)(unsigned long int)(rle - *rle_data)) >= (signed long int)(4u * w)))
    {
      unsigned long int used = (unsigned long int)(rle - *rle_data);
      rle_size = rle_size < (unsigned long int)1 ? (unsigned long int)((w * h) / (unsigned int)16) : rle_size * (unsigned long int)2;
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)*rle_data, rle_size);
      *rle_data = (unsigned char *)return_value_realloc_1;
      rle = *rle_data + (signed long int)used;
    }

    unsigned int color = (unsigned int)*data;
    unsigned int len = (unsigned int)1;
    unsigned int x = (unsigned int)1;
    x = (unsigned int)1;
    for( ; !(x >= w); x = x + 1u)
      if((unsigned int)data[(signed long int)x] == color)
        len = len + 1u;

      else
      {
        rle=write_rle_hdmv(rle, color, len);
        *num_rle = *num_rle + 1;
        color = (unsigned int)data[(signed long int)x];
        len = (unsigned int)1;
      }
    if(!(len == 0u))
    {
      rle=write_rle_hdmv(rle, color, len);
      *num_rle = *num_rle + 1;
    }

    rle=write_rle_hdmv(rle, (unsigned int)0, (unsigned int)0);
    *num_rle = *num_rle + 1;
    data = data + (signed long int)w;
  }
  return (unsigned long int)(rle - *rle_data);
}

// rle_compress_net
// file tools/rle.c line 67
unsigned int rle_compress_net(unsigned char **rle_data, unsigned int *elems, const unsigned char *data, unsigned int w, unsigned int h)
{
  *elems=rle_compress((struct osd_rle_elem_s **)rle_data, data, w, h);
  unsigned int return_value_rle_recompress_net_1;
  return_value_rle_recompress_net_1=rle_recompress_net(*rle_data, *((struct osd_rle_elem_s **)rle_data), *elems);
  return return_value_rle_recompress_net_1;
}

// rle_palette_to_argb
// file tools/rle.h line 32
void rle_palette_to_argb(unsigned int *argb, struct osd_clut_s *palette, unsigned int entries)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= entries); i = i + 1u)
    argb[(signed long int)i] = (unsigned int)((signed int)(palette + (signed long int)i)->alpha << 24 | (signed int)(palette + (signed long int)i)->_anon2.r << 16 | (signed int)(palette + (signed long int)i)->_anon0.g << 8 | (signed int)(palette + (signed long int)i)->_anon1.b);
}

// rle_palette_to_rgba
// file tools/rle.h line 33
void rle_palette_to_rgba(unsigned int *rgba, struct osd_clut_s *palette, unsigned int entries)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= entries); i = i + 1u)
    rgba[(signed long int)i] = (unsigned int)((signed int)(palette + (signed long int)i)->_anon2.r << 24 | (signed int)(palette + (signed long int)i)->_anon0.g << 16 | (signed int)(palette + (signed long int)i)->_anon1.b << 8 | (signed int)(palette + (signed long int)i)->alpha);
}

// rle_recompress_net
// file tools/rle.c line 78
unsigned int rle_recompress_net(unsigned char *raw, struct osd_rle_elem_s *data, unsigned int elems)
{
  unsigned char *raw0 = raw;
  unsigned int i = (unsigned int)0;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  for( ; !(i >= elems); i = i + 1u)
  {
    unsigned short int len = (data + (signed long int)i)->len;
    unsigned short int color = (data + (signed long int)i)->color;
    if((signed int)len >= 0x80)
    {
      tmp_post_1 = raw;
      raw = raw + 1l;
      *tmp_post_1 = (unsigned char)((signed int)len >> 8 | 0x80);
      tmp_post_2 = raw;
      raw = raw + 1l;
      *tmp_post_2 = (unsigned char)((signed int)len & 0xff);
    }

    else
    {
      tmp_post_3 = raw;
      raw = raw + 1l;
      *tmp_post_3 = (unsigned char)((signed int)len & 0x7f);
    }
    tmp_post_4 = raw;
    raw = raw + 1l;
    *tmp_post_4 = (unsigned char)color;
  }
  return (unsigned int)(raw - raw0);
}

// rle_scale_nearest
// file xine/../tools/rle.h line 53
struct osd_rle_elem_s * rle_scale_nearest(const struct osd_rle_elem_s *old_rle, signed int *rle_elems, unsigned int w, unsigned int h, unsigned int new_w, unsigned int new_h)
{
  unsigned int old_w = w;
  unsigned int old_h = h;
  unsigned int old_y = (unsigned int)0;
  unsigned int new_y = (unsigned int)0;
  unsigned int factor_x = ((unsigned int)0x100 * new_w) / old_w;
  unsigned int factor_y = ((unsigned int)0x100 * new_h) / old_h;
  unsigned int rle_size;
  unsigned int tmp_if_expr_1;
  if(!((new_h * (unsigned int)*rle_elems) / h >= 8128u))
    tmp_if_expr_1 = (unsigned int)8128;

  else
    tmp_if_expr_1 = ((unsigned int)*rle_elems * new_h) / h;
  rle_size = tmp_if_expr_1;
  unsigned int num_rle = (unsigned int)0;
  struct osd_rle_elem_s *new_rle;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct osd_rle_elem_s) /*4ul*/  * (unsigned long int)rle_size);
  new_rle = (struct osd_rle_elem_s *)return_value_malloc_2;
  struct osd_rle_elem_s *new_rle_start = new_rle;
  signed int tmp_post_4;
  struct osd_rle_elem_s *tmp_post_6;
  struct osd_rle_elem_s *tmp_post_7;
  unsigned int tmp_post_8;
  while(!(old_y >= old_h))
  {
    unsigned int elems_current_line = (unsigned int)0;
    unsigned int old_x = (unsigned int)0;
    unsigned int new_x = (unsigned int)0;
    while(!(old_x >= old_w))
    {
      unsigned int new_x_end = factor_x * (old_x + (unsigned int)old_rle->len) >> 8;
      if(!(new_w >= new_x_end))
        new_x_end = new_w;

      new_rle->len = (unsigned short int)(new_x_end - new_x);
      new_rle->color = old_rle->color;
      old_x = old_x + (unsigned int)old_rle->len;
      old_rle = old_rle + 1l;
      if((signed int)new_rle->len >= 1)
      {
        new_x = new_x + (unsigned int)new_rle->len;
        new_rle = new_rle + 1l;
        num_rle = num_rle + 1u;
        elems_current_line = elems_current_line + 1u;
        if(1u + num_rle >= rle_size)
        {
          rle_size = rle_size * (unsigned int)2;
          void *return_value_realloc_3;
          return_value_realloc_3=realloc((void *)new_rle_start, (unsigned long int)((unsigned int)4 * rle_size));
          new_rle_start = (struct osd_rle_elem_s *)return_value_realloc_3;
          new_rle = new_rle_start + (signed long int)num_rle;
        }

      }

    }
    if(!(new_x >= new_w))
      (new_rle - (signed long int)1)->len = (new_rle - (signed long int)1)->len + (unsigned short int)(new_w - new_x);

    old_y = old_y + 1u;
    new_y = new_y + 1u;
    if(factor_y >= 257u)
    {
      signed int dup = (signed int)((factor_y * old_y >> 8) - new_y);
      if(old_y == old_h)
        dup = (signed int)((new_h - new_y) - (unsigned int)1);

      do
      {
        tmp_post_4 = dup;
        dup = dup - 1;
        if(tmp_post_4 == 0)
          break;

        if(1u + new_y >= new_h)
          break;

        struct osd_rle_elem_s *prevline;
        unsigned int n;
        if(1u + elems_current_line + num_rle >= rle_size)
        {
          rle_size = rle_size * (unsigned int)2;
          void *return_value_realloc_5;
          return_value_realloc_5=realloc((void *)new_rle_start, (unsigned long int)((unsigned int)4 * rle_size));
          new_rle_start = (struct osd_rle_elem_s *)return_value_realloc_5;
          new_rle = new_rle_start + (signed long int)num_rle;
        }

        prevline = new_rle - (signed long int)elems_current_line;
        n = (unsigned int)0;
        for( ; !(n >= elems_current_line); n = n + 1u)
        {
          tmp_post_6 = new_rle;
          new_rle = new_rle + 1l;
          tmp_post_7 = prevline;
          prevline = prevline + 1l;
          *tmp_post_6 = *tmp_post_7;
          num_rle = num_rle + 1u;
        }
        new_y = new_y + 1u;
      }
      while((_Bool)1);
    }

    else
      if(!(factor_y >= 256u))
      {
        unsigned int skip = new_y - (factor_y * old_y >> 8);
        if(old_y == old_h + 4294967295u)
        {
          if(!(new_y >= new_h))
            skip = (unsigned int)0;

        }

        do
        {
          tmp_post_8 = skip;
          skip = skip - 1u;
          if(tmp_post_8 == 0u)
            break;

          if(old_y >= old_h)
            break;

          old_x = (unsigned int)0;
          for( ; !(old_x >= old_w); old_rle = old_rle + 1l)
            old_x = old_x + (unsigned int)old_rle->len;
          old_y = old_y + 1u;
        }
        while((_Bool)1);
      }

  }
  *rle_elems = (signed int)num_rle;
  return new_rle_start;
}

// rle_uncompress_argb
// file tools/rle.h line 38
void rle_uncompress_argb(unsigned int *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle, struct osd_clut_s *palette, unsigned int palette_entries)
{
  unsigned int lut[256l] = { (unsigned int)0, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u };
  if(!(palette_entries >= 257u))
  {
    rle_palette_to_argb(lut, palette, palette_entries);
    rle_uncompress_u32(dst, w, h, stride, rle_data, num_rle, lut);
  }

}

// rle_uncompress_hdmv
// file tools/rle.c line 298
signed int rle_uncompress_hdmv(struct osd_rle_elem_s **data, unsigned int w, unsigned int h, const unsigned char *rle_data, unsigned int num_rle, unsigned long int rle_size)
{
  unsigned int rle_count = (unsigned int)0;
  unsigned int x = (unsigned int)0;
  unsigned int y = (unsigned int)0;
  struct osd_rle_elem_s *rlep;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)((unsigned int)2 * num_rle), sizeof(struct osd_rle_elem_s) /*4ul*/ );
  rlep = (struct osd_rle_elem_s *)return_value_calloc_1;
  const unsigned char *end = rle_data + (signed long int)rle_size;
  *data = rlep;
  const unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  const unsigned char *tmp_post_5;
  const unsigned char *tmp_post_6;
  _Bool tmp_if_expr_7;
  while(!(y >= h))
  {
    if(rle_data >= end || rle_count >= 2u * num_rle)
    {
      free((void *)*data);
      *data = (struct osd_rle_elem_s *)(void *)0;
      return -1 - (signed int)(rle_data >= end);
    }

    unsigned int byte;
    tmp_post_2 = rle_data;
    rle_data = rle_data + 1l;
    byte = (unsigned int)*tmp_post_2;
    if(!(byte == 0u))
    {
      rlep->color = (unsigned short int)byte;
      rlep->len = (unsigned short int)1;
    }

    else
    {
      tmp_post_3 = rle_data;
      rle_data = rle_data + 1l;
      byte = (unsigned int)*tmp_post_3;
      if((128u & byte) == 0u)
      {
        rlep->color = (unsigned short int)0;
        if((64u & byte) == 0u)
          rlep->len = (unsigned short int)(byte & (unsigned int)0x3f);

        else
        {
          tmp_post_4 = rle_data;
          rle_data = rle_data + 1l;
          rlep->len = (unsigned short int)((byte & (unsigned int)0x3f) << 8 | (unsigned int)*tmp_post_4);
        }
      }

      else
      {
        if((64u & byte) == 0u)
          rlep->len = (unsigned short int)(byte & (unsigned int)0x3f);

        else
        {
          tmp_post_5 = rle_data;
          rle_data = rle_data + 1l;
          rlep->len = (unsigned short int)((byte & (unsigned int)0x3f) << 8 | (unsigned int)*tmp_post_5);
        }
        tmp_post_6 = rle_data;
        rle_data = rle_data + 1l;
        rlep->color = (unsigned short int)*tmp_post_6;
      }
    }
    if((signed int)rlep->len >= 1)
    {
      if((signed int)rlep->len == 1 && !(x == 0u))
        tmp_if_expr_7 = (rlep + (signed long int)-1)->color == rlep->color ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_7 = (_Bool)0;
      if(tmp_if_expr_7)
      {
        (rlep + (signed long int)-1)->len = (rlep + (signed long int)-1)->len + 1;
        x = x + 1u;
      }

      else
      {
        x = x + (unsigned int)rlep->len;
        rlep = rlep + 1l;
        rle_count = rle_count + 1u;
      }
      if(!(w >= x))
        return -9999;

    }

    else
    {
      if(!(x >= w + 4294967295u))
      {
        rlep->len = (unsigned short int)(w - x);
        rlep->color = (unsigned short int)0xff;
        rlep = rlep + 1l;
        rle_count = rle_count + 1u;
      }

      x = (unsigned int)0;
      y = y + 1u;
    }
  }
  return (signed int)rle_count;
}

// rle_uncompress_lut8
// file tools/rle.c line 372
void rle_uncompress_lut8(unsigned char *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle)
{
  unsigned int i;
  unsigned int pixelcounter = (unsigned int)0;
  unsigned int idx = (unsigned int)0;
  unsigned int line = (unsigned int)0;
  i = (unsigned int)0;
  for( ; !(i >= num_rle); i = i + 1u)
  {
    unsigned char color = (unsigned char)(rle_data + (signed long int)i)->color;
    unsigned int len = (unsigned int)(rle_data + (signed long int)i)->len;
    unsigned int j = (unsigned int)0;
    for( ; !(j >= len); j = j + 1u)
    {
      if(pixelcounter >= w)
      {
        idx = idx + (stride - pixelcounter);
        pixelcounter = (unsigned int)0;
        line = line + 1u;
        if(line >= h)
          goto __CPROVER_DUMP_L6;

      }

      dst[(signed long int)idx] = color;
      idx = idx + 1u;
      pixelcounter = pixelcounter + 1u;
    }
  }

__CPROVER_DUMP_L6:
  ;
}

// rle_uncompress_rgba
// file tools/rle.h line 42
void rle_uncompress_rgba(unsigned int *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle, struct osd_clut_s *palette, unsigned int palette_entries)
{
  unsigned int lut[256l] = { (unsigned int)0, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u };
  if(!(palette_entries >= 257u))
  {
    rle_palette_to_rgba(lut, palette, palette_entries);
    rle_uncompress_u32(dst, w, h, stride, rle_data, num_rle, lut);
  }

}

// rle_uncompress_u32
// file tools/rle.c line 420
static void rle_uncompress_u32(unsigned int *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle, unsigned int *lut)
{
  unsigned int i;
  unsigned int pixelcounter = (unsigned int)0;
  unsigned int idx = (unsigned int)0;
  unsigned int line = (unsigned int)0;
  i = (unsigned int)0;
  for( ; !(i >= num_rle); i = i + 1u)
  {
    unsigned int color = lut[(signed long int)(rle_data + (signed long int)i)->color];
    unsigned int len = (unsigned int)(rle_data + (signed long int)i)->len;
    unsigned int j = (unsigned int)0;
    for( ; !(j >= len); j = j + 1u)
    {
      if(pixelcounter >= w)
      {
        idx = idx + (stride - pixelcounter);
        pixelcounter = (unsigned int)0;
        line = line + 1u;
        if(line >= h)
          goto __CPROVER_DUMP_L6;

      }

      dst[(signed long int)idx] = color;
      idx = idx + 1u;
      pixelcounter = pixelcounter + 1u;
    }
  }

__CPROVER_DUMP_L6:
  ;
}

// scale_overlay
// file xine/vo_osdscaler.c line 335
static struct vo_overlay_s * scale_overlay(struct anonymous_80 *this, struct vo_frame_s *frame, struct vo_overlay_s *overlay)
{
  signed int return_value_check_for_scaling_2;
  return_value_check_for_scaling_2=check_for_scaling(this, frame, overlay);
  _Bool tmp_if_expr_1;
  if(!(return_value_check_for_scaling_2 == 0))
  {
    struct osd_data_s *scaled = this->active_osds;
    for( ; !(scaled == ((struct osd_data_s *)NULL)); scaled = scaled->next)
      if(scaled->source == overlay)
        break;

    if(!(scaled == ((struct osd_data_s *)NULL)))
    {
      if(!(scaled->output_width == this->output_width))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = scaled->output_height != this->output_height ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        osd_data_remove(&this->active_osds, scaled);
        scaled = (struct osd_data_s *)(void *)0;
      }

    }

    if(scaled == ((struct osd_data_s *)NULL))
    {
      this->active_osds=osd_data_init(overlay, this->active_osds, this->factor_x, this->factor_y);
      scaled = this->active_osds;
      scaled->output_width = this->output_width;
      scaled->output_height = this->output_height;
    }

    overlay = &scaled->ovl;
  }

  return overlay;
}

// set_above
// file xine_sxfe_frontend.c line 418
static void set_above(struct sxfe_s *this, signed int stay_above)
{
  union _XEvent ev;
  signed long int propvalue[1l];
  if(!(this->window_id >= 1))
  {
    if(!((signed int)this->stay_above == stay_above))
    {
      this->stay_above = (unsigned char)stay_above;
      update_window_title(this);
    }

    memset((void *)&ev, 0, sizeof(union _XEvent) /*192ul*/ );
    ev.type = 33;
    ev.xclient.type = 33;
    ev.xclient.message_type = this->xa_NET_WM_STATE;
    ev.xclient.display = this->display;
    ev.xclient.window = this->window[(signed long int)0];
    ev.xclient.format = 32;
    ev.xclient.data.l[(signed long int)0] = (signed long int)(stay_above != 0 ? 1 : 0);
    XLockDisplay(this->display);
    ev.xclient.data.l[(signed long int)1] = (signed long int)this->xa_NET_WM_STATE_ABOVE;
    XSendEvent(this->display, (&((struct anonymous_34 *)this->display)->screens[(signed long int)((struct anonymous_34 *)this->display)->default_screen])->root, 0, 1L << 19 | 1L << 20, &ev);
    XUnlockDisplay(this->display);
    XLockDisplay(this->display);
    ev.xclient.data.l[(signed long int)1] = (signed long int)this->xa_NET_WM_STATE_STAYS_ON_TOP;
    XSendEvent(this->display, (&((struct anonymous_34 *)this->display)->screens[(signed long int)((struct anonymous_34 *)this->display)->default_screen])->root, 0, 1L << 19 | 1L << 20, &ev);
    XUnlockDisplay(this->display);
    XLockDisplay(this->display);
    ev.xclient.data.l[(signed long int)1] = (signed long int)this->xa_NET_WM_STATE_STICKY;
    XSendEvent(this->display, (&((struct anonymous_34 *)this->display)->screens[(signed long int)((struct anonymous_34 *)this->display)->default_screen])->root, 0, 1L << 19 | 1L << 20, &ev);
    XUnlockDisplay(this->display);
    propvalue[(signed long int)0] = (signed long int)(stay_above != 0 ? 6 : 4);
    XLockDisplay(this->display);
    XChangeProperty(this->display, this->window[(signed long int)0], this->xa_WIN_LAYER, (unsigned long int)6, 32, 0, (unsigned char *)propvalue, 1);
    XUnlockDisplay(this->display);
  }

}

// set_border
// file xine_sxfe_frontend.c line 319
static void set_border(struct sxfe_s *this, unsigned long int window, signed int border)
{
  struct _mwmhints mwmhints = { .flags=(unsigned long int)(1L << 1), .functions=0ul, .decorations=(unsigned long int)(border != 0 ? 1 : 0),
    .input_mode=0l,
    .status=0ul };
  if(!(this->window_id >= 1))
  {
    XLockDisplay(this->display);
    XChangeProperty(this->display, window, this->xa_MOTIF_WM_HINTS, this->xa_MOTIF_WM_HINTS, 32, 0, (unsigned char *)&mwmhints, 5);
    XUnlockDisplay(this->display);
  }

}

// set_cursor
// file xine_sxfe_frontend.c line 523
static void set_cursor(struct _XDisplay *dpy, unsigned long int win, const signed int enable)
{
  XLockDisplay(dpy);
  if(!(enable == 0))
    XDefineCursor(dpy, win, (unsigned long int)0L);

  else
  {
    const char bm_no_data[8l] = { (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0 };
    unsigned long int no_ptr;
    struct anonymous_18 black;
    struct anonymous_18 dummy;
    unsigned long int bm_no;
    bm_no=XCreateBitmapFromData(dpy, win, bm_no_data, (unsigned int)8, (unsigned int)8);
    XAllocNamedColor(dpy, (&((struct anonymous_34 *)dpy)->screens[(signed long int)((struct anonymous_34 *)dpy)->default_screen])->cmap, "black", &black, &dummy);
    no_ptr=XCreatePixmapCursor(dpy, bm_no, bm_no, &black, &black, (unsigned int)0, (unsigned int)0);
    XDefineCursor(dpy, win, (unsigned long int)0L);
    XDefineCursor(dpy, win, no_ptr);
  }
  XUnlockDisplay(dpy);
}

// set_fs_size_hint
// file xine_sxfe_frontend.c line 301
static void set_fs_size_hint(struct sxfe_s *this)
{
  struct anonymous_87 hint;
  hint.flags = 1L << 1 | 1L << 0 | 1L << 2 | 1L << 3;
  hint.x = (signed int)this->xinerama_x;
  hint.y = (signed int)this->xinerama_y;
  hint.width = (signed int)this->_anon0.x.width;
  hint.height = (signed int)this->_anon0.x.height;
  XLockDisplay(this->display);
  XSetNormalHints(this->display, this->window[(signed long int)1], &hint);
  XUnlockDisplay(this->display);
}

// set_fullscreen_props
// file xine_sxfe_frontend.c line 337
static void set_fullscreen_props(struct sxfe_s *this)
{
  union _XEvent ev;
  if(!(this->window_id >= 1))
  {
    set_fs_size_hint(this);
    set_border(this, this->window[(signed long int)1], 0);
    memset((void *)&ev, 0, sizeof(union _XEvent) /*192ul*/ );
    ev.type = 33;
    ev.xclient.type = 33;
    ev.xclient.message_type = this->xa_NET_WM_STATE;
    ev.xclient.display = this->display;
    ev.xclient.window = this->window[(signed long int)1];
    ev.xclient.format = 32;
    ev.xclient.data.l[(signed long int)0] = (signed long int)1;
    XLockDisplay(this->display);
    ev.xclient.data.l[(signed long int)1] = (signed long int)this->xa_NET_WM_STATE_FULLSCREEN;
    XSendEvent(this->display, (&((struct anonymous_34 *)this->display)->screens[(signed long int)((struct anonymous_34 *)this->display)->default_screen])->root, 0, 1L << 19 | 1L << 20, &ev);
    XUnlockDisplay(this->display);
    XLockDisplay(this->display);
    ev.xclient.data.l[(signed long int)1] = (signed long int)this->xa_NET_WM_STATE_ABOVE;
    XSendEvent(this->display, (&((struct anonymous_34 *)this->display)->screens[(signed long int)((struct anonymous_34 *)this->display)->default_screen])->root, 0, 1L << 19 | 1L << 20, &ev);
    XUnlockDisplay(this->display);
    XLockDisplay(this->display);
    ev.xclient.data.l[(signed long int)1] = (signed long int)this->xa_NET_WM_STATE_STAYS_ON_TOP;
    XSendEvent(this->display, (&((struct anonymous_34 *)this->display)->screens[(signed long int)((struct anonymous_34 *)this->display)->default_screen])->root, 0, 1L << 19 | 1L << 20, &ev);
    XUnlockDisplay(this->display);
    XLockDisplay(this->display);
    ev.xclient.message_type = this->xa_NET_ACTIVE_WINDOW;
    ev.xclient.data.l[(signed long int)0] = (signed long int)0;
    ev.xclient.data.l[(signed long int)1] = (signed long int)0;
    XSendEvent(this->display, (&((struct anonymous_34 *)this->display)->screens[(signed long int)((struct anonymous_34 *)this->display)->default_screen])->root, 0, 1L << 19 | 1L << 20, &ev);
    XUnlockDisplay(this->display);
  }

}

// set_icon
// file xine_sxfe_frontend.c line 1409
static void set_icon(struct sxfe_s *this)
{
  XLockDisplay(this->display);
  signed long int q[1026l];
  /* tag-#anon#lST[cU32'width'||cU32'height'||lARR4097{cU8}_cU8_'pixel_data'|] */
struct anonymous_104
{
  // width
  const unsigned int width;
  // height
  const unsigned int height;
  // pixel_data
  const unsigned char pixel_data[4097l];
} __attribute__ ((__packed__));

/* */
  ;
  static const struct anonymous_104 vdrlogo_32x32 = { .width=(const unsigned int)32, .height=(const unsigned int)32, .pixel_data={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 140, 'v', 166, 26, '<', 25, 'x', 'c', 'T', '5', 136, 'F', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 's', 'Z', 150, 31, 'F', '_', '|', '^', ';', 24, 'y', 'c', ';', 24, 'y', 'c', ';', 24, 'y', 'c', 'C', '!', '~', 'c', 'Y', '7', 133, 'U', 153, 136, 181, 'F', 'L', '.', 130, 'c', '<', 24, 'y', 'c', ';', 24, 'y', 'c', ';', 24, 'y', 'c', ';', 24, 'y', 'c', ';', 24, 'y', 'c', ';', 24, 'y', 'c', 'E', '"', 127, 'c', 'U', '4', 128, 'J', 'v', '^', 151, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 148, 196, 8, 'B', 27, 'z', 236, 'I', '!', '~', 246, 205, 190, 217, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'R', '3', 130, 'a', '>', 20, 'z', 247, ':', 15, 'y', 255, ':', 15, 'x', 255, ':', 15, 'x', 255, ':', 15, 'x', 255, ':', 15, 'y', 255, ':', 15, '|', 255, '>', 21, '{', 255, '_', 'C', 132, 255, 'M', '*', 128, 255, ':', 16, 'x', 255, ':', 16, 'x', 255, ':', 16, 'w', 255, ':', 16, 'w', 255, ':', 16, 'w', 255, ':', 15, 'x', 255, ':', 15, 'y', 255, '@', 25, '|', 239, 'e', 'H', 141, 'G', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'R', '.', 132, 149, ';', 15, 'z', 255, 't', 'Y', 153, 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'm', 'T', 147, ' ', '=', 20, 'z', 251, '=', 27, 'n', 255, '>', '!', 'f', 255, 'l', 'a', 'x', 172, 'f', '^', 'n', 137, 'f', ']', 'q', 137, 'e', ']', 'r', 144, '_', 'O', 'v', 172, 'J', '*', 'x', 243, ';', 15, 'y', 255, 'c', 'H', 141, 229, 'g', 'b', 'j', 'v', 'g', 'b', 'j', 's', 'k', 'f', 'm', 's', 'n', 'i', 'p', 's', 'q', 'k', 'r', 's', 'o', 'i', 'v', '|', '^', 'G', '|', 188, '<', 19, 'y', 255, 'E', 30, '~', 234, 186, 170, 208, 17, 0, 0, 0, 0, 0, 0, 0, 0, 'u', '\\', 177, ';', 18, 'z', 255, 'Y', '7', 135, 196, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'O', '+', 132, 130, ';', 17, 'u', 255, 'M', '4', 't', 248, ';', 16, 'y', 255, 'r', 'f', 135, 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 160, 151, 174, '"', 'J', '(', 127, 225, ':', 17, '{', 255, 's', 'Z', 155, 'J', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 226, 224, 227, 1, 'P', '*', 131, 182, ';', 15, 'x', 255, 'z', 'i', 144, 'a', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'K', '&', 132, 206, 'A', 26, '{', 253, 163, 152, 180, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221, 203, 242, 3, 'C', 28, '}', 224, 'M', '1', 't', 248, 'J', '&', 127, 169, ':', 16, 'x', 255, 'r', 'f', 135, 'Y', 0, 0, 0, 0, 'd', 'd', 'd', 6, 20, 20, 20, 193, 29, 29, 29, 193, 'Z', 'Z', 'Z', 18, 'h', 'L', 143, 'X', ';', 15, '{', 255, '[', '=', 138, 181, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'G', '!', '~', 169, ':', 15, 'y', 255, 's', 'e', 133, '{', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'W', '7', 131, 'g', '9', 16, 'z', 255, 'i', 'M', 145, '}', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '\\', ';', 141, 'F', ':', 16, 'y', 255, 'e', 'U', '{', 168, '?', 22, 'y', 152, ':', 16, 'x', 255, 'r', 'f', 135, 'Y', 0, 0, 0, 0, 'f', 'g', 'g', '_', 'G', 'B', '3', 255, 'N', 'K', 'F', 255, 'J', 'J', 'J', 127, 153, 133, 180, 17, '=', 19, 'x', 255, 'T', '2', 129, 240, 221, 223, 208, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 139, 187, 15, 'Y', '7', 136, 'i', '<', 19, 'y', 250, '?', 26, 'o', 255, 146, 142, 151, 'H', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 't', 170, 13, '@', 24, '}', 244, 'T', '2', 135, 216, 233, 227, 229, 1, 0, 0, 0, 0, 0, 0, 0, 0, 'H', '#', '~', 170, '=', 25, 'r', 255, 149, 142, 152, 'E', '?', 22, 'y', 152, ':', 16, 'x', 255, 'r', 'f', 135, 'Y', 0, 0, 0, 0, 146, 143, 144, '"', 176, 141, 255, 159, 139, 'K', 255, 158, 234, 218, 246, 6, 'F', 30, 129, 255, 'L', '\'', '|', 255, 'H', '_', 130, 246, '@', 24, '}', 245, '@', 24, '}', 245, 'A', 23, '{', 245, '=', 19, 'y', 253, ';', 15, 'x', 255, ';', 25, 'n', 255, 'j', '_', 'w', 172, 215, 210, 214, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'I', '&', 129, 158, '>', 20, 'z', 255, 150, 131, 143, 0, 0, 0, 0, '|', 'b', 162, 20, '=', 20, '{', 247, 'V', '@', 'x', 224, 228, 226, 227, 2, '?', 22, 'y', 152, ':', 16, 'x', 255, 'r', 'f', 135, 'Y', 0, 0, 0, 0, 'T', 'U', 'U', 158, 235, 234, 235, 255, 237, 236, 236, 255, '(', '\'', '(', 246, 'M', 'J', 'P', '2', 'B', 25, '}', 255, 'I', '\'', 'z', 255, 'b', 'N', 129, 239, 'T', '?', 'v', 245, 'P', '8', 'v', 247, '<', 23, 'u', 255, ':', 17, 'x', 255, 'U', 'D', 'q', 216, 127, '}', 131, ']', 219, 221, 218, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'e', 'M', 146, ';', ';', 16, 'z', 255, 'a', 'C', 140, 147, 0, 0, 0, 0, 'L', '*', 133, 'n', ':', 17, 'w', 255, 'o', 'd', '}', 130, 0, 0, 0, 0, '?', 22, 'y', 152, ':', 16, 'x', 255, 'r', 'f', 135, 'Y', 'Y', '\\', '\\', ' ', 152, 152, 154, 250, 244, 245, 245, 255, 246, 246, 246, 255, '|', '|', '}', 250, '-', '8', 215, ':', 15, 'x', 255, 'U', '9', '}', 250, 223, 226, 218, 3, 0, 0, 0, 0, 224, 224, 216, 2, 131, 'w', 152, 'T', 'E', ' ', 'z', 245, '<', 19, '{', 247, 'W', '7', 136, 'D', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 215, 197, 239, 1, 'G', '"', '}', 216, 'O', ',', 131, 235, 222, 210, 231, 6, 'F', 31, '~', 209, 'F', '&', 'r', 253, 173, 172, 174, '_', 0, 0, 0, 0, '?', 22, 'y', 152, ':', 15, 'x', 255, 128, 't', 142, 'c', 178, 146, 'D', 145, 186, 176, 142, 255, 243, 244, 245, 255, 246, 246, 246, 255, 138, 129, '^', 251, '#', '%', 255, ':', 15, 'x', 255, '[', 'H', 'x', 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x', 'b', 154, ']', '<', 20, 'z', 255, '>', 23, 'z', 235, 132, 'l', 162, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'R', '2', 133, 't', ';', 16, 'z', 255, 'y', '`', 153, 'w', ';', 17, 'v', 255, '`', 'N', 'z', 195, 0, 0, 0, 0, 0, 0, 0, 0, '@', 23, 'z', 152, ':', 15, 'y', 255, 162, 143, 'r', 165, 237, 186, 17, 255, 200, 160, 16, 255, 217, 214, 211, 255, 212, 212, 212, 255, 201, 153, 31, 255, 223, 175, 21, 255, 'S', '-', '^', 255, '|', 'u', 131, 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '_', '?', 140, 171, 16, 'z', 255, 'M', '*', 130, 178, 247, 241, 243, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 'o', 166, 23, '?', 22, '{', 249, 'J', '_', 127, 248, ':', 20, 's', 255, 130, '{', 134, '`', 0, 0, 0, 0, 0, 0, 0, 0, '?', 22, 'z', 152, ';', 15, 'x', 255, 'g', 'G', 128, 213, '}', 'Q', 'B', 255, 140, '\\', 'C', 255, '<', ' ', 'L', 255, '_', 13, 'H', 255, 135, '^', 21, 255, 'V', '9', ',', 255, 'T', 'M', '_', 199, 202, 207, 199, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 162, 141, 185, 22, 'I', '_', 128, 237, ';', 16, 'z', 255, '_', 'C', 139, 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'M', '+', 130, 177, 16, 'z', 255, 'P', '5', 'u', 241, 203, 204, 199, 13, 0, 0, 0, 0, 0, 0, 0, 0, '>', 21, 'x', 153, ';', 15, 'y', 255, ':', 16, 'y', 255, ':', 15, 'y', 255, ';', 15, 'y', 255, 15, 'z', 255, '<', 20, 'p', 255, '@', ')', '`', 254, 'b', 'X', 'o', 178, 182, 180, 171, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'u', '\\', 155, '`', '<', 17, 'y', 255, 'A', 28, '|', 233, 133, 's', 166, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 145, 137, 153, 'k', 'c', 't', 143, '|', 'y', 134, 'a', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132, 'y', 141, 'M', 'j', 'c', 'x', 143, 'k', 'a', 'v', 141, 'l', 'b', 'x', 143, 'k', 'a', 'r', 141, 'i', 'c', 'r', 133, 130, 130, 132, 'i', 176, 177, 169, '&', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 240, 237, 231, 3, 'w', 'o', 130, 'z', 'j', '`', 'u', 141, 143, 144, 147, '?', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
  unsigned int *p = (unsigned int *)&vdrlogo_32x32;
  unsigned int i = (unsigned int)0;
  for( ; !(i >= vdrlogo_32x32.height * vdrlogo_32x32.width + 2u); i = i + 1u)
    q[(signed long int)i] = (signed long int)p[(signed long int)i];
  unsigned long int return_value_XInternAtom_1;
  return_value_XInternAtom_1=XInternAtom(this->display, "_NET_WM_ICON", 0);
  XChangeProperty(this->display, this->window[(signed long int)0], return_value_XInternAtom_1, (unsigned long int)6, 32, 0, (unsigned char *)q, (signed int)((unsigned int)2 + vdrlogo_32x32.width * vdrlogo_32x32.height));
  XUnlockDisplay(this->display);
}

// shutdown_system
// file xine_frontend.c line 105
static void shutdown_system(char *cmd, signed int user_requested)
{
  const char *reason = user_requested != 0 ? "User requested system shutdown" : "Inactivity timer elapsed";
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(cmd == ((char *)NULL)))
  {
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[vdr-fe]    ", "%s. Executing '%s'", reason, cmd);

    while((_Bool)0);
    signed int return_value_system_4;
    return_value_system_4=system(cmd);
    if(return_value_system_4 == -1)
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[vdr-fe]    ", "Can't execute %s", cmd);
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          if(!(*return_value___errno_location_3 == 0))
          {
            return_value___errno_location_1=__errno_location();
            return_value_strerror_2=strerror(*return_value___errno_location_1);
            x_syslog(3, "[vdr-fe]    ", "   (ERROR (%s,%d): %s)", (const void *)"xine_frontend.c", 112, return_value_strerror_2);
          }

        }

      while((_Bool)0);

  }

  else
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[vdr-fe]    ", "%s, power off comand undefined!", reason);

    while((_Bool)0);
}

// slave_receiver_thread
// file xine_frontend_kbd.c line 257
static void * slave_receiver_thread(void *fe_gen)
{
  struct frontend_s *fe = (struct frontend_s *)fe_gen;
  char str[128l];
  char *pt;
  tcgetattr(0, &saved_tm);
  char *tmp_statement_expression_6;
  signed int return_value;
  do
  {
    struct anonymous_102 __cancel_buf;
    void (*__cancel_routine)(void *) = slave_receiver_thread_cleanup;
    void *__cancel_arg = (void *)0;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 0;
      str[(signed long int)0] = (char)0;
      pthread_testcancel();
      char *return_value_fgets_2;
      return_value_fgets_2=fgets_link1(str, (signed int)sizeof(char [128l]) /*128ul*/ , stdin);
      if(!(return_value_fgets_2 == ((char *)NULL)))
      {
        pthread_testcancel();
        char *return_value___builtin_strchr_3;
        return_value___builtin_strchr_3=__builtin_strchr(str, 13);
        pt = return_value___builtin_strchr_3;
        if(!(pt == ((char *)NULL)))
          *pt = (char)0;

        char *return_value___builtin_strchr_4;
        return_value___builtin_strchr_4=__builtin_strchr(str, 10);
        pt = return_value___builtin_strchr_4;
        if(!(pt == ((char *)NULL)))
          *pt = (char)0;

        signed int return_value_strncasecmp_5;
        return_value_strncasecmp_5=strncasecmp(str, "QUIT", (unsigned long int)4);
        if(return_value_strncasecmp_5 == 0)
          fe->send_event(fe, "QUIT");

        else
        {
          signed int return_value_strncasecmp_8;
          return_value_strncasecmp_8=strncasecmp(str, "FULLSCREEN", (unsigned long int)10);
          if(return_value_strncasecmp_8 == 0)
          {
            char __a0;
            char __a1;
            char __a2;
            char *return_value___builtin_strpbrk_7;
            return_value___builtin_strpbrk_7=__builtin_strpbrk(str + (signed long int)10, "01");
            tmp_statement_expression_6 = return_value___builtin_strpbrk_7;
            if(!(tmp_statement_expression_6 == ((char *)NULL)))
              fe->send_event(fe, str);

            else
              fe->send_event(fe, "TOGGLE_FULLSCREEN");
          }

          else
          {
            signed int return_value_strncasecmp_9;
            return_value_strncasecmp_9=strncasecmp(str, "DEINTERLACE ", (unsigned long int)12);
            if(return_value_strncasecmp_9 == 0)
              fe->send_event(fe, str);

            else
            {
              signed int return_value_strncasecmp_10;
              return_value_strncasecmp_10=strncasecmp(str, "HITK ", (unsigned long int)5);
              if(return_value_strncasecmp_10 == 0)
                fe->send_input_event(fe, (const char *)(void *)0, str + (signed long int)5, 0, 0);

              else
                do
                  if(SysLogLevel >= 2)
                    x_syslog(6, "[console]   ", "Unknown slave mode command: %s", (const void *)str);

                while((_Bool)0);
            }
          }
          return_value=fe->xine_is_finished(fe, 0);
        }
      }

      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[console]   ", "Slave mode receiver terminating");

      while((_Bool)0);

    __CPROVER_DUMP_L17:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  pthread_exit((void *)0);
  return (void *)0;
}

// slave_receiver_thread_cleanup
// file xine_frontend_kbd.c line 250
static void slave_receiver_thread_cleanup(void *arg)
{
  tcsetattr(0, 0, &saved_tm);
  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[console]   ", "Slave mode receiver terminated");

  while((_Bool)0);
}

// snprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack_1;
  return_value___builtin_va_arg_pack_1=__builtin_va_arg_pack();
  signed int return_value___builtin___snprintf_chk_2;
  return_value___builtin___snprintf_chk_2=__builtin___snprintf_chk(__s, __n, 2 - 1, 18446744073709551615ul, __fmt, return_value___builtin_va_arg_pack_1);
  return return_value___builtin___snprintf_chk_2;
}

// snprintf_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf_link1(char * restrict __s_link1, unsigned long int __n_link1, const char * restrict __fmt_link1, ...)
{
  void *return_value___builtin_va_arg_pack_1_link1;
  return_value___builtin_va_arg_pack_1_link1=__builtin_va_arg_pack();
  signed int return_value___builtin___snprintf_chk_2_link1;
  return_value___builtin___snprintf_chk_2_link1=__builtin___snprintf_chk(__s_link1, __n_link1, 2 - 1, 18446744073709551615ul, __fmt_link1, return_value___builtin_va_arg_pack_1_link1);
  return return_value___builtin___snprintf_chk_2_link1;
}

// snprintf_link2
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf_link2(char * restrict __s_link2, unsigned long int __n_link2, const char * restrict __fmt_link2, ...)
{
  void *return_value___builtin_va_arg_pack_1_link2;
  return_value___builtin_va_arg_pack_1_link2=__builtin_va_arg_pack();
  signed int return_value___builtin___snprintf_chk_2_link2;
  return_value___builtin___snprintf_chk_2_link2=__builtin___snprintf_chk(__s_link2, __n_link2, 2 - 1, 18446744073709551615ul, __fmt_link2, return_value___builtin_va_arg_pack_1_link2);
  return return_value___builtin___snprintf_chk_2_link2;
}

// snprintf_link3
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf_link3(char * restrict __s_link3, unsigned long int __n_link3, const char * restrict __fmt_link3, ...)
{
  void *return_value___builtin_va_arg_pack_1_link3;
  return_value___builtin_va_arg_pack_1_link3=__builtin_va_arg_pack();
  signed int return_value___builtin___snprintf_chk_2_link3;
  return_value___builtin___snprintf_chk_2_link3=__builtin___snprintf_chk(__s_link3, __n_link3, 2 - 1, 18446744073709551615ul, __fmt_link3, return_value___builtin_va_arg_pack_1_link3);
  return return_value___builtin___snprintf_chk_2_link3;
}

// sprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 31
static inline signed int sprintf(char * restrict __s, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack_1;
  return_value___builtin_va_arg_pack_1=__builtin_va_arg_pack();
  signed int return_value___builtin___sprintf_chk_2;
  return_value___builtin___sprintf_chk_2=__builtin___sprintf_chk(__s, 2 - 1, 18446744073709551615ul, __fmt, return_value___builtin_va_arg_pack_1);
  return return_value___builtin___sprintf_chk_2;
}

// sprintf_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 31
static inline signed int sprintf_link1(char * restrict __s_link1, const char * restrict __fmt_link1, ...)
{
  void *return_value___builtin_va_arg_pack_1_link1;
  return_value___builtin_va_arg_pack_1_link1=__builtin_va_arg_pack();
  signed int return_value___builtin___sprintf_chk_2_link1;
  return_value___builtin___sprintf_chk_2_link1=__builtin___sprintf_chk(__s_link1, 2 - 1, 18446744073709551615ul, __fmt_link1, return_value___builtin_va_arg_pack_1_link1);
  return return_value___builtin___sprintf_chk_2_link1;
}

// sprintf_link2
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 31
static inline signed int sprintf_link2(char * restrict __s_link2, const char * restrict __fmt_link2, ...)
{
  void *return_value___builtin_va_arg_pack_1_link2;
  return_value___builtin_va_arg_pack_1_link2=__builtin_va_arg_pack();
  signed int return_value___builtin___sprintf_chk_2_link2;
  return_value___builtin___sprintf_chk_2_link2=__builtin___sprintf_chk(__s_link2, 2 - 1, 18446744073709551615ul, __fmt_link2, return_value___builtin_va_arg_pack_1_link2);
  return return_value___builtin___sprintf_chk_2_link2;
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat_1;
  return_value___xstat_1=__xstat(1, __path, __statbuf);
  return return_value___xstat_1;
}

// strcat
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 146
static inline char * strcat(char * restrict __dest, const char * restrict __src)
{
  char *return_value___builtin___strcat_chk_1;
  return_value___builtin___strcat_chk_1=__builtin___strcat_chk(__dest, __src, 18446744073709551615ul);
  return return_value___builtin___strcat_chk_1;
}

// strcat_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 146
static inline char * strcat_link1(char * restrict __dest_link1, const char * restrict __src_link1)
{
  char *return_value___builtin___strcat_chk_1_link1;
  return_value___builtin___strcat_chk_1_link1=__builtin___strcat_chk(__dest_link1, __src_link1, 18446744073709551615ul);
  return return_value___builtin___strcat_chk_1_link1;
}

// strcat_link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 146
static inline char * strcat_link2(char * restrict __dest_link2, const char * restrict __src_link2)
{
  char *return_value___builtin___strcat_chk_1_link2;
  return_value___builtin___strcat_chk_1_link2=__builtin___strcat_chk(__dest_link2, __src_link2, 18446744073709551615ul);
  return return_value___builtin___strcat_chk_1_link2;
}

// strcatrealloc
// file xine_frontend_main.c line 69
static char * strcatrealloc(char *dest, const char *src)
{
  unsigned long int l;
  _Bool tmp_if_expr_1;
  if(src == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*src != 0) ? (_Bool)1 : (_Bool)0;
  unsigned long int tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  if(tmp_if_expr_1)
    return dest;

  else
  {
    if(!(dest == ((char *)NULL)))
    {
      return_value_strlen_2=strlen(dest);
      tmp_if_expr_3 = return_value_strlen_2;
    }

    else
      tmp_if_expr_3 = (unsigned long int)0;
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(src);
    l = tmp_if_expr_3 + return_value_strlen_4 + (unsigned long int)1;
    if(!(dest == ((char *)NULL)))
    {
      void *return_value_realloc_5;
      return_value_realloc_5=realloc((void *)dest, l);
      dest = (char *)return_value_realloc_5;
      strcat_link2(dest, src);
    }

    else
    {
      void *return_value_malloc_6;
      return_value_malloc_6=malloc(l);
      dest = (char *)return_value_malloc_6;
      strcpy(dest, src);
    }
    return dest;
  }
}

// strcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 108
static inline char * strcpy(char * restrict __dest, const char * restrict __src)
{
  char *return_value___builtin___strcpy_chk_1;
  return_value___builtin___strcpy_chk_1=__builtin___strcpy_chk(__dest, __src, 18446744073709551615ul);
  return return_value___builtin___strcpy_chk_1;
}

// strcpy_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 108
static inline char * strcpy_link1(char * restrict __dest_link1, const char * restrict __src_link1)
{
  char *return_value___builtin___strcpy_chk_1_link1;
  return_value___builtin___strcpy_chk_1_link1=__builtin___strcpy_chk(__dest_link1, __src_link1, 18446744073709551615ul);
  return return_value___builtin___strcpy_chk_1_link1;
}

// strcpy_link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 108
static inline char * strcpy_link2(char * restrict __dest_link2, const char * restrict __src_link2)
{
  char *return_value___builtin___strcpy_chk_1_link2;
  return_value___builtin___strcpy_chk_1_link2=__builtin___strcpy_chk(__dest_link2, __src_link2, 18446744073709551615ul);
  return return_value___builtin___strcpy_chk_1_link2;
}

// strn0cpy
// file xine_frontend.c line 72
char * strn0cpy(char *dest, const char *src, signed int n)
{
  char *s = dest;
  _Bool tmp_if_expr_1;
  do
  {
    n = n - 1;
    if(!(n == 0))
    {
      *dest = *src;
      tmp_if_expr_1 = (signed int)*dest != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    dest = dest + 1l;
    src = src + 1l;
  }
  while((_Bool)1);
  *dest = (char)0;
  return s;
}

// strncat
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 153
static inline char * strncat(char * restrict __dest, const char * restrict __src, unsigned long int __len)
{
  char *return_value___builtin___strncat_chk_1;
  return_value___builtin___strncat_chk_1=__builtin___strncat_chk(__dest, __src, __len, 18446744073709551615ul);
  return return_value___builtin___strncat_chk_1;
}

// strncpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 123
static inline char * strncpy(char * restrict __dest, const char * restrict __src, unsigned long int __len)
{
  char *return_value___builtin___strncpy_chk_1;
  return_value___builtin___strncpy_chk_1=__builtin___strncpy_chk(__dest, __src, __len, 18446744073709551615ul);
  return return_value___builtin___strncpy_chk_1;
}

// strncpy_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 123
static inline char * strncpy_link1(char * restrict __dest_link1, const char * restrict __src_link1, unsigned long int __len_link1)
{
  char *return_value___builtin___strncpy_chk_1_link1;
  return_value___builtin___strncpy_chk_1_link1=__builtin___strncpy_chk(__dest_link1, __src_link1, __len_link1, 18446744073709551615ul);
  return return_value___builtin___strncpy_chk_1_link1;
}

// sxfe_dest_size_cb
// file xine_sxfe_frontend.c line 266
static void sxfe_dest_size_cb(void *data, signed int video_width, signed int video_height, double video_pixel_aspect, signed int *dest_width, signed int *dest_height, double *dest_pixel_aspect)
{
  struct fe_s_0 *this = (struct fe_s_0 *)data;
  if(!(this == ((struct fe_s_0 *)NULL)))
  {
    *dest_width = (signed int)this->width;
    *dest_height = (signed int)this->height;
    *dest_pixel_aspect=this->dest_pixel_aspect(this, video_pixel_aspect, video_width, video_height);
  }

}

// sxfe_display_close
// file xine_sxfe_frontend.c line 3070
static void sxfe_display_close(struct frontend_s *this_gen)
{
  struct sxfe_s *this = (struct sxfe_s *)this_gen;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(this == ((struct sxfe_s *)NULL)))
  {
    if(!(this->_anon0.x.xine == ((struct xine_s_0 *)NULL)))
      this->_anon0.fe.xine_exit(this_gen);

    if(!(this->display == ((struct _XDisplay *)NULL)))
    {
      if(!(this->opengl_always == 0))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = this->opengl_hud != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        void *status;
        this->opengl_deinit = (unsigned char)1;
        opengl_trigger_drawing_thread(this);
        signed int return_value_pthread_join_4;
        return_value_pthread_join_4=pthread_join(this->opengl_drawing_thread, &status);
        if(!(return_value_pthread_join_4 == 0))
          do
            if(SysLogLevel >= 1)
            {
              x_syslog(3, "[vdr-sxfe]  ", "sxfe_display_close: can not join opengl drawing thread!");
              signed int *return_value___errno_location_3;
              return_value___errno_location_3=__errno_location();
              if(!(*return_value___errno_location_3 == 0))
              {
                return_value___errno_location_1=__errno_location();
                return_value_strerror_2=strerror(*return_value___errno_location_1);
                x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 3088, return_value_strerror_2);
              }

            }

          while((_Bool)0);

        free((void *)this->opengl_osd_texture_img);
      }

      hud_osd_close(this);
      gnome_screensaver_control(1);
      if(!(this->dpms_state == 0))
        DPMSEnable(this->display);

      if(!(this->window_id >= 1))
      {
        XLockDisplay(this->display);
        XUnmapWindow(this->display, this->window[(signed long int)(this->fullscreen != 0 ? 1 : 0)]);
        XDestroyWindow(this->display, this->window[(signed long int)0]);
        XDestroyWindow(this->display, this->window[(signed long int)1]);
        XUnlockDisplay(this->display);
      }

      XCloseDisplay(this->display);
      this->display = (struct _XDisplay *)(void *)0;
      pthread_mutex_destroy(&this->video_win_mutex);
    }

    free((void *)this->_anon0.x.aspect_controller);
    this->_anon0.x.aspect_controller = (char *)(void *)0;
  }

}

// sxfe_display_config
// file xine_sxfe_frontend.c line 2466
static signed int sxfe_display_config(struct frontend_s *this_gen, signed int xpos, signed int ypos, signed int width, signed int height, signed int fullscreen, signed int modeswitch, const char *modeline, signed int aspect, signed int scale_video)
{
  struct sxfe_s *this = (struct sxfe_s *)this_gen;
  if(!(this->fullscreen_state_forced == 0))
    fullscreen = this->fullscreen != 0 ? 1 : 0;

  _Bool tmp_if_expr_1;
  if(fullscreen == 0)
  {
    if(!((signed int)this->_anon0.x.width == width))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)this->_anon0.x.height != height ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      this->_anon0.x.width = (unsigned short int)width;
      this->_anon0.x.height = (unsigned short int)height;
      XLockDisplay(this->display);
      XResizeWindow(this->display, this->window[(signed long int)0], (unsigned int)this->_anon0.x.width, (unsigned int)this->_anon0.x.height);
      XUnlockDisplay(this->display);
      if(fullscreen == 0)
      {
        if(this->fullscreen == 0)
          xine_port_send_gui_data(this->_anon0.x.video_port, 2, (void *)this->window[(signed long int)0]);

      }

    }

  }

  if(!(fullscreen == 0))
    update_screen_size(this);

  if(!(fullscreen == (signed int)this->fullscreen))
  {
    unsigned long int tmp_win;
    signed int tmp_x;
    signed int tmp_y;
    XLockDisplay(this->display);
    XUnmapWindow(this->display, this->window[(signed long int)(this->fullscreen != 0 ? 1 : 0)]);
    this->fullscreen = (unsigned char)(fullscreen != 0 ? 1 : 0);
    if(!(fullscreen == 0))
      set_fullscreen_props(this);

    else
      set_above(this, (signed int)this->stay_above);
    XMapRaised(this->display, this->window[(signed long int)(this->fullscreen != 0 ? 1 : 0)]);
    if(fullscreen == 0)
    {
      XResizeWindow(this->display, this->window[(signed long int)0], (unsigned int)this->_anon0.x.width, (unsigned int)this->_anon0.x.height);
      XMoveWindow(this->display, this->window[(signed long int)0], (signed int)this->_anon0.x.xpos, (signed int)this->_anon0.x.ypos);
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-sxfe]  ", "sxfe_display_config: XMoveWindow called with x=%d and y=%d", this->_anon0.x.xpos, this->_anon0.x.ypos);

      while((_Bool)0);
      this->check_move = (unsigned char)1;
      set_above(this, (signed int)this->stay_above);
    }

    else
    {
      set_fullscreen_props(this);
      XResizeWindow(this->display, this->window[(signed long int)1], (unsigned int)this->_anon0.x.width, (unsigned int)this->_anon0.x.height);
      XMoveWindow(this->display, this->window[(signed long int)1], (signed int)this->xinerama_x, (signed int)this->xinerama_y);
    }
    XSync(this->display, 0);
    signed int return_value_XTranslateCoordinates_2;
    return_value_XTranslateCoordinates_2=XTranslateCoordinates(this->display, this->window[(signed long int)(this->fullscreen != 0 ? 1 : 0)], this->root_window, 0, 0, &tmp_x, &tmp_y, &tmp_win);
    if(!(return_value_XTranslateCoordinates_2 == 0))
    {
      this->_anon0.x.xpos = (unsigned short int)tmp_x;
      this->_anon0.x.ypos = (unsigned short int)tmp_y;
    }

    XUnlockDisplay(this->display);
    xine_port_send_gui_data(this->_anon0.x.video_port, 2, (void *)this->window[(signed long int)(this->fullscreen != 0 ? 1 : 0)]);
  }

  this->_anon0.x.aspect = (unsigned char)aspect;
  this->_anon0.x.scale_video = (unsigned char)scale_video;
  return 1;
}

// sxfe_display_edid
// file xine_sxfe_frontend.c line 2570
static unsigned char * sxfe_display_edid(struct frontend_s *this_gen, signed int *size)
{
  struct sxfe_s *this = (struct sxfe_s *)this_gen;
  unsigned char *edid = (unsigned char *)(void *)0;
  return edid;
}

// sxfe_display_open
// file xine_sxfe_frontend.c line 2244
static signed int sxfe_display_open(struct frontend_s *this_gen, signed int xpos, signed int ypos, signed int width, signed int height, signed int fullscreen, signed int hud, signed int opengl, signed int modeswitch, const char *modeline, signed int aspect, signed int no_x_kbd, signed int gui_hotkeys, signed int touchscreen, const char *video_port, signed int scale_video, const char *aspect_controller, signed int window_id)
{
  struct sxfe_s *this = (struct sxfe_s *)this_gen;
  if(!(this->display == ((struct _XDisplay *)NULL)))
    this->_anon0.fe.fe_display_close(this_gen);

  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[vdr-sxfe]  ", "sxfe_display_open(width=%d, height=%d, fullscreen=%d, display=%s)", width, height, fullscreen, video_port);

  while((_Bool)0);
  pthread_mutex_init(&this->video_win_mutex, (const union anonymous_12 *)(void *)0);
  if(!(this->_anon0.fe.fe_message_cb == ((void (*)(void *, const char *, const char *))NULL)))
    this->_anon0.fe.fe_message_cb(this->_anon0.fe.fe_message_h, "XKeySym", "");

  this->osd_width = (unsigned short int)720;
  this->osd_height = (unsigned short int)576;
  if(!(opengl == 0))
  {
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[vdr-sxfe]  ", "sxfe_display_open: Using opengl to draw video and HUD OSD");

    while((_Bool)0);
    this->opengl_always = (unsigned char)1;
  }

  else
    if(!((0x4 & hud) == 0))
    {
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-sxfe]  ", "sxfe_display_open: Using opengl to draw HUD OSD only");

      while((_Bool)0);
      this->opengl_hud = (unsigned char)1;
    }

    else
      if(!(hud == 0))
      {
        do
          if(SysLogLevel >= 3)
            x_syslog(7, "[vdr-sxfe]  ", "sxfe_display_open: Enabling HUD OSD");

        while((_Bool)0);
        this->hud = (unsigned char)hud;
        this->xshape_hud = (unsigned char)!(!((hud & 0x2) != 0));
      }

  this->_anon0.x.xpos = (unsigned short int)xpos;
  this->_anon0.x.ypos = (unsigned short int)ypos;
  this->_anon0.x.width = (unsigned short int)width;
  this->_anon0.x.height = (unsigned short int)height;
  this->_anon0.x.aspect = (unsigned char)aspect;
  this->_anon0.x.overscan = (unsigned char)0;
  this->_anon0.x.scale_video = (unsigned char)scale_video;
  char *tmp_if_expr_2;
  char *return_value___strdup_1;
  if(!(aspect_controller == ((const char *)NULL)))
  {
    return_value___strdup_1=__strdup(aspect_controller);
    tmp_if_expr_2 = return_value___strdup_1;
  }

  else
    tmp_if_expr_2 = (char *)(void *)0;
  this->_anon0.x.aspect_controller = tmp_if_expr_2;
  this->video_win_active = (unsigned char)0;
  this->origxpos = (unsigned short int)0;
  this->origypos = (unsigned short int)0;
  this->origwidth = (unsigned short int)(width > 0 ? width : 720);
  this->origheight = (unsigned short int)(height > 0 ? height : 576);
  this->check_move = (unsigned char)0;
  this->dragging = (unsigned char)0;
  this->dragging_x = (unsigned short int)0;
  this->dragging_y = (unsigned short int)0;
  this->fullscreen = (unsigned char)fullscreen;
  this->fullscreen_state_forced = (unsigned char)0;
  this->window_id = window_id;
  this->xinerama_screen = -1;
  this->gui_hotkeys = (unsigned char)!(!(gui_hotkeys != 0));
  this->no_x_kbd = (unsigned char)!(!(no_x_kbd != 0));
  this->touchscreen = (unsigned char)!(!(touchscreen != 0));
  signed int return_value_XInitThreads_6;
  return_value_XInitThreads_6=XInitThreads();
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  _Bool tmp_if_expr_11;
  if(return_value_XInitThreads_6 == 0)
  {
    do
      if(SysLogLevel >= 1)
      {
        x_syslog(3, "[vdr-sxfe]  ", "sxfe_display_open: XInitThreads failed");
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        if(!(*return_value___errno_location_5 == 0))
        {
          return_value___errno_location_3=__errno_location();
          return_value_strerror_4=strerror(*return_value___errno_location_3);
          x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 2340, return_value_strerror_4);
        }

      }

    while((_Bool)0);
    free((void *)this);
    return 0;
  }

  else
  {
    signed int return_value_open_display_7;
    return_value_open_display_7=open_display(this, video_port);
    if(return_value_open_display_7 == 0)
      return 0;

    else
    {
      XLockDisplay(this->display);
      this->screen = ((struct anonymous_34 *)this->display)->default_screen;
      this->root_window = (&((struct anonymous_34 *)this->display)->screens[(signed long int)((struct anonymous_34 *)this->display)->default_screen])->root;
      this->xshm_completion_event = -1;
      signed int return_value_XShmQueryExtension_9;
      return_value_XShmQueryExtension_9=XShmQueryExtension(this->display);
      if(return_value_XShmQueryExtension_9 == 1)
      {
        signed int return_value_XShmGetEventBase_8;
        return_value_XShmGetEventBase_8=XShmGetEventBase(this->display);
        this->xshm_completion_event = return_value_XShmGetEventBase_8 + 0;
      }

      init_atoms(this);
      if(!(fullscreen == 0))
        update_screen_size(this);

      if(this->window_id == -2)
        this->window_id = (signed int)this->root_window;

      if(this->window_id >= 1)
      {
        do
          if(SysLogLevel >= 2)
            x_syslog(6, "[vdr-sxfe]  ", "sxfe_display_open(): Using X11 window %d for output", this->window_id);

        while((_Bool)0);
        this->window[(signed long int)1] = (unsigned long int)this->window_id;
        this->window[(signed long int)0] = this->window[(signed long int)1];
        XUnmapWindow(this->display, this->window[(signed long int)0]);
      }

      else
        create_windows(this);
      XSelectInput(this->display, this->window[(signed long int)0], 1L << 17 | 1L << 15 | 1L << 0 | 1L << 2 | 1L << 3 | 1L << 13 | 1L << 21 | 1L << 6);
      XSelectInput(this->display, this->window[(signed long int)1], 1L << 17 | 1L << 15 | 1L << 0 | 1L << 2 | 1L << 21 | 1L << 6);
      XSelectInput(this->display, this->root_window, 1L << 17);
      XMapRaised(this->display, this->window[(signed long int)!(!(this->fullscreen != 0))]);
      XMoveWindow(this->display, this->window[(signed long int)0], (signed int)this->_anon0.x.xpos, (signed int)this->_anon0.x.ypos);
      this->_anon0.x.display_ratio=detect_display_ratio(this->display, this->screen);
      XSetWMProtocols(this->display, this->window[(signed long int)(this->fullscreen != 0 ? 1 : 0)], &this->xa_WM_DELETE_WINDOW, 1);
      if(!(this->window_id >= 1))
      {
        set_cursor(this->display, this->window[(signed long int)(this->fullscreen != 0 ? 1 : 0)], 0);
        this->mousecursor_timeout = 0;
      }

      XSetScreenSaver(this->display, 0, 0, 2, 2);
      disable_DPMS(this);
      gnome_screensaver_control(0);
      this->_anon0.x.xine_visual_type = 1;
      this->_anon0.x._anon0.vis_x11.display = (void *)this->display;
      this->_anon0.x._anon0.vis_x11.screen = this->screen;
      this->_anon0.x._anon0.vis_x11.d = this->window[(signed long int)(this->fullscreen != 0 ? 1 : 0)];
      this->_anon0.x._anon0.vis_x11.dest_size_cb = sxfe_dest_size_cb;
      this->_anon0.x._anon0.vis_x11.frame_output_cb = this->_anon0.x.frame_output_handler;
      this->_anon0.x._anon0.vis_x11.user_data = (void *)this;
      set_fullscreen_props(this);
      XUnlockDisplay(this->display);
      if(!(this->opengl_always == 0))
        tmp_if_expr_11 = (_Bool)1;

      else
        tmp_if_expr_11 = this->opengl_hud != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_11)
      {
        signed int return_value_opengl_start_10;
        return_value_opengl_start_10=opengl_start(this);
        if(return_value_opengl_start_10 == 0)
          return 0;

      }

      signed int return_value_hud_osd_open_12;
      return_value_hud_osd_open_12=hud_osd_open(this);
      if(return_value_hud_osd_open_12 == 0)
        return 0;

      else
        return 1;
    }
  }
}

// sxfe_get_frontend
// file xine_sxfe_frontend.c line 3185
static struct frontend_s * sxfe_get_frontend(void)
{
  struct sxfe_s *this;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct sxfe_s) /*1160ul*/ );
  this = (struct sxfe_s *)return_value_calloc_1;
  init_fe((struct fe_s_0 *)this);
  this->window_id = -1;
  this->_anon0.fe.fe_display_open = sxfe_display_open;
  this->_anon0.fe.fe_display_config = sxfe_display_config;
  this->_anon0.fe.fe_display_edid = sxfe_display_edid;
  this->_anon0.fe.fe_display_close = sxfe_display_close;
  this->_anon0.fe.fe_run = sxfe_run;
  this->_anon0.fe.fe_interrupt = sxfe_interrupt;
  this->_anon0.x.toggle_fullscreen_cb = sxfe_toggle_fullscreen;
  this->fe_xine_open = this->_anon0.fe.xine_open;
  this->fe_xine_play = this->_anon0.fe.xine_play;
  this->_anon0.fe.xine_open = sxfe_xine_open;
  this->_anon0.fe.xine_play = sxfe_xine_play;
  return (struct frontend_s *)this;
}

// sxfe_interrupt
// file xine_sxfe_frontend.c line 2664
static void sxfe_interrupt(struct frontend_s *this_gen)
{
  struct sxfe_s *this = (struct sxfe_s *)this_gen;
  struct anonymous_62 event = { .type=33, .serial=0ul, .send_event=0, .display=this->display, .window=this->window[(signed long int)(this->fullscreen != 0 ? 1 : 0)],
    .message_type=this->xa_SXFE_INTERRUPT,
    .format=32,
    .data={ .l={ 0l, 0l, 0l, 0l, 0l } } };
  XLockDisplay(this->display);
  signed int return_value_XSendEvent_4;
  return_value_XSendEvent_4=XSendEvent(event.display, event.window, 1, (signed long int)0, (union _XEvent *)&event);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(return_value_XSendEvent_4 == 0)
    do
      if(SysLogLevel >= 1)
      {
        x_syslog(3, "[vdr-sxfe]  ", "sxfe_interrupt: XSendEvent(ClientMessage) FAILED\n");
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        if(!(*return_value___errno_location_3 == 0))
        {
          return_value___errno_location_1=__errno_location();
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          x_syslog(3, "[vdr-sxfe]  ", "   (ERROR (%s,%d): %s)", (const void *)"xine_sxfe_frontend.c", 2677, return_value_strerror_2);
        }

      }

    while((_Bool)0);

  XFlush(this->display);
  XUnlockDisplay(this->display);
}

// sxfe_run
// file xine_sxfe_frontend.c line 2957
static signed int sxfe_run(struct frontend_s *this_gen)
{
  struct sxfe_s *this = (struct sxfe_s *)this_gen;
  signed int return_value_XPending_3;
  return_value_XPending_3=XPending(this->display);
  if(return_value_XPending_3 == 0)
  {
    unsigned long int poll_time = (unsigned long int)0;
    const signed int poll_timeout = 50;
    struct pollfd pfd = { .fd=((struct anonymous_34 *)this->display)->fd, .events=(signed short int)0x001,
    .revents=0 };
    if(this->mousecursor_timeout >= 1)
      poll_time=time_ms();

    signed int return_value_poll_1;
    return_value_poll_1=poll(&pfd, (unsigned long int)1, poll_timeout);
    if((0x001 & (signed int)pfd.revents) == 0 || !(return_value_poll_1 >= 1))
    {
      if(this->mousecursor_timeout >= 1)
        check_mouse_cursor_hide(this, (signed long int)poll_timeout);

      signed int return_value;
      return_value=this->_anon0.x.fe.xine_is_finished((struct frontend_s *)this, 0);
      return (signed int)!(return_value != 0);
    }

    if(!(poll_time == 0ul))
    {
      unsigned long int return_value_elapsed_2;
      return_value_elapsed_2=elapsed(poll_time);
      check_mouse_cursor_hide(this, (signed long int)return_value_elapsed_2);
    }

  }

  signed int return_value_XPending_4;
  struct anonymous_62 *cmessage;
  do
  {
    return_value_XPending_4=XPending(this->display);
    if(!(return_value_XPending_4 >= 1))
      break;

    union _XEvent event;
    XLockDisplay(this->display);
    XNextEvent(this->display, &event);
    XUnlockDisplay(this->display);
    switch(event.type)
    {
      case 12:
      {
        if(event.xexpose.count == 0)
          xine_port_send_gui_data(this->_anon0.x.video_port, 3, (void *)&event);

        break;
      }
      case 22:
      {
        XConfigureEvent_handler(this, (struct anonymous_51 *)&event);
        break;
      }
      case 9:

      case 10:
      {
        hud_osd_focus(this, (struct anonymous_40 *)&event);
        break;
      }
      case 5:
      {
        this->dragging = (unsigned char)0;
        break;
      }
      case 6:
      {
        XMotionEvent_handler(this, (struct anonymous_38 *)&event);
        break;
      }
      case 4:
      {
        XButtonEvent_handler(this, (struct anonymous_37 *)&event);
        break;
      }
      case 2:

      case 3:
      {
        XKeyEvent_handler(this, (struct anonymous_36 *)&event);
        break;
      }
      case 33:
      {
        cmessage = (struct anonymous_62 *)&event;
        if(cmessage->message_type == this->xa_SXFE_INTERRUPT)
          do
            if(SysLogLevel >= 3)
              x_syslog(7, "[vdr-sxfe]  ", "ClientMessage: sxfe_interrupt");

          while((_Bool)0);

        if((unsigned long int)cmessage->data.l[0l] == this->xa_WM_DELETE_WINDOW)
        {
          do
            if(SysLogLevel >= 3)
              x_syslog(7, "[vdr-sxfe]  ", "ClientMessage: WM_DELETE_WINDOW");

          while((_Bool)0);
          this->_anon0.x.fe.send_event((struct frontend_s *)this, "QUIT");
        }

      }
    }
    if(event.type == this->xshm_completion_event)
      xine_port_send_gui_data(this->_anon0.x.video_port, 1, (void *)&event);

  }
  while((_Bool)1);
  signed int return_value_1;
  return_value_1=this->_anon0.x.fe.xine_is_finished((struct frontend_s *)this, 0);
  return (signed int)!(return_value_1 != 0);
}

// sxfe_toggle_fullscreen
// file xine_sxfe_frontend.c line 2542
static void sxfe_toggle_fullscreen(struct fe_s_0 *this_gen, signed int fullscreen)
{
  struct sxfe_s *this = (struct sxfe_s *)this_gen;
  signed int force = (signed int)this->fullscreen_state_forced;
  this->fullscreen_state_forced = (unsigned char)0;
  if(this->fullscreen == 0)
  {
    this->origwidth = this->_anon0.x.width;
    this->origheight = this->_anon0.x.height;
    this->origxpos = this->_anon0.x.xpos;
    this->origypos = this->_anon0.x.ypos;
  }

  else
  {
    this->_anon0.x.xpos = this->origxpos;
    this->_anon0.x.ypos = this->origypos;
  }
  if(!(fullscreen >= 0))
    fullscreen = (signed int)!(this->fullscreen != 0);

  this->_anon0.fe.fe_display_config((struct frontend_s *)this, -1, -1, (signed int)this->origwidth, (signed int)this->origheight, fullscreen, 0, (const char *)(void *)0, (signed int)this->_anon0.x.aspect, (signed int)this->_anon0.x.scale_video);
  this->fullscreen_state_forced = (unsigned char)!(force != 0);
}

// sxfe_xine_open
// file xine_sxfe_frontend.c line 3134
static signed int sxfe_xine_open(struct frontend_s *this_gen, const char *mrl)
{
  struct sxfe_s *this = (struct sxfe_s *)this_gen;
  signed int result;
  result=this->fe_xine_open(this_gen, mrl);
  signed int return_value_strncmp_6;
  char *return_value_strstr_5;
  _Bool tmp_if_expr_2;
  char *return_value___builtin_strchr_1;
  if(!(mrl == ((const char *)NULL)) && !(result == 0))
  {
    return_value_strncmp_6=strncmp(mrl, "xvdr", (unsigned long int)4);
    if(return_value_strncmp_6 == 0)
    {
      return_value_strstr_5=strstr(mrl, "//");
      if(!(return_value_strstr_5 == ((char *)NULL)))
      {
        char *name = (char *)(void *)0;
        char *end;
        char *return_value_strstr_3;
        return_value_strstr_3=strstr(mrl, "//");
        signed int return_value_asprintf_4;
        return_value_asprintf_4=asprintf(&name, "VDR - %s", return_value_strstr_3 + (signed long int)2);
        if(return_value_asprintf_4 >= 0)
        {
          end=strstr(name, ":37890");
          if(!(end == ((char *)NULL)))
            tmp_if_expr_2 = (_Bool)1;

          else
          {
            return_value___builtin_strchr_1=__builtin_strchr(name, 35);
            end = return_value___builtin_strchr_1;
            tmp_if_expr_2 = (char *)(void *)0 != end ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_2)
            *end = (char)0;

          XStoreName(this->display, this->window[(signed long int)0], name);
          XStoreName(this->display, this->window[(signed long int)1], name);
          free((void *)name);
        }

      }

    }

  }

  return result;
}

// sxfe_xine_play
// file xine_sxfe_frontend.c line 3155
static signed int sxfe_xine_play(struct frontend_s *this_gen)
{
  struct sxfe_s *this = (struct sxfe_s *)this_gen;
  signed int result;
  result=this->fe_xine_play(this_gen);
  _Bool tmp_if_expr_1;
  if(!(result == 0))
  {
    if(!(this->_anon0.x.input_plugin == ((struct vdr_input_plugin_if_s_0 *)NULL)))
    {
      if(!(this->hud == 0))
      {
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-sxfe]  ", "sxfe_xine_play: Enabling HUD OSD");

        this->_anon0.x.input_plugin->f.fe_handle = this_gen;
        this->_anon0.x.input_plugin->f.intercept_osd = hud_osd_command;
        this->_anon0.x.fe.send_event((struct frontend_s *)this, "INFO ARGBOSD");
      }

      if(!(this->opengl_always == 0))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = this->opengl_hud != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        if(SysLogLevel >= 3)
          x_syslog(7, "[vdr-sxfe]  ", "sxfe_xine_play: Enabling OpenGL OSD");

        this->_anon0.x.input_plugin->f.fe_handle = this_gen;
        this->_anon0.x.input_plugin->f.intercept_osd = opengl_osd_command;
        this->_anon0.x.fe.send_event((struct frontend_s *)this, "INFO ARGBOSD");
      }

    }

  }

  return result;
}

// syslog
// file /usr/include/x86_64-linux-gnu/bits/syslog.h line 29
static inline void syslog(signed int __pri, const char *__fmt, ...)
{
  void *return_value___builtin_va_arg_pack_1;
  return_value___builtin_va_arg_pack_1=__builtin_va_arg_pack();
  __syslog_chk(__pri, 2 - 1, __fmt, return_value___builtin_va_arg_pack_1);
}

// time_ms
// file tools/time_ms.h line 16
static unsigned long int time_ms(void)
{
  struct timeval t;
  signed int return_value_xine_monotonic_clock_1;
  return_value_xine_monotonic_clock_1=xine_monotonic_clock(&t, (struct timezone *)(void *)0);
  if(return_value_xine_monotonic_clock_1 == 0)
    return (unsigned long int)t.tv_sec * 1000ULL + (unsigned long int)t.tv_usec / 1000ULL;

  else
    return (unsigned long int)0;
}

// time_ms_link1
// file tools/time_ms.h line 16
static unsigned long int time_ms_link1(void)
{
  struct timeval t_link1;
  signed int return_value_gettimeofday_1;
  return_value_gettimeofday_1=gettimeofday(&t_link1, (struct timezone *)(void *)0);
  if(return_value_gettimeofday_1 == 0)
    return (unsigned long int)t_link1.tv_sec * 1000ULL + (unsigned long int)t_link1.tv_usec / 1000ULL;

  else
    return (unsigned long int)0;
}

// udp_discovery_broadcast
// file tools/vdrdiscovery.c line 105
signed int udp_discovery_broadcast(signed int fd_discovery, signed int server_port, const char *server_address)
{
  char *msg = (char *)(void *)0;
  signed int result;
  _Bool tmp_if_expr_1;
  if(!(server_address == ((const char *)NULL)))
    tmp_if_expr_1 = *server_address != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    result=asprintf_link3(&msg, "VDR xineliboutput DISCOVERY 1.0\r\nServer port: %d\r\nServer address: %s\r\nServer version: xineliboutput-2.0.0-cvs\r\n\r\n", server_port, server_address);

  else
    result=asprintf_link3(&msg, "VDR xineliboutput DISCOVERY 1.0\r\nServer port: %d\r\nServer version: xineliboutput-2.0.0-cvs\r\n\r\n", server_port);
  if(result >= 0)
  {
    result=udp_discovery_send(fd_discovery, 37890, msg);
    free((void *)msg);
  }

  return result;
}

// udp_discovery_find_server
// file tools/vdrdiscovery.h line 35
signed int udp_discovery_find_server(signed int *port, char *address)
{
  struct sockaddr_in from;
  char buf[1024l];
  signed int fd_discovery = -1;
  signed int trycount = 0;
  signed int err = 0;
  *port = 37890;
  strcpy_link2(address, "vdr");
  fd_discovery=discovery_init(37890);
  if(!(fd_discovery >= 0))
    return 0;

  else
  {
    while(err >= 0)
    {
      trycount = trycount + 1;
      if(trycount >= 4)
        break;

      signed int return_value_udp_discovery_search_8;
      return_value_udp_discovery_search_8=udp_discovery_search(fd_discovery, 37890);
      err = (signed int)(return_value_udp_discovery_search_8 >= 0);
      if(!(err == 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 0;
        do
        {
          err=udp_discovery_recv(fd_discovery, buf, 500, &from);
          if(!(err >= 1))
            break;

          unsigned int tmp;
          tmp=__bswap_32(from.sin_addr.s_addr);
          buf[(signed long int)err] = (char)0;
          do
            if(SysLogLevel >= 3)
              x_syslog(7, "[discovery] ", "Reveived broadcast: %d bytes from %d.%d.%d.%d \n%s", err, tmp >> 24 & (unsigned int)0xff, tmp >> 16 & (unsigned int)0xff, tmp >> 8 & (unsigned int)0xff, tmp & (unsigned int)0xff, (const void *)buf);

          while((_Bool)0);
          unsigned long int return_value_strlen_6;
          static const char mystring[47l] = { 'V', 'D', 'R', ' ', 'x', 'i', 'n', 'e', 'l', 'i', 'b', 'o', 'u', 't', 'p', 'u', 't', ' ', 'D', 'I', 'S', 'C', 'O', 'V', 'E', 'R', 'Y', ' ', '1', '.', '0', '\r', '\n', 'S', 'e', 'r', 'v', 'e', 'r', ' ', 'p', 'o', 'r', 't', ':', ' ', 0 };
          return_value_strlen_6=strlen(mystring);
          signed int return_value_strncmp_7;
          return_value_strncmp_7=strncmp(mystring, buf, return_value_strlen_6);
          if(return_value_strncmp_7 == 0)
          {
            char *iploc;
            do
              if(SysLogLevel >= 3)
                x_syslog(7, "[discovery] ", "Valid discovery message");

            while((_Bool)0);
            close(fd_discovery);
            sprintf_link2(address, "%d.%d.%d.%d", tmp >> 24 & (unsigned int)0xff, tmp >> 16 & (unsigned int)0xff, tmp >> 8 & (unsigned int)0xff, tmp & (unsigned int)0xff);
            unsigned long int return_value_strlen_2;
            return_value_strlen_2=strlen(mystring);
            iploc=strstr(buf + (signed long int)return_value_strlen_2, "Server address: ");
            if(!(iploc == ((char *)NULL)))
            {
              unsigned int svraddr;
              unsigned long int return_value_strlen_3;
              return_value_strlen_3=strlen("Server address: ");
              iploc = iploc + (signed long int)return_value_strlen_3;
              svraddr=inet_addr(iploc);
              if(svraddr == 0u || svraddr == 0xffffffff)
                do
                  if(SysLogLevel >= 2)
                    x_syslog(6, "[discovery] ", "Server provided invalid address !");

                while((_Bool)0);

              else
              {
                svraddr=__bswap_32(svraddr);
                sprintf_link2(address, "%d.%d.%d.%d", svraddr >> 24 & (unsigned int)0xff, svraddr >> 16 & (unsigned int)0xff, svraddr >> 8 & (unsigned int)0xff, svraddr & (unsigned int)0xff);
                do
                  if(SysLogLevel >= 2)
                    x_syslog(6, "[discovery] ", "Replacing broadcast source address %d.%d.%d.%d with server-given address %s", tmp >> 24 & (unsigned int)0xff, tmp >> 16 & (unsigned int)0xff, tmp >> 8 & (unsigned int)0xff, tmp & (unsigned int)0xff, address);

                while((_Bool)0);
              }
            }

            *port = -1;
            unsigned long int return_value_strlen_4;
            return_value_strlen_4=strlen(mystring);
            signed int return_value_sscanf_5;
            return_value_sscanf_5=sscanf(buf + (signed long int)return_value_strlen_4, "%d", port);
            if(return_value_sscanf_5 == 1)
            {
              if(*port >= 1000)
              {
                if(!(*port >= 65536))
                  return 1;

              }

            }

            do
              if(SysLogLevel >= 2)
                x_syslog(6, "[discovery] ", "Server-given port is invalid !");

            while((_Bool)0);
          }

          else
            do
              if(SysLogLevel >= 3)
                x_syslog(7, "[discovery] ", "NOT valid discovery message");

            while((_Bool)0);
        }
        while((_Bool)1);
      }

    }
    close(fd_discovery);
    return 0;
  }
}

// udp_discovery_init
// file tools/vdrdiscovery.c line 81
signed int udp_discovery_init(void)
{
  signed int return_value_discovery_init_1;
  return_value_discovery_init_1=discovery_init(37890);
  return return_value_discovery_init_1;
}

// udp_discovery_is_valid_search
// file tools/vdrdiscovery.c line 185
signed int udp_discovery_is_valid_search(const char *buf)
{
  unsigned long int return_value_strlen_1;
  static const char id_string[41l] = { 'V', 'D', 'R', ' ', 'x', 'i', 'n', 'e', 'l', 'i', 'b', 'o', 'u', 't', 'p', 'u', 't', ' ', 'D', 'I', 'S', 'C', 'O', 'V', 'E', 'R', 'Y', ' ', '1', '.', '0', '\r', '\n', 'C', 'l', 'i', 'e', 'n', 't', ':', 0 };
  return_value_strlen_1=strlen(id_string);
  signed int return_value_strncmp_2;
  return_value_strncmp_2=strncmp(id_string, buf, return_value_strlen_1);
  if(return_value_strncmp_2 == 0)
  {
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[discovery] ", "Received valid discovery message %s", buf);

    while((_Bool)0);
    return 1;
  }

  else
  {
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[discovery] ", "BROADCAST: %s", buf);

    while((_Bool)0);
    return 0;
  }
}

// udp_discovery_recv
// file tools/vdrdiscovery.c line 155
signed int udp_discovery_recv(signed int fd_discovery, char *buf, signed int timeout, struct sockaddr_in *source)
{
  unsigned int sourcelen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  struct pollfd pfd;
  signed int err;
  pfd.fd = fd_discovery;
  pfd.events = (signed short int)0x001;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  err=poll_link2(&pfd, (unsigned long int)1, timeout);
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  if(!(err >= 1))
  {
    if(!(err >= 0))
      do
        if(SysLogLevel >= 1)
        {
          x_syslog(3, "[discovery] ", "broadcast poll error");
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          if(!(*return_value___errno_location_4 == 0))
          {
            return_value___errno_location_2=__errno_location();
            return_value_strerror_3=strerror(*return_value___errno_location_2);
            x_syslog(3, "[discovery] ", "   (ERROR (%s,%d): %s)", (const void *)"tools/vdrdiscovery.c", 169, return_value_strerror_3);
          }

        }

      while((_Bool)0);

    return err;
  }

  else
  {
    memset_link1((void *)source, 0, (unsigned long int)sourcelen);
    memset_link1((void *)buf, 0, (unsigned long int)1024);
    signed long int return_value_recvfrom_5;
    return_value_recvfrom_5=recvfrom(fd_discovery, (void *)buf, (unsigned long int)(1024 - 1), 0, (struct sockaddr *)source, &sourcelen);
    err = (signed int)return_value_recvfrom_5;
    if(!(err >= 1))
      do
        if(SysLogLevel >= 3)
          x_syslog(7, "[discovery] ", "fd_discovery recvfrom() error");

      while((_Bool)0);

    return err;
  }
}

// udp_discovery_search
// file tools/vdrdiscovery.c line 135
static inline signed int udp_discovery_search(signed int fd_discovery, signed int port)
{
  char *msg = (char *)(void *)0;
  signed int result;
  result=asprintf_link3(&msg, "VDR xineliboutput DISCOVERY 1.0\r\nClient: %s:%d\r\n\r\n", (const void *)"255.255.255.255", port);
  if(result >= 0)
  {
    result=udp_discovery_send(fd_discovery, port, msg);
    free((void *)msg);
  }

  return result;
}

// udp_discovery_send
// file tools/vdrdiscovery.c line 86
static inline signed int udp_discovery_send(signed int fd_discovery, signed int port, char *msg)
{
  struct sockaddr_in sin;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(msg);
  len = (signed int)return_value_strlen_1;
  sin.sin_family = (unsigned short int)2;
  unsigned short int tmp_statement_expression_2;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)port;
  asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression_2 = __v;
  sin.sin_port = tmp_statement_expression_2;
  sin.sin_addr.s_addr = (unsigned int)0xffffffff;
  signed long int return_value_sendto_6;
  return_value_sendto_6=sendto(fd_discovery, (const void *)msg, (unsigned long int)len, 0, (struct sockaddr *)&sin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  if(!((signed long int)len == return_value_sendto_6))
  {
    do
      if(SysLogLevel >= 1)
      {
        x_syslog(3, "[discovery] ", "UDP broadcast send failed (discovery)");
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        if(!(*return_value___errno_location_5 == 0))
        {
          return_value___errno_location_3=__errno_location();
          return_value_strerror_4=strerror(*return_value___errno_location_3);
          x_syslog(3, "[discovery] ", "   (ERROR (%s,%d): %s)", (const void *)"tools/vdrdiscovery.c", 97, return_value_strerror_4);
        }

      }

    while((_Bool)0);
    return -1;
  }

  else
    return 0;
}

// unwire_video_driver
// file xine/vo_hook.c line 182
signed int unwire_video_driver(struct xine_video_port_s *video_port, struct vo_driver_s *hook_gen, struct vo_driver_s *video_out)
{
  struct driver_hook_s *hook = (struct driver_hook_s *)hook_gen;
  struct driver_hook_s *next = (struct driver_hook_s *)video_port->driver;
  if(next == hook)
  {
    video_port->driver = next->orig_driver;
    ((struct anonymous_79 *)video_port)->driver = next->orig_driver;
    next->orig_driver = (struct vo_driver_s *)(void *)0;
    return 1;
  }

  else
  {
    struct driver_hook_s *prev = next;
    for( ; !(next == ((struct driver_hook_s *)NULL)) && !(next == hook) && !((struct vo_driver_s *)next == video_out); next = (struct driver_hook_s *)next->orig_driver)
      prev = next;
    if(next == hook && !(prev == ((struct driver_hook_s *)NULL)))
    {
      prev->orig_driver = next->orig_driver;
      next->orig_driver = (struct vo_driver_s *)(void *)0;
      return 1;
    }

    else
      return 0;
  }
}

// update_mask
// file xine_sxfe_frontend.c line 825
static void update_mask(unsigned int *dst, signed int dst_pitch, unsigned int *mask, signed int mask_pitch, signed int *mask_changed, struct osd_command_s *cmd)
{
  unsigned int x;
  unsigned int y;
  *mask_changed = 0;
  dst = dst + (signed long int)(dst_pitch * (signed int)cmd->y + (signed int)cmd->x);
  mask = mask + (signed long int)(mask_pitch * (signed int)cmd->y + (signed int)cmd->x);
  y = (unsigned int)0;
  for( ; !(y >= (unsigned int)cmd->h); y = y + 1u)
  {
    x = (unsigned int)0;
    for( ; !(x >= (unsigned int)cmd->w); x = x + 1u)
      if(!(mask[(signed long int)x] == dst[(signed long int)x]))
      {
        *mask_changed = 1;
        mask[(signed long int)x] = dst[(signed long int)x];
      }

    dst = dst + (signed long int)dst_pitch;
    mask = mask + (signed long int)mask_pitch;
  }
}

// update_screen_size
// file xine_sxfe_frontend.c line 585
static void update_screen_size(struct sxfe_s *this)
{
  XLockDisplay(this->display);
  this->_anon0.x.width = (unsigned short int)(&((struct anonymous_34 *)this->display)->screens[(signed long int)this->screen])->width;
  this->_anon0.x.height = (unsigned short int)(&((struct anonymous_34 *)this->display)->screens[(signed long int)this->screen])->height;
  XUnlockDisplay(this->display);
  update_xinerama_info(this);
}

// update_window_title
// file xine_sxfe_frontend.c line 390
static void update_window_title(struct sxfe_s *this)
{
  XLockDisplay(this->display);
  char *return_value_strstr_1;
  signed int return_value_asprintf_3;
  if(this->_anon0.fe.fe_message_cb == ((void (*)(void *, const char *, const char *))NULL))
  {
    char *name = (char *)(void *)0;
    signed int return_value_XFetchName_4;
    return_value_XFetchName_4=XFetchName(this->display, this->window[(signed long int)0], &name);
    if(!(name == ((char *)NULL)) && !(return_value_XFetchName_4 == 0))
    {
      char *newname = (char *)(void *)0;
      char *return_value_strstr_2;
      return_value_strstr_2=strstr(name, " (top)");
      if(!(return_value_strstr_2 == ((char *)NULL)))
      {
        return_value_strstr_1=strstr(name, " (top)");
        *return_value_strstr_1 = (char)0;
      }

      if(!(this->stay_above == 0))
      {
        return_value_asprintf_3=asprintf(&newname, "%s (top)", name);
        if(!(return_value_asprintf_3 >= 0))
          newname = (char *)(void *)0;

      }

      XStoreName(this->display, this->window[(signed long int)0], (_Bool)newname ? newname : name);
      XStoreName(this->display, this->window[(signed long int)1], (_Bool)newname ? newname : name);
      XFree((void *)name);
      free((void *)newname);
    }

    else
    {
      XStoreName(this->display, this->window[(signed long int)0], this->stay_above != 0 ? "VDR - (top)" : "VDR");
      XStoreName(this->display, this->window[(signed long int)1], this->stay_above != 0 ? "VDR - (top)" : "VDR");
    }
  }

  else
  {
    XStoreName(this->display, this->window[(signed long int)0], this->stay_above != 0 ? "Local VDR (top)" : "Local VDR");
    XStoreName(this->display, this->window[(signed long int)1], this->stay_above != 0 ? "Local VDR (top)" : "Local VDR");
  }
  XUnlockDisplay(this->display);
}

// update_xinerama_info
// file xine_sxfe_frontend.c line 543
static void update_xinerama_info(struct sxfe_s *this)
{
  signed int screen = this->xinerama_screen;
  this->xinerama_y = (unsigned short int)0;
  this->xinerama_x = this->xinerama_y;
  XLockDisplay(this->display);
  signed int return_value_XineramaIsActive_1;
  if(screen >= -1)
  {
    return_value_XineramaIsActive_1=XineramaIsActive(this->display);
    if(!(return_value_XineramaIsActive_1 == 0))
    {
      struct anonymous_90 *screens;
      signed int num_screens;
      screens=XineramaQueryScreens(this->display, &num_screens);
      if(screen >= num_screens)
        screen = num_screens - 1;

      if(screen == -1)
      {
        const signed int x = (signed int)this->origxpos + (signed int)this->origwidth / 2;
        const signed int y = (signed int)this->origypos + (signed int)this->origheight / 2;
        screen = num_screens - 1;
        for( ; screen >= 1; screen = screen - 1)
        {
          const signed int x0 = (const signed int)(screens + (signed long int)screen)->x_org;
          const signed int y0 = (const signed int)(screens + (signed long int)screen)->y_org;
          const signed int x1 = x0 + (signed int)(screens + (signed long int)screen)->width;
          const signed int y1 = y0 + (signed int)(screens + (signed long int)screen)->height;
          if(x1 >= x && y1 >= y && x >= x0 && y >= y0)
            break;

        }
      }

      if(!(screen >= 0))
        screen = 0;

      this->xinerama_x = (unsigned short int)(screens + (signed long int)screen)->x_org;
      this->xinerama_y = (unsigned short int)(screens + (signed long int)screen)->y_org;
      this->_anon0.x.width = (unsigned short int)(screens + (signed long int)screen)->width;
      this->_anon0.x.height = (unsigned short int)(screens + (signed long int)screen)->height;
      XFree((void *)screens);
    }

  }

  XUnlockDisplay(this->display);
}

// vo_def_alloc_frame
// file xine/vo_hook.c line 62
struct vo_frame_s * vo_def_alloc_frame(struct vo_driver_s *self)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  struct vo_frame_s *return_value;
  return_value=this->orig_driver->alloc_frame(this->orig_driver);
  return return_value;
}

// vo_def_display_frame
// file xine/vo_hook.c line 72
void vo_def_display_frame(struct vo_driver_s *self, struct vo_frame_s *a1)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  this->orig_driver->display_frame(this->orig_driver, a1);
}

// vo_def_dispose
// file xine/vo_hook.c line 85
void vo_def_dispose(struct vo_driver_s *self)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  if(!(this->orig_driver == ((struct vo_driver_s *)NULL)))
    this->orig_driver->dispose(this->orig_driver);

  free((void *)self);
}

// vo_def_get_capabilities
// file xine/vo_hook.c line 61
unsigned int vo_def_get_capabilities(struct vo_driver_s *self)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  unsigned int return_value;
  return_value=this->orig_driver->get_capabilities(this->orig_driver);
  return return_value;
}

// vo_def_get_property
// file xine/vo_hook.c line 76
signed int vo_def_get_property(struct vo_driver_s *self, signed int a1)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  signed int return_value;
  return_value=this->orig_driver->get_property(this->orig_driver, a1);
  return return_value;
}

// vo_def_get_property_min_max
// file xine/vo_hook.c line 78
void vo_def_get_property_min_max(struct vo_driver_s *self, signed int a1, signed int *a2, signed int *a3)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  this->orig_driver->get_property_min_max(this->orig_driver, a1, a2, a3);
}

// vo_def_gui_data_exchange
// file xine/vo_hook.c line 79
signed int vo_def_gui_data_exchange(struct vo_driver_s *self, signed int a1, void *a2)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  signed int return_value;
  return_value=this->orig_driver->gui_data_exchange(this->orig_driver, a1, a2);
  return return_value;
}

// vo_def_new_grab_video_frame
// file xine/vo_hook.c line 82
struct xine_grab_video_frame_s * vo_def_new_grab_video_frame(struct vo_driver_s *self)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  struct xine_grab_video_frame_s *return_value;
  return_value=this->orig_driver->new_grab_video_frame(this->orig_driver);
  return return_value;
}

// vo_def_overlay_begin
// file xine/vo_hook.c line 73
void vo_def_overlay_begin(struct vo_driver_s *self, struct vo_frame_s *a1, signed int a2)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  this->orig_driver->overlay_begin(this->orig_driver, a1, a2);
}

// vo_def_overlay_blend
// file xine/vo_hook.c line 74
void vo_def_overlay_blend(struct vo_driver_s *self, struct vo_frame_s *a1, struct vo_overlay_s *a2)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  this->orig_driver->overlay_blend(this->orig_driver, a1, a2);
}

// vo_def_overlay_end
// file xine/vo_hook.c line 75
void vo_def_overlay_end(struct vo_driver_s *self, struct vo_frame_s *a1)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  this->orig_driver->overlay_end(this->orig_driver, a1);
}

// vo_def_redraw_needed
// file xine/vo_hook.c line 80
signed int vo_def_redraw_needed(struct vo_driver_s *self)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  signed int return_value;
  return_value=this->orig_driver->redraw_needed(this->orig_driver);
  return return_value;
}

// vo_def_set_property
// file xine/vo_hook.c line 77
signed int vo_def_set_property(struct vo_driver_s *self, signed int a1, signed int a2)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  signed int return_value;
  return_value=this->orig_driver->set_property(this->orig_driver, a1, a2);
  return return_value;
}

// vo_def_update_frame_format
// file xine/vo_hook.c line 64
void vo_def_update_frame_format(struct vo_driver_s *self, struct vo_frame_s *img, unsigned int width, unsigned int height, double ratio, signed int format, signed int flags)
{
  struct driver_hook_s *this = (struct driver_hook_s *)self;
  this->orig_driver->update_frame_format(this->orig_driver, img, width, height, ratio, format, flags);
}

// vo_frameoutput_init
// file xine/vo_frameoutput.c line 61
struct vo_driver_s * vo_frameoutput_init(void *handle, void (*cb)(void *, struct vo_frame_s *))
{
  struct anonymous_84 *this;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_84) /*144ul*/ );
  this = (struct anonymous_84 *)return_value_calloc_1;
  this->h.vo.display_frame = display_frame;
  this->handle = handle;
  this->cb = cb;
  return &this->h.vo;
}

// vo_lastpts_init
// file xine/vo_lastpts.c line 99
struct vo_driver_s * vo_lastpts_init(void)
{
  struct anonymous_83 *this;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_83) /*152ul*/ );
  this = (struct anonymous_83 *)return_value_calloc_1;
  this->h.vo.display_frame = lastpts_display_frame;
  return &this->h.vo;
}

// vo_proxy_hooks_init
// file xine/vo_hook.c line 99
static void vo_proxy_hooks_init(struct vo_driver_s *drv, struct vo_driver_s *next_driver)
{
  unsigned int (*tmp_if_expr_1)(struct vo_driver_s *);
  if(!(drv->get_capabilities == ((unsigned int (*)(struct vo_driver_s *))NULL)))
    tmp_if_expr_1 = drv->get_capabilities;

  else
    tmp_if_expr_1 = vo_def_get_capabilities;
  drv->get_capabilities = tmp_if_expr_1;
  struct vo_frame_s * (*tmp_if_expr_2)(struct vo_driver_s *);
  if(!(drv->alloc_frame == ((struct vo_frame_s * (*)(struct vo_driver_s *))NULL)))
    tmp_if_expr_2 = drv->alloc_frame;

  else
    tmp_if_expr_2 = vo_def_alloc_frame;
  drv->alloc_frame = tmp_if_expr_2;
  void (*tmp_if_expr_3)(struct vo_driver_s *, struct vo_frame_s *, unsigned int, unsigned int, double, signed int, signed int);
  if(!(drv->update_frame_format == ((void (*)(struct vo_driver_s *, struct vo_frame_s *, unsigned int, unsigned int, double, signed int, signed int))NULL)))
    tmp_if_expr_3 = drv->update_frame_format;

  else
    tmp_if_expr_3 = vo_def_update_frame_format;
  drv->update_frame_format = tmp_if_expr_3;
  void (*tmp_if_expr_4)(struct vo_driver_s *, struct vo_frame_s *);
  if(!(drv->display_frame == ((void (*)(struct vo_driver_s *, struct vo_frame_s *))NULL)))
    tmp_if_expr_4 = drv->display_frame;

  else
    tmp_if_expr_4 = vo_def_display_frame;
  drv->display_frame = tmp_if_expr_4;
  signed int (*tmp_if_expr_5)(struct vo_driver_s *, signed int);
  if(!(drv->get_property == ((signed int (*)(struct vo_driver_s *, signed int))NULL)))
    tmp_if_expr_5 = drv->get_property;

  else
    tmp_if_expr_5 = vo_def_get_property;
  drv->get_property = tmp_if_expr_5;
  signed int (*tmp_if_expr_6)(struct vo_driver_s *, signed int, signed int);
  if(!(drv->set_property == ((signed int (*)(struct vo_driver_s *, signed int, signed int))NULL)))
    tmp_if_expr_6 = drv->set_property;

  else
    tmp_if_expr_6 = vo_def_set_property;
  drv->set_property = tmp_if_expr_6;
  void (*tmp_if_expr_7)(struct vo_driver_s *, signed int, signed int *, signed int *);
  if(!(drv->get_property_min_max == ((void (*)(struct vo_driver_s *, signed int, signed int *, signed int *))NULL)))
    tmp_if_expr_7 = drv->get_property_min_max;

  else
    tmp_if_expr_7 = vo_def_get_property_min_max;
  drv->get_property_min_max = tmp_if_expr_7;
  signed int (*tmp_if_expr_8)(struct vo_driver_s *, signed int, void *);
  if(!(drv->gui_data_exchange == ((signed int (*)(struct vo_driver_s *, signed int, void *))NULL)))
    tmp_if_expr_8 = drv->gui_data_exchange;

  else
    tmp_if_expr_8 = vo_def_gui_data_exchange;
  drv->gui_data_exchange = tmp_if_expr_8;
  signed int (*tmp_if_expr_9)(struct vo_driver_s *);
  if(!(drv->redraw_needed == ((signed int (*)(struct vo_driver_s *))NULL)))
    tmp_if_expr_9 = drv->redraw_needed;

  else
    tmp_if_expr_9 = vo_def_redraw_needed;
  drv->redraw_needed = tmp_if_expr_9;
  void (*tmp_if_expr_10)(struct vo_driver_s *);
  if(!(drv->dispose == ((void (*)(struct vo_driver_s *))NULL)))
    tmp_if_expr_10 = drv->dispose;

  else
    tmp_if_expr_10 = vo_def_dispose;
  drv->dispose = tmp_if_expr_10;
  if(drv->new_grab_video_frame == ((struct xine_grab_video_frame_s * (*)(struct vo_driver_s *))NULL))
  {
    if(!(next_driver->new_grab_video_frame == ((struct xine_grab_video_frame_s * (*)(struct vo_driver_s *))NULL)))
      drv->new_grab_video_frame = vo_def_new_grab_video_frame;

  }

  if(drv->overlay_begin == vo_def_overlay_begin)
    drv->overlay_begin = (void (*)(struct vo_driver_s *, struct vo_frame_s *, signed int))(void *)0;

  if(drv->overlay_blend == vo_def_overlay_blend)
    drv->overlay_blend = (void (*)(struct vo_driver_s *, struct vo_frame_s *, struct vo_overlay_s *))(void *)0;

  if(drv->overlay_end == vo_def_overlay_end)
    drv->overlay_end = (void (*)(struct vo_driver_s *, struct vo_frame_s *))(void *)0;

  if(drv->overlay_begin == ((void (*)(struct vo_driver_s *, struct vo_frame_s *, signed int))NULL))
  {
    if(!(next_driver->overlay_begin == ((void (*)(struct vo_driver_s *, struct vo_frame_s *, signed int))NULL)))
      drv->overlay_begin = vo_def_overlay_begin;

  }

  if(drv->overlay_blend == ((void (*)(struct vo_driver_s *, struct vo_frame_s *, struct vo_overlay_s *))NULL))
  {
    if(!(next_driver->overlay_blend == ((void (*)(struct vo_driver_s *, struct vo_frame_s *, struct vo_overlay_s *))NULL)))
      drv->overlay_blend = vo_def_overlay_blend;

  }

  if(drv->overlay_end == ((void (*)(struct vo_driver_s *, struct vo_frame_s *))NULL))
  {
    if(!(next_driver->overlay_end == ((void (*)(struct vo_driver_s *, struct vo_frame_s *))NULL)))
      drv->overlay_end = vo_def_overlay_end;

  }

  drv->node = next_driver->node;
}

// vpplugin_disable_post
// file xine/post.c line 796
signed int vpplugin_disable_post(struct post_plugins_s_0 *fe, const char *name)
{
  signed int return_value__pplugin_disable_post_1;
  return_value__pplugin_disable_post_1=_pplugin_disable_post(fe, name, fe->post_video_elements, fe->post_video_elements_num);
  _Bool tmp_if_expr_3;
  signed int return_value__pplugin_disable_post_2;
  if(!(return_value__pplugin_disable_post_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value__pplugin_disable_post_2=_pplugin_disable_post(fe, name, fe->post_pip_elements, fe->post_pip_elements_num);
    tmp_if_expr_3 = return_value__pplugin_disable_post_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    _vpplugin_unwire(fe);
    return 1;
  }

  else
    return 0;
}

// vpplugin_enable_post
// file xine/post.c line 723
signed int vpplugin_enable_post(struct post_plugins_s_0 *fe, const char *initstr, signed int *found)
{
  char *name;
  name=_pp_name_strdup(initstr);
  const char *args;
  args=_pp_args(initstr);
  signed int result;
  result=_vpplugin_enable_post(fe, name, args, found);
  do
    if(SysLogLevel >= 3)
      x_syslog(7, "[xine-post] ", "  * enable post %s --> %s, %s", name, *found != 0 ? "found" : "not found", result != 0 ? "enabled" : "no action");

  while((_Bool)0);
  if(*found == 0)
  {
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[xine-post] ", "  * loading post %s", initstr);

    while((_Bool)0);
    vpplugin_parse_and_store_post(fe, initstr);
    result=_vpplugin_enable_post(fe, name, (const char *)(void *)0, found);
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[xine-post] ", "  * enable post %s --> %s, %s", name, *found != 0 ? "found" : "not found", result != 0 ? "enabled" : "no action");

    while((_Bool)0);
  }

  if(!(result == 0))
    _vpplugin_unwire(fe);

  free((void *)name);
  return result;
}

// vpplugin_parse_and_store_post
// file xine/post.c line 377
void vpplugin_parse_and_store_post(struct post_plugins_s_0 *fe, const char *post_chain)
{
  pplugin_parse_and_store_post(fe, 0x010000, post_chain);
  pplugin_parse_and_store_post(fe, 0x010002, post_chain);
}

// vpplugin_rewire_posts
// file xine/post.c line 628
void vpplugin_rewire_posts(struct post_plugins_s_0 *fe)
{
  _vpplugin_unwire(fe);
  _vpplugin_rewire(fe);
}

// vpplugin_unload_post
// file xine/post.c line 873
signed int vpplugin_unload_post(struct post_plugins_s_0 *fe, const char *name)
{
  signed int result;
  result=vpplugin_disable_post(fe, name);
  _pplugin_unload_post(fe, name, &fe->post_video_elements, &fe->post_video_elements_num);
  _pplugin_unload_post(fe, name, &fe->post_pip_elements, &fe->post_pip_elements_num);
  return result;
}

// vsnprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 74
static inline signed int vsnprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, void **__ap)
{
  signed int return_value___builtin___vsnprintf_chk_1;
  return_value___builtin___vsnprintf_chk_1=__builtin___vsnprintf_chk(__s, __n, 2 - 1, 18446744073709551615ul, __fmt, __ap);
  return return_value___builtin___vsnprintf_chk_1;
}

// wire_video_driver
// file xine/vo_hook.c line 152
signed int wire_video_driver(struct xine_video_port_s *video_port, struct vo_driver_s *hook)
{
  struct vo_driver_s *vos_driver = ((struct anonymous_79 *)video_port)->driver;
  if(!(video_port->driver == vos_driver))
  {
    do
      if(SysLogLevel >= 2)
        x_syslog(6, "[xine-vo  ] ", "wire_video_driver() FAILED (vo_driver != vos_driver)");

    while((_Bool)0);
    return 0;
  }

  else
  {
    vo_proxy_hooks_init(hook, video_port->driver);
    ((struct driver_hook_s *)hook)->orig_driver = video_port->driver;
    video_port->driver = hook;
    ((struct anonymous_79 *)video_port)->driver = hook;
    return 1;
  }
}

// write_rle_hdmv
// file tools/rle.c line 210
static unsigned char * write_rle_hdmv(unsigned char *rle_data, unsigned int color, unsigned int len)
{
  unsigned char *tmp_post_1;
  if(!(color == 0u) && !(len >= 4u))
  {
    unsigned int i = (unsigned int)0;
    for( ; !(i >= len); i = i + 1u)
    {
      tmp_post_1 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post_1 = (unsigned char)color;
    }
    return rle_data;
  }

  unsigned char *tmp_post_2 = rle_data;
  rle_data = rle_data + 1l;
  *tmp_post_2 = (unsigned char)0;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  if(color == 0u)
  {
    if(!(len >= 64u))
    {
      tmp_post_3 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post_3 = (unsigned char)len;
    }

    else
    {
      tmp_post_4 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post_4 = (unsigned char)((unsigned int)0x40 | len >> 8 & (unsigned int)0x3f);
      tmp_post_5 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post_5 = (unsigned char)(len & (unsigned int)0xff);
    }
  }

  else
  {
    if(!(len >= 64u))
    {
      tmp_post_6 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post_6 = (unsigned char)((unsigned int)0x80 | len);
    }

    else
    {
      tmp_post_7 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post_7 = (unsigned char)((unsigned int)(0x80 | 0x40) | len >> 8 & (unsigned int)0x3f);
      tmp_post_8 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post_8 = (unsigned char)(len & (unsigned int)0xff);
    }
    tmp_post_9 = rle_data;
    rle_data = rle_data + 1l;
    *tmp_post_9 = (unsigned char)color;
  }
  return rle_data;
}

// x_syslog
// file logdefs.h line 57
void x_syslog(signed int level, const char *module, const char *fmt, ...)
{
  void **argp;
  char buf[512l];
  argp = (void **)&fmt;
  vsnprintf(buf, (unsigned long int)512, fmt, argp);
  buf[(signed long int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1)] = (char)0;
  if(LogToSysLog == 0)
  {
    signed long int return_value_syscall_1;
    return_value_syscall_1=syscall((signed long int)186);
    fprintf(stderr, "[%ld] %s%s\n", (signed long int)return_value_syscall_1, module, (const void *)buf);
  }

  else
  {
    signed long int return_value_syscall_2;
    return_value_syscall_2=syscall((signed long int)186);
    syslog(level, "[%ld] %s%s", (signed long int)return_value_syscall_2, module, (const void *)buf);
  }
  argp = ((void **)NULL);
}

// xine_control
// file xine_frontend.c line 1330
static signed int xine_control(struct frontend_s *this_gen, const char *cmd)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  signed int return_value_find_input_plugin_1;
  return_value_find_input_plugin_1=find_input_plugin(this);
  if(return_value_find_input_plugin_1 == 0)
    return -1;

  else
  {
    signed int return_value;
    return_value=this->input_plugin->f.push_input_control(this->input_plugin, cmd);
    return return_value;
  }
}

// xine_event_cb
// file xine_frontend.c line 408
static void xine_event_cb(void *user_data, const struct anonymous_15 *event)
{
  struct fe_s *this = (struct fe_s *)user_data;
  if(event->type == 1)
  {
    do
      if(SysLogLevel >= 3)
        x_syslog(7, "[vdr-fe]    ", "XINE_EVENT_UI_PLAYBACK_FINISHED");

    while((_Bool)0);
    if(!(this == ((struct fe_s *)NULL)))
    {
      if(event->stream == this->stream)
        this->playback_finished = (unsigned char)1;

    }

    else
      do
        if(SysLogLevel >= 2)
          x_syslog(6, "[vdr-fe]    ", "xine_event_cb: NO USER DATA !");

      while((_Bool)0);
  }

}

// xine_osd_command
// file xine_frontend.c line 1340
static signed int xine_osd_command(struct frontend_s *this_gen, struct osd_command_s *cmd)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  signed int return_value_find_input_plugin_1;
  return_value_find_input_plugin_1=find_input_plugin(this);
  if(return_value_find_input_plugin_1 == 0)
    return -1;

  else
  {
    signed int return_value;
    return_value=this->input_plugin->f.push_input_osd(this->input_plugin, cmd);
    return return_value;
  }
}

// xine_queue_pes_packet
// file xine_frontend.c line 1349
static signed int xine_queue_pes_packet(struct frontend_s *this_gen, signed int stream, unsigned long int pos, const char *data, signed int len)
{
  struct fe_s *this = (struct fe_s *)this_gen;
  signed int return_value_find_input_plugin_1;
  return_value_find_input_plugin_1=find_input_plugin(this);
  if(return_value_find_input_plugin_1 == 0)
    return 0;

  else
  {
    signed int return_value;
    return_value=this->input_plugin->f.push_input_write(this->input_plugin, stream, pos, data, len);
    return return_value;
  }
}

// xrender_surf_adopt
// file xine_sxfe_frontend.c line 744
static struct _xrender_surf * xrender_surf_adopt(struct _XDisplay *dpy, unsigned long int draw, struct anonymous_16 *vis, signed int w, signed int h)
{
  struct _xrender_surf *rs;
  struct anonymous_21 *fmt;
  struct _XRenderPictureAttributes att;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _xrender_surf) /*32ul*/ );
  rs = (struct _xrender_surf *)return_value_calloc_1;
  fmt=XRenderFindVisualFormat(dpy, vis);
  rs->w = (unsigned short int)w;
  rs->h = (unsigned short int)h;
  rs->depth = (unsigned char)fmt->depth;
  rs->vis = vis;
  rs->draw = draw;
  att.dither = (unsigned long int)1;
  att.component_alpha = 1;
  att.repeat = 0;
  rs->pic=XRenderCreatePicture(dpy, rs->draw, fmt, (unsigned long int)(1 << 0 | 1 << 11 | 1 << 12), &att);
  rs->allocated = (unsigned char)0;
  return rs;
}

// xrender_surf_blend
// file xine_sxfe_frontend.c line 715
static void xrender_surf_blend(struct _XDisplay *dpy, struct _xrender_surf *src, struct _xrender_surf *dst, signed int x, signed int y, signed int w, signed int h, double scale_x, double scale_y, signed int smooth, signed int *new_x, signed int *new_y, signed int *new_w, signed int *new_h)
{
  struct _XTransform xf;
  if(scale_x <= 4.450148e-308)
    scale_x = (double)1;

  if(scale_y <= 4.450148e-308)
    scale_y = (double)1;

  xf.matrix[(signed long int)0][(signed long int)0] = (signed int)((1.0 / scale_x) * (double)65536);
  xf.matrix[(signed long int)0][(signed long int)1] = 0;
  xf.matrix[(signed long int)0][(signed long int)2] = 0;
  xf.matrix[(signed long int)1][(signed long int)0] = 0;
  xf.matrix[(signed long int)1][(signed long int)1] = (signed int)((1.0 / scale_y) * (double)65536);
  xf.matrix[(signed long int)1][(signed long int)2] = 0;
  xf.matrix[(signed long int)2][(signed long int)0] = 0;
  xf.matrix[(signed long int)2][(signed long int)1] = 0;
  xf.matrix[(signed long int)2][(signed long int)2] = (signed int)(1.0 * (double)65536);
  XRenderSetPictureFilter(dpy, src->pic, smooth != 0 ? "bilinear" : "nearest", (signed int *)(void *)0, 0);
  XRenderSetPictureTransform(dpy, src->pic, &xf);
  double return_value_ceil_1;
  return_value_ceil_1=ceil((double)(x > 0 ? x - 1 : 0) * scale_x);
  x = (signed int)return_value_ceil_1;
  double return_value_ceil_2;
  return_value_ceil_2=ceil((double)(y > 0 ? y - 1 : 0) * scale_y);
  y = (signed int)return_value_ceil_2;
  double return_value_floor_3;
  return_value_floor_3=floor((double)(w + 2) * scale_x);
  w = (signed int)return_value_floor_3;
  double return_value_floor_4;
  return_value_floor_4=floor((double)(h + 2) * scale_y);
  h = (signed int)return_value_floor_4;
  XRenderComposite(dpy, 1, src->pic, (unsigned long int)0L, dst->pic, x, y, 0, 0, x, y, (unsigned int)w, (unsigned int)h);
  *new_x = x;
  *new_y = y;
  *new_w = w;
  *new_h = h;
}

// xrender_surf_free
// file xine_sxfe_frontend.c line 766
static void xrender_surf_free(struct _XDisplay *dpy, struct _xrender_surf *rs)
{
  if(!(rs->allocated == 0))
    XFreePixmap(dpy, rs->draw);

  XRenderFreePicture(dpy, rs->pic);
  free((void *)rs);
}

// xrender_surf_new
// file xine_sxfe_frontend.c line 692
static struct _xrender_surf * xrender_surf_new(struct _XDisplay *dpy, unsigned long int draw, struct anonymous_16 *vis, signed int w, signed int h, signed int alpha)
{
  struct _xrender_surf *rs;
  struct anonymous_21 *fmt;
  struct _XRenderPictureAttributes att;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct _xrender_surf) /*32ul*/ );
  rs = (struct _xrender_surf *)return_value_calloc_1;
  fmt=XRenderFindStandardFormat(dpy, alpha != 0 ? 0 : 1);
  rs->w = (unsigned short int)w;
  rs->h = (unsigned short int)h;
  rs->depth = (unsigned char)fmt->depth;
  rs->vis = vis;
  rs->draw=XCreatePixmap(dpy, draw, (unsigned int)w, (unsigned int)h, (unsigned int)fmt->depth);
  att.dither = (unsigned long int)1;
  att.component_alpha = 1;
  att.repeat = 0;
  rs->pic=XRenderCreatePicture(dpy, rs->draw, fmt, (unsigned long int)(1 << 0 | 1 << 11 | 1 << 12), &att);
  rs->allocated = (unsigned char)1;
  return rs;
}

