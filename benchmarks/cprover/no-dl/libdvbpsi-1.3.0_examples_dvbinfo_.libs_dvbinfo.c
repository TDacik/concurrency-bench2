// tag-#anon#ST[*{SYM#tag-dvbpsi_s#}$SYM#tag-dvbpsi_s#$'handle'||S32'i_pat_version'||S32'i_ts_id'||*{SYM#tag-ts_pid_s#}$SYM#tag-ts_pid_s#$'pid'|]
// file libdvbpsi.c line 157
struct anonymous$3;

// tag-#anon#ST[ARR3{U8}$U8$'iso_639_code'|]
// file descriptors/dr_49.h line 65
struct anonymous$11;

// tag-#anon#ST[ARR3{U8}$U8$'iso_639_code'||U8'i_audio_type'|]
// file descriptors/dr_0a.h line 62
struct anonymous$9;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$4;

// tag-#anon#ST[U16'i_service_id'||U8'i_service_type'||U8'$pad0'|]
// file descriptors/dr_41.h line 59
struct anonymous$10;

// tag-#anon#ST[cS32'i_category'||U32'$pad0'||*{cS8}$cS8$'p_category'|]
// file libdvbpsi.c line 1084
struct anonymous$8;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$5;

// tag-#anon#UN[ARR253{U8}$U8$'path'||U16'ref'||U2032'$pad'|]
// file descriptors/dr_76.h line 82
union anonymous$1;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$0;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$2;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$6;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$7;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-buffer_s
// file buffer.h line 26
struct buffer_s;

// tag-dvbinfo_capture_s
// file dvbinfo.c line 95
struct dvbinfo_capture_s;

// tag-dvbpsi_PDC_dr_s
// file descriptors/dr_69.h line 56
struct dvbpsi_PDC_dr_s;

// tag-dvbpsi_aac_dr_s
// file ../../src/descriptors/dr_7c.h line 97
struct dvbpsi_aac_dr_s;

// tag-dvbpsi_aac_profile_and_level_s
// file ../../src/descriptors/types/aac_profile.h line 53
enum dvbpsi_aac_profile_and_level_s { DVBPSI_AAC_PROFILE_RESERVED=0, DVBPSI_AAC_PROFILE_NOT_DEFINED=15, DVBPSI_AAC_PROFILE_MAIN_LEVEL_1=16, DVBPSI_AAC_PROFILE_MAIN_LEVEL_2=17, DVBPSI_AAC_PROFILE_MAIN_LEVEL_3=18, DVBPSI_AAC_PROFILE_MAIN_LEVEL_4=19, DVBPSI_AAC_PROFILE_SCALABLE_LEVEL_1=24, DVBPSI_AAC_PROFILE_SCALABLE_LEVEL_2=25, DVBPSI_AAC_PROFILE_SCALABLE_LEVEL_3=26, DVBPSI_AAC_PROFILE_SCALABLE_LEVEL_4=27, DVBPSI_AAC_PROFILE_SPEECH_LEVEL_1=32, DVBPSI_AAC_PROFILE_SPEECH_LEVEL_2=33, DVBPSI_AAC_PROFILE_SYNTHESIS_LEVEL_1=40, DVBPSI_AAC_PROFILE_SYNTHESIS_LEVEL_2=41, DVBPSI_AAC_PROFILE_SYNTHESIS_LEVEL_3=42, DVBPSI_AAC_PROFILE_HQ_LEVEL_1=48, DVBPSI_AAC_PROFILE_HQ_LEVEL_2=49, DVBPSI_AAC_PROFILE_HQ_LEVEL_3=50, DVBPSI_AAC_PROFILE_HQ_LEVEL_4=51, DVBPSI_AAC_PROFILE_HQ_LEVEL_5=52, DVBPSI_AAC_PROFILE_HQ_LEVEL_6=53, DVBPSI_AAC_PROFILE_HQ_LEVEL_7=54, DVBPSI_AAC_PROFILE_HQ_LEVEL_8=55, DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_1=56, DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_2=57, DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_3=58, DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_4=59, DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_5=60, DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_6=61, DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_7=62, DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_8=63, DVBPSI_AAC_PROFILE_NATURAL_LEVEL_1=64, DVBPSI_AAC_PROFILE_NATURAL_LEVEL_2=65, DVBPSI_AAC_PROFILE_NATURAL_LEVEL_3=66, DVBPSI_AAC_PROFILE_NATURAL_LEVEL_4=67, DVBPSI_AAC_PROFILE_MOBILE_LEVEL_1=72, DVBPSI_AAC_PROFILE_MOBILE_LEVEL_2=73, DVBPSI_AAC_PROFILE_MOBILE_LEVEL_3=74, DVBPSI_AAC_PROFILE_MOBILE_LEVEL_4=75, DVBPSI_AAC_PROFILE_MOBILE_LEVEL_5=76, DVBPSI_AAC_PROFILE_MOBILE_LEVEL_6=77, DVBPSI_AAC_PROFILE_LEVEL_1=80, DVBPSI_AAC_PROFILE_LEVEL_2=81, DVBPSI_AAC_PROFILE_LEVEL_4=82, DVBPSI_AAC_PROFILE_LEVEL_5=83, DVBPSI_HE_AAC_PROFILE_LEVEL_2=88, DVBPSI_HE_AAC_PROFILE_LEVEL_3=89, DVBPSI_HE_AAC_PROFILE_LEVEL_4=90, DVBPSI_HE_AAC_PROFILE_LEVEL_5=91, DVBPSI_HE_AAC_V2_PROFILE_LEVEL_2=96, DVBPSI_HE_AAC_V2_PROFILE_LEVEL_3=97, DVBPSI_HE_AAC_V2_PROFILE_LEVEL_4=98, DVBPSI_HE_AAC_V2_PROFILE_LEVEL_5=99, DVBPSI_AAC_PROFILE_NOT_SPECIFIED=255 };

// tag-dvbpsi_aac_profile_and_level_table_s
// file descriptors/dr_7c.c line 44
struct dvbpsi_aac_profile_and_level_table_s;

// tag-dvbpsi_aac_type_s
// file ../../src/descriptors/dr_7c.h line 54
enum dvbpsi_aac_type_s { DVBPSI_AAC_RESERVED0=0, DVBPSI_HE_AAC_MONO=1, DVBPSI_AAC_RESERVED1=2, DVBPSI_HE_AAC_STEREO=3, DVBPSI_AAC_RESERVED2=4, DVBPSI_HE_AAC_SURROUND=5, DVBPSI_AAC_RESERVED3=6, DVBPSI_HE_AAC_IMPAIRED=64, DVBPSI_HE_AAC_HEARING=65, DVBPSI_HE_AAC_MIXED=66, DVBPSI_HE_AAC_V2_STEREO=67, DVBPSI_HE_AAC_V2_IMPAIRED=68, DVBPSI_HE_AAC_V2_HEARING=69, DVBPSI_HE_AAC_V2_MIXED=70, DVBPSI_HE_AAC_MIXED_IMPAIRED=71, DVBPSI_HE_AAC_BROADCAST_MIXED_IMPAIRED=72, DVBPSI_HE_AAC_V2_MIXED_IMPAIRED=73, DVBPSI_HE_AAC_V2_BROADCAST_MIXED_IMPAIRED=74, DVBPSI_AAC_RESERVED4=75, DVBPSI_AAC_USER=176, DVBPSI_AAC_RESERVED5=255 };

// tag-dvbpsi_aac_type_table_s
// file descriptors/dr_7c.c line 148
struct dvbpsi_aac_type_table_s;

// tag-dvbpsi_ac3_audio_dr_s
// file descriptors/dr_81.h line 50
struct dvbpsi_ac3_audio_dr_s;

// tag-dvbpsi_association_tag_dr_s
// file descriptors/dr_14.h line 46
struct dvbpsi_association_tag_dr_s;

// tag-dvbpsi_astream_dr_s
// file descriptors/dr_03.h line 57
struct dvbpsi_astream_dr_s;

// tag-dvbpsi_atsc_eit_decoder_s
// file tables/atsc_eit.c line 46
struct dvbpsi_atsc_eit_decoder_s;

// tag-dvbpsi_atsc_eit_event_s
// file ../../src/tables/atsc_eit.h line 48
struct dvbpsi_atsc_eit_event_s;

// tag-dvbpsi_atsc_eit_s
// file ../../src/tables/atsc_eit.h line 76
struct dvbpsi_atsc_eit_s;

// tag-dvbpsi_atsc_ett_decoder_s
// file tables/atsc_ett.c line 52
struct dvbpsi_atsc_ett_decoder_s;

// tag-dvbpsi_atsc_ett_s
// file ../../src/tables/atsc_ett.h line 55
struct dvbpsi_atsc_ett_s;

// tag-dvbpsi_atsc_mgt_decoder_s
// file tables/atsc_mgt.c line 47
struct dvbpsi_atsc_mgt_decoder_s;

// tag-dvbpsi_atsc_mgt_s
// file ../../src/tables/atsc_mgt.h line 76
struct dvbpsi_atsc_mgt_s;

// tag-dvbpsi_atsc_mgt_table_s
// file ../../src/tables/atsc_mgt.h line 51
struct dvbpsi_atsc_mgt_table_s;

// tag-dvbpsi_atsc_stt_decoder_s
// file tables/atsc_stt.c line 46
struct dvbpsi_atsc_stt_decoder_s;

// tag-dvbpsi_atsc_stt_s
// file ../../src/tables/atsc_stt.h line 48
struct dvbpsi_atsc_stt_s;

// tag-dvbpsi_atsc_vct_channel_s
// file ../../src/tables/atsc_vct.h line 50
struct dvbpsi_atsc_vct_channel_s;

// tag-dvbpsi_atsc_vct_decoder_s
// file tables/atsc_vct.c line 45
struct dvbpsi_atsc_vct_decoder_s;

// tag-dvbpsi_atsc_vct_s
// file ../../src/tables/atsc_vct.h line 89
struct dvbpsi_atsc_vct_s;

// tag-dvbpsi_bat_decoder_s
// file tables/bat_private.h line 37
struct dvbpsi_bat_decoder_s;

// tag-dvbpsi_bat_s
// file ../../src/tables/bat.h line 89
struct dvbpsi_bat_s;

// tag-dvbpsi_bat_ts_s
// file ../../src/tables/bat.h line 62
struct dvbpsi_bat_ts_s;

// tag-dvbpsi_bouquet_name_dr_s
// file descriptors/dr_47.h line 58
struct dvbpsi_bouquet_name_dr_s;

// tag-dvbpsi_ca_dr_s
// file descriptors/dr_09.h line 57
struct dvbpsi_ca_dr_s;

// tag-dvbpsi_ca_identifier_dr_s
// file ../../src/descriptors/dr_53.h line 81
struct dvbpsi_ca_identifier_dr_s;

// tag-dvbpsi_ca_system_s
// file ../../src/descriptors/dr_53.h line 55
struct dvbpsi_ca_system_s;

// tag-dvbpsi_cable_deliv_sys_dr_s
// file descriptors/dr_44.h line 58
struct dvbpsi_cable_deliv_sys_dr_s;

// tag-dvbpsi_caption_service_dr_s
// file descriptors/dr_86.h line 73
struct dvbpsi_caption_service_dr_s;

// tag-dvbpsi_caption_service_s
// file descriptors/dr_86.h line 50
struct dvbpsi_caption_service_s;

// tag-dvbpsi_carousel_id_dr_s
// file descriptors/dr_13.h line 46
struct dvbpsi_carousel_id_dr_s;

// tag-dvbpsi_cat_decoder_s
// file tables/cat_private.h line 38
struct dvbpsi_cat_decoder_s;

// tag-dvbpsi_cat_s
// file ../../src/tables/cat.h line 57
struct dvbpsi_cat_s;

// tag-dvbpsi_component_dr_t
// file descriptors/dr_50.h line 59
struct dvbpsi_component_dr_t;

// tag-dvbpsi_content_dr_s
// file ../../src/descriptors/dr_54.h line 215
struct dvbpsi_content_dr_s;

// tag-dvbpsi_content_id_dr_s
// file descriptors/dr_76.h line 109
struct dvbpsi_content_id_dr_s;

// tag-dvbpsi_content_s
// file ../../src/descriptors/dr_54.h line 188
struct dvbpsi_content_s;

// tag-dvbpsi_copyright_dr_s
// file descriptors/dr_0d.h line 57
struct dvbpsi_copyright_dr_s;

// tag-dvbpsi_country_availability_dr_s
// file descriptors/dr_49.h line 60
struct dvbpsi_country_availability_dr_s;

// tag-dvbpsi_crid_entry_s
// file descriptors/dr_76.h line 78
struct dvbpsi_crid_entry_s;

// tag-dvbpsi_cuei_dr_s
// file ../../src/descriptors/dr_8a.h line 54
struct dvbpsi_cuei_dr_s;

// tag-dvbpsi_data_broadcast_id_dr_s
// file descriptors/dr_66.h line 46
struct dvbpsi_data_broadcast_id_dr_s;

// tag-dvbpsi_decoder_s
// file ../../src/dvbpsi.h line 105
struct dvbpsi_decoder_s;

// tag-dvbpsi_default_authority_dr_s
// file descriptors/dr_73.h line 50
struct dvbpsi_default_authority_dr_s;

// tag-dvbpsi_demux_s
// file demux.h line 117
struct dvbpsi_demux_s;

// tag-dvbpsi_demux_subdec_s
// file demux.h line 90
struct dvbpsi_demux_subdec_s;

// tag-dvbpsi_descriptor_s
// file ../../src/descriptor.h line 82
struct dvbpsi_descriptor_s;

// tag-dvbpsi_ds_alignment_dr_s
// file descriptors/dr_06.h line 57
struct dvbpsi_ds_alignment_dr_s;

// tag-dvbpsi_eit_decoder_s
// file tables/eit_private.h line 36
struct dvbpsi_eit_decoder_s;

// tag-dvbpsi_eit_event_s
// file ../../src/tables/eit.h line 55
struct dvbpsi_eit_event_s;

// tag-dvbpsi_eit_s
// file ../../src/tables/eit.h line 87
struct dvbpsi_eit_s;

// tag-dvbpsi_extended_channel_name_dr_s
// file descriptors/dr_a0.h line 50
struct dvbpsi_extended_channel_name_dr_s;

// tag-dvbpsi_extended_event_dr_s
// file descriptors/dr_4e.h line 56
struct dvbpsi_extended_event_dr_s;

// tag-dvbpsi_frequency_list_dr_s
// file descriptors/dr_62.h line 50
struct dvbpsi_frequency_list_dr_s;

// tag-dvbpsi_hierarchy_dr_s
// file descriptors/dr_04.h line 57
struct dvbpsi_hierarchy_dr_s;

// tag-dvbpsi_ibp_dr_s
// file ../../src/descriptors/dr_12.h line 49
struct dvbpsi_ibp_dr_s;

// tag-dvbpsi_iso639_dr_s
// file descriptors/dr_0a.h line 58
struct dvbpsi_iso639_dr_s;

// tag-dvbpsi_lcn_dr_s
// file descriptors/dr_83.h line 70
struct dvbpsi_lcn_dr_s;

// tag-dvbpsi_lcn_entry_s
// file descriptors/dr_83.h line 50
struct dvbpsi_lcn_entry_s;

// tag-dvbpsi_linkage_dr_s
// file descriptors/dr_4a.h line 59
struct dvbpsi_linkage_dr_s;

// tag-dvbpsi_local_time_offset_dr_s
// file descriptors/dr_58.h line 89
struct dvbpsi_local_time_offset_dr_s;

// tag-dvbpsi_local_time_offset_s
// file descriptors/dr_58.h line 57
struct dvbpsi_local_time_offset_s;

// tag-dvbpsi_max_bitrate_dr_s
// file ../../src/descriptors/dr_0e.h line 57
struct dvbpsi_max_bitrate_dr_s;

// tag-dvbpsi_mpeg4_audio_dr_s
// file ../../src/descriptors/dr_1c.h line 51
struct dvbpsi_mpeg4_audio_dr_s;

// tag-dvbpsi_mpeg4_video_dr_s
// file ../../src/descriptors/dr_1b.h line 116
struct dvbpsi_mpeg4_video_dr_s;

// tag-dvbpsi_mpeg4_visual_profile_and_level_s
// file ../../src/descriptors/dr_1b.h line 49
enum dvbpsi_mpeg4_visual_profile_and_level_s { DVBPSI_MPEG4V_PROFILE_SIMPLE_L1=1, DVBPSI_MPEG4V_PROFILE_SIMPLE_L2=2, DVBPSI_MPEG4V_PROFILE_SIMPLE_L3=3, DVBPSI_MPEG4V_PROFILE_SIMPLE_SCALABLE_L1=17, DVBPSI_MPEG4V_PROFILE_SIMPLE_SCALABLE_L2=18, DVBPSI_MPEG4V_PROFILE_CORE_L1=33, DVBPSI_MPEG4V_PROFILE_CORE_L2=34, DVBPSI_MPEG4V_PROFILE_MAIN_L2=50, DVBPSI_MPEG4V_PROFILE_MAIN_L3=51, DVBPSI_MPEG4V_PROFILE_MAIN_L4=52, DVBPSI_MPEG4V_PROFILE_N_BIT_L2=66, DVBPSI_MPEG4V_PROFILE_SCALABLE_TEXTURE_L1=81, DVBPSI_MPEG4V_PROFILE_SIMPLE_FACE_ANIMATION_L1=97, DVBPSI_MPEG4V_PROFILE_SIMPLE_FACE_ANIMATION_L2=98, DVBPSI_MPEG4V_PROFILE_SIMPLE_FBA_L1=99, DVBPSI_MPEG4V_PROFILE_SIMPLE_FBA_L2=100, DVBPSI_MPEG4V_PROFILE_BASIC_ANIMATED_TEXTURE_L1=113, DVBPSI_MPEG4V_PROFILE_BASIC_ANIMATED_TEXTURE_L2=114, DVBPSI_MPEG4V_PROFILE_HYBRID_L1=129, DVBPSI_MPEG4V_PROFILE_HYBRID_L2=130, DVBPSI_MPEG4V_PROFILE_ADV_REAL_TIME_SIMPLE_L1=145, DVBPSI_MPEG4V_PROFILE_ADV_REAL_TIME_SIMPLE_L2=146, DVBPSI_MPEG4V_PROFILE_ADV_REAL_TIME_SIMPLE_L3=147, DVBPSI_MPEG4V_PROFILE_ADV_REAL_TIME_SIMPLE_L4=148, DVBPSI_MPEG4V_PROFILE_CORE_SCALABLE_L1=161, DVBPSI_MPEG4V_PROFILE_CORE_SCALABLE_L2=162, DVBPSI_MPEG4V_PROFILE_CORE_SCALABLE_L3=163, DVBPSI_MPEG4V_PROFILE_ADV_CODING_EFF_L1=177, DVBPSI_MPEG4V_PROFILE_ADV_CODING_EFF_L2=178, DVBPSI_MPEG4V_PROFILE_ADV_CODING_EFF_L3=179, DVBPSI_MPEG4V_PROFILE_ADV_CODING_EFF_L4=180, DVBPSI_MPEG4V_PROFILE_ADV_CORE_L1=193, DVBPSI_MPEG4V_PROFILE_ADV_CORE_L2=194, DVBPSI_MPEG4V_PROFILE_ADV_SCALABLE_TEXTURE_L1=209, DVBPSI_MPEG4V_PROFILE_ADV_SCALABLE_TEXTURE_L2=210, DVBPSI_MPEG4V_PROFILE_ADV_SCALABLE_TEXTURE_L3=211, DVBPSI_MPEG4V_PROFILE_LAST=255 };

// tag-dvbpsi_msg_level
// file ../../src/dvbpsi.h line 72
enum dvbpsi_msg_level { DVBPSI_MSG_NONE=-1, DVBPSI_MSG_ERROR=0, DVBPSI_MSG_WARN=1, DVBPSI_MSG_DEBUG=2 };

// tag-dvbpsi_mx_buff_utilization_dr_s
// file descriptors/dr_0c.h line 57
struct dvbpsi_mx_buff_utilization_dr_s;

// tag-dvbpsi_network_name_dr_s
// file descriptors/dr_40.h line 59
struct dvbpsi_network_name_dr_s;

// tag-dvbpsi_nit_decoder_s
// file tables/nit_private.h line 38
struct dvbpsi_nit_decoder_s;

// tag-dvbpsi_nit_s
// file ../../src/tables/nit.h line 83
struct dvbpsi_nit_s;

// tag-dvbpsi_nit_ts_s
// file ../../src/tables/nit.h line 57
struct dvbpsi_nit_ts_s;

// tag-dvbpsi_nvod_ref_dr_s
// file descriptors/dr_4b.h line 79
struct dvbpsi_nvod_ref_dr_s;

// tag-dvbpsi_nvod_ref_s
// file descriptors/dr_4b.h line 58
struct dvbpsi_nvod_ref_s;

// tag-dvbpsi_parental_rating_dr_s
// file descriptors/dr_55.h line 82
struct dvbpsi_parental_rating_dr_s;

// tag-dvbpsi_parental_rating_s
// file descriptors/dr_55.h line 54
struct dvbpsi_parental_rating_s;

// tag-dvbpsi_pat_decoder_s
// file tables/pat_private.h line 36
struct dvbpsi_pat_decoder_s;

// tag-dvbpsi_pat_program_s
// file ../../src/tables/pat.h line 54
struct dvbpsi_pat_program_s;

// tag-dvbpsi_pat_s
// file ../../src/tables/pat.h line 79
struct dvbpsi_pat_s;

// tag-dvbpsi_pmt_decoder_s
// file tables/pmt_private.h line 36
struct dvbpsi_pmt_decoder_s;

// tag-dvbpsi_pmt_es_s
// file ../../src/tables/pmt.h line 55
struct dvbpsi_pmt_es_s;

// tag-dvbpsi_pmt_s
// file ../../src/tables/pmt.h line 81
struct dvbpsi_pmt_s;

// tag-dvbpsi_private_data_dr_s
// file descriptors/dr_0f.h line 57
struct dvbpsi_private_data_dr_s;

// tag-dvbpsi_psi_section_s
// file ../../src/dvbpsi.h line 209
struct dvbpsi_psi_section_s;

// tag-dvbpsi_registration_dr_s
// file descriptors/dr_05.h line 57
struct dvbpsi_registration_dr_s;

// tag-dvbpsi_rst_decoder_s
// file tables/rst_private.h line 35
struct dvbpsi_rst_decoder_s;

// tag-dvbpsi_rst_event_s
// file ../../src/tables/rst.h line 54
struct dvbpsi_rst_event_s;

// tag-dvbpsi_rst_s
// file ../../src/tables/rst.h line 81
struct dvbpsi_rst_s;

// tag-dvbpsi_s
// file ../../src/dvbpsi.h line 66
struct dvbpsi_s;

// tag-dvbpsi_sat_deliv_sys_dr_s
// file descriptors/dr_43.h line 57
struct dvbpsi_sat_deliv_sys_dr_s;

// tag-dvbpsi_sdt_decoder_s
// file tables/sdt_private.h line 36
struct dvbpsi_sdt_decoder_s;

// tag-dvbpsi_sdt_s
// file ../../src/tables/sdt.h line 87
struct dvbpsi_sdt_s;

// tag-dvbpsi_sdt_service_s
// file ../../src/tables/sdt.h line 55
struct dvbpsi_sdt_service_s;

// tag-dvbpsi_service_dr_s
// file descriptors/dr_48.h line 58
struct dvbpsi_service_dr_s;

// tag-dvbpsi_service_list_dr_s
// file descriptors/dr_41.h line 55
struct dvbpsi_service_list_dr_s;

// tag-dvbpsi_service_location_dr_s
// file descriptors/dr_a1.h line 72
struct dvbpsi_service_location_dr_s;

// tag-dvbpsi_service_location_element_s
// file descriptors/dr_a1.h line 51
struct dvbpsi_service_location_element_s;

// tag-dvbpsi_short_event_dr_s
// file descriptors/dr_4d.h line 56
struct dvbpsi_short_event_dr_s;

// tag-dvbpsi_sis_decoder_s
// file tables/sis_private.h line 35
struct dvbpsi_sis_decoder_s;

// tag-dvbpsi_sis_s
// file ../../src/tables/sis.h line 54
struct dvbpsi_sis_s;

// tag-dvbpsi_smoothing_buffer_dr_s
// file ../../src/descriptors/dr_10.h line 49
struct dvbpsi_smoothing_buffer_dr_s;

// tag-dvbpsi_std_dr_s
// file ../../src/descriptors/dr_11.h line 49
struct dvbpsi_std_dr_s;

// tag-dvbpsi_stream_identifier_dr_s
// file ../../src/descriptors/dr_52.h line 56
struct dvbpsi_stream_identifier_dr_s;

// tag-dvbpsi_stuffing_dr_s
// file descriptors/dr_42.h line 58
struct dvbpsi_stuffing_dr_s;

// tag-dvbpsi_subtitle_s
// file ../../src/descriptors/dr_59.h line 55
struct dvbpsi_subtitle_s;

// tag-dvbpsi_subtitling_dr_s
// file ../../src/descriptors/dr_59.h line 85
struct dvbpsi_subtitling_dr_s;

// tag-dvbpsi_system_clock_dr_s
// file ../../src/descriptors/dr_0b.h line 57
struct dvbpsi_system_clock_dr_s;

// tag-dvbpsi_target_bg_grid_dr_s
// file descriptors/dr_07.h line 57
struct dvbpsi_target_bg_grid_dr_s;

// tag-dvbpsi_teletext_dr_s
// file descriptors/dr_56.h line 86
struct dvbpsi_teletext_dr_s;

// tag-dvbpsi_teletextpage_s
// file descriptors/dr_56.h line 56
struct dvbpsi_teletextpage_s;

// tag-dvbpsi_terr_deliv_sys_dr_s
// file descriptors/dr_5a.h line 57
struct dvbpsi_terr_deliv_sys_dr_s;

// tag-dvbpsi_tot_decoder_s
// file tables/tot_private.h line 38
struct dvbpsi_tot_decoder_s;

// tag-dvbpsi_tot_s
// file ../../src/tables/tot.h line 58
struct dvbpsi_tot_s;

// tag-dvbpsi_tshifted_ev_dr_s
// file ../../src/descriptors/dr_4f.h line 59
struct dvbpsi_tshifted_ev_dr_s;

// tag-dvbpsi_tshifted_service_dr_s
// file ../../src/descriptors/dr_4c.h line 59
struct dvbpsi_tshifted_service_dr_s;

// tag-dvbpsi_vbi_dr_s
// file descriptors/dr_45.h line 114
struct dvbpsi_vbi_dr_s;

// tag-dvbpsi_vbidata_line_s
// file descriptors/dr_45.h line 56
struct dvbpsi_vbidata_line_s;

// tag-dvbpsi_vbidata_s
// file descriptors/dr_45.h line 85
struct dvbpsi_vbidata_s;

// tag-dvbpsi_vstream_dr_s
// file descriptors/dr_02.h line 57
struct dvbpsi_vstream_dr_s;

// tag-dvbpsi_vwindow_dr_s
// file descriptors/dr_08.h line 57
struct dvbpsi_vwindow_dr_s;

// tag-fifo_s
// file buffer.h line 36
struct fifo_s;

// tag-group_req
// file /usr/include/netinet/in.h line 300
struct group_req;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-params_s
// file dvbinfo.h line 35
struct params_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-summary_s
// file dvbinfo.h line 61
struct summary_s;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-ts_atsc_eit_s
// file libdvbpsi.c line 229
struct ts_atsc_eit_s;

// tag-ts_atsc_s
// file libdvbpsi.c line 223
struct ts_atsc_s;

// tag-ts_cat_s
// file libdvbpsi.c line 180
struct ts_cat_s;

// tag-ts_eit_s
// file libdvbpsi.c line 211
struct ts_eit_s;

// tag-ts_pid_s
// file libdvbpsi.c line 109
struct ts_pid_s;

// tag-ts_pmt_s
// file libdvbpsi.c line 167
struct ts_pmt_s;

// tag-ts_rst_s
// file libdvbpsi.c line 205
struct ts_rst_s;

// tag-ts_sdt_s
// file libdvbpsi.c line 199
struct ts_sdt_s;

// tag-ts_sis_s
// file libdvbpsi.c line 191
struct ts_sis_s;

// tag-ts_stream_t
// file libdvbpsi.h line 39
struct ts_stream_t;

// tag-ts_tdt_s
// file libdvbpsi.c line 217
struct ts_tdt_s;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// AACProfileToString
// file libdvbpsi.c line 1264
static const char * AACProfileToString(enum dvbpsi_aac_profile_and_level_s profile);
// DumpAACDescriptor
// file libdvbpsi.c line 1347
static void DumpAACDescriptor(const void *p_descriptor);
// DumpATSCEITEventDescriptors
// file libdvbpsi.c line 1985
static void DumpATSCEITEventDescriptors(struct dvbpsi_atsc_eit_event_s *p_atsc_eit_event);
// DumpAtscVCTChannels
// file libdvbpsi.c line 1940
static void DumpAtscVCTChannels(struct dvbpsi_atsc_vct_channel_s *p_vct_channels);
// DumpCAIdentifierDescriptor
// file libdvbpsi.c line 1073
static void DumpCAIdentifierDescriptor(const void *p_descriptor);
// DumpCUEIDescriptor
// file libdvbpsi.c line 1446
static void DumpCUEIDescriptor(const void *p_descriptor);
// DumpContentDescriptor
// file libdvbpsi.c line 1208
static void DumpContentDescriptor(const void *p_descriptor);
// DumpDescriptor
// file libdvbpsi.c line 1591
static void DumpDescriptor(struct dvbpsi_descriptor_s *p_descriptor);
// DumpDescriptor::1::dump_dr_fn$object
//
void dump_dr_fn$object(const void *);
// DumpDescriptors
// file libdvbpsi.c line 1702
static void DumpDescriptors(const char *str, struct dvbpsi_descriptor_s *p_descriptor);
// DumpEITEventDescriptors
// file libdvbpsi.c line 1748
static void DumpEITEventDescriptors(struct dvbpsi_eit_event_s *p_eit_event);
// DumpIBPDescriptor
// file libdvbpsi.c line 978
static void DumpIBPDescriptor(const void *p_descriptor);
// DumpMPEG4AudioDescriptor
// file libdvbpsi.c line 1041
static void DumpMPEG4AudioDescriptor(const void *p_descriptor);
// DumpMPEG4VideoDescriptor
// file libdvbpsi.c line 1033
static void DumpMPEG4VideoDescriptor(const void *p_descriptor);
// DumpMaxBitrateDescriptor
// file libdvbpsi.c line 950
static void DumpMaxBitrateDescriptor(const void *p_descriptor);
// DumpRSTEvents
// file libdvbpsi.c line 2068
static void DumpRSTEvents(const char *str, struct dvbpsi_rst_event_s *p_event);
// DumpSISDescriptors
// file libdvbpsi.c line 1491
static void DumpSISDescriptors(const char *str, struct dvbpsi_descriptor_s *p_descriptor);
// DumpSISSegmentationDescriptor
// file libdvbpsi.c line 1479
static void DumpSISSegmentationDescriptor(struct dvbpsi_descriptor_s *p_descriptor);
// DumpSTDDescriptor
// file libdvbpsi.c line 969
static void DumpSTDDescriptor(const void *p_descriptor);
// DumpSmoothingBufferDescriptor
// file libdvbpsi.c line 959
static void DumpSmoothingBufferDescriptor(const void *p_descriptor);
// DumpStreamIdentifierDescriptor
// file libdvbpsi.c line 1064
static void DumpStreamIdentifierDescriptor(const void *p_descriptor);
// DumpSubtitleDescriptor
// file libdvbpsi.c line 1246
static void DumpSubtitleDescriptor(const void *p_descriptor);
// DumpSystemClockDescriptor
// file libdvbpsi.c line 1052
static void DumpSystemClockDescriptor(const void *p_descriptor);
// DumpTSDescriptorsBAT
// file libdvbpsi.c line 2135
static void DumpTSDescriptorsBAT(struct dvbpsi_bat_ts_s *p_bat_ts);
// DumpTSDescriptorsNIT
// file libdvbpsi.c line 2105
static void DumpTSDescriptorsNIT(struct dvbpsi_nit_ts_s *p_nit_ts);
// DumpTimeShiftedEventDescriptor
// file libdvbpsi.c line 1434
static void DumpTimeShiftedEventDescriptor(const void *p_descriptor);
// DumpTimeShiftedServiceDescriptor
// file libdvbpsi.c line 1424
static void DumpTimeShiftedServiceDescriptor(const void *p_descriptor);
// EncodeEventHeaders
// file tables/eit.c line 611
static inline void EncodeEventHeaders(struct dvbpsi_eit_event_s *p_event, unsigned char *buf);
// GetATSCTableType
// file libdvbpsi.c line 1807
static const char * GetATSCTableType(const signed int i_type);
// GetAtscETMLocations
// file libdvbpsi.c line 1928
static const char * GetAtscETMLocations(const unsigned char i_etm_location);
// GetAtscVCTModulationModes
// file libdvbpsi.c line 1908
static const char * GetAtscVCTModulationModes(const unsigned char i_mode);
// GetContentSubCategory
// file libdvbpsi.c line 1089
static const char * GetContentSubCategory(const signed int i_type);
// GetDescriptorName
// file libdvbpsi.c line 826
static const char * GetDescriptorName(unsigned char tag);
// GetTypeName
// file libdvbpsi.c line 778
static const char * GetTypeName(unsigned char type);
// MPEG4VideoProfileToString
// file libdvbpsi.c line 986
static const char * MPEG4VideoProfileToString(enum dvbpsi_mpeg4_visual_profile_and_level_s profile);
// NewAssociationTagDr
// file descriptors/dr_14.c line 42
static struct dvbpsi_association_tag_dr_s * NewAssociationTagDr(const unsigned long int i_selector, const unsigned long int i_private);
// NewCarouselDr
// file descriptors/dr_13.c line 42
static struct dvbpsi_carousel_id_dr_s * NewCarouselDr(const unsigned long int i_private);
// NewDataBroadcastDr
// file descriptors/dr_66.c line 42
static struct dvbpsi_data_broadcast_id_dr_s * NewDataBroadcastDr(const unsigned long int i_private);
// NewEITSection
// file tables/eit.c line 571
static struct dvbpsi_psi_section_s * NewEITSection(struct dvbpsi_eit_s *p_eit, signed int i_table_id, signed int i_section_number);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$7, unsigned int);
// buffer_free
// file buffer.h line 43
void buffer_free(struct buffer_s *buffer);
// buffer_new
// file buffer.h line 42
struct buffer_s * buffer_new(unsigned long int i_size);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_sync_word
// file libdvbpsi.c line 2442
static signed long int check_sync_word(unsigned char *buf, signed long int length);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$7, unsigned int);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// dvbinfo_capture
// file dvbinfo.c line 285
static void * dvbinfo_capture(void *data);
// dvbinfo_close
// file dvbinfo.c line 232
static void dvbinfo_close(struct params_s *param);
// dvbinfo_open
// file dvbinfo.c line 247
static void dvbinfo_open(struct params_s *param);
// dvbinfo_process
// file dvbinfo.c line 352
static signed int dvbinfo_process(struct dvbinfo_capture_s *capture);
// dvbpsi_AddDescriptor
// file descriptor.c line 118
struct dvbpsi_descriptor_s * dvbpsi_AddDescriptor(struct dvbpsi_descriptor_s *p_list, struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_AddSectionBAT
// file tables/bat.c line 332
static _Bool dvbpsi_AddSectionBAT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_bat_decoder_s *p_bat_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AddSectionCAT
// file tables/cat.c line 228
static _Bool dvbpsi_AddSectionCAT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_cat_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AddSectionEIT
// file tables/eit.c line 381
static _Bool dvbpsi_AddSectionEIT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_eit_decoder_s *p_eit_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AddSectionEIT$link1
// file tables/atsc_eit.c line 347
static _Bool dvbpsi_AddSectionEIT$link1(struct dvbpsi_s *p_dvbpsi$link1, struct dvbpsi_atsc_eit_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section$link1);
// dvbpsi_AddSectionETT
// file tables/atsc_ett.c line 280
static _Bool dvbpsi_AddSectionETT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_ett_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AddSectionMGT
// file tables/atsc_mgt.c line 372
static _Bool dvbpsi_AddSectionMGT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_mgt_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AddSectionNIT
// file tables/nit.c line 328
static _Bool dvbpsi_AddSectionNIT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_nit_decoder_s *p_nit_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AddSectionPAT
// file tables/pat.c line 244
static _Bool dvbpsi_AddSectionPAT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_pat_decoder_s *p_pat_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AddSectionPMT
// file tables/pmt.c line 289
static _Bool dvbpsi_AddSectionPMT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_pmt_decoder_s *p_pmt_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AddSectionSDT
// file tables/sdt.c line 315
static _Bool dvbpsi_AddSectionSDT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sdt_decoder_s *p_sdt_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AddSectionSIS
// file tables/sis.c line 300
static _Bool dvbpsi_AddSectionSIS(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sis_decoder_s *p_sis_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AddSectionSTT
// file tables/atsc_stt.c line 279
static _Bool dvbpsi_AddSectionSTT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_stt_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AddSectionTOT
// file tables/tot.c line 273
static _Bool dvbpsi_AddSectionTOT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_tot_decoder_s *p_tot_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AddSectionVCT
// file tables/atsc_vct.c line 412
static _Bool dvbpsi_AddSectionVCT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_vct_decoder_s *p_vct_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_AttachDemux
// file ../../src/demux.h line 142
_Bool dvbpsi_AttachDemux(struct dvbpsi_s *p_dvbpsi, void (*pf_new_cb)(struct dvbpsi_s *, unsigned char, unsigned short int, void *), void *p_new_cb_data);
// dvbpsi_AttachDemux::pf_new_cb$object
//
void pf_new_cb$object(struct dvbpsi_s *, unsigned char, unsigned short int, void *);
// dvbpsi_AttachDemuxSubDecoder
// file demux.c line 203
void dvbpsi_AttachDemuxSubDecoder(struct dvbpsi_demux_s *p_demux, struct dvbpsi_demux_subdec_s *p_subdec);
// dvbpsi_Bcd8ToUint32
// file descriptors/dr_62.c line 90
unsigned int dvbpsi_Bcd8ToUint32(unsigned int bcd);
// dvbpsi_BuildPSISection
// file psi.c line 276
void dvbpsi_BuildPSISection(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CalculateCRC32
// file psi.c line 253
void dvbpsi_CalculateCRC32(struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CanDecodeAsDescriptor
// file descriptor.c line 69
_Bool dvbpsi_CanDecodeAsDescriptor(struct dvbpsi_descriptor_s *p_descriptor, const unsigned char i_tag);
// dvbpsi_CheckBAT
// file tables/bat.c line 298
static _Bool dvbpsi_CheckBAT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_bat_decoder_s *p_bat_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CheckCAT
// file tables/cat.c line 188
static _Bool dvbpsi_CheckCAT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CheckEIT
// file tables/eit.c line 294
static _Bool dvbpsi_CheckEIT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_eit_decoder_s *p_eit_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CheckEIT$link1
// file tables/atsc_eit.c line 311
static _Bool dvbpsi_CheckEIT$link1(struct dvbpsi_s *p_dvbpsi$link1, struct dvbpsi_atsc_eit_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section$link1);
// dvbpsi_CheckETT
// file tables/atsc_ett.c line 244
static _Bool dvbpsi_CheckETT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_ett_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CheckMGT
// file tables/atsc_mgt.c line 336
static _Bool dvbpsi_CheckMGT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_mgt_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CheckNIT
// file tables/nit.c line 299
static _Bool dvbpsi_CheckNIT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_nit_decoder_s *p_nit_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CheckPAT
// file tables/pat.c line 207
static _Bool dvbpsi_CheckPAT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CheckPMT
// file tables/pmt.c line 261
static _Bool dvbpsi_CheckPMT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CheckPSISection
// file psi.c line 193
_Bool dvbpsi_CheckPSISection(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section, const unsigned char table_id, const char *psz_table_name);
// dvbpsi_CheckSDT
// file tables/sdt.c line 280
static _Bool dvbpsi_CheckSDT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sdt_decoder_s *p_sdt_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CheckSIS
// file tables/sis.c line 259
static _Bool dvbpsi_CheckSIS(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sis_decoder_s *p_sis_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CheckSTT
// file tables/atsc_stt.c line 251
static _Bool dvbpsi_CheckSTT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_stt_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CheckTOT
// file tables/tot.c line 238
static _Bool dvbpsi_CheckTOT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_tot_decoder_s *p_tot_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_CheckVCT
// file tables/atsc_vct.c line 376
static _Bool dvbpsi_CheckVCT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_vct_decoder_s *p_vct_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_DecodeAACDr
// file ../../src/descriptors/dr_7c.h line 124
struct dvbpsi_aac_dr_s * dvbpsi_DecodeAACDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeAStreamDr
// file descriptors/dr_03.c line 47
struct dvbpsi_astream_dr_s * dvbpsi_DecodeAStreamDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeAc3AudioDr
// file descriptors/dr_81.c line 45
struct dvbpsi_ac3_audio_dr_s * dvbpsi_DecodeAc3AudioDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeAssociationTagDr
// file descriptors/dr_14.c line 65
struct dvbpsi_association_tag_dr_s * dvbpsi_DecodeAssociationTagDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeBouquetNameDr
// file descriptors/dr_47.c line 48
struct dvbpsi_bouquet_name_dr_s * dvbpsi_DecodeBouquetNameDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeCADr
// file descriptors/dr_09.c line 47
struct dvbpsi_ca_dr_s * dvbpsi_DecodeCADr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeCAIdentifierDr
// file ../../src/descriptors/dr_53.h line 100
struct dvbpsi_ca_identifier_dr_s * dvbpsi_DecodeCAIdentifierDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeCUEIDr
// file ../../src/descriptors/dr_8a.h line 71
struct dvbpsi_cuei_dr_s * dvbpsi_DecodeCUEIDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeCableDelivSysDr
// file descriptors/dr_44.c line 47
struct dvbpsi_cable_deliv_sys_dr_s * dvbpsi_DecodeCableDelivSysDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeCaptionServiceDr
// file descriptors/dr_86.c line 45
struct dvbpsi_caption_service_dr_s * dvbpsi_DecodeCaptionServiceDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeCarouselIdDr
// file descriptors/dr_13.c line 60
struct dvbpsi_carousel_id_dr_s * dvbpsi_DecodeCarouselIdDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeComponentDr
// file descriptors/dr_50.c line 45
struct dvbpsi_component_dr_t * dvbpsi_DecodeComponentDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeContentDr
// file ../../src/descriptors/dr_54.h line 234
struct dvbpsi_content_dr_s * dvbpsi_DecodeContentDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeContentIdDr
// file descriptors/dr_76.c line 45
struct dvbpsi_content_id_dr_s * dvbpsi_DecodeContentIdDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeCopyrightDr
// file descriptors/dr_0d.c line 47
struct dvbpsi_copyright_dr_s * dvbpsi_DecodeCopyrightDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeCountryAvailability
// file descriptors/dr_49.c line 45
struct dvbpsi_country_availability_dr_s * dvbpsi_DecodeCountryAvailability(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeDSAlignmentDr
// file descriptors/dr_06.c line 47
struct dvbpsi_ds_alignment_dr_s * dvbpsi_DecodeDSAlignmentDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeDataBroadcastIdDr
// file descriptors/dr_66.c line 62
struct dvbpsi_data_broadcast_id_dr_s * dvbpsi_DecodeDataBroadcastIdDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeDefaultAuthorityDr
// file descriptors/dr_73.c line 45
struct dvbpsi_default_authority_dr_s * dvbpsi_DecodeDefaultAuthorityDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeExtendedEventDr
// file descriptors/dr_4e.c line 46
struct dvbpsi_extended_event_dr_s * dvbpsi_DecodeExtendedEventDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeFrequencyListDr
// file descriptors/dr_62.c line 45
struct dvbpsi_frequency_list_dr_s * dvbpsi_DecodeFrequencyListDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeHierarchyDr
// file descriptors/dr_04.c line 47
struct dvbpsi_hierarchy_dr_s * dvbpsi_DecodeHierarchyDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeIBPDr
// file ../../src/descriptors/dr_12.h line 62
struct dvbpsi_ibp_dr_s * dvbpsi_DecodeIBPDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeISO639Dr
// file descriptors/dr_0a.c line 47
struct dvbpsi_iso639_dr_s * dvbpsi_DecodeISO639Dr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeLCNDr
// file descriptors/dr_83.c line 45
struct dvbpsi_lcn_dr_s * dvbpsi_DecodeLCNDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeLinkageDr
// file descriptors/dr_4a.c line 45
struct dvbpsi_linkage_dr_s * dvbpsi_DecodeLinkageDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeLocalTimeOffsetDr
// file descriptors/dr_58.c line 47
struct dvbpsi_local_time_offset_dr_s * dvbpsi_DecodeLocalTimeOffsetDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeMPEG4AudioDr
// file ../../src/descriptors/dr_1c.h line 63
struct dvbpsi_mpeg4_audio_dr_s * dvbpsi_DecodeMPEG4AudioDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeMPEG4VideoDr
// file ../../src/descriptors/dr_1b.h line 128
struct dvbpsi_mpeg4_video_dr_s * dvbpsi_DecodeMPEG4VideoDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeMaxBitrateDr
// file ../../src/descriptors/dr_0e.h line 75
struct dvbpsi_max_bitrate_dr_s * dvbpsi_DecodeMaxBitrateDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeMxBuffUtilizationDr
// file descriptors/dr_0c.c line 47
struct dvbpsi_mx_buff_utilization_dr_s * dvbpsi_DecodeMxBuffUtilizationDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeNVODReferenceDr
// file descriptors/dr_4b.c line 45
struct dvbpsi_nvod_ref_dr_s * dvbpsi_DecodeNVODReferenceDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeNetworkNameDr
// file descriptors/dr_40.c line 45
struct dvbpsi_network_name_dr_s * dvbpsi_DecodeNetworkNameDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodePDCDr
// file descriptors/dr_69.c line 47
struct dvbpsi_PDC_dr_s * dvbpsi_DecodePDCDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeParentalRatingDr
// file descriptors/dr_55.c line 47
struct dvbpsi_parental_rating_dr_s * dvbpsi_DecodeParentalRatingDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodePrivateDataDr
// file descriptors/dr_0f.c line 47
struct dvbpsi_private_data_dr_s * dvbpsi_DecodePrivateDataDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeRegistrationDr
// file descriptors/dr_05.c line 47
struct dvbpsi_registration_dr_s * dvbpsi_DecodeRegistrationDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeSTDDr
// file ../../src/descriptors/dr_11.h line 60
struct dvbpsi_std_dr_s * dvbpsi_DecodeSTDDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeSatDelivSysDr
// file descriptors/dr_43.c line 47
struct dvbpsi_sat_deliv_sys_dr_s * dvbpsi_DecodeSatDelivSysDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeServiceDr
// file descriptors/dr_48.c line 48
struct dvbpsi_service_dr_s * dvbpsi_DecodeServiceDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeServiceListDr
// file descriptors/dr_41.c line 45
struct dvbpsi_service_list_dr_s * dvbpsi_DecodeServiceListDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeServiceLocationDr
// file descriptors/dr_a1.c line 48
struct dvbpsi_service_location_dr_s * dvbpsi_DecodeServiceLocationDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeShortEventDr
// file descriptors/dr_4d.c line 46
struct dvbpsi_short_event_dr_s * dvbpsi_DecodeShortEventDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeSmoothingBufferDr
// file ../../src/descriptors/dr_10.h line 64
struct dvbpsi_smoothing_buffer_dr_s * dvbpsi_DecodeSmoothingBufferDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeStreamIdentifierDr
// file ../../src/descriptors/dr_52.h line 73
struct dvbpsi_stream_identifier_dr_s * dvbpsi_DecodeStreamIdentifierDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeStuffingDr
// file descriptors/dr_42.c line 48
struct dvbpsi_stuffing_dr_s * dvbpsi_DecodeStuffingDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeSubtitlingDr
// file ../../src/descriptors/dr_59.h line 104
struct dvbpsi_subtitling_dr_s * dvbpsi_DecodeSubtitlingDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeSystemClockDr
// file ../../src/descriptors/dr_0b.h line 78
struct dvbpsi_system_clock_dr_s * dvbpsi_DecodeSystemClockDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeTargetBgGridDr
// file descriptors/dr_07.c line 47
struct dvbpsi_target_bg_grid_dr_s * dvbpsi_DecodeTargetBgGridDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeTeletextDr
// file descriptors/dr_56.c line 46
struct dvbpsi_teletext_dr_s * dvbpsi_DecodeTeletextDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeTerrDelivSysDr
// file descriptors/dr_5a.c line 47
struct dvbpsi_terr_deliv_sys_dr_s * dvbpsi_DecodeTerrDelivSysDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeTimeShiftedEventDr
// file ../../src/descriptors/dr_4f.h line 76
struct dvbpsi_tshifted_ev_dr_s * dvbpsi_DecodeTimeShiftedEventDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeTimeShiftedServiceDr
// file ../../src/descriptors/dr_4c.h line 75
struct dvbpsi_tshifted_service_dr_s * dvbpsi_DecodeTimeShiftedServiceDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeVBIDataDr
// file descriptors/dr_45.c line 46
struct dvbpsi_vbi_dr_s * dvbpsi_DecodeVBIDataDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeVStreamDr
// file descriptors/dr_02.c line 46
struct dvbpsi_vstream_dr_s * dvbpsi_DecodeVStreamDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DecodeVWindowDr
// file descriptors/dr_08.c line 47
struct dvbpsi_vwindow_dr_s * dvbpsi_DecodeVWindowDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DeleteDemuxSubDecoder
// file demux.c line 190
void dvbpsi_DeleteDemuxSubDecoder(struct dvbpsi_demux_subdec_s *p_subdec);
// dvbpsi_DeleteDescriptors
// file descriptor.c line 140
void dvbpsi_DeleteDescriptors(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_DeletePSISections
// file psi.h line 119
void dvbpsi_DeletePSISections(struct dvbpsi_psi_section_s *p_section);
// dvbpsi_Demux
// file demux.c line 102
void dvbpsi_Demux(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_DetachDemux
// file ../../src/demux.h line 155
void dvbpsi_DetachDemux(struct dvbpsi_s *p_dvbpsi);
// dvbpsi_DetachDemuxSubDecoder
// file demux.c line 218
void dvbpsi_DetachDemuxSubDecoder(struct dvbpsi_demux_s *p_demux, struct dvbpsi_demux_subdec_s *p_subdec);
// dvbpsi_DuplicateDecodedDescriptor
// file descriptor.c line 162
void * dvbpsi_DuplicateDecodedDescriptor(void *p_decoded, signed long int i_size);
// dvbpsi_ExtendedChannelNameDr
// file descriptors/dr_a0.c line 45
struct dvbpsi_extended_channel_name_dr_s * dvbpsi_ExtendedChannelNameDr(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_GenAACDr
// file descriptors/dr_7c.c line 278
struct dvbpsi_descriptor_s * dvbpsi_GenAACDr(struct dvbpsi_aac_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenAStreamDr
// file descriptors/dr_03.c line 84
struct dvbpsi_descriptor_s * dvbpsi_GenAStreamDr(struct dvbpsi_astream_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenBouquetNameDr
// file descriptors/dr_47.c line 83
struct dvbpsi_descriptor_s * dvbpsi_GenBouquetNameDr(struct dvbpsi_bouquet_name_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenCADr
// file descriptors/dr_09.c line 88
struct dvbpsi_descriptor_s * dvbpsi_GenCADr(struct dvbpsi_ca_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenCAIdentifierDr
// file descriptors/dr_53.c line 85
struct dvbpsi_descriptor_s * dvbpsi_GenCAIdentifierDr(struct dvbpsi_ca_identifier_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenCUEIDr
// file descriptors/dr_8a.c line 85
struct dvbpsi_descriptor_s * dvbpsi_GenCUEIDr(struct dvbpsi_cuei_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenCableDelivSysDr
// file descriptors/dr_44.c line 87
struct dvbpsi_descriptor_s * dvbpsi_GenCableDelivSysDr(struct dvbpsi_cable_deliv_sys_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenComponentDr
// file descriptors/dr_50.c line 95
struct dvbpsi_descriptor_s * dvbpsi_GenComponentDr(struct dvbpsi_component_dr_t *p_decoded, _Bool b_duplicate);
// dvbpsi_GenContentDr
// file descriptors/dr_54.c line 86
struct dvbpsi_descriptor_s * dvbpsi_GenContentDr(struct dvbpsi_content_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenCopyrightDr
// file descriptors/dr_0d.c line 92
struct dvbpsi_descriptor_s * dvbpsi_GenCopyrightDr(struct dvbpsi_copyright_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenCountryAvailabilityDr
// file descriptors/dr_49.c line 90
struct dvbpsi_descriptor_s * dvbpsi_GenCountryAvailabilityDr(struct dvbpsi_country_availability_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenDSAlignmentDr
// file descriptors/dr_06.c line 78
struct dvbpsi_descriptor_s * dvbpsi_GenDSAlignmentDr(struct dvbpsi_ds_alignment_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenExtendedEventDr
// file descriptors/dr_4e.c line 108
struct dvbpsi_descriptor_s * dvbpsi_GenExtendedEventDr(struct dvbpsi_extended_event_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenHierarchyDr
// file descriptors/dr_04.c line 85
struct dvbpsi_descriptor_s * dvbpsi_GenHierarchyDr(struct dvbpsi_hierarchy_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenIBPDr
// file descriptors/dr_12.c line 74
struct dvbpsi_descriptor_s * dvbpsi_GenIBPDr(struct dvbpsi_ibp_dr_s *p_decoded);
// dvbpsi_GenISO639Dr
// file descriptors/dr_0a.c line 90
struct dvbpsi_descriptor_s * dvbpsi_GenISO639Dr(struct dvbpsi_iso639_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenLCNDr
// file descriptors/dr_83.c line 90
struct dvbpsi_descriptor_s * dvbpsi_GenLCNDr(struct dvbpsi_lcn_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenLinkageDr
// file descriptors/dr_4a.c line 138
struct dvbpsi_descriptor_s * dvbpsi_GenLinkageDr(struct dvbpsi_linkage_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenLocalTimeOffsetDr
// file descriptors/dr_58.c line 105
struct dvbpsi_descriptor_s * dvbpsi_GenLocalTimeOffsetDr(struct dvbpsi_local_time_offset_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenMPEG4AudioDr
// file descriptors/dr_1c.c line 64
struct dvbpsi_descriptor_s * dvbpsi_GenMPEG4AudioDr(struct dvbpsi_mpeg4_audio_dr_s *p_decoded);
// dvbpsi_GenMPEG4VideoDr
// file descriptors/dr_1b.c line 64
struct dvbpsi_descriptor_s * dvbpsi_GenMPEG4VideoDr(struct dvbpsi_mpeg4_video_dr_s *p_decoded);
// dvbpsi_GenMaxBitrateDr
// file descriptors/dr_0e.c line 81
struct dvbpsi_descriptor_s * dvbpsi_GenMaxBitrateDr(struct dvbpsi_max_bitrate_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenMxBuffUtilizationDr
// file descriptors/dr_0c.c line 84
struct dvbpsi_descriptor_s * dvbpsi_GenMxBuffUtilizationDr(struct dvbpsi_mx_buff_utilization_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenNVODReferenceDr
// file descriptors/dr_4b.c line 91
struct dvbpsi_descriptor_s * dvbpsi_GenNVODReferenceDr(struct dvbpsi_nvod_ref_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenNetworkNameDr
// file descriptors/dr_40.c line 80
struct dvbpsi_descriptor_s * dvbpsi_GenNetworkNameDr(struct dvbpsi_network_name_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenPDCDr
// file descriptors/dr_69.c line 84
struct dvbpsi_descriptor_s * dvbpsi_GenPDCDr(struct dvbpsi_PDC_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenParentalRatingDr
// file descriptors/dr_55.c line 92
struct dvbpsi_descriptor_s * dvbpsi_GenParentalRatingDr(struct dvbpsi_parental_rating_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenPrivateDataDr
// file descriptors/dr_0f.c line 82
struct dvbpsi_descriptor_s * dvbpsi_GenPrivateDataDr(struct dvbpsi_private_data_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenRegistrationDr
// file descriptors/dr_05.c line 94
struct dvbpsi_descriptor_s * dvbpsi_GenRegistrationDr(struct dvbpsi_registration_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenSTDDr
// file descriptors/dr_11.c line 63
struct dvbpsi_descriptor_s * dvbpsi_GenSTDDr(struct dvbpsi_std_dr_s *p_decoded);
// dvbpsi_GenSatDelivSysDr
// file descriptors/dr_43.c line 92
struct dvbpsi_descriptor_s * dvbpsi_GenSatDelivSysDr(struct dvbpsi_sat_deliv_sys_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenServiceDr
// file descriptors/dr_48.c line 111
struct dvbpsi_descriptor_s * dvbpsi_GenServiceDr(struct dvbpsi_service_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenServiceListDr
// file descriptors/dr_41.c line 89
struct dvbpsi_descriptor_s * dvbpsi_GenServiceListDr(struct dvbpsi_service_list_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenServiceLocationDr
// file descriptors/dr_a1.c line 98
struct dvbpsi_descriptor_s * dvbpsi_GenServiceLocationDr(struct dvbpsi_service_location_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenShortEventDr
// file descriptors/dr_4d.c line 94
struct dvbpsi_descriptor_s * dvbpsi_GenShortEventDr(struct dvbpsi_short_event_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenSmoothingBufferDr
// file descriptors/dr_10.c line 72
struct dvbpsi_descriptor_s * dvbpsi_GenSmoothingBufferDr(struct dvbpsi_smoothing_buffer_dr_s *p_decoded);
// dvbpsi_GenStreamIdentifierDr
// file descriptors/dr_52.c line 78
struct dvbpsi_descriptor_s * dvbpsi_GenStreamIdentifierDr(struct dvbpsi_stream_identifier_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenStuffingDr
// file descriptors/dr_42.c line 83
struct dvbpsi_descriptor_s * dvbpsi_GenStuffingDr(struct dvbpsi_stuffing_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenSubtitlingDr
// file descriptors/dr_59.c line 105
struct dvbpsi_descriptor_s * dvbpsi_GenSubtitlingDr(struct dvbpsi_subtitling_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenSystemClockDr
// file descriptors/dr_0b.c line 82
struct dvbpsi_descriptor_s * dvbpsi_GenSystemClockDr(struct dvbpsi_system_clock_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenTargetBgGridDr
// file descriptors/dr_07.c line 85
struct dvbpsi_descriptor_s * dvbpsi_GenTargetBgGridDr(struct dvbpsi_target_bg_grid_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenTeletextDr
// file descriptors/dr_56.c line 100
struct dvbpsi_descriptor_s * dvbpsi_GenTeletextDr(struct dvbpsi_teletext_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenTerrDelivSysDr
// file descriptors/dr_5a.c line 89
struct dvbpsi_descriptor_s * dvbpsi_GenTerrDelivSysDr(struct dvbpsi_terr_deliv_sys_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenTimeShiftedEventDr
// file descriptors/dr_4f.c line 78
struct dvbpsi_descriptor_s * dvbpsi_GenTimeShiftedEventDr(struct dvbpsi_tshifted_ev_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenTimeShiftedServiceDr
// file descriptors/dr_4c.c line 76
struct dvbpsi_descriptor_s * dvbpsi_GenTimeShiftedServiceDr(struct dvbpsi_tshifted_service_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenVBIDataDr
// file descriptors/dr_45.c line 106
struct dvbpsi_descriptor_s * dvbpsi_GenVBIDataDr(struct dvbpsi_vbi_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenVStreamDr
// file descriptors/dr_02.c line 93
struct dvbpsi_descriptor_s * dvbpsi_GenVStreamDr(struct dvbpsi_vstream_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_GenVWindowDr
// file descriptors/dr_08.c line 84
struct dvbpsi_descriptor_s * dvbpsi_GenVWindowDr(struct dvbpsi_vwindow_dr_s *p_decoded, _Bool b_duplicate);
// dvbpsi_IsCompleteEIT
// file tables/eit.c line 329
static _Bool dvbpsi_IsCompleteEIT(struct dvbpsi_eit_decoder_s *p_eit_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_IsDescriptor
// file descriptor.c line 49
static inline _Bool dvbpsi_IsDescriptor(struct dvbpsi_descriptor_s *p_descriptor, const unsigned char i_tag);
// dvbpsi_IsDescriptorDecoded
// file descriptor.c line 59
_Bool dvbpsi_IsDescriptorDecoded(struct dvbpsi_descriptor_s *p_descriptor);
// dvbpsi_NewDemuxSubDecoder
// file demux.c line 161
struct dvbpsi_demux_subdec_s * dvbpsi_NewDemuxSubDecoder(const unsigned char i_table_id, const unsigned short int i_extension, void (*pf_detach)(struct dvbpsi_s *, unsigned char, unsigned short int), void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_decoder_s *, struct dvbpsi_psi_section_s *), struct dvbpsi_decoder_s *p_decoder);
// dvbpsi_NewDemuxSubDecoder::pf_detach$object
//
void pf_detach$object(struct dvbpsi_s *, unsigned char, unsigned short int);
// dvbpsi_NewDemuxSubDecoder::pf_gather$object
//
void pf_gather$object(struct dvbpsi_s *, struct dvbpsi_decoder_s *, struct dvbpsi_psi_section_s *);
// dvbpsi_NewDescriptor
// file descriptor.c line 85
struct dvbpsi_descriptor_s * dvbpsi_NewDescriptor(unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_NewPSISection
// file psi.h line 108
struct dvbpsi_psi_section_s * dvbpsi_NewPSISection(signed int i_max_size);
// dvbpsi_ReInitBAT
// file tables/bat.c line 282
static void dvbpsi_ReInitBAT(struct dvbpsi_bat_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ReInitCAT
// file tables/cat.c line 172
static void dvbpsi_ReInitCAT(struct dvbpsi_cat_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ReInitEIT
// file tables/eit.c line 279
static void dvbpsi_ReInitEIT(struct dvbpsi_eit_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ReInitEIT$link1
// file tables/atsc_eit.c line 295
static void dvbpsi_ReInitEIT$link1(struct dvbpsi_atsc_eit_decoder_s *p_decoder$link1, const _Bool b_force$link1);
// dvbpsi_ReInitETT
// file tables/atsc_ett.c line 228
static void dvbpsi_ReInitETT(struct dvbpsi_atsc_ett_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ReInitMGT
// file tables/atsc_mgt.c line 320
static void dvbpsi_ReInitMGT(struct dvbpsi_atsc_mgt_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ReInitNIT
// file tables/nit.c line 283
static void dvbpsi_ReInitNIT(struct dvbpsi_nit_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ReInitPAT
// file tables/pat.c line 191
static void dvbpsi_ReInitPAT(struct dvbpsi_pat_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ReInitPMT
// file tables/pmt.c line 245
static void dvbpsi_ReInitPMT(struct dvbpsi_pmt_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ReInitSDT
// file tables/sdt.c line 264
static void dvbpsi_ReInitSDT(struct dvbpsi_sdt_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ReInitSIS
// file tables/sis.c line 243
static void dvbpsi_ReInitSIS(struct dvbpsi_sis_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ReInitSTT
// file tables/atsc_stt.c line 235
static void dvbpsi_ReInitSTT(struct dvbpsi_atsc_stt_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ReInitTOT
// file tables/tot.c line 222
static void dvbpsi_ReInitTOT(struct dvbpsi_tot_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ReInitVCT
// file tables/atsc_vct.c line 360
static void dvbpsi_ReInitVCT(struct dvbpsi_atsc_vct_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_ValidPSISection
// file psi.h line 150
_Bool dvbpsi_ValidPSISection(struct dvbpsi_psi_section_s *p_section);
// dvbpsi_aac_profile_and_level_lookup
// file descriptors/dr_7c.c line 116
static enum dvbpsi_aac_profile_and_level_s dvbpsi_aac_profile_and_level_lookup(const unsigned char value);
// dvbpsi_aac_profile_and_level_to_hex
// file descriptors/dr_7c.c line 129
static unsigned char dvbpsi_aac_profile_and_level_to_hex(const enum dvbpsi_aac_profile_and_level_s profile_and_level);
// dvbpsi_aac_type_lookup
// file descriptors/dr_7c.c line 175
static enum dvbpsi_aac_type_s dvbpsi_aac_type_lookup(const unsigned char value);
// dvbpsi_aac_type_to_hex
// file descriptors/dr_7c.c line 198
static unsigned char dvbpsi_aac_type_to_hex(const enum dvbpsi_aac_type_s type);
// dvbpsi_atsc_AttachEIT
// file ../../src/tables/atsc_eit.h line 116
_Bool dvbpsi_atsc_AttachEIT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_atsc_eit_s *), void *p_cb_data);
// dvbpsi_atsc_AttachEIT::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_atsc_eit_s *);
// dvbpsi_atsc_AttachETT
// file ../../src/tables/atsc_ett.h line 103
_Bool dvbpsi_atsc_AttachETT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_atsc_ett_s *), void *p_cb_data);
// dvbpsi_atsc_AttachETT::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_atsc_ett_s *);
// dvbpsi_atsc_AttachMGT
// file ../../src/tables/atsc_mgt.h line 116
_Bool dvbpsi_atsc_AttachMGT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_atsc_mgt_s *), void *p_cb_data);
// dvbpsi_atsc_AttachMGT::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_atsc_mgt_s *);
// dvbpsi_atsc_AttachSTT
// file ../../src/tables/atsc_stt.h line 87
_Bool dvbpsi_atsc_AttachSTT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_stt_callback)(void *, struct dvbpsi_atsc_stt_s *), void *p_cb_data);
// dvbpsi_atsc_AttachSTT::pf_stt_callback$object
//
void pf_stt_callback$object(void *, struct dvbpsi_atsc_stt_s *);
// dvbpsi_atsc_AttachVCT
// file ../../src/tables/atsc_vct.h line 129
_Bool dvbpsi_atsc_AttachVCT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_vct_callback)(void *, struct dvbpsi_atsc_vct_s *), void *p_cb_data);
// dvbpsi_atsc_AttachVCT::pf_vct_callback$object
//
void pf_vct_callback$object(void *, struct dvbpsi_atsc_vct_s *);
// dvbpsi_atsc_DecodeEITSections
// file tables/atsc_eit.c line 493
static void dvbpsi_atsc_DecodeEITSections(struct dvbpsi_atsc_eit_s *p_eit, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_atsc_DecodeETTSections
// file tables/atsc_ett.c line 409
static void dvbpsi_atsc_DecodeETTSections(struct dvbpsi_atsc_ett_s *p_ett, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_atsc_DecodeMGTSections
// file tables/atsc_mgt.c line 516
static void dvbpsi_atsc_DecodeMGTSections(struct dvbpsi_atsc_mgt_s *p_mgt, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_atsc_DecodeSTTSections
// file tables/atsc_stt.c line 421
static void dvbpsi_atsc_DecodeSTTSections(struct dvbpsi_atsc_stt_s *p_stt, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_atsc_DecodeVCTSections
// file tables/atsc_vct.c line 554
static void dvbpsi_atsc_DecodeVCTSections(struct dvbpsi_atsc_vct_s *p_vct, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_atsc_DeleteEIT
// file ../../src/tables/atsc_eit.h line 187
void dvbpsi_atsc_DeleteEIT(struct dvbpsi_atsc_eit_s *p_eit);
// dvbpsi_atsc_DeleteETT
// file ../../src/tables/atsc_ett.h line 175
void dvbpsi_atsc_DeleteETT(struct dvbpsi_atsc_ett_s *p_ett);
// dvbpsi_atsc_DeleteMGT
// file ../../src/tables/atsc_mgt.h line 182
void dvbpsi_atsc_DeleteMGT(struct dvbpsi_atsc_mgt_s *p_mgt);
// dvbpsi_atsc_DeleteSTT
// file ../../src/tables/atsc_stt.h line 153
void dvbpsi_atsc_DeleteSTT(struct dvbpsi_atsc_stt_s *p_stt);
// dvbpsi_atsc_DeleteVCT
// file ../../src/tables/atsc_vct.h line 209
void dvbpsi_atsc_DeleteVCT(struct dvbpsi_atsc_vct_s *p_vct);
// dvbpsi_atsc_DetachEIT
// file tables/atsc_eit.c line 130
void dvbpsi_atsc_DetachEIT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension);
// dvbpsi_atsc_DetachETT
// file tables/atsc_ett.c line 134
void dvbpsi_atsc_DetachETT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension);
// dvbpsi_atsc_DetachMGT
// file tables/atsc_mgt.c line 134
void dvbpsi_atsc_DetachMGT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension);
// dvbpsi_atsc_DetachSTT
// file tables/atsc_stt.c line 120
void dvbpsi_atsc_DetachSTT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension);
// dvbpsi_atsc_DetachVCT
// file tables/atsc_vct.c line 144
void dvbpsi_atsc_DetachVCT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension);
// dvbpsi_atsc_EITAddEvent
// file tables/atsc_eit.c line 229
static struct dvbpsi_atsc_eit_event_s * dvbpsi_atsc_EITAddEvent(struct dvbpsi_atsc_eit_s *p_eit, unsigned short int i_event_id, unsigned int i_start_time, unsigned char i_etm_location, unsigned int i_length_seconds, unsigned char i_title_length, unsigned char *p_title);
// dvbpsi_atsc_EITChannelAddDescriptor
// file tables/atsc_eit.c line 273
static struct dvbpsi_descriptor_s * dvbpsi_atsc_EITChannelAddDescriptor(struct dvbpsi_atsc_eit_event_s *p_event, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_atsc_EmptyEIT
// file tables/atsc_eit.c line 199
void dvbpsi_atsc_EmptyEIT(struct dvbpsi_atsc_eit_s *p_eit);
// dvbpsi_atsc_EmptyETT
// file tables/atsc_ett.c line 205
void dvbpsi_atsc_EmptyETT(struct dvbpsi_atsc_ett_s *p_ett);
// dvbpsi_atsc_EmptyMGT
// file tables/atsc_mgt.c line 200
void dvbpsi_atsc_EmptyMGT(struct dvbpsi_atsc_mgt_s *p_mgt);
// dvbpsi_atsc_EmptySTT
// file tables/atsc_stt.c line 191
void dvbpsi_atsc_EmptySTT(struct dvbpsi_atsc_stt_s *p_stt);
// dvbpsi_atsc_EmptyVCT
// file tables/atsc_vct.c line 215
void dvbpsi_atsc_EmptyVCT(struct dvbpsi_atsc_vct_s *p_vct);
// dvbpsi_atsc_GatherEITSections
// file tables/atsc_eit.c line 382
static void dvbpsi_atsc_GatherEITSections(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_atsc_GatherETTSections
// file tables/atsc_ett.c line 320
static void dvbpsi_atsc_GatherETTSections(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_atsc_GatherMGTSections
// file tables/atsc_mgt.c line 405
static void dvbpsi_atsc_GatherMGTSections(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_atsc_GatherSTTSections
// file tables/atsc_stt.c line 310
static void dvbpsi_atsc_GatherSTTSections(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_atsc_GatherVCTSections
// file tables/atsc_vct.c line 445
static void dvbpsi_atsc_GatherVCTSections(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_atsc_InitEIT
// file tables/atsc_eit.c line 165
void dvbpsi_atsc_InitEIT(struct dvbpsi_atsc_eit_s *p_eit, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, unsigned char i_protocol, unsigned short int i_source_id, _Bool b_current_next);
// dvbpsi_atsc_InitETT
// file tables/atsc_ett.c line 170
void dvbpsi_atsc_InitETT(struct dvbpsi_atsc_ett_s *p_ett, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, unsigned char i_protocol, unsigned int i_etm_id, _Bool b_current_next);
// dvbpsi_atsc_InitMGT
// file tables/atsc_mgt.c line 170
void dvbpsi_atsc_InitMGT(struct dvbpsi_atsc_mgt_s *p_mgt, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, unsigned char i_protocol, _Bool b_current_next);
// dvbpsi_atsc_InitSTT
// file tables/atsc_stt.c line 157
void dvbpsi_atsc_InitSTT(struct dvbpsi_atsc_stt_s *p_stt, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next);
// dvbpsi_atsc_InitVCT
// file tables/atsc_vct.c line 194
void dvbpsi_atsc_InitVCT(struct dvbpsi_atsc_vct_s *p_vct, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_protocol, _Bool b_cable_vct, unsigned char i_version, _Bool b_current_next);
// dvbpsi_atsc_MGTAddDescriptor
// file tables/atsc_mgt.c line 229
static struct dvbpsi_descriptor_s * dvbpsi_atsc_MGTAddDescriptor(struct dvbpsi_atsc_mgt_s *p_mgt, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_atsc_MGTAddTable
// file tables/atsc_mgt.c line 253
static struct dvbpsi_atsc_mgt_table_s * dvbpsi_atsc_MGTAddTable(struct dvbpsi_atsc_mgt_s *p_mgt, unsigned short int i_table_type, unsigned short int i_table_type_pid, unsigned char i_table_type_version, unsigned int i_number_bytes);
// dvbpsi_atsc_MGTTableAddDescriptor
// file tables/atsc_mgt.c line 292
static struct dvbpsi_descriptor_s * dvbpsi_atsc_MGTTableAddDescriptor(struct dvbpsi_atsc_mgt_table_s *p_table, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_atsc_NewEIT
// file tables/atsc_eit.c line 182
struct dvbpsi_atsc_eit_s * dvbpsi_atsc_NewEIT(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, unsigned char i_protocol, unsigned short int i_source_id, _Bool b_current_next);
// dvbpsi_atsc_NewETT
// file tables/atsc_ett.c line 188
struct dvbpsi_atsc_ett_s * dvbpsi_atsc_NewETT(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, unsigned char i_protocol, unsigned int i_etm_id, _Bool b_current_next);
// dvbpsi_atsc_NewMGT
// file tables/atsc_mgt.c line 185
struct dvbpsi_atsc_mgt_s * dvbpsi_atsc_NewMGT(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, unsigned char i_protocol, _Bool b_current_next);
// dvbpsi_atsc_NewSTT
// file tables/atsc_stt.c line 176
struct dvbpsi_atsc_stt_s * dvbpsi_atsc_NewSTT(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next);
// dvbpsi_atsc_NewVCT
// file tables/atsc_vct.c line 179
struct dvbpsi_atsc_vct_s * dvbpsi_atsc_NewVCT(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_protocol, _Bool b_cable_vct, unsigned char i_version, _Bool b_current_next);
// dvbpsi_atsc_STTAddDescriptor
// file tables/atsc_stt.c line 215
struct dvbpsi_descriptor_s * dvbpsi_atsc_STTAddDescriptor(struct dvbpsi_atsc_stt_s *p_stt, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_atsc_VCTAddChannel
// file tables/atsc_vct.c line 271
static struct dvbpsi_atsc_vct_channel_s * dvbpsi_atsc_VCTAddChannel(struct dvbpsi_atsc_vct_s *p_vct, unsigned char *p_short_name, unsigned short int i_major_number, unsigned short int i_minor_number, unsigned char i_modulation, unsigned int i_carrier_freq, unsigned short int i_channel_tsid, unsigned short int i_program_number, unsigned char i_etm_location, signed int b_access_controlled, signed int b_hidden, signed int b_path_select, signed int b_out_of_band, signed int b_hide_guide, unsigned char i_service_type, unsigned short int i_source_id);
// dvbpsi_atsc_VCTAddDescriptor
// file tables/atsc_vct.c line 248
static struct dvbpsi_descriptor_s * dvbpsi_atsc_VCTAddDescriptor(struct dvbpsi_atsc_vct_s *p_vct, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_atsc_VCTChannelAddDescriptor
// file tables/atsc_vct.c line 332
static struct dvbpsi_descriptor_s * dvbpsi_atsc_VCTChannelAddDescriptor(struct dvbpsi_atsc_vct_channel_s *p_channel, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_bat_attach
// file ../../src/tables/bat.h line 128
_Bool dvbpsi_bat_attach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_bat_s *), void *p_cb_data);
// dvbpsi_bat_attach::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_bat_s *);
// dvbpsi_bat_bouquet_descriptor_add
// file tables/bat.c line 205
struct dvbpsi_descriptor_s * dvbpsi_bat_bouquet_descriptor_add(struct dvbpsi_bat_s *p_bat, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_bat_delete
// file ../../src/tables/bat.h line 192
void dvbpsi_bat_delete(struct dvbpsi_bat_s *p_bat);
// dvbpsi_bat_detach
// file tables/bat.c line 106
void dvbpsi_bat_detach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension);
// dvbpsi_bat_empty
// file tables/bat.c line 171
void dvbpsi_bat_empty(struct dvbpsi_bat_s *p_bat);
// dvbpsi_bat_init
// file tables/bat.c line 139
void dvbpsi_bat_init(struct dvbpsi_bat_s *p_bat, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next);
// dvbpsi_bat_new
// file tables/bat.c line 157
struct dvbpsi_bat_s * dvbpsi_bat_new(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next);
// dvbpsi_bat_sections_decode
// file tables/bat.c line 467
void dvbpsi_bat_sections_decode(struct dvbpsi_bat_s *p_bat, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_bat_sections_gather
// file tables/bat.c line 364
void dvbpsi_bat_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_bat_sections_generate
// file tables/bat.c line 533
struct dvbpsi_psi_section_s * dvbpsi_bat_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_bat_s *p_bat);
// dvbpsi_bat_ts_add
// file tables/bat.c line 228
struct dvbpsi_bat_ts_s * dvbpsi_bat_ts_add(struct dvbpsi_bat_s *p_bat, unsigned short int i_ts_id, unsigned short int i_orig_network_id);
// dvbpsi_bat_ts_descriptor_add
// file tables/bat.c line 260
struct dvbpsi_descriptor_s * dvbpsi_bat_ts_descriptor_add(struct dvbpsi_bat_ts_s *p_bat, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_cat_attach
// file ../../src/tables/cat.h line 88
_Bool dvbpsi_cat_attach(struct dvbpsi_s *p_dvbpsi, void (*pf_callback)(void *, struct dvbpsi_cat_s *), void *p_cb_data);
// dvbpsi_cat_attach::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_cat_s *);
// dvbpsi_cat_delete
// file ../../src/tables/cat.h line 147
void dvbpsi_cat_delete(struct dvbpsi_cat_s *p_cat);
// dvbpsi_cat_descriptor_add
// file tables/cat.c line 153
struct dvbpsi_descriptor_s * dvbpsi_cat_descriptor_add(struct dvbpsi_cat_s *p_cat, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_cat_detach
// file ../../src/tables/cat.h line 103
void dvbpsi_cat_detach(struct dvbpsi_s *p_dvbpsi);
// dvbpsi_cat_empty
// file tables/cat.c line 130
void dvbpsi_cat_empty(struct dvbpsi_cat_s *p_cat);
// dvbpsi_cat_init
// file tables/cat.c line 103
void dvbpsi_cat_init(struct dvbpsi_cat_s *p_cat, unsigned char i_version, _Bool b_current_next);
// dvbpsi_cat_new
// file tables/cat.c line 117
struct dvbpsi_cat_s * dvbpsi_cat_new(unsigned char i_version, _Bool b_current_next);
// dvbpsi_cat_sections_decode
// file tables/cat.c line 340
void dvbpsi_cat_sections_decode(struct dvbpsi_cat_s *p_cat, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_cat_sections_gather
// file tables/cat.c line 259
void dvbpsi_cat_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_cat_sections_generate
// file tables/cat.c line 365
struct dvbpsi_psi_section_s * dvbpsi_cat_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_cat_s *p_cat);
// dvbpsi_decoder_delete
// file dvbpsi.c line 225
void dvbpsi_decoder_delete(struct dvbpsi_decoder_s *p_decoder);
// dvbpsi_decoder_new
// file dvbpsi.c line 79
void * dvbpsi_decoder_new(void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *), const signed int i_section_max_size, const _Bool b_discontinuity, const unsigned long int psi_size);
// dvbpsi_decoder_new::pf_gather$object
//
void pf_gather$object(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
// dvbpsi_decoder_present
// file ../../src/dvbpsi.h line 351
_Bool dvbpsi_decoder_present(struct dvbpsi_s *p_dvbpsi);
// dvbpsi_decoder_psi_section_add
// file dvbpsi.c line 148
_Bool dvbpsi_decoder_psi_section_add(struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_decoder_psi_sections_completed
// file dvbpsi.c line 123
_Bool dvbpsi_decoder_psi_sections_completed(struct dvbpsi_decoder_s *p_decoder);
// dvbpsi_decoder_reset
// file dvbpsi.c line 107
void dvbpsi_decoder_reset(struct dvbpsi_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_delete
// file ../../src/dvbpsi.h line 185
void dvbpsi_delete(struct dvbpsi_s *p_dvbpsi);
// dvbpsi_demuxGetSubDec
// file demux.c line 79
struct dvbpsi_demux_subdec_s * dvbpsi_demuxGetSubDec(struct dvbpsi_demux_s *p_demux, unsigned char i_table_id, unsigned short int i_extension);
// dvbpsi_eit_attach
// file ../../src/tables/eit.h line 127
_Bool dvbpsi_eit_attach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_eit_s *), void *p_cb_data);
// dvbpsi_eit_attach::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_eit_s *);
// dvbpsi_eit_delete
// file ../../src/tables/eit.h line 211
void dvbpsi_eit_delete(struct dvbpsi_eit_s *p_eit);
// dvbpsi_eit_detach
// file tables/eit.c line 106
void dvbpsi_eit_detach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension);
// dvbpsi_eit_empty
// file tables/eit.c line 180
void dvbpsi_eit_empty(struct dvbpsi_eit_s *p_eit);
// dvbpsi_eit_event_add
// file tables/eit.c line 211
struct dvbpsi_eit_event_s * dvbpsi_eit_event_add(struct dvbpsi_eit_s *p_eit, unsigned short int i_event_id, unsigned long int i_start_time, unsigned int i_duration, unsigned char i_running_status, _Bool b_free_ca, unsigned short int i_event_descriptor_length);
// dvbpsi_eit_event_descriptor_add
// file tables/eit.c line 261
struct dvbpsi_descriptor_s * dvbpsi_eit_event_descriptor_add(struct dvbpsi_eit_event_s *p_event, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_eit_init
// file tables/eit.c line 140
void dvbpsi_eit_init(struct dvbpsi_eit_s *p_eit, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned short int i_ts_id, unsigned short int i_network_id, unsigned char i_segment_last_section_number, unsigned char i_last_table_id);
// dvbpsi_eit_new
// file tables/eit.c line 162
struct dvbpsi_eit_s * dvbpsi_eit_new(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned short int i_ts_id, unsigned short int i_network_id, unsigned char i_segment_last_section_number, unsigned char i_last_table_id);
// dvbpsi_eit_nvod_event_add
// file tables/eit.c line 248
struct dvbpsi_eit_event_s * dvbpsi_eit_nvod_event_add(struct dvbpsi_eit_s *p_eit, unsigned short int i_event_id, unsigned int i_duration, _Bool b_free_ca, unsigned short int i_event_descriptor_length);
// dvbpsi_eit_sections_decode
// file tables/eit.c line 515
void dvbpsi_eit_sections_decode(struct dvbpsi_eit_s *p_eit, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_eit_sections_gather
// file tables/eit.c line 424
void dvbpsi_eit_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_private_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_eit_sections_generate
// file tables/eit.c line 641
struct dvbpsi_psi_section_s * dvbpsi_eit_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_eit_s *p_eit, unsigned char i_table_id);
// dvbpsi_has_CRC32
// file psi.h line 188
static inline _Bool dvbpsi_has_CRC32(struct dvbpsi_psi_section_s *p_section);
// dvbpsi_has_CRC32$link1
// file psi.h line 188
static inline _Bool dvbpsi_has_CRC32$link1(struct dvbpsi_psi_section_s *p_section$link1);
// dvbpsi_message
// file libdvbpsi.c line 331
static void dvbpsi_message(struct dvbpsi_s *p_dvbpsi, const enum dvbpsi_msg_level level, const char *msg);
// dvbpsi_message$link1
// file dvbpsi.c line 518
void dvbpsi_message$link1(struct dvbpsi_s *dvbpsi, const enum dvbpsi_msg_level level$link1, const char *fmt, ...);
// dvbpsi_new
// file ../../src/dvbpsi.h line 171
struct dvbpsi_s * dvbpsi_new(void (*callback)(struct dvbpsi_s *, const enum dvbpsi_msg_level, const char *), enum dvbpsi_msg_level level);
// dvbpsi_new::callback$object
//
void callback$object(struct dvbpsi_s *, const enum dvbpsi_msg_level, const char *);
// dvbpsi_nit_attach
// file ../../src/tables/nit.h line 122
_Bool dvbpsi_nit_attach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_nit_s *), void *p_cb_data);
// dvbpsi_nit_attach::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_nit_s *);
// dvbpsi_nit_delete
// file ../../src/tables/nit.h line 191
void dvbpsi_nit_delete(struct dvbpsi_nit_s *p_nit);
// dvbpsi_nit_descriptor_add
// file tables/nit.c line 209
struct dvbpsi_descriptor_s * dvbpsi_nit_descriptor_add(struct dvbpsi_nit_s *p_nit, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_nit_detach
// file tables/nit.c line 109
void dvbpsi_nit_detach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension);
// dvbpsi_nit_empty
// file tables/nit.c line 174
void dvbpsi_nit_empty(struct dvbpsi_nit_s *p_nit);
// dvbpsi_nit_init
// file tables/nit.c line 140
void dvbpsi_nit_init(struct dvbpsi_nit_s *p_nit, unsigned char i_table_id, unsigned short int i_extension, unsigned short int i_network_id, unsigned char i_version, _Bool b_current_next);
// dvbpsi_nit_new
// file tables/nit.c line 158
struct dvbpsi_nit_s * dvbpsi_nit_new(unsigned char i_table_id, unsigned short int i_extension, unsigned short int i_network_id, unsigned char i_version, _Bool b_current_next);
// dvbpsi_nit_sections_decode
// file tables/nit.c line 453
void dvbpsi_nit_sections_decode(struct dvbpsi_nit_s *p_nit, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_nit_sections_gather
// file tables/nit.c line 359
void dvbpsi_nit_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_private_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_nit_sections_generate
// file tables/nit.c line 518
struct dvbpsi_psi_section_s * dvbpsi_nit_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_nit_s *p_nit, unsigned char i_table_id);
// dvbpsi_nit_ts_add
// file tables/nit.c line 235
struct dvbpsi_nit_ts_s * dvbpsi_nit_ts_add(struct dvbpsi_nit_s *p_nit, unsigned short int i_ts_id, unsigned short int i_orig_network_id);
// dvbpsi_nit_ts_descriptor_add
// file tables/nit.c line 264
struct dvbpsi_descriptor_s * dvbpsi_nit_ts_descriptor_add(struct dvbpsi_nit_ts_s *p_ts, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_packet_push
// file ../../src/dvbpsi.h line 199
_Bool dvbpsi_packet_push(struct dvbpsi_s *p_dvbpsi, unsigned char *p_data);
// dvbpsi_pat_attach
// file ../../src/tables/pat.h line 111
_Bool dvbpsi_pat_attach(struct dvbpsi_s *p_dvbpsi, void (*pf_callback)(void *, struct dvbpsi_pat_s *), void *p_cb_data);
// dvbpsi_pat_attach::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_pat_s *);
// dvbpsi_pat_delete
// file ../../src/tables/pat.h line 171
void dvbpsi_pat_delete(struct dvbpsi_pat_s *p_pat);
// dvbpsi_pat_detach
// file ../../src/tables/pat.h line 125
void dvbpsi_pat_detach(struct dvbpsi_s *p_dvbpsi);
// dvbpsi_pat_empty
// file tables/pat.c line 129
void dvbpsi_pat_empty(struct dvbpsi_pat_s *p_pat);
// dvbpsi_pat_init
// file tables/pat.c line 99
void dvbpsi_pat_init(struct dvbpsi_pat_s *p_pat, unsigned short int i_ts_id, unsigned char i_version, _Bool b_current_next);
// dvbpsi_pat_new
// file tables/pat.c line 115
struct dvbpsi_pat_s * dvbpsi_pat_new(unsigned short int i_ts_id, unsigned char i_version, _Bool b_current_next);
// dvbpsi_pat_program_add
// file tables/pat.c line 159
struct dvbpsi_pat_program_s * dvbpsi_pat_program_add(struct dvbpsi_pat_s *p_pat, unsigned short int i_number, unsigned short int i_pid);
// dvbpsi_pat_sections_decode
// file tables/pat.c line 359
_Bool dvbpsi_pat_sections_decode(struct dvbpsi_pat_s *p_pat, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_pat_sections_gather
// file tables/pat.c line 274
void dvbpsi_pat_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_pat_sections_generate
// file tables/pat.c line 386
struct dvbpsi_psi_section_s * dvbpsi_pat_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_pat_s *p_pat, signed int i_max_pps);
// dvbpsi_pmt_attach
// file ../../src/tables/pmt.h line 121
_Bool dvbpsi_pmt_attach(struct dvbpsi_s *p_dvbpsi, unsigned short int i_program_number, void (*pf_callback)(void *, struct dvbpsi_pmt_s *), void *p_cb_data);
// dvbpsi_pmt_attach::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_pmt_s *);
// dvbpsi_pmt_delete
// file ../../src/tables/pmt.h line 186
void dvbpsi_pmt_delete(struct dvbpsi_pmt_s *p_pmt);
// dvbpsi_pmt_descriptor_add
// file tables/pmt.c line 171
struct dvbpsi_descriptor_s * dvbpsi_pmt_descriptor_add(struct dvbpsi_pmt_s *p_pmt, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_pmt_detach
// file ../../src/tables/pmt.h line 135
void dvbpsi_pmt_detach(struct dvbpsi_s *p_dvbpsi);
// dvbpsi_pmt_empty
// file tables/pmt.c line 136
void dvbpsi_pmt_empty(struct dvbpsi_pmt_s *p_pmt);
// dvbpsi_pmt_es_add
// file tables/pmt.c line 194
struct dvbpsi_pmt_es_s * dvbpsi_pmt_es_add(struct dvbpsi_pmt_s *p_pmt, unsigned char i_type, unsigned short int i_pid);
// dvbpsi_pmt_es_descriptor_add
// file tables/pmt.c line 223
struct dvbpsi_descriptor_s * dvbpsi_pmt_es_descriptor_add(struct dvbpsi_pmt_es_s *p_es, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_pmt_init
// file tables/pmt.c line 103
void dvbpsi_pmt_init(struct dvbpsi_pmt_s *p_pmt, unsigned short int i_program_number, unsigned char i_version, _Bool b_current_next, unsigned short int i_pcr_pid);
// dvbpsi_pmt_new
// file tables/pmt.c line 121
struct dvbpsi_pmt_s * dvbpsi_pmt_new(unsigned short int i_program_number, unsigned char i_version, _Bool b_current_next, unsigned short int i_pcr_pid);
// dvbpsi_pmt_sections_decode
// file tables/pmt.c line 411
void dvbpsi_pmt_sections_decode(struct dvbpsi_pmt_s *p_pmt, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_pmt_sections_gather
// file tables/pmt.c line 322
void dvbpsi_pmt_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_pmt_sections_generate
// file tables/pmt.c line 463
struct dvbpsi_psi_section_s * dvbpsi_pmt_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_pmt_s *p_pmt);
// dvbpsi_rst_attach
// file ../../src/tables/rst.h line 109
_Bool dvbpsi_rst_attach(struct dvbpsi_s *p_dvbpsi, void (*pf_callback)(void *, struct dvbpsi_rst_s *), void *p_cb_data);
// dvbpsi_rst_attach::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_rst_s *);
// dvbpsi_rst_delete
// file ../../src/tables/rst.h line 161
void dvbpsi_rst_delete(struct dvbpsi_rst_s *p_rst);
// dvbpsi_rst_detach
// file ../../src/tables/rst.h line 124
void dvbpsi_rst_detach(struct dvbpsi_s *p_dvbpsi);
// dvbpsi_rst_empty
// file tables/rst.c line 127
void dvbpsi_rst_empty(struct dvbpsi_rst_s *p_rst);
// dvbpsi_rst_event_add
// file tables/rst.c line 161
struct dvbpsi_rst_event_s * dvbpsi_rst_event_add(struct dvbpsi_rst_s *p_rst, unsigned short int i_ts_id, unsigned short int i_orig_network_id, unsigned short int i_service_id, unsigned short int i_event_id, unsigned char i_running_status);
// dvbpsi_rst_init
// file tables/rst.c line 102
void dvbpsi_rst_init(struct dvbpsi_rst_s *p_rst);
// dvbpsi_rst_new
// file tables/rst.c line 114
struct dvbpsi_rst_s * dvbpsi_rst_new(void);
// dvbpsi_rst_reset
// file tables/rst.c line 259
static void dvbpsi_rst_reset(struct dvbpsi_rst_decoder_s *p_decoder, const _Bool b_force);
// dvbpsi_rst_section_add
// file tables/rst.c line 275
static _Bool dvbpsi_rst_section_add(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_rst_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_rst_section_check
// file tables/rst.c line 306
static _Bool dvbpsi_rst_section_check(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section, const unsigned char table_id, const char *psz_table_name);
// dvbpsi_rst_sections_decode
// file tables/rst.c line 403
void dvbpsi_rst_sections_decode(struct dvbpsi_rst_s *p_rst, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_rst_sections_gather
// file tables/rst.c line 346
void dvbpsi_rst_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_rst_sections_generate
// file tables/rst.c line 199
struct dvbpsi_psi_section_s * dvbpsi_rst_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_rst_s *p_rst);
// dvbpsi_sdt_attach
// file ../../src/tables/sdt.h line 128
_Bool dvbpsi_sdt_attach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_sdt_s *), void *p_cb_data);
// dvbpsi_sdt_attach::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_sdt_s *);
// dvbpsi_sdt_delete
// file ../../src/tables/sdt.h line 194
void dvbpsi_sdt_delete(struct dvbpsi_sdt_s *p_sdt);
// dvbpsi_sdt_detach
// file tables/sdt.c line 105
void dvbpsi_sdt_detach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension);
// dvbpsi_sdt_empty
// file tables/sdt.c line 175
void dvbpsi_sdt_empty(struct dvbpsi_sdt_s *p_sdt);
// dvbpsi_sdt_init
// file tables/sdt.c line 141
void dvbpsi_sdt_init(struct dvbpsi_sdt_s *p_sdt, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned short int i_network_id);
// dvbpsi_sdt_new
// file tables/sdt.c line 160
struct dvbpsi_sdt_s * dvbpsi_sdt_new(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned short int i_network_id);
// dvbpsi_sdt_sections_decode
// file tables/sdt.c line 436
void dvbpsi_sdt_sections_decode(struct dvbpsi_sdt_s *p_sdt, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_sdt_sections_gather
// file tables/sdt.c line 349
void dvbpsi_sdt_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_private_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_sdt_sections_generate
// file tables/sdt.c line 479
struct dvbpsi_psi_section_s * dvbpsi_sdt_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sdt_s *p_sdt);
// dvbpsi_sdt_service_add
// file tables/sdt.c line 206
struct dvbpsi_sdt_service_s * dvbpsi_sdt_service_add(struct dvbpsi_sdt_s *p_sdt, unsigned short int i_service_id, _Bool b_eit_schedule, _Bool b_eit_present, unsigned char i_running_status, _Bool b_free_ca);
// dvbpsi_sdt_service_descriptor_add
// file tables/sdt.c line 244
struct dvbpsi_descriptor_s * dvbpsi_sdt_service_descriptor_add(struct dvbpsi_sdt_service_s *p_service, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_sis_attach
// file ../../src/tables/sis.h line 364
_Bool dvbpsi_sis_attach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_sis_s *), void *p_cb_data);
// dvbpsi_sis_attach::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_sis_s *);
// dvbpsi_sis_delete
// file ../../src/tables/sis.h line 430
void dvbpsi_sis_delete(struct dvbpsi_sis_s *p_sis);
// dvbpsi_sis_descriptor_add
// file tables/sis.c line 224
struct dvbpsi_descriptor_s * dvbpsi_sis_descriptor_add(struct dvbpsi_sis_s *p_sis, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_sis_detach
// file tables/sis.c line 107
void dvbpsi_sis_detach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension);
// dvbpsi_sis_empty
// file tables/sis.c line 197
void dvbpsi_sis_empty(struct dvbpsi_sis_s *p_sis);
// dvbpsi_sis_init
// file tables/sis.c line 143
void dvbpsi_sis_init(struct dvbpsi_sis_s *p_sis, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned char i_protocol_version);
// dvbpsi_sis_new
// file tables/sis.c line 182
struct dvbpsi_sis_s * dvbpsi_sis_new(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned char i_protocol_version);
// dvbpsi_sis_sections_decode
// file tables/sis.c line 422
void dvbpsi_sis_sections_decode(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sis_s *p_sis, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_sis_sections_gather
// file tables/sis.c line 331
void dvbpsi_sis_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_sis_sections_generate
// file tables/sis.c line 509
struct dvbpsi_psi_section_s * dvbpsi_sis_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sis_s *p_sis);
// dvbpsi_tot_attach
// file ../../src/tables/tot.h line 97
_Bool dvbpsi_tot_attach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_tot_s *), void *p_cb_data);
// dvbpsi_tot_attach::pf_callback$object
//
void pf_callback$object(void *, struct dvbpsi_tot_s *);
// dvbpsi_tot_delete
// file ../../src/tables/tot.h line 163
void dvbpsi_tot_delete(struct dvbpsi_tot_s *p_tot);
// dvbpsi_tot_descriptor_add
// file tables/tot.c line 203
struct dvbpsi_descriptor_s * dvbpsi_tot_descriptor_add(struct dvbpsi_tot_s *p_tot, unsigned char i_tag, unsigned char i_length, unsigned char *p_data);
// dvbpsi_tot_detach
// file tables/tot.c line 108
void dvbpsi_tot_detach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension);
// dvbpsi_tot_empty
// file tables/tot.c line 180
void dvbpsi_tot_empty(struct dvbpsi_tot_s *p_tot);
// dvbpsi_tot_init
// file tables/tot.c line 145
void dvbpsi_tot_init(struct dvbpsi_tot_s *p_tot, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned long int i_utc_time);
// dvbpsi_tot_new
// file tables/tot.c line 165
struct dvbpsi_tot_s * dvbpsi_tot_new(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned long int i_utc_time);
// dvbpsi_tot_section_valid
// file tables/tot.c line 399
static _Bool dvbpsi_tot_section_valid(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_tot_sections_decode
// file tables/tot.c line 424
void dvbpsi_tot_sections_decode(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_tot_s *p_tot, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_tot_sections_gather
// file tables/tot.c line 309
void dvbpsi_tot_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section);
// dvbpsi_tot_sections_generate
// file tables/tot.c line 474
struct dvbpsi_psi_section_s * dvbpsi_tot_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_tot_s *p_tot);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fifo_count
// file buffer.h line 56
signed long int fifo_count(struct fifo_s *fifo);
// fifo_free
// file buffer.h line 55
void fifo_free(struct fifo_s *fifo);
// fifo_new
// file buffer.h line 54
struct fifo_s * fifo_new(void);
// fifo_pop
// file buffer.h line 59
struct buffer_s * fifo_pop(struct fifo_s *fifo);
// fifo_push
// file buffer.h line 58
void fifo_push(struct fifo_s *fifo, struct buffer_s *buffer);
// fifo_size
// file buffer.h line 57
unsigned long int fifo_size(struct fifo_s *fifo);
// fifo_wake
// file buffer.h line 60
void fifo_wake(struct fifo_s *fifo);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// handle_BAT
// file libdvbpsi.c line 2148
static void handle_BAT(void *p_data, struct dvbpsi_bat_s *p_bat);
// handle_CAT
// file libdvbpsi.c line 2206
static void handle_CAT(void *p_data, struct dvbpsi_cat_s *p_cat);
// handle_EIT
// file libdvbpsi.c line 1769
static void handle_EIT(void *p_data, struct dvbpsi_eit_s *p_eit);
// handle_NIT
// file libdvbpsi.c line 2118
static void handle_NIT(void *p_data, struct dvbpsi_nit_s *p_nit);
// handle_PAT
// file libdvbpsi.c line 713
static void handle_PAT(void *p_data, struct dvbpsi_pat_s *p_pat);
// handle_PMT
// file libdvbpsi.c line 2165
static void handle_PMT(void *p_data, struct dvbpsi_pmt_s *p_pmt);
// handle_RST
// file libdvbpsi.c line 2092
static void handle_RST(void *p_data, struct dvbpsi_rst_s *p_rst);
// handle_SDT
// file libdvbpsi.c line 1715
static void handle_SDT(void *p_data, struct dvbpsi_sdt_s *p_sdt);
// handle_SIS
// file libdvbpsi.c line 1547
static void handle_SIS(void *p_data, struct dvbpsi_sis_s *p_sis);
// handle_TOT
// file libdvbpsi.c line 1788
static void handle_TOT(void *p_data, struct dvbpsi_tot_s *p_tot);
// handle_atsc_EIT
// file libdvbpsi.c line 2003
static void handle_atsc_EIT(void *p_data, struct dvbpsi_atsc_eit_s *p_eit);
// handle_atsc_ETT
// file libdvbpsi.c line 2022
static void handle_atsc_ETT(void *p_data, struct dvbpsi_atsc_ett_s *p_ett);
// handle_atsc_MGT
// file libdvbpsi.c line 1843
static void handle_atsc_MGT(void *p_data, struct dvbpsi_atsc_mgt_s *p_mgt);
// handle_atsc_STT
// file libdvbpsi.c line 2042
static void handle_atsc_STT(void *p_data, struct dvbpsi_atsc_stt_s *p_stt);
// handle_atsc_VCT
// file libdvbpsi.c line 1968
static void handle_atsc_VCT(void *p_data, struct dvbpsi_atsc_vct_s *p_vct);
// handle_subtable
// file libdvbpsi.c line 590
static void handle_subtable(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void *p_data);
// if_nametoindex
// file /usr/include/net/if.h line 193
extern unsigned int if_nametoindex(const char *);
// is_ipv6
// file udp.c line 177
static _Bool is_ipv6(const char *ipaddress);
// is_multicast
// file udp.c line 69
static _Bool is_multicast(struct sockaddr_storage *saddr, unsigned int len);
// libdvbpsi_exit
// file libdvbpsi.h line 46
void libdvbpsi_exit(struct ts_stream_t *stream);
// libdvbpsi_init
// file libdvbpsi.h line 43
struct ts_stream_t * libdvbpsi_init(signed int debug, void (*pf_log)(void *, const signed int, const char *, ...), void *cb_data);
// libdvbpsi_init::pf_log$object
//
void pf_log$object(void *, const signed int, const char *, ...);
// libdvbpsi_log
// file dvbinfo.c line 154
static void libdvbpsi_log(void *data, const signed int level, const char *format, ...);
// libdvbpsi_process
// file libdvbpsi.h line 44
_Bool libdvbpsi_process(struct ts_stream_t *stream, unsigned char *buf, signed long int length, signed long int date);
// libdvbpsi_summary
// file libdvbpsi.h line 45
void libdvbpsi_summary(struct _IO_FILE *fd, struct ts_stream_t *stream, const signed int summary_mode);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mcast_connect
// file udp.c line 97
static _Bool mcast_connect(signed int s, const char *interface, struct sockaddr_storage *saddr, unsigned int len);
// mdate
// file libdvbpsi.h line 30
signed long int mdate(void);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// params_free
// file dvbinfo.c line 221
static void params_free(struct params_s *param);
// params_init
// file dvbinfo.c line 190
static struct params_s * params_init(void);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$2 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$2 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$2 *, const union anonymous$0 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$2 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$2 *, union anonymous *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous$0 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// summary
// file libdvbpsi.c line 480
static void summary(struct _IO_FILE *fd, struct ts_stream_t *stream);
// summary_packet
// file libdvbpsi.c line 572
static void summary_packet(struct _IO_FILE *fd, struct ts_stream_t *stream);
// summary_table
// file libdvbpsi.c line 540
static void summary_table(struct _IO_FILE *fd, struct ts_stream_t *stream);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// tcp_close
// file tcp.h line 27
signed int tcp_close(signed int fd);
// tcp_open
// file tcp.h line 26
signed int tcp_open(const char *ipaddress, signed int port);
// tcp_read
// file tcp.h line 28
signed long int tcp_read(signed int fd, void *buf, unsigned long int count);
// ts_dump_packet_details
// file libdvbpsi.c line 464
static void ts_dump_packet_details(struct _IO_FILE *fd, struct ts_stream_t *stream, const unsigned char *data, const unsigned short int i_pid);
// ts_header_dump
// file libdvbpsi.c line 377
static void ts_header_dump(struct _IO_FILE *fd, struct ts_pid_s *ts);
// ts_hexdump
// file libdvbpsi.c line 365
static void ts_hexdump(struct _IO_FILE *fd, const unsigned char * const data, const unsigned int length);
// udp_close
// file udp.h line 28
signed int udp_close(signed int fd);
// udp_open
// file udp.h line 27
signed int udp_open(const char *interface, const char *ipaddress, signed int port);
// udp_read
// file udp.h line 29
signed long int udp_read(signed int fd, void *buf, unsigned long int count);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file dvbinfo.c line 113
static void usage(void);
// vasprintf
// file /usr/include/stdio.h line 399
extern signed int vasprintf(char ** restrict , const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$3
{
  // handle
  struct dvbpsi_s *handle;
  // i_pat_version
  signed int i_pat_version;
  // i_ts_id
  signed int i_ts_id;
  // pid
  struct ts_pid_s *pid;
};

struct anonymous$11
{
  // iso_639_code
  unsigned char iso_639_code[3l];
};

struct anonymous$9
{
  // iso_639_code
  unsigned char iso_639_code[3l];
  // i_audio_type
  unsigned char i_audio_type;
};

struct anonymous$4
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$10
{
  // i_service_id
  unsigned short int i_service_id;
  // i_service_type
  unsigned char i_service_type;
};

struct anonymous$8
{
  // i_category
  const signed int i_category;
  // p_category
  const char *p_category;
};

union anonymous$5
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$1
{
  // path
  unsigned char path[253l];
  // ref
  unsigned short int ref;
};

union anonymous$0
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$2
{
  // __data
  struct anonymous$4 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$6
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$7
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct buffer_s
{
  // i_size
  unsigned long int i_size;
  // i_date
  signed long int i_date;
  // p_next
  struct buffer_s *p_next;
  // p_data
  unsigned char *p_data;
};

struct dvbinfo_capture_s
{
  // fifo
  struct fifo_s *fifo;
  // empty
  struct fifo_s *empty;
  // lock
  union anonymous lock;
  // fifo_full
  union anonymous$2 fifo_full;
  // b_fifo_full
  _Bool b_fifo_full;
  // size
  unsigned long int size;
  // params
  struct params_s *params;
  // b_alive
  _Bool b_alive;
};

struct dvbpsi_PDC_dr_s
{
  // i_PDC
  unsigned char i_PDC[4l];
};

struct dvbpsi_aac_dr_s
{
  // i_profile_and_level
  enum dvbpsi_aac_profile_and_level_s i_profile_and_level;
  // b_type
  _Bool b_type;
  // i_type
  enum dvbpsi_aac_type_s i_type;
  // i_additional_info_length
  unsigned char i_additional_info_length;
  // p_additional_info
  unsigned char *p_additional_info;
};

struct dvbpsi_aac_profile_and_level_table_s
{
  // hex
  unsigned char hex;
  // profile_and_level
  enum dvbpsi_aac_profile_and_level_s profile_and_level;
};

struct dvbpsi_aac_type_table_s
{
  // hex
  unsigned char hex;
  // type
  enum dvbpsi_aac_type_s type;
};

struct dvbpsi_ac3_audio_dr_s
{
  // i_sample_rate_code
  unsigned char i_sample_rate_code;
  // i_bsid
  unsigned char i_bsid;
  // i_bit_rate_code
  unsigned char i_bit_rate_code;
  // i_surround_mode
  unsigned char i_surround_mode;
  // i_bsmod
  unsigned char i_bsmod;
  // i_num_channels
  unsigned char i_num_channels;
  // b_full_svc
  signed int b_full_svc;
  // i_lang_code
  unsigned char i_lang_code;
  // i_lang_code2
  unsigned char i_lang_code2;
  // i_mainid
  unsigned char i_mainid;
  // i_priority
  unsigned char i_priority;
  // i_asvcflags
  unsigned char i_asvcflags;
  // i_textlen
  unsigned char i_textlen;
  // b_text_code
  signed int b_text_code;
  // text
  unsigned char text[128l];
  // b_language_flag
  signed int b_language_flag;
  // b_language_flag_2
  signed int b_language_flag_2;
  // language
  unsigned char language[3l];
  // language_2
  unsigned char language_2[3l];
};

struct dvbpsi_association_tag_dr_s
{
  // i_tag
  unsigned short int i_tag;
  // i_use
  unsigned short int i_use;
  // i_selector_len
  unsigned char i_selector_len;
  // p_selector
  unsigned char *p_selector;
  // i_private_data_len
  unsigned char i_private_data_len;
  // p_private_data
  unsigned char *p_private_data;
};

struct dvbpsi_astream_dr_s
{
  // b_free_format
  _Bool b_free_format;
  // i_id
  unsigned char i_id;
  // i_layer
  unsigned char i_layer;
  // b_variable_rate_audio_indicator
  _Bool b_variable_rate_audio_indicator;
};

struct dvbpsi_atsc_eit_s
{
  // i_table_id
  unsigned char i_table_id;
  // i_extension
  unsigned short int i_extension;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // i_source_id
  unsigned short int i_source_id;
  // i_protocol
  unsigned char i_protocol;
  // p_first_event
  struct dvbpsi_atsc_eit_event_s *p_first_event;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
};

struct dvbpsi_atsc_eit_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_eit_callback
  void (*pf_eit_callback)(void *, struct dvbpsi_atsc_eit_s *);
  // p_cb_data
  void *p_cb_data;
  // current_eit
  struct dvbpsi_atsc_eit_s current_eit;
  // p_building_eit
  struct dvbpsi_atsc_eit_s *p_building_eit;
};

struct dvbpsi_atsc_eit_event_s
{
  // i_event_id
  unsigned short int i_event_id;
  // i_start_time
  unsigned int i_start_time;
  // i_etm_location
  unsigned char i_etm_location;
  // i_length_seconds
  unsigned int i_length_seconds;
  // i_title_length
  unsigned char i_title_length;
  // i_title
  unsigned char i_title[256l];
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_atsc_eit_event_s *p_next;
};

struct dvbpsi_atsc_ett_s
{
  // i_table_id
  unsigned char i_table_id;
  // i_extension
  unsigned short int i_extension;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // i_protocol
  unsigned char i_protocol;
  // i_etm_id
  unsigned int i_etm_id;
  // i_etm_length
  unsigned int i_etm_length;
  // p_etm_data
  unsigned char *p_etm_data;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
};

struct dvbpsi_atsc_ett_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_ett_callback
  void (*pf_ett_callback)(void *, struct dvbpsi_atsc_ett_s *);
  // p_cb_data
  void *p_cb_data;
  // current_ett
  struct dvbpsi_atsc_ett_s current_ett;
  // p_building_ett
  struct dvbpsi_atsc_ett_s *p_building_ett;
};

struct dvbpsi_atsc_mgt_s
{
  // i_table_id
  unsigned char i_table_id;
  // i_extension
  unsigned short int i_extension;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // i_table_id_ext
  unsigned short int i_table_id_ext;
  // i_protocol
  unsigned char i_protocol;
  // p_first_table
  struct dvbpsi_atsc_mgt_table_s *p_first_table;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
};

struct dvbpsi_atsc_mgt_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_mgt_callback
  void (*pf_mgt_callback)(void *, struct dvbpsi_atsc_mgt_s *);
  // p_cb_data
  void *p_cb_data;
  // current_mgt
  struct dvbpsi_atsc_mgt_s current_mgt;
  // p_building_mgt
  struct dvbpsi_atsc_mgt_s *p_building_mgt;
};

struct dvbpsi_atsc_mgt_table_s
{
  // i_table_type
  unsigned short int i_table_type;
  // i_table_type_pid
  unsigned short int i_table_type_pid;
  // i_table_type_version
  unsigned char i_table_type_version;
  // i_number_bytes
  unsigned int i_number_bytes;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_atsc_mgt_table_s *p_next;
};

struct dvbpsi_atsc_stt_s
{
  // i_table_id
  unsigned char i_table_id;
  // i_extension
  unsigned short int i_extension;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // i_system_time
  unsigned int i_system_time;
  // i_gps_utc_offset
  unsigned char i_gps_utc_offset;
  // i_daylight_savings
  unsigned short int i_daylight_savings;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
};

struct dvbpsi_atsc_stt_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_stt_callback
  void (*pf_stt_callback)(void *, struct dvbpsi_atsc_stt_s *);
  // p_cb_data
  void *p_cb_data;
  // current_stt
  struct dvbpsi_atsc_stt_s current_stt;
  // p_building_stt
  struct dvbpsi_atsc_stt_s *p_building_stt;
};

struct dvbpsi_atsc_vct_channel_s
{
  // i_short_name
  unsigned char i_short_name[14l];
  // i_major_number
  unsigned short int i_major_number;
  // i_minor_number
  unsigned short int i_minor_number;
  // i_modulation
  unsigned char i_modulation;
  // i_carrier_freq
  unsigned int i_carrier_freq;
  // i_channel_tsid
  unsigned short int i_channel_tsid;
  // i_program_number
  unsigned short int i_program_number;
  // i_etm_location
  unsigned char i_etm_location;
  // b_access_controlled
  _Bool b_access_controlled;
  // b_path_select
  _Bool b_path_select;
  // b_out_of_band
  _Bool b_out_of_band;
  // b_hidden
  _Bool b_hidden;
  // b_hide_guide
  _Bool b_hide_guide;
  // i_service_type
  unsigned char i_service_type;
  // i_source_id
  unsigned short int i_source_id;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_atsc_vct_channel_s *p_next;
};

struct dvbpsi_atsc_vct_s
{
  // i_table_id
  unsigned char i_table_id;
  // i_extension
  unsigned short int i_extension;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // i_protocol
  unsigned char i_protocol;
  // b_cable_vct
  _Bool b_cable_vct;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_first_channel
  struct dvbpsi_atsc_vct_channel_s *p_first_channel;
};

struct dvbpsi_atsc_vct_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_vct_callback
  void (*pf_vct_callback)(void *, struct dvbpsi_atsc_vct_s *);
  // p_cb_data
  void *p_cb_data;
  // current_vct
  struct dvbpsi_atsc_vct_s current_vct;
  // p_building_vct
  struct dvbpsi_atsc_vct_s *p_building_vct;
};

struct dvbpsi_bat_s
{
  // i_table_id
  unsigned char i_table_id;
  // i_extension
  unsigned short int i_extension;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_first_ts
  struct dvbpsi_bat_ts_s *p_first_ts;
};

struct dvbpsi_bat_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_bat_callback
  void (*pf_bat_callback)(void *, struct dvbpsi_bat_s *);
  // p_cb_data
  void *p_cb_data;
  // current_bat
  struct dvbpsi_bat_s current_bat;
  // p_building_bat
  struct dvbpsi_bat_s *p_building_bat;
};

struct dvbpsi_bat_ts_s
{
  // i_ts_id
  unsigned short int i_ts_id;
  // i_orig_network_id
  unsigned short int i_orig_network_id;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_bat_ts_s *p_next;
};

struct dvbpsi_bouquet_name_dr_s
{
  // i_name_length
  unsigned char i_name_length;
  // i_char
  unsigned char i_char[255l];
};

struct dvbpsi_ca_dr_s
{
  // i_ca_system_id
  unsigned short int i_ca_system_id;
  // i_ca_pid
  unsigned short int i_ca_pid;
  // i_private_length
  unsigned char i_private_length;
  // i_private_data
  unsigned char i_private_data[251l];
};

struct dvbpsi_ca_system_s
{
  // i_ca_system_id
  unsigned short int i_ca_system_id;
};

struct dvbpsi_ca_identifier_dr_s
{
  // i_number
  unsigned char i_number;
  // p_system
  struct dvbpsi_ca_system_s p_system[127l];
};

struct dvbpsi_cable_deliv_sys_dr_s
{
  // i_frequency
  unsigned int i_frequency;
  // i_modulation
  unsigned char i_modulation;
  // i_symbol_rate
  unsigned int i_symbol_rate;
  // i_fec_inner
  unsigned char i_fec_inner;
  // i_fec_outer
  unsigned char i_fec_outer;
};

struct dvbpsi_caption_service_s
{
  // i_iso_639_code
  char i_iso_639_code[3l];
  // b_digital_cc
  signed int b_digital_cc;
  // b_line21_field
  signed int b_line21_field;
  // i_caption_service_number
  unsigned short int i_caption_service_number;
  // b_easy_reader
  signed int b_easy_reader;
  // b_wide_aspect_ratio
  signed int b_wide_aspect_ratio;
};

struct dvbpsi_caption_service_dr_s
{
  // i_number_of_services
  unsigned char i_number_of_services;
  // services
  struct dvbpsi_caption_service_s services[31l];
};

struct dvbpsi_carousel_id_dr_s
{
  // i_carousel_id
  unsigned int i_carousel_id;
  // i_private_data_len
  unsigned char i_private_data_len;
  // p_private_data
  unsigned char *p_private_data;
};

struct dvbpsi_cat_s
{
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
};

struct dvbpsi_cat_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_cat_callback
  void (*pf_cat_callback)(void *, struct dvbpsi_cat_s *);
  // p_cb_data
  void *p_cb_data;
  // current_cat
  struct dvbpsi_cat_s current_cat;
  // p_building_cat
  struct dvbpsi_cat_s *p_building_cat;
};

struct dvbpsi_component_dr_t
{
  // i_stream_content
  unsigned char i_stream_content;
  // i_component_type
  unsigned char i_component_type;
  // i_component_tag
  unsigned char i_component_tag;
  // i_iso_639_code
  unsigned char i_iso_639_code[3l];
  // i_text_length
  signed int i_text_length;
  // i_text
  unsigned char *i_text;
};

struct dvbpsi_content_s
{
  // i_type
  unsigned char i_type;
  // i_user_byte
  unsigned char i_user_byte;
};

struct dvbpsi_content_dr_s
{
  // i_contents_number
  unsigned char i_contents_number;
  // p_content
  struct dvbpsi_content_s p_content[64l];
};

struct dvbpsi_crid_entry_s
{
  // i_type
  unsigned char i_type;
  // i_location
  unsigned char i_location;
  // value
  union anonymous$1 value;
};

struct dvbpsi_content_id_dr_s
{
  // i_number_of_entries
  unsigned char i_number_of_entries;
  // p_entries
  struct dvbpsi_crid_entry_s p_entries[85l];
};

struct dvbpsi_copyright_dr_s
{
  // i_copyright_identifier
  unsigned int i_copyright_identifier;
  // i_additional_length
  unsigned char i_additional_length;
  // i_additional_info
  unsigned char i_additional_info[251l];
};

struct dvbpsi_country_availability_dr_s
{
  // b_country_availability_flag
  _Bool b_country_availability_flag;
  // i_code_count
  unsigned char i_code_count;
  // code
  struct anonymous$11 code[84l];
};

struct dvbpsi_cuei_dr_s
{
  // i_cue_stream_type
  unsigned char i_cue_stream_type;
};

struct dvbpsi_data_broadcast_id_dr_s
{
  // i_data_broadcast_id
  unsigned short int i_data_broadcast_id;
  // i_id_selector_len
  unsigned char i_id_selector_len;
  // p_id_selector
  unsigned char *p_id_selector;
};

struct dvbpsi_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
};

struct dvbpsi_default_authority_dr_s
{
  // authority
  unsigned char authority[255l];
};

struct dvbpsi_demux_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // p_first_subdec
  struct dvbpsi_demux_subdec_s *p_first_subdec;
  // pf_new_callback
  void (*pf_new_callback)(struct dvbpsi_s *, unsigned char, unsigned short int, void *);
  // p_new_cb_data
  void *p_new_cb_data;
};

struct dvbpsi_demux_subdec_s
{
  // i_id
  unsigned int i_id;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_decoder_s *, struct dvbpsi_psi_section_s *);
  // p_decoder
  struct dvbpsi_decoder_s *p_decoder;
  // pf_detach
  void (*pf_detach)(struct dvbpsi_s *, unsigned char, unsigned short int);
  // p_next
  struct dvbpsi_demux_subdec_s *p_next;
};

struct dvbpsi_descriptor_s
{
  // i_tag
  unsigned char i_tag;
  // i_length
  unsigned char i_length;
  // p_data
  unsigned char *p_data;
  // p_next
  struct dvbpsi_descriptor_s *p_next;
  // p_decoded
  void *p_decoded;
};

struct dvbpsi_ds_alignment_dr_s
{
  // i_alignment_type
  unsigned char i_alignment_type;
};

struct dvbpsi_eit_s
{
  // i_table_id
  unsigned char i_table_id;
  // i_extension
  unsigned short int i_extension;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // i_ts_id
  unsigned short int i_ts_id;
  // i_network_id
  unsigned short int i_network_id;
  // i_segment_last_section_number
  unsigned char i_segment_last_section_number;
  // i_last_table_id
  unsigned char i_last_table_id;
  // p_first_event
  struct dvbpsi_eit_event_s *p_first_event;
};

struct dvbpsi_eit_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_eit_callback
  void (*pf_eit_callback)(void *, struct dvbpsi_eit_s *);
  // p_cb_data
  void *p_cb_data;
  // current_eit
  struct dvbpsi_eit_s current_eit;
  // p_building_eit
  struct dvbpsi_eit_s *p_building_eit;
  // i_first_received_section_number
  unsigned char i_first_received_section_number;
};

struct dvbpsi_eit_event_s
{
  // i_event_id
  unsigned short int i_event_id;
  // i_start_time
  unsigned long int i_start_time;
  // i_duration
  unsigned int i_duration;
  // i_running_status
  unsigned char i_running_status;
  // b_free_ca
  _Bool b_free_ca;
  // b_nvod
  _Bool b_nvod;
  // i_descriptors_length
  unsigned short int i_descriptors_length;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_eit_event_s *p_next;
};

struct dvbpsi_extended_channel_name_dr_s
{
  // i_long_channel_name_length
  unsigned char i_long_channel_name_length;
  // i_long_channel_name
  unsigned char i_long_channel_name[256l];
};

struct dvbpsi_extended_event_dr_s
{
  // i_descriptor_number
  unsigned char i_descriptor_number;
  // i_last_descriptor_number
  unsigned char i_last_descriptor_number;
  // i_iso_639_code
  unsigned char i_iso_639_code[3l];
  // i_entry_count
  signed int i_entry_count;
  // i_item_description_length
  unsigned char i_item_description_length[126l];
  // i_item_description
  unsigned char *i_item_description[126l];
  // i_item_length
  unsigned char i_item_length[126l];
  // i_item
  unsigned char *i_item[126l];
  // i_text_length
  signed int i_text_length;
  // i_text
  unsigned char *i_text;
  // i_buffer
  unsigned char i_buffer[256l];
};

struct dvbpsi_frequency_list_dr_s
{
  // i_coding_type
  unsigned char i_coding_type;
  // i_number_of_frequencies
  unsigned char i_number_of_frequencies;
  // p_center_frequencies
  unsigned int p_center_frequencies[63l];
};

struct dvbpsi_hierarchy_dr_s
{
  // i_h_type
  unsigned char i_h_type;
  // i_h_layer_index
  unsigned char i_h_layer_index;
  // i_h_embedded_layer
  unsigned char i_h_embedded_layer;
  // i_h_priority
  unsigned char i_h_priority;
};

struct dvbpsi_ibp_dr_s
{
  // b_closed_gop_flag
  _Bool b_closed_gop_flag;
  // b_identical_gop_flag
  _Bool b_identical_gop_flag;
  // i_max_gop_length
  unsigned short int i_max_gop_length;
};

struct dvbpsi_iso639_dr_s
{
  // i_code_count
  unsigned char i_code_count;
  // code
  struct anonymous$9 code[64l];
};

struct dvbpsi_lcn_entry_s
{
  // i_service_id
  unsigned short int i_service_id;
  // b_visible_service_flag
  signed int b_visible_service_flag;
  // i_logical_channel_number
  unsigned short int i_logical_channel_number;
};

struct dvbpsi_lcn_dr_s
{
  // i_number_of_entries
  unsigned char i_number_of_entries;
  // p_entries
  struct dvbpsi_lcn_entry_s p_entries[64l];
};

struct dvbpsi_linkage_dr_s
{
  // i_transport_stream_id
  unsigned short int i_transport_stream_id;
  // i_original_network_id
  unsigned short int i_original_network_id;
  // i_service_id
  unsigned short int i_service_id;
  // i_linkage_type
  unsigned char i_linkage_type;
  // i_handover_type
  unsigned char i_handover_type;
  // i_origin_type
  unsigned char i_origin_type;
  // i_network_id
  unsigned short int i_network_id;
  // i_initial_service_id
  unsigned short int i_initial_service_id;
  // i_target_event_id
  unsigned short int i_target_event_id;
  // b_target_listed
  _Bool b_target_listed;
  // b_event_simulcast
  _Bool b_event_simulcast;
  // i_private_data_length
  unsigned char i_private_data_length;
  // i_private_data
  unsigned char i_private_data[248l];
};

struct dvbpsi_local_time_offset_s
{
  // i_country_code
  unsigned char i_country_code[3l];
  // i_country_region_id
  unsigned char i_country_region_id;
  // i_local_time_offset_polarity
  unsigned char i_local_time_offset_polarity;
  // i_local_time_offset
  unsigned short int i_local_time_offset;
  // i_time_of_change
  unsigned long int i_time_of_change;
  // i_next_time_offset
  unsigned short int i_next_time_offset;
};

struct dvbpsi_local_time_offset_dr_s
{
  // i_local_time_offsets_number
  unsigned char i_local_time_offsets_number;
  // p_local_time_offset
  struct dvbpsi_local_time_offset_s p_local_time_offset[19l];
};

struct dvbpsi_max_bitrate_dr_s
{
  // i_max_bitrate
  unsigned int i_max_bitrate;
};

struct dvbpsi_mpeg4_audio_dr_s
{
  // i_mpeg4_audio_profile_and_level
  enum dvbpsi_aac_profile_and_level_s i_mpeg4_audio_profile_and_level;
};

struct dvbpsi_mpeg4_video_dr_s
{
  // i_mpeg4_visual_profile_and_level
  enum dvbpsi_mpeg4_visual_profile_and_level_s i_mpeg4_visual_profile_and_level;
};

struct dvbpsi_mx_buff_utilization_dr_s
{
  // b_mdv_valid
  _Bool b_mdv_valid;
  // i_mx_delay_variation
  unsigned short int i_mx_delay_variation;
  // i_mx_strategy
  unsigned char i_mx_strategy;
};

struct dvbpsi_network_name_dr_s
{
  // i_name_length
  unsigned char i_name_length;
  // i_name_byte
  unsigned char i_name_byte[255l];
};

struct dvbpsi_nit_s
{
  // i_table_id
  unsigned char i_table_id;
  // i_extension
  unsigned short int i_extension;
  // i_network_id
  unsigned short int i_network_id;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_first_ts
  struct dvbpsi_nit_ts_s *p_first_ts;
};

struct dvbpsi_nit_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_nit_callback
  void (*pf_nit_callback)(void *, struct dvbpsi_nit_s *);
  // p_cb_data
  void *p_cb_data;
  // current_nit
  struct dvbpsi_nit_s current_nit;
  // p_building_nit
  struct dvbpsi_nit_s *p_building_nit;
  // i_network_id
  unsigned short int i_network_id;
};

struct dvbpsi_nit_ts_s
{
  // i_ts_id
  unsigned short int i_ts_id;
  // i_orig_network_id
  unsigned short int i_orig_network_id;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_nit_ts_s *p_next;
};

struct dvbpsi_nvod_ref_s
{
  // i_transport_stream_id
  unsigned short int i_transport_stream_id;
  // i_original_network_id
  unsigned short int i_original_network_id;
  // i_service_id
  unsigned short int i_service_id;
};

struct dvbpsi_nvod_ref_dr_s
{
  // i_references
  unsigned char i_references;
  // p_nvod_refs
  struct dvbpsi_nvod_ref_s p_nvod_refs[43l];
};

struct dvbpsi_parental_rating_s
{
  // i_country_code
  unsigned int i_country_code;
  // i_rating
  unsigned char i_rating;
};

struct dvbpsi_parental_rating_dr_s
{
  // i_ratings_number
  unsigned char i_ratings_number;
  // p_parental_rating
  struct dvbpsi_parental_rating_s p_parental_rating[64l];
};

struct dvbpsi_pat_s
{
  // i_ts_id
  unsigned short int i_ts_id;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // p_first_program
  struct dvbpsi_pat_program_s *p_first_program;
};

struct dvbpsi_pat_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_pat_callback
  void (*pf_pat_callback)(void *, struct dvbpsi_pat_s *);
  // p_cb_data
  void *p_cb_data;
  // current_pat
  struct dvbpsi_pat_s current_pat;
  // p_building_pat
  struct dvbpsi_pat_s *p_building_pat;
};

struct dvbpsi_pat_program_s
{
  // i_number
  unsigned short int i_number;
  // i_pid
  unsigned short int i_pid;
  // p_next
  struct dvbpsi_pat_program_s *p_next;
};

struct dvbpsi_pmt_s
{
  // i_program_number
  unsigned short int i_program_number;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // i_pcr_pid
  unsigned short int i_pcr_pid;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_first_es
  struct dvbpsi_pmt_es_s *p_first_es;
};

struct dvbpsi_pmt_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_pmt_callback
  void (*pf_pmt_callback)(void *, struct dvbpsi_pmt_s *);
  // p_cb_data
  void *p_cb_data;
  // current_pmt
  struct dvbpsi_pmt_s current_pmt;
  // p_building_pmt
  struct dvbpsi_pmt_s *p_building_pmt;
  // i_program_number
  unsigned short int i_program_number;
};

struct dvbpsi_pmt_es_s
{
  // i_type
  unsigned char i_type;
  // i_pid
  unsigned short int i_pid;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_pmt_es_s *p_next;
};

struct dvbpsi_private_data_dr_s
{
  // i_private_data
  unsigned int i_private_data;
};

struct dvbpsi_psi_section_s
{
  // i_table_id
  unsigned char i_table_id;
  // b_syntax_indicator
  _Bool b_syntax_indicator;
  // b_private_indicator
  _Bool b_private_indicator;
  // i_length
  unsigned short int i_length;
  // i_extension
  unsigned short int i_extension;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // i_number
  unsigned char i_number;
  // i_last_number
  unsigned char i_last_number;
  // p_data
  unsigned char *p_data;
  // p_payload_start
  unsigned char *p_payload_start;
  // p_payload_end
  unsigned char *p_payload_end;
  // i_crc
  unsigned int i_crc;
  // p_next
  struct dvbpsi_psi_section_s *p_next;
};

struct dvbpsi_registration_dr_s
{
  // i_format_identifier
  unsigned int i_format_identifier;
  // i_additional_length
  unsigned char i_additional_length;
  // i_additional_info
  unsigned char i_additional_info[251l];
};

struct dvbpsi_rst_s
{
  // p_first_event
  struct dvbpsi_rst_event_s *p_first_event;
};

struct dvbpsi_rst_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_rst_callback
  void (*pf_rst_callback)(void *, struct dvbpsi_rst_s *);
  // p_cb_data
  void *p_cb_data;
  // current_rst
  struct dvbpsi_rst_s current_rst;
  // p_building_rst
  struct dvbpsi_rst_s *p_building_rst;
};

struct dvbpsi_rst_event_s
{
  // i_ts_id
  unsigned short int i_ts_id;
  // i_orig_network_id
  unsigned short int i_orig_network_id;
  // i_service_id
  unsigned short int i_service_id;
  // i_event_id
  unsigned short int i_event_id;
  // i_running_status
  unsigned char i_running_status;
  // p_next
  struct dvbpsi_rst_event_s *p_next;
};

struct dvbpsi_s
{
  // p_decoder
  struct dvbpsi_decoder_s *p_decoder;
  // pf_message
  void (*pf_message)(struct dvbpsi_s *, const enum dvbpsi_msg_level, const char *);
  // i_msg_level
  enum dvbpsi_msg_level i_msg_level;
  // p_sys
  void *p_sys;
};

struct dvbpsi_sat_deliv_sys_dr_s
{
  // i_frequency
  unsigned int i_frequency;
  // i_orbital_position
  unsigned short int i_orbital_position;
  // i_west_east_flag
  unsigned char i_west_east_flag;
  // i_polarization
  unsigned char i_polarization;
  // i_roll_off
  unsigned char i_roll_off;
  // i_modulation_system
  unsigned char i_modulation_system;
  // i_modulation_type
  unsigned char i_modulation_type;
  // i_symbol_rate
  unsigned int i_symbol_rate;
  // i_fec_inner
  unsigned char i_fec_inner;
};

struct dvbpsi_sdt_s
{
  // i_table_id
  unsigned char i_table_id;
  // i_extension
  unsigned short int i_extension;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // i_network_id
  unsigned short int i_network_id;
  // p_first_service
  struct dvbpsi_sdt_service_s *p_first_service;
};

struct dvbpsi_sdt_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_sdt_callback
  void (*pf_sdt_callback)(void *, struct dvbpsi_sdt_s *);
  // p_cb_data
  void *p_cb_data;
  // current_sdt
  struct dvbpsi_sdt_s current_sdt;
  // p_building_sdt
  struct dvbpsi_sdt_s *p_building_sdt;
};

struct dvbpsi_sdt_service_s
{
  // i_service_id
  unsigned short int i_service_id;
  // b_eit_schedule
  _Bool b_eit_schedule;
  // b_eit_present
  _Bool b_eit_present;
  // i_running_status
  unsigned char i_running_status;
  // b_free_ca
  _Bool b_free_ca;
  // i_descriptors_length
  unsigned short int i_descriptors_length;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_sdt_service_s *p_next;
};

struct dvbpsi_service_dr_s
{
  // i_service_type
  unsigned char i_service_type;
  // i_service_provider_name_length
  unsigned char i_service_provider_name_length;
  // i_service_provider_name
  unsigned char i_service_provider_name[252l];
  // i_service_name_length
  unsigned char i_service_name_length;
  // i_service_name
  unsigned char i_service_name[252l];
};

struct dvbpsi_service_list_dr_s
{
  // i_service_count
  unsigned char i_service_count;
  // i_service
  struct anonymous$10 i_service[64l];
};

struct dvbpsi_service_location_element_s
{
  // i_stream_type
  unsigned char i_stream_type;
  // i_elementary_pid
  unsigned short int i_elementary_pid;
  // i_iso_639_code
  char i_iso_639_code[3l];
};

struct dvbpsi_service_location_dr_s
{
  // i_pcr_pid
  unsigned short int i_pcr_pid;
  // i_number_elements
  unsigned char i_number_elements;
  // elements
  struct dvbpsi_service_location_element_s elements[255l];
};

struct dvbpsi_short_event_dr_s
{
  // i_iso_639_code
  unsigned char i_iso_639_code[3l];
  // i_event_name_length
  signed int i_event_name_length;
  // i_event_name
  unsigned char i_event_name[256l];
  // i_text_length
  signed int i_text_length;
  // i_text
  unsigned char i_text[256l];
};

struct dvbpsi_sis_s
{
  // i_table_id
  unsigned char i_table_id;
  // i_extension
  unsigned short int i_extension;
  // i_ts_id
  unsigned short int i_ts_id;
  // i_version
  unsigned char i_version;
  // i_protocol_version
  unsigned char i_protocol_version;
  // b_current_next
  _Bool b_current_next;
  // b_encrypted_packet
  _Bool b_encrypted_packet;
  // i_encryption_algorithm
  unsigned char i_encryption_algorithm;
  // i_pts_adjustment
  unsigned long int i_pts_adjustment;
  // cw_index
  unsigned char cw_index;
  // i_splice_command_length
  unsigned short int i_splice_command_length;
  // i_splice_command_type
  unsigned char i_splice_command_type;
  // p_splice_command
  void *p_splice_command;
  // i_descriptors_length
  unsigned short int i_descriptors_length;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // i_ecrc
  unsigned int i_ecrc;
} __attribute__ ((__packed__));

struct dvbpsi_sis_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_sis_callback
  void (*pf_sis_callback)(void *, struct dvbpsi_sis_s *);
  // p_cb_data
  void *p_cb_data;
  // current_sis
  struct dvbpsi_sis_s current_sis;
  // p_building_sis
  struct dvbpsi_sis_s *p_building_sis;
};

struct dvbpsi_smoothing_buffer_dr_s
{
  // i_sb_leak_rate
  unsigned int i_sb_leak_rate;
  // i_sb_size
  unsigned int i_sb_size;
};

struct dvbpsi_std_dr_s
{
  // b_leak_valid_flag
  _Bool b_leak_valid_flag;
};

struct dvbpsi_stream_identifier_dr_s
{
  // i_component_tag
  unsigned char i_component_tag;
};

struct dvbpsi_stuffing_dr_s
{
  // i_stuffing_length
  unsigned char i_stuffing_length;
  // i_stuffing_byte
  unsigned char i_stuffing_byte[255l];
};

struct dvbpsi_subtitle_s
{
  // i_iso6392_language_code
  unsigned char i_iso6392_language_code[3l];
  // i_subtitling_type
  unsigned char i_subtitling_type;
  // i_composition_page_id
  unsigned short int i_composition_page_id;
  // i_ancillary_page_id
  unsigned short int i_ancillary_page_id;
};

struct dvbpsi_subtitling_dr_s
{
  // i_subtitles_number
  unsigned char i_subtitles_number;
  // p_subtitle
  struct dvbpsi_subtitle_s p_subtitle[20l];
};

struct dvbpsi_system_clock_dr_s
{
  // b_external_clock_ref
  _Bool b_external_clock_ref;
  // i_clock_accuracy_integer
  unsigned char i_clock_accuracy_integer;
  // i_clock_accuracy_exponent
  unsigned char i_clock_accuracy_exponent;
};

struct dvbpsi_target_bg_grid_dr_s
{
  // i_horizontal_size
  unsigned short int i_horizontal_size;
  // i_vertical_size
  unsigned short int i_vertical_size;
  // i_pel_aspect_ratio
  unsigned char i_pel_aspect_ratio;
};

struct dvbpsi_teletextpage_s
{
  // i_iso6392_language_code
  unsigned char i_iso6392_language_code[3l];
  // i_teletext_type
  unsigned char i_teletext_type;
  // i_teletext_magazine_number
  unsigned char i_teletext_magazine_number;
  // i_teletext_page_number
  unsigned char i_teletext_page_number;
};

struct dvbpsi_teletext_dr_s
{
  // i_pages_number
  unsigned char i_pages_number;
  // p_pages
  struct dvbpsi_teletextpage_s p_pages[51l];
};

struct dvbpsi_terr_deliv_sys_dr_s
{
  // i_centre_frequency
  unsigned int i_centre_frequency;
  // i_bandwidth
  unsigned char i_bandwidth;
  // i_priority
  unsigned char i_priority;
  // i_time_slice_indicator
  unsigned char i_time_slice_indicator;
  // i_mpe_fec_indicator
  unsigned char i_mpe_fec_indicator;
  // i_constellation
  unsigned char i_constellation;
  // i_hierarchy_information
  unsigned char i_hierarchy_information;
  // i_code_rate_hp_stream
  unsigned char i_code_rate_hp_stream;
  // i_code_rate_lp_stream
  unsigned char i_code_rate_lp_stream;
  // i_guard_interval
  unsigned char i_guard_interval;
  // i_transmission_mode
  unsigned char i_transmission_mode;
  // i_other_frequency_flag
  unsigned char i_other_frequency_flag;
};

struct dvbpsi_tot_s
{
  // i_table_id
  unsigned char i_table_id;
  // i_extension
  unsigned short int i_extension;
  // i_version
  unsigned char i_version;
  // b_current_next
  _Bool b_current_next;
  // i_utc_time
  unsigned long int i_utc_time;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
} __attribute__ ((__packed__));

struct dvbpsi_tot_decoder_s
{
  // i_magic
  unsigned char i_magic[3l];
  // b_complete_header
  _Bool b_complete_header;
  // b_discontinuity
  _Bool b_discontinuity;
  // b_current_valid
  _Bool b_current_valid;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // i_last_section_number
  unsigned char i_last_section_number;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // p_sections
  struct dvbpsi_psi_section_s *p_sections;
  // pf_gather
  void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *);
  // i_section_max_size
  signed int i_section_max_size;
  // i_need
  signed int i_need;
  // pf_tot_callback
  void (*pf_tot_callback)(void *, struct dvbpsi_tot_s *);
  // p_cb_data
  void *p_cb_data;
  // current_tot
  struct dvbpsi_tot_s current_tot;
  // p_building_tot
  struct dvbpsi_tot_s *p_building_tot;
};

struct dvbpsi_tshifted_ev_dr_s
{
  // i_ref_service_id
  unsigned short int i_ref_service_id;
  // i_ref_event_id
  unsigned short int i_ref_event_id;
};

struct dvbpsi_tshifted_service_dr_s
{
  // i_ref_service_id
  unsigned short int i_ref_service_id;
};

struct dvbpsi_vbidata_line_s
{
  // i_parity
  unsigned char i_parity;
  // i_line_offset
  unsigned char i_line_offset;
};

struct dvbpsi_vbidata_s
{
  // i_data_service_id
  unsigned char i_data_service_id;
  // i_lines
  unsigned char i_lines;
  // p_lines
  struct dvbpsi_vbidata_line_s p_lines[255l];
};

struct dvbpsi_vbi_dr_s
{
  // i_services_number
  unsigned char i_services_number;
  // p_services
  struct dvbpsi_vbidata_s p_services[85l];
};

struct dvbpsi_vstream_dr_s
{
  // b_multiple_frame_rate
  _Bool b_multiple_frame_rate;
  // i_frame_rate_code
  unsigned char i_frame_rate_code;
  // b_mpeg2
  _Bool b_mpeg2;
  // b_constrained_parameter
  _Bool b_constrained_parameter;
  // b_still_picture
  _Bool b_still_picture;
  // i_profile_level_indication
  unsigned char i_profile_level_indication;
  // i_chroma_format
  unsigned char i_chroma_format;
  // b_frame_rate_extension
  _Bool b_frame_rate_extension;
};

struct dvbpsi_vwindow_dr_s
{
  // i_horizontal_offset
  unsigned short int i_horizontal_offset;
  // i_vertical_offset
  unsigned short int i_vertical_offset;
  // i_window_priority
  unsigned char i_window_priority;
};

struct fifo_s
{
  // lock
  union anonymous lock;
  // wait
  union anonymous$2 wait;
  // b_force_wake
  _Bool b_force_wake;
  // i_count
  signed long int i_count;
  // i_size
  unsigned long int i_size;
  // p_first
  struct buffer_s *p_first;
  // pp_last
  struct buffer_s **pp_last;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct group_req
{
  // gr_interface
  unsigned int gr_interface;
  // gr_group
  struct sockaddr_storage gr_group;
};

struct in6_addr
{
  // __in6_u
  union anonymous$5 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct summary_s
{
  // mode
  signed int mode;
  // period
  signed long int period;
  // file
  char *file;
  // fd
  struct _IO_FILE *fd;
};

struct params_s
{
  // output
  char *output;
  // input
  char *input;
  // port
  signed int port;
  // mcast_interface
  char *mcast_interface;
  // b_udp
  _Bool b_udp;
  // b_tcp
  _Bool b_tcp;
  // b_file
  _Bool b_file;
  // threshold
  unsigned long int threshold;
  // fd_in
  signed int fd_in;
  // fd_out
  signed int fd_out;
  // debug
  signed int debug;
  // b_verbose
  _Bool b_verbose;
  // b_monitor
  _Bool b_monitor;
  // b_summary
  _Bool b_summary;
  // summary
  struct summary_s summary;
  // pf_read
  signed long int (*pf_read)(signed int, void *, unsigned long int);
  // pf_write
  signed long int (*pf_write)(signed int, const void *, unsigned long int);
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct ts_atsc_eit_s
{
  // handle
  struct dvbpsi_s *handle;
  // i_table_pid
  signed int i_table_pid;
  // i_mgt_version
  signed int i_mgt_version;
  // pid
  struct ts_pid_s *pid;
  // p_next
  struct ts_atsc_eit_s *p_next;
};

struct ts_atsc_s
{
  // handle
  struct dvbpsi_s *handle;
  // pid
  struct ts_pid_s *pid;
};

struct ts_cat_s
{
  // handle
  struct dvbpsi_s *handle;
  // i_version
  unsigned char i_version;
  // pid
  struct ts_pid_s *pid;
};

struct ts_eit_s
{
  // handle
  struct dvbpsi_s *handle;
  // pid
  struct ts_pid_s *pid;
};

struct ts_pid_s
{
  // i_pid
  signed int i_pid;
  // i_cc
  signed int i_cc;
  // b_seen
  _Bool b_seen;
  // b_transport_error_indicator
  _Bool b_transport_error_indicator;
  // b_payload_unit_start_indicator
  _Bool b_payload_unit_start_indicator;
  // b_transport_priority
  _Bool b_transport_priority;
  // i_transport_scrambling_control
  unsigned char i_transport_scrambling_control;
  // b_adaptation_field
  _Bool b_adaptation_field;
  // b_discontinuity_indicator
  _Bool b_discontinuity_indicator;
  // b_random_access_indicator
  _Bool b_random_access_indicator;
  // b_elementary_stream_priority_indicator
  _Bool b_elementary_stream_priority_indicator;
  // b_transport_private_data
  _Bool b_transport_private_data;
  // b_splicing_point
  _Bool b_splicing_point;
  // i_splice_countdown
  signed char i_splice_countdown;
  // i_splice_type
  unsigned char i_splice_type;
  // i_transport_private_data_length
  unsigned char i_transport_private_data_length;
  // b_opcr
  _Bool b_opcr;
  // b_pcr
  _Bool b_pcr;
  // i_pcr
  signed long int i_pcr;
  // b_adaptation_field_extension
  _Bool b_adaptation_field_extension;
  // i_adaptation_field_extension_length
  unsigned int i_adaptation_field_extension_length;
  // b_ltw
  _Bool b_ltw;
  // b_ltw_valid
  _Bool b_ltw_valid;
  // i_ltw_offset
  unsigned short int i_ltw_offset;
  // b_piecewise_rate
  _Bool b_piecewise_rate;
  // i_piecewise_rate
  unsigned int i_piecewise_rate;
  // b_seamless_splice
  _Bool b_seamless_splice;
  // i_packets
  unsigned long int i_packets;
  // i_first_pcr
  signed long int i_first_pcr;
  // i_prev_pcr
  signed long int i_prev_pcr;
  // i_last_pcr
  signed long int i_last_pcr;
  // i_prev_received
  signed long int i_prev_received;
  // i_received
  signed long int i_received;
};

struct ts_pmt_s
{
  // handle
  struct dvbpsi_s *handle;
  // i_number
  signed int i_number;
  // i_pmt_version
  signed int i_pmt_version;
  // pid_pmt
  struct ts_pid_s *pid_pmt;
  // pid_pcr
  struct ts_pid_s *pid_pcr;
  // p_next
  struct ts_pmt_s *p_next;
};

struct ts_rst_s
{
  // handle
  struct dvbpsi_s *handle;
  // pid
  struct ts_pid_s *pid;
};

struct ts_sdt_s
{
  // handle
  struct dvbpsi_s *handle;
  // pid
  struct ts_pid_s *pid;
};

struct ts_sis_s
{
  // i_protocol_version
  unsigned char i_protocol_version;
};

struct ts_tdt_s
{
  // handle
  struct dvbpsi_s *handle;
  // pid
  struct ts_pid_s *pid;
};

struct ts_stream_t
{
  // pat
  struct anonymous$3 pat;
  // i_pmt
  signed int i_pmt;
  // pmt
  struct ts_pmt_s *pmt;
  // cat
  struct ts_cat_s cat;
  // sis
  struct ts_sis_s sis;
  // rst
  struct ts_rst_s rst;
  // sdt
  struct ts_sdt_s sdt;
  // eit
  struct ts_eit_s eit;
  // tdt
  struct ts_tdt_s tdt;
  // atsc
  struct ts_atsc_s atsc;
  // atsc_eit
  struct ts_atsc_eit_s *atsc_eit;
  // i_atsc_eit
  signed int i_atsc_eit;
  // pid
  struct ts_pid_s pid[8192l];
  // level
  enum dvbpsi_msg_level level;
  // i_packets
  unsigned long int i_packets;
  // i_null_packets
  unsigned long int i_null_packets;
  // i_lost_bytes
  unsigned long int i_lost_bytes;
  // pf_log
  void (*pf_log)(void *, const signed int, const char *, ...);
  // cb_data
  void *cb_data;
};


// aac_profile_and_level_table
// file descriptors/dr_7c.c line 49
static struct dvbpsi_aac_profile_and_level_table_s aac_profile_and_level_table[54l] = { { .hex=(unsigned char)0x00, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)0 },
    { .hex=(unsigned char)0x0F, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)15 },
    { .hex=(unsigned char)0x10, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)16 },
    { .hex=(unsigned char)0x11, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)17 },
    { .hex=(unsigned char)0x12, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)18 },
    { .hex=(unsigned char)0x13, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)19 },
    { .hex=(unsigned char)0x18, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)24 },
    { .hex=(unsigned char)0x19, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)25 },
    { .hex=(unsigned char)0x1A, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)26 },
    { .hex=(unsigned char)0x1B, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)27 },
    { .hex=(unsigned char)0x20, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)32 },
    { .hex=(unsigned char)0x21, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)33 },
    { .hex=(unsigned char)0x28, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)40 },
    { .hex=(unsigned char)0x29, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)41 },
    { .hex=(unsigned char)0x2A, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)42 },
    { .hex=(unsigned char)0x30, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)48 },
    { .hex=(unsigned char)0x31, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)49 },
    { .hex=(unsigned char)0x32, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)50 },
    { .hex=(unsigned char)0x33, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)51 },
    { .hex=(unsigned char)0x34, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)52 },
    { .hex=(unsigned char)0x35, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)53 },
    { .hex=(unsigned char)0x36, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)54 },
    { .hex=(unsigned char)0x37, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)55 },
    { .hex=(unsigned char)0x38, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)56 },
    { .hex=(unsigned char)0x39, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)57 },
    { .hex=(unsigned char)0x3A, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)58 },
    { .hex=(unsigned char)0x3B, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)59 },
    { .hex=(unsigned char)0x3C, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)60 },
    { .hex=(unsigned char)0x3D, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)61 },
    { .hex=(unsigned char)0x3E, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)62 },
    { .hex=(unsigned char)0x3F, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)63 },
    { .hex=(unsigned char)0x40, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)64 },
    { .hex=(unsigned char)0x41, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)65 },
    { .hex=(unsigned char)0x42, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)66 },
    { .hex=(unsigned char)0x43, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)67 },
    { .hex=(unsigned char)0x48, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)72 },
    { .hex=(unsigned char)0x49, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)73 },
    { .hex=(unsigned char)0x4A, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)74 },
    { .hex=(unsigned char)0x4B, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)75 },
    { .hex=(unsigned char)0x4C, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)76 },
    { .hex=(unsigned char)0x4D, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)77 },
    { .hex=(unsigned char)0x50, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)80 },
    { .hex=(unsigned char)0x51, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)81 },
    { .hex=(unsigned char)0x52, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)82 },
    { .hex=(unsigned char)0x53, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)83 },
    { .hex=(unsigned char)0x58, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)88 },
    { .hex=(unsigned char)0x59, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)89 },
    { .hex=(unsigned char)0x5A, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)90 },
    { .hex=(unsigned char)0x5B, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)91 },
    { .hex=(unsigned char)0x60, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)96 },
    { .hex=(unsigned char)0x61, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)97 },
    { .hex=(unsigned char)0x62, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)98 },
    { .hex=(unsigned char)0x63, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)99 },
    { .hex=(unsigned char)0xFF, .profile_and_level=(enum dvbpsi_aac_profile_and_level_s)255 } };
// aac_type_table
// file descriptors/dr_7c.c line 153
static struct dvbpsi_aac_type_table_s aac_type_table[17l] = { { .hex=(unsigned char)0x00, .type=(enum dvbpsi_aac_type_s)0 },
    { .hex=(unsigned char)0x01, .type=(enum dvbpsi_aac_type_s)1 },
    { .hex=(unsigned char)0x02, .type=(enum dvbpsi_aac_type_s)2 },
    { .hex=(unsigned char)0x03, .type=(enum dvbpsi_aac_type_s)3 },
    { .hex=(unsigned char)0x04, .type=(enum dvbpsi_aac_type_s)4 },
    { .hex=(unsigned char)0x05, .type=(enum dvbpsi_aac_type_s)5 },
    { .hex=(unsigned char)0x40, .type=(enum dvbpsi_aac_type_s)64 },
    { .hex=(unsigned char)0x41, .type=(enum dvbpsi_aac_type_s)65 },
    { .hex=(unsigned char)0x42, .type=(enum dvbpsi_aac_type_s)66 },
    { .hex=(unsigned char)0x43, .type=(enum dvbpsi_aac_type_s)67 },
    { .hex=(unsigned char)0x44, .type=(enum dvbpsi_aac_type_s)68 },
    { .hex=(unsigned char)0x45, .type=(enum dvbpsi_aac_type_s)69 },
    { .hex=(unsigned char)0x46, .type=(enum dvbpsi_aac_type_s)70 },
    { .hex=(unsigned char)0x47, .type=(enum dvbpsi_aac_type_s)71 },
    { .hex=(unsigned char)0x48, .type=(enum dvbpsi_aac_type_s)72 },
    { .hex=(unsigned char)0x49, .type=(enum dvbpsi_aac_type_s)73 },
    { .hex=(unsigned char)0x4A, .type=(enum dvbpsi_aac_type_s)74 } };
// dvbpsi_crc32_table
// file psi.c line 72
static unsigned int dvbpsi_crc32_table[256l] = { (unsigned int)0x00000000, (unsigned int)0x04c11db7, (unsigned int)0x09823b6e, (unsigned int)0x0d4326d9, (unsigned int)0x130476dc, (unsigned int)0x17c56b6b, (unsigned int)0x1a864db2, (unsigned int)0x1e475005, (unsigned int)0x2608edb8, (unsigned int)0x22c9f00f, (unsigned int)0x2f8ad6d6, (unsigned int)0x2b4bcb61, (unsigned int)0x350c9b64, (unsigned int)0x31cd86d3, (unsigned int)0x3c8ea00a, (unsigned int)0x384fbdbd, (unsigned int)0x4c11db70, (unsigned int)0x48d0c6c7, (unsigned int)0x4593e01e, (unsigned int)0x4152fda9, (unsigned int)0x5f15adac, (unsigned int)0x5bd4b01b, (unsigned int)0x569796c2, (unsigned int)0x52568b75, (unsigned int)0x6a1936c8, (unsigned int)0x6ed82b7f, (unsigned int)0x639b0da6, (unsigned int)0x675a1011, (unsigned int)0x791d4014, (unsigned int)0x7ddc5da3, (unsigned int)0x709f7b7a, (unsigned int)0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, (unsigned int)0x34867077, (unsigned int)0x30476dc0, (unsigned int)0x3d044b19, (unsigned int)0x39c556ae, (unsigned int)0x278206ab, (unsigned int)0x23431b1c, (unsigned int)0x2e003dc5, (unsigned int)0x2ac12072, (unsigned int)0x128e9dcf, (unsigned int)0x164f8078, (unsigned int)0x1b0ca6a1, (unsigned int)0x1fcdbb16, (unsigned int)0x018aeb13, (unsigned int)0x054bf6a4, (unsigned int)0x0808d07d, (unsigned int)0x0cc9cdca, (unsigned int)0x7897ab07, (unsigned int)0x7c56b6b0, (unsigned int)0x71159069, (unsigned int)0x75d48dde, (unsigned int)0x6b93dddb, (unsigned int)0x6f52c06c, (unsigned int)0x6211e6b5, (unsigned int)0x66d0fb02, (unsigned int)0x5e9f46bf, (unsigned int)0x5a5e5b08, (unsigned int)0x571d7dd1, (unsigned int)0x53dc6066, (unsigned int)0x4d9b3063, (unsigned int)0x495a2dd4, (unsigned int)0x44190b0d, (unsigned int)0x40d816ba, 0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a, (unsigned int)0x690ce0ee, (unsigned int)0x6dcdfd59, (unsigned int)0x608edb80, (unsigned int)0x644fc637, (unsigned int)0x7a089632, (unsigned int)0x7ec98b85, (unsigned int)0x738aad5c, (unsigned int)0x774bb0eb, (unsigned int)0x4f040d56, (unsigned int)0x4bc510e1, (unsigned int)0x46863638, (unsigned int)0x42472b8f, (unsigned int)0x5c007b8a, (unsigned int)0x58c1663d, (unsigned int)0x558240e4, (unsigned int)0x51435d53, (unsigned int)0x251d3b9e, (unsigned int)0x21dc2629, (unsigned int)0x2c9f00f0, (unsigned int)0x285e1d47, (unsigned int)0x36194d42, (unsigned int)0x32d850f5, (unsigned int)0x3f9b762c, (unsigned int)0x3b5a6b9b, (unsigned int)0x0315d626, (unsigned int)0x07d4cb91, (unsigned int)0x0a97ed48, (unsigned int)0x0e56f0ff, (unsigned int)0x1011a0fa, (unsigned int)0x14d0bd4d, (unsigned int)0x19939b94, (unsigned int)0x1d528623, 0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3, (unsigned int)0x5d8a9099, (unsigned int)0x594b8d2e, (unsigned int)0x5408abf7, (unsigned int)0x50c9b640, (unsigned int)0x4e8ee645, (unsigned int)0x4a4ffbf2, (unsigned int)0x470cdd2b, (unsigned int)0x43cdc09c, (unsigned int)0x7b827d21, (unsigned int)0x7f436096, (unsigned int)0x7200464f, (unsigned int)0x76c15bf8, (unsigned int)0x68860bfd, (unsigned int)0x6c47164a, (unsigned int)0x61043093, (unsigned int)0x65c52d24, (unsigned int)0x119b4be9, (unsigned int)0x155a565e, (unsigned int)0x18197087, (unsigned int)0x1cd86d30, (unsigned int)0x029f3d35, (unsigned int)0x065e2082, (unsigned int)0x0b1d065b, (unsigned int)0x0fdc1bec, (unsigned int)0x3793a651, (unsigned int)0x3352bbe6, (unsigned int)0x3e119d3f, (unsigned int)0x3ad08088, (unsigned int)0x2497d08d, (unsigned int)0x2056cd3a, (unsigned int)0x2d15ebe3, (unsigned int)0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4 };
// i_summary_mode
// file dvbinfo.c line 88
static const signed int i_summary_mode[4l] = { 0, 1, 2, 3 };
// log_level
// file dvbinfo.c line 150
static signed int log_level[4l] = { 3, 4, 6, 7 };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// psz_level
// file dvbinfo.c line 152
static const char *psz_level[4l] = { "ERROR", "WARNING", "INFO", "DEBUG" };
// psz_summary_mode
// file dvbinfo.c line 89
static const char *psz_summary_mode[4l] = { "bandwidth", "table", "packet", "wire" };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// AACProfileToString
// file libdvbpsi.c line 1264
static const char * AACProfileToString(enum dvbpsi_aac_profile_and_level_s profile)
{
  switch((signed int)profile)
  {
    case DVBPSI_AAC_PROFILE_NOT_DEFINED:
      return "No audio profile and level defined for the associated MPEG-4 audio stream";
    case DVBPSI_AAC_PROFILE_MAIN_LEVEL_1:
      return "Main profile, level 1";
    case DVBPSI_AAC_PROFILE_MAIN_LEVEL_2:
      return "Main profile, level 2";
    case DVBPSI_AAC_PROFILE_MAIN_LEVEL_3:
      return "Main profile, level 3";
    case DVBPSI_AAC_PROFILE_MAIN_LEVEL_4:
      return "Main profile, level 4";
    case DVBPSI_AAC_PROFILE_SCALABLE_LEVEL_1:
      return "Scalable Profile, level 1";
    case DVBPSI_AAC_PROFILE_SCALABLE_LEVEL_2:
      return "Scalable Profile, level 2";
    case DVBPSI_AAC_PROFILE_SCALABLE_LEVEL_3:
      return "Scalable Profile, level 3";
    case DVBPSI_AAC_PROFILE_SCALABLE_LEVEL_4:
      return "Scalable Profile, level 4";
    case DVBPSI_AAC_PROFILE_SPEECH_LEVEL_1:
      return "Speech profile, level 1";
    case DVBPSI_AAC_PROFILE_SPEECH_LEVEL_2:
      return "Speech profile, level 2";
    case DVBPSI_AAC_PROFILE_SYNTHESIS_LEVEL_1:
      return "Synthesis profile, level 1";
    case DVBPSI_AAC_PROFILE_SYNTHESIS_LEVEL_2:
      return "Synthesis profile, level 2";
    case DVBPSI_AAC_PROFILE_SYNTHESIS_LEVEL_3:
      return "Synthesis profile, level 3";
    case DVBPSI_AAC_PROFILE_HQ_LEVEL_1:
      return "High quality audio profile, level 1";
    case DVBPSI_AAC_PROFILE_HQ_LEVEL_2:
      return "High quality audio profile, level 2";
    case DVBPSI_AAC_PROFILE_HQ_LEVEL_3:
      return "High quality audio profile, level 3";
    case DVBPSI_AAC_PROFILE_HQ_LEVEL_4:
      return "High quality audio profile, level 4";
    case DVBPSI_AAC_PROFILE_HQ_LEVEL_5:
      return "High quality audio profile, level 5";
    case DVBPSI_AAC_PROFILE_HQ_LEVEL_6:
      return "High quality audio profile, level 6";
    case DVBPSI_AAC_PROFILE_HQ_LEVEL_7:
      return "High quality audio profile, level 7";
    case DVBPSI_AAC_PROFILE_HQ_LEVEL_8:
      return "High quality audio profile, level 8";
    case DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_1:
      return "Low delay audio profile, level 1";
    case DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_2:
      return "Low delay audio profile, level 2";
    case DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_3:
      return "Low delay audio profile, level 3";
    case DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_4:
      return "Low delay audio profile, level 4";
    case DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_5:
      return "Low delay audio profile, level 5";
    case DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_6:
      return "Low delay audio profile, level 6";
    case DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_7:
      return "Low delay audio profile, level 7";
    case DVBPSI_AAC_PROFILE_LOW_DELAY_LEVEL_8:
      return "Low delay audio profile, level 8";
    case DVBPSI_AAC_PROFILE_NATURAL_LEVEL_1:
      return "Natural audio profile, level 1";
    case DVBPSI_AAC_PROFILE_NATURAL_LEVEL_2:
      return "Natural audio profile, level 2";
    case DVBPSI_AAC_PROFILE_NATURAL_LEVEL_3:
      return "Natural audio profile, level 3";
    case DVBPSI_AAC_PROFILE_NATURAL_LEVEL_4:
      return "Natural audio profile, level 4";
    case DVBPSI_AAC_PROFILE_MOBILE_LEVEL_1:
      return "Mobile audio internetworking profile, level 1";
    case DVBPSI_AAC_PROFILE_MOBILE_LEVEL_2:
      return "Mobile audio internetworking profile, level 2";
    case DVBPSI_AAC_PROFILE_MOBILE_LEVEL_3:
      return "Mobile audio internetworking profile, level 3";
    case DVBPSI_AAC_PROFILE_MOBILE_LEVEL_4:
      return "Mobile audio internetworking profile, level 4";
    case DVBPSI_AAC_PROFILE_MOBILE_LEVEL_5:
      return "Mobile audio internetworking profile, level 5";
    case DVBPSI_AAC_PROFILE_MOBILE_LEVEL_6:
      return "Mobile audio internetworking profile, level 6";
    case DVBPSI_AAC_PROFILE_LEVEL_1:
      return "AAC profile, level 1";
    case DVBPSI_AAC_PROFILE_LEVEL_2:
      return "AAC profile, level 2";
    case DVBPSI_AAC_PROFILE_LEVEL_4:
      return "AAC profile, level 4";
    case DVBPSI_AAC_PROFILE_LEVEL_5:
      return "AAC profile, level 5";
    case DVBPSI_HE_AAC_PROFILE_LEVEL_2:
      return "High efficiency AAC profile, level 2";
    case DVBPSI_HE_AAC_PROFILE_LEVEL_3:
      return "High efficiency AAC profile, level 3";
    case DVBPSI_HE_AAC_PROFILE_LEVEL_4:
      return "High efficiency AAC profile, level 4";
    case DVBPSI_HE_AAC_PROFILE_LEVEL_5:
      return "High efficiency AAC profile, level 5";
    case DVBPSI_HE_AAC_V2_PROFILE_LEVEL_2:
      return "High efficiency AAC v2 profile, level 2";
    case DVBPSI_HE_AAC_V2_PROFILE_LEVEL_3:
      return "High efficiency AAC v2 profile, level 3";
    case DVBPSI_HE_AAC_V2_PROFILE_LEVEL_4:
      return "High efficiency AAC v2 profile, level 4";
    case DVBPSI_HE_AAC_V2_PROFILE_LEVEL_5:
      return "High efficiency AAC v2 profile, level 5";
    case DVBPSI_AAC_PROFILE_NOT_SPECIFIED:
      return "Audio profile and level not specified by the MPEG-4_audio_profile_and_level field in this descriptor";
    case DVBPSI_AAC_PROFILE_RESERVED:

    default:
      return "reserved";
  }
}

// DumpAACDescriptor
// file libdvbpsi.c line 1347
static void DumpAACDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_aac_dr_s *p_aac_descriptor = (const struct dvbpsi_aac_dr_s *)p_descriptor;
  printf("AAC audio descriptor\n");
  const char *return_value_AACProfileToString$1;
  return_value_AACProfileToString$1=AACProfileToString(p_aac_descriptor->i_profile_and_level);
  printf("\tprofile and level: %s (0x%02x)\n", return_value_AACProfileToString$1, p_aac_descriptor->i_profile_and_level);
  if(!(p_aac_descriptor->b_type == (_Bool)0))
  {
    printf("\ttype: ");
    switch((signed int)p_aac_descriptor->i_type)
    {
      case DVBPSI_AAC_RESERVED0:
      {
        printf("reserved\n");
        break;
      }
      case DVBPSI_HE_AAC_MONO:
      {
        printf("HE-AAC audio, single mono channel\n");
        break;
      }
      case DVBPSI_AAC_RESERVED1:
      {
        printf("reserved\n");
        break;
      }
      case DVBPSI_HE_AAC_STEREO:
      {
        printf("HE-AAC audio, stereo\n");
        break;
      }
      case DVBPSI_AAC_RESERVED2:
      {
        printf("reserved\n");
        break;
      }
      case DVBPSI_HE_AAC_SURROUND:
      {
        printf("HE-AAC audio, surround sound\n");
        break;
      }
      case DVBPSI_HE_AAC_IMPAIRED:
      {
        printf("HE-AAC audio description for the visually impaired\n");
        break;
      }
      case DVBPSI_HE_AAC_HEARING:
      {
        printf("HE-AAC audio for the hard of hearing\n");
        break;
      }
      case DVBPSI_HE_AAC_MIXED:
      {
        printf("HE-AAC receiver-mixed supplementary audio as per annex E of TS 101 154\n");
        break;
      }
      case DVBPSI_HE_AAC_V2_STEREO:
      {
        printf("HE-AAC v2 audio, stereo\n");
        break;
      }
      case DVBPSI_HE_AAC_V2_IMPAIRED:
      {
        printf("HE-AAC v2 audio description for the visually impaired\n");
        break;
      }
      case DVBPSI_HE_AAC_V2_HEARING:
      {
        printf("HE-AAC v2 audio for the hard of hearing\n");
        break;
      }
      case DVBPSI_HE_AAC_V2_MIXED:
      {
        printf("HE-AAC v2 receiver-mixed supplementary audio as per annex E of TS 101 154\n");
        break;
      }
      case DVBPSI_HE_AAC_MIXED_IMPAIRED:
      {
        printf("HE-AAC receiver mix audio description for the visually impaired\n");
        break;
      }
      case DVBPSI_HE_AAC_BROADCAST_MIXED_IMPAIRED:
      {
        printf("HE-AAC broadcaster mix audio description for the visually impaired\n");
        break;
      }
      case DVBPSI_HE_AAC_V2_MIXED_IMPAIRED:
      {
        printf("HE-AAC v2 receiver mix audio description for the visually impaired\n");
        break;
      }
      case DVBPSI_HE_AAC_V2_BROADCAST_MIXED_IMPAIRED:
      {
        printf("HE-AAC v2 broadcaster mix audio description for the visually impaired\n");
        break;
      }
      default:
        printf("reserved\n");
    }
  }

  printf("\tadditional info bytes: %d\n", p_aac_descriptor->i_additional_info_length);
}

// DumpATSCEITEventDescriptors
// file libdvbpsi.c line 1985
static void DumpATSCEITEventDescriptors(struct dvbpsi_atsc_eit_event_s *p_atsc_eit_event)
{
  struct dvbpsi_atsc_eit_event_s *p_event = p_atsc_eit_event;
  while(!(p_event == ((struct dvbpsi_atsc_eit_event_s *)NULL)))
  {
    printf("\t  | Event id: %d\n", p_event->i_event_id);
    printf("\t  | Start time: %u\n", p_event->i_start_time);
    const char *return_value_GetAtscETMLocations$1;
    return_value_GetAtscETMLocations$1=GetAtscETMLocations(p_event->i_etm_location);
    printf("\t  | ETM location: %s\n", return_value_GetAtscETMLocations$1);
    printf("\t  | Duration: %d seconds\n", p_event->i_length_seconds);
    printf("\t  | Title length: %d bytes\n", p_event->i_title_length);
    printf("\t  | Title: %s\n", (const void *)p_event->i_title);
    DumpDescriptors("\t  |  ]", p_event->p_first_descriptor);
    p_event = p_event->p_next;
  }
}

// DumpAtscVCTChannels
// file libdvbpsi.c line 1940
static void DumpAtscVCTChannels(struct dvbpsi_atsc_vct_channel_s *p_vct_channels)
{
  struct dvbpsi_atsc_vct_channel_s *p_channel = p_vct_channels;
  while(!(p_channel == ((struct dvbpsi_atsc_vct_channel_s *)NULL)))
  {
    printf("\n");
    printf("\t  | Short name  : %s\n", (const void *)p_channel->i_short_name);
    printf("\t  | Major number: %d\n", p_channel->i_major_number);
    printf("\t  | Minor number: %d\n", p_channel->i_minor_number);
    const char *return_value_GetAtscVCTModulationModes$1;
    return_value_GetAtscVCTModulationModes$1=GetAtscVCTModulationModes(p_channel->i_modulation);
    printf("\t  | Modulation  : %s\n", return_value_GetAtscVCTModulationModes$1);
    printf("\t  | Carrier     : %d\n", p_channel->i_carrier_freq);
    printf("\t  | Transport id: %d\n", p_channel->i_channel_tsid);
    printf("\t  | Program number: %d\n", p_channel->i_program_number);
    const char *return_value_GetAtscETMLocations$2;
    return_value_GetAtscETMLocations$2=GetAtscETMLocations(p_channel->i_etm_location);
    printf("\t  | ETM location: %s\n", return_value_GetAtscETMLocations$2);
    printf("\t  | Scrambled   : %s\n", p_channel->b_access_controlled != (_Bool)0 ? "yes" : "no");
    printf("\t  | Path Select : %s\n", p_channel->b_path_select != (_Bool)0 ? "yes" : "no");
    printf("\t  | Out of band : %s\n", p_channel->b_out_of_band != (_Bool)0 ? "yes" : "no");
    printf("\t  | Hidden      : %s\n", p_channel->b_hidden != (_Bool)0 ? "yes" : "no");
    printf("\t  | Hide guide  : %s\n", p_channel->b_hide_guide != (_Bool)0 ? "yes" : "no");
    printf("\t  | Service type: %d\n", p_channel->i_service_type);
    printf("\t  | Source id   : %d\n", p_channel->i_source_id);
    DumpDescriptors("\t  |  ]", p_channel->p_first_descriptor);
    p_channel = p_channel->p_next;
  }
}

// DumpCAIdentifierDescriptor
// file libdvbpsi.c line 1073
static void DumpCAIdentifierDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_ca_identifier_dr_s *p_ca_descriptor = (const struct dvbpsi_ca_identifier_dr_s *)p_descriptor;
  printf("CA system id\n");
  signed int i = 0;
  for( ; !(i >= (signed int)p_ca_descriptor->i_number); i = i + 1)
    printf("\t%d: %d\n", i, p_ca_descriptor->p_system[(signed long int)i].i_ca_system_id);
}

// DumpCUEIDescriptor
// file libdvbpsi.c line 1446
static void DumpCUEIDescriptor(const void *p_descriptor)
{
  const char *cuei_stream_type;
  const struct dvbpsi_cuei_dr_s *p_cuei_descriptor = (const struct dvbpsi_cuei_dr_s *)p_descriptor;
  /* assertion p_cuei_descriptor */
  assert(p_cuei_descriptor != ((const struct dvbpsi_cuei_dr_s *)NULL));
  _Bool tmp_if_expr$1;
  switch((signed int)p_cuei_descriptor->i_cue_stream_type)
  {
    case 0x00:
    {
      cuei_stream_type = "splice_insert, splice_null, splice_schedule";
      break;
    }
    case 0x01:
    {
      cuei_stream_type = "All Commands";
      break;
    }
    case 0x02:
    {
      cuei_stream_type = "Segmentation";
      break;
    }
    case 0x03:
    {
      cuei_stream_type = "Tiered Splicing";
      break;
    }
    case 0x04:
    {
      cuei_stream_type = "Tiered Segmentation";
      break;
    }
    default:
    {
      if((signed int)p_cuei_descriptor->i_cue_stream_type >= 0x05)
        tmp_if_expr$1 = (signed int)p_cuei_descriptor->i_cue_stream_type <= 0x7f ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        cuei_stream_type = "Reserved";

      else
        if((signed int)p_cuei_descriptor->i_cue_stream_type >= 0x80)
          cuei_stream_type = "User defined";

      goto __CPROVER_DUMP_L12;
    }
  }
  printf("CUE Identifier stream type: (%0xd) %s\n", p_cuei_descriptor->i_cue_stream_type, cuei_stream_type);

__CPROVER_DUMP_L12:
  ;
}

// DumpContentDescriptor
// file libdvbpsi.c line 1208
static void DumpContentDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_content_dr_s *p_content_descriptor = (const struct dvbpsi_content_dr_s *)p_descriptor;
  struct anonymous$8 content_category[17l] = { { .i_category=0x0, .p_category="Undefined" },
    { .i_category=0x1, .p_category="Movie" },
    { .i_category=0x2, .p_category="News" },
    { .i_category=0x3, .p_category="Show" },
    { .i_category=0x4, .p_category="Sports" },
    { .i_category=0x5, .p_category="Children" },
    { .i_category=0x6, .p_category="Music" },
    { .i_category=0x7, .p_category="Culture" },
    { .i_category=0x8, .p_category="Social" },
    { .i_category=0x9, .p_category="Education" },
    { .i_category=0xa, .p_category="Leisur" },
    { .i_category=0xb, .p_category="Special" },
    { .i_category=0, .p_category=(const char *)(void *)0 },
    { .i_category=0, .p_category=(const char *)(void *)0 },
    { .i_category=0, .p_category=(const char *)(void *)0 },
    { .i_category=0xf, .p_category="User defined" },
    { .i_category=0, .p_category=(const char *)(void *)0 } };
  printf("Content\n");
  signed int i = 0;
  for( ; !(i >= (signed int)p_content_descriptor->i_contents_number); i = i + 1)
  {
    signed int i_type = (signed int)p_content_descriptor->p_content[(signed long int)i].i_type;
    signed int i_category = i_type >> 4;
    printf("\t\tcategory: %s\n", content_category[(signed long int)i_category].p_category);
    const char *return_value_GetContentSubCategory$1;
    return_value_GetContentSubCategory$1=GetContentSubCategory(i_type);
    printf("\t\tsub category: %s\n", return_value_GetContentSubCategory$1);
    printf("\t\tuser byte: 0x%x\n", p_content_descriptor->p_content[(signed long int)i].i_user_byte);
  }
}

// DumpDescriptor
// file libdvbpsi.c line 1591
static void DumpDescriptor(struct dvbpsi_descriptor_s *p_descriptor)
{
  const void *p_decoded = (void *)0;
  void (*dump_dr_fn)(const void *) = (void (*)(const void *))(void *)0;
  const char *return_value_GetDescriptorName$1;
  const char *return_value_GetDescriptorName$2;
  struct dvbpsi_aac_dr_s *return_value_dvbpsi_DecodeAACDr$3;
  struct dvbpsi_system_clock_dr_s *return_value_dvbpsi_DecodeSystemClockDr$4;
  struct dvbpsi_cuei_dr_s *return_value_dvbpsi_DecodeCUEIDr$5;
  struct dvbpsi_max_bitrate_dr_s *return_value_dvbpsi_DecodeMaxBitrateDr$6;
  struct dvbpsi_smoothing_buffer_dr_s *return_value_dvbpsi_DecodeSmoothingBufferDr$7;
  struct dvbpsi_std_dr_s *return_value_dvbpsi_DecodeSTDDr$8;
  struct dvbpsi_ibp_dr_s *return_value_dvbpsi_DecodeIBPDr$9;
  struct dvbpsi_mpeg4_video_dr_s *return_value_dvbpsi_DecodeMPEG4VideoDr$10;
  struct dvbpsi_mpeg4_audio_dr_s *return_value_dvbpsi_DecodeMPEG4AudioDr$11;
  struct dvbpsi_tshifted_service_dr_s *return_value_dvbpsi_DecodeTimeShiftedServiceDr$12;
  struct dvbpsi_tshifted_ev_dr_s *return_value_dvbpsi_DecodeTimeShiftedEventDr$13;
  struct dvbpsi_stream_identifier_dr_s *return_value_dvbpsi_DecodeStreamIdentifierDr$14;
  struct dvbpsi_ca_identifier_dr_s *return_value_dvbpsi_DecodeCAIdentifierDr$15;
  struct dvbpsi_content_dr_s *return_value_dvbpsi_DecodeContentDr$16;
  struct dvbpsi_subtitling_dr_s *return_value_dvbpsi_DecodeSubtitlingDr$17;
  switch((signed int)p_descriptor->i_tag)
  {
    case 0x06:

    case 0x28:
    {
      printf("\"");
      signed int i = 0;
      for( ; !(i >= (signed int)p_descriptor->i_length); i = i + 1)
        switch((signed int)p_descriptor->p_data[(signed long int)i])
        {
          case 0x00:
          {
            printf("0");
            break;
          }
          case 0x01:
          {
            printf("1");
            break;
          }
          case 0x02:
          {
            printf("2");
            break;
          }
          case 0x03:
          {
            printf("3");
            break;
          }
          default:
            printf("?");
        }
      return_value_GetDescriptorName$1=GetDescriptorName(p_descriptor->i_tag);
      printf("\" (%s)\n", return_value_GetDescriptorName$1);
      break;
    }
    case 0x6a:
    {
      return_value_GetDescriptorName$2=GetDescriptorName(p_descriptor->i_tag);
      printf("\"a52\" (%s)\n", return_value_GetDescriptorName$2);
      break;
    }
    case 0x7c:
    {
      return_value_dvbpsi_DecodeAACDr$3=dvbpsi_DecodeAACDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeAACDr$3;
      dump_dr_fn = DumpAACDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x08:
    {
      return_value_dvbpsi_DecodeSystemClockDr$4=dvbpsi_DecodeSystemClockDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeSystemClockDr$4;
      dump_dr_fn = DumpSystemClockDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x8a:
    {
      return_value_dvbpsi_DecodeCUEIDr$5=dvbpsi_DecodeCUEIDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeCUEIDr$5;
      dump_dr_fn = DumpCUEIDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x0e:
    {
      return_value_dvbpsi_DecodeMaxBitrateDr$6=dvbpsi_DecodeMaxBitrateDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeMaxBitrateDr$6;
      dump_dr_fn = DumpMaxBitrateDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x10:
    {
      return_value_dvbpsi_DecodeSmoothingBufferDr$7=dvbpsi_DecodeSmoothingBufferDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeSmoothingBufferDr$7;
      dump_dr_fn = DumpSmoothingBufferDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x11:
    {
      return_value_dvbpsi_DecodeSTDDr$8=dvbpsi_DecodeSTDDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeSTDDr$8;
      dump_dr_fn = DumpSTDDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x12:
    {
      return_value_dvbpsi_DecodeIBPDr$9=dvbpsi_DecodeIBPDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeIBPDr$9;
      dump_dr_fn = DumpIBPDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x1b:
    {
      return_value_dvbpsi_DecodeMPEG4VideoDr$10=dvbpsi_DecodeMPEG4VideoDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeMPEG4VideoDr$10;
      dump_dr_fn = DumpMPEG4VideoDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x1c:
    {
      return_value_dvbpsi_DecodeMPEG4AudioDr$11=dvbpsi_DecodeMPEG4AudioDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeMPEG4AudioDr$11;
      dump_dr_fn = DumpMPEG4AudioDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x4c:
    {
      return_value_dvbpsi_DecodeTimeShiftedServiceDr$12=dvbpsi_DecodeTimeShiftedServiceDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeTimeShiftedServiceDr$12;
      dump_dr_fn = DumpTimeShiftedServiceDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x4f:
    {
      return_value_dvbpsi_DecodeTimeShiftedEventDr$13=dvbpsi_DecodeTimeShiftedEventDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeTimeShiftedEventDr$13;
      dump_dr_fn = DumpTimeShiftedEventDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x52:
    {
      return_value_dvbpsi_DecodeStreamIdentifierDr$14=dvbpsi_DecodeStreamIdentifierDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeStreamIdentifierDr$14;
      dump_dr_fn = DumpStreamIdentifierDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x53:
    {
      return_value_dvbpsi_DecodeCAIdentifierDr$15=dvbpsi_DecodeCAIdentifierDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeCAIdentifierDr$15;
      dump_dr_fn = DumpCAIdentifierDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x54:
    {
      return_value_dvbpsi_DecodeContentDr$16=dvbpsi_DecodeContentDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeContentDr$16;
      dump_dr_fn = DumpContentDescriptor;
      goto __CPROVER_DUMP_L26;
    }
    case 0x59:
    {
      return_value_dvbpsi_DecodeSubtitlingDr$17=dvbpsi_DecodeSubtitlingDr(p_descriptor);
      p_decoded = (const void *)return_value_dvbpsi_DecodeSubtitlingDr$17;
      dump_dr_fn = DumpSubtitleDescriptor;
    }
    default:
    {

    __CPROVER_DUMP_L26:
      ;
      if(!(dump_dr_fn == ((void (*)(const void *))NULL)) && !(p_decoded == NULL))
        dump_dr_fn(p_decoded);

      else
      {
        printf("\"");
        signed int DumpDescriptor$$1$$3$$1$$i = 0;
        for( ; !(DumpDescriptor$$1$$3$$1$$i >= (signed int)p_descriptor->i_length); DumpDescriptor$$1$$3$$1$$i = DumpDescriptor$$1$$3$$1$$i + 1)
          printf("%c", p_descriptor->p_data[(signed long int)DumpDescriptor$$1$$3$$1$$i]);
        const char *return_value_GetDescriptorName$18;
        return_value_GetDescriptorName$18=GetDescriptorName(p_descriptor->i_tag);
        printf("\" (%s)\n", return_value_GetDescriptorName$18);
      }
    }
  }
}

// DumpDescriptors
// file libdvbpsi.c line 1702
static void DumpDescriptors(const char *str, struct dvbpsi_descriptor_s *p_descriptor)
{
  for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
  {
    printf("%s 0x%02x : ", str, p_descriptor->i_tag);
    DumpDescriptor(p_descriptor);
  }
}

// DumpEITEventDescriptors
// file libdvbpsi.c line 1748
static void DumpEITEventDescriptors(struct dvbpsi_eit_event_s *p_eit_event)
{
  struct dvbpsi_eit_event_s *p_event = p_eit_event;
  for( ; !(p_event == ((struct dvbpsi_eit_event_s *)NULL)); p_event = p_event->p_next)
  {
    printf("\t  | Event id: %d\n", p_event->i_event_id);
    if(!(p_event->b_nvod == (_Bool)0))
      printf("\t  | Start time: Unscheduled Near Video On Demand (NVOD) event\n");

    else
      printf("\t  | Start time: %ld\n", p_event->i_start_time);
    printf("\t  | Duration: %d\n", p_event->i_duration);
    printf("\t  | Running status: %d\n", p_event->i_running_status);
    printf("\t  | Free CA mode: %s\n", p_event->b_free_ca != (_Bool)0 ? "yes" : "no");
    printf("\t  | Descriptor loop length: %d bytes\n", p_event->i_descriptors_length);
    DumpDescriptors("\t  |  ]", p_event->p_first_descriptor);
  }
}

// DumpIBPDescriptor
// file libdvbpsi.c line 978
static void DumpIBPDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_ibp_dr_s *ibp_descriptor = (const struct dvbpsi_ibp_dr_s *)p_descriptor;
  printf("Closed GOP flag: %d \n", ibp_descriptor->b_closed_gop_flag);
  printf("\t\tIdentical GOP flag: %d \n", ibp_descriptor->b_identical_gop_flag);
  printf("\t\tMax GOP length: %u \n", ibp_descriptor->i_max_gop_length);
}

// DumpMPEG4AudioDescriptor
// file libdvbpsi.c line 1041
static void DumpMPEG4AudioDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_mpeg4_audio_dr_s *mpeg4_descriptor = (const struct dvbpsi_mpeg4_audio_dr_s *)p_descriptor;
  const char *return_value_AACProfileToString$1;
  return_value_AACProfileToString$1=AACProfileToString(mpeg4_descriptor->i_mpeg4_audio_profile_and_level);
  printf("MPEG-4 Audio Profile and Level : %s (0x%02x) \n", return_value_AACProfileToString$1, mpeg4_descriptor->i_mpeg4_audio_profile_and_level);
}

// DumpMPEG4VideoDescriptor
// file libdvbpsi.c line 1033
static void DumpMPEG4VideoDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_mpeg4_video_dr_s *mpeg4_descriptor = (const struct dvbpsi_mpeg4_video_dr_s *)p_descriptor;
  const char *return_value_MPEG4VideoProfileToString$1;
  return_value_MPEG4VideoProfileToString$1=MPEG4VideoProfileToString(mpeg4_descriptor->i_mpeg4_visual_profile_and_level);
  printf("MPEG-4 Video Profile and Level : %s (0x%02x) \n", return_value_MPEG4VideoProfileToString$1, mpeg4_descriptor->i_mpeg4_visual_profile_and_level);
}

// DumpMaxBitrateDescriptor
// file libdvbpsi.c line 950
static void DumpMaxBitrateDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_max_bitrate_dr_s *bitrate_descriptor = (const struct dvbpsi_max_bitrate_dr_s *)p_descriptor;
  printf("Bitrate: %d\n", bitrate_descriptor->i_max_bitrate);
}

// DumpRSTEvents
// file libdvbpsi.c line 2068
static void DumpRSTEvents(const char *str, struct dvbpsi_rst_event_s *p_event)
{
  for( ; !(p_event == ((struct dvbpsi_rst_event_s *)NULL)); p_event = p_event->p_next)
  {
    printf("%s transport stream id: %d\n", str, p_event->i_ts_id);
    printf("%s original network id: %d\n", str, p_event->i_orig_network_id);
    printf("%s service id: %d\n", str, p_event->i_service_id);
    printf("%s event id: %d\n", str, p_event->i_event_id);
    printf("%s running status id: %d ", str, p_event->i_running_status);
    switch((signed int)p_event->i_running_status)
    {
      case 0x00:
      {
        printf("(undefined)\n");
        break;
      }
      case 0x01:
      {
        printf("(not running)\n");
        break;
      }
      case 0x02:
      {
        printf("(starts in a few seconds (e.g. for video recording))\n");
        break;
      }
      case 0x03:
      {
        printf("(pausing)\n");
        break;
      }
      case 0x04:
      {
        printf("(running)\n");
        break;
      }
      case 0x05:
      {
        printf("(service off-air)\n");
        break;
      }
      default:
        printf("(reserved for future use)\n");
    }
  }
}

// DumpSISDescriptors
// file libdvbpsi.c line 1491
static void DumpSISDescriptors(const char *str, struct dvbpsi_descriptor_s *p_descriptor)
{
  unsigned int id;
  double i_preroll;
  unsigned char i_dtmf_count;
  const char *return_value_GetDescriptorName$1;
  while(!(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)))
  {
    /* assertion p_descriptor->i_length >= 4 */
    assert((signed int)p_descriptor->i_length >= 4);
    unsigned int i_identifier = (unsigned int)p_descriptor->p_data[(signed long int)0] << 24 | (unsigned int)p_descriptor->p_data[(signed long int)1] << 16 | (unsigned int)p_descriptor->p_data[(signed long int)2] << 8 | (unsigned int)p_descriptor->p_data[(signed long int)3];
    printf("%s 0x%02x : ", str, p_descriptor->i_tag);
    if(i_identifier == 1129661769u)
      printf("CUEI");

    else
      printf("unknown");
    switch((signed int)p_descriptor->i_tag)
    {
      case 0x00:
      {
        /* assertion p_descriptor->i_length >= 8 */
        assert((signed int)p_descriptor->i_length >= 8);
        id = (unsigned int)p_descriptor->p_data[(signed long int)4] << 24 | (unsigned int)p_descriptor->p_data[(signed long int)5] << 16 | (unsigned int)p_descriptor->p_data[(signed long int)6] << 8 | (unsigned int)p_descriptor->p_data[(signed long int)7];
        printf("\"0x%x\" (%s)\n", id, (const void *)"avail descriptor");
        break;
      }
      case 0x01:
      {
        /* assertion p_descriptor->i_length >= 6 */
        assert((signed int)p_descriptor->i_length >= 6);
        i_preroll = (double)p_descriptor->p_data[(signed long int)4] * 0.1;
        i_dtmf_count = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)5] & 0xE0);
        printf("\"");
        signed int DumpSISDescriptors$$1$$1$$1$$2$$1$$i = 0;
        for( ; !(DumpSISDescriptors$$1$$1$$1$$2$$1$$i >= (signed int)i_dtmf_count); DumpSISDescriptors$$1$$1$$1$$2$$1$$i = DumpSISDescriptors$$1$$1$$1$$2$$1$$i + 1)
          printf("%c", p_descriptor->p_data[(signed long int)(6 + DumpSISDescriptors$$1$$1$$1$$2$$1$$i)]);
        printf("\" preroll %.2f sec. (%s)\n", i_preroll, (const void *)"DTMF descriptor");
        break;
      }
      case 0x02:
      {
        DumpSISSegmentationDescriptor(p_descriptor);
        break;
      }
      default:
      {
        printf("\"");
        signed int i = 4;
        for( ; !(i >= (signed int)p_descriptor->i_length); i = i + 1)
          printf("%c", p_descriptor->p_data[(signed long int)i]);
        return_value_GetDescriptorName$1=GetDescriptorName(p_descriptor->i_tag);
        printf("\" (%s)\n", return_value_GetDescriptorName$1);
      }
    }
    p_descriptor = p_descriptor->p_next;
  }
}

// DumpSISSegmentationDescriptor
// file libdvbpsi.c line 1479
static void DumpSISSegmentationDescriptor(struct dvbpsi_descriptor_s *p_descriptor)
{
  printf("\"");
  signed int i = 4;
  for( ; !(i >= (signed int)p_descriptor->i_length); i = i + 1)
    printf("%c", p_descriptor->p_data[(signed long int)i]);
  printf("\" (%s)\n", (const void *)"segmentation descriptor");
}

// DumpSTDDescriptor
// file libdvbpsi.c line 969
static void DumpSTDDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_std_dr_s *std_descriptor = (const struct dvbpsi_std_dr_s *)p_descriptor;
  printf("Leak valid flag: %d\n", std_descriptor->b_leak_valid_flag);
}

// DumpSmoothingBufferDescriptor
// file libdvbpsi.c line 959
static void DumpSmoothingBufferDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_smoothing_buffer_dr_s *smoothing_descriptor = (const struct dvbpsi_smoothing_buffer_dr_s *)p_descriptor;
  printf("Leak rate: %d \n", smoothing_descriptor->i_sb_leak_rate);
  printf("\t\tSize: %d \n", smoothing_descriptor->i_sb_size);
}

// DumpStreamIdentifierDescriptor
// file libdvbpsi.c line 1064
static void DumpStreamIdentifierDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_stream_identifier_dr_s *p_si_descriptor = (const struct dvbpsi_stream_identifier_dr_s *)p_descriptor;
  printf("Component tag: %d\n", p_si_descriptor->i_component_tag);
}

// DumpSubtitleDescriptor
// file libdvbpsi.c line 1246
static void DumpSubtitleDescriptor(const void *p_descriptor)
{
  signed int a;
  const struct dvbpsi_subtitling_dr_s *p_subtitle_descriptor = (const struct dvbpsi_subtitling_dr_s *)p_descriptor;
  printf("%d subtitles,\n", p_subtitle_descriptor->i_subtitles_number);
  a = 0;
  for( ; !(a >= (signed int)p_subtitle_descriptor->i_subtitles_number); a = a + 1)
    printf("\t\t   | %d - lang: %c%c%c, type: %d, cpid: %d, apid: %d\n", a, p_subtitle_descriptor->p_subtitle[(signed long int)a].i_iso6392_language_code[(signed long int)0], p_subtitle_descriptor->p_subtitle[(signed long int)a].i_iso6392_language_code[(signed long int)1], p_subtitle_descriptor->p_subtitle[(signed long int)a].i_iso6392_language_code[(signed long int)2], p_subtitle_descriptor->p_subtitle[(signed long int)a].i_subtitling_type, p_subtitle_descriptor->p_subtitle[(signed long int)a].i_composition_page_id, p_subtitle_descriptor->p_subtitle[(signed long int)a].i_ancillary_page_id);
}

// DumpSystemClockDescriptor
// file libdvbpsi.c line 1052
static void DumpSystemClockDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_system_clock_dr_s *p_clock_descriptor = (const struct dvbpsi_system_clock_dr_s *)p_descriptor;
  double return_value_pow$1;
  return_value_pow$1=pow(10.0, -((double)p_clock_descriptor->i_clock_accuracy_exponent));
  printf("External clock: %s, Accuracy: %E\n", p_clock_descriptor->b_external_clock_ref != (_Bool)0 ? "Yes" : "No", (double)p_clock_descriptor->i_clock_accuracy_integer * return_value_pow$1);
}

// DumpTSDescriptorsBAT
// file libdvbpsi.c line 2135
static void DumpTSDescriptorsBAT(struct dvbpsi_bat_ts_s *p_bat_ts)
{
  struct dvbpsi_bat_ts_s *p_ts = p_bat_ts;
  for( ; !(p_ts == ((struct dvbpsi_bat_ts_s *)NULL)); p_ts = p_ts->p_next)
  {
    printf("\t  | transport id: %d\n", p_ts->i_ts_id);
    printf("\t  | original network id: %d\n", p_ts->i_orig_network_id);
    DumpDescriptors("\t  |  ]", p_bat_ts->p_first_descriptor);
  }
}

// DumpTSDescriptorsNIT
// file libdvbpsi.c line 2105
static void DumpTSDescriptorsNIT(struct dvbpsi_nit_ts_s *p_nit_ts)
{
  struct dvbpsi_nit_ts_s *p_ts = p_nit_ts;
  for( ; !(p_ts == ((struct dvbpsi_nit_ts_s *)NULL)); p_ts = p_ts->p_next)
  {
    printf("\t  | transport id: %d\n", p_ts->i_ts_id);
    printf("\t  | original network id: %d\n", p_ts->i_orig_network_id);
    DumpDescriptors("\t  |  ]", p_nit_ts->p_first_descriptor);
  }
}

// DumpTimeShiftedEventDescriptor
// file libdvbpsi.c line 1434
static void DumpTimeShiftedEventDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_tshifted_ev_dr_s *p_ts_event = (const struct dvbpsi_tshifted_ev_dr_s *)p_descriptor;
  printf("Time Shifted Event");
  printf("\treference service id:%d", p_ts_event->i_ref_service_id);
  printf("\treference event id:%d", p_ts_event->i_ref_event_id);
}

// DumpTimeShiftedServiceDescriptor
// file libdvbpsi.c line 1424
static void DumpTimeShiftedServiceDescriptor(const void *p_descriptor)
{
  const struct dvbpsi_tshifted_service_dr_s *p_ts_service = (const struct dvbpsi_tshifted_service_dr_s *)p_descriptor;
  printf("Time Shifted Service\n");
  printf("\treference service id:%d", p_ts_service->i_ref_service_id);
}

// EncodeEventHeaders
// file tables/eit.c line 611
static inline void EncodeEventHeaders(struct dvbpsi_eit_event_s *p_event, unsigned char *buf)
{
  buf[(signed long int)0] = (unsigned char)((signed int)p_event->i_event_id >> 8);
  buf[(signed long int)1] = (unsigned char)p_event->i_event_id;
  buf[(signed long int)2] = (unsigned char)(p_event->i_start_time >> 32);
  buf[(signed long int)3] = (unsigned char)(p_event->i_start_time >> 24);
  buf[(signed long int)4] = (unsigned char)(p_event->i_start_time >> 16);
  buf[(signed long int)5] = (unsigned char)(p_event->i_start_time >> 8);
  buf[(signed long int)6] = (unsigned char)p_event->i_start_time;
  buf[(signed long int)7] = (unsigned char)(p_event->i_duration >> 16);
  buf[(signed long int)8] = (unsigned char)(p_event->i_duration >> 8);
  buf[(signed long int)9] = (unsigned char)p_event->i_duration;
  buf[(signed long int)10] = (unsigned char)(((signed int)p_event->i_running_status & 0x7) << 5 | ((signed int)p_event->b_free_ca & 0x1) << 4);
}

// GetATSCTableType
// file libdvbpsi.c line 1807
static const char * GetATSCTableType(const signed int i_type)
{
  switch(i_type)
  {
    case 0x0000:
      return "Terrestrial VCT with current_next_indicator=’1’";
    case 0x0001:
      return "Terrestrial VCT with current_next_indicator=’0’";
    case 0x0002:
      return "Cable VCT with current_next_indicator=’1’";
    case 0x0003:
      return "Cable VCT with current_next_indicator=’0’";
    case 0x0004:
      return "Channel ETT";
    case 0x0005:
      return "DCCSCT";
    default:
      if(i_type >= 0x0006 && !(i_type >= 256))
        return "Reserved for future ATSC use";

      else
        if(i_type >= 0x0100 && !(i_type >= 384))
          return "EIT-0 to EIT-127";

        else
          if(i_type >= 0x0180 && !(i_type >= 512))
            return "[Reserved for future ATSC use]";

          else
            if(i_type >= 0x0200 && !(i_type >= 640))
              return "Event ETT-0 to event ETT-127";

            else
              if(i_type >= 0x0280 && !(i_type >= 769))
                return "Reserved for future ATSC use";

              else
                if(i_type >= 0x0301 && !(i_type >= 1024))
                  return "RRT with rating_region 1-255";

                else
                  if(i_type >= 0x0400 && !(i_type >= 4096))
                    return "User private";

                  else
                    if(i_type >= 0x1000 && !(i_type >= 5120))
                      return "Reserved for future ATSC use";

                    else
                      if(i_type >= 0x1400 && !(i_type >= 5376))
                        return "DCCT with dcc_id 0x00 – 0xFF";

                      else
                        if(i_type >= 0x1500 && !(i_type >= 65536))
                          return "Reserved for future ATSC use";

                        else
                          return "unknown";
  }
}

// GetAtscETMLocations
// file libdvbpsi.c line 1928
static const char * GetAtscETMLocations(const unsigned char i_etm_location)
{
  switch((signed int)i_etm_location)
  {
    case 0x0:
      return "No ETM";
    case 0x1:
      return "ETM located in the PTC carrying this PSIP";
    case 0x2:
      return "ETM located in the PTC specified by the channel_TSID";
    case 0x3:
      return "Reserved for future ATSC use";
    default:
      return "unknown";
  }
}

// GetAtscVCTModulationModes
// file libdvbpsi.c line 1908
static const char * GetAtscVCTModulationModes(const unsigned char i_mode)
{
  switch((signed int)i_mode)
  {
    case 0x00:
      return "Reserved";
    case 0x01:
      return "Analog — The virtual channel is modulated using standard analog methods for analog television.";
    case 0x02:
      return "SCTE_mode_1 — The virtual channel has a symbol rate of 5.057 Msps, transmitted in accordance with ANSI/SCTE 07 [21] (Mode 1). Typically, mode 1 will be used for 64-QAM.";
    case 0x03:
      return "SCTE_mode_2 — The virtual channel has a symbol rate of 5.361 Msps, transmitted in accordance with ANSI/SCTE 07 [21] (Mode 2). Typically, mode 2 will be used for 256-QAM.";
    case 0x04:
      return "ATSC (8 VSB) — The virtual channel uses the 8-VSB modulation method conforming to A/53 Part 2 [2].";
    case 0x05:
      return "ATSC (16 VSB) — The virtual channel uses the 16-VSB modulation method conforming to A/53 Part 2 [2].";
    default:
      if((signed int)i_mode >= 0x06 && !((signed int)i_mode >= 128))
        return "Reserved for future use by ATSC";

      else
        if((signed int)i_mode >= 0x80 && !((signed int)i_mode >= 256))
          return "User Private";

        else
          return "unknown";
  }
}

// GetContentSubCategory
// file libdvbpsi.c line 1089
static const char * GetContentSubCategory(const signed int i_type)
{
  struct anonymous$8 content_subcategory[95l] = { { .i_category=0x1 << 4 | 0x0, .p_category="General" },
    { .i_category=0x1 << 4 | 0x1, .p_category="Detective" },
    { .i_category=0x1 << 4 | 0x2, .p_category="Adventure" },
    { .i_category=0x1 << 4 | 0x3, .p_category="Science Fiction" },
    { .i_category=0x1 << 4 | 0x4, .p_category="Comedy" },
    { .i_category=0x1 << 4 | 0x5, .p_category="Soap" },
    { .i_category=0x1 << 4 | 0x6, .p_category="Romance" },
    { .i_category=0x1 << 4 | 0x7, .p_category="Classical" },
    { .i_category=0x1 << 4 | 0x8, .p_category="Adult" },
    { .i_category=0x1 << 4 | 0xf, .p_category="User defined" },
    { .i_category=0x2 << 4 | 0x0, .p_category="General" },
    { .i_category=0x2 << 4 | 0x1, .p_category="Weather" },
    { .i_category=0x2 << 4 | 0x2, .p_category="Magazine" },
    { .i_category=0x2 << 4 | 0x3, .p_category="Documentary" },
    { .i_category=0x2 << 4 | 0x4, .p_category="Discussion" },
    { .i_category=0x2 << 4 | 0xf, .p_category="User Defined" },
    { .i_category=0x3 << 4 | 0x0, .p_category="General" },
    { .i_category=0x3 << 4 | 0x1, .p_category="Quiz" },
    { .i_category=0x3 << 4 | 0x2, .p_category="Variety" },
    { .i_category=0x3 << 4 | 0x3, .p_category="Talk" },
    { .i_category=0x3 << 4 | 0xf, .p_category="User Defined" },
    { .i_category=0x4 << 4 | 0x0, .p_category="General" },
    { .i_category=0x4 << 4 | 0x1, .p_category="Events" },
    { .i_category=0x4 << 4 | 0x2, .p_category="Magazine" },
    { .i_category=0x4 << 4 | 0x3, .p_category="Football" },
    { .i_category=0x4 << 4 | 0x4, .p_category="Tennis" },
    { .i_category=0x4 << 4 | 0x5, .p_category="Team" },
    { .i_category=0x4 << 4 | 0x6, .p_category="Athletics" },
    { .i_category=0x4 << 4 | 0x7, .p_category="Motor" },
    { .i_category=0x4 << 4 | 0x8, .p_category="Water" },
    { .i_category=0x4 << 4 | 0x9, .p_category="Winter" },
    { .i_category=0x4 << 4 | 0xa, .p_category="Equestrian" },
    { .i_category=0x4 << 4 | 0xb, .p_category="Martial" },
    { .i_category=0x4 << 4 | 0xf, .p_category="User Defined" },
    { .i_category=0x5 << 4 | 0x0, .p_category="General" },
    { .i_category=0x5 << 4 | 0x1, .p_category="Preschool" },
    { .i_category=0x5 << 4 | 0x2, .p_category="06 to 14" },
    { .i_category=0x5 << 4 | 0x3, .p_category="10 to 16" },
    { .i_category=0x5 << 4 | 0x4, .p_category="Educational" },
    { .i_category=0x5 << 4 | 0x5, .p_category="Cartoons" },
    { .i_category=0x5 << 4 | 0xf, .p_category="User Defined" },
    { .i_category=0x6 << 4 | 0x0, .p_category="General" },
    { .i_category=0x6 << 4 | 0x1, .p_category="Poprock" },
    { .i_category=0x6 << 4 | 0x2, .p_category="Classical" },
    { .i_category=0x6 << 4 | 0x3, .p_category="Folk" },
    { .i_category=0x6 << 4 | 0x4, .p_category="Jazz" },
    { .i_category=0x6 << 4 | 0x5, .p_category="Opera" },
    { .i_category=0x6 << 4 | 0x6, .p_category="Ballet" },
    { .i_category=0x6 << 4 | 0xf, .p_category="User Defined" },
    { .i_category=0x7 << 4 | 0x0, .p_category="General" },
    { .i_category=0x7 << 4 | 0x1, .p_category="Performance" },
    { .i_category=0x7 << 4 | 0x2, .p_category="Fine Arts" },
    { .i_category=0x7 << 4 | 0x3, .p_category="Religion" },
    { .i_category=0x7 << 4 | 0x4, .p_category="Traditional" },
    { .i_category=0x7 << 4 | 0x5, .p_category="Literature" },
    { .i_category=0x7 << 4 | 0x6, .p_category="Cinema" },
    { .i_category=0x7 << 4 | 0x7, .p_category="Experimental" },
    { .i_category=0x7 << 4 | 0x8, .p_category="Press" },
    { .i_category=0x7 << 4 | 0x9, .p_category="New Media" },
    { .i_category=0x7 << 4 | 0xa, .p_category="Magazine" },
    { .i_category=0x7 << 4 | 0xb, .p_category="Fashion" },
    { .i_category=0x7 << 4 | 0xf, .p_category="User Defined" },
    { .i_category=0x8 << 4 | 0x0, .p_category="General" },
    { .i_category=0x8 << 4 | 0x1, .p_category="Magazine" },
    { .i_category=0x8 << 4 | 0x2, .p_category="Advisory" },
    { .i_category=0x8 << 4 | 0x3, .p_category="People" },
    { .i_category=0x8 << 4 | 0xf, .p_category="User Defined" },
    { .i_category=0x9 << 4 | 0x0, .p_category="General" },
    { .i_category=0x9 << 4 | 0x1, .p_category="Nature" },
    { .i_category=0x9 << 4 | 0x2, .p_category="Technology" },
    { .i_category=0x9 << 4 | 0x3, .p_category="Medicine" },
    { .i_category=0x9 << 4 | 0x4, .p_category="Foreign" },
    { .i_category=0x9 << 4 | 0x5, .p_category="Social" },
    { .i_category=0x9 << 4 | 0x6, .p_category="Further" },
    { .i_category=0x9 << 4 | 0x7, .p_category="Language" },
    { .i_category=0x9 << 4 | 0xf, .p_category="User Defined" },
    { .i_category=0xa << 4 | 0x0, .p_category="General" },
    { .i_category=0xa << 4 | 0x1, .p_category="Travel" },
    { .i_category=0xa << 4 | 0x2, .p_category="Handicraft" },
    { .i_category=0xa << 4 | 0x3, .p_category="Motoring" },
    { .i_category=0xa << 4 | 0x4, .p_category="Fitness" },
    { .i_category=0xa << 4 | 0x5, .p_category="Cooking" },
    { .i_category=0xa << 4 | 0x6, .p_category="Shopping" },
    { .i_category=0xa << 4 | 0x7, .p_category="Gardening" },
    { .i_category=0xa << 4 | 0xf, .p_category="User Defined" },
    { .i_category=0xb << 4 | 0x0, .p_category="Original Language" },
    { .i_category=0xb << 4 | 0x1, .p_category="Black and White " },
    { .i_category=0xb << 4 | 0x2, .p_category="Unpublished" },
    { .i_category=0xb << 4 | 0x3, .p_category="Live" },
    { .i_category=0xb << 4 | 0x4, .p_category="Planostereoscopic" },
    { .i_category=0xb << 4 | 0xb, .p_category="User Defined" },
    { .i_category=0xb << 4 | 0xc, .p_category="User Defined 1" },
    { .i_category=0xb << 4 | 0xd, .p_category="User Defined 2" },
    { .i_category=0xb << 4 | 0xe, .p_category="User Defined 3" },
    { .i_category=0xb << 4 | 0xf, .p_category="User Defined 4" } };
  unsigned int i = (unsigned int)0;
  for( ; !((unsigned long int)i >= 95ul); i = i + 1u)
    if(i_type == content_subcategory[(signed long int)i].i_category)
      return content_subcategory[(signed long int)i].p_category;

  return "Unknown";
}

// GetDescriptorName
// file libdvbpsi.c line 826
static const char * GetDescriptorName(unsigned char tag)
{
  switch((signed int)tag)
  {
    case 0x00:

    case 0x01:
      return "Reserved";
    case 0x02:
      return "Video stream descriptor";
    case 0x03:
      return "Audio stream descriptor";
    case 0x04:
      return "Hierarchy descriptor";
    case 0x05:
      return "Registration descriptor";
    case 0x06:
      return "Data stream alignment descriptor";
    case 0x07:
      return "Target background grid descriptor";
    case 0x08:
      return "Video window descriptor";
    case 0x09:
      return "CA descriptor";
    case 0x0a:
      return "ISO 639 language descriptor";
    case 0x0b:
      return "System clock descriptor";
    case 0x0c:
      return "Multiplex buffer utilization descriptor";
    case 0x0d:
      return "Copyright descriptor";
    case 0x0e:
      return "Maximum bitrate descriptor";
    case 0x0f:
      return "Private data indicator descriptor";
    case 0x10:
      return "Smoothing buffer descriptor";
    case 0x11:
      return "STD descriptor";
    case 0x12:
      return "IBP descriptor";
    case 0x1b:
      return "MPEG-4 video descriptor";
    case 0x1c:
      return "MPEG-4 audio descriptor";
    case 0x1d:
      return "IOD descriptor";
    case 0x1e:
      return "SL descriptor";
    case 0x1f:
      return "FMC descriptor";
    case 0x20:
      return "External ES ID descriptor";
    case 0x21:
      return "Mux Code descriptor";
    case 0x22:
      return "Fmx Buffer Size descriptor";
    case 0x23:
      return "Multiplex buffer descriptor";
    case 0x24:
      return "Content labeling descriptor";
    case 0x25:
      return "Metadata pointer descriptor";
    case 0x26:
      return "Metadata descriptor";
    case 0x27:
      return "Metadata STD descriptor";
    case 0x28:
      return "AVC video descriptor";
    case 0x29:
      return "IPMP descriptor (defined in ISO/IEC 13818-11; break; MPEG-2 IPMP)";
    case 0x2a:
      return "AVC timing and HRD descriptor";
    case 0x2b:
      return "MPEG-2 AAC audio descriptor";
    case 0x2c:
      return "FlexMuxTiming descriptor";
    case 0x40:
      return "User Private | Network Name";
    case 0x41:
      return "User Private | Service List";
    case 0x42:
      return "User Private | Stuffing";
    case 0x43:
      return "Satellite Delivery System descriptor";
    case 0x44:
      return "Cable Delivery System descriptor";
    case 0x45:
      return "VBI Data descriptor";
    case 0x46:
      return "VBI Teletext descriptor";
    case 0x47:
      return "User Private | Bouquet Name";
    case 0x48:
      return "User Private | Service";
    case 0x49:
      return "User Private | Country Availability";
    case 0x4a:
      return "User Private | Linkage";
    case 0x4b:
      return "User Private | NVOD Reference";
    case 0x4c:
      return "User Private | Timeshifted Service";
    case 0x4d:
      return "User Private | ShortEvent";
    case 0x4e:
      return "User Private | Extended Event";
    case 0x4f:
      return "User Private | Timeshifted Event";
    case 0x50:
      return "User Private | Component";
    case 0x51:
      return "User Private | Mosaic";
    case 0x52:
      return "User Private | Stream Component Identifier";
    case 0x53:
      return "User Private | CA Identifier";
    case 0x54:
      return "User Private | Content";
    case 0x55:
      return "User Private | Parental Rating";
    case 0x56:
      return "EBU Teletext";
    case 0x57:
      return "Telephone";
    case 0x58:
      return "Local Time Offset";
    case 0x59:
      return "Subtitling";
    case 0x5A:
      return "Terrestrial Delivery System";
    case 0x5B:
      return "Multilingual Network Name";
    case 0x5C:
      return "Multilingual Bouquet Name";
    case 0x5D:
      return "Multilingual Service Name";
    case 0x5E:
      return "Multilingual Component";
    case 0x5F:
      return "Private Data Specifier";
    case 0x60:
      return "Service Move";
    case 0x61:
      return "Short Smoothing Buffer";
    case 0x62:
      return "Frequency List";
    case 0x63:
      return "Partial Transport Stream";
    case 0x64:
      return "Data Broadcast";
    case 0x65:
      return "CA System descriptor";
    case 0x66:
      return "Data Broadcast Identifier";
    case 0x67:
      return "Transport Stream Identifier";
    case 0x68:
      return "DSNG descriptor";
    case 0x69:
      return "PDC descriptor";
    case 0x6A:
      return "AC3 audio descriptor";
    case 0x6B:
      return "Ancilliary Data descriptor";
    case 0x6C:
      return "Cell List";
    case 0x6D:
      return "Cell Frequency Link";
    case 0x6E:
      return "Announcement Support";
    case 0x6F:
      return "Application Signalling";
    case 0x70:
      return "Adaptation Field";
    case 0x71:
      return "Service Identifier";
    case 0x72:
      return "Service Availability";
    case 0x73:
      return "Default Authority";
    case 0x74:
      return "Related Content";
    case 0x75:
      return "TVA ID";
    case 0x76:
      return "Content Identifier";
    case 0x77:
      return "Time Slice FEC Identifier";
    case 0x78:
      return "ECM Repeater Rate";
    case 0x79:
      return "DVB S2 Satellite Delivery System descriptor";
    case 0x7A:
      return "Enhanced AC3 audio descriptor";
    case 0x7B:
      return "DTS audio descriptor";
    case 0x7C:
      return "AAC audio descriptor";
    case 0x8a:
      return "CUE Identifier descriptor";
    default:
      if((signed int)tag >= 0x13 && !((signed int)tag >= 27))
        return "Defined in ISO/IEC 13818-6";

      else
        if((signed int)tag >= 0x2d && !((signed int)tag >= 64))
          return "ITU-T Rec. H.222.0 | ISO/IEC 13818-1 Reserved";

        else
          if((signed int)tag >= 0x40 && !((signed int)tag >= 82) || (signed int)tag >= 0x53 && !((signed int)tag >= 86))
            return "User Private";

          else
            return "User Private";
  }
}

// GetTypeName
// file libdvbpsi.c line 778
static const char * GetTypeName(unsigned char type)
{
  switch((signed int)type)
  {
    case 0x00:
      return "ITU-T | ISO/IEC Reserved";
    case 0x01:
      return "ISO/IEC 11172-2 Video";
    case 0x02:
      return "ITU-T Rec H.262 | ISO/IEC 13818-2 Video stream descriptor or ISO/IEC 11172-2 constrained parameter video stream";
    case 0x03:
      return "ISO/IEC 11172-3 Audio stream descriptor";
    case 0x04:
      return "ISO/IEC 13818-3 Audio MPEG Audio layer 1/2";
    case 0x05:
      return "ITU-T Rec H.222.0 | ISO/IEC 13818-1 Private Section: Registration descriptor";
    case 0x06:
      return "ITU-T Rec H.222.0 | ISO/IEC 13818-1 Private PES data packets";
    case 0x07:
      return "ISO/IEC 13522 MHEG";
    case 0x08:
      return "ITU-T Rec H.222.0 | ISO/IEC 13818-1 Annex A DSM CC";
    case 0x09:
      return "ITU-T Rec H222.1";
    case 0x0a:
      return "ISO/IEC 13818-6 type A";
    case 0x0b:
      return "ISO/IEC 13818-6 type B";
    case 0x0c:
      return "ISO/IEC 13818-6 type C";
    case 0x0d:
      return "ISO/IEC 13818-6 type D";
    case 0x0e:
      return "ITU-T Rec H.222.0 | ISO/IEC 13818-1 auxillary";
    case 0x0f:
      return "ISO/IEC 13818-7 MPEG2 Audio with ADTS transport syntax";
    case 0x10:
      return "ISO/IEC 14496-2 Visual";
    case 0x11:
      return "ISO/IEC 14496-3 MPEG4 Audio with the LATM transport syntax as defined in ISO/IEC 14496-3";
    case 0x12:
      return "ISO/IEC 14496-1 SL-packetized stream or FlexMux stream carried in PES packets";
    case 0x13:
      return "ISO/IEC 14496-1 SL-packetized stream or FlexMux stream carried in ISO/IEC 14496_sections";
    case 0x14:
      return "ISO/IEC 13818-6 Synchronized Download Protocol";
    case 0x15:
      return "Metadata carried in PES packets";
    case 0x16:
      return "Metadata carried in metadata_sections";
    case 0x17:
      return "Metadata carried in ISO/IEC 13818-6 Data Carousel";
    case 0x18:
      return "Metadata carried in ISO/IEC 13818-6 Object Carousel";
    case 0x19:
      return "Metadata carried in ISO/IEC 13818-6 Synchronized Download Protocol";
    case 0x1A:
      return "IPMP stream (defined in ISO/IEC 13818-11, MPEG-2 IPMP)";
    case 0x1B:
      return "AVC video stream as defined in ITU-T Rec. H.264 | ISO/IEC 14496-10 Video";
    case 0x7F:
      return "IPMP stream";
    default:
      if((signed int)type >= 0x1C && !((signed int)type >= 127))
        return "ITU-T Rec. H.222.0 | ISO/IEC 13818-1 Reserved";

      else
        if((signed int)type >= 0x80)
          return "User Private";

        else
          return "Unknown";
  }
}

// MPEG4VideoProfileToString
// file libdvbpsi.c line 986
static const char * MPEG4VideoProfileToString(enum dvbpsi_mpeg4_visual_profile_and_level_s profile)
{
  switch((signed int)profile)
  {
    case DVBPSI_MPEG4V_PROFILE_SIMPLE_L1:
      return "Simple Profile/Level 1";
    case DVBPSI_MPEG4V_PROFILE_SIMPLE_L2:
      return "Simple Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_SIMPLE_L3:
      return "Simple Profile/Level 3";
    case DVBPSI_MPEG4V_PROFILE_SIMPLE_SCALABLE_L1:
      return "Simple Scalable Profile/Level 1";
    case DVBPSI_MPEG4V_PROFILE_SIMPLE_SCALABLE_L2:
      return "Simple Scalable Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_CORE_L1:
      return "Core Profile/Level 1";
    case DVBPSI_MPEG4V_PROFILE_CORE_L2:
      return "Core Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_MAIN_L2:
      return "Main Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_MAIN_L3:
      return "Main Profile/Level 3";
    case DVBPSI_MPEG4V_PROFILE_MAIN_L4:
      return "Main Profile/Level 4";
    case DVBPSI_MPEG4V_PROFILE_N_BIT_L2:
      return "N-bit Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_SCALABLE_TEXTURE_L1:
      return "Scalable Texture Profile/Level 1";
    case DVBPSI_MPEG4V_PROFILE_SIMPLE_FACE_ANIMATION_L1:
      return "Simple Face Animation Profile/Level 1";
    case DVBPSI_MPEG4V_PROFILE_SIMPLE_FACE_ANIMATION_L2:
      return "Simple Face Animation Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_SIMPLE_FBA_L1:
      return "Simple FBA Profile/Level 1";
    case DVBPSI_MPEG4V_PROFILE_SIMPLE_FBA_L2:
      return "Simple FBA Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_BASIC_ANIMATED_TEXTURE_L1:
      return "Basic Animated Texture Profile/Level 1";
    case DVBPSI_MPEG4V_PROFILE_BASIC_ANIMATED_TEXTURE_L2:
      return "Basic Animated Texture Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_HYBRID_L1:
      return "Hybrid Profile/Level 1";
    case DVBPSI_MPEG4V_PROFILE_HYBRID_L2:
      return "Hybrid Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_ADV_REAL_TIME_SIMPLE_L1:
      return "Advanced Real Time Simple Profile/Level 1";
    case DVBPSI_MPEG4V_PROFILE_ADV_REAL_TIME_SIMPLE_L2:
      return "Advanced Real Time Simple Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_ADV_REAL_TIME_SIMPLE_L3:
      return "Advanced Real Time Simple Profile/Level 3";
    case DVBPSI_MPEG4V_PROFILE_ADV_REAL_TIME_SIMPLE_L4:
      return "Advanced Real Time Simple Profile/Level 4";
    case DVBPSI_MPEG4V_PROFILE_CORE_SCALABLE_L1:
      return "Core Scalable Profile/Level 1";
    case DVBPSI_MPEG4V_PROFILE_CORE_SCALABLE_L2:
      return "Core Scalable Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_CORE_SCALABLE_L3:
      return "Core Scalable Profile/Level 3";
    case DVBPSI_MPEG4V_PROFILE_ADV_CODING_EFF_L1:
      return "Advanced Coding Efficiency Profile/Level 1";
    case DVBPSI_MPEG4V_PROFILE_ADV_CODING_EFF_L2:
      return "Advanced Coding Efficiency Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_ADV_CODING_EFF_L3:
      return "Advanced Coding Efficiency Profile/Level 3";
    case DVBPSI_MPEG4V_PROFILE_ADV_CODING_EFF_L4:
      return "Advanced Coding Efficiency Profile/Level 4";
    case DVBPSI_MPEG4V_PROFILE_ADV_CORE_L1:
      return "Advanced Core Profile/Level 1";
    case DVBPSI_MPEG4V_PROFILE_ADV_CORE_L2:
      return "Advanced Core Profile/Level 2";
    case DVBPSI_MPEG4V_PROFILE_ADV_SCALABLE_TEXTURE_L1:
      return "Advanced Scalable Texture/Level 1";
    case DVBPSI_MPEG4V_PROFILE_ADV_SCALABLE_TEXTURE_L2:
      return "Advanced Scalable Texture/Level 2";
    case DVBPSI_MPEG4V_PROFILE_ADV_SCALABLE_TEXTURE_L3:
      return "Advanced Scalable Texture/Level 3";
    case DVBPSI_MPEG4V_PROFILE_LAST:

    default:
      return "Reserved";
  }
}

// NewAssociationTagDr
// file descriptors/dr_14.c line 42
static struct dvbpsi_association_tag_dr_s * NewAssociationTagDr(const unsigned long int i_selector, const unsigned long int i_private)
{
  struct dvbpsi_association_tag_dr_s *p_tag;
  if(!(i_private >= 1ul) || !(i_selector >= 1ul))
    return (struct dvbpsi_association_tag_dr_s *)(void *)0;

  else
  {
    unsigned long int i_size = sizeof(struct dvbpsi_association_tag_dr_s) /*32ul*/  + i_selector + i_private;
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, i_size);
    p_tag = (struct dvbpsi_association_tag_dr_s *)return_value_calloc$1;
    if(!(p_tag == ((struct dvbpsi_association_tag_dr_s *)NULL)))
    {
      p_tag->p_selector = (unsigned char *)p_tag + (signed long int)sizeof(struct dvbpsi_association_tag_dr_s) /*32ul*/ ;
      p_tag->i_selector_len = (unsigned char)i_selector;
      p_tag->p_private_data = p_tag->p_selector + (signed long int)i_selector;
      p_tag->i_private_data_len = (unsigned char)i_private;
    }

    return p_tag;
  }
}

// NewCarouselDr
// file descriptors/dr_13.c line 42
static struct dvbpsi_carousel_id_dr_s * NewCarouselDr(const unsigned long int i_private)
{
  struct dvbpsi_carousel_id_dr_s *p_carousel;
  if(!(i_private >= 1ul))
    return (struct dvbpsi_carousel_id_dr_s *)(void *)0;

  else
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct dvbpsi_carousel_id_dr_s) /*16ul*/  + i_private);
    p_carousel = (struct dvbpsi_carousel_id_dr_s *)return_value_calloc$1;
    if(!(p_carousel == ((struct dvbpsi_carousel_id_dr_s *)NULL)))
    {
      p_carousel->p_private_data = (unsigned char *)p_carousel + (signed long int)sizeof(struct dvbpsi_carousel_id_dr_s) /*16ul*/ ;
      p_carousel->i_private_data_len = (unsigned char)i_private;
    }

    return p_carousel;
  }
}

// NewDataBroadcastDr
// file descriptors/dr_66.c line 42
static struct dvbpsi_data_broadcast_id_dr_s * NewDataBroadcastDr(const unsigned long int i_private)
{
  struct dvbpsi_data_broadcast_id_dr_s *p_bcast;
  if(!(i_private >= 1ul))
    return (struct dvbpsi_data_broadcast_id_dr_s *)(void *)0;

  else
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct dvbpsi_data_broadcast_id_dr_s) /*16ul*/  + i_private);
    p_bcast = (struct dvbpsi_data_broadcast_id_dr_s *)return_value_calloc$1;
    if(!(p_bcast == ((struct dvbpsi_data_broadcast_id_dr_s *)NULL)))
    {
      p_bcast->p_id_selector = (unsigned char *)p_bcast + (signed long int)sizeof(struct dvbpsi_data_broadcast_id_dr_s) /*16ul*/ ;
      p_bcast->i_id_selector_len = (unsigned char)i_private;
    }

    return p_bcast;
  }
}

// NewEITSection
// file tables/eit.c line 571
static struct dvbpsi_psi_section_s * NewEITSection(struct dvbpsi_eit_s *p_eit, signed int i_table_id, signed int i_section_number)
{
  struct dvbpsi_psi_section_s *p_result;
  p_result=dvbpsi_NewPSISection(4094);
  p_result->i_table_id = (unsigned char)i_table_id;
  p_result->b_syntax_indicator = (_Bool)1;
  p_result->b_private_indicator = (_Bool)1;
  p_result->i_length = (unsigned short int)15;
  p_result->i_extension = p_eit->i_extension;
  p_result->i_version = p_eit->i_version;
  p_result->b_current_next = p_eit->b_current_next;
  p_result->i_number = (unsigned char)i_section_number;
  p_result->p_payload_end = p_result->p_payload_end + (signed long int)14;
  p_result->p_payload_start = p_result->p_data + (signed long int)8;
  p_result->p_data[(signed long int)8] = (unsigned char)((signed int)p_eit->i_ts_id >> 8);
  p_result->p_data[(signed long int)9] = (unsigned char)p_eit->i_ts_id;
  p_result->p_data[(signed long int)10] = (unsigned char)((signed int)p_eit->i_network_id >> 8);
  p_result->p_data[(signed long int)11] = (unsigned char)p_eit->i_network_id;
  p_result->p_data[(signed long int)13] = p_eit->i_last_table_id;
  return p_result;
}

// buffer_free
// file buffer.h line 43
void buffer_free(struct buffer_s *buffer)
{
  free((void *)buffer);
  buffer = (struct buffer_s *)(void *)0;
}

// buffer_new
// file buffer.h line 42
struct buffer_s * buffer_new(unsigned long int i_size)
{
  struct buffer_s *buffer;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct buffer_s) /*32ul*/  + i_size);
  buffer = (struct buffer_s *)return_value_malloc$1;
  if(buffer == ((struct buffer_s *)NULL))
    return (struct buffer_s *)(void *)0;

  else
  {
    buffer->i_size = i_size;
    buffer->i_date = (signed long int)0;
    buffer->p_next = (struct buffer_s *)(void *)0;
    buffer->p_data = (unsigned char *)((unsigned char *)buffer + (signed long int)sizeof(struct buffer_s) /*32ul*/ );
    return buffer;
  }
}

// check_sync_word
// file libdvbpsi.c line 2442
static signed long int check_sync_word(unsigned char *buf, signed long int length)
{
  signed long int i_lost = (signed long int)0;
  i_lost = (signed long int)0;
  for( ; !(i_lost >= length); i_lost = i_lost + 1l)
    if((signed int)buf[i_lost] == 0x47)
      break;

  if(!(length + -i_lost >= 188l))
    i_lost = length;

  return i_lost;
}

// dvbinfo_capture
// file dvbinfo.c line 285
static void * dvbinfo_capture(void *data)
{
  struct dvbinfo_capture_s *capture = (struct dvbinfo_capture_s *)data;
  const struct params_s *param = capture->params;
  _Bool b_eof = (_Bool)0;
  if(!(capture->b_alive == (_Bool)0))
  {
    if(b_eof == (_Bool)0)
    {
      struct buffer_s *buffer;
      signed long int return_value_fifo_count$1;
      return_value_fifo_count$1=fifo_count(capture->empty);
      if(return_value_fifo_count$1 == 0l)
        buffer=buffer_new(capture->size);

      else
        buffer=fifo_pop(capture->empty);
      if(!(buffer == ((struct buffer_s *)NULL)))
      {
        signed long int size;
        size=param->pf_read(param->fd_in, (void *)buffer->p_data, buffer->i_size);
        if(!(size >= 0l))
          fifo_push(capture->empty, buffer);

        else
          if(size == 0l)
          {
            fifo_push(capture->empty, buffer);
            b_eof = (_Bool)1;
          }

        buffer->i_date=mdate();
        unsigned long int return_value_fifo_size$2;
        return_value_fifo_size$2=fifo_size(capture->fifo);
        if(return_value_fifo_size$2 >= param->threshold)
        {
          pthread_mutex_lock(&capture->lock);
          capture->b_fifo_full = (_Bool)1;
          pthread_mutex_unlock(&capture->lock);
          if(!(param->b_file == (_Bool)0))
          {
            pthread_mutex_lock(&capture->lock);
            if(!(capture->b_fifo_full == (_Bool)0))
              pthread_cond_wait(&capture->fifo_full, &capture->lock);

            pthread_mutex_unlock(&capture->lock);
          }

          libdvbpsi_log((void *)capture->params, 0, "error fifo full discarding buffer\n");
          fifo_push(capture->empty, buffer);
        }

        else
        {
          fifo_push(capture->fifo, buffer);
          buffer = (struct buffer_s *)(void *)0;
        }
      }

    }

  }

  capture->b_alive = (_Bool)0;
  fifo_wake(capture->fifo);
  return (void *)0;
}

// dvbinfo_close
// file dvbinfo.c line 232
static void dvbinfo_close(struct params_s *param)
{
  _Bool tmp_if_expr$3;
  if(!(param->input == ((char *)NULL)))
    tmp_if_expr$3 = param->b_udp != (_Bool)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = param->fd_in >= 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$4 = (_Bool)0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$4)
    udp_close(param->fd_in);

  else
  {
    if(!(param->input == ((char *)NULL)))
      tmp_if_expr$1 = param->b_tcp != (_Bool)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = param->fd_in >= 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      tcp_close(param->fd_in);

    else
      if(!(param->input == ((char *)NULL)))
      {
        if(param->fd_in >= 0)
          close(param->fd_in);

      }

  }
  if(!(param->output == ((char *)NULL)))
  {
    if(param->fd_out >= 0)
      close(param->fd_out);

  }

}

// dvbinfo_open
// file dvbinfo.c line 247
static void dvbinfo_open(struct params_s *param)
{
  if(!(param->output == ((char *)NULL)))
  {
    param->fd_out=open(param->output, 0100 | 02 | 04000 | 0200 | 02000000, 0400 | 0200 | 0100);
    if(!(param->fd_out >= 0))
      goto error;

  }

  _Bool tmp_if_expr$2;
  if(!(param->input == ((char *)NULL)))
    tmp_if_expr$2 = param->b_udp != (_Bool)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$1;
  if(tmp_if_expr$2)
  {
    param->fd_in=udp_open(param->mcast_interface, param->input, param->port);
    if(!(param->fd_in >= 0))
      goto error;

  }

  else
  {
    if(!(param->input == ((char *)NULL)))
      tmp_if_expr$1 = param->b_tcp != (_Bool)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      param->fd_in=tcp_open(param->input, param->port);
      if(!(param->fd_in >= 0))
        goto error;

    }

    else
      if(!(param->input == ((char *)NULL)))
      {
        param->fd_in=open(param->input, 00 | 04000);
        if(!(param->fd_in >= 0))
          goto error;

      }

  }
  goto __CPROVER_DUMP_L10;

error:
  ;
  dvbinfo_close(param);
  params_free(param);
  exit(1);

__CPROVER_DUMP_L10:
  ;
}

// dvbinfo_process
// file dvbinfo.c line 352
static signed int dvbinfo_process(struct dvbinfo_capture_s *capture)
{
  signed int err = -1;
  _Bool b_error = (_Bool)0;
  struct params_s *param = capture->params;
  struct buffer_s *buffer = (struct buffer_s *)(void *)0;
  char *psz_temp = (char *)(void *)0;
  signed long int deadline = (signed long int)0;
  if(!(param->b_summary == (_Bool)0))
  {
    signed int return_value_asprintf$1;
    return_value_asprintf$1=asprintf(&psz_temp, "%s.part", param->summary.file);
    if(!(return_value_asprintf$1 >= 0))
    {
      libdvbpsi_log((void *)param, 0, "Could not create temporary summary file %s\n", param->summary.file);
      return err;
    }

    signed long int return_value_mdate$2;
    return_value_mdate$2=mdate();
    deadline = return_value_mdate$2 + param->summary.period;
  }

  struct ts_stream_t *stream;
  stream=libdvbpsi_init(param->debug, libdvbpsi_log, (void *)param);
  signed long int return_value_fifo_count$3;
  signed long int return_value_fifo_count$9;
  if(!(stream == ((struct ts_stream_t *)NULL)))
  {
    while(b_error == (_Bool)0)
    {
      if(capture->b_alive == (_Bool)0)
      {
        return_value_fifo_count$3=fifo_count(capture->fifo);
        if(return_value_fifo_count$3 == 0l)
          break;

      }

      buffer=fifo_pop(capture->fifo);
      if(!(buffer == ((struct buffer_s *)NULL)))
      {
        if(!(param->output == ((char *)NULL)))
        {
          signed long int size;
          size=param->pf_write(param->fd_out, (const void *)buffer->p_data, buffer->i_size);
          if(!(size >= 0l))
          {
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            libdvbpsi_log((void *)param, 0, "error (%d) writting to %s\n", *return_value___errno_location$4, param->output);
            break;
          }

          else
            if(!((unsigned long int)size >= buffer->i_size))
            {
              libdvbpsi_log((void *)param, 0, "error writting to %s (disk full?)\n", param->output);
              break;
            }

        }

        _Bool return_value_libdvbpsi_process$5;
        return_value_libdvbpsi_process$5=libdvbpsi_process(stream, buffer->p_data, (signed long int)buffer->i_size, buffer->i_date);
        if(return_value_libdvbpsi_process$5 == (_Bool)0)
          b_error = (_Bool)1;

        if(!(param->b_summary == (_Bool)0))
        {
          signed long int return_value_mdate$7;
          return_value_mdate$7=mdate();
          if(return_value_mdate$7 >= deadline)
          {
            struct _IO_FILE *fd;
            fd=fopen(psz_temp, "w+");
            if(!(fd == ((struct _IO_FILE *)NULL)))
            {
              libdvbpsi_summary(fd, stream, param->summary.mode);
              fflush(fd);
              fclose(fd);
              unlink(param->summary.file);
              signed int ret;
              ret=rename(psz_temp, param->summary.file);
              if(!(ret >= 0))
              {
                libdvbpsi_log((void *)param, 0, "failed renming summary file (disabling summary logging)\n");
                param->b_summary = (_Bool)0;
              }

            }

            else
            {
              libdvbpsi_log((void *)param, 0, "failed opening summary file (disabling summary logging)\n");
              param->b_summary = (_Bool)0;
            }
            signed long int return_value_mdate$6;
            return_value_mdate$6=mdate();
            deadline = return_value_mdate$6 + param->summary.period;
          }

        }

        fifo_push(capture->empty, buffer);
        buffer = (struct buffer_s *)(void *)0;
        unsigned long int return_value_fifo_size$8;
        return_value_fifo_size$8=fifo_size(capture->fifo);
        if(!(return_value_fifo_size$8 >= param->threshold))
        {
          pthread_mutex_lock(&capture->lock);
          capture->b_fifo_full = (_Bool)0;
          pthread_cond_signal(&capture->fifo_full);
          pthread_mutex_unlock(&capture->lock);
        }

      }

    }
    return_value_fifo_count$9=fifo_count(capture->fifo);
    /* assertion fifo_count(capture->fifo) == 0 */
    assert(return_value_fifo_count$9 == (signed long int)0);
    libdvbpsi_exit(stream);
    err = 0;
  }


out:
  ;
  if(!(b_error == (_Bool)0))
    libdvbpsi_log((void *)param, 0, "error while processing\n");

  if(!(buffer == ((struct buffer_s *)NULL)))
    buffer_free(buffer);

  free((void *)psz_temp);
  return err;
}

// dvbpsi_AddDescriptor
// file descriptor.c line 118
struct dvbpsi_descriptor_s * dvbpsi_AddDescriptor(struct dvbpsi_descriptor_s *p_list, struct dvbpsi_descriptor_s *p_descriptor)
{
  /* assertion p_descriptor */
  assert(p_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
  if(p_list == ((struct dvbpsi_descriptor_s *)NULL))
    p_list = p_descriptor;

  else
  {
    struct dvbpsi_descriptor_s *p_last = p_list;
    for( ; !(p_last->p_next == ((struct dvbpsi_descriptor_s *)NULL)); p_last = p_last->p_next)
      ;
    p_last->p_next = p_descriptor;
  }
  return p_list;
}

// dvbpsi_AddSectionBAT
// file tables/bat.c line 332
static _Bool dvbpsi_AddSectionBAT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_bat_decoder_s *p_bat_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_bat_decoder */
  assert(p_bat_decoder != ((struct dvbpsi_bat_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_bat_decoder->p_building_bat == ((struct dvbpsi_bat_s *)NULL))
  {
    p_bat_decoder->p_building_bat=dvbpsi_bat_new(p_section->i_table_id, p_section->i_extension, p_section->i_version, p_section->b_current_next);
    if(p_bat_decoder->p_building_bat == ((struct dvbpsi_bat_s *)NULL))
      return (_Bool)0;

    p_bat_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_bat_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"BAT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionCAT
// file tables/cat.c line 228
static _Bool dvbpsi_AddSectionCAT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_cat_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_cat_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_decoder->p_building_cat == ((struct dvbpsi_cat_s *)NULL))
  {
    p_decoder->p_building_cat=dvbpsi_cat_new(p_section->i_version, p_section->b_current_next);
    if(p_decoder->p_building_cat == ((struct dvbpsi_cat_s *)NULL))
      return (_Bool)0;

    p_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"CAT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionEIT
// file tables/eit.c line 381
static _Bool dvbpsi_AddSectionEIT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_eit_decoder_s *p_eit_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_eit_decoder */
  assert(p_eit_decoder != ((struct dvbpsi_eit_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_eit_decoder->p_building_eit == ((struct dvbpsi_eit_s *)NULL))
  {
    p_eit_decoder->p_building_eit=dvbpsi_eit_new(p_section->i_table_id, p_section->i_extension, p_section->i_version, p_section->b_current_next, (unsigned short int)((signed int)(unsigned short int)p_section->p_payload_start[(signed long int)0] << 8 | (signed int)p_section->p_payload_start[(signed long int)1]), (unsigned short int)((signed int)(unsigned short int)p_section->p_payload_start[(signed long int)2] << 8 | (signed int)p_section->p_payload_start[(signed long int)3]), p_section->p_payload_start[(signed long int)4], p_section->p_payload_start[(signed long int)5]);
    p_eit_decoder->i_last_section_number = p_section->i_last_number;
    p_eit_decoder->i_first_received_section_number = p_section->i_number;
    if(p_eit_decoder->p_building_eit == ((struct dvbpsi_eit_s *)NULL))
      return (_Bool)0;

    p_eit_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_eit_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"EIT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionEIT$link1
// file tables/atsc_eit.c line 347
static _Bool dvbpsi_AddSectionEIT$link1(struct dvbpsi_s *p_dvbpsi$link1, struct dvbpsi_atsc_eit_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section$link1)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi$link1 != ((struct dvbpsi_s *)NULL));
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_atsc_eit_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section$link1 != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_decoder->p_building_eit == ((struct dvbpsi_atsc_eit_s *)NULL))
  {
    p_decoder->p_building_eit=dvbpsi_atsc_NewEIT(p_section$link1->i_table_id, p_section$link1->i_extension, p_section$link1->i_version, p_section$link1->p_payload_start[(signed long int)0], p_section$link1->i_extension, p_section$link1->b_current_next);
    if(p_decoder->p_building_eit == ((struct dvbpsi_atsc_eit_s *)NULL))
      return (_Bool)0;

    p_decoder->i_last_section_number = p_section$link1->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1$link1;
  return_value_dvbpsi_decoder_psi_section_add$1$link1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_decoder, p_section$link1);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1$link1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi$link1, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"ATSC EIT decoder", p_section$link1->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionETT
// file tables/atsc_ett.c line 280
static _Bool dvbpsi_AddSectionETT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_ett_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_atsc_ett_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_decoder->p_building_ett == ((struct dvbpsi_atsc_ett_s *)NULL))
  {
    unsigned int i_etm_id = (unsigned int)p_section->p_payload_start[(signed long int)1] << 24 | (unsigned int)p_section->p_payload_start[(signed long int)2] << 16 | (unsigned int)p_section->p_payload_start[(signed long int)3] << 8 | (unsigned int)p_section->p_payload_start[(signed long int)4] << 0;
    p_decoder->p_building_ett=dvbpsi_atsc_NewETT(p_section->i_table_id, p_section->i_extension, p_section->i_version, p_section->p_payload_start[(signed long int)0], i_etm_id, p_section->b_current_next);
    if(p_decoder->p_building_ett == ((struct dvbpsi_atsc_ett_s *)NULL))
      return (_Bool)0;

    p_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"ATSC ETT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionMGT
// file tables/atsc_mgt.c line 372
static _Bool dvbpsi_AddSectionMGT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_mgt_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_atsc_mgt_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_decoder->p_building_mgt == ((struct dvbpsi_atsc_mgt_s *)NULL))
  {
    p_decoder->p_building_mgt=dvbpsi_atsc_NewMGT(p_section->i_table_id, p_section->i_extension, p_section->i_version, p_section->p_payload_start[(signed long int)0], p_section->b_current_next);
    if(p_decoder->p_building_mgt == ((struct dvbpsi_atsc_mgt_s *)NULL))
      return (_Bool)0;

    p_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"ATSC MGT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionNIT
// file tables/nit.c line 328
static _Bool dvbpsi_AddSectionNIT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_nit_decoder_s *p_nit_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_nit_decoder */
  assert(p_nit_decoder != ((struct dvbpsi_nit_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_nit_decoder->p_building_nit == ((struct dvbpsi_nit_s *)NULL))
  {
    p_nit_decoder->p_building_nit=dvbpsi_nit_new(p_section->i_table_id, p_section->i_extension, p_nit_decoder->i_network_id, p_section->i_version, p_section->b_current_next);
    if(p_nit_decoder->p_building_nit == ((struct dvbpsi_nit_s *)NULL))
      return (_Bool)0;

    p_nit_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_nit_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"NIT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionPAT
// file tables/pat.c line 244
static _Bool dvbpsi_AddSectionPAT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_pat_decoder_s *p_pat_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_pat_decoder */
  assert(p_pat_decoder != ((struct dvbpsi_pat_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_pat_decoder->p_building_pat == ((struct dvbpsi_pat_s *)NULL))
  {
    p_pat_decoder->p_building_pat=dvbpsi_pat_new(p_section->i_extension, p_section->i_version, p_section->b_current_next);
    if(p_pat_decoder->p_building_pat == ((struct dvbpsi_pat_s *)NULL))
      return (_Bool)0;

    p_pat_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_pat_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"PAT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionPMT
// file tables/pmt.c line 289
static _Bool dvbpsi_AddSectionPMT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_pmt_decoder_s *p_pmt_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_pmt_decoder */
  assert(p_pmt_decoder != ((struct dvbpsi_pmt_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_pmt_decoder->p_building_pmt == ((struct dvbpsi_pmt_s *)NULL))
  {
    p_pmt_decoder->p_building_pmt=dvbpsi_pmt_new(p_pmt_decoder->i_program_number, p_section->i_version, p_section->b_current_next, (unsigned short int)((signed int)(unsigned short int)((signed int)p_section->p_payload_start[(signed long int)0] & 0x1f) << 8 | (signed int)p_section->p_payload_start[(signed long int)1]));
    if(p_pmt_decoder->p_building_pmt == ((struct dvbpsi_pmt_s *)NULL))
      return (_Bool)0;

    p_pmt_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_pmt_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"PMT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionSDT
// file tables/sdt.c line 315
static _Bool dvbpsi_AddSectionSDT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sdt_decoder_s *p_sdt_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_sdt_decoder */
  assert(p_sdt_decoder != ((struct dvbpsi_sdt_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_sdt_decoder->p_building_sdt == ((struct dvbpsi_sdt_s *)NULL))
  {
    p_sdt_decoder->p_building_sdt=dvbpsi_sdt_new(p_section->i_table_id, p_section->i_extension, p_section->i_version, p_section->b_current_next, (unsigned short int)((signed int)(unsigned short int)p_section->p_payload_start[(signed long int)0] << 8 | (signed int)p_section->p_payload_start[(signed long int)1]));
    if(p_sdt_decoder->p_building_sdt == ((struct dvbpsi_sdt_s *)NULL))
      return (_Bool)0;

    p_sdt_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_sdt_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"SDT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionSIS
// file tables/sis.c line 300
static _Bool dvbpsi_AddSectionSIS(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sis_decoder_s *p_sis_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_sis_decoder */
  assert(p_sis_decoder != ((struct dvbpsi_sis_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_sis_decoder->p_building_sis == ((struct dvbpsi_sis_s *)NULL))
  {
    p_sis_decoder->p_building_sis=dvbpsi_sis_new(p_section->i_table_id, p_section->i_extension, p_section->i_version, p_section->b_current_next, (unsigned char)0);
    if(p_sis_decoder->p_building_sis == ((struct dvbpsi_sis_s *)NULL))
      return (_Bool)0;

    p_sis_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_sis_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"SDT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionSTT
// file tables/atsc_stt.c line 279
static _Bool dvbpsi_AddSectionSTT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_stt_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_atsc_stt_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_decoder->p_building_stt == ((struct dvbpsi_atsc_stt_s *)NULL))
  {
    p_decoder->p_building_stt=dvbpsi_atsc_NewSTT(p_section->i_table_id, p_section->i_extension, p_section->i_version, p_section->b_current_next);
    if(p_decoder->p_building_stt == ((struct dvbpsi_atsc_stt_s *)NULL))
      return (_Bool)0;

    p_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"ATSC STT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionTOT
// file tables/tot.c line 273
static _Bool dvbpsi_AddSectionTOT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_tot_decoder_s *p_tot_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_tot_decoder */
  assert(p_tot_decoder != ((struct dvbpsi_tot_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_tot_decoder->p_building_tot == ((struct dvbpsi_tot_s *)NULL))
  {
    p_tot_decoder->p_building_tot=dvbpsi_tot_new(p_section->i_table_id, p_section->i_extension, p_section->i_version, p_section->b_current_next, (unsigned long int)p_section->p_payload_start[(signed long int)0] << 32 | (unsigned long int)p_section->p_payload_start[(signed long int)1] << 24 | (unsigned long int)p_section->p_payload_start[(signed long int)2] << 16 | (unsigned long int)p_section->p_payload_start[(signed long int)3] << 8 | (unsigned long int)p_section->p_payload_start[(signed long int)4]);
    if(p_tot_decoder->p_building_tot == ((struct dvbpsi_tot_s *)NULL))
      return (_Bool)0;

    p_tot_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_tot_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"TOT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AddSectionVCT
// file tables/atsc_vct.c line 412
static _Bool dvbpsi_AddSectionVCT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_vct_decoder_s *p_vct_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_vct_decoder */
  assert(p_vct_decoder != ((struct dvbpsi_atsc_vct_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_vct_decoder->p_building_vct == ((struct dvbpsi_atsc_vct_s *)NULL))
  {
    p_vct_decoder->p_building_vct=dvbpsi_atsc_NewVCT(p_section->i_table_id, p_section->i_extension, p_section->p_payload_start[(signed long int)0], (signed int)p_section->i_table_id == 0xC9, p_section->i_version, p_section->b_current_next);
    if(p_vct_decoder->p_building_vct == ((struct dvbpsi_atsc_vct_s *)NULL))
      return (_Bool)0;

    p_vct_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_vct_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"ATSC VCT decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_AttachDemux
// file ../../src/demux.h line 142
_Bool dvbpsi_AttachDemux(struct dvbpsi_s *p_dvbpsi, void (*pf_new_cb)(struct dvbpsi_s *, unsigned char, unsigned short int, void *), void *p_new_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder == ((void *)0) */
  assert(p_dvbpsi->p_decoder == (struct dvbpsi_decoder_s *)(void *)0);
  struct dvbpsi_demux_s *p_demux;
  void *return_value_dvbpsi_decoder_new$1;
  return_value_dvbpsi_decoder_new$1=dvbpsi_decoder_new(dvbpsi_Demux, 4096, (const _Bool)1, sizeof(struct dvbpsi_demux_s) /*64ul*/ );
  p_demux = (struct dvbpsi_demux_s *)return_value_dvbpsi_decoder_new$1;
  if(p_demux == ((struct dvbpsi_demux_s *)NULL))
    return (_Bool)0;

  else
  {
    p_demux->p_first_subdec = (struct dvbpsi_demux_subdec_s *)(void *)0;
    p_demux->pf_new_callback = pf_new_cb;
    p_demux->p_new_cb_data = p_new_cb_data;
    p_dvbpsi->p_decoder = (struct dvbpsi_decoder_s *)p_demux;
    return (_Bool)1;
  }
}

// dvbpsi_AttachDemuxSubDecoder
// file demux.c line 203
void dvbpsi_AttachDemuxSubDecoder(struct dvbpsi_demux_s *p_demux, struct dvbpsi_demux_subdec_s *p_subdec)
{
  /* assertion p_demux */
  assert(p_demux != ((struct dvbpsi_demux_s *)NULL));
  /* assertion p_subdec */
  assert(p_subdec != ((struct dvbpsi_demux_subdec_s *)NULL));
  if(p_demux == ((struct dvbpsi_demux_s *)NULL) || p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    abort();

  p_subdec->p_next = p_demux->p_first_subdec;
  p_demux->p_first_subdec = p_subdec;
}

// dvbpsi_Bcd8ToUint32
// file descriptors/dr_62.c line 90
unsigned int dvbpsi_Bcd8ToUint32(unsigned int bcd)
{
  unsigned int i_decoded = (bcd >> 28 & (unsigned int)0xf) * (unsigned int)10000000;
  i_decoded = i_decoded + (bcd >> 24 & (unsigned int)0xf) * (unsigned int)1000000;
  i_decoded = i_decoded + (bcd >> 20 & (unsigned int)0xf) * (unsigned int)100000;
  i_decoded = i_decoded + (bcd >> 16 & (unsigned int)0xf) * (unsigned int)10000;
  i_decoded = i_decoded + (bcd >> 12 & (unsigned int)0xf) * (unsigned int)1000;
  i_decoded = i_decoded + (bcd >> 8 & (unsigned int)0xf) * (unsigned int)100;
  i_decoded = i_decoded + (bcd >> 4 & (unsigned int)0xf) * (unsigned int)10;
  i_decoded = i_decoded + (bcd >> 0 & (unsigned int)0xf) * (unsigned int)1;
  return i_decoded;
}

// dvbpsi_BuildPSISection
// file psi.c line 276
void dvbpsi_BuildPSISection(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section)
{
  p_section->p_data[(signed long int)0] = p_section->i_table_id;
  p_section->p_data[(signed long int)1] = (unsigned char)((p_section->b_syntax_indicator != (_Bool)0 ? 0x80 : 0x00) | (p_section->b_private_indicator != (_Bool)0 ? 0x40 : 0x00) | 0x30 | (signed int)p_section->i_length >> 8 & 0x0f);
  p_section->p_data[(signed long int)2] = (unsigned char)((signed int)p_section->i_length & 0xff);
  if(!(p_section->b_syntax_indicator == (_Bool)0))
  {
    p_section->p_data[(signed long int)3] = (unsigned char)((signed int)p_section->i_extension >> 8 & 0xff);
    p_section->p_data[(signed long int)4] = (unsigned char)((signed int)p_section->i_extension & 0xff);
    p_section->p_data[(signed long int)5] = (unsigned char)(0xc0 | ((signed int)p_section->i_version & 0x1f) << 1 | (p_section->b_current_next != (_Bool)0 ? 0x01 : 0x00));
    p_section->p_data[(signed long int)6] = p_section->i_number;
    p_section->p_data[(signed long int)7] = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_has_CRC32$2;
  return_value_dvbpsi_has_CRC32$2=dvbpsi_has_CRC32$link1(p_section);
  if(!(return_value_dvbpsi_has_CRC32$2 == (_Bool)0))
  {
    dvbpsi_CalculateCRC32(p_section);
    _Bool return_value_dvbpsi_ValidPSISection$1;
    return_value_dvbpsi_ValidPSISection$1=dvbpsi_ValidPSISection(p_section);
    if(return_value_dvbpsi_ValidPSISection$1 == (_Bool)0)
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): ********************************************", (const void *)"misc PSI");
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): * Generated PSI section has a bad CRC_32.  *", (const void *)"misc PSI");
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): * THIS IS A BUG, PLEASE REPORT TO THE LIST *", (const void *)"misc PSI");
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): *  ---  libdvbpsi-devel@videolan.org  ---  *", (const void *)"misc PSI");
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): ********************************************", (const void *)"misc PSI");
    }

  }

}

// dvbpsi_CalculateCRC32
// file psi.c line 253
void dvbpsi_CalculateCRC32(struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte = p_section->p_data;
  p_section->i_crc = 0xffffffff;
  for( ; !(p_byte >= p_section->p_payload_end); p_byte = p_byte + 1l)
    p_section->i_crc = p_section->i_crc << 8 ^ dvbpsi_crc32_table[(signed long int)(p_section->i_crc >> 24 ^ (unsigned int)*p_byte)];
  p_section->p_payload_end[(signed long int)0] = (unsigned char)(p_section->i_crc >> 24 & (unsigned int)0xff);
  p_section->p_payload_end[(signed long int)1] = (unsigned char)(p_section->i_crc >> 16 & (unsigned int)0xff);
  p_section->p_payload_end[(signed long int)2] = (unsigned char)(p_section->i_crc >> 8 & (unsigned int)0xff);
  p_section->p_payload_end[(signed long int)3] = (unsigned char)(p_section->i_crc & (unsigned int)0xff);
}

// dvbpsi_CanDecodeAsDescriptor
// file descriptor.c line 69
_Bool dvbpsi_CanDecodeAsDescriptor(struct dvbpsi_descriptor_s *p_descriptor, const unsigned char i_tag)
{
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (_Bool)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptor$1;
    return_value_dvbpsi_IsDescriptor$1=dvbpsi_IsDescriptor(p_descriptor, i_tag);
    if(return_value_dvbpsi_IsDescriptor$1 == (_Bool)0)
      return (_Bool)0;

    else
      return (_Bool)1;
  }
}

// dvbpsi_CheckBAT
// file tables/bat.c line 298
static _Bool dvbpsi_CheckBAT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_bat_decoder_s *p_bat_decoder, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_reinit = (_Bool)0;
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_bat_decoder */
  assert(p_bat_decoder != ((struct dvbpsi_bat_decoder_s *)NULL));
  if(!(p_bat_decoder->p_building_bat->i_extension == p_section->i_extension))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'bouquet_id' differs whereas no TS discontinuity has occured", (const void *)"BAT decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_bat_decoder->p_building_bat->i_version == p_section->i_version))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"BAT decoder");
      b_reinit = (_Bool)1;
    }

    else
      if(!(p_bat_decoder->i_last_section_number == p_section->i_last_number))
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"BAT decoder");
        b_reinit = (_Bool)1;
      }

  return b_reinit;
}

// dvbpsi_CheckCAT
// file tables/cat.c line 188
static _Bool dvbpsi_CheckCAT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_reinit = (_Bool)0;
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_cat_decoder_s *p_cat_decoder = (struct dvbpsi_cat_decoder_s *)p_dvbpsi->p_decoder;
  if(!(p_cat_decoder->p_building_cat->i_version == p_section->i_version))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"CAT decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_cat_decoder->i_last_section_number == p_section->i_last_number))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"CAT decoder");
      b_reinit = (_Bool)1;
    }

  return b_reinit;
}

// dvbpsi_CheckEIT
// file tables/eit.c line 294
static _Bool dvbpsi_CheckEIT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_eit_decoder_s *p_eit_decoder, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_reinit = (_Bool)0;
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_eit_decoder */
  assert(p_eit_decoder != ((struct dvbpsi_eit_decoder_s *)NULL));
  if(!(p_eit_decoder->p_building_eit->i_extension == p_section->i_extension))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'service_id' differs whereas no TS discontinuity has occurred", (const void *)"EIT decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_eit_decoder->p_building_eit->i_version == p_section->i_version))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occurred", (const void *)"EIT decoder");
      b_reinit = (_Bool)1;
    }

    else
      if(!(p_eit_decoder->i_last_section_number == p_section->i_last_number))
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"EIT decoder");
        b_reinit = (_Bool)1;
      }

  return b_reinit;
}

// dvbpsi_CheckEIT$link1
// file tables/atsc_eit.c line 311
static _Bool dvbpsi_CheckEIT$link1(struct dvbpsi_s *p_dvbpsi$link1, struct dvbpsi_atsc_eit_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section$link1)
{
  _Bool b_reinit$link1 = (_Bool)0;
  /* assertion p_dvbpsi */
  assert(p_dvbpsi$link1 != ((struct dvbpsi_s *)NULL));
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_atsc_eit_decoder_s *)NULL));
  if(!(p_decoder->p_building_eit->i_source_id == p_section$link1->i_extension))
  {
    dvbpsi_message$link1(p_dvbpsi$link1, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'transport_stream_id' differs whereas no TS discontinuity has occured", (const void *)"ATSC EIT decoder");
    b_reinit$link1 = (_Bool)1;
  }

  else
    if(!(p_decoder->p_building_eit->i_version == p_section$link1->i_version))
    {
      dvbpsi_message$link1(p_dvbpsi$link1, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"ATSC EIT decoder");
      b_reinit$link1 = (_Bool)1;
    }

    else
      if(!(p_decoder->i_last_section_number == p_section$link1->i_last_number))
      {
        dvbpsi_message$link1(p_dvbpsi$link1, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"ATSC EIT decoder");
        b_reinit$link1 = (_Bool)1;
      }

  return b_reinit$link1;
}

// dvbpsi_CheckETT
// file tables/atsc_ett.c line 244
static _Bool dvbpsi_CheckETT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_ett_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_reinit = (_Bool)0;
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_atsc_ett_decoder_s *)NULL));
  if(!((signed int)p_decoder->p_building_ett->i_protocol == (signed int)p_section->i_extension))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'protocol version' differs whereas no TS discontinuity has occured", (const void *)"ATSC ETT decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_decoder->p_building_ett->i_version == p_section->i_version))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"ATSC ETT decoder");
      b_reinit = (_Bool)1;
    }

    else
      if(!(p_decoder->i_last_section_number == p_section->i_last_number))
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"ATSC ETT decoder");
        b_reinit = (_Bool)1;
      }

  return b_reinit;
}

// dvbpsi_CheckMGT
// file tables/atsc_mgt.c line 336
static _Bool dvbpsi_CheckMGT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_mgt_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_reinit = (_Bool)0;
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_atsc_mgt_decoder_s *)NULL));
  if(!(p_decoder->p_building_mgt->i_table_id_ext == p_section->i_extension))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'transport_stream_id' differs whereas no TS discontinuity has occured", (const void *)"ATSC MGT decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_decoder->p_building_mgt->i_version == p_section->i_version))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"ATSC MGT decoder");
      b_reinit = (_Bool)1;
    }

    else
      if(!(p_decoder->i_last_section_number == p_section->i_last_number))
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"ATSC MGT decoder");
        b_reinit = (_Bool)1;
      }

  return b_reinit;
}

// dvbpsi_CheckNIT
// file tables/nit.c line 299
static _Bool dvbpsi_CheckNIT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_nit_decoder_s *p_nit_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_nit_decoder */
  assert(p_nit_decoder != ((struct dvbpsi_nit_decoder_s *)NULL));
  _Bool b_reinit = (_Bool)0;
  if(!(p_nit_decoder->p_building_nit->i_version == p_section->i_version))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"NIT decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_nit_decoder->i_last_section_number == p_section->i_last_number))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"NIT decoder");
      b_reinit = (_Bool)1;
    }

  return b_reinit;
}

// dvbpsi_CheckPAT
// file tables/pat.c line 207
static _Bool dvbpsi_CheckPAT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_reinit = (_Bool)0;
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_pat_decoder_s *p_pat_decoder = (struct dvbpsi_pat_decoder_s *)p_dvbpsi->p_decoder;
  if(!(p_pat_decoder->p_building_pat->i_ts_id == p_section->i_extension))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'transport_stream_id' differs whereas no TS discontinuity has occured", (const void *)"PAT decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_pat_decoder->p_building_pat->i_version == p_section->i_version))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"PAT decoder");
      b_reinit = (_Bool)1;
    }

    else
      if(!(p_pat_decoder->i_last_section_number == p_section->i_last_number))
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"PAT decoder");
        b_reinit = (_Bool)1;
      }

  return b_reinit;
}

// dvbpsi_CheckPMT
// file tables/pmt.c line 261
static _Bool dvbpsi_CheckPMT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_reinit = (_Bool)0;
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_pmt_decoder_s *p_pmt_decoder = (struct dvbpsi_pmt_decoder_s *)p_dvbpsi->p_decoder;
  if(!(p_pmt_decoder->p_building_pmt->i_version == p_section->i_version))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"PMT decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_pmt_decoder->i_last_section_number == p_section->i_last_number))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"PMT decoder");
      b_reinit = (_Bool)1;
    }

  return b_reinit;
}

// dvbpsi_CheckPSISection
// file psi.c line 193
_Bool dvbpsi_CheckPSISection(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section, const unsigned char table_id, const char *psz_table_name)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(!(p_section->i_table_id == table_id))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring section (table_id == 0x%02x expected 0x%02x)", psz_table_name, p_section->i_table_id, table_id);
    return (_Bool)0;
  }

  else
    if(p_section->b_syntax_indicator == (_Bool)0)
    {
      if((signed int)table_id == 0x70 || (signed int)table_id == 0x73)
        goto __CPROVER_DUMP_L2;

      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): invalid section (section_syntax_indicator == 0)", psz_table_name);
      return (_Bool)0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): Table version %2d, i_extension %5d, section %3d up to %3d, current %1d", psz_table_name, p_section->i_version, p_section->i_extension, p_section->i_number, p_section->i_last_number, p_section->b_current_next);
      return (_Bool)1;
    }
}

// dvbpsi_CheckSDT
// file tables/sdt.c line 280
static _Bool dvbpsi_CheckSDT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sdt_decoder_s *p_sdt_decoder, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_reinit = (_Bool)0;
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_sdt_decoder */
  assert(p_sdt_decoder != ((struct dvbpsi_sdt_decoder_s *)NULL));
  if(!(p_sdt_decoder->p_building_sdt->i_extension == p_section->i_extension))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'transport_stream_id' differs whereas no TS discontinuity has occured", (const void *)"SDT decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_sdt_decoder->p_building_sdt->i_version == p_section->i_version))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"SDT decoder");
      b_reinit = (_Bool)1;
    }

    else
      if(!(p_sdt_decoder->i_last_section_number == p_section->i_last_number))
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"SDT decoder");
        b_reinit = (_Bool)1;
      }

  return b_reinit;
}

// dvbpsi_CheckSIS
// file tables/sis.c line 259
static _Bool dvbpsi_CheckSIS(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sis_decoder_s *p_sis_decoder, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_reinit = (_Bool)0;
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_sis_decoder */
  assert(p_sis_decoder != ((struct dvbpsi_sis_decoder_s *)NULL));
  if(!((signed int)p_sis_decoder->p_building_sis->i_protocol_version == 0))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'protocol_version' differs while no discontinuity has occured", (const void *)"SIS decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_sis_decoder->p_building_sis->i_extension == p_section->i_extension))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'transport_stream_id' differs whereas no discontinuity has occured", (const void *)"SIS decoder");
      b_reinit = (_Bool)1;
    }

    else
      if(!(p_sis_decoder->p_building_sis->i_version == p_section->i_version))
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"SIS decoder");
        b_reinit = (_Bool)1;
      }

      else
        if(!(p_sis_decoder->i_last_section_number == p_section->i_last_number))
        {
          dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"SIS decoder");
          b_reinit = (_Bool)1;
        }

  return b_reinit;
}

// dvbpsi_CheckSTT
// file tables/atsc_stt.c line 251
static _Bool dvbpsi_CheckSTT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_stt_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_reinit = (_Bool)0;
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_atsc_stt_decoder_s *)NULL));
  if(!(p_decoder->p_building_stt->i_version == p_section->i_version))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"ATSC STT decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_decoder->i_last_section_number == p_section->i_last_number))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"ATSC STT decoder");
      b_reinit = (_Bool)1;
    }

  return b_reinit;
}

// dvbpsi_CheckTOT
// file tables/tot.c line 238
static _Bool dvbpsi_CheckTOT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_tot_decoder_s *p_tot_decoder, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_reinit = (_Bool)0;
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_tot_decoder */
  assert(p_tot_decoder != ((struct dvbpsi_tot_decoder_s *)NULL));
  if(!(p_tot_decoder->p_building_tot->i_extension == p_section->i_extension))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'transport_stream_id' differs whereas no TS discontinuity has occured", (const void *)"TDT/TOT decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_tot_decoder->p_building_tot->i_version == p_section->i_version))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"TDT/TOT decoder");
      b_reinit = (_Bool)1;
    }

    else
      if(!(p_tot_decoder->i_last_section_number == p_section->i_last_number))
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"TDT/TOT decoder");
        b_reinit = (_Bool)1;
      }

  return b_reinit;
}

// dvbpsi_CheckVCT
// file tables/atsc_vct.c line 376
static _Bool dvbpsi_CheckVCT(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_atsc_vct_decoder_s *p_vct_decoder, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_reinit = (_Bool)0;
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_vct_decoder */
  assert(p_vct_decoder != ((struct dvbpsi_atsc_vct_decoder_s *)NULL));
  if(!(p_vct_decoder->p_building_vct->i_extension == p_section->i_extension))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'transport_stream_id' differs whereas no TS discontinuity has occured", (const void *)"ATSC VCT decoder");
    b_reinit = (_Bool)1;
  }

  else
    if(!(p_vct_decoder->p_building_vct->i_version == p_section->i_version))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'version_number' differs whereas no discontinuity has occured", (const void *)"ATSC VCT decoder");
      b_reinit = (_Bool)1;
    }

    else
      if(!(p_vct_decoder->i_last_section_number == p_section->i_last_number))
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'last_section_number' differs whereas no discontinuity has occured", (const void *)"ATSC VCT decoder");
        b_reinit = (_Bool)1;
      }

  return b_reinit;
}

// dvbpsi_DecodeAACDr
// file ../../src/descriptors/dr_7c.h line 124
struct dvbpsi_aac_dr_s * dvbpsi_DecodeAACDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x7c);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_aac_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_aac_dr_s *)p_descriptor->p_decoded;

    else
      if((signed int)p_descriptor->i_length == 0x01)
        return (struct dvbpsi_aac_dr_s *)(void *)0;

      else
      {
        struct dvbpsi_aac_dr_s *p_decoded;
        void *return_value_calloc$3;
        return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct dvbpsi_aac_dr_s) /*24ul*/ );
        p_decoded = (struct dvbpsi_aac_dr_s *)return_value_calloc$3;
        if(p_decoded == ((struct dvbpsi_aac_dr_s *)NULL))
          return (struct dvbpsi_aac_dr_s *)(void *)0;

        else
        {
          p_decoded->i_profile_and_level=dvbpsi_aac_profile_and_level_lookup(p_descriptor->p_data[(signed long int)0]);
          if((signed int)p_descriptor->i_length >= 2)
            p_decoded->b_type = (signed int)p_descriptor->p_data[(signed long int)1] >> 7 == 0x01;

          if(!(p_decoded->b_type == (_Bool)0))
            p_decoded->i_type=dvbpsi_aac_type_lookup(p_descriptor->p_data[(signed long int)2]);

          if((signed int)p_descriptor->i_length >= 2)
          {
            unsigned char i_info_length = (unsigned char)((signed int)p_descriptor->i_length - (p_decoded->b_type != (_Bool)0 ? 3 : 2));
            struct dvbpsi_aac_dr_s *p_tmp;
            void *return_value_realloc$4;
            return_value_realloc$4=realloc((void *)p_decoded, sizeof(struct dvbpsi_aac_dr_s) /*24ul*/  + (unsigned long int)i_info_length);
            p_tmp = (struct dvbpsi_aac_dr_s *)return_value_realloc$4;
            if(p_tmp == ((struct dvbpsi_aac_dr_s *)NULL))
            {
              free((void *)p_decoded);
              return (struct dvbpsi_aac_dr_s *)(void *)0;
            }

            p_decoded->p_additional_info = (unsigned char *)p_tmp + (signed long int)sizeof(struct dvbpsi_aac_dr_s) /*24ul*/ ;
            p_decoded->i_additional_info_length = i_info_length;
            unsigned char i_data = (unsigned char)(p_decoded->b_type != (_Bool)0 ? 3 : 2);
            unsigned char *p = &p_descriptor->p_data[(signed long int)i_data];
            memcpy((void *)p_decoded->p_additional_info, (const void *)p, (unsigned long int)i_info_length);
          }

          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeAStreamDr
// file descriptors/dr_03.c line 47
struct dvbpsi_astream_dr_s * dvbpsi_DecodeAStreamDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_astream_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x03);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_astream_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_astream_dr_s *)p_descriptor->p_decoded;

    else
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct dvbpsi_astream_dr_s) /*4ul*/ );
      p_decoded = (struct dvbpsi_astream_dr_s *)return_value_malloc$3;
      if(p_decoded == ((struct dvbpsi_astream_dr_s *)NULL))
        return (struct dvbpsi_astream_dr_s *)(void *)0;

      else
        if(!((signed int)p_descriptor->i_length == 1))
        {
          free((void *)p_decoded);
          return (struct dvbpsi_astream_dr_s *)(void *)0;
        }

        else
        {
          p_decoded->b_free_format = (_Bool)(((signed int)p_descriptor->p_data[(signed long int)0] & 0x80) != 0 ? 1 : 0);
          p_decoded->i_id = (unsigned char)(((signed int)p_descriptor->p_data[(signed long int)0] & 0x40) >> 6);
          p_decoded->i_layer = (unsigned char)(((signed int)p_descriptor->p_data[(signed long int)0] & 0x30) >> 4);
          p_decoded->b_variable_rate_audio_indicator = (_Bool)(((signed int)p_descriptor->p_data[(signed long int)0] & 0x08) >> 3 != 0 ? 1 : 0);
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
    }
  }
}

// dvbpsi_DecodeAc3AudioDr
// file descriptors/dr_81.c line 45
struct dvbpsi_ac3_audio_dr_s * dvbpsi_DecodeAc3AudioDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_ac3_audio_dr_s *p_decoded;
  unsigned char *buf = p_descriptor->p_data;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x81);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_ac3_audio_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_ac3_audio_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 3))
        return (struct dvbpsi_ac3_audio_dr_s *)(void *)0;

      else
      {
        void *return_value_calloc$3;
        return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct dvbpsi_ac3_audio_dr_s) /*168ul*/ );
        p_decoded = (struct dvbpsi_ac3_audio_dr_s *)return_value_calloc$3;
        if(p_decoded == ((struct dvbpsi_ac3_audio_dr_s *)NULL))
          return (struct dvbpsi_ac3_audio_dr_s *)(void *)0;

        else
        {
          p_descriptor->p_decoded = (void *)p_decoded;
          p_decoded->i_sample_rate_code = (unsigned char)(0x07 & (signed int)buf[(signed long int)0] >> 5);
          p_decoded->i_bsid = (unsigned char)(0x1f & (signed int)buf[(signed long int)0]);
          p_decoded->i_bit_rate_code = (unsigned char)(0x3f & (signed int)buf[(signed long int)1] >> 2);
          p_decoded->i_surround_mode = (unsigned char)(0x03 & (signed int)buf[(signed long int)1]);
          p_decoded->i_bsmod = (unsigned char)(0x07 & (signed int)buf[(signed long int)2] >> 5);
          p_decoded->i_num_channels = (unsigned char)(0x0f & (signed int)buf[(signed long int)2] >> 1);
          p_decoded->b_full_svc = 0x01 & (signed int)buf[(signed long int)2];
          buf = buf + (signed long int)3;
          if(buf == p_descriptor->p_data + (signed long int)p_descriptor->i_length)
            return p_decoded;

          else
          {
            p_decoded->i_lang_code = buf[(signed long int)0];
            buf = buf + 1l;
            if(buf == p_descriptor->p_data + (signed long int)p_descriptor->i_length)
              return p_decoded;

            else
            {
              if(p_decoded->i_num_channels == 0)
              {
                p_decoded->i_lang_code2 = buf[(signed long int)0];
                buf = buf + 1l;
              }

              if(buf == p_descriptor->p_data + (signed long int)p_descriptor->i_length)
                return p_decoded;

              else
              {
                if(!((signed int)p_decoded->i_bsmod >= 2))
                {
                  p_decoded->i_mainid = (unsigned char)(0x07 & (signed int)buf[(signed long int)0] >> 5);
                  p_decoded->i_priority = (unsigned char)(0x03 & (signed int)buf[(signed long int)0] >> 3);
                }

                else
                  p_decoded->i_asvcflags = buf[(signed long int)0];
                buf = buf + 1l;
                if(buf == p_descriptor->p_data + (signed long int)p_descriptor->i_length)
                  return p_decoded;

                else
                {
                  p_decoded->i_textlen = (unsigned char)(0x7f & (signed int)buf[(signed long int)0] >> 1);
                  p_decoded->b_text_code = 0X01 & (signed int)buf[(signed long int)0];
                  buf = buf + 1l;
                  memset((void *)p_decoded->text, 0, sizeof(unsigned char [128l]) /*128ul*/ );
                  memcpy((void *)p_decoded->text, (const void *)buf, (unsigned long int)p_decoded->i_textlen);
                  buf = buf + (signed long int)p_decoded->i_textlen;
                  if(buf == p_descriptor->p_data + (signed long int)p_descriptor->i_length)
                    return p_decoded;

                  else
                  {
                    p_decoded->b_language_flag = 0x01 & (signed int)buf[(signed long int)0] >> 7;
                    p_decoded->b_language_flag_2 = 0x01 & (signed int)buf[(signed long int)0] >> 6;
                    buf = buf + 1l;
                    if(!(p_decoded->b_language_flag == 0))
                    {
                      memcpy((void *)p_decoded->language, (const void *)buf, (unsigned long int)3);
                      buf = buf + (signed long int)3;
                    }

                    if(!(p_decoded->b_language_flag_2 == 0))
                    {
                      memcpy((void *)p_decoded->language_2, (const void *)buf, (unsigned long int)3);
                      buf = buf + (signed long int)3;
                    }

                    return p_decoded;
                  }
                }
              }
            }
          }
        }
      }
  }
}

// dvbpsi_DecodeAssociationTagDr
// file descriptors/dr_14.c line 65
struct dvbpsi_association_tag_dr_s * dvbpsi_DecodeAssociationTagDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_association_tag_dr_s *p_decoded;
  unsigned char selector_len;
  unsigned char private_data_len;
  if(!((signed int)p_descriptor->i_tag == 0x14))
    return (struct dvbpsi_association_tag_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_association_tag_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 5))
        return (struct dvbpsi_association_tag_dr_s *)(void *)0;

      else
      {
        selector_len = p_descriptor->p_data[(signed long int)4];
        private_data_len = (unsigned char)((signed int)p_descriptor->i_length - (5 + (signed int)selector_len));
        if(!((signed int)p_descriptor->i_length >= 5 + (signed int)selector_len))
          return (struct dvbpsi_association_tag_dr_s *)(void *)0;

        else
        {
          p_decoded=NewAssociationTagDr((const unsigned long int)selector_len, (const unsigned long int)private_data_len);
          if(p_decoded == ((struct dvbpsi_association_tag_dr_s *)NULL))
            return (struct dvbpsi_association_tag_dr_s *)(void *)0;

          else
          {
            p_decoded->i_tag = (unsigned short int)(((signed int)p_descriptor->p_data[(signed long int)0] & 0xff) << 8 | (signed int)p_descriptor->p_data[(signed long int)1] & 0xff);
            p_decoded->i_use = (unsigned short int)(((signed int)p_descriptor->p_data[(signed long int)2] & 0xff) << 8 | (signed int)p_descriptor->p_data[(signed long int)3] & 0xff);
            memcpy((void *)p_decoded->p_selector, (const void *)&p_descriptor->p_data[(signed long int)5], (unsigned long int)selector_len);
            memcpy((void *)p_decoded->p_private_data, (const void *)&p_descriptor->p_data[(signed long int)(5 + (signed int)selector_len)], (unsigned long int)private_data_len);
            p_descriptor->p_decoded = (void *)p_decoded;
            return p_decoded;
          }
        }
      }
}

// dvbpsi_DecodeBouquetNameDr
// file descriptors/dr_47.c line 48
struct dvbpsi_bouquet_name_dr_s * dvbpsi_DecodeBouquetNameDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_bouquet_name_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x47);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_bouquet_name_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_bouquet_name_dr_s *)p_descriptor->p_decoded;

    else
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct dvbpsi_bouquet_name_dr_s) /*256ul*/ );
      p_decoded = (struct dvbpsi_bouquet_name_dr_s *)return_value_malloc$3;
      if(p_decoded == ((struct dvbpsi_bouquet_name_dr_s *)NULL))
        return (struct dvbpsi_bouquet_name_dr_s *)(void *)0;

      else
      {
        p_decoded->i_name_length = p_descriptor->i_length;
        if(!(p_decoded->i_name_length == 0))
          memcpy((void *)p_decoded->i_char, (const void *)p_descriptor->p_data, (unsigned long int)p_decoded->i_name_length);

        p_descriptor->p_decoded = (void *)p_decoded;
        return p_decoded;
      }
    }
  }
}

// dvbpsi_DecodeCADr
// file descriptors/dr_09.c line 47
struct dvbpsi_ca_dr_s * dvbpsi_DecodeCADr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_ca_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x09);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_ca_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_ca_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 4))
        return (struct dvbpsi_ca_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_ca_dr_s) /*256ul*/ );
        p_decoded = (struct dvbpsi_ca_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_ca_dr_s *)NULL))
          return (struct dvbpsi_ca_dr_s *)(void *)0;

        else
        {
          p_decoded->i_ca_system_id = (unsigned short int)((signed int)(unsigned short int)p_descriptor->p_data[(signed long int)0] << 8 | (signed int)p_descriptor->p_data[(signed long int)1]);
          p_decoded->i_ca_pid = (unsigned short int)((signed int)(unsigned short int)((signed int)p_descriptor->p_data[(signed long int)2] & 0x1f) << 8 | (signed int)p_descriptor->p_data[(signed long int)3]);
          p_decoded->i_private_length = (unsigned char)((signed int)p_descriptor->i_length - 4);
          if((signed int)p_decoded->i_private_length >= 252)
            p_decoded->i_private_length = (unsigned char)251;

          if(!(p_decoded->i_private_length == 0))
            memcpy((void *)p_decoded->i_private_data, (const void *)(p_descriptor->p_data + (signed long int)4), (unsigned long int)p_decoded->i_private_length);

          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeCAIdentifierDr
// file ../../src/descriptors/dr_53.h line 100
struct dvbpsi_ca_identifier_dr_s * dvbpsi_DecodeCAIdentifierDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_ca_identifier_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x53);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_ca_identifier_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_ca_identifier_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 1))
        return (struct dvbpsi_ca_identifier_dr_s *)(void *)0;

      else
      {
        void *return_value_calloc$3;
        return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct dvbpsi_ca_identifier_dr_s) /*256ul*/ );
        p_decoded = (struct dvbpsi_ca_identifier_dr_s *)return_value_calloc$3;
        if(p_decoded == ((struct dvbpsi_ca_identifier_dr_s *)NULL))
          return (struct dvbpsi_ca_identifier_dr_s *)(void *)0;

        else
        {
          signed int i_number = (signed int)p_descriptor->i_length / 2;
          if(i_number >= 128)
            i_number = 127;

          p_decoded->i_number = (unsigned char)i_number;
          signed int i = 0;
          for( ; !(i >= i_number); i = i + 1)
            p_decoded->p_system[(signed long int)i].i_ca_system_id = (unsigned short int)p_descriptor->p_data[(signed long int)(2 * i)];
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeCUEIDr
// file ../../src/descriptors/dr_8a.h line 71
struct dvbpsi_cuei_dr_s * dvbpsi_DecodeCUEIDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x8a);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_cuei_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_cuei_dr_s *)p_descriptor->p_decoded;

    else
      if((signed int)p_descriptor->i_length == 0x01)
        return (struct dvbpsi_cuei_dr_s *)(void *)0;

      else
      {
        struct dvbpsi_cuei_dr_s *p_decoded;
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_cuei_dr_s) /*1ul*/ );
        p_decoded = (struct dvbpsi_cuei_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_cuei_dr_s *)NULL))
          return (struct dvbpsi_cuei_dr_s *)(void *)0;

        else
        {
          p_decoded->i_cue_stream_type = p_descriptor->p_data[(signed long int)0];
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeCableDelivSysDr
// file descriptors/dr_44.c line 47
struct dvbpsi_cable_deliv_sys_dr_s * dvbpsi_DecodeCableDelivSysDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_cable_deliv_sys_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x44);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_cable_deliv_sys_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_cable_deliv_sys_dr_s *)p_descriptor->p_decoded;

    else
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct dvbpsi_cable_deliv_sys_dr_s) /*16ul*/ );
      p_decoded = (struct dvbpsi_cable_deliv_sys_dr_s *)return_value_malloc$3;
      if(p_decoded == ((struct dvbpsi_cable_deliv_sys_dr_s *)NULL))
        return (struct dvbpsi_cable_deliv_sys_dr_s *)(void *)0;

      else
      {
        p_decoded->i_frequency = (unsigned int)((signed int)p_descriptor->p_data[(signed long int)0] << 24) | (unsigned int)((signed int)p_descriptor->p_data[(signed long int)1] << 16) | (unsigned int)((signed int)p_descriptor->p_data[(signed long int)2] << 8) | (unsigned int)p_descriptor->p_data[(signed long int)3];
        p_decoded->i_fec_outer = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)5] & 0x0f);
        p_decoded->i_modulation = (unsigned char)p_descriptor->p_data[(signed long int)6];
        p_decoded->i_symbol_rate = (unsigned int)((signed int)p_descriptor->p_data[(signed long int)7] << 20) | (unsigned int)((signed int)p_descriptor->p_data[(signed long int)8] << 12) | (unsigned int)((signed int)p_descriptor->p_data[(signed long int)9] << 4) | (unsigned int)(((signed int)p_descriptor->p_data[(signed long int)10] & 0xf0) >> 4);
        p_decoded->i_fec_inner = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)10] & 0x0f);
        p_descriptor->p_decoded = (void *)p_decoded;
        return p_decoded;
      }
    }
  }
}

// dvbpsi_DecodeCaptionServiceDr
// file descriptors/dr_86.c line 45
struct dvbpsi_caption_service_dr_s * dvbpsi_DecodeCaptionServiceDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_caption_service_dr_s *p_decoded;
  unsigned char *buf = p_descriptor->p_data;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x86);
  signed int tmp_if_expr$4;
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_caption_service_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_caption_service_dr_s *)p_descriptor->p_decoded;

    else
      if(!(((signed int)p_descriptor->i_length + -1) % 6 == 0))
        return (struct dvbpsi_caption_service_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_caption_service_dr_s) /*748ul*/ );
        p_decoded = (struct dvbpsi_caption_service_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_caption_service_dr_s *)NULL))
          return (struct dvbpsi_caption_service_dr_s *)(void *)0;

        else
        {
          p_descriptor->p_decoded = (void *)p_decoded;
          p_decoded->i_number_of_services = (unsigned char)(0x1f & (signed int)buf[(signed long int)0]);
          buf = buf + 1l;
          signed int i = 0;
          for( ; !(i >= (signed int)p_decoded->i_number_of_services); i = i + 1)
          {
            struct dvbpsi_caption_service_s *p_service = &p_decoded->services[(signed long int)i];
            memcpy((void *)p_service->i_iso_639_code, (const void *)buf, (unsigned long int)3);
            buf = buf + (signed long int)3;
            p_service->b_digital_cc = 0x01 & (signed int)buf[(signed long int)0] >> 7;
            p_service->b_line21_field = 0x01 & (signed int)buf[(signed long int)0];
            if(!(p_service->b_digital_cc == 0))
              tmp_if_expr$4 = 0x3F & (signed int)buf[(signed long int)0];

            else
              tmp_if_expr$4 = 0;
            p_service->i_caption_service_number = (unsigned short int)tmp_if_expr$4;
            buf = buf + 1l;
            p_service->b_easy_reader = 0x01 & (signed int)buf[(signed long int)0] >> 7;
            p_service->b_wide_aspect_ratio = 0x01 & (signed int)buf[(signed long int)0] >> 6;
            buf = buf + (signed long int)2;
          }
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeCarouselIdDr
// file descriptors/dr_13.c line 60
struct dvbpsi_carousel_id_dr_s * dvbpsi_DecodeCarouselIdDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_carousel_id_dr_s *p_decoded;
  if(!((signed int)p_descriptor->i_tag == 0x13))
    return (struct dvbpsi_carousel_id_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_carousel_id_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 4))
        return (struct dvbpsi_carousel_id_dr_s *)(void *)0;

      else
      {
        p_decoded=NewCarouselDr((const unsigned long int)((signed int)p_descriptor->i_length - 4));
        if(p_decoded == ((struct dvbpsi_carousel_id_dr_s *)NULL))
          return (struct dvbpsi_carousel_id_dr_s *)(void *)0;

        else
        {
          p_decoded->i_carousel_id = (unsigned int)(((signed int)p_descriptor->p_data[(signed long int)0] & 0xff) << 24 | ((signed int)p_descriptor->p_data[(signed long int)1] & 0xff) << 16 | ((signed int)p_descriptor->p_data[(signed long int)2] & 0xff) << 8 | (signed int)p_descriptor->p_data[(signed long int)3] & 0xff);
          memcpy((void *)p_decoded->p_private_data, (const void *)&p_descriptor->p_data[(signed long int)4], (unsigned long int)p_decoded->i_private_data_len);
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
}

// dvbpsi_DecodeComponentDr
// file descriptors/dr_50.c line 45
struct dvbpsi_component_dr_t * dvbpsi_DecodeComponentDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  if(!((signed int)p_descriptor->i_tag == 0x50))
    return (struct dvbpsi_component_dr_t *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_component_dr_t *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 6))
        return (struct dvbpsi_component_dr_t *)(void *)0;

      else
      {
        struct dvbpsi_component_dr_t *p_decoded;
        void *return_value_calloc$1;
        return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct dvbpsi_component_dr_t) /*24ul*/ );
        p_decoded = (struct dvbpsi_component_dr_t *)return_value_calloc$1;
        if(p_decoded == ((struct dvbpsi_component_dr_t *)NULL))
          return (struct dvbpsi_component_dr_t *)(void *)0;

        else
        {
          p_decoded->i_stream_content = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)0] & 0x0F);
          p_decoded->i_component_type = p_descriptor->p_data[(signed long int)1];
          p_decoded->i_component_tag = p_descriptor->p_data[(signed long int)2];
          memcpy((void *)&p_decoded->i_iso_639_code[(signed long int)0], (const void *)&p_descriptor->p_data[(signed long int)3], (unsigned long int)3);
          if((signed int)p_descriptor->i_length >= 7)
          {
            p_decoded->i_text_length = (signed int)p_descriptor->i_length - 6;
            void *return_value_calloc$2;
            return_value_calloc$2=calloc((unsigned long int)1, (unsigned long int)p_decoded->i_text_length);
            p_decoded->i_text = (unsigned char *)return_value_calloc$2;
            if(p_decoded->i_text == ((unsigned char *)NULL))
            {
              free((void *)p_decoded);
              return (struct dvbpsi_component_dr_t *)(void *)0;
            }

            memcpy((void *)p_decoded->i_text, (const void *)&p_descriptor->p_data[(signed long int)6], (unsigned long int)p_decoded->i_text_length);
          }

          else
          {
            p_decoded->i_text_length = 0;
            p_decoded->i_text = (unsigned char *)(void *)0;
          }
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
}

// dvbpsi_DecodeContentDr
// file ../../src/descriptors/dr_54.h line 234
struct dvbpsi_content_dr_s * dvbpsi_DecodeContentDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x54);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_content_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_content_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length % 2 == 0))
        return (struct dvbpsi_content_dr_s *)(void *)0;

      else
      {
        struct dvbpsi_content_dr_s *p_decoded;
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_content_dr_s) /*129ul*/ );
        p_decoded = (struct dvbpsi_content_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_content_dr_s *)NULL))
          return (struct dvbpsi_content_dr_s *)(void *)0;

        else
        {
          signed int i_contents_number = (signed int)p_descriptor->i_length / 2;
          if(i_contents_number >= 65)
            i_contents_number = 64;

          p_decoded->i_contents_number = (unsigned char)i_contents_number;
          signed int i = 0;
          for( ; !(i >= i_contents_number); i = i + 1)
          {
            p_decoded->p_content[(signed long int)i].i_type = p_descriptor->p_data[(signed long int)(2 * i)];
            p_decoded->p_content[(signed long int)i].i_user_byte = p_descriptor->p_data[(signed long int)(2 * i + 1)];
          }
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeContentIdDr
// file descriptors/dr_76.c line 45
struct dvbpsi_content_id_dr_s * dvbpsi_DecodeContentIdDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_content_id_dr_s *p_decoded;
  signed int byte;
  _Bool tmp_if_expr$2;
  if(!((signed int)p_descriptor->i_tag == 0x76))
    return (struct dvbpsi_content_id_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_content_id_dr_s *)p_descriptor->p_decoded;

    else
    {
      if((unsigned long int)p_descriptor->i_length >= 86ul)
        p_descriptor->i_length = (unsigned char)(sizeof(struct dvbpsi_crid_entry_s [85l]) /*43180ul*/  / sizeof(struct dvbpsi_crid_entry_s) /*508ul*/ );

      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct dvbpsi_content_id_dr_s) /*43434ul*/ );
      p_decoded = (struct dvbpsi_content_id_dr_s *)return_value_malloc$1;
      if(p_decoded == ((struct dvbpsi_content_id_dr_s *)NULL))
        return (struct dvbpsi_content_id_dr_s *)(void *)0;

      else
      {
        p_decoded->i_number_of_entries = (unsigned char)0;
        byte = 0;
        do
        {
          if(!(byte >= (signed int)p_descriptor->i_length))
            tmp_if_expr$2 = (signed int)p_decoded->i_number_of_entries < 85 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$2 = (_Bool)0;
          if(!tmp_if_expr$2)
            break;

          struct dvbpsi_crid_entry_s *entry = &p_decoded->p_entries[(signed long int)p_decoded->i_number_of_entries];
          entry->i_type = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)byte] >> 2 & 0x3f);
          entry->i_location = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)byte] & 3);
          byte = byte + 1;
          if((signed int)entry->i_location == 0)
          {
            unsigned char len = p_descriptor->p_data[(signed long int)byte];
            if((signed int)len >= 254)
              len = (unsigned char)253;

            unsigned int i;
            byte = byte + 1;
            i = (unsigned int)0;
            for( ; !(i >= (unsigned int)len); i = i + 1u)
              entry->value.path[(signed long int)i] = p_descriptor->p_data[(signed long int)((unsigned int)byte + i)];
            byte = byte + (signed int)len;
            unsigned int last = i < (unsigned int)len ? i : (unsigned int)len - 1U;
            entry->value.path[(signed long int)last] = (unsigned char)0;
          }

          else
            if((signed int)entry->i_location == 1)
            {
              entry->value.ref = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)byte] << 8 | (signed int)p_descriptor->p_data[(signed long int)(byte + 1)]);
              byte = byte + 2;
            }

            else
            {
              free((void *)p_decoded);
              return (struct dvbpsi_content_id_dr_s *)(void *)0;
            }
          p_decoded->i_number_of_entries = p_decoded->i_number_of_entries + 1;
        }
        while((_Bool)1);
        p_descriptor->p_decoded = (void *)p_decoded;
        return p_decoded;
      }
    }
}

// dvbpsi_DecodeCopyrightDr
// file descriptors/dr_0d.c line 47
struct dvbpsi_copyright_dr_s * dvbpsi_DecodeCopyrightDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_copyright_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x0d);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_copyright_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_copyright_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 4))
        return (struct dvbpsi_copyright_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_copyright_dr_s) /*256ul*/ );
        p_decoded = (struct dvbpsi_copyright_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_copyright_dr_s *)NULL))
          return (struct dvbpsi_copyright_dr_s *)(void *)0;

        else
        {
          p_decoded->i_copyright_identifier = (unsigned int)p_descriptor->p_data[(signed long int)0] << 24 | (unsigned int)p_descriptor->p_data[(signed long int)1] << 16 | (unsigned int)p_descriptor->p_data[(signed long int)2] << 8 | (unsigned int)p_descriptor->p_data[(signed long int)3];
          p_decoded->i_additional_length = (unsigned char)((signed int)p_descriptor->i_length - 4);
          if((signed int)p_decoded->i_additional_length >= 252)
            p_decoded->i_additional_length = (unsigned char)251;

          if(!(p_decoded->i_additional_length == 0))
            memcpy((void *)p_decoded->i_additional_info, (const void *)(p_descriptor->p_data + (signed long int)4), (unsigned long int)p_decoded->i_additional_length);

          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeCountryAvailability
// file descriptors/dr_49.c line 45
struct dvbpsi_country_availability_dr_s * dvbpsi_DecodeCountryAvailability(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_country_availability_dr_s *p_decoded;
  _Bool tmp_if_expr$1;
  if(!((signed int)p_descriptor->i_tag == 0x49))
    return (struct dvbpsi_country_availability_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_country_availability_dr_s *)p_descriptor->p_decoded;

    else
    {
      unsigned int code_count = (unsigned int)(((signed int)p_descriptor->i_length - 1) / 3);
      if(!((signed int)p_descriptor->i_length >= 1))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = ((signed int)p_descriptor->i_length - 1) % 3 != 0 ? (_Bool)1 : (_Bool)0;
      if(code_count >= 84u || tmp_if_expr$1)
        return (struct dvbpsi_country_availability_dr_s *)(void *)0;

      else
      {
        void *return_value_calloc$2;
        return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct dvbpsi_country_availability_dr_s) /*254ul*/ );
        p_decoded = (struct dvbpsi_country_availability_dr_s *)return_value_calloc$2;
        if(p_decoded == ((struct dvbpsi_country_availability_dr_s *)NULL))
          return (struct dvbpsi_country_availability_dr_s *)(void *)0;

        else
        {
          p_decoded->i_code_count = (unsigned char)code_count;
          p_decoded->b_country_availability_flag = (_Bool)((signed int)p_descriptor->p_data[(signed long int)0] & 0x80);
          unsigned char i = (unsigned char)0;
          for( ; !((signed int)i >= (signed int)p_decoded->i_code_count); i = i + 1)
          {
            p_decoded->code[(signed long int)i].iso_639_code[(signed long int)0] = p_descriptor->p_data[(signed long int)(1 + (signed int)i * 3)];
            p_decoded->code[(signed long int)i].iso_639_code[(signed long int)1] = p_descriptor->p_data[(signed long int)(2 + (signed int)i * 3)];
            p_decoded->code[(signed long int)i].iso_639_code[(signed long int)2] = p_descriptor->p_data[(signed long int)(3 + (signed int)i * 3)];
          }
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
    }
}

// dvbpsi_DecodeDSAlignmentDr
// file descriptors/dr_06.c line 47
struct dvbpsi_ds_alignment_dr_s * dvbpsi_DecodeDSAlignmentDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_ds_alignment_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x06);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_ds_alignment_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_ds_alignment_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 1))
        return (struct dvbpsi_ds_alignment_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_ds_alignment_dr_s) /*1ul*/ );
        p_decoded = (struct dvbpsi_ds_alignment_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_ds_alignment_dr_s *)NULL))
          return (struct dvbpsi_ds_alignment_dr_s *)(void *)0;

        else
        {
          p_decoded->i_alignment_type = p_descriptor->p_data[(signed long int)0];
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeDataBroadcastIdDr
// file descriptors/dr_66.c line 62
struct dvbpsi_data_broadcast_id_dr_s * dvbpsi_DecodeDataBroadcastIdDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_data_broadcast_id_dr_s *p_decoded;
  if(!((signed int)p_descriptor->i_tag == 0x66))
    return (struct dvbpsi_data_broadcast_id_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_data_broadcast_id_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 2))
        return (struct dvbpsi_data_broadcast_id_dr_s *)(void *)0;

      else
      {
        p_decoded=NewDataBroadcastDr((const unsigned long int)((signed int)p_descriptor->i_length - 2));
        if(p_decoded == ((struct dvbpsi_data_broadcast_id_dr_s *)NULL))
          return (struct dvbpsi_data_broadcast_id_dr_s *)(void *)0;

        else
        {
          p_decoded->i_data_broadcast_id = (unsigned short int)(((signed int)p_descriptor->p_data[(signed long int)0] & 0xff) << 8 | (signed int)p_descriptor->p_data[(signed long int)1] & 0xff);
          memcpy((void *)p_decoded->p_id_selector, (const void *)&p_descriptor->p_data[(signed long int)2], (unsigned long int)p_decoded->i_id_selector_len);
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
}

// dvbpsi_DecodeDefaultAuthorityDr
// file descriptors/dr_73.c line 45
struct dvbpsi_default_authority_dr_s * dvbpsi_DecodeDefaultAuthorityDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_default_authority_dr_s *p_decoded;
  if(!((signed int)p_descriptor->i_tag == 0x73))
    return (struct dvbpsi_default_authority_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_default_authority_dr_s *)p_descriptor->p_decoded;

    else
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct dvbpsi_default_authority_dr_s) /*255ul*/ );
      p_decoded = (struct dvbpsi_default_authority_dr_s *)return_value_malloc$1;
      if(p_decoded == ((struct dvbpsi_default_authority_dr_s *)NULL))
        return (struct dvbpsi_default_authority_dr_s *)(void *)0;

      else
      {
        memcpy((void *)&p_decoded->authority, (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
        p_decoded->authority[(signed long int)p_descriptor->i_length] = (unsigned char)0;
        p_descriptor->p_decoded = (void *)p_decoded;
        return p_decoded;
      }
    }
}

// dvbpsi_DecodeExtendedEventDr
// file descriptors/dr_4e.c line 46
struct dvbpsi_extended_event_dr_s * dvbpsi_DecodeExtendedEventDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_extended_event_dr_s *p_decoded;
  signed int i_len;
  signed int i_pos;
  unsigned char *p;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x4e);
  _Bool tmp_if_expr$2;
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)p_descriptor->i_length < 6 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return (struct dvbpsi_extended_event_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$3;
    return_value_dvbpsi_IsDescriptorDecoded$3=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$3 == (_Bool)0))
      return (struct dvbpsi_extended_event_dr_s *)p_descriptor->p_decoded;

    else
    {
      void *return_value_malloc$4;
      return_value_malloc$4=malloc(sizeof(struct dvbpsi_extended_event_dr_s) /*2560ul*/ );
      p_decoded = (struct dvbpsi_extended_event_dr_s *)return_value_malloc$4;
      if(p_decoded == ((struct dvbpsi_extended_event_dr_s *)NULL))
        return (struct dvbpsi_extended_event_dr_s *)(void *)0;

      else
      {
        p_decoded->i_descriptor_number = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)0] >> 4 & 0xf);
        p_decoded->i_last_descriptor_number = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)0] & 0x0f);
        memcpy((void *)&p_decoded->i_iso_639_code[(signed long int)0], (const void *)&p_descriptor->p_data[(signed long int)1], (unsigned long int)3);
        p_decoded->i_entry_count = 0;
        i_len = (signed int)p_descriptor->p_data[(signed long int)4];
        i_pos = 0;
        p = &p_descriptor->p_data[(signed long int)5];
        while(!(p >= p_descriptor->p_data + (signed long int)(5 + i_len)))
        {
          signed int idx = p_decoded->i_entry_count;
          p_decoded->i_item_description_length[(signed long int)idx] = p[(signed long int)0];
          p_decoded->i_item_description[(signed long int)idx] = &p_decoded->i_buffer[(signed long int)i_pos];
          memcpy((void *)&p_decoded->i_buffer[(signed long int)i_pos], (const void *)&p[(signed long int)1], (unsigned long int)p[(signed long int)0]);
          i_pos = i_pos + (signed int)p[(signed long int)0];
          p = p + (signed long int)(1 + (signed int)p[(signed long int)0]);
          p_decoded->i_item_length[(signed long int)idx] = p[(signed long int)0];
          p_decoded->i_item[(signed long int)idx] = &p_decoded->i_buffer[(signed long int)i_pos];
          memcpy((void *)&p_decoded->i_buffer[(signed long int)i_pos], (const void *)&p[(signed long int)1], (unsigned long int)p[(signed long int)0]);
          i_pos = i_pos + (signed int)p[(signed long int)0];
          p = p + (signed long int)(1 + (signed int)p[(signed long int)0]);
          p_decoded->i_entry_count = p_decoded->i_entry_count + 1;
        }
        p_decoded->i_text_length = (signed int)p_descriptor->p_data[(signed long int)(5 + i_len)];
        if(p_decoded->i_text_length >= 1)
          memcpy((void *)&p_decoded->i_buffer[(signed long int)i_pos], (const void *)&p_descriptor->p_data[(signed long int)(5 + i_len + 1)], (unsigned long int)p_decoded->i_text_length);

        p_decoded->i_text = &p_decoded->i_buffer[(signed long int)i_pos];
        p_descriptor->p_decoded = (void *)p_decoded;
        return p_decoded;
      }
    }
  }
}

// dvbpsi_DecodeFrequencyListDr
// file descriptors/dr_62.c line 45
struct dvbpsi_frequency_list_dr_s * dvbpsi_DecodeFrequencyListDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_frequency_list_dr_s *p_decoded;
  signed int i;
  _Bool tmp_if_expr$2;
  if(!((signed int)p_descriptor->i_tag == 0x62))
    return (struct dvbpsi_frequency_list_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_frequency_list_dr_s *)p_descriptor->p_decoded;

    else
      if(!(((signed int)p_descriptor->i_length + -1) % 4 == 0))
        return (struct dvbpsi_frequency_list_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(sizeof(struct dvbpsi_frequency_list_dr_s) /*256ul*/ );
        p_decoded = (struct dvbpsi_frequency_list_dr_s *)return_value_malloc$1;
        if(p_decoded == ((struct dvbpsi_frequency_list_dr_s *)NULL))
          return (struct dvbpsi_frequency_list_dr_s *)(void *)0;

        else
        {
          p_decoded->i_number_of_frequencies = (unsigned char)(((signed int)p_descriptor->i_length - 1) / 4);
          if((unsigned long int)p_decoded->i_number_of_frequencies >= 64ul)
            p_decoded->i_number_of_frequencies = (unsigned char)(sizeof(unsigned int [63l]) /*252ul*/  / sizeof(unsigned int) /*4ul*/ );

          p_decoded->i_coding_type = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)0] & 0x3);
          i = 0;
          for( ; !(i >= (signed int)p_decoded->i_number_of_frequencies); i = i + 1)
          {
            p_decoded->p_center_frequencies[(signed long int)i] = (unsigned int)((signed int)p_descriptor->p_data[(signed long int)(i * 4 + 1)] << 24 | (signed int)p_descriptor->p_data[(signed long int)(i * 4 + 2)] << 16 | (signed int)p_descriptor->p_data[(signed long int)(i * 4 + 3)] << 8 | (signed int)p_descriptor->p_data[(signed long int)(i * 4 + 4)]);
            if((signed int)p_decoded->i_coding_type == 1)
              tmp_if_expr$2 = (_Bool)1;

            else
              tmp_if_expr$2 = (signed int)p_decoded->i_coding_type == 2 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$2)
              p_decoded->p_center_frequencies[(signed long int)i]=dvbpsi_Bcd8ToUint32(p_decoded->p_center_frequencies[(signed long int)i]);

          }
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
}

// dvbpsi_DecodeHierarchyDr
// file descriptors/dr_04.c line 47
struct dvbpsi_hierarchy_dr_s * dvbpsi_DecodeHierarchyDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_hierarchy_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x04);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_hierarchy_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_hierarchy_dr_s *)p_descriptor->p_decoded;

    else
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct dvbpsi_hierarchy_dr_s) /*4ul*/ );
      p_decoded = (struct dvbpsi_hierarchy_dr_s *)return_value_malloc$3;
      if(p_decoded == ((struct dvbpsi_hierarchy_dr_s *)NULL))
        return (struct dvbpsi_hierarchy_dr_s *)(void *)0;

      else
        if(!((signed int)p_descriptor->i_length == 4))
        {
          free((void *)p_decoded);
          return (struct dvbpsi_hierarchy_dr_s *)(void *)0;
        }

        else
        {
          p_decoded->i_h_type = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)0] & 0x0f);
          p_decoded->i_h_layer_index = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)1] & 0x3f);
          p_decoded->i_h_embedded_layer = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)2] & 0x3f);
          p_decoded->i_h_priority = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)3] & 0x3f);
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
    }
  }
}

// dvbpsi_DecodeIBPDr
// file ../../src/descriptors/dr_12.h line 62
struct dvbpsi_ibp_dr_s * dvbpsi_DecodeIBPDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_ibp_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x12);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_ibp_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_ibp_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 2))
        return (struct dvbpsi_ibp_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_ibp_dr_s) /*4ul*/ );
        p_decoded = (struct dvbpsi_ibp_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_ibp_dr_s *)NULL))
          return (struct dvbpsi_ibp_dr_s *)(void *)0;

        else
        {
          p_decoded->b_closed_gop_flag = (_Bool)((signed int)p_descriptor->p_data[(signed long int)0] & 0x80);
          p_decoded->b_identical_gop_flag = (_Bool)((signed int)p_descriptor->p_data[(signed long int)0] & 0x40);
          p_decoded->i_max_gop_length = (unsigned short int)(((signed int)(unsigned short int)p_descriptor->p_data[(signed long int)0] & 0x3f) << 8 | (signed int)p_descriptor->p_data[(signed long int)1]);
          if((signed int)p_decoded->i_max_gop_length == 0)
          {
            free((void *)p_decoded);
            return (struct dvbpsi_ibp_dr_s *)(void *)0;
          }

          else
          {
            p_descriptor->p_decoded = (void *)p_decoded;
            return p_decoded;
          }
        }
      }
  }
}

// dvbpsi_DecodeISO639Dr
// file descriptors/dr_0a.c line 47
struct dvbpsi_iso639_dr_s * dvbpsi_DecodeISO639Dr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_iso639_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x0a);
  _Bool tmp_if_expr$3;
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_iso639_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_iso639_dr_s *)p_descriptor->p_decoded;

    else
    {
      if(!((signed int)p_descriptor->i_length >= 1))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)p_descriptor->i_length % 4 != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        return (struct dvbpsi_iso639_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$4;
        return_value_malloc$4=malloc(sizeof(struct dvbpsi_iso639_dr_s) /*257ul*/ );
        p_decoded = (struct dvbpsi_iso639_dr_s *)return_value_malloc$4;
        if(p_decoded == ((struct dvbpsi_iso639_dr_s *)NULL))
          return (struct dvbpsi_iso639_dr_s *)(void *)0;

        else
        {
          p_decoded->i_code_count = (unsigned char)((signed int)p_descriptor->i_length / 4);
          if((signed int)p_decoded->i_code_count >= 65)
            p_decoded->i_code_count = (unsigned char)64;

          signed int i = 0;
          for( ; !(i >= (signed int)p_decoded->i_code_count); i = i + 1)
          {
            p_decoded->code[(signed long int)i].iso_639_code[(signed long int)0] = p_descriptor->p_data[(signed long int)(i * 4)];
            p_decoded->code[(signed long int)i].iso_639_code[(signed long int)1] = p_descriptor->p_data[(signed long int)(i * 4 + 1)];
            p_decoded->code[(signed long int)i].iso_639_code[(signed long int)2] = p_descriptor->p_data[(signed long int)(i * 4 + 2)];
            p_decoded->code[(signed long int)i].i_audio_type = p_descriptor->p_data[(signed long int)(i * 4 + 3)];
          }
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
    }
  }
}

// dvbpsi_DecodeLCNDr
// file descriptors/dr_83.c line 45
struct dvbpsi_lcn_dr_s * dvbpsi_DecodeLCNDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_lcn_dr_s *p_decoded;
  signed int i;
  if(!((signed int)p_descriptor->i_tag == 0x83))
    return (struct dvbpsi_lcn_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_lcn_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length % 4 == 0))
        return (struct dvbpsi_lcn_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(sizeof(struct dvbpsi_lcn_dr_s) /*772ul*/ );
        p_decoded = (struct dvbpsi_lcn_dr_s *)return_value_malloc$1;
        if(p_decoded == ((struct dvbpsi_lcn_dr_s *)NULL))
          return (struct dvbpsi_lcn_dr_s *)(void *)0;

        else
        {
          p_decoded->i_number_of_entries = (unsigned char)((signed int)p_descriptor->i_length / 4);
          if((unsigned long int)p_decoded->i_number_of_entries >= 65ul)
            p_decoded->i_number_of_entries = (unsigned char)(sizeof(struct dvbpsi_lcn_entry_s [64l]) /*768ul*/  / sizeof(struct dvbpsi_lcn_entry_s) /*12ul*/ );

          i = 0;
          for( ; !(i >= (signed int)p_decoded->i_number_of_entries); i = i + 1)
          {
            p_decoded->p_entries[(signed long int)i].i_service_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)(i * 4)] << 8 | (signed int)p_descriptor->p_data[(signed long int)(i * 4 + 1)]);
            p_decoded->p_entries[(signed long int)i].b_visible_service_flag = (signed int)p_descriptor->p_data[(signed long int)(i * 4 + 2)] >> 7 & 1;
            p_decoded->p_entries[(signed long int)i].i_logical_channel_number = (unsigned short int)(((signed int)p_descriptor->p_data[(signed long int)(i * 4 + 2)] << 8 | (signed int)p_descriptor->p_data[(signed long int)(i * 4 + 3)]) & 0x3ff);
          }
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
}

// dvbpsi_DecodeLinkageDr
// file descriptors/dr_4a.c line 45
struct dvbpsi_linkage_dr_s * dvbpsi_DecodeLinkageDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(!((signed int)p_descriptor->i_tag == 0x4A))
    return (struct dvbpsi_linkage_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_linkage_dr_s *)p_descriptor->p_decoded;

    else
    {
      signed int handover_type = 0;
      signed int origin_type = 0;
      if((signed int)p_descriptor->p_data[6l] == 0x08)
      {
        handover_type = (signed int)p_descriptor->p_data[(signed long int)7] & 0xF0 >> 4;
        origin_type = (signed int)p_descriptor->p_data[(signed long int)7] & 0x01;
        if(origin_type == 0 && handover_type >= 1 && !(handover_type >= 4))
          tmp_if_expr$1 = (signed int)p_descriptor->i_length > 243 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          if(origin_type == 1 && handover_type >= 1 && !(handover_type >= 4))
            tmp_if_expr$2 = (signed int)p_descriptor->i_length > 245 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$2 = (_Bool)0;
          tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$3)
          goto __CPROVER_DUMP_L9;

        return (struct dvbpsi_linkage_dr_s *)(void *)0;
      }

      else
      {

      __CPROVER_DUMP_L9:
        ;
        if((signed int)p_descriptor->p_data[6l] == 0x0D)
        {
          if(!((signed int)p_descriptor->i_length >= 246))
            goto __CPROVER_DUMP_L10;

          return (struct dvbpsi_linkage_dr_s *)(void *)0;
        }

        else
        {

        __CPROVER_DUMP_L10:
          ;
          if(!((signed int)p_descriptor->p_data[6l] == 0x08))
          {
            if((signed int)p_descriptor->p_data[6l] == 0x0D)
              goto __CPROVER_DUMP_L11;

            if(!((signed int)p_descriptor->i_length >= 249))
              goto __CPROVER_DUMP_L11;

            return (struct dvbpsi_linkage_dr_s *)(void *)0;
          }

          else
          {

          __CPROVER_DUMP_L11:
            ;
            struct dvbpsi_linkage_dr_s *p_decoded;
            void *return_value_calloc$4;
            return_value_calloc$4=calloc((unsigned long int)1, sizeof(struct dvbpsi_linkage_dr_s) /*268ul*/ );
            p_decoded = (struct dvbpsi_linkage_dr_s *)return_value_calloc$4;
            if(p_decoded == ((struct dvbpsi_linkage_dr_s *)NULL))
              return (struct dvbpsi_linkage_dr_s *)(void *)0;

            else
            {
              signed int i = 7;
              p_decoded->i_transport_stream_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)0] << 8 | (signed int)p_descriptor->p_data[(signed long int)1]);
              p_decoded->i_original_network_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)2] << 8 | (signed int)p_descriptor->p_data[(signed long int)3]);
              p_decoded->i_service_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)4] << 8 | (signed int)p_descriptor->p_data[(signed long int)5]);
              p_decoded->i_linkage_type = p_descriptor->p_data[(signed long int)6];
              if((signed int)p_descriptor->p_data[6l] == 0x08)
              {
                p_decoded->i_handover_type = (unsigned char)handover_type;
                p_decoded->i_origin_type = (unsigned char)origin_type;
                if(handover_type >= 1 && !(handover_type >= 4))
                {
                  p_decoded->i_network_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)8] << 8 | (signed int)p_descriptor->p_data[(signed long int)9]);
                  i = 10;
                }

                if(origin_type == 0)
                {
                  if(handover_type >= 1 && !(handover_type >= 4))
                  {
                    p_decoded->i_initial_service_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)10] << 8 | (signed int)p_descriptor->p_data[(signed long int)11]);
                    i = 12;
                  }

                  else
                  {
                    p_decoded->i_initial_service_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)8] << 8 | (signed int)p_descriptor->p_data[(signed long int)9]);
                    i = 10;
                  }
                }

              }

              if((signed int)p_descriptor->p_data[6l] == 0x0D)
              {
                p_decoded->i_target_event_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)7] << 8 | (signed int)p_descriptor->p_data[(signed long int)8]);
                p_decoded->b_target_listed = (_Bool)(((signed int)p_descriptor->p_data[(signed long int)9] & 0x80) != 0 ? 1 : 0);
                p_decoded->b_event_simulcast = (_Bool)(((signed int)p_descriptor->p_data[(signed long int)9] & 0x40) != 0 ? 1 : 0);
                i = 10;
              }

              p_decoded->i_private_data_length = (unsigned char)((signed int)p_descriptor->i_length - i);
              if((signed int)p_decoded->i_private_data_length >= 249)
                p_decoded->i_private_data_length = (unsigned char)248;

              memcpy((void *)p_decoded->i_private_data, (const void *)&p_descriptor->p_data[(signed long int)i], (unsigned long int)p_decoded->i_private_data_length);
              p_descriptor->p_decoded = (void *)p_decoded;
              return p_decoded;
            }
          }
        }
      }
    }
}

// dvbpsi_DecodeLocalTimeOffsetDr
// file descriptors/dr_58.c line 47
struct dvbpsi_local_time_offset_dr_s * dvbpsi_DecodeLocalTimeOffsetDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_local_time_offset_dr_s *p_decoded;
  unsigned char *p_data;
  unsigned char *p_end;
  struct dvbpsi_local_time_offset_s *p_current;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x58);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_local_time_offset_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_local_time_offset_dr_s *)p_descriptor->p_decoded;

    else
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct dvbpsi_local_time_offset_dr_s) /*464ul*/ );
      p_decoded = (struct dvbpsi_local_time_offset_dr_s *)return_value_malloc$3;
      if(p_decoded == ((struct dvbpsi_local_time_offset_dr_s *)NULL))
        return (struct dvbpsi_local_time_offset_dr_s *)(void *)0;

      else
      {
        p_decoded->i_local_time_offsets_number = (unsigned char)0;
        p_current = p_decoded->p_local_time_offset;
        p_end = p_descriptor->p_data + (signed long int)p_descriptor->i_length;
        p_data = p_descriptor->p_data;
        for( ; p_end >= p_data + 13l; p_current = p_current + 1l)
        {
          memcpy((void *)p_current->i_country_code, (const void *)p_data, (unsigned long int)3);
          p_current->i_country_region_id = (unsigned char)((signed int)p_data[(signed long int)3] >> 2 & 0x3f);
          p_current->i_local_time_offset_polarity = (unsigned char)((signed int)p_data[(signed long int)3] & 0x01);
          p_current->i_local_time_offset = (unsigned short int)((signed int)(unsigned short int)p_data[(signed long int)4] << 8 | (signed int)(unsigned short int)p_data[(signed long int)5]);
          p_current->i_time_of_change = (unsigned long int)p_data[(signed long int)6] << 32 | (unsigned long int)p_data[(signed long int)7] << 24 | (unsigned long int)p_data[(signed long int)8] << 16 | (unsigned long int)p_data[(signed long int)9] << 8 | (unsigned long int)p_data[(signed long int)10];
          p_current->i_next_time_offset = (unsigned short int)((signed int)(unsigned short int)p_data[(signed long int)11] << 8 | (signed int)(unsigned short int)p_data[(signed long int)12]);
          p_decoded->i_local_time_offsets_number = p_decoded->i_local_time_offsets_number + 1;
          if((signed int)p_decoded->i_local_time_offsets_number == 19)
            break;

          p_data = p_data + (signed long int)13;
        }
        p_descriptor->p_decoded = (void *)p_decoded;
        return p_decoded;
      }
    }
  }
}

// dvbpsi_DecodeMPEG4AudioDr
// file ../../src/descriptors/dr_1c.h line 63
struct dvbpsi_mpeg4_audio_dr_s * dvbpsi_DecodeMPEG4AudioDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_mpeg4_audio_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x1c);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_mpeg4_audio_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_mpeg4_audio_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 1))
        return (struct dvbpsi_mpeg4_audio_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_mpeg4_audio_dr_s) /*4ul*/ );
        p_decoded = (struct dvbpsi_mpeg4_audio_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_mpeg4_audio_dr_s *)NULL))
          return (struct dvbpsi_mpeg4_audio_dr_s *)(void *)0;

        else
        {
          p_decoded->i_mpeg4_audio_profile_and_level = (enum dvbpsi_aac_profile_and_level_s)p_descriptor->p_data[(signed long int)0];
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeMPEG4VideoDr
// file ../../src/descriptors/dr_1b.h line 128
struct dvbpsi_mpeg4_video_dr_s * dvbpsi_DecodeMPEG4VideoDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_mpeg4_video_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x1b);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_mpeg4_video_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_mpeg4_video_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 1))
        return (struct dvbpsi_mpeg4_video_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_mpeg4_video_dr_s) /*4ul*/ );
        p_decoded = (struct dvbpsi_mpeg4_video_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_mpeg4_video_dr_s *)NULL))
          return (struct dvbpsi_mpeg4_video_dr_s *)(void *)0;

        else
        {
          p_decoded->i_mpeg4_visual_profile_and_level = (enum dvbpsi_mpeg4_visual_profile_and_level_s)p_descriptor->p_data[(signed long int)0];
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeMaxBitrateDr
// file ../../src/descriptors/dr_0e.h line 75
struct dvbpsi_max_bitrate_dr_s * dvbpsi_DecodeMaxBitrateDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_max_bitrate_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x0e);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_max_bitrate_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_max_bitrate_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 3))
        return (struct dvbpsi_max_bitrate_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_max_bitrate_dr_s) /*4ul*/ );
        p_decoded = (struct dvbpsi_max_bitrate_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_max_bitrate_dr_s *)NULL))
          return (struct dvbpsi_max_bitrate_dr_s *)(void *)0;

        else
        {
          p_decoded->i_max_bitrate = (unsigned int)((signed int)p_descriptor->p_data[(signed long int)0] & 0x3f) << 16 | (unsigned int)p_descriptor->p_data[(signed long int)1] << 8 | (unsigned int)p_descriptor->p_data[(signed long int)2];
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeMxBuffUtilizationDr
// file descriptors/dr_0c.c line 47
struct dvbpsi_mx_buff_utilization_dr_s * dvbpsi_DecodeMxBuffUtilizationDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_mx_buff_utilization_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x0c);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_mx_buff_utilization_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_mx_buff_utilization_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 3))
        return (struct dvbpsi_mx_buff_utilization_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_mx_buff_utilization_dr_s) /*6ul*/ );
        p_decoded = (struct dvbpsi_mx_buff_utilization_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_mx_buff_utilization_dr_s *)NULL))
          return (struct dvbpsi_mx_buff_utilization_dr_s *)(void *)0;

        else
        {
          p_decoded->b_mdv_valid = (_Bool)(((signed int)p_descriptor->p_data[(signed long int)0] & 0x80) != 0 ? 1 : 0);
          p_decoded->i_mx_delay_variation = (unsigned short int)((signed int)(unsigned short int)((signed int)p_descriptor->p_data[(signed long int)0] & 0x7f) << 8 | (signed int)p_descriptor->p_data[(signed long int)1]);
          p_decoded->i_mx_strategy = (unsigned char)(((signed int)p_descriptor->p_data[(signed long int)2] & 0xe0) >> 5);
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeNVODReferenceDr
// file descriptors/dr_4b.c line 45
struct dvbpsi_nvod_ref_dr_s * dvbpsi_DecodeNVODReferenceDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  if(!((signed int)p_descriptor->i_tag == 0x4B))
    return (struct dvbpsi_nvod_ref_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_nvod_ref_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 6))
        return (struct dvbpsi_nvod_ref_dr_s *)(void *)0;

      else
        if(!((signed int)p_descriptor->i_length % 6 == 0))
          return (struct dvbpsi_nvod_ref_dr_s *)(void *)0;

        else
        {
          struct dvbpsi_nvod_ref_dr_s *p_decoded;
          void *return_value_calloc$1;
          return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct dvbpsi_nvod_ref_dr_s) /*260ul*/ );
          p_decoded = (struct dvbpsi_nvod_ref_dr_s *)return_value_calloc$1;
          if(p_decoded == ((struct dvbpsi_nvod_ref_dr_s *)NULL))
            return (struct dvbpsi_nvod_ref_dr_s *)(void *)0;

          else
          {
            p_decoded->i_references = (unsigned char)((signed int)p_descriptor->i_length % 6);
            if((signed int)p_decoded->i_references >= 44)
              p_decoded->i_references = (unsigned char)43;

            signed int i = 0;
            for( ; !(i >= (signed int)p_decoded->i_references); i = i + 1)
            {
              signed int pos = i * 6;
              p_decoded->p_nvod_refs[(signed long int)i].i_transport_stream_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)pos] << 8 | (signed int)p_descriptor->p_data[(signed long int)(pos + 1)]);
              p_decoded->p_nvod_refs[(signed long int)i].i_original_network_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)(pos + 2)] << 8 | (signed int)p_descriptor->p_data[(signed long int)(pos + 3)]);
              p_decoded->p_nvod_refs[(signed long int)i].i_service_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)(pos + 4)] << 8 | (signed int)p_descriptor->p_data[(signed long int)(pos + 5)]);
            }
            p_descriptor->p_decoded = (void *)p_decoded;
            return p_decoded;
          }
        }
}

// dvbpsi_DecodeNetworkNameDr
// file descriptors/dr_40.c line 45
struct dvbpsi_network_name_dr_s * dvbpsi_DecodeNetworkNameDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_network_name_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x40);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_network_name_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_network_name_dr_s *)p_descriptor->p_decoded;

    else
    {
      void *return_value_calloc$3;
      return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct dvbpsi_network_name_dr_s) /*256ul*/ );
      p_decoded = (struct dvbpsi_network_name_dr_s *)return_value_calloc$3;
      if(p_decoded == ((struct dvbpsi_network_name_dr_s *)NULL))
        return (struct dvbpsi_network_name_dr_s *)(void *)0;

      else
      {
        p_decoded->i_name_length = p_descriptor->i_length;
        if(!(p_decoded->i_name_length == 0))
          memcpy((void *)p_decoded->i_name_byte, (const void *)p_descriptor->p_data, (unsigned long int)p_decoded->i_name_length);

        p_descriptor->p_decoded = (void *)p_decoded;
        return p_decoded;
      }
    }
  }
}

// dvbpsi_DecodePDCDr
// file descriptors/dr_69.c line 47
struct dvbpsi_PDC_dr_s * dvbpsi_DecodePDCDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_PDC_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x69);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_PDC_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_PDC_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 3))
        return (struct dvbpsi_PDC_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_PDC_dr_s) /*4ul*/ );
        p_decoded = (struct dvbpsi_PDC_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_PDC_dr_s *)NULL))
          return (struct dvbpsi_PDC_dr_s *)(void *)0;

        else
        {
          p_decoded->i_PDC[(signed long int)0] = (unsigned char)(((signed int)p_descriptor->p_data[(signed long int)0] & 0x0f) << 1 | (signed int)p_descriptor->p_data[(signed long int)1] >> 7);
          p_decoded->i_PDC[(signed long int)1] = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)1] >> 3 & 0x0f);
          p_decoded->i_PDC[(signed long int)2] = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)1] << 2 & 0x1c | (signed int)p_descriptor->p_data[(signed long int)2] >> 6);
          p_decoded->i_PDC[(signed long int)3] = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)2] & 0x3f);
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeParentalRatingDr
// file descriptors/dr_55.c line 47
struct dvbpsi_parental_rating_dr_s * dvbpsi_DecodeParentalRatingDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x55);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_parental_rating_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_parental_rating_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length % 4 == 0))
        return (struct dvbpsi_parental_rating_dr_s *)(void *)0;

      else
      {
        struct dvbpsi_parental_rating_dr_s *p_decoded;
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_parental_rating_dr_s) /*516ul*/ );
        p_decoded = (struct dvbpsi_parental_rating_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_parental_rating_dr_s *)NULL))
          return (struct dvbpsi_parental_rating_dr_s *)(void *)0;

        else
        {
          signed int i_ratings_number = (signed int)p_descriptor->i_length / 4;
          if(i_ratings_number >= 65)
            i_ratings_number = 64;

          p_decoded->i_ratings_number = (unsigned char)i_ratings_number;
          signed int i = 0;
          for( ; !(i >= i_ratings_number); i = i + 1)
          {
            p_decoded->p_parental_rating[(signed long int)i].i_country_code = (unsigned int)p_descriptor->p_data[(signed long int)(4 * i)] << 16 | (unsigned int)p_descriptor->p_data[(signed long int)(4 * i + 1)] << 8 | (unsigned int)p_descriptor->p_data[(signed long int)(4 * i + 2)];
            p_decoded->p_parental_rating[(signed long int)i].i_rating = p_descriptor->p_data[(signed long int)(4 * i + 3)];
          }
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodePrivateDataDr
// file descriptors/dr_0f.c line 47
struct dvbpsi_private_data_dr_s * dvbpsi_DecodePrivateDataDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_private_data_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x0f);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_private_data_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_private_data_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 4))
        return (struct dvbpsi_private_data_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_private_data_dr_s) /*4ul*/ );
        p_decoded = (struct dvbpsi_private_data_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_private_data_dr_s *)NULL))
          return (struct dvbpsi_private_data_dr_s *)(void *)0;

        else
        {
          p_decoded->i_private_data = (unsigned int)p_descriptor->p_data[(signed long int)0] << 24 | (unsigned int)p_descriptor->p_data[(signed long int)1] << 16 | (unsigned int)p_descriptor->p_data[(signed long int)2] << 8 | (unsigned int)p_descriptor->p_data[(signed long int)3];
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeRegistrationDr
// file descriptors/dr_05.c line 47
struct dvbpsi_registration_dr_s * dvbpsi_DecodeRegistrationDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_registration_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x05);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_registration_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_registration_dr_s *)p_descriptor->p_decoded;

    else
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct dvbpsi_registration_dr_s) /*256ul*/ );
      p_decoded = (struct dvbpsi_registration_dr_s *)return_value_malloc$3;
      if(p_decoded == ((struct dvbpsi_registration_dr_s *)NULL))
        return (struct dvbpsi_registration_dr_s *)(void *)0;

      else
        if(!((signed int)p_descriptor->i_length >= 4))
        {
          free((void *)p_decoded);
          return (struct dvbpsi_registration_dr_s *)(void *)0;
        }

        else
        {
          p_decoded->i_format_identifier = (unsigned int)p_descriptor->p_data[(signed long int)0] << 24 | (unsigned int)p_descriptor->p_data[(signed long int)1] << 16 | (unsigned int)p_descriptor->p_data[(signed long int)2] << 8 | (unsigned int)p_descriptor->p_data[(signed long int)3];
          p_decoded->i_additional_length = (unsigned char)((signed int)p_descriptor->i_length - 4);
          if((signed int)p_decoded->i_additional_length >= 252)
            p_decoded->i_additional_length = (unsigned char)251;

          if(!(p_decoded->i_additional_length == 0))
            memcpy((void *)p_decoded->i_additional_info, (const void *)(p_descriptor->p_data + (signed long int)4), (unsigned long int)p_decoded->i_additional_length);

          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
    }
  }
}

// dvbpsi_DecodeSTDDr
// file ../../src/descriptors/dr_11.h line 60
struct dvbpsi_std_dr_s * dvbpsi_DecodeSTDDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_std_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x11);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_std_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_std_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 1))
        return (struct dvbpsi_std_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_std_dr_s) /*1ul*/ );
        p_decoded = (struct dvbpsi_std_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_std_dr_s *)NULL))
          return (struct dvbpsi_std_dr_s *)(void *)0;

        else
        {
          p_decoded->b_leak_valid_flag = (_Bool)((signed int)p_descriptor->p_data[(signed long int)0] & 0x01);
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeSatDelivSysDr
// file descriptors/dr_43.c line 47
struct dvbpsi_sat_deliv_sys_dr_s * dvbpsi_DecodeSatDelivSysDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_sat_deliv_sys_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x43);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_sat_deliv_sys_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_sat_deliv_sys_dr_s *)p_descriptor->p_decoded;

    else
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct dvbpsi_sat_deliv_sys_dr_s) /*20ul*/ );
      p_decoded = (struct dvbpsi_sat_deliv_sys_dr_s *)return_value_malloc$3;
      if(p_decoded == ((struct dvbpsi_sat_deliv_sys_dr_s *)NULL))
        return (struct dvbpsi_sat_deliv_sys_dr_s *)(void *)0;

      else
      {
        p_decoded->i_frequency = (unsigned int)((signed int)p_descriptor->p_data[(signed long int)0] << 24) | (unsigned int)((signed int)p_descriptor->p_data[(signed long int)1] << 16) | (unsigned int)((signed int)p_descriptor->p_data[(signed long int)2] << 8) | (unsigned int)p_descriptor->p_data[(signed long int)3];
        p_decoded->i_orbital_position = (unsigned short int)((signed int)(unsigned short int)((signed int)p_descriptor->p_data[(signed long int)4] << 8) | (signed int)(unsigned short int)p_descriptor->p_data[(signed long int)5]);
        p_decoded->i_west_east_flag = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)6] >> 7 & 0x01);
        p_decoded->i_polarization = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)6] >> 5 & 0x03);
        p_decoded->i_roll_off = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)6] >> 3 & 0x03);
        p_decoded->i_modulation_system = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)6] >> 2 & 0x01);
        p_decoded->i_modulation_type = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)6] & 0x03);
        p_decoded->i_symbol_rate = (unsigned int)((signed int)p_descriptor->p_data[(signed long int)7] << 20) | (unsigned int)((signed int)p_descriptor->p_data[(signed long int)8] << 12) | (unsigned int)((signed int)p_descriptor->p_data[(signed long int)9] << 4) | (unsigned int)((signed int)p_descriptor->p_data[(signed long int)10] >> 4 & 0x0f);
        p_decoded->i_fec_inner = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)10] & 0x0f);
        p_descriptor->p_decoded = (void *)p_decoded;
        return p_decoded;
      }
    }
  }
}

// dvbpsi_DecodeServiceDr
// file descriptors/dr_48.c line 48
struct dvbpsi_service_dr_s * dvbpsi_DecodeServiceDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x48);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_service_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_service_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 3))
        return (struct dvbpsi_service_dr_s *)(void *)0;

      else
      {
        struct dvbpsi_service_dr_s *p_decoded;
        void *return_value_calloc$3;
        return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct dvbpsi_service_dr_s) /*507ul*/ );
        p_decoded = (struct dvbpsi_service_dr_s *)return_value_calloc$3;
        if(p_decoded == ((struct dvbpsi_service_dr_s *)NULL))
          return (struct dvbpsi_service_dr_s *)(void *)0;

        else
        {
          p_descriptor->p_decoded = (void *)p_decoded;
          p_decoded->i_service_type = p_descriptor->p_data[(signed long int)0];
          p_decoded->i_service_provider_name_length = p_descriptor->p_data[(signed long int)1];
          p_decoded->i_service_name_length = (unsigned char)0;
          p_decoded->i_service_provider_name[(signed long int)0] = (unsigned char)0;
          p_decoded->i_service_name[(signed long int)0] = (unsigned char)0;
          if((signed int)p_decoded->i_service_provider_name_length >= 253)
            p_decoded->i_service_provider_name_length = (unsigned char)252;

          if(!((signed int)p_descriptor->i_length >= 2 + (signed int)p_decoded->i_service_provider_name_length))
            return p_decoded;

          else
          {
            if(!(p_decoded->i_service_provider_name_length == 0))
              memcpy((void *)p_decoded->i_service_provider_name, (const void *)(p_descriptor->p_data + (signed long int)2), (unsigned long int)p_decoded->i_service_provider_name_length);

            if(!((signed int)p_descriptor->i_length >= 3 + (signed int)p_decoded->i_service_provider_name_length))
              return p_decoded;

            else
            {
              p_decoded->i_service_name_length = p_descriptor->p_data[(signed long int)(2 + (signed int)p_decoded->i_service_provider_name_length)];
              if((signed int)p_decoded->i_service_name_length >= 253)
                p_decoded->i_service_name_length = (unsigned char)252;

              if(!((signed int)p_descriptor->i_length >= 3 + (signed int)p_decoded->i_service_name_length + (signed int)p_decoded->i_service_provider_name_length))
                return p_decoded;

              else
              {
                if(!(p_decoded->i_service_name_length == 0))
                  memcpy((void *)p_decoded->i_service_name, (const void *)(p_descriptor->p_data + (signed long int)3 + (signed long int)p_decoded->i_service_provider_name_length), (unsigned long int)p_decoded->i_service_name_length);

                return p_decoded;
              }
            }
          }
        }
      }
  }
}

// dvbpsi_DecodeServiceListDr
// file descriptors/dr_41.c line 45
struct dvbpsi_service_list_dr_s * dvbpsi_DecodeServiceListDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_service_list_dr_s *p_decoded;
  _Bool tmp_if_expr$1;
  if(!((signed int)p_descriptor->i_tag == 0x41))
    return (struct dvbpsi_service_list_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_service_list_dr_s *)p_descriptor->p_decoded;

    else
    {
      unsigned int service_count = (unsigned int)((signed int)p_descriptor->i_length / 3);
      if(!((signed int)p_descriptor->i_length >= 1))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)p_descriptor->i_length % 3 != 0 ? (_Bool)1 : (_Bool)0;
      if(service_count >= 64u || tmp_if_expr$1)
        return (struct dvbpsi_service_list_dr_s *)(void *)0;

      else
      {
        void *return_value_calloc$2;
        return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct dvbpsi_service_list_dr_s) /*258ul*/ );
        p_decoded = (struct dvbpsi_service_list_dr_s *)return_value_calloc$2;
        if(p_decoded == ((struct dvbpsi_service_list_dr_s *)NULL))
          return (struct dvbpsi_service_list_dr_s *)(void *)0;

        else
        {
          p_decoded->i_service_count = (unsigned char)service_count;
          unsigned char i = (unsigned char)0;
          for( ; !((signed int)i >= (signed int)p_decoded->i_service_count); i = i + 1)
          {
            p_decoded->i_service[(signed long int)i].i_service_id = (unsigned short int)((signed int)(unsigned short int)p_descriptor->p_data[(signed long int)((signed int)i * 3)] << 8 | (signed int)p_descriptor->p_data[(signed long int)((signed int)i * 3 + 1)]);
            p_decoded->i_service[(signed long int)i].i_service_type = p_descriptor->p_data[(signed long int)((signed int)i * 3 + 2)];
          }
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
    }
}

// dvbpsi_DecodeServiceLocationDr
// file descriptors/dr_a1.c line 48
struct dvbpsi_service_location_dr_s * dvbpsi_DecodeServiceLocationDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_service_location_dr_s *p_decoded;
  unsigned char *buf = p_descriptor->p_data;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0xa1);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_service_location_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_service_location_dr_s *)p_descriptor->p_decoded;

    else
      if(!(((signed int)p_descriptor->i_length + -3) % 6 == 0))
        return (struct dvbpsi_service_location_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_service_location_dr_s) /*2044ul*/ );
        p_decoded = (struct dvbpsi_service_location_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_service_location_dr_s *)NULL))
          return (struct dvbpsi_service_location_dr_s *)(void *)0;

        else
        {
          memset((void *)p_decoded, 0, sizeof(struct dvbpsi_service_location_dr_s) /*2044ul*/ );
          p_descriptor->p_decoded = (void *)p_decoded;
          p_decoded->i_pcr_pid = (unsigned short int)((signed int)(unsigned short int)((signed int)buf[(signed long int)0] & 0x1f) << 8 | (signed int)buf[(signed long int)1]);
          p_decoded->i_number_elements = buf[(signed long int)2];
          buf = buf + (signed long int)3;
          signed int i = 0;
          for( ; !(i >= (signed int)p_decoded->i_number_elements); i = i + 1)
          {
            struct dvbpsi_service_location_element_s *p_element = &p_decoded->elements[(signed long int)i];
            p_element->i_stream_type = buf[(signed long int)0];
            p_element->i_elementary_pid = (unsigned short int)((signed int)(unsigned short int)((signed int)buf[(signed long int)1] & 0x1f) << 8 | (signed int)buf[(signed long int)2]);
            memcpy((void *)p_element->i_iso_639_code, (const void *)&buf[(signed long int)3], (unsigned long int)3);
            buf = buf + (signed long int)6;
          }
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeShortEventDr
// file descriptors/dr_4d.c line 46
struct dvbpsi_short_event_dr_s * dvbpsi_DecodeShortEventDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_short_event_dr_s *p_decoded;
  signed int i_len1;
  signed int i_len2;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x4d);
  _Bool tmp_if_expr$2;
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)p_descriptor->i_length < 5 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return (struct dvbpsi_short_event_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$3;
    return_value_dvbpsi_IsDescriptorDecoded$3=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$3 == (_Bool)0))
      return (struct dvbpsi_short_event_dr_s *)p_descriptor->p_decoded;

    else
    {
      i_len1 = (signed int)p_descriptor->p_data[(signed long int)3];
      i_len2 = (signed int)p_descriptor->p_data[(signed long int)(4 + i_len1)];
      if(!((signed int)p_descriptor->i_length >= 5 + i_len1 + i_len2))
        return (struct dvbpsi_short_event_dr_s *)(void *)0;

      else
        if(!(p_descriptor->p_decoded == NULL))
          return (struct dvbpsi_short_event_dr_s *)p_descriptor->p_decoded;

        else
        {
          void *return_value_malloc$4;
          return_value_malloc$4=malloc(sizeof(struct dvbpsi_short_event_dr_s) /*524ul*/ );
          p_decoded = (struct dvbpsi_short_event_dr_s *)return_value_malloc$4;
          if(p_decoded == ((struct dvbpsi_short_event_dr_s *)NULL))
            return (struct dvbpsi_short_event_dr_s *)(void *)0;

          else
          {
            memcpy((void *)p_decoded->i_iso_639_code, (const void *)&p_descriptor->p_data[(signed long int)0], (unsigned long int)3);
            p_decoded->i_event_name_length = i_len1;
            if(i_len1 >= 1)
              memcpy((void *)p_decoded->i_event_name, (const void *)&p_descriptor->p_data[(signed long int)(3 + 1)], (unsigned long int)i_len1);

            p_decoded->i_text_length = i_len2;
            if(i_len2 >= 1)
              memcpy((void *)p_decoded->i_text, (const void *)&p_descriptor->p_data[(signed long int)(4 + i_len1 + 1)], (unsigned long int)i_len2);

            p_descriptor->p_decoded = (void *)p_decoded;
            return p_decoded;
          }
        }
    }
  }
}

// dvbpsi_DecodeSmoothingBufferDr
// file ../../src/descriptors/dr_10.h line 64
struct dvbpsi_smoothing_buffer_dr_s * dvbpsi_DecodeSmoothingBufferDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_smoothing_buffer_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x10);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_smoothing_buffer_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_smoothing_buffer_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 6))
        return (struct dvbpsi_smoothing_buffer_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_smoothing_buffer_dr_s) /*8ul*/ );
        p_decoded = (struct dvbpsi_smoothing_buffer_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_smoothing_buffer_dr_s *)NULL))
          return (struct dvbpsi_smoothing_buffer_dr_s *)(void *)0;

        else
        {
          p_decoded->i_sb_leak_rate = ((unsigned int)p_descriptor->p_data[(signed long int)0] & (unsigned int)0x3f) << 16 | (unsigned int)p_descriptor->p_data[(signed long int)1] << 8 | (unsigned int)p_descriptor->p_data[(signed long int)2];
          p_decoded->i_sb_size = ((unsigned int)p_descriptor->p_data[(signed long int)3] & (unsigned int)0x3f) << 16 | (unsigned int)p_descriptor->p_data[(signed long int)4] << 8 | (unsigned int)p_descriptor->p_data[(signed long int)5];
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeStreamIdentifierDr
// file ../../src/descriptors/dr_52.h line 73
struct dvbpsi_stream_identifier_dr_s * dvbpsi_DecodeStreamIdentifierDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_stream_identifier_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x52);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_stream_identifier_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_stream_identifier_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 1))
        return (struct dvbpsi_stream_identifier_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_stream_identifier_dr_s) /*1ul*/ );
        p_decoded = (struct dvbpsi_stream_identifier_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_stream_identifier_dr_s *)NULL))
          return (struct dvbpsi_stream_identifier_dr_s *)(void *)0;

        else
        {
          p_decoded->i_component_tag = p_descriptor->p_data[(signed long int)0];
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeStuffingDr
// file descriptors/dr_42.c line 48
struct dvbpsi_stuffing_dr_s * dvbpsi_DecodeStuffingDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_stuffing_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x42);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_stuffing_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_stuffing_dr_s *)p_descriptor->p_decoded;

    else
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct dvbpsi_stuffing_dr_s) /*256ul*/ );
      p_decoded = (struct dvbpsi_stuffing_dr_s *)return_value_malloc$3;
      if(p_decoded == ((struct dvbpsi_stuffing_dr_s *)NULL))
        return (struct dvbpsi_stuffing_dr_s *)(void *)0;

      else
      {
        p_decoded->i_stuffing_length = p_descriptor->i_length;
        if(!(p_decoded->i_stuffing_length == 0))
          memcpy((void *)p_decoded->i_stuffing_byte, (const void *)p_descriptor->p_data, (unsigned long int)p_decoded->i_stuffing_length);

        p_descriptor->p_decoded = (void *)p_decoded;
        return p_decoded;
      }
    }
  }
}

// dvbpsi_DecodeSubtitlingDr
// file ../../src/descriptors/dr_59.h line 104
struct dvbpsi_subtitling_dr_s * dvbpsi_DecodeSubtitlingDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  signed int i_subtitles_number;
  struct dvbpsi_subtitling_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x59);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_subtitling_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_subtitling_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 3))
        return (struct dvbpsi_subtitling_dr_s *)(void *)0;

      else
        if(!((signed int)p_descriptor->i_length % 8 == 0))
          return (struct dvbpsi_subtitling_dr_s *)(void *)0;

        else
        {
          void *return_value_malloc$3;
          return_value_malloc$3=malloc(sizeof(struct dvbpsi_subtitling_dr_s) /*162ul*/ );
          p_decoded = (struct dvbpsi_subtitling_dr_s *)return_value_malloc$3;
          if(p_decoded == ((struct dvbpsi_subtitling_dr_s *)NULL))
            return (struct dvbpsi_subtitling_dr_s *)(void *)0;

          else
          {
            i_subtitles_number = (signed int)p_descriptor->i_length / 8;
            if(i_subtitles_number >= 21)
              i_subtitles_number = 20;

            p_decoded->i_subtitles_number = (unsigned char)i_subtitles_number;
            signed int i = 0;
            for( ; !(i >= i_subtitles_number); i = i + 1)
            {
              memcpy((void *)p_decoded->p_subtitle[(signed long int)i].i_iso6392_language_code, (const void *)(p_descriptor->p_data + (signed long int)(8 * i)), (unsigned long int)3);
              p_decoded->p_subtitle[(signed long int)i].i_subtitling_type = p_descriptor->p_data[(signed long int)(8 * i + 3)];
              p_decoded->p_subtitle[(signed long int)i].i_composition_page_id = (unsigned short int)((signed int)(unsigned short int)p_descriptor->p_data[(signed long int)(8 * i + 4)] << 8 | (signed int)p_descriptor->p_data[(signed long int)(8 * i + 5)]);
              p_decoded->p_subtitle[(signed long int)i].i_ancillary_page_id = (unsigned short int)((signed int)(unsigned short int)p_descriptor->p_data[(signed long int)(8 * i + 6)] << 8 | (signed int)p_descriptor->p_data[(signed long int)(8 * i + 7)]);
            }
            p_descriptor->p_decoded = (void *)p_decoded;
            return p_decoded;
          }
        }
  }
}

// dvbpsi_DecodeSystemClockDr
// file ../../src/descriptors/dr_0b.h line 78
struct dvbpsi_system_clock_dr_s * dvbpsi_DecodeSystemClockDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_system_clock_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x0b);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_system_clock_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_system_clock_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 2))
        return (struct dvbpsi_system_clock_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_system_clock_dr_s) /*3ul*/ );
        p_decoded = (struct dvbpsi_system_clock_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_system_clock_dr_s *)NULL))
          return (struct dvbpsi_system_clock_dr_s *)(void *)0;

        else
        {
          p_decoded->b_external_clock_ref = (_Bool)(((signed int)p_descriptor->p_data[(signed long int)0] & 0x80) != 0 ? 1 : 0);
          p_decoded->i_clock_accuracy_integer = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)0] & 0x3f);
          p_decoded->i_clock_accuracy_exponent = (unsigned char)(((signed int)p_descriptor->p_data[(signed long int)1] & 0xe0) >> 5);
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeTargetBgGridDr
// file descriptors/dr_07.c line 47
struct dvbpsi_target_bg_grid_dr_s * dvbpsi_DecodeTargetBgGridDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_target_bg_grid_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x07);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_target_bg_grid_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_target_bg_grid_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 4))
        return (struct dvbpsi_target_bg_grid_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_target_bg_grid_dr_s) /*6ul*/ );
        p_decoded = (struct dvbpsi_target_bg_grid_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_target_bg_grid_dr_s *)NULL))
          return (struct dvbpsi_target_bg_grid_dr_s *)(void *)0;

        else
        {
          p_decoded->i_horizontal_size = (unsigned short int)((signed int)(unsigned short int)p_descriptor->p_data[(signed long int)0] << 6 | ((signed int)p_descriptor->p_data[(signed long int)1] & 0xfc) >> 2);
          p_decoded->i_vertical_size = (unsigned short int)((signed int)(unsigned short int)((signed int)p_descriptor->p_data[(signed long int)1] & 0x03) << 12 | (signed int)(unsigned short int)p_descriptor->p_data[(signed long int)2] << 4 | ((signed int)p_descriptor->p_data[(signed long int)3] & 0xf0) >> 4);
          p_decoded->i_pel_aspect_ratio = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)3] & 0x0f);
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeTeletextDr
// file descriptors/dr_56.c line 46
struct dvbpsi_teletext_dr_s * dvbpsi_DecodeTeletextDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$2;
  return_value_dvbpsi_CanDecodeAsDescriptor$2=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x56);
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  if(return_value_dvbpsi_CanDecodeAsDescriptor$2 == (_Bool)0)
  {
    return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x46);
    if(return_value_dvbpsi_CanDecodeAsDescriptor$1 != (_Bool)0)
      goto __CPROVER_DUMP_L1;

    return (struct dvbpsi_teletext_dr_s *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    _Bool return_value_dvbpsi_IsDescriptorDecoded$3;
    return_value_dvbpsi_IsDescriptorDecoded$3=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$3 == (_Bool)0))
      return (struct dvbpsi_teletext_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 3))
        return (struct dvbpsi_teletext_dr_s *)(void *)0;

      else
        if(!((signed int)p_descriptor->i_length % 5 == 0))
          return (struct dvbpsi_teletext_dr_s *)(void *)0;

        else
        {
          struct dvbpsi_teletext_dr_s *p_decoded;
          void *return_value_malloc$4;
          return_value_malloc$4=malloc(sizeof(struct dvbpsi_teletext_dr_s) /*307ul*/ );
          p_decoded = (struct dvbpsi_teletext_dr_s *)return_value_malloc$4;
          if(p_decoded == ((struct dvbpsi_teletext_dr_s *)NULL))
            return (struct dvbpsi_teletext_dr_s *)(void *)0;

          else
          {
            signed int i_pages_number = (signed int)p_descriptor->i_length / 5;
            if(i_pages_number >= 52)
              i_pages_number = 51;

            p_decoded->i_pages_number = (unsigned char)i_pages_number;
            signed int i = 0;
            for( ; !(i >= i_pages_number); i = i + 1)
            {
              memcpy((void *)p_decoded->p_pages[(signed long int)i].i_iso6392_language_code, (const void *)(p_descriptor->p_data + (signed long int)(5 * i)), (unsigned long int)3);
              p_decoded->p_pages[(signed long int)i].i_teletext_type = (unsigned char)((signed int)(unsigned char)p_descriptor->p_data[(signed long int)(5 * i + 3)] >> 3);
              p_decoded->p_pages[(signed long int)i].i_teletext_magazine_number = (unsigned char)((signed int)(unsigned short int)p_descriptor->p_data[(signed long int)(5 * i + 3)] & 0x07);
              p_decoded->p_pages[(signed long int)i].i_teletext_page_number = p_descriptor->p_data[(signed long int)(5 * i + 4)];
            }
            p_descriptor->p_decoded = (void *)p_decoded;
            return p_decoded;
          }
        }
  }
}

// dvbpsi_DecodeTerrDelivSysDr
// file descriptors/dr_5a.c line 47
struct dvbpsi_terr_deliv_sys_dr_s * dvbpsi_DecodeTerrDelivSysDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x5a);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_terr_deliv_sys_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_terr_deliv_sys_dr_s *)p_descriptor->p_decoded;

    else
    {
      struct dvbpsi_terr_deliv_sys_dr_s *p_decoded;
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct dvbpsi_terr_deliv_sys_dr_s) /*16ul*/ );
      p_decoded = (struct dvbpsi_terr_deliv_sys_dr_s *)return_value_malloc$3;
      if(p_decoded == ((struct dvbpsi_terr_deliv_sys_dr_s *)NULL))
        return (struct dvbpsi_terr_deliv_sys_dr_s *)(void *)0;

      else
      {
        p_decoded->i_centre_frequency = (unsigned int)((signed int)p_descriptor->p_data[(signed long int)0] << 24) | (unsigned int)((signed int)p_descriptor->p_data[(signed long int)1] << 16) | (unsigned int)((signed int)p_descriptor->p_data[(signed long int)2] << 8) | (unsigned int)p_descriptor->p_data[(signed long int)3];
        p_decoded->i_bandwidth = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)4] >> 5 & 0x07);
        p_decoded->i_priority = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)4] >> 4 & 0x01);
        p_decoded->i_time_slice_indicator = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)4] >> 3 & 0x01);
        p_decoded->i_mpe_fec_indicator = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)4] >> 2 & 0x01);
        p_decoded->i_constellation = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)5] >> 6 & 0x03);
        p_decoded->i_hierarchy_information = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)5] >> 3 & 0x07);
        p_decoded->i_code_rate_hp_stream = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)5] & 0x07);
        p_decoded->i_code_rate_lp_stream = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)6] >> 5 & 0x07);
        p_decoded->i_guard_interval = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)6] >> 3 & 0x03);
        p_decoded->i_transmission_mode = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)6] >> 1 & 0x03);
        p_decoded->i_other_frequency_flag = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)6] & 0x01);
        p_descriptor->p_decoded = (void *)p_decoded;
        return p_decoded;
      }
    }
  }
}

// dvbpsi_DecodeTimeShiftedEventDr
// file ../../src/descriptors/dr_4f.h line 76
struct dvbpsi_tshifted_ev_dr_s * dvbpsi_DecodeTimeShiftedEventDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  if(!((signed int)p_descriptor->i_tag == 0x4F))
    return (struct dvbpsi_tshifted_ev_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_tshifted_ev_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 4))
        return (struct dvbpsi_tshifted_ev_dr_s *)(void *)0;

      else
      {
        struct dvbpsi_tshifted_ev_dr_s *p_decoded;
        void *return_value_calloc$1;
        return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct dvbpsi_tshifted_ev_dr_s) /*4ul*/ );
        p_decoded = (struct dvbpsi_tshifted_ev_dr_s *)return_value_calloc$1;
        if(p_decoded == ((struct dvbpsi_tshifted_ev_dr_s *)NULL))
          return (struct dvbpsi_tshifted_ev_dr_s *)(void *)0;

        else
        {
          p_decoded->i_ref_service_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)0] << 8 | (signed int)p_descriptor->p_data[(signed long int)1]);
          p_decoded->i_ref_event_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)2] << 8 | (signed int)p_descriptor->p_data[(signed long int)3]);
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
}

// dvbpsi_DecodeTimeShiftedServiceDr
// file ../../src/descriptors/dr_4c.h line 75
struct dvbpsi_tshifted_service_dr_s * dvbpsi_DecodeTimeShiftedServiceDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x4c);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_tshifted_service_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_tshifted_service_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 2))
        return (struct dvbpsi_tshifted_service_dr_s *)(void *)0;

      else
      {
        struct dvbpsi_tshifted_service_dr_s *p_decoded;
        void *return_value_calloc$3;
        return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct dvbpsi_tshifted_service_dr_s) /*2ul*/ );
        p_decoded = (struct dvbpsi_tshifted_service_dr_s *)return_value_calloc$3;
        if(p_decoded == ((struct dvbpsi_tshifted_service_dr_s *)NULL))
          return (struct dvbpsi_tshifted_service_dr_s *)(void *)0;

        else
        {
          p_decoded->i_ref_service_id = (unsigned short int)((signed int)p_descriptor->p_data[(signed long int)0] << 8 | (signed int)p_descriptor->p_data[(signed long int)1]);
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DecodeVBIDataDr
// file descriptors/dr_45.c line 46
struct dvbpsi_vbi_dr_s * dvbpsi_DecodeVBIDataDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x45);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_vbi_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_vbi_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length >= 3))
        return (struct dvbpsi_vbi_dr_s *)(void *)0;

      else
        if(!((signed int)p_descriptor->i_length % 2 == 0))
          return (struct dvbpsi_vbi_dr_s *)(void *)0;

        else
        {
          struct dvbpsi_vbi_dr_s *p_decoded;
          unsigned char i_services_number = (unsigned char)((signed int)p_descriptor->i_length / 2);
          if((signed int)i_services_number >= 86)
            i_services_number = (unsigned char)85;

          void *return_value_malloc$3;
          return_value_malloc$3=malloc(sizeof(struct dvbpsi_vbi_dr_s) /*43521ul*/ );
          p_decoded = (struct dvbpsi_vbi_dr_s *)return_value_malloc$3;
          if(p_decoded == ((struct dvbpsi_vbi_dr_s *)NULL))
            return (struct dvbpsi_vbi_dr_s *)(void *)0;

          else
          {
            p_decoded->i_services_number = i_services_number;
            unsigned char i = (unsigned char)0;
            for( ; !((signed int)i >= (signed int)i_services_number); i = i + 1)
            {
              unsigned char i_lines = (unsigned char)0;
              unsigned char i_data_service_id = (unsigned char)p_descriptor->p_data[(signed long int)(3 * (signed int)i + 2 + (signed int)i_lines)];
              p_decoded->p_services[(signed long int)i].i_data_service_id = i_data_service_id;
              i_lines = (unsigned char)p_descriptor->p_data[(signed long int)(3 * (signed int)i + 3)];
              p_decoded->p_services[(signed long int)i].i_lines = i_lines;
              unsigned char n = (unsigned char)0;
              for( ; !((signed int)n >= (signed int)i_lines); n = n + 1)
                if((signed int)i_data_service_id >= 0x01 && !((signed int)i_data_service_id >= 8))
                {
                  p_decoded->p_services[(signed long int)i].p_lines[(signed long int)n].i_parity = (unsigned char)((signed int)(unsigned char)((signed int)p_descriptor->p_data[(signed long int)(3 * (signed int)i + 3 + (signed int)n)] & 0x20) >> 5);
                  p_decoded->p_services[(signed long int)i].p_lines[(signed long int)n].i_line_offset = (unsigned char)((signed int)(unsigned char)p_descriptor->p_data[(signed long int)(3 * (signed int)i + 3 + (signed int)n)] & 0x1f);
                }

            }
            p_descriptor->p_decoded = (void *)p_decoded;
            return p_decoded;
          }
        }
  }
}

// dvbpsi_DecodeVStreamDr
// file descriptors/dr_02.c line 46
struct dvbpsi_vstream_dr_s * dvbpsi_DecodeVStreamDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_vstream_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x02);
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_vstream_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_vstream_dr_s *)p_descriptor->p_decoded;

    else
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct dvbpsi_vstream_dr_s) /*8ul*/ );
      p_decoded = (struct dvbpsi_vstream_dr_s *)return_value_malloc$3;
      if(p_decoded == ((struct dvbpsi_vstream_dr_s *)NULL))
        return (struct dvbpsi_vstream_dr_s *)(void *)0;

      else
      {
        p_decoded->b_mpeg2 = !((((signed int)p_descriptor->p_data[(signed long int)0] & 0x04) != 0 ? 1 : 0) != 0);
        if(p_decoded->b_mpeg2 == (_Bool)0)
          tmp_if_expr$4 = (signed int)p_descriptor->i_length != 1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          if(!(p_decoded->b_mpeg2 == (_Bool)0))
            tmp_if_expr$5 = (signed int)p_descriptor->i_length != 3 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$5 = (_Bool)0;
          tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$6)
        {
          free((void *)p_decoded);
          return (struct dvbpsi_vstream_dr_s *)(void *)0;
        }

        else
        {
          p_decoded->b_multiple_frame_rate = (_Bool)(((signed int)p_descriptor->p_data[(signed long int)0] & 0x80) != 0 ? 1 : 0);
          p_decoded->i_frame_rate_code = (unsigned char)(((signed int)p_descriptor->p_data[(signed long int)0] & 0x78) >> 3);
          p_decoded->b_constrained_parameter = (_Bool)(((signed int)p_descriptor->p_data[(signed long int)0] & 0x02) != 0 ? 1 : 0);
          p_decoded->b_still_picture = (_Bool)(((signed int)p_descriptor->p_data[(signed long int)0] & 0x01) != 0 ? 1 : 0);
          if(!(p_decoded->b_mpeg2 == (_Bool)0))
          {
            p_decoded->i_profile_level_indication = p_descriptor->p_data[(signed long int)1];
            p_decoded->i_chroma_format = (unsigned char)(((signed int)p_descriptor->p_data[(signed long int)2] & 0xc0) >> 6);
            p_decoded->b_frame_rate_extension = (_Bool)(((signed int)p_descriptor->p_data[(signed long int)2] & 0x20) != 0 ? 1 : 0);
          }

          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
    }
  }
}

// dvbpsi_DecodeVWindowDr
// file descriptors/dr_08.c line 47
struct dvbpsi_vwindow_dr_s * dvbpsi_DecodeVWindowDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_vwindow_dr_s *p_decoded;
  _Bool return_value_dvbpsi_CanDecodeAsDescriptor$1;
  return_value_dvbpsi_CanDecodeAsDescriptor$1=dvbpsi_CanDecodeAsDescriptor(p_descriptor, (const unsigned char)0x08);
  if(return_value_dvbpsi_CanDecodeAsDescriptor$1 == (_Bool)0)
    return (struct dvbpsi_vwindow_dr_s *)(void *)0;

  else
  {
    _Bool return_value_dvbpsi_IsDescriptorDecoded$2;
    return_value_dvbpsi_IsDescriptorDecoded$2=dvbpsi_IsDescriptorDecoded(p_descriptor);
    if(!(return_value_dvbpsi_IsDescriptorDecoded$2 == (_Bool)0))
      return (struct dvbpsi_vwindow_dr_s *)p_descriptor->p_decoded;

    else
      if(!((signed int)p_descriptor->i_length == 4))
        return (struct dvbpsi_vwindow_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct dvbpsi_vwindow_dr_s) /*6ul*/ );
        p_decoded = (struct dvbpsi_vwindow_dr_s *)return_value_malloc$3;
        if(p_decoded == ((struct dvbpsi_vwindow_dr_s *)NULL))
          return (struct dvbpsi_vwindow_dr_s *)(void *)0;

        else
        {
          p_decoded->i_horizontal_offset = (unsigned short int)((signed int)(unsigned short int)p_descriptor->p_data[(signed long int)0] << 6 | ((signed int)p_descriptor->p_data[(signed long int)1] & 0xfc) >> 2);
          p_decoded->i_vertical_offset = (unsigned short int)((signed int)(unsigned short int)((signed int)p_descriptor->p_data[(signed long int)1] & 0x03) << 12 | (signed int)(unsigned short int)p_descriptor->p_data[(signed long int)2] << 4 | ((signed int)p_descriptor->p_data[(signed long int)3] & 0xf0) >> 4);
          p_decoded->i_window_priority = (unsigned char)((signed int)p_descriptor->p_data[(signed long int)3] & 0x0f);
          p_descriptor->p_decoded = (void *)p_decoded;
          return p_decoded;
        }
      }
  }
}

// dvbpsi_DeleteDemuxSubDecoder
// file demux.c line 190
void dvbpsi_DeleteDemuxSubDecoder(struct dvbpsi_demux_subdec_s *p_subdec)
{
  if(!(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    dvbpsi_decoder_delete(p_subdec->p_decoder);
    free((void *)p_subdec);
    p_subdec = (struct dvbpsi_demux_subdec_s *)(void *)0;
  }

}

// dvbpsi_DeleteDescriptors
// file descriptor.c line 140
void dvbpsi_DeleteDescriptors(struct dvbpsi_descriptor_s *p_descriptor)
{
  while(!(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)))
  {
    struct dvbpsi_descriptor_s *p_next = p_descriptor->p_next;
    if(!(p_descriptor->p_data == ((unsigned char *)NULL)))
      free((void *)p_descriptor->p_data);

    if(!(p_descriptor->p_decoded == NULL))
      free(p_descriptor->p_decoded);

    free((void *)p_descriptor);
    p_descriptor = p_next;
  }
}

// dvbpsi_DeletePSISections
// file psi.h line 119
void dvbpsi_DeletePSISections(struct dvbpsi_psi_section_s *p_section)
{
  while(!(p_section == ((struct dvbpsi_psi_section_s *)NULL)))
  {
    struct dvbpsi_psi_section_s *p_next = p_section->p_next;
    if(!(p_section->p_data == ((unsigned char *)NULL)))
      free((void *)p_section->p_data);

    free((void *)p_section);
    p_section = p_next;
  }
  p_section = (struct dvbpsi_psi_section_s *)(void *)0;
}

// dvbpsi_Demux
// file demux.c line 102
void dvbpsi_Demux(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *p_subdec;
  p_subdec=dvbpsi_demuxGetSubDec(p_demux, p_section->i_table_id, p_section->i_extension);
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
  {
    p_demux->pf_new_callback(p_dvbpsi, p_section->i_table_id, p_section->i_extension, p_demux->p_new_cb_data);
    p_subdec=dvbpsi_demuxGetSubDec(p_demux, p_section->i_table_id, p_section->i_extension);
  }

  if(!(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL)))
    p_subdec->pf_gather(p_dvbpsi, p_subdec->p_decoder, p_section);

  else
    dvbpsi_DeletePSISections(p_section);
}

// dvbpsi_DetachDemux
// file ../../src/demux.h line 155
void dvbpsi_DetachDemux(struct dvbpsi_s *p_dvbpsi)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *p_subdec = p_demux->p_first_subdec;
  while(!(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    struct dvbpsi_demux_subdec_s *p_subdec_temp = p_subdec;
    p_subdec = p_subdec->p_next;
    if(!(p_subdec_temp->pf_detach == ((void (*)(struct dvbpsi_s *, unsigned char, unsigned short int))NULL)))
      p_subdec_temp->pf_detach(p_dvbpsi, (unsigned char)(p_subdec_temp->i_id >> 16 & (unsigned int)0xFFFF), (unsigned short int)(p_subdec_temp->i_id & (unsigned int)0xFFFF));

    else
      free((void *)p_subdec_temp);
  }
  dvbpsi_decoder_delete(p_dvbpsi->p_decoder);
  p_dvbpsi->p_decoder = (struct dvbpsi_decoder_s *)(void *)0;
}

// dvbpsi_DetachDemuxSubDecoder
// file demux.c line 218
void dvbpsi_DetachDemuxSubDecoder(struct dvbpsi_demux_s *p_demux, struct dvbpsi_demux_subdec_s *p_subdec)
{
  /* assertion p_demux */
  assert(p_demux != ((struct dvbpsi_demux_s *)NULL));
  /* assertion p_subdec */
  assert(p_subdec != ((struct dvbpsi_demux_subdec_s *)NULL));
  if(p_demux == ((struct dvbpsi_demux_s *)NULL) || p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    abort();

  /* assertion p_demux->p_first_subdec */
  assert(p_demux->p_first_subdec != ((struct dvbpsi_demux_subdec_s *)NULL));
  struct dvbpsi_demux_subdec_s **pp_prev_subdec = &p_demux->p_first_subdec;
  for( ; !(*pp_prev_subdec == p_subdec); pp_prev_subdec = &(*pp_prev_subdec)->p_next)
    ;
  *pp_prev_subdec = p_subdec->p_next;
}

// dvbpsi_DuplicateDecodedDescriptor
// file descriptor.c line 162
void * dvbpsi_DuplicateDecodedDescriptor(void *p_decoded, signed long int i_size)
{
  if(p_decoded == NULL)
    return (void *)0;

  else
  {
    void *p_duplicate;
    p_duplicate=calloc((unsigned long int)1, (unsigned long int)i_size);
    if(!(p_duplicate == NULL))
      memcpy(p_duplicate, p_decoded, (unsigned long int)i_size);

    return p_duplicate;
  }
}

// dvbpsi_ExtendedChannelNameDr
// file descriptors/dr_a0.c line 45
struct dvbpsi_extended_channel_name_dr_s * dvbpsi_ExtendedChannelNameDr(struct dvbpsi_descriptor_s *p_descriptor)
{
  struct dvbpsi_extended_channel_name_dr_s *p_decoded;
  if(!((signed int)p_descriptor->i_tag == 0xA0))
    return (struct dvbpsi_extended_channel_name_dr_s *)(void *)0;

  else
    if(!(p_descriptor->p_decoded == NULL))
      return (struct dvbpsi_extended_channel_name_dr_s *)p_descriptor->p_decoded;

    else
      if(p_descriptor->i_length == 0)
        return (struct dvbpsi_extended_channel_name_dr_s *)(void *)0;

      else
      {
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(sizeof(struct dvbpsi_extended_channel_name_dr_s) /*257ul*/ );
        p_decoded = (struct dvbpsi_extended_channel_name_dr_s *)return_value_malloc$1;
        if(p_decoded == ((struct dvbpsi_extended_channel_name_dr_s *)NULL))
          return (struct dvbpsi_extended_channel_name_dr_s *)(void *)0;

        else
        {
          p_descriptor->p_decoded = (void *)p_decoded;
          p_decoded->i_long_channel_name_length = p_descriptor->i_length;
          memcpy((void *)p_decoded->i_long_channel_name, (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
          return p_decoded;
        }
      }
}

// dvbpsi_GenAACDr
// file descriptors/dr_7c.c line 278
struct dvbpsi_descriptor_s * dvbpsi_GenAACDr(struct dvbpsi_aac_dr_s *p_decoded, _Bool b_duplicate)
{
  unsigned char i_length;
  signed int tmp_if_expr$1;
  if(!(p_decoded->b_type == (_Bool)0))
    tmp_if_expr$1 = 3 + (signed int)p_decoded->i_additional_info_length;

  else
    tmp_if_expr$1 = 1;
  i_length = (unsigned char)tmp_if_expr$1;
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x7c, i_length, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0]=dvbpsi_aac_profile_and_level_to_hex(p_decoded->i_profile_and_level);
    if((signed int)p_descriptor->i_length >= 2)
    {
      p_descriptor->p_data[(signed long int)1] = (unsigned char)0x00;
      p_descriptor->p_data[(signed long int)1] = p_descriptor->p_data[(signed long int)1] | (unsigned char)((p_decoded->b_type != (_Bool)0 ? 1 : 0) << 7);
    }

    if(!(p_decoded->b_type == (_Bool)0))
      p_descriptor->p_data[(signed long int)2]=dvbpsi_aac_type_to_hex(p_decoded->i_type);

    if((signed int)p_descriptor->i_length >= 2)
    {
      unsigned char *p = &p_descriptor->p_data[(signed long int)(p_decoded->b_type != (_Bool)0 ? 3 : 2)];
      memcpy((void *)p, (const void *)p_decoded->p_additional_info, (unsigned long int)p_decoded->i_additional_info_length);
    }

    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_aac_dr_s) /*24ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenAStreamDr
// file descriptors/dr_03.c line 84
struct dvbpsi_descriptor_s * dvbpsi_GenAStreamDr(struct dvbpsi_astream_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x03, (unsigned char)1, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    *p_descriptor->p_data = (unsigned char)0x0f;
    if(!(p_decoded->b_free_format == (_Bool)0))
      *p_descriptor->p_data = *p_descriptor->p_data | (unsigned char)0x80;

    *p_descriptor->p_data = *p_descriptor->p_data | (unsigned char)(((signed int)p_decoded->i_id & 0x01) << 6);
    *p_descriptor->p_data = *p_descriptor->p_data | (unsigned char)(((signed int)p_decoded->i_layer & 0x03) << 4);
    if(!(p_decoded->b_variable_rate_audio_indicator == (_Bool)0))
      *p_descriptor->p_data = *p_descriptor->p_data | (unsigned char)0x08;

    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_astream_dr_s) /*4ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenBouquetNameDr
// file descriptors/dr_47.c line 83
struct dvbpsi_descriptor_s * dvbpsi_GenBouquetNameDr(struct dvbpsi_bouquet_name_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x47, p_decoded->i_name_length, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    if(!(p_decoded->i_name_length == 0))
      memcpy((void *)p_descriptor->p_data, (const void *)p_decoded->i_char, (unsigned long int)p_decoded->i_name_length);

    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_bouquet_name_dr_s) /*256ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenCADr
// file descriptors/dr_09.c line 88
struct dvbpsi_descriptor_s * dvbpsi_GenCADr(struct dvbpsi_ca_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_private_length >= 252)
    p_decoded->i_private_length = (unsigned char)251;

  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x09, (unsigned char)((signed int)p_decoded->i_private_length + 4), (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)((signed int)p_decoded->i_ca_system_id >> 8);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)p_decoded->i_ca_system_id;
    p_descriptor->p_data[(signed long int)2] = (unsigned char)(0xe0 | (signed int)p_decoded->i_ca_pid >> 8 & 0x1f);
    p_descriptor->p_data[(signed long int)3] = (unsigned char)p_decoded->i_ca_pid;
    if(!(p_decoded->i_private_length == 0))
      memcpy((void *)(p_descriptor->p_data + (signed long int)4), (const void *)p_decoded->i_private_data, (unsigned long int)p_decoded->i_private_length);

    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_ca_dr_s) /*256ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenCAIdentifierDr
// file descriptors/dr_53.c line 85
struct dvbpsi_descriptor_s * dvbpsi_GenCAIdentifierDr(struct dvbpsi_ca_identifier_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_number >= 128)
    p_decoded->i_number = (unsigned char)127;

  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x53, (unsigned char)((signed int)p_decoded->i_number * 2), (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    signed int i = 0;
    for( ; !(i >= (signed int)p_decoded->i_number); i = i + 1)
    {
      p_descriptor->p_data[(signed long int)(2 * i)] = (unsigned char)((signed int)p_decoded->p_system[(signed long int)i].i_ca_system_id >> 8);
      p_descriptor->p_data[(signed long int)(2 * i + 1)] = (unsigned char)p_decoded->p_system[(signed long int)i].i_ca_system_id;
    }
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_ca_identifier_dr_s) /*256ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenCUEIDr
// file descriptors/dr_8a.c line 85
struct dvbpsi_descriptor_s * dvbpsi_GenCUEIDr(struct dvbpsi_cuei_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x8a, (unsigned char)0x01, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = p_decoded->i_cue_stream_type;
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_cuei_dr_s) /*1ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenCableDelivSysDr
// file descriptors/dr_44.c line 87
struct dvbpsi_descriptor_s * dvbpsi_GenCableDelivSysDr(struct dvbpsi_cable_deliv_sys_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x44, (unsigned char)11, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)(p_decoded->i_frequency >> 24 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)(p_decoded->i_frequency >> 16 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)2] = (unsigned char)(p_decoded->i_frequency >> 8 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)3] = (unsigned char)(p_decoded->i_frequency & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)5] = (unsigned char)((signed int)p_decoded->i_fec_outer & 0x0f);
    p_descriptor->p_data[(signed long int)6] = p_decoded->i_modulation;
    p_descriptor->p_data[(signed long int)7] = (unsigned char)(p_decoded->i_symbol_rate >> 20 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)8] = (unsigned char)(p_decoded->i_symbol_rate >> 12 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)9] = (unsigned char)(p_decoded->i_symbol_rate >> 4 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)10] = (unsigned char)(p_decoded->i_symbol_rate << 4 & (unsigned int)0xf0 | (unsigned int)((signed int)p_decoded->i_fec_inner & 0x0f));
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_cable_deliv_sys_dr_s) /*16ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenComponentDr
// file descriptors/dr_50.c line 95
struct dvbpsi_descriptor_s * dvbpsi_GenComponentDr(struct dvbpsi_component_dr_t *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x50, (unsigned char)(6 + p_decoded->i_text_length), (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)((signed int)p_decoded->i_stream_content + 0xF0);
    p_descriptor->p_data[(signed long int)1] = p_decoded->i_component_type;
    p_descriptor->p_data[(signed long int)2] = p_decoded->i_component_tag;
    memcpy((void *)&p_descriptor->p_data[(signed long int)3], (const void *)p_decoded->i_iso_639_code, (unsigned long int)3);
    if(!(p_decoded->i_text_length == 0))
      memcpy((void *)&p_descriptor->p_data[(signed long int)6], (const void *)p_decoded->i_text, (unsigned long int)p_decoded->i_text_length);

    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_component_dr_t) /*24ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenContentDr
// file descriptors/dr_54.c line 86
struct dvbpsi_descriptor_s * dvbpsi_GenContentDr(struct dvbpsi_content_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_contents_number >= 65)
    p_decoded->i_contents_number = (unsigned char)64;

  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x54, (unsigned char)((signed int)p_decoded->i_contents_number * 2), (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    signed int i = 0;
    for( ; !(i >= (signed int)p_decoded->i_contents_number); i = i + 1)
    {
      p_descriptor->p_data[(signed long int)(8 * i)] = p_decoded->p_content[(signed long int)i].i_type;
      p_descriptor->p_data[(signed long int)(8 * i + 1)] = p_decoded->p_content[(signed long int)i].i_user_byte;
    }
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_content_dr_s) /*129ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenCopyrightDr
// file descriptors/dr_0d.c line 92
struct dvbpsi_descriptor_s * dvbpsi_GenCopyrightDr(struct dvbpsi_copyright_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_additional_length >= 252)
    p_decoded->i_additional_length = (unsigned char)251;

  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x0d, (unsigned char)((signed int)p_decoded->i_additional_length + 4), (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)(p_decoded->i_copyright_identifier >> 24);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)(p_decoded->i_copyright_identifier >> 16);
    p_descriptor->p_data[(signed long int)2] = (unsigned char)(p_decoded->i_copyright_identifier >> 8);
    p_descriptor->p_data[(signed long int)3] = (unsigned char)p_decoded->i_copyright_identifier;
    if(!(p_decoded->i_additional_length == 0))
      memcpy((void *)(p_descriptor->p_data + (signed long int)4), (const void *)p_decoded->i_additional_info, (unsigned long int)p_decoded->i_additional_length);

    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_copyright_dr_s) /*256ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenCountryAvailabilityDr
// file descriptors/dr_49.c line 90
struct dvbpsi_descriptor_s * dvbpsi_GenCountryAvailabilityDr(struct dvbpsi_country_availability_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_code_count >= 84)
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    struct dvbpsi_descriptor_s *p_descriptor;
    p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x83, (unsigned char)(1 + (signed int)p_decoded->i_code_count * 3), (unsigned char *)(void *)0);
    if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
    {
      p_descriptor->p_data[(signed long int)0] = (unsigned char)(p_decoded->b_country_availability_flag != (_Bool)0 ? 0x80 : 0x00);
      unsigned char i = (unsigned char)0;
      for( ; !((signed int)i >= (signed int)p_decoded->i_code_count); i = i + 1)
      {
        p_descriptor->p_data[(signed long int)(1 + (signed int)i * 3)] = p_decoded->code[(signed long int)i].iso_639_code[(signed long int)0];
        p_descriptor->p_data[(signed long int)(2 + (signed int)i * 3)] = p_decoded->code[(signed long int)i].iso_639_code[(signed long int)1];
        p_descriptor->p_data[(signed long int)(3 + (signed int)i * 3)] = p_decoded->code[(signed long int)i].iso_639_code[(signed long int)2];
      }
      if(!(b_duplicate == (_Bool)0))
        p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_country_availability_dr_s) /*254ul*/ );

      return p_descriptor;
    }
  }
}

// dvbpsi_GenDSAlignmentDr
// file descriptors/dr_06.c line 78
struct dvbpsi_descriptor_s * dvbpsi_GenDSAlignmentDr(struct dvbpsi_ds_alignment_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x06, (unsigned char)1, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = p_decoded->i_alignment_type;
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_ds_alignment_dr_s) /*1ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenExtendedEventDr
// file descriptors/dr_4e.c line 108
struct dvbpsi_descriptor_s * dvbpsi_GenExtendedEventDr(struct dvbpsi_extended_event_dr_s *p_decoded, _Bool b_duplicate)
{
  signed int i_len;
  signed int i_len2;
  struct dvbpsi_descriptor_s *p_descriptor;
  i_len2 = 0;
  signed int dvbpsi_GenExtendedEventDr$$1$$1$$i = 0;
  for( ; !(dvbpsi_GenExtendedEventDr$$1$$1$$i >= p_decoded->i_entry_count); dvbpsi_GenExtendedEventDr$$1$$1$$i = dvbpsi_GenExtendedEventDr$$1$$1$$i + 1)
    i_len2 = i_len2 + 2 + (signed int)p_decoded->i_item_description_length[(signed long int)dvbpsi_GenExtendedEventDr$$1$$1$$i] + (signed int)p_decoded->i_item_length[(signed long int)dvbpsi_GenExtendedEventDr$$1$$1$$i];
  i_len = 1 + 3 + 1 + i_len2 + 1 + p_decoded->i_text_length;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x4e, (unsigned char)i_len, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    unsigned char *p = &p_descriptor->p_data[(signed long int)0];
    p[(signed long int)0] = (unsigned char)((signed int)p_decoded->i_descriptor_number << 4 | (signed int)p_decoded->i_last_descriptor_number);
    memcpy((void *)&p[(signed long int)1], (const void *)p_decoded->i_iso_639_code, (unsigned long int)3);
    p[(signed long int)4] = (unsigned char)i_len2;
    p = p + (signed long int)4;
    signed int i = 0;
    for( ; !(i >= p_decoded->i_entry_count); i = i + 1)
    {
      p[(signed long int)0] = p_decoded->i_item_description_length[(signed long int)i];
      memcpy((void *)&p[(signed long int)1], (const void *)p_decoded->i_item_description[(signed long int)i], (unsigned long int)p[(signed long int)0]);
      p = p + (signed long int)(1 + (signed int)p_decoded->i_item_description_length[(signed long int)i]);
      p[(signed long int)0] = p_decoded->i_item_length[(signed long int)i];
      memcpy((void *)&p[(signed long int)1], (const void *)p_decoded->i_item[(signed long int)i], (unsigned long int)p[(signed long int)0]);
      p = p + (signed long int)(1 + (signed int)p_decoded->i_item_length[(signed long int)i]);
    }
    p[(signed long int)0] = (unsigned char)p_decoded->i_text_length;
    memcpy((void *)&p[(signed long int)1], (const void *)p_decoded->i_text, (unsigned long int)p[(signed long int)0]);
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_extended_event_dr_s) /*2560ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenHierarchyDr
// file descriptors/dr_04.c line 85
struct dvbpsi_descriptor_s * dvbpsi_GenHierarchyDr(struct dvbpsi_hierarchy_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x04, (unsigned char)4, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)(0xf0 | (signed int)p_decoded->i_h_type);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)(0xc0 | (signed int)p_decoded->i_h_layer_index);
    p_descriptor->p_data[(signed long int)2] = (unsigned char)(0xc0 | (signed int)p_decoded->i_h_embedded_layer);
    p_descriptor->p_data[(signed long int)3] = (unsigned char)(0xc0 | (signed int)p_decoded->i_h_priority);
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_hierarchy_dr_s) /*4ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenIBPDr
// file descriptors/dr_12.c line 74
struct dvbpsi_descriptor_s * dvbpsi_GenIBPDr(struct dvbpsi_ibp_dr_s *p_decoded)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x12, (unsigned char)2, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)((signed int)p_decoded->b_closed_gop_flag << 7);
    p_descriptor->p_data[(signed long int)0] = p_descriptor->p_data[(signed long int)0] | (unsigned char)((signed int)p_decoded->b_identical_gop_flag << 6);
    p_descriptor->p_data[(signed long int)0] = p_descriptor->p_data[(signed long int)0] | (unsigned char)((signed int)p_decoded->i_max_gop_length >> 8);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)p_decoded->i_max_gop_length;
    return p_descriptor;
  }
}

// dvbpsi_GenISO639Dr
// file descriptors/dr_0a.c line 90
struct dvbpsi_descriptor_s * dvbpsi_GenISO639Dr(struct dvbpsi_iso639_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_code_count >= 65)
    p_decoded->i_code_count = (unsigned char)64;

  unsigned char i_size;
  signed int tmp_if_expr$1;
  if(4 * (signed int)p_decoded->i_code_count >= 256)
    tmp_if_expr$1 = 255;

  else
    tmp_if_expr$1 = (signed int)p_decoded->i_code_count * 4;
  i_size = (unsigned char)tmp_if_expr$1;
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x0a, i_size, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    signed int i = 0;
    for( ; !(i >= (signed int)p_decoded->i_code_count); i = i + 1)
    {
      p_descriptor->p_data[(signed long int)(i * 4)] = p_decoded->code[(signed long int)i].iso_639_code[(signed long int)0];
      p_descriptor->p_data[(signed long int)(i * 4 + 1)] = p_decoded->code[(signed long int)i].iso_639_code[(signed long int)1];
      p_descriptor->p_data[(signed long int)(i * 4 + 2)] = p_decoded->code[(signed long int)i].iso_639_code[(signed long int)2];
      p_descriptor->p_data[(signed long int)(i * 4 + 3)] = p_decoded->code[(signed long int)i].i_audio_type;
    }
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_iso639_dr_s) /*257ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenLCNDr
// file descriptors/dr_83.c line 90
struct dvbpsi_descriptor_s * dvbpsi_GenLCNDr(struct dvbpsi_lcn_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_number_of_entries >= 64)
    p_decoded->i_number_of_entries = (unsigned char)63;

  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x83, (unsigned char)((signed int)p_decoded->i_number_of_entries * 4), ((unsigned char *)NULL));
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    signed int i = 0;
    for( ; !(i >= (signed int)p_decoded->i_number_of_entries); i = i + 1)
    {
      p_descriptor->p_data[(signed long int)(4 * i)] = (unsigned char)((signed int)p_decoded->p_entries[(signed long int)i].i_service_id >> 8);
      p_descriptor->p_data[(signed long int)(4 * i + 1)] = (unsigned char)p_decoded->p_entries[(signed long int)i].i_service_id;
      p_descriptor->p_data[(signed long int)(4 * i + 2)] = (unsigned char)(p_decoded->p_entries[(signed long int)i].b_visible_service_flag << 7);
      p_descriptor->p_data[(signed long int)(4 * i + 2)] = p_descriptor->p_data[(signed long int)(4 * i + 2)] | (unsigned char)((signed int)p_decoded->p_entries[(signed long int)i].i_logical_channel_number >> 8);
      p_descriptor->p_data[(signed long int)(4 * i + 3)] = (unsigned char)p_decoded->p_entries[(signed long int)i].i_logical_channel_number;
    }
    if(!(b_duplicate == (_Bool)0))
    {
      struct dvbpsi_lcn_dr_s *p_dup;
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct dvbpsi_lcn_dr_s) /*772ul*/ );
      p_dup = (struct dvbpsi_lcn_dr_s *)return_value_malloc$1;
      if(!(p_dup == ((struct dvbpsi_lcn_dr_s *)NULL)))
        memcpy((void *)p_dup, (const void *)p_decoded, sizeof(struct dvbpsi_lcn_dr_s) /*772ul*/ );

      p_descriptor->p_decoded = (void *)p_dup;
    }

    return p_descriptor;
  }
}

// dvbpsi_GenLinkageDr
// file descriptors/dr_4a.c line 138
struct dvbpsi_descriptor_s * dvbpsi_GenLinkageDr(struct dvbpsi_linkage_dr_s *p_decoded, _Bool b_duplicate)
{
  signed int last_pos;
  signed int length = 7;
  if((signed int)p_decoded->i_linkage_type == 0x08)
  {
    length = length + 1;
    if((signed int)p_decoded->i_handover_type >= 1)
    {
      if(!((signed int)p_decoded->i_handover_type >= 3))
      {
        length = length + 2;
        if((signed int)p_decoded->i_origin_type == 0)
          length = length + 2;

      }

    }

  }

  if((signed int)p_decoded->i_linkage_type == 0x0D)
    length = length + 3;

  _Bool tmp_if_expr$1;
  if(length + (signed int)p_decoded->i_private_data_length >= 256)
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    struct dvbpsi_descriptor_s *p_descriptor;
    p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x4a, (unsigned char)((signed int)p_decoded->i_private_data_length + length), (unsigned char *)(void *)0);
    if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
    {
      p_descriptor->p_data[(signed long int)0] = (unsigned char)((signed int)p_decoded->i_transport_stream_id >> 8);
      p_descriptor->p_data[(signed long int)1] = (unsigned char)p_decoded->i_transport_stream_id;
      p_descriptor->p_data[(signed long int)2] = (unsigned char)((signed int)p_decoded->i_original_network_id >> 8);
      p_descriptor->p_data[(signed long int)3] = (unsigned char)p_decoded->i_original_network_id;
      p_descriptor->p_data[(signed long int)4] = (unsigned char)((signed int)p_decoded->i_service_id >> 8);
      p_descriptor->p_data[(signed long int)5] = (unsigned char)p_decoded->i_service_id;
      p_descriptor->p_data[(signed long int)6] = p_decoded->i_linkage_type;
      last_pos = 6;
      if((signed int)p_decoded->i_linkage_type == 0x08)
      {
        p_descriptor->p_data[(signed long int)7] = (unsigned char)(((signed int)p_decoded->i_handover_type & 0x0F) << 4 | 0x0E | (signed int)p_decoded->i_origin_type & 0x01);
        if((signed int)p_decoded->i_handover_type >= 1)
        {
          if(!((signed int)p_decoded->i_handover_type >= 3))
          {
            p_descriptor->p_data[(signed long int)8] = (unsigned char)((signed int)p_decoded->i_network_id >> 8);
            p_descriptor->p_data[(signed long int)9] = (unsigned char)p_decoded->i_network_id;
            last_pos = 9;
          }

        }

        if((signed int)p_decoded->i_origin_type == 0)
        {
          if((signed int)p_decoded->i_handover_type >= 1)
            tmp_if_expr$1 = (signed int)p_decoded->i_handover_type < 3 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(tmp_if_expr$1)
          {
            p_descriptor->p_data[(signed long int)10] = (unsigned char)((signed int)p_decoded->i_initial_service_id >> 8);
            p_descriptor->p_data[(signed long int)11] = (unsigned char)p_decoded->i_initial_service_id;
            last_pos = 11;
          }

          else
          {
            p_descriptor->p_data[(signed long int)8] = (unsigned char)((signed int)p_decoded->i_initial_service_id >> 8);
            p_descriptor->p_data[(signed long int)9] = (unsigned char)p_decoded->i_initial_service_id;
            last_pos = 9;
          }
        }

      }

      if((signed int)p_decoded->i_linkage_type == 0x0D)
      {
        p_descriptor->p_data[(signed long int)7] = (unsigned char)((signed int)p_decoded->i_target_event_id >> 8);
        p_descriptor->p_data[(signed long int)8] = (unsigned char)p_decoded->i_target_event_id;
        p_descriptor->p_data[(signed long int)9] = (unsigned char)((p_decoded->b_target_listed != (_Bool)0 ? 0x80 : 0x00) | (p_decoded->b_event_simulcast != (_Bool)0 ? 0x40 : 0x00) | 0x3F);
        last_pos = 9;
      }

      memcpy((void *)&p_descriptor->p_data[(signed long int)(last_pos + 1)], (const void *)p_decoded->i_private_data, (unsigned long int)p_decoded->i_private_data_length);
      if(!(b_duplicate == (_Bool)0))
        p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_linkage_dr_s) /*268ul*/ );

      return p_descriptor;
    }
  }
}

// dvbpsi_GenLocalTimeOffsetDr
// file descriptors/dr_58.c line 105
struct dvbpsi_descriptor_s * dvbpsi_GenLocalTimeOffsetDr(struct dvbpsi_local_time_offset_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_local_time_offsets_number >= 20)
    p_decoded->i_local_time_offsets_number = (unsigned char)19;

  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x58, (unsigned char)((signed int)p_decoded->i_local_time_offsets_number * 13), (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    struct dvbpsi_local_time_offset_s *p_current;
    unsigned char *p_data;
    p_current = p_decoded->p_local_time_offset;
    p_data = p_descriptor->p_data;
    unsigned char i_num = (unsigned char)0;
    for( ; !((signed int)i_num >= (signed int)p_decoded->i_local_time_offsets_number); i_num = i_num + 1)
    {
      memcpy((void *)p_data, (const void *)p_current->i_country_code, (unsigned long int)3);
      p_data[(signed long int)3] = (unsigned char)(((signed int)p_current->i_country_region_id & 0x3f) << 2 | 0x02 | (signed int)p_current->i_local_time_offset_polarity & 0x01);
      p_data[(signed long int)4] = (unsigned char)((signed int)p_current->i_local_time_offset >> 8 & 0xff);
      p_data[(signed long int)5] = (unsigned char)((signed int)p_current->i_local_time_offset & 0xff);
      p_data[(signed long int)6] = (unsigned char)(p_current->i_time_of_change >> 32 & (unsigned long int)0xff);
      p_data[(signed long int)7] = (unsigned char)(p_current->i_time_of_change >> 24 & (unsigned long int)0xff);
      p_data[(signed long int)8] = (unsigned char)(p_current->i_time_of_change >> 16 & (unsigned long int)0xff);
      p_data[(signed long int)9] = (unsigned char)(p_current->i_time_of_change >> 8 & (unsigned long int)0xff);
      p_data[(signed long int)10] = (unsigned char)(p_current->i_time_of_change & (unsigned long int)0xff);
      p_data[(signed long int)11] = (unsigned char)((signed int)p_current->i_next_time_offset >> 8 & 0xff);
      p_data[(signed long int)12] = (unsigned char)((signed int)p_current->i_next_time_offset & 0xff);
      p_data = p_data + (signed long int)13;
      p_current = p_current + 1l;
    }
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_local_time_offset_dr_s) /*464ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenMPEG4AudioDr
// file descriptors/dr_1c.c line 64
struct dvbpsi_descriptor_s * dvbpsi_GenMPEG4AudioDr(struct dvbpsi_mpeg4_audio_dr_s *p_decoded)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x1c, (unsigned char)1, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)p_decoded->i_mpeg4_audio_profile_and_level;
    return p_descriptor;
  }
}

// dvbpsi_GenMPEG4VideoDr
// file descriptors/dr_1b.c line 64
struct dvbpsi_descriptor_s * dvbpsi_GenMPEG4VideoDr(struct dvbpsi_mpeg4_video_dr_s *p_decoded)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x1b, (unsigned char)1, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)p_decoded->i_mpeg4_visual_profile_and_level;
    return p_descriptor;
  }
}

// dvbpsi_GenMaxBitrateDr
// file descriptors/dr_0e.c line 81
struct dvbpsi_descriptor_s * dvbpsi_GenMaxBitrateDr(struct dvbpsi_max_bitrate_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x0e, (unsigned char)3, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)((unsigned int)0xc0 | p_decoded->i_max_bitrate >> 16 & (unsigned int)0x3f);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)(p_decoded->i_max_bitrate >> 8);
    p_descriptor->p_data[(signed long int)2] = (unsigned char)p_decoded->i_max_bitrate;
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_max_bitrate_dr_s) /*4ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenMxBuffUtilizationDr
// file descriptors/dr_0c.c line 84
struct dvbpsi_descriptor_s * dvbpsi_GenMxBuffUtilizationDr(struct dvbpsi_mx_buff_utilization_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x0c, (unsigned char)3, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)((signed int)p_decoded->i_mx_delay_variation >> 8 & 0x7f);
    if(!(p_decoded->b_mdv_valid == (_Bool)0))
      p_descriptor->p_data[(signed long int)0] = p_descriptor->p_data[(signed long int)0] | (unsigned char)0x80;

    p_descriptor->p_data[(signed long int)1] = (unsigned char)p_decoded->i_mx_delay_variation;
    p_descriptor->p_data[(signed long int)2] = (unsigned char)(0x1f | (signed int)p_decoded->i_mx_strategy << 5);
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_mx_buff_utilization_dr_s) /*6ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenNVODReferenceDr
// file descriptors/dr_4b.c line 91
struct dvbpsi_descriptor_s * dvbpsi_GenNVODReferenceDr(struct dvbpsi_nvod_ref_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x4b, (unsigned char)((signed int)p_decoded->i_references * 6), (unsigned char *)(void *)0);
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    if((signed int)p_decoded->i_references >= 44)
      p_decoded->i_references = (unsigned char)43;

    signed int pos = 0;
    signed int i = 0;
    for( ; !(i >= (signed int)p_decoded->i_references); i = i + 1)
    {
      tmp_post$1 = pos;
      pos = pos + 1;
      p_descriptor->p_data[(signed long int)tmp_post$1] = (unsigned char)((signed int)p_decoded->p_nvod_refs[(signed long int)i].i_transport_stream_id >> 8);
      tmp_post$2 = pos;
      pos = pos + 1;
      p_descriptor->p_data[(signed long int)tmp_post$2] = (unsigned char)p_decoded->p_nvod_refs[(signed long int)i].i_transport_stream_id;
      tmp_post$3 = pos;
      pos = pos + 1;
      p_descriptor->p_data[(signed long int)tmp_post$3] = (unsigned char)((signed int)p_decoded->p_nvod_refs[(signed long int)i].i_original_network_id >> 8);
      tmp_post$4 = pos;
      pos = pos + 1;
      p_descriptor->p_data[(signed long int)tmp_post$4] = (unsigned char)p_decoded->p_nvod_refs[(signed long int)i].i_original_network_id;
      tmp_post$5 = pos;
      pos = pos + 1;
      p_descriptor->p_data[(signed long int)tmp_post$5] = (unsigned char)((signed int)p_decoded->p_nvod_refs[(signed long int)i].i_service_id >> 8);
      tmp_post$6 = pos;
      pos = pos + 1;
      p_descriptor->p_data[(signed long int)tmp_post$6] = (unsigned char)p_decoded->p_nvod_refs[(signed long int)i].i_service_id;
    }
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_nvod_ref_dr_s) /*260ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenNetworkNameDr
// file descriptors/dr_40.c line 80
struct dvbpsi_descriptor_s * dvbpsi_GenNetworkNameDr(struct dvbpsi_network_name_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x40, p_decoded->i_name_length, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    if(!(p_decoded->i_name_length == 0))
      memcpy((void *)p_descriptor->p_data, (const void *)p_decoded->i_name_byte, (unsigned long int)p_decoded->i_name_length);

    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_network_name_dr_s) /*256ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenPDCDr
// file descriptors/dr_69.c line 84
struct dvbpsi_descriptor_s * dvbpsi_GenPDCDr(struct dvbpsi_PDC_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x69, (unsigned char)3, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)(0xf0 | (signed int)p_decoded->i_PDC[(signed long int)0] >> 1);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)((signed int)p_decoded->i_PDC[(signed long int)0] << 7 | (signed int)p_decoded->i_PDC[(signed long int)1] << 3 | (signed int)p_decoded->i_PDC[(signed long int)2] >> 2);
    p_descriptor->p_data[(signed long int)2] = (unsigned char)((signed int)p_decoded->i_PDC[(signed long int)2] << 6 | (signed int)p_decoded->i_PDC[(signed long int)3]);
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_PDC_dr_s) /*4ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenParentalRatingDr
// file descriptors/dr_55.c line 92
struct dvbpsi_descriptor_s * dvbpsi_GenParentalRatingDr(struct dvbpsi_parental_rating_dr_s *p_decoded, _Bool b_duplicate)
{
  unsigned char i_length;
  if((signed int)p_decoded->i_ratings_number >= 64)
  {
    i_length = (unsigned char)((64 - 1) * 4);
    p_decoded->i_ratings_number = (unsigned char)64;
  }

  else
    i_length = (unsigned char)((signed int)p_decoded->i_ratings_number * 4);
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x55, i_length, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    signed int i = 0;
    for( ; !(i >= (signed int)p_decoded->i_ratings_number); i = i + 1)
    {
      p_descriptor->p_data[(signed long int)(8 * i)] = (unsigned char)(p_decoded->p_parental_rating[(signed long int)i].i_country_code >> 16);
      p_descriptor->p_data[(signed long int)(8 * i + 1)] = (unsigned char)(p_decoded->p_parental_rating[(signed long int)i].i_country_code >> 8 & (unsigned int)0xff);
      p_descriptor->p_data[(signed long int)(8 * i + 2)] = (unsigned char)(p_decoded->p_parental_rating[(signed long int)i].i_country_code & (unsigned int)0xff);
      p_descriptor->p_data[(signed long int)(8 * i + 3)] = p_decoded->p_parental_rating[(signed long int)i].i_rating;
    }
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_parental_rating_dr_s) /*516ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenPrivateDataDr
// file descriptors/dr_0f.c line 82
struct dvbpsi_descriptor_s * dvbpsi_GenPrivateDataDr(struct dvbpsi_private_data_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x0f, (unsigned char)4, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)(p_decoded->i_private_data >> 24);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)(p_decoded->i_private_data >> 16);
    p_descriptor->p_data[(signed long int)2] = (unsigned char)(p_decoded->i_private_data >> 8);
    p_descriptor->p_data[(signed long int)3] = (unsigned char)p_decoded->i_private_data;
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_private_data_dr_s) /*4ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenRegistrationDr
// file descriptors/dr_05.c line 94
struct dvbpsi_descriptor_s * dvbpsi_GenRegistrationDr(struct dvbpsi_registration_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_additional_length >= 252)
    p_decoded->i_additional_length = (unsigned char)251;

  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x05, (unsigned char)((signed int)p_decoded->i_additional_length + 4), (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)(p_decoded->i_format_identifier >> 24);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)(p_decoded->i_format_identifier >> 16);
    p_descriptor->p_data[(signed long int)2] = (unsigned char)(p_decoded->i_format_identifier >> 8);
    p_descriptor->p_data[(signed long int)3] = (unsigned char)p_decoded->i_format_identifier;
    if(!(p_decoded->i_additional_length == 0))
      memcpy((void *)(p_descriptor->p_data + (signed long int)4), (const void *)p_decoded->i_additional_info, (unsigned long int)p_decoded->i_additional_length);

    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_registration_dr_s) /*256ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenSTDDr
// file descriptors/dr_11.c line 63
struct dvbpsi_descriptor_s * dvbpsi_GenSTDDr(struct dvbpsi_std_dr_s *p_decoded)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x11, (unsigned char)1, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)(0xfe | (signed int)p_decoded->b_leak_valid_flag);
    return p_descriptor;
  }
}

// dvbpsi_GenSatDelivSysDr
// file descriptors/dr_43.c line 92
struct dvbpsi_descriptor_s * dvbpsi_GenSatDelivSysDr(struct dvbpsi_sat_deliv_sys_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x43, (unsigned char)11, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)(p_decoded->i_frequency >> 24 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)(p_decoded->i_frequency >> 16 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)2] = (unsigned char)(p_decoded->i_frequency >> 8 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)3] = (unsigned char)(p_decoded->i_frequency & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)4] = (unsigned char)((signed int)p_decoded->i_orbital_position >> 8 & 0xff);
    p_descriptor->p_data[(signed long int)5] = (unsigned char)((signed int)p_decoded->i_orbital_position & 0xff);
    p_descriptor->p_data[(signed long int)6] = (unsigned char)(((signed int)p_decoded->i_west_east_flag & 0x01) << 7 | ((signed int)p_decoded->i_polarization & 0x03) << 5 | ((signed int)p_decoded->i_roll_off & 0x03) << 3 | ((signed int)p_decoded->i_modulation_system & 0x01) << 2 | (signed int)p_decoded->i_modulation_type & 0x03);
    p_descriptor->p_data[(signed long int)7] = (unsigned char)(p_decoded->i_symbol_rate >> 20 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)8] = (unsigned char)(p_decoded->i_symbol_rate >> 12 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)9] = (unsigned char)(p_decoded->i_symbol_rate >> 4 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)10] = (unsigned char)(p_decoded->i_symbol_rate << 4 & (unsigned int)0xf0 | (unsigned int)((signed int)p_decoded->i_fec_inner & 0x0f));
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_sat_deliv_sys_dr_s) /*20ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenServiceDr
// file descriptors/dr_48.c line 111
struct dvbpsi_descriptor_s * dvbpsi_GenServiceDr(struct dvbpsi_service_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_service_provider_name_length >= 253)
    p_decoded->i_service_provider_name_length = (unsigned char)252;

  if((signed int)p_decoded->i_service_name_length >= 253)
    p_decoded->i_service_name_length = (unsigned char)252;

  unsigned char i_size = (unsigned char)0;
  signed int i_length = 3 + (signed int)p_decoded->i_service_name_length + (signed int)p_decoded->i_service_provider_name_length;
  i_size = (unsigned char)(i_length >= 255 ? 255 : i_length);
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x48, i_size, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = p_decoded->i_service_type;
    p_descriptor->p_data[(signed long int)1] = p_decoded->i_service_provider_name_length;
    if(!(p_decoded->i_service_provider_name_length == 0))
      memcpy((void *)(p_descriptor->p_data + (signed long int)2), (const void *)p_decoded->i_service_provider_name, (unsigned long int)p_decoded->i_service_provider_name_length);

    p_descriptor->p_data[(signed long int)(2 + (signed int)p_decoded->i_service_provider_name_length)] = p_decoded->i_service_name_length;
    if(!(p_decoded->i_service_name_length == 0))
      memcpy((void *)(p_descriptor->p_data + (signed long int)3 + (signed long int)p_decoded->i_service_provider_name_length), (const void *)p_decoded->i_service_name, (unsigned long int)p_decoded->i_service_name_length);

    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_service_dr_s) /*507ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenServiceListDr
// file descriptors/dr_41.c line 89
struct dvbpsi_descriptor_s * dvbpsi_GenServiceListDr(struct dvbpsi_service_list_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_service_count >= 64)
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    struct dvbpsi_descriptor_s *p_descriptor;
    p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x83, (unsigned char)((signed int)p_decoded->i_service_count * 3), (unsigned char *)(void *)0);
    if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
    {
      unsigned char i = (unsigned char)0;
      for( ; !((signed int)i >= (signed int)p_decoded->i_service_count); i = i + 1)
      {
        p_descriptor->p_data[(signed long int)((signed int)i * 3)] = (unsigned char)((signed int)p_decoded->i_service[(signed long int)i].i_service_id >> 8);
        p_descriptor->p_data[(signed long int)((signed int)i * 3 + 1)] = (unsigned char)p_decoded->i_service[(signed long int)i].i_service_id;
        p_descriptor->p_data[(signed long int)((signed int)i * 3 + 2)] = p_decoded->i_service[(signed long int)i].i_service_type;
      }
      if(!(b_duplicate == (_Bool)0))
        p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_service_list_dr_s) /*258ul*/ );

      return p_descriptor;
    }
  }
}

// dvbpsi_GenServiceLocationDr
// file descriptors/dr_a1.c line 98
struct dvbpsi_descriptor_s * dvbpsi_GenServiceLocationDr(struct dvbpsi_service_location_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_number_elements >= 43)
    p_decoded->i_number_elements = (unsigned char)42;

  unsigned char i_desc_length = (unsigned char)(3 + (signed int)p_decoded->i_number_elements * 6);
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0xa1, i_desc_length, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    unsigned char *p_data = p_descriptor->p_data;
    p_data[(signed long int)0] = (unsigned char)((signed int)p_decoded->i_pcr_pid >> 8);
    p_data[(signed long int)1] = (unsigned char)p_decoded->i_pcr_pid;
    p_data[(signed long int)2] = p_decoded->i_number_elements;
    p_data = p_data + (signed long int)3;
    unsigned char i = (unsigned char)0;
    for( ; !((signed int)i >= (signed int)p_decoded->i_number_elements); i = i + 1)
    {
      struct dvbpsi_service_location_element_s p_es = p_decoded->elements[(signed long int)i];
      unsigned char *p_es_data = p_data;
      p_es_data[(signed long int)0] = p_es.i_stream_type;
      p_es_data[(signed long int)1] = (unsigned char)((signed int)p_es.i_elementary_pid >> 8);
      p_es_data[(signed long int)2] = (unsigned char)p_es.i_elementary_pid;
      p_es_data[(signed long int)3] = (unsigned char)p_es.i_iso_639_code[(signed long int)0];
      p_es_data[(signed long int)4] = (unsigned char)p_es.i_iso_639_code[(signed long int)1];
      p_es_data[(signed long int)5] = (unsigned char)p_es.i_iso_639_code[(signed long int)2];
      p_data = p_data + (signed long int)6;
    }
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_service_location_dr_s) /*2044ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenShortEventDr
// file descriptors/dr_4d.c line 94
struct dvbpsi_descriptor_s * dvbpsi_GenShortEventDr(struct dvbpsi_short_event_dr_s *p_decoded, _Bool b_duplicate)
{
  unsigned char i_len1 = (unsigned char)p_decoded->i_event_name_length;
  unsigned char i_len2 = (unsigned char)p_decoded->i_text_length;
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x4d, (unsigned char)(5 + (signed int)i_len1 + (signed int)i_len2), (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    memcpy((void *)&p_descriptor->p_data[(signed long int)0], (const void *)p_decoded->i_iso_639_code, (unsigned long int)3);
    p_descriptor->p_data[(signed long int)3] = i_len1;
    if(!(i_len1 == 0))
      memcpy((void *)&p_descriptor->p_data[(signed long int)4], (const void *)p_decoded->i_event_name, (unsigned long int)i_len1);

    p_descriptor->p_data[(signed long int)(3 + 1 + (signed int)i_len1)] = i_len2;
    if(!(i_len2 == 0))
      memcpy((void *)&p_descriptor->p_data[(signed long int)(3 + 1 + (signed int)i_len1 + 1)], (const void *)p_decoded->i_text, (unsigned long int)i_len2);

    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_short_event_dr_s) /*524ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenSmoothingBufferDr
// file descriptors/dr_10.c line 72
struct dvbpsi_descriptor_s * dvbpsi_GenSmoothingBufferDr(struct dvbpsi_smoothing_buffer_dr_s *p_decoded)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x10, (unsigned char)6, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)(p_decoded->i_sb_leak_rate >> 16 | (unsigned int)0xc0);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)(p_decoded->i_sb_leak_rate >> 8);
    p_descriptor->p_data[(signed long int)2] = (unsigned char)p_decoded->i_sb_leak_rate;
    p_descriptor->p_data[(signed long int)3] = (unsigned char)(p_decoded->i_sb_size >> 16 | (unsigned int)0xc0);
    p_descriptor->p_data[(signed long int)4] = (unsigned char)(p_decoded->i_sb_size >> 8);
    p_descriptor->p_data[(signed long int)5] = (unsigned char)p_decoded->i_sb_size;
    return p_descriptor;
  }
}

// dvbpsi_GenStreamIdentifierDr
// file descriptors/dr_52.c line 78
struct dvbpsi_descriptor_s * dvbpsi_GenStreamIdentifierDr(struct dvbpsi_stream_identifier_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x52, (unsigned char)1, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = p_decoded->i_component_tag;
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_stream_identifier_dr_s) /*1ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenStuffingDr
// file descriptors/dr_42.c line 83
struct dvbpsi_descriptor_s * dvbpsi_GenStuffingDr(struct dvbpsi_stuffing_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x42, p_decoded->i_stuffing_length, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    if(!(p_decoded->i_stuffing_length == 0))
      memcpy((void *)p_descriptor->p_data, (const void *)p_decoded->i_stuffing_byte, (unsigned long int)p_decoded->i_stuffing_length);

    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_stuffing_dr_s) /*256ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenSubtitlingDr
// file descriptors/dr_59.c line 105
struct dvbpsi_descriptor_s * dvbpsi_GenSubtitlingDr(struct dvbpsi_subtitling_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_subtitles_number >= 21)
    p_decoded->i_subtitles_number = (unsigned char)20;

  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x59, (unsigned char)((signed int)p_decoded->i_subtitles_number * 8), (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    signed int i = 0;
    for( ; !(i >= (signed int)p_decoded->i_subtitles_number); i = i + 1)
    {
      memcpy((void *)(p_descriptor->p_data + (signed long int)(8 * i)), (const void *)p_decoded->p_subtitle[(signed long int)i].i_iso6392_language_code, (unsigned long int)3);
      p_descriptor->p_data[(signed long int)(8 * i + 3)] = p_decoded->p_subtitle[(signed long int)i].i_subtitling_type;
      p_descriptor->p_data[(signed long int)(8 * i + 4)] = (unsigned char)((signed int)p_decoded->p_subtitle[(signed long int)i].i_composition_page_id >> 8);
      p_descriptor->p_data[(signed long int)(8 * i + 5)] = (unsigned char)((signed int)p_decoded->p_subtitle[(signed long int)i].i_composition_page_id % 0xFF);
      p_descriptor->p_data[(signed long int)(8 * i + 6)] = (unsigned char)((signed int)p_decoded->p_subtitle[(signed long int)i].i_ancillary_page_id >> 8);
      p_descriptor->p_data[(signed long int)(8 * i + 7)] = (unsigned char)((signed int)p_decoded->p_subtitle[(signed long int)i].i_ancillary_page_id % 0xFF);
    }
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_subtitling_dr_s) /*162ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenSystemClockDr
// file descriptors/dr_0b.c line 82
struct dvbpsi_descriptor_s * dvbpsi_GenSystemClockDr(struct dvbpsi_system_clock_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x0b, (unsigned char)2, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)(0x40 | (signed int)p_decoded->i_clock_accuracy_integer & 0x3f);
    if(!(p_decoded->b_external_clock_ref == (_Bool)0))
      p_descriptor->p_data[(signed long int)0] = p_descriptor->p_data[(signed long int)0] | (unsigned char)0x80;

    p_descriptor->p_data[(signed long int)1] = (unsigned char)(0x1f | (signed int)p_decoded->i_clock_accuracy_exponent << 5);
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_system_clock_dr_s) /*3ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenTargetBgGridDr
// file descriptors/dr_07.c line 85
struct dvbpsi_descriptor_s * dvbpsi_GenTargetBgGridDr(struct dvbpsi_target_bg_grid_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x07, (unsigned char)4, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)((signed int)p_decoded->i_horizontal_size >> 6);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)((signed int)(unsigned char)p_decoded->i_horizontal_size << 2 | (signed int)p_decoded->i_vertical_size >> 12);
    p_descriptor->p_data[(signed long int)2] = (unsigned char)((signed int)p_decoded->i_vertical_size >> 4);
    p_descriptor->p_data[(signed long int)3] = (unsigned char)((signed int)(unsigned char)p_decoded->i_vertical_size << 4 | (signed int)p_decoded->i_pel_aspect_ratio & 0x0f);
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_target_bg_grid_dr_s) /*6ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenTeletextDr
// file descriptors/dr_56.c line 100
struct dvbpsi_descriptor_s * dvbpsi_GenTeletextDr(struct dvbpsi_teletext_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_pages_number >= 52)
    p_decoded->i_pages_number = (unsigned char)51;

  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x56, (unsigned char)((signed int)p_decoded->i_pages_number * 5), (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    signed int i = 0;
    for( ; !(i >= (signed int)p_decoded->i_pages_number); i = i + 1)
    {
      memcpy((void *)(p_descriptor->p_data + (signed long int)(8 * i)), (const void *)p_decoded->p_pages[(signed long int)i].i_iso6392_language_code, (unsigned long int)3);
      p_descriptor->p_data[(signed long int)(8 * i + 3)] = (unsigned char)((signed int)(unsigned char)p_decoded->p_pages[(signed long int)i].i_teletext_type << 3 | (signed int)(unsigned char)p_decoded->p_pages[(signed long int)i].i_teletext_magazine_number & 0x07);
      p_descriptor->p_data[(signed long int)(8 * i + 4)] = p_decoded->p_pages[(signed long int)i].i_teletext_page_number;
    }
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_teletext_dr_s) /*307ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenTerrDelivSysDr
// file descriptors/dr_5a.c line 89
struct dvbpsi_descriptor_s * dvbpsi_GenTerrDelivSysDr(struct dvbpsi_terr_deliv_sys_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x5a, (unsigned char)11, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)(p_decoded->i_centre_frequency >> 24 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)(p_decoded->i_centre_frequency >> 16 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)2] = (unsigned char)(p_decoded->i_centre_frequency >> 8 & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)3] = (unsigned char)(p_decoded->i_centre_frequency & (unsigned int)0xff);
    p_descriptor->p_data[(signed long int)4] = (unsigned char)(((signed int)p_decoded->i_bandwidth & 0x07) << 5 | ((signed int)p_decoded->i_priority & 0x01) << 4 | ((signed int)p_decoded->i_time_slice_indicator & 0x01) << 3 | ((signed int)p_decoded->i_mpe_fec_indicator & 0x01) << 2 | 0x03);
    p_descriptor->p_data[(signed long int)5] = (unsigned char)(((signed int)p_decoded->i_constellation & 0x03) << 6 | ((signed int)p_decoded->i_hierarchy_information & 0x07) << 3 | (signed int)p_decoded->i_code_rate_hp_stream & 0x07);
    p_descriptor->p_data[(signed long int)6] = (unsigned char)(((signed int)p_decoded->i_code_rate_lp_stream & 0x07) << 5 | ((signed int)p_decoded->i_guard_interval & 0x03) << 3 | ((signed int)p_decoded->i_transmission_mode & 0x03) << 1 | (signed int)p_decoded->i_other_frequency_flag & 0x01);
    p_descriptor->p_data[(signed long int)7] = (unsigned char)0xff;
    p_descriptor->p_data[(signed long int)8] = (unsigned char)0xff;
    p_descriptor->p_data[(signed long int)9] = (unsigned char)0xff;
    p_descriptor->p_data[(signed long int)10] = (unsigned char)0xff;
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_terr_deliv_sys_dr_s) /*16ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenTimeShiftedEventDr
// file descriptors/dr_4f.c line 78
struct dvbpsi_descriptor_s * dvbpsi_GenTimeShiftedEventDr(struct dvbpsi_tshifted_ev_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x4f, (unsigned char)4, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)((signed int)p_decoded->i_ref_service_id >> 8);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)p_decoded->i_ref_service_id;
    p_descriptor->p_data[(signed long int)2] = (unsigned char)((signed int)p_decoded->i_ref_event_id >> 8);
    p_descriptor->p_data[(signed long int)3] = (unsigned char)p_decoded->i_ref_event_id;
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_tshifted_ev_dr_s) /*4ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenTimeShiftedServiceDr
// file descriptors/dr_4c.c line 76
struct dvbpsi_descriptor_s * dvbpsi_GenTimeShiftedServiceDr(struct dvbpsi_tshifted_service_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x4c, (unsigned char)2, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)((signed int)p_decoded->i_ref_service_id >> 8);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)p_decoded->i_ref_service_id;
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_tshifted_service_dr_s) /*2ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenVBIDataDr
// file descriptors/dr_45.c line 106
struct dvbpsi_descriptor_s * dvbpsi_GenVBIDataDr(struct dvbpsi_vbi_dr_s *p_decoded, _Bool b_duplicate)
{
  if((signed int)p_decoded->i_services_number >= 86)
    p_decoded->i_services_number = (unsigned char)85;

  unsigned char i_size;
  signed int tmp_if_expr$1;
  if(5 * (signed int)p_decoded->i_services_number >= 256)
    tmp_if_expr$1 = 255;

  else
    tmp_if_expr$1 = (signed int)p_decoded->i_services_number * 5;
  i_size = (unsigned char)tmp_if_expr$1;
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x45, i_size, (unsigned char *)(void *)0);
  _Bool tmp_if_expr$2;
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    unsigned char i = (unsigned char)0;
    for( ; !((signed int)i >= (signed int)p_decoded->i_services_number); i = i + 1)
    {
      p_descriptor->p_data[(signed long int)(5 * (signed int)i + 3)] = (unsigned char)p_decoded->p_services[(signed long int)i].i_data_service_id;
      p_descriptor->p_data[(signed long int)(5 * (signed int)i + 4)] = p_decoded->p_services[(signed long int)i].i_lines;
      unsigned char n = (unsigned char)0;
      for( ; !((signed int)n >= (signed int)p_decoded->p_services[(signed long int)i].i_lines); n = n + 1)
      {
        if((signed int)p_decoded->p_services[(signed long int)i].i_data_service_id >= 0x01)
          tmp_if_expr$2 = (signed int)p_decoded->p_services[(signed long int)i].i_data_service_id <= 0x07 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          p_descriptor->p_data[(signed long int)(5 * (signed int)i + 4 + (signed int)n)] = (unsigned char)((signed int)(unsigned char)(((signed int)(unsigned char)p_decoded->p_services[(signed long int)i].p_lines[(signed long int)n].i_parity & 0x20) << 5) | (signed int)(unsigned char)p_decoded->p_services[(signed long int)i].p_lines[(signed long int)n].i_line_offset & 0x1f);

        else
          p_descriptor->p_data[(signed long int)(5 * (signed int)i + 3 + (signed int)n)] = (unsigned char)0xFF;
      }
    }
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_vbi_dr_s) /*43521ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenVStreamDr
// file descriptors/dr_02.c line 93
struct dvbpsi_descriptor_s * dvbpsi_GenVStreamDr(struct dvbpsi_vstream_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x02, (unsigned char)(p_decoded->b_mpeg2 != (_Bool)0 ? 3 : 1), (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)(p_decoded->b_mpeg2 != (_Bool)0 ? 0 : 0x04);
    if(!(p_decoded->b_multiple_frame_rate == (_Bool)0))
      p_descriptor->p_data[(signed long int)0] = p_descriptor->p_data[(signed long int)0] | (unsigned char)0x80;

    p_descriptor->p_data[(signed long int)0] = p_descriptor->p_data[(signed long int)0] | (unsigned char)(((signed int)p_decoded->i_frame_rate_code & 0x0f) << 3);
    if(!(p_decoded->b_constrained_parameter == (_Bool)0))
      p_descriptor->p_data[(signed long int)0] = p_descriptor->p_data[(signed long int)0] | (unsigned char)0x02;

    if(!(p_decoded->b_still_picture == (_Bool)0))
      p_descriptor->p_data[(signed long int)0] = p_descriptor->p_data[(signed long int)0] | (unsigned char)0x01;

    if(!(p_decoded->b_mpeg2 == (_Bool)0))
    {
      p_descriptor->p_data[(signed long int)1] = p_decoded->i_profile_level_indication;
      p_descriptor->p_data[(signed long int)2] = (unsigned char)0x1f;
      p_descriptor->p_data[(signed long int)2] = p_descriptor->p_data[(signed long int)2] | (unsigned char)(((signed int)p_decoded->i_chroma_format & 0x03) << 6);
      if(!(p_decoded->b_frame_rate_extension == (_Bool)0))
        p_descriptor->p_data[(signed long int)2] = p_descriptor->p_data[(signed long int)2] | (unsigned char)0x20;

    }

    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_vstream_dr_s) /*8ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_GenVWindowDr
// file descriptors/dr_08.c line 84
struct dvbpsi_descriptor_s * dvbpsi_GenVWindowDr(struct dvbpsi_vwindow_dr_s *p_decoded, _Bool b_duplicate)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor((unsigned char)0x08, (unsigned char)4, (unsigned char *)(void *)0);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_descriptor->p_data[(signed long int)0] = (unsigned char)((signed int)p_decoded->i_horizontal_offset >> 6);
    p_descriptor->p_data[(signed long int)1] = (unsigned char)((signed int)(unsigned char)p_decoded->i_horizontal_offset << 2 | (signed int)p_decoded->i_vertical_offset >> 12);
    p_descriptor->p_data[(signed long int)2] = (unsigned char)((signed int)p_decoded->i_vertical_offset >> 4);
    p_descriptor->p_data[(signed long int)3] = (unsigned char)((signed int)(unsigned char)p_decoded->i_vertical_offset << 4 | (signed int)p_decoded->i_window_priority & 0x0f);
    if(!(b_duplicate == (_Bool)0))
      p_descriptor->p_decoded=dvbpsi_DuplicateDecodedDescriptor((void *)p_decoded, (signed long int)sizeof(struct dvbpsi_vwindow_dr_s) /*6ul*/ );

    return p_descriptor;
  }
}

// dvbpsi_IsCompleteEIT
// file tables/eit.c line 329
static _Bool dvbpsi_IsCompleteEIT(struct dvbpsi_eit_decoder_s *p_eit_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_eit_decoder */
  assert(p_eit_decoder != ((struct dvbpsi_eit_decoder_s *)NULL));
  _Bool b_complete = (_Bool)0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if((signed int)p_eit_decoder->i_first_received_section_number >= 1)
  {
    if(p_section->i_number == p_eit_decoder->i_first_received_section_number)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)p_section->i_number == (signed int)p_eit_decoder->i_first_received_section_number - 1 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    if((signed int)p_eit_decoder->i_first_received_section_number == 0)
      tmp_if_expr$3 = p_section->i_number == p_eit_decoder->i_last_section_number ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$4)
  {
    struct dvbpsi_psi_section_s *p = p_eit_decoder->p_sections;
    for( ; !(p == ((struct dvbpsi_psi_section_s *)NULL)); p = p->p_next)
    {
      if(p->i_number == p_eit_decoder->i_last_section_number)
      {
        b_complete = (_Bool)1;
        break;
      }

      if(p->i_number == p->p_payload_start[4l])
        for( ; !(p->p_next == ((struct dvbpsi_psi_section_s *)NULL)); p = p->p_next)
          if((signed int)p->p_next->i_number >= (signed int)p_eit_decoder->i_last_section_number)
            break;


    }
  }

  return b_complete;
}

// dvbpsi_IsDescriptor
// file descriptor.c line 49
static inline _Bool dvbpsi_IsDescriptor(struct dvbpsi_descriptor_s *p_descriptor, const unsigned char i_tag)
{
  return p_descriptor->i_tag == i_tag;
}

// dvbpsi_IsDescriptorDecoded
// file descriptor.c line 59
_Bool dvbpsi_IsDescriptorDecoded(struct dvbpsi_descriptor_s *p_descriptor)
{
  return p_descriptor->p_decoded != (void *)0;
}

// dvbpsi_NewDemuxSubDecoder
// file demux.c line 161
struct dvbpsi_demux_subdec_s * dvbpsi_NewDemuxSubDecoder(const unsigned char i_table_id, const unsigned short int i_extension, void (*pf_detach)(struct dvbpsi_s *, unsigned char, unsigned short int), void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_decoder_s *, struct dvbpsi_psi_section_s *), struct dvbpsi_decoder_s *p_decoder)
{
  /* assertion pf_gather */
  assert(pf_gather != ((void (*)(struct dvbpsi_s *, struct dvbpsi_decoder_s *, struct dvbpsi_psi_section_s *))NULL));
  /* assertion pf_detach */
  assert(pf_detach != ((void (*)(struct dvbpsi_s *, unsigned char, unsigned short int))NULL));
  struct dvbpsi_demux_subdec_s *p_subdec;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct dvbpsi_demux_subdec_s) /*40ul*/ );
  p_subdec = (struct dvbpsi_demux_subdec_s *)return_value_calloc$1;
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    return (struct dvbpsi_demux_subdec_s *)(void *)0;

  else
  {
    unsigned int i_id = (unsigned int)i_table_id << 16 | (unsigned int)i_extension;
    p_subdec->i_id = i_id;
    p_subdec->p_decoder = p_decoder;
    p_subdec->pf_gather = pf_gather;
    p_subdec->pf_detach = pf_detach;
    return p_subdec;
  }
}

// dvbpsi_NewDescriptor
// file descriptor.c line 85
struct dvbpsi_descriptor_s * dvbpsi_NewDescriptor(unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_descriptor_s) /*32ul*/ );
  p_descriptor = (struct dvbpsi_descriptor_s *)return_value_malloc$1;
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)i_length * sizeof(unsigned char) /*1ul*/ );
    p_descriptor->p_data = (unsigned char *)return_value_malloc$2;
    if(!(p_descriptor->p_data == ((unsigned char *)NULL)))
    {
      p_descriptor->i_tag = i_tag;
      p_descriptor->i_length = i_length;
      if(!(p_data == ((unsigned char *)NULL)))
        memcpy((void *)p_descriptor->p_data, (const void *)p_data, (unsigned long int)i_length);

      p_descriptor->p_decoded = (void *)0;
      p_descriptor->p_next = (struct dvbpsi_descriptor_s *)(void *)0;
    }

    else
    {
      free((void *)p_descriptor);
      p_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
    }
    return p_descriptor;
  }
}

// dvbpsi_NewPSISection
// file psi.h line 108
struct dvbpsi_psi_section_s * dvbpsi_NewPSISection(signed int i_max_size)
{
  struct dvbpsi_psi_section_s *p_section;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct dvbpsi_psi_section_s) /*56ul*/ );
  p_section = (struct dvbpsi_psi_section_s *)return_value_calloc$1;
  if(p_section == ((struct dvbpsi_psi_section_s *)NULL))
    return (struct dvbpsi_psi_section_s *)(void *)0;

  else
  {
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)1, (unsigned long int)i_max_size * sizeof(unsigned char) /*1ul*/ );
    p_section->p_data = (unsigned char *)return_value_calloc$2;
    if(p_section->p_data == ((unsigned char *)NULL))
    {
      free((void *)p_section);
      return (struct dvbpsi_psi_section_s *)(void *)0;
    }

    else
    {
      p_section->p_payload_end = p_section->p_data;
      p_section->p_next = (struct dvbpsi_psi_section_s *)(void *)0;
      return p_section;
    }
  }
}

// dvbpsi_ReInitBAT
// file tables/bat.c line 282
static void dvbpsi_ReInitBAT(struct dvbpsi_bat_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_bat_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_bat == ((struct dvbpsi_bat_s *)NULL)))
      dvbpsi_bat_delete(p_decoder->p_building_bat);

  }

  p_decoder->p_building_bat = (struct dvbpsi_bat_s *)(void *)0;
}

// dvbpsi_ReInitCAT
// file tables/cat.c line 172
static void dvbpsi_ReInitCAT(struct dvbpsi_cat_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_cat_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_cat == ((struct dvbpsi_cat_s *)NULL)))
      dvbpsi_cat_delete(p_decoder->p_building_cat);

  }

  p_decoder->p_building_cat = (struct dvbpsi_cat_s *)(void *)0;
}

// dvbpsi_ReInitEIT
// file tables/eit.c line 279
static void dvbpsi_ReInitEIT(struct dvbpsi_eit_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_eit_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_eit == ((struct dvbpsi_eit_s *)NULL)))
      dvbpsi_eit_delete(p_decoder->p_building_eit);

  }

  p_decoder->p_building_eit = (struct dvbpsi_eit_s *)(void *)0;
}

// dvbpsi_ReInitEIT$link1
// file tables/atsc_eit.c line 295
static void dvbpsi_ReInitEIT$link1(struct dvbpsi_atsc_eit_decoder_s *p_decoder$link1, const _Bool b_force$link1)
{
  /* assertion p_decoder */
  assert(p_decoder$link1 != ((struct dvbpsi_atsc_eit_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder$link1, b_force$link1);
  if(!(b_force$link1 == (_Bool)0))
  {
    if(!(p_decoder$link1->p_building_eit == ((struct dvbpsi_atsc_eit_s *)NULL)))
      dvbpsi_atsc_DeleteEIT(p_decoder$link1->p_building_eit);

  }

  p_decoder$link1->p_building_eit = (struct dvbpsi_atsc_eit_s *)(void *)0;
}

// dvbpsi_ReInitETT
// file tables/atsc_ett.c line 228
static void dvbpsi_ReInitETT(struct dvbpsi_atsc_ett_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_atsc_ett_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_ett == ((struct dvbpsi_atsc_ett_s *)NULL)))
      dvbpsi_atsc_DeleteETT(p_decoder->p_building_ett);

  }

  p_decoder->p_building_ett = (struct dvbpsi_atsc_ett_s *)(void *)0;
}

// dvbpsi_ReInitMGT
// file tables/atsc_mgt.c line 320
static void dvbpsi_ReInitMGT(struct dvbpsi_atsc_mgt_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_atsc_mgt_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_mgt == ((struct dvbpsi_atsc_mgt_s *)NULL)))
      dvbpsi_atsc_DeleteMGT(p_decoder->p_building_mgt);

  }

  p_decoder->p_building_mgt = (struct dvbpsi_atsc_mgt_s *)(void *)0;
}

// dvbpsi_ReInitNIT
// file tables/nit.c line 283
static void dvbpsi_ReInitNIT(struct dvbpsi_nit_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_nit_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_nit == ((struct dvbpsi_nit_s *)NULL)))
      dvbpsi_nit_delete(p_decoder->p_building_nit);

  }

  p_decoder->p_building_nit = (struct dvbpsi_nit_s *)(void *)0;
}

// dvbpsi_ReInitPAT
// file tables/pat.c line 191
static void dvbpsi_ReInitPAT(struct dvbpsi_pat_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_pat_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_pat == ((struct dvbpsi_pat_s *)NULL)))
      dvbpsi_pat_delete(p_decoder->p_building_pat);

  }

  p_decoder->p_building_pat = (struct dvbpsi_pat_s *)(void *)0;
}

// dvbpsi_ReInitPMT
// file tables/pmt.c line 245
static void dvbpsi_ReInitPMT(struct dvbpsi_pmt_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_pmt_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_pmt == ((struct dvbpsi_pmt_s *)NULL)))
      dvbpsi_pmt_delete(p_decoder->p_building_pmt);

  }

  p_decoder->p_building_pmt = (struct dvbpsi_pmt_s *)(void *)0;
}

// dvbpsi_ReInitSDT
// file tables/sdt.c line 264
static void dvbpsi_ReInitSDT(struct dvbpsi_sdt_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_sdt_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_sdt == ((struct dvbpsi_sdt_s *)NULL)))
      dvbpsi_sdt_delete(p_decoder->p_building_sdt);

  }

  p_decoder->p_building_sdt = (struct dvbpsi_sdt_s *)(void *)0;
}

// dvbpsi_ReInitSIS
// file tables/sis.c line 243
static void dvbpsi_ReInitSIS(struct dvbpsi_sis_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_sis_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_sis == ((struct dvbpsi_sis_s *)NULL)))
      dvbpsi_sis_delete(p_decoder->p_building_sis);

  }

  p_decoder->p_building_sis = (struct dvbpsi_sis_s *)(void *)0;
}

// dvbpsi_ReInitSTT
// file tables/atsc_stt.c line 235
static void dvbpsi_ReInitSTT(struct dvbpsi_atsc_stt_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_atsc_stt_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_stt == ((struct dvbpsi_atsc_stt_s *)NULL)))
      dvbpsi_atsc_DeleteSTT(p_decoder->p_building_stt);

  }

  p_decoder->p_building_stt = (struct dvbpsi_atsc_stt_s *)(void *)0;
}

// dvbpsi_ReInitTOT
// file tables/tot.c line 222
static void dvbpsi_ReInitTOT(struct dvbpsi_tot_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_tot_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_tot == ((struct dvbpsi_tot_s *)NULL)))
      dvbpsi_tot_delete(p_decoder->p_building_tot);

  }

  p_decoder->p_building_tot = (struct dvbpsi_tot_s *)(void *)0;
}

// dvbpsi_ReInitVCT
// file tables/atsc_vct.c line 360
static void dvbpsi_ReInitVCT(struct dvbpsi_atsc_vct_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_atsc_vct_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_vct == ((struct dvbpsi_atsc_vct_s *)NULL)))
      dvbpsi_atsc_DeleteVCT(p_decoder->p_building_vct);

  }

  p_decoder->p_building_vct = (struct dvbpsi_atsc_vct_s *)(void *)0;
}

// dvbpsi_ValidPSISection
// file psi.h line 150
_Bool dvbpsi_ValidPSISection(struct dvbpsi_psi_section_s *p_section)
{
  unsigned int i_crc = 0xffffffff;
  unsigned char *p_byte = p_section->p_data;
  for( ; !(p_byte >= p_section->p_payload_end + 4l); p_byte = p_byte + 1l)
    i_crc = i_crc << 8 ^ dvbpsi_crc32_table[(signed long int)(i_crc >> 24 ^ (unsigned int)*p_byte)];
  if(i_crc == 0u)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// dvbpsi_aac_profile_and_level_lookup
// file descriptors/dr_7c.c line 116
static enum dvbpsi_aac_profile_and_level_s dvbpsi_aac_profile_and_level_lookup(const unsigned char value)
{
  enum dvbpsi_aac_profile_and_level_s profile_and_level = (enum dvbpsi_aac_profile_and_level_s)DVBPSI_AAC_PROFILE_RESERVED;
  unsigned int i = (unsigned int)0;
  for( ; !((unsigned long int)i >= 54ul); i = i + 1u)
    if(aac_profile_and_level_table[(signed long int)i].hex == value)
      profile_and_level = aac_profile_and_level_table[(signed long int)i].profile_and_level;

  return profile_and_level;
}

// dvbpsi_aac_profile_and_level_to_hex
// file descriptors/dr_7c.c line 129
static unsigned char dvbpsi_aac_profile_and_level_to_hex(const enum dvbpsi_aac_profile_and_level_s profile_and_level)
{
  unsigned char value = (unsigned char)0x00;
  if((signed int)profile_and_level == DVBPSI_AAC_PROFILE_RESERVED)
    value = (unsigned char)0x56;

  else
  {
    unsigned int i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 54ul); i = i + 1u)
      if(aac_profile_and_level_table[(signed long int)i].profile_and_level == profile_and_level)
        value = aac_profile_and_level_table[(signed long int)i].hex;

  }
  return value;
}

// dvbpsi_aac_type_lookup
// file descriptors/dr_7c.c line 175
static enum dvbpsi_aac_type_s dvbpsi_aac_type_lookup(const unsigned char value)
{
  enum dvbpsi_aac_type_s type = (enum dvbpsi_aac_type_s)0;
  if((signed int)value >= 0x06 && !((signed int)value >= 64))
    type = (enum dvbpsi_aac_type_s)DVBPSI_AAC_RESERVED3;

  else
    if((signed int)value >= 0x4B && !((signed int)value >= 176))
      type = (enum dvbpsi_aac_type_s)DVBPSI_AAC_RESERVED4;

    else
      if((signed int)value >= 0xB0 && !((signed int)value >= 255))
        type = (enum dvbpsi_aac_type_s)DVBPSI_AAC_USER;

      else
        if((signed int)value == 0xFF)
          type = (enum dvbpsi_aac_type_s)DVBPSI_AAC_RESERVED5;

        else
        {
          unsigned int i = (unsigned int)0;
          for( ; !((unsigned long int)i >= 17ul); i = i + 1u)
            if(aac_type_table[(signed long int)i].hex == value)
              type = aac_type_table[(signed long int)i].type;

        }
  return type;
}

// dvbpsi_aac_type_to_hex
// file descriptors/dr_7c.c line 198
static unsigned char dvbpsi_aac_type_to_hex(const enum dvbpsi_aac_type_s type)
{
  unsigned char value = (unsigned char)0;
  if((signed int)type == DVBPSI_AAC_RESERVED3)
    value = (unsigned char)0x06;

  else
    if((signed int)type == DVBPSI_AAC_RESERVED4)
      value = (unsigned char)0x4B;

    else
      if((signed int)type == DVBPSI_AAC_USER)
        value = (unsigned char)0xB0;

      else
        if((signed int)type == DVBPSI_AAC_RESERVED5)
          value = (unsigned char)0xFF;

        else
        {
          unsigned int i = (unsigned int)0;
          for( ; !((unsigned long int)i >= 17ul); i = i + 1u)
            if(aac_type_table[(signed long int)i].type == type)
              value = aac_type_table[(signed long int)i].hex;

        }
  return value;
}

// dvbpsi_atsc_AttachEIT
// file ../../src/tables/atsc_eit.h line 116
_Bool dvbpsi_atsc_AttachEIT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_atsc_eit_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *return_value_dvbpsi_demuxGetSubDec$1;
  return_value_dvbpsi_demuxGetSubDec$1=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(!(return_value_dvbpsi_demuxGetSubDec$1 == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): Already a decoder for (table_id == 0x%02x extension == 0x%04x)", (const void *)"ATSC EIT decoder", i_table_id, i_extension);
    return (_Bool)0;
  }

  else
  {
    struct dvbpsi_atsc_eit_decoder_s *p_eit_decoder;
    void *return_value_dvbpsi_decoder_new$2;
    return_value_dvbpsi_decoder_new$2=dvbpsi_decoder_new((void (*)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *))(void *)0, 0, (const _Bool)1, sizeof(struct dvbpsi_atsc_eit_decoder_s) /*96ul*/ );
    p_eit_decoder = (struct dvbpsi_atsc_eit_decoder_s *)return_value_dvbpsi_decoder_new$2;
    if(p_eit_decoder == ((struct dvbpsi_atsc_eit_decoder_s *)NULL))
      return (_Bool)0;

    else
    {
      struct dvbpsi_demux_subdec_s *p_subdec;
      p_subdec=dvbpsi_NewDemuxSubDecoder(i_table_id, i_extension, dvbpsi_atsc_DetachEIT, dvbpsi_atsc_GatherEITSections, (struct dvbpsi_decoder_s *)p_eit_decoder);
      if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
      {
        dvbpsi_decoder_delete((struct dvbpsi_decoder_s *)p_eit_decoder);
        return (_Bool)0;
      }

      else
      {
        dvbpsi_AttachDemuxSubDecoder(p_demux, p_subdec);
        p_eit_decoder->pf_eit_callback = pf_callback;
        p_eit_decoder->p_cb_data = p_cb_data;
        p_eit_decoder->p_building_eit = (struct dvbpsi_atsc_eit_s *)(void *)0;
        return (_Bool)1;
      }
    }
  }
}

// dvbpsi_atsc_AttachETT
// file ../../src/tables/atsc_ett.h line 103
_Bool dvbpsi_atsc_AttachETT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_atsc_ett_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *return_value_dvbpsi_demuxGetSubDec$1;
  return_value_dvbpsi_demuxGetSubDec$1=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(!(return_value_dvbpsi_demuxGetSubDec$1 == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): Already a decoder for (table_id == 0x%02x extension == 0x%04x)", (const void *)"ATSC ETT decoder", i_table_id, i_extension);
    return (_Bool)0;
  }

  else
  {
    struct dvbpsi_atsc_ett_decoder_s *p_ett_decoder;
    void *return_value_dvbpsi_decoder_new$2;
    return_value_dvbpsi_decoder_new$2=dvbpsi_decoder_new((void (*)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *))(void *)0, 0, (const _Bool)1, sizeof(struct dvbpsi_atsc_ett_decoder_s) /*96ul*/ );
    p_ett_decoder = (struct dvbpsi_atsc_ett_decoder_s *)return_value_dvbpsi_decoder_new$2;
    if(p_ett_decoder == ((struct dvbpsi_atsc_ett_decoder_s *)NULL))
      return (_Bool)0;

    else
    {
      struct dvbpsi_demux_subdec_s *p_subdec;
      p_subdec=dvbpsi_NewDemuxSubDecoder(i_table_id, i_extension, dvbpsi_atsc_DetachETT, dvbpsi_atsc_GatherETTSections, (struct dvbpsi_decoder_s *)p_ett_decoder);
      if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
      {
        dvbpsi_decoder_delete((struct dvbpsi_decoder_s *)p_ett_decoder);
        return (_Bool)0;
      }

      else
      {
        dvbpsi_AttachDemuxSubDecoder(p_demux, p_subdec);
        p_ett_decoder->pf_ett_callback = pf_callback;
        p_ett_decoder->p_cb_data = p_cb_data;
        p_ett_decoder->p_building_ett = (struct dvbpsi_atsc_ett_s *)(void *)0;
        return (_Bool)1;
      }
    }
  }
}

// dvbpsi_atsc_AttachMGT
// file ../../src/tables/atsc_mgt.h line 116
_Bool dvbpsi_atsc_AttachMGT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_atsc_mgt_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *return_value_dvbpsi_demuxGetSubDec$1;
  return_value_dvbpsi_demuxGetSubDec$1=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(!(return_value_dvbpsi_demuxGetSubDec$1 == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): Already a decoder for (table_id == 0x%02x extension == 0x%04x)", (const void *)"ATSC MGT decoder", i_table_id, i_extension);
    return (_Bool)0;
  }

  else
  {
    struct dvbpsi_atsc_mgt_decoder_s *p_mgt_decoder;
    void *return_value_dvbpsi_decoder_new$2;
    return_value_dvbpsi_decoder_new$2=dvbpsi_decoder_new((void (*)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *))(void *)0, 0, (const _Bool)1, sizeof(struct dvbpsi_atsc_mgt_decoder_s) /*96ul*/ );
    p_mgt_decoder = (struct dvbpsi_atsc_mgt_decoder_s *)return_value_dvbpsi_decoder_new$2;
    if(p_mgt_decoder == ((struct dvbpsi_atsc_mgt_decoder_s *)NULL))
      return (_Bool)0;

    else
    {
      struct dvbpsi_demux_subdec_s *p_subdec;
      p_subdec=dvbpsi_NewDemuxSubDecoder(i_table_id, i_extension, dvbpsi_atsc_DetachMGT, dvbpsi_atsc_GatherMGTSections, (struct dvbpsi_decoder_s *)p_mgt_decoder);
      if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
      {
        dvbpsi_decoder_delete((struct dvbpsi_decoder_s *)p_mgt_decoder);
        return (_Bool)0;
      }

      else
      {
        dvbpsi_AttachDemuxSubDecoder(p_demux, p_subdec);
        p_mgt_decoder->pf_mgt_callback = pf_callback;
        p_mgt_decoder->p_cb_data = p_cb_data;
        p_mgt_decoder->p_building_mgt = (struct dvbpsi_atsc_mgt_s *)(void *)0;
        return (_Bool)1;
      }
    }
  }
}

// dvbpsi_atsc_AttachSTT
// file ../../src/tables/atsc_stt.h line 87
_Bool dvbpsi_atsc_AttachSTT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_stt_callback)(void *, struct dvbpsi_atsc_stt_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *return_value_dvbpsi_demuxGetSubDec$1;
  return_value_dvbpsi_demuxGetSubDec$1=dvbpsi_demuxGetSubDec(p_demux, i_table_id, (unsigned short int)0);
  if(!(return_value_dvbpsi_demuxGetSubDec$1 == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): Already a decoder for (table_id == 0x%02x)", (const void *)"ATSC STT decoder", i_table_id);
    return (_Bool)0;
  }

  else
  {
    struct dvbpsi_atsc_stt_decoder_s *p_stt_decoder;
    void *return_value_dvbpsi_decoder_new$2;
    return_value_dvbpsi_decoder_new$2=dvbpsi_decoder_new((void (*)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *))(void *)0, 0, (const _Bool)1, sizeof(struct dvbpsi_atsc_stt_decoder_s) /*88ul*/ );
    p_stt_decoder = (struct dvbpsi_atsc_stt_decoder_s *)return_value_dvbpsi_decoder_new$2;
    if(p_stt_decoder == ((struct dvbpsi_atsc_stt_decoder_s *)NULL))
      return (_Bool)0;

    else
    {
      struct dvbpsi_demux_subdec_s *p_subdec;
      p_subdec=dvbpsi_NewDemuxSubDecoder(i_table_id, i_extension, dvbpsi_atsc_DetachSTT, dvbpsi_atsc_GatherSTTSections, (struct dvbpsi_decoder_s *)p_stt_decoder);
      if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
      {
        dvbpsi_decoder_delete((struct dvbpsi_decoder_s *)p_stt_decoder);
        return (_Bool)0;
      }

      else
      {
        dvbpsi_AttachDemuxSubDecoder(p_demux, p_subdec);
        p_stt_decoder->pf_stt_callback = pf_stt_callback;
        p_stt_decoder->p_cb_data = p_cb_data;
        p_stt_decoder->p_building_stt = (struct dvbpsi_atsc_stt_s *)(void *)0;
        return (_Bool)1;
      }
    }
  }
}

// dvbpsi_atsc_AttachVCT
// file ../../src/tables/atsc_vct.h line 129
_Bool dvbpsi_atsc_AttachVCT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_vct_callback)(void *, struct dvbpsi_atsc_vct_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *return_value_dvbpsi_demuxGetSubDec$1;
  return_value_dvbpsi_demuxGetSubDec$1=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(!(return_value_dvbpsi_demuxGetSubDec$1 == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): Already a decoder for (table_id == 0x%02x,extension == 0x%02x)", (const void *)"ATSC VCT decoder", i_table_id, i_extension);
    return (_Bool)0;
  }

  else
  {
    struct dvbpsi_atsc_vct_decoder_s *p_vct_decoder;
    void *return_value_dvbpsi_decoder_new$2;
    return_value_dvbpsi_decoder_new$2=dvbpsi_decoder_new((void (*)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *))(void *)0, 0, (const _Bool)1, sizeof(struct dvbpsi_atsc_vct_decoder_s) /*88ul*/ );
    p_vct_decoder = (struct dvbpsi_atsc_vct_decoder_s *)return_value_dvbpsi_decoder_new$2;
    if(p_vct_decoder == ((struct dvbpsi_atsc_vct_decoder_s *)NULL))
      return (_Bool)0;

    else
    {
      struct dvbpsi_demux_subdec_s *p_subdec;
      p_subdec=dvbpsi_NewDemuxSubDecoder(i_table_id, i_extension, dvbpsi_atsc_DetachVCT, dvbpsi_atsc_GatherVCTSections, (struct dvbpsi_decoder_s *)p_vct_decoder);
      if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
      {
        dvbpsi_decoder_delete((struct dvbpsi_decoder_s *)p_vct_decoder);
        return (_Bool)0;
      }

      else
      {
        dvbpsi_AttachDemuxSubDecoder(p_demux, p_subdec);
        p_vct_decoder->pf_vct_callback = pf_vct_callback;
        p_vct_decoder->p_cb_data = p_cb_data;
        p_vct_decoder->p_building_vct = (struct dvbpsi_atsc_vct_s *)(void *)0;
        return (_Bool)1;
      }
    }
  }
}

// dvbpsi_atsc_DecodeEITSections
// file tables/atsc_eit.c line 493
static void dvbpsi_atsc_DecodeEITSections(struct dvbpsi_atsc_eit_s *p_eit, struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte;
  unsigned char *p_end;
  while(!(p_section == ((struct dvbpsi_psi_section_s *)NULL)))
  {
    unsigned short int i_number_events = (unsigned short int)p_section->p_payload_start[(signed long int)1];
    unsigned short int i_events_count = (unsigned short int)0;
    unsigned short int i_length = (unsigned short int)0;
    p_byte = p_section->p_payload_start + (signed long int)2;
    for( ; !(p_byte + 4l >= p_section->p_payload_end) && !((signed int)i_events_count >= (signed int)i_number_events); i_events_count = i_events_count + 1)
    {
      struct dvbpsi_atsc_eit_event_s *p_event;
      unsigned short int i_event_id = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)0] & 0x3f) << 8 | (signed int)(unsigned short int)p_byte[(signed long int)1]);
      unsigned int i_start_time = (unsigned int)((signed int)p_byte[(signed long int)2] << 24) | (unsigned int)((signed int)p_byte[(signed long int)3] << 16) | (unsigned int)((signed int)p_byte[(signed long int)4] << 8) | (unsigned int)p_byte[(signed long int)5];
      unsigned char i_etm_location = (unsigned char)(((signed int)p_byte[(signed long int)6] & 0x30) >> 4);
      unsigned int i_length_seconds = (unsigned int)(((signed int)p_byte[(signed long int)6] & 0x0f) << 16) | (unsigned int)((signed int)p_byte[(signed long int)7] << 8) | (unsigned int)p_byte[(signed long int)8];
      unsigned char i_title_length = p_byte[(signed long int)9];
      p_byte = p_byte + (signed long int)10;
      p_event=dvbpsi_atsc_EITAddEvent(p_eit, i_event_id, i_start_time, i_etm_location, i_length_seconds, i_title_length, p_byte);
      p_byte = p_byte + (signed long int)i_title_length;
      i_length = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)0] & 0xf) << 8 | (signed int)p_byte[(signed long int)1]);
      p_byte = p_byte + (signed long int)2;
      p_end = p_byte + (signed long int)i_length;
      if(!(p_section->p_payload_end >= p_end))
        break;

      while(p_end >= p_byte + 2l)
      {
        unsigned char i_tag = p_byte[(signed long int)0];
        unsigned char i_len = p_byte[(signed long int)1];
        if(p_end - p_byte >= (signed long int)(2 + (signed int)i_len))
          dvbpsi_atsc_EITChannelAddDescriptor(p_event, i_tag, i_len, p_byte + (signed long int)2);

        p_byte = p_byte + (signed long int)(2 + (signed int)i_len);
      }
    }
    p_section = p_section->p_next;
  }
}

// dvbpsi_atsc_DecodeETTSections
// file tables/atsc_ett.c line 409
static void dvbpsi_atsc_DecodeETTSections(struct dvbpsi_atsc_ett_s *p_ett, struct dvbpsi_psi_section_s *p_section)
{
  while(!(p_section == ((struct dvbpsi_psi_section_s *)NULL)))
  {
    unsigned short int i_etm_length = (unsigned short int)((signed int)p_section->i_length - 14);
    if(!(p_ett->p_etm_data == ((unsigned char *)NULL)))
      abort();

    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)i_etm_length, sizeof(unsigned char) /*1ul*/ );
    p_ett->p_etm_data = (unsigned char *)return_value_calloc$1;
    if(!(p_ett->p_etm_data == ((unsigned char *)NULL)))
    {
      memcpy((void *)p_ett->p_etm_data, (const void *)(p_section->p_payload_start + (signed long int)5), (unsigned long int)i_etm_length);
      p_ett->i_etm_length = (unsigned int)i_etm_length;
      p_section = p_section->p_next;
    }

  }
}

// dvbpsi_atsc_DecodeMGTSections
// file tables/atsc_mgt.c line 516
static void dvbpsi_atsc_DecodeMGTSections(struct dvbpsi_atsc_mgt_s *p_mgt, struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte;
  unsigned char *p_end;
  while(!(p_section == ((struct dvbpsi_psi_section_s *)NULL)))
  {
    unsigned short int i_tables_defined = (unsigned short int)((signed int)p_section->p_payload_start[(signed long int)1] << 8 | (signed int)p_section->p_payload_start[(signed long int)2]);
    unsigned short int i_tables_count = (unsigned short int)0;
    unsigned short int i_length = (unsigned short int)0;
    p_byte = p_section->p_payload_start + (signed long int)3;
    for( ; !(p_byte + 6l >= p_section->p_payload_end) && !((signed int)i_tables_count >= (signed int)i_tables_defined); i_tables_count = i_tables_count + 1)
    {
      struct dvbpsi_atsc_mgt_table_s *p_table;
      unsigned short int i_table_type = (unsigned short int)((signed int)(unsigned short int)p_byte[(signed long int)0] << 8 | (signed int)(unsigned short int)p_byte[(signed long int)1]);
      unsigned short int i_table_type_pid = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)2] & 0x1f) << 8 | (signed int)(unsigned short int)((signed int)p_byte[(signed long int)3] & 0xff));
      unsigned char i_table_type_version = (unsigned char)((signed int)p_byte[(signed long int)4] & 0x1f);
      unsigned int i_number_bytes = (unsigned int)((signed int)p_byte[(signed long int)5] << 24) | (unsigned int)((signed int)p_byte[(signed long int)6] << 16) | (unsigned int)((signed int)p_byte[(signed long int)7] << 8) | (unsigned int)p_byte[(signed long int)8];
      i_length = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)9] & 0xf) << 8 | (signed int)p_byte[(signed long int)10]);
      p_table=dvbpsi_atsc_MGTAddTable(p_mgt, i_table_type, i_table_type_pid, i_table_type_version, i_number_bytes);
      p_byte = p_byte + (signed long int)11;
      p_end = p_byte + (signed long int)i_length;
      if(!(p_section->p_payload_end >= p_end))
        break;

      while(p_end >= p_byte + 2l)
      {
        unsigned char i_tag = p_byte[(signed long int)0];
        unsigned char i_len = p_byte[(signed long int)1];
        if(p_end - p_byte >= (signed long int)(2 + (signed int)i_len))
          dvbpsi_atsc_MGTTableAddDescriptor(p_table, i_tag, i_len, p_byte + (signed long int)2);

        p_byte = p_byte + (signed long int)(2 + (signed int)i_len);
      }
    }
    i_length = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)0] & 0xf) << 8 | (signed int)p_byte[(signed long int)1]);
    p_byte = p_byte + (signed long int)2;
    p_end = p_byte + (signed long int)i_length;
    while(p_end >= p_byte + 2l)
    {
      unsigned char dvbpsi_atsc_DecodeMGTSections$$1$$1$$2$$i_tag = p_byte[(signed long int)0];
      unsigned char dvbpsi_atsc_DecodeMGTSections$$1$$1$$2$$i_len = p_byte[(signed long int)1];
      if(p_end - p_byte >= (signed long int)(2 + (signed int)i_length))
        dvbpsi_atsc_MGTAddDescriptor(p_mgt, dvbpsi_atsc_DecodeMGTSections$$1$$1$$2$$i_tag, dvbpsi_atsc_DecodeMGTSections$$1$$1$$2$$i_len, p_byte + (signed long int)2);

      p_byte = p_byte + (signed long int)(2 + (signed int)dvbpsi_atsc_DecodeMGTSections$$1$$1$$2$$i_len);
    }
    p_section = p_section->p_next;
  }
}

// dvbpsi_atsc_DecodeSTTSections
// file tables/atsc_stt.c line 421
static void dvbpsi_atsc_DecodeSTTSections(struct dvbpsi_atsc_stt_s *p_stt, struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte;
  unsigned char *p_end;
  unsigned short int i_length = (unsigned short int)0;
  p_byte = p_section->p_payload_start + (signed long int)1;
  p_stt->i_system_time = (unsigned int)p_byte[(signed long int)0] << 24 | (unsigned int)p_byte[(signed long int)1] << 16 | (unsigned int)p_byte[(signed long int)2] << 8 | (unsigned int)p_byte[(signed long int)3];
  p_stt->i_gps_utc_offset = p_byte[(signed long int)4];
  p_stt->i_daylight_savings = (unsigned short int)((signed int)(unsigned short int)p_byte[(signed long int)5] << 16 | (signed int)(unsigned short int)p_byte[(signed long int)6]);
  p_byte = p_byte + (signed long int)7;
  i_length = (unsigned short int)((signed int)p_section->i_length - 17);
  p_end = p_byte + (signed long int)i_length;
  while(p_end >= p_byte + 2l)
  {
    unsigned char i_tag = p_byte[(signed long int)0];
    unsigned char i_len = p_byte[(signed long int)1];
    if(p_end - p_byte >= (signed long int)(2 + (signed int)i_len))
      dvbpsi_atsc_STTAddDescriptor(p_stt, i_tag, i_len, p_byte + (signed long int)2);

    p_byte = p_byte + (signed long int)(2 + (signed int)i_len);
  }
}

// dvbpsi_atsc_DecodeVCTSections
// file tables/atsc_vct.c line 554
static void dvbpsi_atsc_DecodeVCTSections(struct dvbpsi_atsc_vct_s *p_vct, struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte;
  unsigned char *p_end;
  while(!(p_section == ((struct dvbpsi_psi_section_s *)NULL)))
  {
    unsigned short int i_channels_defined = (unsigned short int)p_section->p_payload_start[(signed long int)1];
    unsigned short int i_channels_count = (unsigned short int)0;
    unsigned short int i_length = (unsigned short int)0;
    p_byte = p_section->p_payload_start + (signed long int)2;
    for( ; !(p_byte + 6l >= p_section->p_payload_end) && !((signed int)i_channels_count >= (signed int)i_channels_defined); i_channels_count = i_channels_count + 1)
    {
      struct dvbpsi_atsc_vct_channel_s *p_channel;
      unsigned short int i_major_number = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)14] & 0xf) << 6 | (signed int)(unsigned short int)((signed int)p_byte[(signed long int)15] & 0xfc) >> 2);
      unsigned short int i_minor_number = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)15] & 0x3) << 8 | (signed int)(unsigned short int)p_byte[(signed long int)16]);
      unsigned char i_modulation = p_byte[(signed long int)17];
      unsigned int i_carrier_freq = (unsigned int)((signed int)p_byte[(signed long int)18] << 24) | (unsigned int)((signed int)p_byte[(signed long int)19] << 16) | (unsigned int)((signed int)p_byte[(signed long int)20] << 8) | (unsigned int)p_byte[(signed long int)21];
      unsigned short int i_channel_tsid = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)22] << 8) | (signed int)(unsigned short int)p_byte[(signed long int)23]);
      unsigned short int i_program_number = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)24] << 8) | (signed int)(unsigned short int)p_byte[(signed long int)25]);
      unsigned char i_etm_location = (unsigned char)(((signed int)p_byte[(signed long int)26] & 0xC0) >> 6);
      signed int b_access_controlled = ((signed int)p_byte[(signed long int)26] & 0x20) >> 5;
      signed int b_hidden = ((signed int)p_byte[(signed long int)26] & 0x10) >> 4;
      signed int b_path_select = ((signed int)p_byte[(signed long int)26] & 0x08) >> 3;
      signed int b_out_of_band = ((signed int)p_byte[(signed long int)26] & 0x04) >> 2;
      signed int b_hide_guide = ((signed int)p_byte[(signed long int)26] & 0x02) >> 1;
      unsigned char i_service_type = (unsigned char)((signed int)p_byte[(signed long int)27] & 0x3f);
      unsigned short int i_source_id = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)28] << 8) | (signed int)(unsigned short int)p_byte[(signed long int)29]);
      i_length = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)30] & 0x3) << 8 | (signed int)p_byte[(signed long int)31]);
      p_channel=dvbpsi_atsc_VCTAddChannel(p_vct, p_byte, i_major_number, i_minor_number, i_modulation, i_carrier_freq, i_channel_tsid, i_program_number, i_etm_location, b_access_controlled, b_hidden, b_path_select, b_out_of_band, b_hide_guide, i_service_type, i_source_id);
      p_byte = p_byte + (signed long int)32;
      p_end = p_byte + (signed long int)i_length;
      if(!(p_section->p_payload_end >= p_end))
        break;

      while(p_end >= p_byte + 2l)
      {
        unsigned char i_tag = p_byte[(signed long int)0];
        unsigned char i_len = p_byte[(signed long int)1];
        if(p_end - p_byte >= (signed long int)(2 + (signed int)i_len))
          dvbpsi_atsc_VCTChannelAddDescriptor(p_channel, i_tag, i_len, p_byte + (signed long int)2);

        p_byte = p_byte + (signed long int)(2 + (signed int)i_len);
      }
    }
    i_length = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)0] & 0x3) << 8 | (signed int)p_byte[(signed long int)1]);
    p_byte = p_byte + (signed long int)2;
    p_end = p_byte + (signed long int)i_length;
    while(p_end >= p_byte + 2l)
    {
      unsigned char dvbpsi_atsc_DecodeVCTSections$$1$$1$$2$$i_tag = p_byte[(signed long int)0];
      unsigned char dvbpsi_atsc_DecodeVCTSections$$1$$1$$2$$i_len = p_byte[(signed long int)1];
      if(p_end - p_byte >= (signed long int)(2 + (signed int)dvbpsi_atsc_DecodeVCTSections$$1$$1$$2$$i_len))
        dvbpsi_atsc_VCTAddDescriptor(p_vct, dvbpsi_atsc_DecodeVCTSections$$1$$1$$2$$i_tag, dvbpsi_atsc_DecodeVCTSections$$1$$1$$2$$i_len, p_byte + (signed long int)2);

      p_byte = p_byte + (signed long int)(2 + (signed int)dvbpsi_atsc_DecodeVCTSections$$1$$1$$2$$i_len);
    }
    p_section = p_section->p_next;
  }
}

// dvbpsi_atsc_DeleteEIT
// file ../../src/tables/atsc_eit.h line 187
void dvbpsi_atsc_DeleteEIT(struct dvbpsi_atsc_eit_s *p_eit)
{
  if(!(p_eit == ((struct dvbpsi_atsc_eit_s *)NULL)))
    dvbpsi_atsc_EmptyEIT(p_eit);

  free((void *)p_eit);
  p_eit = (struct dvbpsi_atsc_eit_s *)(void *)0;
}

// dvbpsi_atsc_DeleteETT
// file ../../src/tables/atsc_ett.h line 175
void dvbpsi_atsc_DeleteETT(struct dvbpsi_atsc_ett_s *p_ett)
{
  if(!(p_ett == ((struct dvbpsi_atsc_ett_s *)NULL)))
    dvbpsi_atsc_EmptyETT(p_ett);

  free((void *)p_ett);
  p_ett = (struct dvbpsi_atsc_ett_s *)(void *)0;
}

// dvbpsi_atsc_DeleteMGT
// file ../../src/tables/atsc_mgt.h line 182
void dvbpsi_atsc_DeleteMGT(struct dvbpsi_atsc_mgt_s *p_mgt)
{
  if(!(p_mgt == ((struct dvbpsi_atsc_mgt_s *)NULL)))
    dvbpsi_atsc_EmptyMGT(p_mgt);

  free((void *)p_mgt);
  p_mgt = (struct dvbpsi_atsc_mgt_s *)(void *)0;
}

// dvbpsi_atsc_DeleteSTT
// file ../../src/tables/atsc_stt.h line 153
void dvbpsi_atsc_DeleteSTT(struct dvbpsi_atsc_stt_s *p_stt)
{
  if(!(p_stt == ((struct dvbpsi_atsc_stt_s *)NULL)))
    dvbpsi_atsc_EmptySTT(p_stt);

  free((void *)p_stt);
  p_stt = (struct dvbpsi_atsc_stt_s *)(void *)0;
}

// dvbpsi_atsc_DeleteVCT
// file ../../src/tables/atsc_vct.h line 209
void dvbpsi_atsc_DeleteVCT(struct dvbpsi_atsc_vct_s *p_vct)
{
  if(!(p_vct == ((struct dvbpsi_atsc_vct_s *)NULL)))
    dvbpsi_atsc_EmptyVCT(p_vct);

  free((void *)p_vct);
}

// dvbpsi_atsc_DetachEIT
// file tables/atsc_eit.c line 130
void dvbpsi_atsc_DetachEIT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *p_subdec;
  p_subdec=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No such EIT decoder (table_id == 0x%02x,extension == 0x%04x)", (const void *)"ATSC EIT Decoder", i_table_id, i_extension);

  else
  {
    struct dvbpsi_atsc_eit_decoder_s *p_eit_decoder = (struct dvbpsi_atsc_eit_decoder_s *)p_subdec->p_decoder;
    if(!(p_eit_decoder == ((struct dvbpsi_atsc_eit_decoder_s *)NULL)))
    {
      if(!(p_eit_decoder->p_building_eit == ((struct dvbpsi_atsc_eit_s *)NULL)))
        dvbpsi_atsc_DeleteEIT(p_eit_decoder->p_building_eit);

      p_eit_decoder->p_building_eit = (struct dvbpsi_atsc_eit_s *)(void *)0;
      dvbpsi_DetachDemuxSubDecoder(p_demux, p_subdec);
      dvbpsi_DeleteDemuxSubDecoder(p_subdec);
    }

  }
}

// dvbpsi_atsc_DetachETT
// file tables/atsc_ett.c line 134
void dvbpsi_atsc_DetachETT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *p_subdec;
  p_subdec=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No such ETT decoder (table_id == 0x%02x,extension == 0x%04x)", (const void *)"ATSC ETT Decoder", i_table_id, i_extension);

  else
  {
    struct dvbpsi_atsc_ett_decoder_s *p_ett_decoder = (struct dvbpsi_atsc_ett_decoder_s *)p_subdec->p_decoder;
    if(!(p_ett_decoder == ((struct dvbpsi_atsc_ett_decoder_s *)NULL)))
    {
      if(!(p_ett_decoder->p_building_ett == ((struct dvbpsi_atsc_ett_s *)NULL)))
        dvbpsi_atsc_DeleteETT(p_ett_decoder->p_building_ett);

      p_ett_decoder->p_building_ett = (struct dvbpsi_atsc_ett_s *)(void *)0;
      dvbpsi_DetachDemuxSubDecoder(p_demux, p_subdec);
      dvbpsi_DeleteDemuxSubDecoder(p_subdec);
    }

  }
}

// dvbpsi_atsc_DetachMGT
// file tables/atsc_mgt.c line 134
void dvbpsi_atsc_DetachMGT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *p_subdec;
  p_subdec=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No such MGT decoder (table_id == 0x%02x,extension == 0x%04x)", (const void *)"ATSC MGT Decoder", i_table_id, i_extension);

  else
  {
    struct dvbpsi_atsc_mgt_decoder_s *p_mgt_decoder = (struct dvbpsi_atsc_mgt_decoder_s *)p_subdec->p_decoder;
    if(!(p_mgt_decoder == ((struct dvbpsi_atsc_mgt_decoder_s *)NULL)))
    {
      if(!(p_mgt_decoder->p_building_mgt == ((struct dvbpsi_atsc_mgt_s *)NULL)))
        dvbpsi_atsc_DeleteMGT(p_mgt_decoder->p_building_mgt);

      p_mgt_decoder->p_building_mgt = (struct dvbpsi_atsc_mgt_s *)(void *)0;
      dvbpsi_DetachDemuxSubDecoder(p_demux, p_subdec);
      dvbpsi_DeleteDemuxSubDecoder(p_subdec);
    }

  }
}

// dvbpsi_atsc_DetachSTT
// file tables/atsc_stt.c line 120
void dvbpsi_atsc_DetachSTT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  i_extension = (unsigned short int)0;
  struct dvbpsi_demux_subdec_s *p_subdec;
  p_subdec=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No such STT decoder (table_id == 0x%02x,extension == 0x00)", (const void *)"ATSC STT Decoder", i_table_id);

  else
  {
    struct dvbpsi_atsc_stt_decoder_s *p_stt_decoder = (struct dvbpsi_atsc_stt_decoder_s *)p_subdec->p_decoder;
    if(!(p_stt_decoder == ((struct dvbpsi_atsc_stt_decoder_s *)NULL)))
    {
      if(!(p_stt_decoder->p_building_stt == ((struct dvbpsi_atsc_stt_s *)NULL)))
        dvbpsi_atsc_DeleteSTT(p_stt_decoder->p_building_stt);

      p_stt_decoder->p_building_stt = (struct dvbpsi_atsc_stt_s *)(void *)0;
      dvbpsi_DetachDemuxSubDecoder(p_demux, p_subdec);
      dvbpsi_DeleteDemuxSubDecoder(p_subdec);
    }

  }
}

// dvbpsi_atsc_DetachVCT
// file tables/atsc_vct.c line 144
void dvbpsi_atsc_DetachVCT(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *p_subdec;
  p_subdec=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No such VCT decoder (table_id == 0x%02x,extension == 0x%04x)", (const void *)"ATSC VCT Decoder", i_table_id, i_extension);

  else
  {
    struct dvbpsi_atsc_vct_decoder_s *p_vct_decoder = (struct dvbpsi_atsc_vct_decoder_s *)p_subdec->p_decoder;
    if(!(p_vct_decoder == ((struct dvbpsi_atsc_vct_decoder_s *)NULL)))
    {
      if(!(p_vct_decoder->p_building_vct == ((struct dvbpsi_atsc_vct_s *)NULL)))
        dvbpsi_atsc_DeleteVCT(p_vct_decoder->p_building_vct);

      p_vct_decoder->p_building_vct = (struct dvbpsi_atsc_vct_s *)(void *)0;
      dvbpsi_DetachDemuxSubDecoder(p_demux, p_subdec);
      dvbpsi_DeleteDemuxSubDecoder(p_subdec);
    }

  }
}

// dvbpsi_atsc_EITAddEvent
// file tables/atsc_eit.c line 229
static struct dvbpsi_atsc_eit_event_s * dvbpsi_atsc_EITAddEvent(struct dvbpsi_atsc_eit_s *p_eit, unsigned short int i_event_id, unsigned int i_start_time, unsigned char i_etm_location, unsigned int i_length_seconds, unsigned char i_title_length, unsigned char *p_title)
{
  struct dvbpsi_atsc_eit_event_s *p_event;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_atsc_eit_event_s) /*296ul*/ );
  p_event = (struct dvbpsi_atsc_eit_event_s *)return_value_malloc$1;
  if(!(p_event == ((struct dvbpsi_atsc_eit_event_s *)NULL)))
  {
    p_event->i_event_id = i_event_id;
    p_event->i_start_time = i_start_time;
    p_event->i_etm_location = i_etm_location;
    p_event->i_length_seconds = i_length_seconds;
    p_event->i_title_length = i_title_length;
    memcpy((void *)p_event->i_title, (const void *)p_title, (unsigned long int)i_title_length);
    p_event->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
    p_event->p_next = (struct dvbpsi_atsc_eit_event_s *)(void *)0;
    if(p_eit->p_first_event == ((struct dvbpsi_atsc_eit_event_s *)NULL))
      p_eit->p_first_event = p_event;

    else
    {
      struct dvbpsi_atsc_eit_event_s *p_last_event = p_eit->p_first_event;
      for( ; !(p_last_event->p_next == ((struct dvbpsi_atsc_eit_event_s *)NULL)); p_last_event = p_last_event->p_next)
        ;
      p_last_event->p_next = p_event;
    }
  }

  return p_event;
}

// dvbpsi_atsc_EITChannelAddDescriptor
// file tables/atsc_eit.c line 273
static struct dvbpsi_descriptor_s * dvbpsi_atsc_EITChannelAddDescriptor(struct dvbpsi_atsc_eit_event_s *p_event, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_event->p_first_descriptor=dvbpsi_AddDescriptor(p_event->p_first_descriptor, p_descriptor);
    /* assertion p_event->p_first_descriptor */
    assert(p_event->p_first_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
    if(p_event->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
      return p_descriptor;
  }
}

// dvbpsi_atsc_EmptyEIT
// file tables/atsc_eit.c line 199
void dvbpsi_atsc_EmptyEIT(struct dvbpsi_atsc_eit_s *p_eit)
{
  struct dvbpsi_atsc_eit_event_s *p_event = p_eit->p_first_event;
  while(!(p_event == ((struct dvbpsi_atsc_eit_event_s *)NULL)))
  {
    struct dvbpsi_atsc_eit_event_s *p_tmp = p_event->p_next;
    dvbpsi_DeleteDescriptors(p_event->p_first_descriptor);
    free((void *)p_event);
    p_event = p_tmp;
  }
  p_eit->p_first_event = (struct dvbpsi_atsc_eit_event_s *)(void *)0;
  dvbpsi_DeleteDescriptors(p_eit->p_first_descriptor);
  p_eit->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_atsc_EmptyETT
// file tables/atsc_ett.c line 205
void dvbpsi_atsc_EmptyETT(struct dvbpsi_atsc_ett_s *p_ett)
{
  /* assertion p_ett */
  assert(p_ett != ((struct dvbpsi_atsc_ett_s *)NULL));
  dvbpsi_DeleteDescriptors(p_ett->p_first_descriptor);
  free((void *)p_ett->p_etm_data);
  p_ett->i_etm_length = (unsigned int)0;
  p_ett->p_etm_data = (unsigned char *)(void *)0;
  p_ett->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_atsc_EmptyMGT
// file tables/atsc_mgt.c line 200
void dvbpsi_atsc_EmptyMGT(struct dvbpsi_atsc_mgt_s *p_mgt)
{
  struct dvbpsi_atsc_mgt_table_s *p_table = p_mgt->p_first_table;
  while(!(p_table == ((struct dvbpsi_atsc_mgt_table_s *)NULL)))
  {
    struct dvbpsi_atsc_mgt_table_s *p_tmp = p_table->p_next;
    dvbpsi_DeleteDescriptors(p_table->p_first_descriptor);
    free((void *)p_table);
    p_table = p_tmp;
  }
  dvbpsi_DeleteDescriptors(p_mgt->p_first_descriptor);
  p_mgt->p_first_table = (struct dvbpsi_atsc_mgt_table_s *)(void *)0;
  p_mgt->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_atsc_EmptySTT
// file tables/atsc_stt.c line 191
void dvbpsi_atsc_EmptySTT(struct dvbpsi_atsc_stt_s *p_stt)
{
  dvbpsi_DeleteDescriptors(p_stt->p_first_descriptor);
  p_stt->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_atsc_EmptyVCT
// file tables/atsc_vct.c line 215
void dvbpsi_atsc_EmptyVCT(struct dvbpsi_atsc_vct_s *p_vct)
{
  struct dvbpsi_atsc_vct_channel_s *p_channel = p_vct->p_first_channel;
  dvbpsi_DeleteDescriptors(p_vct->p_first_descriptor);
  p_vct->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
  while(!(p_channel == ((struct dvbpsi_atsc_vct_channel_s *)NULL)))
  {
    struct dvbpsi_atsc_vct_channel_s *p_tmp = p_channel->p_next;
    dvbpsi_DeleteDescriptors(p_channel->p_first_descriptor);
    free((void *)p_channel);
    p_channel = p_tmp;
  }
  p_vct->p_first_channel = (struct dvbpsi_atsc_vct_channel_s *)(void *)0;
}

// dvbpsi_atsc_GatherEITSections
// file tables/atsc_eit.c line 382
static void dvbpsi_atsc_GatherEITSections(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  _Bool return_value_dvbpsi_CheckPSISection$1;
  return_value_dvbpsi_CheckPSISection$1=dvbpsi_CheckPSISection(p_dvbpsi, p_section, (const unsigned char)0xCB, "ATSC EIT decoder");
  if(return_value_dvbpsi_CheckPSISection$1 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
    struct dvbpsi_atsc_eit_decoder_s *p_eit_decoder = (struct dvbpsi_atsc_eit_decoder_s *)p_decoder;
    if(p_eit_decoder == ((struct dvbpsi_atsc_eit_decoder_s *)NULL))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No decoder specified", (const void *)"ATSC EIT decoder");
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      if(!(p_demux->b_discontinuity == (_Bool)0))
      {
        dvbpsi_ReInitEIT$link1(p_eit_decoder, (const _Bool)1);
        p_eit_decoder->b_discontinuity = (_Bool)0;
        p_demux->b_discontinuity = (_Bool)0;
      }

      else
        if(!(p_eit_decoder->p_building_eit == ((struct dvbpsi_atsc_eit_s *)NULL)))
        {
          _Bool return_value_dvbpsi_CheckEIT$2;
          return_value_dvbpsi_CheckEIT$2=dvbpsi_CheckEIT$link1(p_dvbpsi, p_eit_decoder, p_section);
          if(!(return_value_dvbpsi_CheckEIT$2 == (_Bool)0))
            dvbpsi_ReInitEIT$link1(p_eit_decoder, (const _Bool)1);

        }

        else
          if(!(p_eit_decoder->b_current_valid == (_Bool)0))
          {
            if(p_eit_decoder->current_eit.i_version == p_section->i_version)
            {
              if(p_eit_decoder->current_eit.b_current_next == p_section->b_current_next)
              {
                dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"ATSC EIT decoder", p_section->i_number);
                dvbpsi_DeletePSISections(p_section);
                goto __CPROVER_DUMP_L9;
              }

            }

          }

      _Bool return_value_dvbpsi_AddSectionEIT$3;
      return_value_dvbpsi_AddSectionEIT$3=dvbpsi_AddSectionEIT$link1(p_dvbpsi, p_eit_decoder, p_section);
      if(return_value_dvbpsi_AddSectionEIT$3 == (_Bool)0)
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"ATSC EIT decoder", p_section->i_number);
        dvbpsi_DeletePSISections(p_section);
      }

      else
      {
        _Bool return_value_dvbpsi_decoder_psi_sections_completed$4;
        return_value_dvbpsi_decoder_psi_sections_completed$4=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_eit_decoder);
        if(!(return_value_dvbpsi_decoder_psi_sections_completed$4 == (_Bool)0))
        {
          /* assertion p_eit_decoder->pf_eit_callback */
          assert(p_eit_decoder->pf_eit_callback != ((void (*)(void *, struct dvbpsi_atsc_eit_s *))NULL));
          p_eit_decoder->current_eit = *p_eit_decoder->p_building_eit;
          p_eit_decoder->b_current_valid = (_Bool)1;
          dvbpsi_atsc_DecodeEITSections(p_eit_decoder->p_building_eit, p_eit_decoder->p_sections);
          p_eit_decoder->pf_eit_callback(p_eit_decoder->p_cb_data, p_eit_decoder->p_building_eit);
          dvbpsi_ReInitEIT$link1(p_eit_decoder, (const _Bool)0);
          /* assertion p_eit_decoder->p_sections == ((void *)0) */
          assert(p_eit_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
        }

      }
    }
  }

__CPROVER_DUMP_L9:
  ;
}

// dvbpsi_atsc_GatherETTSections
// file tables/atsc_ett.c line 320
static void dvbpsi_atsc_GatherETTSections(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  _Bool return_value_dvbpsi_CheckPSISection$1;
  return_value_dvbpsi_CheckPSISection$1=dvbpsi_CheckPSISection(p_dvbpsi, p_section, (const unsigned char)0xCC, "ATSC ETT decoder");
  if(return_value_dvbpsi_CheckPSISection$1 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
    struct dvbpsi_atsc_ett_decoder_s *p_ett_decoder = (struct dvbpsi_atsc_ett_decoder_s *)p_decoder;
    if(p_ett_decoder == ((struct dvbpsi_atsc_ett_decoder_s *)NULL))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No decoder specified", (const void *)"ATSC ETT decoder");
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      if(!(p_demux->b_discontinuity == (_Bool)0))
      {
        dvbpsi_ReInitETT(p_ett_decoder, (const _Bool)1);
        p_ett_decoder->b_discontinuity = (_Bool)0;
        p_demux->b_discontinuity = (_Bool)0;
      }

      else
        if(!(p_ett_decoder->p_building_ett == ((struct dvbpsi_atsc_ett_s *)NULL)))
        {
          _Bool return_value_dvbpsi_CheckETT$2;
          return_value_dvbpsi_CheckETT$2=dvbpsi_CheckETT(p_dvbpsi, p_ett_decoder, p_section);
          if(!(return_value_dvbpsi_CheckETT$2 == (_Bool)0))
            dvbpsi_ReInitETT(p_ett_decoder, (const _Bool)1);

        }

        else
          if(!(p_ett_decoder->b_current_valid == (_Bool)0))
          {
            if(p_ett_decoder->current_ett.i_version == p_section->i_version)
            {
              if(p_ett_decoder->current_ett.b_current_next == p_section->b_current_next)
              {
                dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"ATSC ETT decoder", p_section->i_number);
                dvbpsi_DeletePSISections(p_section);
                goto __CPROVER_DUMP_L9;
              }

            }

          }

      _Bool return_value_dvbpsi_AddSectionETT$3;
      return_value_dvbpsi_AddSectionETT$3=dvbpsi_AddSectionETT(p_dvbpsi, p_ett_decoder, p_section);
      if(return_value_dvbpsi_AddSectionETT$3 == (_Bool)0)
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"ATSC ETT decoder", p_section->i_number);
        dvbpsi_DeletePSISections(p_section);
      }

      else
      {
        _Bool return_value_dvbpsi_decoder_psi_sections_completed$4;
        return_value_dvbpsi_decoder_psi_sections_completed$4=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_ett_decoder);
        if(!(return_value_dvbpsi_decoder_psi_sections_completed$4 == (_Bool)0))
        {
          /* assertion p_ett_decoder->pf_ett_callback */
          assert(p_ett_decoder->pf_ett_callback != ((void (*)(void *, struct dvbpsi_atsc_ett_s *))NULL));
          p_ett_decoder->current_ett = *p_ett_decoder->p_building_ett;
          p_ett_decoder->b_current_valid = (_Bool)1;
          dvbpsi_atsc_DecodeETTSections(p_ett_decoder->p_building_ett, p_ett_decoder->p_sections);
          p_ett_decoder->pf_ett_callback(p_ett_decoder->p_cb_data, p_ett_decoder->p_building_ett);
          dvbpsi_ReInitETT(p_ett_decoder, (const _Bool)0);
          /* assertion p_ett_decoder->p_sections == ((void *)0) */
          assert(p_ett_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
        }

      }
    }
  }

__CPROVER_DUMP_L9:
  ;
}

// dvbpsi_atsc_GatherMGTSections
// file tables/atsc_mgt.c line 405
static void dvbpsi_atsc_GatherMGTSections(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  _Bool return_value_dvbpsi_CheckPSISection$1;
  return_value_dvbpsi_CheckPSISection$1=dvbpsi_CheckPSISection(p_dvbpsi, p_section, (const unsigned char)0xC7, "ATSC MGT decoder");
  if(return_value_dvbpsi_CheckPSISection$1 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
    struct dvbpsi_atsc_mgt_decoder_s *p_mgt_decoder = (struct dvbpsi_atsc_mgt_decoder_s *)p_decoder;
    if(p_mgt_decoder == ((struct dvbpsi_atsc_mgt_decoder_s *)NULL))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No decoder specified", (const void *)"ATSC MGT decoder");
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      if(!(p_demux->b_discontinuity == (_Bool)0))
      {
        dvbpsi_ReInitMGT(p_mgt_decoder, (const _Bool)1);
        p_mgt_decoder->b_discontinuity = (_Bool)0;
        p_demux->b_discontinuity = (_Bool)0;
      }

      else
        if(!(p_mgt_decoder->p_building_mgt == ((struct dvbpsi_atsc_mgt_s *)NULL)))
        {
          _Bool return_value_dvbpsi_CheckMGT$2;
          return_value_dvbpsi_CheckMGT$2=dvbpsi_CheckMGT(p_dvbpsi, p_mgt_decoder, p_section);
          if(!(return_value_dvbpsi_CheckMGT$2 == (_Bool)0))
            dvbpsi_ReInitMGT(p_mgt_decoder, (const _Bool)1);

        }

        else
          if(!(p_mgt_decoder->b_current_valid == (_Bool)0))
          {
            if(p_mgt_decoder->current_mgt.i_version == p_section->i_version)
            {
              if(p_mgt_decoder->current_mgt.b_current_next == p_section->b_current_next)
              {
                dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"ATSC MGT decoder", p_section->i_number);
                dvbpsi_DeletePSISections(p_section);
                goto __CPROVER_DUMP_L9;
              }

            }

          }

      _Bool return_value_dvbpsi_AddSectionMGT$3;
      return_value_dvbpsi_AddSectionMGT$3=dvbpsi_AddSectionMGT(p_dvbpsi, p_mgt_decoder, p_section);
      if(return_value_dvbpsi_AddSectionMGT$3 == (_Bool)0)
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"ATSC MGT decoder", p_section->i_number);
        dvbpsi_DeletePSISections(p_section);
      }

      else
      {
        _Bool return_value_dvbpsi_decoder_psi_sections_completed$4;
        return_value_dvbpsi_decoder_psi_sections_completed$4=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_mgt_decoder);
        if(!(return_value_dvbpsi_decoder_psi_sections_completed$4 == (_Bool)0))
        {
          /* assertion p_mgt_decoder->pf_mgt_callback */
          assert(p_mgt_decoder->pf_mgt_callback != ((void (*)(void *, struct dvbpsi_atsc_mgt_s *))NULL));
          p_mgt_decoder->current_mgt = *p_mgt_decoder->p_building_mgt;
          p_mgt_decoder->b_current_valid = (_Bool)1;
          dvbpsi_atsc_DecodeMGTSections(p_mgt_decoder->p_building_mgt, p_mgt_decoder->p_sections);
          p_mgt_decoder->pf_mgt_callback(p_mgt_decoder->p_cb_data, p_mgt_decoder->p_building_mgt);
          dvbpsi_ReInitMGT(p_mgt_decoder, (const _Bool)0);
          /* assertion p_mgt_decoder->p_sections == ((void *)0) */
          assert(p_mgt_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
        }

      }
    }
  }

__CPROVER_DUMP_L9:
  ;
}

// dvbpsi_atsc_GatherSTTSections
// file tables/atsc_stt.c line 310
static void dvbpsi_atsc_GatherSTTSections(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  _Bool return_value_dvbpsi_CheckPSISection$1;
  return_value_dvbpsi_CheckPSISection$1=dvbpsi_CheckPSISection(p_dvbpsi, p_section, (const unsigned char)0xCD, "ATSC STT decoder");
  if(return_value_dvbpsi_CheckPSISection$1 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
    struct dvbpsi_atsc_stt_decoder_s *p_stt_decoder = (struct dvbpsi_atsc_stt_decoder_s *)p_decoder;
    if(p_stt_decoder == ((struct dvbpsi_atsc_stt_decoder_s *)NULL))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No decoder specified", (const void *)"ATSC STT decoder");
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      if(!(p_demux->b_discontinuity == (_Bool)0))
      {
        dvbpsi_ReInitSTT(p_stt_decoder, (const _Bool)1);
        p_stt_decoder->b_discontinuity = (_Bool)0;
        p_demux->b_discontinuity = (_Bool)0;
      }

      else
        if(!(p_stt_decoder->p_building_stt == ((struct dvbpsi_atsc_stt_s *)NULL)))
        {
          _Bool return_value_dvbpsi_CheckSTT$2;
          return_value_dvbpsi_CheckSTT$2=dvbpsi_CheckSTT(p_dvbpsi, p_stt_decoder, p_section);
          if(!(return_value_dvbpsi_CheckSTT$2 == (_Bool)0))
            dvbpsi_ReInitSTT(p_stt_decoder, (const _Bool)1);

        }

        else
          if(!(p_stt_decoder->b_current_valid == (_Bool)0))
          {
            if(p_stt_decoder->current_stt.i_version == p_section->i_version)
            {
              if(p_stt_decoder->current_stt.b_current_next == p_section->b_current_next)
              {
                dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"ATSC STT decoder", p_section->i_number);
                dvbpsi_DeletePSISections(p_section);
                goto __CPROVER_DUMP_L9;
              }

            }

          }

      _Bool return_value_dvbpsi_AddSectionSTT$3;
      return_value_dvbpsi_AddSectionSTT$3=dvbpsi_AddSectionSTT(p_dvbpsi, p_stt_decoder, p_section);
      if(return_value_dvbpsi_AddSectionSTT$3 == (_Bool)0)
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"ATSC STT decoder", p_section->i_number);
        dvbpsi_DeletePSISections(p_section);
      }

      else
      {
        _Bool return_value_dvbpsi_decoder_psi_sections_completed$4;
        return_value_dvbpsi_decoder_psi_sections_completed$4=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_stt_decoder);
        if(!(return_value_dvbpsi_decoder_psi_sections_completed$4 == (_Bool)0))
        {
          /* assertion p_stt_decoder->pf_stt_callback */
          assert(p_stt_decoder->pf_stt_callback != ((void (*)(void *, struct dvbpsi_atsc_stt_s *))NULL));
          p_stt_decoder->current_stt = *p_stt_decoder->p_building_stt;
          p_stt_decoder->b_current_valid = (_Bool)1;
          dvbpsi_atsc_DecodeSTTSections(p_stt_decoder->p_building_stt, p_stt_decoder->p_sections);
          p_stt_decoder->pf_stt_callback(p_stt_decoder->p_cb_data, p_stt_decoder->p_building_stt);
          dvbpsi_ReInitSTT(p_stt_decoder, (const _Bool)0);
          /* assertion p_stt_decoder->p_sections == ((void *)0) */
          assert(p_stt_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
        }

      }
    }
  }

__CPROVER_DUMP_L9:
  ;
}

// dvbpsi_atsc_GatherVCTSections
// file tables/atsc_vct.c line 445
static void dvbpsi_atsc_GatherVCTSections(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  unsigned char i_table_id;
  _Bool tmp_if_expr$1;
  if((signed int)p_section->i_table_id == 0xC8)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)p_section->i_table_id == 0xC9 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (signed int)p_section->i_table_id;

  else
    tmp_if_expr$2 = 0xC8;
  i_table_id = (const unsigned char)tmp_if_expr$2;
  _Bool return_value_dvbpsi_CheckPSISection$3;
  return_value_dvbpsi_CheckPSISection$3=dvbpsi_CheckPSISection(p_dvbpsi, p_section, i_table_id, "ATSC VCT decoder");
  if(return_value_dvbpsi_CheckPSISection$3 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
    struct dvbpsi_atsc_vct_decoder_s *p_vct_decoder = (struct dvbpsi_atsc_vct_decoder_s *)p_decoder;
    if(!(p_demux->b_discontinuity == (_Bool)0))
    {
      dvbpsi_ReInitVCT(p_vct_decoder, (const _Bool)1);
      p_vct_decoder->b_discontinuity = (_Bool)0;
      p_demux->b_discontinuity = (_Bool)0;
    }

    else
      if(!(p_vct_decoder->p_building_vct == ((struct dvbpsi_atsc_vct_s *)NULL)))
      {
        _Bool return_value_dvbpsi_CheckVCT$4;
        return_value_dvbpsi_CheckVCT$4=dvbpsi_CheckVCT(p_dvbpsi, p_vct_decoder, p_section);
        if(!(return_value_dvbpsi_CheckVCT$4 == (_Bool)0))
          dvbpsi_ReInitVCT(p_vct_decoder, (const _Bool)1);

      }

      else
        if(!(p_vct_decoder->b_current_valid == (_Bool)0))
        {
          if(p_vct_decoder->current_vct.i_version == p_section->i_version)
          {
            if(p_vct_decoder->current_vct.b_current_next == p_section->b_current_next)
            {
              dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"ATSC VCT decoder", p_section->i_number);
              dvbpsi_DeletePSISections(p_section);
              goto __CPROVER_DUMP_L12;
            }

          }

        }

    _Bool return_value_dvbpsi_AddSectionVCT$5;
    return_value_dvbpsi_AddSectionVCT$5=dvbpsi_AddSectionVCT(p_dvbpsi, p_vct_decoder, p_section);
    if(return_value_dvbpsi_AddSectionVCT$5 == (_Bool)0)
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"ATSC_VCT decoder", p_section->i_number);
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      _Bool return_value_dvbpsi_decoder_psi_sections_completed$6;
      return_value_dvbpsi_decoder_psi_sections_completed$6=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_vct_decoder);
      if(!(return_value_dvbpsi_decoder_psi_sections_completed$6 == (_Bool)0))
      {
        /* assertion p_vct_decoder->pf_vct_callback */
        assert(p_vct_decoder->pf_vct_callback != ((void (*)(void *, struct dvbpsi_atsc_vct_s *))NULL));
        p_vct_decoder->current_vct = *p_vct_decoder->p_building_vct;
        p_vct_decoder->b_current_valid = (_Bool)1;
        dvbpsi_atsc_DecodeVCTSections(p_vct_decoder->p_building_vct, p_vct_decoder->p_sections);
        p_vct_decoder->pf_vct_callback(p_vct_decoder->p_cb_data, p_vct_decoder->p_building_vct);
        dvbpsi_ReInitVCT(p_vct_decoder, (const _Bool)0);
        /* assertion p_vct_decoder->p_sections == ((void *)0) */
        assert(p_vct_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
      }

    }
  }

__CPROVER_DUMP_L12:
  ;
}

// dvbpsi_atsc_InitEIT
// file tables/atsc_eit.c line 165
void dvbpsi_atsc_InitEIT(struct dvbpsi_atsc_eit_s *p_eit, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, unsigned char i_protocol, unsigned short int i_source_id, _Bool b_current_next)
{
  /* assertion p_eit */
  assert(p_eit != ((struct dvbpsi_atsc_eit_s *)NULL));
  p_eit->i_table_id = i_table_id;
  p_eit->i_extension = i_extension;
  p_eit->i_version = i_version;
  p_eit->b_current_next = b_current_next;
  p_eit->i_protocol = i_protocol;
  p_eit->i_source_id = i_source_id;
  p_eit->p_first_event = (struct dvbpsi_atsc_eit_event_s *)(void *)0;
  p_eit->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_atsc_InitETT
// file tables/atsc_ett.c line 170
void dvbpsi_atsc_InitETT(struct dvbpsi_atsc_ett_s *p_ett, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, unsigned char i_protocol, unsigned int i_etm_id, _Bool b_current_next)
{
  /* assertion p_ett */
  assert(p_ett != ((struct dvbpsi_atsc_ett_s *)NULL));
  p_ett->i_table_id = i_table_id;
  p_ett->i_extension = i_extension;
  p_ett->i_version = i_version;
  p_ett->b_current_next = b_current_next;
  p_ett->i_protocol = i_protocol;
  p_ett->i_etm_id = i_etm_id;
  p_ett->i_etm_length = (unsigned int)0;
  p_ett->p_etm_data = (unsigned char *)(void *)0;
  p_ett->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_atsc_InitMGT
// file tables/atsc_mgt.c line 170
void dvbpsi_atsc_InitMGT(struct dvbpsi_atsc_mgt_s *p_mgt, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, unsigned char i_protocol, _Bool b_current_next)
{
  /* assertion p_mgt */
  assert(p_mgt != ((struct dvbpsi_atsc_mgt_s *)NULL));
  p_mgt->i_table_id = i_table_id;
  p_mgt->i_extension = i_extension;
  p_mgt->i_version = i_version;
  p_mgt->b_current_next = b_current_next;
  p_mgt->i_protocol = i_protocol;
  p_mgt->p_first_table = (struct dvbpsi_atsc_mgt_table_s *)(void *)0;
  p_mgt->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_atsc_InitSTT
// file tables/atsc_stt.c line 157
void dvbpsi_atsc_InitSTT(struct dvbpsi_atsc_stt_s *p_stt, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next)
{
  /* assertion p_stt */
  assert(p_stt != ((struct dvbpsi_atsc_stt_s *)NULL));
  p_stt->i_table_id = i_table_id;
  p_stt->i_extension = i_extension;
  p_stt->i_version = i_version;
  p_stt->b_current_next = b_current_next;
  p_stt->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_atsc_InitVCT
// file tables/atsc_vct.c line 194
void dvbpsi_atsc_InitVCT(struct dvbpsi_atsc_vct_s *p_vct, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_protocol, _Bool b_cable_vct, unsigned char i_version, _Bool b_current_next)
{
  /* assertion p_vct */
  assert(p_vct != ((struct dvbpsi_atsc_vct_s *)NULL));
  p_vct->i_table_id = i_table_id;
  p_vct->i_extension = i_extension;
  p_vct->i_version = i_version;
  p_vct->b_current_next = b_current_next;
  p_vct->i_protocol = i_protocol;
  p_vct->b_cable_vct = b_cable_vct;
  p_vct->p_first_channel = (struct dvbpsi_atsc_vct_channel_s *)(void *)0;
  p_vct->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_atsc_MGTAddDescriptor
// file tables/atsc_mgt.c line 229
static struct dvbpsi_descriptor_s * dvbpsi_atsc_MGTAddDescriptor(struct dvbpsi_atsc_mgt_s *p_mgt, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_mgt->p_first_descriptor=dvbpsi_AddDescriptor(p_mgt->p_first_descriptor, p_descriptor);
    /* assertion p_mgt->p_first_descriptor */
    assert(p_mgt->p_first_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
    if(p_mgt->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
      return p_descriptor;
  }
}

// dvbpsi_atsc_MGTAddTable
// file tables/atsc_mgt.c line 253
static struct dvbpsi_atsc_mgt_table_s * dvbpsi_atsc_MGTAddTable(struct dvbpsi_atsc_mgt_s *p_mgt, unsigned short int i_table_type, unsigned short int i_table_type_pid, unsigned char i_table_type_version, unsigned int i_number_bytes)
{
  struct dvbpsi_atsc_mgt_table_s *p_table;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_atsc_mgt_table_s) /*32ul*/ );
  p_table = (struct dvbpsi_atsc_mgt_table_s *)return_value_malloc$1;
  if(!(p_table == ((struct dvbpsi_atsc_mgt_table_s *)NULL)))
  {
    p_table->i_table_type = i_table_type;
    p_table->i_table_type_pid = i_table_type_pid;
    p_table->i_table_type_version = i_table_type_version;
    p_table->i_number_bytes = i_number_bytes;
    p_table->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
    p_table->p_next = (struct dvbpsi_atsc_mgt_table_s *)(void *)0;
    if(p_mgt->p_first_table == ((struct dvbpsi_atsc_mgt_table_s *)NULL))
      p_mgt->p_first_table = p_table;

    else
    {
      struct dvbpsi_atsc_mgt_table_s *p_last_table = p_mgt->p_first_table;
      for( ; !(p_last_table->p_next == ((struct dvbpsi_atsc_mgt_table_s *)NULL)); p_last_table = p_last_table->p_next)
        ;
      p_last_table->p_next = p_table;
    }
  }

  return p_table;
}

// dvbpsi_atsc_MGTTableAddDescriptor
// file tables/atsc_mgt.c line 292
static struct dvbpsi_descriptor_s * dvbpsi_atsc_MGTTableAddDescriptor(struct dvbpsi_atsc_mgt_table_s *p_table, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(!(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)))
  {
    if(p_table->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      p_table->p_first_descriptor = p_descriptor;

    else
    {
      struct dvbpsi_descriptor_s *p_last_descriptor = p_table->p_first_descriptor;
      for( ; !(p_last_descriptor->p_next == ((struct dvbpsi_descriptor_s *)NULL)); p_last_descriptor = p_last_descriptor->p_next)
        ;
      p_last_descriptor->p_next = p_descriptor;
    }
  }

  return p_descriptor;
}

// dvbpsi_atsc_NewEIT
// file tables/atsc_eit.c line 182
struct dvbpsi_atsc_eit_s * dvbpsi_atsc_NewEIT(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, unsigned char i_protocol, unsigned short int i_source_id, _Bool b_current_next)
{
  struct dvbpsi_atsc_eit_s *p_eit;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_atsc_eit_s) /*32ul*/ );
  p_eit = (struct dvbpsi_atsc_eit_s *)return_value_malloc$1;
  if(!(p_eit == ((struct dvbpsi_atsc_eit_s *)NULL)))
    dvbpsi_atsc_InitEIT(p_eit, i_table_id, i_extension, i_version, i_protocol, i_source_id, b_current_next);

  return p_eit;
}

// dvbpsi_atsc_NewETT
// file tables/atsc_ett.c line 188
struct dvbpsi_atsc_ett_s * dvbpsi_atsc_NewETT(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, unsigned char i_protocol, unsigned int i_etm_id, _Bool b_current_next)
{
  struct dvbpsi_atsc_ett_s *p_ett;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_atsc_ett_s) /*32ul*/ );
  p_ett = (struct dvbpsi_atsc_ett_s *)return_value_malloc$1;
  if(!(p_ett == ((struct dvbpsi_atsc_ett_s *)NULL)))
    dvbpsi_atsc_InitETT(p_ett, i_table_id, i_extension, i_version, i_protocol, i_etm_id, b_current_next);

  return p_ett;
}

// dvbpsi_atsc_NewMGT
// file tables/atsc_mgt.c line 185
struct dvbpsi_atsc_mgt_s * dvbpsi_atsc_NewMGT(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, unsigned char i_protocol, _Bool b_current_next)
{
  struct dvbpsi_atsc_mgt_s *p_mgt;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct dvbpsi_atsc_mgt_s) /*32ul*/ );
  p_mgt = (struct dvbpsi_atsc_mgt_s *)return_value_calloc$1;
  if(!(p_mgt == ((struct dvbpsi_atsc_mgt_s *)NULL)))
    dvbpsi_atsc_InitMGT(p_mgt, i_table_id, i_extension, i_version, i_protocol, b_current_next);

  return p_mgt;
}

// dvbpsi_atsc_NewSTT
// file tables/atsc_stt.c line 176
struct dvbpsi_atsc_stt_s * dvbpsi_atsc_NewSTT(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next)
{
  struct dvbpsi_atsc_stt_s *p_stt;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_atsc_stt_s) /*24ul*/ );
  p_stt = (struct dvbpsi_atsc_stt_s *)return_value_malloc$1;
  if(!(p_stt == ((struct dvbpsi_atsc_stt_s *)NULL)))
    dvbpsi_atsc_InitSTT(p_stt, i_table_id, i_extension, i_version, b_current_next);

  return p_stt;
}

// dvbpsi_atsc_NewVCT
// file tables/atsc_vct.c line 179
struct dvbpsi_atsc_vct_s * dvbpsi_atsc_NewVCT(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_protocol, _Bool b_cable_vct, unsigned char i_version, _Bool b_current_next)
{
  struct dvbpsi_atsc_vct_s *p_vct;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_atsc_vct_s) /*24ul*/ );
  p_vct = (struct dvbpsi_atsc_vct_s *)return_value_malloc$1;
  if(!(p_vct == ((struct dvbpsi_atsc_vct_s *)NULL)))
    dvbpsi_atsc_InitVCT(p_vct, i_table_id, i_extension, i_protocol, b_cable_vct, i_version, b_current_next);

  return p_vct;
}

// dvbpsi_atsc_STTAddDescriptor
// file tables/atsc_stt.c line 215
struct dvbpsi_descriptor_s * dvbpsi_atsc_STTAddDescriptor(struct dvbpsi_atsc_stt_s *p_stt, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_stt->p_first_descriptor=dvbpsi_AddDescriptor(p_stt->p_first_descriptor, p_descriptor);
    /* assertion p_stt->p_first_descriptor */
    assert(p_stt->p_first_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
    if(p_stt->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
      return p_descriptor;
  }
}

// dvbpsi_atsc_VCTAddChannel
// file tables/atsc_vct.c line 271
static struct dvbpsi_atsc_vct_channel_s * dvbpsi_atsc_VCTAddChannel(struct dvbpsi_atsc_vct_s *p_vct, unsigned char *p_short_name, unsigned short int i_major_number, unsigned short int i_minor_number, unsigned char i_modulation, unsigned int i_carrier_freq, unsigned short int i_channel_tsid, unsigned short int i_program_number, unsigned char i_etm_location, signed int b_access_controlled, signed int b_hidden, signed int b_path_select, signed int b_out_of_band, signed int b_hide_guide, unsigned char i_service_type, unsigned short int i_source_id)
{
  struct dvbpsi_atsc_vct_channel_s *p_channel;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_atsc_vct_channel_s) /*56ul*/ );
  p_channel = (struct dvbpsi_atsc_vct_channel_s *)return_value_malloc$1;
  if(!(p_channel == ((struct dvbpsi_atsc_vct_channel_s *)NULL)))
  {
    memcpy((void *)p_channel->i_short_name, (const void *)p_short_name, sizeof(unsigned short int) /*2ul*/  * (unsigned long int)7);
    p_channel->i_major_number = i_major_number;
    p_channel->i_minor_number = i_minor_number;
    p_channel->i_modulation = i_modulation;
    p_channel->i_carrier_freq = i_carrier_freq;
    p_channel->i_channel_tsid = i_channel_tsid;
    p_channel->i_program_number = i_program_number;
    p_channel->i_etm_location = i_etm_location;
    p_channel->b_access_controlled = (_Bool)b_access_controlled;
    p_channel->b_path_select = (_Bool)b_path_select;
    p_channel->b_out_of_band = (_Bool)b_out_of_band;
    p_channel->b_hidden = (_Bool)b_hidden;
    p_channel->b_hide_guide = (_Bool)b_hide_guide;
    p_channel->i_service_type = i_service_type;
    p_channel->i_source_id = i_source_id;
    p_channel->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
    p_channel->p_next = (struct dvbpsi_atsc_vct_channel_s *)(void *)0;
    if(p_vct->p_first_channel == ((struct dvbpsi_atsc_vct_channel_s *)NULL))
      p_vct->p_first_channel = p_channel;

    else
    {
      struct dvbpsi_atsc_vct_channel_s *p_last_channel = p_vct->p_first_channel;
      for( ; !(p_last_channel->p_next == ((struct dvbpsi_atsc_vct_channel_s *)NULL)); p_last_channel = p_last_channel->p_next)
        ;
      p_last_channel->p_next = p_channel;
    }
  }

  return p_channel;
}

// dvbpsi_atsc_VCTAddDescriptor
// file tables/atsc_vct.c line 248
static struct dvbpsi_descriptor_s * dvbpsi_atsc_VCTAddDescriptor(struct dvbpsi_atsc_vct_s *p_vct, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_vct->p_first_descriptor=dvbpsi_AddDescriptor(p_vct->p_first_descriptor, p_descriptor);
    /* assertion p_vct->p_first_descriptor */
    assert(p_vct->p_first_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
    if(p_vct->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
      return p_descriptor;
  }
}

// dvbpsi_atsc_VCTChannelAddDescriptor
// file tables/atsc_vct.c line 332
static struct dvbpsi_descriptor_s * dvbpsi_atsc_VCTChannelAddDescriptor(struct dvbpsi_atsc_vct_channel_s *p_channel, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(!(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)))
  {
    if(p_channel->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      p_channel->p_first_descriptor = p_descriptor;

    else
    {
      struct dvbpsi_descriptor_s *p_last_descriptor = p_channel->p_first_descriptor;
      for( ; !(p_last_descriptor->p_next == ((struct dvbpsi_descriptor_s *)NULL)); p_last_descriptor = p_last_descriptor->p_next)
        ;
      p_last_descriptor->p_next = p_descriptor;
    }
  }

  return p_descriptor;
}

// dvbpsi_bat_attach
// file ../../src/tables/bat.h line 128
_Bool dvbpsi_bat_attach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_bat_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *return_value_dvbpsi_demuxGetSubDec$1;
  return_value_dvbpsi_demuxGetSubDec$1=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(!(return_value_dvbpsi_demuxGetSubDec$1 == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): Already a decoder for (table_id == 0x%02x,extension == 0x%02x)", (const void *)"BAT decoder", i_table_id, i_extension);
    return (_Bool)0;
  }

  else
  {
    struct dvbpsi_bat_decoder_s *p_bat_decoder;
    void *return_value_dvbpsi_decoder_new$2;
    return_value_dvbpsi_decoder_new$2=dvbpsi_decoder_new((void (*)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *))(void *)0, 0, (const _Bool)1, sizeof(struct dvbpsi_bat_decoder_s) /*88ul*/ );
    p_bat_decoder = (struct dvbpsi_bat_decoder_s *)return_value_dvbpsi_decoder_new$2;
    if(p_bat_decoder == ((struct dvbpsi_bat_decoder_s *)NULL))
      return (_Bool)0;

    else
    {
      struct dvbpsi_demux_subdec_s *p_subdec;
      p_subdec=dvbpsi_NewDemuxSubDecoder(i_table_id, i_extension, dvbpsi_bat_detach, dvbpsi_bat_sections_gather, (struct dvbpsi_decoder_s *)p_bat_decoder);
      if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
      {
        dvbpsi_decoder_delete((struct dvbpsi_decoder_s *)p_bat_decoder);
        return (_Bool)0;
      }

      else
      {
        dvbpsi_AttachDemuxSubDecoder(p_demux, p_subdec);
        p_bat_decoder->pf_bat_callback = pf_callback;
        p_bat_decoder->p_cb_data = p_cb_data;
        p_bat_decoder->p_building_bat = (struct dvbpsi_bat_s *)(void *)0;
        return (_Bool)1;
      }
    }
  }
}

// dvbpsi_bat_bouquet_descriptor_add
// file tables/bat.c line 205
struct dvbpsi_descriptor_s * dvbpsi_bat_bouquet_descriptor_add(struct dvbpsi_bat_s *p_bat, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_bat->p_first_descriptor=dvbpsi_AddDescriptor(p_bat->p_first_descriptor, p_descriptor);
    /* assertion p_bat->p_first_descriptor */
    assert(p_bat->p_first_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
    if(p_bat->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
      return p_descriptor;
  }
}

// dvbpsi_bat_delete
// file ../../src/tables/bat.h line 192
void dvbpsi_bat_delete(struct dvbpsi_bat_s *p_bat)
{
  if(!(p_bat == ((struct dvbpsi_bat_s *)NULL)))
    dvbpsi_bat_empty(p_bat);

  free((void *)p_bat);
}

// dvbpsi_bat_detach
// file tables/bat.c line 106
void dvbpsi_bat_detach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *p_subdec;
  p_subdec=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No such BAT decoder (table_id == 0x%02x,extension == 0x%02x)", (const void *)"BAT Decoder", i_table_id, i_extension);

  else
  {
    struct dvbpsi_bat_decoder_s *p_bat_decoder = (struct dvbpsi_bat_decoder_s *)p_subdec->p_decoder;
    if(!(p_bat_decoder->p_building_bat == ((struct dvbpsi_bat_s *)NULL)))
      dvbpsi_bat_delete(p_bat_decoder->p_building_bat);

    p_bat_decoder->p_building_bat = (struct dvbpsi_bat_s *)(void *)0;
    dvbpsi_DetachDemuxSubDecoder(p_demux, p_subdec);
    dvbpsi_DeleteDemuxSubDecoder(p_subdec);
  }
}

// dvbpsi_bat_empty
// file tables/bat.c line 171
void dvbpsi_bat_empty(struct dvbpsi_bat_s *p_bat)
{
  struct dvbpsi_bat_ts_s *p_ts = p_bat->p_first_ts;
  dvbpsi_DeleteDescriptors(p_bat->p_first_descriptor);
  p_bat->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
  while(!(p_ts == ((struct dvbpsi_bat_ts_s *)NULL)))
  {
    struct dvbpsi_bat_ts_s *p_tmp = p_ts->p_next;
    dvbpsi_DeleteDescriptors(p_ts->p_first_descriptor);
    free((void *)p_ts);
    p_ts = p_tmp;
  }
  p_bat->p_first_ts = (struct dvbpsi_bat_ts_s *)(void *)0;
}

// dvbpsi_bat_init
// file tables/bat.c line 139
void dvbpsi_bat_init(struct dvbpsi_bat_s *p_bat, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next)
{
  /* assertion p_bat */
  assert(p_bat != ((struct dvbpsi_bat_s *)NULL));
  p_bat->i_table_id = i_table_id;
  p_bat->i_extension = i_extension;
  p_bat->i_version = i_version;
  p_bat->b_current_next = b_current_next;
  p_bat->p_first_ts = (struct dvbpsi_bat_ts_s *)(void *)0;
  p_bat->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_bat_new
// file tables/bat.c line 157
struct dvbpsi_bat_s * dvbpsi_bat_new(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next)
{
  struct dvbpsi_bat_s *p_bat;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_bat_s) /*24ul*/ );
  p_bat = (struct dvbpsi_bat_s *)return_value_malloc$1;
  if(!(p_bat == ((struct dvbpsi_bat_s *)NULL)))
    dvbpsi_bat_init(p_bat, i_table_id, i_extension, i_version, b_current_next);

  return p_bat;
}

// dvbpsi_bat_sections_decode
// file tables/bat.c line 467
void dvbpsi_bat_sections_decode(struct dvbpsi_bat_s *p_bat, struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte;
  unsigned char *p_end;
  for( ; !(p_section == ((struct dvbpsi_psi_section_s *)NULL)); p_section = p_section->p_next)
  {
    p_byte = p_section->p_payload_start + (signed long int)2;
    p_end = p_byte + (signed long int)((signed int)(unsigned short int)((signed int)p_section->p_payload_start[(signed long int)0] & 0x0f) << 8 | (signed int)p_section->p_payload_start[(signed long int)1]);
    if(!(p_section->p_payload_end >= p_end))
      p_end = p_section->p_payload_end;

    while(p_end >= p_byte + 2l)
    {
      unsigned char dvbpsi_bat_sections_decode$$1$$1$$1$$i_tag = p_byte[(signed long int)0];
      unsigned char dvbpsi_bat_sections_decode$$1$$1$$1$$i_length = p_byte[(signed long int)1];
      if(p_end - p_byte >= (signed long int)(2 + (signed int)dvbpsi_bat_sections_decode$$1$$1$$1$$i_length))
        dvbpsi_bat_bouquet_descriptor_add(p_bat, dvbpsi_bat_sections_decode$$1$$1$$1$$i_tag, dvbpsi_bat_sections_decode$$1$$1$$1$$i_length, p_byte + (signed long int)2);

      p_byte = p_byte + (signed long int)(2 + (signed int)dvbpsi_bat_sections_decode$$1$$1$$1$$i_length);
    }
    p_end = (signed long int)2 + p_byte + (signed long int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)0] & 0x0f) << 8 | (signed int)p_byte[(signed long int)1]);
    if(!(p_section->p_payload_end >= p_end))
      p_end = p_section->p_payload_end;

    p_byte = p_byte + (signed long int)2;
    while(p_end >= p_byte + 6l)
    {
      unsigned char *p_end2;
      unsigned short int i_ts_id = (unsigned short int)((signed int)(unsigned short int)p_byte[(signed long int)0] << 8 | (signed int)p_byte[(signed long int)1]);
      unsigned short int i_orig_network_id = (unsigned short int)((signed int)(unsigned short int)p_byte[(signed long int)2] << 8 | (signed int)p_byte[(signed long int)3]);
      unsigned short int i_transport_descriptors_length = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)4] & 0x0f) << 8 | (signed int)p_byte[(signed long int)5]);
      struct dvbpsi_bat_ts_s *p_ts;
      p_ts=dvbpsi_bat_ts_add(p_bat, i_ts_id, i_orig_network_id);
      if(p_ts == ((struct dvbpsi_bat_ts_s *)NULL))
        break;

      p_byte = p_byte + (signed long int)6;
      p_end2 = p_byte + (signed long int)i_transport_descriptors_length;
      if(!(p_section->p_payload_end >= p_end2))
        p_end2 = p_section->p_payload_end;

      while(p_end2 >= p_byte + 2l)
      {
        unsigned char i_tag = p_byte[(signed long int)0];
        unsigned char i_length = p_byte[(signed long int)1];
        if(p_end2 - p_byte >= (signed long int)(2 + (signed int)i_length))
          dvbpsi_bat_ts_descriptor_add(p_ts, i_tag, i_length, p_byte + (signed long int)2);

        p_byte = p_byte + (signed long int)(2 + (signed int)i_length);
      }
    }
  }
}

// dvbpsi_bat_sections_gather
// file tables/bat.c line 364
void dvbpsi_bat_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_bat_decoder_s *p_bat_decoder = (struct dvbpsi_bat_decoder_s *)p_decoder;
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  _Bool return_value_dvbpsi_CheckPSISection$1;
  return_value_dvbpsi_CheckPSISection$1=dvbpsi_CheckPSISection(p_dvbpsi, p_section, (const unsigned char)0x4a, "BAT decoder");
  if(return_value_dvbpsi_CheckPSISection$1 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    if(!(p_demux->b_discontinuity == (_Bool)0))
    {
      dvbpsi_ReInitBAT(p_bat_decoder, (const _Bool)1);
      p_bat_decoder->b_discontinuity = (_Bool)0;
      p_demux->b_discontinuity = (_Bool)0;
    }

    else
      if(!(p_bat_decoder->p_building_bat == ((struct dvbpsi_bat_s *)NULL)))
      {
        _Bool return_value_dvbpsi_CheckBAT$2;
        return_value_dvbpsi_CheckBAT$2=dvbpsi_CheckBAT(p_dvbpsi, p_bat_decoder, p_section);
        if(!(return_value_dvbpsi_CheckBAT$2 == (_Bool)0))
          dvbpsi_ReInitBAT(p_bat_decoder, (const _Bool)1);

      }

      else
        if(!(p_bat_decoder->b_current_valid == (_Bool)0))
        {
          if(p_bat_decoder->current_bat.i_version == p_section->i_version)
          {
            if(p_bat_decoder->current_bat.b_current_next == p_section->b_current_next)
            {
              dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"BAT decoder", p_section->i_number);
              dvbpsi_DeletePSISections(p_section);
              goto __CPROVER_DUMP_L8;
            }

          }

        }

    _Bool return_value_dvbpsi_AddSectionBAT$3;
    return_value_dvbpsi_AddSectionBAT$3=dvbpsi_AddSectionBAT(p_dvbpsi, p_bat_decoder, p_section);
    if(return_value_dvbpsi_AddSectionBAT$3 == (_Bool)0)
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"BAT decoder", p_section->i_number);
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      _Bool return_value_dvbpsi_decoder_psi_sections_completed$4;
      return_value_dvbpsi_decoder_psi_sections_completed$4=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_bat_decoder);
      if(!(return_value_dvbpsi_decoder_psi_sections_completed$4 == (_Bool)0))
      {
        /* assertion p_bat_decoder->pf_bat_callback */
        assert(p_bat_decoder->pf_bat_callback != ((void (*)(void *, struct dvbpsi_bat_s *))NULL));
        p_bat_decoder->current_bat = *p_bat_decoder->p_building_bat;
        p_bat_decoder->b_current_valid = (_Bool)1;
        dvbpsi_bat_sections_decode(p_bat_decoder->p_building_bat, p_bat_decoder->p_sections);
        p_bat_decoder->pf_bat_callback(p_bat_decoder->p_cb_data, p_bat_decoder->p_building_bat);
        dvbpsi_ReInitBAT(p_bat_decoder, (const _Bool)0);
        /* assertion p_bat_decoder->p_sections == ((void *)0) */
        assert(p_bat_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
      }

    }
  }

__CPROVER_DUMP_L8:
  ;
}

// dvbpsi_bat_sections_generate
// file tables/bat.c line 533
struct dvbpsi_psi_section_s * dvbpsi_bat_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_bat_s *p_bat)
{
  struct dvbpsi_psi_section_s *p_result;
  p_result=dvbpsi_NewPSISection(1024);
  struct dvbpsi_psi_section_s *p_current = p_result;
  struct dvbpsi_psi_section_s *p_prev;
  struct dvbpsi_descriptor_s *p_descriptor = p_bat->p_first_descriptor;
  struct dvbpsi_bat_ts_s *p_ts = p_bat->p_first_ts;
  unsigned short int i_bouquet_descriptors_length;
  unsigned short int i_transport_stream_loop_length;
  unsigned char *p_transport_stream_loop_length;
  if(p_current == ((struct dvbpsi_psi_section_s *)NULL))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed to allocate new PSI section", (const void *)"BAT encoder");
    return (struct dvbpsi_psi_section_s *)(void *)0;
  }

  else
  {
    p_current->i_table_id = (unsigned char)0x4a;
    p_current->b_syntax_indicator = (_Bool)1;
    p_current->b_private_indicator = (_Bool)1;
    p_current->i_length = (unsigned short int)13;
    p_current->i_extension = p_bat->i_extension;
    p_current->i_version = p_bat->i_version;
    p_current->b_current_next = p_bat->b_current_next;
    p_current->i_number = (unsigned char)0;
    p_current->p_payload_end = p_current->p_payload_end + (signed long int)10;
    p_current->p_payload_start = p_current->p_data + (signed long int)8;
    for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
    {
      if((p_current->p_payload_end - p_current->p_data) + (signed long int)p_descriptor->i_length >= 1019l)
      {
        i_bouquet_descriptors_length = (unsigned short int)((p_current->p_payload_end - p_current->p_payload_start) - (signed long int)2);
        p_current->p_data[(signed long int)8] = (unsigned char)((signed int)i_bouquet_descriptors_length >> 8 | 0xf0);
        p_current->p_data[(signed long int)9] = (unsigned char)i_bouquet_descriptors_length;
        p_current->p_payload_end[(signed long int)0] = (unsigned char)0;
        p_current->p_payload_end[(signed long int)1] = (unsigned char)0;
        p_current->p_payload_end = p_current->p_payload_end + (signed long int)2;
        p_prev = p_current;
        p_current=dvbpsi_NewPSISection(1024);
        if(p_current == ((struct dvbpsi_psi_section_s *)NULL))
        {
          dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed to allocate new PSI section", (const void *)"BAT encoder");
          goto error;
        }

        p_prev->p_next = p_current;
        p_current->i_table_id = (unsigned char)0x4a;
        p_current->b_syntax_indicator = (_Bool)1;
        p_current->b_private_indicator = (_Bool)1;
        p_current->i_length = (unsigned short int)13;
        p_current->i_extension = p_bat->i_extension;
        p_current->i_version = p_bat->i_version;
        p_current->b_current_next = p_bat->b_current_next;
        p_current->i_number = (unsigned char)((signed int)p_prev->i_number + 1);
        p_current->p_payload_end = p_current->p_payload_end + (signed long int)10;
        p_current->p_payload_start = p_current->p_data + (signed long int)8;
      }

      p_current->p_payload_end[(signed long int)0] = p_descriptor->i_tag;
      p_current->p_payload_end[(signed long int)1] = p_descriptor->i_length;
      memcpy((void *)(p_current->p_payload_end + (signed long int)2), (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
      p_current->p_payload_end = p_current->p_payload_end + (signed long int)((signed int)p_descriptor->i_length + 2);
      p_current->i_length = p_current->i_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
    }
    i_bouquet_descriptors_length = (unsigned short int)((p_current->p_payload_end - p_current->p_payload_start) - (signed long int)2);
    p_current->p_data[(signed long int)8] = (unsigned char)((signed int)i_bouquet_descriptors_length >> 8 | 0xf0);
    p_current->p_data[(signed long int)9] = (unsigned char)i_bouquet_descriptors_length;
    p_transport_stream_loop_length = p_current->p_payload_end;
    p_current->p_payload_end = p_current->p_payload_end + (signed long int)2;
    while(!(p_ts == ((struct dvbpsi_bat_ts_s *)NULL)))
    {
      unsigned char *p_ts_start = p_current->p_payload_end;
      unsigned short int i_transport_descriptors_length = (unsigned short int)5;
      p_descriptor = p_ts->p_first_descriptor;
      for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
      {
        if((p_ts_start - p_current->p_data) + (signed long int)i_transport_descriptors_length >= 1021l)
          break;

        i_transport_descriptors_length = i_transport_descriptors_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
      }
      if(!(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)))
      {
        if(!(p_ts_start - p_current->p_data == 12l))
        {
          if(!((signed int)i_transport_descriptors_length >= 1009))
          {
            i_transport_stream_loop_length = (unsigned short int)((p_current->p_payload_end - p_transport_stream_loop_length) - (signed long int)2);
            p_transport_stream_loop_length[(signed long int)0] = (unsigned char)((signed int)i_transport_stream_loop_length >> 8 | 0xf0);
            p_transport_stream_loop_length[(signed long int)1] = (unsigned char)i_transport_stream_loop_length;
            dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): create a new section to carry more TS descriptors", (const void *)"BAT generator");
            p_prev = p_current;
            p_current=dvbpsi_NewPSISection(1024);
            p_prev->p_next = p_current;
            p_current->i_table_id = (unsigned char)0x4a;
            p_current->b_syntax_indicator = (_Bool)1;
            p_current->b_private_indicator = (_Bool)1;
            p_current->i_length = (unsigned short int)13;
            p_current->i_extension = p_bat->i_extension;
            p_current->i_version = p_bat->i_version;
            p_current->b_current_next = p_bat->b_current_next;
            p_current->i_number = (unsigned char)((signed int)p_prev->i_number + 1);
            p_current->p_payload_end = p_current->p_payload_end + (signed long int)10;
            p_current->p_payload_start = p_current->p_data + (signed long int)8;
            p_current->p_data[(signed long int)8] = (unsigned char)0xf0;
            p_current->p_data[(signed long int)9] = (unsigned char)0x00;
            p_transport_stream_loop_length = p_current->p_payload_end;
            p_current->p_payload_end = p_current->p_payload_end + (signed long int)2;
            p_ts_start = p_current->p_payload_end;
          }

        }

      }

      p_ts_start[(signed long int)0] = (unsigned char)((signed int)p_ts->i_ts_id >> 8);
      p_ts_start[(signed long int)1] = (unsigned char)((signed int)p_ts->i_ts_id & 0xff);
      p_ts_start[(signed long int)2] = (unsigned char)((signed int)p_ts->i_orig_network_id >> 8);
      p_ts_start[(signed long int)3] = (unsigned char)((signed int)p_ts->i_orig_network_id & 0xff);
      p_current->p_payload_end = p_current->p_payload_end + (signed long int)6;
      p_current->i_length = p_current->i_length + (unsigned short int)6;
      p_descriptor = p_ts->p_first_descriptor;
      for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
      {
        if((p_current->p_payload_end - p_current->p_data) + (signed long int)p_descriptor->i_length >= 1019l)
          break;

        p_current->p_payload_end[(signed long int)0] = p_descriptor->i_tag;
        p_current->p_payload_end[(signed long int)1] = p_descriptor->i_length;
        memcpy((void *)(p_current->p_payload_end + (signed long int)2), (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
        p_current->p_payload_end = p_current->p_payload_end + (signed long int)((signed int)p_descriptor->i_length + 2);
        p_current->i_length = p_current->i_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
      }
      if(!(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)))
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): unable to carry all the TS descriptors", (const void *)"BAT generator");

      i_transport_descriptors_length = (unsigned short int)((p_current->p_payload_end - p_ts_start) - (signed long int)5);
      p_ts_start[(signed long int)4] = (unsigned char)((signed int)i_transport_descriptors_length >> 8 | 0xf0);
      p_ts_start[(signed long int)5] = (unsigned char)i_transport_descriptors_length;
      p_ts = p_ts->p_next;
    }
    i_transport_stream_loop_length = (unsigned short int)((p_current->p_payload_end - p_transport_stream_loop_length) - (signed long int)2);
    p_transport_stream_loop_length[(signed long int)0] = (unsigned char)((signed int)i_transport_stream_loop_length >> 8 | 0xf0);
    p_transport_stream_loop_length[(signed long int)1] = (unsigned char)i_transport_stream_loop_length;
    p_prev = p_result;
    for( ; !(p_prev == ((struct dvbpsi_psi_section_s *)NULL)); p_prev = p_prev->p_next)
    {
      p_prev->i_last_number = p_current->i_number;
      dvbpsi_BuildPSISection(p_dvbpsi, p_prev);
    }
    return p_result;

  error:
    ;
    p_prev = p_result;
    dvbpsi_DeletePSISections(p_prev);
    return (struct dvbpsi_psi_section_s *)(void *)0;
  }
}

// dvbpsi_bat_ts_add
// file tables/bat.c line 228
struct dvbpsi_bat_ts_s * dvbpsi_bat_ts_add(struct dvbpsi_bat_s *p_bat, unsigned short int i_ts_id, unsigned short int i_orig_network_id)
{
  struct dvbpsi_bat_ts_s *p_ts;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_bat_ts_s) /*24ul*/ );
  p_ts = (struct dvbpsi_bat_ts_s *)return_value_malloc$1;
  if(p_ts == ((struct dvbpsi_bat_ts_s *)NULL))
    return (struct dvbpsi_bat_ts_s *)(void *)0;

  else
  {
    p_ts->i_ts_id = i_ts_id;
    p_ts->i_orig_network_id = i_orig_network_id;
    p_ts->p_next = (struct dvbpsi_bat_ts_s *)(void *)0;
    p_ts->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
    if(p_bat->p_first_ts == ((struct dvbpsi_bat_ts_s *)NULL))
      p_bat->p_first_ts = p_ts;

    else
    {
      struct dvbpsi_bat_ts_s *p_last_ts = p_bat->p_first_ts;
      for( ; !(p_last_ts->p_next == ((struct dvbpsi_bat_ts_s *)NULL)); p_last_ts = p_last_ts->p_next)
        ;
      p_last_ts->p_next = p_ts;
    }
    return p_ts;
  }
}

// dvbpsi_bat_ts_descriptor_add
// file tables/bat.c line 260
struct dvbpsi_descriptor_s * dvbpsi_bat_ts_descriptor_add(struct dvbpsi_bat_ts_s *p_bat, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    if(p_bat->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      p_bat->p_first_descriptor = p_descriptor;

    else
    {
      struct dvbpsi_descriptor_s *p_last_descriptor = p_bat->p_first_descriptor;
      for( ; !(p_last_descriptor->p_next == ((struct dvbpsi_descriptor_s *)NULL)); p_last_descriptor = p_last_descriptor->p_next)
        ;
      p_last_descriptor->p_next = p_descriptor;
    }
    return p_descriptor;
  }
}

// dvbpsi_cat_attach
// file ../../src/tables/cat.h line 88
_Bool dvbpsi_cat_attach(struct dvbpsi_s *p_dvbpsi, void (*pf_callback)(void *, struct dvbpsi_cat_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder == ((void *)0) */
  assert(p_dvbpsi->p_decoder == (struct dvbpsi_decoder_s *)(void *)0);
  struct dvbpsi_cat_decoder_s *p_cat_decoder;
  void *return_value_dvbpsi_decoder_new$1;
  return_value_dvbpsi_decoder_new$1=dvbpsi_decoder_new(dvbpsi_cat_sections_gather, 1024, (const _Bool)1, sizeof(struct dvbpsi_cat_decoder_s) /*80ul*/ );
  p_cat_decoder = (struct dvbpsi_cat_decoder_s *)return_value_dvbpsi_decoder_new$1;
  if(p_cat_decoder == ((struct dvbpsi_cat_decoder_s *)NULL))
    return (_Bool)0;

  else
  {
    p_cat_decoder->pf_cat_callback = pf_callback;
    p_cat_decoder->p_cb_data = p_cb_data;
    p_cat_decoder->p_building_cat = (struct dvbpsi_cat_s *)(void *)0;
    p_dvbpsi->p_decoder = (struct dvbpsi_decoder_s *)p_cat_decoder;
    return (_Bool)1;
  }
}

// dvbpsi_cat_delete
// file ../../src/tables/cat.h line 147
void dvbpsi_cat_delete(struct dvbpsi_cat_s *p_cat)
{
  if(!(p_cat == ((struct dvbpsi_cat_s *)NULL)))
    dvbpsi_cat_empty(p_cat);

  free((void *)p_cat);
}

// dvbpsi_cat_descriptor_add
// file tables/cat.c line 153
struct dvbpsi_descriptor_s * dvbpsi_cat_descriptor_add(struct dvbpsi_cat_s *p_cat, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_cat->p_first_descriptor=dvbpsi_AddDescriptor(p_cat->p_first_descriptor, p_descriptor);
    /* assertion p_cat->p_first_descriptor */
    assert(p_cat->p_first_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
    if(p_cat->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
      return p_descriptor;
  }
}

// dvbpsi_cat_detach
// file ../../src/tables/cat.h line 103
void dvbpsi_cat_detach(struct dvbpsi_s *p_dvbpsi)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_cat_decoder_s *p_cat_decoder = (struct dvbpsi_cat_decoder_s *)p_dvbpsi->p_decoder;
  if(!(p_cat_decoder->p_building_cat == ((struct dvbpsi_cat_s *)NULL)))
    dvbpsi_cat_delete(p_cat_decoder->p_building_cat);

  p_cat_decoder->p_building_cat = (struct dvbpsi_cat_s *)(void *)0;
  dvbpsi_decoder_delete(p_dvbpsi->p_decoder);
  p_dvbpsi->p_decoder = (struct dvbpsi_decoder_s *)(void *)0;
}

// dvbpsi_cat_empty
// file tables/cat.c line 130
void dvbpsi_cat_empty(struct dvbpsi_cat_s *p_cat)
{
  dvbpsi_DeleteDescriptors(p_cat->p_first_descriptor);
  p_cat->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_cat_init
// file tables/cat.c line 103
void dvbpsi_cat_init(struct dvbpsi_cat_s *p_cat, unsigned char i_version, _Bool b_current_next)
{
  /* assertion p_cat */
  assert(p_cat != ((struct dvbpsi_cat_s *)NULL));
  p_cat->i_version = i_version;
  p_cat->b_current_next = b_current_next;
  p_cat->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_cat_new
// file tables/cat.c line 117
struct dvbpsi_cat_s * dvbpsi_cat_new(unsigned char i_version, _Bool b_current_next)
{
  struct dvbpsi_cat_s *p_cat;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_cat_s) /*16ul*/ );
  p_cat = (struct dvbpsi_cat_s *)return_value_malloc$1;
  if(!(p_cat == ((struct dvbpsi_cat_s *)NULL)))
    dvbpsi_cat_init(p_cat, i_version, b_current_next);

  return p_cat;
}

// dvbpsi_cat_sections_decode
// file tables/cat.c line 340
void dvbpsi_cat_sections_decode(struct dvbpsi_cat_s *p_cat, struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte;
  for( ; !(p_section == ((struct dvbpsi_psi_section_s *)NULL)); p_section = p_section->p_next)
  {
    p_byte = p_section->p_payload_start;
    while(p_section->p_payload_end >= p_byte)
    {
      unsigned char i_tag = p_byte[(signed long int)0];
      unsigned char i_length = p_byte[(signed long int)1];
      if(p_section->p_payload_end - p_byte >= (signed long int)(2 + (signed int)i_length))
        dvbpsi_cat_descriptor_add(p_cat, i_tag, i_length, p_byte + (signed long int)2);

      p_byte = p_byte + (signed long int)(2 + (signed int)i_length);
    }
  }
}

// dvbpsi_cat_sections_gather
// file tables/cat.c line 259
void dvbpsi_cat_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  _Bool return_value_dvbpsi_CheckPSISection$1;
  return_value_dvbpsi_CheckPSISection$1=dvbpsi_CheckPSISection(p_dvbpsi, p_section, (const unsigned char)0x01, "CAT decoder");
  if(return_value_dvbpsi_CheckPSISection$1 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_cat_decoder_s *p_cat_decoder = (struct dvbpsi_cat_decoder_s *)p_dvbpsi->p_decoder;
    if(!(p_cat_decoder->b_discontinuity == (_Bool)0))
    {
      dvbpsi_ReInitCAT(p_cat_decoder, (const _Bool)1);
      p_cat_decoder->b_discontinuity = (_Bool)0;
    }

    else
      if(!(p_cat_decoder->p_building_cat == ((struct dvbpsi_cat_s *)NULL)))
      {
        _Bool return_value_dvbpsi_CheckCAT$2;
        return_value_dvbpsi_CheckCAT$2=dvbpsi_CheckCAT(p_dvbpsi, p_section);
        if(!(return_value_dvbpsi_CheckCAT$2 == (_Bool)0))
          dvbpsi_ReInitCAT(p_cat_decoder, (const _Bool)1);

      }

      else
        if(!(p_cat_decoder->b_current_valid == (_Bool)0))
        {
          if(p_cat_decoder->current_cat.i_version == p_section->i_version)
          {
            if(p_cat_decoder->current_cat.b_current_next == p_section->b_current_next)
            {
              dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"CAT decoder", p_section->i_number);
              dvbpsi_DeletePSISections(p_section);
              goto __CPROVER_DUMP_L8;
            }

          }

        }

    _Bool return_value_dvbpsi_AddSectionCAT$3;
    return_value_dvbpsi_AddSectionCAT$3=dvbpsi_AddSectionCAT(p_dvbpsi, p_cat_decoder, p_section);
    if(return_value_dvbpsi_AddSectionCAT$3 == (_Bool)0)
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"CAT decoder", p_section->i_number);
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      _Bool return_value_dvbpsi_decoder_psi_sections_completed$4;
      return_value_dvbpsi_decoder_psi_sections_completed$4=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_cat_decoder);
      if(!(return_value_dvbpsi_decoder_psi_sections_completed$4 == (_Bool)0))
      {
        /* assertion p_cat_decoder->pf_cat_callback */
        assert(p_cat_decoder->pf_cat_callback != ((void (*)(void *, struct dvbpsi_cat_s *))NULL));
        p_cat_decoder->current_cat = *p_cat_decoder->p_building_cat;
        p_cat_decoder->b_current_valid = (_Bool)1;
        dvbpsi_cat_sections_decode(p_cat_decoder->p_building_cat, p_cat_decoder->p_sections);
        p_cat_decoder->pf_cat_callback(p_cat_decoder->p_cb_data, p_cat_decoder->p_building_cat);
        dvbpsi_ReInitCAT(p_cat_decoder, (const _Bool)0);
        /* assertion p_cat_decoder->p_sections == ((void *)0) */
        assert(p_cat_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
      }

    }
  }

__CPROVER_DUMP_L8:
  ;
}

// dvbpsi_cat_sections_generate
// file tables/cat.c line 365
struct dvbpsi_psi_section_s * dvbpsi_cat_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_cat_s *p_cat)
{
  struct dvbpsi_psi_section_s *p_result;
  p_result=dvbpsi_NewPSISection(1024);
  struct dvbpsi_psi_section_s *p_current = p_result;
  struct dvbpsi_psi_section_s *p_prev;
  struct dvbpsi_descriptor_s *p_descriptor = p_cat->p_first_descriptor;
  p_current->i_table_id = (unsigned char)0x01;
  p_current->b_syntax_indicator = (_Bool)1;
  p_current->b_private_indicator = (_Bool)0;
  p_current->i_length = (unsigned short int)9;
  p_current->i_extension = (unsigned short int)0;
  p_current->i_version = p_cat->i_version;
  p_current->b_current_next = p_cat->b_current_next;
  p_current->i_number = (unsigned char)0;
  p_current->p_payload_end = p_current->p_payload_end + (signed long int)8;
  p_current->p_payload_start = p_current->p_data + (signed long int)8;
  for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
  {
    if((p_current->p_payload_end - p_current->p_data) + (signed long int)p_descriptor->i_length >= 1019l)
    {
      p_prev = p_current;
      p_current=dvbpsi_NewPSISection(1024);
      p_prev->p_next = p_current;
      p_current->i_table_id = (unsigned char)0x01;
      p_current->b_syntax_indicator = (_Bool)1;
      p_current->b_private_indicator = (_Bool)0;
      p_current->i_length = (unsigned short int)9;
      p_current->i_extension = (unsigned short int)0;
      p_current->i_version = p_cat->i_version;
      p_current->b_current_next = p_cat->b_current_next;
      p_current->i_number = (unsigned char)((signed int)p_prev->i_number + 1);
      p_current->p_payload_end = p_current->p_payload_end + (signed long int)8;
      p_current->p_payload_start = p_current->p_data + (signed long int)8;
    }

    p_current->p_payload_end[(signed long int)0] = p_descriptor->i_tag;
    p_current->p_payload_end[(signed long int)1] = p_descriptor->i_length;
    memcpy((void *)(p_current->p_payload_end + (signed long int)2), (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
    p_current->p_payload_end = p_current->p_payload_end + (signed long int)((signed int)p_descriptor->i_length + 2);
    p_current->i_length = p_current->i_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
  }
  p_prev = p_result;
  for( ; !(p_prev == ((struct dvbpsi_psi_section_s *)NULL)); p_prev = p_prev->p_next)
  {
    p_prev->i_last_number = p_current->i_number;
    dvbpsi_BuildPSISection(p_dvbpsi, p_prev);
  }
  return p_result;
}

// dvbpsi_decoder_delete
// file dvbpsi.c line 225
void dvbpsi_decoder_delete(struct dvbpsi_decoder_s *p_decoder)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  if(!(p_decoder->p_sections == ((struct dvbpsi_psi_section_s *)NULL)))
  {
    dvbpsi_DeletePSISections(p_decoder->p_sections);
    p_decoder->p_sections = (struct dvbpsi_psi_section_s *)(void *)0;
  }

  dvbpsi_DeletePSISections(p_decoder->p_current_section);
  free((void *)p_decoder);
}

// dvbpsi_decoder_new
// file dvbpsi.c line 79
void * dvbpsi_decoder_new(void (*pf_gather)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *), const signed int i_section_max_size, const _Bool b_discontinuity, const unsigned long int psi_size)
{
  /* assertion psi_size >= sizeof(dvbpsi_decoder_t) */
  assert(psi_size >= sizeof(struct dvbpsi_decoder_s) /*40ul*/ );
  struct dvbpsi_decoder_s *p_decoder;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, psi_size);
  p_decoder = (struct dvbpsi_decoder_s *)return_value_calloc$1;
  if(p_decoder == ((struct dvbpsi_decoder_s *)NULL))
    return (void *)0;

  else
  {
    memcpy((void *)&p_decoder->i_magic[(signed long int)0], (const void *)"psi", (unsigned long int)3);
    p_decoder->pf_gather = pf_gather;
    p_decoder->p_current_section = (struct dvbpsi_psi_section_s *)(void *)0;
    p_decoder->i_section_max_size = i_section_max_size;
    p_decoder->b_discontinuity = b_discontinuity;
    p_decoder->i_continuity_counter = (unsigned char)0xFF;
    p_decoder->p_current_section = (struct dvbpsi_psi_section_s *)(void *)0;
    p_decoder->b_current_valid = (_Bool)0;
    p_decoder->i_last_section_number = (unsigned char)0;
    p_decoder->p_sections = (struct dvbpsi_psi_section_s *)(void *)0;
    p_decoder->b_complete_header = (_Bool)0;
    return (void *)p_decoder;
  }
}

// dvbpsi_decoder_present
// file ../../src/dvbpsi.h line 351
_Bool dvbpsi_decoder_present(struct dvbpsi_s *p_dvbpsi)
{
  _Bool tmp_if_expr$1;
  if(!(p_dvbpsi == ((struct dvbpsi_s *)NULL)))
    tmp_if_expr$1 = p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// dvbpsi_decoder_psi_section_add
// file dvbpsi.c line 148
_Bool dvbpsi_decoder_psi_section_add(struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  /* assertion p_section->p_next == ((void *)0) */
  assert(p_section->p_next == (struct dvbpsi_psi_section_s *)(void *)0);
  if(p_decoder->p_sections == ((struct dvbpsi_psi_section_s *)NULL))
  {
    p_decoder->p_sections = p_section;
    p_section->p_next = (struct dvbpsi_psi_section_s *)(void *)0;
    return (_Bool)0;
  }

  else
  {
    struct dvbpsi_psi_section_s *p = p_decoder->p_sections;
    struct dvbpsi_psi_section_s *p_prev = (struct dvbpsi_psi_section_s *)(void *)0;
    _Bool b_overwrite = (_Bool)0;
    for( ; !(p == ((struct dvbpsi_psi_section_s *)NULL)); p = p->p_next)
    {
      if(p->i_number == p_section->i_number)
      {
        if(!(p_prev == ((struct dvbpsi_psi_section_s *)NULL)))
        {
          p_prev->p_next = p_section;
          p_section->p_next = p->p_next;
          p->p_next = (struct dvbpsi_psi_section_s *)(void *)0;
          dvbpsi_DeletePSISections(p);
          b_overwrite = (_Bool)1;
        }

        else
        {
          p_section->p_next = p->p_next;
          p->p_next = (struct dvbpsi_psi_section_s *)(void *)0;
          dvbpsi_DeletePSISections(p);
          p = p_section;
          p_decoder->p_sections = p;
          b_overwrite = (_Bool)1;
        }
        goto out;
      }

      else
        if(!((signed int)p_section->i_number >= (signed int)p->i_number))
        {
          if(!(p_prev == ((struct dvbpsi_psi_section_s *)NULL)))
          {
            p_prev->p_next = p_section;
            p_section->p_next = p;
          }

          else
          {
            p_section->p_next = p;
            p_decoder->p_sections = p_section;
          }
          goto out;
        }

      p_prev = p;
    }
    if(!((signed int)p_prev->i_number >= (signed int)p_section->i_number))
    {
      p_prev->p_next = p_section;
      p_section->p_next = (struct dvbpsi_psi_section_s *)(void *)0;
    }


  out:
    ;
    return b_overwrite;
  }
}

// dvbpsi_decoder_psi_sections_completed
// file dvbpsi.c line 123
_Bool dvbpsi_decoder_psi_sections_completed(struct dvbpsi_decoder_s *p_decoder)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  _Bool b_complete = (_Bool)0;
  struct dvbpsi_psi_section_s *p = p_decoder->p_sections;
  unsigned int prev_nr = (unsigned int)0;
  for( ; !(p == ((struct dvbpsi_psi_section_s *)NULL)); prev_nr = prev_nr + 1u)
  {
    /* assertion prev_nr < 256 */
    assert(prev_nr < (unsigned int)256);
    if(!(prev_nr == (unsigned int)p->i_number))
      break;

    if(p_decoder->i_last_section_number == p->i_number)
      b_complete = (_Bool)1;

    p = p->p_next;
  }
  return b_complete;
}

// dvbpsi_decoder_reset
// file dvbpsi.c line 107
void dvbpsi_decoder_reset(struct dvbpsi_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  if(!(b_force == (_Bool)0))
    p_decoder->b_current_valid = (_Bool)0;

  dvbpsi_DeletePSISections(p_decoder->p_sections);
  p_decoder->p_sections = (struct dvbpsi_psi_section_s *)(void *)0;
}

// dvbpsi_delete
// file ../../src/dvbpsi.h line 185
void dvbpsi_delete(struct dvbpsi_s *p_dvbpsi)
{
  if(!(p_dvbpsi == ((struct dvbpsi_s *)NULL)))
  {
    /* assertion p_dvbpsi->p_decoder == ((void *)0) */
    assert(p_dvbpsi->p_decoder == (struct dvbpsi_decoder_s *)(void *)0);
    p_dvbpsi->pf_message = (void (*)(struct dvbpsi_s *, const enum dvbpsi_msg_level, const char *))(void *)0;
  }

  free((void *)p_dvbpsi);
}

// dvbpsi_demuxGetSubDec
// file demux.c line 79
struct dvbpsi_demux_subdec_s * dvbpsi_demuxGetSubDec(struct dvbpsi_demux_s *p_demux, unsigned char i_table_id, unsigned short int i_extension)
{
  unsigned int i_id = (unsigned int)i_table_id << 16 | (unsigned int)i_extension;
  struct dvbpsi_demux_subdec_s *p_subdec = p_demux->p_first_subdec;
  for( ; !(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL)); p_subdec = p_subdec->p_next)
    if(p_subdec->i_id == i_id)
      break;

  return p_subdec;
}

// dvbpsi_eit_attach
// file ../../src/tables/eit.h line 127
_Bool dvbpsi_eit_attach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_eit_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *return_value_dvbpsi_demuxGetSubDec$1;
  return_value_dvbpsi_demuxGetSubDec$1=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(!(return_value_dvbpsi_demuxGetSubDec$1 == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): Already a decoder for (table_id == 0x%02x,extension == 0x%02x)", (const void *)"EIT decoder", i_table_id, i_extension);
    return (_Bool)0;
  }

  else
  {
    struct dvbpsi_eit_decoder_s *p_eit_decoder;
    void *return_value_dvbpsi_decoder_new$2;
    return_value_dvbpsi_decoder_new$2=dvbpsi_decoder_new((void (*)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *))(void *)0, 0, (const _Bool)1, sizeof(struct dvbpsi_eit_decoder_s) /*96ul*/ );
    p_eit_decoder = (struct dvbpsi_eit_decoder_s *)return_value_dvbpsi_decoder_new$2;
    if(p_eit_decoder == ((struct dvbpsi_eit_decoder_s *)NULL))
      return (_Bool)0;

    else
    {
      struct dvbpsi_demux_subdec_s *p_subdec;
      p_subdec=dvbpsi_NewDemuxSubDecoder(i_table_id, i_extension, dvbpsi_eit_detach, dvbpsi_eit_sections_gather, (struct dvbpsi_decoder_s *)p_eit_decoder);
      if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
      {
        dvbpsi_decoder_delete((struct dvbpsi_decoder_s *)p_eit_decoder);
        return (_Bool)0;
      }

      else
      {
        dvbpsi_AttachDemuxSubDecoder(p_demux, p_subdec);
        p_eit_decoder->pf_eit_callback = pf_callback;
        p_eit_decoder->p_cb_data = p_cb_data;
        p_eit_decoder->p_building_eit = (struct dvbpsi_eit_s *)(void *)0;
        return (_Bool)1;
      }
    }
  }
}

// dvbpsi_eit_delete
// file ../../src/tables/eit.h line 211
void dvbpsi_eit_delete(struct dvbpsi_eit_s *p_eit)
{
  if(!(p_eit == ((struct dvbpsi_eit_s *)NULL)))
    dvbpsi_eit_empty(p_eit);

  free((void *)p_eit);
}

// dvbpsi_eit_detach
// file tables/eit.c line 106
void dvbpsi_eit_detach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *p_subdec;
  p_subdec=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No such EIT decoder (table_id == 0x%02x,extension == 0x%02x)", (const void *)"EIT Decoder", i_table_id, i_extension);

  else
  {
    struct dvbpsi_eit_decoder_s *p_eit_decoder = (struct dvbpsi_eit_decoder_s *)p_subdec->p_decoder;
    if(!(p_eit_decoder->p_building_eit == ((struct dvbpsi_eit_s *)NULL)))
      dvbpsi_eit_delete(p_eit_decoder->p_building_eit);

    p_eit_decoder->p_building_eit = (struct dvbpsi_eit_s *)(void *)0;
    dvbpsi_DetachDemuxSubDecoder(p_demux, p_subdec);
    dvbpsi_DeleteDemuxSubDecoder(p_subdec);
  }
}

// dvbpsi_eit_empty
// file tables/eit.c line 180
void dvbpsi_eit_empty(struct dvbpsi_eit_s *p_eit)
{
  struct dvbpsi_eit_event_s *p_event = p_eit->p_first_event;
  while(!(p_event == ((struct dvbpsi_eit_event_s *)NULL)))
  {
    struct dvbpsi_eit_event_s *p_tmp = p_event->p_next;
    dvbpsi_DeleteDescriptors(p_event->p_first_descriptor);
    free((void *)p_event);
    p_event = p_tmp;
  }
  p_eit->p_first_event = (struct dvbpsi_eit_event_s *)(void *)0;
}

// dvbpsi_eit_event_add
// file tables/eit.c line 211
struct dvbpsi_eit_event_s * dvbpsi_eit_event_add(struct dvbpsi_eit_s *p_eit, unsigned short int i_event_id, unsigned long int i_start_time, unsigned int i_duration, unsigned char i_running_status, _Bool b_free_ca, unsigned short int i_event_descriptor_length)
{
  struct dvbpsi_eit_event_s *p_event;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct dvbpsi_eit_event_s) /*48ul*/ );
  p_event = (struct dvbpsi_eit_event_s *)return_value_calloc$1;
  if(p_event == ((struct dvbpsi_eit_event_s *)NULL))
    return (struct dvbpsi_eit_event_s *)(void *)0;

  else
  {
    p_event->i_event_id = i_event_id;
    p_event->i_start_time = i_start_time;
    p_event->i_duration = i_duration;
    p_event->i_running_status = i_running_status;
    p_event->b_free_ca = b_free_ca;
    p_event->b_nvod = (i_start_time & (unsigned long int)0xFFFFF000) == (unsigned long int)0xFFFFF000 && (signed int)i_running_status == 0x0;
    p_event->p_next = (struct dvbpsi_eit_event_s *)(void *)0;
    p_event->i_descriptors_length = i_event_descriptor_length;
    p_event->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
    if(p_eit->p_first_event == ((struct dvbpsi_eit_event_s *)NULL))
      p_eit->p_first_event = p_event;

    else
    {
      struct dvbpsi_eit_event_s *p_last_event = p_eit->p_first_event;
      for( ; !(p_last_event->p_next == ((struct dvbpsi_eit_event_s *)NULL)); p_last_event = p_last_event->p_next)
        ;
      p_last_event->p_next = p_event;
    }
    return p_event;
  }
}

// dvbpsi_eit_event_descriptor_add
// file tables/eit.c line 261
struct dvbpsi_descriptor_s * dvbpsi_eit_event_descriptor_add(struct dvbpsi_eit_event_s *p_event, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_event->p_first_descriptor=dvbpsi_AddDescriptor(p_event->p_first_descriptor, p_descriptor);
    /* assertion p_event->p_first_descriptor */
    assert(p_event->p_first_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
    if(p_event->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
      return p_descriptor;
  }
}

// dvbpsi_eit_init
// file tables/eit.c line 140
void dvbpsi_eit_init(struct dvbpsi_eit_s *p_eit, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned short int i_ts_id, unsigned short int i_network_id, unsigned char i_segment_last_section_number, unsigned char i_last_table_id)
{
  p_eit->i_table_id = i_table_id;
  p_eit->i_extension = i_extension;
  p_eit->i_version = i_version;
  p_eit->b_current_next = b_current_next;
  p_eit->i_ts_id = i_ts_id;
  p_eit->i_network_id = i_network_id;
  p_eit->i_segment_last_section_number = i_segment_last_section_number;
  p_eit->i_last_table_id = i_last_table_id;
  p_eit->p_first_event = (struct dvbpsi_eit_event_s *)(void *)0;
}

// dvbpsi_eit_new
// file tables/eit.c line 162
struct dvbpsi_eit_s * dvbpsi_eit_new(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned short int i_ts_id, unsigned short int i_network_id, unsigned char i_segment_last_section_number, unsigned char i_last_table_id)
{
  struct dvbpsi_eit_s *p_eit;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_eit_s) /*24ul*/ );
  p_eit = (struct dvbpsi_eit_s *)return_value_malloc$1;
  if(!(p_eit == ((struct dvbpsi_eit_s *)NULL)))
    dvbpsi_eit_init(p_eit, i_table_id, i_extension, i_version, b_current_next, i_ts_id, i_network_id, i_segment_last_section_number, i_last_table_id);

  return p_eit;
}

// dvbpsi_eit_nvod_event_add
// file tables/eit.c line 248
struct dvbpsi_eit_event_s * dvbpsi_eit_nvod_event_add(struct dvbpsi_eit_s *p_eit, unsigned short int i_event_id, unsigned int i_duration, _Bool b_free_ca, unsigned short int i_event_descriptor_length)
{
  struct dvbpsi_eit_event_s *return_value_dvbpsi_eit_event_add$1;
  return_value_dvbpsi_eit_event_add$1=dvbpsi_eit_event_add(p_eit, i_event_id, (unsigned long int)0xFFFFF000, i_duration, (unsigned char)0x0, b_free_ca, i_event_descriptor_length);
  return return_value_dvbpsi_eit_event_add$1;
}

// dvbpsi_eit_sections_decode
// file tables/eit.c line 515
void dvbpsi_eit_sections_decode(struct dvbpsi_eit_s *p_eit, struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte;
  unsigned char *p_end;
  for( ; !(p_section == ((struct dvbpsi_psi_section_s *)NULL)); p_section = p_section->p_next)
  {
    p_byte = p_section->p_payload_start + (signed long int)6;
    p_end = p_section->p_payload_end;
    while(!(p_byte >= p_end))
    {
      unsigned short int i_event_id = (unsigned short int)((signed int)(unsigned short int)p_byte[(signed long int)0] << 8 | (signed int)p_byte[(signed long int)1]);
      unsigned long int i_start_time = (unsigned long int)p_byte[(signed long int)2] << 32 | (unsigned long int)p_byte[(signed long int)3] << 24 | (unsigned long int)p_byte[(signed long int)4] << 16 | (unsigned long int)p_byte[(signed long int)5] << 8 | (unsigned long int)p_byte[(signed long int)6];
      unsigned int i_duration = (unsigned int)p_byte[(signed long int)7] << 16 | (unsigned int)p_byte[(signed long int)8] << 8 | (unsigned int)p_byte[(signed long int)9];
      unsigned char i_running_status = (unsigned char)((signed int)(unsigned char)p_byte[(signed long int)10] >> 5);
      _Bool b_free_ca = (_Bool)(((signed int)p_byte[(signed long int)10] & 0x10) == 0x10 ? 1 : 0);
      unsigned short int i_ev_length = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)10] & 0xf) << 8 | (signed int)p_byte[(signed long int)11]);
      struct dvbpsi_eit_event_s *p_event;
      p_event=dvbpsi_eit_event_add(p_eit, i_event_id, i_start_time, i_duration, i_running_status, b_free_ca, i_ev_length);
      if(p_event == ((struct dvbpsi_eit_event_s *)NULL))
        break;

      p_byte = p_byte + (signed long int)12;
      unsigned char *p_ev_end = p_byte + (signed long int)i_ev_length;
      if(!(p_section->p_payload_end >= p_ev_end))
        p_ev_end = p_section->p_payload_end;

      while(!(p_byte >= p_ev_end))
      {
        unsigned char i_tag = p_byte[(signed long int)0];
        unsigned char i_length = p_byte[(signed long int)1];
        if(p_ev_end - p_byte >= (signed long int)(2 + (signed int)i_length))
          dvbpsi_eit_event_descriptor_add(p_event, i_tag, i_length, p_byte + (signed long int)2);

        p_byte = p_byte + (signed long int)(2 + (signed int)i_length);
      }
    }
  }
}

// dvbpsi_eit_sections_gather
// file tables/eit.c line 424
void dvbpsi_eit_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_private_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  unsigned char i_table_id;
  _Bool tmp_if_expr$1;
  if((signed int)p_section->i_table_id >= 0x4e)
    tmp_if_expr$1 = (signed int)p_section->i_table_id <= 0x6f ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  signed int tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (signed int)p_section->i_table_id;

  else
    tmp_if_expr$2 = 0x4e;
  i_table_id = (const unsigned char)tmp_if_expr$2;
  _Bool return_value_dvbpsi_CheckPSISection$3;
  return_value_dvbpsi_CheckPSISection$3=dvbpsi_CheckPSISection(p_dvbpsi, p_section, i_table_id, "EIT decoder");
  if(return_value_dvbpsi_CheckPSISection$3 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
    struct dvbpsi_eit_decoder_s *p_eit_decoder = (struct dvbpsi_eit_decoder_s *)p_private_decoder;
    if(!(p_demux->b_discontinuity == (_Bool)0))
    {
      dvbpsi_ReInitEIT(p_eit_decoder, (const _Bool)1);
      p_eit_decoder->b_discontinuity = (_Bool)0;
      p_demux->b_discontinuity = (_Bool)0;
    }

    else
      if(!(p_eit_decoder->p_building_eit == ((struct dvbpsi_eit_s *)NULL)))
      {
        _Bool return_value_dvbpsi_CheckEIT$4;
        return_value_dvbpsi_CheckEIT$4=dvbpsi_CheckEIT(p_dvbpsi, p_eit_decoder, p_section);
        if(!(return_value_dvbpsi_CheckEIT$4 == (_Bool)0))
          dvbpsi_ReInitEIT(p_eit_decoder, (const _Bool)1);

      }

      else
        if(!(p_eit_decoder->b_current_valid == (_Bool)0))
        {
          if(p_eit_decoder->current_eit.i_version == p_section->i_version)
          {
            if(p_eit_decoder->current_eit.b_current_next == p_section->b_current_next)
            {
              dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"EIT decoder", p_section->i_number);
              dvbpsi_DeletePSISections(p_section);
              goto __CPROVER_DUMP_L12;
            }

          }

        }

    _Bool return_value_dvbpsi_AddSectionEIT$5;
    return_value_dvbpsi_AddSectionEIT$5=dvbpsi_AddSectionEIT(p_dvbpsi, p_eit_decoder, p_section);
    if(return_value_dvbpsi_AddSectionEIT$5 == (_Bool)0)
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"EIT decoder", p_section->i_number);
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      _Bool return_value_dvbpsi_IsCompleteEIT$6;
      return_value_dvbpsi_IsCompleteEIT$6=dvbpsi_IsCompleteEIT(p_eit_decoder, p_section);
      if(!(return_value_dvbpsi_IsCompleteEIT$6 == (_Bool)0))
      {
        /* assertion p_eit_decoder->pf_eit_callback */
        assert(p_eit_decoder->pf_eit_callback != ((void (*)(void *, struct dvbpsi_eit_s *))NULL));
        p_eit_decoder->current_eit = *p_eit_decoder->p_building_eit;
        p_eit_decoder->b_current_valid = (_Bool)1;
        dvbpsi_eit_sections_decode(p_eit_decoder->p_building_eit, p_eit_decoder->p_sections);
        p_eit_decoder->pf_eit_callback(p_eit_decoder->p_cb_data, p_eit_decoder->p_building_eit);
        dvbpsi_ReInitEIT(p_eit_decoder, (const _Bool)0);
        /* assertion p_eit_decoder->p_sections == ((void *)0) */
        assert(p_eit_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
      }

    }
  }

__CPROVER_DUMP_L12:
  ;
}

// dvbpsi_eit_sections_generate
// file tables/eit.c line 641
struct dvbpsi_psi_section_s * dvbpsi_eit_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_eit_s *p_eit, unsigned char i_table_id)
{
  struct dvbpsi_psi_section_s *p_result;
  p_result=NewEITSection(p_eit, (signed int)i_table_id, 0);
  struct dvbpsi_psi_section_s *p_current = p_result;
  unsigned char i_last_section_number = (unsigned char)0;
  struct dvbpsi_eit_event_s *p_event;
  if(p_current == ((struct dvbpsi_psi_section_s *)NULL))
    return (struct dvbpsi_psi_section_s *)(void *)0;

  else
  {
    p_event = p_eit->p_first_event;
    for( ; !(p_event == ((struct dvbpsi_eit_event_s *)NULL)); p_event = p_event->p_next)
    {
      unsigned char *p_event_start = p_current->p_payload_end;
      unsigned short int i_event_length = (unsigned short int)12;
      struct dvbpsi_descriptor_s *p_descriptor = p_event->p_first_descriptor;
      for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
      {
        i_event_length = i_event_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
        if((p_event_start - p_current->p_data) + (signed long int)i_event_length >= 4091l)
        {
          struct dvbpsi_psi_section_s *p_prev = p_current;
          i_last_section_number = i_last_section_number + 1;
          p_current=NewEITSection(p_eit, (signed int)i_table_id, (signed int)i_last_section_number);
          p_event_start = p_current->p_payload_end;
          p_prev->p_next = p_current;
          break;
        }

      }
      EncodeEventHeaders(p_event, p_event_start);
      p_current->p_payload_end = p_current->p_payload_end + (signed long int)12;
      p_current->i_length = p_current->i_length + (unsigned short int)12;
      p_descriptor = p_event->p_first_descriptor;
      for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
      {
        if((p_current->p_payload_end - p_current->p_data) + (signed long int)p_descriptor->i_length >= 4091l)
        {
          dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): too many descriptors in event, unable to carry all the descriptors", (const void *)"EIT generator");
          break;
        }

        p_current->p_payload_end[(signed long int)0] = p_descriptor->i_tag;
        p_current->p_payload_end[(signed long int)1] = p_descriptor->i_length;
        memcpy((void *)(p_current->p_payload_end + (signed long int)2), (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
        p_current->p_payload_end = p_current->p_payload_end + (signed long int)((signed int)p_descriptor->i_length + 2);
        p_current->i_length = p_current->i_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
      }
      i_event_length = (unsigned short int)((p_current->p_payload_end - p_event_start) - (signed long int)12);
      p_event_start[(signed long int)10] = p_event_start[(signed long int)10] | (unsigned char)((signed int)i_event_length >> 8 & 0x0f);
      p_event_start[(signed long int)11] = (unsigned char)i_event_length;
    }
    p_current = p_result;
    for( ; !(p_current == ((struct dvbpsi_psi_section_s *)NULL)); p_current = p_current->p_next)
    {
      p_current->p_data[(signed long int)12] = i_last_section_number;
      p_current->i_last_number = i_last_section_number;
      dvbpsi_BuildPSISection(p_dvbpsi, p_current);
    }
    return p_result;
  }
}

// dvbpsi_has_CRC32
// file psi.h line 188
static inline _Bool dvbpsi_has_CRC32(struct dvbpsi_psi_section_s *p_section)
{
  _Bool tmp_if_expr$1;
  if(p_section->i_table_id == 112)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = p_section->i_table_id == (unsigned char)0x71 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = p_section->i_table_id == (unsigned char)0x72 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = p_section->i_table_id == (unsigned char)0x7E ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    return (_Bool)0;

  else
  {
    if(!(p_section->b_syntax_indicator == (_Bool)0))
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)p_section->i_table_id == 0x73 ? (_Bool)1 : (_Bool)0;
    return tmp_if_expr$4;
  }
}

// dvbpsi_has_CRC32$link1
// file psi.h line 188
static inline _Bool dvbpsi_has_CRC32$link1(struct dvbpsi_psi_section_s *p_section$link1)
{
  _Bool tmp_if_expr$1$link1;
  if(p_section$link1->i_table_id == 112)
    tmp_if_expr$1$link1 = (_Bool)1;

  else
    tmp_if_expr$1$link1 = p_section$link1->i_table_id == (unsigned char)0x71 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2$link1;
  if(tmp_if_expr$1$link1)
    tmp_if_expr$2$link1 = (_Bool)1;

  else
    tmp_if_expr$2$link1 = p_section$link1->i_table_id == (unsigned char)0x72 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3$link1;
  if(tmp_if_expr$2$link1)
    tmp_if_expr$3$link1 = (_Bool)1;

  else
    tmp_if_expr$3$link1 = p_section$link1->i_table_id == (unsigned char)0x7E ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4$link1;
  if(tmp_if_expr$3$link1)
    return (_Bool)0;

  else
  {
    if(!(p_section$link1->b_syntax_indicator == (_Bool)0))
      tmp_if_expr$4$link1 = (_Bool)1;

    else
      tmp_if_expr$4$link1 = (signed int)p_section$link1->i_table_id == 0x73 ? (_Bool)1 : (_Bool)0;
    return tmp_if_expr$4$link1;
  }
}

// dvbpsi_message
// file libdvbpsi.c line 331
static void dvbpsi_message(struct dvbpsi_s *p_dvbpsi, const enum dvbpsi_msg_level level, const char *msg)
{
  signed int code = 0;
  const char *dvbpsi_message$$1$$psz_level;
  switch((signed int)level)
  {
    case DVBPSI_MSG_ERROR:
    {
      code = 0;
      dvbpsi_message$$1$$psz_level = "Error: ";
      break;
    }
    case DVBPSI_MSG_WARN:
    {
      code = 1;
      dvbpsi_message$$1$$psz_level = "Warning: ";
      break;
    }
    case DVBPSI_MSG_DEBUG:
    {
      code = 3;
      dvbpsi_message$$1$$psz_level = "Debug: ";
      break;
    }
    default:
      goto __CPROVER_DUMP_L11;
  }
  struct ts_stream_t *stream = (struct ts_stream_t *)p_dvbpsi->p_sys;
  _Bool tmp_if_expr$2;
  if(!(stream == ((struct ts_stream_t *)NULL)))
    tmp_if_expr$2 = stream->pf_log != ((void (*)(void *, const signed int, const char *, ...))NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    stream->pf_log(stream->cb_data, code, msg);

  else
  {
    char *reply = (char *)(void *)0;
    signed int return_value_asprintf$1;
    return_value_asprintf$1=asprintf(&reply, "%s%s\n", dvbpsi_message$$1$$psz_level, msg);
    if(return_value_asprintf$1 >= 1)
    {
      fprintf(stderr, "%s", reply);
      free((void *)reply);
    }

  }

__CPROVER_DUMP_L11:
  ;
}

// dvbpsi_message$link1
// file dvbpsi.c line 518
void dvbpsi_message$link1(struct dvbpsi_s *dvbpsi, const enum dvbpsi_msg_level level$link1, const char *fmt, ...)
{
  if((signed int)dvbpsi->i_msg_level >= 0)
  {
    if((signed int)dvbpsi->i_msg_level >= (signed int)level$link1)
    {
      void **ap = (void **)&fmt;
      char *msg = (char *)(void *)0;
      signed int err;
      err=vasprintf(&msg, fmt, ap);
      ap = ((void **)NULL);
      if(err >= 1)
      {
        if(!(dvbpsi->pf_message == ((void (*)(struct dvbpsi_s *, const enum dvbpsi_msg_level, const char *))NULL)))
          dvbpsi->pf_message(dvbpsi, level$link1, msg);

      }

      free((void *)msg);
    }

  }

}

// dvbpsi_new
// file ../../src/dvbpsi.h line 171
struct dvbpsi_s * dvbpsi_new(void (*callback)(struct dvbpsi_s *, const enum dvbpsi_msg_level, const char *), enum dvbpsi_msg_level level)
{
  struct dvbpsi_s *p_dvbpsi;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct dvbpsi_s) /*32ul*/ );
  p_dvbpsi = (struct dvbpsi_s *)return_value_calloc$1;
  if(p_dvbpsi == ((struct dvbpsi_s *)NULL))
    return (struct dvbpsi_s *)(void *)0;

  else
  {
    p_dvbpsi->p_decoder = (struct dvbpsi_decoder_s *)(void *)0;
    p_dvbpsi->pf_message = callback;
    p_dvbpsi->i_msg_level = level;
    return p_dvbpsi;
  }
}

// dvbpsi_nit_attach
// file ../../src/tables/nit.h line 122
_Bool dvbpsi_nit_attach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_nit_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *return_value_dvbpsi_demuxGetSubDec$1;
  return_value_dvbpsi_demuxGetSubDec$1=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(!(return_value_dvbpsi_demuxGetSubDec$1 == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): Already a decoder for (table_id == 0x%02x,extension == 0x%02x)", (const void *)"NIT decoder", i_table_id, i_extension);
    return (_Bool)0;
  }

  else
  {
    struct dvbpsi_nit_decoder_s *p_nit_decoder;
    void *return_value_dvbpsi_decoder_new$2;
    return_value_dvbpsi_decoder_new$2=dvbpsi_decoder_new((void (*)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *))(void *)0, 0, (const _Bool)1, sizeof(struct dvbpsi_nit_decoder_s) /*96ul*/ );
    p_nit_decoder = (struct dvbpsi_nit_decoder_s *)return_value_dvbpsi_decoder_new$2;
    if(p_nit_decoder == ((struct dvbpsi_nit_decoder_s *)NULL))
      return (_Bool)0;

    else
    {
      struct dvbpsi_demux_subdec_s *p_subdec;
      p_subdec=dvbpsi_NewDemuxSubDecoder(i_table_id, i_extension, dvbpsi_nit_detach, dvbpsi_nit_sections_gather, (struct dvbpsi_decoder_s *)p_nit_decoder);
      if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
      {
        dvbpsi_decoder_delete((struct dvbpsi_decoder_s *)p_nit_decoder);
        return (_Bool)0;
      }

      else
      {
        dvbpsi_AttachDemuxSubDecoder(p_demux, p_subdec);
        p_nit_decoder->i_network_id = i_extension;
        p_nit_decoder->pf_nit_callback = pf_callback;
        p_nit_decoder->p_cb_data = p_cb_data;
        p_nit_decoder->p_building_nit = (struct dvbpsi_nit_s *)(void *)0;
        return (_Bool)1;
      }
    }
  }
}

// dvbpsi_nit_delete
// file ../../src/tables/nit.h line 191
void dvbpsi_nit_delete(struct dvbpsi_nit_s *p_nit)
{
  if(!(p_nit == ((struct dvbpsi_nit_s *)NULL)))
    dvbpsi_nit_empty(p_nit);

  free((void *)p_nit);
}

// dvbpsi_nit_descriptor_add
// file tables/nit.c line 209
struct dvbpsi_descriptor_s * dvbpsi_nit_descriptor_add(struct dvbpsi_nit_s *p_nit, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    if(p_nit->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      p_nit->p_first_descriptor = p_descriptor;

    else
    {
      struct dvbpsi_descriptor_s *p_last_descriptor = p_nit->p_first_descriptor;
      for( ; !(p_last_descriptor->p_next == ((struct dvbpsi_descriptor_s *)NULL)); p_last_descriptor = p_last_descriptor->p_next)
        ;
      p_last_descriptor->p_next = p_descriptor;
    }
    return p_descriptor;
  }
}

// dvbpsi_nit_detach
// file tables/nit.c line 109
void dvbpsi_nit_detach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension)
{
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *p_subdec;
  p_subdec=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No such NIT decoder (table_id == 0x%02x,extension == 0x%02x)", (const void *)"NIT Decoder", i_table_id, i_extension);

  else
  {
    struct dvbpsi_nit_decoder_s *p_nit_decoder = (struct dvbpsi_nit_decoder_s *)p_subdec->p_decoder;
    if(!(p_nit_decoder->p_building_nit == ((struct dvbpsi_nit_s *)NULL)))
      dvbpsi_nit_delete(p_nit_decoder->p_building_nit);

    p_nit_decoder->p_building_nit = (struct dvbpsi_nit_s *)(void *)0;
    dvbpsi_DetachDemuxSubDecoder(p_demux, p_subdec);
    dvbpsi_DeleteDemuxSubDecoder(p_subdec);
  }
}

// dvbpsi_nit_empty
// file tables/nit.c line 174
void dvbpsi_nit_empty(struct dvbpsi_nit_s *p_nit)
{
  struct dvbpsi_nit_ts_s *p_ts = p_nit->p_first_ts;
  dvbpsi_DeleteDescriptors(p_nit->p_first_descriptor);
  while(!(p_ts == ((struct dvbpsi_nit_ts_s *)NULL)))
  {
    struct dvbpsi_nit_ts_s *p_tmp = p_ts->p_next;
    dvbpsi_DeleteDescriptors(p_ts->p_first_descriptor);
    free((void *)p_ts);
    p_ts = p_tmp;
  }
  p_nit->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
  p_nit->p_first_ts = (struct dvbpsi_nit_ts_s *)(void *)0;
}

// dvbpsi_nit_init
// file tables/nit.c line 140
void dvbpsi_nit_init(struct dvbpsi_nit_s *p_nit, unsigned char i_table_id, unsigned short int i_extension, unsigned short int i_network_id, unsigned char i_version, _Bool b_current_next)
{
  p_nit->i_table_id = i_table_id;
  p_nit->i_extension = i_extension;
  p_nit->i_network_id = i_network_id;
  p_nit->i_version = i_version;
  p_nit->b_current_next = b_current_next;
  p_nit->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
  p_nit->p_first_ts = (struct dvbpsi_nit_ts_s *)(void *)0;
}

// dvbpsi_nit_new
// file tables/nit.c line 158
struct dvbpsi_nit_s * dvbpsi_nit_new(unsigned char i_table_id, unsigned short int i_extension, unsigned short int i_network_id, unsigned char i_version, _Bool b_current_next)
{
  struct dvbpsi_nit_s *p_nit;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_nit_s) /*24ul*/ );
  p_nit = (struct dvbpsi_nit_s *)return_value_malloc$1;
  if(!(p_nit == ((struct dvbpsi_nit_s *)NULL)))
    dvbpsi_nit_init(p_nit, i_table_id, i_extension, i_network_id, i_version, b_current_next);

  return p_nit;
}

// dvbpsi_nit_sections_decode
// file tables/nit.c line 453
void dvbpsi_nit_sections_decode(struct dvbpsi_nit_s *p_nit, struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte;
  unsigned char *p_end;
  for( ; !(p_section == ((struct dvbpsi_psi_section_s *)NULL)); p_section = p_section->p_next)
  {
    p_byte = p_section->p_payload_start + (signed long int)2;
    p_end = p_byte + (signed long int)((signed int)(unsigned short int)((signed int)p_section->p_payload_start[(signed long int)0] & 0x0f) << 8 | (signed int)p_section->p_payload_start[(signed long int)1]);
    while(p_end >= p_byte + 2l)
    {
      unsigned char dvbpsi_nit_sections_decode$$1$$1$$1$$i_tag = p_byte[(signed long int)0];
      unsigned char dvbpsi_nit_sections_decode$$1$$1$$1$$i_length = p_byte[(signed long int)1];
      if(p_end - p_byte >= (signed long int)(2 + (signed int)dvbpsi_nit_sections_decode$$1$$1$$1$$i_length))
        dvbpsi_nit_descriptor_add(p_nit, dvbpsi_nit_sections_decode$$1$$1$$1$$i_tag, dvbpsi_nit_sections_decode$$1$$1$$1$$i_length, p_byte + (signed long int)2);

      p_byte = p_byte + (signed long int)(2 + (signed int)dvbpsi_nit_sections_decode$$1$$1$$1$$i_length);
    }
    p_end = (signed long int)2 + p_byte + (signed long int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)0] & 0x0f) << 8 | (signed int)p_byte[(signed long int)1]);
    if(!(p_section->p_payload_end >= p_end))
      p_end = p_section->p_payload_end;

    p_byte = p_byte + (signed long int)2;
    while(p_end >= p_byte + 6l)
    {
      unsigned char *p_end2;
      unsigned short int i_ts_id = (unsigned short int)((signed int)(unsigned short int)p_byte[(signed long int)0] << 8 | (signed int)p_byte[(signed long int)1]);
      unsigned short int i_orig_network_id = (unsigned short int)((signed int)(unsigned short int)p_byte[(signed long int)2] << 8 | (signed int)p_byte[(signed long int)3]);
      unsigned short int i_ts_length = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)4] & 0x0f) << 8 | (signed int)p_byte[(signed long int)5]);
      struct dvbpsi_nit_ts_s *p_ts;
      p_ts=dvbpsi_nit_ts_add(p_nit, i_ts_id, i_orig_network_id);
      if(p_ts == ((struct dvbpsi_nit_ts_s *)NULL))
        break;

      p_byte = p_byte + (signed long int)6;
      p_end2 = p_byte + (signed long int)i_ts_length;
      if(!(p_section->p_payload_end >= p_end2))
        p_end2 = p_section->p_payload_end;

      while(p_end2 >= p_byte + 2l)
      {
        unsigned char i_tag = p_byte[(signed long int)0];
        unsigned char i_length = p_byte[(signed long int)1];
        if(p_end2 - p_byte >= (signed long int)(2 + (signed int)i_length))
          dvbpsi_nit_ts_descriptor_add(p_ts, i_tag, i_length, p_byte + (signed long int)2);

        p_byte = p_byte + (signed long int)(2 + (signed int)i_length);
      }
    }
  }
}

// dvbpsi_nit_sections_gather
// file tables/nit.c line 359
void dvbpsi_nit_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_private_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  unsigned char i_table_id;
  _Bool tmp_if_expr$1;
  if((signed int)p_section->i_table_id == 0x40)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)p_section->i_table_id == 0x41 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (signed int)p_section->i_table_id;

  else
    tmp_if_expr$2 = 0x40;
  i_table_id = (const unsigned char)tmp_if_expr$2;
  _Bool return_value_dvbpsi_CheckPSISection$3;
  return_value_dvbpsi_CheckPSISection$3=dvbpsi_CheckPSISection(p_dvbpsi, p_section, i_table_id, "NIT decoder");
  if(return_value_dvbpsi_CheckPSISection$3 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_nit_decoder_s *p_nit_decoder = (struct dvbpsi_nit_decoder_s *)p_private_decoder;
    if(!(p_nit_decoder->i_network_id == p_section->i_extension))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): 'network_id' don't match", (const void *)"NIT decoder");
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      if(!(p_nit_decoder->b_discontinuity == (_Bool)0))
      {
        dvbpsi_ReInitNIT(p_nit_decoder, (const _Bool)1);
        p_nit_decoder->b_discontinuity = (_Bool)0;
      }

      else
        if(!(p_nit_decoder->p_building_nit == ((struct dvbpsi_nit_s *)NULL)))
        {
          _Bool return_value_dvbpsi_CheckNIT$4;
          return_value_dvbpsi_CheckNIT$4=dvbpsi_CheckNIT(p_dvbpsi, p_nit_decoder, p_section);
          if(!(return_value_dvbpsi_CheckNIT$4 == (_Bool)0))
            dvbpsi_ReInitNIT(p_nit_decoder, (const _Bool)1);

        }

        else
          if(!(p_nit_decoder->b_current_valid == (_Bool)0))
          {
            if(p_nit_decoder->current_nit.i_version == p_section->i_version)
            {
              if(p_nit_decoder->current_nit.b_current_next == p_section->b_current_next)
              {
                dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"NIT decoder", p_section->i_number);
                dvbpsi_DeletePSISections(p_section);
                goto __CPROVER_DUMP_L13;
              }

            }

          }

      _Bool return_value_dvbpsi_AddSectionNIT$5;
      return_value_dvbpsi_AddSectionNIT$5=dvbpsi_AddSectionNIT(p_dvbpsi, p_nit_decoder, p_section);
      if(return_value_dvbpsi_AddSectionNIT$5 == (_Bool)0)
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"NIT decoder", p_section->i_number);
        dvbpsi_DeletePSISections(p_section);
      }

      else
      {
        _Bool return_value_dvbpsi_decoder_psi_sections_completed$6;
        return_value_dvbpsi_decoder_psi_sections_completed$6=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_nit_decoder);
        if(!(return_value_dvbpsi_decoder_psi_sections_completed$6 == (_Bool)0))
        {
          /* assertion p_nit_decoder->pf_nit_callback */
          assert(p_nit_decoder->pf_nit_callback != ((void (*)(void *, struct dvbpsi_nit_s *))NULL));
          p_nit_decoder->current_nit = *p_nit_decoder->p_building_nit;
          p_nit_decoder->b_current_valid = (_Bool)1;
          dvbpsi_nit_sections_decode(p_nit_decoder->p_building_nit, p_nit_decoder->p_sections);
          p_nit_decoder->pf_nit_callback(p_nit_decoder->p_cb_data, p_nit_decoder->p_building_nit);
          dvbpsi_ReInitNIT(p_nit_decoder, (const _Bool)0);
          /* assertion p_nit_decoder->p_sections == ((void *)0) */
          assert(p_nit_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
        }

      }
    }
  }

__CPROVER_DUMP_L13:
  ;
}

// dvbpsi_nit_sections_generate
// file tables/nit.c line 518
struct dvbpsi_psi_section_s * dvbpsi_nit_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_nit_s *p_nit, unsigned char i_table_id)
{
  struct dvbpsi_psi_section_s *p_result;
  p_result=dvbpsi_NewPSISection(1024);
  struct dvbpsi_psi_section_s *p_current = p_result;
  struct dvbpsi_psi_section_s *p_prev;
  struct dvbpsi_descriptor_s *p_descriptor = p_nit->p_first_descriptor;
  struct dvbpsi_nit_ts_s *p_ts = p_nit->p_first_ts;
  unsigned short int i_network_descriptors_length;
  unsigned short int i_transport_stream_loop_length;
  unsigned char *p_transport_stream_loop_length;
  p_current->i_table_id = i_table_id;
  p_current->b_syntax_indicator = (_Bool)1;
  p_current->b_private_indicator = (_Bool)0;
  p_current->i_length = (unsigned short int)13;
  p_current->i_extension = p_nit->i_network_id;
  p_current->i_version = p_nit->i_version;
  p_current->b_current_next = p_nit->b_current_next;
  p_current->i_number = (unsigned char)0;
  p_current->p_payload_end = p_current->p_payload_end + (signed long int)10;
  p_current->p_payload_start = p_current->p_data + (signed long int)8;
  for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
  {
    if((p_current->p_payload_end - p_current->p_data) + (signed long int)p_descriptor->i_length >= 1019l)
    {
      i_network_descriptors_length = (unsigned short int)((p_current->p_payload_end - p_current->p_payload_start) - (signed long int)2);
      p_current->p_data[(signed long int)8] = (unsigned char)((signed int)i_network_descriptors_length >> 8 | 0xf0);
      p_current->p_data[(signed long int)9] = (unsigned char)i_network_descriptors_length;
      p_current->p_payload_end[(signed long int)0] = (unsigned char)0;
      p_current->p_payload_end[(signed long int)1] = (unsigned char)0;
      p_current->p_payload_end = p_current->p_payload_end + (signed long int)2;
      p_prev = p_current;
      p_current=dvbpsi_NewPSISection(1024);
      p_prev->p_next = p_current;
      p_current->i_table_id = i_table_id;
      p_current->b_syntax_indicator = (_Bool)1;
      p_current->b_private_indicator = (_Bool)0;
      p_current->i_length = (unsigned short int)13;
      p_current->i_extension = p_nit->i_network_id;
      p_current->i_version = p_nit->i_version;
      p_current->b_current_next = p_nit->b_current_next;
      p_current->i_number = (unsigned char)((signed int)p_prev->i_number + 1);
      p_current->p_payload_end = p_current->p_payload_end + (signed long int)10;
      p_current->p_payload_start = p_current->p_data + (signed long int)8;
    }

    p_current->p_payload_end[(signed long int)0] = p_descriptor->i_tag;
    p_current->p_payload_end[(signed long int)1] = p_descriptor->i_length;
    memcpy((void *)(p_current->p_payload_end + (signed long int)2), (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
    p_current->p_payload_end = p_current->p_payload_end + (signed long int)((signed int)p_descriptor->i_length + 2);
    p_current->i_length = p_current->i_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
  }
  i_network_descriptors_length = (unsigned short int)((p_current->p_payload_end - p_current->p_payload_start) - (signed long int)2);
  p_current->p_data[(signed long int)8] = (unsigned char)((signed int)i_network_descriptors_length >> 8 | 0xf0);
  p_current->p_data[(signed long int)9] = (unsigned char)i_network_descriptors_length;
  p_transport_stream_loop_length = p_current->p_payload_end;
  p_current->p_payload_end = p_current->p_payload_end + (signed long int)2;
  while(!(p_ts == ((struct dvbpsi_nit_ts_s *)NULL)))
  {
    unsigned char *p_ts_start = p_current->p_payload_end;
    unsigned short int i_ts_length = (unsigned short int)5;
    p_descriptor = p_ts->p_first_descriptor;
    for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
    {
      if((p_ts_start - p_current->p_data) + (signed long int)i_ts_length >= 1021l)
        break;

      i_ts_length = i_ts_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
    }
    if(!(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)))
    {
      if(!(p_ts_start - p_current->p_data == 12l))
      {
        if(!((signed int)i_ts_length >= 1009))
        {
          i_transport_stream_loop_length = (unsigned short int)((p_current->p_payload_end - p_transport_stream_loop_length) - (signed long int)2);
          p_transport_stream_loop_length[(signed long int)0] = (unsigned char)((signed int)i_transport_stream_loop_length >> 8 | 0xf0);
          p_transport_stream_loop_length[(signed long int)1] = (unsigned char)i_transport_stream_loop_length;
          dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): create a new section to carry more TS descriptors", (const void *)"NIT generator");
          p_prev = p_current;
          p_current=dvbpsi_NewPSISection(1024);
          p_prev->p_next = p_current;
          p_current->i_table_id = i_table_id;
          p_current->b_syntax_indicator = (_Bool)1;
          p_current->b_private_indicator = (_Bool)0;
          p_current->i_length = (unsigned short int)13;
          p_current->i_extension = p_nit->i_network_id;
          p_current->i_version = p_nit->i_version;
          p_current->b_current_next = p_nit->b_current_next;
          p_current->i_number = (unsigned char)((signed int)p_prev->i_number + 1);
          p_current->p_payload_end = p_current->p_payload_end + (signed long int)10;
          p_current->p_payload_start = p_current->p_data + (signed long int)8;
          p_current->p_data[(signed long int)8] = (unsigned char)0xf0;
          p_current->p_data[(signed long int)9] = (unsigned char)0x00;
          p_transport_stream_loop_length = p_current->p_payload_end;
          p_current->p_payload_end = p_current->p_payload_end + (signed long int)2;
          p_ts_start = p_current->p_payload_end;
        }

      }

    }

    p_ts_start[(signed long int)0] = (unsigned char)((signed int)p_ts->i_ts_id >> 8);
    p_ts_start[(signed long int)1] = (unsigned char)((signed int)p_ts->i_ts_id & 0xff);
    p_ts_start[(signed long int)2] = (unsigned char)((signed int)p_ts->i_orig_network_id >> 8);
    p_ts_start[(signed long int)3] = (unsigned char)((signed int)p_ts->i_orig_network_id & 0xff);
    p_current->p_payload_end = p_current->p_payload_end + (signed long int)6;
    p_current->i_length = p_current->i_length + (unsigned short int)6;
    p_descriptor = p_ts->p_first_descriptor;
    for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
    {
      if((p_current->p_payload_end - p_current->p_data) + (signed long int)p_descriptor->i_length >= 1019l)
        break;

      p_current->p_payload_end[(signed long int)0] = p_descriptor->i_tag;
      p_current->p_payload_end[(signed long int)1] = p_descriptor->i_length;
      memcpy((void *)(p_current->p_payload_end + (signed long int)2), (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
      p_current->p_payload_end = p_current->p_payload_end + (signed long int)((signed int)p_descriptor->i_length + 2);
      p_current->i_length = p_current->i_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
    }
    if(!(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)))
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): unable to carry all the TS descriptors", (const void *)"NIT generator");

    i_ts_length = (unsigned short int)((p_current->p_payload_end - p_ts_start) - (signed long int)6);
    p_ts_start[(signed long int)4] = (unsigned char)((signed int)i_ts_length >> 8 | 0xf0);
    p_ts_start[(signed long int)5] = (unsigned char)i_ts_length;
    p_ts = p_ts->p_next;
  }
  i_transport_stream_loop_length = (unsigned short int)((p_current->p_payload_end - p_transport_stream_loop_length) - (signed long int)2);
  p_transport_stream_loop_length[(signed long int)0] = (unsigned char)((signed int)i_transport_stream_loop_length >> 8 | 0xf0);
  p_transport_stream_loop_length[(signed long int)1] = (unsigned char)i_transport_stream_loop_length;
  p_prev = p_result;
  for( ; !(p_prev == ((struct dvbpsi_psi_section_s *)NULL)); p_prev = p_prev->p_next)
  {
    p_prev->i_last_number = p_current->i_number;
    dvbpsi_BuildPSISection(p_dvbpsi, p_prev);
  }
  return p_result;
}

// dvbpsi_nit_ts_add
// file tables/nit.c line 235
struct dvbpsi_nit_ts_s * dvbpsi_nit_ts_add(struct dvbpsi_nit_s *p_nit, unsigned short int i_ts_id, unsigned short int i_orig_network_id)
{
  struct dvbpsi_nit_ts_s *p_ts;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_nit_ts_s) /*24ul*/ );
  p_ts = (struct dvbpsi_nit_ts_s *)return_value_malloc$1;
  if(p_ts == ((struct dvbpsi_nit_ts_s *)NULL))
    return (struct dvbpsi_nit_ts_s *)(void *)0;

  else
  {
    p_ts->i_ts_id = i_ts_id;
    p_ts->i_orig_network_id = i_orig_network_id;
    p_ts->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
    p_ts->p_next = (struct dvbpsi_nit_ts_s *)(void *)0;
    if(p_nit->p_first_ts == ((struct dvbpsi_nit_ts_s *)NULL))
      p_nit->p_first_ts = p_ts;

    else
    {
      struct dvbpsi_nit_ts_s *p_last_ts = p_nit->p_first_ts;
      for( ; !(p_last_ts->p_next == ((struct dvbpsi_nit_ts_s *)NULL)); p_last_ts = p_last_ts->p_next)
        ;
      p_last_ts->p_next = p_ts;
    }
    return p_ts;
  }
}

// dvbpsi_nit_ts_descriptor_add
// file tables/nit.c line 264
struct dvbpsi_descriptor_s * dvbpsi_nit_ts_descriptor_add(struct dvbpsi_nit_ts_s *p_ts, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_ts->p_first_descriptor=dvbpsi_AddDescriptor(p_ts->p_first_descriptor, p_descriptor);
    /* assertion p_ts->p_first_descriptor */
    assert(p_ts->p_first_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
    if(p_ts->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
      return p_descriptor;
  }
}

// dvbpsi_packet_push
// file ../../src/dvbpsi.h line 199
_Bool dvbpsi_packet_push(struct dvbpsi_s *p_dvbpsi, unsigned char *p_data)
{
  unsigned char i_expected_counter;
  struct dvbpsi_psi_section_s *p_section;
  unsigned char *p_payload_pos;
  unsigned char *p_new_pos = (unsigned char *)(void *)0;
  signed int i_available;
  struct dvbpsi_decoder_s *p_decoder = p_dvbpsi->p_decoder;
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  _Bool tmp_if_expr$2;
  _Bool return_value_dvbpsi_ValidPSISection$1;
  if(!((signed int)*p_data == 0x47))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): not a TS packet", (const void *)"PSI decoder");
    return (_Bool)0;
  }

  else
  {
    _Bool b_first = (signed int)p_decoder->i_continuity_counter == 0xFF;
    if(!(b_first == (_Bool)0))
      p_decoder->i_continuity_counter = (unsigned char)((signed int)p_data[(signed long int)3] & 0xf);

    else
    {
      i_expected_counter = (unsigned char)((signed int)p_decoder->i_continuity_counter + 1 & 0xf);
      p_decoder->i_continuity_counter = (unsigned char)((signed int)p_data[(signed long int)3] & 0xf);
      if((signed int)i_expected_counter == (1 + (signed int)p_decoder->i_continuity_counter & 0xf))
      {
        if(p_decoder->b_discontinuity == (_Bool)0)
        {
          dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): TS duplicate (received %d, expected %d) for PID %d", (const void *)"PSI decoder", p_decoder->i_continuity_counter, i_expected_counter, (signed int)(unsigned short int)((signed int)p_data[(signed long int)1] & 0x1f) << 8 | (signed int)p_data[(signed long int)2]);
          return (_Bool)0;
        }

      }

      if(!(i_expected_counter == p_decoder->i_continuity_counter))
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): TS discontinuity (received %d, expected %d) for PID %d", (const void *)"PSI decoder", p_decoder->i_continuity_counter, i_expected_counter, (signed int)(unsigned short int)((signed int)p_data[(signed long int)1] & 0x1f) << 8 | (signed int)p_data[(signed long int)2]);
        p_decoder->b_discontinuity = (_Bool)1;
        if(!(p_decoder->p_current_section == ((struct dvbpsi_psi_section_s *)NULL)))
        {
          dvbpsi_DeletePSISections(p_decoder->p_current_section);
          p_decoder->p_current_section = (struct dvbpsi_psi_section_s *)(void *)0;
        }

      }

    }
    if((0x10 & (signed int)p_data[3l]) == 0)
      return (_Bool)0;

    else
    {
      if(!((0x20 & (signed int)p_data[3l]) == 0))
        p_payload_pos = p_data + (signed long int)5 + (signed long int)p_data[(signed long int)4];

      else
        p_payload_pos = p_data + (signed long int)4;
      if(!((0x40 & (signed int)p_data[1l]) == 0))
      {
        p_new_pos = p_payload_pos + (signed long int)*p_payload_pos + (signed long int)1;
        p_payload_pos = p_payload_pos + (signed long int)1;
      }

      p_section = p_decoder->p_current_section;
      if(p_section == ((struct dvbpsi_psi_section_s *)NULL))
      {
        if(!(p_new_pos == ((unsigned char *)NULL)))
        {
          p_section=dvbpsi_NewPSISection(p_decoder->i_section_max_size);
          p_decoder->p_current_section = p_section;
          if(p_section == ((struct dvbpsi_psi_section_s *)NULL))
            return (_Bool)0;

          p_payload_pos = p_new_pos;
          p_new_pos = (unsigned char *)(void *)0;
          p_decoder->i_need = 3;
          p_decoder->b_complete_header = (_Bool)0;
          goto __CPROVER_DUMP_L11;
        }

        return (_Bool)0;
      }

      else
      {

      __CPROVER_DUMP_L11:
        ;
        i_available = (signed int)(((signed long int)188 + p_data) - p_payload_pos);
        while(i_available >= 1)
          if(i_available >= p_decoder->i_need)
          {
            memcpy((void *)p_section->p_payload_end, (const void *)p_payload_pos, (unsigned long int)p_decoder->i_need);
            p_payload_pos = p_payload_pos + (signed long int)p_decoder->i_need;
            p_section->p_payload_end = p_section->p_payload_end + (signed long int)p_decoder->i_need;
            i_available = i_available - p_decoder->i_need;
            if(p_decoder->b_complete_header == (_Bool)0)
            {
              p_decoder->b_complete_header = (_Bool)1;
              p_section->i_length = (unsigned short int)((signed int)(unsigned short int)((signed int)p_section->p_data[(signed long int)1] & 0xf) << 8 | (signed int)p_section->p_data[(signed long int)2]);
              p_decoder->i_need = (signed int)p_section->i_length;
              if(!(p_decoder->i_section_max_size + -3 >= p_decoder->i_need))
              {
                dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): PSI section too long", (const void *)"PSI decoder");
                dvbpsi_DeletePSISections(p_section);
                p_decoder->p_current_section = (struct dvbpsi_psi_section_s *)(void *)0;
                if(!(p_new_pos == ((unsigned char *)NULL)))
                {
                  p_section=dvbpsi_NewPSISection(p_decoder->i_section_max_size);
                  p_decoder->p_current_section = p_section;
                  if(p_section == ((struct dvbpsi_psi_section_s *)NULL))
                    return (_Bool)0;

                  p_payload_pos = p_new_pos;
                  p_new_pos = (unsigned char *)(void *)0;
                  p_decoder->i_need = 3;
                  p_decoder->b_complete_header = (_Bool)0;
                  i_available = (signed int)(((signed long int)188 + p_data) - p_payload_pos);
                }

                else
                  i_available = 0;
              }

            }

            else
            {
              _Bool b_valid_crc32 = (_Bool)0;
              _Bool has_crc32;
              p_section->i_table_id = p_section->p_data[(signed long int)0];
              p_section->b_syntax_indicator = (_Bool)((signed int)p_section->p_data[(signed long int)1] & 0x80);
              p_section->b_private_indicator = (_Bool)((signed int)p_section->p_data[(signed long int)1] & 0x40);
              has_crc32=dvbpsi_has_CRC32(p_section);
              if(!(p_section->b_syntax_indicator == (_Bool)0) || !(has_crc32 == (_Bool)0))
                p_section->p_payload_end = p_section->p_payload_end - (signed long int)4;

              if(!(has_crc32 == (_Bool)0))
                b_valid_crc32=dvbpsi_ValidPSISection(p_section);

              if(has_crc32 == (_Bool)0 || !(b_valid_crc32 == (_Bool)0))
              {
                if(!(p_section->b_syntax_indicator == (_Bool)0))
                {
                  p_section->i_extension = (unsigned short int)((signed int)p_section->p_data[(signed long int)3] << 8 | (signed int)p_section->p_data[(signed long int)4]);
                  p_section->i_version = (unsigned char)(((signed int)p_section->p_data[(signed long int)5] & 0x3e) >> 1);
                  p_section->b_current_next = (_Bool)((signed int)p_section->p_data[(signed long int)5] & 0x1);
                  p_section->i_number = p_section->p_data[(signed long int)6];
                  p_section->i_last_number = p_section->p_data[(signed long int)7];
                  p_section->p_payload_start = p_section->p_data + (signed long int)8;
                }

                else
                {
                  p_section->i_extension = (unsigned short int)0;
                  p_section->i_version = (unsigned char)0;
                  p_section->b_current_next = (_Bool)1;
                  p_section->i_number = (unsigned char)0;
                  p_section->i_last_number = (unsigned char)0;
                  p_section->p_payload_start = p_section->p_data + (signed long int)3;
                }
                if(!(p_decoder->pf_gather == ((void (*)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *))NULL)))
                  p_decoder->pf_gather(p_dvbpsi, p_section);

                p_decoder->p_current_section = (struct dvbpsi_psi_section_s *)(void *)0;
              }

              else
              {
                if(!(has_crc32 == (_Bool)0))
                {
                  return_value_dvbpsi_ValidPSISection$1=dvbpsi_ValidPSISection(p_section);
                  tmp_if_expr$2 = !(return_value_dvbpsi_ValidPSISection$1 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$2 = (_Bool)0;
                if(tmp_if_expr$2)
                  dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): Bad CRC_32 table 0x%x !!!", (const void *)"misc PSI", p_section->p_data[(signed long int)0]);

                else
                  dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): table 0x%x", (const void *)"misc PSI", p_section->p_data[(signed long int)0]);
                dvbpsi_DeletePSISections(p_section);
                p_decoder->p_current_section = (struct dvbpsi_psi_section_s *)(void *)0;
              }
              if(p_new_pos == ((unsigned char *)NULL) && !(i_available == 0))
              {
                if(!((signed int)*p_payload_pos == 0xff))
                  p_new_pos = p_payload_pos;

              }

              if(!(p_new_pos == ((unsigned char *)NULL)))
              {
                p_section=dvbpsi_NewPSISection(p_decoder->i_section_max_size);
                p_decoder->p_current_section = p_section;
                if(p_section == ((struct dvbpsi_psi_section_s *)NULL))
                  return (_Bool)0;

                p_payload_pos = p_new_pos;
                p_new_pos = (unsigned char *)(void *)0;
                p_decoder->i_need = 3;
                p_decoder->b_complete_header = (_Bool)0;
                i_available = (signed int)(((signed long int)188 + p_data) - p_payload_pos);
              }

              else
                i_available = 0;
            }
          }

          else
          {
            memcpy((void *)p_section->p_payload_end, (const void *)p_payload_pos, (unsigned long int)i_available);
            p_section->p_payload_end = p_section->p_payload_end + (signed long int)i_available;
            p_decoder->i_need = p_decoder->i_need - i_available;
            i_available = 0;
          }
        return (_Bool)1;
      }
    }
  }
}

// dvbpsi_pat_attach
// file ../../src/tables/pat.h line 111
_Bool dvbpsi_pat_attach(struct dvbpsi_s *p_dvbpsi, void (*pf_callback)(void *, struct dvbpsi_pat_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder == ((void *)0) */
  assert(p_dvbpsi->p_decoder == (struct dvbpsi_decoder_s *)(void *)0);
  struct dvbpsi_pat_decoder_s *p_pat_decoder;
  void *return_value_dvbpsi_decoder_new$1;
  return_value_dvbpsi_decoder_new$1=dvbpsi_decoder_new(dvbpsi_pat_sections_gather, 1024, (const _Bool)1, sizeof(struct dvbpsi_pat_decoder_s) /*80ul*/ );
  p_pat_decoder = (struct dvbpsi_pat_decoder_s *)return_value_dvbpsi_decoder_new$1;
  if(p_pat_decoder == ((struct dvbpsi_pat_decoder_s *)NULL))
    return (_Bool)0;

  else
  {
    p_pat_decoder->pf_pat_callback = pf_callback;
    p_pat_decoder->p_cb_data = p_cb_data;
    p_pat_decoder->p_building_pat = (struct dvbpsi_pat_s *)(void *)0;
    p_dvbpsi->p_decoder = (struct dvbpsi_decoder_s *)p_pat_decoder;
    return (_Bool)1;
  }
}

// dvbpsi_pat_delete
// file ../../src/tables/pat.h line 171
void dvbpsi_pat_delete(struct dvbpsi_pat_s *p_pat)
{
  if(!(p_pat == ((struct dvbpsi_pat_s *)NULL)))
    dvbpsi_pat_empty(p_pat);

  free((void *)p_pat);
}

// dvbpsi_pat_detach
// file ../../src/tables/pat.h line 125
void dvbpsi_pat_detach(struct dvbpsi_s *p_dvbpsi)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_pat_decoder_s *p_pat_decoder = (struct dvbpsi_pat_decoder_s *)p_dvbpsi->p_decoder;
  if(!(p_pat_decoder->p_building_pat == ((struct dvbpsi_pat_s *)NULL)))
    dvbpsi_pat_delete(p_pat_decoder->p_building_pat);

  p_pat_decoder->p_building_pat = (struct dvbpsi_pat_s *)(void *)0;
  dvbpsi_decoder_delete(p_dvbpsi->p_decoder);
  p_dvbpsi->p_decoder = (struct dvbpsi_decoder_s *)(void *)0;
}

// dvbpsi_pat_empty
// file tables/pat.c line 129
void dvbpsi_pat_empty(struct dvbpsi_pat_s *p_pat)
{
  struct dvbpsi_pat_program_s *p_program = p_pat->p_first_program;
  while(!(p_program == ((struct dvbpsi_pat_program_s *)NULL)))
  {
    struct dvbpsi_pat_program_s *p_tmp = p_program->p_next;
    free((void *)p_program);
    p_program = p_tmp;
  }
  p_pat->p_first_program = (struct dvbpsi_pat_program_s *)(void *)0;
}

// dvbpsi_pat_init
// file tables/pat.c line 99
void dvbpsi_pat_init(struct dvbpsi_pat_s *p_pat, unsigned short int i_ts_id, unsigned char i_version, _Bool b_current_next)
{
  /* assertion p_pat */
  assert(p_pat != ((struct dvbpsi_pat_s *)NULL));
  p_pat->i_ts_id = i_ts_id;
  p_pat->i_version = i_version;
  p_pat->b_current_next = b_current_next;
  p_pat->p_first_program = (struct dvbpsi_pat_program_s *)(void *)0;
}

// dvbpsi_pat_new
// file tables/pat.c line 115
struct dvbpsi_pat_s * dvbpsi_pat_new(unsigned short int i_ts_id, unsigned char i_version, _Bool b_current_next)
{
  struct dvbpsi_pat_s *p_pat;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_pat_s) /*16ul*/ );
  p_pat = (struct dvbpsi_pat_s *)return_value_malloc$1;
  if(!(p_pat == ((struct dvbpsi_pat_s *)NULL)))
    dvbpsi_pat_init(p_pat, i_ts_id, i_version, b_current_next);

  return p_pat;
}

// dvbpsi_pat_program_add
// file tables/pat.c line 159
struct dvbpsi_pat_program_s * dvbpsi_pat_program_add(struct dvbpsi_pat_s *p_pat, unsigned short int i_number, unsigned short int i_pid)
{
  struct dvbpsi_pat_program_s *p_program;
  if((signed int)i_pid == 0)
    return (struct dvbpsi_pat_program_s *)(void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct dvbpsi_pat_program_s) /*16ul*/ );
    p_program = (struct dvbpsi_pat_program_s *)return_value_malloc$1;
    if(p_program == ((struct dvbpsi_pat_program_s *)NULL))
      return (struct dvbpsi_pat_program_s *)(void *)0;

    else
    {
      p_program->i_number = i_number;
      p_program->i_pid = i_pid;
      p_program->p_next = (struct dvbpsi_pat_program_s *)(void *)0;
      if(p_pat->p_first_program == ((struct dvbpsi_pat_program_s *)NULL))
        p_pat->p_first_program = p_program;

      else
      {
        struct dvbpsi_pat_program_s *p_last_program = p_pat->p_first_program;
        for( ; !(p_last_program->p_next == ((struct dvbpsi_pat_program_s *)NULL)); p_last_program = p_last_program->p_next)
          ;
        p_last_program->p_next = p_program;
      }
      return p_program;
    }
  }
}

// dvbpsi_pat_sections_decode
// file tables/pat.c line 359
_Bool dvbpsi_pat_sections_decode(struct dvbpsi_pat_s *p_pat, struct dvbpsi_psi_section_s *p_section)
{
  _Bool b_valid = (_Bool)0;
  for( ; !(p_section == ((struct dvbpsi_psi_section_s *)NULL)); p_section = p_section->p_next)
  {
    unsigned char *p_byte = p_section->p_payload_start;
    for( ; !(p_byte >= p_section->p_payload_end); p_byte = p_byte + (signed long int)4)
    {
      unsigned short int i_program_number = (unsigned short int)((signed int)(unsigned short int)p_byte[(signed long int)0] << 8 | (signed int)p_byte[(signed long int)1]);
      unsigned short int i_pid = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)2] & 0x1f) << 8 | (signed int)p_byte[(signed long int)3]);
      struct dvbpsi_pat_program_s *p_program;
      p_program=dvbpsi_pat_program_add(p_pat, i_program_number, i_pid);
      if(!(p_program == ((struct dvbpsi_pat_program_s *)NULL)))
        b_valid = (_Bool)1;

    }
  }
  return b_valid;
}

// dvbpsi_pat_sections_gather
// file tables/pat.c line 274
void dvbpsi_pat_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section)
{
  struct dvbpsi_pat_decoder_s *p_pat_decoder;
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  _Bool return_value_dvbpsi_CheckPSISection$1;
  return_value_dvbpsi_CheckPSISection$1=dvbpsi_CheckPSISection(p_dvbpsi, p_section, (const unsigned char)0x00, "PAT decoder");
  if(return_value_dvbpsi_CheckPSISection$1 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    p_pat_decoder = (struct dvbpsi_pat_decoder_s *)p_dvbpsi->p_decoder;
    if(!(p_pat_decoder->b_discontinuity == (_Bool)0))
    {
      dvbpsi_ReInitPAT(p_pat_decoder, (const _Bool)1);
      p_pat_decoder->b_discontinuity = (_Bool)0;
    }

    else
      if(!(p_pat_decoder->p_building_pat == ((struct dvbpsi_pat_s *)NULL)))
      {
        _Bool return_value_dvbpsi_CheckPAT$2;
        return_value_dvbpsi_CheckPAT$2=dvbpsi_CheckPAT(p_dvbpsi, p_section);
        if(!(return_value_dvbpsi_CheckPAT$2 == (_Bool)0))
          dvbpsi_ReInitPAT(p_pat_decoder, (const _Bool)1);

      }

      else
        if(!(p_pat_decoder->b_current_valid == (_Bool)0))
        {
          if(p_pat_decoder->current_pat.i_version == p_section->i_version)
          {
            if(p_pat_decoder->current_pat.b_current_next == p_section->b_current_next)
            {
              dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"PAT decoder", p_section->i_number);
              dvbpsi_DeletePSISections(p_section);
              goto __CPROVER_DUMP_L10;
            }

          }

        }

    _Bool return_value_dvbpsi_AddSectionPAT$3;
    return_value_dvbpsi_AddSectionPAT$3=dvbpsi_AddSectionPAT(p_dvbpsi, p_pat_decoder, p_section);
    if(return_value_dvbpsi_AddSectionPAT$3 == (_Bool)0)
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"PAT decoder", p_section->i_number);
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      _Bool return_value_dvbpsi_decoder_psi_sections_completed$5;
      return_value_dvbpsi_decoder_psi_sections_completed$5=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_pat_decoder);
      if(!(return_value_dvbpsi_decoder_psi_sections_completed$5 == (_Bool)0))
      {
        /* assertion p_pat_decoder->pf_pat_callback */
        assert(p_pat_decoder->pf_pat_callback != ((void (*)(void *, struct dvbpsi_pat_s *))NULL));
        p_pat_decoder->current_pat = *p_pat_decoder->p_building_pat;
        _Bool return_value_dvbpsi_pat_sections_decode$4;
        return_value_dvbpsi_pat_sections_decode$4=dvbpsi_pat_sections_decode(p_pat_decoder->p_building_pat, p_pat_decoder->p_sections);
        if(!(return_value_dvbpsi_pat_sections_decode$4 == (_Bool)0))
          p_pat_decoder->b_current_valid = (_Bool)1;

        if(!(p_pat_decoder->b_current_valid == (_Bool)0))
          p_pat_decoder->pf_pat_callback(p_pat_decoder->p_cb_data, p_pat_decoder->p_building_pat);

        dvbpsi_ReInitPAT(p_pat_decoder, !(p_pat_decoder->b_current_valid != (_Bool)0));
        /* assertion p_pat_decoder->p_sections == ((void *)0) */
        assert(p_pat_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
      }

    }
  }

__CPROVER_DUMP_L10:
  ;
}

// dvbpsi_pat_sections_generate
// file tables/pat.c line 386
struct dvbpsi_psi_section_s * dvbpsi_pat_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_pat_s *p_pat, signed int i_max_pps)
{
  struct dvbpsi_psi_section_s *p_result;
  p_result=dvbpsi_NewPSISection(1024);
  struct dvbpsi_psi_section_s *p_current = p_result;
  struct dvbpsi_psi_section_s *p_prev;
  struct dvbpsi_pat_program_s *p_program = p_pat->p_first_program;
  signed int i_count = 0;
  if(p_current == ((struct dvbpsi_psi_section_s *)NULL))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed to allocate new PSI section", (const void *)"PAT encoder");
    return (struct dvbpsi_psi_section_s *)(void *)0;
  }

  else
  {
    if(i_max_pps >= 254 || !(i_max_pps >= 1))
      i_max_pps = 253;

    p_current->i_table_id = (unsigned char)0;
    p_current->b_syntax_indicator = (_Bool)1;
    p_current->b_private_indicator = (_Bool)0;
    p_current->i_length = (unsigned short int)9;
    p_current->i_extension = p_pat->i_ts_id;
    p_current->i_version = p_pat->i_version;
    p_current->b_current_next = p_pat->b_current_next;
    p_current->i_number = (unsigned char)0;
    p_current->p_payload_end = p_current->p_payload_end + (signed long int)8;
    p_current->p_payload_start = p_current->p_payload_end;
    for( ; !(p_program == ((struct dvbpsi_pat_program_s *)NULL)); p_program = p_program->p_next)
    {
      i_count = i_count + 1;
      if(!(i_max_pps >= i_count))
      {
        p_prev = p_current;
        p_current=dvbpsi_NewPSISection(1024);
        if(p_current == ((struct dvbpsi_psi_section_s *)NULL))
        {
          dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed to allocate new PSI section", (const void *)"PAT encoder");
          goto error;
        }

        p_prev->p_next = p_current;
        i_count = 1;
        p_current->i_table_id = (unsigned char)0;
        p_current->b_syntax_indicator = (_Bool)1;
        p_current->b_private_indicator = (_Bool)0;
        p_current->i_length = (unsigned short int)9;
        p_current->i_extension = p_pat->i_ts_id;
        p_current->i_version = p_pat->i_version;
        p_current->b_current_next = p_pat->b_current_next;
        p_current->i_number = (unsigned char)((signed int)p_prev->i_number + 1);
        p_current->p_payload_end = p_current->p_payload_end + (signed long int)8;
        p_current->p_payload_start = p_current->p_payload_end;
      }

      p_current->p_payload_end[(signed long int)0] = (unsigned char)((signed int)p_program->i_number >> 8);
      p_current->p_payload_end[(signed long int)1] = (unsigned char)p_program->i_number;
      p_current->p_payload_end[(signed long int)2] = (unsigned char)((signed int)p_program->i_pid >> 8 | 0xe0);
      p_current->p_payload_end[(signed long int)3] = (unsigned char)p_program->i_pid;
      p_current->p_payload_end = p_current->p_payload_end + (signed long int)4;
      p_current->i_length = p_current->i_length + (unsigned short int)4;
    }
    p_prev = p_result;
    for( ; !(p_prev == ((struct dvbpsi_psi_section_s *)NULL)); p_prev = p_prev->p_next)
    {
      p_prev->i_last_number = p_current->i_number;
      dvbpsi_BuildPSISection(p_dvbpsi, p_prev);
    }
    return p_result;

  error:
    ;
    p_prev = p_result;
    dvbpsi_DeletePSISections(p_prev);
    return (struct dvbpsi_psi_section_s *)(void *)0;
  }
}

// dvbpsi_pmt_attach
// file ../../src/tables/pmt.h line 121
_Bool dvbpsi_pmt_attach(struct dvbpsi_s *p_dvbpsi, unsigned short int i_program_number, void (*pf_callback)(void *, struct dvbpsi_pmt_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder == ((void *)0) */
  assert(p_dvbpsi->p_decoder == (struct dvbpsi_decoder_s *)(void *)0);
  struct dvbpsi_pmt_decoder_s *p_pmt_decoder;
  void *return_value_dvbpsi_decoder_new$1;
  return_value_dvbpsi_decoder_new$1=dvbpsi_decoder_new(dvbpsi_pmt_sections_gather, 1024, (const _Bool)1, sizeof(struct dvbpsi_pmt_decoder_s) /*96ul*/ );
  p_pmt_decoder = (struct dvbpsi_pmt_decoder_s *)return_value_dvbpsi_decoder_new$1;
  if(p_pmt_decoder == ((struct dvbpsi_pmt_decoder_s *)NULL))
    return (_Bool)0;

  else
  {
    p_dvbpsi->p_decoder = (struct dvbpsi_decoder_s *)p_pmt_decoder;
    p_pmt_decoder->i_program_number = i_program_number;
    p_pmt_decoder->pf_pmt_callback = pf_callback;
    p_pmt_decoder->p_cb_data = p_cb_data;
    p_pmt_decoder->p_building_pmt = (struct dvbpsi_pmt_s *)(void *)0;
    return (_Bool)1;
  }
}

// dvbpsi_pmt_delete
// file ../../src/tables/pmt.h line 186
void dvbpsi_pmt_delete(struct dvbpsi_pmt_s *p_pmt)
{
  if(!(p_pmt == ((struct dvbpsi_pmt_s *)NULL)))
    dvbpsi_pmt_empty(p_pmt);

  free((void *)p_pmt);
}

// dvbpsi_pmt_descriptor_add
// file tables/pmt.c line 171
struct dvbpsi_descriptor_s * dvbpsi_pmt_descriptor_add(struct dvbpsi_pmt_s *p_pmt, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_pmt->p_first_descriptor=dvbpsi_AddDescriptor(p_pmt->p_first_descriptor, p_descriptor);
    /* assertion p_pmt->p_first_descriptor */
    assert(p_pmt->p_first_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
    if(p_pmt->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
      return p_descriptor;
  }
}

// dvbpsi_pmt_detach
// file ../../src/tables/pmt.h line 135
void dvbpsi_pmt_detach(struct dvbpsi_s *p_dvbpsi)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_pmt_decoder_s *p_pmt_decoder = (struct dvbpsi_pmt_decoder_s *)p_dvbpsi->p_decoder;
  if(!(p_pmt_decoder->p_building_pmt == ((struct dvbpsi_pmt_s *)NULL)))
    dvbpsi_pmt_delete(p_pmt_decoder->p_building_pmt);

  p_pmt_decoder->p_building_pmt = (struct dvbpsi_pmt_s *)(void *)0;
  dvbpsi_decoder_delete(p_dvbpsi->p_decoder);
  p_dvbpsi->p_decoder = (struct dvbpsi_decoder_s *)(void *)0;
}

// dvbpsi_pmt_empty
// file tables/pmt.c line 136
void dvbpsi_pmt_empty(struct dvbpsi_pmt_s *p_pmt)
{
  struct dvbpsi_pmt_es_s *p_es = p_pmt->p_first_es;
  dvbpsi_DeleteDescriptors(p_pmt->p_first_descriptor);
  while(!(p_es == ((struct dvbpsi_pmt_es_s *)NULL)))
  {
    struct dvbpsi_pmt_es_s *p_tmp = p_es->p_next;
    dvbpsi_DeleteDescriptors(p_es->p_first_descriptor);
    free((void *)p_es);
    p_es = p_tmp;
  }
  p_pmt->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
  p_pmt->p_first_es = (struct dvbpsi_pmt_es_s *)(void *)0;
}

// dvbpsi_pmt_es_add
// file tables/pmt.c line 194
struct dvbpsi_pmt_es_s * dvbpsi_pmt_es_add(struct dvbpsi_pmt_s *p_pmt, unsigned char i_type, unsigned short int i_pid)
{
  struct dvbpsi_pmt_es_s *p_es;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_pmt_es_s) /*24ul*/ );
  p_es = (struct dvbpsi_pmt_es_s *)return_value_malloc$1;
  if(p_es == ((struct dvbpsi_pmt_es_s *)NULL))
    return (struct dvbpsi_pmt_es_s *)(void *)0;

  else
  {
    p_es->i_type = i_type;
    p_es->i_pid = i_pid;
    p_es->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
    p_es->p_next = (struct dvbpsi_pmt_es_s *)(void *)0;
    if(p_pmt->p_first_es == ((struct dvbpsi_pmt_es_s *)NULL))
      p_pmt->p_first_es = p_es;

    else
    {
      struct dvbpsi_pmt_es_s *p_last_es = p_pmt->p_first_es;
      for( ; !(p_last_es->p_next == ((struct dvbpsi_pmt_es_s *)NULL)); p_last_es = p_last_es->p_next)
        ;
      p_last_es->p_next = p_es;
    }
    return p_es;
  }
}

// dvbpsi_pmt_es_descriptor_add
// file tables/pmt.c line 223
struct dvbpsi_descriptor_s * dvbpsi_pmt_es_descriptor_add(struct dvbpsi_pmt_es_s *p_es, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    if(p_es->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      p_es->p_first_descriptor = p_descriptor;

    else
    {
      struct dvbpsi_descriptor_s *p_last_descriptor = p_es->p_first_descriptor;
      for( ; !(p_last_descriptor->p_next == ((struct dvbpsi_descriptor_s *)NULL)); p_last_descriptor = p_last_descriptor->p_next)
        ;
      p_last_descriptor->p_next = p_descriptor;
    }
    return p_descriptor;
  }
}

// dvbpsi_pmt_init
// file tables/pmt.c line 103
void dvbpsi_pmt_init(struct dvbpsi_pmt_s *p_pmt, unsigned short int i_program_number, unsigned char i_version, _Bool b_current_next, unsigned short int i_pcr_pid)
{
  /* assertion p_pmt */
  assert(p_pmt != ((struct dvbpsi_pmt_s *)NULL));
  p_pmt->i_program_number = i_program_number;
  p_pmt->i_version = i_version;
  p_pmt->b_current_next = b_current_next;
  p_pmt->i_pcr_pid = i_pcr_pid;
  p_pmt->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
  p_pmt->p_first_es = (struct dvbpsi_pmt_es_s *)(void *)0;
}

// dvbpsi_pmt_new
// file tables/pmt.c line 121
struct dvbpsi_pmt_s * dvbpsi_pmt_new(unsigned short int i_program_number, unsigned char i_version, _Bool b_current_next, unsigned short int i_pcr_pid)
{
  struct dvbpsi_pmt_s *p_pmt;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_pmt_s) /*24ul*/ );
  p_pmt = (struct dvbpsi_pmt_s *)return_value_malloc$1;
  if(!(p_pmt == ((struct dvbpsi_pmt_s *)NULL)))
    dvbpsi_pmt_init(p_pmt, i_program_number, i_version, b_current_next, i_pcr_pid);

  return p_pmt;
}

// dvbpsi_pmt_sections_decode
// file tables/pmt.c line 411
void dvbpsi_pmt_sections_decode(struct dvbpsi_pmt_s *p_pmt, struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte;
  unsigned char *p_end;
  for( ; !(p_section == ((struct dvbpsi_psi_section_s *)NULL)); p_section = p_section->p_next)
  {
    p_byte = p_section->p_payload_start + (signed long int)4;
    p_end = p_byte + (signed long int)((signed int)(unsigned short int)((signed int)p_section->p_payload_start[(signed long int)2] & 0x0f) << 8 | (signed int)p_section->p_payload_start[(signed long int)3]);
    while(p_end >= p_byte + 2l)
    {
      unsigned char dvbpsi_pmt_sections_decode$$1$$1$$1$$i_tag = p_byte[(signed long int)0];
      unsigned char i_length = p_byte[(signed long int)1];
      if(p_end - p_byte >= (signed long int)(2 + (signed int)i_length))
        dvbpsi_pmt_descriptor_add(p_pmt, dvbpsi_pmt_sections_decode$$1$$1$$1$$i_tag, i_length, p_byte + (signed long int)2);

      p_byte = p_byte + (signed long int)(2 + (signed int)i_length);
    }
    p_byte = p_end;
    while(p_section->p_payload_end >= p_byte + 5l)
    {
      unsigned char i_type = p_byte[(signed long int)0];
      unsigned short int i_pid = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)1] & 0x1f) << 8 | (signed int)p_byte[(signed long int)2]);
      unsigned short int i_es_length = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)3] & 0x0f) << 8 | (signed int)p_byte[(signed long int)4]);
      struct dvbpsi_pmt_es_s *p_es;
      p_es=dvbpsi_pmt_es_add(p_pmt, i_type, i_pid);
      p_byte = p_byte + (signed long int)5;
      p_end = p_byte + (signed long int)i_es_length;
      if(!(p_section->p_payload_end >= p_end))
        p_end = p_section->p_payload_end;

      while(p_end >= p_byte + 2l)
      {
        unsigned char i_tag = p_byte[(signed long int)0];
        unsigned char dvbpsi_pmt_sections_decode$$1$$1$$2$$1$$2$$i_length = p_byte[(signed long int)1];
        if(p_end - p_byte >= (signed long int)(2 + (signed int)dvbpsi_pmt_sections_decode$$1$$1$$2$$1$$2$$i_length))
          dvbpsi_pmt_es_descriptor_add(p_es, i_tag, dvbpsi_pmt_sections_decode$$1$$1$$2$$1$$2$$i_length, p_byte + (signed long int)2);

        p_byte = p_byte + (signed long int)(2 + (signed int)dvbpsi_pmt_sections_decode$$1$$1$$2$$1$$2$$i_length);
      }
    }
  }
}

// dvbpsi_pmt_sections_gather
// file tables/pmt.c line 322
void dvbpsi_pmt_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  _Bool return_value_dvbpsi_CheckPSISection$1;
  return_value_dvbpsi_CheckPSISection$1=dvbpsi_CheckPSISection(p_dvbpsi, p_section, (const unsigned char)0x02, "PMT decoder");
  if(return_value_dvbpsi_CheckPSISection$1 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_pmt_decoder_s *p_pmt_decoder = (struct dvbpsi_pmt_decoder_s *)p_dvbpsi->p_decoder;
    /* assertion p_pmt_decoder */
    assert(p_pmt_decoder != ((struct dvbpsi_pmt_decoder_s *)NULL));
    if(!(p_pmt_decoder->i_program_number == p_section->i_extension))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring section %d not belonging to 'program_number' %d", (const void *)"PMT decoder", p_section->i_extension, p_pmt_decoder->i_program_number);
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      if(!(p_pmt_decoder->b_discontinuity == (_Bool)0))
      {
        dvbpsi_ReInitPMT(p_pmt_decoder, (const _Bool)1);
        p_pmt_decoder->b_discontinuity = (_Bool)0;
      }

      else
        if(!(p_pmt_decoder->p_building_pmt == ((struct dvbpsi_pmt_s *)NULL)))
        {
          _Bool return_value_dvbpsi_CheckPMT$2;
          return_value_dvbpsi_CheckPMT$2=dvbpsi_CheckPMT(p_dvbpsi, p_section);
          if(!(return_value_dvbpsi_CheckPMT$2 == (_Bool)0))
            dvbpsi_ReInitPMT(p_pmt_decoder, (const _Bool)1);

        }

        else
          if(!(p_pmt_decoder->b_current_valid == (_Bool)0))
          {
            if(p_pmt_decoder->current_pmt.i_version == p_section->i_version)
            {
              if(p_pmt_decoder->current_pmt.b_current_next == p_section->b_current_next)
              {
                dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"PMT decoder", p_section->i_number);
                dvbpsi_DeletePSISections(p_section);
                goto __CPROVER_DUMP_L9;
              }

            }

          }

      _Bool return_value_dvbpsi_AddSectionPMT$3;
      return_value_dvbpsi_AddSectionPMT$3=dvbpsi_AddSectionPMT(p_dvbpsi, p_pmt_decoder, p_section);
      if(return_value_dvbpsi_AddSectionPMT$3 == (_Bool)0)
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"PMT decoder", p_section->i_number);
        dvbpsi_DeletePSISections(p_section);
      }

      else
      {
        _Bool return_value_dvbpsi_decoder_psi_sections_completed$4;
        return_value_dvbpsi_decoder_psi_sections_completed$4=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_pmt_decoder);
        if(!(return_value_dvbpsi_decoder_psi_sections_completed$4 == (_Bool)0))
        {
          /* assertion p_pmt_decoder->pf_pmt_callback */
          assert(p_pmt_decoder->pf_pmt_callback != ((void (*)(void *, struct dvbpsi_pmt_s *))NULL));
          p_pmt_decoder->current_pmt = *p_pmt_decoder->p_building_pmt;
          p_pmt_decoder->b_current_valid = (_Bool)1;
          dvbpsi_pmt_sections_decode(p_pmt_decoder->p_building_pmt, p_pmt_decoder->p_sections);
          p_pmt_decoder->pf_pmt_callback(p_pmt_decoder->p_cb_data, p_pmt_decoder->p_building_pmt);
          dvbpsi_ReInitPMT(p_pmt_decoder, (const _Bool)0);
          /* assertion p_pmt_decoder->p_sections == ((void *)0) */
          assert(p_pmt_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
        }

      }
    }
  }

__CPROVER_DUMP_L9:
  ;
}

// dvbpsi_pmt_sections_generate
// file tables/pmt.c line 463
struct dvbpsi_psi_section_s * dvbpsi_pmt_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_pmt_s *p_pmt)
{
  struct dvbpsi_psi_section_s *p_result;
  p_result=dvbpsi_NewPSISection(1024);
  struct dvbpsi_psi_section_s *p_current = p_result;
  struct dvbpsi_psi_section_s *p_prev;
  struct dvbpsi_descriptor_s *p_descriptor = p_pmt->p_first_descriptor;
  struct dvbpsi_pmt_es_s *p_es = p_pmt->p_first_es;
  unsigned short int i_info_length;
  p_current->i_table_id = (unsigned char)0x02;
  p_current->b_syntax_indicator = (_Bool)1;
  p_current->b_private_indicator = (_Bool)0;
  p_current->i_length = (unsigned short int)13;
  p_current->i_extension = p_pmt->i_program_number;
  p_current->i_version = p_pmt->i_version;
  p_current->b_current_next = p_pmt->b_current_next;
  p_current->i_number = (unsigned char)0;
  p_current->p_payload_end = p_current->p_payload_end + (signed long int)12;
  p_current->p_payload_start = p_current->p_data + (signed long int)8;
  p_current->p_data[(signed long int)8] = (unsigned char)((signed int)p_pmt->i_pcr_pid >> 8 | 0xe0);
  p_current->p_data[(signed long int)9] = (unsigned char)p_pmt->i_pcr_pid;
  for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
  {
    if((p_current->p_payload_end - p_current->p_data) + (signed long int)p_descriptor->i_length >= 1019l)
    {
      i_info_length = (unsigned short int)((p_current->p_payload_end - p_current->p_data) - (signed long int)12);
      p_current->p_data[(signed long int)10] = (unsigned char)((signed int)i_info_length >> 8 | 0xf0);
      p_current->p_data[(signed long int)11] = (unsigned char)i_info_length;
      p_prev = p_current;
      p_current=dvbpsi_NewPSISection(1024);
      p_prev->p_next = p_current;
      p_current->i_table_id = (unsigned char)0x02;
      p_current->b_syntax_indicator = (_Bool)1;
      p_current->b_private_indicator = (_Bool)0;
      p_current->i_length = (unsigned short int)13;
      p_current->i_extension = p_pmt->i_program_number;
      p_current->i_version = p_pmt->i_version;
      p_current->b_current_next = p_pmt->b_current_next;
      p_current->i_number = (unsigned char)((signed int)p_prev->i_number + 1);
      p_current->p_payload_end = p_current->p_payload_end + (signed long int)12;
      p_current->p_payload_start = p_current->p_data + (signed long int)8;
      p_current->p_data[(signed long int)8] = (unsigned char)((signed int)p_pmt->i_pcr_pid >> 8 | 0xe0);
      p_current->p_data[(signed long int)9] = (unsigned char)p_pmt->i_pcr_pid;
    }

    p_current->p_payload_end[(signed long int)0] = p_descriptor->i_tag;
    p_current->p_payload_end[(signed long int)1] = p_descriptor->i_length;
    memcpy((void *)(p_current->p_payload_end + (signed long int)2), (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
    p_current->p_payload_end = p_current->p_payload_end + (signed long int)((signed int)p_descriptor->i_length + 2);
    p_current->i_length = p_current->i_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
  }
  i_info_length = (unsigned short int)((p_current->p_payload_end - p_current->p_data) - (signed long int)12);
  p_current->p_data[(signed long int)10] = (unsigned char)((signed int)i_info_length >> 8 | 0xf0);
  p_current->p_data[(signed long int)11] = (unsigned char)i_info_length;
  while(!(p_es == ((struct dvbpsi_pmt_es_s *)NULL)))
  {
    unsigned char *p_es_start = p_current->p_payload_end;
    unsigned short int i_es_length = (unsigned short int)5;
    p_descriptor = p_es->p_first_descriptor;
    for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
    {
      if((p_es_start - p_current->p_data) + (signed long int)i_es_length >= 1021l)
        break;

      i_es_length = i_es_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
    }
    if(!(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)))
    {
      if(!(p_es_start - p_current->p_data == 12l))
      {
        if(!((signed int)i_es_length >= 1009))
        {
          dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): create a new section to carry more ES descriptors", (const void *)"PMT generator");
          p_prev = p_current;
          p_current=dvbpsi_NewPSISection(1024);
          p_prev->p_next = p_current;
          p_current->i_table_id = (unsigned char)0x02;
          p_current->b_syntax_indicator = (_Bool)1;
          p_current->b_private_indicator = (_Bool)0;
          p_current->i_length = (unsigned short int)13;
          p_current->i_extension = p_pmt->i_program_number;
          p_current->i_version = p_pmt->i_version;
          p_current->b_current_next = p_pmt->b_current_next;
          p_current->i_number = (unsigned char)((signed int)p_prev->i_number + 1);
          p_current->p_payload_end = p_current->p_payload_end + (signed long int)12;
          p_current->p_payload_start = p_current->p_data + (signed long int)8;
          p_current->p_data[(signed long int)8] = (unsigned char)((signed int)p_pmt->i_pcr_pid >> 8 | 0xe0);
          p_current->p_data[(signed long int)9] = (unsigned char)p_pmt->i_pcr_pid;
          i_info_length = (unsigned short int)0;
          p_current->p_data[(signed long int)10] = (unsigned char)0xf0;
          p_current->p_data[(signed long int)11] = (unsigned char)0x00;
          p_es_start = p_current->p_payload_end;
        }

      }

    }

    p_es_start[(signed long int)0] = p_es->i_type;
    p_es_start[(signed long int)1] = (unsigned char)((signed int)p_es->i_pid >> 8 | 0xe0);
    p_es_start[(signed long int)2] = (unsigned char)p_es->i_pid;
    p_current->p_payload_end = p_current->p_payload_end + (signed long int)5;
    p_current->i_length = p_current->i_length + (unsigned short int)5;
    p_descriptor = p_es->p_first_descriptor;
    for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
    {
      if((p_current->p_payload_end - p_current->p_data) + (signed long int)p_descriptor->i_length >= 1019l)
        break;

      p_current->p_payload_end[(signed long int)0] = p_descriptor->i_tag;
      p_current->p_payload_end[(signed long int)1] = p_descriptor->i_length;
      memcpy((void *)(p_current->p_payload_end + (signed long int)2), (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
      p_current->p_payload_end = p_current->p_payload_end + (signed long int)((signed int)p_descriptor->i_length + 2);
      p_current->i_length = p_current->i_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
    }
    if(!(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)))
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): unable to carry all the ES descriptors", (const void *)"PMT generator");

    i_es_length = (unsigned short int)((p_current->p_payload_end - p_es_start) - (signed long int)5);
    p_es_start[(signed long int)3] = (unsigned char)((signed int)i_es_length >> 8 | 0xf0);
    p_es_start[(signed long int)4] = (unsigned char)i_es_length;
    p_es = p_es->p_next;
  }
  p_prev = p_result;
  for( ; !(p_prev == ((struct dvbpsi_psi_section_s *)NULL)); p_prev = p_prev->p_next)
  {
    p_prev->i_last_number = p_current->i_number;
    dvbpsi_BuildPSISection(p_dvbpsi, p_prev);
  }
  return p_result;
}

// dvbpsi_rst_attach
// file ../../src/tables/rst.h line 109
_Bool dvbpsi_rst_attach(struct dvbpsi_s *p_dvbpsi, void (*pf_callback)(void *, struct dvbpsi_rst_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder == ((void *)0) */
  assert(p_dvbpsi->p_decoder == (struct dvbpsi_decoder_s *)(void *)0);
  struct dvbpsi_rst_decoder_s *p_rst_decoder;
  void *return_value_dvbpsi_decoder_new$1;
  return_value_dvbpsi_decoder_new$1=dvbpsi_decoder_new(dvbpsi_rst_sections_gather, 1024, (const _Bool)1, sizeof(struct dvbpsi_rst_decoder_s) /*72ul*/ );
  p_rst_decoder = (struct dvbpsi_rst_decoder_s *)return_value_dvbpsi_decoder_new$1;
  if(p_rst_decoder == ((struct dvbpsi_rst_decoder_s *)NULL))
    return (_Bool)0;

  else
  {
    p_rst_decoder->pf_rst_callback = pf_callback;
    p_rst_decoder->p_cb_data = p_cb_data;
    p_rst_decoder->p_building_rst = (struct dvbpsi_rst_s *)(void *)0;
    p_dvbpsi->p_decoder = (struct dvbpsi_decoder_s *)p_rst_decoder;
    return (_Bool)1;
  }
}

// dvbpsi_rst_delete
// file ../../src/tables/rst.h line 161
void dvbpsi_rst_delete(struct dvbpsi_rst_s *p_rst)
{
  if(!(p_rst == ((struct dvbpsi_rst_s *)NULL)))
    dvbpsi_rst_empty(p_rst);

  free((void *)p_rst);
}

// dvbpsi_rst_detach
// file ../../src/tables/rst.h line 124
void dvbpsi_rst_detach(struct dvbpsi_s *p_dvbpsi)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_rst_decoder_s *p_rst_decoder = (struct dvbpsi_rst_decoder_s *)p_dvbpsi->p_decoder;
  if(!(p_rst_decoder->p_building_rst == ((struct dvbpsi_rst_s *)NULL)))
    dvbpsi_rst_delete(p_rst_decoder->p_building_rst);

  p_rst_decoder->p_building_rst = (struct dvbpsi_rst_s *)(void *)0;
  dvbpsi_decoder_delete(p_dvbpsi->p_decoder);
  p_dvbpsi->p_decoder = (struct dvbpsi_decoder_s *)(void *)0;
}

// dvbpsi_rst_empty
// file tables/rst.c line 127
void dvbpsi_rst_empty(struct dvbpsi_rst_s *p_rst)
{
  struct dvbpsi_rst_event_s *p_rst_event = p_rst->p_first_event;
  while(!(p_rst_event == ((struct dvbpsi_rst_event_s *)NULL)))
  {
    struct dvbpsi_rst_event_s *p_next = p_rst_event->p_next;
    free((void *)p_rst_event);
    p_rst_event = p_next;
  }
  p_rst->p_first_event = (struct dvbpsi_rst_event_s *)(void *)0;
}

// dvbpsi_rst_event_add
// file tables/rst.c line 161
struct dvbpsi_rst_event_s * dvbpsi_rst_event_add(struct dvbpsi_rst_s *p_rst, unsigned short int i_ts_id, unsigned short int i_orig_network_id, unsigned short int i_service_id, unsigned short int i_event_id, unsigned char i_running_status)
{
  struct dvbpsi_rst_event_s *p_rst_event;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_rst_event_s) /*24ul*/ );
  p_rst_event = (struct dvbpsi_rst_event_s *)return_value_malloc$1;
  if(p_rst_event == ((struct dvbpsi_rst_event_s *)NULL))
    return (struct dvbpsi_rst_event_s *)(void *)0;

  else
  {
    p_rst_event->i_ts_id = i_ts_id;
    p_rst_event->i_orig_network_id = i_orig_network_id;
    p_rst_event->i_service_id = i_service_id;
    p_rst_event->i_event_id = i_event_id;
    p_rst_event->i_running_status = i_running_status;
    p_rst_event->p_next = (struct dvbpsi_rst_event_s *)(void *)0;
    if(p_rst->p_first_event == ((struct dvbpsi_rst_event_s *)NULL))
      p_rst->p_first_event = p_rst_event;

    else
    {
      struct dvbpsi_rst_event_s *p_last = p_rst->p_first_event;
      for( ; !(p_last->p_next == ((struct dvbpsi_rst_event_s *)NULL)); p_last = p_last->p_next)
        ;
      p_last->p_next = p_rst_event;
    }
    return p_rst_event;
  }
}

// dvbpsi_rst_init
// file tables/rst.c line 102
void dvbpsi_rst_init(struct dvbpsi_rst_s *p_rst)
{
  /* assertion p_rst */
  assert(p_rst != ((struct dvbpsi_rst_s *)NULL));
  p_rst->p_first_event = (struct dvbpsi_rst_event_s *)(void *)0;
}

// dvbpsi_rst_new
// file tables/rst.c line 114
struct dvbpsi_rst_s * dvbpsi_rst_new(void)
{
  struct dvbpsi_rst_s *p_rst;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_rst_s) /*8ul*/ );
  p_rst = (struct dvbpsi_rst_s *)return_value_malloc$1;
  if(!(p_rst == ((struct dvbpsi_rst_s *)NULL)))
    dvbpsi_rst_init(p_rst);

  return p_rst;
}

// dvbpsi_rst_reset
// file tables/rst.c line 259
static void dvbpsi_rst_reset(struct dvbpsi_rst_decoder_s *p_decoder, const _Bool b_force)
{
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_rst_decoder_s *)NULL));
  dvbpsi_decoder_reset((struct dvbpsi_decoder_s *)p_decoder, b_force);
  if(!(b_force == (_Bool)0))
  {
    if(!(p_decoder->p_building_rst == ((struct dvbpsi_rst_s *)NULL)))
      dvbpsi_rst_delete(p_decoder->p_building_rst);

  }

  p_decoder->p_building_rst = (struct dvbpsi_rst_s *)(void *)0;
}

// dvbpsi_rst_section_add
// file tables/rst.c line 275
static _Bool dvbpsi_rst_section_add(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_rst_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_decoder */
  assert(p_decoder != ((struct dvbpsi_rst_decoder_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(p_decoder->p_building_rst == ((struct dvbpsi_rst_s *)NULL))
  {
    p_decoder->p_building_rst=dvbpsi_rst_new();
    if(p_decoder->p_building_rst == ((struct dvbpsi_rst_s *)NULL))
      return (_Bool)0;

    p_decoder->i_last_section_number = p_section->i_last_number;
  }

  _Bool return_value_dvbpsi_decoder_psi_section_add$1;
  return_value_dvbpsi_decoder_psi_section_add$1=dvbpsi_decoder_psi_section_add((struct dvbpsi_decoder_s *)p_decoder, p_section);
  if(!(return_value_dvbpsi_decoder_psi_section_add$1 == (_Bool)0))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): overwrite section number %d", (const void *)"RST decoder", p_section->i_number);

  return (_Bool)1;
}

// dvbpsi_rst_section_check
// file tables/rst.c line 306
static _Bool dvbpsi_rst_section_check(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section, const unsigned char table_id, const char *psz_table_name)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_section */
  assert(p_section != ((struct dvbpsi_psi_section_s *)NULL));
  if(!(p_section->i_table_id == table_id))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): invalid section (table_id == 0x%02x expected 0x%02)", psz_table_name, p_section->i_table_id, table_id);

  else
    if(!(p_section->b_syntax_indicator == (_Bool)0))
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): invalid section (section_syntax_indicator != 0)", psz_table_name);

    else
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): Table version %2d, i_extension %5d, section %3d up to %3d, current %1d", psz_table_name, p_section->i_version, p_section->i_extension, p_section->i_number, p_section->i_last_number, p_section->b_current_next);
      return (_Bool)1;
    }

error:
  ;
  return (_Bool)0;
}

// dvbpsi_rst_sections_decode
// file tables/rst.c line 403
void dvbpsi_rst_sections_decode(struct dvbpsi_rst_s *p_rst, struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte;
  for( ; !(p_section == ((struct dvbpsi_psi_section_s *)NULL)); p_section = p_section->p_next)
  {
    p_byte = p_section->p_payload_start;
    while(p_section->p_payload_end >= p_byte + 9l)
    {
      unsigned short int i_transport_stream_id = (unsigned short int)(((signed int)p_byte[(signed long int)0] << 8) + (signed int)p_byte[(signed long int)1]);
      unsigned short int i_original_network_id = (unsigned short int)(((signed int)p_byte[(signed long int)2] << 8) + (signed int)p_byte[(signed long int)3]);
      unsigned short int i_service_id = (unsigned short int)(((signed int)p_byte[(signed long int)4] << 8) + (signed int)p_byte[(signed long int)5]);
      unsigned short int i_event_id = (unsigned short int)(((signed int)p_byte[(signed long int)6] << 8) + (signed int)p_byte[(signed long int)7]);
      unsigned char i_running_status = (unsigned char)((signed int)p_byte[(signed long int)8] & 0x07);
      dvbpsi_rst_event_add(p_rst, i_transport_stream_id, i_original_network_id, i_service_id, i_event_id, i_running_status);
      p_byte = p_byte + (signed long int)9;
    }
  }
}

// dvbpsi_rst_sections_gather
// file tables/rst.c line 346
void dvbpsi_rst_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  _Bool return_value_dvbpsi_rst_section_check$1;
  return_value_dvbpsi_rst_section_check$1=dvbpsi_rst_section_check(p_dvbpsi, p_section, (const unsigned char)0x71, "RST decoder");
  if(return_value_dvbpsi_rst_section_check$1 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_rst_decoder_s *p_rst_decoder = (struct dvbpsi_rst_decoder_s *)p_dvbpsi->p_decoder;
    if(!(p_rst_decoder->b_discontinuity == (_Bool)0))
    {
      dvbpsi_rst_reset(p_rst_decoder, (const _Bool)1);
      p_rst_decoder->b_discontinuity = (_Bool)0;
    }

    _Bool return_value_dvbpsi_rst_section_add$2;
    return_value_dvbpsi_rst_section_add$2=dvbpsi_rst_section_add(p_dvbpsi, p_rst_decoder, p_section);
    if(return_value_dvbpsi_rst_section_add$2 == (_Bool)0)
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"RST decoder", p_section->i_number);
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      _Bool return_value_dvbpsi_decoder_psi_sections_completed$3;
      return_value_dvbpsi_decoder_psi_sections_completed$3=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_rst_decoder);
      if(!(return_value_dvbpsi_decoder_psi_sections_completed$3 == (_Bool)0))
      {
        /* assertion p_rst_decoder->pf_rst_callback */
        assert(p_rst_decoder->pf_rst_callback != ((void (*)(void *, struct dvbpsi_rst_s *))NULL));
        p_rst_decoder->current_rst = *p_rst_decoder->p_building_rst;
        p_rst_decoder->b_current_valid = (_Bool)1;
        dvbpsi_rst_sections_decode(p_rst_decoder->p_building_rst, p_rst_decoder->p_sections);
        p_rst_decoder->pf_rst_callback(p_rst_decoder->p_cb_data, p_rst_decoder->p_building_rst);
        dvbpsi_rst_reset(p_rst_decoder, (const _Bool)0);
        /* assertion p_rst_decoder->p_sections == ((void *)0) */
        assert(p_rst_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
      }

    }
  }
}

// dvbpsi_rst_sections_generate
// file tables/rst.c line 199
struct dvbpsi_psi_section_s * dvbpsi_rst_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_rst_s *p_rst)
{
  struct dvbpsi_psi_section_s *p_result;
  p_result=dvbpsi_NewPSISection(1024);
  struct dvbpsi_psi_section_s *p_current = p_result;
  struct dvbpsi_psi_section_s *p_prev;
  struct dvbpsi_rst_event_s *p_event = p_rst->p_first_event;
  signed int i_count = 0;
  if(p_current == ((struct dvbpsi_psi_section_s *)NULL))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed to allocate new PSI section", (const void *)"RST encoder");
    return (struct dvbpsi_psi_section_s *)(void *)0;
  }

  else
  {
    p_current->i_table_id = (unsigned char)0x71;
    p_current->b_syntax_indicator = (_Bool)0;
    p_current->b_private_indicator = (_Bool)0;
    p_current->i_length = (unsigned short int)3;
    p_current->i_extension = (unsigned short int)0;
    p_current->i_version = (unsigned char)0;
    p_current->b_current_next = (_Bool)1;
    p_current->i_number = (unsigned char)0;
    p_current->p_payload_end = p_current->p_payload_end + (signed long int)3;
    p_current->p_payload_start = p_current->p_payload_end;
    for( ; !(p_event == ((struct dvbpsi_rst_event_s *)NULL)); i_count = i_count + 1)
    {
      if(!(p_current->p_payload_end - p_current->p_data >= 1021l))
      {
        p_current->p_data[(signed long int)(0 + i_count)] = (unsigned char)((signed int)p_event->i_ts_id >> 8);
        p_current->p_data[(signed long int)(1 + i_count)] = (unsigned char)((signed int)p_event->i_ts_id & 0xFF);
        p_current->p_data[(signed long int)(2 + i_count)] = (unsigned char)((signed int)p_event->i_orig_network_id >> 8);
        p_current->p_data[(signed long int)(3 + i_count)] = (unsigned char)((signed int)p_event->i_orig_network_id & 0xFF);
        p_current->p_data[(signed long int)(4 + i_count)] = (unsigned char)((signed int)p_event->i_service_id >> 8);
        p_current->p_data[(signed long int)(5 + i_count)] = (unsigned char)((signed int)p_event->i_service_id & 0xFF);
        p_current->p_data[(signed long int)(6 + i_count)] = (unsigned char)((signed int)p_event->i_event_id >> 8);
        p_current->p_data[(signed long int)(7 + i_count)] = (unsigned char)((signed int)p_event->i_event_id & 0xFF);
        p_current->p_data[(signed long int)(8 + i_count)] = (unsigned char)(0xF8 + (signed int)p_event->i_running_status);
        p_current->i_length = p_current->i_length + (unsigned short int)9;
        p_current->p_payload_end = p_current->p_payload_end + (signed long int)9;
      }

      p_event = p_event->p_next;
    }
    p_prev = p_result;
    for( ; !(p_prev == ((struct dvbpsi_psi_section_s *)NULL)); p_prev = p_prev->p_next)
    {
      p_prev->i_last_number = p_current->i_number;
      dvbpsi_BuildPSISection(p_dvbpsi, p_prev);
    }
    return p_result;
  }
}

// dvbpsi_sdt_attach
// file ../../src/tables/sdt.h line 128
_Bool dvbpsi_sdt_attach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_sdt_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *return_value_dvbpsi_demuxGetSubDec$1;
  return_value_dvbpsi_demuxGetSubDec$1=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(!(return_value_dvbpsi_demuxGetSubDec$1 == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): Already a decoder for (table_id == 0x%02x,extension == 0x%02x)", (const void *)"SDT decoder", i_table_id, i_extension);
    return (_Bool)0;
  }

  else
  {
    struct dvbpsi_sdt_decoder_s *p_sdt_decoder;
    void *return_value_dvbpsi_decoder_new$2;
    return_value_dvbpsi_decoder_new$2=dvbpsi_decoder_new((void (*)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *))(void *)0, 0, (const _Bool)1, sizeof(struct dvbpsi_sdt_decoder_s) /*80ul*/ );
    p_sdt_decoder = (struct dvbpsi_sdt_decoder_s *)return_value_dvbpsi_decoder_new$2;
    if(p_sdt_decoder == ((struct dvbpsi_sdt_decoder_s *)NULL))
      return (_Bool)0;

    else
    {
      struct dvbpsi_demux_subdec_s *p_subdec;
      p_subdec=dvbpsi_NewDemuxSubDecoder(i_table_id, i_extension, dvbpsi_sdt_detach, dvbpsi_sdt_sections_gather, (struct dvbpsi_decoder_s *)p_sdt_decoder);
      if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
      {
        dvbpsi_decoder_delete((struct dvbpsi_decoder_s *)p_sdt_decoder);
        return (_Bool)0;
      }

      else
      {
        dvbpsi_AttachDemuxSubDecoder(p_demux, p_subdec);
        p_sdt_decoder->pf_sdt_callback = pf_callback;
        p_sdt_decoder->p_cb_data = p_cb_data;
        p_sdt_decoder->p_building_sdt = (struct dvbpsi_sdt_s *)(void *)0;
        return (_Bool)1;
      }
    }
  }
}

// dvbpsi_sdt_delete
// file ../../src/tables/sdt.h line 194
void dvbpsi_sdt_delete(struct dvbpsi_sdt_s *p_sdt)
{
  if(!(p_sdt == ((struct dvbpsi_sdt_s *)NULL)))
    dvbpsi_sdt_empty(p_sdt);

  free((void *)p_sdt);
}

// dvbpsi_sdt_detach
// file tables/sdt.c line 105
void dvbpsi_sdt_detach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *p_subdec;
  p_subdec=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No such SDT decoder (table_id == 0x%02x,extension == 0x%02x)", (const void *)"SDT Decoder", i_table_id, i_extension);

  else
  {
    /* assertion p_subdec->p_decoder */
    assert(p_subdec->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
    struct dvbpsi_sdt_decoder_s *p_sdt_decoder = (struct dvbpsi_sdt_decoder_s *)p_subdec->p_decoder;
    if(!(p_sdt_decoder->p_building_sdt == ((struct dvbpsi_sdt_s *)NULL)))
      dvbpsi_sdt_delete(p_sdt_decoder->p_building_sdt);

    p_sdt_decoder->p_building_sdt = (struct dvbpsi_sdt_s *)(void *)0;
    dvbpsi_DetachDemuxSubDecoder(p_demux, p_subdec);
    dvbpsi_DeleteDemuxSubDecoder(p_subdec);
  }
}

// dvbpsi_sdt_empty
// file tables/sdt.c line 175
void dvbpsi_sdt_empty(struct dvbpsi_sdt_s *p_sdt)
{
  struct dvbpsi_sdt_service_s *p_service = p_sdt->p_first_service;
  while(!(p_service == ((struct dvbpsi_sdt_service_s *)NULL)))
  {
    struct dvbpsi_sdt_service_s *p_tmp = p_service->p_next;
    dvbpsi_DeleteDescriptors(p_service->p_first_descriptor);
    free((void *)p_service);
    p_service = p_tmp;
  }
  p_sdt->p_first_service = (struct dvbpsi_sdt_service_s *)(void *)0;
}

// dvbpsi_sdt_init
// file tables/sdt.c line 141
void dvbpsi_sdt_init(struct dvbpsi_sdt_s *p_sdt, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned short int i_network_id)
{
  /* assertion p_sdt */
  assert(p_sdt != ((struct dvbpsi_sdt_s *)NULL));
  p_sdt->i_table_id = i_table_id;
  p_sdt->i_extension = i_extension;
  p_sdt->i_version = i_version;
  p_sdt->b_current_next = b_current_next;
  p_sdt->i_network_id = i_network_id;
  p_sdt->p_first_service = (struct dvbpsi_sdt_service_s *)(void *)0;
}

// dvbpsi_sdt_new
// file tables/sdt.c line 160
struct dvbpsi_sdt_s * dvbpsi_sdt_new(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned short int i_network_id)
{
  struct dvbpsi_sdt_s *p_sdt;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_sdt_s) /*16ul*/ );
  p_sdt = (struct dvbpsi_sdt_s *)return_value_malloc$1;
  if(!(p_sdt == ((struct dvbpsi_sdt_s *)NULL)))
    dvbpsi_sdt_init(p_sdt, i_table_id, i_extension, i_version, b_current_next, i_network_id);

  return p_sdt;
}

// dvbpsi_sdt_sections_decode
// file tables/sdt.c line 436
void dvbpsi_sdt_sections_decode(struct dvbpsi_sdt_s *p_sdt, struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte;
  unsigned char *p_end;
  for( ; !(p_section == ((struct dvbpsi_psi_section_s *)NULL)); p_section = p_section->p_next)
  {
    p_byte = p_section->p_payload_start + (signed long int)3;
    while(!(p_byte + 4l >= p_section->p_payload_end))
    {
      unsigned short int i_service_id = (unsigned short int)((signed int)(unsigned short int)p_byte[(signed long int)0] << 8 | (signed int)p_byte[(signed long int)1]);
      _Bool b_eit_schedule = (_Bool)(((signed int)p_byte[(signed long int)2] & 0x2) >> 1);
      _Bool b_eit_present = (_Bool)((signed int)p_byte[(signed long int)2] & 0x1);
      unsigned char i_running_status = (unsigned char)((signed int)(unsigned char)p_byte[(signed long int)3] >> 5);
      _Bool b_free_ca = (_Bool)(((signed int)p_byte[(signed long int)3] & 0x10) >> 4);
      unsigned short int i_srv_length = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)3] & 0xf) << 8 | (signed int)p_byte[(signed long int)4]);
      struct dvbpsi_sdt_service_s *p_service;
      p_service=dvbpsi_sdt_service_add(p_sdt, i_service_id, b_eit_schedule, b_eit_present, i_running_status, b_free_ca);
      p_byte = p_byte + (signed long int)5;
      p_end = p_byte + (signed long int)i_srv_length;
      if(!(p_section->p_payload_end >= p_end))
        break;

      while(p_end >= p_byte + 2l)
      {
        unsigned char i_tag = p_byte[(signed long int)0];
        unsigned char i_length = p_byte[(signed long int)1];
        if(p_end - p_byte >= (signed long int)(2 + (signed int)i_length))
          dvbpsi_sdt_service_descriptor_add(p_service, i_tag, i_length, p_byte + (signed long int)2);

        p_byte = p_byte + (signed long int)(2 + (signed int)i_length);
      }
    }
  }
}

// dvbpsi_sdt_sections_gather
// file tables/sdt.c line 349
void dvbpsi_sdt_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_private_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  unsigned char i_table_id;
  _Bool tmp_if_expr$1;
  if((signed int)p_section->i_table_id == 0x42)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)p_section->i_table_id == 0x46 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (signed int)p_section->i_table_id;

  else
    tmp_if_expr$2 = 0x42;
  i_table_id = (const unsigned char)tmp_if_expr$2;
  _Bool return_value_dvbpsi_CheckPSISection$3;
  return_value_dvbpsi_CheckPSISection$3=dvbpsi_CheckPSISection(p_dvbpsi, p_section, i_table_id, "SDT decoder");
  if(return_value_dvbpsi_CheckPSISection$3 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
    struct dvbpsi_sdt_decoder_s *p_sdt_decoder = (struct dvbpsi_sdt_decoder_s *)p_private_decoder;
    if(!(p_demux->b_discontinuity == (_Bool)0))
    {
      dvbpsi_ReInitSDT(p_sdt_decoder, (const _Bool)1);
      p_sdt_decoder->b_discontinuity = (_Bool)0;
      p_demux->b_discontinuity = (_Bool)0;
    }

    else
      if(!(p_sdt_decoder->p_building_sdt == ((struct dvbpsi_sdt_s *)NULL)))
      {
        _Bool return_value_dvbpsi_CheckSDT$4;
        return_value_dvbpsi_CheckSDT$4=dvbpsi_CheckSDT(p_dvbpsi, p_sdt_decoder, p_section);
        if(!(return_value_dvbpsi_CheckSDT$4 == (_Bool)0))
          dvbpsi_ReInitSDT(p_sdt_decoder, (const _Bool)1);

      }

      else
        if(!(p_sdt_decoder->b_current_valid == (_Bool)0))
        {
          if(p_sdt_decoder->current_sdt.i_version == p_section->i_version)
          {
            if(p_sdt_decoder->current_sdt.b_current_next == p_section->b_current_next)
            {
              dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"SDT decoder", p_section->i_number);
              dvbpsi_DeletePSISections(p_section);
              goto __CPROVER_DUMP_L12;
            }

          }

        }

    _Bool return_value_dvbpsi_AddSectionSDT$5;
    return_value_dvbpsi_AddSectionSDT$5=dvbpsi_AddSectionSDT(p_dvbpsi, p_sdt_decoder, p_section);
    if(return_value_dvbpsi_AddSectionSDT$5 == (_Bool)0)
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"SDT decoder", p_section->i_number);
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      _Bool return_value_dvbpsi_decoder_psi_sections_completed$6;
      return_value_dvbpsi_decoder_psi_sections_completed$6=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_sdt_decoder);
      if(!(return_value_dvbpsi_decoder_psi_sections_completed$6 == (_Bool)0))
      {
        /* assertion p_sdt_decoder->pf_sdt_callback */
        assert(p_sdt_decoder->pf_sdt_callback != ((void (*)(void *, struct dvbpsi_sdt_s *))NULL));
        p_sdt_decoder->current_sdt = *p_sdt_decoder->p_building_sdt;
        p_sdt_decoder->b_current_valid = (_Bool)1;
        dvbpsi_sdt_sections_decode(p_sdt_decoder->p_building_sdt, p_sdt_decoder->p_sections);
        p_sdt_decoder->pf_sdt_callback(p_sdt_decoder->p_cb_data, p_sdt_decoder->p_building_sdt);
        dvbpsi_ReInitSDT(p_sdt_decoder, (const _Bool)0);
        /* assertion p_sdt_decoder->p_sections == ((void *)0) */
        assert(p_sdt_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
      }

    }
  }

__CPROVER_DUMP_L12:
  ;
}

// dvbpsi_sdt_sections_generate
// file tables/sdt.c line 479
struct dvbpsi_psi_section_s * dvbpsi_sdt_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sdt_s *p_sdt)
{
  struct dvbpsi_psi_section_s *p_result;
  p_result=dvbpsi_NewPSISection(1024);
  struct dvbpsi_psi_section_s *p_current = p_result;
  struct dvbpsi_psi_section_s *p_prev;
  struct dvbpsi_sdt_service_s *p_service = p_sdt->p_first_service;
  p_current->i_table_id = (unsigned char)0x42;
  p_current->b_syntax_indicator = (_Bool)1;
  p_current->b_private_indicator = (_Bool)1;
  p_current->i_length = (unsigned short int)12;
  p_current->i_extension = p_sdt->i_extension;
  p_current->i_version = p_sdt->i_version;
  p_current->b_current_next = p_sdt->b_current_next;
  p_current->i_number = (unsigned char)0;
  p_current->p_payload_end = p_current->p_payload_end + (signed long int)11;
  p_current->p_payload_start = p_current->p_data + (signed long int)8;
  p_current->p_data[(signed long int)8] = (unsigned char)((signed int)p_sdt->i_network_id >> 8);
  p_current->p_data[(signed long int)9] = (unsigned char)p_sdt->i_network_id;
  p_current->p_data[(signed long int)10] = (unsigned char)0xff;
  while(!(p_service == ((struct dvbpsi_sdt_service_s *)NULL)))
  {
    unsigned char *p_service_start = p_current->p_payload_end;
    unsigned short int i_service_length = (unsigned short int)5;
    struct dvbpsi_descriptor_s *p_descriptor = p_service->p_first_descriptor;
    for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
    {
      if((p_service_start - p_current->p_data) + (signed long int)i_service_length >= 1021l)
        break;

      i_service_length = i_service_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
    }
    if(!(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)))
    {
      if(!(p_service_start - p_current->p_data == 11l))
      {
        if(!((signed int)i_service_length >= 1010))
        {
          dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): create a new section to carry more Service descriptors", (const void *)"SDT generator");
          p_prev = p_current;
          p_current=dvbpsi_NewPSISection(1024);
          p_prev->p_next = p_current;
          p_current->i_table_id = (unsigned char)0x42;
          p_current->b_syntax_indicator = (_Bool)1;
          p_current->b_private_indicator = (_Bool)1;
          p_current->i_length = (unsigned short int)12;
          p_current->i_extension = p_sdt->i_extension;
          p_current->i_version = p_sdt->i_version;
          p_current->b_current_next = p_sdt->b_current_next;
          p_current->i_number = (unsigned char)((signed int)p_prev->i_number + 1);
          p_current->p_payload_end = p_current->p_payload_end + (signed long int)11;
          p_current->p_payload_start = p_current->p_data + (signed long int)8;
          p_current->p_data[(signed long int)8] = (unsigned char)((signed int)p_sdt->i_network_id >> 8);
          p_current->p_data[(signed long int)9] = (unsigned char)p_sdt->i_network_id;
          p_current->p_data[(signed long int)10] = (unsigned char)0xff;
          p_service_start = p_current->p_payload_end;
        }

      }

    }

    p_service_start[(signed long int)0] = (unsigned char)((signed int)p_service->i_service_id >> 8);
    p_service_start[(signed long int)1] = (unsigned char)p_service->i_service_id;
    p_service_start[(signed long int)2] = (unsigned char)(0xfc | (p_service->b_eit_schedule != (_Bool)0 ? 0x2 : 0x0) | (p_service->b_eit_present != (_Bool)0 ? 0x01 : 0x00));
    p_service_start[(signed long int)3] = (unsigned char)(((signed int)p_service->i_running_status & 0x07) << 5 | ((signed int)p_service->b_free_ca & 0x1) << 4);
    p_current->p_payload_end = p_current->p_payload_end + (signed long int)5;
    p_current->i_length = p_current->i_length + (unsigned short int)5;
    p_descriptor = p_service->p_first_descriptor;
    for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
    {
      if((p_current->p_payload_end - p_current->p_data) + (signed long int)p_descriptor->i_length >= 1019l)
        break;

      p_current->p_payload_end[(signed long int)0] = p_descriptor->i_tag;
      p_current->p_payload_end[(signed long int)1] = p_descriptor->i_length;
      memcpy((void *)(p_current->p_payload_end + (signed long int)2), (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
      p_current->p_payload_end = p_current->p_payload_end + (signed long int)((signed int)p_descriptor->i_length + 2);
      p_current->i_length = p_current->i_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
    }
    if(!(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)))
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): unable to carry all the descriptors", (const void *)"SDT generator");

    i_service_length = (unsigned short int)((p_current->p_payload_end - p_service_start) - (signed long int)5);
    p_service_start[(signed long int)3] = p_service_start[(signed long int)3] | (unsigned char)((signed int)i_service_length >> 8 & 0x0f);
    p_service_start[(signed long int)4] = (unsigned char)i_service_length;
    p_service = p_service->p_next;
  }
  p_prev = p_result;
  for( ; !(p_prev == ((struct dvbpsi_psi_section_s *)NULL)); p_prev = p_prev->p_next)
  {
    p_prev->i_last_number = p_current->i_number;
    dvbpsi_BuildPSISection(p_dvbpsi, p_prev);
  }
  return p_result;
}

// dvbpsi_sdt_service_add
// file tables/sdt.c line 206
struct dvbpsi_sdt_service_s * dvbpsi_sdt_service_add(struct dvbpsi_sdt_s *p_sdt, unsigned short int i_service_id, _Bool b_eit_schedule, _Bool b_eit_present, unsigned char i_running_status, _Bool b_free_ca)
{
  struct dvbpsi_sdt_service_s *p_service;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct dvbpsi_sdt_service_s) /*24ul*/ );
  p_service = (struct dvbpsi_sdt_service_s *)return_value_calloc$1;
  if(p_service == ((struct dvbpsi_sdt_service_s *)NULL))
    return (struct dvbpsi_sdt_service_s *)(void *)0;

  else
  {
    p_service->i_service_id = i_service_id;
    p_service->b_eit_schedule = b_eit_schedule;
    p_service->b_eit_present = b_eit_present;
    p_service->i_running_status = i_running_status;
    p_service->b_free_ca = b_free_ca;
    p_service->p_next = (struct dvbpsi_sdt_service_s *)(void *)0;
    p_service->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
    if(p_sdt->p_first_service == ((struct dvbpsi_sdt_service_s *)NULL))
      p_sdt->p_first_service = p_service;

    else
    {
      struct dvbpsi_sdt_service_s *p_last_service = p_sdt->p_first_service;
      for( ; !(p_last_service->p_next == ((struct dvbpsi_sdt_service_s *)NULL)); p_last_service = p_last_service->p_next)
        ;
      p_last_service->p_next = p_service;
    }
    return p_service;
  }
}

// dvbpsi_sdt_service_descriptor_add
// file tables/sdt.c line 244
struct dvbpsi_descriptor_s * dvbpsi_sdt_service_descriptor_add(struct dvbpsi_sdt_service_s *p_service, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_service->p_first_descriptor=dvbpsi_AddDescriptor(p_service->p_first_descriptor, p_descriptor);
    /* assertion p_service->p_first_descriptor */
    assert(p_service->p_first_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
    if(p_service->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
      return p_descriptor;
  }
}

// dvbpsi_sis_attach
// file ../../src/tables/sis.h line 364
_Bool dvbpsi_sis_attach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_sis_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  i_extension = (unsigned short int)0;
  struct dvbpsi_demux_subdec_s *return_value_dvbpsi_demuxGetSubDec$1;
  return_value_dvbpsi_demuxGetSubDec$1=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(!(return_value_dvbpsi_demuxGetSubDec$1 == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): Already a decoder for (table_id == 0x%02x,extension == 0x%02x)", (const void *)"SIS decoder", i_table_id, i_extension);
    return (_Bool)0;
  }

  else
  {
    struct dvbpsi_sis_decoder_s *p_sis_decoder;
    void *return_value_dvbpsi_decoder_new$2;
    return_value_dvbpsi_decoder_new$2=dvbpsi_decoder_new((void (*)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *))(void *)0, 0, (const _Bool)1, sizeof(struct dvbpsi_sis_decoder_s) /*112ul*/ );
    p_sis_decoder = (struct dvbpsi_sis_decoder_s *)return_value_dvbpsi_decoder_new$2;
    if(p_sis_decoder == ((struct dvbpsi_sis_decoder_s *)NULL))
      return (_Bool)0;

    else
    {
      struct dvbpsi_demux_subdec_s *p_subdec;
      p_subdec=dvbpsi_NewDemuxSubDecoder(i_table_id, i_extension, dvbpsi_sis_detach, dvbpsi_sis_sections_gather, (struct dvbpsi_decoder_s *)p_sis_decoder);
      if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
      {
        dvbpsi_decoder_delete((struct dvbpsi_decoder_s *)p_sis_decoder);
        return (_Bool)0;
      }

      else
      {
        dvbpsi_AttachDemuxSubDecoder(p_demux, p_subdec);
        p_sis_decoder->pf_sis_callback = pf_callback;
        p_sis_decoder->p_cb_data = p_cb_data;
        p_sis_decoder->p_building_sis = (struct dvbpsi_sis_s *)(void *)0;
        return (_Bool)1;
      }
    }
  }
}

// dvbpsi_sis_delete
// file ../../src/tables/sis.h line 430
void dvbpsi_sis_delete(struct dvbpsi_sis_s *p_sis)
{
  if(!(p_sis == ((struct dvbpsi_sis_s *)NULL)))
    dvbpsi_sis_empty(p_sis);

  free((void *)p_sis);
}

// dvbpsi_sis_descriptor_add
// file tables/sis.c line 224
struct dvbpsi_descriptor_s * dvbpsi_sis_descriptor_add(struct dvbpsi_sis_s *p_sis, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_sis->p_first_descriptor=dvbpsi_AddDescriptor(p_sis->p_first_descriptor, p_descriptor);
    /* assertion p_sis->p_first_descriptor */
    assert(p_sis->p_first_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
    if(p_sis->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
      return p_descriptor;
  }
}

// dvbpsi_sis_detach
// file tables/sis.c line 107
void dvbpsi_sis_detach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  i_extension = (unsigned short int)0;
  struct dvbpsi_demux_subdec_s *p_subdec;
  p_subdec=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No such SIS decoder (table_id == 0x%02x,extension == 0x%02x)", (const void *)"SIS Decoder", i_table_id, i_extension);

  else
  {
    /* assertion p_subdec->p_decoder */
    assert(p_subdec->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
    struct dvbpsi_sis_decoder_s *p_sis_decoder = (struct dvbpsi_sis_decoder_s *)p_subdec->p_decoder;
    if(!(p_sis_decoder->p_building_sis == ((struct dvbpsi_sis_s *)NULL)))
      dvbpsi_sis_delete(p_sis_decoder->p_building_sis);

    p_sis_decoder->p_building_sis = (struct dvbpsi_sis_s *)(void *)0;
    dvbpsi_DetachDemuxSubDecoder(p_demux, p_subdec);
    dvbpsi_DeleteDemuxSubDecoder(p_subdec);
  }
}

// dvbpsi_sis_empty
// file tables/sis.c line 197
void dvbpsi_sis_empty(struct dvbpsi_sis_s *p_sis)
{
  dvbpsi_DeleteDescriptors(p_sis->p_first_descriptor);
  p_sis->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_sis_init
// file tables/sis.c line 143
void dvbpsi_sis_init(struct dvbpsi_sis_s *p_sis, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned char i_protocol_version)
{
  p_sis->i_table_id = i_table_id;
  p_sis->i_extension = i_extension;
  p_sis->i_version = i_version;
  p_sis->b_current_next = b_current_next;
  /* assertion i_protocol_version == 0 */
  assert((signed int)i_protocol_version == 0);
  p_sis->i_protocol_version = (unsigned char)0;
  p_sis->b_encrypted_packet = (_Bool)0;
  p_sis->i_encryption_algorithm = (unsigned char)0;
  p_sis->i_pts_adjustment = (unsigned long int)0;
  p_sis->cw_index = (unsigned char)0;
  p_sis->i_splice_command_length = (unsigned short int)0;
  p_sis->i_splice_command_type = (unsigned char)0x00;
  p_sis->i_descriptors_length = (unsigned short int)0;
  p_sis->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
  p_sis->i_ecrc = (unsigned int)0;
}

// dvbpsi_sis_new
// file tables/sis.c line 182
struct dvbpsi_sis_s * dvbpsi_sis_new(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned char i_protocol_version)
{
  struct dvbpsi_sis_s *p_sis;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_sis_s) /*44ul*/ );
  p_sis = (struct dvbpsi_sis_s *)return_value_malloc$1;
  if(!(p_sis == ((struct dvbpsi_sis_s *)NULL)))
    dvbpsi_sis_init(p_sis, i_table_id, i_extension, i_version, b_current_next, i_protocol_version);

  return p_sis;
}

// dvbpsi_sis_sections_decode
// file tables/sis.c line 422
void dvbpsi_sis_sections_decode(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sis_s *p_sis, struct dvbpsi_psi_section_s *p_section)
{
  unsigned char *p_byte;
  unsigned char *p_end;
  for( ; !(p_section == ((struct dvbpsi_psi_section_s *)NULL)); p_section = p_section->p_next)
  {
    p_byte = p_section->p_payload_start + (signed long int)3;
    while(!(p_byte >= p_section->p_payload_end))
    {
      p_sis->i_protocol_version = p_byte[(signed long int)3];
      p_sis->b_encrypted_packet = ((signed int)p_byte[(signed long int)4] & 0x80) == 0x80;
      /* assertion p_sis->b_encrypted_packet */
      assert(p_sis->b_encrypted_packet != (_Bool)0);
      p_sis->i_encryption_algorithm = (unsigned char)(((signed int)p_byte[(signed long int)4] & 0x7E) >> 1);
      p_sis->i_pts_adjustment = ((unsigned long int)p_byte[(signed long int)4] & (unsigned long int)0x01) << 32 | (unsigned long int)p_byte[(signed long int)5] << 24 | (unsigned long int)p_byte[(signed long int)6] << 16 | (unsigned long int)p_byte[(signed long int)7] << 8 | (unsigned long int)p_byte[(signed long int)8];
      p_sis->cw_index = p_byte[(signed long int)9];
      p_sis->i_splice_command_length = (unsigned short int)(((signed int)p_byte[(signed long int)11] & 0x0F) << 8 | (signed int)p_byte[(signed long int)12]);
      p_sis->i_splice_command_type = p_byte[(signed long int)13];
      unsigned int i_splice_command_length = (unsigned int)p_sis->i_splice_command_length;
      if((signed int)p_sis->i_splice_command_length == 0xfff)
        /* assertion p_sis->i_splice_command_length != 0xfff */
        assert((signed int)p_sis->i_splice_command_length != 0xfff);

      if((signed int)p_sis->i_splice_command_type == 0x00 || (signed int)p_sis->i_splice_command_type == 0x04 || (signed int)p_sis->i_splice_command_type == 0x05 || (signed int)p_sis->i_splice_command_type == 0x06 || (signed int)p_sis->i_splice_command_type == 0x07)
        goto __CPROVER_DUMP_L6;

      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): invalid SIS Command found", (const void *)"SIS decoder");

    __CPROVER_DUMP_L6:
      ;
      unsigned char *p_desc = p_byte + (signed long int)13 + (signed long int)i_splice_command_length;
      p_sis->i_descriptors_length = (unsigned short int)((signed int)p_desc[(signed long int)0] << 8 | (signed int)p_desc[(signed long int)1]);
      p_desc = p_desc + (signed long int)1;
      p_end = p_desc + (signed long int)p_sis->i_descriptors_length;
      if(!(p_section->p_payload_end >= p_end))
        break;

      while(p_end >= p_desc + 2l)
      {
        unsigned char i_tag = p_desc[(signed long int)0];
        unsigned char i_length = p_desc[(signed long int)1];
        if(p_end - p_desc >= (signed long int)(2 + (signed int)i_length) && !((signed int)i_length >= 255))
          dvbpsi_sis_descriptor_add(p_sis, i_tag, i_length, p_desc + (signed long int)2);

        p_desc = p_desc + (signed long int)(2 + (signed int)i_length);
      }
      if(!(p_sis->b_encrypted_packet == (_Bool)0))
        p_desc = p_desc + (signed long int)4;

      p_byte = p_desc + (signed long int)4;
    }
  }
}

// dvbpsi_sis_sections_gather
// file tables/sis.c line 331
void dvbpsi_sis_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  _Bool return_value_dvbpsi_CheckPSISection$1;
  return_value_dvbpsi_CheckPSISection$1=dvbpsi_CheckPSISection(p_dvbpsi, p_section, (const unsigned char)0xFC, "SIS decoder");
  if(return_value_dvbpsi_CheckPSISection$1 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
    struct dvbpsi_sis_decoder_s *p_sis_decoder = (struct dvbpsi_sis_decoder_s *)p_decoder;
    if(!(p_section->b_private_indicator == (_Bool)0))
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): invalid private section (private_syntax_indicator != false)", (const void *)"SIS decoder");
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      if(!(p_demux->b_discontinuity == (_Bool)0))
      {
        dvbpsi_ReInitSIS(p_sis_decoder, (const _Bool)1);
        p_sis_decoder->b_discontinuity = (_Bool)0;
        p_demux->b_discontinuity = (_Bool)0;
      }

      else
        if(!(p_sis_decoder->p_building_sis == ((struct dvbpsi_sis_s *)NULL)))
        {
          _Bool return_value_dvbpsi_CheckSIS$2;
          return_value_dvbpsi_CheckSIS$2=dvbpsi_CheckSIS(p_dvbpsi, p_sis_decoder, p_section);
          if(!(return_value_dvbpsi_CheckSIS$2 == (_Bool)0))
            dvbpsi_ReInitSIS(p_sis_decoder, (const _Bool)1);

        }

        else
          if(!(p_sis_decoder->b_current_valid == (_Bool)0))
          {
            if(p_sis_decoder->current_sis.i_version == p_section->i_version)
            {
              if(p_sis_decoder->current_sis.b_current_next == p_section->b_current_next)
              {
                dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG, "libdvbpsi debug (%s): ignoring already decoded section %d", (const void *)"SIT decoder", p_section->i_number);
                dvbpsi_DeletePSISections(p_section);
                goto __CPROVER_DUMP_L9;
              }

            }

          }

      _Bool return_value_dvbpsi_AddSectionSIS$3;
      return_value_dvbpsi_AddSectionSIS$3=dvbpsi_AddSectionSIS(p_dvbpsi, p_sis_decoder, p_section);
      if(return_value_dvbpsi_AddSectionSIS$3 == (_Bool)0)
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"SIS decoder", p_section->i_number);
        dvbpsi_DeletePSISections(p_section);
      }

      else
      {
        _Bool return_value_dvbpsi_decoder_psi_sections_completed$4;
        return_value_dvbpsi_decoder_psi_sections_completed$4=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_sis_decoder);
        if(!(return_value_dvbpsi_decoder_psi_sections_completed$4 == (_Bool)0))
        {
          /* assertion p_sis_decoder->pf_sis_callback */
          assert(p_sis_decoder->pf_sis_callback != ((void (*)(void *, struct dvbpsi_sis_s *))NULL));
          p_sis_decoder->current_sis = *p_sis_decoder->p_building_sis;
          p_sis_decoder->b_current_valid = (_Bool)1;
          dvbpsi_sis_sections_decode(p_dvbpsi, p_sis_decoder->p_building_sis, p_sis_decoder->p_sections);
          p_sis_decoder->pf_sis_callback(p_sis_decoder->p_cb_data, p_sis_decoder->p_building_sis);
          dvbpsi_ReInitSIS(p_sis_decoder, (const _Bool)0);
          /* assertion p_sis_decoder->p_sections == ((void *)0) */
          assert(p_sis_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
        }

      }
    }
  }

__CPROVER_DUMP_L9:
  ;
}

// dvbpsi_sis_sections_generate
// file tables/sis.c line 509
struct dvbpsi_psi_section_s * dvbpsi_sis_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_sis_s *p_sis)
{
  struct dvbpsi_psi_section_s *p_current;
  p_current=dvbpsi_NewPSISection(1024);
  p_current->i_table_id = (unsigned char)0xFC;
  p_current->b_syntax_indicator = (_Bool)0;
  p_current->b_private_indicator = (_Bool)0;
  p_current->i_length = (unsigned short int)3;
  p_current->p_payload_end = p_current->p_payload_end + (signed long int)2;
  p_current->p_payload_start = p_current->p_data + (signed long int)3;
  p_current->p_data[(signed long int)3] = p_sis->i_protocol_version;
  p_current->p_data[(signed long int)4] = (unsigned char)(p_sis->b_encrypted_packet != (_Bool)0 ? 0x80 : 0x0);
  /* assertion p_sis->b_encrypted_packet */
  assert(p_sis->b_encrypted_packet != (_Bool)0);
  p_current->p_data[(signed long int)4] = p_current->p_data[(signed long int)4] | (unsigned char)((signed int)p_sis->i_encryption_algorithm << 1 & 0x7E);
  p_current->p_data[(signed long int)4] = p_current->p_data[(signed long int)4] | (unsigned char)((p_sis->i_pts_adjustment & (unsigned long int)0x00800) >> 32);
  p_current->p_data[(signed long int)5] = (unsigned char)(p_sis->i_pts_adjustment >> 24);
  p_current->p_data[(signed long int)6] = (unsigned char)(p_sis->i_pts_adjustment >> 16);
  p_current->p_data[(signed long int)7] = (unsigned char)(p_sis->i_pts_adjustment >> 8);
  p_current->p_data[(signed long int)8] = (unsigned char)p_sis->i_pts_adjustment;
  p_current->p_data[(signed long int)9] = p_sis->cw_index;
  p_current->p_data[(signed long int)11] = (unsigned char)0x00;
  p_current->p_data[(signed long int)11] = p_current->p_data[(signed long int)11] | (unsigned char)((signed int)p_sis->i_splice_command_length >> 8 & 0x0F);
  p_current->p_data[(signed long int)12] = (unsigned char)((signed int)p_sis->i_splice_command_length & 0xFF);
  p_current->p_data[(signed long int)13] = p_sis->i_splice_command_type;
  unsigned int i_desc_start = (unsigned int)(13 + (signed int)p_sis->i_splice_command_length);
  if((signed int)p_sis->i_splice_command_length == 0xfff)
    /* assertion p_sis->i_splice_command_length != 0xfff */
    assert((signed int)p_sis->i_splice_command_length != 0xfff);

  p_current->p_data[(signed long int)i_desc_start] = (unsigned char)((signed int)p_sis->i_descriptors_length >> 8);
  p_current->p_data[(signed long int)(i_desc_start + (unsigned int)1)] = (unsigned char)((signed int)p_sis->i_descriptors_length & 0xFF);
  p_current->p_payload_end = p_current->p_payload_end + (signed long int)(i_desc_start + (unsigned int)1);
  unsigned int i_desc_length = (unsigned int)0;
  struct dvbpsi_descriptor_s *p_descriptor = p_sis->p_first_descriptor;
  for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_current->i_length = p_current->i_length + (unsigned short int)((signed int)p_descriptor->i_length + 2))
  {
    if((signed int)p_current->i_length >= 1019)
      break;

    i_desc_length = i_desc_length + (unsigned int)((signed int)p_descriptor->i_length + 2);
    p_descriptor = p_descriptor->p_next;
    p_current->p_payload_end[(signed long int)0] = p_descriptor->i_tag;
    p_current->p_payload_end[(signed long int)1] = p_descriptor->i_length;
    memcpy((void *)(p_current->p_payload_end + (signed long int)2), (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
    p_current->p_payload_end = p_current->p_payload_end + (signed long int)((signed int)p_descriptor->i_length + 2);
  }
  /* assertion i_desc_length == p_sis->i_descriptors_length */
  assert(i_desc_length == (unsigned int)p_sis->i_descriptors_length);
  dvbpsi_BuildPSISection(p_dvbpsi, p_current);
  return p_current;
}

// dvbpsi_tot_attach
// file ../../src/tables/tot.h line 97
_Bool dvbpsi_tot_attach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void (*pf_callback)(void *, struct dvbpsi_tot_s *), void *p_cb_data)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  i_extension = (unsigned short int)0;
  struct dvbpsi_demux_subdec_s *return_value_dvbpsi_demuxGetSubDec$1;
  return_value_dvbpsi_demuxGetSubDec$1=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(!(return_value_dvbpsi_demuxGetSubDec$1 == ((struct dvbpsi_demux_subdec_s *)NULL)))
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): Already a decoder for (table_id == 0x%02x,extension == 0x%02x)", (const void *)"TDT/TOT decoder", i_table_id, i_extension);
    return (_Bool)0;
  }

  else
  {
    struct dvbpsi_tot_decoder_s *p_tot_decoder;
    void *return_value_dvbpsi_decoder_new$2;
    return_value_dvbpsi_decoder_new$2=dvbpsi_decoder_new((void (*)(struct dvbpsi_s *, struct dvbpsi_psi_section_s *))(void *)0, 0, (const _Bool)1, sizeof(struct dvbpsi_tot_decoder_s) /*88ul*/ );
    p_tot_decoder = (struct dvbpsi_tot_decoder_s *)return_value_dvbpsi_decoder_new$2;
    if(p_tot_decoder == ((struct dvbpsi_tot_decoder_s *)NULL))
      return (_Bool)0;

    else
    {
      struct dvbpsi_demux_subdec_s *p_subdec;
      p_subdec=dvbpsi_NewDemuxSubDecoder(i_table_id, i_extension, dvbpsi_tot_detach, dvbpsi_tot_sections_gather, (struct dvbpsi_decoder_s *)p_tot_decoder);
      if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
      {
        dvbpsi_decoder_delete((struct dvbpsi_decoder_s *)p_tot_decoder);
        return (_Bool)0;
      }

      else
      {
        dvbpsi_AttachDemuxSubDecoder(p_demux, p_subdec);
        p_tot_decoder->pf_tot_callback = pf_callback;
        p_tot_decoder->p_cb_data = p_cb_data;
        p_tot_decoder->p_building_tot = (struct dvbpsi_tot_s *)(void *)0;
        return (_Bool)1;
      }
    }
  }
}

// dvbpsi_tot_delete
// file ../../src/tables/tot.h line 163
void dvbpsi_tot_delete(struct dvbpsi_tot_s *p_tot)
{
  if(!(p_tot == ((struct dvbpsi_tot_s *)NULL)))
    dvbpsi_tot_empty(p_tot);

  free((void *)p_tot);
}

// dvbpsi_tot_descriptor_add
// file tables/tot.c line 203
struct dvbpsi_descriptor_s * dvbpsi_tot_descriptor_add(struct dvbpsi_tot_s *p_tot, unsigned char i_tag, unsigned char i_length, unsigned char *p_data)
{
  struct dvbpsi_descriptor_s *p_descriptor;
  p_descriptor=dvbpsi_NewDescriptor(i_tag, i_length, p_data);
  if(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    p_tot->p_first_descriptor=dvbpsi_AddDescriptor(p_tot->p_first_descriptor, p_descriptor);
    /* assertion p_tot->p_first_descriptor */
    assert(p_tot->p_first_descriptor != ((struct dvbpsi_descriptor_s *)NULL));
    if(p_tot->p_first_descriptor == ((struct dvbpsi_descriptor_s *)NULL))
      return (struct dvbpsi_descriptor_s *)(void *)0;

    else
      return p_descriptor;
  }
}

// dvbpsi_tot_detach
// file tables/tot.c line 108
void dvbpsi_tot_detach(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  struct dvbpsi_demux_s *p_demux = (struct dvbpsi_demux_s *)p_dvbpsi->p_decoder;
  struct dvbpsi_demux_subdec_s *p_subdec;
  i_extension = (unsigned short int)0;
  p_subdec=dvbpsi_demuxGetSubDec(p_demux, i_table_id, i_extension);
  if(p_subdec == ((struct dvbpsi_demux_subdec_s *)NULL))
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): No such TDT/TOT decoder (table_id == 0x%02x,extension == 0x%02x)", (const void *)"TDT/TOT Decoder", i_table_id, i_extension);

  else
  {
    /* assertion p_subdec->p_decoder */
    assert(p_subdec->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
    struct dvbpsi_tot_decoder_s *p_tot_decoder = (struct dvbpsi_tot_decoder_s *)p_subdec->p_decoder;
    if(!(p_tot_decoder->p_building_tot == ((struct dvbpsi_tot_s *)NULL)))
      dvbpsi_tot_delete(p_tot_decoder->p_building_tot);

    p_tot_decoder->p_building_tot = (struct dvbpsi_tot_s *)(void *)0;
    dvbpsi_DetachDemuxSubDecoder(p_demux, p_subdec);
    dvbpsi_DeleteDemuxSubDecoder(p_subdec);
  }
}

// dvbpsi_tot_empty
// file tables/tot.c line 180
void dvbpsi_tot_empty(struct dvbpsi_tot_s *p_tot)
{
  dvbpsi_DeleteDescriptors(p_tot->p_first_descriptor);
  p_tot->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_tot_init
// file tables/tot.c line 145
void dvbpsi_tot_init(struct dvbpsi_tot_s *p_tot, unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned long int i_utc_time)
{
  /* assertion p_tot */
  assert(p_tot != ((struct dvbpsi_tot_s *)NULL));
  p_tot->i_table_id = i_table_id;
  p_tot->i_extension = i_extension;
  p_tot->i_version = i_version;
  p_tot->b_current_next = b_current_next;
  p_tot->i_utc_time = i_utc_time;
  p_tot->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
}

// dvbpsi_tot_new
// file tables/tot.c line 165
struct dvbpsi_tot_s * dvbpsi_tot_new(unsigned char i_table_id, unsigned short int i_extension, unsigned char i_version, _Bool b_current_next, unsigned long int i_utc_time)
{
  struct dvbpsi_tot_s *p_tot;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dvbpsi_tot_s) /*21ul*/ );
  p_tot = (struct dvbpsi_tot_s *)return_value_malloc$1;
  if(!(p_tot == ((struct dvbpsi_tot_s *)NULL)))
    dvbpsi_tot_init(p_tot, i_table_id, i_extension, i_version, b_current_next, i_utc_time);

  return p_tot;
}

// dvbpsi_tot_section_valid
// file tables/tot.c line 399
static _Bool dvbpsi_tot_section_valid(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_psi_section_s *p_section)
{
  if((signed int)p_section->i_table_id == 0x70)
  {
    if((signed int)p_section->i_length == 5)
      goto __CPROVER_DUMP_L1;

    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): TDT has an invalid payload size (%d bytes) !!!", (const void *)"TDT decoder", p_section->i_length);
    return (_Bool)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (_Bool)1;
  }
}

// dvbpsi_tot_sections_decode
// file tables/tot.c line 424
void dvbpsi_tot_sections_decode(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_tot_s *p_tot, struct dvbpsi_psi_section_s *p_section)
{
  if(!(p_section == ((struct dvbpsi_psi_section_s *)NULL)))
  {
    unsigned char *p_byte;
    _Bool return_value_dvbpsi_tot_section_valid$1;
    return_value_dvbpsi_tot_section_valid$1=dvbpsi_tot_section_valid(p_dvbpsi, p_section);
    if(!(return_value_dvbpsi_tot_section_valid$1 == (_Bool)0))
    {
      p_byte = p_section->p_payload_start;
      if(p_section->p_payload_end >= p_byte + 5l)
      {
        p_tot->i_utc_time = (unsigned long int)p_byte[(signed long int)0] << 32 | (unsigned long int)p_byte[(signed long int)1] << 24 | (unsigned long int)p_byte[(signed long int)2] << 16 | (unsigned long int)p_byte[(signed long int)3] << 8 | (unsigned long int)p_byte[(signed long int)4];
        p_byte = p_byte + (signed long int)5;
      }

      if((signed int)p_section->i_table_id == 0x73)
      {
        unsigned short int i_loop_length;
        unsigned char *p_end;
        i_loop_length = (unsigned short int)((signed int)(unsigned short int)((signed int)p_byte[(signed long int)0] & 0x0f) << 8 | (signed int)p_byte[(signed long int)1]);
        p_end = p_byte + (signed long int)i_loop_length;
        p_byte = p_byte + (signed long int)2;
        while(p_end >= p_byte + 2l)
        {
          unsigned char i_tag = p_byte[(signed long int)0];
          unsigned char i_length = p_byte[(signed long int)1];
          if(p_section->p_payload_end - p_byte >= (signed long int)(2 + (signed int)i_length))
            dvbpsi_tot_descriptor_add(p_tot, i_tag, i_length, p_byte + (signed long int)2);

          p_byte = p_byte + (signed long int)(2 + (signed int)i_length);
        }
      }

    }

  }

}

// dvbpsi_tot_sections_gather
// file tables/tot.c line 309
void dvbpsi_tot_sections_gather(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_decoder_s *p_decoder, struct dvbpsi_psi_section_s *p_section)
{
  /* assertion p_dvbpsi */
  assert(p_dvbpsi != ((struct dvbpsi_s *)NULL));
  /* assertion p_dvbpsi->p_decoder */
  assert(p_dvbpsi->p_decoder != ((struct dvbpsi_decoder_s *)NULL));
  unsigned char i_table_id;
  _Bool tmp_if_expr$1;
  if((signed int)p_section->i_table_id == 0x70)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)p_section->i_table_id == 0x73 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (signed int)p_section->i_table_id;

  else
    tmp_if_expr$2 = 0x70;
  i_table_id = (const unsigned char)tmp_if_expr$2;
  _Bool return_value_dvbpsi_CheckPSISection$3;
  return_value_dvbpsi_CheckPSISection$3=dvbpsi_CheckPSISection(p_dvbpsi, p_section, i_table_id, "TDT/TOT decoder");
  if(return_value_dvbpsi_CheckPSISection$3 == (_Bool)0)
    dvbpsi_DeletePSISections(p_section);

  else
  {
    struct dvbpsi_tot_decoder_s *p_tot_decoder = (struct dvbpsi_tot_decoder_s *)p_decoder;
    if(!(p_tot_decoder->b_discontinuity == (_Bool)0))
      p_tot_decoder->b_discontinuity = (_Bool)0;

    else
      if(!(p_tot_decoder->p_building_tot == ((struct dvbpsi_tot_s *)NULL)))
      {
        _Bool return_value_dvbpsi_CheckTOT$4;
        return_value_dvbpsi_CheckTOT$4=dvbpsi_CheckTOT(p_dvbpsi, p_tot_decoder, p_section);
        if(!(return_value_dvbpsi_CheckTOT$4 == (_Bool)0))
          dvbpsi_ReInitTOT(p_tot_decoder, (const _Bool)1);

      }

    _Bool return_value_dvbpsi_AddSectionTOT$5;
    return_value_dvbpsi_AddSectionTOT$5=dvbpsi_AddSectionTOT(p_dvbpsi, p_tot_decoder, p_section);
    if(return_value_dvbpsi_AddSectionTOT$5 == (_Bool)0)
    {
      dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): failed decoding section %d", (const void *)"TOT decoder", p_section->i_number);
      dvbpsi_DeletePSISections(p_section);
    }

    else
    {
      _Bool return_value_dvbpsi_decoder_psi_sections_completed$6;
      return_value_dvbpsi_decoder_psi_sections_completed$6=dvbpsi_decoder_psi_sections_completed((struct dvbpsi_decoder_s *)p_tot_decoder);
      if(!(return_value_dvbpsi_decoder_psi_sections_completed$6 == (_Bool)0))
      {
        /* assertion p_tot_decoder->pf_tot_callback */
        assert(p_tot_decoder->pf_tot_callback != ((void (*)(void *, struct dvbpsi_tot_s *))NULL));
        p_tot_decoder->current_tot = *p_tot_decoder->p_building_tot;
        p_tot_decoder->b_current_valid = (_Bool)1;
        dvbpsi_tot_sections_decode(p_dvbpsi, p_tot_decoder->p_building_tot, p_tot_decoder->p_sections);
        p_tot_decoder->pf_tot_callback(p_tot_decoder->p_cb_data, p_tot_decoder->p_building_tot);
        dvbpsi_ReInitTOT(p_tot_decoder, (const _Bool)0);
        /* assertion p_tot_decoder->p_sections == ((void *)0) */
        assert(p_tot_decoder->p_sections == (struct dvbpsi_psi_section_s *)(void *)0);
      }

    }
  }
}

// dvbpsi_tot_sections_generate
// file tables/tot.c line 474
struct dvbpsi_psi_section_s * dvbpsi_tot_sections_generate(struct dvbpsi_s *p_dvbpsi, struct dvbpsi_tot_s *p_tot)
{
  struct dvbpsi_psi_section_s *p_result;
  struct dvbpsi_descriptor_s *p_descriptor = p_tot->p_first_descriptor;
  p_result=dvbpsi_NewPSISection(p_descriptor != (struct dvbpsi_descriptor_s *)(void *)0 ? 4096 : 8);
  p_result->i_table_id = (unsigned char)(p_descriptor != (struct dvbpsi_descriptor_s *)(void *)0 ? 0x73 : 0x70);
  p_result->b_syntax_indicator = (_Bool)0;
  p_result->b_private_indicator = (_Bool)0;
  p_result->i_length = (unsigned short int)5;
  p_result->p_payload_start = p_result->p_data + (signed long int)3;
  p_result->p_payload_end = p_result->p_data + (signed long int)8;
  p_result->p_data[(signed long int)3] = (unsigned char)(p_tot->i_utc_time >> 32 & (unsigned long int)0xff);
  p_result->p_data[(signed long int)4] = (unsigned char)(p_tot->i_utc_time >> 24 & (unsigned long int)0xff);
  p_result->p_data[(signed long int)5] = (unsigned char)(p_tot->i_utc_time >> 16 & (unsigned long int)0xff);
  p_result->p_data[(signed long int)6] = (unsigned char)(p_tot->i_utc_time >> 8 & (unsigned long int)0xff);
  p_result->p_data[(signed long int)7] = (unsigned char)(p_tot->i_utc_time & (unsigned long int)0xff);
  if((signed int)p_result->i_table_id == 0x73)
  {
    p_result->p_payload_end = p_result->p_payload_end + (signed long int)2;
    p_result->i_length = p_result->i_length + (unsigned short int)2;
    for( ; !(p_descriptor == ((struct dvbpsi_descriptor_s *)NULL)); p_descriptor = p_descriptor->p_next)
    {
      if((p_result->p_payload_end - p_result->p_data) + (signed long int)p_descriptor->i_length >= 4091l)
      {
        dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): TOT does not fit into one section as it ought to be !!!", (const void *)"TDT/TOT generator");
        break;
      }

      p_result->p_payload_end[(signed long int)0] = p_descriptor->i_tag;
      p_result->p_payload_end[(signed long int)1] = p_descriptor->i_length;
      memcpy((void *)(p_result->p_payload_end + (signed long int)2), (const void *)p_descriptor->p_data, (unsigned long int)p_descriptor->i_length);
      p_result->p_payload_end = p_result->p_payload_end + (signed long int)((signed int)p_descriptor->i_length + 2);
      p_result->i_length = p_result->i_length + (unsigned short int)((signed int)p_descriptor->i_length + 2);
    }
    p_result->p_payload_start[(signed long int)5] = (unsigned char)((signed int)p_result->i_length - 7 << 8 | 0xf0);
    p_result->p_payload_start[(signed long int)6] = (unsigned char)((signed int)p_result->i_length - 7 & 0xff);
  }

  dvbpsi_BuildPSISection(p_dvbpsi, p_result);
  if((signed int)p_result->i_table_id == 0x73)
  {
    p_result->p_payload_end = p_result->p_payload_end + (signed long int)4;
    p_result->i_length = p_result->i_length + (unsigned short int)4;
  }

  _Bool return_value_dvbpsi_tot_section_valid$1;
  return_value_dvbpsi_tot_section_valid$1=dvbpsi_tot_section_valid(p_dvbpsi, p_result);
  if(return_value_dvbpsi_tot_section_valid$1 == (_Bool)0)
  {
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): ********************************************", (const void *)"TDT/TOT generator");
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): *  Generated TDT/TOT section is invalid.   *", (const void *)"TDT/TOT generator");
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): * THIS IS A BUG, PLEASE REPORT TO THE LIST *", (const void *)"TDT/TOT generator");
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): *  ---  libdvbpsi-devel@videolan.org  ---  *", (const void *)"TDT/TOT generator");
    dvbpsi_message$link1(p_dvbpsi, (const enum dvbpsi_msg_level)DVBPSI_MSG_ERROR, "libdvbpsi error (%s): ********************************************", (const void *)"TDT/TOT generator");
  }

  return p_result;
}

// fifo_count
// file buffer.h line 56
signed long int fifo_count(struct fifo_s *fifo)
{
  pthread_mutex_lock(&fifo->lock);
  signed long int count = fifo->i_count;
  pthread_mutex_unlock(&fifo->lock);
  return count;
}

// fifo_free
// file buffer.h line 55
void fifo_free(struct fifo_s *fifo)
{
  if(!(fifo == ((struct fifo_s *)NULL)))
  {
    pthread_mutex_lock(&fifo->lock);
    struct buffer_s *p = fifo->p_first;
    if(!(p == ((struct buffer_s *)NULL)))
    {
      fifo->i_count = (signed long int)0;
      fifo->p_first = (struct buffer_s *)(void *)0;
      fifo->pp_last = &fifo->p_first;
    }

    pthread_mutex_unlock(&fifo->lock);
    while(!(p == ((struct buffer_s *)NULL)))
    {
      struct buffer_s *buffer = p->p_next;
      buffer_free(p);
      p = buffer;
    }
    pthread_cond_destroy(&fifo->wait);
    pthread_mutex_destroy(&fifo->lock);
    free((void *)fifo);
    fifo = (struct fifo_s *)(void *)0;
  }

}

// fifo_new
// file buffer.h line 54
struct fifo_s * fifo_new(void)
{
  struct fifo_s *fifo;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct fifo_s) /*128ul*/ );
  fifo = (struct fifo_s *)return_value_malloc$1;
  if(fifo == ((struct fifo_s *)NULL))
    return (struct fifo_s *)(void *)0;

  else
  {
    fifo->i_count = (signed long int)0;
    fifo->i_size = (unsigned long int)0;
    fifo->b_force_wake = (_Bool)0;
    fifo->p_first = (struct buffer_s *)(void *)0;
    fifo->pp_last = &fifo->p_first;
    pthread_mutex_init(&fifo->lock, (const union anonymous$0 *)(void *)0);
    pthread_cond_init(&fifo->wait, (const union anonymous$0 *)(void *)0);
    return fifo;
  }
}

// fifo_pop
// file buffer.h line 59
struct buffer_s * fifo_pop(struct fifo_s *fifo)
{
  struct buffer_s *buffer;
  pthread_mutex_lock(&fifo->lock);
  while(fifo->p_first == ((struct buffer_s *)NULL))
  {
    if(fifo->b_force_wake != (_Bool)0)
      break;

    pthread_cond_wait(&fifo->wait, &fifo->lock);
  }
  buffer = fifo->p_first;
  fifo->b_force_wake = (_Bool)0;
  if(buffer == ((struct buffer_s *)NULL))
  {
    pthread_mutex_unlock(&fifo->lock);
    return (struct buffer_s *)(void *)0;
  }

  else
  {
    fifo->p_first = buffer->p_next;
    fifo->i_count = fifo->i_count - 1l;
    fifo->i_size = fifo->i_size - buffer->i_size;
    if(fifo->p_first == ((struct buffer_s *)NULL))
      fifo->pp_last = &fifo->p_first;

    pthread_mutex_unlock(&fifo->lock);
    buffer->p_next = (struct buffer_s *)(void *)0;
    return buffer;
  }
}

// fifo_push
// file buffer.h line 58
void fifo_push(struct fifo_s *fifo, struct buffer_s *buffer)
{
  struct buffer_s *p_last;
  unsigned long int i_depth = (unsigned long int)0;
  if(!(buffer == ((struct buffer_s *)NULL)))
  {
    pthread_mutex_lock(&fifo->lock);
    p_last = buffer;
    do
    {
      i_depth = i_depth + 1ul;
      if(p_last->p_next == ((struct buffer_s *)NULL))
        break;

      p_last = p_last->p_next;
    }
    while((_Bool)1);
    *fifo->pp_last = buffer;
    fifo->pp_last = &p_last->p_next;
    fifo->i_count = fifo->i_count + (signed long int)i_depth;
    fifo->i_size = fifo->i_size + buffer->i_size;
    /* assertion fifo->p_first != ((void *)0) */
    assert(fifo->p_first != (struct buffer_s *)(void *)0);
    /* assertion fifo->pp_last != ((void *)0) */
    assert(fifo->pp_last != (struct buffer_s **)(void *)0);
    pthread_cond_signal(&fifo->wait);
    pthread_mutex_unlock(&fifo->lock);
  }

}

// fifo_size
// file buffer.h line 57
unsigned long int fifo_size(struct fifo_s *fifo)
{
  pthread_mutex_lock(&fifo->lock);
  unsigned long int size = fifo->i_size;
  pthread_mutex_unlock(&fifo->lock);
  return size;
}

// fifo_wake
// file buffer.h line 60
void fifo_wake(struct fifo_s *fifo)
{
  pthread_mutex_lock(&fifo->lock);
  if(fifo->p_first == ((struct buffer_s *)NULL))
    fifo->b_force_wake = (_Bool)1;

  pthread_cond_broadcast(&fifo->wait);
  pthread_mutex_unlock(&fifo->lock);
}

// handle_BAT
// file libdvbpsi.c line 2148
static void handle_BAT(void *p_data, struct dvbpsi_bat_s *p_bat)
{
  printf("\n");
  printf("  BAT: Bouquet Association Table\n");
  printf("\tVersion number : %d\n", p_bat->i_version);
  printf("\tBouquet id     : %d\n", p_bat->i_extension);
  printf("\tCurrent next   : %s\n", p_bat->b_current_next != (_Bool)0 ? "yes" : "no");
  DumpDescriptors("\t  |  ]", p_bat->p_first_descriptor);
  DumpTSDescriptorsBAT(p_bat->p_first_ts);
  dvbpsi_bat_delete(p_bat);
}

// handle_CAT
// file libdvbpsi.c line 2206
static void handle_CAT(void *p_data, struct dvbpsi_cat_s *p_cat)
{
  struct ts_stream_t *p_stream = (struct ts_stream_t *)p_data;
  p_stream->cat.i_version = p_cat->i_version;
  printf("\n");
  printf("  CAT: Conditional Access Table\n");
  printf("\tVersion number : %d\n", p_cat->i_version);
  printf("\tCurrent next   : %s\n", p_cat->b_current_next != (_Bool)0 ? "yes" : "no");
  DumpDescriptors("\t   ]", p_cat->p_first_descriptor);
  printf("\n");
  dvbpsi_cat_delete(p_cat);
}

// handle_EIT
// file libdvbpsi.c line 1769
static void handle_EIT(void *p_data, struct dvbpsi_eit_s *p_eit)
{
  printf("\n");
  printf("  EIT: Event Information Table\n");
  printf("\tVersion number : %d\n", p_eit->i_version);
  printf("\tService id     : %d\n", p_eit->i_extension);
  printf("\tCurrent next   : %s\n", p_eit->b_current_next != (_Bool)0 ? "yes" : "no");
  printf("\tTransport stream id : %d\n", p_eit->i_ts_id);
  printf("\tOriginal network id : %d\n", p_eit->i_network_id);
  printf("\tSegment last section number : %d\n", p_eit->i_segment_last_section_number);
  printf("\tLast Table id  : %d\n", p_eit->i_last_table_id);
  DumpEITEventDescriptors(p_eit->p_first_event);
  dvbpsi_eit_delete(p_eit);
}

// handle_NIT
// file libdvbpsi.c line 2118
static void handle_NIT(void *p_data, struct dvbpsi_nit_s *p_nit)
{
  printf("\n");
  printf("  NIT: Network Information Table\n");
  printf("\tVersion number : %d\n", p_nit->i_version);
  printf("\tNetwork id     : %d\n", p_nit->i_network_id);
  printf("\tCurrent next   : %s\n", p_nit->b_current_next != (_Bool)0 ? "yes" : "no");
  DumpDescriptors("\t  |  ]", p_nit->p_first_descriptor);
  DumpTSDescriptorsNIT(p_nit->p_first_ts);
  dvbpsi_nit_delete(p_nit);
}

// handle_PAT
// file libdvbpsi.c line 713
static void handle_PAT(void *p_data, struct dvbpsi_pat_s *p_pat)
{
  struct dvbpsi_pat_program_s *p_program = p_pat->p_first_program;
  struct ts_stream_t *p_stream = (struct ts_stream_t *)p_data;
  p_stream->pat.i_pat_version = (signed int)p_pat->i_version;
  p_stream->pat.i_ts_id = (signed int)p_pat->i_ts_id;
  printf("\n");
  printf("  PAT: Program Association Table\n");
  printf("\tTransport stream id : %d\n", p_pat->i_ts_id);
  printf("\tVersion number : %d\n", p_pat->i_version);
  printf("\tCurrent next   : %s\n", p_pat->b_current_next != (_Bool)0 ? "yes" : "no");
  if(p_stream->pat.pid->i_prev_received >= 1l)
    printf("\tLast received  : %ld ms ago\n", (signed long int)(p_stream->pat.pid->i_received - p_stream->pat.pid->i_prev_received));

  printf("\t\t| program_number @ [NIT|PMT]_PID\n");
  while(!(p_program == ((struct dvbpsi_pat_program_s *)NULL)))
  {
    struct ts_pmt_s *p_pmt;
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct ts_pmt_s) /*40ul*/ );
    p_pmt = (struct ts_pmt_s *)return_value_calloc$1;
    if(!(p_pmt == ((struct ts_pmt_s *)NULL)))
    {
      p_pmt->handle=dvbpsi_new(dvbpsi_message, p_stream->level);
      if(p_pmt->handle == ((struct dvbpsi_s *)NULL))
      {
        fprintf(stderr, "dvbinfo: Failed attach new PMT decoder\n");
        free((void *)p_pmt);
        break;
      }

      p_pmt->i_number = (signed int)p_program->i_number;
      p_pmt->pid_pmt = &p_stream->pid[(signed long int)p_program->i_pid];
      p_pmt->pid_pmt->i_pid = (signed int)p_program->i_pid;
      p_pmt->p_next = (struct ts_pmt_s *)(void *)0;
      _Bool return_value_dvbpsi_pmt_attach$2;
      return_value_dvbpsi_pmt_attach$2=dvbpsi_pmt_attach(p_pmt->handle, p_program->i_number, handle_PMT, (void *)p_stream);
      if(return_value_dvbpsi_pmt_attach$2 == (_Bool)0)
      {
        fprintf(stderr, "dvbinfo: Failed to attach new pmt decoder\n");
        dvbpsi_delete(p_pmt->handle);
        free((void *)p_pmt);
        break;
      }

      p_pmt->p_next = p_stream->pmt;
      p_stream->pmt = p_pmt;
      p_stream->i_pmt = p_stream->i_pmt + 1;
      /* assertion p_stream->pmt */
      assert(p_stream->pmt != ((struct ts_pmt_s *)NULL));
    }

    else
      fprintf(stderr, "dvbinfo: Failed create new PMT decoder\n");
    printf("\t\t| %14d @ pid: 0x%x (%d)\n", p_program->i_number, p_program->i_pid, p_program->i_pid);
    p_program = p_program->p_next;
  }
  printf("\tActive         : %s\n", p_pat->b_current_next != (_Bool)0 ? "yes" : "no");
  dvbpsi_pat_delete(p_pat);
}

// handle_PMT
// file libdvbpsi.c line 2165
static void handle_PMT(void *p_data, struct dvbpsi_pmt_s *p_pmt)
{
  struct dvbpsi_pmt_es_s *p_es = p_pmt->p_first_es;
  struct ts_stream_t *p_stream = (struct ts_stream_t *)p_data;
  struct ts_pmt_s *p = p_stream->pmt;
  for( ; !(p == ((struct ts_pmt_s *)NULL)); p = p->p_next)
    if(p->i_number == (signed int)p_pmt->i_program_number)
      break;

  /* assertion p */
  assert(p != ((struct ts_pmt_s *)NULL));
  p->i_pmt_version = (signed int)p_pmt->i_version;
  p->pid_pcr = &p_stream->pid[(signed long int)p_pmt->i_pcr_pid];
  p_stream->pid[(signed long int)p_pmt->i_pcr_pid].b_pcr = (_Bool)1;
  printf("\n");
  printf("  PMT: Program Map Table\n");
  printf("\tProgram number : %d\n", p_pmt->i_program_number);
  printf("\tVersion number : %d\n", p_pmt->i_version);
  printf("\tPCR_PID        : 0x%x (%d)\n", p_pmt->i_pcr_pid, p_pmt->i_pcr_pid);
  printf("\tCurrent next   : %s\n", p_pmt->b_current_next != (_Bool)0 ? "yes" : "no");
  DumpDescriptors("\t   ]", p_pmt->p_first_descriptor);
  printf("\t| type @ elementary_PID : Description\n");
  while(!(p_es == ((struct dvbpsi_pmt_es_s *)NULL)))
  {
    const char *return_value_GetTypeName$1;
    return_value_GetTypeName$1=GetTypeName(p_es->i_type);
    printf("\t| 0x%02x @ pid 0x%x (%d): %s\n", p_es->i_type, p_es->i_pid, p_es->i_pid, return_value_GetTypeName$1);
    DumpDescriptors("\t|  ]", p_es->p_first_descriptor);
    p_es = p_es->p_next;
  }
  dvbpsi_pmt_delete(p_pmt);
}

// handle_RST
// file libdvbpsi.c line 2092
static void handle_RST(void *p_data, struct dvbpsi_rst_s *p_rst)
{
  printf("\n");
  printf("  RST: Running Status Table\n");
  DumpRSTEvents("\t  |  ]", p_rst->p_first_event);
  dvbpsi_rst_delete(p_rst);
}

// handle_SDT
// file libdvbpsi.c line 1715
static void handle_SDT(void *p_data, struct dvbpsi_sdt_s *p_sdt)
{
  struct dvbpsi_sdt_service_s *p_service = p_sdt->p_first_service;
  printf("\n");
  printf("  SDT: Session Descriptor Table\n");
  printf("\tVersion number : %d\n", p_sdt->i_version);
  printf("\tTransport stream id : %d\n", p_sdt->i_extension);
  printf("\tNetwork id     : %d\n", p_sdt->i_network_id);
  for( ; !(p_service == ((struct dvbpsi_sdt_service_s *)NULL)); p_service = p_service->p_next)
  {
    printf("\t  | Service id   : 0x%02x \n", p_service->i_service_id);
    printf("\t  | EIT schedule : %s\n", p_service->b_eit_schedule != (_Bool)0 ? "yes" : "no");
    printf("\t  | EIT present  : %s\n", p_service->b_eit_present != (_Bool)0 ? "yes" : "no");
    printf("\t  | Running      : %d ", p_service->i_running_status);
    switch((signed int)p_service->i_running_status)
    {
      case 0x00:
      {
        printf("(undefined)\n");
        break;
      }
      case 0x01:
      {
        printf("(not running)\n");
        break;
      }
      case 0x02:
      {
        printf("(starts in a few seconds (e.g. for video recording))\n");
        break;
      }
      case 0x03:
      {
        printf("(pausing)\n");
        break;
      }
      case 0x04:
      {
        printf("(running)\n");
        break;
      }
      case 0x05:
      {
        printf("(service off-air)\n");
        break;
      }
      default:
        printf("(reserved for future use)\n");
    }
    printf("\t  | Free CA      : %s\n", p_service->b_free_ca != (_Bool)0 ? "yes" : "no");
    printf("\t  | Descriptor loop length: %d\n", p_service->i_descriptors_length);
    DumpDescriptors("\t  |  ]", p_service->p_first_descriptor);
  }
  dvbpsi_sdt_delete(p_sdt);
}

// handle_SIS
// file libdvbpsi.c line 1547
static void handle_SIS(void *p_data, struct dvbpsi_sis_s *p_sis)
{
  struct ts_stream_t *p_stream = (struct ts_stream_t *)p_data;
  p_stream->sis.i_protocol_version = p_sis->i_protocol_version;
  printf("\n");
  printf("  SIS: Splice Info Section\n");
  printf("\tProtocol version : %d\n", p_sis->i_protocol_version);
  printf("\tEncrypted        : %s\n", p_sis->b_encrypted_packet != (_Bool)0 ? "yes" : "no");
  printf("\tEncryption algorithm  : %d\n", p_sis->i_encryption_algorithm);
  printf("\tPTS adjustment   : %ld\n", p_sis->i_pts_adjustment);
  printf("\tCA Control word index : %d\n", p_sis->cw_index);
  printf("\tSplice command length : %d\n", p_sis->i_splice_command_length);
  printf("\tSplice command : ");
  if(!((signed int)p_sis->i_splice_command_type == 0x00))
  {
    if((signed int)p_sis->i_splice_command_type == 0x04)
      goto __CPROVER_DUMP_L2;

    if((signed int)p_sis->i_splice_command_type == 0x05)
      goto __CPROVER_DUMP_L3;

    if((signed int)p_sis->i_splice_command_type == 0x06)
      goto __CPROVER_DUMP_L4;

    if((signed int)p_sis->i_splice_command_type == 0x07)
      goto __CPROVER_DUMP_L5;

  }

  printf("splice_null");
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L2:
  ;
  printf("splice_schedule");
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L3:
  ;
  printf("splice_insert");
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L4:
  ;
  printf("time_signal");
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L5:
  ;
  printf("bandwidth_reservation");

__CPROVER_DUMP_L6:
  ;
  printf("\n");
  DumpSISDescriptors("\t   ]", p_sis->p_first_descriptor);
  dvbpsi_sis_delete(p_sis);
}

// handle_TOT
// file libdvbpsi.c line 1788
static void handle_TOT(void *p_data, struct dvbpsi_tot_s *p_tot)
{
  printf("\n");
  unsigned char table_id = (unsigned char)(p_tot->p_first_descriptor != (struct dvbpsi_descriptor_s *)(void *)0 ? 0x73 : 0x70);
  if((signed int)table_id == 0x70)
    printf("  TDT: Time and Date Table\n");

  else
    if((signed int)table_id == 0x73)
      printf("  TOT: Time Offset Table\n");

  printf("\tVersion number : %d\n", p_tot->i_version);
  printf("\tCurrent next   : %s\n", p_tot->b_current_next != (_Bool)0 ? "yes" : "no");
  printf("\tUTC time       : %ld\n", p_tot->i_utc_time);
  DumpDescriptors("\t  |  ]", p_tot->p_first_descriptor);
  dvbpsi_tot_delete(p_tot);
}

// handle_atsc_EIT
// file libdvbpsi.c line 2003
static void handle_atsc_EIT(void *p_data, struct dvbpsi_atsc_eit_s *p_eit)
{
  printf("\n");
  printf("  ATSC EIT: Event Information Table\n");
  printf("\tVersion number : %d\n", p_eit->i_version);
  printf("\tCurrent next   : %s\n", p_eit->b_current_next != (_Bool)0 ? "yes" : "no");
  printf("\tProtocol version: %d\n", p_eit->i_protocol);
  printf("\tSource id      : %d\n", p_eit->i_source_id);
  printf("\tEIT events\n");
  DumpATSCEITEventDescriptors(p_eit->p_first_event);
  DumpDescriptors("\t  |  ]", p_eit->p_first_descriptor);
  dvbpsi_atsc_DeleteEIT(p_eit);
}

// handle_atsc_ETT
// file libdvbpsi.c line 2022
static void handle_atsc_ETT(void *p_data, struct dvbpsi_atsc_ett_s *p_ett)
{
  printf("\n");
  printf("  ATSC ETT: Extended Text Table\n");
  printf("\tVersion number : %d\n", p_ett->i_version);
  printf("\tCurrent next   : %s\n", p_ett->b_current_next != (_Bool)0 ? "yes" : "no");
  printf("\tProtocol version: %d\n", p_ett->i_protocol);
  printf("\tETM specific\n");
  printf("\tIdentifier     : %d\n", p_ett->i_etm_id);
  printf("\tLength         : %d\n", p_ett->i_etm_length);
  printf("\tRaw Data       : '%s'\n", p_ett->p_etm_data);
  DumpDescriptors("\t  |  ]", p_ett->p_first_descriptor);
  dvbpsi_atsc_DeleteETT(p_ett);
}

// handle_atsc_MGT
// file libdvbpsi.c line 1843
static void handle_atsc_MGT(void *p_data, struct dvbpsi_atsc_mgt_s *p_mgt)
{
  struct ts_stream_t *p_stream = (struct ts_stream_t *)p_data;
  printf("\n");
  printf("  ATSC MGT: Master Guide Table\n");
  printf("\tVersion number : %d\n", p_mgt->i_version);
  printf("\tCurrent next   : %s\n", p_mgt->b_current_next != (_Bool)0 ? "yes" : "no");
  printf("\tTable ID extension: %d\n", p_mgt->i_table_id_ext);
  printf("\tProtocol version: %d\n", p_mgt->i_protocol);
  struct dvbpsi_atsc_mgt_table_s *p_table = p_mgt->p_first_table;
  while(!(p_table == ((struct dvbpsi_atsc_mgt_table_s *)NULL)))
  {
    struct ts_atsc_eit_s *p;
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct ts_atsc_eit_s) /*32ul*/ );
    p = (struct ts_atsc_eit_s *)return_value_calloc$1;
    if(!(p == ((struct ts_atsc_eit_s *)NULL)))
    {
      p->handle=dvbpsi_new(dvbpsi_message, p_stream->level);
      if(p->handle == ((struct dvbpsi_s *)NULL))
      {
        fprintf(stderr, "dvbinfo: Failed attach new ATSC EIT decoder\n");
        free((void *)p);
        break;
      }

      p->i_table_pid = (signed int)p_table->i_table_type_pid;
      p->pid = &p_stream->pid[(signed long int)p_table->i_table_type_pid];
      p->pid->i_pid = (signed int)p_table->i_table_type_pid;
      p->p_next = (struct ts_atsc_eit_s *)(void *)0;
      _Bool return_value_dvbpsi_AttachDemux$2;
      return_value_dvbpsi_AttachDemux$2=dvbpsi_AttachDemux(p->handle, handle_subtable, (void *)p_stream);
      if(return_value_dvbpsi_AttachDemux$2 == (_Bool)0)
      {
        fprintf(stderr, "dvbinfo: Failed to attach new ATSC EIT decoder\n");
        dvbpsi_delete(p->handle);
        free((void *)p);
        break;
      }

      p->p_next = p_stream->atsc_eit;
      p_stream->atsc_eit = p;
      p_stream->i_atsc_eit = p_stream->i_atsc_eit + 1;
      /* assertion p_stream->atsc_eit */
      assert(p_stream->atsc_eit != ((struct ts_atsc_eit_s *)NULL));
    }

    else
      fprintf(stderr, "dvbinfo: Failed create new ATSC EIT decoder\n");
    printf("\n\t Table %d\n", p_stream->i_atsc_eit);
    printf("\t | PID : 0x%x (%d)\n", p_table->i_table_type_pid, p_table->i_table_type_pid);
    const char *return_value_GetATSCTableType$3;
    return_value_GetATSCTableType$3=GetATSCTableType((const signed int)p_table->i_table_type);
    printf("\t | Type: %s\n", return_value_GetATSCTableType$3);
    printf("\t | Version: %d\n", p_table->i_table_type_version);
    printf("\t | Size: %d bytes\n", p_table->i_number_bytes);
    DumpDescriptors("\t  |  ]", p_table->p_first_descriptor);
    p_table = p_table->p_next;
  }
  DumpDescriptors("\t  |  ]", p_mgt->p_first_descriptor);
  dvbpsi_atsc_DeleteMGT(p_mgt);
}

// handle_atsc_STT
// file libdvbpsi.c line 2042
static void handle_atsc_STT(void *p_data, struct dvbpsi_atsc_stt_s *p_stt)
{
  printf("\n");
  printf("  ATSC STT: System Time Table\n");
  printf("\tVersion number : %d\n", p_stt->i_version);
  printf("\tCurrent next   : %s\n", p_stt->b_current_next != (_Bool)0 ? "yes" : "no");
  printf("\tSystem time (GPS): %d seconds\n", p_stt->i_system_time);
  printf("\tGPS-UTC Offset   : %d seconds\n", p_stt->i_gps_utc_offset);
  _Bool b_status = (_Bool)((signed int)p_stt->i_daylight_savings & 0x01);
  unsigned char i_day_of_month = (unsigned char)(((signed int)p_stt->i_daylight_savings & 0x00F8) >> 3);
  unsigned char i_hour = (unsigned char)((signed int)p_stt->i_daylight_savings >> 8);
  printf("\tDaylight savings : %s\n", b_status != (_Bool)0 ? "on" : "off");
  printf("\t\tDay of month: %d\n", i_day_of_month);
  printf("\t\tHour of day : %d\n", i_hour);
  DumpDescriptors("\t  |  ]", p_stt->p_first_descriptor);
  dvbpsi_atsc_DeleteSTT(p_stt);
}

// handle_atsc_VCT
// file libdvbpsi.c line 1968
static void handle_atsc_VCT(void *p_data, struct dvbpsi_atsc_vct_s *p_vct)
{
  printf("\n");
  printf("  ATSC VCT: Virtual Channel Table\n");
  printf("\tVersion number : %d\n", p_vct->i_version);
  printf("\tCurrent next   : %s\n", p_vct->b_current_next != (_Bool)0 ? "yes" : "no");
  printf("\tProtocol version: %d\n", p_vct->i_protocol);
  printf("\tType : %s Virtual Channel Table\n", p_vct->b_cable_vct != (_Bool)0 ? "Cable" : "Terrestrial");
  DumpAtscVCTChannels(p_vct->p_first_channel);
  DumpDescriptors("\t  |  ]", p_vct->p_first_descriptor);
  dvbpsi_atsc_DeleteVCT(p_vct);
}

// handle_subtable
// file libdvbpsi.c line 590
static void handle_subtable(struct dvbpsi_s *p_dvbpsi, unsigned char i_table_id, unsigned short int i_extension, void *p_data)
{
  _Bool return_value_dvbpsi_nit_attach$1;
  _Bool return_value_dvbpsi_sdt_attach$2;
  _Bool return_value_dvbpsi_bat_attach$3;
  _Bool return_value_dvbpsi_eit_attach$4;
  _Bool return_value_dvbpsi_tot_attach$5;
  _Bool return_value_dvbpsi_atsc_AttachMGT$6;
  _Bool return_value_dvbpsi_atsc_AttachVCT$7;
  _Bool return_value_dvbpsi_atsc_AttachEIT$8;
  _Bool return_value_dvbpsi_atsc_AttachETT$9;
  _Bool return_value_dvbpsi_atsc_AttachSTT$10;
  _Bool return_value_dvbpsi_sis_attach$11;
  switch((signed int)i_table_id)
  {
    case 0x40:

    case 0x41:
    {
      return_value_dvbpsi_nit_attach$1=dvbpsi_nit_attach(p_dvbpsi, i_table_id, i_extension, handle_NIT, p_data);
      if(return_value_dvbpsi_nit_attach$1 == (_Bool)0)
        fprintf(stderr, "dvbinfo: Failed to attach NIT subdecoder\n");

      break;
    }
    case 0x42:
    {
      return_value_dvbpsi_sdt_attach$2=dvbpsi_sdt_attach(p_dvbpsi, i_table_id, i_extension, handle_SDT, p_data);
      if(return_value_dvbpsi_sdt_attach$2 == (_Bool)0)
        fprintf(stderr, "dvbinfo: Failed to attach SDT subdecoder\n");

      break;
    }
    case 0x4A:
    {
      return_value_dvbpsi_bat_attach$3=dvbpsi_bat_attach(p_dvbpsi, i_table_id, i_extension, handle_BAT, p_data);
      if(return_value_dvbpsi_bat_attach$3 == (_Bool)0)
        fprintf(stderr, "dvbinfo: Failed to attach BAT subdecoder\n");

      break;
    }
    case 0x4E:

    case 0x4F:

    case 0x50:

    case 0x51:

    case 0x52:

    case 0x53:

    case 0x54:

    case 0x55:

    case 0x56:

    case 0x57:

    case 0x58:

    case 0x59:

    case 0x5A:

    case 0x5B:

    case 0x5C:

    case 0x5D:

    case 0x5E:

    case 0x5F:

    case 0x60:

    case 0x61:

    case 0x62:

    case 0x63:

    case 0x64:

    case 0x65:

    case 0x66:

    case 0x67:

    case 0x68:

    case 0x69:

    case 0x6A:

    case 0x6B:

    case 0x6C:

    case 0x6D:

    case 0x6E:

    case 0x6F:
    {
      return_value_dvbpsi_eit_attach$4=dvbpsi_eit_attach(p_dvbpsi, i_table_id, i_extension, handle_EIT, p_data);
      if(return_value_dvbpsi_eit_attach$4 == (_Bool)0)
        fprintf(stderr, "dvbinfo: Failed to attach EIT subdecoder\n");

      break;
    }
    case 0x70:

    case 0x73:
    {
      return_value_dvbpsi_tot_attach$5=dvbpsi_tot_attach(p_dvbpsi, i_table_id, i_extension, handle_TOT, p_data);
      if(return_value_dvbpsi_tot_attach$5 == (_Bool)0)
        fprintf(stderr, "dvbinfo: Failed to attach TOT subdecoder\n");

      break;
    }
    case 0xC7:
    {
      return_value_dvbpsi_atsc_AttachMGT$6=dvbpsi_atsc_AttachMGT(p_dvbpsi, i_table_id, i_extension, handle_atsc_MGT, p_data);
      if(return_value_dvbpsi_atsc_AttachMGT$6 == (_Bool)0)
        fprintf(stderr, "dvbinfo: Failed to attach ATSC MGT subdecoder\n");

      break;
    }
    case 0xC8:

    case 0xC9:
    {
      return_value_dvbpsi_atsc_AttachVCT$7=dvbpsi_atsc_AttachVCT(p_dvbpsi, i_table_id, i_extension, handle_atsc_VCT, p_data);
      if(return_value_dvbpsi_atsc_AttachVCT$7 == (_Bool)0)
        fprintf(stderr, "dvbinfo: Failed to attach ATSC VCT subdecoder\n");

      break;
    }
    case 0xCB:
    {
      return_value_dvbpsi_atsc_AttachEIT$8=dvbpsi_atsc_AttachEIT(p_dvbpsi, i_table_id, i_extension, handle_atsc_EIT, p_data);
      if(return_value_dvbpsi_atsc_AttachEIT$8 == (_Bool)0)
        fprintf(stderr, "dvbinfo: Failed to attach ATSC EIT subdecoder\n");

      break;
    }
    case 0xCC:
    {
      return_value_dvbpsi_atsc_AttachETT$9=dvbpsi_atsc_AttachETT(p_dvbpsi, i_table_id, i_extension, handle_atsc_ETT, p_data);
      if(return_value_dvbpsi_atsc_AttachETT$9 == (_Bool)0)
        fprintf(stderr, "dvbinfo: Failed to attach ATSC ETT subdecoder\n");

      break;
    }
    case 0xCD:
    {
      return_value_dvbpsi_atsc_AttachSTT$10=dvbpsi_atsc_AttachSTT(p_dvbpsi, i_table_id, i_extension, handle_atsc_STT, p_data);
      if(return_value_dvbpsi_atsc_AttachSTT$10 == (_Bool)0)
        fprintf(stderr, "dvbinfo: Failed to attach ATSC STT subdecoder\n");

      break;
    }
    case 0xFC:
    {
      return_value_dvbpsi_sis_attach$11=dvbpsi_sis_attach(p_dvbpsi, i_table_id, i_extension, handle_SIS, p_data);
      if(return_value_dvbpsi_sis_attach$11 == (_Bool)0)
        fprintf(stderr, "dvbinfo: Failed to attach SIS subdecoder\n");

    }
  }
}

// is_ipv6
// file udp.c line 177
static _Bool is_ipv6(const char *ipaddress)
{
  char *return_value_strchr$1;
  return_value_strchr$1=strchr(ipaddress, 58);
  return return_value_strchr$1 != (char *)(void *)0;
}

// is_multicast
// file udp.c line 69
static _Bool is_multicast(struct sockaddr_storage *saddr, unsigned int len)
{
  struct sockaddr *addr = (struct sockaddr *)saddr;
  struct sockaddr_in *ip;
  unsigned int return_value_ntohl$1;
  struct sockaddr_in6 *ip6;
  switch((signed int)addr->sa_family)
  {
    case 2:
    {
      ip = (struct sockaddr_in *)saddr;
      if(!((unsigned long int)len >= sizeof(struct sockaddr_in) /*16ul*/ ))
        return (_Bool)0;

      return_value_ntohl$1=ntohl(ip->sin_addr.s_addr);
      return (signed int)(((unsigned int)return_value_ntohl$1 & 0xf0000000) == 0xe0000000) != 0;
    }
    case 10:
    {
      ip6 = (struct sockaddr_in6 *)saddr;
      if(!((unsigned long int)len >= sizeof(struct sockaddr_in6) /*28ul*/ ))
        return (_Bool)0;

      return (signed int)((signed int)((const unsigned char *)&ip6->sin6_addr)[(signed long int)0] == 0xff) != 0;
    }
    default:
      return (_Bool)0;
  }
}

// libdvbpsi_exit
// file libdvbpsi.h line 46
void libdvbpsi_exit(struct ts_stream_t *stream)
{
  summary(stdout, stream);
  _Bool return_value_dvbpsi_decoder_present$1;
  return_value_dvbpsi_decoder_present$1=dvbpsi_decoder_present(stream->pat.handle);
  if(!(return_value_dvbpsi_decoder_present$1 == (_Bool)0))
    dvbpsi_pat_detach(stream->pat.handle);

  struct ts_pmt_s *p_pmt = stream->pmt;
  struct ts_pmt_s *p_prev = (struct ts_pmt_s *)(void *)0;
  while(!(p_pmt == ((struct ts_pmt_s *)NULL)))
  {
    struct dvbpsi_s *libdvbpsi_exit$$1$$1$$handle = p_pmt->handle;
    _Bool return_value_dvbpsi_decoder_present$2;
    return_value_dvbpsi_decoder_present$2=dvbpsi_decoder_present(libdvbpsi_exit$$1$$1$$handle);
    if(!(return_value_dvbpsi_decoder_present$2 == (_Bool)0))
    {
      dvbpsi_pmt_detach(libdvbpsi_exit$$1$$1$$handle);
      dvbpsi_delete(p_pmt->handle);
    }

    stream->i_pmt = stream->i_pmt - 1;
    p_prev = p_pmt;
    p_pmt = p_pmt->p_next;
    if(!(p_prev == ((struct ts_pmt_s *)NULL)))
      p_prev->p_next = (struct ts_pmt_s *)(void *)0;

    free((void *)p_prev);
  }
  struct ts_atsc_eit_s *p_atsc_eit = stream->atsc_eit;
  struct ts_atsc_eit_s *p_atsc_prev = (struct ts_atsc_eit_s *)(void *)0;
  while(!(p_atsc_eit == ((struct ts_atsc_eit_s *)NULL)))
  {
    struct dvbpsi_s *handle = p_atsc_eit->handle;
    _Bool return_value_dvbpsi_decoder_present$3;
    return_value_dvbpsi_decoder_present$3=dvbpsi_decoder_present(handle);
    if(!(return_value_dvbpsi_decoder_present$3 == (_Bool)0))
    {
      dvbpsi_DetachDemux(handle);
      dvbpsi_delete(p_atsc_eit->handle);
    }

    stream->i_atsc_eit = stream->i_atsc_eit - 1;
    p_atsc_prev = p_atsc_eit;
    p_atsc_eit = p_atsc_eit->p_next;
    if(!(p_atsc_prev == ((struct ts_atsc_eit_s *)NULL)))
      p_atsc_prev->p_next = (struct ts_atsc_eit_s *)(void *)0;

    free((void *)p_atsc_prev);
  }
  _Bool return_value_dvbpsi_decoder_present$4;
  return_value_dvbpsi_decoder_present$4=dvbpsi_decoder_present(stream->cat.handle);
  if(!(return_value_dvbpsi_decoder_present$4 == (_Bool)0))
    dvbpsi_cat_detach(stream->cat.handle);

  _Bool return_value_dvbpsi_decoder_present$5;
  return_value_dvbpsi_decoder_present$5=dvbpsi_decoder_present(stream->sdt.handle);
  if(!(return_value_dvbpsi_decoder_present$5 == (_Bool)0))
    dvbpsi_DetachDemux(stream->sdt.handle);

  _Bool return_value_dvbpsi_decoder_present$6;
  return_value_dvbpsi_decoder_present$6=dvbpsi_decoder_present(stream->rst.handle);
  if(!(return_value_dvbpsi_decoder_present$6 == (_Bool)0))
    dvbpsi_rst_detach(stream->rst.handle);

  _Bool return_value_dvbpsi_decoder_present$7;
  return_value_dvbpsi_decoder_present$7=dvbpsi_decoder_present(stream->eit.handle);
  if(!(return_value_dvbpsi_decoder_present$7 == (_Bool)0))
    dvbpsi_DetachDemux(stream->eit.handle);

  _Bool return_value_dvbpsi_decoder_present$8;
  return_value_dvbpsi_decoder_present$8=dvbpsi_decoder_present(stream->tdt.handle);
  if(!(return_value_dvbpsi_decoder_present$8 == (_Bool)0))
    dvbpsi_DetachDemux(stream->tdt.handle);

  _Bool return_value_dvbpsi_decoder_present$9;
  return_value_dvbpsi_decoder_present$9=dvbpsi_decoder_present(stream->atsc.handle);
  if(!(return_value_dvbpsi_decoder_present$9 == (_Bool)0))
    dvbpsi_DetachDemux(stream->atsc.handle);

  if(!(stream->pat.handle == ((struct dvbpsi_s *)NULL)))
    dvbpsi_delete(stream->pat.handle);

  if(!(stream->cat.handle == ((struct dvbpsi_s *)NULL)))
    dvbpsi_delete(stream->cat.handle);

  if(!(stream->sdt.handle == ((struct dvbpsi_s *)NULL)))
    dvbpsi_delete(stream->sdt.handle);

  if(!(stream->rst.handle == ((struct dvbpsi_s *)NULL)))
    dvbpsi_delete(stream->rst.handle);

  if(!(stream->eit.handle == ((struct dvbpsi_s *)NULL)))
    dvbpsi_delete(stream->eit.handle);

  if(!(stream->tdt.handle == ((struct dvbpsi_s *)NULL)))
    dvbpsi_delete(stream->tdt.handle);

  if(!(stream->atsc.handle == ((struct dvbpsi_s *)NULL)))
    dvbpsi_delete(stream->atsc.handle);

  free((void *)stream);
  stream = (struct ts_stream_t *)(void *)0;
}

// libdvbpsi_init
// file libdvbpsi.h line 43
struct ts_stream_t * libdvbpsi_init(signed int debug, void (*pf_log)(void *, const signed int, const char *, ...), void *cb_data)
{
  struct ts_stream_t *stream;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct ts_stream_t) /*852184ul*/ );
  stream = (struct ts_stream_t *)return_value_calloc$1;
  _Bool return_value_dvbpsi_pat_attach$2;
  _Bool return_value_dvbpsi_cat_attach$3;
  _Bool return_value_dvbpsi_AttachDemux$4;
  _Bool return_value_dvbpsi_rst_attach$5;
  _Bool return_value_dvbpsi_AttachDemux$6;
  _Bool return_value_dvbpsi_AttachDemux$7;
  _Bool return_value_dvbpsi_AttachDemux$8;
  if(stream == ((struct ts_stream_t *)NULL))
    return (struct ts_stream_t *)(void *)0;

  else
  {
    if(!(pf_log == ((void (*)(void *, const signed int, const char *, ...))NULL)))
    {
      stream->pf_log = pf_log;
      stream->cb_data = cb_data;
    }

    switch(debug)
    {
      case 0:
      {
        stream->level = (enum dvbpsi_msg_level)DVBPSI_MSG_NONE;
        break;
      }
      case 1:
      {
        stream->level = (enum dvbpsi_msg_level)DVBPSI_MSG_ERROR;
        break;
      }
      case 2:
      {
        stream->level = (enum dvbpsi_msg_level)DVBPSI_MSG_WARN;
        break;
      }
      case 3:
        stream->level = (enum dvbpsi_msg_level)DVBPSI_MSG_DEBUG;
    }
    stream->pat.handle=dvbpsi_new(dvbpsi_message, stream->level);
    if(!(stream->pat.handle == ((struct dvbpsi_s *)NULL)))
    {
      return_value_dvbpsi_pat_attach$2=dvbpsi_pat_attach(stream->pat.handle, handle_PAT, (void *)stream);
      if(return_value_dvbpsi_pat_attach$2 == (_Bool)0)
      {
        dvbpsi_delete(stream->pat.handle);
        stream->pat.handle = (struct dvbpsi_s *)(void *)0;
        goto error;
      }

      stream->cat.handle=dvbpsi_new(dvbpsi_message, stream->level);
      if(stream->cat.handle == ((struct dvbpsi_s *)NULL))
        goto error;

      return_value_dvbpsi_cat_attach$3=dvbpsi_cat_attach(stream->cat.handle, handle_CAT, (void *)stream);
      if(return_value_dvbpsi_cat_attach$3 == (_Bool)0)
      {
        dvbpsi_delete(stream->cat.handle);
        stream->cat.handle = (struct dvbpsi_s *)(void *)0;
        goto error;
      }

      stream->sdt.handle=dvbpsi_new(dvbpsi_message, stream->level);
      if(stream->sdt.handle == ((struct dvbpsi_s *)NULL))
        goto error;

      return_value_dvbpsi_AttachDemux$4=dvbpsi_AttachDemux(stream->sdt.handle, handle_subtable, (void *)stream);
      if(return_value_dvbpsi_AttachDemux$4 == (_Bool)0)
      {
        dvbpsi_delete(stream->sdt.handle);
        stream->sdt.handle = (struct dvbpsi_s *)(void *)0;
        goto error;
      }

      stream->rst.handle=dvbpsi_new(dvbpsi_message, stream->level);
      if(stream->rst.handle == ((struct dvbpsi_s *)NULL))
        goto error;

      return_value_dvbpsi_rst_attach$5=dvbpsi_rst_attach(stream->rst.handle, handle_RST, (void *)stream);
      if(return_value_dvbpsi_rst_attach$5 == (_Bool)0)
      {
        dvbpsi_delete(stream->rst.handle);
        stream->rst.handle = (struct dvbpsi_s *)(void *)0;
        goto error;
      }

      stream->eit.handle=dvbpsi_new(dvbpsi_message, stream->level);
      if(stream->eit.handle == ((struct dvbpsi_s *)NULL))
        goto error;

      return_value_dvbpsi_AttachDemux$6=dvbpsi_AttachDemux(stream->eit.handle, handle_subtable, (void *)stream);
      if(return_value_dvbpsi_AttachDemux$6 == (_Bool)0)
      {
        dvbpsi_delete(stream->eit.handle);
        stream->eit.handle = (struct dvbpsi_s *)(void *)0;
        goto error;
      }

      stream->tdt.handle=dvbpsi_new(dvbpsi_message, stream->level);
      if(stream->tdt.handle == ((struct dvbpsi_s *)NULL))
        goto error;

      return_value_dvbpsi_AttachDemux$7=dvbpsi_AttachDemux(stream->tdt.handle, handle_subtable, (void *)stream);
      if(return_value_dvbpsi_AttachDemux$7 == (_Bool)0)
      {
        dvbpsi_delete(stream->tdt.handle);
        stream->tdt.handle = (struct dvbpsi_s *)(void *)0;
        goto error;
      }

      stream->atsc.handle=dvbpsi_new(dvbpsi_message, stream->level);
      if(stream->atsc.handle == ((struct dvbpsi_s *)NULL))
        goto error;

      return_value_dvbpsi_AttachDemux$8=dvbpsi_AttachDemux(stream->atsc.handle, handle_subtable, (void *)stream);
      if(return_value_dvbpsi_AttachDemux$8 == (_Bool)0)
      {
        dvbpsi_delete(stream->atsc.handle);
        stream->atsc.handle = (struct dvbpsi_s *)(void *)0;
        goto error;
      }

      stream->pat.pid = &stream->pid[(signed long int)0x00];
      stream->cat.pid = &stream->pid[(signed long int)0x01];
      stream->sdt.pid = &stream->pid[(signed long int)0x11];
      stream->eit.pid = &stream->pid[(signed long int)0x12];
      stream->rst.pid = &stream->pid[(signed long int)0x13];
      stream->tdt.pid = &stream->pid[(signed long int)0x14];
      stream->atsc.pid = &stream->pid[(signed long int)0x1FFB];
      return stream;
    }

    else
    {

    error:
      ;
      _Bool return_value_dvbpsi_decoder_present$9;
      return_value_dvbpsi_decoder_present$9=dvbpsi_decoder_present(stream->pat.handle);
      if(!(return_value_dvbpsi_decoder_present$9 == (_Bool)0))
        dvbpsi_pat_detach(stream->pat.handle);

      _Bool return_value_dvbpsi_decoder_present$10;
      return_value_dvbpsi_decoder_present$10=dvbpsi_decoder_present(stream->cat.handle);
      if(!(return_value_dvbpsi_decoder_present$10 == (_Bool)0))
        dvbpsi_cat_detach(stream->cat.handle);

      _Bool return_value_dvbpsi_decoder_present$11;
      return_value_dvbpsi_decoder_present$11=dvbpsi_decoder_present(stream->sdt.handle);
      if(!(return_value_dvbpsi_decoder_present$11 == (_Bool)0))
        dvbpsi_DetachDemux(stream->sdt.handle);

      _Bool return_value_dvbpsi_decoder_present$12;
      return_value_dvbpsi_decoder_present$12=dvbpsi_decoder_present(stream->eit.handle);
      if(!(return_value_dvbpsi_decoder_present$12 == (_Bool)0))
        dvbpsi_DetachDemux(stream->eit.handle);

      _Bool return_value_dvbpsi_decoder_present$13;
      return_value_dvbpsi_decoder_present$13=dvbpsi_decoder_present(stream->rst.handle);
      if(!(return_value_dvbpsi_decoder_present$13 == (_Bool)0))
        dvbpsi_rst_detach(stream->rst.handle);

      _Bool return_value_dvbpsi_decoder_present$14;
      return_value_dvbpsi_decoder_present$14=dvbpsi_decoder_present(stream->tdt.handle);
      if(!(return_value_dvbpsi_decoder_present$14 == (_Bool)0))
        dvbpsi_DetachDemux(stream->tdt.handle);

      _Bool return_value_dvbpsi_decoder_present$15;
      return_value_dvbpsi_decoder_present$15=dvbpsi_decoder_present(stream->atsc.handle);
      if(!(return_value_dvbpsi_decoder_present$15 == (_Bool)0))
        dvbpsi_DetachDemux(stream->atsc.handle);

      if(!(stream->pat.handle == ((struct dvbpsi_s *)NULL)))
        dvbpsi_delete(stream->pat.handle);

      if(!(stream->cat.handle == ((struct dvbpsi_s *)NULL)))
        dvbpsi_delete(stream->cat.handle);

      if(!(stream->sdt.handle == ((struct dvbpsi_s *)NULL)))
        dvbpsi_delete(stream->sdt.handle);

      if(!(stream->rst.handle == ((struct dvbpsi_s *)NULL)))
        dvbpsi_delete(stream->rst.handle);

      if(!(stream->eit.handle == ((struct dvbpsi_s *)NULL)))
        dvbpsi_delete(stream->eit.handle);

      if(!(stream->tdt.handle == ((struct dvbpsi_s *)NULL)))
        dvbpsi_delete(stream->tdt.handle);

      if(!(stream->atsc.handle == ((struct dvbpsi_s *)NULL)))
        dvbpsi_delete(stream->atsc.handle);

      free((void *)stream);
      return (struct ts_stream_t *)(void *)0;
    }
  }
}

// libdvbpsi_log
// file dvbinfo.c line 154
static void libdvbpsi_log(void *data, const signed int level, const char *format, ...)
{
  signed int err = 0;
  char *msg = (char *)(void *)0;
  void **ap = (void **)&format;
  err=vasprintf(&msg, format, ap);
  ap = ((void **)NULL);
  if(err >= 0)
  {
    struct params_s *param = (struct params_s *)data;
    if(param == ((struct params_s *)NULL))
      free((void *)msg);

    else
    {
      if(!(param->b_monitor == (_Bool)0))
        syslog(log_level[(signed long int)level], "%s", msg);

      else
        fprintf(stderr, "%s: %s", psz_level[(signed long int)level], msg);
      free((void *)msg);
    }
  }

}

// libdvbpsi_process
// file libdvbpsi.h line 44
_Bool libdvbpsi_process(struct ts_stream_t *stream, unsigned char *buf, signed long int length, signed long int date)
{
  signed long int i_prev_pcr = (signed long int)0;
  signed int i_old_cc = -1;
  signed long int i = (signed long int)0;
  signed int tmp_if_expr$1;
  for( ; !(i >= length); i = i + (signed long int)188)
  {
    signed long int i_lost;
    i_lost=check_sync_word(buf + i, length - i);
    if(i_lost >= 1l)
    {
      stream->i_lost_bytes = stream->i_lost_bytes + (unsigned long int)i_lost;
      i = i + i_lost;
      stream->pf_log(stream->cb_data, 0, "dvbinfo: %ld: lost %ld bytes out of %ld in buffer\n", date, (signed long int)i_lost, (signed long int)length);
      if(i >= length)
        return (_Bool)1;

    }

    /* assertion buf[i] == 0x47 */
    assert((signed int)buf[i] == 0x47);
    unsigned char *p_tmp = &buf[i];
    unsigned short int i_pid = (unsigned short int)(((signed int)(unsigned short int)((signed int)p_tmp[(signed long int)1] & 0x1f) << 8) + (signed int)p_tmp[(signed long int)2]);
    signed int i_cc = (signed int)p_tmp[(signed long int)3] & 0x0f;
    _Bool b_discontinuity_seen = (_Bool)0;
    stream->pid[(signed long int)i_pid].i_packets = stream->pid[(signed long int)i_pid].i_packets + 1ul;
    stream->i_packets = stream->i_packets + 1ul;
    stream->pid[(signed long int)i_pid].i_prev_received = stream->pid[(signed long int)i_pid].i_received;
    stream->pid[(signed long int)i_pid].i_received = date;
    if(!((signed int)stream->level >= DVBPSI_MSG_DEBUG))
      stream->pf_log(stream->cb_data, 3, "dvbinfo: %ld packet %ld pid %u (0x%x) cc %d\n", date, stream->i_packets, i_pid, i_pid, i_cc);

    if((signed int)i_pid == 0x0)
      dvbpsi_packet_push(stream->pat.handle, p_tmp);

    else
      if((signed int)i_pid == 0x01)
        dvbpsi_packet_push(stream->cat.handle, p_tmp);

      else
        if((signed int)i_pid == 0x02)
          dvbpsi_packet_push(stream->tdt.handle, p_tmp);

        else
          if((signed int)i_pid == 0x11)
            dvbpsi_packet_push(stream->sdt.handle, p_tmp);

          else
            if((signed int)i_pid == 0x12)
              dvbpsi_packet_push(stream->eit.handle, p_tmp);

            else
              if((signed int)i_pid == 0x13)
                dvbpsi_packet_push(stream->rst.handle, p_tmp);

              else
                if((signed int)i_pid == 0x14)
                  dvbpsi_packet_push(stream->tdt.handle, p_tmp);

                else
                  if((signed int)i_pid == 0x1FFB)
                    dvbpsi_packet_push(stream->atsc.handle, p_tmp);

                  else
                  {
                    struct ts_pmt_s *p = stream->pmt;
                    for( ; !(p == ((struct ts_pmt_s *)NULL)); p = p->p_next)
                      if(p->pid_pmt->i_pid == (signed int)i_pid)
                        dvbpsi_packet_push(p->handle, p_tmp);

                    struct ts_atsc_eit_s *p_atsc_eit = stream->atsc_eit;
                    for( ; !(p_atsc_eit == ((struct ts_atsc_eit_s *)NULL)); p_atsc_eit = p_atsc_eit->p_next)
                      if(p_atsc_eit->pid->i_pid == (signed int)i_pid)
                        dvbpsi_packet_push(p_atsc_eit->handle, p_tmp);

                  }
    if(stream->pid[(signed long int)i_pid].b_seen == (_Bool)0)
    {
      stream->pid[(signed long int)i_pid].i_pid = (signed int)i_pid;
      stream->pid[(signed long int)i_pid].b_seen = (_Bool)1;
      i_old_cc = i_cc;
      stream->pid[(signed long int)i_pid].i_cc = i_cc;
    }

    else
    {
      signed int i_diff = 0;
      i_diff = i_cc - (stream->pid[(signed long int)i_pid].i_cc + 1) % 16;
      b_discontinuity_seen = i_diff != 0;
      i_old_cc = stream->pid[(signed long int)i_pid].i_cc;
      stream->pid[(signed long int)i_pid].i_cc = i_cc;
    }
    if((signed int)i_pid == 0x1FFF)
      stream->i_null_packets = stream->i_null_packets + 1ul;

    else
    {
      stream->pid[(signed long int)i_pid].b_transport_error_indicator = ((signed int)p_tmp[(signed long int)1] & 0x80) == 0x80;
      stream->pid[(signed long int)i_pid].b_payload_unit_start_indicator = ((signed int)p_tmp[(signed long int)1] & 0x40) == 0x40;
      stream->pid[(signed long int)i_pid].b_transport_priority = ((signed int)p_tmp[(signed long int)1] & 0x20) == 0x20;
      stream->pid[(signed long int)i_pid].i_transport_scrambling_control = (unsigned char)(((signed int)p_tmp[(signed long int)3] & 0xC0) >> 6);
      stream->pid[(signed long int)i_pid].b_adaptation_field = (_Bool)((signed int)p_tmp[(signed long int)3] & 0x20);
      if(!(stream->pid[(signed long int)i_pid].b_adaptation_field == (_Bool)0))
      {
        if((signed int)p_tmp[4l] >= 1)
        {
          _Bool b_pcr = ((signed int)p_tmp[(signed long int)5] & 0x10) == 0x10;
          _Bool b_opcr = ((signed int)p_tmp[(signed long int)5] & 0x08) == 0x08;
          stream->pid[(signed long int)i_pid].b_discontinuity_indicator = ((signed int)p_tmp[(signed long int)5] & 0x80) == 0x80;
          stream->pid[(signed long int)i_pid].b_random_access_indicator = ((signed int)p_tmp[(signed long int)5] & 0x40) == 0x40;
          stream->pid[(signed long int)i_pid].b_elementary_stream_priority_indicator = ((signed int)p_tmp[(signed long int)5] & 0x20) == 0x20;
          stream->pid[(signed long int)i_pid].b_splicing_point = ((signed int)p_tmp[(signed long int)5] & 0x04) == 0x04;
          stream->pid[(signed long int)i_pid].b_transport_private_data = ((signed int)p_tmp[(signed long int)5] & 0x02) == 0x02;
          stream->pid[(signed long int)i_pid].b_adaptation_field_extension = ((signed int)p_tmp[(signed long int)5] & 0x01) == 0x01;
          unsigned int i_ext = (unsigned int)5;
          if(!(b_pcr == (_Bool)0))
            i_ext = i_ext + (unsigned int)6;

          if(!(b_pcr == (_Bool)0))
          {
            if((signed int)p_tmp[4l] >= 7)
            {
              signed long int i_pcr = (signed long int)p_tmp[(signed long int)6] << 25 | (signed long int)p_tmp[(signed long int)7] << 17 | (signed long int)p_tmp[(signed long int)8] << 9 | (signed long int)p_tmp[(signed long int)9] << 1 | (signed long int)((signed int)p_tmp[(signed long int)10] & 0x80) >> 7;
              i_pcr = (i_pcr * (signed long int)100) / (signed long int)9;
              i_prev_pcr = stream->pid[(signed long int)i_pid].i_pcr;
              stream->pid[(signed long int)i_pid].i_pcr = i_pcr;
              if(stream->pid[(signed long int)i_pid].i_first_pcr == 0l)
                stream->pid[(signed long int)i_pid].i_first_pcr = i_pcr;

              if(!(i_pcr >= stream->pid[(signed long int)i_pid].i_last_pcr))
              {
                if(!(b_discontinuity_seen == (_Bool)0))
                  stream->pf_log(stream->cb_data, 2, "dvbinfo: Warning wrapping PCR on discontinuity\n");

                else
                  stream->pf_log(stream->cb_data, 2, "dvbinfo: Warning wrapping PCR\n");
              }

              stream->pid[(signed long int)i_pid].i_prev_pcr = i_prev_pcr;
              stream->pid[(signed long int)i_pid].i_last_pcr = i_pcr;
              if(!(stream->pid[(signed long int)i_pid].b_discontinuity_indicator == (_Bool)0))
              {
                stream->pf_log(stream->cb_data, 2, "dvbinfo: Server signalled the continuity counter discontinuity\n");
                b_discontinuity_seen = (_Bool)0;
              }

            }

          }

          if(!(b_opcr == (_Bool)0))
            i_ext = i_ext + (unsigned int)6;

          if(!(stream->pid[(signed long int)i_pid].b_splicing_point == (_Bool)0))
          {
            i_ext = i_ext + 1u;
            if((0x80 & (signed int)p_tmp[(signed long int)i_ext]) == 0x80)
              tmp_if_expr$1 = -1 * ((signed int)p_tmp[(signed long int)i_ext] & 0x7f);

            else
              tmp_if_expr$1 = (signed int)p_tmp[(signed long int)i_ext] & 0x7f;
            stream->pid[(signed long int)i_pid].i_splice_countdown = (signed char)tmp_if_expr$1;
          }

          if(!(stream->pid[(signed long int)i_pid].b_transport_private_data == (_Bool)0))
          {
            i_ext = i_ext + 1u;
            stream->pid[(signed long int)i_pid].i_transport_private_data_length = p_tmp[(signed long int)i_ext];
            i_ext = i_ext + (unsigned int)stream->pid[(signed long int)i_pid].i_transport_private_data_length;
          }

          if(!(stream->pid[(signed long int)i_pid].b_adaptation_field_extension == (_Bool)0))
          {
            i_ext = i_ext + 1u;
            unsigned char *p_ext = &p_tmp[(signed long int)i_ext];
            unsigned int i_seamless_splice = i_ext;
            stream->pid[(signed long int)i_pid].i_adaptation_field_extension_length = (unsigned int)p_ext[(signed long int)0];
            if(stream->pid[(signed long int)i_pid].i_adaptation_field_extension_length >= 1u)
            {
              stream->pid[(signed long int)i_pid].b_ltw = ((signed int)p_ext[(signed long int)1] & 0x80) == 0x80;
              stream->pid[(signed long int)i_pid].b_piecewise_rate = ((signed int)p_ext[(signed long int)1] & 0x40) == 0x40;
              stream->pid[(signed long int)i_pid].b_seamless_splice = ((signed int)p_ext[(signed long int)1] & 0x20) == 0x20;
              if(!(stream->pid[(signed long int)i_pid].b_ltw == (_Bool)0))
              {
                stream->pid[(signed long int)i_pid].b_ltw_valid = ((signed int)p_ext[(signed long int)2] & 0x80) == 0x80;
                stream->pid[(signed long int)i_pid].i_ltw_offset = (unsigned short int)((signed int)(unsigned short int)p_ext[(signed long int)2] & 0x7F);
                i_seamless_splice = i_seamless_splice + (unsigned int)2;
              }

              if(!(stream->pid[(signed long int)i_pid].b_piecewise_rate == (_Bool)0))
              {
                stream->pid[(signed long int)i_pid].i_piecewise_rate = ((unsigned int)p_ext[(signed long int)i_seamless_splice] & (unsigned int)0x3F) << 16 | (unsigned int)p_ext[(signed long int)(i_seamless_splice + (unsigned int)1)] << 8 | (unsigned int)p_ext[(signed long int)(i_seamless_splice + (unsigned int)2)];
                i_seamless_splice = i_seamless_splice + (unsigned int)3;
              }

              if(!(stream->pid[(signed long int)i_pid].b_seamless_splice == (_Bool)0))
                stream->pid[(signed long int)i_pid].i_splice_type = (unsigned char)((signed int)p_tmp[(signed long int)i_seamless_splice] & 0xF0);

            }

          }

        }

      }

      if(!(b_discontinuity_seen == (_Bool)0))
      {
        stream->pf_log(stream->cb_data, 2, "dvbinfo: Continuity counter discontinuity (pid %u 0x%x found %d expected %d)\n", i_pid, i_pid, stream->pid[(signed long int)i_pid].i_cc, i_old_cc + 1);
        b_discontinuity_seen = (_Bool)0;
      }

    }

  dump_packet:
    ;
    if((signed int)stream->level >= DVBPSI_MSG_DEBUG)
      ts_dump_packet_details(stdout, stream, &buf[i], i_pid);

  }
  return (_Bool)1;
}

// libdvbpsi_summary
// file libdvbpsi.h line 45
void libdvbpsi_summary(struct _IO_FILE *fd, struct ts_stream_t *stream, const signed int summary_mode)
{
  switch(summary_mode)
  {
    case 1:
    {
      summary_table(fd, stream);
      break;
    }
    case 2:
    {
      summary_packet(fd, stream);
      break;
    }
    case 0:

    default:
      summary(fd, stream);
  }
}

// main
// file dvbinfo.c line 467
signed int main(signed int argc, char **pp_argv)
{
  struct dvbinfo_capture_s capture;
  struct params_s *param = (struct params_s *)(void *)0;
  char c;
  printf("dvbinfo: Copyright (C) 2011-2014 M2X BV\n");
  printf("License: LGPL v2.1\n");
  if(argc == 1)
    usage();

  param=params_init();
  if(param == ((struct params_s *)NULL))
  {
    printf("dvbinfo: out of memory\n");
    exit(1);
  }

  capture.params = param;
  capture.fifo=fifo_new();
  capture.empty=fifo_new();
  capture.b_fifo_full = (_Bool)0;
  pthread_mutex_init(&capture.lock, (const union anonymous$0 *)(void *)0);
  pthread_cond_init(&capture.fifo_full, (const union anonymous$0 *)(void *)0);
  signed int return_value_getopt_long$1;
  signed int return_value_strncmp$3;
  signed int return_value_strncmp$2;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$13;
  signed int *return_value___errno_location$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$22;
  signed int *return_value___errno_location$20;
  _Bool tmp_if_expr$21;
  do
  {
    static struct option long_options[14l] = { { .name="debug", .has_arg=1, .flag=(signed int *)(void *)0, .val=100 },
    { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="file", .has_arg=1, .flag=(signed int *)(void *)0, .val=102 },
    { .name="ipaddress", .has_arg=1, .flag=(signed int *)(void *)0, .val=105 },
    { .name="miface", .has_arg=1, .flag=(signed int *)(void *)0, .val=97 },
    { .name="tcp", .has_arg=0, .flag=(signed int *)(void *)0, .val=116 },
    { .name="udp", .has_arg=0, .flag=(signed int *)(void *)0, .val=117 },
    { .name="output", .has_arg=1, .flag=(signed int *)(void *)0, .val=111 },
    { .name="monitor", .has_arg=0, .flag=(signed int *)(void *)0, .val=109 },
    { .name="summary", .has_arg=1, .flag=(signed int *)(void *)0, .val=115 },
    { .name="summary-file", .has_arg=1, .flag=(signed int *)(void *)0, .val=106 },
    { .name="summary-period", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="capturesize", .has_arg=1, .flag=(signed int *)(void *)0, .val=99 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
    return_value_getopt_long$1=getopt_long(argc, pp_argv, "a:c:d:f:i:j:ho:p:ms:tu", long_options, (signed int *)(void *)0);
    c = (char)return_value_getopt_long$1;
    if((signed int)c == -1)
      break;

    switch((signed int)c)
    {
      case 100:
      {
        if(!(optarg == ((char *)NULL)))
        {
          param->debug = 0;
          signed int return_value_strncmp$4;
          return_value_strncmp$4=strncmp(optarg, "error", (unsigned long int)5);
          if(return_value_strncmp$4 == 0)
            param->debug = 1;

          else
          {
            return_value_strncmp$3=strncmp(optarg, "warn", (unsigned long int)4);
            if(return_value_strncmp$3 == 0)
              param->debug = 2;

            else
            {
              return_value_strncmp$2=strncmp(optarg, "debug", (unsigned long int)5);
              if(return_value_strncmp$2 == 0)
                param->debug = 3;

            }
          }
        }

        break;
      }
      case 102:
      {
        if(!(optarg == ((char *)NULL)))
        {
          signed int return_value_asprintf$5;
          return_value_asprintf$5=asprintf(&param->input, "%s", optarg);
          if(!(return_value_asprintf$5 >= 0))
          {
            fprintf(stderr, "error: out of memory\n");
            params_free(param);
            usage();
          }

          param->pf_read = read;
          param->b_file = (_Bool)1;
        }

        break;
      }
      case 97:
      {
        if(!(optarg == ((char *)NULL)))
        {
          signed int return_value_asprintf$6;
          return_value_asprintf$6=asprintf(&param->mcast_interface, "%s", optarg);
          if(!(return_value_asprintf$6 >= 0))
          {
            params_free(param);
            usage();
          }

        }

        break;
      }
      case 105:
      {
        if(!(optarg == ((char *)NULL)))
        {
          char *psz_tmp;
          psz_tmp=strtok(optarg, ":");
          if(!(psz_tmp == ((char *)NULL)))
          {
            unsigned long int len;
            len=strlen(psz_tmp);
            signed long int return_value_strtol$7;
            return_value_strtol$7=strtol(&optarg[(signed long int)(len + (unsigned long int)1)], (char ** restrict )(void *)0, 0);
            param->port = (signed int)return_value_strtol$7;
            param->input=strdup(psz_tmp);
          }

          else
          {
            params_free(param);
            usage();
          }
        }

        break;
      }
      case 109:
      {
        param->b_monitor = (_Bool)1;
        break;
      }
      case 111:
      {
        if(!(optarg == ((char *)NULL)))
        {
          signed int return_value_asprintf$8;
          return_value_asprintf$8=asprintf(&param->output, "%s", optarg);
          if(!(return_value_asprintf$8 >= 0))
          {
            fprintf(stderr, "error: out of memory\n");
            params_free(param);
            usage();
          }

          param->pf_write = write;
        }

        break;
      }
      case 116:
      {
        param->b_tcp = (_Bool)1;
        param->pf_read = tcp_read;
        break;
      }
      case 117:
      {
        param->b_udp = (_Bool)1;
        param->pf_read = udp_read;
        break;
      }
      case 99:
      {
        if(!(optarg == ((char *)NULL)))
        {
          param->threshold=strtoul(optarg, (char ** restrict )(void *)0, 10);
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          if(*return_value___errno_location$9 == 34)
            tmp_if_expr$10 = param->threshold == (unsigned long int)0x7fffffffffffffffL * 2UL + 1UL ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$10 = (_Bool)0;
          if(tmp_if_expr$10)
            tmp_if_expr$13 = (_Bool)1;

          else
          {
            return_value___errno_location$11=__errno_location();
            if(!(*return_value___errno_location$11 == 0))
              tmp_if_expr$12 = param->threshold == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$12 = (_Bool)0;
            tmp_if_expr$13 = tmp_if_expr$12 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$13)
          {
            fprintf(stderr, "Option --capturesize has invalid content %s\n", optarg);
            params_free(param);
            usage();
          }

        }

        break;
      }
      case 115:
      {
        if(!(optarg == ((char *)NULL)))
        {
          signed long int size = (signed long int)(sizeof(const char *[4l]) /*32ul*/  / sizeof(const char *) /*8ul*/ );
          signed long int i = (signed long int)0;
          for( ; !(i >= size); i = i + 1l)
          {
            printf("summary mode %s\n", psz_summary_mode[i]);
            unsigned long int return_value_strlen$14;
            return_value_strlen$14=strlen(psz_summary_mode[i]);
            signed int return_value_strncmp$15;
            return_value_strncmp$15=strncmp(optarg, psz_summary_mode[i], return_value_strlen$14);
            if(return_value_strncmp$15 == 0)
            {
              param->summary.mode = i_summary_mode[i];
              param->b_summary = (_Bool)1;
              break;
            }

          }
        }

        if(param->b_summary == (_Bool)0)
        {
          fprintf(stderr, "Option --summary has invalid content %s\n", optarg);
          params_free(param);
          usage();
        }

        break;
      }
      case 106:
      {
        if(!(optarg == ((char *)NULL)))
        {
          signed int return_value_asprintf$16;
          return_value_asprintf$16=asprintf(&param->summary.file, "%s", optarg);
          if(!(return_value_asprintf$16 >= 0))
          {
            params_free(param);
            usage();
          }

        }

        break;
      }
      case 112:
      {
        if(!(optarg == ((char *)NULL)))
        {
          param->summary.period=strtoll(optarg, (char ** restrict )(void *)0, 10);
          signed int *return_value___errno_location$17;
          return_value___errno_location$17=__errno_location();
          if(*return_value___errno_location$17 == 34)
          {
            if(param->summary.period == -9223372036854775808ll)
              tmp_if_expr$18 = (_Bool)1;

            else
              tmp_if_expr$18 = param->summary.period == 0x7fffffffffffffffLL ? (_Bool)1 : (_Bool)0;
            tmp_if_expr$19 = tmp_if_expr$18 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$19 = (_Bool)0;
          if(tmp_if_expr$19)
            tmp_if_expr$22 = (_Bool)1;

          else
          {
            return_value___errno_location$20=__errno_location();
            if(!(*return_value___errno_location$20 == 0))
              tmp_if_expr$21 = param->summary.period == (signed long int)0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$21 = (_Bool)0;
            tmp_if_expr$22 = tmp_if_expr$21 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$22)
          {
            fprintf(stderr, "Option --summary-period has invalid content %s\n", optarg);
            params_free(param);
            usage();
          }

        }

        break;
      }
      case 58:
      {
        fprintf(stderr, "Option %c is missing arguments\n", c);
        params_free(param);
        exit(1);
        break;
      }
      case 63:
      {
        fprintf(stderr, "Unknown option %c found\n", c);
        params_free(param);
        exit(1);
        break;
      }
      case 104:

      default:
      {
        params_free(param);
        usage();
      }
    }
  }
  while((_Bool)1);
  if(!(param->b_monitor == (_Bool)0))
  {
    openlog("dvbinfo", 0x01, 3 << 3);
    signed int return_value_daemon$23;
    return_value_daemon$23=daemon(1, 0);
    if(!(return_value_daemon$23 >= 0))
    {
      libdvbpsi_log((void *)param, 0, "Failed to start in background\n");
      params_free(param);
      closelog();
      usage();
    }

    libdvbpsi_log((void *)param, 2, "dvbinfo: Copyright (C) 2011-2012 M2X BV\n");
    libdvbpsi_log((void *)param, 0, "License: LGPL v2.1\n");
  }

  if(param->input == ((char *)NULL))
  {
    libdvbpsi_log((void *)param, 0, "No source given\n");
    if(!(param->b_monitor == (_Bool)0))
      closelog();

    params_free(param);
    usage();
  }

  _Bool tmp_if_expr$24;
  if(!(param->b_udp == (_Bool)0))
    tmp_if_expr$24 = (_Bool)1;

  else
    tmp_if_expr$24 = param->b_tcp != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$24)
  {
    capture.size = (unsigned long int)(7 * 188);
    libdvbpsi_log((void *)param, 2, "Listen: host=%s port=%d\n", param->input, param->port);
  }

  else
  {
    capture.size = (unsigned long int)188;
    libdvbpsi_log((void *)param, 2, "Examining: %s\n", param->input);
  }
  dvbinfo_open(param);
  unsigned long int handle;
  capture.b_alive = (_Bool)1;
  signed int return_value_pthread_create$25;
  return_value_pthread_create$25=pthread_create(&handle, (const union pthread_attr_t *)(void *)0, dvbinfo_capture, (void *)&capture);
  if(!(return_value_pthread_create$25 >= 0))
  {
    libdvbpsi_log((void *)param, 0, "failed creating thread\n");
    dvbinfo_close(param);
    if(!(param->b_monitor == (_Bool)0))
      closelog();

    params_free(param);
    exit(1);
  }

  signed int err;
  err=dvbinfo_process(&capture);
  capture.b_alive = (_Bool)0;
  signed int return_value_pthread_join$26;
  return_value_pthread_join$26=pthread_join(handle, (void **)(void *)0);
  if(!(return_value_pthread_join$26 >= 0))
    libdvbpsi_log((void *)param, 0, "error joining capture thread\n");

  dvbinfo_close(param);
  fifo_wake((&capture)->fifo);
  fifo_wake((&capture)->empty);
  fifo_free((&capture)->fifo);
  fifo_free((&capture)->empty);
  pthread_mutex_destroy(&capture.lock);
  pthread_cond_destroy(&capture.fifo_full);
  if(!(param->b_monitor == (_Bool)0))
    closelog();

  params_free(param);
  param = (struct params_s *)(void *)0;
  if(!(err >= 0))
    exit(1);

  else
    exit(0);
}

// mcast_connect
// file udp.c line 97
static _Bool mcast_connect(signed int s, const char *interface, struct sockaddr_storage *saddr, unsigned int len)
{
  unsigned int ifindex;
  unsigned int tmp_if_expr$2;
  unsigned int return_value_if_nametoindex$1;
  if(!(interface == ((const char *)NULL)))
  {
    return_value_if_nametoindex$1=if_nametoindex(interface);
    tmp_if_expr$2 = return_value_if_nametoindex$1;
  }

  else
    tmp_if_expr$2 = (unsigned int)0;
  ifindex = tmp_if_expr$2;
  struct sockaddr *addr = (struct sockaddr *)saddr;
  struct group_req greq;
  memset((void *)&greq, 0, sizeof(struct group_req) /*136ul*/ );
  struct sockaddr_in6 *sin6;
  signed int return_value_setsockopt$3;
  signed int return_value_setsockopt$4;
  if(ifindex == 0u)
    return (_Bool)0;

  else
  {
    greq.gr_interface = ifindex;
    /* assertion len <= sizeof(greq.gr_group) */
    assert((unsigned long int)len <= sizeof(struct sockaddr_storage) /*128ul*/ );
    memcpy((void *)&greq.gr_group, (const void *)addr, (unsigned long int)len);
    switch((signed int)addr->sa_family)
    {
      case 10:
      {
        sin6 = (struct sockaddr_in6 *)saddr;
        /* assertion len >= sizeof (struct sockaddr_in6) */
        assert((unsigned long int)len >= sizeof(struct sockaddr_in6) /*28ul*/ );
        if(!(sin6->sin6_scope_id == 0u))
          greq.gr_interface = sin6->sin6_scope_id;

        return_value_setsockopt$3=setsockopt(s, 41, 42, (const void *)&greq, (unsigned int)sizeof(struct group_req) /*136ul*/ );
        if(return_value_setsockopt$3 == 0)
          return (_Bool)1;

        break;
      }
      case 2:
      {
        return_value_setsockopt$4=setsockopt(s, 0, 42, (const void *)&greq, (unsigned int)sizeof(struct group_req) /*136ul*/ );
        if(return_value_setsockopt$4 == 0)
          return (_Bool)1;

        break;
      }
      default:
        return (_Bool)0;
    }
    return (_Bool)0;
  }
}

// mdate
// file libdvbpsi.h line 30
signed long int mdate(void)
{
  struct timeval tv;
  signed int return_value_gettimeofday$3;
  return_value_gettimeofday$3=gettimeofday(&tv, (struct timezone *)(void *)0);
  if(!(return_value_gettimeofday$3 >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    fprintf(stderr, "gettimeofday() error: %s\n", return_value_strerror$2);
    abort();
  }

  return tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000;
}

// params_free
// file dvbinfo.c line 221
static void params_free(struct params_s *param)
{
  free((void *)param->mcast_interface);
  free((void *)param->input);
  free((void *)param->output);
  free((void *)param->summary.file);
  free((void *)param);
  param = (struct params_s *)(void *)0;
}

// params_init
// file dvbinfo.c line 190
static struct params_s * params_init(void)
{
  struct params_s *param;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct params_s) /*112ul*/ );
  param = (struct params_s *)return_value_calloc$1;
  if(param == ((struct params_s *)NULL))
    exit(1);

  param->fd_out = -1;
  param->fd_in = param->fd_out;
  param->input = (char *)(void *)0;
  param->output = (char *)(void *)0;
  param->mcast_interface = (char *)(void *)0;
  param->b_verbose = (_Bool)0;
  param->b_monitor = (_Bool)0;
  param->threshold = (unsigned long int)(400 * 1024 * 1024);
  param->b_summary = (_Bool)0;
  param->summary.mode = 0;
  param->summary.file = (char *)(void *)0;
  param->summary.fd = stdout;
  param->summary.period = (signed long int)1000;
  param->pf_read = (signed long int (*)(signed int, void *, unsigned long int))(void *)0;
  param->pf_write = (signed long int (*)(signed int, const void *, unsigned long int))(void *)0;
  return param;
}

// summary
// file libdvbpsi.c line 480
static void summary(struct _IO_FILE *fd, struct ts_stream_t *stream)
{
  unsigned long int i_packets = (unsigned long int)0;
  signed long int i_first_pcr = (signed long int)0;
  signed long int i_last_pcr = (signed long int)0;
  signed long int start = (signed long int)0;
  signed long int end = (signed long int)0;
  fprintf(fd, "\n---------------------------------------------------------\n");
  fprintf(fd, "\nSummary: Bandwidth\n");
  signed int i_pid = 0;
  for( ; !(i_pid >= 8192); i_pid = i_pid + 1)
    if(!(stream->pid[(signed long int)i_pid].b_pcr == (_Bool)0))
    {
      start = stream->pid[(signed long int)i_pid].i_first_pcr;
      end = stream->pid[(signed long int)i_pid].i_last_pcr;
      if(!(stream->pid[(signed long int)i_pid].b_discontinuity_indicator == (_Bool)0))
        fprintf(fd, "PCR discontinuity was signalled for PID: %4d (0x%4x)\n", i_pid, i_pid);

    }

  signed int summary$$1$$2$$i_pid = 0;
  for( ; !(summary$$1$$2$$i_pid >= 8192); summary$$1$$2$$i_pid = summary$$1$$2$$i_pid + 1)
    if(!(stream->pid[(signed long int)summary$$1$$2$$i_pid].b_seen == (_Bool)0))
    {
      fprintf(fd, "Found PID: %4d (0x%4x), DRM: %s,", summary$$1$$2$$i_pid, summary$$1$$2$$i_pid, (signed int)stream->pid[(signed long int)summary$$1$$2$$i_pid].i_transport_scrambling_control != 0x00 ? "yes" : " no");
      double bitrate = (double)0;
      if(end + -start >= 1l)
        bitrate = (double)(stream->pid[(signed long int)summary$$1$$2$$i_pid].i_packets * (unsigned long int)188 * (unsigned long int)8) / ((double)(end - start) / 1000.0);

      fprintf(fd, " bitrate %0.4f kbit/s,", bitrate);
      fprintf(fd, " seen %ld packets", stream->pid[(signed long int)summary$$1$$2$$i_pid].i_packets);
      fprintf(fd, "\n");
      i_packets = i_packets + stream->pid[(signed long int)summary$$1$$2$$i_pid].i_packets;
      if(i_first_pcr == 0l)
        i_first_pcr = start;

      else
        i_first_pcr = i_first_pcr < start ? i_first_pcr : start;
      i_last_pcr = i_last_pcr > end ? i_last_pcr : end;
    }

  double total_bitrate = (double)((i_packets * (unsigned long int)188 + stream->i_lost_bytes) * (unsigned long int)8) / ((double)(i_last_pcr - i_first_pcr) / 1000.0);
  fprintf(fd, "\nTotal bitrate %0.4f kbits/s\n", total_bitrate);
  fprintf(fd, "Number of packets: %ld, stuffing %ld packets, lost %ld bytes\n", i_packets, stream->i_null_packets, stream->i_lost_bytes);
  fprintf(fd, "PCR first: %ld, last: %ld, duration: %ld\n", i_first_pcr, i_last_pcr, (signed long int)(i_last_pcr - i_first_pcr));
  fprintf(fd, "\n---------------------------------------------------------\n");
}

// summary_packet
// file libdvbpsi.c line 572
static void summary_packet(struct _IO_FILE *fd, struct ts_stream_t *stream)
{
  fprintf(fd, "\n---------------------------------------------------------\n");
  fprintf(fd, "\nSummary: Packet\n");
  signed int i_pid = 0;
  for( ; !(i_pid >= 8192); i_pid = i_pid + 1)
  {
    struct ts_pid_s *ts = &stream->pid[(signed long int)i_pid];
    ts_header_dump(fd, ts);
  }
  fprintf(fd, "\n---------------------------------------------------------\n");
}

// summary_table
// file libdvbpsi.c line 540
static void summary_table(struct _IO_FILE *fd, struct ts_stream_t *stream)
{
  fprintf(fd, "\n---------------------------------------------------------\n");
  fprintf(fd, "\nSummary: Table\n");
  fprintf(fd, "\nTable: PAT\n");
  if(!(stream->pat.handle == ((struct dvbpsi_s *)NULL)))
    ts_header_dump(fd, stream->pat.pid);

  fprintf(fd, "\nTable: PMT\n");
  struct ts_pmt_s *p_pmt = stream->pmt;
  for( ; !(p_pmt == ((struct ts_pmt_s *)NULL)); p_pmt = p_pmt->p_next)
    if(!(p_pmt->handle == ((struct dvbpsi_s *)NULL)))
      ts_header_dump(fd, p_pmt->pid_pmt);

  fprintf(fd, "\nTable: CAT\n");
  if(!(stream->cat.handle == ((struct dvbpsi_s *)NULL)))
    ts_header_dump(fd, stream->cat.pid);

  fprintf(fd, "\nTable: SDT\n");
  if(!(stream->sdt.handle == ((struct dvbpsi_s *)NULL)))
    ts_header_dump(fd, stream->sdt.pid);

  fprintf(fd, "\nTable: EIT\n");
  if(!(stream->eit.handle == ((struct dvbpsi_s *)NULL)))
    ts_header_dump(fd, stream->eit.pid);

  fprintf(fd, "\nTable: TDT\n");
  if(!(stream->tdt.handle == ((struct dvbpsi_s *)NULL)))
    ts_header_dump(fd, stream->tdt.pid);

  fprintf(fd, "\n---------------------------------------------------------\n");
}

// tcp_close
// file tcp.h line 27
signed int tcp_close(signed int fd)
{
  signed int result = 0;
  result=shutdown(fd, 2);
  if(!(result >= 0))
    perror("tcp shutdown error");

  return result;
}

// tcp_open
// file tcp.h line 26
signed int tcp_open(const char *ipaddress, signed int port)
{
  signed int s_ctl = -1;
  signed int result = -1;
  if(ipaddress == ((const char *)NULL))
    return -1;

  else
  {
    struct addrinfo hints;
    struct addrinfo *addr;
    char *psz_service;
    if(port >= 65536 || !(port >= 0))
    {
      fprintf(stderr, "tcp error: invalid port %d specified\n", port);
      return -1;
    }

    else
    {
      signed int return_value_asprintf$1;
      return_value_asprintf$1=asprintf(&psz_service, "%d", port);
      if(!(return_value_asprintf$1 >= 0))
        return -1;

      else
      {
        memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
        hints.ai_family = 2;
        hints.ai_socktype = 1;
        hints.ai_protocol = 6;
        hints.ai_flags = 0x0002 | 0;
        result=getaddrinfo(ipaddress, psz_service, &hints, &addr);
        if(!(result >= 0))
        {
          const char *return_value_gai_strerror$2;
          return_value_gai_strerror$2=gai_strerror(result);
          fprintf(stderr, "tcp address error: %s\n", return_value_gai_strerror$2);
          free((void *)psz_service);
          return -1;
        }

        struct addrinfo *ptr = addr;
        for( ; !(ptr == ((struct addrinfo *)NULL)); ptr = ptr->ai_next)
        {
          signed int sflags = 0;
          sflags = 524288;
          s_ctl=socket(ptr->ai_family, ptr->ai_socktype | sflags, ptr->ai_protocol);
          if(!(s_ctl >= 0))
            perror("tcp socket error");

          else
          {
            signed int literal$3 = 1;
            signed int return_value_setsockopt$4;
            return_value_setsockopt$4=setsockopt(s_ctl, 1, 2, (const void *)&literal$3, (unsigned int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_setsockopt$4 >= 0))
              perror("tcp setsockopt error");

            result=connect(s_ctl, ptr->ai_addr, ptr->ai_addrlen);
            if(!(result >= 0))
            {
              close(s_ctl);
              s_ctl = -1;
              perror("tcp connect error");
            }

            else
              break;
          }
        }
        freeaddrinfo(addr);
        free((void *)psz_service);
        return s_ctl;
      }
    }
  }
}

// tcp_read
// file tcp.h line 28
signed long int tcp_read(signed int fd, void *buf, unsigned long int count)
{
  signed long int err;
  signed int *return_value___errno_location$1;
  do
  {

  again:
    ;
    err=recv(fd, buf, count, 256);
    if(err >= 0l)
      goto __CPROVER_DUMP_L7;

    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 4) && !(*return_value___errno_location$1 == 11))
    {
      if(*return_value___errno_location$1 == 111)
        break;

      if(*return_value___errno_location$1 == 107)
        goto __CPROVER_DUMP_L4;

      goto __CPROVER_DUMP_L5;
    }

  }
  while((_Bool)1);
  fprintf(stderr, "remote host refused connection\n");
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L4:
  ;
  fprintf(stderr, "connection not established\n");
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L5:
  ;
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  char *return_value_strerror$3;
  return_value_strerror$3=strerror(*return_value___errno_location$2);
  fprintf(stderr, "recv error: %s\n", return_value_strerror$3);
  return (signed long int)-1;

__CPROVER_DUMP_L6:
  ;

__CPROVER_DUMP_L7:
  ;
  return err;
}

// ts_dump_packet_details
// file libdvbpsi.c line 464
static void ts_dump_packet_details(struct _IO_FILE *fd, struct ts_stream_t *stream, const unsigned char *data, const unsigned short int i_pid)
{
  fprintf(fd, "\n\t---------------------------------------------------------\n");
  fprintf(fd, "\tTS Packet number %ld, ES number %ld, pid %d (0x%x)\n", stream->i_packets, stream->pid[(signed long int)i_pid].i_packets, i_pid, i_pid);
  fprintf(fd, "\tReceived time: %ld ms\n", stream->pid[(signed long int)i_pid].i_received);
  ts_header_dump(fd, &stream->pid[(signed long int)i_pid]);
  ts_hexdump(fd, data, (const unsigned int)188);
  fprintf(fd, "\n\t---------------------------------------------------------\n");
}

// ts_header_dump
// file libdvbpsi.c line 377
static void ts_header_dump(struct _IO_FILE *fd, struct ts_pid_s *ts)
{
  fprintf(fd, "\n\tPID 0x%x seen %s\n", ts->i_pid, ts->b_seen != (_Bool)0 ? "yes" : "no");
  fprintf(fd, "\tContinuity counter: %d\n", ts->i_cc);
  fprintf(fd, "\tTransport Error indicator: %s\n", ts->b_transport_error_indicator != (_Bool)0 ? "yes" : "no");
  fprintf(fd, "\tPayload unit start indicator: %s\n", ts->b_payload_unit_start_indicator != (_Bool)0 ? "yes" : "no");
  fprintf(fd, "\tScrambling control: %s\n", (signed int)ts->i_transport_scrambling_control != 0x0 ? "yes" : "no");
  if((signed int)ts->i_transport_scrambling_control >= 1)
    fprintf(fd, "\tScrambling control word: 0x%x\n", ts->i_transport_scrambling_control);

  fprintf(fd, "\tAdaptation field control: %s\n", ts->b_adaptation_field != (_Bool)0 ? "yes" : "no");
  if(!(ts->b_adaptation_field == (_Bool)0))
  {
    fprintf(fd, "\tDiscontinuity indicator: %s\n", ts->b_discontinuity_indicator != (_Bool)0 ? "yes" : "no");
    fprintf(fd, "\tRandom access indicator: %s\n", ts->b_random_access_indicator != (_Bool)0 ? "yes" : "no");
    fprintf(fd, "\tElementary stream priority indicator: %s\n", ts->b_elementary_stream_priority_indicator != (_Bool)0 ? "yes" : "no");
    fprintf(fd, "\tTransport private data: %s\n", ts->b_transport_private_data != (_Bool)0 ? "yes" : "no");
    if(!(ts->b_transport_private_data == (_Bool)0))
      fprintf(fd, "\tTransport private data length: %d\n", ts->i_transport_private_data_length);

    fprintf(fd, "\tSplicing point: %s\n", ts->b_splicing_point != (_Bool)0 ? "yes" : "no");
    if(!(ts->b_splicing_point == (_Bool)0))
      fprintf(fd, "\tSplice countdown: %d (0x%x)\n", ts->i_splice_countdown, ts->i_splice_countdown);

    fprintf(fd, "\tOriginal PCR: %s\n", ts->b_opcr != (_Bool)0 ? "yes" : "no");
    fprintf(fd, "\tPCR PID: %s\n", ts->b_pcr != (_Bool)0 ? "yes" : "no");
    if(!(ts->b_pcr == (_Bool)0))
      fprintf(fd, "\tPCR: %ld\n", ts->i_pcr);

    if(!(ts->b_adaptation_field_extension == (_Bool)0))
    {
      if(ts->i_adaptation_field_extension_length >= 1u)
      {
        fprintf(fd, "\tadaptation field extension, length: %d\n", ts->i_adaptation_field_extension_length);
        fprintf(fd, "\tlegal time window (ltw): %s\n", ts->b_ltw != (_Bool)0 ? "yes" : "no");
        fprintf(fd, "\tltw valid: %s\n", ts->b_ltw_valid != (_Bool)0 ? "yes" : "no");
        if(!(ts->b_ltw == (_Bool)0))
          fprintf(fd, "\tlegal time window offset: %d\n", ts->i_ltw_offset);

        fprintf(fd, "\tpiecewise rate: %s\n", ts->b_piecewise_rate != (_Bool)0 ? "yes" : "no");
        if(!(ts->b_piecewise_rate == (_Bool)0))
          fprintf(fd, "\tpiecewise rate: %d\n", ts->i_piecewise_rate);

        fprintf(fd, "\tseamless splice: %s\n", ts->b_seamless_splice != (_Bool)0 ? "yes" : "no");
        if(!(ts->b_seamless_splice == (_Bool)0))
        {
          const char *descr;
          switch((signed int)ts->i_splice_type)
          {
            case 0x00:
            {
              descr = "splice_decoding_delay = 120 ms; max_splice_rate = 15.0 × 106 bit/s";
              break;
            }
            case 0x01:
            {
              descr = "splice_decoding_delay = 150 ms; max_splice_rate = 12.0 × 106 bit/s";
              break;
            }
            case 0x02:
            {
              descr = "splice_decoding_delay = 225 ms; max_splice_rate = 8.0 × 106 bit/s";
              break;
            }
            case 0x03:
            {
              descr = "splice_decoding_delay = 250 ms; max_splice_rate = 7.2 × 106 bit/s";
              break;
            }
            default:
              descr = "Reserved/User-defined";
          }
          fprintf(fd, "\tsplice type 0x%x (%s)\n", ts->i_splice_type, descr);
        }

      }

    }

  }

}

// ts_hexdump
// file libdvbpsi.c line 365
static void ts_hexdump(struct _IO_FILE *fd, const unsigned char * const data, const unsigned int length)
{
  unsigned int i;
  fprintf(fd, "\t");
  i = (unsigned int)0;
  for( ; !(i >= length); i = i + 1u)
  {
    if(i % 8u == 0u)
      fprintf(fd, " ");

    if(i % 16u == 0u)
      fprintf(fd, "\n\t %.4x: ", i);

    fprintf(fd, "%.2x ", data[(signed long int)i]);
  }
}

// udp_close
// file udp.h line 28
signed int udp_close(signed int fd)
{
  signed int result = 0;
  result=close(fd);
  if(!(result >= 0))
    perror("udp shutdown error");

  return result;
}

// udp_open
// file udp.h line 27
signed int udp_open(const char *interface, const char *ipaddress, signed int port)
{
  signed int s_ctl = -1;
  signed int result = -1;
  _Bool return_value_mcast_connect$10;
  if(ipaddress == ((const char *)NULL))
    return -1;

  else
  {
    struct addrinfo hints;
    struct addrinfo *addr;
    char *psz_service;
    if(port >= 65536 || !(port >= 0))
    {
      fprintf(stderr, "udp error: invalid port %d specified\n", port);
      return -1;
    }

    else
    {
      signed int return_value_asprintf$1;
      return_value_asprintf$1=asprintf(&psz_service, "%d", port);
      if(!(return_value_asprintf$1 >= 0))
        return -1;

      else
      {
        memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
        _Bool return_value_is_ipv6$2;
        return_value_is_ipv6$2=is_ipv6(ipaddress);
        hints.ai_family = return_value_is_ipv6$2 != (_Bool)0 ? 10 : 2;
        hints.ai_socktype = 2;
        hints.ai_protocol = 17;
        hints.ai_flags = 0x0002 | 0;
        result=getaddrinfo(ipaddress, psz_service, &hints, &addr);
        if(!(result >= 0))
        {
          const char *return_value_gai_strerror$3;
          return_value_gai_strerror$3=gai_strerror(result);
          fprintf(stderr, "udp address error: %s\n", return_value_gai_strerror$3);
          free((void *)psz_service);
          return -1;
        }

        struct addrinfo *ptr = addr;
        for( ; !(ptr == ((struct addrinfo *)NULL)); ptr = ptr->ai_next)
        {
          signed int sflags = 0;
          sflags = 524288;
          s_ctl=socket(ptr->ai_family, ptr->ai_socktype | sflags, ptr->ai_protocol);
          if(!(s_ctl >= 0))
            perror("udp socket error");

          else
          {
            signed int literal$4 = 0x80000;
            signed int return_value_setsockopt$5;
            return_value_setsockopt$5=setsockopt(s_ctl, 1, 8, (void *)&literal$4, (unsigned int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_setsockopt$5 >= 0))
              perror("udp setsockopt error");

            signed int literal$6 = 0x80000;
            signed int return_value_setsockopt$7;
            return_value_setsockopt$7=setsockopt(s_ctl, 1, 7, (void *)&literal$6, (unsigned int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_setsockopt$7 >= 0))
              perror("udp setsockopt error");

            signed int literal$8 = 1;
            signed int return_value_setsockopt$9;
            return_value_setsockopt$9=setsockopt(s_ctl, 1, 2, (const void *)&literal$8, (unsigned int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_setsockopt$9 >= 0))
              perror("udp setsockopt error");

            result=bind(s_ctl, ptr->ai_addr, ptr->ai_addrlen);
            if(!(result >= 0))
            {
              close(s_ctl);
              s_ctl = -1;
              perror("udp bind error");
            }

            else
            {
              struct sockaddr_storage *saddr = (struct sockaddr_storage *)&ptr->ai_addr;
              _Bool return_value_is_multicast$11;
              return_value_is_multicast$11=is_multicast(saddr, ptr->ai_addrlen);
              if(!(return_value_is_multicast$11 == (_Bool)0))
              {
                return_value_mcast_connect$10=mcast_connect(s_ctl, (const char *)(void *)0, saddr, ptr->ai_addrlen);
                if(return_value_mcast_connect$10 == (_Bool)0)
                  goto __CPROVER_DUMP_L11;

                close(s_ctl);
                s_ctl = -1;
                perror("mcast connect error");
              }

              else
              {

              __CPROVER_DUMP_L11:
                ;
                break;
              }
            }
          }
        }
        freeaddrinfo(addr);
        free((void *)psz_service);
        return s_ctl;
      }
    }
  }
}

// udp_read
// file udp.h line 29
signed long int udp_read(signed int fd, void *buf, unsigned long int count)
{
  signed long int err;
  signed int *return_value___errno_location$1;
  do
  {

  again:
    ;
    err=recv(fd, buf, count, 0);
    if(err >= 0l)
      goto __CPROVER_DUMP_L7;

    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 4) && !(*return_value___errno_location$1 == 11))
    {
      if(*return_value___errno_location$1 == 111)
        break;

      if(*return_value___errno_location$1 == 107)
        goto __CPROVER_DUMP_L4;

      goto __CPROVER_DUMP_L5;
    }

  }
  while((_Bool)1);
  fprintf(stderr, "remote host refused connection\n");
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L4:
  ;
  fprintf(stderr, "connection not established\n");
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L5:
  ;
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  char *return_value_strerror$3;
  return_value_strerror$3=strerror(*return_value___errno_location$2);
  fprintf(stderr, "recv error: %s\n", return_value_strerror$3);
  return (signed long int)-1;

__CPROVER_DUMP_L6:
  ;

__CPROVER_DUMP_L7:
  ;
  return err;
}

// usage
// file dvbinfo.c line 113
static void usage(void)
{
  printf("Usage: dvbinfo [-h] [-d <debug>] [-f <filename> | -m | -c <bufsize> | [[-u|-t] -a <mcast_interface> -i <ipaddress:port>] -o <outputfile>\n");
  printf("               [-s [bandwidth|table|packet] --summary-file <file> --summary-period <ms>]\n");
  printf("\n");
  printf(" -d | --debug          : debug level (default:none, error, warn, debug)\n");
  printf(" -h | --help           : help information\n");
  printf("\nInputs: \n");
  printf(" -f | --file           : filename\n");
  printf(" -i | --ipadddress     : hostname or ipaddress\n");
  printf(" -a | --miface         : multicast interface to use\n");
  printf(" -t | --tcp            : tcp network transport\n");
  printf(" -u | --udp            : udp network transport\n");
  printf("\nOutputs: \n");
  printf(" -o | --output         : output incoming data to filename\n");
  printf("\nStatistics: \n");
  printf(" -m | --monitor        : monitor mode (run as unix daemon)\n");
  printf(" -s | --summary=[<type>]:write summary for one of the modes (default: bandwidth):\n");
  printf("                         bandwidth = bandwidth per elementary stream\n");
  printf("                         table  = tables and descriptors\n");
  printf("                         packet = decode packets and print structs\n");
  printf(" -j | --summary-file   : file to write summary information to (default: stdout)\n");
  printf(" -p | --summary-period : refresh summary file every n milliseconds (default: 1000ms)\n");
  printf("\nTuning options: \n");
  printf(" -c | --capture buffer size : number of bytes in capture buffer (default: %d bytes)\n", 400 * 1024 * 1024);
  exit(1);
}

